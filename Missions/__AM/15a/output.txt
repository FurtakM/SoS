// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22869 0 0
// InitNature ;
  19: CALL 19535 0 0
// InitArtifact ;
  23: CALL 20152 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7179 0 0
// PrepareRussian ;
  52: CALL 9486 0 0
// PrepareLegion ;
  56: CALL 7746 0 0
// Action ;
  60: CALL 12458 0 0
// MC_Start ( ) ;
  64: CALL 25049 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 46766 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 47845 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 47938 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47103 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 47288 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 47845 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 47938 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47103 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 47288 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 47718 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 46766 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 47845 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 47938 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47103 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 47288 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 47845 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 47938 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 48256 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 48050 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47103 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 47288 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 47669 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 53577 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 53577 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 53577 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 53577 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 53577 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 53577 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 53577 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 53577 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 53577 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 53577 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 53577 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 53577 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 53577 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 53577 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 53577 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 53577 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 53577 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 53577 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 53577 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 53577 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 53577 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 53577 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 53577 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 53577 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 53577 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 53577 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 53577 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 53577 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 53577 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 53577 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 53577 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 53577 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 53577 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 53577 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 53577 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 58417 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 58417 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 58417 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 58417 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 58417 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 58417 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 58417 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 58417 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 58417 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 58417 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 58417 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 58417 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 58417 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 58417 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 58417 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 58417 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 58417 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 58417 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// if Difficulty = 1 then
5149: LD_OWVAR 67
5153: PUSH
5154: LD_INT 1
5156: EQUAL
5157: IFFALSE 5195
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 39
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5193
// RemoveUnit ( i ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 64
5191: GO 5179
5193: POP
5194: POP
// InitHc ;
5195: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5199: LD_INT 387
5201: PPUSH
5202: LD_STRING sigma
5204: PPUSH
5205: CALL_OW 500
// uc_side := 1 ;
5209: LD_ADDR_OWVAR 20
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// uc_nation := 1 ;
5217: LD_ADDR_OWVAR 21
5221: PUSH
5222: LD_INT 1
5224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: LD_INT 22
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 21
5242: PUSH
5243: LD_INT 3
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: PUSH
5259: FOR_IN
5260: IFFALSE 5276
// SetBLevel ( i , 10 ) ;
5262: LD_VAR 0 2
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: CALL_OW 241
5274: GO 5259
5276: POP
5277: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 274
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 7500
5291: PPUSH
5292: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5296: LD_INT 387
5298: PPUSH
5299: CALL_OW 274
5303: PPUSH
5304: LD_INT 2
5306: PPUSH
5307: LD_INT 4000
5309: PPUSH
5310: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5314: LD_INT 387
5316: PPUSH
5317: CALL_OW 274
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 50
5327: PPUSH
5328: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5332: LD_INT 476
5334: PPUSH
5335: CALL_OW 274
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 5500
5345: PPUSH
5346: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5350: LD_INT 476
5352: PPUSH
5353: CALL_OW 274
5357: PPUSH
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 4000
5363: PPUSH
5364: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5368: LD_INT 476
5370: PPUSH
5371: CALL_OW 274
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5386: LD_STRING 12a_PowellKilled
5388: PPUSH
5389: LD_INT 0
5391: PPUSH
5392: CALL_OW 30
5396: IFFALSE 5423
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5398: LD_INT 1
5400: PPUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 10
5406: PPUSH
5407: CALL_OW 380
// Powell := CreateHuman ;
5411: LD_ADDR_EXP 57
5415: PUSH
5416: CALL_OW 44
5420: ST_TO_ADDR
// end else
5421: GO 5436
// Powell := NewCharacter ( Powell ) ;
5423: LD_ADDR_EXP 57
5427: PUSH
5428: LD_STRING Powell
5430: PPUSH
5431: CALL_OW 25
5435: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5436: LD_EXP 57
5440: PPUSH
5441: LD_INT 387
5443: PPUSH
5444: CALL_OW 52
// tmp := [ ] ;
5448: LD_ADDR_VAR 0 7
5452: PUSH
5453: EMPTY
5454: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5455: LD_ADDR_EXP 23
5459: PUSH
5460: LD_STRING Lisa
5462: PPUSH
5463: LD_EXP 1
5467: NOT
5468: PPUSH
5469: LD_STRING 12p_
5471: PPUSH
5472: CALL 53577 0 3
5476: ST_TO_ADDR
// if Lisa then
5477: LD_EXP 23
5481: IFFALSE 5499
// tmp := tmp ^ Lisa ;
5483: LD_ADDR_VAR 0 7
5487: PUSH
5488: LD_VAR 0 7
5492: PUSH
5493: LD_EXP 23
5497: ADD
5498: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5499: LD_ADDR_EXP 24
5503: PUSH
5504: LD_STRING Donaldson
5506: PPUSH
5507: LD_EXP 1
5511: NOT
5512: PPUSH
5513: LD_STRING 12p_
5515: PPUSH
5516: CALL 53577 0 3
5520: ST_TO_ADDR
// if Donaldson then
5521: LD_EXP 24
5525: IFFALSE 5543
// tmp := tmp ^ Donaldson ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_VAR 0 7
5536: PUSH
5537: LD_EXP 24
5541: ADD
5542: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5543: LD_ADDR_EXP 25
5547: PUSH
5548: LD_STRING Bobby
5550: PPUSH
5551: LD_EXP 1
5555: NOT
5556: PPUSH
5557: LD_STRING 12p_
5559: PPUSH
5560: CALL 53577 0 3
5564: ST_TO_ADDR
// if Bobby then
5565: LD_EXP 25
5569: IFFALSE 5587
// tmp := tmp ^ Bobby ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_VAR 0 7
5580: PUSH
5581: LD_EXP 25
5585: ADD
5586: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5587: LD_ADDR_EXP 26
5591: PUSH
5592: LD_STRING Cyrus
5594: PPUSH
5595: LD_EXP 1
5599: NOT
5600: PPUSH
5601: LD_STRING 12p_
5603: PPUSH
5604: CALL 53577 0 3
5608: ST_TO_ADDR
// if Cyrus then
5609: LD_EXP 26
5613: IFFALSE 5631
// tmp := tmp ^ Cyrus ;
5615: LD_ADDR_VAR 0 7
5619: PUSH
5620: LD_VAR 0 7
5624: PUSH
5625: LD_EXP 26
5629: ADD
5630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5631: LD_ADDR_EXP 28
5635: PUSH
5636: LD_STRING Brown
5638: PPUSH
5639: LD_EXP 1
5643: NOT
5644: PPUSH
5645: LD_STRING 12p_
5647: PPUSH
5648: CALL 53577 0 3
5652: ST_TO_ADDR
// if Brown then
5653: LD_EXP 28
5657: IFFALSE 5675
// tmp := tmp ^ Brown ;
5659: LD_ADDR_VAR 0 7
5663: PUSH
5664: LD_VAR 0 7
5668: PUSH
5669: LD_EXP 28
5673: ADD
5674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_STRING Gladstone
5682: PPUSH
5683: LD_EXP 1
5687: NOT
5688: PPUSH
5689: LD_STRING 12p_
5691: PPUSH
5692: CALL 53577 0 3
5696: ST_TO_ADDR
// if Gladstone then
5697: LD_EXP 29
5701: IFFALSE 5719
// tmp := tmp ^ Gladstone ;
5703: LD_ADDR_VAR 0 7
5707: PUSH
5708: LD_VAR 0 7
5712: PUSH
5713: LD_EXP 29
5717: ADD
5718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5719: LD_ADDR_EXP 30
5723: PUSH
5724: LD_STRING Houten
5726: PPUSH
5727: LD_EXP 1
5731: NOT
5732: PPUSH
5733: LD_STRING 12p_
5735: PPUSH
5736: CALL 53577 0 3
5740: ST_TO_ADDR
// if Houten then
5741: LD_EXP 30
5745: IFFALSE 5763
// tmp := tmp ^ Houten ;
5747: LD_ADDR_VAR 0 7
5751: PUSH
5752: LD_VAR 0 7
5756: PUSH
5757: LD_EXP 30
5761: ADD
5762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5763: LD_ADDR_EXP 31
5767: PUSH
5768: LD_STRING Cornel
5770: PPUSH
5771: LD_EXP 1
5775: NOT
5776: PPUSH
5777: LD_STRING 12p_
5779: PPUSH
5780: CALL 53577 0 3
5784: ST_TO_ADDR
// if Cornel then
5785: LD_EXP 31
5789: IFFALSE 5807
// tmp := tmp ^ Cornel ;
5791: LD_ADDR_VAR 0 7
5795: PUSH
5796: LD_VAR 0 7
5800: PUSH
5801: LD_EXP 31
5805: ADD
5806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5807: LD_ADDR_EXP 32
5811: PUSH
5812: LD_STRING Gary
5814: PPUSH
5815: LD_EXP 1
5819: NOT
5820: PPUSH
5821: LD_STRING 12p_
5823: PPUSH
5824: CALL 53577 0 3
5828: ST_TO_ADDR
// if Gary then
5829: LD_EXP 32
5833: IFFALSE 5851
// tmp := tmp ^ Gary ;
5835: LD_ADDR_VAR 0 7
5839: PUSH
5840: LD_VAR 0 7
5844: PUSH
5845: LD_EXP 32
5849: ADD
5850: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5851: LD_ADDR_EXP 34
5855: PUSH
5856: LD_STRING Kikuchi
5858: PPUSH
5859: LD_EXP 1
5863: NOT
5864: PPUSH
5865: LD_STRING 12p_
5867: PPUSH
5868: CALL 53577 0 3
5872: ST_TO_ADDR
// if Kikuchi then
5873: LD_EXP 34
5877: IFFALSE 5895
// tmp := tmp ^ Kikuchi ;
5879: LD_ADDR_VAR 0 7
5883: PUSH
5884: LD_VAR 0 7
5888: PUSH
5889: LD_EXP 34
5893: ADD
5894: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5895: LD_ADDR_VAR 0 7
5899: PUSH
5900: LD_VAR 0 7
5904: PUSH
5905: LD_STRING 12p_others
5907: PPUSH
5908: CALL_OW 31
5912: UNION
5913: ST_TO_ADDR
// InitHc_All ( ) ;
5914: CALL_OW 584
// if tmp < 36 then
5918: LD_VAR 0 7
5922: PUSH
5923: LD_INT 36
5925: LESS
5926: IFFALSE 5993
// for i = 1 to 36 - tmp do
5928: LD_ADDR_VAR 0 2
5932: PUSH
5933: DOUBLE
5934: LD_INT 1
5936: DEC
5937: ST_TO_ADDR
5938: LD_INT 36
5940: PUSH
5941: LD_VAR 0 7
5945: MINUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 5991
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 2
5957: PUSH
5958: LD_INT 4
5960: MOD
5961: PUSH
5962: LD_INT 1
5964: PLUS
5965: PPUSH
5966: LD_INT 10
5968: PPUSH
5969: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PUSH
5983: CALL_OW 44
5987: ADD
5988: ST_TO_ADDR
// end ;
5989: GO 5947
5991: POP
5992: POP
// p := 0 ;
5993: LD_ADDR_VAR 0 6
5997: PUSH
5998: LD_INT 0
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 7
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6064
// begin p := Inc ( p ) ;
6014: LD_ADDR_VAR 0 6
6018: PUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: CALL 92629 0 1
6028: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
6029: LD_VAR 0 2
6033: PPUSH
6034: LD_INT 62
6036: PPUSH
6037: LD_INT 93
6039: PPUSH
6040: LD_INT 9
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 50
// if p > 36 then
6050: LD_VAR 0 6
6054: PUSH
6055: LD_INT 36
6057: GREATER
6058: IFFALSE 6062
// break ;
6060: GO 6064
// end ;
6062: GO 6011
6064: POP
6065: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6066: LD_ADDR_EXP 80
6070: PUSH
6071: LD_EXP 80
6075: PPUSH
6076: LD_INT 4
6078: PPUSH
6079: LD_INT 22
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PPUSH
6089: CALL_OW 69
6093: PUSH
6094: LD_EXP 57
6098: DIFF
6099: PPUSH
6100: CALL_OW 1
6104: ST_TO_ADDR
// uc_side := 0 ;
6105: LD_ADDR_OWVAR 20
6109: PUSH
6110: LD_INT 0
6112: ST_TO_ADDR
// uc_nation := 0 ;
6113: LD_ADDR_OWVAR 21
6117: PUSH
6118: LD_INT 0
6120: ST_TO_ADDR
// for i = 1 to 4 do
6121: LD_ADDR_VAR 0 2
6125: PUSH
6126: DOUBLE
6127: LD_INT 1
6129: DEC
6130: ST_TO_ADDR
6131: LD_INT 4
6133: PUSH
6134: FOR_TO
6135: IFFALSE 6166
// begin InitHc ;
6137: CALL_OW 19
// hc_class := class_apeman ;
6141: LD_ADDR_OWVAR 28
6145: PUSH
6146: LD_INT 12
6148: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6149: CALL_OW 44
6153: PPUSH
6154: LD_INT 11
6156: PPUSH
6157: LD_INT 0
6159: PPUSH
6160: CALL_OW 49
// end ;
6164: GO 6134
6166: POP
6167: POP
// end ;
6168: LD_VAR 0 1
6172: RET
// every 6 6$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6173: LD_EXP 4
6177: NOT
6178: IFFALSE 7101
6180: GO 6182
6182: DISABLE
6183: LD_INT 0
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin enable ;
6189: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6190: LD_INT 22
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 30
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 7101
// if Prob ( 40 ) then
6234: LD_INT 40
6236: PPUSH
6237: CALL_OW 13
6241: IFFALSE 6368
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6243: LD_INT 4
6245: PPUSH
6246: LD_INT 5
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: LD_INT 2
6254: PUSH
6255: LD_INT 7
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: LD_INT 2
6272: PUSH
6273: LD_INT 7
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 5
6284: PUSH
6285: LD_INT 1
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 7
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 2
6308: PUSH
6309: LD_INT 6
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 5
6320: PUSH
6321: LD_INT 1
6323: PUSH
6324: LD_INT 2
6326: PUSH
6327: LD_INT 6
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 5
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 6
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL 47151 0 2
// end else
6366: GO 6491
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 5
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 2
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 5
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 2
6397: PUSH
6398: LD_INT 9
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 9
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 5
6427: PUSH
6428: LD_INT 1
6430: PUSH
6431: LD_INT 2
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: PUSH
6461: LD_INT 5
6463: PUSH
6464: LD_INT 1
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 6
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PPUSH
6487: CALL 47151 0 2
// end ; p := 0 ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 0
6498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// p := Inc ( p ) ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 92629 0 1
6520: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6521: LD_INT 4
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL 48569 0 2
6531: PUSH
6532: LD_INT 6
6534: GREATEREQUAL
6535: PUSH
6536: LD_VAR 0 4
6540: PUSH
6541: LD_INT 100
6543: GREATER
6544: OR
6545: IFFALSE 6499
// wait ( 0 0$30 ) ;
6547: LD_INT 1050
6549: PPUSH
6550: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6554: LD_ADDR_VAR 0 2
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_INT 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 21
6571: PUSH
6572: LD_INT 2
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: PUSH
6579: LD_INT 3
6581: PUSH
6582: LD_INT 34
6584: PUSH
6585: LD_INT 8
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 3
6598: PUSH
6599: LD_INT 34
6601: PUSH
6602: LD_INT 12
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: LD_INT 3
6615: PUSH
6616: LD_INT 34
6618: PUSH
6619: LD_INT 13
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: PPUSH
6637: CALL_OW 69
6641: PUSH
6642: LD_EXP 102
6646: PUSH
6647: LD_INT 4
6649: ARRAY
6650: DIFF
6651: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6652: LD_ADDR_EXP 99
6656: PUSH
6657: LD_EXP 99
6661: PPUSH
6662: LD_INT 4
6664: PPUSH
6665: LD_EXP 99
6669: PUSH
6670: LD_INT 4
6672: ARRAY
6673: PUSH
6674: LD_VAR 0 2
6678: DIFF
6679: PPUSH
6680: CALL_OW 1
6684: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_INT 0
6692: PPUSH
6693: LD_INT 2
6695: PPUSH
6696: CALL_OW 12
6700: ST_TO_ADDR
// p := 0 ;
6701: LD_ADDR_VAR 0 4
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
// if target then
6709: LD_VAR 0 3
6713: IFFALSE 6866
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6715: LD_ADDR_VAR 0 2
6719: PUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: LD_INT 24
6727: PUSH
6728: LD_INT 250
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 72
6739: ST_TO_ADDR
// for i in tmp do
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_VAR 0 2
6749: PUSH
6750: FOR_IN
6751: IFFALSE 6791
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6753: LD_VAR 0 1
6757: PPUSH
6758: LD_INT 114
6760: PPUSH
6761: LD_INT 108
6763: PPUSH
6764: CALL_OW 297
6768: PUSH
6769: LD_INT 9
6771: GREATER
6772: IFFALSE 6789
// ComMoveXY ( i , 114 , 108 ) ;
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_INT 114
6781: PPUSH
6782: LD_INT 108
6784: PPUSH
6785: CALL_OW 111
6789: GO 6750
6791: POP
6792: POP
// wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// p := Inc ( p ) ;
6800: LD_ADDR_VAR 0 4
6804: PUSH
6805: LD_VAR 0 4
6809: PPUSH
6810: CALL 92629 0 1
6814: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6815: LD_VAR 0 2
6819: PPUSH
6820: LD_INT 92
6822: PUSH
6823: LD_INT 114
6825: PUSH
6826: LD_INT 108
6828: PUSH
6829: LD_INT 9
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PPUSH
6838: CALL_OW 72
6842: PUSH
6843: LD_VAR 0 2
6847: PUSH
6848: LD_INT 1
6850: MINUS
6851: GREATEREQUAL
6852: PUSH
6853: LD_VAR 0 4
6857: PUSH
6858: LD_INT 30
6860: GREATER
6861: OR
6862: IFFALSE 6715
// end else
6864: GO 7015
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6866: LD_ADDR_VAR 0 2
6870: PUSH
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 24
6878: PUSH
6879: LD_INT 250
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PPUSH
6886: CALL_OW 72
6890: ST_TO_ADDR
// for i in tmp do
6891: LD_ADDR_VAR 0 1
6895: PUSH
6896: LD_VAR 0 2
6900: PUSH
6901: FOR_IN
6902: IFFALSE 6942
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 129
6911: PPUSH
6912: LD_INT 139
6914: PPUSH
6915: CALL_OW 297
6919: PUSH
6920: LD_INT 9
6922: GREATER
6923: IFFALSE 6940
// ComMoveXY ( i , 129 , 139 ) ;
6925: LD_VAR 0 1
6929: PPUSH
6930: LD_INT 129
6932: PPUSH
6933: LD_INT 139
6935: PPUSH
6936: CALL_OW 111
6940: GO 6901
6942: POP
6943: POP
// wait ( 0 0$1 ) ;
6944: LD_INT 35
6946: PPUSH
6947: CALL_OW 67
// p := Inc ( p ) ;
6951: LD_ADDR_VAR 0 4
6955: PUSH
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 92629 0 1
6965: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6966: LD_VAR 0 2
6970: PPUSH
6971: LD_INT 92
6973: PUSH
6974: LD_INT 129
6976: PUSH
6977: LD_INT 139
6979: PUSH
6980: LD_INT 9
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: LIST
6987: LIST
6988: PPUSH
6989: CALL_OW 72
6993: PUSH
6994: LD_VAR 0 2
6998: PUSH
6999: LD_INT 1
7001: MINUS
7002: GREATEREQUAL
7003: PUSH
7004: LD_VAR 0 4
7008: PUSH
7009: LD_INT 30
7011: GREATER
7012: OR
7013: IFFALSE 6866
// end ; repeat wait ( 0 0$1 ) ;
7015: LD_INT 35
7017: PPUSH
7018: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_VAR 0 2
7031: PPUSH
7032: LD_INT 50
7034: PUSH
7035: EMPTY
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: ST_TO_ADDR
// for i in tmp do
7043: LD_ADDR_VAR 0 1
7047: PUSH
7048: LD_VAR 0 2
7052: PUSH
7053: FOR_IN
7054: IFFALSE 7092
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7056: LD_VAR 0 1
7060: PPUSH
7061: LD_INT 81
7063: PUSH
7064: LD_INT 1
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PPUSH
7071: CALL_OW 69
7075: PPUSH
7076: LD_VAR 0 1
7080: PPUSH
7081: CALL_OW 74
7085: PPUSH
7086: CALL_OW 115
7090: GO 7053
7092: POP
7093: POP
// until not tmp ;
7094: LD_VAR 0 2
7098: NOT
7099: IFFALSE 7015
// end ;
7101: PPOPN 4
7103: END
// every 30 30$00 trigger not americanDestroyed do
7104: LD_EXP 4
7108: NOT
7109: IFFALSE 7178
7111: GO 7113
7113: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7114: LD_INT 63000
7116: PUSH
7117: LD_INT 42000
7119: PUSH
7120: LD_INT 31500
7122: PUSH
7123: LD_INT 21000
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: PUSH
7132: LD_OWVAR 67
7136: ARRAY
7137: PPUSH
7138: CALL_OW 67
// if americanDestroyed then
7142: LD_EXP 4
7146: IFFALSE 7150
// exit ;
7148: GO 7178
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7150: LD_INT 4
7152: PPUSH
7153: LD_INT 5
7155: PUSH
7156: LD_INT 3
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: LD_INT 8
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: PPUSH
7174: CALL 47151 0 2
// end ; end_of_file
7178: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7179: LD_INT 0
7181: PPUSH
7182: PPUSH
7183: PPUSH
7184: PPUSH
7185: PPUSH
// side := 2 ;
7186: LD_ADDR_VAR 0 5
7190: PUSH
7191: LD_INT 2
7193: ST_TO_ADDR
// InitHc ;
7194: CALL_OW 19
// uc_side := side ;
7198: LD_ADDR_OWVAR 20
7202: PUSH
7203: LD_VAR 0 5
7207: ST_TO_ADDR
// uc_nation := 2 ;
7208: LD_ADDR_OWVAR 21
7212: PUSH
7213: LD_INT 2
7215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7216: LD_ADDR_VAR 0 2
7220: PUSH
7221: LD_INT 22
7223: PUSH
7224: LD_INT 2
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 21
7233: PUSH
7234: LD_INT 3
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 69
7249: PUSH
7250: FOR_IN
7251: IFFALSE 7267
// SetBLevel ( i , 10 ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 10
7260: PPUSH
7261: CALL_OW 241
7265: GO 7250
7267: POP
7268: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7269: LD_ADDR_VAR 0 4
7273: PUSH
7274: LD_INT 22
7276: PUSH
7277: LD_VAR 0 5
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: PUSH
7286: LD_INT 30
7288: PUSH
7289: LD_INT 32
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 58
7298: PUSH
7299: EMPTY
7300: LIST
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: LIST
7306: PPUSH
7307: CALL_OW 69
7311: ST_TO_ADDR
// for i = 1 to 10 do
7312: LD_ADDR_VAR 0 2
7316: PUSH
7317: DOUBLE
7318: LD_INT 1
7320: DEC
7321: ST_TO_ADDR
7322: LD_INT 10
7324: PUSH
7325: FOR_TO
7326: IFFALSE 7398
// begin uc_nation := nation_nature ;
7328: LD_ADDR_OWVAR 21
7332: PUSH
7333: LD_INT 0
7335: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7336: LD_ADDR_OWVAR 28
7340: PUSH
7341: LD_INT 15
7343: ST_TO_ADDR
// hc_gallery :=  ;
7344: LD_ADDR_OWVAR 33
7348: PUSH
7349: LD_STRING 
7351: ST_TO_ADDR
// hc_name :=  ;
7352: LD_ADDR_OWVAR 26
7356: PUSH
7357: LD_STRING 
7359: ST_TO_ADDR
// un := CreateHuman ;
7360: LD_ADDR_VAR 0 3
7364: PUSH
7365: CALL_OW 44
7369: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7370: LD_VAR 0 3
7374: PPUSH
7375: LD_VAR 0 4
7379: PUSH
7380: LD_VAR 0 4
7384: PUSH
7385: LD_VAR 0 2
7389: MINUS
7390: ARRAY
7391: PPUSH
7392: CALL_OW 52
// end ;
7396: GO 7325
7398: POP
7399: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7400: LD_INT 503
7402: PPUSH
7403: LD_INT 27
7405: PPUSH
7406: LD_STRING 
7408: PPUSH
7409: LD_INT 8
7411: PUSH
7412: LD_INT 9
7414: PUSH
7415: LD_INT 10
7417: PUSH
7418: LD_INT 10
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: PUSH
7427: LD_OWVAR 67
7431: ARRAY
7432: PPUSH
7433: LD_INT 3000
7435: PUSH
7436: LD_INT 500
7438: PUSH
7439: LD_INT 150
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: LD_INT 16
7449: PUSH
7450: LD_INT 6
7452: PUSH
7453: LD_INT 6
7455: PUSH
7456: LD_INT 6
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL 62238 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7469: LD_ADDR_EXP 80
7473: PUSH
7474: LD_EXP 80
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_VAR 0 5
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 23
7496: PUSH
7497: LD_INT 2
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: LD_INT 3
7506: PUSH
7507: LD_INT 21
7509: PUSH
7510: LD_INT 2
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: LIST
7525: PPUSH
7526: CALL_OW 69
7530: PPUSH
7531: CALL_OW 1
7535: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7536: LD_INT 216
7538: PPUSH
7539: LD_INT 228
7541: PPUSH
7542: LD_INT 2
7544: PPUSH
7545: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7549: LD_INT 223
7551: PPUSH
7552: LD_INT 241
7554: PPUSH
7555: LD_INT 2
7557: PPUSH
7558: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7562: LD_INT 216
7564: PPUSH
7565: LD_INT 217
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7575: LD_INT 233
7577: PPUSH
7578: LD_INT 257
7580: PPUSH
7581: LD_INT 2
7583: PPUSH
7584: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7588: LD_INT 230
7590: PPUSH
7591: LD_INT 199
7593: PPUSH
7594: LD_INT 2
7596: PPUSH
7597: CALL_OW 244
// end ;
7601: LD_VAR 0 1
7605: RET
// export Omar ; export function PrepareOmarAli ; begin
7606: LD_INT 0
7608: PPUSH
// uc_side := 5 ;
7609: LD_ADDR_OWVAR 20
7613: PUSH
7614: LD_INT 5
7616: ST_TO_ADDR
// uc_nation := 2 ;
7617: LD_ADDR_OWVAR 21
7621: PUSH
7622: LD_INT 2
7624: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7625: LD_ADDR_EXP 58
7629: PUSH
7630: LD_STRING Omar
7632: PPUSH
7633: CALL_OW 25
7637: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7638: LD_EXP 58
7642: PPUSH
7643: LD_INT 330
7645: PPUSH
7646: LD_INT 244
7648: PPUSH
7649: LD_INT 0
7651: PPUSH
7652: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7656: LD_EXP 58
7660: PPUSH
7661: LD_INT 252
7663: PPUSH
7664: LD_INT 220
7666: PPUSH
7667: CALL_OW 111
// end ;
7671: LD_VAR 0 1
7675: RET
// export function PrepareOmarAli2 ; begin
7676: LD_INT 0
7678: PPUSH
// uc_side := 5 ;
7679: LD_ADDR_OWVAR 20
7683: PUSH
7684: LD_INT 5
7686: ST_TO_ADDR
// uc_nation := 2 ;
7687: LD_ADDR_OWVAR 21
7691: PUSH
7692: LD_INT 2
7694: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7695: LD_ADDR_EXP 58
7699: PUSH
7700: LD_STRING Omar
7702: PPUSH
7703: CALL_OW 25
7707: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7708: LD_EXP 58
7712: PPUSH
7713: LD_INT 289
7715: PPUSH
7716: LD_INT 164
7718: PPUSH
7719: LD_INT 0
7721: PPUSH
7722: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7726: LD_EXP 58
7730: PPUSH
7731: LD_INT 254
7733: PPUSH
7734: LD_INT 166
7736: PPUSH
7737: CALL_OW 111
// end ; end_of_file
7741: LD_VAR 0 1
7745: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7746: LD_INT 0
7748: PPUSH
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
// side := 8 ;
7753: LD_ADDR_VAR 0 3
7757: PUSH
7758: LD_INT 8
7760: ST_TO_ADDR
// InitHc ;
7761: CALL_OW 19
// uc_side := side ;
7765: LD_ADDR_OWVAR 20
7769: PUSH
7770: LD_VAR 0 3
7774: ST_TO_ADDR
// uc_nation := 2 ;
7775: LD_ADDR_OWVAR 21
7779: PUSH
7780: LD_INT 2
7782: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7783: LD_ADDR_VAR 0 2
7787: PUSH
7788: LD_INT 22
7790: PUSH
7791: LD_VAR 0 3
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 21
7802: PUSH
7803: LD_INT 3
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PPUSH
7814: CALL_OW 69
7818: PUSH
7819: FOR_IN
7820: IFFALSE 7836
// SetBLevel ( i , 10 ) ;
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_INT 10
7829: PPUSH
7830: CALL_OW 241
7834: GO 7819
7836: POP
7837: POP
// Schulz := NewCharacter ( Schulz ) ;
7838: LD_ADDR_EXP 59
7842: PUSH
7843: LD_STRING Schulz
7845: PPUSH
7846: CALL_OW 25
7850: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7851: LD_ADDR_EXP 61
7855: PUSH
7856: LD_STRING Kaia
7858: PPUSH
7859: CALL_OW 25
7863: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7864: LD_EXP 61
7868: PPUSH
7869: LD_INT 324
7871: PPUSH
7872: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7876: LD_ADDR_EXP 60
7880: PUSH
7881: LD_STRING Kozlov
7883: PPUSH
7884: LD_INT 0
7886: PPUSH
7887: LD_STRING 
7889: PPUSH
7890: CALL 53577 0 3
7894: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7895: LD_EXP 60
7899: PPUSH
7900: LD_INT 22
7902: PUSH
7903: LD_INT 8
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 23
7912: PUSH
7913: LD_INT 3
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 8
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: LIST
7934: PPUSH
7935: CALL_OW 69
7939: PUSH
7940: LD_INT 1
7942: ARRAY
7943: PPUSH
7944: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7948: LD_EXP 60
7952: PPUSH
7953: LD_INT 3
7955: PPUSH
7956: LD_INT 10
7958: PPUSH
7959: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7963: LD_ADDR_VAR 0 5
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_VAR 0 3
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 30
7982: PUSH
7983: LD_INT 32
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: LD_INT 58
7992: PUSH
7993: EMPTY
7994: LIST
7995: PUSH
7996: EMPTY
7997: LIST
7998: LIST
7999: LIST
8000: PPUSH
8001: CALL_OW 69
8005: ST_TO_ADDR
// for i = 1 to 10 do
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: DOUBLE
8012: LD_INT 1
8014: DEC
8015: ST_TO_ADDR
8016: LD_INT 10
8018: PUSH
8019: FOR_TO
8020: IFFALSE 8092
// begin uc_nation := nation_nature ;
8022: LD_ADDR_OWVAR 21
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
8030: LD_ADDR_OWVAR 28
8034: PUSH
8035: LD_INT 15
8037: ST_TO_ADDR
// hc_gallery :=  ;
8038: LD_ADDR_OWVAR 33
8042: PUSH
8043: LD_STRING 
8045: ST_TO_ADDR
// hc_name :=  ;
8046: LD_ADDR_OWVAR 26
8050: PUSH
8051: LD_STRING 
8053: ST_TO_ADDR
// un := CreateHuman ;
8054: LD_ADDR_VAR 0 4
8058: PUSH
8059: CALL_OW 44
8063: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8064: LD_VAR 0 4
8068: PPUSH
8069: LD_VAR 0 5
8073: PUSH
8074: LD_VAR 0 5
8078: PUSH
8079: LD_VAR 0 2
8083: MINUS
8084: ARRAY
8085: PPUSH
8086: CALL_OW 52
// end ;
8090: GO 8019
8092: POP
8093: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8094: LD_INT 324
8096: PPUSH
8097: LD_INT 3
8099: PPUSH
8100: LD_STRING 
8102: PPUSH
8103: LD_INT 8
8105: PUSH
8106: LD_INT 9
8108: PUSH
8109: LD_INT 10
8111: PUSH
8112: LD_INT 10
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: LD_OWVAR 67
8125: ARRAY
8126: PPUSH
8127: LD_INT 3000
8129: PUSH
8130: LD_INT 500
8132: PUSH
8133: LD_INT 150
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: PPUSH
8141: LD_INT 16
8143: PUSH
8144: LD_INT 6
8146: PUSH
8147: LD_INT 6
8149: PUSH
8150: LD_INT 8
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: PPUSH
8159: CALL 62238 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8163: LD_ADDR_EXP 80
8167: PUSH
8168: LD_EXP 80
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 22
8178: PUSH
8179: LD_VAR 0 3
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 23
8190: PUSH
8191: LD_INT 2
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PUSH
8198: LD_INT 3
8200: PUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: PUSH
8215: EMPTY
8216: LIST
8217: LIST
8218: LIST
8219: PPUSH
8220: CALL_OW 69
8224: PUSH
8225: LD_EXP 59
8229: DIFF
8230: PPUSH
8231: CALL_OW 1
8235: ST_TO_ADDR
// end ;
8236: LD_VAR 0 1
8240: RET
// export function BuildKozlovBomb ; begin
8241: LD_INT 0
8243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8244: LD_INT 332
8246: PPUSH
8247: CALL_OW 302
8251: NOT
8252: PUSH
8253: LD_INT 336
8255: PPUSH
8256: CALL_OW 302
8260: NOT
8261: OR
8262: IFFALSE 8266
// exit ;
8264: GO 8363
// ComChangeProfession ( Kozlov , 4 ) ;
8266: LD_EXP 60
8270: PPUSH
8271: LD_INT 4
8273: PPUSH
8274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8278: LD_INT 336
8280: PPUSH
8281: LD_INT 25
8283: PPUSH
8284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8288: LD_INT 35
8290: PPUSH
8291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8295: LD_INT 25
8297: PPUSH
8298: LD_INT 8
8300: PPUSH
8301: CALL_OW 321
8305: PUSH
8306: LD_INT 2
8308: EQUAL
8309: IFFALSE 8288
// ComExitBuilding ( Kozlov ) ;
8311: LD_EXP 60
8315: PPUSH
8316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8320: LD_EXP 60
8324: PPUSH
8325: LD_INT 332
8327: PPUSH
8328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8332: LD_EXP 60
8336: PPUSH
8337: LD_INT 3
8339: PPUSH
8340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8344: LD_INT 332
8346: PPUSH
8347: LD_INT 23
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 1
8355: PPUSH
8356: LD_INT 48
8358: PPUSH
8359: CALL_OW 125
// end ;
8363: LD_VAR 0 1
8367: RET
// every 5 5$30 + 4 4$00 trigger not legionDestroyed do var i , tmp , target , p ;
8368: LD_EXP 3
8372: NOT
8373: IFFALSE 9380
8375: GO 8377
8377: DISABLE
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
// begin enable ;
8384: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8385: LD_INT 22
8387: PUSH
8388: LD_INT 8
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: LD_INT 23
8397: PUSH
8398: LD_INT 2
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 30
8407: PUSH
8408: LD_INT 3
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: NOT
8425: IFFALSE 8429
// exit ;
8427: GO 9380
// if Prob ( 40 ) then
8429: LD_INT 40
8431: PPUSH
8432: CALL_OW 13
8436: IFFALSE 8563
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8438: LD_INT 3
8440: PPUSH
8441: LD_INT 14
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: LD_INT 2
8449: PUSH
8450: LD_INT 28
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: PUSH
8459: LD_INT 14
8461: PUSH
8462: LD_INT 1
8464: PUSH
8465: LD_INT 2
8467: PUSH
8468: LD_INT 28
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 14
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: LD_INT 2
8485: PUSH
8486: LD_INT 28
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 14
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: LD_INT 2
8503: PUSH
8504: LD_INT 28
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: LIST
8512: PUSH
8513: LD_INT 14
8515: PUSH
8516: LD_INT 1
8518: PUSH
8519: LD_INT 2
8521: PUSH
8522: LD_INT 28
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: LD_INT 14
8533: PUSH
8534: LD_INT 1
8536: PUSH
8537: LD_INT 2
8539: PUSH
8540: LD_INT 26
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PPUSH
8557: CALL 47151 0 2
// end else
8561: GO 8770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8563: LD_INT 3
8565: PPUSH
8566: LD_INT 14
8568: PUSH
8569: LD_INT 1
8571: PUSH
8572: LD_INT 2
8574: PUSH
8575: LD_INT 27
8577: PUSH
8578: LD_INT 26
8580: PUSH
8581: LD_INT 26
8583: PUSH
8584: LD_INT 28
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: PUSH
8605: LD_INT 14
8607: PUSH
8608: LD_INT 1
8610: PUSH
8611: LD_INT 2
8613: PUSH
8614: LD_INT 27
8616: PUSH
8617: LD_INT 26
8619: PUSH
8620: LD_INT 26
8622: PUSH
8623: LD_INT 26
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_INT 14
8646: PUSH
8647: LD_INT 1
8649: PUSH
8650: LD_INT 2
8652: PUSH
8653: LD_INT 26
8655: PUSH
8656: LD_INT 26
8658: PUSH
8659: LD_INT 29
8661: PUSH
8662: LD_INT 29
8664: PUSH
8665: EMPTY
8666: LIST
8667: LIST
8668: LIST
8669: LIST
8670: PUSH
8671: LD_OWVAR 67
8675: ARRAY
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 13
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: LD_INT 2
8691: PUSH
8692: LD_INT 26
8694: PUSH
8695: LD_INT 29
8697: PUSH
8698: LD_INT 29
8700: PUSH
8701: LD_INT 29
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: LIST
8708: LIST
8709: PUSH
8710: LD_OWVAR 67
8714: ARRAY
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 13
8724: PUSH
8725: LD_INT 1
8727: PUSH
8728: LD_INT 2
8730: PUSH
8731: LD_INT 29
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 14
8742: PUSH
8743: LD_INT 1
8745: PUSH
8746: LD_INT 2
8748: PUSH
8749: LD_INT 26
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PPUSH
8766: CALL 47151 0 2
// end ; p := 0 ;
8770: LD_ADDR_VAR 0 4
8774: PUSH
8775: LD_INT 0
8777: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8778: LD_INT 35
8780: PPUSH
8781: CALL_OW 67
// p := Inc ( p ) ;
8785: LD_ADDR_VAR 0 4
8789: PUSH
8790: LD_VAR 0 4
8794: PPUSH
8795: CALL 92629 0 1
8799: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8800: LD_INT 3
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL 48569 0 2
8810: PUSH
8811: LD_INT 6
8813: GREATEREQUAL
8814: PUSH
8815: LD_VAR 0 4
8819: PUSH
8820: LD_INT 100
8822: GREATER
8823: OR
8824: IFFALSE 8778
// wait ( 0 0$30 ) ;
8826: LD_INT 1050
8828: PPUSH
8829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8833: LD_ADDR_VAR 0 2
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_INT 8
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 21
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 3
8860: PUSH
8861: LD_INT 34
8863: PUSH
8864: LD_INT 31
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 3
8877: PUSH
8878: LD_INT 34
8880: PUSH
8881: LD_INT 32
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 34
8897: PUSH
8898: LD_INT 88
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: PPUSH
8916: CALL_OW 69
8920: PUSH
8921: LD_EXP 102
8925: PUSH
8926: LD_INT 3
8928: ARRAY
8929: DIFF
8930: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8931: LD_ADDR_EXP 99
8935: PUSH
8936: LD_EXP 99
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: LD_EXP 99
8948: PUSH
8949: LD_INT 3
8951: ARRAY
8952: PUSH
8953: LD_VAR 0 2
8957: DIFF
8958: PPUSH
8959: CALL_OW 1
8963: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8964: LD_ADDR_VAR 0 3
8968: PUSH
8969: LD_INT 0
8971: PPUSH
8972: LD_INT 2
8974: PPUSH
8975: CALL_OW 12
8979: ST_TO_ADDR
// p := 0 ;
8980: LD_ADDR_VAR 0 4
8984: PUSH
8985: LD_INT 0
8987: ST_TO_ADDR
// if target then
8988: LD_VAR 0 3
8992: IFFALSE 9145
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8994: LD_ADDR_VAR 0 2
8998: PUSH
8999: LD_VAR 0 2
9003: PPUSH
9004: LD_INT 24
9006: PUSH
9007: LD_INT 250
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 72
9018: ST_TO_ADDR
// for i in tmp do
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: FOR_IN
9030: IFFALSE 9070
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
9032: LD_VAR 0 1
9036: PPUSH
9037: LD_INT 89
9039: PPUSH
9040: LD_INT 71
9042: PPUSH
9043: CALL_OW 297
9047: PUSH
9048: LD_INT 9
9050: GREATER
9051: IFFALSE 9068
// ComMoveXY ( i , 89 , 71 ) ;
9053: LD_VAR 0 1
9057: PPUSH
9058: LD_INT 89
9060: PPUSH
9061: LD_INT 71
9063: PPUSH
9064: CALL_OW 111
9068: GO 9029
9070: POP
9071: POP
// wait ( 0 0$1 ) ;
9072: LD_INT 35
9074: PPUSH
9075: CALL_OW 67
// p := Inc ( p ) ;
9079: LD_ADDR_VAR 0 4
9083: PUSH
9084: LD_VAR 0 4
9088: PPUSH
9089: CALL 92629 0 1
9093: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9094: LD_VAR 0 2
9098: PPUSH
9099: LD_INT 92
9101: PUSH
9102: LD_INT 89
9104: PUSH
9105: LD_INT 71
9107: PUSH
9108: LD_INT 9
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 72
9121: PUSH
9122: LD_VAR 0 2
9126: PUSH
9127: LD_INT 1
9129: MINUS
9130: GREATEREQUAL
9131: PUSH
9132: LD_VAR 0 4
9136: PUSH
9137: LD_INT 30
9139: GREATER
9140: OR
9141: IFFALSE 8994
// end else
9143: GO 9294
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9145: LD_ADDR_VAR 0 2
9149: PUSH
9150: LD_VAR 0 2
9154: PPUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 250
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PPUSH
9165: CALL_OW 72
9169: ST_TO_ADDR
// for i in tmp do
9170: LD_ADDR_VAR 0 1
9174: PUSH
9175: LD_VAR 0 2
9179: PUSH
9180: FOR_IN
9181: IFFALSE 9221
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9183: LD_VAR 0 1
9187: PPUSH
9188: LD_INT 147
9190: PPUSH
9191: LD_INT 4
9193: PPUSH
9194: CALL_OW 297
9198: PUSH
9199: LD_INT 9
9201: GREATER
9202: IFFALSE 9219
// ComMoveXY ( i , 147 , 4 ) ;
9204: LD_VAR 0 1
9208: PPUSH
9209: LD_INT 147
9211: PPUSH
9212: LD_INT 4
9214: PPUSH
9215: CALL_OW 111
9219: GO 9180
9221: POP
9222: POP
// wait ( 0 0$1 ) ;
9223: LD_INT 35
9225: PPUSH
9226: CALL_OW 67
// p := Inc ( p ) ;
9230: LD_ADDR_VAR 0 4
9234: PUSH
9235: LD_VAR 0 4
9239: PPUSH
9240: CALL 92629 0 1
9244: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9245: LD_VAR 0 2
9249: PPUSH
9250: LD_INT 92
9252: PUSH
9253: LD_INT 147
9255: PUSH
9256: LD_INT 4
9258: PUSH
9259: LD_INT 9
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: LIST
9266: LIST
9267: PPUSH
9268: CALL_OW 72
9272: PUSH
9273: LD_VAR 0 2
9277: PUSH
9278: LD_INT 1
9280: MINUS
9281: GREATEREQUAL
9282: PUSH
9283: LD_VAR 0 4
9287: PUSH
9288: LD_INT 30
9290: GREATER
9291: OR
9292: IFFALSE 9145
// end ; repeat wait ( 0 0$1 ) ;
9294: LD_INT 35
9296: PPUSH
9297: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9301: LD_ADDR_VAR 0 2
9305: PUSH
9306: LD_VAR 0 2
9310: PPUSH
9311: LD_INT 50
9313: PUSH
9314: EMPTY
9315: LIST
9316: PPUSH
9317: CALL_OW 72
9321: ST_TO_ADDR
// for i in tmp do
9322: LD_ADDR_VAR 0 1
9326: PUSH
9327: LD_VAR 0 2
9331: PUSH
9332: FOR_IN
9333: IFFALSE 9371
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9335: LD_VAR 0 1
9339: PPUSH
9340: LD_INT 81
9342: PUSH
9343: LD_INT 8
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 69
9354: PPUSH
9355: LD_VAR 0 1
9359: PPUSH
9360: CALL_OW 74
9364: PPUSH
9365: CALL_OW 115
9369: GO 9332
9371: POP
9372: POP
// until not tmp ;
9373: LD_VAR 0 2
9377: NOT
9378: IFFALSE 9294
// end ;
9380: PPOPN 4
9382: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9383: LD_EXP 60
9387: PPUSH
9388: CALL_OW 302
9392: PUSH
9393: LD_EXP 3
9397: NOT
9398: AND
9399: IFFALSE 9408
9401: GO 9403
9403: DISABLE
// BuildKozlovBomb ;
9404: CALL 8241 0 0
9408: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9409: LD_INT 22
9411: PUSH
9412: LD_INT 8
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 34
9421: PUSH
9422: LD_INT 48
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 69
9437: IFFALSE 9485
9439: GO 9441
9441: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9442: LD_INT 22
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 34
9454: PUSH
9455: LD_INT 48
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: PPUSH
9466: CALL_OW 69
9470: PUSH
9471: LD_INT 1
9473: ARRAY
9474: PPUSH
9475: LD_INT 173
9477: PPUSH
9478: LD_INT 96
9480: PPUSH
9481: CALL_OW 116
// end ; end_of_file
9485: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9486: LD_INT 0
9488: PPUSH
9489: PPUSH
9490: PPUSH
9491: PPUSH
9492: PPUSH
9493: PPUSH
9494: PPUSH
9495: PPUSH
9496: PPUSH
9497: PPUSH
// side := 3 ;
9498: LD_ADDR_VAR 0 6
9502: PUSH
9503: LD_INT 3
9505: ST_TO_ADDR
// InitHc ;
9506: CALL_OW 19
// uc_side := side ;
9510: LD_ADDR_OWVAR 20
9514: PUSH
9515: LD_VAR 0 6
9519: ST_TO_ADDR
// uc_nation := 3 ;
9520: LD_ADDR_OWVAR 21
9524: PUSH
9525: LD_INT 3
9527: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PUSH
9545: LD_INT 21
9547: PUSH
9548: LD_INT 3
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: PUSH
9564: FOR_IN
9565: IFFALSE 9581
// SetBLevel ( i , 10 ) ;
9567: LD_VAR 0 2
9571: PPUSH
9572: LD_INT 10
9574: PPUSH
9575: CALL_OW 241
9579: GO 9564
9581: POP
9582: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9583: LD_ADDR_VAR 0 10
9587: PUSH
9588: LD_INT 22
9590: PUSH
9591: LD_VAR 0 6
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 30
9602: PUSH
9603: LD_INT 34
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PPUSH
9614: CALL_OW 69
9618: ST_TO_ADDR
// if teleport then
9619: LD_VAR 0 10
9623: IFFALSE 9644
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9625: LD_VAR 0 10
9629: PUSH
9630: LD_INT 1
9632: ARRAY
9633: PPUSH
9634: LD_INT 123
9636: PPUSH
9637: LD_INT 122
9639: PPUSH
9640: CALL_OW 243
// hc_importance := 0 ;
9644: LD_ADDR_OWVAR 32
9648: PUSH
9649: LD_INT 0
9651: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9652: LD_ADDR_EXP 62
9656: PUSH
9657: LD_STRING Platonov
9659: PPUSH
9660: CALL_OW 25
9664: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9665: LD_ADDR_EXP 63
9669: PUSH
9670: LD_STRING Yakotich
9672: PPUSH
9673: LD_EXP 1
9677: NOT
9678: PPUSH
9679: LD_STRING 09_
9681: PPUSH
9682: CALL 53577 0 3
9686: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9687: LD_ADDR_EXP 64
9691: PUSH
9692: LD_STRING Gleb
9694: PPUSH
9695: CALL_OW 25
9699: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9700: LD_STRING 03_Cornel
9702: PPUSH
9703: CALL_OW 28
9707: IFFALSE 9755
// begin Bierezov := NewCharacter ( Mikhail ) ;
9709: LD_ADDR_EXP 65
9713: PUSH
9714: LD_STRING Mikhail
9716: PPUSH
9717: CALL_OW 25
9721: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9722: LD_EXP 65
9726: PPUSH
9727: LD_INT 197
9729: PPUSH
9730: LD_INT 111
9732: PPUSH
9733: LD_INT 9
9735: PPUSH
9736: LD_INT 0
9738: PPUSH
9739: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9743: LD_EXP 65
9747: PPUSH
9748: LD_INT 3
9750: PPUSH
9751: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9755: LD_EXP 62
9759: PPUSH
9760: LD_INT 126
9762: PPUSH
9763: CALL_OW 52
// if Yakotich then
9767: LD_EXP 63
9771: IFFALSE 9794
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9773: LD_EXP 63
9777: PPUSH
9778: LD_INT 197
9780: PPUSH
9781: LD_INT 111
9783: PPUSH
9784: LD_INT 9
9786: PPUSH
9787: LD_INT 0
9789: PPUSH
9790: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9794: LD_EXP 64
9798: PPUSH
9799: LD_INT 197
9801: PPUSH
9802: LD_INT 111
9804: PPUSH
9805: LD_INT 9
9807: PPUSH
9808: LD_INT 0
9810: PPUSH
9811: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9815: LD_ADDR_VAR 0 5
9819: PUSH
9820: LD_INT 126
9822: PPUSH
9823: LD_INT 2
9825: PPUSH
9826: LD_STRING zhukov
9828: PPUSH
9829: LD_INT 9
9831: PUSH
9832: LD_INT 10
9834: PUSH
9835: LD_INT 10
9837: PUSH
9838: LD_INT 10
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_OWVAR 67
9851: ARRAY
9852: PPUSH
9853: LD_INT 9000
9855: PUSH
9856: LD_INT 1000
9858: PUSH
9859: LD_INT 300
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: PPUSH
9867: LD_INT 21
9869: PUSH
9870: LD_INT 8
9872: PUSH
9873: LD_INT 13
9875: PUSH
9876: LD_INT 8
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: PPUSH
9885: CALL 62238 0 6
9889: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9890: LD_ADDR_EXP 80
9894: PUSH
9895: LD_EXP 80
9899: PPUSH
9900: LD_INT 2
9902: PPUSH
9903: LD_VAR 0 5
9907: PUSH
9908: LD_EXP 63
9912: PUSH
9913: LD_EXP 64
9917: PUSH
9918: LD_EXP 65
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: LIST
9927: UNION
9928: PPUSH
9929: CALL_OW 1
9933: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9934: LD_ADDR_VAR 0 4
9938: PUSH
9939: LD_INT 267
9941: PPUSH
9942: CALL_OW 274
9946: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9947: LD_VAR 0 4
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 5000
9957: PPUSH
9958: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9962: LD_VAR 0 4
9966: PPUSH
9967: LD_INT 2
9969: PPUSH
9970: LD_INT 200
9972: PPUSH
9973: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9977: LD_VAR 0 4
9981: PPUSH
9982: LD_INT 3
9984: PPUSH
9985: LD_INT 200
9987: PPUSH
9988: CALL_OW 277
// for i := 1 to 6 do
9992: LD_ADDR_VAR 0 2
9996: PUSH
9997: DOUBLE
9998: LD_INT 1
10000: DEC
10001: ST_TO_ADDR
10002: LD_INT 6
10004: PUSH
10005: FOR_TO
10006: IFFALSE 10089
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
10008: LD_INT 0
10010: PPUSH
10011: LD_INT 8
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: LD_INT 10
10019: PUSH
10020: LD_INT 10
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_OWVAR 67
10033: ARRAY
10034: PPUSH
10035: CALL_OW 381
// un := CreateHuman ;
10039: LD_ADDR_VAR 0 8
10043: PUSH
10044: CALL_OW 44
10048: ST_TO_ADDR
// if i mod 2 = 0 then
10049: LD_VAR 0 2
10053: PUSH
10054: LD_INT 2
10056: MOD
10057: PUSH
10058: LD_INT 0
10060: EQUAL
10061: IFFALSE 10075
// SetClass ( un , class_bazooker ) ;
10063: LD_VAR 0 8
10067: PPUSH
10068: LD_INT 9
10070: PPUSH
10071: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10075: LD_VAR 0 8
10079: PPUSH
10080: LD_INT 674
10082: PPUSH
10083: CALL_OW 52
// end ;
10087: GO 10005
10089: POP
10090: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10091: LD_INT 21
10093: PPUSH
10094: LD_INT 3
10096: PPUSH
10097: LD_INT 3
10099: PPUSH
10100: LD_INT 52
10102: PPUSH
10103: LD_INT 100
10105: PPUSH
10106: CALL 58417 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10110: CALL_OW 45
10114: PPUSH
10115: LD_INT 259
10117: PPUSH
10118: LD_INT 145
10120: PPUSH
10121: LD_INT 3
10123: PPUSH
10124: LD_INT 0
10126: PPUSH
10127: CALL 93408 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10131: CALL_OW 45
10135: PPUSH
10136: LD_INT 245
10138: PPUSH
10139: LD_INT 139
10141: PPUSH
10142: LD_INT 3
10144: PPUSH
10145: LD_INT 0
10147: PPUSH
10148: CALL 93408 0 5
// behemoths := [ ] ;
10152: LD_ADDR_EXP 66
10156: PUSH
10157: EMPTY
10158: ST_TO_ADDR
// behemothBuilders := [ ] ;
10159: LD_ADDR_EXP 67
10163: PUSH
10164: EMPTY
10165: ST_TO_ADDR
// j := 3 ;
10166: LD_ADDR_VAR 0 3
10170: PUSH
10171: LD_INT 3
10173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10174: LD_ADDR_VAR 0 2
10178: PUSH
10179: LD_INT 22
10181: PUSH
10182: LD_INT 3
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 25
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PUSH
10199: EMPTY
10200: LIST
10201: LIST
10202: PPUSH
10203: CALL_OW 69
10207: PUSH
10208: FOR_IN
10209: IFFALSE 10259
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10211: LD_ADDR_EXP 67
10215: PUSH
10216: LD_EXP 67
10220: PPUSH
10221: LD_VAR 0 2
10225: PPUSH
10226: CALL 91268 0 2
10230: ST_TO_ADDR
// j := j - 1 ;
10231: LD_ADDR_VAR 0 3
10235: PUSH
10236: LD_VAR 0 3
10240: PUSH
10241: LD_INT 1
10243: MINUS
10244: ST_TO_ADDR
// if j = 0 then
10245: LD_VAR 0 3
10249: PUSH
10250: LD_INT 0
10252: EQUAL
10253: IFFALSE 10257
// break ;
10255: GO 10259
// end ;
10257: GO 10208
10259: POP
10260: POP
// end ;
10261: LD_VAR 0 1
10265: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10266: LD_INT 0
10268: PPUSH
10269: PPUSH
10270: PPUSH
10271: PPUSH
10272: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10273: LD_ADDR_VAR 0 4
10277: PUSH
10278: LD_INT 209
10280: PUSH
10281: LD_INT 149
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 219
10290: PUSH
10291: LD_INT 154
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: PUSH
10298: LD_INT 223
10300: PUSH
10301: LD_INT 149
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PUSH
10308: LD_INT 232
10310: PUSH
10311: LD_INT 155
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: ST_TO_ADDR
// if not behemothBuilders then
10324: LD_EXP 67
10328: NOT
10329: IFFALSE 10333
// exit ;
10331: GO 10437
// j := 1 ;
10333: LD_ADDR_VAR 0 3
10337: PUSH
10338: LD_INT 1
10340: ST_TO_ADDR
// for i in behemothBuilders do
10341: LD_ADDR_VAR 0 2
10345: PUSH
10346: LD_EXP 67
10350: PUSH
10351: FOR_IN
10352: IFFALSE 10435
// begin if IsInUnit ( i ) then
10354: LD_VAR 0 2
10358: PPUSH
10359: CALL_OW 310
10363: IFFALSE 10374
// ComExitBuilding ( i ) ;
10365: LD_VAR 0 2
10369: PPUSH
10370: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10374: LD_VAR 0 2
10378: PPUSH
10379: LD_INT 37
10381: PPUSH
10382: LD_VAR 0 4
10386: PUSH
10387: LD_VAR 0 3
10391: ARRAY
10392: PUSH
10393: LD_INT 1
10395: ARRAY
10396: PPUSH
10397: LD_VAR 0 4
10401: PUSH
10402: LD_VAR 0 3
10406: ARRAY
10407: PUSH
10408: LD_INT 2
10410: ARRAY
10411: PPUSH
10412: LD_INT 0
10414: PPUSH
10415: CALL_OW 230
// j := j + 1 ;
10419: LD_ADDR_VAR 0 3
10423: PUSH
10424: LD_VAR 0 3
10428: PUSH
10429: LD_INT 1
10431: PLUS
10432: ST_TO_ADDR
// end ;
10433: GO 10351
10435: POP
10436: POP
// end ;
10437: LD_VAR 0 1
10441: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10442: LD_INT 3
10444: PPUSH
10445: CALL 91329 0 1
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 30
10462: PUSH
10463: LD_INT 37
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PPUSH
10474: CALL_OW 69
10478: NOT
10479: AND
10480: IFFALSE 10666
10482: GO 10484
10484: DISABLE
10485: LD_INT 0
10487: PPUSH
10488: PPUSH
// begin enable ;
10489: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10490: LD_ADDR_VAR 0 2
10494: PUSH
10495: LD_INT 3
10497: PPUSH
10498: CALL 91329 0 1
10502: ST_TO_ADDR
// for i in tmp do
10503: LD_ADDR_VAR 0 1
10507: PUSH
10508: LD_VAR 0 2
10512: PUSH
10513: FOR_IN
10514: IFFALSE 10664
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10516: LD_VAR 0 1
10520: PPUSH
10521: LD_INT 7
10523: PPUSH
10524: CALL_OW 308
10528: PUSH
10529: LD_VAR 0 1
10533: PPUSH
10534: CALL_OW 110
10538: PUSH
10539: LD_INT 2
10541: EQUAL
10542: NOT
10543: AND
10544: IFFALSE 10558
// SetTag ( i , 2 ) ;
10546: LD_VAR 0 1
10550: PPUSH
10551: LD_INT 2
10553: PPUSH
10554: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10558: LD_INT 81
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 91
10570: PUSH
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 12
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: LIST
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 69
10592: NOT
10593: PUSH
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL_OW 110
10603: PUSH
10604: LD_INT 2
10606: EQUAL
10607: NOT
10608: AND
10609: IFFALSE 10628
// ComAgressiveMove ( i , 64 , 93 ) else
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_INT 64
10618: PPUSH
10619: LD_INT 93
10621: PPUSH
10622: CALL_OW 114
10626: GO 10662
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 81
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 69
10647: PPUSH
10648: LD_VAR 0 1
10652: PPUSH
10653: CALL_OW 74
10657: PPUSH
10658: CALL_OW 115
// end ;
10662: GO 10513
10664: POP
10665: POP
// end ;
10666: PPOPN 2
10668: END
// every 6 6$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10669: LD_EXP 2
10673: NOT
10674: IFFALSE 11760
10676: GO 10678
10678: DISABLE
10679: LD_INT 0
10681: PPUSH
10682: PPUSH
10683: PPUSH
10684: PPUSH
10685: PPUSH
// begin enable ;
10686: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10687: LD_INT 22
10689: PUSH
10690: LD_INT 3
10692: PUSH
10693: EMPTY
10694: LIST
10695: LIST
10696: PUSH
10697: LD_INT 30
10699: PUSH
10700: LD_INT 3
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: PPUSH
10711: CALL_OW 69
10715: NOT
10716: IFFALSE 10720
// exit ;
10718: GO 11760
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10720: LD_ADDR_VAR 0 4
10724: PUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 3
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 30
10737: PUSH
10738: LD_INT 34
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: ST_TO_ADDR
// if Prob ( 40 ) then
10754: LD_INT 40
10756: PPUSH
10757: CALL_OW 13
10761: IFFALSE 10888
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10763: LD_INT 2
10765: PPUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 3
10771: PUSH
10772: LD_INT 3
10774: PUSH
10775: LD_INT 49
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: LIST
10782: LIST
10783: PUSH
10784: LD_INT 22
10786: PUSH
10787: LD_INT 3
10789: PUSH
10790: LD_INT 3
10792: PUSH
10793: LD_INT 49
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 22
10804: PUSH
10805: LD_INT 3
10807: PUSH
10808: LD_INT 3
10810: PUSH
10811: LD_INT 49
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: PUSH
10820: LD_INT 24
10822: PUSH
10823: LD_INT 3
10825: PUSH
10826: LD_INT 3
10828: PUSH
10829: LD_INT 46
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 24
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: LD_INT 3
10846: PUSH
10847: LD_INT 46
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: PUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 3
10864: PUSH
10865: LD_INT 46
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL 47151 0 2
// end else
10886: GO 11011
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10888: LD_INT 2
10890: PPUSH
10891: LD_INT 24
10893: PUSH
10894: LD_INT 3
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: LD_INT 47
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 24
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: LD_INT 3
10917: PUSH
10918: LD_INT 47
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: LD_INT 24
10929: PUSH
10930: LD_INT 3
10932: PUSH
10933: LD_INT 3
10935: PUSH
10936: LD_INT 47
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PUSH
10945: LD_INT 24
10947: PUSH
10948: LD_INT 3
10950: PUSH
10951: LD_INT 3
10953: PUSH
10954: LD_INT 46
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: LIST
10961: LIST
10962: PUSH
10963: LD_INT 24
10965: PUSH
10966: LD_INT 3
10968: PUSH
10969: LD_INT 3
10971: PUSH
10972: LD_INT 46
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: PUSH
10981: LD_INT 24
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: LD_INT 3
10989: PUSH
10990: LD_INT 46
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: LIST
11006: PPUSH
11007: CALL 47151 0 2
// end ; if Difficulty > 1 then
11011: LD_OWVAR 67
11015: PUSH
11016: LD_INT 1
11018: GREATER
11019: IFFALSE 11049
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11021: LD_INT 2
11023: PPUSH
11024: LD_INT 24
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 47
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: PPUSH
11045: CALL 47151 0 2
// p := 0 ;
11049: LD_ADDR_VAR 0 5
11053: PUSH
11054: LD_INT 0
11056: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11057: LD_INT 35
11059: PPUSH
11060: CALL_OW 67
// p := Inc ( p ) ;
11064: LD_ADDR_VAR 0 5
11068: PUSH
11069: LD_VAR 0 5
11073: PPUSH
11074: CALL 92629 0 1
11078: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11079: LD_INT 2
11081: PPUSH
11082: LD_INT 1
11084: PPUSH
11085: CALL 48569 0 2
11089: PUSH
11090: LD_INT 6
11092: PUSH
11093: LD_INT 7
11095: PUSH
11096: LD_INT 7
11098: PUSH
11099: LD_INT 7
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: LD_OWVAR 67
11112: ARRAY
11113: GREATEREQUAL
11114: PUSH
11115: LD_VAR 0 5
11119: PUSH
11120: LD_INT 120
11122: GREATER
11123: OR
11124: IFFALSE 11057
// wait ( 0 0$30 ) ;
11126: LD_INT 1050
11128: PPUSH
11129: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11133: LD_ADDR_VAR 0 2
11137: PUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 23
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: LD_INT 21
11160: PUSH
11161: LD_INT 2
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 34
11173: PUSH
11174: LD_INT 48
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 3
11187: PUSH
11188: LD_INT 34
11190: PUSH
11191: LD_INT 51
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 3
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: PPUSH
11227: CALL_OW 69
11231: PUSH
11232: LD_EXP 102
11236: PUSH
11237: LD_INT 2
11239: ARRAY
11240: DIFF
11241: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11242: LD_ADDR_EXP 99
11246: PUSH
11247: LD_EXP 99
11251: PPUSH
11252: LD_INT 2
11254: PPUSH
11255: LD_EXP 99
11259: PUSH
11260: LD_INT 2
11262: ARRAY
11263: PUSH
11264: LD_VAR 0 2
11268: DIFF
11269: PPUSH
11270: CALL_OW 1
11274: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11275: LD_ADDR_VAR 0 3
11279: PUSH
11280: LD_INT 0
11282: PPUSH
11283: LD_INT 1
11285: PPUSH
11286: CALL_OW 12
11290: ST_TO_ADDR
// p := 0 ;
11291: LD_ADDR_VAR 0 5
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// if target then
11299: LD_VAR 0 3
11303: IFFALSE 11456
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11305: LD_ADDR_VAR 0 2
11309: PUSH
11310: LD_VAR 0 2
11314: PPUSH
11315: LD_INT 24
11317: PUSH
11318: LD_INT 250
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PPUSH
11325: CALL_OW 72
11329: ST_TO_ADDR
// for i in tmp do
11330: LD_ADDR_VAR 0 1
11334: PUSH
11335: LD_VAR 0 2
11339: PUSH
11340: FOR_IN
11341: IFFALSE 11381
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11343: LD_VAR 0 1
11347: PPUSH
11348: LD_INT 139
11350: PPUSH
11351: LD_INT 89
11353: PPUSH
11354: CALL_OW 297
11358: PUSH
11359: LD_INT 9
11361: GREATER
11362: IFFALSE 11379
// ComMoveXY ( i , 139 , 89 ) ;
11364: LD_VAR 0 1
11368: PPUSH
11369: LD_INT 139
11371: PPUSH
11372: LD_INT 89
11374: PPUSH
11375: CALL_OW 111
11379: GO 11340
11381: POP
11382: POP
// wait ( 0 0$1 ) ;
11383: LD_INT 35
11385: PPUSH
11386: CALL_OW 67
// p := Inc ( p ) ;
11390: LD_ADDR_VAR 0 5
11394: PUSH
11395: LD_VAR 0 5
11399: PPUSH
11400: CALL 92629 0 1
11404: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11405: LD_VAR 0 2
11409: PPUSH
11410: LD_INT 92
11412: PUSH
11413: LD_INT 139
11415: PUSH
11416: LD_INT 89
11418: PUSH
11419: LD_INT 9
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 72
11432: PUSH
11433: LD_VAR 0 2
11437: PUSH
11438: LD_INT 1
11440: MINUS
11441: GREATEREQUAL
11442: PUSH
11443: LD_VAR 0 5
11447: PUSH
11448: LD_INT 30
11450: GREATER
11451: OR
11452: IFFALSE 11305
// end else
11454: GO 11623
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11456: LD_VAR 0 2
11460: PPUSH
11461: LD_VAR 0 4
11465: PUSH
11466: LD_INT 1
11468: ARRAY
11469: PPUSH
11470: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11474: LD_ADDR_VAR 0 2
11478: PUSH
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 24
11486: PUSH
11487: LD_INT 250
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 72
11498: ST_TO_ADDR
// for i in tmp do
11499: LD_ADDR_VAR 0 1
11503: PUSH
11504: LD_VAR 0 2
11508: PUSH
11509: FOR_IN
11510: IFFALSE 11550
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 124
11519: PPUSH
11520: LD_INT 139
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 9
11530: GREATER
11531: IFFALSE 11548
// ComMoveXY ( i , 124 , 139 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 124
11540: PPUSH
11541: LD_INT 139
11543: PPUSH
11544: CALL_OW 111
11548: GO 11509
11550: POP
11551: POP
// wait ( 0 0$1 ) ;
11552: LD_INT 35
11554: PPUSH
11555: CALL_OW 67
// p := Inc ( p ) ;
11559: LD_ADDR_VAR 0 5
11563: PUSH
11564: LD_VAR 0 5
11568: PPUSH
11569: CALL 92629 0 1
11573: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11574: LD_VAR 0 2
11578: PPUSH
11579: LD_INT 92
11581: PUSH
11582: LD_INT 124
11584: PUSH
11585: LD_INT 139
11587: PUSH
11588: LD_INT 9
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: PPUSH
11597: CALL_OW 72
11601: PUSH
11602: LD_VAR 0 2
11606: PUSH
11607: LD_INT 1
11609: MINUS
11610: GREATEREQUAL
11611: PUSH
11612: LD_VAR 0 5
11616: PUSH
11617: LD_INT 30
11619: GREATER
11620: OR
11621: IFFALSE 11474
// end ; repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11630: LD_ADDR_VAR 0 2
11634: PUSH
11635: LD_VAR 0 2
11639: PPUSH
11640: LD_INT 50
11642: PUSH
11643: EMPTY
11644: LIST
11645: PPUSH
11646: CALL_OW 72
11650: ST_TO_ADDR
// for i in tmp do
11651: LD_ADDR_VAR 0 1
11655: PUSH
11656: LD_VAR 0 2
11660: PUSH
11661: FOR_IN
11662: IFFALSE 11751
// begin if GetWeapon ( i ) = ru_time_lapser then
11664: LD_VAR 0 1
11668: PPUSH
11669: CALL_OW 264
11673: PUSH
11674: LD_INT 49
11676: EQUAL
11677: IFFALSE 11715
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11679: LD_VAR 0 1
11683: PPUSH
11684: LD_INT 81
11686: PUSH
11687: LD_INT 3
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PPUSH
11694: CALL_OW 69
11698: PPUSH
11699: LD_VAR 0 1
11703: PPUSH
11704: CALL_OW 74
11708: PPUSH
11709: CALL_OW 112
11713: GO 11749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11715: LD_VAR 0 1
11719: PPUSH
11720: LD_INT 81
11722: PUSH
11723: LD_INT 3
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PPUSH
11730: CALL_OW 69
11734: PPUSH
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL_OW 74
11744: PPUSH
11745: CALL_OW 115
// end ;
11749: GO 11661
11751: POP
11752: POP
// until not tmp ;
11753: LD_VAR 0 2
11757: NOT
11758: IFFALSE 11623
// end ;
11760: PPOPN 5
11762: END
// every 30 30$00 trigger not russianDestroyed do
11763: LD_EXP 2
11767: NOT
11768: IFFALSE 11837
11770: GO 11772
11772: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11773: LD_INT 105000
11775: PUSH
11776: LD_INT 84000
11778: PUSH
11779: LD_INT 63000
11781: PUSH
11782: LD_INT 52500
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: PUSH
11791: LD_OWVAR 67
11795: ARRAY
11796: PPUSH
11797: CALL_OW 67
// if russianDestroyed then
11801: LD_EXP 2
11805: IFFALSE 11809
// exit ;
11807: GO 11837
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11809: LD_INT 2
11811: PPUSH
11812: LD_INT 23
11814: PUSH
11815: LD_INT 3
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: LD_INT 48
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: PPUSH
11833: CALL 47151 0 2
// end ; end_of_file
11837: END
// export function CustomEvent ( event ) ; begin
11838: LD_INT 0
11840: PPUSH
// end ;
11841: LD_VAR 0 2
11845: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11846: LD_VAR 0 2
11850: PPUSH
11851: LD_VAR 0 3
11855: PPUSH
11856: LD_INT 15
11858: PPUSH
11859: CALL_OW 309
11863: IFFALSE 11872
// YouLost ( MothContaminate ) ;
11865: LD_STRING MothContaminate
11867: PPUSH
11868: CALL_OW 104
// end ;
11872: PPOPN 3
11874: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11875: LD_VAR 0 2
11879: PPUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_INT 15
11887: PPUSH
11888: CALL_OW 309
11892: IFFALSE 11908
// begin wait ( 0 0$6 ) ;
11894: LD_INT 210
11896: PPUSH
11897: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11901: LD_STRING MothContaminateBomb
11903: PPUSH
11904: CALL_OW 104
// end ; end ;
11908: PPOPN 3
11910: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11911: LD_VAR 0 1
11915: PPUSH
11916: CALL 112171 0 1
// if un = JMM then
11920: LD_VAR 0 1
11924: PUSH
11925: LD_EXP 21
11929: EQUAL
11930: IFFALSE 11941
// begin YouLost ( JMM ) ;
11932: LD_STRING JMM
11934: PPUSH
11935: CALL_OW 104
// exit ;
11939: GO 12090
// end ; if un = Omar then
11941: LD_VAR 0 1
11945: PUSH
11946: LD_EXP 58
11950: EQUAL
11951: IFFALSE 11961
// omarKilled := true ;
11953: LD_ADDR_EXP 20
11957: PUSH
11958: LD_INT 1
11960: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: LD_INT 2
11973: EQUAL
11974: PUSH
11975: LD_EXP 18
11979: NOT
11980: AND
11981: IFFALSE 11991
// arabianAttacked := true ;
11983: LD_ADDR_EXP 18
11987: PUSH
11988: LD_INT 1
11990: ST_TO_ADDR
// if un = Powell then
11991: LD_VAR 0 1
11995: PUSH
11996: LD_EXP 57
12000: EQUAL
12001: IFFALSE 12011
// americanDestroyed := true ;
12003: LD_ADDR_EXP 4
12007: PUSH
12008: LD_INT 1
12010: ST_TO_ADDR
// if un = Platonov then
12011: LD_VAR 0 1
12015: PUSH
12016: LD_EXP 62
12020: EQUAL
12021: IFFALSE 12031
// russianDestroyed := true ;
12023: LD_ADDR_EXP 2
12027: PUSH
12028: LD_INT 1
12030: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
12031: LD_VAR 0 1
12035: PUSH
12036: LD_INT 22
12038: PUSH
12039: LD_INT 7
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 21
12048: PUSH
12049: LD_INT 2
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: IN
12065: IFFALSE 12081
// vehicleLostCounter := vehicleLostCounter + 1 ;
12067: LD_ADDR_EXP 15
12071: PUSH
12072: LD_EXP 15
12076: PUSH
12077: LD_INT 1
12079: PLUS
12080: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL 50593 0 1
// end ;
12090: PPOPN 1
12092: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12093: LD_VAR 0 1
12097: PPUSH
12098: LD_VAR 0 2
12102: PPUSH
12103: CALL 52925 0 2
// end ;
12107: PPOPN 2
12109: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12110: LD_VAR 0 1
12114: PPUSH
12115: CALL 51993 0 1
// end ;
12119: PPOPN 1
12121: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12122: LD_VAR 0 1
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 8
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 30
12139: PUSH
12140: LD_INT 2
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 23
12149: PUSH
12150: LD_INT 3
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: PPUSH
12162: CALL_OW 69
12166: IN
12167: IFFALSE 12194
// begin ComUpgrade ( building ) ;
12169: LD_VAR 0 1
12173: PPUSH
12174: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12178: LD_EXP 60
12182: PPUSH
12183: LD_VAR 0 1
12187: PPUSH
12188: CALL 61777 0 2
// exit ;
12192: GO 12203
// end ; MCE_BuildingComplete ( building ) ;
12194: LD_VAR 0 1
12198: PPUSH
12199: CALL 52234 0 1
// end ;
12203: PPOPN 1
12205: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12206: LD_VAR 0 1
12210: PPUSH
12211: LD_VAR 0 2
12215: PPUSH
12216: CALL 50289 0 2
// end ;
12220: PPOPN 2
12222: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12223: LD_VAR 0 1
12227: PPUSH
12228: LD_VAR 0 2
12232: PPUSH
12233: LD_VAR 0 3
12237: PPUSH
12238: LD_VAR 0 4
12242: PPUSH
12243: LD_VAR 0 5
12247: PPUSH
12248: CALL 49909 0 5
// end ;
12252: PPOPN 5
12254: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12255: LD_VAR 0 1
12259: PPUSH
12260: LD_VAR 0 2
12264: PPUSH
12265: CALL 112291 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12269: LD_VAR 0 1
12273: PPUSH
12274: LD_VAR 0 2
12278: PPUSH
12279: CALL 49462 0 2
// end ;
12283: PPOPN 2
12285: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12286: LD_VAR 0 1
12290: PPUSH
12291: LD_VAR 0 2
12295: PPUSH
12296: LD_VAR 0 3
12300: PPUSH
12301: LD_VAR 0 4
12305: PPUSH
12306: CALL 49300 0 4
// end ;
12310: PPOPN 4
12312: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12313: LD_VAR 0 1
12317: PPUSH
12318: LD_VAR 0 2
12322: PPUSH
12323: LD_VAR 0 3
12327: PPUSH
12328: CALL 49075 0 3
// end ;
12332: PPOPN 3
12334: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12335: LD_VAR 0 1
12339: PPUSH
12340: LD_VAR 0 2
12344: PPUSH
12345: CALL 48960 0 2
// end ;
12349: PPOPN 2
12351: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12352: LD_VAR 0 1
12356: PPUSH
12357: LD_VAR 0 2
12361: PPUSH
12362: CALL 53220 0 2
// end ;
12366: PPOPN 2
12368: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12369: LD_VAR 0 1
12373: PUSH
12374: LD_INT 674
12376: EQUAL
12377: IFFALSE 12399
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12379: LD_VAR 0 2
12383: PPUSH
12384: LD_INT 227
12386: PPUSH
12387: LD_INT 136
12389: PPUSH
12390: CALL_OW 428
12394: PPUSH
12395: CALL_OW 120
// end ;
12399: PPOPN 2
12401: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12402: LD_VAR 0 1
12406: PPUSH
12407: LD_VAR 0 2
12411: PPUSH
12412: LD_VAR 0 3
12416: PPUSH
12417: LD_VAR 0 4
12421: PPUSH
12422: CALL 53436 0 4
// end ;
12426: PPOPN 4
12428: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12429: LD_VAR 0 1
12433: PPUSH
12434: LD_VAR 0 2
12438: PPUSH
12439: CALL 48769 0 2
// end ;
12443: PPOPN 2
12445: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12446: LD_VAR 0 1
12450: PPUSH
12451: CALL 112275 0 1
// end ; end_of_file
12455: PPOPN 1
12457: END
// export function Action ; begin
12458: LD_INT 0
12460: PPUSH
// InGameOn ;
12461: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12465: LD_INT 206
12467: PPUSH
12468: LD_INT 11
12470: PPUSH
12471: CALL_OW 86
// wait ( 0 0$1 ) ;
12475: LD_INT 35
12477: PPUSH
12478: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12482: LD_EXP 21
12486: PPUSH
12487: LD_STRING DStart-JMM-JMM-1
12489: PPUSH
12490: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12494: LD_EXP 54
12498: PPUSH
12499: LD_STRING DStart-JMM-Bur-1
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12506: LD_EXP 21
12510: PPUSH
12511: LD_STRING DStart-JMM-JMM-2
12513: PPUSH
12514: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12518: LD_EXP 54
12522: PPUSH
12523: LD_STRING DStart-JMM-Bur-2
12525: PPUSH
12526: CALL_OW 88
// InGameOff ;
12530: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12534: LD_STRING MStart
12536: PPUSH
12537: CALL_OW 337
// SaveForQuickRestart ;
12541: CALL_OW 22
// end ;
12545: LD_VAR 0 1
12549: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12550: LD_INT 7
12552: PPUSH
12553: LD_INT 255
12555: PPUSH
12556: LD_INT 219
12558: PPUSH
12559: CALL_OW 293
12563: IFFALSE 13172
12565: GO 12567
12567: DISABLE
12568: LD_INT 0
12570: PPUSH
// begin wait ( 0 0$3 ) ;
12571: LD_INT 105
12573: PPUSH
12574: CALL_OW 67
// alienSpotted := true ;
12578: LD_ADDR_EXP 10
12582: PUSH
12583: LD_INT 1
12585: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12586: LD_ADDR_VAR 0 1
12590: PUSH
12591: LD_INT 22
12593: PUSH
12594: LD_INT 7
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 23
12603: PUSH
12604: LD_INT 3
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 21
12613: PUSH
12614: LD_INT 1
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PUSH
12621: LD_INT 26
12623: PUSH
12624: LD_INT 1
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: PPUSH
12637: CALL_OW 69
12641: PUSH
12642: LD_EXP 54
12646: PUSH
12647: LD_EXP 42
12651: PUSH
12652: LD_EXP 44
12656: PUSH
12657: LD_EXP 45
12661: PUSH
12662: LD_EXP 52
12666: PUSH
12667: LD_EXP 51
12671: PUSH
12672: LD_EXP 46
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: DIFF
12686: ST_TO_ADDR
// DialogueOn ;
12687: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12691: LD_INT 255
12693: PPUSH
12694: LD_INT 219
12696: PPUSH
12697: LD_INT 7
12699: PPUSH
12700: LD_INT 20
12702: NEG
12703: PPUSH
12704: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12708: LD_INT 255
12710: PPUSH
12711: LD_INT 219
12713: PPUSH
12714: CALL_OW 86
// if speaker then
12718: LD_VAR 0 1
12722: IFFALSE 12740
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DAlienBase-RSol1-1
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12740: LD_EXP 21
12744: PPUSH
12745: LD_STRING DAlienBase-JMM-1
12747: PPUSH
12748: CALL_OW 88
// if IsOk ( Burlak ) then
12752: LD_EXP 54
12756: PPUSH
12757: CALL_OW 302
12761: IFFALSE 12782
// begin dwait ( 0 0$1 ) ;
12763: LD_INT 35
12765: PPUSH
12766: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12770: LD_EXP 54
12774: PPUSH
12775: LD_STRING DAlienBase-Bur-1
12777: PPUSH
12778: CALL_OW 88
// end ; if IsOk ( Roth ) then
12782: LD_EXP 22
12786: PPUSH
12787: CALL_OW 302
12791: IFFALSE 12805
// Say ( Roth , DAlienBase-Roth-1 ) ;
12793: LD_EXP 22
12797: PPUSH
12798: LD_STRING DAlienBase-Roth-1
12800: PPUSH
12801: CALL_OW 88
// if IsOk ( Gossudarov ) then
12805: LD_EXP 40
12809: PPUSH
12810: CALL_OW 302
12814: IFFALSE 12830
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12816: LD_EXP 40
12820: PPUSH
12821: LD_STRING DAlienBase-Gos-1
12823: PPUSH
12824: CALL_OW 88
12828: GO 12947
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_INT 22
12837: PUSH
12838: LD_INT 7
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PUSH
12845: LD_INT 25
12847: PUSH
12848: LD_INT 4
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 21
12857: PUSH
12858: LD_INT 1
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PUSH
12865: LD_INT 26
12867: PUSH
12868: LD_INT 1
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 22
12890: PUSH
12891: LD_EXP 21
12895: PUSH
12896: LD_EXP 54
12900: PUSH
12901: LD_EXP 42
12905: PUSH
12906: LD_EXP 52
12910: PUSH
12911: LD_EXP 51
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DAlienBase-Sci1-1
12942: PPUSH
12943: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12947: LD_INT 255
12949: PPUSH
12950: LD_INT 219
12952: PPUSH
12953: LD_INT 7
12955: PPUSH
12956: CALL_OW 331
// DialogueOff ;
12960: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12964: LD_INT 35
12966: PPUSH
12967: CALL_OW 67
// until IsSelected ( alien ) ;
12971: LD_INT 1
12973: PPUSH
12974: CALL_OW 306
12978: IFFALSE 12964
// if not artifactIResearched or not artifactIIResearched then
12980: LD_EXP 12
12984: NOT
12985: PUSH
12986: LD_EXP 13
12990: NOT
12991: OR
12992: IFFALSE 13172
// begin if IsOk ( Roth ) then
12994: LD_EXP 22
12998: PPUSH
12999: CALL_OW 302
13003: IFFALSE 13019
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
13005: LD_EXP 22
13009: PPUSH
13010: LD_STRING DAlieBaseNotReady-Roth-1
13012: PPUSH
13013: CALL_OW 88
13017: GO 13172
// if IsOk ( Gossudarov ) then
13019: LD_EXP 40
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13044
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
13030: LD_EXP 40
13034: PPUSH
13035: LD_STRING DAlieBaseNotReady-Gos-1
13037: PPUSH
13038: CALL_OW 88
13042: GO 13172
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13044: LD_ADDR_VAR 0 1
13048: PUSH
13049: LD_INT 22
13051: PUSH
13052: LD_INT 7
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 25
13071: PUSH
13072: LD_INT 4
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 21
13081: PUSH
13082: LD_INT 1
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 26
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: PUSH
13111: LD_EXP 22
13115: PUSH
13116: LD_EXP 21
13120: PUSH
13121: LD_EXP 54
13125: PUSH
13126: LD_EXP 42
13130: PUSH
13131: LD_EXP 52
13135: PUSH
13136: LD_EXP 51
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: DIFF
13149: ST_TO_ADDR
// if speaker then
13150: LD_VAR 0 1
13154: IFFALSE 13172
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13156: LD_VAR 0 1
13160: PUSH
13161: LD_INT 1
13163: ARRAY
13164: PPUSH
13165: LD_STRING DAlieBaseNotReady-RSci1-1
13167: PPUSH
13168: CALL_OW 88
// end ; end ; end ;
13172: PPOPN 1
13174: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13175: LD_INT 24
13177: PPUSH
13178: LD_INT 7
13180: PPUSH
13181: CALL_OW 321
13185: PUSH
13186: LD_INT 2
13188: EQUAL
13189: IFFALSE 13880
13191: GO 13193
13193: DISABLE
13194: LD_INT 0
13196: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13197: LD_ADDR_VAR 0 1
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 7
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 23
13214: PUSH
13215: LD_INT 3
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: LD_INT 25
13224: PUSH
13225: LD_INT 4
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 21
13234: PUSH
13235: LD_INT 1
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 26
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 22
13268: PUSH
13269: LD_EXP 21
13273: PUSH
13274: LD_EXP 54
13278: PUSH
13279: LD_EXP 42
13283: PUSH
13284: LD_EXP 52
13288: PUSH
13289: LD_EXP 51
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: DIFF
13302: ST_TO_ADDR
// if not speaker then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13880
// DialogueOn ;
13312: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING DArtefTechnology-RSci1-1
13327: PPUSH
13328: CALL_OW 88
// if IsOk ( Burlak ) then
13332: LD_EXP 54
13336: PPUSH
13337: CALL_OW 302
13341: IFFALSE 13355
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13343: LD_EXP 54
13347: PPUSH
13348: LD_STRING DArtefTechnology-Bur-1
13350: PPUSH
13351: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13355: LD_VAR 0 1
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: PPUSH
13364: LD_STRING DArtefTechnology-RSci1-2
13366: PPUSH
13367: CALL_OW 88
// if Denis then
13371: LD_EXP 27
13375: IFFALSE 13392
// speaker := [ Denis ] else
13377: LD_ADDR_VAR 0 1
13381: PUSH
13382: LD_EXP 27
13386: PUSH
13387: EMPTY
13388: LIST
13389: ST_TO_ADDR
13390: GO 13498
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13392: LD_ADDR_VAR 0 1
13396: PUSH
13397: LD_INT 22
13399: PUSH
13400: LD_INT 7
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: LD_INT 23
13409: PUSH
13410: LD_INT 1
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: PUSH
13417: LD_INT 25
13419: PUSH
13420: LD_INT 4
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: PUSH
13427: LD_INT 21
13429: PUSH
13430: LD_INT 1
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PUSH
13437: LD_INT 26
13439: PUSH
13440: LD_INT 1
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 69
13458: PUSH
13459: LD_EXP 22
13463: PUSH
13464: LD_EXP 21
13468: PUSH
13469: LD_EXP 54
13473: PUSH
13474: LD_EXP 42
13478: PUSH
13479: LD_EXP 52
13483: PUSH
13484: LD_EXP 51
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: DIFF
13497: ST_TO_ADDR
// if speaker then
13498: LD_VAR 0 1
13502: IFFALSE 13520
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13504: LD_VAR 0 1
13508: PUSH
13509: LD_INT 1
13511: ARRAY
13512: PPUSH
13513: LD_STRING DArtefTechnology-Sci1-2
13515: PPUSH
13516: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13520: LD_ADDR_VAR 0 1
13524: PUSH
13525: LD_INT 22
13527: PUSH
13528: LD_INT 7
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 23
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 21
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 26
13567: PUSH
13568: LD_INT 1
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: PPUSH
13582: CALL_OW 69
13586: PUSH
13587: LD_EXP 22
13591: PUSH
13592: LD_EXP 21
13596: PUSH
13597: LD_EXP 54
13601: PUSH
13602: LD_EXP 42
13606: PUSH
13607: LD_EXP 52
13611: PUSH
13612: LD_EXP 51
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: DIFF
13625: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13626: LD_VAR 0 1
13630: PUSH
13631: LD_EXP 9
13635: PUSH
13636: LD_EXP 5
13640: OR
13641: AND
13642: IFFALSE 13876
// begin if arabianDestroyed and IsOk ( Burlak ) then
13644: LD_EXP 5
13648: PUSH
13649: LD_EXP 54
13653: PPUSH
13654: CALL_OW 302
13658: AND
13659: IFFALSE 13675
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13661: LD_EXP 54
13665: PPUSH
13666: LD_STRING DArtefTechnology-Bur-2
13668: PPUSH
13669: CALL_OW 88
13673: GO 13687
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13675: LD_EXP 21
13679: PPUSH
13680: LD_STRING DArtefTechnology-JMM-2
13682: PPUSH
13683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13687: LD_VAR 0 1
13691: PUSH
13692: LD_INT 1
13694: ARRAY
13695: PPUSH
13696: LD_STRING DArtefTechnology-RSci1-3
13698: PPUSH
13699: CALL_OW 88
// if Denis then
13703: LD_EXP 27
13707: IFFALSE 13724
// speaker := [ Denis ] else
13709: LD_ADDR_VAR 0 1
13713: PUSH
13714: LD_EXP 27
13718: PUSH
13719: EMPTY
13720: LIST
13721: ST_TO_ADDR
13722: GO 13830
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 7
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 23
13741: PUSH
13742: LD_INT 1
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 25
13751: PUSH
13752: LD_INT 4
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 21
13761: PUSH
13762: LD_INT 1
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 26
13771: PUSH
13772: LD_INT 1
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 69
13790: PUSH
13791: LD_EXP 22
13795: PUSH
13796: LD_EXP 21
13800: PUSH
13801: LD_EXP 54
13805: PUSH
13806: LD_EXP 42
13810: PUSH
13811: LD_EXP 52
13815: PUSH
13816: LD_EXP 51
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: DIFF
13829: ST_TO_ADDR
// if speaker then
13830: LD_VAR 0 1
13834: IFFALSE 13876
// if alienSpotted then
13836: LD_EXP 10
13840: IFFALSE 13860
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13842: LD_VAR 0 1
13846: PUSH
13847: LD_INT 1
13849: ARRAY
13850: PPUSH
13851: LD_STRING DArtefTechnology-Sci1-3
13853: PPUSH
13854: CALL_OW 88
13858: GO 13876
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13860: LD_VAR 0 1
13864: PUSH
13865: LD_INT 1
13867: ARRAY
13868: PPUSH
13869: LD_STRING DArtefTechnology-Sci1-3a
13871: PPUSH
13872: CALL_OW 88
// end ; DialogueOff ;
13876: CALL_OW 7
// end ;
13880: PPOPN 1
13882: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13883: LD_EXP 12
13887: IFFALSE 14090
13889: GO 13891
13891: DISABLE
13892: LD_INT 0
13894: PPUSH
// begin if Denis then
13895: LD_EXP 27
13899: IFFALSE 13916
// speaker := [ Denis ] else
13901: LD_ADDR_VAR 0 1
13905: PUSH
13906: LD_EXP 27
13910: PUSH
13911: EMPTY
13912: LIST
13913: ST_TO_ADDR
13914: GO 14022
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13916: LD_ADDR_VAR 0 1
13920: PUSH
13921: LD_INT 22
13923: PUSH
13924: LD_INT 7
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 1
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PUSH
13941: LD_INT 25
13943: PUSH
13944: LD_INT 4
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: PUSH
13951: LD_INT 21
13953: PUSH
13954: LD_INT 1
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PUSH
13961: LD_INT 26
13963: PUSH
13964: LD_INT 1
13966: PUSH
13967: EMPTY
13968: LIST
13969: LIST
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 69
13982: PUSH
13983: LD_EXP 22
13987: PUSH
13988: LD_EXP 21
13992: PUSH
13993: LD_EXP 54
13997: PUSH
13998: LD_EXP 42
14002: PUSH
14003: LD_EXP 52
14007: PUSH
14008: LD_EXP 51
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: DIFF
14021: ST_TO_ADDR
// if not speaker then
14022: LD_VAR 0 1
14026: NOT
14027: IFFALSE 14031
// exit ;
14029: GO 14090
// DialogueOn ;
14031: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
14035: LD_VAR 0 1
14039: PUSH
14040: LD_INT 1
14042: ARRAY
14043: PPUSH
14044: LD_STRING DArtefTechnologyAm-Sci1-1
14046: PPUSH
14047: CALL_OW 88
// if IsOk ( Burlak ) then
14051: LD_EXP 54
14055: PPUSH
14056: CALL_OW 302
14060: IFFALSE 14074
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
14062: LD_EXP 54
14066: PPUSH
14067: LD_STRING DArtefTechnologyAm-Bur-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
14074: LD_EXP 21
14078: PPUSH
14079: LD_STRING DArtefTechnologyAm-JMM-1
14081: PPUSH
14082: CALL_OW 88
// DialogueOff ;
14086: CALL_OW 7
// end ;
14090: PPOPN 1
14092: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
14093: LD_EXP 13
14097: IFFALSE 14299
14099: GO 14101
14101: DISABLE
14102: LD_INT 0
14104: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14105: LD_ADDR_VAR 0 1
14109: PUSH
14110: LD_INT 22
14112: PUSH
14113: LD_INT 7
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: PUSH
14120: LD_INT 23
14122: PUSH
14123: LD_INT 3
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PUSH
14130: LD_INT 25
14132: PUSH
14133: LD_INT 4
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: LD_INT 21
14142: PUSH
14143: LD_INT 1
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 26
14152: PUSH
14153: LD_INT 1
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: PPUSH
14167: CALL_OW 69
14171: PUSH
14172: LD_EXP 22
14176: PUSH
14177: LD_EXP 21
14181: PUSH
14182: LD_EXP 54
14186: PUSH
14187: LD_EXP 42
14191: PUSH
14192: LD_EXP 52
14196: PUSH
14197: LD_EXP 51
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: DIFF
14210: ST_TO_ADDR
// if not speaker then
14211: LD_VAR 0 1
14215: NOT
14216: IFFALSE 14220
// exit ;
14218: GO 14299
// DialogueOn ;
14220: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14224: LD_VAR 0 1
14228: PUSH
14229: LD_VAR 0 1
14233: ARRAY
14234: PPUSH
14235: LD_STRING DArtefTechnologyRu-RSci1-1
14237: PPUSH
14238: CALL_OW 88
// if IsOk ( Burlak ) then
14242: LD_EXP 54
14246: PPUSH
14247: CALL_OW 302
14251: IFFALSE 14265
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14253: LD_EXP 54
14257: PPUSH
14258: LD_STRING DArtefTechnologyRu-Bur-1
14260: PPUSH
14261: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14265: LD_VAR 0 1
14269: PUSH
14270: LD_VAR 0 1
14274: ARRAY
14275: PPUSH
14276: LD_STRING DArtefTechnologyRu-RSci1-2
14278: PPUSH
14279: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14283: LD_EXP 21
14287: PPUSH
14288: LD_STRING DArtefTechnologyRu-JMM-1
14290: PPUSH
14291: CALL_OW 88
// DialogueOff ;
14295: CALL_OW 7
// end ;
14299: PPOPN 1
14301: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14302: LD_INT 24
14304: PPUSH
14305: LD_INT 7
14307: PPUSH
14308: CALL_OW 321
14312: PUSH
14313: LD_INT 2
14315: EQUAL
14316: PUSH
14317: LD_INT 1
14319: PPUSH
14320: CALL_OW 255
14324: PUSH
14325: LD_INT 7
14327: EQUAL
14328: AND
14329: IFFALSE 14497
14331: GO 14333
14333: DISABLE
14334: LD_INT 0
14336: PPUSH
// begin if Denis then
14337: LD_EXP 27
14341: IFFALSE 14358
// speaker := [ Denis ] else
14343: LD_ADDR_VAR 0 1
14347: PUSH
14348: LD_EXP 27
14352: PUSH
14353: EMPTY
14354: LIST
14355: ST_TO_ADDR
14356: GO 14464
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14358: LD_ADDR_VAR 0 1
14362: PUSH
14363: LD_INT 22
14365: PUSH
14366: LD_INT 7
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 23
14375: PUSH
14376: LD_INT 1
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 4
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 21
14395: PUSH
14396: LD_INT 1
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 26
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: PPUSH
14420: CALL_OW 69
14424: PUSH
14425: LD_EXP 22
14429: PUSH
14430: LD_EXP 21
14434: PUSH
14435: LD_EXP 54
14439: PUSH
14440: LD_EXP 42
14444: PUSH
14445: LD_EXP 52
14449: PUSH
14450: LD_EXP 51
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: DIFF
14463: ST_TO_ADDR
// if not speaker then
14464: LD_VAR 0 1
14468: NOT
14469: IFFALSE 14473
// exit ;
14471: GO 14497
// DialogueOn ;
14473: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14477: LD_VAR 0 1
14481: PUSH
14482: LD_INT 1
14484: ARRAY
14485: PPUSH
14486: LD_STRING DArtefTechnologyArStart-Sci1-1
14488: PPUSH
14489: CALL_OW 88
// DialogueOff ;
14493: CALL_OW 7
// end ;
14497: PPOPN 1
14499: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14500: LD_EXP 14
14504: IFFALSE 14785
14506: GO 14508
14508: DISABLE
14509: LD_INT 0
14511: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14512: LD_ADDR_VAR 0 1
14516: PUSH
14517: LD_INT 22
14519: PUSH
14520: LD_INT 7
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: LD_INT 23
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 25
14539: PUSH
14540: LD_INT 4
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PUSH
14547: LD_INT 21
14549: PUSH
14550: LD_INT 1
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: LD_INT 26
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: PPUSH
14574: CALL_OW 69
14578: PUSH
14579: LD_EXP 22
14583: PUSH
14584: LD_EXP 21
14588: PUSH
14589: LD_EXP 54
14593: PUSH
14594: LD_EXP 42
14598: PUSH
14599: LD_EXP 52
14603: PUSH
14604: LD_EXP 51
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: DIFF
14617: ST_TO_ADDR
// if not speaker then
14618: LD_VAR 0 1
14622: NOT
14623: IFFALSE 14627
// exit ;
14625: GO 14785
// DialogueOn ;
14627: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14631: LD_VAR 0 1
14635: PUSH
14636: LD_INT 1
14638: ARRAY
14639: PPUSH
14640: LD_STRING DArtefTechnologyAr-RSci1-1
14642: PPUSH
14643: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING DArtefTechnologyAr-JMM-1
14654: PPUSH
14655: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14659: LD_VAR 0 1
14663: PUSH
14664: LD_INT 1
14666: ARRAY
14667: PPUSH
14668: LD_STRING DArtefTechnologyAr-RSci1-2
14670: PPUSH
14671: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14675: LD_EXP 21
14679: PPUSH
14680: LD_STRING DArtefTechnologyAr-JMM-2
14682: PPUSH
14683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14687: LD_VAR 0 1
14691: PUSH
14692: LD_INT 1
14694: ARRAY
14695: PPUSH
14696: LD_STRING DArtefTechnologyAr-RSci1-3
14698: PPUSH
14699: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14703: LD_EXP 21
14707: PPUSH
14708: LD_STRING DArtefTechnologyAr-JMM-3
14710: PPUSH
14711: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14715: LD_VAR 0 1
14719: PUSH
14720: LD_INT 1
14722: ARRAY
14723: PPUSH
14724: LD_STRING DArtefTechnologyAr-RSci1-4
14726: PPUSH
14727: CALL_OW 88
// if IsOk ( Burlak ) then
14731: LD_EXP 54
14735: PPUSH
14736: CALL_OW 302
14740: IFFALSE 14754
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14742: LD_EXP 54
14746: PPUSH
14747: LD_STRING DArtefTechnologyAr-Bur-4
14749: PPUSH
14750: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14754: LD_EXP 21
14758: PPUSH
14759: LD_STRING DArtefTechnologyAr-JMM-4
14761: PPUSH
14762: CALL_OW 88
// DialogueOff ;
14766: CALL_OW 7
// wait ( 0 0$45 ) ;
14770: LD_INT 1575
14772: PPUSH
14773: CALL_OW 67
// spawnOmar := true ;
14777: LD_ADDR_EXP 11
14781: PUSH
14782: LD_INT 1
14784: ST_TO_ADDR
// end ;
14785: PPOPN 1
14787: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14788: LD_EXP 11
14792: PUSH
14793: LD_EXP 19
14797: AND
14798: IFFALSE 15177
14800: GO 14802
14802: DISABLE
// begin PrepareOmarAli ;
14803: CALL 7606 0 0
// if not HasTask ( Omar ) then
14807: LD_EXP 58
14811: PPUSH
14812: CALL_OW 314
14816: NOT
14817: IFFALSE 14834
// ComMoveXY ( Omar , 252 , 220 ) ;
14819: LD_EXP 58
14823: PPUSH
14824: LD_INT 252
14826: PPUSH
14827: LD_INT 220
14829: PPUSH
14830: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14834: LD_INT 35
14836: PPUSH
14837: CALL_OW 67
// if omarKilled then
14841: LD_EXP 20
14845: IFFALSE 14849
// exit ;
14847: GO 15177
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14849: LD_EXP 58
14853: PPUSH
14854: CALL_OW 314
14858: NOT
14859: PUSH
14860: LD_EXP 58
14864: PPUSH
14865: LD_INT 252
14867: PPUSH
14868: LD_INT 220
14870: PPUSH
14871: CALL_OW 297
14875: PUSH
14876: LD_INT 6
14878: GREATER
14879: AND
14880: IFFALSE 14897
// ComMoveXY ( Omar , 252 , 220 ) ;
14882: LD_EXP 58
14886: PPUSH
14887: LD_INT 252
14889: PPUSH
14890: LD_INT 220
14892: PPUSH
14893: CALL_OW 111
// until See ( 7 , Omar ) ;
14897: LD_INT 7
14899: PPUSH
14900: LD_EXP 58
14904: PPUSH
14905: CALL_OW 292
14909: IFFALSE 14834
// CenterNowOnUnits ( Omar ) ;
14911: LD_EXP 58
14915: PPUSH
14916: CALL_OW 87
// DialogueOn ;
14920: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14924: LD_EXP 58
14928: PPUSH
14929: LD_STRING DOmar-Omar-1
14931: PPUSH
14932: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14936: LD_EXP 21
14940: PPUSH
14941: LD_STRING DOmar-JMM-1
14943: PPUSH
14944: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14948: LD_EXP 58
14952: PPUSH
14953: LD_STRING DOmar-Omar-2
14955: PPUSH
14956: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14960: LD_EXP 21
14964: PPUSH
14965: LD_STRING DOmar-JMM-2
14967: PPUSH
14968: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14972: LD_EXP 58
14976: PPUSH
14977: LD_STRING DOmar-Omar-3
14979: PPUSH
14980: CALL_OW 88
// if IsOk ( Burlak ) then
14984: LD_EXP 54
14988: PPUSH
14989: CALL_OW 302
14993: IFFALSE 15009
// Say ( Burlak , DOmar-Bur-3 ) else
14995: LD_EXP 54
14999: PPUSH
15000: LD_STRING DOmar-Bur-3
15002: PPUSH
15003: CALL_OW 88
15007: GO 15021
// Say ( JMM , DOmar-JMM-3 ) ;
15009: LD_EXP 21
15013: PPUSH
15014: LD_STRING DOmar-JMM-3
15016: PPUSH
15017: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
15021: LD_EXP 58
15025: PPUSH
15026: LD_STRING DOmar-Omar-4
15028: PPUSH
15029: CALL_OW 88
// case Query ( QAccept ) of 1 :
15033: LD_STRING QAccept
15035: PPUSH
15036: CALL_OW 97
15040: PUSH
15041: LD_INT 1
15043: DOUBLE
15044: EQUAL
15045: IFTRUE 15049
15047: GO 15085
15049: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
15050: LD_EXP 21
15054: PPUSH
15055: LD_STRING DQrAccept#1-JMM-1
15057: PPUSH
15058: CALL_OW 88
// SetSide ( Omar , 7 ) ;
15062: LD_EXP 58
15066: PPUSH
15067: LD_INT 7
15069: PPUSH
15070: CALL_OW 235
// ComStop ( Omar ) ;
15074: LD_EXP 58
15078: PPUSH
15079: CALL_OW 141
// end ; 2 :
15083: GO 15134
15085: LD_INT 2
15087: DOUBLE
15088: EQUAL
15089: IFTRUE 15093
15091: GO 15133
15093: POP
// begin if IsOk ( Burlak ) then
15094: LD_EXP 54
15098: PPUSH
15099: CALL_OW 302
15103: IFFALSE 15119
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15105: LD_EXP 54
15109: PPUSH
15110: LD_STRING DQrAccept#2-Bur-1
15112: PPUSH
15113: CALL_OW 88
15117: GO 15131
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15119: LD_EXP 21
15123: PPUSH
15124: LD_STRING DQrAccept#2-JMM-1
15126: PPUSH
15127: CALL_OW 88
// end ; end ;
15131: GO 15134
15133: POP
// DialogueOff ;
15134: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15138: LD_EXP 58
15142: PPUSH
15143: CALL_OW 255
15147: PUSH
15148: LD_INT 7
15150: EQUAL
15151: IFFALSE 15162
// begin SetAchievement ( ACH_OMAR ) ;
15153: LD_STRING ACH_OMAR
15155: PPUSH
15156: CALL_OW 543
// exit ;
15160: GO 15177
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
15162: LD_EXP 58
15166: PPUSH
15167: LD_INT 202
15169: PPUSH
15170: LD_INT 115
15172: PPUSH
15173: CALL_OW 111
// end ;
15177: END
// every 0 0$1 trigger not omarKilled and russianCapitulated and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15178: LD_EXP 20
15182: NOT
15183: PUSH
15184: LD_EXP 7
15188: AND
15189: PUSH
15190: LD_EXP 58
15194: PPUSH
15195: CALL_OW 302
15199: PUSH
15200: LD_EXP 58
15204: PPUSH
15205: CALL_OW 255
15209: PUSH
15210: LD_INT 7
15212: EQUAL
15213: AND
15214: PUSH
15215: LD_EXP 19
15219: NOT
15220: OR
15221: AND
15222: IFFALSE 15740
15224: GO 15226
15226: DISABLE
15227: LD_INT 0
15229: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15230: LD_EXP 19
15234: NOT
15235: PUSH
15236: LD_EXP 20
15240: NOT
15241: AND
15242: IFFALSE 15248
// PrepareOmarAli2 ;
15244: CALL 7676 0 0
// wait ( 0 0$2 ) ;
15248: LD_INT 70
15250: PPUSH
15251: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15255: LD_EXP 58
15259: PPUSH
15260: LD_INT 5
15262: PPUSH
15263: CALL_OW 235
// if IsInUnit ( Omar ) then
15267: LD_EXP 58
15271: PPUSH
15272: CALL_OW 310
15276: IFFALSE 15287
// ComExitVehicle ( Omar ) ;
15278: LD_EXP 58
15282: PPUSH
15283: CALL_OW 121
// if IsInUnit ( Omar ) then
15287: LD_EXP 58
15291: PPUSH
15292: CALL_OW 310
15296: IFFALSE 15307
// ComExitBuilding ( Omar ) ;
15298: LD_EXP 58
15302: PPUSH
15303: CALL_OW 122
// wait ( 0 0$1 ) ;
15307: LD_INT 35
15309: PPUSH
15310: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15314: LD_EXP 58
15318: PPUSH
15319: LD_INT 203
15321: PPUSH
15322: LD_INT 120
15324: PPUSH
15325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15329: LD_INT 35
15331: PPUSH
15332: CALL_OW 67
// if omarKilled then
15336: LD_EXP 20
15340: IFFALSE 15344
// exit ;
15342: GO 15740
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15344: LD_EXP 58
15348: PPUSH
15349: CALL_OW 306
15353: PUSH
15354: LD_EXP 58
15358: PPUSH
15359: LD_INT 203
15361: PPUSH
15362: LD_INT 120
15364: PPUSH
15365: CALL_OW 297
15369: PUSH
15370: LD_INT 20
15372: LESS
15373: OR
15374: IFFALSE 15329
// DialogueOn ;
15376: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15380: LD_EXP 58
15384: PPUSH
15385: CALL_OW 250
15389: PPUSH
15390: LD_EXP 58
15394: PPUSH
15395: CALL_OW 251
15399: PPUSH
15400: LD_INT 7
15402: PPUSH
15403: LD_INT 6
15405: NEG
15406: PPUSH
15407: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15411: LD_EXP 58
15415: PPUSH
15416: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15420: LD_EXP 21
15424: PPUSH
15425: LD_STRING DOmarContam-JMM-1
15427: PPUSH
15428: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15432: LD_EXP 58
15436: PPUSH
15437: LD_STRING DOmarContam-Omar-1
15439: PPUSH
15440: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15444: LD_EXP 21
15448: PPUSH
15449: LD_STRING DOmarContam-JMM-2
15451: PPUSH
15452: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15456: LD_EXP 58
15460: PPUSH
15461: CALL_OW 250
15465: PPUSH
15466: LD_EXP 58
15470: PPUSH
15471: CALL_OW 251
15475: PPUSH
15476: LD_INT 7
15478: PPUSH
15479: CALL_OW 331
// DialogueOff ;
15483: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15487: LD_INT 5
15489: PPUSH
15490: LD_INT 7
15492: PPUSH
15493: LD_INT 2
15495: PPUSH
15496: LD_INT 1
15498: PPUSH
15499: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15503: LD_INT 105
15505: PPUSH
15506: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15510: LD_EXP 58
15514: PPUSH
15515: LD_INT 203
15517: PPUSH
15518: LD_INT 120
15520: PPUSH
15521: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15525: LD_EXP 58
15529: PPUSH
15530: LD_INT 203
15532: PPUSH
15533: LD_INT 120
15535: PPUSH
15536: CALL_OW 307
15540: IFFALSE 15503
// ComHold ( Omar ) ;
15542: LD_EXP 58
15546: PPUSH
15547: CALL_OW 140
// InGameOn ;
15551: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15555: LD_INT 203
15557: PPUSH
15558: LD_INT 120
15560: PPUSH
15561: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15565: LD_INT 203
15567: PPUSH
15568: LD_INT 120
15570: PPUSH
15571: LD_INT 7
15573: PPUSH
15574: LD_INT 30
15576: NEG
15577: PPUSH
15578: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15582: LD_ADDR_VAR 0 1
15586: PUSH
15587: LD_INT 203
15589: PUSH
15590: LD_INT 120
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: PUSH
15597: LD_INT 202
15599: PUSH
15600: LD_INT 125
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PUSH
15607: LD_INT 195
15609: PUSH
15610: LD_INT 117
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 216
15619: PUSH
15620: LD_INT 123
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: LD_INT 224
15629: PUSH
15630: LD_INT 131
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: LD_INT 212
15639: PUSH
15640: LD_INT 133
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: LIST
15651: LIST
15652: LIST
15653: LIST
15654: PUSH
15655: FOR_IN
15656: IFFALSE 15692
// begin wait ( 0 0$0.5 ) ;
15658: LD_INT 18
15660: PPUSH
15661: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15665: LD_VAR 0 1
15669: PUSH
15670: LD_INT 1
15672: ARRAY
15673: PPUSH
15674: LD_VAR 0 1
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: LD_INT 5
15685: PPUSH
15686: CALL_OW 495
// end ;
15690: GO 15655
15692: POP
15693: POP
// KillUnit ( Omar ) ;
15694: LD_EXP 58
15698: PPUSH
15699: CALL_OW 66
// wait ( 0 0$3 ) ;
15703: LD_INT 105
15705: PPUSH
15706: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15710: LD_EXP 21
15714: PPUSH
15715: LD_STRING D16b-JMM-1
15717: PPUSH
15718: CALL_OW 91
// wait ( 0 0$2 ) ;
15722: LD_INT 70
15724: PPUSH
15725: CALL_OW 67
// InGameOff ;
15729: CALL_OW 9
// YouLost ( MothContaminate ) ;
15733: LD_STRING MothContaminate
15735: PPUSH
15736: CALL_OW 104
// end ;
15740: PPOPN 1
15742: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15743: LD_EXP 4
15747: NOT
15748: PUSH
15749: LD_INT 22
15751: PUSH
15752: LD_INT 1
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: LD_INT 34
15761: PUSH
15762: LD_INT 8
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: AND
15778: IFFALSE 15897
15780: GO 15782
15782: DISABLE
// begin wait ( 0 0$10 ) ;
15783: LD_INT 350
15785: PPUSH
15786: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15790: LD_EXP 57
15794: PPUSH
15795: CALL_OW 302
15799: NOT
15800: PUSH
15801: LD_INT 22
15803: PUSH
15804: LD_INT 1
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 34
15813: PUSH
15814: LD_INT 8
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PPUSH
15825: CALL_OW 69
15829: NOT
15830: OR
15831: IFFALSE 15835
// exit ;
15833: GO 15897
// DialogueOn ;
15835: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15839: LD_EXP 57
15843: PPUSH
15844: LD_STRING DWinAmericans-Pow-1
15846: PPUSH
15847: CALL_OW 94
// if IsOk ( Burlak ) then
15851: LD_EXP 54
15855: PPUSH
15856: CALL_OW 302
15860: IFFALSE 15874
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15862: LD_EXP 54
15866: PPUSH
15867: LD_STRING DWinAmericans-Bur-1
15869: PPUSH
15870: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15874: LD_EXP 21
15878: PPUSH
15879: LD_STRING DWinAmericans-JMM-1
15881: PPUSH
15882: CALL_OW 88
// DialogueOff ;
15886: CALL_OW 7
// YouLost ( AmBomb ) ;
15890: LD_STRING AmBomb
15892: PPUSH
15893: CALL_OW 104
// end ;
15897: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15898: LD_EXP 2
15902: NOT
15903: PUSH
15904: LD_INT 22
15906: PUSH
15907: LD_INT 3
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: LD_INT 34
15916: PUSH
15917: LD_INT 48
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PPUSH
15928: CALL_OW 69
15932: AND
15933: IFFALSE 16052
15935: GO 15937
15937: DISABLE
// begin wait ( 0 0$10 ) ;
15938: LD_INT 350
15940: PPUSH
15941: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15945: LD_EXP 62
15949: PPUSH
15950: CALL_OW 302
15954: NOT
15955: PUSH
15956: LD_INT 22
15958: PUSH
15959: LD_INT 3
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 34
15968: PUSH
15969: LD_INT 48
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PPUSH
15980: CALL_OW 69
15984: NOT
15985: OR
15986: IFFALSE 15990
// exit ;
15988: GO 16052
// DialogueOn ;
15990: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15994: LD_EXP 62
15998: PPUSH
15999: LD_STRING DWinRussians-Pla-1
16001: PPUSH
16002: CALL_OW 94
// if IsOk ( Burlak ) then
16006: LD_EXP 54
16010: PPUSH
16011: CALL_OW 302
16015: IFFALSE 16029
// Say ( Burlak , DWinRussians-Bur-1 ) ;
16017: LD_EXP 54
16021: PPUSH
16022: LD_STRING DWinRussians-Bur-1
16024: PPUSH
16025: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
16029: LD_EXP 21
16033: PPUSH
16034: LD_STRING DWinRussians-JMM-1
16036: PPUSH
16037: CALL_OW 88
// DialogueOff ;
16041: CALL_OW 7
// YouLost ( RuBomb ) ;
16045: LD_STRING RuBomb
16047: PPUSH
16048: CALL_OW 104
// end ;
16052: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
16053: LD_INT 7
16055: PPUSH
16056: LD_INT 22
16058: PUSH
16059: LD_INT 7
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PPUSH
16066: CALL_OW 70
16070: PUSH
16071: LD_EXP 4
16075: NOT
16076: AND
16077: IFFALSE 16106
16079: GO 16081
16081: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
16082: LD_EXP 57
16086: PPUSH
16087: LD_STRING DSurrenderAmericans-Pow-1
16089: PPUSH
16090: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
16094: LD_EXP 21
16098: PPUSH
16099: LD_STRING DSurrenderAmericans-JMM-1
16101: PPUSH
16102: CALL_OW 88
// end ;
16106: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16107: LD_INT 2
16109: PPUSH
16110: LD_INT 22
16112: PUSH
16113: LD_INT 7
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PPUSH
16120: CALL_OW 70
16124: PUSH
16125: LD_EXP 2
16129: NOT
16130: AND
16131: PUSH
16132: LD_EXP 54
16136: AND
16137: IFFALSE 16166
16139: GO 16141
16141: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16142: LD_EXP 62
16146: PPUSH
16147: LD_STRING DSurrenderRussians-Pla-1
16149: PPUSH
16150: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16154: LD_EXP 54
16158: PPUSH
16159: LD_STRING DSurrenderRussians-Bur-1
16161: PPUSH
16162: CALL_OW 88
// end ;
16166: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16167: LD_EXP 4
16171: IFFALSE 16610
16173: GO 16175
16175: DISABLE
16176: LD_INT 0
16178: PPUSH
16179: PPUSH
16180: PPUSH
// begin MC_Kill ( 4 ) ;
16181: LD_INT 4
16183: PPUSH
16184: CALL 23126 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16188: LD_INT 1
16190: PPUSH
16191: LD_INT 7
16193: PPUSH
16194: LD_INT 1
16196: PPUSH
16197: LD_INT 1
16199: PPUSH
16200: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16204: LD_ADDR_VAR 0 3
16208: PUSH
16209: LD_INT 22
16211: PUSH
16212: LD_INT 1
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: PUSH
16219: LD_INT 50
16221: PUSH
16222: EMPTY
16223: LIST
16224: PUSH
16225: LD_INT 26
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: LD_INT 23
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: PPUSH
16251: CALL_OW 69
16255: PUSH
16256: LD_EXP 57
16260: PUSH
16261: LD_EXP 29
16265: PUSH
16266: LD_EXP 26
16270: PUSH
16271: LD_EXP 25
16275: PUSH
16276: LD_EXP 32
16280: PUSH
16281: LD_EXP 30
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: DIFF
16294: ST_TO_ADDR
// if not speaker then
16295: LD_VAR 0 3
16299: NOT
16300: IFFALSE 16340
// begin uc_side := 1 ;
16302: LD_ADDR_OWVAR 20
16306: PUSH
16307: LD_INT 1
16309: ST_TO_ADDR
// uc_nation := 1 ;
16310: LD_ADDR_OWVAR 21
16314: PUSH
16315: LD_INT 1
16317: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16318: LD_INT 1
16320: PPUSH
16321: LD_INT 0
16323: PPUSH
16324: CALL_OW 381
// speaker := CreateHuman ;
16328: LD_ADDR_VAR 0 3
16332: PUSH
16333: CALL_OW 44
16337: ST_TO_ADDR
// end else
16338: GO 16354
// speaker := speaker [ 1 ] ;
16340: LD_ADDR_VAR 0 3
16344: PUSH
16345: LD_VAR 0 3
16349: PUSH
16350: LD_INT 1
16352: ARRAY
16353: ST_TO_ADDR
// DialogueOn ;
16354: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16358: LD_VAR 0 3
16362: PPUSH
16363: LD_STRING DSurrenderAmericans-Sol1-1a
16365: PPUSH
16366: CALL_OW 94
// DialogueOff ;
16370: CALL_OW 7
// americanCapitulated := true ;
16374: LD_ADDR_EXP 6
16378: PUSH
16379: LD_INT 1
16381: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16382: LD_ADDR_VAR 0 2
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 21
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PPUSH
16411: CALL_OW 69
16415: PUSH
16416: LD_INT 22
16418: PUSH
16419: LD_INT 1
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: LD_INT 21
16428: PUSH
16429: LD_INT 2
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: PPUSH
16447: CALL_OW 69
16451: ADD
16452: ST_TO_ADDR
// if tmp then
16453: LD_VAR 0 2
16457: IFFALSE 16610
// repeat wait ( 0 0$1 ) ;
16459: LD_INT 35
16461: PPUSH
16462: CALL_OW 67
// for i in tmp do
16466: LD_ADDR_VAR 0 1
16470: PUSH
16471: LD_VAR 0 2
16475: PUSH
16476: FOR_IN
16477: IFFALSE 16559
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16479: LD_VAR 0 1
16483: PPUSH
16484: CALL_OW 310
16488: PUSH
16489: LD_VAR 0 1
16493: PPUSH
16494: CALL_OW 310
16498: PPUSH
16499: CALL_OW 247
16503: PUSH
16504: LD_INT 3
16506: EQUAL
16507: AND
16508: IFFALSE 16519
// ComExitBuilding ( i ) ;
16510: LD_VAR 0 1
16514: PPUSH
16515: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_INT 122
16526: PPUSH
16527: LD_INT 242
16529: PPUSH
16530: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_INT 35
16541: PPUSH
16542: CALL_OW 308
16546: IFFALSE 16557
// RemoveUnit ( i ) ;
16548: LD_VAR 0 1
16552: PPUSH
16553: CALL_OW 64
// end ;
16557: GO 16476
16559: POP
16560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16561: LD_INT 22
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 21
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 33
16586: PUSH
16587: LD_INT 1
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PPUSH
16603: CALL_OW 69
16607: NOT
16608: IFFALSE 16459
// end ;
16610: PPOPN 3
16612: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16613: LD_EXP 2
16617: IFFALSE 17066
16619: GO 16621
16621: DISABLE
16622: LD_INT 0
16624: PPUSH
16625: PPUSH
16626: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16627: LD_INT 35
16629: PPUSH
16630: CALL_OW 67
// until IsDead ( Yakotich ) ;
16634: LD_EXP 63
16638: PPUSH
16639: CALL_OW 301
16643: IFFALSE 16627
// MC_Kill ( 2 ) ;
16645: LD_INT 2
16647: PPUSH
16648: CALL 23126 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16652: LD_INT 3
16654: PPUSH
16655: LD_INT 7
16657: PPUSH
16658: LD_INT 1
16660: PPUSH
16661: LD_INT 1
16663: PPUSH
16664: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16668: LD_ADDR_VAR 0 3
16672: PUSH
16673: LD_INT 22
16675: PUSH
16676: LD_INT 3
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: PUSH
16683: LD_INT 50
16685: PUSH
16686: EMPTY
16687: LIST
16688: PUSH
16689: LD_INT 26
16691: PUSH
16692: LD_INT 1
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: LD_INT 23
16701: PUSH
16702: LD_INT 3
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PPUSH
16715: CALL_OW 69
16719: PUSH
16720: LD_EXP 62
16724: DIFF
16725: ST_TO_ADDR
// if not speaker then
16726: LD_VAR 0 3
16730: NOT
16731: IFFALSE 16771
// begin uc_side := 3 ;
16733: LD_ADDR_OWVAR 20
16737: PUSH
16738: LD_INT 3
16740: ST_TO_ADDR
// uc_nation := 3 ;
16741: LD_ADDR_OWVAR 21
16745: PUSH
16746: LD_INT 3
16748: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16749: LD_INT 1
16751: PPUSH
16752: LD_INT 0
16754: PPUSH
16755: CALL_OW 381
// speaker := CreateHuman ;
16759: LD_ADDR_VAR 0 3
16763: PUSH
16764: CALL_OW 44
16768: ST_TO_ADDR
// end else
16769: GO 16785
// speaker := speaker [ 1 ] ;
16771: LD_ADDR_VAR 0 3
16775: PUSH
16776: LD_VAR 0 3
16780: PUSH
16781: LD_INT 1
16783: ARRAY
16784: ST_TO_ADDR
// DialogueOn ;
16785: CALL_OW 6
// if IsOK ( Burlak ) then
16789: LD_EXP 54
16793: PPUSH
16794: CALL_OW 302
16798: IFFALSE 16814
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16800: LD_VAR 0 3
16804: PPUSH
16805: LD_STRING DSurrenderRussians-RSol1-1
16807: PPUSH
16808: CALL_OW 94
16812: GO 16826
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16814: LD_VAR 0 3
16818: PPUSH
16819: LD_STRING DSurrenderRussians-RSol1-1a
16821: PPUSH
16822: CALL_OW 94
// DialogueOff ;
16826: CALL_OW 7
// russianCapitulated := true ;
16830: LD_ADDR_EXP 7
16834: PUSH
16835: LD_INT 1
16837: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: LD_INT 22
16845: PUSH
16846: LD_INT 3
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: LD_INT 21
16855: PUSH
16856: LD_INT 1
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PPUSH
16867: CALL_OW 69
16871: PUSH
16872: LD_INT 22
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: LD_INT 21
16884: PUSH
16885: LD_INT 2
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: LD_INT 1
16894: PUSH
16895: EMPTY
16896: LIST
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: LIST
16902: PPUSH
16903: CALL_OW 69
16907: ADD
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 2
16913: IFFALSE 17066
// repeat wait ( 0 0$1 ) ;
16915: LD_INT 35
16917: PPUSH
16918: CALL_OW 67
// for i in tmp do
16922: LD_ADDR_VAR 0 1
16926: PUSH
16927: LD_VAR 0 2
16931: PUSH
16932: FOR_IN
16933: IFFALSE 17015
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16935: LD_VAR 0 1
16939: PPUSH
16940: CALL_OW 310
16944: PUSH
16945: LD_VAR 0 1
16949: PPUSH
16950: CALL_OW 310
16954: PPUSH
16955: CALL_OW 247
16959: PUSH
16960: LD_INT 3
16962: EQUAL
16963: AND
16964: IFFALSE 16975
// ComExitBuilding ( i ) ;
16966: LD_VAR 0 1
16970: PPUSH
16971: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16975: LD_VAR 0 1
16979: PPUSH
16980: LD_INT 154
16982: PPUSH
16983: LD_INT 1
16985: PPUSH
16986: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16990: LD_VAR 0 1
16994: PPUSH
16995: LD_INT 36
16997: PPUSH
16998: CALL_OW 308
17002: IFFALSE 17013
// RemoveUnit ( i ) ;
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 64
// end ;
17013: GO 16932
17015: POP
17016: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17017: LD_INT 22
17019: PUSH
17020: LD_INT 3
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 2
17029: PUSH
17030: LD_INT 21
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: PUSH
17040: LD_INT 33
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PPUSH
17059: CALL_OW 69
17063: NOT
17064: IFFALSE 16915
// end ;
17066: PPOPN 3
17068: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
17069: LD_INT 22
17071: PUSH
17072: LD_INT 8
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 21
17081: PUSH
17082: LD_INT 1
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 23
17091: PUSH
17092: LD_INT 2
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PUSH
17109: LD_INT 18
17111: LESS
17112: PUSH
17113: LD_EXP 60
17117: PPUSH
17118: CALL_OW 301
17122: OR
17123: PUSH
17124: LD_INT 324
17126: PPUSH
17127: CALL_OW 255
17131: PUSH
17132: LD_INT 7
17134: EQUAL
17135: OR
17136: IFFALSE 17149
17138: GO 17140
17140: DISABLE
// legionDestroyed := true ;
17141: LD_ADDR_EXP 3
17145: PUSH
17146: LD_INT 1
17148: ST_TO_ADDR
17149: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17150: LD_INT 22
17152: PUSH
17153: LD_INT 2
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: PUSH
17160: LD_INT 21
17162: PUSH
17163: LD_INT 1
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 23
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: PPUSH
17185: CALL_OW 69
17189: PUSH
17190: LD_INT 9
17192: LESS
17193: PUSH
17194: LD_INT 503
17196: PPUSH
17197: CALL_OW 301
17201: OR
17202: PUSH
17203: LD_INT 503
17205: PPUSH
17206: CALL_OW 255
17210: PUSH
17211: LD_INT 7
17213: EQUAL
17214: OR
17215: IFFALSE 17228
17217: GO 17219
17219: DISABLE
// arabianDestroyed := true ;
17220: LD_ADDR_EXP 5
17224: PUSH
17225: LD_INT 1
17227: ST_TO_ADDR
17228: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17229: LD_EXP 5
17233: IFFALSE 17477
17235: GO 17237
17237: DISABLE
17238: LD_INT 0
17240: PPUSH
17241: PPUSH
// begin MC_Kill ( 1 ) ;
17242: LD_INT 1
17244: PPUSH
17245: CALL 23126 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17249: LD_ADDR_VAR 0 2
17253: PUSH
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: LD_INT 21
17266: PUSH
17267: LD_INT 1
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PPUSH
17278: CALL_OW 69
17282: PUSH
17283: LD_INT 22
17285: PUSH
17286: LD_INT 2
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: PUSH
17293: LD_INT 21
17295: PUSH
17296: LD_INT 2
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 1
17305: PUSH
17306: EMPTY
17307: LIST
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: LIST
17313: PPUSH
17314: CALL_OW 69
17318: ADD
17319: ST_TO_ADDR
// if tmp then
17320: LD_VAR 0 2
17324: IFFALSE 17477
// repeat wait ( 0 0$1 ) ;
17326: LD_INT 35
17328: PPUSH
17329: CALL_OW 67
// for i in tmp do
17333: LD_ADDR_VAR 0 1
17337: PUSH
17338: LD_VAR 0 2
17342: PUSH
17343: FOR_IN
17344: IFFALSE 17426
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 310
17355: PUSH
17356: LD_VAR 0 1
17360: PPUSH
17361: CALL_OW 310
17365: PPUSH
17366: CALL_OW 247
17370: PUSH
17371: LD_INT 3
17373: EQUAL
17374: AND
17375: IFFALSE 17386
// ComExitBuilding ( i ) ;
17377: LD_VAR 0 1
17381: PPUSH
17382: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_INT 254
17393: PPUSH
17394: LD_INT 268
17396: PPUSH
17397: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 34
17408: PPUSH
17409: CALL_OW 308
17413: IFFALSE 17424
// RemoveUnit ( i ) ;
17415: LD_VAR 0 1
17419: PPUSH
17420: CALL_OW 64
// end ;
17424: GO 17343
17426: POP
17427: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17428: LD_INT 22
17430: PUSH
17431: LD_INT 2
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: PUSH
17438: LD_INT 2
17440: PUSH
17441: LD_INT 21
17443: PUSH
17444: LD_INT 1
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: PUSH
17451: LD_INT 33
17453: PUSH
17454: LD_INT 1
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: LIST
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: PPUSH
17470: CALL_OW 69
17474: NOT
17475: IFFALSE 17326
// end ;
17477: PPOPN 2
17479: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17480: LD_EXP 3
17484: IFFALSE 17836
17486: GO 17488
17488: DISABLE
17489: LD_INT 0
17491: PPUSH
17492: PPUSH
// begin MC_Kill ( 3 ) ;
17493: LD_INT 3
17495: PPUSH
17496: CALL 23126 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17500: LD_INT 8
17502: PPUSH
17503: LD_INT 7
17505: PPUSH
17506: LD_INT 1
17508: PPUSH
17509: LD_INT 1
17511: PPUSH
17512: CALL_OW 80
// DialogueOn ;
17516: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17520: LD_EXP 59
17524: PPUSH
17525: LD_STRING D15-Szulc-1
17527: PPUSH
17528: CALL_OW 94
// DialogueOff ;
17532: CALL_OW 7
// legionCapitulated := true ;
17536: LD_ADDR_EXP 8
17540: PUSH
17541: LD_INT 1
17543: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17544: LD_ADDR_VAR 0 1
17548: PUSH
17549: LD_INT 22
17551: PUSH
17552: LD_INT 8
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PUSH
17559: LD_INT 21
17561: PUSH
17562: LD_INT 3
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: PUSH
17569: LD_INT 23
17571: PUSH
17572: LD_INT 3
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: PPUSH
17584: CALL_OW 69
17588: PUSH
17589: FOR_IN
17590: IFFALSE 17606
// SetLives ( i , 3 ) ;
17592: LD_VAR 0 1
17596: PPUSH
17597: LD_INT 3
17599: PPUSH
17600: CALL_OW 234
17604: GO 17589
17606: POP
17607: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17608: LD_ADDR_VAR 0 2
17612: PUSH
17613: LD_INT 22
17615: PUSH
17616: LD_INT 8
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PUSH
17623: LD_INT 21
17625: PUSH
17626: LD_INT 1
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: PPUSH
17637: CALL_OW 69
17641: PUSH
17642: LD_INT 22
17644: PUSH
17645: LD_INT 8
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PUSH
17652: LD_INT 21
17654: PUSH
17655: LD_INT 2
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: LD_INT 1
17664: PUSH
17665: EMPTY
17666: LIST
17667: PUSH
17668: EMPTY
17669: LIST
17670: LIST
17671: LIST
17672: PPUSH
17673: CALL_OW 69
17677: ADD
17678: ST_TO_ADDR
// if tmp then
17679: LD_VAR 0 2
17683: IFFALSE 17836
// repeat wait ( 0 0$1 ) ;
17685: LD_INT 35
17687: PPUSH
17688: CALL_OW 67
// for i in tmp do
17692: LD_ADDR_VAR 0 1
17696: PUSH
17697: LD_VAR 0 2
17701: PUSH
17702: FOR_IN
17703: IFFALSE 17785
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17705: LD_VAR 0 1
17709: PPUSH
17710: CALL_OW 310
17714: PUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL_OW 310
17724: PPUSH
17725: CALL_OW 247
17729: PUSH
17730: LD_INT 3
17732: EQUAL
17733: AND
17734: IFFALSE 17745
// ComExitBuilding ( i ) ;
17736: LD_VAR 0 1
17740: PPUSH
17741: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_INT 10
17752: PPUSH
17753: LD_INT 1
17755: PPUSH
17756: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17760: LD_VAR 0 1
17764: PPUSH
17765: LD_INT 32
17767: PPUSH
17768: CALL_OW 308
17772: IFFALSE 17783
// RemoveUnit ( i ) ;
17774: LD_VAR 0 1
17778: PPUSH
17779: CALL_OW 64
// end ;
17783: GO 17702
17785: POP
17786: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17787: LD_INT 22
17789: PUSH
17790: LD_INT 8
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PUSH
17797: LD_INT 2
17799: PUSH
17800: LD_INT 21
17802: PUSH
17803: LD_INT 1
17805: PUSH
17806: EMPTY
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 33
17812: PUSH
17813: LD_INT 1
17815: PUSH
17816: EMPTY
17817: LIST
17818: LIST
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PPUSH
17829: CALL_OW 69
17833: NOT
17834: IFFALSE 17685
// end ;
17836: PPOPN 2
17838: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17839: LD_EXP 5
17843: NOT
17844: PUSH
17845: LD_OWVAR 1
17849: PUSH
17850: LD_INT 63000
17852: GREATEREQUAL
17853: AND
17854: PUSH
17855: LD_OWVAR 67
17859: PUSH
17860: LD_INT 3
17862: LESS
17863: AND
17864: IFFALSE 17873
17866: GO 17868
17868: DISABLE
// AllianceSupport ;
17869: CALL 4711 0 0
17873: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17874: LD_EXP 4
17878: PUSH
17879: LD_EXP 2
17883: AND
17884: PUSH
17885: LD_EXP 3
17889: AND
17890: PUSH
17891: LD_EXP 5
17895: AND
17896: PUSH
17897: LD_EXP 6
17901: AND
17902: PUSH
17903: LD_EXP 7
17907: AND
17908: PUSH
17909: LD_EXP 8
17913: AND
17914: PUSH
17915: LD_EXP 58
17919: PPUSH
17920: CALL_OW 255
17924: PUSH
17925: LD_INT 5
17927: NONEQUAL
17928: PUSH
17929: LD_EXP 20
17933: OR
17934: PUSH
17935: LD_EXP 58
17939: PPUSH
17940: CALL_OW 305
17944: NOT
17945: OR
17946: AND
17947: IFFALSE 19532
17949: GO 17951
17951: DISABLE
17952: LD_INT 0
17954: PPUSH
17955: PPUSH
// begin wait ( 0 0$5 ) ;
17956: LD_INT 175
17958: PPUSH
17959: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
17963: LD_INT 22
17965: PUSH
17966: LD_INT 7
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PUSH
17973: LD_INT 21
17975: PUSH
17976: LD_INT 1
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PUSH
17983: LD_INT 23
17985: PUSH
17986: LD_INT 1
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 50
17995: PUSH
17996: EMPTY
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: PPUSH
18005: CALL_OW 69
18009: PPUSH
18010: CALL 55679 0 1
18014: PUSH
18015: LD_INT 3
18017: LESS
18018: IFFALSE 18029
// begin YouLost ( LostVictory ) ;
18020: LD_STRING LostVictory
18022: PPUSH
18023: CALL_OW 104
// exit ;
18027: GO 19532
// end ; music_class := 5 ;
18029: LD_ADDR_OWVAR 72
18033: PUSH
18034: LD_INT 5
18036: ST_TO_ADDR
// music_nat := 5 ;
18037: LD_ADDR_OWVAR 71
18041: PUSH
18042: LD_INT 5
18044: ST_TO_ADDR
// if vehicleLostCounter < 3 then
18045: LD_EXP 15
18049: PUSH
18050: LD_INT 3
18052: LESS
18053: IFFALSE 18062
// SetAchievement ( ACH_ECONOMY ) ;
18055: LD_STRING ACH_ECONOMY
18057: PPUSH
18058: CALL_OW 543
// if tick < 60 60$00 then
18062: LD_OWVAR 1
18066: PUSH
18067: LD_INT 126000
18069: LESS
18070: IFFALSE 18086
// begin wait ( 3 ) ;
18072: LD_INT 3
18074: PPUSH
18075: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
18079: LD_STRING ACH_ASPEED_19
18081: PPUSH
18082: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
18086: LD_EXP 21
18090: PPUSH
18091: CALL_OW 87
// InGameOn ;
18095: CALL_OW 8
// DialogueOn ;
18099: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18103: LD_EXP 21
18107: PPUSH
18108: LD_STRING DEnd-JMM-JMM-1
18110: PPUSH
18111: CALL_OW 88
// if Joan then
18115: LD_EXP 36
18119: IFFALSE 18135
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18121: LD_EXP 36
18125: PPUSH
18126: LD_STRING DEnd-JMM-Joan-1
18128: PPUSH
18129: CALL_OW 88
18133: GO 18179
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18135: LD_EXP 23
18139: PUSH
18140: LD_EXP 23
18144: PPUSH
18145: CALL_OW 255
18149: PUSH
18150: LD_INT 7
18152: EQUAL
18153: AND
18154: PUSH
18155: LD_EXP 23
18159: PPUSH
18160: CALL_OW 305
18164: AND
18165: IFFALSE 18179
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18167: LD_EXP 23
18171: PPUSH
18172: LD_STRING DEnd-JMM-Lisa-1
18174: PPUSH
18175: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18179: LD_EXP 33
18183: PUSH
18184: LD_EXP 33
18188: PPUSH
18189: CALL_OW 305
18193: AND
18194: IFFALSE 18208
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18196: LD_EXP 33
18200: PPUSH
18201: LD_STRING DEnd-JMM-Frank-1
18203: PPUSH
18204: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18208: LD_EXP 26
18212: PUSH
18213: LD_EXP 26
18217: PPUSH
18218: CALL_OW 255
18222: PUSH
18223: LD_INT 7
18225: EQUAL
18226: AND
18227: PUSH
18228: LD_EXP 26
18232: PPUSH
18233: CALL_OW 305
18237: AND
18238: IFFALSE 18252
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18240: LD_EXP 26
18244: PPUSH
18245: LD_STRING DEnd-JMM-Cyrus-1
18247: PPUSH
18248: CALL_OW 88
// if Burlak then
18252: LD_EXP 54
18256: IFFALSE 18270
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18258: LD_EXP 54
18262: PPUSH
18263: LD_STRING DEnd-JMM-Bur-1
18265: PPUSH
18266: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18270: LD_EXP 36
18274: PUSH
18275: LD_EXP 23
18279: AND
18280: PUSH
18281: LD_EXP 23
18285: PPUSH
18286: CALL_OW 255
18290: PUSH
18291: LD_INT 7
18293: EQUAL
18294: AND
18295: PUSH
18296: LD_EXP 23
18300: PPUSH
18301: CALL_OW 305
18305: AND
18306: PUSH
18307: LD_EXP 54
18311: PPUSH
18312: CALL_OW 302
18316: AND
18317: IFFALSE 18331
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18319: LD_EXP 23
18323: PPUSH
18324: LD_STRING DEnd-Burlak-Lisa-1
18326: PPUSH
18327: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18331: LD_EXP 55
18335: PUSH
18336: LD_EXP 55
18340: PPUSH
18341: CALL_OW 305
18345: AND
18346: IFFALSE 18360
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18348: LD_EXP 55
18352: PPUSH
18353: LD_STRING DEnd-JMM-Bel-1
18355: PPUSH
18356: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18360: LD_EXP 56
18364: PUSH
18365: LD_EXP 56
18369: PPUSH
18370: CALL_OW 305
18374: AND
18375: IFFALSE 18389
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18377: LD_EXP 56
18381: PPUSH
18382: LD_STRING DEnd-JMM-Gny-1
18384: PPUSH
18385: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18389: LD_EXP 31
18393: PUSH
18394: LD_EXP 31
18398: PPUSH
18399: CALL_OW 255
18403: PUSH
18404: LD_INT 7
18406: EQUAL
18407: AND
18408: PUSH
18409: LD_EXP 31
18413: PPUSH
18414: CALL_OW 305
18418: AND
18419: IFFALSE 18433
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18421: LD_EXP 31
18425: PPUSH
18426: LD_STRING DEnd-JMM-Corn-1
18428: PPUSH
18429: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18433: LD_EXP 24
18437: PUSH
18438: LD_EXP 24
18442: PPUSH
18443: CALL_OW 255
18447: PUSH
18448: LD_INT 7
18450: EQUAL
18451: AND
18452: PUSH
18453: LD_EXP 24
18457: PPUSH
18458: CALL_OW 305
18462: AND
18463: IFFALSE 18477
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18465: LD_EXP 24
18469: PPUSH
18470: LD_STRING DEnd-JMM-Don-1
18472: PPUSH
18473: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18477: LD_EXP 25
18481: PUSH
18482: LD_EXP 25
18486: PPUSH
18487: CALL_OW 255
18491: PUSH
18492: LD_INT 7
18494: EQUAL
18495: AND
18496: PUSH
18497: LD_EXP 25
18501: PPUSH
18502: CALL_OW 305
18506: AND
18507: IFFALSE 18521
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18509: LD_EXP 25
18513: PPUSH
18514: LD_STRING DEnd-JMM-Bobby-1
18516: PPUSH
18517: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18521: LD_EXP 27
18525: PUSH
18526: LD_EXP 27
18530: PPUSH
18531: CALL_OW 255
18535: PUSH
18536: LD_INT 7
18538: EQUAL
18539: AND
18540: PUSH
18541: LD_EXP 27
18545: PPUSH
18546: CALL_OW 305
18550: AND
18551: IFFALSE 18565
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18553: LD_EXP 27
18557: PPUSH
18558: LD_STRING DEnd-JMM-Den-1
18560: PPUSH
18561: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18565: LD_EXP 29
18569: PUSH
18570: LD_EXP 29
18574: PPUSH
18575: CALL_OW 255
18579: PUSH
18580: LD_INT 7
18582: EQUAL
18583: AND
18584: PUSH
18585: LD_EXP 29
18589: PPUSH
18590: CALL_OW 305
18594: AND
18595: IFFALSE 18609
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18597: LD_EXP 29
18601: PPUSH
18602: LD_STRING DEnd-JMM-Glad-1
18604: PPUSH
18605: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18609: LD_EXP 34
18613: PUSH
18614: LD_EXP 34
18618: PPUSH
18619: CALL_OW 255
18623: PUSH
18624: LD_INT 7
18626: EQUAL
18627: AND
18628: PUSH
18629: LD_EXP 34
18633: PPUSH
18634: CALL_OW 305
18638: AND
18639: IFFALSE 18653
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18641: LD_EXP 34
18645: PPUSH
18646: LD_STRING DEnd-JMM-Yam-1
18648: PPUSH
18649: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18653: LD_EXP 28
18657: PUSH
18658: LD_EXP 28
18662: PPUSH
18663: CALL_OW 255
18667: PUSH
18668: LD_INT 7
18670: EQUAL
18671: AND
18672: PUSH
18673: LD_EXP 28
18677: PPUSH
18678: CALL_OW 305
18682: AND
18683: IFFALSE 18697
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18685: LD_EXP 28
18689: PPUSH
18690: LD_STRING DEnd-JMM-Brown-1
18692: PPUSH
18693: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18697: LD_EXP 38
18701: PUSH
18702: LD_EXP 38
18706: PPUSH
18707: CALL_OW 255
18711: PUSH
18712: LD_INT 7
18714: EQUAL
18715: AND
18716: PUSH
18717: LD_EXP 38
18721: PPUSH
18722: CALL_OW 305
18726: AND
18727: IFFALSE 18741
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18729: LD_EXP 38
18733: PPUSH
18734: LD_STRING DEnd-JMM-Con-1
18736: PPUSH
18737: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18741: LD_EXP 32
18745: PUSH
18746: LD_EXP 32
18750: PPUSH
18751: CALL_OW 255
18755: PUSH
18756: LD_INT 7
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_EXP 32
18765: PPUSH
18766: CALL_OW 305
18770: AND
18771: IFFALSE 18785
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18773: LD_EXP 32
18777: PPUSH
18778: LD_STRING DEnd-JMM-Gary-1
18780: PPUSH
18781: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18785: LD_EXP 22
18789: PUSH
18790: LD_EXP 22
18794: PPUSH
18795: CALL_OW 305
18799: AND
18800: IFFALSE 18814
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18802: LD_EXP 22
18806: PPUSH
18807: LD_STRING DEnd-JMM-Roth-1
18809: PPUSH
18810: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18814: LD_EXP 35
18818: PUSH
18819: LD_EXP 22
18823: AND
18824: PUSH
18825: LD_EXP 35
18829: PPUSH
18830: CALL_OW 305
18834: AND
18835: IFFALSE 18849
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18837: LD_EXP 35
18841: PPUSH
18842: LD_STRING DEnd-JMM-Sim-1
18844: PPUSH
18845: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18849: LD_EXP 30
18853: PUSH
18854: LD_EXP 30
18858: PPUSH
18859: CALL_OW 255
18863: PUSH
18864: LD_INT 7
18866: EQUAL
18867: AND
18868: PUSH
18869: LD_EXP 30
18873: PPUSH
18874: CALL_OW 305
18878: AND
18879: IFFALSE 18893
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18881: LD_EXP 30
18885: PPUSH
18886: LD_STRING DEnd-JMM-VanH-1
18888: PPUSH
18889: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18893: LD_EXP 44
18897: PUSH
18898: LD_EXP 44
18902: PPUSH
18903: CALL_OW 305
18907: AND
18908: IFFALSE 18922
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18910: LD_EXP 44
18914: PPUSH
18915: LD_STRING DEnd-JMM-Dol-1
18917: PPUSH
18918: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18922: LD_EXP 34
18926: PUSH
18927: LD_EXP 34
18931: PPUSH
18932: CALL_OW 255
18936: PUSH
18937: LD_INT 7
18939: EQUAL
18940: AND
18941: PUSH
18942: LD_EXP 34
18946: PPUSH
18947: CALL_OW 305
18951: AND
18952: IFFALSE 18966
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18954: LD_EXP 34
18958: PPUSH
18959: LD_STRING DEnd-JMM-Yam-1
18961: PPUSH
18962: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18966: LD_EXP 48
18970: PUSH
18971: LD_EXP 48
18975: PPUSH
18976: CALL_OW 305
18980: AND
18981: IFFALSE 18995
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18983: LD_EXP 48
18987: PPUSH
18988: LD_STRING DEnd-JMM-Kap-1
18990: PPUSH
18991: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18995: LD_EXP 51
18999: PUSH
19000: LD_EXP 51
19004: PPUSH
19005: CALL_OW 305
19009: AND
19010: IFFALSE 19024
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
19012: LD_EXP 51
19016: PPUSH
19017: LD_STRING DEnd-JMM-Kov-1
19019: PPUSH
19020: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
19024: LD_EXP 46
19028: PUSH
19029: LD_EXP 46
19033: PPUSH
19034: CALL_OW 305
19038: AND
19039: IFFALSE 19053
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
19041: LD_EXP 46
19045: PPUSH
19046: LD_STRING DEnd-JMM-Sch-1
19048: PPUSH
19049: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
19053: LD_EXP 42
19057: PUSH
19058: LD_EXP 42
19062: PPUSH
19063: CALL_OW 305
19067: AND
19068: PUSH
19069: LD_EXP 54
19073: PPUSH
19074: CALL_OW 302
19078: AND
19079: IFFALSE 19093
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
19081: LD_EXP 42
19085: PPUSH
19086: LD_STRING DEnd-JMM-Tit-1
19088: PPUSH
19089: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
19093: LD_EXP 47
19097: PUSH
19098: LD_EXP 47
19102: PPUSH
19103: CALL_OW 305
19107: AND
19108: IFFALSE 19122
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19110: LD_EXP 47
19114: PPUSH
19115: LD_STRING DEnd-JMM-Obl-1
19117: PPUSH
19118: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19122: LD_EXP 49
19126: PUSH
19127: LD_EXP 49
19131: PPUSH
19132: CALL_OW 305
19136: AND
19137: IFFALSE 19151
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19139: LD_EXP 49
19143: PPUSH
19144: LD_STRING DEnd-JMM-Lip-1
19146: PPUSH
19147: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19151: LD_EXP 43
19155: PUSH
19156: LD_EXP 43
19160: PPUSH
19161: CALL_OW 305
19165: AND
19166: PUSH
19167: LD_EXP 54
19171: PPUSH
19172: CALL_OW 302
19176: AND
19177: IFFALSE 19191
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19179: LD_EXP 43
19183: PPUSH
19184: LD_STRING DEnd-Burlak-Fad-1
19186: PPUSH
19187: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19191: LD_EXP 50
19195: PUSH
19196: LD_EXP 50
19200: PPUSH
19201: CALL_OW 305
19205: AND
19206: IFFALSE 19220
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19208: LD_EXP 50
19212: PPUSH
19213: LD_STRING DEnd-Burlak-Ptr-1
19215: PPUSH
19216: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19220: LD_EXP 52
19224: PUSH
19225: LD_EXP 52
19229: PPUSH
19230: CALL_OW 305
19234: AND
19235: IFFALSE 19249
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19237: LD_EXP 52
19241: PPUSH
19242: LD_STRING DEnd-Burlak-Kuz-1
19244: PPUSH
19245: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19249: LD_EXP 41
19253: PUSH
19254: LD_EXP 41
19258: PPUSH
19259: CALL_OW 305
19263: AND
19264: PUSH
19265: LD_EXP 54
19269: PPUSH
19270: CALL_OW 302
19274: AND
19275: IFFALSE 19289
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19277: LD_EXP 41
19281: PPUSH
19282: LD_STRING DEnd-Burlak-Kir-1
19284: PPUSH
19285: CALL_OW 88
// if Joan then
19289: LD_EXP 36
19293: IFFALSE 19307
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19295: LD_EXP 36
19299: PPUSH
19300: LD_STRING DEnd-Burlak-Joan-1
19302: PPUSH
19303: CALL_OW 88
// if IsOk ( Burlak ) then
19307: LD_EXP 54
19311: PPUSH
19312: CALL_OW 302
19316: IFFALSE 19330
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19318: LD_EXP 21
19322: PPUSH
19323: LD_STRING DEnd-Burlak-JMM-1
19325: PPUSH
19326: CALL_OW 88
// dwait ( 0 0$2 ) ;
19330: LD_INT 70
19332: PPUSH
19333: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19337: LD_EXP 59
19341: PPUSH
19342: LD_STRING DEnd-Szulc
19344: PPUSH
19345: CALL_OW 94
// dwait ( 0 0$1 ) ;
19349: LD_INT 35
19351: PPUSH
19352: CALL_OW 68
// if IsLive ( Burlak ) then
19356: LD_EXP 54
19360: PPUSH
19361: CALL_OW 300
19365: IFFALSE 19377
// med1 := 1 else
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: LD_INT 1
19374: ST_TO_ADDR
19375: GO 19386
// med1 := - 1 ;
19377: LD_ADDR_VAR 0 1
19381: PUSH
19382: LD_INT 1
19384: NEG
19385: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19386: LD_EXP 12
19390: PUSH
19391: LD_EXP 13
19395: AND
19396: PUSH
19397: LD_EXP 14
19401: AND
19402: IFFALSE 19414
// med2 := 1 else
19404: LD_ADDR_VAR 0 2
19408: PUSH
19409: LD_INT 1
19411: ST_TO_ADDR
19412: GO 19423
// med2 := - 1 ;
19414: LD_ADDR_VAR 0 2
19418: PUSH
19419: LD_INT 1
19421: NEG
19422: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19423: LD_STRING Hero
19425: PPUSH
19426: LD_INT 1
19428: PPUSH
19429: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19433: LD_STRING Artefact
19435: PPUSH
19436: LD_VAR 0 2
19440: PPUSH
19441: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19445: LD_STRING ReconcileBurlak
19447: PPUSH
19448: LD_VAR 0 1
19452: PPUSH
19453: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19457: LD_OWVAR 67
19461: PUSH
19462: LD_INT 3
19464: GREATEREQUAL
19465: PUSH
19466: LD_VAR 0 1
19470: PUSH
19471: LD_INT 1
19473: EQUAL
19474: AND
19475: PUSH
19476: LD_VAR 0 2
19480: PUSH
19481: LD_INT 1
19483: EQUAL
19484: AND
19485: IFFALSE 19497
// SetAchievementEX ( ACH_AMER , 19 ) ;
19487: LD_STRING ACH_AMER
19489: PPUSH
19490: LD_INT 19
19492: PPUSH
19493: CALL_OW 564
// GiveMedals ( MAIN ) ;
19497: LD_STRING MAIN
19499: PPUSH
19500: CALL_OW 102
// InGameOff ;
19504: CALL_OW 9
// DialogueOff ;
19508: CALL_OW 7
// music_nat := 1 ;
19512: LD_ADDR_OWVAR 71
19516: PUSH
19517: LD_INT 1
19519: ST_TO_ADDR
// music_class := 4 ;
19520: LD_ADDR_OWVAR 72
19524: PUSH
19525: LD_INT 4
19527: ST_TO_ADDR
// YouWin ;
19528: CALL_OW 103
// end ; end_of_file
19532: PPOPN 2
19534: END
// export function InitNature ; begin
19535: LD_INT 0
19537: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19538: LD_INT 3
19540: PPUSH
19541: LD_INT 3
19543: PPUSH
19544: LD_INT 2
19546: PPUSH
19547: LD_INT 1
19549: PPUSH
19550: LD_INT 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: LD_INT 0
19558: PPUSH
19559: LD_INT 17
19561: PPUSH
19562: LD_INT 0
19564: PPUSH
19565: CALL 87945 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19569: LD_INT 2
19571: PPUSH
19572: LD_INT 1
19574: PPUSH
19575: LD_INT 1
19577: PPUSH
19578: LD_INT 1
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: LD_INT 0
19586: PPUSH
19587: LD_INT 0
19589: PPUSH
19590: LD_INT 18
19592: PPUSH
19593: LD_INT 0
19595: PPUSH
19596: CALL 87945 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19600: LD_INT 4
19602: PPUSH
19603: LD_INT 1
19605: PPUSH
19606: LD_INT 2
19608: PPUSH
19609: LD_INT 4
19611: PPUSH
19612: LD_INT 2
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: LD_INT 19
19623: PPUSH
19624: LD_INT 0
19626: PPUSH
19627: CALL 87945 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19631: LD_INT 0
19633: PPUSH
19634: LD_INT 0
19636: PPUSH
19637: LD_INT 0
19639: PPUSH
19640: LD_INT 0
19642: PPUSH
19643: LD_INT 0
19645: PPUSH
19646: LD_INT 0
19648: PPUSH
19649: LD_INT 9
19651: PPUSH
19652: LD_INT 0
19654: PPUSH
19655: LD_INT 20
19657: PPUSH
19658: CALL 87945 0 9
// end ; end_of_file
19662: LD_VAR 0 1
19666: RET
// every 0 0$30 do var time ;
19667: GO 19669
19669: DISABLE
19670: LD_INT 0
19672: PPUSH
// begin time := 0 0$30 ;
19673: LD_ADDR_VAR 0 1
19677: PUSH
19678: LD_INT 1050
19680: ST_TO_ADDR
// repeat wait ( time ) ;
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 67
// if Prob ( 50 ) then
19690: LD_INT 50
19692: PPUSH
19693: CALL_OW 13
19697: IFFALSE 19726
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19699: LD_INT 1
19701: PPUSH
19702: LD_INT 5
19704: PPUSH
19705: CALL_OW 12
19709: PPUSH
19710: LD_INT 106
19712: PPUSH
19713: LD_INT 89
19715: PPUSH
19716: LD_INT 45
19718: PPUSH
19719: LD_INT 1
19721: PPUSH
19722: CALL_OW 56
// time := time + 0 0$3 ;
19726: LD_ADDR_VAR 0 1
19730: PUSH
19731: LD_VAR 0 1
19735: PUSH
19736: LD_INT 105
19738: PLUS
19739: ST_TO_ADDR
// if Prob ( 30 ) then
19740: LD_INT 30
19742: PPUSH
19743: CALL_OW 13
19747: IFFALSE 19793
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19749: LD_INT 525
19751: PPUSH
19752: LD_INT 735
19754: PPUSH
19755: CALL_OW 12
19759: PPUSH
19760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19764: LD_INT 1
19766: PPUSH
19767: LD_INT 5
19769: PPUSH
19770: CALL_OW 12
19774: PPUSH
19775: LD_INT 21
19777: PPUSH
19778: LD_INT 26
19780: PPUSH
19781: LD_INT 12
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: CALL_OW 56
// end else
19791: GO 19829
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19793: LD_INT 700
19795: PPUSH
19796: LD_INT 1225
19798: PPUSH
19799: CALL_OW 12
19803: PPUSH
19804: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19808: LD_INT 1
19810: PPUSH
19811: LD_INT 5
19813: PPUSH
19814: CALL_OW 12
19818: PPUSH
19819: LD_INT 14
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: CALL_OW 55
// end ; if Prob ( 50 ) then
19829: LD_INT 50
19831: PPUSH
19832: CALL_OW 13
19836: IFFALSE 19882
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19838: LD_INT 700
19840: PPUSH
19841: LD_INT 1050
19843: PPUSH
19844: CALL_OW 12
19848: PPUSH
19849: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19853: LD_INT 1
19855: PPUSH
19856: LD_INT 5
19858: PPUSH
19859: CALL_OW 12
19863: PPUSH
19864: LD_INT 181
19866: PPUSH
19867: LD_INT 218
19869: PPUSH
19870: LD_INT 16
19872: PPUSH
19873: LD_INT 1
19875: PPUSH
19876: CALL_OW 56
// end else
19880: GO 19954
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19882: LD_INT 350
19884: PPUSH
19885: LD_INT 525
19887: PPUSH
19888: CALL_OW 12
19892: PPUSH
19893: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19897: LD_INT 1
19899: PPUSH
19900: LD_INT 5
19902: PPUSH
19903: CALL_OW 12
19907: PPUSH
19908: LD_INT 13
19910: PPUSH
19911: LD_INT 1
19913: PPUSH
19914: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19918: LD_INT 350
19920: PPUSH
19921: LD_INT 700
19923: PPUSH
19924: CALL_OW 12
19928: PPUSH
19929: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19933: LD_INT 1
19935: PPUSH
19936: LD_INT 5
19938: PPUSH
19939: CALL_OW 12
19943: PPUSH
19944: LD_INT 33
19946: PPUSH
19947: LD_INT 1
19949: PPUSH
19950: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19954: LD_INT 65
19956: PUSH
19957: LD_INT 62
19959: PUSH
19960: LD_INT 55
19962: PUSH
19963: LD_INT 50
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: PUSH
19972: LD_OWVAR 67
19976: ARRAY
19977: PPUSH
19978: CALL_OW 13
19982: IFFALSE 20028
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19984: LD_INT 525
19986: PPUSH
19987: LD_INT 875
19989: PPUSH
19990: CALL_OW 12
19994: PPUSH
19995: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19999: LD_INT 1
20001: PPUSH
20002: LD_INT 5
20004: PPUSH
20005: CALL_OW 12
20009: PPUSH
20010: LD_INT 294
20012: PPUSH
20013: LD_INT 211
20015: PPUSH
20016: LD_INT 30
20018: PPUSH
20019: LD_INT 1
20021: PPUSH
20022: CALL_OW 56
// end else
20026: GO 20070
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
20028: LD_INT 420
20030: PPUSH
20031: LD_INT 770
20033: PPUSH
20034: CALL_OW 12
20038: PPUSH
20039: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20043: LD_INT 1
20045: PPUSH
20046: LD_INT 5
20048: PPUSH
20049: CALL_OW 12
20053: PPUSH
20054: LD_INT 294
20056: PPUSH
20057: LD_INT 211
20059: PPUSH
20060: LD_INT 30
20062: PPUSH
20063: LD_INT 1
20065: PPUSH
20066: CALL_OW 56
// end ; if time > 2 2$20 then
20070: LD_VAR 0 1
20074: PUSH
20075: LD_INT 4900
20077: GREATER
20078: IFFALSE 20088
// time := 0 0$50 ;
20080: LD_ADDR_VAR 0 1
20084: PUSH
20085: LD_INT 1750
20087: ST_TO_ADDR
// until false ;
20088: LD_INT 0
20090: IFFALSE 19681
// end ;
20092: PPOPN 1
20094: END
// every 0 0$45 trigger tick < 10 10$00 do
20095: LD_OWVAR 1
20099: PUSH
20100: LD_INT 21000
20102: LESS
20103: IFFALSE 20151
20105: GO 20107
20107: DISABLE
// begin enable ;
20108: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20109: LD_INT 350
20111: PPUSH
20112: LD_INT 700
20114: PPUSH
20115: CALL_OW 12
20119: PPUSH
20120: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20124: LD_INT 3
20126: PPUSH
20127: LD_INT 5
20129: PPUSH
20130: CALL_OW 12
20134: PPUSH
20135: LD_INT 181
20137: PPUSH
20138: LD_INT 13
20140: PPUSH
20141: LD_INT 20
20143: PPUSH
20144: LD_INT 1
20146: PPUSH
20147: CALL_OW 56
// end ; end_of_file
20151: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20152: LD_INT 0
20154: PPUSH
// SetArtifactRes ( 7 , true ) ;
20155: LD_INT 7
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20165: LD_ADDR_EXP 68
20169: PUSH
20170: EMPTY
20171: PUSH
20172: EMPTY
20173: PUSH
20174: EMPTY
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: LIST
20180: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20181: LD_ADDR_EXP 69
20185: PUSH
20186: LD_INT 1050
20188: PUSH
20189: LD_OWVAR 67
20193: MUL
20194: PUSH
20195: LD_INT 2800
20197: PUSH
20198: LD_OWVAR 67
20202: MUL
20203: PUSH
20204: LD_INT 1
20206: NEG
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: LIST
20212: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20213: LD_ADDR_EXP 70
20217: PUSH
20218: LD_INT 10
20220: PUSH
20221: LD_INT 35
20223: PUSH
20224: LD_INT 100
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20232: LD_ADDR_EXP 71
20236: PUSH
20237: LD_INT 0
20239: PUSH
20240: LD_INT 0
20242: PUSH
20243: LD_INT 0
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20251: LD_ADDR_EXP 73
20255: PUSH
20256: LD_INT 300
20258: PUSH
20259: LD_INT 500
20261: PUSH
20262: LD_INT 800
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: LIST
20269: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20270: LD_ADDR_EXP 74
20274: PUSH
20275: LD_INT 0
20277: PUSH
20278: LD_INT 0
20280: PUSH
20281: LD_INT 0
20283: PUSH
20284: EMPTY
20285: LIST
20286: LIST
20287: LIST
20288: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20289: LD_ADDR_EXP 75
20293: PUSH
20294: LD_INT 0
20296: PUSH
20297: LD_INT 0
20299: PUSH
20300: LD_INT 0
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: LIST
20307: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20308: LD_ADDR_EXP 72
20312: PUSH
20313: LD_INT 0
20315: PUSH
20316: LD_INT 0
20318: PUSH
20319: LD_INT 0
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: LIST
20326: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20327: LD_ADDR_EXP 76
20331: PUSH
20332: LD_INT 4
20334: PUSH
20335: LD_INT 3
20337: PUSH
20338: LD_INT 1
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: LD_INT 5
20348: PUSH
20349: LD_INT 4
20351: PUSH
20352: LD_INT 2
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: PUSH
20360: LD_INT 6
20362: PUSH
20363: LD_INT 3
20365: PUSH
20366: LD_INT 3
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: LIST
20378: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20379: LD_ADDR_EXP 77
20383: PUSH
20384: LD_INT 0
20386: PUSH
20387: LD_INT 0
20389: PUSH
20390: LD_INT 0
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// end ;
20398: LD_VAR 0 1
20402: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20403: LD_INT 24
20405: PPUSH
20406: LD_INT 7
20408: PPUSH
20409: CALL_OW 321
20413: PUSH
20414: LD_INT 2
20416: EQUAL
20417: IFFALSE 21343
20419: GO 20421
20421: DISABLE
20422: LD_INT 0
20424: PPUSH
20425: PPUSH
20426: PPUSH
20427: PPUSH
20428: PPUSH
// begin enable ;
20429: ENABLE
// for i = 1 to 3 do
20430: LD_ADDR_VAR 0 1
20434: PUSH
20435: DOUBLE
20436: LD_INT 1
20438: DEC
20439: ST_TO_ADDR
20440: LD_INT 3
20442: PUSH
20443: FOR_TO
20444: IFFALSE 21341
// begin pos := FindArtifact ( i + 2 ) ;
20446: LD_ADDR_VAR 0 2
20450: PUSH
20451: LD_VAR 0 1
20455: PUSH
20456: LD_INT 2
20458: PLUS
20459: PPUSH
20460: CALL_OW 469
20464: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20465: LD_ADDR_EXP 68
20469: PUSH
20470: LD_EXP 68
20474: PPUSH
20475: LD_VAR 0 1
20479: PPUSH
20480: LD_VAR 0 2
20484: PPUSH
20485: CALL_OW 1
20489: ST_TO_ADDR
// if pos then
20490: LD_VAR 0 2
20494: IFFALSE 21202
// begin case i of 1 :
20496: LD_VAR 0 1
20500: PUSH
20501: LD_INT 1
20503: DOUBLE
20504: EQUAL
20505: IFTRUE 20509
20507: GO 20586
20509: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20510: LD_ADDR_VAR 0 4
20514: PUSH
20515: LD_INT 22
20517: PUSH
20518: LD_INT 7
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: PUSH
20525: LD_INT 23
20527: PUSH
20528: LD_INT 1
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 2
20537: PUSH
20538: LD_INT 30
20540: PUSH
20541: LD_INT 8
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 30
20550: PUSH
20551: LD_INT 7
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PUSH
20558: LD_INT 30
20560: PUSH
20561: LD_INT 11
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: LIST
20578: PPUSH
20579: CALL_OW 69
20583: ST_TO_ADDR
20584: GO 20694
20586: LD_INT 2
20588: DOUBLE
20589: EQUAL
20590: IFTRUE 20594
20592: GO 20671
20594: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20595: LD_ADDR_VAR 0 4
20599: PUSH
20600: LD_INT 22
20602: PUSH
20603: LD_INT 7
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 23
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 2
20622: PUSH
20623: LD_INT 30
20625: PUSH
20626: LD_INT 8
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: PUSH
20633: LD_INT 30
20635: PUSH
20636: LD_INT 7
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: LD_INT 30
20645: PUSH
20646: LD_INT 11
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: LIST
20663: PPUSH
20664: CALL_OW 69
20668: ST_TO_ADDR
20669: GO 20694
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20693
20679: POP
// labs := [ alien ] ; end ;
20680: LD_ADDR_VAR 0 4
20684: PUSH
20685: LD_INT 1
20687: PUSH
20688: EMPTY
20689: LIST
20690: ST_TO_ADDR
20691: GO 20694
20693: POP
// if not labs then
20694: LD_VAR 0 4
20698: NOT
20699: IFFALSE 20703
// continue ;
20701: GO 20443
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20703: LD_ADDR_VAR 0 5
20707: PUSH
20708: LD_VAR 0 4
20712: PPUSH
20713: LD_EXP 68
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_INT 1
20726: ARRAY
20727: PPUSH
20728: LD_EXP 68
20732: PUSH
20733: LD_VAR 0 1
20737: ARRAY
20738: PUSH
20739: LD_INT 2
20741: ARRAY
20742: PPUSH
20743: CALL_OW 73
20747: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20748: LD_VAR 0 5
20752: NOT
20753: PUSH
20754: LD_VAR 0 5
20758: PUSH
20759: LD_EXP 75
20763: PUSH
20764: LD_VAR 0 1
20768: ARRAY
20769: NONEQUAL
20770: OR
20771: IFFALSE 20876
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20773: LD_INT 7
20775: PPUSH
20776: LD_EXP 76
20780: PUSH
20781: LD_VAR 0 1
20785: ARRAY
20786: PUSH
20787: LD_INT 3
20789: ARRAY
20790: PPUSH
20791: LD_INT 0
20793: PPUSH
20794: LD_EXP 75
20798: PUSH
20799: LD_VAR 0 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20809: LD_INT 7
20811: PPUSH
20812: LD_EXP 76
20816: PUSH
20817: LD_VAR 0 1
20821: ARRAY
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: LD_INT 0
20829: PPUSH
20830: LD_EXP 75
20834: PUSH
20835: LD_VAR 0 1
20839: ARRAY
20840: PPUSH
20841: CALL_OW 468
// if nearestLab then
20845: LD_VAR 0 5
20849: IFFALSE 20876
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20851: LD_ADDR_EXP 75
20855: PUSH
20856: LD_EXP 75
20860: PPUSH
20861: LD_VAR 0 1
20865: PPUSH
20866: LD_VAR 0 5
20870: PPUSH
20871: CALL_OW 1
20875: ST_TO_ADDR
// end ; if not nearestLab then
20876: LD_VAR 0 5
20880: NOT
20881: IFFALSE 20885
// continue ;
20883: GO 20443
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20885: LD_VAR 0 5
20889: PPUSH
20890: LD_EXP 68
20894: PUSH
20895: LD_VAR 0 1
20899: ARRAY
20900: PUSH
20901: LD_INT 1
20903: ARRAY
20904: PPUSH
20905: LD_EXP 68
20909: PUSH
20910: LD_VAR 0 1
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: ARRAY
20919: PPUSH
20920: CALL_OW 297
20924: PUSH
20925: LD_INT 8
20927: LESS
20928: IFFALSE 21125
// begin if not artifactsResearched [ i ] then
20930: LD_EXP 71
20934: PUSH
20935: LD_VAR 0 1
20939: ARRAY
20940: NOT
20941: IFFALSE 21022
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20943: LD_VAR 0 5
20947: PPUSH
20948: CALL_OW 461
20952: PUSH
20953: LD_INT 2
20955: EQUAL
20956: IFFALSE 20990
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20958: LD_INT 7
20960: PPUSH
20961: LD_EXP 76
20965: PUSH
20966: LD_VAR 0 1
20970: ARRAY
20971: PUSH
20972: LD_INT 3
20974: ARRAY
20975: PPUSH
20976: LD_INT 2
20978: PPUSH
20979: LD_VAR 0 5
20983: PPUSH
20984: CALL_OW 468
20988: GO 21020
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20990: LD_INT 7
20992: PPUSH
20993: LD_EXP 76
20997: PUSH
20998: LD_VAR 0 1
21002: ARRAY
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: LD_INT 1
21010: PPUSH
21011: LD_VAR 0 5
21015: PPUSH
21016: CALL_OW 468
// end else
21020: GO 21123
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
21022: LD_VAR 0 5
21026: PPUSH
21027: CALL_OW 461
21031: PUSH
21032: LD_INT 2
21034: EQUAL
21035: PUSH
21036: LD_EXP 77
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: AND
21047: IFFALSE 21093
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
21049: LD_INT 7
21051: PPUSH
21052: LD_EXP 76
21056: PUSH
21057: LD_VAR 0 1
21061: ARRAY
21062: PUSH
21063: LD_INT 1
21065: ARRAY
21066: PPUSH
21067: LD_EXP 76
21071: PUSH
21072: LD_VAR 0 1
21076: ARRAY
21077: PUSH
21078: LD_INT 2
21080: ARRAY
21081: PPUSH
21082: LD_VAR 0 5
21086: PPUSH
21087: CALL_OW 468
21091: GO 21123
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
21093: LD_INT 7
21095: PPUSH
21096: LD_EXP 76
21100: PUSH
21101: LD_VAR 0 1
21105: ARRAY
21106: PUSH
21107: LD_INT 1
21109: ARRAY
21110: PPUSH
21111: LD_INT 1
21113: PPUSH
21114: LD_VAR 0 5
21118: PPUSH
21119: CALL_OW 468
// end else
21123: GO 21200
// begin if not artifactsResearched [ i ] then
21125: LD_EXP 71
21129: PUSH
21130: LD_VAR 0 1
21134: ARRAY
21135: NOT
21136: IFFALSE 21170
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21138: LD_INT 7
21140: PPUSH
21141: LD_EXP 76
21145: PUSH
21146: LD_VAR 0 1
21150: ARRAY
21151: PUSH
21152: LD_INT 3
21154: ARRAY
21155: PPUSH
21156: LD_INT 0
21158: PPUSH
21159: LD_VAR 0 5
21163: PPUSH
21164: CALL_OW 468
21168: GO 21200
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21170: LD_INT 7
21172: PPUSH
21173: LD_EXP 76
21177: PUSH
21178: LD_VAR 0 1
21182: ARRAY
21183: PUSH
21184: LD_INT 1
21186: ARRAY
21187: PPUSH
21188: LD_INT 0
21190: PPUSH
21191: LD_VAR 0 5
21195: PPUSH
21196: CALL_OW 468
// end ; end else
21200: GO 21339
// begin if not artifactsLabs [ i ] then
21202: LD_EXP 75
21206: PUSH
21207: LD_VAR 0 1
21211: ARRAY
21212: NOT
21213: IFFALSE 21217
// continue ;
21215: GO 20443
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21217: LD_INT 7
21219: PPUSH
21220: LD_EXP 76
21224: PUSH
21225: LD_VAR 0 1
21229: ARRAY
21230: PUSH
21231: LD_INT 3
21233: ARRAY
21234: PPUSH
21235: LD_INT 0
21237: PPUSH
21238: LD_EXP 75
21242: PUSH
21243: LD_VAR 0 1
21247: ARRAY
21248: PPUSH
21249: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21253: LD_INT 7
21255: PPUSH
21256: LD_EXP 76
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PUSH
21267: LD_INT 1
21269: ARRAY
21270: PPUSH
21271: LD_INT 0
21273: PPUSH
21274: LD_EXP 75
21278: PUSH
21279: LD_VAR 0 1
21283: ARRAY
21284: PPUSH
21285: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21289: LD_EXP 72
21293: PUSH
21294: LD_VAR 0 1
21298: ARRAY
21299: IFFALSE 21339
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21301: LD_ADDR_EXP 72
21305: PUSH
21306: LD_EXP 72
21310: PPUSH
21311: LD_VAR 0 1
21315: PPUSH
21316: LD_INT 0
21318: PPUSH
21319: CALL_OW 1
21323: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21324: LD_EXP 75
21328: PUSH
21329: LD_VAR 0 1
21333: ARRAY
21334: PPUSH
21335: CALL_OW 127
// end ; end ; end ;
21339: GO 20443
21341: POP
21342: POP
// end ;
21343: PPOPN 5
21345: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
21346: LD_INT 0
21348: PPUSH
21349: PPUSH
21350: PPUSH
21351: PPUSH
21352: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21353: LD_VAR 0 2
21357: PUSH
21358: LD_EXP 76
21362: PUSH
21363: LD_INT 1
21365: ARRAY
21366: PUSH
21367: LD_INT 3
21369: ARRAY
21370: EQUAL
21371: IFFALSE 21494
// begin lab := artifactsLabs [ 1 ] ;
21373: LD_ADDR_VAR 0 6
21377: PUSH
21378: LD_EXP 75
21382: PUSH
21383: LD_INT 1
21385: ARRAY
21386: ST_TO_ADDR
// if not lab then
21387: LD_VAR 0 6
21391: NOT
21392: IFFALSE 21396
// exit ;
21394: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_EXP 73
21405: PUSH
21406: LD_INT 1
21408: ARRAY
21409: PPUSH
21410: LD_INT 1
21412: PPUSH
21413: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21417: LD_EXP 74
21421: PUSH
21422: LD_INT 1
21424: ARRAY
21425: IFFALSE 21445
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21427: LD_VAR 0 6
21431: PPUSH
21432: LD_EXP 74
21436: PUSH
21437: LD_INT 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21445: LD_ADDR_EXP 72
21449: PUSH
21450: LD_EXP 72
21454: PPUSH
21455: LD_INT 1
21457: PPUSH
21458: LD_INT 1
21460: PPUSH
21461: CALL_OW 1
21465: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21466: LD_INT 7
21468: PPUSH
21469: LD_EXP 76
21473: PUSH
21474: LD_INT 1
21476: ARRAY
21477: PUSH
21478: LD_INT 3
21480: ARRAY
21481: PPUSH
21482: LD_INT 0
21484: PPUSH
21485: LD_VAR 0 6
21489: PPUSH
21490: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_EXP 76
21503: PUSH
21504: LD_INT 2
21506: ARRAY
21507: PUSH
21508: LD_INT 3
21510: ARRAY
21511: EQUAL
21512: IFFALSE 21635
// begin lab := artifactsLabs [ 2 ] ;
21514: LD_ADDR_VAR 0 6
21518: PUSH
21519: LD_EXP 75
21523: PUSH
21524: LD_INT 2
21526: ARRAY
21527: ST_TO_ADDR
// if not lab then
21528: LD_VAR 0 6
21532: NOT
21533: IFFALSE 21537
// exit ;
21535: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21537: LD_VAR 0 6
21541: PPUSH
21542: LD_EXP 73
21546: PUSH
21547: LD_INT 2
21549: ARRAY
21550: PPUSH
21551: LD_INT 1
21553: PPUSH
21554: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21558: LD_EXP 74
21562: PUSH
21563: LD_INT 2
21565: ARRAY
21566: IFFALSE 21586
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21568: LD_VAR 0 6
21572: PPUSH
21573: LD_EXP 74
21577: PUSH
21578: LD_INT 2
21580: ARRAY
21581: PPUSH
21582: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21586: LD_ADDR_EXP 72
21590: PUSH
21591: LD_EXP 72
21595: PPUSH
21596: LD_INT 2
21598: PPUSH
21599: LD_INT 1
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21607: LD_INT 7
21609: PPUSH
21610: LD_EXP 76
21614: PUSH
21615: LD_INT 2
21617: ARRAY
21618: PUSH
21619: LD_INT 3
21621: ARRAY
21622: PPUSH
21623: LD_INT 0
21625: PPUSH
21626: LD_VAR 0 6
21630: PPUSH
21631: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21635: LD_VAR 0 2
21639: PUSH
21640: LD_EXP 76
21644: PUSH
21645: LD_INT 3
21647: ARRAY
21648: PUSH
21649: LD_INT 3
21651: ARRAY
21652: EQUAL
21653: IFFALSE 21776
// begin lab := artifactsLabs [ 3 ] ;
21655: LD_ADDR_VAR 0 6
21659: PUSH
21660: LD_EXP 75
21664: PUSH
21665: LD_INT 3
21667: ARRAY
21668: ST_TO_ADDR
// if not lab then
21669: LD_VAR 0 6
21673: NOT
21674: IFFALSE 21678
// exit ;
21676: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21678: LD_VAR 0 6
21682: PPUSH
21683: LD_EXP 73
21687: PUSH
21688: LD_INT 3
21690: ARRAY
21691: PPUSH
21692: LD_INT 1
21694: PPUSH
21695: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21699: LD_EXP 74
21703: PUSH
21704: LD_INT 3
21706: ARRAY
21707: IFFALSE 21727
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21709: LD_VAR 0 6
21713: PPUSH
21714: LD_EXP 74
21718: PUSH
21719: LD_INT 3
21721: ARRAY
21722: PPUSH
21723: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21727: LD_ADDR_EXP 72
21731: PUSH
21732: LD_EXP 72
21736: PPUSH
21737: LD_INT 3
21739: PPUSH
21740: LD_INT 1
21742: PPUSH
21743: CALL_OW 1
21747: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21748: LD_INT 7
21750: PPUSH
21751: LD_EXP 76
21755: PUSH
21756: LD_INT 3
21758: ARRAY
21759: PUSH
21760: LD_INT 3
21762: ARRAY
21763: PPUSH
21764: LD_INT 0
21766: PPUSH
21767: LD_VAR 0 6
21771: PPUSH
21772: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21776: LD_VAR 0 2
21780: PUSH
21781: LD_EXP 76
21785: PUSH
21786: LD_INT 1
21788: ARRAY
21789: PUSH
21790: LD_INT 1
21792: ARRAY
21793: EQUAL
21794: IFFALSE 21952
// begin lab := artifactsLabs [ 1 ] ;
21796: LD_ADDR_VAR 0 6
21800: PUSH
21801: LD_EXP 75
21805: PUSH
21806: LD_INT 1
21808: ARRAY
21809: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21810: LD_VAR 0 6
21814: PPUSH
21815: CALL_OW 274
21819: PPUSH
21820: CALL 91498 0 1
21824: PUSH
21825: LD_INT 3
21827: ARRAY
21828: PUSH
21829: LD_EXP 70
21833: PUSH
21834: LD_INT 1
21836: ARRAY
21837: LESS
21838: IFFALSE 21852
// begin HintSpec ( ArtifactCost , 2 ) ;
21840: LD_STRING ArtifactCost
21842: PPUSH
21843: LD_INT 2
21845: PPUSH
21846: CALL_OW 338
// exit ;
21850: GO 22474
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21852: LD_ADDR_EXP 77
21856: PUSH
21857: LD_EXP 77
21861: PPUSH
21862: LD_INT 1
21864: PPUSH
21865: LD_INT 0
21867: PPUSH
21868: CALL_OW 1
21872: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21873: LD_VAR 0 3
21877: PPUSH
21878: LD_VAR 0 4
21882: PPUSH
21883: LD_INT 7
21885: PPUSH
21886: LD_INT 12
21888: NEG
21889: PPUSH
21890: CALL_OW 330
// wait ( 0 0$30 ) ;
21894: LD_INT 1050
21896: PPUSH
21897: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21901: LD_VAR 0 3
21905: PPUSH
21906: LD_VAR 0 4
21910: PPUSH
21911: LD_INT 7
21913: PPUSH
21914: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21918: LD_EXP 69
21922: PUSH
21923: LD_INT 1
21925: ARRAY
21926: PPUSH
21927: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21931: LD_ADDR_EXP 77
21935: PUSH
21936: LD_EXP 77
21940: PPUSH
21941: LD_INT 1
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL_OW 1
21951: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21952: LD_VAR 0 2
21956: PUSH
21957: LD_EXP 76
21961: PUSH
21962: LD_INT 2
21964: ARRAY
21965: PUSH
21966: LD_INT 1
21968: ARRAY
21969: EQUAL
21970: IFFALSE 22207
// begin lab := artifactsLabs [ 2 ] ;
21972: LD_ADDR_VAR 0 6
21976: PUSH
21977: LD_EXP 75
21981: PUSH
21982: LD_INT 2
21984: ARRAY
21985: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21986: LD_VAR 0 3
21990: PUSH
21991: LD_INT 81
21993: PUSH
21994: LD_INT 7
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 2
22003: PUSH
22004: LD_INT 32
22006: PUSH
22007: LD_INT 3
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: PUSH
22014: LD_INT 30
22016: PUSH
22017: LD_INT 28
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: LD_INT 30
22026: PUSH
22027: LD_INT 30
22029: PUSH
22030: EMPTY
22031: LIST
22032: LIST
22033: PUSH
22034: LD_INT 35
22036: PUSH
22037: LD_INT 49
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: PUSH
22044: LD_INT 34
22046: PUSH
22047: LD_INT 49
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: PUSH
22054: LD_INT 30
22056: PUSH
22057: LD_INT 21
22059: PUSH
22060: EMPTY
22061: LIST
22062: LIST
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: LIST
22068: LIST
22069: LIST
22070: LIST
22071: LIST
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PPUSH
22077: CALL_OW 69
22081: IN
22082: NOT
22083: IFFALSE 22087
// exit ;
22085: GO 22474
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
22087: LD_VAR 0 6
22091: PPUSH
22092: CALL_OW 274
22096: PPUSH
22097: CALL 91498 0 1
22101: PUSH
22102: LD_INT 3
22104: ARRAY
22105: PUSH
22106: LD_EXP 70
22110: PUSH
22111: LD_INT 2
22113: ARRAY
22114: LESS
22115: IFFALSE 22129
// begin HintSpec ( ArtifactCost , 2 ) ;
22117: LD_STRING ArtifactCost
22119: PPUSH
22120: LD_INT 2
22122: PPUSH
22123: CALL_OW 338
// exit ;
22127: GO 22474
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22129: LD_ADDR_EXP 77
22133: PUSH
22134: LD_EXP 77
22138: PPUSH
22139: LD_INT 2
22141: PPUSH
22142: LD_INT 0
22144: PPUSH
22145: CALL_OW 1
22149: ST_TO_ADDR
// KillUnit ( x ) ;
22150: LD_VAR 0 3
22154: PPUSH
22155: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22159: LD_ADDR_EXP 16
22163: PUSH
22164: LD_EXP 16
22168: PUSH
22169: LD_INT 1
22171: PLUS
22172: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22173: LD_EXP 69
22177: PUSH
22178: LD_INT 2
22180: ARRAY
22181: PPUSH
22182: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22186: LD_ADDR_EXP 77
22190: PUSH
22191: LD_EXP 77
22195: PPUSH
22196: LD_INT 2
22198: PPUSH
22199: LD_INT 1
22201: PPUSH
22202: CALL_OW 1
22206: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22207: LD_VAR 0 2
22211: PUSH
22212: LD_EXP 76
22216: PUSH
22217: LD_INT 3
22219: ARRAY
22220: PUSH
22221: LD_INT 1
22223: ARRAY
22224: EQUAL
22225: IFFALSE 22474
// begin lab := artifactsLabs [ 3 ] ;
22227: LD_ADDR_VAR 0 6
22231: PUSH
22232: LD_EXP 75
22236: PUSH
22237: LD_INT 3
22239: ARRAY
22240: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22241: LD_VAR 0 6
22245: PPUSH
22246: CALL_OW 274
22250: PPUSH
22251: CALL 91498 0 1
22255: PUSH
22256: LD_INT 3
22258: ARRAY
22259: PUSH
22260: LD_EXP 70
22264: PUSH
22265: LD_INT 3
22267: ARRAY
22268: LESS
22269: IFFALSE 22283
// begin HintSpec ( ArtifactCost , 2 ) ;
22271: LD_STRING ArtifactCost
22273: PPUSH
22274: LD_INT 2
22276: PPUSH
22277: CALL_OW 338
// exit ;
22281: GO 22474
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
22283: LD_INT 37
22285: PPUSH
22286: LD_INT 1
22288: PPUSH
22289: CALL_OW 424
// time := 0 0$30 ;
22293: LD_ADDR_VAR 0 7
22297: PUSH
22298: LD_INT 1050
22300: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22301: LD_ADDR_EXP 77
22305: PUSH
22306: LD_EXP 77
22310: PPUSH
22311: LD_INT 3
22313: PPUSH
22314: LD_INT 0
22316: PPUSH
22317: CALL_OW 1
22321: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22322: LD_ADDR_OWVAR 47
22326: PUSH
22327: LD_STRING #Am15a-1
22329: PUSH
22330: LD_VAR 0 7
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22339: LD_INT 35
22341: PPUSH
22342: CALL_OW 67
// time := time - 0 0$1 ;
22346: LD_ADDR_VAR 0 7
22350: PUSH
22351: LD_VAR 0 7
22355: PUSH
22356: LD_INT 35
22358: MINUS
22359: ST_TO_ADDR
// until time = 0 0$00 ;
22360: LD_VAR 0 7
22364: PUSH
22365: LD_INT 0
22367: EQUAL
22368: IFFALSE 22322
// display_strings :=  ;
22370: LD_ADDR_OWVAR 47
22374: PUSH
22375: LD_STRING 
22377: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22378: LD_INT 37
22380: PPUSH
22381: LD_INT 0
22383: PPUSH
22384: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22388: LD_ADDR_VAR 0 8
22392: PUSH
22393: LD_INT 37
22395: PPUSH
22396: LD_INT 3
22398: PUSH
22399: LD_INT 21
22401: PUSH
22402: LD_INT 3
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PPUSH
22413: CALL_OW 70
22417: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: CALL_OW 84
// for un in list do
22432: LD_ADDR_VAR 0 9
22436: PUSH
22437: LD_VAR 0 8
22441: PUSH
22442: FOR_IN
22443: IFFALSE 22472
// TeleportUnit ( un , x , y , 12 , true ) ;
22445: LD_VAR 0 9
22449: PPUSH
22450: LD_VAR 0 3
22454: PPUSH
22455: LD_VAR 0 4
22459: PPUSH
22460: LD_INT 12
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 483
22470: GO 22442
22472: POP
22473: POP
// end ; end ;
22474: PPOPN 9
22476: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22477: LD_INT 0
22479: PPUSH
22480: PPUSH
// begin labNum := 0 ;
22481: LD_ADDR_VAR 0 4
22485: PUSH
22486: LD_INT 0
22488: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22489: LD_ADDR_VAR 0 3
22493: PUSH
22494: DOUBLE
22495: LD_INT 1
22497: DEC
22498: ST_TO_ADDR
22499: LD_EXP 75
22503: PUSH
22504: FOR_TO
22505: IFFALSE 22539
// if artifactsLabs [ i ] = lab then
22507: LD_EXP 75
22511: PUSH
22512: LD_VAR 0 3
22516: ARRAY
22517: PUSH
22518: LD_VAR 0 1
22522: EQUAL
22523: IFFALSE 22537
// begin labNum := i ;
22525: LD_ADDR_VAR 0 4
22529: PUSH
22530: LD_VAR 0 3
22534: ST_TO_ADDR
// break ;
22535: GO 22539
// end ;
22537: GO 22504
22539: POP
22540: POP
// if not labNum then
22541: LD_VAR 0 4
22545: NOT
22546: IFFALSE 22550
// exit ;
22548: GO 22628
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22550: LD_INT 7
22552: PPUSH
22553: LD_EXP 76
22557: PUSH
22558: LD_VAR 0 4
22562: ARRAY
22563: PUSH
22564: LD_INT 3
22566: ARRAY
22567: PPUSH
22568: LD_INT 2
22570: PPUSH
22571: LD_VAR 0 1
22575: PPUSH
22576: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22580: LD_ADDR_EXP 74
22584: PUSH
22585: LD_EXP 74
22589: PPUSH
22590: LD_VAR 0 4
22594: PPUSH
22595: LD_VAR 0 2
22599: PPUSH
22600: CALL_OW 1
22604: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22605: LD_ADDR_EXP 72
22609: PUSH
22610: LD_EXP 72
22614: PPUSH
22615: LD_VAR 0 4
22619: PPUSH
22620: LD_INT 0
22622: PPUSH
22623: CALL_OW 1
22627: ST_TO_ADDR
// end ;
22628: PPOPN 4
22630: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22631: LD_INT 0
22633: PPUSH
22634: PPUSH
// begin labNum := 0 ;
22635: LD_ADDR_VAR 0 3
22639: PUSH
22640: LD_INT 0
22642: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22643: LD_ADDR_VAR 0 2
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_EXP 75
22657: PUSH
22658: FOR_TO
22659: IFFALSE 22693
// if artifactsLabs [ i ] = lab then
22661: LD_EXP 75
22665: PUSH
22666: LD_VAR 0 2
22670: ARRAY
22671: PUSH
22672: LD_VAR 0 1
22676: EQUAL
22677: IFFALSE 22691
// begin labNum := i ;
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: LD_VAR 0 2
22688: ST_TO_ADDR
// break ;
22689: GO 22693
// end ;
22691: GO 22658
22693: POP
22694: POP
// if not labNum then
22695: LD_VAR 0 3
22699: NOT
22700: IFFALSE 22704
// exit ;
22702: GO 22866
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22704: LD_INT 7
22706: PPUSH
22707: LD_EXP 76
22711: PUSH
22712: LD_VAR 0 3
22716: ARRAY
22717: PUSH
22718: LD_INT 3
22720: ARRAY
22721: PPUSH
22722: LD_INT 0
22724: PPUSH
22725: LD_VAR 0 1
22729: PPUSH
22730: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22734: LD_ADDR_EXP 71
22738: PUSH
22739: LD_EXP 71
22743: PPUSH
22744: LD_VAR 0 3
22748: PPUSH
22749: LD_INT 1
22751: PPUSH
22752: CALL_OW 1
22756: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22757: LD_ADDR_EXP 77
22761: PUSH
22762: LD_EXP 77
22766: PPUSH
22767: LD_VAR 0 3
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 1
22779: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22780: LD_ADDR_EXP 72
22784: PUSH
22785: LD_EXP 72
22789: PPUSH
22790: LD_VAR 0 3
22794: PPUSH
22795: LD_INT 0
22797: PPUSH
22798: CALL_OW 1
22802: ST_TO_ADDR
// case labNum of 1 :
22803: LD_VAR 0 3
22807: PUSH
22808: LD_INT 1
22810: DOUBLE
22811: EQUAL
22812: IFTRUE 22816
22814: GO 22827
22816: POP
// artifactIResearched := true ; 2 :
22817: LD_ADDR_EXP 12
22821: PUSH
22822: LD_INT 1
22824: ST_TO_ADDR
22825: GO 22866
22827: LD_INT 2
22829: DOUBLE
22830: EQUAL
22831: IFTRUE 22835
22833: GO 22846
22835: POP
// artifactIIResearched := true ; 3 :
22836: LD_ADDR_EXP 13
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
22844: GO 22866
22846: LD_INT 3
22848: DOUBLE
22849: EQUAL
22850: IFTRUE 22854
22852: GO 22865
22854: POP
// artifactIIIResearched := true ; end ;
22855: LD_ADDR_EXP 14
22859: PUSH
22860: LD_INT 1
22862: ST_TO_ADDR
22863: GO 22866
22865: POP
// end ; end_of_file
22866: PPOPN 3
22868: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22869: LD_INT 0
22871: PPUSH
22872: PPUSH
// skirmish := false ;
22873: LD_ADDR_EXP 78
22877: PUSH
22878: LD_INT 0
22880: ST_TO_ADDR
// debug_mc := false ;
22881: LD_ADDR_EXP 79
22885: PUSH
22886: LD_INT 0
22888: ST_TO_ADDR
// mc_bases := [ ] ;
22889: LD_ADDR_EXP 80
22893: PUSH
22894: EMPTY
22895: ST_TO_ADDR
// mc_sides := [ ] ;
22896: LD_ADDR_EXP 106
22900: PUSH
22901: EMPTY
22902: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22903: LD_ADDR_EXP 81
22907: PUSH
22908: EMPTY
22909: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22910: LD_ADDR_EXP 82
22914: PUSH
22915: EMPTY
22916: ST_TO_ADDR
// mc_need_heal := [ ] ;
22917: LD_ADDR_EXP 83
22921: PUSH
22922: EMPTY
22923: ST_TO_ADDR
// mc_healers := [ ] ;
22924: LD_ADDR_EXP 84
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// mc_build_list := [ ] ;
22931: LD_ADDR_EXP 85
22935: PUSH
22936: EMPTY
22937: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22938: LD_ADDR_EXP 112
22942: PUSH
22943: EMPTY
22944: ST_TO_ADDR
// mc_builders := [ ] ;
22945: LD_ADDR_EXP 86
22949: PUSH
22950: EMPTY
22951: ST_TO_ADDR
// mc_construct_list := [ ] ;
22952: LD_ADDR_EXP 87
22956: PUSH
22957: EMPTY
22958: ST_TO_ADDR
// mc_turret_list := [ ] ;
22959: LD_ADDR_EXP 88
22963: PUSH
22964: EMPTY
22965: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22966: LD_ADDR_EXP 89
22970: PUSH
22971: EMPTY
22972: ST_TO_ADDR
// mc_miners := [ ] ;
22973: LD_ADDR_EXP 94
22977: PUSH
22978: EMPTY
22979: ST_TO_ADDR
// mc_mines := [ ] ;
22980: LD_ADDR_EXP 93
22984: PUSH
22985: EMPTY
22986: ST_TO_ADDR
// mc_minefields := [ ] ;
22987: LD_ADDR_EXP 95
22991: PUSH
22992: EMPTY
22993: ST_TO_ADDR
// mc_crates := [ ] ;
22994: LD_ADDR_EXP 96
22998: PUSH
22999: EMPTY
23000: ST_TO_ADDR
// mc_crates_collector := [ ] ;
23001: LD_ADDR_EXP 97
23005: PUSH
23006: EMPTY
23007: ST_TO_ADDR
// mc_crates_area := [ ] ;
23008: LD_ADDR_EXP 98
23012: PUSH
23013: EMPTY
23014: ST_TO_ADDR
// mc_vehicles := [ ] ;
23015: LD_ADDR_EXP 99
23019: PUSH
23020: EMPTY
23021: ST_TO_ADDR
// mc_attack := [ ] ;
23022: LD_ADDR_EXP 100
23026: PUSH
23027: EMPTY
23028: ST_TO_ADDR
// mc_produce := [ ] ;
23029: LD_ADDR_EXP 101
23033: PUSH
23034: EMPTY
23035: ST_TO_ADDR
// mc_defender := [ ] ;
23036: LD_ADDR_EXP 102
23040: PUSH
23041: EMPTY
23042: ST_TO_ADDR
// mc_parking := [ ] ;
23043: LD_ADDR_EXP 104
23047: PUSH
23048: EMPTY
23049: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
23050: LD_ADDR_EXP 90
23054: PUSH
23055: EMPTY
23056: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
23057: LD_ADDR_EXP 92
23061: PUSH
23062: EMPTY
23063: ST_TO_ADDR
// mc_scan := [ ] ;
23064: LD_ADDR_EXP 103
23068: PUSH
23069: EMPTY
23070: ST_TO_ADDR
// mc_scan_area := [ ] ;
23071: LD_ADDR_EXP 105
23075: PUSH
23076: EMPTY
23077: ST_TO_ADDR
// mc_tech := [ ] ;
23078: LD_ADDR_EXP 107
23082: PUSH
23083: EMPTY
23084: ST_TO_ADDR
// mc_class := [ ] ;
23085: LD_ADDR_EXP 121
23089: PUSH
23090: EMPTY
23091: ST_TO_ADDR
// mc_class_case_use := [ ] ;
23092: LD_ADDR_EXP 122
23096: PUSH
23097: EMPTY
23098: ST_TO_ADDR
// mc_is_defending := [ ] ;
23099: LD_ADDR_EXP 123
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23106: LD_ADDR_EXP 114
23110: PUSH
23111: EMPTY
23112: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23113: LD_ADDR_EXP 124
23117: PUSH
23118: LD_INT 0
23120: ST_TO_ADDR
// end ;
23121: LD_VAR 0 1
23125: RET
// export function MC_Kill ( base ) ; begin
23126: LD_INT 0
23128: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23129: LD_ADDR_EXP 80
23133: PUSH
23134: LD_EXP 80
23138: PPUSH
23139: LD_VAR 0 1
23143: PPUSH
23144: EMPTY
23145: PPUSH
23146: CALL_OW 1
23150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23151: LD_ADDR_EXP 81
23155: PUSH
23156: LD_EXP 81
23160: PPUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: EMPTY
23167: PPUSH
23168: CALL_OW 1
23172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23173: LD_ADDR_EXP 82
23177: PUSH
23178: LD_EXP 82
23182: PPUSH
23183: LD_VAR 0 1
23187: PPUSH
23188: EMPTY
23189: PPUSH
23190: CALL_OW 1
23194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23195: LD_ADDR_EXP 83
23199: PUSH
23200: LD_EXP 83
23204: PPUSH
23205: LD_VAR 0 1
23209: PPUSH
23210: EMPTY
23211: PPUSH
23212: CALL_OW 1
23216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23217: LD_ADDR_EXP 84
23221: PUSH
23222: LD_EXP 84
23226: PPUSH
23227: LD_VAR 0 1
23231: PPUSH
23232: EMPTY
23233: PPUSH
23234: CALL_OW 1
23238: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23239: LD_ADDR_EXP 85
23243: PUSH
23244: LD_EXP 85
23248: PPUSH
23249: LD_VAR 0 1
23253: PPUSH
23254: EMPTY
23255: PPUSH
23256: CALL_OW 1
23260: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23261: LD_ADDR_EXP 86
23265: PUSH
23266: LD_EXP 86
23270: PPUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: EMPTY
23277: PPUSH
23278: CALL_OW 1
23282: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23283: LD_ADDR_EXP 87
23287: PUSH
23288: LD_EXP 87
23292: PPUSH
23293: LD_VAR 0 1
23297: PPUSH
23298: EMPTY
23299: PPUSH
23300: CALL_OW 1
23304: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23305: LD_ADDR_EXP 88
23309: PUSH
23310: LD_EXP 88
23314: PPUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: EMPTY
23321: PPUSH
23322: CALL_OW 1
23326: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23327: LD_ADDR_EXP 89
23331: PUSH
23332: LD_EXP 89
23336: PPUSH
23337: LD_VAR 0 1
23341: PPUSH
23342: EMPTY
23343: PPUSH
23344: CALL_OW 1
23348: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23349: LD_ADDR_EXP 90
23353: PUSH
23354: LD_EXP 90
23358: PPUSH
23359: LD_VAR 0 1
23363: PPUSH
23364: EMPTY
23365: PPUSH
23366: CALL_OW 1
23370: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23371: LD_ADDR_EXP 91
23375: PUSH
23376: LD_EXP 91
23380: PPUSH
23381: LD_VAR 0 1
23385: PPUSH
23386: LD_INT 0
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23394: LD_ADDR_EXP 92
23398: PUSH
23399: LD_EXP 92
23403: PPUSH
23404: LD_VAR 0 1
23408: PPUSH
23409: EMPTY
23410: PPUSH
23411: CALL_OW 1
23415: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23416: LD_ADDR_EXP 93
23420: PUSH
23421: LD_EXP 93
23425: PPUSH
23426: LD_VAR 0 1
23430: PPUSH
23431: EMPTY
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23438: LD_ADDR_EXP 94
23442: PUSH
23443: LD_EXP 94
23447: PPUSH
23448: LD_VAR 0 1
23452: PPUSH
23453: EMPTY
23454: PPUSH
23455: CALL_OW 1
23459: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23460: LD_ADDR_EXP 95
23464: PUSH
23465: LD_EXP 95
23469: PPUSH
23470: LD_VAR 0 1
23474: PPUSH
23475: EMPTY
23476: PPUSH
23477: CALL_OW 1
23481: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23482: LD_ADDR_EXP 96
23486: PUSH
23487: LD_EXP 96
23491: PPUSH
23492: LD_VAR 0 1
23496: PPUSH
23497: EMPTY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23504: LD_ADDR_EXP 97
23508: PUSH
23509: LD_EXP 97
23513: PPUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: EMPTY
23520: PPUSH
23521: CALL_OW 1
23525: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23526: LD_ADDR_EXP 98
23530: PUSH
23531: LD_EXP 98
23535: PPUSH
23536: LD_VAR 0 1
23540: PPUSH
23541: EMPTY
23542: PPUSH
23543: CALL_OW 1
23547: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23548: LD_ADDR_EXP 99
23552: PUSH
23553: LD_EXP 99
23557: PPUSH
23558: LD_VAR 0 1
23562: PPUSH
23563: EMPTY
23564: PPUSH
23565: CALL_OW 1
23569: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23570: LD_ADDR_EXP 100
23574: PUSH
23575: LD_EXP 100
23579: PPUSH
23580: LD_VAR 0 1
23584: PPUSH
23585: EMPTY
23586: PPUSH
23587: CALL_OW 1
23591: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23592: LD_ADDR_EXP 101
23596: PUSH
23597: LD_EXP 101
23601: PPUSH
23602: LD_VAR 0 1
23606: PPUSH
23607: EMPTY
23608: PPUSH
23609: CALL_OW 1
23613: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23614: LD_ADDR_EXP 102
23618: PUSH
23619: LD_EXP 102
23623: PPUSH
23624: LD_VAR 0 1
23628: PPUSH
23629: EMPTY
23630: PPUSH
23631: CALL_OW 1
23635: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23636: LD_ADDR_EXP 103
23640: PUSH
23641: LD_EXP 103
23645: PPUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: EMPTY
23652: PPUSH
23653: CALL_OW 1
23657: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23658: LD_ADDR_EXP 104
23662: PUSH
23663: LD_EXP 104
23667: PPUSH
23668: LD_VAR 0 1
23672: PPUSH
23673: EMPTY
23674: PPUSH
23675: CALL_OW 1
23679: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23680: LD_ADDR_EXP 105
23684: PUSH
23685: LD_EXP 105
23689: PPUSH
23690: LD_VAR 0 1
23694: PPUSH
23695: EMPTY
23696: PPUSH
23697: CALL_OW 1
23701: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23702: LD_ADDR_EXP 107
23706: PUSH
23707: LD_EXP 107
23711: PPUSH
23712: LD_VAR 0 1
23716: PPUSH
23717: EMPTY
23718: PPUSH
23719: CALL_OW 1
23723: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23724: LD_ADDR_EXP 109
23728: PUSH
23729: LD_EXP 109
23733: PPUSH
23734: LD_VAR 0 1
23738: PPUSH
23739: EMPTY
23740: PPUSH
23741: CALL_OW 1
23745: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23746: LD_ADDR_EXP 110
23750: PUSH
23751: LD_EXP 110
23755: PPUSH
23756: LD_VAR 0 1
23760: PPUSH
23761: EMPTY
23762: PPUSH
23763: CALL_OW 1
23767: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23768: LD_ADDR_EXP 111
23772: PUSH
23773: LD_EXP 111
23777: PPUSH
23778: LD_VAR 0 1
23782: PPUSH
23783: EMPTY
23784: PPUSH
23785: CALL_OW 1
23789: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23790: LD_ADDR_EXP 112
23794: PUSH
23795: LD_EXP 112
23799: PPUSH
23800: LD_VAR 0 1
23804: PPUSH
23805: EMPTY
23806: PPUSH
23807: CALL_OW 1
23811: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23812: LD_ADDR_EXP 113
23816: PUSH
23817: LD_EXP 113
23821: PPUSH
23822: LD_VAR 0 1
23826: PPUSH
23827: EMPTY
23828: PPUSH
23829: CALL_OW 1
23833: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23834: LD_ADDR_EXP 114
23838: PUSH
23839: LD_EXP 114
23843: PPUSH
23844: LD_VAR 0 1
23848: PPUSH
23849: EMPTY
23850: PPUSH
23851: CALL_OW 1
23855: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23856: LD_ADDR_EXP 115
23860: PUSH
23861: LD_EXP 115
23865: PPUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: EMPTY
23872: PPUSH
23873: CALL_OW 1
23877: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23878: LD_ADDR_EXP 116
23882: PUSH
23883: LD_EXP 116
23887: PPUSH
23888: LD_VAR 0 1
23892: PPUSH
23893: EMPTY
23894: PPUSH
23895: CALL_OW 1
23899: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23900: LD_ADDR_EXP 117
23904: PUSH
23905: LD_EXP 117
23909: PPUSH
23910: LD_VAR 0 1
23914: PPUSH
23915: EMPTY
23916: PPUSH
23917: CALL_OW 1
23921: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23922: LD_ADDR_EXP 118
23926: PUSH
23927: LD_EXP 118
23931: PPUSH
23932: LD_VAR 0 1
23936: PPUSH
23937: EMPTY
23938: PPUSH
23939: CALL_OW 1
23943: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23944: LD_ADDR_EXP 119
23948: PUSH
23949: LD_EXP 119
23953: PPUSH
23954: LD_VAR 0 1
23958: PPUSH
23959: EMPTY
23960: PPUSH
23961: CALL_OW 1
23965: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23966: LD_ADDR_EXP 120
23970: PUSH
23971: LD_EXP 120
23975: PPUSH
23976: LD_VAR 0 1
23980: PPUSH
23981: EMPTY
23982: PPUSH
23983: CALL_OW 1
23987: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23988: LD_ADDR_EXP 121
23992: PUSH
23993: LD_EXP 121
23997: PPUSH
23998: LD_VAR 0 1
24002: PPUSH
24003: EMPTY
24004: PPUSH
24005: CALL_OW 1
24009: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24010: LD_ADDR_EXP 122
24014: PUSH
24015: LD_EXP 122
24019: PPUSH
24020: LD_VAR 0 1
24024: PPUSH
24025: LD_INT 0
24027: PPUSH
24028: CALL_OW 1
24032: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24033: LD_ADDR_EXP 123
24037: PUSH
24038: LD_EXP 123
24042: PPUSH
24043: LD_VAR 0 1
24047: PPUSH
24048: LD_INT 0
24050: PPUSH
24051: CALL_OW 1
24055: ST_TO_ADDR
// end ;
24056: LD_VAR 0 2
24060: RET
// export function MC_Add ( side , units ) ; var base ; begin
24061: LD_INT 0
24063: PPUSH
24064: PPUSH
// base := mc_bases + 1 ;
24065: LD_ADDR_VAR 0 4
24069: PUSH
24070: LD_EXP 80
24074: PUSH
24075: LD_INT 1
24077: PLUS
24078: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
24079: LD_ADDR_EXP 106
24083: PUSH
24084: LD_EXP 106
24088: PPUSH
24089: LD_VAR 0 4
24093: PPUSH
24094: LD_VAR 0 1
24098: PPUSH
24099: CALL_OW 1
24103: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24104: LD_ADDR_EXP 80
24108: PUSH
24109: LD_EXP 80
24113: PPUSH
24114: LD_VAR 0 4
24118: PPUSH
24119: LD_VAR 0 2
24123: PPUSH
24124: CALL_OW 1
24128: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24129: LD_ADDR_EXP 81
24133: PUSH
24134: LD_EXP 81
24138: PPUSH
24139: LD_VAR 0 4
24143: PPUSH
24144: EMPTY
24145: PPUSH
24146: CALL_OW 1
24150: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24151: LD_ADDR_EXP 82
24155: PUSH
24156: LD_EXP 82
24160: PPUSH
24161: LD_VAR 0 4
24165: PPUSH
24166: EMPTY
24167: PPUSH
24168: CALL_OW 1
24172: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24173: LD_ADDR_EXP 83
24177: PUSH
24178: LD_EXP 83
24182: PPUSH
24183: LD_VAR 0 4
24187: PPUSH
24188: EMPTY
24189: PPUSH
24190: CALL_OW 1
24194: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24195: LD_ADDR_EXP 84
24199: PUSH
24200: LD_EXP 84
24204: PPUSH
24205: LD_VAR 0 4
24209: PPUSH
24210: EMPTY
24211: PPUSH
24212: CALL_OW 1
24216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24217: LD_ADDR_EXP 85
24221: PUSH
24222: LD_EXP 85
24226: PPUSH
24227: LD_VAR 0 4
24231: PPUSH
24232: EMPTY
24233: PPUSH
24234: CALL_OW 1
24238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24239: LD_ADDR_EXP 86
24243: PUSH
24244: LD_EXP 86
24248: PPUSH
24249: LD_VAR 0 4
24253: PPUSH
24254: EMPTY
24255: PPUSH
24256: CALL_OW 1
24260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24261: LD_ADDR_EXP 87
24265: PUSH
24266: LD_EXP 87
24270: PPUSH
24271: LD_VAR 0 4
24275: PPUSH
24276: EMPTY
24277: PPUSH
24278: CALL_OW 1
24282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24283: LD_ADDR_EXP 88
24287: PUSH
24288: LD_EXP 88
24292: PPUSH
24293: LD_VAR 0 4
24297: PPUSH
24298: EMPTY
24299: PPUSH
24300: CALL_OW 1
24304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24305: LD_ADDR_EXP 89
24309: PUSH
24310: LD_EXP 89
24314: PPUSH
24315: LD_VAR 0 4
24319: PPUSH
24320: EMPTY
24321: PPUSH
24322: CALL_OW 1
24326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24327: LD_ADDR_EXP 90
24331: PUSH
24332: LD_EXP 90
24336: PPUSH
24337: LD_VAR 0 4
24341: PPUSH
24342: EMPTY
24343: PPUSH
24344: CALL_OW 1
24348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24349: LD_ADDR_EXP 91
24353: PUSH
24354: LD_EXP 91
24358: PPUSH
24359: LD_VAR 0 4
24363: PPUSH
24364: LD_INT 0
24366: PPUSH
24367: CALL_OW 1
24371: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24372: LD_ADDR_EXP 92
24376: PUSH
24377: LD_EXP 92
24381: PPUSH
24382: LD_VAR 0 4
24386: PPUSH
24387: EMPTY
24388: PPUSH
24389: CALL_OW 1
24393: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24394: LD_ADDR_EXP 93
24398: PUSH
24399: LD_EXP 93
24403: PPUSH
24404: LD_VAR 0 4
24408: PPUSH
24409: EMPTY
24410: PPUSH
24411: CALL_OW 1
24415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24416: LD_ADDR_EXP 94
24420: PUSH
24421: LD_EXP 94
24425: PPUSH
24426: LD_VAR 0 4
24430: PPUSH
24431: EMPTY
24432: PPUSH
24433: CALL_OW 1
24437: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24438: LD_ADDR_EXP 95
24442: PUSH
24443: LD_EXP 95
24447: PPUSH
24448: LD_VAR 0 4
24452: PPUSH
24453: EMPTY
24454: PPUSH
24455: CALL_OW 1
24459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24460: LD_ADDR_EXP 96
24464: PUSH
24465: LD_EXP 96
24469: PPUSH
24470: LD_VAR 0 4
24474: PPUSH
24475: EMPTY
24476: PPUSH
24477: CALL_OW 1
24481: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24482: LD_ADDR_EXP 97
24486: PUSH
24487: LD_EXP 97
24491: PPUSH
24492: LD_VAR 0 4
24496: PPUSH
24497: EMPTY
24498: PPUSH
24499: CALL_OW 1
24503: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24504: LD_ADDR_EXP 98
24508: PUSH
24509: LD_EXP 98
24513: PPUSH
24514: LD_VAR 0 4
24518: PPUSH
24519: EMPTY
24520: PPUSH
24521: CALL_OW 1
24525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24526: LD_ADDR_EXP 99
24530: PUSH
24531: LD_EXP 99
24535: PPUSH
24536: LD_VAR 0 4
24540: PPUSH
24541: EMPTY
24542: PPUSH
24543: CALL_OW 1
24547: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24548: LD_ADDR_EXP 100
24552: PUSH
24553: LD_EXP 100
24557: PPUSH
24558: LD_VAR 0 4
24562: PPUSH
24563: EMPTY
24564: PPUSH
24565: CALL_OW 1
24569: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24570: LD_ADDR_EXP 101
24574: PUSH
24575: LD_EXP 101
24579: PPUSH
24580: LD_VAR 0 4
24584: PPUSH
24585: EMPTY
24586: PPUSH
24587: CALL_OW 1
24591: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24592: LD_ADDR_EXP 102
24596: PUSH
24597: LD_EXP 102
24601: PPUSH
24602: LD_VAR 0 4
24606: PPUSH
24607: EMPTY
24608: PPUSH
24609: CALL_OW 1
24613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24614: LD_ADDR_EXP 103
24618: PUSH
24619: LD_EXP 103
24623: PPUSH
24624: LD_VAR 0 4
24628: PPUSH
24629: EMPTY
24630: PPUSH
24631: CALL_OW 1
24635: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24636: LD_ADDR_EXP 104
24640: PUSH
24641: LD_EXP 104
24645: PPUSH
24646: LD_VAR 0 4
24650: PPUSH
24651: EMPTY
24652: PPUSH
24653: CALL_OW 1
24657: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24658: LD_ADDR_EXP 105
24662: PUSH
24663: LD_EXP 105
24667: PPUSH
24668: LD_VAR 0 4
24672: PPUSH
24673: EMPTY
24674: PPUSH
24675: CALL_OW 1
24679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24680: LD_ADDR_EXP 107
24684: PUSH
24685: LD_EXP 107
24689: PPUSH
24690: LD_VAR 0 4
24694: PPUSH
24695: EMPTY
24696: PPUSH
24697: CALL_OW 1
24701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24702: LD_ADDR_EXP 109
24706: PUSH
24707: LD_EXP 109
24711: PPUSH
24712: LD_VAR 0 4
24716: PPUSH
24717: EMPTY
24718: PPUSH
24719: CALL_OW 1
24723: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24724: LD_ADDR_EXP 110
24728: PUSH
24729: LD_EXP 110
24733: PPUSH
24734: LD_VAR 0 4
24738: PPUSH
24739: EMPTY
24740: PPUSH
24741: CALL_OW 1
24745: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24746: LD_ADDR_EXP 111
24750: PUSH
24751: LD_EXP 111
24755: PPUSH
24756: LD_VAR 0 4
24760: PPUSH
24761: EMPTY
24762: PPUSH
24763: CALL_OW 1
24767: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24768: LD_ADDR_EXP 112
24772: PUSH
24773: LD_EXP 112
24777: PPUSH
24778: LD_VAR 0 4
24782: PPUSH
24783: EMPTY
24784: PPUSH
24785: CALL_OW 1
24789: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24790: LD_ADDR_EXP 113
24794: PUSH
24795: LD_EXP 113
24799: PPUSH
24800: LD_VAR 0 4
24804: PPUSH
24805: EMPTY
24806: PPUSH
24807: CALL_OW 1
24811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24812: LD_ADDR_EXP 114
24816: PUSH
24817: LD_EXP 114
24821: PPUSH
24822: LD_VAR 0 4
24826: PPUSH
24827: EMPTY
24828: PPUSH
24829: CALL_OW 1
24833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24834: LD_ADDR_EXP 115
24838: PUSH
24839: LD_EXP 115
24843: PPUSH
24844: LD_VAR 0 4
24848: PPUSH
24849: EMPTY
24850: PPUSH
24851: CALL_OW 1
24855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24856: LD_ADDR_EXP 116
24860: PUSH
24861: LD_EXP 116
24865: PPUSH
24866: LD_VAR 0 4
24870: PPUSH
24871: EMPTY
24872: PPUSH
24873: CALL_OW 1
24877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24878: LD_ADDR_EXP 117
24882: PUSH
24883: LD_EXP 117
24887: PPUSH
24888: LD_VAR 0 4
24892: PPUSH
24893: EMPTY
24894: PPUSH
24895: CALL_OW 1
24899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24900: LD_ADDR_EXP 118
24904: PUSH
24905: LD_EXP 118
24909: PPUSH
24910: LD_VAR 0 4
24914: PPUSH
24915: EMPTY
24916: PPUSH
24917: CALL_OW 1
24921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24922: LD_ADDR_EXP 119
24926: PUSH
24927: LD_EXP 119
24931: PPUSH
24932: LD_VAR 0 4
24936: PPUSH
24937: EMPTY
24938: PPUSH
24939: CALL_OW 1
24943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24944: LD_ADDR_EXP 120
24948: PUSH
24949: LD_EXP 120
24953: PPUSH
24954: LD_VAR 0 4
24958: PPUSH
24959: EMPTY
24960: PPUSH
24961: CALL_OW 1
24965: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24966: LD_ADDR_EXP 121
24970: PUSH
24971: LD_EXP 121
24975: PPUSH
24976: LD_VAR 0 4
24980: PPUSH
24981: EMPTY
24982: PPUSH
24983: CALL_OW 1
24987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24988: LD_ADDR_EXP 122
24992: PUSH
24993: LD_EXP 122
24997: PPUSH
24998: LD_VAR 0 4
25002: PPUSH
25003: LD_INT 0
25005: PPUSH
25006: CALL_OW 1
25010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
25011: LD_ADDR_EXP 123
25015: PUSH
25016: LD_EXP 123
25020: PPUSH
25021: LD_VAR 0 4
25025: PPUSH
25026: LD_INT 0
25028: PPUSH
25029: CALL_OW 1
25033: ST_TO_ADDR
// result := base ;
25034: LD_ADDR_VAR 0 3
25038: PUSH
25039: LD_VAR 0 4
25043: ST_TO_ADDR
// end ;
25044: LD_VAR 0 3
25048: RET
// export function MC_Start ( ) ; var i ; begin
25049: LD_INT 0
25051: PPUSH
25052: PPUSH
// for i = 1 to mc_bases do
25053: LD_ADDR_VAR 0 2
25057: PUSH
25058: DOUBLE
25059: LD_INT 1
25061: DEC
25062: ST_TO_ADDR
25063: LD_EXP 80
25067: PUSH
25068: FOR_TO
25069: IFFALSE 26169
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
25071: LD_ADDR_EXP 80
25075: PUSH
25076: LD_EXP 80
25080: PPUSH
25081: LD_VAR 0 2
25085: PPUSH
25086: LD_EXP 80
25090: PUSH
25091: LD_VAR 0 2
25095: ARRAY
25096: PUSH
25097: LD_INT 0
25099: DIFF
25100: PPUSH
25101: CALL_OW 1
25105: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25106: LD_ADDR_EXP 81
25110: PUSH
25111: LD_EXP 81
25115: PPUSH
25116: LD_VAR 0 2
25120: PPUSH
25121: EMPTY
25122: PPUSH
25123: CALL_OW 1
25127: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25128: LD_ADDR_EXP 82
25132: PUSH
25133: LD_EXP 82
25137: PPUSH
25138: LD_VAR 0 2
25142: PPUSH
25143: EMPTY
25144: PPUSH
25145: CALL_OW 1
25149: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25150: LD_ADDR_EXP 83
25154: PUSH
25155: LD_EXP 83
25159: PPUSH
25160: LD_VAR 0 2
25164: PPUSH
25165: EMPTY
25166: PPUSH
25167: CALL_OW 1
25171: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25172: LD_ADDR_EXP 84
25176: PUSH
25177: LD_EXP 84
25181: PPUSH
25182: LD_VAR 0 2
25186: PPUSH
25187: EMPTY
25188: PUSH
25189: EMPTY
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PPUSH
25195: CALL_OW 1
25199: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25200: LD_ADDR_EXP 85
25204: PUSH
25205: LD_EXP 85
25209: PPUSH
25210: LD_VAR 0 2
25214: PPUSH
25215: EMPTY
25216: PPUSH
25217: CALL_OW 1
25221: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25222: LD_ADDR_EXP 112
25226: PUSH
25227: LD_EXP 112
25231: PPUSH
25232: LD_VAR 0 2
25236: PPUSH
25237: EMPTY
25238: PPUSH
25239: CALL_OW 1
25243: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25244: LD_ADDR_EXP 86
25248: PUSH
25249: LD_EXP 86
25253: PPUSH
25254: LD_VAR 0 2
25258: PPUSH
25259: EMPTY
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25266: LD_ADDR_EXP 87
25270: PUSH
25271: LD_EXP 87
25275: PPUSH
25276: LD_VAR 0 2
25280: PPUSH
25281: EMPTY
25282: PPUSH
25283: CALL_OW 1
25287: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25288: LD_ADDR_EXP 88
25292: PUSH
25293: LD_EXP 88
25297: PPUSH
25298: LD_VAR 0 2
25302: PPUSH
25303: LD_EXP 80
25307: PUSH
25308: LD_VAR 0 2
25312: ARRAY
25313: PPUSH
25314: LD_INT 2
25316: PUSH
25317: LD_INT 30
25319: PUSH
25320: LD_INT 32
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 30
25329: PUSH
25330: LD_INT 33
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: LIST
25341: PPUSH
25342: CALL_OW 72
25346: PPUSH
25347: CALL_OW 1
25351: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25352: LD_ADDR_EXP 89
25356: PUSH
25357: LD_EXP 89
25361: PPUSH
25362: LD_VAR 0 2
25366: PPUSH
25367: LD_EXP 80
25371: PUSH
25372: LD_VAR 0 2
25376: ARRAY
25377: PPUSH
25378: LD_INT 2
25380: PUSH
25381: LD_INT 30
25383: PUSH
25384: LD_INT 32
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 30
25393: PUSH
25394: LD_INT 31
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 58
25408: PUSH
25409: EMPTY
25410: LIST
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PPUSH
25416: CALL_OW 72
25420: PPUSH
25421: CALL_OW 1
25425: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25426: LD_ADDR_EXP 90
25430: PUSH
25431: LD_EXP 90
25435: PPUSH
25436: LD_VAR 0 2
25440: PPUSH
25441: EMPTY
25442: PPUSH
25443: CALL_OW 1
25447: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25448: LD_ADDR_EXP 94
25452: PUSH
25453: LD_EXP 94
25457: PPUSH
25458: LD_VAR 0 2
25462: PPUSH
25463: EMPTY
25464: PPUSH
25465: CALL_OW 1
25469: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25470: LD_ADDR_EXP 93
25474: PUSH
25475: LD_EXP 93
25479: PPUSH
25480: LD_VAR 0 2
25484: PPUSH
25485: EMPTY
25486: PPUSH
25487: CALL_OW 1
25491: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25492: LD_ADDR_EXP 95
25496: PUSH
25497: LD_EXP 95
25501: PPUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: EMPTY
25508: PPUSH
25509: CALL_OW 1
25513: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25514: LD_ADDR_EXP 96
25518: PUSH
25519: LD_EXP 96
25523: PPUSH
25524: LD_VAR 0 2
25528: PPUSH
25529: EMPTY
25530: PPUSH
25531: CALL_OW 1
25535: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25536: LD_ADDR_EXP 97
25540: PUSH
25541: LD_EXP 97
25545: PPUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: EMPTY
25552: PPUSH
25553: CALL_OW 1
25557: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25558: LD_ADDR_EXP 98
25562: PUSH
25563: LD_EXP 98
25567: PPUSH
25568: LD_VAR 0 2
25572: PPUSH
25573: EMPTY
25574: PPUSH
25575: CALL_OW 1
25579: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25580: LD_ADDR_EXP 99
25584: PUSH
25585: LD_EXP 99
25589: PPUSH
25590: LD_VAR 0 2
25594: PPUSH
25595: EMPTY
25596: PPUSH
25597: CALL_OW 1
25601: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25602: LD_ADDR_EXP 100
25606: PUSH
25607: LD_EXP 100
25611: PPUSH
25612: LD_VAR 0 2
25616: PPUSH
25617: EMPTY
25618: PPUSH
25619: CALL_OW 1
25623: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25624: LD_ADDR_EXP 101
25628: PUSH
25629: LD_EXP 101
25633: PPUSH
25634: LD_VAR 0 2
25638: PPUSH
25639: EMPTY
25640: PPUSH
25641: CALL_OW 1
25645: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25646: LD_ADDR_EXP 102
25650: PUSH
25651: LD_EXP 102
25655: PPUSH
25656: LD_VAR 0 2
25660: PPUSH
25661: EMPTY
25662: PPUSH
25663: CALL_OW 1
25667: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25668: LD_ADDR_EXP 91
25672: PUSH
25673: LD_EXP 91
25677: PPUSH
25678: LD_VAR 0 2
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 1
25690: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25691: LD_ADDR_EXP 104
25695: PUSH
25696: LD_EXP 104
25700: PPUSH
25701: LD_VAR 0 2
25705: PPUSH
25706: LD_INT 0
25708: PPUSH
25709: CALL_OW 1
25713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25714: LD_ADDR_EXP 92
25718: PUSH
25719: LD_EXP 92
25723: PPUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: EMPTY
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25736: LD_ADDR_EXP 103
25740: PUSH
25741: LD_EXP 103
25745: PPUSH
25746: LD_VAR 0 2
25750: PPUSH
25751: LD_INT 0
25753: PPUSH
25754: CALL_OW 1
25758: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25759: LD_ADDR_EXP 105
25763: PUSH
25764: LD_EXP 105
25768: PPUSH
25769: LD_VAR 0 2
25773: PPUSH
25774: EMPTY
25775: PPUSH
25776: CALL_OW 1
25780: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25781: LD_ADDR_EXP 108
25785: PUSH
25786: LD_EXP 108
25790: PPUSH
25791: LD_VAR 0 2
25795: PPUSH
25796: LD_INT 0
25798: PPUSH
25799: CALL_OW 1
25803: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25804: LD_ADDR_EXP 109
25808: PUSH
25809: LD_EXP 109
25813: PPUSH
25814: LD_VAR 0 2
25818: PPUSH
25819: EMPTY
25820: PPUSH
25821: CALL_OW 1
25825: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25826: LD_ADDR_EXP 110
25830: PUSH
25831: LD_EXP 110
25835: PPUSH
25836: LD_VAR 0 2
25840: PPUSH
25841: EMPTY
25842: PPUSH
25843: CALL_OW 1
25847: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25848: LD_ADDR_EXP 111
25852: PUSH
25853: LD_EXP 111
25857: PPUSH
25858: LD_VAR 0 2
25862: PPUSH
25863: EMPTY
25864: PPUSH
25865: CALL_OW 1
25869: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25870: LD_ADDR_EXP 113
25874: PUSH
25875: LD_EXP 113
25879: PPUSH
25880: LD_VAR 0 2
25884: PPUSH
25885: LD_EXP 80
25889: PUSH
25890: LD_VAR 0 2
25894: ARRAY
25895: PPUSH
25896: LD_INT 2
25898: PUSH
25899: LD_INT 30
25901: PUSH
25902: LD_INT 6
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PUSH
25909: LD_INT 30
25911: PUSH
25912: LD_INT 7
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 30
25921: PUSH
25922: LD_INT 8
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: PPUSH
25935: CALL_OW 72
25939: PPUSH
25940: CALL_OW 1
25944: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25945: LD_ADDR_EXP 114
25949: PUSH
25950: LD_EXP 114
25954: PPUSH
25955: LD_VAR 0 2
25959: PPUSH
25960: EMPTY
25961: PPUSH
25962: CALL_OW 1
25966: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25967: LD_ADDR_EXP 115
25971: PUSH
25972: LD_EXP 115
25976: PPUSH
25977: LD_VAR 0 2
25981: PPUSH
25982: EMPTY
25983: PPUSH
25984: CALL_OW 1
25988: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25989: LD_ADDR_EXP 116
25993: PUSH
25994: LD_EXP 116
25998: PPUSH
25999: LD_VAR 0 2
26003: PPUSH
26004: EMPTY
26005: PPUSH
26006: CALL_OW 1
26010: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
26011: LD_ADDR_EXP 117
26015: PUSH
26016: LD_EXP 117
26020: PPUSH
26021: LD_VAR 0 2
26025: PPUSH
26026: EMPTY
26027: PPUSH
26028: CALL_OW 1
26032: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
26033: LD_ADDR_EXP 118
26037: PUSH
26038: LD_EXP 118
26042: PPUSH
26043: LD_VAR 0 2
26047: PPUSH
26048: EMPTY
26049: PPUSH
26050: CALL_OW 1
26054: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
26055: LD_ADDR_EXP 119
26059: PUSH
26060: LD_EXP 119
26064: PPUSH
26065: LD_VAR 0 2
26069: PPUSH
26070: EMPTY
26071: PPUSH
26072: CALL_OW 1
26076: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
26077: LD_ADDR_EXP 120
26081: PUSH
26082: LD_EXP 120
26086: PPUSH
26087: LD_VAR 0 2
26091: PPUSH
26092: EMPTY
26093: PPUSH
26094: CALL_OW 1
26098: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26099: LD_ADDR_EXP 121
26103: PUSH
26104: LD_EXP 121
26108: PPUSH
26109: LD_VAR 0 2
26113: PPUSH
26114: EMPTY
26115: PPUSH
26116: CALL_OW 1
26120: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26121: LD_ADDR_EXP 122
26125: PUSH
26126: LD_EXP 122
26130: PPUSH
26131: LD_VAR 0 2
26135: PPUSH
26136: LD_INT 0
26138: PPUSH
26139: CALL_OW 1
26143: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26144: LD_ADDR_EXP 123
26148: PUSH
26149: LD_EXP 123
26153: PPUSH
26154: LD_VAR 0 2
26158: PPUSH
26159: LD_INT 0
26161: PPUSH
26162: CALL_OW 1
26166: ST_TO_ADDR
// end ;
26167: GO 25068
26169: POP
26170: POP
// MC_InitSides ( ) ;
26171: CALL 26457 0 0
// MC_InitResearch ( ) ;
26175: CALL 26196 0 0
// CustomInitMacro ( ) ;
26179: CALL 252 0 0
// skirmish := true ;
26183: LD_ADDR_EXP 78
26187: PUSH
26188: LD_INT 1
26190: ST_TO_ADDR
// end ;
26191: LD_VAR 0 1
26195: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26196: LD_INT 0
26198: PPUSH
26199: PPUSH
26200: PPUSH
26201: PPUSH
26202: PPUSH
26203: PPUSH
// if not mc_bases then
26204: LD_EXP 80
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26452
// for i = 1 to 8 do
26213: LD_ADDR_VAR 0 2
26217: PUSH
26218: DOUBLE
26219: LD_INT 1
26221: DEC
26222: ST_TO_ADDR
26223: LD_INT 8
26225: PUSH
26226: FOR_TO
26227: IFFALSE 26253
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26229: LD_ADDR_EXP 107
26233: PUSH
26234: LD_EXP 107
26238: PPUSH
26239: LD_VAR 0 2
26243: PPUSH
26244: EMPTY
26245: PPUSH
26246: CALL_OW 1
26250: ST_TO_ADDR
26251: GO 26226
26253: POP
26254: POP
// tmp := [ ] ;
26255: LD_ADDR_VAR 0 5
26259: PUSH
26260: EMPTY
26261: ST_TO_ADDR
// for i = 1 to mc_sides do
26262: LD_ADDR_VAR 0 2
26266: PUSH
26267: DOUBLE
26268: LD_INT 1
26270: DEC
26271: ST_TO_ADDR
26272: LD_EXP 106
26276: PUSH
26277: FOR_TO
26278: IFFALSE 26336
// if not mc_sides [ i ] in tmp then
26280: LD_EXP 106
26284: PUSH
26285: LD_VAR 0 2
26289: ARRAY
26290: PUSH
26291: LD_VAR 0 5
26295: IN
26296: NOT
26297: IFFALSE 26334
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26299: LD_ADDR_VAR 0 5
26303: PUSH
26304: LD_VAR 0 5
26308: PPUSH
26309: LD_VAR 0 5
26313: PUSH
26314: LD_INT 1
26316: PLUS
26317: PPUSH
26318: LD_EXP 106
26322: PUSH
26323: LD_VAR 0 2
26327: ARRAY
26328: PPUSH
26329: CALL_OW 2
26333: ST_TO_ADDR
26334: GO 26277
26336: POP
26337: POP
// if not tmp then
26338: LD_VAR 0 5
26342: NOT
26343: IFFALSE 26347
// exit ;
26345: GO 26452
// for j in tmp do
26347: LD_ADDR_VAR 0 3
26351: PUSH
26352: LD_VAR 0 5
26356: PUSH
26357: FOR_IN
26358: IFFALSE 26450
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26360: LD_ADDR_VAR 0 6
26364: PUSH
26365: LD_INT 22
26367: PUSH
26368: LD_VAR 0 3
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PPUSH
26377: CALL_OW 69
26381: ST_TO_ADDR
// if not un then
26382: LD_VAR 0 6
26386: NOT
26387: IFFALSE 26391
// continue ;
26389: GO 26357
// nation := GetNation ( un [ 1 ] ) ;
26391: LD_ADDR_VAR 0 4
26395: PUSH
26396: LD_VAR 0 6
26400: PUSH
26401: LD_INT 1
26403: ARRAY
26404: PPUSH
26405: CALL_OW 248
26409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26410: LD_ADDR_EXP 107
26414: PUSH
26415: LD_EXP 107
26419: PPUSH
26420: LD_VAR 0 3
26424: PPUSH
26425: LD_VAR 0 3
26429: PPUSH
26430: LD_VAR 0 4
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: CALL 53640 0 3
26442: PPUSH
26443: CALL_OW 1
26447: ST_TO_ADDR
// end ;
26448: GO 26357
26450: POP
26451: POP
// end ;
26452: LD_VAR 0 1
26456: RET
// export function MC_InitSides ( ) ; var i ; begin
26457: LD_INT 0
26459: PPUSH
26460: PPUSH
// if not mc_bases then
26461: LD_EXP 80
26465: NOT
26466: IFFALSE 26470
// exit ;
26468: GO 26544
// for i = 1 to mc_bases do
26470: LD_ADDR_VAR 0 2
26474: PUSH
26475: DOUBLE
26476: LD_INT 1
26478: DEC
26479: ST_TO_ADDR
26480: LD_EXP 80
26484: PUSH
26485: FOR_TO
26486: IFFALSE 26542
// if mc_bases [ i ] then
26488: LD_EXP 80
26492: PUSH
26493: LD_VAR 0 2
26497: ARRAY
26498: IFFALSE 26540
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26500: LD_ADDR_EXP 106
26504: PUSH
26505: LD_EXP 106
26509: PPUSH
26510: LD_VAR 0 2
26514: PPUSH
26515: LD_EXP 80
26519: PUSH
26520: LD_VAR 0 2
26524: ARRAY
26525: PUSH
26526: LD_INT 1
26528: ARRAY
26529: PPUSH
26530: CALL_OW 255
26534: PPUSH
26535: CALL_OW 1
26539: ST_TO_ADDR
26540: GO 26485
26542: POP
26543: POP
// end ;
26544: LD_VAR 0 1
26548: RET
// every 0 0$03 trigger skirmish do
26549: LD_EXP 78
26553: IFFALSE 26707
26555: GO 26557
26557: DISABLE
// begin enable ;
26558: ENABLE
// MC_CheckBuildings ( ) ;
26559: CALL 31219 0 0
// MC_CheckPeopleLife ( ) ;
26563: CALL 31380 0 0
// RaiseSailEvent ( 100 ) ;
26567: LD_INT 100
26569: PPUSH
26570: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26574: LD_INT 103
26576: PPUSH
26577: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26581: LD_INT 104
26583: PPUSH
26584: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26588: LD_INT 105
26590: PPUSH
26591: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26595: LD_INT 106
26597: PPUSH
26598: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26602: LD_INT 107
26604: PPUSH
26605: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26609: LD_INT 108
26611: PPUSH
26612: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26616: LD_INT 109
26618: PPUSH
26619: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26623: LD_INT 110
26625: PPUSH
26626: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26630: LD_INT 111
26632: PPUSH
26633: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26637: LD_INT 112
26639: PPUSH
26640: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26644: LD_INT 113
26646: PPUSH
26647: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26651: LD_INT 120
26653: PPUSH
26654: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26658: LD_INT 121
26660: PPUSH
26661: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26665: LD_INT 122
26667: PPUSH
26668: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26672: LD_INT 123
26674: PPUSH
26675: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26679: LD_INT 124
26681: PPUSH
26682: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26686: LD_INT 125
26688: PPUSH
26689: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26693: LD_INT 126
26695: PPUSH
26696: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26700: LD_INT 200
26702: PPUSH
26703: CALL_OW 427
// end ;
26707: END
// on SailEvent ( event ) do begin if event < 100 then
26708: LD_VAR 0 1
26712: PUSH
26713: LD_INT 100
26715: LESS
26716: IFFALSE 26727
// CustomEvent ( event ) ;
26718: LD_VAR 0 1
26722: PPUSH
26723: CALL 11838 0 1
// if event = 100 then
26727: LD_VAR 0 1
26731: PUSH
26732: LD_INT 100
26734: EQUAL
26735: IFFALSE 26741
// MC_ClassManager ( ) ;
26737: CALL 27133 0 0
// if event = 101 then
26741: LD_VAR 0 1
26745: PUSH
26746: LD_INT 101
26748: EQUAL
26749: IFFALSE 26755
// MC_RepairBuildings ( ) ;
26751: CALL 31965 0 0
// if event = 102 then
26755: LD_VAR 0 1
26759: PUSH
26760: LD_INT 102
26762: EQUAL
26763: IFFALSE 26769
// MC_Heal ( ) ;
26765: CALL 32900 0 0
// if event = 103 then
26769: LD_VAR 0 1
26773: PUSH
26774: LD_INT 103
26776: EQUAL
26777: IFFALSE 26783
// MC_Build ( ) ;
26779: CALL 33322 0 0
// if event = 104 then
26783: LD_VAR 0 1
26787: PUSH
26788: LD_INT 104
26790: EQUAL
26791: IFFALSE 26797
// MC_TurretWeapon ( ) ;
26793: CALL 34956 0 0
// if event = 105 then
26797: LD_VAR 0 1
26801: PUSH
26802: LD_INT 105
26804: EQUAL
26805: IFFALSE 26811
// MC_BuildUpgrade ( ) ;
26807: CALL 34507 0 0
// if event = 106 then
26811: LD_VAR 0 1
26815: PUSH
26816: LD_INT 106
26818: EQUAL
26819: IFFALSE 26825
// MC_PlantMines ( ) ;
26821: CALL 35386 0 0
// if event = 107 then
26825: LD_VAR 0 1
26829: PUSH
26830: LD_INT 107
26832: EQUAL
26833: IFFALSE 26839
// MC_CollectCrates ( ) ;
26835: CALL 36184 0 0
// if event = 108 then
26839: LD_VAR 0 1
26843: PUSH
26844: LD_INT 108
26846: EQUAL
26847: IFFALSE 26853
// MC_LinkRemoteControl ( ) ;
26849: CALL 38034 0 0
// if event = 109 then
26853: LD_VAR 0 1
26857: PUSH
26858: LD_INT 109
26860: EQUAL
26861: IFFALSE 26867
// MC_ProduceVehicle ( ) ;
26863: CALL 38215 0 0
// if event = 110 then
26867: LD_VAR 0 1
26871: PUSH
26872: LD_INT 110
26874: EQUAL
26875: IFFALSE 26881
// MC_SendAttack ( ) ;
26877: CALL 38681 0 0
// if event = 111 then
26881: LD_VAR 0 1
26885: PUSH
26886: LD_INT 111
26888: EQUAL
26889: IFFALSE 26895
// MC_Defend ( ) ;
26891: CALL 38789 0 0
// if event = 112 then
26895: LD_VAR 0 1
26899: PUSH
26900: LD_INT 112
26902: EQUAL
26903: IFFALSE 26909
// MC_Research ( ) ;
26905: CALL 39669 0 0
// if event = 113 then
26909: LD_VAR 0 1
26913: PUSH
26914: LD_INT 113
26916: EQUAL
26917: IFFALSE 26923
// MC_MinesTrigger ( ) ;
26919: CALL 40783 0 0
// if event = 120 then
26923: LD_VAR 0 1
26927: PUSH
26928: LD_INT 120
26930: EQUAL
26931: IFFALSE 26937
// MC_RepairVehicle ( ) ;
26933: CALL 40882 0 0
// if event = 121 then
26937: LD_VAR 0 1
26941: PUSH
26942: LD_INT 121
26944: EQUAL
26945: IFFALSE 26951
// MC_TameApe ( ) ;
26947: CALL 41651 0 0
// if event = 122 then
26951: LD_VAR 0 1
26955: PUSH
26956: LD_INT 122
26958: EQUAL
26959: IFFALSE 26965
// MC_ChangeApeClass ( ) ;
26961: CALL 42480 0 0
// if event = 123 then
26965: LD_VAR 0 1
26969: PUSH
26970: LD_INT 123
26972: EQUAL
26973: IFFALSE 26979
// MC_Bazooka ( ) ;
26975: CALL 43130 0 0
// if event = 124 then
26979: LD_VAR 0 1
26983: PUSH
26984: LD_INT 124
26986: EQUAL
26987: IFFALSE 26993
// MC_TeleportExit ( ) ;
26989: CALL 43328 0 0
// if event = 125 then
26993: LD_VAR 0 1
26997: PUSH
26998: LD_INT 125
27000: EQUAL
27001: IFFALSE 27007
// MC_Deposits ( ) ;
27003: CALL 43975 0 0
// if event = 126 then
27007: LD_VAR 0 1
27011: PUSH
27012: LD_INT 126
27014: EQUAL
27015: IFFALSE 27021
// MC_RemoteDriver ( ) ;
27017: CALL 44600 0 0
// if event = 200 then
27021: LD_VAR 0 1
27025: PUSH
27026: LD_INT 200
27028: EQUAL
27029: IFFALSE 27035
// MC_Idle ( ) ;
27031: CALL 46507 0 0
// end ;
27035: PPOPN 1
27037: END
// export function MC_Reset ( base , tag ) ; var i ; begin
27038: LD_INT 0
27040: PPUSH
27041: PPUSH
// if not mc_bases [ base ] or not tag then
27042: LD_EXP 80
27046: PUSH
27047: LD_VAR 0 1
27051: ARRAY
27052: NOT
27053: PUSH
27054: LD_VAR 0 2
27058: NOT
27059: OR
27060: IFFALSE 27064
// exit ;
27062: GO 27128
// for i in mc_bases [ base ] union mc_ape [ base ] do
27064: LD_ADDR_VAR 0 4
27068: PUSH
27069: LD_EXP 80
27073: PUSH
27074: LD_VAR 0 1
27078: ARRAY
27079: PUSH
27080: LD_EXP 109
27084: PUSH
27085: LD_VAR 0 1
27089: ARRAY
27090: UNION
27091: PUSH
27092: FOR_IN
27093: IFFALSE 27126
// if GetTag ( i ) = tag then
27095: LD_VAR 0 4
27099: PPUSH
27100: CALL_OW 110
27104: PUSH
27105: LD_VAR 0 2
27109: EQUAL
27110: IFFALSE 27124
// SetTag ( i , 0 ) ;
27112: LD_VAR 0 4
27116: PPUSH
27117: LD_INT 0
27119: PPUSH
27120: CALL_OW 109
27124: GO 27092
27126: POP
27127: POP
// end ;
27128: LD_VAR 0 3
27132: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27133: LD_INT 0
27135: PPUSH
27136: PPUSH
27137: PPUSH
27138: PPUSH
27139: PPUSH
27140: PPUSH
27141: PPUSH
27142: PPUSH
// if not mc_bases then
27143: LD_EXP 80
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27601
// for i = 1 to mc_bases do
27152: LD_ADDR_VAR 0 2
27156: PUSH
27157: DOUBLE
27158: LD_INT 1
27160: DEC
27161: ST_TO_ADDR
27162: LD_EXP 80
27166: PUSH
27167: FOR_TO
27168: IFFALSE 27599
// begin tmp := MC_ClassCheckReq ( i ) ;
27170: LD_ADDR_VAR 0 4
27174: PUSH
27175: LD_VAR 0 2
27179: PPUSH
27180: CALL 27606 0 1
27184: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27185: LD_ADDR_EXP 121
27189: PUSH
27190: LD_EXP 121
27194: PPUSH
27195: LD_VAR 0 2
27199: PPUSH
27200: LD_VAR 0 4
27204: PPUSH
27205: CALL_OW 1
27209: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27210: LD_ADDR_VAR 0 6
27214: PUSH
27215: LD_EXP 80
27219: PUSH
27220: LD_VAR 0 2
27224: ARRAY
27225: PPUSH
27226: LD_INT 2
27228: PUSH
27229: LD_INT 30
27231: PUSH
27232: LD_INT 4
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PUSH
27239: LD_INT 30
27241: PUSH
27242: LD_INT 5
27244: PUSH
27245: EMPTY
27246: LIST
27247: LIST
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: LIST
27253: PPUSH
27254: CALL_OW 72
27258: PUSH
27259: LD_EXP 80
27263: PUSH
27264: LD_VAR 0 2
27268: ARRAY
27269: PPUSH
27270: LD_INT 2
27272: PUSH
27273: LD_INT 30
27275: PUSH
27276: LD_INT 0
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: LD_INT 30
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: LIST
27297: PPUSH
27298: CALL_OW 72
27302: PUSH
27303: LD_EXP 80
27307: PUSH
27308: LD_VAR 0 2
27312: ARRAY
27313: PPUSH
27314: LD_INT 30
27316: PUSH
27317: LD_INT 3
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: PUSH
27329: LD_EXP 80
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: PPUSH
27340: LD_INT 2
27342: PUSH
27343: LD_INT 30
27345: PUSH
27346: LD_INT 6
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 30
27355: PUSH
27356: LD_INT 7
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 30
27365: PUSH
27366: LD_INT 8
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: PPUSH
27379: CALL_OW 72
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: ST_TO_ADDR
// for j := 1 to 4 do
27390: LD_ADDR_VAR 0 3
27394: PUSH
27395: DOUBLE
27396: LD_INT 1
27398: DEC
27399: ST_TO_ADDR
27400: LD_INT 4
27402: PUSH
27403: FOR_TO
27404: IFFALSE 27595
// begin if not tmp [ j ] then
27406: LD_VAR 0 4
27410: PUSH
27411: LD_VAR 0 3
27415: ARRAY
27416: NOT
27417: IFFALSE 27421
// continue ;
27419: GO 27403
// for p in tmp [ j ] do
27421: LD_ADDR_VAR 0 5
27425: PUSH
27426: LD_VAR 0 4
27430: PUSH
27431: LD_VAR 0 3
27435: ARRAY
27436: PUSH
27437: FOR_IN
27438: IFFALSE 27591
// begin if not b [ j ] then
27440: LD_VAR 0 6
27444: PUSH
27445: LD_VAR 0 3
27449: ARRAY
27450: NOT
27451: IFFALSE 27455
// break ;
27453: GO 27591
// e := 0 ;
27455: LD_ADDR_VAR 0 7
27459: PUSH
27460: LD_INT 0
27462: ST_TO_ADDR
// for k in b [ j ] do
27463: LD_ADDR_VAR 0 8
27467: PUSH
27468: LD_VAR 0 6
27472: PUSH
27473: LD_VAR 0 3
27477: ARRAY
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27507
// if IsNotFull ( k ) then
27482: LD_VAR 0 8
27486: PPUSH
27487: CALL 55761 0 1
27491: IFFALSE 27505
// begin e := k ;
27493: LD_ADDR_VAR 0 7
27497: PUSH
27498: LD_VAR 0 8
27502: ST_TO_ADDR
// break ;
27503: GO 27507
// end ;
27505: GO 27479
27507: POP
27508: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27509: LD_VAR 0 7
27513: PUSH
27514: LD_VAR 0 5
27518: PPUSH
27519: LD_VAR 0 7
27523: PPUSH
27524: CALL 89900 0 2
27528: NOT
27529: AND
27530: IFFALSE 27589
// begin if IsInUnit ( p ) then
27532: LD_VAR 0 5
27536: PPUSH
27537: CALL_OW 310
27541: IFFALSE 27552
// ComExitBuilding ( p ) ;
27543: LD_VAR 0 5
27547: PPUSH
27548: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27552: LD_VAR 0 5
27556: PPUSH
27557: LD_VAR 0 7
27561: PPUSH
27562: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27566: LD_VAR 0 5
27570: PPUSH
27571: LD_VAR 0 3
27575: PPUSH
27576: CALL_OW 183
// AddComExitBuilding ( p ) ;
27580: LD_VAR 0 5
27584: PPUSH
27585: CALL_OW 182
// end ; end ;
27589: GO 27437
27591: POP
27592: POP
// end ;
27593: GO 27403
27595: POP
27596: POP
// end ;
27597: GO 27167
27599: POP
27600: POP
// end ;
27601: LD_VAR 0 1
27605: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27606: LD_INT 0
27608: PPUSH
27609: PPUSH
27610: PPUSH
27611: PPUSH
27612: PPUSH
27613: PPUSH
27614: PPUSH
27615: PPUSH
27616: PPUSH
27617: PPUSH
27618: PPUSH
27619: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27620: LD_ADDR_VAR 0 2
27624: PUSH
27625: LD_INT 0
27627: PUSH
27628: LD_INT 0
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 0
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27643: LD_VAR 0 1
27647: NOT
27648: PUSH
27649: LD_EXP 80
27653: PUSH
27654: LD_VAR 0 1
27658: ARRAY
27659: NOT
27660: OR
27661: PUSH
27662: LD_EXP 80
27666: PUSH
27667: LD_VAR 0 1
27671: ARRAY
27672: PPUSH
27673: LD_INT 2
27675: PUSH
27676: LD_INT 30
27678: PUSH
27679: LD_INT 0
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 30
27688: PUSH
27689: LD_INT 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: LIST
27700: PPUSH
27701: CALL_OW 72
27705: NOT
27706: OR
27707: IFFALSE 27711
// exit ;
27709: GO 31214
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27711: LD_ADDR_VAR 0 4
27715: PUSH
27716: LD_EXP 80
27720: PUSH
27721: LD_VAR 0 1
27725: ARRAY
27726: PPUSH
27727: LD_INT 2
27729: PUSH
27730: LD_INT 25
27732: PUSH
27733: LD_INT 1
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: LD_INT 25
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 25
27752: PUSH
27753: LD_INT 3
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PUSH
27760: LD_INT 25
27762: PUSH
27763: LD_INT 4
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: LD_INT 25
27772: PUSH
27773: LD_INT 5
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 25
27782: PUSH
27783: LD_INT 8
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 25
27792: PUSH
27793: LD_INT 9
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: PPUSH
27810: CALL_OW 72
27814: ST_TO_ADDR
// if not tmp then
27815: LD_VAR 0 4
27819: NOT
27820: IFFALSE 27824
// exit ;
27822: GO 31214
// for i in tmp do
27824: LD_ADDR_VAR 0 3
27828: PUSH
27829: LD_VAR 0 4
27833: PUSH
27834: FOR_IN
27835: IFFALSE 27866
// if GetTag ( i ) then
27837: LD_VAR 0 3
27841: PPUSH
27842: CALL_OW 110
27846: IFFALSE 27864
// tmp := tmp diff i ;
27848: LD_ADDR_VAR 0 4
27852: PUSH
27853: LD_VAR 0 4
27857: PUSH
27858: LD_VAR 0 3
27862: DIFF
27863: ST_TO_ADDR
27864: GO 27834
27866: POP
27867: POP
// if not tmp then
27868: LD_VAR 0 4
27872: NOT
27873: IFFALSE 27877
// exit ;
27875: GO 31214
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27877: LD_ADDR_VAR 0 5
27881: PUSH
27882: LD_EXP 80
27886: PUSH
27887: LD_VAR 0 1
27891: ARRAY
27892: PPUSH
27893: LD_INT 2
27895: PUSH
27896: LD_INT 25
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 25
27908: PUSH
27909: LD_INT 5
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 25
27918: PUSH
27919: LD_INT 8
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 25
27928: PUSH
27929: LD_INT 9
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: PPUSH
27943: CALL_OW 72
27947: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27948: LD_ADDR_VAR 0 6
27952: PUSH
27953: LD_EXP 80
27957: PUSH
27958: LD_VAR 0 1
27962: ARRAY
27963: PPUSH
27964: LD_INT 25
27966: PUSH
27967: LD_INT 2
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PPUSH
27974: CALL_OW 72
27978: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27979: LD_ADDR_VAR 0 7
27983: PUSH
27984: LD_EXP 80
27988: PUSH
27989: LD_VAR 0 1
27993: ARRAY
27994: PPUSH
27995: LD_INT 25
27997: PUSH
27998: LD_INT 3
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PPUSH
28005: CALL_OW 72
28009: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
28010: LD_ADDR_VAR 0 8
28014: PUSH
28015: LD_EXP 80
28019: PUSH
28020: LD_VAR 0 1
28024: ARRAY
28025: PPUSH
28026: LD_INT 25
28028: PUSH
28029: LD_INT 4
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 24
28038: PUSH
28039: LD_INT 251
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PPUSH
28050: CALL_OW 72
28054: ST_TO_ADDR
// if mc_is_defending [ base ] then
28055: LD_EXP 123
28059: PUSH
28060: LD_VAR 0 1
28064: ARRAY
28065: IFFALSE 28526
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
28067: LD_ADDR_EXP 122
28071: PUSH
28072: LD_EXP 122
28076: PPUSH
28077: LD_VAR 0 1
28081: PPUSH
28082: LD_INT 4
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
28090: LD_ADDR_VAR 0 12
28094: PUSH
28095: LD_EXP 80
28099: PUSH
28100: LD_VAR 0 1
28104: ARRAY
28105: PPUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 30
28111: PUSH
28112: LD_INT 4
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 30
28121: PUSH
28122: LD_INT 5
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: PPUSH
28134: CALL_OW 72
28138: ST_TO_ADDR
// if not b then
28139: LD_VAR 0 12
28143: NOT
28144: IFFALSE 28148
// exit ;
28146: GO 31214
// p := [ ] ;
28148: LD_ADDR_VAR 0 11
28152: PUSH
28153: EMPTY
28154: ST_TO_ADDR
// if sci >= 2 then
28155: LD_VAR 0 8
28159: PUSH
28160: LD_INT 2
28162: GREATEREQUAL
28163: IFFALSE 28194
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28165: LD_ADDR_VAR 0 8
28169: PUSH
28170: LD_VAR 0 8
28174: PUSH
28175: LD_INT 1
28177: ARRAY
28178: PUSH
28179: LD_VAR 0 8
28183: PUSH
28184: LD_INT 2
28186: ARRAY
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: ST_TO_ADDR
28192: GO 28255
// if sci = 1 then
28194: LD_VAR 0 8
28198: PUSH
28199: LD_INT 1
28201: EQUAL
28202: IFFALSE 28223
// sci := [ sci [ 1 ] ] else
28204: LD_ADDR_VAR 0 8
28208: PUSH
28209: LD_VAR 0 8
28213: PUSH
28214: LD_INT 1
28216: ARRAY
28217: PUSH
28218: EMPTY
28219: LIST
28220: ST_TO_ADDR
28221: GO 28255
// if sci = 0 then
28223: LD_VAR 0 8
28227: PUSH
28228: LD_INT 0
28230: EQUAL
28231: IFFALSE 28255
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28233: LD_ADDR_VAR 0 11
28237: PUSH
28238: LD_VAR 0 4
28242: PPUSH
28243: LD_INT 4
28245: PPUSH
28246: CALL 89772 0 2
28250: PUSH
28251: LD_INT 1
28253: ARRAY
28254: ST_TO_ADDR
// if eng > 4 then
28255: LD_VAR 0 6
28259: PUSH
28260: LD_INT 4
28262: GREATER
28263: IFFALSE 28309
// for i = eng downto 4 do
28265: LD_ADDR_VAR 0 3
28269: PUSH
28270: DOUBLE
28271: LD_VAR 0 6
28275: INC
28276: ST_TO_ADDR
28277: LD_INT 4
28279: PUSH
28280: FOR_DOWNTO
28281: IFFALSE 28307
// eng := eng diff eng [ i ] ;
28283: LD_ADDR_VAR 0 6
28287: PUSH
28288: LD_VAR 0 6
28292: PUSH
28293: LD_VAR 0 6
28297: PUSH
28298: LD_VAR 0 3
28302: ARRAY
28303: DIFF
28304: ST_TO_ADDR
28305: GO 28280
28307: POP
28308: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28309: LD_ADDR_VAR 0 4
28313: PUSH
28314: LD_VAR 0 4
28318: PUSH
28319: LD_VAR 0 5
28323: PUSH
28324: LD_VAR 0 6
28328: UNION
28329: PUSH
28330: LD_VAR 0 7
28334: UNION
28335: PUSH
28336: LD_VAR 0 8
28340: UNION
28341: DIFF
28342: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28343: LD_ADDR_VAR 0 13
28347: PUSH
28348: LD_EXP 80
28352: PUSH
28353: LD_VAR 0 1
28357: ARRAY
28358: PPUSH
28359: LD_INT 2
28361: PUSH
28362: LD_INT 30
28364: PUSH
28365: LD_INT 32
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 30
28374: PUSH
28375: LD_INT 31
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: LIST
28386: PPUSH
28387: CALL_OW 72
28391: PUSH
28392: LD_EXP 80
28396: PUSH
28397: LD_VAR 0 1
28401: ARRAY
28402: PPUSH
28403: LD_INT 2
28405: PUSH
28406: LD_INT 30
28408: PUSH
28409: LD_INT 4
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 30
28418: PUSH
28419: LD_INT 5
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: LIST
28430: PPUSH
28431: CALL_OW 72
28435: PUSH
28436: LD_INT 6
28438: MUL
28439: PLUS
28440: ST_TO_ADDR
// if bcount < tmp then
28441: LD_VAR 0 13
28445: PUSH
28446: LD_VAR 0 4
28450: LESS
28451: IFFALSE 28497
// for i = tmp downto bcount do
28453: LD_ADDR_VAR 0 3
28457: PUSH
28458: DOUBLE
28459: LD_VAR 0 4
28463: INC
28464: ST_TO_ADDR
28465: LD_VAR 0 13
28469: PUSH
28470: FOR_DOWNTO
28471: IFFALSE 28495
// tmp := Delete ( tmp , tmp ) ;
28473: LD_ADDR_VAR 0 4
28477: PUSH
28478: LD_VAR 0 4
28482: PPUSH
28483: LD_VAR 0 4
28487: PPUSH
28488: CALL_OW 3
28492: ST_TO_ADDR
28493: GO 28470
28495: POP
28496: POP
// result := [ tmp , 0 , 0 , p ] ;
28497: LD_ADDR_VAR 0 2
28501: PUSH
28502: LD_VAR 0 4
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: LD_INT 0
28512: PUSH
28513: LD_VAR 0 11
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: ST_TO_ADDR
// exit ;
28524: GO 31214
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28526: LD_EXP 80
28530: PUSH
28531: LD_VAR 0 1
28535: ARRAY
28536: PPUSH
28537: LD_INT 2
28539: PUSH
28540: LD_INT 30
28542: PUSH
28543: LD_INT 6
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 30
28552: PUSH
28553: LD_INT 7
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 30
28562: PUSH
28563: LD_INT 8
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: PPUSH
28576: CALL_OW 72
28580: NOT
28581: PUSH
28582: LD_EXP 80
28586: PUSH
28587: LD_VAR 0 1
28591: ARRAY
28592: PPUSH
28593: LD_INT 30
28595: PUSH
28596: LD_INT 3
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PPUSH
28603: CALL_OW 72
28607: NOT
28608: AND
28609: IFFALSE 28681
// begin if eng = tmp then
28611: LD_VAR 0 6
28615: PUSH
28616: LD_VAR 0 4
28620: EQUAL
28621: IFFALSE 28625
// exit ;
28623: GO 31214
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28625: LD_ADDR_EXP 122
28629: PUSH
28630: LD_EXP 122
28634: PPUSH
28635: LD_VAR 0 1
28639: PPUSH
28640: LD_INT 1
28642: PPUSH
28643: CALL_OW 1
28647: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_VAR 0 4
28660: PUSH
28661: LD_VAR 0 6
28665: DIFF
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: LIST
28677: LIST
28678: ST_TO_ADDR
// exit ;
28679: GO 31214
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28681: LD_EXP 107
28685: PUSH
28686: LD_EXP 106
28690: PUSH
28691: LD_VAR 0 1
28695: ARRAY
28696: ARRAY
28697: PUSH
28698: LD_EXP 80
28702: PUSH
28703: LD_VAR 0 1
28707: ARRAY
28708: PPUSH
28709: LD_INT 2
28711: PUSH
28712: LD_INT 30
28714: PUSH
28715: LD_INT 6
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 30
28724: PUSH
28725: LD_INT 7
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 30
28734: PUSH
28735: LD_INT 8
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: PPUSH
28748: CALL_OW 72
28752: AND
28753: PUSH
28754: LD_EXP 80
28758: PUSH
28759: LD_VAR 0 1
28763: ARRAY
28764: PPUSH
28765: LD_INT 30
28767: PUSH
28768: LD_INT 3
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PPUSH
28775: CALL_OW 72
28779: NOT
28780: AND
28781: IFFALSE 28995
// begin if sci >= 6 then
28783: LD_VAR 0 8
28787: PUSH
28788: LD_INT 6
28790: GREATEREQUAL
28791: IFFALSE 28795
// exit ;
28793: GO 31214
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28795: LD_ADDR_EXP 122
28799: PUSH
28800: LD_EXP 122
28804: PPUSH
28805: LD_VAR 0 1
28809: PPUSH
28810: LD_INT 2
28812: PPUSH
28813: CALL_OW 1
28817: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28818: LD_ADDR_VAR 0 9
28822: PUSH
28823: LD_VAR 0 4
28827: PUSH
28828: LD_VAR 0 8
28832: DIFF
28833: PPUSH
28834: LD_INT 4
28836: PPUSH
28837: CALL 89772 0 2
28841: ST_TO_ADDR
// p := [ ] ;
28842: LD_ADDR_VAR 0 11
28846: PUSH
28847: EMPTY
28848: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28849: LD_VAR 0 8
28853: PUSH
28854: LD_INT 6
28856: LESS
28857: PUSH
28858: LD_VAR 0 9
28862: PUSH
28863: LD_INT 6
28865: GREATER
28866: AND
28867: IFFALSE 28948
// begin for i = 1 to 6 - sci do
28869: LD_ADDR_VAR 0 3
28873: PUSH
28874: DOUBLE
28875: LD_INT 1
28877: DEC
28878: ST_TO_ADDR
28879: LD_INT 6
28881: PUSH
28882: LD_VAR 0 8
28886: MINUS
28887: PUSH
28888: FOR_TO
28889: IFFALSE 28944
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28891: LD_ADDR_VAR 0 11
28895: PUSH
28896: LD_VAR 0 11
28900: PPUSH
28901: LD_VAR 0 11
28905: PUSH
28906: LD_INT 1
28908: PLUS
28909: PPUSH
28910: LD_VAR 0 9
28914: PUSH
28915: LD_INT 1
28917: ARRAY
28918: PPUSH
28919: CALL_OW 2
28923: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28924: LD_ADDR_VAR 0 9
28928: PUSH
28929: LD_VAR 0 9
28933: PPUSH
28934: LD_INT 1
28936: PPUSH
28937: CALL_OW 3
28941: ST_TO_ADDR
// end ;
28942: GO 28888
28944: POP
28945: POP
// end else
28946: GO 28968
// if sort then
28948: LD_VAR 0 9
28952: IFFALSE 28968
// p := sort [ 1 ] ;
28954: LD_ADDR_VAR 0 11
28958: PUSH
28959: LD_VAR 0 9
28963: PUSH
28964: LD_INT 1
28966: ARRAY
28967: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28968: LD_ADDR_VAR 0 2
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 0
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: LD_VAR 0 11
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// exit ;
28993: GO 31214
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28995: LD_EXP 107
28999: PUSH
29000: LD_EXP 106
29004: PUSH
29005: LD_VAR 0 1
29009: ARRAY
29010: ARRAY
29011: PUSH
29012: LD_EXP 80
29016: PUSH
29017: LD_VAR 0 1
29021: ARRAY
29022: PPUSH
29023: LD_INT 2
29025: PUSH
29026: LD_INT 30
29028: PUSH
29029: LD_INT 6
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: LD_INT 30
29038: PUSH
29039: LD_INT 7
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 30
29048: PUSH
29049: LD_INT 8
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: PPUSH
29062: CALL_OW 72
29066: AND
29067: PUSH
29068: LD_EXP 80
29072: PUSH
29073: LD_VAR 0 1
29077: ARRAY
29078: PPUSH
29079: LD_INT 30
29081: PUSH
29082: LD_INT 3
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PPUSH
29089: CALL_OW 72
29093: AND
29094: IFFALSE 29828
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
29096: LD_ADDR_EXP 122
29100: PUSH
29101: LD_EXP 122
29105: PPUSH
29106: LD_VAR 0 1
29110: PPUSH
29111: LD_INT 3
29113: PPUSH
29114: CALL_OW 1
29118: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29119: LD_ADDR_VAR 0 2
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: LD_INT 0
29129: PUSH
29130: LD_INT 0
29132: PUSH
29133: LD_INT 0
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: LIST
29140: LIST
29141: ST_TO_ADDR
// if not eng then
29142: LD_VAR 0 6
29146: NOT
29147: IFFALSE 29210
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29149: LD_ADDR_VAR 0 11
29153: PUSH
29154: LD_VAR 0 4
29158: PPUSH
29159: LD_INT 2
29161: PPUSH
29162: CALL 89772 0 2
29166: PUSH
29167: LD_INT 1
29169: ARRAY
29170: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29171: LD_ADDR_VAR 0 2
29175: PUSH
29176: LD_VAR 0 2
29180: PPUSH
29181: LD_INT 2
29183: PPUSH
29184: LD_VAR 0 11
29188: PPUSH
29189: CALL_OW 1
29193: ST_TO_ADDR
// tmp := tmp diff p ;
29194: LD_ADDR_VAR 0 4
29198: PUSH
29199: LD_VAR 0 4
29203: PUSH
29204: LD_VAR 0 11
29208: DIFF
29209: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29210: LD_VAR 0 4
29214: PUSH
29215: LD_VAR 0 8
29219: PUSH
29220: LD_INT 6
29222: LESS
29223: AND
29224: IFFALSE 29412
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29226: LD_ADDR_VAR 0 9
29230: PUSH
29231: LD_VAR 0 4
29235: PUSH
29236: LD_VAR 0 8
29240: PUSH
29241: LD_VAR 0 7
29245: UNION
29246: DIFF
29247: PPUSH
29248: LD_INT 4
29250: PPUSH
29251: CALL 89772 0 2
29255: ST_TO_ADDR
// p := [ ] ;
29256: LD_ADDR_VAR 0 11
29260: PUSH
29261: EMPTY
29262: ST_TO_ADDR
// if sort then
29263: LD_VAR 0 9
29267: IFFALSE 29383
// for i = 1 to 6 - sci do
29269: LD_ADDR_VAR 0 3
29273: PUSH
29274: DOUBLE
29275: LD_INT 1
29277: DEC
29278: ST_TO_ADDR
29279: LD_INT 6
29281: PUSH
29282: LD_VAR 0 8
29286: MINUS
29287: PUSH
29288: FOR_TO
29289: IFFALSE 29381
// begin if i = sort then
29291: LD_VAR 0 3
29295: PUSH
29296: LD_VAR 0 9
29300: EQUAL
29301: IFFALSE 29305
// break ;
29303: GO 29381
// if GetClass ( i ) = 4 then
29305: LD_VAR 0 3
29309: PPUSH
29310: CALL_OW 257
29314: PUSH
29315: LD_INT 4
29317: EQUAL
29318: IFFALSE 29322
// continue ;
29320: GO 29288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29322: LD_ADDR_VAR 0 11
29326: PUSH
29327: LD_VAR 0 11
29331: PPUSH
29332: LD_VAR 0 11
29336: PUSH
29337: LD_INT 1
29339: PLUS
29340: PPUSH
29341: LD_VAR 0 9
29345: PUSH
29346: LD_VAR 0 3
29350: ARRAY
29351: PPUSH
29352: CALL_OW 2
29356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29357: LD_ADDR_VAR 0 4
29361: PUSH
29362: LD_VAR 0 4
29366: PUSH
29367: LD_VAR 0 9
29371: PUSH
29372: LD_VAR 0 3
29376: ARRAY
29377: DIFF
29378: ST_TO_ADDR
// end ;
29379: GO 29288
29381: POP
29382: POP
// if p then
29383: LD_VAR 0 11
29387: IFFALSE 29412
// result := Replace ( result , 4 , p ) ;
29389: LD_ADDR_VAR 0 2
29393: PUSH
29394: LD_VAR 0 2
29398: PPUSH
29399: LD_INT 4
29401: PPUSH
29402: LD_VAR 0 11
29406: PPUSH
29407: CALL_OW 1
29411: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29412: LD_VAR 0 4
29416: PUSH
29417: LD_VAR 0 7
29421: PUSH
29422: LD_INT 6
29424: LESS
29425: AND
29426: IFFALSE 29614
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29428: LD_ADDR_VAR 0 9
29432: PUSH
29433: LD_VAR 0 4
29437: PUSH
29438: LD_VAR 0 8
29442: PUSH
29443: LD_VAR 0 7
29447: UNION
29448: DIFF
29449: PPUSH
29450: LD_INT 3
29452: PPUSH
29453: CALL 89772 0 2
29457: ST_TO_ADDR
// p := [ ] ;
29458: LD_ADDR_VAR 0 11
29462: PUSH
29463: EMPTY
29464: ST_TO_ADDR
// if sort then
29465: LD_VAR 0 9
29469: IFFALSE 29585
// for i = 1 to 6 - mech do
29471: LD_ADDR_VAR 0 3
29475: PUSH
29476: DOUBLE
29477: LD_INT 1
29479: DEC
29480: ST_TO_ADDR
29481: LD_INT 6
29483: PUSH
29484: LD_VAR 0 7
29488: MINUS
29489: PUSH
29490: FOR_TO
29491: IFFALSE 29583
// begin if i = sort then
29493: LD_VAR 0 3
29497: PUSH
29498: LD_VAR 0 9
29502: EQUAL
29503: IFFALSE 29507
// break ;
29505: GO 29583
// if GetClass ( i ) = 3 then
29507: LD_VAR 0 3
29511: PPUSH
29512: CALL_OW 257
29516: PUSH
29517: LD_INT 3
29519: EQUAL
29520: IFFALSE 29524
// continue ;
29522: GO 29490
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29524: LD_ADDR_VAR 0 11
29528: PUSH
29529: LD_VAR 0 11
29533: PPUSH
29534: LD_VAR 0 11
29538: PUSH
29539: LD_INT 1
29541: PLUS
29542: PPUSH
29543: LD_VAR 0 9
29547: PUSH
29548: LD_VAR 0 3
29552: ARRAY
29553: PPUSH
29554: CALL_OW 2
29558: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29559: LD_ADDR_VAR 0 4
29563: PUSH
29564: LD_VAR 0 4
29568: PUSH
29569: LD_VAR 0 9
29573: PUSH
29574: LD_VAR 0 3
29578: ARRAY
29579: DIFF
29580: ST_TO_ADDR
// end ;
29581: GO 29490
29583: POP
29584: POP
// if p then
29585: LD_VAR 0 11
29589: IFFALSE 29614
// result := Replace ( result , 3 , p ) ;
29591: LD_ADDR_VAR 0 2
29595: PUSH
29596: LD_VAR 0 2
29600: PPUSH
29601: LD_INT 3
29603: PPUSH
29604: LD_VAR 0 11
29608: PPUSH
29609: CALL_OW 1
29613: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29614: LD_VAR 0 4
29618: PUSH
29619: LD_INT 6
29621: GREATER
29622: PUSH
29623: LD_VAR 0 6
29627: PUSH
29628: LD_INT 6
29630: LESS
29631: AND
29632: IFFALSE 29826
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29634: LD_ADDR_VAR 0 9
29638: PUSH
29639: LD_VAR 0 4
29643: PUSH
29644: LD_VAR 0 8
29648: PUSH
29649: LD_VAR 0 7
29653: UNION
29654: PUSH
29655: LD_VAR 0 6
29659: UNION
29660: DIFF
29661: PPUSH
29662: LD_INT 2
29664: PPUSH
29665: CALL 89772 0 2
29669: ST_TO_ADDR
// p := [ ] ;
29670: LD_ADDR_VAR 0 11
29674: PUSH
29675: EMPTY
29676: ST_TO_ADDR
// if sort then
29677: LD_VAR 0 9
29681: IFFALSE 29797
// for i = 1 to 6 - eng do
29683: LD_ADDR_VAR 0 3
29687: PUSH
29688: DOUBLE
29689: LD_INT 1
29691: DEC
29692: ST_TO_ADDR
29693: LD_INT 6
29695: PUSH
29696: LD_VAR 0 6
29700: MINUS
29701: PUSH
29702: FOR_TO
29703: IFFALSE 29795
// begin if i = sort then
29705: LD_VAR 0 3
29709: PUSH
29710: LD_VAR 0 9
29714: EQUAL
29715: IFFALSE 29719
// break ;
29717: GO 29795
// if GetClass ( i ) = 2 then
29719: LD_VAR 0 3
29723: PPUSH
29724: CALL_OW 257
29728: PUSH
29729: LD_INT 2
29731: EQUAL
29732: IFFALSE 29736
// continue ;
29734: GO 29702
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29736: LD_ADDR_VAR 0 11
29740: PUSH
29741: LD_VAR 0 11
29745: PPUSH
29746: LD_VAR 0 11
29750: PUSH
29751: LD_INT 1
29753: PLUS
29754: PPUSH
29755: LD_VAR 0 9
29759: PUSH
29760: LD_VAR 0 3
29764: ARRAY
29765: PPUSH
29766: CALL_OW 2
29770: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29771: LD_ADDR_VAR 0 4
29775: PUSH
29776: LD_VAR 0 4
29780: PUSH
29781: LD_VAR 0 9
29785: PUSH
29786: LD_VAR 0 3
29790: ARRAY
29791: DIFF
29792: ST_TO_ADDR
// end ;
29793: GO 29702
29795: POP
29796: POP
// if p then
29797: LD_VAR 0 11
29801: IFFALSE 29826
// result := Replace ( result , 2 , p ) ;
29803: LD_ADDR_VAR 0 2
29807: PUSH
29808: LD_VAR 0 2
29812: PPUSH
29813: LD_INT 2
29815: PPUSH
29816: LD_VAR 0 11
29820: PPUSH
29821: CALL_OW 1
29825: ST_TO_ADDR
// end ; exit ;
29826: GO 31214
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29828: LD_EXP 107
29832: PUSH
29833: LD_EXP 106
29837: PUSH
29838: LD_VAR 0 1
29842: ARRAY
29843: ARRAY
29844: NOT
29845: PUSH
29846: LD_EXP 80
29850: PUSH
29851: LD_VAR 0 1
29855: ARRAY
29856: PPUSH
29857: LD_INT 30
29859: PUSH
29860: LD_INT 3
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 72
29871: AND
29872: PUSH
29873: LD_EXP 85
29877: PUSH
29878: LD_VAR 0 1
29882: ARRAY
29883: AND
29884: IFFALSE 30492
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29886: LD_ADDR_EXP 122
29890: PUSH
29891: LD_EXP 122
29895: PPUSH
29896: LD_VAR 0 1
29900: PPUSH
29901: LD_INT 5
29903: PPUSH
29904: CALL_OW 1
29908: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29909: LD_ADDR_VAR 0 2
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: LD_INT 0
29919: PUSH
29920: LD_INT 0
29922: PUSH
29923: LD_INT 0
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: ST_TO_ADDR
// if sci > 1 then
29932: LD_VAR 0 8
29936: PUSH
29937: LD_INT 1
29939: GREATER
29940: IFFALSE 29968
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29942: LD_ADDR_VAR 0 4
29946: PUSH
29947: LD_VAR 0 4
29951: PUSH
29952: LD_VAR 0 8
29956: PUSH
29957: LD_VAR 0 8
29961: PUSH
29962: LD_INT 1
29964: ARRAY
29965: DIFF
29966: DIFF
29967: ST_TO_ADDR
// if tmp and not sci then
29968: LD_VAR 0 4
29972: PUSH
29973: LD_VAR 0 8
29977: NOT
29978: AND
29979: IFFALSE 30048
// begin sort := SortBySkill ( tmp , 4 ) ;
29981: LD_ADDR_VAR 0 9
29985: PUSH
29986: LD_VAR 0 4
29990: PPUSH
29991: LD_INT 4
29993: PPUSH
29994: CALL 89772 0 2
29998: ST_TO_ADDR
// if sort then
29999: LD_VAR 0 9
30003: IFFALSE 30019
// p := sort [ 1 ] ;
30005: LD_ADDR_VAR 0 11
30009: PUSH
30010: LD_VAR 0 9
30014: PUSH
30015: LD_INT 1
30017: ARRAY
30018: ST_TO_ADDR
// if p then
30019: LD_VAR 0 11
30023: IFFALSE 30048
// result := Replace ( result , 4 , p ) ;
30025: LD_ADDR_VAR 0 2
30029: PUSH
30030: LD_VAR 0 2
30034: PPUSH
30035: LD_INT 4
30037: PPUSH
30038: LD_VAR 0 11
30042: PPUSH
30043: CALL_OW 1
30047: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30048: LD_ADDR_VAR 0 4
30052: PUSH
30053: LD_VAR 0 4
30057: PUSH
30058: LD_VAR 0 7
30062: DIFF
30063: ST_TO_ADDR
// if tmp and mech < 6 then
30064: LD_VAR 0 4
30068: PUSH
30069: LD_VAR 0 7
30073: PUSH
30074: LD_INT 6
30076: LESS
30077: AND
30078: IFFALSE 30266
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
30080: LD_ADDR_VAR 0 9
30084: PUSH
30085: LD_VAR 0 4
30089: PUSH
30090: LD_VAR 0 8
30094: PUSH
30095: LD_VAR 0 7
30099: UNION
30100: DIFF
30101: PPUSH
30102: LD_INT 3
30104: PPUSH
30105: CALL 89772 0 2
30109: ST_TO_ADDR
// p := [ ] ;
30110: LD_ADDR_VAR 0 11
30114: PUSH
30115: EMPTY
30116: ST_TO_ADDR
// if sort then
30117: LD_VAR 0 9
30121: IFFALSE 30237
// for i = 1 to 6 - mech do
30123: LD_ADDR_VAR 0 3
30127: PUSH
30128: DOUBLE
30129: LD_INT 1
30131: DEC
30132: ST_TO_ADDR
30133: LD_INT 6
30135: PUSH
30136: LD_VAR 0 7
30140: MINUS
30141: PUSH
30142: FOR_TO
30143: IFFALSE 30235
// begin if i = sort then
30145: LD_VAR 0 3
30149: PUSH
30150: LD_VAR 0 9
30154: EQUAL
30155: IFFALSE 30159
// break ;
30157: GO 30235
// if GetClass ( i ) = 3 then
30159: LD_VAR 0 3
30163: PPUSH
30164: CALL_OW 257
30168: PUSH
30169: LD_INT 3
30171: EQUAL
30172: IFFALSE 30176
// continue ;
30174: GO 30142
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30176: LD_ADDR_VAR 0 11
30180: PUSH
30181: LD_VAR 0 11
30185: PPUSH
30186: LD_VAR 0 11
30190: PUSH
30191: LD_INT 1
30193: PLUS
30194: PPUSH
30195: LD_VAR 0 9
30199: PUSH
30200: LD_VAR 0 3
30204: ARRAY
30205: PPUSH
30206: CALL_OW 2
30210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30211: LD_ADDR_VAR 0 4
30215: PUSH
30216: LD_VAR 0 4
30220: PUSH
30221: LD_VAR 0 9
30225: PUSH
30226: LD_VAR 0 3
30230: ARRAY
30231: DIFF
30232: ST_TO_ADDR
// end ;
30233: GO 30142
30235: POP
30236: POP
// if p then
30237: LD_VAR 0 11
30241: IFFALSE 30266
// result := Replace ( result , 3 , p ) ;
30243: LD_ADDR_VAR 0 2
30247: PUSH
30248: LD_VAR 0 2
30252: PPUSH
30253: LD_INT 3
30255: PPUSH
30256: LD_VAR 0 11
30260: PPUSH
30261: CALL_OW 1
30265: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30266: LD_ADDR_VAR 0 4
30270: PUSH
30271: LD_VAR 0 4
30275: PUSH
30276: LD_VAR 0 6
30280: DIFF
30281: ST_TO_ADDR
// if tmp and eng < 6 then
30282: LD_VAR 0 4
30286: PUSH
30287: LD_VAR 0 6
30291: PUSH
30292: LD_INT 6
30294: LESS
30295: AND
30296: IFFALSE 30490
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30298: LD_ADDR_VAR 0 9
30302: PUSH
30303: LD_VAR 0 4
30307: PUSH
30308: LD_VAR 0 8
30312: PUSH
30313: LD_VAR 0 7
30317: UNION
30318: PUSH
30319: LD_VAR 0 6
30323: UNION
30324: DIFF
30325: PPUSH
30326: LD_INT 2
30328: PPUSH
30329: CALL 89772 0 2
30333: ST_TO_ADDR
// p := [ ] ;
30334: LD_ADDR_VAR 0 11
30338: PUSH
30339: EMPTY
30340: ST_TO_ADDR
// if sort then
30341: LD_VAR 0 9
30345: IFFALSE 30461
// for i = 1 to 6 - eng do
30347: LD_ADDR_VAR 0 3
30351: PUSH
30352: DOUBLE
30353: LD_INT 1
30355: DEC
30356: ST_TO_ADDR
30357: LD_INT 6
30359: PUSH
30360: LD_VAR 0 6
30364: MINUS
30365: PUSH
30366: FOR_TO
30367: IFFALSE 30459
// begin if i = sort then
30369: LD_VAR 0 3
30373: PUSH
30374: LD_VAR 0 9
30378: EQUAL
30379: IFFALSE 30383
// break ;
30381: GO 30459
// if GetClass ( i ) = 2 then
30383: LD_VAR 0 3
30387: PPUSH
30388: CALL_OW 257
30392: PUSH
30393: LD_INT 2
30395: EQUAL
30396: IFFALSE 30400
// continue ;
30398: GO 30366
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30400: LD_ADDR_VAR 0 11
30404: PUSH
30405: LD_VAR 0 11
30409: PPUSH
30410: LD_VAR 0 11
30414: PUSH
30415: LD_INT 1
30417: PLUS
30418: PPUSH
30419: LD_VAR 0 9
30423: PUSH
30424: LD_VAR 0 3
30428: ARRAY
30429: PPUSH
30430: CALL_OW 2
30434: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30435: LD_ADDR_VAR 0 4
30439: PUSH
30440: LD_VAR 0 4
30444: PUSH
30445: LD_VAR 0 9
30449: PUSH
30450: LD_VAR 0 3
30454: ARRAY
30455: DIFF
30456: ST_TO_ADDR
// end ;
30457: GO 30366
30459: POP
30460: POP
// if p then
30461: LD_VAR 0 11
30465: IFFALSE 30490
// result := Replace ( result , 2 , p ) ;
30467: LD_ADDR_VAR 0 2
30471: PUSH
30472: LD_VAR 0 2
30476: PPUSH
30477: LD_INT 2
30479: PPUSH
30480: LD_VAR 0 11
30484: PPUSH
30485: CALL_OW 1
30489: ST_TO_ADDR
// end ; exit ;
30490: GO 31214
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30492: LD_EXP 107
30496: PUSH
30497: LD_EXP 106
30501: PUSH
30502: LD_VAR 0 1
30506: ARRAY
30507: ARRAY
30508: NOT
30509: PUSH
30510: LD_EXP 80
30514: PUSH
30515: LD_VAR 0 1
30519: ARRAY
30520: PPUSH
30521: LD_INT 30
30523: PUSH
30524: LD_INT 3
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PPUSH
30531: CALL_OW 72
30535: AND
30536: PUSH
30537: LD_EXP 85
30541: PUSH
30542: LD_VAR 0 1
30546: ARRAY
30547: NOT
30548: AND
30549: IFFALSE 31214
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30551: LD_ADDR_EXP 122
30555: PUSH
30556: LD_EXP 122
30560: PPUSH
30561: LD_VAR 0 1
30565: PPUSH
30566: LD_INT 6
30568: PPUSH
30569: CALL_OW 1
30573: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30574: LD_ADDR_VAR 0 2
30578: PUSH
30579: LD_INT 0
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: ST_TO_ADDR
// if sci >= 1 then
30597: LD_VAR 0 8
30601: PUSH
30602: LD_INT 1
30604: GREATEREQUAL
30605: IFFALSE 30627
// tmp := tmp diff sci [ 1 ] ;
30607: LD_ADDR_VAR 0 4
30611: PUSH
30612: LD_VAR 0 4
30616: PUSH
30617: LD_VAR 0 8
30621: PUSH
30622: LD_INT 1
30624: ARRAY
30625: DIFF
30626: ST_TO_ADDR
// if tmp and not sci then
30627: LD_VAR 0 4
30631: PUSH
30632: LD_VAR 0 8
30636: NOT
30637: AND
30638: IFFALSE 30707
// begin sort := SortBySkill ( tmp , 4 ) ;
30640: LD_ADDR_VAR 0 9
30644: PUSH
30645: LD_VAR 0 4
30649: PPUSH
30650: LD_INT 4
30652: PPUSH
30653: CALL 89772 0 2
30657: ST_TO_ADDR
// if sort then
30658: LD_VAR 0 9
30662: IFFALSE 30678
// p := sort [ 1 ] ;
30664: LD_ADDR_VAR 0 11
30668: PUSH
30669: LD_VAR 0 9
30673: PUSH
30674: LD_INT 1
30676: ARRAY
30677: ST_TO_ADDR
// if p then
30678: LD_VAR 0 11
30682: IFFALSE 30707
// result := Replace ( result , 4 , p ) ;
30684: LD_ADDR_VAR 0 2
30688: PUSH
30689: LD_VAR 0 2
30693: PPUSH
30694: LD_INT 4
30696: PPUSH
30697: LD_VAR 0 11
30701: PPUSH
30702: CALL_OW 1
30706: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30707: LD_ADDR_VAR 0 4
30711: PUSH
30712: LD_VAR 0 4
30716: PUSH
30717: LD_VAR 0 7
30721: DIFF
30722: ST_TO_ADDR
// if tmp and mech < 6 then
30723: LD_VAR 0 4
30727: PUSH
30728: LD_VAR 0 7
30732: PUSH
30733: LD_INT 6
30735: LESS
30736: AND
30737: IFFALSE 30919
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30739: LD_ADDR_VAR 0 9
30743: PUSH
30744: LD_VAR 0 4
30748: PUSH
30749: LD_VAR 0 7
30753: DIFF
30754: PPUSH
30755: LD_INT 3
30757: PPUSH
30758: CALL 89772 0 2
30762: ST_TO_ADDR
// p := [ ] ;
30763: LD_ADDR_VAR 0 11
30767: PUSH
30768: EMPTY
30769: ST_TO_ADDR
// if sort then
30770: LD_VAR 0 9
30774: IFFALSE 30890
// for i = 1 to 6 - mech do
30776: LD_ADDR_VAR 0 3
30780: PUSH
30781: DOUBLE
30782: LD_INT 1
30784: DEC
30785: ST_TO_ADDR
30786: LD_INT 6
30788: PUSH
30789: LD_VAR 0 7
30793: MINUS
30794: PUSH
30795: FOR_TO
30796: IFFALSE 30888
// begin if i = sort then
30798: LD_VAR 0 3
30802: PUSH
30803: LD_VAR 0 9
30807: EQUAL
30808: IFFALSE 30812
// break ;
30810: GO 30888
// if GetClass ( i ) = 3 then
30812: LD_VAR 0 3
30816: PPUSH
30817: CALL_OW 257
30821: PUSH
30822: LD_INT 3
30824: EQUAL
30825: IFFALSE 30829
// continue ;
30827: GO 30795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30829: LD_ADDR_VAR 0 11
30833: PUSH
30834: LD_VAR 0 11
30838: PPUSH
30839: LD_VAR 0 11
30843: PUSH
30844: LD_INT 1
30846: PLUS
30847: PPUSH
30848: LD_VAR 0 9
30852: PUSH
30853: LD_VAR 0 3
30857: ARRAY
30858: PPUSH
30859: CALL_OW 2
30863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30864: LD_ADDR_VAR 0 4
30868: PUSH
30869: LD_VAR 0 4
30873: PUSH
30874: LD_VAR 0 9
30878: PUSH
30879: LD_VAR 0 3
30883: ARRAY
30884: DIFF
30885: ST_TO_ADDR
// end ;
30886: GO 30795
30888: POP
30889: POP
// if p then
30890: LD_VAR 0 11
30894: IFFALSE 30919
// result := Replace ( result , 3 , p ) ;
30896: LD_ADDR_VAR 0 2
30900: PUSH
30901: LD_VAR 0 2
30905: PPUSH
30906: LD_INT 3
30908: PPUSH
30909: LD_VAR 0 11
30913: PPUSH
30914: CALL_OW 1
30918: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30919: LD_ADDR_VAR 0 4
30923: PUSH
30924: LD_VAR 0 4
30928: PUSH
30929: LD_VAR 0 6
30933: DIFF
30934: ST_TO_ADDR
// if tmp and eng < 4 then
30935: LD_VAR 0 4
30939: PUSH
30940: LD_VAR 0 6
30944: PUSH
30945: LD_INT 4
30947: LESS
30948: AND
30949: IFFALSE 31139
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30951: LD_ADDR_VAR 0 9
30955: PUSH
30956: LD_VAR 0 4
30960: PUSH
30961: LD_VAR 0 7
30965: PUSH
30966: LD_VAR 0 6
30970: UNION
30971: DIFF
30972: PPUSH
30973: LD_INT 2
30975: PPUSH
30976: CALL 89772 0 2
30980: ST_TO_ADDR
// p := [ ] ;
30981: LD_ADDR_VAR 0 11
30985: PUSH
30986: EMPTY
30987: ST_TO_ADDR
// if sort then
30988: LD_VAR 0 9
30992: IFFALSE 31108
// for i = 1 to 4 - eng do
30994: LD_ADDR_VAR 0 3
30998: PUSH
30999: DOUBLE
31000: LD_INT 1
31002: DEC
31003: ST_TO_ADDR
31004: LD_INT 4
31006: PUSH
31007: LD_VAR 0 6
31011: MINUS
31012: PUSH
31013: FOR_TO
31014: IFFALSE 31106
// begin if i = sort then
31016: LD_VAR 0 3
31020: PUSH
31021: LD_VAR 0 9
31025: EQUAL
31026: IFFALSE 31030
// break ;
31028: GO 31106
// if GetClass ( i ) = 2 then
31030: LD_VAR 0 3
31034: PPUSH
31035: CALL_OW 257
31039: PUSH
31040: LD_INT 2
31042: EQUAL
31043: IFFALSE 31047
// continue ;
31045: GO 31013
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31047: LD_ADDR_VAR 0 11
31051: PUSH
31052: LD_VAR 0 11
31056: PPUSH
31057: LD_VAR 0 11
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 9
31070: PUSH
31071: LD_VAR 0 3
31075: ARRAY
31076: PPUSH
31077: CALL_OW 2
31081: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31082: LD_ADDR_VAR 0 4
31086: PUSH
31087: LD_VAR 0 4
31091: PUSH
31092: LD_VAR 0 9
31096: PUSH
31097: LD_VAR 0 3
31101: ARRAY
31102: DIFF
31103: ST_TO_ADDR
// end ;
31104: GO 31013
31106: POP
31107: POP
// if p then
31108: LD_VAR 0 11
31112: IFFALSE 31137
// result := Replace ( result , 2 , p ) ;
31114: LD_ADDR_VAR 0 2
31118: PUSH
31119: LD_VAR 0 2
31123: PPUSH
31124: LD_INT 2
31126: PPUSH
31127: LD_VAR 0 11
31131: PPUSH
31132: CALL_OW 1
31136: ST_TO_ADDR
// end else
31137: GO 31183
// for i = eng downto 5 do
31139: LD_ADDR_VAR 0 3
31143: PUSH
31144: DOUBLE
31145: LD_VAR 0 6
31149: INC
31150: ST_TO_ADDR
31151: LD_INT 5
31153: PUSH
31154: FOR_DOWNTO
31155: IFFALSE 31181
// tmp := tmp union eng [ i ] ;
31157: LD_ADDR_VAR 0 4
31161: PUSH
31162: LD_VAR 0 4
31166: PUSH
31167: LD_VAR 0 6
31171: PUSH
31172: LD_VAR 0 3
31176: ARRAY
31177: UNION
31178: ST_TO_ADDR
31179: GO 31154
31181: POP
31182: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31183: LD_ADDR_VAR 0 2
31187: PUSH
31188: LD_VAR 0 2
31192: PPUSH
31193: LD_INT 1
31195: PPUSH
31196: LD_VAR 0 4
31200: PUSH
31201: LD_VAR 0 5
31205: DIFF
31206: PPUSH
31207: CALL_OW 1
31211: ST_TO_ADDR
// exit ;
31212: GO 31214
// end ; end ;
31214: LD_VAR 0 2
31218: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31219: LD_INT 0
31221: PPUSH
31222: PPUSH
31223: PPUSH
// if not mc_bases then
31224: LD_EXP 80
31228: NOT
31229: IFFALSE 31233
// exit ;
31231: GO 31375
// for i = 1 to mc_bases do
31233: LD_ADDR_VAR 0 2
31237: PUSH
31238: DOUBLE
31239: LD_INT 1
31241: DEC
31242: ST_TO_ADDR
31243: LD_EXP 80
31247: PUSH
31248: FOR_TO
31249: IFFALSE 31366
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31251: LD_ADDR_VAR 0 3
31255: PUSH
31256: LD_EXP 80
31260: PUSH
31261: LD_VAR 0 2
31265: ARRAY
31266: PPUSH
31267: LD_INT 21
31269: PUSH
31270: LD_INT 3
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 3
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 30
31285: PUSH
31286: LD_INT 29
31288: PUSH
31289: EMPTY
31290: LIST
31291: LIST
31292: PUSH
31293: LD_INT 30
31295: PUSH
31296: LD_INT 30
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: LIST
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 3
31314: PUSH
31315: LD_INT 24
31317: PUSH
31318: LD_INT 1000
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: LIST
31333: PPUSH
31334: CALL_OW 72
31338: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31339: LD_ADDR_EXP 81
31343: PUSH
31344: LD_EXP 81
31348: PPUSH
31349: LD_VAR 0 2
31353: PPUSH
31354: LD_VAR 0 3
31358: PPUSH
31359: CALL_OW 1
31363: ST_TO_ADDR
// end ;
31364: GO 31248
31366: POP
31367: POP
// RaiseSailEvent ( 101 ) ;
31368: LD_INT 101
31370: PPUSH
31371: CALL_OW 427
// end ;
31375: LD_VAR 0 1
31379: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31380: LD_INT 0
31382: PPUSH
31383: PPUSH
31384: PPUSH
31385: PPUSH
31386: PPUSH
31387: PPUSH
31388: PPUSH
// if not mc_bases then
31389: LD_EXP 80
31393: NOT
31394: IFFALSE 31398
// exit ;
31396: GO 31960
// for i = 1 to mc_bases do
31398: LD_ADDR_VAR 0 2
31402: PUSH
31403: DOUBLE
31404: LD_INT 1
31406: DEC
31407: ST_TO_ADDR
31408: LD_EXP 80
31412: PUSH
31413: FOR_TO
31414: IFFALSE 31951
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31416: LD_ADDR_VAR 0 5
31420: PUSH
31421: LD_EXP 80
31425: PUSH
31426: LD_VAR 0 2
31430: ARRAY
31431: PUSH
31432: LD_EXP 109
31436: PUSH
31437: LD_VAR 0 2
31441: ARRAY
31442: UNION
31443: PPUSH
31444: LD_INT 21
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: PUSH
31457: LD_INT 3
31459: PUSH
31460: LD_INT 54
31462: PUSH
31463: EMPTY
31464: LIST
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 3
31472: PUSH
31473: LD_INT 24
31475: PUSH
31476: LD_INT 1000
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: LIST
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PPUSH
31496: CALL_OW 72
31500: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31501: LD_ADDR_VAR 0 6
31505: PUSH
31506: LD_EXP 80
31510: PUSH
31511: LD_VAR 0 2
31515: ARRAY
31516: PPUSH
31517: LD_INT 21
31519: PUSH
31520: LD_INT 1
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: LD_INT 3
31532: PUSH
31533: LD_INT 54
31535: PUSH
31536: EMPTY
31537: LIST
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: LD_INT 3
31545: PUSH
31546: LD_INT 24
31548: PUSH
31549: LD_INT 250
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: LIST
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PPUSH
31569: CALL_OW 72
31573: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31574: LD_ADDR_VAR 0 7
31578: PUSH
31579: LD_VAR 0 5
31583: PUSH
31584: LD_VAR 0 6
31588: DIFF
31589: ST_TO_ADDR
// if not need_heal_1 then
31590: LD_VAR 0 6
31594: NOT
31595: IFFALSE 31628
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31597: LD_ADDR_EXP 83
31601: PUSH
31602: LD_EXP 83
31606: PPUSH
31607: LD_VAR 0 2
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PPUSH
31619: EMPTY
31620: PPUSH
31621: CALL 58539 0 3
31625: ST_TO_ADDR
31626: GO 31698
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31628: LD_ADDR_EXP 83
31632: PUSH
31633: LD_EXP 83
31637: PPUSH
31638: LD_VAR 0 2
31642: PUSH
31643: LD_INT 1
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PPUSH
31650: LD_EXP 83
31654: PUSH
31655: LD_VAR 0 2
31659: ARRAY
31660: PUSH
31661: LD_INT 1
31663: ARRAY
31664: PPUSH
31665: LD_INT 3
31667: PUSH
31668: LD_INT 24
31670: PUSH
31671: LD_INT 1000
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PPUSH
31682: CALL_OW 72
31686: PUSH
31687: LD_VAR 0 6
31691: UNION
31692: PPUSH
31693: CALL 58539 0 3
31697: ST_TO_ADDR
// if not need_heal_2 then
31698: LD_VAR 0 7
31702: NOT
31703: IFFALSE 31736
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31705: LD_ADDR_EXP 83
31709: PUSH
31710: LD_EXP 83
31714: PPUSH
31715: LD_VAR 0 2
31719: PUSH
31720: LD_INT 2
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PPUSH
31727: EMPTY
31728: PPUSH
31729: CALL 58539 0 3
31733: ST_TO_ADDR
31734: GO 31768
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31736: LD_ADDR_EXP 83
31740: PUSH
31741: LD_EXP 83
31745: PPUSH
31746: LD_VAR 0 2
31750: PUSH
31751: LD_INT 2
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PPUSH
31758: LD_VAR 0 7
31762: PPUSH
31763: CALL 58539 0 3
31767: ST_TO_ADDR
// if need_heal_2 then
31768: LD_VAR 0 7
31772: IFFALSE 31933
// for j in need_heal_2 do
31774: LD_ADDR_VAR 0 3
31778: PUSH
31779: LD_VAR 0 7
31783: PUSH
31784: FOR_IN
31785: IFFALSE 31931
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31787: LD_ADDR_VAR 0 5
31791: PUSH
31792: LD_EXP 80
31796: PUSH
31797: LD_VAR 0 2
31801: ARRAY
31802: PPUSH
31803: LD_INT 2
31805: PUSH
31806: LD_INT 30
31808: PUSH
31809: LD_INT 6
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 30
31818: PUSH
31819: LD_INT 7
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 30
31828: PUSH
31829: LD_INT 8
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 30
31838: PUSH
31839: LD_INT 0
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 30
31848: PUSH
31849: LD_INT 1
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 72
31868: ST_TO_ADDR
// if tmp then
31869: LD_VAR 0 5
31873: IFFALSE 31929
// begin k := NearestUnitToUnit ( tmp , j ) ;
31875: LD_ADDR_VAR 0 4
31879: PUSH
31880: LD_VAR 0 5
31884: PPUSH
31885: LD_VAR 0 3
31889: PPUSH
31890: CALL_OW 74
31894: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31895: LD_VAR 0 3
31899: PPUSH
31900: LD_VAR 0 4
31904: PPUSH
31905: CALL_OW 296
31909: PUSH
31910: LD_INT 5
31912: GREATER
31913: IFFALSE 31929
// ComMoveToNearbyEntrance ( j , k ) ;
31915: LD_VAR 0 3
31919: PPUSH
31920: LD_VAR 0 4
31924: PPUSH
31925: CALL 92145 0 2
// end ; end ;
31929: GO 31784
31931: POP
31932: POP
// if not need_heal_1 and not need_heal_2 then
31933: LD_VAR 0 6
31937: NOT
31938: PUSH
31939: LD_VAR 0 7
31943: NOT
31944: AND
31945: IFFALSE 31949
// continue ;
31947: GO 31413
// end ;
31949: GO 31413
31951: POP
31952: POP
// RaiseSailEvent ( 102 ) ;
31953: LD_INT 102
31955: PPUSH
31956: CALL_OW 427
// end ;
31960: LD_VAR 0 1
31964: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31965: LD_INT 0
31967: PPUSH
31968: PPUSH
31969: PPUSH
31970: PPUSH
31971: PPUSH
31972: PPUSH
31973: PPUSH
31974: PPUSH
// if not mc_bases then
31975: LD_EXP 80
31979: NOT
31980: IFFALSE 31984
// exit ;
31982: GO 32895
// for i = 1 to mc_bases do
31984: LD_ADDR_VAR 0 2
31988: PUSH
31989: DOUBLE
31990: LD_INT 1
31992: DEC
31993: ST_TO_ADDR
31994: LD_EXP 80
31998: PUSH
31999: FOR_TO
32000: IFFALSE 32893
// begin if not mc_building_need_repair [ i ] then
32002: LD_EXP 81
32006: PUSH
32007: LD_VAR 0 2
32011: ARRAY
32012: NOT
32013: IFFALSE 32198
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
32015: LD_ADDR_VAR 0 6
32019: PUSH
32020: LD_EXP 99
32024: PUSH
32025: LD_VAR 0 2
32029: ARRAY
32030: PPUSH
32031: LD_INT 3
32033: PUSH
32034: LD_INT 24
32036: PUSH
32037: LD_INT 1000
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: LD_INT 2
32050: PUSH
32051: LD_INT 34
32053: PUSH
32054: LD_INT 13
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 34
32063: PUSH
32064: LD_INT 52
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 34
32073: PUSH
32074: LD_INT 88
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PPUSH
32091: CALL_OW 72
32095: ST_TO_ADDR
// if cranes then
32096: LD_VAR 0 6
32100: IFFALSE 32162
// for j in cranes do
32102: LD_ADDR_VAR 0 3
32106: PUSH
32107: LD_VAR 0 6
32111: PUSH
32112: FOR_IN
32113: IFFALSE 32160
// if not IsInArea ( j , mc_parking [ i ] ) then
32115: LD_VAR 0 3
32119: PPUSH
32120: LD_EXP 104
32124: PUSH
32125: LD_VAR 0 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 308
32135: NOT
32136: IFFALSE 32158
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32138: LD_VAR 0 3
32142: PPUSH
32143: LD_EXP 104
32147: PUSH
32148: LD_VAR 0 2
32152: ARRAY
32153: PPUSH
32154: CALL_OW 113
32158: GO 32112
32160: POP
32161: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32162: LD_ADDR_EXP 82
32166: PUSH
32167: LD_EXP 82
32171: PPUSH
32172: LD_VAR 0 2
32176: PPUSH
32177: EMPTY
32178: PPUSH
32179: CALL_OW 1
32183: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32184: LD_VAR 0 2
32188: PPUSH
32189: LD_INT 101
32191: PPUSH
32192: CALL 27038 0 2
// continue ;
32196: GO 31999
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32198: LD_ADDR_EXP 86
32202: PUSH
32203: LD_EXP 86
32207: PPUSH
32208: LD_VAR 0 2
32212: PPUSH
32213: EMPTY
32214: PPUSH
32215: CALL_OW 1
32219: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32220: LD_VAR 0 2
32224: PPUSH
32225: LD_INT 103
32227: PPUSH
32228: CALL 27038 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32232: LD_ADDR_VAR 0 5
32236: PUSH
32237: LD_EXP 80
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: LD_EXP 109
32252: PUSH
32253: LD_VAR 0 2
32257: ARRAY
32258: UNION
32259: PPUSH
32260: LD_INT 2
32262: PUSH
32263: LD_INT 25
32265: PUSH
32266: LD_INT 2
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 25
32275: PUSH
32276: LD_INT 16
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: LIST
32287: PUSH
32288: EMPTY
32289: LIST
32290: PPUSH
32291: CALL_OW 72
32295: ST_TO_ADDR
// if mc_need_heal [ i ] then
32296: LD_EXP 83
32300: PUSH
32301: LD_VAR 0 2
32305: ARRAY
32306: IFFALSE 32350
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32308: LD_ADDR_VAR 0 5
32312: PUSH
32313: LD_VAR 0 5
32317: PUSH
32318: LD_EXP 83
32322: PUSH
32323: LD_VAR 0 2
32327: ARRAY
32328: PUSH
32329: LD_INT 1
32331: ARRAY
32332: PUSH
32333: LD_EXP 83
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: PUSH
32344: LD_INT 2
32346: ARRAY
32347: UNION
32348: DIFF
32349: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32350: LD_ADDR_VAR 0 6
32354: PUSH
32355: LD_EXP 99
32359: PUSH
32360: LD_VAR 0 2
32364: ARRAY
32365: PPUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 34
32371: PUSH
32372: LD_INT 13
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 34
32381: PUSH
32382: LD_INT 52
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 34
32391: PUSH
32392: LD_INT 88
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: PPUSH
32405: CALL_OW 72
32409: ST_TO_ADDR
// if cranes then
32410: LD_VAR 0 6
32414: IFFALSE 32582
// begin for j in cranes do
32416: LD_ADDR_VAR 0 3
32420: PUSH
32421: LD_VAR 0 6
32425: PUSH
32426: FOR_IN
32427: IFFALSE 32580
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32429: LD_VAR 0 3
32433: PPUSH
32434: CALL_OW 256
32438: PUSH
32439: LD_INT 1000
32441: EQUAL
32442: PUSH
32443: LD_VAR 0 3
32447: PPUSH
32448: CALL_OW 314
32452: NOT
32453: AND
32454: IFFALSE 32520
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32456: LD_ADDR_VAR 0 8
32460: PUSH
32461: LD_EXP 81
32465: PUSH
32466: LD_VAR 0 2
32470: ARRAY
32471: PPUSH
32472: LD_VAR 0 3
32476: PPUSH
32477: CALL_OW 74
32481: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32482: LD_VAR 0 8
32486: PPUSH
32487: LD_INT 16
32489: PPUSH
32490: CALL 61504 0 2
32494: PUSH
32495: LD_INT 4
32497: ARRAY
32498: PUSH
32499: LD_INT 10
32501: LESS
32502: IFFALSE 32518
// ComRepairBuilding ( j , to_repair ) ;
32504: LD_VAR 0 3
32508: PPUSH
32509: LD_VAR 0 8
32513: PPUSH
32514: CALL_OW 130
// end else
32518: GO 32578
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32520: LD_VAR 0 3
32524: PPUSH
32525: CALL_OW 256
32529: PUSH
32530: LD_INT 500
32532: LESS
32533: PUSH
32534: LD_VAR 0 3
32538: PPUSH
32539: LD_EXP 104
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PPUSH
32550: CALL_OW 308
32554: NOT
32555: AND
32556: IFFALSE 32578
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32558: LD_VAR 0 3
32562: PPUSH
32563: LD_EXP 104
32567: PUSH
32568: LD_VAR 0 2
32572: ARRAY
32573: PPUSH
32574: CALL_OW 113
// end ;
32578: GO 32426
32580: POP
32581: POP
// end ; if tmp > 3 then
32582: LD_VAR 0 5
32586: PUSH
32587: LD_INT 3
32589: GREATER
32590: IFFALSE 32610
// tmp := ShrinkArray ( tmp , 4 ) ;
32592: LD_ADDR_VAR 0 5
32596: PUSH
32597: LD_VAR 0 5
32601: PPUSH
32602: LD_INT 4
32604: PPUSH
32605: CALL 91583 0 2
32609: ST_TO_ADDR
// if not tmp then
32610: LD_VAR 0 5
32614: NOT
32615: IFFALSE 32619
// continue ;
32617: GO 31999
// for j in tmp do
32619: LD_ADDR_VAR 0 3
32623: PUSH
32624: LD_VAR 0 5
32628: PUSH
32629: FOR_IN
32630: IFFALSE 32889
// begin if IsInUnit ( j ) then
32632: LD_VAR 0 3
32636: PPUSH
32637: CALL_OW 310
32641: IFFALSE 32652
// ComExitBuilding ( j ) ;
32643: LD_VAR 0 3
32647: PPUSH
32648: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32652: LD_VAR 0 3
32656: PUSH
32657: LD_EXP 82
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: IN
32668: NOT
32669: IFFALSE 32727
// begin SetTag ( j , 101 ) ;
32671: LD_VAR 0 3
32675: PPUSH
32676: LD_INT 101
32678: PPUSH
32679: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32683: LD_ADDR_EXP 82
32687: PUSH
32688: LD_EXP 82
32692: PPUSH
32693: LD_VAR 0 2
32697: PUSH
32698: LD_EXP 82
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: PUSH
32709: LD_INT 1
32711: PLUS
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PPUSH
32717: LD_VAR 0 3
32721: PPUSH
32722: CALL 58539 0 3
32726: ST_TO_ADDR
// end ; wait ( 1 ) ;
32727: LD_INT 1
32729: PPUSH
32730: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32734: LD_ADDR_VAR 0 7
32738: PUSH
32739: LD_EXP 81
32743: PUSH
32744: LD_VAR 0 2
32748: ARRAY
32749: ST_TO_ADDR
// if mc_scan [ i ] then
32750: LD_EXP 103
32754: PUSH
32755: LD_VAR 0 2
32759: ARRAY
32760: IFFALSE 32822
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32762: LD_ADDR_VAR 0 7
32766: PUSH
32767: LD_EXP 81
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PPUSH
32778: LD_INT 3
32780: PUSH
32781: LD_INT 30
32783: PUSH
32784: LD_INT 32
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 30
32793: PUSH
32794: LD_INT 33
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 30
32803: PUSH
32804: LD_INT 31
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: PPUSH
32817: CALL_OW 72
32821: ST_TO_ADDR
// if not to_repair_tmp then
32822: LD_VAR 0 7
32826: NOT
32827: IFFALSE 32831
// continue ;
32829: GO 32629
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32831: LD_ADDR_VAR 0 8
32835: PUSH
32836: LD_VAR 0 7
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 74
32850: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32851: LD_VAR 0 8
32855: PPUSH
32856: LD_INT 16
32858: PPUSH
32859: CALL 61504 0 2
32863: PUSH
32864: LD_INT 4
32866: ARRAY
32867: PUSH
32868: LD_INT 14
32870: LESS
32871: IFFALSE 32887
// ComRepairBuilding ( j , to_repair ) ;
32873: LD_VAR 0 3
32877: PPUSH
32878: LD_VAR 0 8
32882: PPUSH
32883: CALL_OW 130
// end ;
32887: GO 32629
32889: POP
32890: POP
// end ;
32891: GO 31999
32893: POP
32894: POP
// end ;
32895: LD_VAR 0 1
32899: RET
// export function MC_Heal ; var i , j , tmp ; begin
32900: LD_INT 0
32902: PPUSH
32903: PPUSH
32904: PPUSH
32905: PPUSH
// if not mc_bases then
32906: LD_EXP 80
32910: NOT
32911: IFFALSE 32915
// exit ;
32913: GO 33317
// for i = 1 to mc_bases do
32915: LD_ADDR_VAR 0 2
32919: PUSH
32920: DOUBLE
32921: LD_INT 1
32923: DEC
32924: ST_TO_ADDR
32925: LD_EXP 80
32929: PUSH
32930: FOR_TO
32931: IFFALSE 33315
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32933: LD_EXP 83
32937: PUSH
32938: LD_VAR 0 2
32942: ARRAY
32943: PUSH
32944: LD_INT 1
32946: ARRAY
32947: NOT
32948: PUSH
32949: LD_EXP 83
32953: PUSH
32954: LD_VAR 0 2
32958: ARRAY
32959: PUSH
32960: LD_INT 2
32962: ARRAY
32963: NOT
32964: AND
32965: IFFALSE 33003
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32967: LD_ADDR_EXP 84
32971: PUSH
32972: LD_EXP 84
32976: PPUSH
32977: LD_VAR 0 2
32981: PPUSH
32982: EMPTY
32983: PPUSH
32984: CALL_OW 1
32988: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32989: LD_VAR 0 2
32993: PPUSH
32994: LD_INT 102
32996: PPUSH
32997: CALL 27038 0 2
// continue ;
33001: GO 32930
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33003: LD_ADDR_VAR 0 4
33007: PUSH
33008: LD_EXP 80
33012: PUSH
33013: LD_VAR 0 2
33017: ARRAY
33018: PPUSH
33019: LD_INT 25
33021: PUSH
33022: LD_INT 4
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PPUSH
33029: CALL_OW 72
33033: ST_TO_ADDR
// if not tmp then
33034: LD_VAR 0 4
33038: NOT
33039: IFFALSE 33043
// continue ;
33041: GO 32930
// if mc_taming [ i ] then
33043: LD_EXP 111
33047: PUSH
33048: LD_VAR 0 2
33052: ARRAY
33053: IFFALSE 33077
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33055: LD_ADDR_EXP 111
33059: PUSH
33060: LD_EXP 111
33064: PPUSH
33065: LD_VAR 0 2
33069: PPUSH
33070: EMPTY
33071: PPUSH
33072: CALL_OW 1
33076: ST_TO_ADDR
// for j in tmp do
33077: LD_ADDR_VAR 0 3
33081: PUSH
33082: LD_VAR 0 4
33086: PUSH
33087: FOR_IN
33088: IFFALSE 33311
// begin if IsInUnit ( j ) then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 310
33099: IFFALSE 33110
// ComExitBuilding ( j ) ;
33101: LD_VAR 0 3
33105: PPUSH
33106: CALL_OW 122
// if not j in mc_healers [ i ] then
33110: LD_VAR 0 3
33114: PUSH
33115: LD_EXP 84
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: IN
33126: NOT
33127: IFFALSE 33173
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33129: LD_ADDR_EXP 84
33133: PUSH
33134: LD_EXP 84
33138: PPUSH
33139: LD_VAR 0 2
33143: PUSH
33144: LD_EXP 84
33148: PUSH
33149: LD_VAR 0 2
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: PLUS
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PPUSH
33163: LD_VAR 0 3
33167: PPUSH
33168: CALL 58539 0 3
33172: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33173: LD_VAR 0 3
33177: PPUSH
33178: CALL_OW 110
33182: PUSH
33183: LD_INT 102
33185: NONEQUAL
33186: IFFALSE 33200
// SetTag ( j , 102 ) ;
33188: LD_VAR 0 3
33192: PPUSH
33193: LD_INT 102
33195: PPUSH
33196: CALL_OW 109
// Wait ( 3 ) ;
33200: LD_INT 3
33202: PPUSH
33203: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33207: LD_EXP 83
33211: PUSH
33212: LD_VAR 0 2
33216: ARRAY
33217: PUSH
33218: LD_INT 1
33220: ARRAY
33221: IFFALSE 33253
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33223: LD_VAR 0 3
33227: PPUSH
33228: LD_EXP 83
33232: PUSH
33233: LD_VAR 0 2
33237: ARRAY
33238: PUSH
33239: LD_INT 1
33241: ARRAY
33242: PUSH
33243: LD_INT 1
33245: ARRAY
33246: PPUSH
33247: CALL_OW 128
33251: GO 33309
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33253: LD_VAR 0 3
33257: PPUSH
33258: CALL_OW 314
33262: NOT
33263: PUSH
33264: LD_EXP 83
33268: PUSH
33269: LD_VAR 0 2
33273: ARRAY
33274: PUSH
33275: LD_INT 2
33277: ARRAY
33278: AND
33279: IFFALSE 33309
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33281: LD_VAR 0 3
33285: PPUSH
33286: LD_EXP 83
33290: PUSH
33291: LD_VAR 0 2
33295: ARRAY
33296: PUSH
33297: LD_INT 2
33299: ARRAY
33300: PUSH
33301: LD_INT 1
33303: ARRAY
33304: PPUSH
33305: CALL_OW 128
// end ;
33309: GO 33087
33311: POP
33312: POP
// end ;
33313: GO 32930
33315: POP
33316: POP
// end ;
33317: LD_VAR 0 1
33321: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33322: LD_INT 0
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
// if not mc_bases then
33330: LD_EXP 80
33334: NOT
33335: IFFALSE 33339
// exit ;
33337: GO 34502
// for i = 1 to mc_bases do
33339: LD_ADDR_VAR 0 2
33343: PUSH
33344: DOUBLE
33345: LD_INT 1
33347: DEC
33348: ST_TO_ADDR
33349: LD_EXP 80
33353: PUSH
33354: FOR_TO
33355: IFFALSE 34500
// begin if mc_scan [ i ] then
33357: LD_EXP 103
33361: PUSH
33362: LD_VAR 0 2
33366: ARRAY
33367: IFFALSE 33371
// continue ;
33369: GO 33354
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33371: LD_EXP 85
33375: PUSH
33376: LD_VAR 0 2
33380: ARRAY
33381: NOT
33382: PUSH
33383: LD_EXP 87
33387: PUSH
33388: LD_VAR 0 2
33392: ARRAY
33393: NOT
33394: AND
33395: PUSH
33396: LD_EXP 86
33400: PUSH
33401: LD_VAR 0 2
33405: ARRAY
33406: AND
33407: IFFALSE 33445
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33409: LD_ADDR_EXP 86
33413: PUSH
33414: LD_EXP 86
33418: PPUSH
33419: LD_VAR 0 2
33423: PPUSH
33424: EMPTY
33425: PPUSH
33426: CALL_OW 1
33430: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33431: LD_VAR 0 2
33435: PPUSH
33436: LD_INT 103
33438: PPUSH
33439: CALL 27038 0 2
// continue ;
33443: GO 33354
// end ; if mc_construct_list [ i ] then
33445: LD_EXP 87
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: IFFALSE 33675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33457: LD_ADDR_VAR 0 5
33461: PUSH
33462: LD_EXP 80
33466: PUSH
33467: LD_VAR 0 2
33471: ARRAY
33472: PPUSH
33473: LD_INT 25
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PPUSH
33483: CALL_OW 72
33487: PUSH
33488: LD_EXP 82
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: DIFF
33499: ST_TO_ADDR
// if not tmp then
33500: LD_VAR 0 5
33504: NOT
33505: IFFALSE 33509
// continue ;
33507: GO 33354
// for j in tmp do
33509: LD_ADDR_VAR 0 3
33513: PUSH
33514: LD_VAR 0 5
33518: PUSH
33519: FOR_IN
33520: IFFALSE 33671
// begin if not mc_builders [ i ] then
33522: LD_EXP 86
33526: PUSH
33527: LD_VAR 0 2
33531: ARRAY
33532: NOT
33533: IFFALSE 33591
// begin SetTag ( j , 103 ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: LD_INT 103
33542: PPUSH
33543: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33547: LD_ADDR_EXP 86
33551: PUSH
33552: LD_EXP 86
33556: PPUSH
33557: LD_VAR 0 2
33561: PUSH
33562: LD_EXP 86
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: PUSH
33573: LD_INT 1
33575: PLUS
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PPUSH
33581: LD_VAR 0 3
33585: PPUSH
33586: CALL 58539 0 3
33590: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33591: LD_VAR 0 3
33595: PPUSH
33596: CALL_OW 310
33600: IFFALSE 33611
// ComExitBuilding ( j ) ;
33602: LD_VAR 0 3
33606: PPUSH
33607: CALL_OW 122
// wait ( 3 ) ;
33611: LD_INT 3
33613: PPUSH
33614: CALL_OW 67
// if not mc_construct_list [ i ] then
33618: LD_EXP 87
33622: PUSH
33623: LD_VAR 0 2
33627: ARRAY
33628: NOT
33629: IFFALSE 33633
// break ;
33631: GO 33671
// if not HasTask ( j ) then
33633: LD_VAR 0 3
33637: PPUSH
33638: CALL_OW 314
33642: NOT
33643: IFFALSE 33669
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33645: LD_VAR 0 3
33649: PPUSH
33650: LD_EXP 87
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_INT 1
33663: ARRAY
33664: PPUSH
33665: CALL 61777 0 2
// end ;
33669: GO 33519
33671: POP
33672: POP
// end else
33673: GO 34498
// if mc_build_list [ i ] then
33675: LD_EXP 85
33679: PUSH
33680: LD_VAR 0 2
33684: ARRAY
33685: IFFALSE 34498
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33687: LD_EXP 85
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_INT 1
33700: ARRAY
33701: PUSH
33702: LD_INT 1
33704: ARRAY
33705: PPUSH
33706: CALL 61601 0 1
33710: PUSH
33711: LD_EXP 80
33715: PUSH
33716: LD_VAR 0 2
33720: ARRAY
33721: PPUSH
33722: LD_INT 2
33724: PUSH
33725: LD_INT 30
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 30
33737: PUSH
33738: LD_INT 3
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: PPUSH
33750: CALL_OW 72
33754: NOT
33755: AND
33756: IFFALSE 33861
// begin for j = 1 to mc_build_list [ i ] do
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: DOUBLE
33764: LD_INT 1
33766: DEC
33767: ST_TO_ADDR
33768: LD_EXP 85
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: FOR_TO
33780: IFFALSE 33859
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33782: LD_EXP 85
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: PUSH
33793: LD_VAR 0 3
33797: ARRAY
33798: PUSH
33799: LD_INT 1
33801: ARRAY
33802: PUSH
33803: LD_INT 2
33805: EQUAL
33806: IFFALSE 33857
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33808: LD_ADDR_EXP 85
33812: PUSH
33813: LD_EXP 85
33817: PPUSH
33818: LD_VAR 0 2
33822: PPUSH
33823: LD_EXP 85
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: PPUSH
33834: LD_VAR 0 3
33838: PPUSH
33839: LD_INT 1
33841: PPUSH
33842: LD_INT 0
33844: PPUSH
33845: CALL 57957 0 4
33849: PPUSH
33850: CALL_OW 1
33854: ST_TO_ADDR
// break ;
33855: GO 33859
// end ;
33857: GO 33779
33859: POP
33860: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33861: LD_ADDR_VAR 0 6
33865: PUSH
33866: LD_EXP 80
33870: PUSH
33871: LD_VAR 0 2
33875: ARRAY
33876: PPUSH
33877: LD_INT 2
33879: PUSH
33880: LD_INT 30
33882: PUSH
33883: LD_INT 0
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 30
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: LIST
33904: PPUSH
33905: CALL_OW 72
33909: ST_TO_ADDR
// for k := 1 to depot do
33910: LD_ADDR_VAR 0 4
33914: PUSH
33915: DOUBLE
33916: LD_INT 1
33918: DEC
33919: ST_TO_ADDR
33920: LD_VAR 0 6
33924: PUSH
33925: FOR_TO
33926: IFFALSE 34496
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33928: LD_EXP 85
33932: PUSH
33933: LD_VAR 0 2
33937: ARRAY
33938: PUSH
33939: LD_INT 1
33941: ARRAY
33942: PUSH
33943: LD_INT 1
33945: ARRAY
33946: PUSH
33947: LD_INT 0
33949: EQUAL
33950: PUSH
33951: LD_VAR 0 6
33955: PUSH
33956: LD_VAR 0 4
33960: ARRAY
33961: PPUSH
33962: LD_EXP 85
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_INT 1
33975: ARRAY
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: LD_EXP 85
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PUSH
33992: LD_INT 1
33994: ARRAY
33995: PUSH
33996: LD_INT 2
33998: ARRAY
33999: PPUSH
34000: LD_EXP 85
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PUSH
34011: LD_INT 1
34013: ARRAY
34014: PUSH
34015: LD_INT 3
34017: ARRAY
34018: PPUSH
34019: LD_EXP 85
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_INT 1
34032: ARRAY
34033: PUSH
34034: LD_INT 4
34036: ARRAY
34037: PPUSH
34038: CALL 67013 0 5
34042: OR
34043: IFFALSE 34324
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34045: LD_ADDR_VAR 0 5
34049: PUSH
34050: LD_EXP 80
34054: PUSH
34055: LD_VAR 0 2
34059: ARRAY
34060: PPUSH
34061: LD_INT 25
34063: PUSH
34064: LD_INT 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PPUSH
34071: CALL_OW 72
34075: PUSH
34076: LD_EXP 82
34080: PUSH
34081: LD_VAR 0 2
34085: ARRAY
34086: DIFF
34087: ST_TO_ADDR
// if not tmp then
34088: LD_VAR 0 5
34092: NOT
34093: IFFALSE 34097
// continue ;
34095: GO 33925
// for j in tmp do
34097: LD_ADDR_VAR 0 3
34101: PUSH
34102: LD_VAR 0 5
34106: PUSH
34107: FOR_IN
34108: IFFALSE 34320
// begin if not mc_builders [ i ] then
34110: LD_EXP 86
34114: PUSH
34115: LD_VAR 0 2
34119: ARRAY
34120: NOT
34121: IFFALSE 34179
// begin SetTag ( j , 103 ) ;
34123: LD_VAR 0 3
34127: PPUSH
34128: LD_INT 103
34130: PPUSH
34131: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34135: LD_ADDR_EXP 86
34139: PUSH
34140: LD_EXP 86
34144: PPUSH
34145: LD_VAR 0 2
34149: PUSH
34150: LD_EXP 86
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PUSH
34161: LD_INT 1
34163: PLUS
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PPUSH
34169: LD_VAR 0 3
34173: PPUSH
34174: CALL 58539 0 3
34178: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34179: LD_VAR 0 3
34183: PPUSH
34184: CALL_OW 310
34188: IFFALSE 34199
// ComExitBuilding ( j ) ;
34190: LD_VAR 0 3
34194: PPUSH
34195: CALL_OW 122
// wait ( 3 ) ;
34199: LD_INT 3
34201: PPUSH
34202: CALL_OW 67
// if not mc_build_list [ i ] then
34206: LD_EXP 85
34210: PUSH
34211: LD_VAR 0 2
34215: ARRAY
34216: NOT
34217: IFFALSE 34221
// break ;
34219: GO 34320
// if not HasTask ( j ) then
34221: LD_VAR 0 3
34225: PPUSH
34226: CALL_OW 314
34230: NOT
34231: IFFALSE 34318
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34233: LD_VAR 0 3
34237: PPUSH
34238: LD_EXP 85
34242: PUSH
34243: LD_VAR 0 2
34247: ARRAY
34248: PUSH
34249: LD_INT 1
34251: ARRAY
34252: PUSH
34253: LD_INT 1
34255: ARRAY
34256: PPUSH
34257: LD_EXP 85
34261: PUSH
34262: LD_VAR 0 2
34266: ARRAY
34267: PUSH
34268: LD_INT 1
34270: ARRAY
34271: PUSH
34272: LD_INT 2
34274: ARRAY
34275: PPUSH
34276: LD_EXP 85
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_INT 1
34289: ARRAY
34290: PUSH
34291: LD_INT 3
34293: ARRAY
34294: PPUSH
34295: LD_EXP 85
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PUSH
34310: LD_INT 4
34312: ARRAY
34313: PPUSH
34314: CALL_OW 145
// end ;
34318: GO 34107
34320: POP
34321: POP
// end else
34322: GO 34494
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34324: LD_EXP 80
34328: PUSH
34329: LD_VAR 0 2
34333: ARRAY
34334: PPUSH
34335: LD_EXP 85
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: PUSH
34346: LD_INT 1
34348: ARRAY
34349: PUSH
34350: LD_INT 1
34352: ARRAY
34353: PPUSH
34354: LD_EXP 85
34358: PUSH
34359: LD_VAR 0 2
34363: ARRAY
34364: PUSH
34365: LD_INT 1
34367: ARRAY
34368: PUSH
34369: LD_INT 2
34371: ARRAY
34372: PPUSH
34373: LD_EXP 85
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PUSH
34388: LD_INT 3
34390: ARRAY
34391: PPUSH
34392: LD_EXP 85
34396: PUSH
34397: LD_VAR 0 2
34401: ARRAY
34402: PUSH
34403: LD_INT 1
34405: ARRAY
34406: PUSH
34407: LD_INT 4
34409: ARRAY
34410: PPUSH
34411: LD_EXP 80
34415: PUSH
34416: LD_VAR 0 2
34420: ARRAY
34421: PPUSH
34422: LD_INT 21
34424: PUSH
34425: LD_INT 3
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PPUSH
34432: CALL_OW 72
34436: PPUSH
34437: EMPTY
34438: PPUSH
34439: CALL 65767 0 7
34443: NOT
34444: IFFALSE 34494
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34446: LD_ADDR_EXP 85
34450: PUSH
34451: LD_EXP 85
34455: PPUSH
34456: LD_VAR 0 2
34460: PPUSH
34461: LD_EXP 85
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PPUSH
34472: LD_INT 1
34474: PPUSH
34475: LD_INT 1
34477: NEG
34478: PPUSH
34479: LD_INT 0
34481: PPUSH
34482: CALL 57957 0 4
34486: PPUSH
34487: CALL_OW 1
34491: ST_TO_ADDR
// continue ;
34492: GO 33925
// end ; end ;
34494: GO 33925
34496: POP
34497: POP
// end ; end ;
34498: GO 33354
34500: POP
34501: POP
// end ;
34502: LD_VAR 0 1
34506: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34507: LD_INT 0
34509: PPUSH
34510: PPUSH
34511: PPUSH
34512: PPUSH
34513: PPUSH
34514: PPUSH
// if not mc_bases then
34515: LD_EXP 80
34519: NOT
34520: IFFALSE 34524
// exit ;
34522: GO 34951
// for i = 1 to mc_bases do
34524: LD_ADDR_VAR 0 2
34528: PUSH
34529: DOUBLE
34530: LD_INT 1
34532: DEC
34533: ST_TO_ADDR
34534: LD_EXP 80
34538: PUSH
34539: FOR_TO
34540: IFFALSE 34949
// begin tmp := mc_build_upgrade [ i ] ;
34542: LD_ADDR_VAR 0 4
34546: PUSH
34547: LD_EXP 112
34551: PUSH
34552: LD_VAR 0 2
34556: ARRAY
34557: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34558: LD_ADDR_VAR 0 6
34562: PUSH
34563: LD_EXP 113
34567: PUSH
34568: LD_VAR 0 2
34572: ARRAY
34573: PPUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 30
34579: PUSH
34580: LD_INT 6
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 30
34589: PUSH
34590: LD_INT 7
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: LIST
34601: PPUSH
34602: CALL_OW 72
34606: ST_TO_ADDR
// if not tmp and not lab then
34607: LD_VAR 0 4
34611: NOT
34612: PUSH
34613: LD_VAR 0 6
34617: NOT
34618: AND
34619: IFFALSE 34623
// continue ;
34621: GO 34539
// if tmp then
34623: LD_VAR 0 4
34627: IFFALSE 34747
// for j in tmp do
34629: LD_ADDR_VAR 0 3
34633: PUSH
34634: LD_VAR 0 4
34638: PUSH
34639: FOR_IN
34640: IFFALSE 34745
// begin if UpgradeCost ( j ) then
34642: LD_VAR 0 3
34646: PPUSH
34647: CALL 65427 0 1
34651: IFFALSE 34743
// begin ComUpgrade ( j ) ;
34653: LD_VAR 0 3
34657: PPUSH
34658: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34662: LD_ADDR_EXP 112
34666: PUSH
34667: LD_EXP 112
34671: PPUSH
34672: LD_VAR 0 2
34676: PPUSH
34677: LD_EXP 112
34681: PUSH
34682: LD_VAR 0 2
34686: ARRAY
34687: PUSH
34688: LD_VAR 0 3
34692: DIFF
34693: PPUSH
34694: CALL_OW 1
34698: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34699: LD_ADDR_EXP 87
34703: PUSH
34704: LD_EXP 87
34708: PPUSH
34709: LD_VAR 0 2
34713: PUSH
34714: LD_EXP 87
34718: PUSH
34719: LD_VAR 0 2
34723: ARRAY
34724: PUSH
34725: LD_INT 1
34727: PLUS
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PPUSH
34733: LD_VAR 0 3
34737: PPUSH
34738: CALL 58539 0 3
34742: ST_TO_ADDR
// end ; end ;
34743: GO 34639
34745: POP
34746: POP
// if not lab or not mc_lab_upgrade [ i ] then
34747: LD_VAR 0 6
34751: NOT
34752: PUSH
34753: LD_EXP 114
34757: PUSH
34758: LD_VAR 0 2
34762: ARRAY
34763: NOT
34764: OR
34765: IFFALSE 34769
// continue ;
34767: GO 34539
// for j in lab do
34769: LD_ADDR_VAR 0 3
34773: PUSH
34774: LD_VAR 0 6
34778: PUSH
34779: FOR_IN
34780: IFFALSE 34945
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34782: LD_VAR 0 3
34786: PPUSH
34787: CALL_OW 266
34791: PUSH
34792: LD_INT 6
34794: PUSH
34795: LD_INT 7
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: IN
34802: PUSH
34803: LD_VAR 0 3
34807: PPUSH
34808: CALL_OW 461
34812: PUSH
34813: LD_INT 1
34815: NONEQUAL
34816: AND
34817: IFFALSE 34943
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34819: LD_VAR 0 3
34823: PPUSH
34824: LD_EXP 114
34828: PUSH
34829: LD_VAR 0 2
34833: ARRAY
34834: PUSH
34835: LD_INT 1
34837: ARRAY
34838: PPUSH
34839: CALL 65632 0 2
34843: IFFALSE 34943
// begin ComCancel ( j ) ;
34845: LD_VAR 0 3
34849: PPUSH
34850: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_EXP 114
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: PUSH
34870: LD_INT 1
34872: ARRAY
34873: PPUSH
34874: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34878: LD_VAR 0 3
34882: PUSH
34883: LD_EXP 87
34887: PUSH
34888: LD_VAR 0 2
34892: ARRAY
34893: IN
34894: NOT
34895: IFFALSE 34941
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34897: LD_ADDR_EXP 87
34901: PUSH
34902: LD_EXP 87
34906: PPUSH
34907: LD_VAR 0 2
34911: PUSH
34912: LD_EXP 87
34916: PUSH
34917: LD_VAR 0 2
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: PLUS
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PPUSH
34931: LD_VAR 0 3
34935: PPUSH
34936: CALL 58539 0 3
34940: ST_TO_ADDR
// break ;
34941: GO 34945
// end ; end ; end ;
34943: GO 34779
34945: POP
34946: POP
// end ;
34947: GO 34539
34949: POP
34950: POP
// end ;
34951: LD_VAR 0 1
34955: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34956: LD_INT 0
34958: PPUSH
34959: PPUSH
34960: PPUSH
34961: PPUSH
34962: PPUSH
34963: PPUSH
34964: PPUSH
34965: PPUSH
34966: PPUSH
// if not mc_bases then
34967: LD_EXP 80
34971: NOT
34972: IFFALSE 34976
// exit ;
34974: GO 35381
// for i = 1 to mc_bases do
34976: LD_ADDR_VAR 0 2
34980: PUSH
34981: DOUBLE
34982: LD_INT 1
34984: DEC
34985: ST_TO_ADDR
34986: LD_EXP 80
34990: PUSH
34991: FOR_TO
34992: IFFALSE 35379
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34994: LD_EXP 88
34998: PUSH
34999: LD_VAR 0 2
35003: ARRAY
35004: NOT
35005: PUSH
35006: LD_EXP 80
35010: PUSH
35011: LD_VAR 0 2
35015: ARRAY
35016: PPUSH
35017: LD_INT 30
35019: PUSH
35020: LD_INT 3
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PPUSH
35027: CALL_OW 72
35031: NOT
35032: OR
35033: IFFALSE 35037
// continue ;
35035: GO 34991
// busy := false ;
35037: LD_ADDR_VAR 0 8
35041: PUSH
35042: LD_INT 0
35044: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35045: LD_ADDR_VAR 0 4
35049: PUSH
35050: LD_EXP 80
35054: PUSH
35055: LD_VAR 0 2
35059: ARRAY
35060: PPUSH
35061: LD_INT 30
35063: PUSH
35064: LD_INT 3
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PPUSH
35071: CALL_OW 72
35075: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
35076: LD_ADDR_VAR 0 6
35080: PUSH
35081: LD_EXP 88
35085: PUSH
35086: LD_VAR 0 2
35090: ARRAY
35091: PPUSH
35092: LD_INT 2
35094: PUSH
35095: LD_INT 30
35097: PUSH
35098: LD_INT 32
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 30
35107: PUSH
35108: LD_INT 33
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: LIST
35119: PPUSH
35120: CALL_OW 72
35124: ST_TO_ADDR
// if not t then
35125: LD_VAR 0 6
35129: NOT
35130: IFFALSE 35134
// continue ;
35132: GO 34991
// for j in tmp do
35134: LD_ADDR_VAR 0 3
35138: PUSH
35139: LD_VAR 0 4
35143: PUSH
35144: FOR_IN
35145: IFFALSE 35175
// if not BuildingStatus ( j ) = bs_idle then
35147: LD_VAR 0 3
35151: PPUSH
35152: CALL_OW 461
35156: PUSH
35157: LD_INT 2
35159: EQUAL
35160: NOT
35161: IFFALSE 35173
// begin busy := true ;
35163: LD_ADDR_VAR 0 8
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// break ;
35171: GO 35175
// end ;
35173: GO 35144
35175: POP
35176: POP
// if busy then
35177: LD_VAR 0 8
35181: IFFALSE 35185
// continue ;
35183: GO 34991
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35185: LD_ADDR_VAR 0 7
35189: PUSH
35190: LD_VAR 0 6
35194: PPUSH
35195: LD_INT 35
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PPUSH
35205: CALL_OW 72
35209: ST_TO_ADDR
// if tw then
35210: LD_VAR 0 7
35214: IFFALSE 35291
// begin tw := tw [ 1 ] ;
35216: LD_ADDR_VAR 0 7
35220: PUSH
35221: LD_VAR 0 7
35225: PUSH
35226: LD_INT 1
35228: ARRAY
35229: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35230: LD_ADDR_VAR 0 9
35234: PUSH
35235: LD_VAR 0 7
35239: PPUSH
35240: LD_EXP 105
35244: PUSH
35245: LD_VAR 0 2
35249: ARRAY
35250: PPUSH
35251: CALL 63924 0 2
35255: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35256: LD_EXP 119
35260: PUSH
35261: LD_VAR 0 2
35265: ARRAY
35266: IFFALSE 35289
// if not weapon in mc_allowed_tower_weapons [ i ] then
35268: LD_VAR 0 9
35272: PUSH
35273: LD_EXP 119
35277: PUSH
35278: LD_VAR 0 2
35282: ARRAY
35283: IN
35284: NOT
35285: IFFALSE 35289
// continue ;
35287: GO 34991
// end else
35289: GO 35354
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35291: LD_ADDR_VAR 0 5
35295: PUSH
35296: LD_EXP 88
35300: PUSH
35301: LD_VAR 0 2
35305: ARRAY
35306: PPUSH
35307: LD_VAR 0 4
35311: PPUSH
35312: CALL 90816 0 2
35316: ST_TO_ADDR
// if not tmp2 then
35317: LD_VAR 0 5
35321: NOT
35322: IFFALSE 35326
// continue ;
35324: GO 34991
// tw := tmp2 [ 1 ] ;
35326: LD_ADDR_VAR 0 7
35330: PUSH
35331: LD_VAR 0 5
35335: PUSH
35336: LD_INT 1
35338: ARRAY
35339: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35340: LD_ADDR_VAR 0 9
35344: PUSH
35345: LD_VAR 0 5
35349: PUSH
35350: LD_INT 2
35352: ARRAY
35353: ST_TO_ADDR
// end ; if not weapon then
35354: LD_VAR 0 9
35358: NOT
35359: IFFALSE 35363
// continue ;
35361: GO 34991
// ComPlaceWeapon ( tw , weapon ) ;
35363: LD_VAR 0 7
35367: PPUSH
35368: LD_VAR 0 9
35372: PPUSH
35373: CALL_OW 148
// end ;
35377: GO 34991
35379: POP
35380: POP
// end ;
35381: LD_VAR 0 1
35385: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35386: LD_INT 0
35388: PPUSH
35389: PPUSH
35390: PPUSH
35391: PPUSH
35392: PPUSH
35393: PPUSH
35394: PPUSH
// if not mc_bases then
35395: LD_EXP 80
35399: NOT
35400: IFFALSE 35404
// exit ;
35402: GO 36179
// for i = 1 to mc_bases do
35404: LD_ADDR_VAR 0 2
35408: PUSH
35409: DOUBLE
35410: LD_INT 1
35412: DEC
35413: ST_TO_ADDR
35414: LD_EXP 80
35418: PUSH
35419: FOR_TO
35420: IFFALSE 36177
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35422: LD_EXP 93
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: NOT
35433: PUSH
35434: LD_EXP 93
35438: PUSH
35439: LD_VAR 0 2
35443: ARRAY
35444: PUSH
35445: LD_EXP 94
35449: PUSH
35450: LD_VAR 0 2
35454: ARRAY
35455: EQUAL
35456: OR
35457: PUSH
35458: LD_EXP 103
35462: PUSH
35463: LD_VAR 0 2
35467: ARRAY
35468: OR
35469: IFFALSE 35473
// continue ;
35471: GO 35419
// if mc_miners [ i ] then
35473: LD_EXP 94
35477: PUSH
35478: LD_VAR 0 2
35482: ARRAY
35483: IFFALSE 35864
// begin for j = mc_miners [ i ] downto 1 do
35485: LD_ADDR_VAR 0 3
35489: PUSH
35490: DOUBLE
35491: LD_EXP 94
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: INC
35502: ST_TO_ADDR
35503: LD_INT 1
35505: PUSH
35506: FOR_DOWNTO
35507: IFFALSE 35862
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35509: LD_EXP 94
35513: PUSH
35514: LD_VAR 0 2
35518: ARRAY
35519: PUSH
35520: LD_VAR 0 3
35524: ARRAY
35525: PPUSH
35526: CALL_OW 301
35530: PUSH
35531: LD_EXP 94
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_VAR 0 3
35546: ARRAY
35547: PPUSH
35548: CALL_OW 257
35552: PUSH
35553: LD_INT 1
35555: NONEQUAL
35556: OR
35557: IFFALSE 35620
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35559: LD_ADDR_VAR 0 5
35563: PUSH
35564: LD_EXP 94
35568: PUSH
35569: LD_VAR 0 2
35573: ARRAY
35574: PUSH
35575: LD_EXP 94
35579: PUSH
35580: LD_VAR 0 2
35584: ARRAY
35585: PUSH
35586: LD_VAR 0 3
35590: ARRAY
35591: DIFF
35592: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35593: LD_ADDR_EXP 94
35597: PUSH
35598: LD_EXP 94
35602: PPUSH
35603: LD_VAR 0 2
35607: PPUSH
35608: LD_VAR 0 5
35612: PPUSH
35613: CALL_OW 1
35617: ST_TO_ADDR
// continue ;
35618: GO 35506
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35620: LD_EXP 94
35624: PUSH
35625: LD_VAR 0 2
35629: ARRAY
35630: PUSH
35631: LD_VAR 0 3
35635: ARRAY
35636: PPUSH
35637: CALL_OW 257
35641: PUSH
35642: LD_INT 1
35644: EQUAL
35645: PUSH
35646: LD_EXP 94
35650: PUSH
35651: LD_VAR 0 2
35655: ARRAY
35656: PUSH
35657: LD_VAR 0 3
35661: ARRAY
35662: PPUSH
35663: CALL_OW 459
35667: NOT
35668: AND
35669: PUSH
35670: LD_EXP 94
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: PUSH
35681: LD_VAR 0 3
35685: ARRAY
35686: PPUSH
35687: CALL_OW 314
35691: NOT
35692: AND
35693: IFFALSE 35860
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35695: LD_EXP 94
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_VAR 0 3
35710: ARRAY
35711: PPUSH
35712: CALL_OW 310
35716: IFFALSE 35739
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35718: LD_EXP 94
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: PUSH
35729: LD_VAR 0 3
35733: ARRAY
35734: PPUSH
35735: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35739: LD_EXP 94
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_VAR 0 3
35754: ARRAY
35755: PPUSH
35756: CALL_OW 314
35760: NOT
35761: IFFALSE 35860
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35763: LD_ADDR_VAR 0 7
35767: PUSH
35768: LD_VAR 0 3
35772: PUSH
35773: LD_EXP 93
35777: PUSH
35778: LD_VAR 0 2
35782: ARRAY
35783: PPUSH
35784: CALL 55679 0 1
35788: MOD
35789: PUSH
35790: LD_INT 1
35792: PLUS
35793: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35794: LD_EXP 94
35798: PUSH
35799: LD_VAR 0 2
35803: ARRAY
35804: PUSH
35805: LD_VAR 0 3
35809: ARRAY
35810: PPUSH
35811: LD_EXP 93
35815: PUSH
35816: LD_VAR 0 2
35820: ARRAY
35821: PUSH
35822: LD_VAR 0 7
35826: ARRAY
35827: PUSH
35828: LD_INT 1
35830: ARRAY
35831: PPUSH
35832: LD_EXP 93
35836: PUSH
35837: LD_VAR 0 2
35841: ARRAY
35842: PUSH
35843: LD_VAR 0 7
35847: ARRAY
35848: PUSH
35849: LD_INT 2
35851: ARRAY
35852: PPUSH
35853: LD_INT 0
35855: PPUSH
35856: CALL_OW 193
// end ; end ; end ;
35860: GO 35506
35862: POP
35863: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35864: LD_ADDR_VAR 0 5
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PPUSH
35880: LD_INT 2
35882: PUSH
35883: LD_INT 30
35885: PUSH
35886: LD_INT 4
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 30
35895: PUSH
35896: LD_INT 5
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 30
35905: PUSH
35906: LD_INT 32
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: PPUSH
35919: CALL_OW 72
35923: ST_TO_ADDR
// if not tmp then
35924: LD_VAR 0 5
35928: NOT
35929: IFFALSE 35933
// continue ;
35931: GO 35419
// list := [ ] ;
35933: LD_ADDR_VAR 0 6
35937: PUSH
35938: EMPTY
35939: ST_TO_ADDR
// for j in tmp do
35940: LD_ADDR_VAR 0 3
35944: PUSH
35945: LD_VAR 0 5
35949: PUSH
35950: FOR_IN
35951: IFFALSE 36020
// begin for k in UnitsInside ( j ) do
35953: LD_ADDR_VAR 0 4
35957: PUSH
35958: LD_VAR 0 3
35962: PPUSH
35963: CALL_OW 313
35967: PUSH
35968: FOR_IN
35969: IFFALSE 36016
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35971: LD_VAR 0 4
35975: PPUSH
35976: CALL_OW 257
35980: PUSH
35981: LD_INT 1
35983: EQUAL
35984: PUSH
35985: LD_VAR 0 4
35989: PPUSH
35990: CALL_OW 459
35994: NOT
35995: AND
35996: IFFALSE 36014
// list := list ^ k ;
35998: LD_ADDR_VAR 0 6
36002: PUSH
36003: LD_VAR 0 6
36007: PUSH
36008: LD_VAR 0 4
36012: ADD
36013: ST_TO_ADDR
36014: GO 35968
36016: POP
36017: POP
// end ;
36018: GO 35950
36020: POP
36021: POP
// list := list diff mc_miners [ i ] ;
36022: LD_ADDR_VAR 0 6
36026: PUSH
36027: LD_VAR 0 6
36031: PUSH
36032: LD_EXP 94
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: DIFF
36043: ST_TO_ADDR
// if not list then
36044: LD_VAR 0 6
36048: NOT
36049: IFFALSE 36053
// continue ;
36051: GO 35419
// k := mc_mines [ i ] - mc_miners [ i ] ;
36053: LD_ADDR_VAR 0 4
36057: PUSH
36058: LD_EXP 93
36062: PUSH
36063: LD_VAR 0 2
36067: ARRAY
36068: PUSH
36069: LD_EXP 94
36073: PUSH
36074: LD_VAR 0 2
36078: ARRAY
36079: MINUS
36080: ST_TO_ADDR
// if k > list then
36081: LD_VAR 0 4
36085: PUSH
36086: LD_VAR 0 6
36090: GREATER
36091: IFFALSE 36103
// k := list ;
36093: LD_ADDR_VAR 0 4
36097: PUSH
36098: LD_VAR 0 6
36102: ST_TO_ADDR
// for j = 1 to k do
36103: LD_ADDR_VAR 0 3
36107: PUSH
36108: DOUBLE
36109: LD_INT 1
36111: DEC
36112: ST_TO_ADDR
36113: LD_VAR 0 4
36117: PUSH
36118: FOR_TO
36119: IFFALSE 36173
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36121: LD_ADDR_EXP 94
36125: PUSH
36126: LD_EXP 94
36130: PPUSH
36131: LD_VAR 0 2
36135: PUSH
36136: LD_EXP 94
36140: PUSH
36141: LD_VAR 0 2
36145: ARRAY
36146: PUSH
36147: LD_INT 1
36149: PLUS
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PPUSH
36155: LD_VAR 0 6
36159: PUSH
36160: LD_VAR 0 3
36164: ARRAY
36165: PPUSH
36166: CALL 58539 0 3
36170: ST_TO_ADDR
36171: GO 36118
36173: POP
36174: POP
// end ;
36175: GO 35419
36177: POP
36178: POP
// end ;
36179: LD_VAR 0 1
36183: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36184: LD_INT 0
36186: PPUSH
36187: PPUSH
36188: PPUSH
36189: PPUSH
36190: PPUSH
36191: PPUSH
36192: PPUSH
36193: PPUSH
36194: PPUSH
36195: PPUSH
36196: PPUSH
// if not mc_bases then
36197: LD_EXP 80
36201: NOT
36202: IFFALSE 36206
// exit ;
36204: GO 38029
// for i = 1 to mc_bases do
36206: LD_ADDR_VAR 0 2
36210: PUSH
36211: DOUBLE
36212: LD_INT 1
36214: DEC
36215: ST_TO_ADDR
36216: LD_EXP 80
36220: PUSH
36221: FOR_TO
36222: IFFALSE 38027
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36224: LD_EXP 80
36228: PUSH
36229: LD_VAR 0 2
36233: ARRAY
36234: NOT
36235: PUSH
36236: LD_EXP 87
36240: PUSH
36241: LD_VAR 0 2
36245: ARRAY
36246: OR
36247: IFFALSE 36251
// continue ;
36249: GO 36221
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36251: LD_EXP 96
36255: PUSH
36256: LD_VAR 0 2
36260: ARRAY
36261: NOT
36262: PUSH
36263: LD_EXP 97
36267: PUSH
36268: LD_VAR 0 2
36272: ARRAY
36273: AND
36274: IFFALSE 36312
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36276: LD_ADDR_EXP 97
36280: PUSH
36281: LD_EXP 97
36285: PPUSH
36286: LD_VAR 0 2
36290: PPUSH
36291: EMPTY
36292: PPUSH
36293: CALL_OW 1
36297: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36298: LD_VAR 0 2
36302: PPUSH
36303: LD_INT 107
36305: PPUSH
36306: CALL 27038 0 2
// continue ;
36310: GO 36221
// end ; target := [ ] ;
36312: LD_ADDR_VAR 0 7
36316: PUSH
36317: EMPTY
36318: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36319: LD_ADDR_VAR 0 6
36323: PUSH
36324: LD_EXP 80
36328: PUSH
36329: LD_VAR 0 2
36333: ARRAY
36334: PUSH
36335: LD_INT 1
36337: ARRAY
36338: PPUSH
36339: CALL_OW 255
36343: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36344: LD_ADDR_VAR 0 9
36348: PUSH
36349: LD_EXP 80
36353: PUSH
36354: LD_VAR 0 2
36358: ARRAY
36359: PPUSH
36360: LD_INT 2
36362: PUSH
36363: LD_INT 30
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 30
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: LIST
36387: PPUSH
36388: CALL_OW 72
36392: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36393: LD_ADDR_VAR 0 3
36397: PUSH
36398: DOUBLE
36399: LD_EXP 96
36403: PUSH
36404: LD_VAR 0 2
36408: ARRAY
36409: INC
36410: ST_TO_ADDR
36411: LD_INT 1
36413: PUSH
36414: FOR_DOWNTO
36415: IFFALSE 36660
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36417: LD_EXP 96
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PUSH
36428: LD_VAR 0 3
36432: ARRAY
36433: PUSH
36434: LD_INT 2
36436: ARRAY
36437: PPUSH
36438: LD_EXP 96
36442: PUSH
36443: LD_VAR 0 2
36447: ARRAY
36448: PUSH
36449: LD_VAR 0 3
36453: ARRAY
36454: PUSH
36455: LD_INT 3
36457: ARRAY
36458: PPUSH
36459: CALL_OW 488
36463: PUSH
36464: LD_EXP 96
36468: PUSH
36469: LD_VAR 0 2
36473: ARRAY
36474: PUSH
36475: LD_VAR 0 3
36479: ARRAY
36480: PUSH
36481: LD_INT 2
36483: ARRAY
36484: PPUSH
36485: LD_EXP 96
36489: PUSH
36490: LD_VAR 0 2
36494: ARRAY
36495: PUSH
36496: LD_VAR 0 3
36500: ARRAY
36501: PUSH
36502: LD_INT 3
36504: ARRAY
36505: PPUSH
36506: CALL_OW 284
36510: PUSH
36511: LD_INT 0
36513: EQUAL
36514: AND
36515: IFFALSE 36570
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36517: LD_ADDR_VAR 0 5
36521: PUSH
36522: LD_EXP 96
36526: PUSH
36527: LD_VAR 0 2
36531: ARRAY
36532: PPUSH
36533: LD_VAR 0 3
36537: PPUSH
36538: CALL_OW 3
36542: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36543: LD_ADDR_EXP 96
36547: PUSH
36548: LD_EXP 96
36552: PPUSH
36553: LD_VAR 0 2
36557: PPUSH
36558: LD_VAR 0 5
36562: PPUSH
36563: CALL_OW 1
36567: ST_TO_ADDR
// continue ;
36568: GO 36414
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36570: LD_VAR 0 6
36574: PPUSH
36575: LD_EXP 96
36579: PUSH
36580: LD_VAR 0 2
36584: ARRAY
36585: PUSH
36586: LD_VAR 0 3
36590: ARRAY
36591: PUSH
36592: LD_INT 2
36594: ARRAY
36595: PPUSH
36596: LD_EXP 96
36600: PUSH
36601: LD_VAR 0 2
36605: ARRAY
36606: PUSH
36607: LD_VAR 0 3
36611: ARRAY
36612: PUSH
36613: LD_INT 3
36615: ARRAY
36616: PPUSH
36617: LD_INT 30
36619: PPUSH
36620: CALL 59803 0 4
36624: PUSH
36625: LD_INT 4
36627: ARRAY
36628: PUSH
36629: LD_INT 0
36631: EQUAL
36632: IFFALSE 36658
// begin target := mc_crates [ i ] [ j ] ;
36634: LD_ADDR_VAR 0 7
36638: PUSH
36639: LD_EXP 96
36643: PUSH
36644: LD_VAR 0 2
36648: ARRAY
36649: PUSH
36650: LD_VAR 0 3
36654: ARRAY
36655: ST_TO_ADDR
// break ;
36656: GO 36660
// end ; end ;
36658: GO 36414
36660: POP
36661: POP
// if not target then
36662: LD_VAR 0 7
36666: NOT
36667: IFFALSE 36671
// continue ;
36669: GO 36221
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36671: LD_ADDR_VAR 0 8
36675: PUSH
36676: LD_EXP 99
36680: PUSH
36681: LD_VAR 0 2
36685: ARRAY
36686: PPUSH
36687: LD_INT 2
36689: PUSH
36690: LD_INT 3
36692: PUSH
36693: LD_INT 58
36695: PUSH
36696: EMPTY
36697: LIST
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 61
36705: PUSH
36706: EMPTY
36707: LIST
36708: PUSH
36709: LD_INT 33
36711: PUSH
36712: LD_INT 5
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 33
36721: PUSH
36722: LD_INT 3
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: LD_INT 34
36741: PUSH
36742: LD_INT 32
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 34
36751: PUSH
36752: LD_INT 51
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 34
36761: PUSH
36762: LD_INT 12
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PPUSH
36779: CALL_OW 72
36783: ST_TO_ADDR
// if not cargo then
36784: LD_VAR 0 8
36788: NOT
36789: IFFALSE 37495
// begin if mc_crates_collector [ i ] < 5 then
36791: LD_EXP 97
36795: PUSH
36796: LD_VAR 0 2
36800: ARRAY
36801: PUSH
36802: LD_INT 5
36804: LESS
36805: IFFALSE 37171
// begin if mc_ape [ i ] then
36807: LD_EXP 109
36811: PUSH
36812: LD_VAR 0 2
36816: ARRAY
36817: IFFALSE 36864
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36819: LD_ADDR_VAR 0 5
36823: PUSH
36824: LD_EXP 109
36828: PUSH
36829: LD_VAR 0 2
36833: ARRAY
36834: PPUSH
36835: LD_INT 25
36837: PUSH
36838: LD_INT 16
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 24
36847: PUSH
36848: LD_INT 750
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PPUSH
36859: CALL_OW 72
36863: ST_TO_ADDR
// if not tmp then
36864: LD_VAR 0 5
36868: NOT
36869: IFFALSE 36916
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36871: LD_ADDR_VAR 0 5
36875: PUSH
36876: LD_EXP 80
36880: PUSH
36881: LD_VAR 0 2
36885: ARRAY
36886: PPUSH
36887: LD_INT 25
36889: PUSH
36890: LD_INT 2
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 24
36899: PUSH
36900: LD_INT 750
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PPUSH
36911: CALL_OW 72
36915: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36916: LD_EXP 109
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PUSH
36927: LD_EXP 80
36931: PUSH
36932: LD_VAR 0 2
36936: ARRAY
36937: PPUSH
36938: LD_INT 25
36940: PUSH
36941: LD_INT 2
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 24
36950: PUSH
36951: LD_INT 750
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PPUSH
36962: CALL_OW 72
36966: AND
36967: PUSH
36968: LD_VAR 0 5
36972: PUSH
36973: LD_INT 5
36975: LESS
36976: AND
36977: IFFALSE 37059
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36979: LD_ADDR_VAR 0 3
36983: PUSH
36984: LD_EXP 80
36988: PUSH
36989: LD_VAR 0 2
36993: ARRAY
36994: PPUSH
36995: LD_INT 25
36997: PUSH
36998: LD_INT 2
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 24
37007: PUSH
37008: LD_INT 750
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PPUSH
37019: CALL_OW 72
37023: PUSH
37024: FOR_IN
37025: IFFALSE 37057
// begin tmp := tmp union j ;
37027: LD_ADDR_VAR 0 5
37031: PUSH
37032: LD_VAR 0 5
37036: PUSH
37037: LD_VAR 0 3
37041: UNION
37042: ST_TO_ADDR
// if tmp >= 5 then
37043: LD_VAR 0 5
37047: PUSH
37048: LD_INT 5
37050: GREATEREQUAL
37051: IFFALSE 37055
// break ;
37053: GO 37057
// end ;
37055: GO 37024
37057: POP
37058: POP
// end ; if not tmp then
37059: LD_VAR 0 5
37063: NOT
37064: IFFALSE 37068
// continue ;
37066: GO 36221
// for j in tmp do
37068: LD_ADDR_VAR 0 3
37072: PUSH
37073: LD_VAR 0 5
37077: PUSH
37078: FOR_IN
37079: IFFALSE 37169
// if not GetTag ( j ) then
37081: LD_VAR 0 3
37085: PPUSH
37086: CALL_OW 110
37090: NOT
37091: IFFALSE 37167
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
37093: LD_ADDR_EXP 97
37097: PUSH
37098: LD_EXP 97
37102: PPUSH
37103: LD_VAR 0 2
37107: PUSH
37108: LD_EXP 97
37112: PUSH
37113: LD_VAR 0 2
37117: ARRAY
37118: PUSH
37119: LD_INT 1
37121: PLUS
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PPUSH
37127: LD_VAR 0 3
37131: PPUSH
37132: CALL 58539 0 3
37136: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37137: LD_VAR 0 3
37141: PPUSH
37142: LD_INT 107
37144: PPUSH
37145: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37149: LD_EXP 97
37153: PUSH
37154: LD_VAR 0 2
37158: ARRAY
37159: PUSH
37160: LD_INT 5
37162: GREATEREQUAL
37163: IFFALSE 37167
// break ;
37165: GO 37169
// end ;
37167: GO 37078
37169: POP
37170: POP
// end ; if mc_crates_collector [ i ] and target then
37171: LD_EXP 97
37175: PUSH
37176: LD_VAR 0 2
37180: ARRAY
37181: PUSH
37182: LD_VAR 0 7
37186: AND
37187: IFFALSE 37493
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37189: LD_EXP 97
37193: PUSH
37194: LD_VAR 0 2
37198: ARRAY
37199: PUSH
37200: LD_VAR 0 7
37204: PUSH
37205: LD_INT 1
37207: ARRAY
37208: LESS
37209: IFFALSE 37229
// tmp := mc_crates_collector [ i ] else
37211: LD_ADDR_VAR 0 5
37215: PUSH
37216: LD_EXP 97
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: ST_TO_ADDR
37227: GO 37243
// tmp := target [ 1 ] ;
37229: LD_ADDR_VAR 0 5
37233: PUSH
37234: LD_VAR 0 7
37238: PUSH
37239: LD_INT 1
37241: ARRAY
37242: ST_TO_ADDR
// k := 0 ;
37243: LD_ADDR_VAR 0 4
37247: PUSH
37248: LD_INT 0
37250: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37251: LD_ADDR_VAR 0 3
37255: PUSH
37256: LD_EXP 97
37260: PUSH
37261: LD_VAR 0 2
37265: ARRAY
37266: PUSH
37267: FOR_IN
37268: IFFALSE 37491
// begin k := k + 1 ;
37270: LD_ADDR_VAR 0 4
37274: PUSH
37275: LD_VAR 0 4
37279: PUSH
37280: LD_INT 1
37282: PLUS
37283: ST_TO_ADDR
// if k > tmp then
37284: LD_VAR 0 4
37288: PUSH
37289: LD_VAR 0 5
37293: GREATER
37294: IFFALSE 37298
// break ;
37296: GO 37491
// if not GetClass ( j ) in [ 2 , 16 ] then
37298: LD_VAR 0 3
37302: PPUSH
37303: CALL_OW 257
37307: PUSH
37308: LD_INT 2
37310: PUSH
37311: LD_INT 16
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: IN
37318: NOT
37319: IFFALSE 37372
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37321: LD_ADDR_EXP 97
37325: PUSH
37326: LD_EXP 97
37330: PPUSH
37331: LD_VAR 0 2
37335: PPUSH
37336: LD_EXP 97
37340: PUSH
37341: LD_VAR 0 2
37345: ARRAY
37346: PUSH
37347: LD_VAR 0 3
37351: DIFF
37352: PPUSH
37353: CALL_OW 1
37357: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37358: LD_VAR 0 3
37362: PPUSH
37363: LD_INT 0
37365: PPUSH
37366: CALL_OW 109
// continue ;
37370: GO 37267
// end ; if IsInUnit ( j ) then
37372: LD_VAR 0 3
37376: PPUSH
37377: CALL_OW 310
37381: IFFALSE 37392
// ComExitBuilding ( j ) ;
37383: LD_VAR 0 3
37387: PPUSH
37388: CALL_OW 122
// wait ( 3 ) ;
37392: LD_INT 3
37394: PPUSH
37395: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37399: LD_VAR 0 3
37403: PPUSH
37404: CALL_OW 314
37408: PUSH
37409: LD_VAR 0 6
37413: PPUSH
37414: LD_VAR 0 7
37418: PUSH
37419: LD_INT 2
37421: ARRAY
37422: PPUSH
37423: LD_VAR 0 7
37427: PUSH
37428: LD_INT 3
37430: ARRAY
37431: PPUSH
37432: LD_INT 30
37434: PPUSH
37435: CALL 59803 0 4
37439: PUSH
37440: LD_INT 4
37442: ARRAY
37443: AND
37444: IFFALSE 37462
// ComStandNearbyBuilding ( j , depot ) else
37446: LD_VAR 0 3
37450: PPUSH
37451: LD_VAR 0 9
37455: PPUSH
37456: CALL 55141 0 2
37460: GO 37489
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37462: LD_VAR 0 3
37466: PPUSH
37467: LD_VAR 0 7
37471: PUSH
37472: LD_INT 2
37474: ARRAY
37475: PPUSH
37476: LD_VAR 0 7
37480: PUSH
37481: LD_INT 3
37483: ARRAY
37484: PPUSH
37485: CALL_OW 117
// end ;
37489: GO 37267
37491: POP
37492: POP
// end ; end else
37493: GO 38025
// begin for j in cargo do
37495: LD_ADDR_VAR 0 3
37499: PUSH
37500: LD_VAR 0 8
37504: PUSH
37505: FOR_IN
37506: IFFALSE 38023
// begin if GetTag ( j ) <> 0 then
37508: LD_VAR 0 3
37512: PPUSH
37513: CALL_OW 110
37517: PUSH
37518: LD_INT 0
37520: NONEQUAL
37521: IFFALSE 37525
// continue ;
37523: GO 37505
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37525: LD_VAR 0 3
37529: PPUSH
37530: CALL_OW 256
37534: PUSH
37535: LD_INT 1000
37537: LESS
37538: PUSH
37539: LD_VAR 0 3
37543: PPUSH
37544: LD_EXP 104
37548: PUSH
37549: LD_VAR 0 2
37553: ARRAY
37554: PPUSH
37555: CALL_OW 308
37559: NOT
37560: AND
37561: IFFALSE 37583
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37563: LD_VAR 0 3
37567: PPUSH
37568: LD_EXP 104
37572: PUSH
37573: LD_VAR 0 2
37577: ARRAY
37578: PPUSH
37579: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37583: LD_VAR 0 3
37587: PPUSH
37588: CALL_OW 256
37592: PUSH
37593: LD_INT 1000
37595: LESS
37596: PUSH
37597: LD_VAR 0 3
37601: PPUSH
37602: LD_EXP 104
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: PPUSH
37613: CALL_OW 308
37617: AND
37618: IFFALSE 37622
// continue ;
37620: GO 37505
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37622: LD_VAR 0 3
37626: PPUSH
37627: CALL_OW 262
37631: PUSH
37632: LD_INT 2
37634: EQUAL
37635: PUSH
37636: LD_VAR 0 3
37640: PPUSH
37641: CALL_OW 261
37645: PUSH
37646: LD_INT 15
37648: LESS
37649: AND
37650: IFFALSE 37654
// continue ;
37652: GO 37505
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37654: LD_VAR 0 3
37658: PPUSH
37659: CALL_OW 262
37663: PUSH
37664: LD_INT 1
37666: EQUAL
37667: PUSH
37668: LD_VAR 0 3
37672: PPUSH
37673: CALL_OW 261
37677: PUSH
37678: LD_INT 10
37680: LESS
37681: AND
37682: IFFALSE 37962
// begin if not depot then
37684: LD_VAR 0 9
37688: NOT
37689: IFFALSE 37693
// continue ;
37691: GO 37505
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37693: LD_VAR 0 3
37697: PPUSH
37698: LD_VAR 0 9
37702: PPUSH
37703: LD_VAR 0 3
37707: PPUSH
37708: CALL_OW 74
37712: PPUSH
37713: CALL_OW 296
37717: PUSH
37718: LD_INT 6
37720: LESS
37721: IFFALSE 37737
// SetFuel ( j , 100 ) else
37723: LD_VAR 0 3
37727: PPUSH
37728: LD_INT 100
37730: PPUSH
37731: CALL_OW 240
37735: GO 37962
// if GetFuel ( j ) = 0 then
37737: LD_VAR 0 3
37741: PPUSH
37742: CALL_OW 261
37746: PUSH
37747: LD_INT 0
37749: EQUAL
37750: IFFALSE 37962
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37752: LD_ADDR_EXP 99
37756: PUSH
37757: LD_EXP 99
37761: PPUSH
37762: LD_VAR 0 2
37766: PPUSH
37767: LD_EXP 99
37771: PUSH
37772: LD_VAR 0 2
37776: ARRAY
37777: PUSH
37778: LD_VAR 0 3
37782: DIFF
37783: PPUSH
37784: CALL_OW 1
37788: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37789: LD_VAR 0 3
37793: PPUSH
37794: CALL_OW 263
37798: PUSH
37799: LD_INT 1
37801: EQUAL
37802: IFFALSE 37818
// ComExitVehicle ( IsInUnit ( j ) ) ;
37804: LD_VAR 0 3
37808: PPUSH
37809: CALL_OW 310
37813: PPUSH
37814: CALL_OW 121
// if GetControl ( j ) = control_remote then
37818: LD_VAR 0 3
37822: PPUSH
37823: CALL_OW 263
37827: PUSH
37828: LD_INT 2
37830: EQUAL
37831: IFFALSE 37842
// ComUnlink ( j ) ;
37833: LD_VAR 0 3
37837: PPUSH
37838: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37842: LD_ADDR_VAR 0 10
37846: PUSH
37847: LD_VAR 0 2
37851: PPUSH
37852: LD_INT 3
37854: PPUSH
37855: CALL 47606 0 2
37859: ST_TO_ADDR
// if fac then
37860: LD_VAR 0 10
37864: IFFALSE 37960
// begin for k in fac do
37866: LD_ADDR_VAR 0 4
37870: PUSH
37871: LD_VAR 0 10
37875: PUSH
37876: FOR_IN
37877: IFFALSE 37958
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37879: LD_ADDR_VAR 0 11
37883: PUSH
37884: LD_VAR 0 10
37888: PPUSH
37889: LD_VAR 0 3
37893: PPUSH
37894: CALL_OW 265
37898: PPUSH
37899: LD_VAR 0 3
37903: PPUSH
37904: CALL_OW 262
37908: PPUSH
37909: LD_VAR 0 3
37913: PPUSH
37914: CALL_OW 263
37918: PPUSH
37919: LD_VAR 0 3
37923: PPUSH
37924: CALL_OW 264
37928: PPUSH
37929: CALL 56037 0 5
37933: ST_TO_ADDR
// if components then
37934: LD_VAR 0 11
37938: IFFALSE 37956
// begin MC_InsertProduceList ( i , components ) ;
37940: LD_VAR 0 2
37944: PPUSH
37945: LD_VAR 0 11
37949: PPUSH
37950: CALL 47151 0 2
// break ;
37954: GO 37958
// end ; end ;
37956: GO 37876
37958: POP
37959: POP
// end ; continue ;
37960: GO 37505
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37962: LD_VAR 0 3
37966: PPUSH
37967: LD_INT 1
37969: PPUSH
37970: CALL_OW 289
37974: PUSH
37975: LD_INT 100
37977: LESS
37978: PUSH
37979: LD_VAR 0 3
37983: PPUSH
37984: CALL_OW 314
37988: NOT
37989: AND
37990: IFFALSE 38019
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37992: LD_VAR 0 3
37996: PPUSH
37997: LD_VAR 0 7
38001: PUSH
38002: LD_INT 2
38004: ARRAY
38005: PPUSH
38006: LD_VAR 0 7
38010: PUSH
38011: LD_INT 3
38013: ARRAY
38014: PPUSH
38015: CALL_OW 117
// break ;
38019: GO 38023
// end ;
38021: GO 37505
38023: POP
38024: POP
// end ; end ;
38025: GO 36221
38027: POP
38028: POP
// end ;
38029: LD_VAR 0 1
38033: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
38034: LD_INT 0
38036: PPUSH
38037: PPUSH
38038: PPUSH
38039: PPUSH
// if not mc_bases then
38040: LD_EXP 80
38044: NOT
38045: IFFALSE 38049
// exit ;
38047: GO 38210
// for i = 1 to mc_bases do
38049: LD_ADDR_VAR 0 2
38053: PUSH
38054: DOUBLE
38055: LD_INT 1
38057: DEC
38058: ST_TO_ADDR
38059: LD_EXP 80
38063: PUSH
38064: FOR_TO
38065: IFFALSE 38208
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
38067: LD_ADDR_VAR 0 4
38071: PUSH
38072: LD_EXP 99
38076: PUSH
38077: LD_VAR 0 2
38081: ARRAY
38082: PUSH
38083: LD_EXP 102
38087: PUSH
38088: LD_VAR 0 2
38092: ARRAY
38093: UNION
38094: PPUSH
38095: LD_INT 33
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PPUSH
38105: CALL_OW 72
38109: ST_TO_ADDR
// if tmp then
38110: LD_VAR 0 4
38114: IFFALSE 38206
// for j in tmp do
38116: LD_ADDR_VAR 0 3
38120: PUSH
38121: LD_VAR 0 4
38125: PUSH
38126: FOR_IN
38127: IFFALSE 38204
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38129: LD_VAR 0 3
38133: PPUSH
38134: CALL_OW 312
38138: NOT
38139: PUSH
38140: LD_VAR 0 3
38144: PPUSH
38145: CALL_OW 256
38149: PUSH
38150: LD_INT 250
38152: GREATEREQUAL
38153: AND
38154: IFFALSE 38167
// Connect ( j ) else
38156: LD_VAR 0 3
38160: PPUSH
38161: CALL 61885 0 1
38165: GO 38202
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38167: LD_VAR 0 3
38171: PPUSH
38172: CALL_OW 256
38176: PUSH
38177: LD_INT 250
38179: LESS
38180: PUSH
38181: LD_VAR 0 3
38185: PPUSH
38186: CALL_OW 312
38190: AND
38191: IFFALSE 38202
// ComUnlink ( j ) ;
38193: LD_VAR 0 3
38197: PPUSH
38198: CALL_OW 136
38202: GO 38126
38204: POP
38205: POP
// end ;
38206: GO 38064
38208: POP
38209: POP
// end ;
38210: LD_VAR 0 1
38214: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38215: LD_INT 0
38217: PPUSH
38218: PPUSH
38219: PPUSH
38220: PPUSH
38221: PPUSH
// if not mc_bases then
38222: LD_EXP 80
38226: NOT
38227: IFFALSE 38231
// exit ;
38229: GO 38676
// for i = 1 to mc_bases do
38231: LD_ADDR_VAR 0 2
38235: PUSH
38236: DOUBLE
38237: LD_INT 1
38239: DEC
38240: ST_TO_ADDR
38241: LD_EXP 80
38245: PUSH
38246: FOR_TO
38247: IFFALSE 38674
// begin if not mc_produce [ i ] then
38249: LD_EXP 101
38253: PUSH
38254: LD_VAR 0 2
38258: ARRAY
38259: NOT
38260: IFFALSE 38264
// continue ;
38262: GO 38246
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38264: LD_ADDR_VAR 0 5
38268: PUSH
38269: LD_EXP 80
38273: PUSH
38274: LD_VAR 0 2
38278: ARRAY
38279: PPUSH
38280: LD_INT 30
38282: PUSH
38283: LD_INT 3
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PPUSH
38290: CALL_OW 72
38294: ST_TO_ADDR
// if not fac then
38295: LD_VAR 0 5
38299: NOT
38300: IFFALSE 38304
// continue ;
38302: GO 38246
// for j in fac do
38304: LD_ADDR_VAR 0 3
38308: PUSH
38309: LD_VAR 0 5
38313: PUSH
38314: FOR_IN
38315: IFFALSE 38670
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38317: LD_VAR 0 3
38321: PPUSH
38322: CALL_OW 461
38326: PUSH
38327: LD_INT 2
38329: NONEQUAL
38330: PUSH
38331: LD_VAR 0 3
38335: PPUSH
38336: LD_INT 15
38338: PPUSH
38339: CALL 61504 0 2
38343: PUSH
38344: LD_INT 4
38346: ARRAY
38347: OR
38348: IFFALSE 38352
// continue ;
38350: GO 38314
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38352: LD_VAR 0 3
38356: PPUSH
38357: LD_EXP 101
38361: PUSH
38362: LD_VAR 0 2
38366: ARRAY
38367: PUSH
38368: LD_INT 1
38370: ARRAY
38371: PUSH
38372: LD_INT 1
38374: ARRAY
38375: PPUSH
38376: LD_EXP 101
38380: PUSH
38381: LD_VAR 0 2
38385: ARRAY
38386: PUSH
38387: LD_INT 1
38389: ARRAY
38390: PUSH
38391: LD_INT 2
38393: ARRAY
38394: PPUSH
38395: LD_EXP 101
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_INT 1
38408: ARRAY
38409: PUSH
38410: LD_INT 3
38412: ARRAY
38413: PPUSH
38414: LD_EXP 101
38418: PUSH
38419: LD_VAR 0 2
38423: ARRAY
38424: PUSH
38425: LD_INT 1
38427: ARRAY
38428: PUSH
38429: LD_INT 4
38431: ARRAY
38432: PPUSH
38433: CALL_OW 448
38437: PUSH
38438: LD_VAR 0 3
38442: PPUSH
38443: LD_EXP 101
38447: PUSH
38448: LD_VAR 0 2
38452: ARRAY
38453: PUSH
38454: LD_INT 1
38456: ARRAY
38457: PUSH
38458: LD_INT 1
38460: ARRAY
38461: PUSH
38462: LD_EXP 101
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PUSH
38473: LD_INT 1
38475: ARRAY
38476: PUSH
38477: LD_INT 2
38479: ARRAY
38480: PUSH
38481: LD_EXP 101
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: PUSH
38496: LD_INT 3
38498: ARRAY
38499: PUSH
38500: LD_EXP 101
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: PUSH
38511: LD_INT 1
38513: ARRAY
38514: PUSH
38515: LD_INT 4
38517: ARRAY
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL 65280 0 2
38529: AND
38530: IFFALSE 38668
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38532: LD_VAR 0 3
38536: PPUSH
38537: LD_EXP 101
38541: PUSH
38542: LD_VAR 0 2
38546: ARRAY
38547: PUSH
38548: LD_INT 1
38550: ARRAY
38551: PUSH
38552: LD_INT 1
38554: ARRAY
38555: PPUSH
38556: LD_EXP 101
38560: PUSH
38561: LD_VAR 0 2
38565: ARRAY
38566: PUSH
38567: LD_INT 1
38569: ARRAY
38570: PUSH
38571: LD_INT 2
38573: ARRAY
38574: PPUSH
38575: LD_EXP 101
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PUSH
38586: LD_INT 1
38588: ARRAY
38589: PUSH
38590: LD_INT 3
38592: ARRAY
38593: PPUSH
38594: LD_EXP 101
38598: PUSH
38599: LD_VAR 0 2
38603: ARRAY
38604: PUSH
38605: LD_INT 1
38607: ARRAY
38608: PUSH
38609: LD_INT 4
38611: ARRAY
38612: PPUSH
38613: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38617: LD_ADDR_VAR 0 4
38621: PUSH
38622: LD_EXP 101
38626: PUSH
38627: LD_VAR 0 2
38631: ARRAY
38632: PPUSH
38633: LD_INT 1
38635: PPUSH
38636: CALL_OW 3
38640: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38641: LD_ADDR_EXP 101
38645: PUSH
38646: LD_EXP 101
38650: PPUSH
38651: LD_VAR 0 2
38655: PPUSH
38656: LD_VAR 0 4
38660: PPUSH
38661: CALL_OW 1
38665: ST_TO_ADDR
// break ;
38666: GO 38670
// end ; end ;
38668: GO 38314
38670: POP
38671: POP
// end ;
38672: GO 38246
38674: POP
38675: POP
// end ;
38676: LD_VAR 0 1
38680: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38681: LD_INT 0
38683: PPUSH
38684: PPUSH
38685: PPUSH
// if not mc_bases then
38686: LD_EXP 80
38690: NOT
38691: IFFALSE 38695
// exit ;
38693: GO 38784
// for i = 1 to mc_bases do
38695: LD_ADDR_VAR 0 2
38699: PUSH
38700: DOUBLE
38701: LD_INT 1
38703: DEC
38704: ST_TO_ADDR
38705: LD_EXP 80
38709: PUSH
38710: FOR_TO
38711: IFFALSE 38782
// begin if mc_attack [ i ] then
38713: LD_EXP 100
38717: PUSH
38718: LD_VAR 0 2
38722: ARRAY
38723: IFFALSE 38780
// begin tmp := mc_attack [ i ] [ 1 ] ;
38725: LD_ADDR_VAR 0 3
38729: PUSH
38730: LD_EXP 100
38734: PUSH
38735: LD_VAR 0 2
38739: ARRAY
38740: PUSH
38741: LD_INT 1
38743: ARRAY
38744: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38745: LD_ADDR_EXP 100
38749: PUSH
38750: LD_EXP 100
38754: PPUSH
38755: LD_VAR 0 2
38759: PPUSH
38760: EMPTY
38761: PPUSH
38762: CALL_OW 1
38766: ST_TO_ADDR
// Attack ( tmp ) ;
38767: LD_VAR 0 3
38771: PPUSH
38772: CALL 117138 0 1
// exit ;
38776: POP
38777: POP
38778: GO 38784
// end ; end ;
38780: GO 38710
38782: POP
38783: POP
// end ;
38784: LD_VAR 0 1
38788: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38789: LD_INT 0
38791: PPUSH
38792: PPUSH
38793: PPUSH
38794: PPUSH
38795: PPUSH
38796: PPUSH
38797: PPUSH
// if not mc_bases then
38798: LD_EXP 80
38802: NOT
38803: IFFALSE 38807
// exit ;
38805: GO 39664
// for i = 1 to mc_bases do
38807: LD_ADDR_VAR 0 2
38811: PUSH
38812: DOUBLE
38813: LD_INT 1
38815: DEC
38816: ST_TO_ADDR
38817: LD_EXP 80
38821: PUSH
38822: FOR_TO
38823: IFFALSE 39662
// begin if not mc_bases [ i ] then
38825: LD_EXP 80
38829: PUSH
38830: LD_VAR 0 2
38834: ARRAY
38835: NOT
38836: IFFALSE 38840
// continue ;
38838: GO 38822
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38840: LD_ADDR_VAR 0 7
38844: PUSH
38845: LD_EXP 80
38849: PUSH
38850: LD_VAR 0 2
38854: ARRAY
38855: PUSH
38856: LD_INT 1
38858: ARRAY
38859: PPUSH
38860: CALL 55363 0 1
38864: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38865: LD_ADDR_EXP 103
38869: PUSH
38870: LD_EXP 103
38874: PPUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: LD_EXP 80
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: PUSH
38891: LD_INT 1
38893: ARRAY
38894: PPUSH
38895: CALL_OW 255
38899: PPUSH
38900: LD_EXP 105
38904: PUSH
38905: LD_VAR 0 2
38909: ARRAY
38910: PPUSH
38911: CALL 55328 0 2
38915: PPUSH
38916: CALL_OW 1
38920: ST_TO_ADDR
// if not mc_scan [ i ] then
38921: LD_EXP 103
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: NOT
38932: IFFALSE 39110
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38934: LD_ADDR_EXP 123
38938: PUSH
38939: LD_EXP 123
38943: PPUSH
38944: LD_VAR 0 2
38948: PPUSH
38949: LD_INT 0
38951: PPUSH
38952: CALL_OW 1
38956: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38957: LD_ADDR_VAR 0 4
38961: PUSH
38962: LD_EXP 80
38966: PUSH
38967: LD_VAR 0 2
38971: ARRAY
38972: PPUSH
38973: LD_INT 2
38975: PUSH
38976: LD_INT 25
38978: PUSH
38979: LD_INT 5
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 25
38988: PUSH
38989: LD_INT 8
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 25
38998: PUSH
38999: LD_INT 9
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: PPUSH
39012: CALL_OW 72
39016: ST_TO_ADDR
// if not tmp then
39017: LD_VAR 0 4
39021: NOT
39022: IFFALSE 39026
// continue ;
39024: GO 38822
// for j in tmp do
39026: LD_ADDR_VAR 0 3
39030: PUSH
39031: LD_VAR 0 4
39035: PUSH
39036: FOR_IN
39037: IFFALSE 39108
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
39039: LD_VAR 0 3
39043: PPUSH
39044: CALL_OW 310
39048: PPUSH
39049: CALL_OW 266
39053: PUSH
39054: LD_INT 5
39056: EQUAL
39057: PUSH
39058: LD_VAR 0 3
39062: PPUSH
39063: CALL_OW 257
39067: PUSH
39068: LD_INT 1
39070: EQUAL
39071: AND
39072: PUSH
39073: LD_VAR 0 3
39077: PPUSH
39078: CALL_OW 459
39082: NOT
39083: AND
39084: PUSH
39085: LD_VAR 0 7
39089: AND
39090: IFFALSE 39106
// ComChangeProfession ( j , class ) ;
39092: LD_VAR 0 3
39096: PPUSH
39097: LD_VAR 0 7
39101: PPUSH
39102: CALL_OW 123
39106: GO 39036
39108: POP
39109: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39110: LD_EXP 103
39114: PUSH
39115: LD_VAR 0 2
39119: ARRAY
39120: PUSH
39121: LD_EXP 123
39125: PUSH
39126: LD_VAR 0 2
39130: ARRAY
39131: NOT
39132: AND
39133: PUSH
39134: LD_EXP 102
39138: PUSH
39139: LD_VAR 0 2
39143: ARRAY
39144: NOT
39145: AND
39146: PUSH
39147: LD_EXP 80
39151: PUSH
39152: LD_VAR 0 2
39156: ARRAY
39157: PPUSH
39158: LD_INT 50
39160: PUSH
39161: EMPTY
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 30
39169: PUSH
39170: LD_INT 32
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 30
39179: PUSH
39180: LD_INT 33
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 30
39189: PUSH
39190: LD_INT 4
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 30
39199: PUSH
39200: LD_INT 5
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PPUSH
39218: CALL_OW 72
39222: PUSH
39223: LD_INT 4
39225: LESS
39226: PUSH
39227: LD_EXP 80
39231: PUSH
39232: LD_VAR 0 2
39236: ARRAY
39237: PPUSH
39238: LD_INT 3
39240: PUSH
39241: LD_INT 24
39243: PUSH
39244: LD_INT 1000
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 2
39257: PUSH
39258: LD_INT 30
39260: PUSH
39261: LD_INT 0
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 30
39270: PUSH
39271: LD_INT 1
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PPUSH
39287: CALL_OW 72
39291: OR
39292: AND
39293: IFFALSE 39544
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39295: LD_ADDR_EXP 123
39299: PUSH
39300: LD_EXP 123
39304: PPUSH
39305: LD_VAR 0 2
39309: PPUSH
39310: LD_INT 1
39312: PPUSH
39313: CALL_OW 1
39317: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39318: LD_ADDR_VAR 0 4
39322: PUSH
39323: LD_EXP 80
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: PPUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 25
39339: PUSH
39340: LD_INT 1
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 25
39349: PUSH
39350: LD_INT 5
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 25
39359: PUSH
39360: LD_INT 8
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 25
39369: PUSH
39370: LD_INT 9
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: PPUSH
39384: CALL_OW 72
39388: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39389: LD_ADDR_VAR 0 4
39393: PUSH
39394: LD_VAR 0 4
39398: PUSH
39399: LD_VAR 0 4
39403: PPUSH
39404: LD_INT 18
39406: PPUSH
39407: CALL 88837 0 2
39411: DIFF
39412: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39413: LD_VAR 0 4
39417: NOT
39418: PUSH
39419: LD_EXP 80
39423: PUSH
39424: LD_VAR 0 2
39428: ARRAY
39429: PPUSH
39430: LD_INT 2
39432: PUSH
39433: LD_INT 30
39435: PUSH
39436: LD_INT 4
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 30
39445: PUSH
39446: LD_INT 5
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: LIST
39457: PPUSH
39458: CALL_OW 72
39462: NOT
39463: AND
39464: IFFALSE 39526
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39466: LD_ADDR_VAR 0 4
39470: PUSH
39471: LD_EXP 80
39475: PUSH
39476: LD_VAR 0 2
39480: ARRAY
39481: PPUSH
39482: LD_INT 2
39484: PUSH
39485: LD_INT 25
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 25
39497: PUSH
39498: LD_INT 3
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 25
39507: PUSH
39508: LD_INT 4
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: PPUSH
39521: CALL_OW 72
39525: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39526: LD_VAR 0 2
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL 121847 0 2
// exit ;
39540: POP
39541: POP
39542: GO 39664
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39544: LD_EXP 103
39548: PUSH
39549: LD_VAR 0 2
39553: ARRAY
39554: PUSH
39555: LD_EXP 123
39559: PUSH
39560: LD_VAR 0 2
39564: ARRAY
39565: NOT
39566: AND
39567: PUSH
39568: LD_EXP 102
39572: PUSH
39573: LD_VAR 0 2
39577: ARRAY
39578: AND
39579: IFFALSE 39660
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39581: LD_ADDR_EXP 123
39585: PUSH
39586: LD_EXP 123
39590: PPUSH
39591: LD_VAR 0 2
39595: PPUSH
39596: LD_INT 1
39598: PPUSH
39599: CALL_OW 1
39603: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39604: LD_ADDR_VAR 0 4
39608: PUSH
39609: LD_EXP 102
39613: PUSH
39614: LD_VAR 0 2
39618: ARRAY
39619: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39620: LD_ADDR_EXP 102
39624: PUSH
39625: LD_EXP 102
39629: PPUSH
39630: LD_VAR 0 2
39634: PPUSH
39635: EMPTY
39636: PPUSH
39637: CALL_OW 1
39641: ST_TO_ADDR
// Defend ( i , tmp ) ;
39642: LD_VAR 0 2
39646: PPUSH
39647: LD_VAR 0 4
39651: PPUSH
39652: CALL 122443 0 2
// exit ;
39656: POP
39657: POP
39658: GO 39664
// end ; end ;
39660: GO 38822
39662: POP
39663: POP
// end ;
39664: LD_VAR 0 1
39668: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39669: LD_INT 0
39671: PPUSH
39672: PPUSH
39673: PPUSH
39674: PPUSH
39675: PPUSH
39676: PPUSH
39677: PPUSH
39678: PPUSH
39679: PPUSH
39680: PPUSH
39681: PPUSH
// if not mc_bases then
39682: LD_EXP 80
39686: NOT
39687: IFFALSE 39691
// exit ;
39689: GO 40778
// for i = 1 to mc_bases do
39691: LD_ADDR_VAR 0 2
39695: PUSH
39696: DOUBLE
39697: LD_INT 1
39699: DEC
39700: ST_TO_ADDR
39701: LD_EXP 80
39705: PUSH
39706: FOR_TO
39707: IFFALSE 40776
// begin tmp := mc_lab [ i ] ;
39709: LD_ADDR_VAR 0 6
39713: PUSH
39714: LD_EXP 113
39718: PUSH
39719: LD_VAR 0 2
39723: ARRAY
39724: ST_TO_ADDR
// if not tmp then
39725: LD_VAR 0 6
39729: NOT
39730: IFFALSE 39734
// continue ;
39732: GO 39706
// idle_lab := 0 ;
39734: LD_ADDR_VAR 0 11
39738: PUSH
39739: LD_INT 0
39741: ST_TO_ADDR
// for j in tmp do
39742: LD_ADDR_VAR 0 3
39746: PUSH
39747: LD_VAR 0 6
39751: PUSH
39752: FOR_IN
39753: IFFALSE 40772
// begin researching := false ;
39755: LD_ADDR_VAR 0 10
39759: PUSH
39760: LD_INT 0
39762: ST_TO_ADDR
// side := GetSide ( j ) ;
39763: LD_ADDR_VAR 0 4
39767: PUSH
39768: LD_VAR 0 3
39772: PPUSH
39773: CALL_OW 255
39777: ST_TO_ADDR
// if not mc_tech [ side ] then
39778: LD_EXP 107
39782: PUSH
39783: LD_VAR 0 4
39787: ARRAY
39788: NOT
39789: IFFALSE 39793
// continue ;
39791: GO 39752
// if BuildingStatus ( j ) = bs_idle then
39793: LD_VAR 0 3
39797: PPUSH
39798: CALL_OW 461
39802: PUSH
39803: LD_INT 2
39805: EQUAL
39806: IFFALSE 39994
// begin if idle_lab and UnitsInside ( j ) < 6 then
39808: LD_VAR 0 11
39812: PUSH
39813: LD_VAR 0 3
39817: PPUSH
39818: CALL_OW 313
39822: PUSH
39823: LD_INT 6
39825: LESS
39826: AND
39827: IFFALSE 39898
// begin tmp2 := UnitsInside ( idle_lab ) ;
39829: LD_ADDR_VAR 0 9
39833: PUSH
39834: LD_VAR 0 11
39838: PPUSH
39839: CALL_OW 313
39843: ST_TO_ADDR
// if tmp2 then
39844: LD_VAR 0 9
39848: IFFALSE 39890
// for x in tmp2 do
39850: LD_ADDR_VAR 0 7
39854: PUSH
39855: LD_VAR 0 9
39859: PUSH
39860: FOR_IN
39861: IFFALSE 39888
// begin ComExitBuilding ( x ) ;
39863: LD_VAR 0 7
39867: PPUSH
39868: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39872: LD_VAR 0 7
39876: PPUSH
39877: LD_VAR 0 3
39881: PPUSH
39882: CALL_OW 180
// end ;
39886: GO 39860
39888: POP
39889: POP
// idle_lab := 0 ;
39890: LD_ADDR_VAR 0 11
39894: PUSH
39895: LD_INT 0
39897: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39898: LD_ADDR_VAR 0 5
39902: PUSH
39903: LD_EXP 107
39907: PUSH
39908: LD_VAR 0 4
39912: ARRAY
39913: PUSH
39914: FOR_IN
39915: IFFALSE 39975
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39917: LD_VAR 0 3
39921: PPUSH
39922: LD_VAR 0 5
39926: PPUSH
39927: CALL_OW 430
39931: PUSH
39932: LD_VAR 0 4
39936: PPUSH
39937: LD_VAR 0 5
39941: PPUSH
39942: CALL 54433 0 2
39946: AND
39947: IFFALSE 39973
// begin researching := true ;
39949: LD_ADDR_VAR 0 10
39953: PUSH
39954: LD_INT 1
39956: ST_TO_ADDR
// ComResearch ( j , t ) ;
39957: LD_VAR 0 3
39961: PPUSH
39962: LD_VAR 0 5
39966: PPUSH
39967: CALL_OW 124
// break ;
39971: GO 39975
// end ;
39973: GO 39914
39975: POP
39976: POP
// if not researching then
39977: LD_VAR 0 10
39981: NOT
39982: IFFALSE 39994
// idle_lab := j ;
39984: LD_ADDR_VAR 0 11
39988: PUSH
39989: LD_VAR 0 3
39993: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39994: LD_VAR 0 3
39998: PPUSH
39999: CALL_OW 461
40003: PUSH
40004: LD_INT 10
40006: EQUAL
40007: IFFALSE 40595
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
40009: LD_EXP 109
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: NOT
40020: PUSH
40021: LD_EXP 110
40025: PUSH
40026: LD_VAR 0 2
40030: ARRAY
40031: NOT
40032: AND
40033: PUSH
40034: LD_EXP 107
40038: PUSH
40039: LD_VAR 0 4
40043: ARRAY
40044: PUSH
40045: LD_INT 1
40047: GREATER
40048: AND
40049: IFFALSE 40180
// begin ComCancel ( j ) ;
40051: LD_VAR 0 3
40055: PPUSH
40056: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
40060: LD_ADDR_EXP 107
40064: PUSH
40065: LD_EXP 107
40069: PPUSH
40070: LD_VAR 0 4
40074: PPUSH
40075: LD_EXP 107
40079: PUSH
40080: LD_VAR 0 4
40084: ARRAY
40085: PPUSH
40086: LD_EXP 107
40090: PUSH
40091: LD_VAR 0 4
40095: ARRAY
40096: PUSH
40097: LD_INT 1
40099: MINUS
40100: PPUSH
40101: LD_EXP 107
40105: PUSH
40106: LD_VAR 0 4
40110: ARRAY
40111: PPUSH
40112: LD_INT 0
40114: PPUSH
40115: CALL 57957 0 4
40119: PPUSH
40120: CALL_OW 1
40124: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40125: LD_ADDR_EXP 107
40129: PUSH
40130: LD_EXP 107
40134: PPUSH
40135: LD_VAR 0 4
40139: PPUSH
40140: LD_EXP 107
40144: PUSH
40145: LD_VAR 0 4
40149: ARRAY
40150: PPUSH
40151: LD_EXP 107
40155: PUSH
40156: LD_VAR 0 4
40160: ARRAY
40161: PPUSH
40162: LD_INT 1
40164: PPUSH
40165: LD_INT 0
40167: PPUSH
40168: CALL 57957 0 4
40172: PPUSH
40173: CALL_OW 1
40177: ST_TO_ADDR
// continue ;
40178: GO 39752
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40180: LD_EXP 109
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: PUSH
40191: LD_EXP 110
40195: PUSH
40196: LD_VAR 0 2
40200: ARRAY
40201: NOT
40202: AND
40203: IFFALSE 40330
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40205: LD_ADDR_EXP 110
40209: PUSH
40210: LD_EXP 110
40214: PPUSH
40215: LD_VAR 0 2
40219: PUSH
40220: LD_EXP 110
40224: PUSH
40225: LD_VAR 0 2
40229: ARRAY
40230: PUSH
40231: LD_INT 1
40233: PLUS
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PPUSH
40239: LD_EXP 109
40243: PUSH
40244: LD_VAR 0 2
40248: ARRAY
40249: PUSH
40250: LD_INT 1
40252: ARRAY
40253: PPUSH
40254: CALL 58539 0 3
40258: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40259: LD_EXP 109
40263: PUSH
40264: LD_VAR 0 2
40268: ARRAY
40269: PUSH
40270: LD_INT 1
40272: ARRAY
40273: PPUSH
40274: LD_INT 112
40276: PPUSH
40277: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40281: LD_ADDR_VAR 0 9
40285: PUSH
40286: LD_EXP 109
40290: PUSH
40291: LD_VAR 0 2
40295: ARRAY
40296: PPUSH
40297: LD_INT 1
40299: PPUSH
40300: CALL_OW 3
40304: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40305: LD_ADDR_EXP 109
40309: PUSH
40310: LD_EXP 109
40314: PPUSH
40315: LD_VAR 0 2
40319: PPUSH
40320: LD_VAR 0 9
40324: PPUSH
40325: CALL_OW 1
40329: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40330: LD_EXP 109
40334: PUSH
40335: LD_VAR 0 2
40339: ARRAY
40340: PUSH
40341: LD_EXP 110
40345: PUSH
40346: LD_VAR 0 2
40350: ARRAY
40351: AND
40352: PUSH
40353: LD_EXP 110
40357: PUSH
40358: LD_VAR 0 2
40362: ARRAY
40363: PUSH
40364: LD_INT 1
40366: ARRAY
40367: PPUSH
40368: CALL_OW 310
40372: NOT
40373: AND
40374: PUSH
40375: LD_VAR 0 3
40379: PPUSH
40380: CALL_OW 313
40384: PUSH
40385: LD_INT 6
40387: EQUAL
40388: AND
40389: IFFALSE 40445
// begin tmp2 := UnitsInside ( j ) ;
40391: LD_ADDR_VAR 0 9
40395: PUSH
40396: LD_VAR 0 3
40400: PPUSH
40401: CALL_OW 313
40405: ST_TO_ADDR
// if tmp2 = 6 then
40406: LD_VAR 0 9
40410: PUSH
40411: LD_INT 6
40413: EQUAL
40414: IFFALSE 40445
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40416: LD_VAR 0 9
40420: PUSH
40421: LD_INT 1
40423: ARRAY
40424: PPUSH
40425: LD_INT 112
40427: PPUSH
40428: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40432: LD_VAR 0 9
40436: PUSH
40437: LD_INT 1
40439: ARRAY
40440: PPUSH
40441: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40445: LD_EXP 110
40449: PUSH
40450: LD_VAR 0 2
40454: ARRAY
40455: PUSH
40456: LD_EXP 110
40460: PUSH
40461: LD_VAR 0 2
40465: ARRAY
40466: PUSH
40467: LD_INT 1
40469: ARRAY
40470: PPUSH
40471: CALL_OW 314
40475: NOT
40476: AND
40477: PUSH
40478: LD_EXP 110
40482: PUSH
40483: LD_VAR 0 2
40487: ARRAY
40488: PUSH
40489: LD_INT 1
40491: ARRAY
40492: PPUSH
40493: CALL_OW 310
40497: NOT
40498: AND
40499: IFFALSE 40525
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40501: LD_EXP 110
40505: PUSH
40506: LD_VAR 0 2
40510: ARRAY
40511: PUSH
40512: LD_INT 1
40514: ARRAY
40515: PPUSH
40516: LD_VAR 0 3
40520: PPUSH
40521: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40525: LD_EXP 110
40529: PUSH
40530: LD_VAR 0 2
40534: ARRAY
40535: PUSH
40536: LD_INT 1
40538: ARRAY
40539: PPUSH
40540: CALL_OW 310
40544: PUSH
40545: LD_EXP 110
40549: PUSH
40550: LD_VAR 0 2
40554: ARRAY
40555: PUSH
40556: LD_INT 1
40558: ARRAY
40559: PPUSH
40560: CALL_OW 310
40564: PPUSH
40565: CALL_OW 461
40569: PUSH
40570: LD_INT 3
40572: NONEQUAL
40573: AND
40574: IFFALSE 40595
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40576: LD_EXP 110
40580: PUSH
40581: LD_VAR 0 2
40585: ARRAY
40586: PUSH
40587: LD_INT 1
40589: ARRAY
40590: PPUSH
40591: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40595: LD_VAR 0 3
40599: PPUSH
40600: CALL_OW 461
40604: PUSH
40605: LD_INT 6
40607: EQUAL
40608: PUSH
40609: LD_VAR 0 6
40613: PUSH
40614: LD_INT 1
40616: GREATER
40617: AND
40618: IFFALSE 40770
// begin sci := [ ] ;
40620: LD_ADDR_VAR 0 8
40624: PUSH
40625: EMPTY
40626: ST_TO_ADDR
// for x in ( tmp diff j ) do
40627: LD_ADDR_VAR 0 7
40631: PUSH
40632: LD_VAR 0 6
40636: PUSH
40637: LD_VAR 0 3
40641: DIFF
40642: PUSH
40643: FOR_IN
40644: IFFALSE 40696
// begin if sci = 6 then
40646: LD_VAR 0 8
40650: PUSH
40651: LD_INT 6
40653: EQUAL
40654: IFFALSE 40658
// break ;
40656: GO 40696
// if BuildingStatus ( x ) = bs_idle then
40658: LD_VAR 0 7
40662: PPUSH
40663: CALL_OW 461
40667: PUSH
40668: LD_INT 2
40670: EQUAL
40671: IFFALSE 40694
// sci := sci ^ UnitsInside ( x ) ;
40673: LD_ADDR_VAR 0 8
40677: PUSH
40678: LD_VAR 0 8
40682: PUSH
40683: LD_VAR 0 7
40687: PPUSH
40688: CALL_OW 313
40692: ADD
40693: ST_TO_ADDR
// end ;
40694: GO 40643
40696: POP
40697: POP
// if not sci then
40698: LD_VAR 0 8
40702: NOT
40703: IFFALSE 40707
// continue ;
40705: GO 39752
// for x in sci do
40707: LD_ADDR_VAR 0 7
40711: PUSH
40712: LD_VAR 0 8
40716: PUSH
40717: FOR_IN
40718: IFFALSE 40768
// if IsInUnit ( x ) and not HasTask ( x ) then
40720: LD_VAR 0 7
40724: PPUSH
40725: CALL_OW 310
40729: PUSH
40730: LD_VAR 0 7
40734: PPUSH
40735: CALL_OW 314
40739: NOT
40740: AND
40741: IFFALSE 40766
// begin ComExitBuilding ( x ) ;
40743: LD_VAR 0 7
40747: PPUSH
40748: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40752: LD_VAR 0 7
40756: PPUSH
40757: LD_VAR 0 3
40761: PPUSH
40762: CALL_OW 180
// end ;
40766: GO 40717
40768: POP
40769: POP
// end ; end ;
40770: GO 39752
40772: POP
40773: POP
// end ;
40774: GO 39706
40776: POP
40777: POP
// end ;
40778: LD_VAR 0 1
40782: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40783: LD_INT 0
40785: PPUSH
40786: PPUSH
// if not mc_bases then
40787: LD_EXP 80
40791: NOT
40792: IFFALSE 40796
// exit ;
40794: GO 40877
// for i = 1 to mc_bases do
40796: LD_ADDR_VAR 0 2
40800: PUSH
40801: DOUBLE
40802: LD_INT 1
40804: DEC
40805: ST_TO_ADDR
40806: LD_EXP 80
40810: PUSH
40811: FOR_TO
40812: IFFALSE 40875
// if mc_mines [ i ] and mc_miners [ i ] then
40814: LD_EXP 93
40818: PUSH
40819: LD_VAR 0 2
40823: ARRAY
40824: PUSH
40825: LD_EXP 94
40829: PUSH
40830: LD_VAR 0 2
40834: ARRAY
40835: AND
40836: IFFALSE 40873
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40838: LD_EXP 94
40842: PUSH
40843: LD_VAR 0 2
40847: ARRAY
40848: PUSH
40849: LD_INT 1
40851: ARRAY
40852: PPUSH
40853: CALL_OW 255
40857: PPUSH
40858: LD_EXP 93
40862: PUSH
40863: LD_VAR 0 2
40867: ARRAY
40868: PPUSH
40869: CALL 55516 0 2
40873: GO 40811
40875: POP
40876: POP
// end ;
40877: LD_VAR 0 1
40881: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40882: LD_INT 0
40884: PPUSH
40885: PPUSH
40886: PPUSH
40887: PPUSH
40888: PPUSH
40889: PPUSH
40890: PPUSH
40891: PPUSH
// if not mc_bases or not mc_parking then
40892: LD_EXP 80
40896: NOT
40897: PUSH
40898: LD_EXP 104
40902: NOT
40903: OR
40904: IFFALSE 40908
// exit ;
40906: GO 41646
// for i = 1 to mc_bases do
40908: LD_ADDR_VAR 0 2
40912: PUSH
40913: DOUBLE
40914: LD_INT 1
40916: DEC
40917: ST_TO_ADDR
40918: LD_EXP 80
40922: PUSH
40923: FOR_TO
40924: IFFALSE 41644
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40926: LD_EXP 80
40930: PUSH
40931: LD_VAR 0 2
40935: ARRAY
40936: NOT
40937: PUSH
40938: LD_EXP 104
40942: PUSH
40943: LD_VAR 0 2
40947: ARRAY
40948: NOT
40949: OR
40950: IFFALSE 40954
// continue ;
40952: GO 40923
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40954: LD_ADDR_VAR 0 5
40958: PUSH
40959: LD_EXP 80
40963: PUSH
40964: LD_VAR 0 2
40968: ARRAY
40969: PUSH
40970: LD_INT 1
40972: ARRAY
40973: PPUSH
40974: CALL_OW 255
40978: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40979: LD_ADDR_VAR 0 6
40983: PUSH
40984: LD_EXP 80
40988: PUSH
40989: LD_VAR 0 2
40993: ARRAY
40994: PPUSH
40995: LD_INT 30
40997: PUSH
40998: LD_INT 3
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PPUSH
41005: CALL_OW 72
41009: ST_TO_ADDR
// if not fac then
41010: LD_VAR 0 6
41014: NOT
41015: IFFALSE 41066
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41017: LD_ADDR_VAR 0 6
41021: PUSH
41022: LD_EXP 80
41026: PUSH
41027: LD_VAR 0 2
41031: ARRAY
41032: PPUSH
41033: LD_INT 2
41035: PUSH
41036: LD_INT 30
41038: PUSH
41039: LD_INT 0
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 30
41048: PUSH
41049: LD_INT 1
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: LIST
41060: PPUSH
41061: CALL_OW 72
41065: ST_TO_ADDR
// if not fac then
41066: LD_VAR 0 6
41070: NOT
41071: IFFALSE 41075
// continue ;
41073: GO 40923
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41075: LD_ADDR_VAR 0 7
41079: PUSH
41080: LD_EXP 104
41084: PUSH
41085: LD_VAR 0 2
41089: ARRAY
41090: PPUSH
41091: LD_INT 22
41093: PUSH
41094: LD_VAR 0 5
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 21
41105: PUSH
41106: LD_INT 2
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 3
41115: PUSH
41116: LD_INT 60
41118: PUSH
41119: EMPTY
41120: LIST
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: LD_INT 24
41131: PUSH
41132: LD_INT 1000
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: PPUSH
41149: CALL_OW 70
41153: ST_TO_ADDR
// for j in fac do
41154: LD_ADDR_VAR 0 3
41158: PUSH
41159: LD_VAR 0 6
41163: PUSH
41164: FOR_IN
41165: IFFALSE 41260
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41167: LD_ADDR_VAR 0 7
41171: PUSH
41172: LD_VAR 0 7
41176: PUSH
41177: LD_INT 22
41179: PUSH
41180: LD_VAR 0 5
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 91
41191: PUSH
41192: LD_VAR 0 3
41196: PUSH
41197: LD_INT 15
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 21
41207: PUSH
41208: LD_INT 2
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: LD_INT 60
41220: PUSH
41221: EMPTY
41222: LIST
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 3
41230: PUSH
41231: LD_INT 24
41233: PUSH
41234: LD_INT 1000
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: PPUSH
41252: CALL_OW 69
41256: UNION
41257: ST_TO_ADDR
41258: GO 41164
41260: POP
41261: POP
// if not vehs then
41262: LD_VAR 0 7
41266: NOT
41267: IFFALSE 41293
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41269: LD_ADDR_EXP 92
41273: PUSH
41274: LD_EXP 92
41278: PPUSH
41279: LD_VAR 0 2
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// continue ;
41291: GO 40923
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41293: LD_ADDR_VAR 0 8
41297: PUSH
41298: LD_EXP 80
41302: PUSH
41303: LD_VAR 0 2
41307: ARRAY
41308: PPUSH
41309: LD_INT 30
41311: PUSH
41312: LD_INT 3
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PPUSH
41319: CALL_OW 72
41323: ST_TO_ADDR
// if tmp then
41324: LD_VAR 0 8
41328: IFFALSE 41431
// begin for j in tmp do
41330: LD_ADDR_VAR 0 3
41334: PUSH
41335: LD_VAR 0 8
41339: PUSH
41340: FOR_IN
41341: IFFALSE 41429
// for k in UnitsInside ( j ) do
41343: LD_ADDR_VAR 0 4
41347: PUSH
41348: LD_VAR 0 3
41352: PPUSH
41353: CALL_OW 313
41357: PUSH
41358: FOR_IN
41359: IFFALSE 41425
// if k then
41361: LD_VAR 0 4
41365: IFFALSE 41423
// if not k in mc_repair_vehicle [ i ] then
41367: LD_VAR 0 4
41371: PUSH
41372: LD_EXP 92
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: IN
41383: NOT
41384: IFFALSE 41423
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41386: LD_ADDR_EXP 92
41390: PUSH
41391: LD_EXP 92
41395: PPUSH
41396: LD_VAR 0 2
41400: PPUSH
41401: LD_EXP 92
41405: PUSH
41406: LD_VAR 0 2
41410: ARRAY
41411: PUSH
41412: LD_VAR 0 4
41416: UNION
41417: PPUSH
41418: CALL_OW 1
41422: ST_TO_ADDR
41423: GO 41358
41425: POP
41426: POP
41427: GO 41340
41429: POP
41430: POP
// end ; if not mc_repair_vehicle [ i ] then
41431: LD_EXP 92
41435: PUSH
41436: LD_VAR 0 2
41440: ARRAY
41441: NOT
41442: IFFALSE 41446
// continue ;
41444: GO 40923
// for j in mc_repair_vehicle [ i ] do
41446: LD_ADDR_VAR 0 3
41450: PUSH
41451: LD_EXP 92
41455: PUSH
41456: LD_VAR 0 2
41460: ARRAY
41461: PUSH
41462: FOR_IN
41463: IFFALSE 41640
// begin if GetClass ( j ) <> 3 then
41465: LD_VAR 0 3
41469: PPUSH
41470: CALL_OW 257
41474: PUSH
41475: LD_INT 3
41477: NONEQUAL
41478: IFFALSE 41519
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41480: LD_ADDR_EXP 92
41484: PUSH
41485: LD_EXP 92
41489: PPUSH
41490: LD_VAR 0 2
41494: PPUSH
41495: LD_EXP 92
41499: PUSH
41500: LD_VAR 0 2
41504: ARRAY
41505: PUSH
41506: LD_VAR 0 3
41510: DIFF
41511: PPUSH
41512: CALL_OW 1
41516: ST_TO_ADDR
// continue ;
41517: GO 41462
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41519: LD_VAR 0 3
41523: PPUSH
41524: CALL_OW 311
41528: NOT
41529: PUSH
41530: LD_VAR 0 3
41534: PUSH
41535: LD_EXP 83
41539: PUSH
41540: LD_VAR 0 2
41544: ARRAY
41545: PUSH
41546: LD_INT 1
41548: ARRAY
41549: IN
41550: NOT
41551: AND
41552: PUSH
41553: LD_VAR 0 3
41557: PUSH
41558: LD_EXP 83
41562: PUSH
41563: LD_VAR 0 2
41567: ARRAY
41568: PUSH
41569: LD_INT 2
41571: ARRAY
41572: IN
41573: NOT
41574: AND
41575: IFFALSE 41638
// begin if IsInUnit ( j ) then
41577: LD_VAR 0 3
41581: PPUSH
41582: CALL_OW 310
41586: IFFALSE 41599
// ComExitBuilding ( j ) else
41588: LD_VAR 0 3
41592: PPUSH
41593: CALL_OW 122
41597: GO 41638
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41599: LD_VAR 0 3
41603: PPUSH
41604: LD_VAR 0 7
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL 93333 0 2
41617: NOT
41618: IFFALSE 41638
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41620: LD_VAR 0 3
41624: PPUSH
41625: LD_VAR 0 7
41629: PUSH
41630: LD_INT 1
41632: ARRAY
41633: PPUSH
41634: CALL_OW 129
// end ; end ;
41638: GO 41462
41640: POP
41641: POP
// end ;
41642: GO 40923
41644: POP
41645: POP
// end ;
41646: LD_VAR 0 1
41650: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41651: LD_INT 0
41653: PPUSH
41654: PPUSH
41655: PPUSH
41656: PPUSH
41657: PPUSH
41658: PPUSH
41659: PPUSH
41660: PPUSH
41661: PPUSH
41662: PPUSH
41663: PPUSH
// if not mc_bases then
41664: LD_EXP 80
41668: NOT
41669: IFFALSE 41673
// exit ;
41671: GO 42475
// for i = 1 to mc_bases do
41673: LD_ADDR_VAR 0 2
41677: PUSH
41678: DOUBLE
41679: LD_INT 1
41681: DEC
41682: ST_TO_ADDR
41683: LD_EXP 80
41687: PUSH
41688: FOR_TO
41689: IFFALSE 42473
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41691: LD_EXP 108
41695: PUSH
41696: LD_VAR 0 2
41700: ARRAY
41701: NOT
41702: PUSH
41703: LD_EXP 83
41707: PUSH
41708: LD_VAR 0 2
41712: ARRAY
41713: PUSH
41714: LD_INT 1
41716: ARRAY
41717: OR
41718: PUSH
41719: LD_EXP 83
41723: PUSH
41724: LD_VAR 0 2
41728: ARRAY
41729: PUSH
41730: LD_INT 2
41732: ARRAY
41733: OR
41734: PUSH
41735: LD_EXP 106
41739: PUSH
41740: LD_VAR 0 2
41744: ARRAY
41745: PPUSH
41746: LD_INT 1
41748: PPUSH
41749: CALL_OW 325
41753: NOT
41754: OR
41755: PUSH
41756: LD_EXP 103
41760: PUSH
41761: LD_VAR 0 2
41765: ARRAY
41766: OR
41767: IFFALSE 41771
// continue ;
41769: GO 41688
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41771: LD_ADDR_VAR 0 8
41775: PUSH
41776: LD_EXP 80
41780: PUSH
41781: LD_VAR 0 2
41785: ARRAY
41786: PPUSH
41787: LD_INT 25
41789: PUSH
41790: LD_INT 4
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 50
41799: PUSH
41800: EMPTY
41801: LIST
41802: PUSH
41803: LD_INT 3
41805: PUSH
41806: LD_INT 60
41808: PUSH
41809: EMPTY
41810: LIST
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: LIST
41820: PPUSH
41821: CALL_OW 72
41825: PUSH
41826: LD_EXP 84
41830: PUSH
41831: LD_VAR 0 2
41835: ARRAY
41836: DIFF
41837: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41838: LD_ADDR_VAR 0 9
41842: PUSH
41843: LD_EXP 80
41847: PUSH
41848: LD_VAR 0 2
41852: ARRAY
41853: PPUSH
41854: LD_INT 2
41856: PUSH
41857: LD_INT 30
41859: PUSH
41860: LD_INT 0
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 30
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: LIST
41881: PPUSH
41882: CALL_OW 72
41886: ST_TO_ADDR
// if not tmp or not dep then
41887: LD_VAR 0 8
41891: NOT
41892: PUSH
41893: LD_VAR 0 9
41897: NOT
41898: OR
41899: IFFALSE 41903
// continue ;
41901: GO 41688
// side := GetSide ( tmp [ 1 ] ) ;
41903: LD_ADDR_VAR 0 11
41907: PUSH
41908: LD_VAR 0 8
41912: PUSH
41913: LD_INT 1
41915: ARRAY
41916: PPUSH
41917: CALL_OW 255
41921: ST_TO_ADDR
// dep := dep [ 1 ] ;
41922: LD_ADDR_VAR 0 9
41926: PUSH
41927: LD_VAR 0 9
41931: PUSH
41932: LD_INT 1
41934: ARRAY
41935: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41936: LD_ADDR_VAR 0 7
41940: PUSH
41941: LD_EXP 108
41945: PUSH
41946: LD_VAR 0 2
41950: ARRAY
41951: PPUSH
41952: LD_INT 22
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 25
41964: PUSH
41965: LD_INT 12
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PPUSH
41976: CALL_OW 70
41980: PUSH
41981: LD_INT 22
41983: PUSH
41984: LD_INT 0
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 25
41993: PUSH
41994: LD_INT 12
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 91
42003: PUSH
42004: LD_VAR 0 9
42008: PUSH
42009: LD_INT 20
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: LIST
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: LIST
42021: PPUSH
42022: CALL_OW 69
42026: UNION
42027: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
42028: LD_ADDR_VAR 0 10
42032: PUSH
42033: LD_EXP 108
42037: PUSH
42038: LD_VAR 0 2
42042: ARRAY
42043: PPUSH
42044: LD_INT 81
42046: PUSH
42047: LD_VAR 0 11
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PPUSH
42056: CALL_OW 70
42060: ST_TO_ADDR
// if not apes or danger_at_area then
42061: LD_VAR 0 7
42065: NOT
42066: PUSH
42067: LD_VAR 0 10
42071: OR
42072: IFFALSE 42122
// begin if mc_taming [ i ] then
42074: LD_EXP 111
42078: PUSH
42079: LD_VAR 0 2
42083: ARRAY
42084: IFFALSE 42120
// begin MC_Reset ( i , 121 ) ;
42086: LD_VAR 0 2
42090: PPUSH
42091: LD_INT 121
42093: PPUSH
42094: CALL 27038 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42098: LD_ADDR_EXP 111
42102: PUSH
42103: LD_EXP 111
42107: PPUSH
42108: LD_VAR 0 2
42112: PPUSH
42113: EMPTY
42114: PPUSH
42115: CALL_OW 1
42119: ST_TO_ADDR
// end ; continue ;
42120: GO 41688
// end ; for j in tmp do
42122: LD_ADDR_VAR 0 3
42126: PUSH
42127: LD_VAR 0 8
42131: PUSH
42132: FOR_IN
42133: IFFALSE 42469
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42135: LD_VAR 0 3
42139: PUSH
42140: LD_EXP 111
42144: PUSH
42145: LD_VAR 0 2
42149: ARRAY
42150: IN
42151: NOT
42152: PUSH
42153: LD_EXP 111
42157: PUSH
42158: LD_VAR 0 2
42162: ARRAY
42163: PUSH
42164: LD_INT 3
42166: LESS
42167: AND
42168: IFFALSE 42226
// begin SetTag ( j , 121 ) ;
42170: LD_VAR 0 3
42174: PPUSH
42175: LD_INT 121
42177: PPUSH
42178: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42182: LD_ADDR_EXP 111
42186: PUSH
42187: LD_EXP 111
42191: PPUSH
42192: LD_VAR 0 2
42196: PUSH
42197: LD_EXP 111
42201: PUSH
42202: LD_VAR 0 2
42206: ARRAY
42207: PUSH
42208: LD_INT 1
42210: PLUS
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PPUSH
42216: LD_VAR 0 3
42220: PPUSH
42221: CALL 58539 0 3
42225: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 111
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: IFFALSE 42467
// begin if GetClass ( j ) <> 4 then
42244: LD_VAR 0 3
42248: PPUSH
42249: CALL_OW 257
42253: PUSH
42254: LD_INT 4
42256: NONEQUAL
42257: IFFALSE 42310
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42259: LD_ADDR_EXP 111
42263: PUSH
42264: LD_EXP 111
42268: PPUSH
42269: LD_VAR 0 2
42273: PPUSH
42274: LD_EXP 111
42278: PUSH
42279: LD_VAR 0 2
42283: ARRAY
42284: PUSH
42285: LD_VAR 0 3
42289: DIFF
42290: PPUSH
42291: CALL_OW 1
42295: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42296: LD_VAR 0 3
42300: PPUSH
42301: LD_INT 0
42303: PPUSH
42304: CALL_OW 109
// continue ;
42308: GO 42132
// end ; if IsInUnit ( j ) then
42310: LD_VAR 0 3
42314: PPUSH
42315: CALL_OW 310
42319: IFFALSE 42330
// ComExitBuilding ( j ) ;
42321: LD_VAR 0 3
42325: PPUSH
42326: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42330: LD_ADDR_VAR 0 6
42334: PUSH
42335: LD_VAR 0 7
42339: PPUSH
42340: LD_VAR 0 3
42344: PPUSH
42345: CALL_OW 74
42349: ST_TO_ADDR
// if not ape then
42350: LD_VAR 0 6
42354: NOT
42355: IFFALSE 42359
// break ;
42357: GO 42469
// x := GetX ( ape ) ;
42359: LD_ADDR_VAR 0 4
42363: PUSH
42364: LD_VAR 0 6
42368: PPUSH
42369: CALL_OW 250
42373: ST_TO_ADDR
// y := GetY ( ape ) ;
42374: LD_ADDR_VAR 0 5
42378: PUSH
42379: LD_VAR 0 6
42383: PPUSH
42384: CALL_OW 251
42388: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42389: LD_VAR 0 4
42393: PPUSH
42394: LD_VAR 0 5
42398: PPUSH
42399: CALL_OW 488
42403: NOT
42404: PUSH
42405: LD_VAR 0 11
42409: PPUSH
42410: LD_VAR 0 4
42414: PPUSH
42415: LD_VAR 0 5
42419: PPUSH
42420: LD_INT 20
42422: PPUSH
42423: CALL 59803 0 4
42427: PUSH
42428: LD_INT 4
42430: ARRAY
42431: OR
42432: IFFALSE 42436
// break ;
42434: GO 42469
// if not HasTask ( j ) then
42436: LD_VAR 0 3
42440: PPUSH
42441: CALL_OW 314
42445: NOT
42446: IFFALSE 42467
// ComTameXY ( j , x , y ) ;
42448: LD_VAR 0 3
42452: PPUSH
42453: LD_VAR 0 4
42457: PPUSH
42458: LD_VAR 0 5
42462: PPUSH
42463: CALL_OW 131
// end ; end ;
42467: GO 42132
42469: POP
42470: POP
// end ;
42471: GO 41688
42473: POP
42474: POP
// end ;
42475: LD_VAR 0 1
42479: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42480: LD_INT 0
42482: PPUSH
42483: PPUSH
42484: PPUSH
42485: PPUSH
42486: PPUSH
42487: PPUSH
42488: PPUSH
42489: PPUSH
// if not mc_bases then
42490: LD_EXP 80
42494: NOT
42495: IFFALSE 42499
// exit ;
42497: GO 43125
// for i = 1 to mc_bases do
42499: LD_ADDR_VAR 0 2
42503: PUSH
42504: DOUBLE
42505: LD_INT 1
42507: DEC
42508: ST_TO_ADDR
42509: LD_EXP 80
42513: PUSH
42514: FOR_TO
42515: IFFALSE 43123
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42517: LD_EXP 109
42521: PUSH
42522: LD_VAR 0 2
42526: ARRAY
42527: NOT
42528: PUSH
42529: LD_EXP 109
42533: PUSH
42534: LD_VAR 0 2
42538: ARRAY
42539: PPUSH
42540: LD_INT 25
42542: PUSH
42543: LD_INT 12
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PPUSH
42550: CALL_OW 72
42554: NOT
42555: OR
42556: IFFALSE 42560
// continue ;
42558: GO 42514
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42560: LD_ADDR_VAR 0 5
42564: PUSH
42565: LD_EXP 109
42569: PUSH
42570: LD_VAR 0 2
42574: ARRAY
42575: PUSH
42576: LD_INT 1
42578: ARRAY
42579: PPUSH
42580: CALL_OW 255
42584: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42585: LD_VAR 0 5
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: CALL_OW 325
42597: IFFALSE 42850
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42599: LD_ADDR_VAR 0 4
42603: PUSH
42604: LD_EXP 109
42608: PUSH
42609: LD_VAR 0 2
42613: ARRAY
42614: PPUSH
42615: LD_INT 25
42617: PUSH
42618: LD_INT 16
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PPUSH
42625: CALL_OW 72
42629: ST_TO_ADDR
// if tmp < 6 then
42630: LD_VAR 0 4
42634: PUSH
42635: LD_INT 6
42637: LESS
42638: IFFALSE 42850
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42640: LD_ADDR_VAR 0 6
42644: PUSH
42645: LD_EXP 80
42649: PUSH
42650: LD_VAR 0 2
42654: ARRAY
42655: PPUSH
42656: LD_INT 2
42658: PUSH
42659: LD_INT 30
42661: PUSH
42662: LD_INT 0
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 30
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: LIST
42683: PPUSH
42684: CALL_OW 72
42688: ST_TO_ADDR
// if depot then
42689: LD_VAR 0 6
42693: IFFALSE 42850
// begin selected := 0 ;
42695: LD_ADDR_VAR 0 7
42699: PUSH
42700: LD_INT 0
42702: ST_TO_ADDR
// for j in depot do
42703: LD_ADDR_VAR 0 3
42707: PUSH
42708: LD_VAR 0 6
42712: PUSH
42713: FOR_IN
42714: IFFALSE 42745
// begin if UnitsInside ( j ) < 6 then
42716: LD_VAR 0 3
42720: PPUSH
42721: CALL_OW 313
42725: PUSH
42726: LD_INT 6
42728: LESS
42729: IFFALSE 42743
// begin selected := j ;
42731: LD_ADDR_VAR 0 7
42735: PUSH
42736: LD_VAR 0 3
42740: ST_TO_ADDR
// break ;
42741: GO 42745
// end ; end ;
42743: GO 42713
42745: POP
42746: POP
// if selected then
42747: LD_VAR 0 7
42751: IFFALSE 42850
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42753: LD_ADDR_VAR 0 3
42757: PUSH
42758: LD_EXP 109
42762: PUSH
42763: LD_VAR 0 2
42767: ARRAY
42768: PPUSH
42769: LD_INT 25
42771: PUSH
42772: LD_INT 12
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PPUSH
42779: CALL_OW 72
42783: PUSH
42784: FOR_IN
42785: IFFALSE 42848
// if not HasTask ( j ) then
42787: LD_VAR 0 3
42791: PPUSH
42792: CALL_OW 314
42796: NOT
42797: IFFALSE 42846
// begin if not IsInUnit ( j ) then
42799: LD_VAR 0 3
42803: PPUSH
42804: CALL_OW 310
42808: NOT
42809: IFFALSE 42825
// ComEnterUnit ( j , selected ) ;
42811: LD_VAR 0 3
42815: PPUSH
42816: LD_VAR 0 7
42820: PPUSH
42821: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42825: LD_VAR 0 3
42829: PPUSH
42830: LD_INT 16
42832: PPUSH
42833: CALL_OW 183
// AddComExitBuilding ( j ) ;
42837: LD_VAR 0 3
42841: PPUSH
42842: CALL_OW 182
// end ;
42846: GO 42784
42848: POP
42849: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42850: LD_VAR 0 5
42854: PPUSH
42855: LD_INT 11
42857: PPUSH
42858: CALL_OW 325
42862: IFFALSE 43121
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42864: LD_ADDR_VAR 0 4
42868: PUSH
42869: LD_EXP 109
42873: PUSH
42874: LD_VAR 0 2
42878: ARRAY
42879: PPUSH
42880: LD_INT 25
42882: PUSH
42883: LD_INT 16
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PPUSH
42890: CALL_OW 72
42894: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42895: LD_VAR 0 4
42899: PUSH
42900: LD_INT 6
42902: GREATEREQUAL
42903: PUSH
42904: LD_VAR 0 5
42908: PPUSH
42909: LD_INT 2
42911: PPUSH
42912: CALL_OW 325
42916: NOT
42917: OR
42918: IFFALSE 43121
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42920: LD_ADDR_VAR 0 8
42924: PUSH
42925: LD_EXP 80
42929: PUSH
42930: LD_VAR 0 2
42934: ARRAY
42935: PPUSH
42936: LD_INT 2
42938: PUSH
42939: LD_INT 30
42941: PUSH
42942: LD_INT 4
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 30
42951: PUSH
42952: LD_INT 5
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: PPUSH
42964: CALL_OW 72
42968: ST_TO_ADDR
// if barracks then
42969: LD_VAR 0 8
42973: IFFALSE 43121
// begin selected := 0 ;
42975: LD_ADDR_VAR 0 7
42979: PUSH
42980: LD_INT 0
42982: ST_TO_ADDR
// for j in barracks do
42983: LD_ADDR_VAR 0 3
42987: PUSH
42988: LD_VAR 0 8
42992: PUSH
42993: FOR_IN
42994: IFFALSE 43025
// begin if UnitsInside ( j ) < 6 then
42996: LD_VAR 0 3
43000: PPUSH
43001: CALL_OW 313
43005: PUSH
43006: LD_INT 6
43008: LESS
43009: IFFALSE 43023
// begin selected := j ;
43011: LD_ADDR_VAR 0 7
43015: PUSH
43016: LD_VAR 0 3
43020: ST_TO_ADDR
// break ;
43021: GO 43025
// end ; end ;
43023: GO 42993
43025: POP
43026: POP
// if selected then
43027: LD_VAR 0 7
43031: IFFALSE 43121
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43033: LD_ADDR_VAR 0 3
43037: PUSH
43038: LD_EXP 109
43042: PUSH
43043: LD_VAR 0 2
43047: ARRAY
43048: PPUSH
43049: LD_INT 25
43051: PUSH
43052: LD_INT 12
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PPUSH
43059: CALL_OW 72
43063: PUSH
43064: FOR_IN
43065: IFFALSE 43119
// if not IsInUnit ( j ) and not HasTask ( j ) then
43067: LD_VAR 0 3
43071: PPUSH
43072: CALL_OW 310
43076: NOT
43077: PUSH
43078: LD_VAR 0 3
43082: PPUSH
43083: CALL_OW 314
43087: NOT
43088: AND
43089: IFFALSE 43117
// begin ComEnterUnit ( j , selected ) ;
43091: LD_VAR 0 3
43095: PPUSH
43096: LD_VAR 0 7
43100: PPUSH
43101: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43105: LD_VAR 0 3
43109: PPUSH
43110: LD_INT 15
43112: PPUSH
43113: CALL_OW 183
// end ;
43117: GO 43064
43119: POP
43120: POP
// end ; end ; end ; end ; end ;
43121: GO 42514
43123: POP
43124: POP
// end ;
43125: LD_VAR 0 1
43129: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43130: LD_INT 0
43132: PPUSH
43133: PPUSH
43134: PPUSH
43135: PPUSH
// if not mc_bases then
43136: LD_EXP 80
43140: NOT
43141: IFFALSE 43145
// exit ;
43143: GO 43323
// for i = 1 to mc_bases do
43145: LD_ADDR_VAR 0 2
43149: PUSH
43150: DOUBLE
43151: LD_INT 1
43153: DEC
43154: ST_TO_ADDR
43155: LD_EXP 80
43159: PUSH
43160: FOR_TO
43161: IFFALSE 43321
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43163: LD_ADDR_VAR 0 4
43167: PUSH
43168: LD_EXP 80
43172: PUSH
43173: LD_VAR 0 2
43177: ARRAY
43178: PPUSH
43179: LD_INT 25
43181: PUSH
43182: LD_INT 9
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PPUSH
43189: CALL_OW 72
43193: ST_TO_ADDR
// if not tmp then
43194: LD_VAR 0 4
43198: NOT
43199: IFFALSE 43203
// continue ;
43201: GO 43160
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43203: LD_EXP 106
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: PPUSH
43214: LD_INT 29
43216: PPUSH
43217: CALL_OW 325
43221: NOT
43222: PUSH
43223: LD_EXP 106
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 28
43236: PPUSH
43237: CALL_OW 325
43241: NOT
43242: AND
43243: IFFALSE 43247
// continue ;
43245: GO 43160
// for j in tmp do
43247: LD_ADDR_VAR 0 3
43251: PUSH
43252: LD_VAR 0 4
43256: PUSH
43257: FOR_IN
43258: IFFALSE 43317
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43260: LD_VAR 0 3
43264: PUSH
43265: LD_EXP 83
43269: PUSH
43270: LD_VAR 0 2
43274: ARRAY
43275: PUSH
43276: LD_INT 1
43278: ARRAY
43279: IN
43280: NOT
43281: PUSH
43282: LD_VAR 0 3
43286: PUSH
43287: LD_EXP 83
43291: PUSH
43292: LD_VAR 0 2
43296: ARRAY
43297: PUSH
43298: LD_INT 2
43300: ARRAY
43301: IN
43302: NOT
43303: AND
43304: IFFALSE 43315
// ComSpaceTimeShoot ( j ) ;
43306: LD_VAR 0 3
43310: PPUSH
43311: CALL 54524 0 1
43315: GO 43257
43317: POP
43318: POP
// end ;
43319: GO 43160
43321: POP
43322: POP
// end ;
43323: LD_VAR 0 1
43327: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43328: LD_INT 0
43330: PPUSH
43331: PPUSH
43332: PPUSH
43333: PPUSH
43334: PPUSH
43335: PPUSH
43336: PPUSH
43337: PPUSH
43338: PPUSH
// if not mc_bases then
43339: LD_EXP 80
43343: NOT
43344: IFFALSE 43348
// exit ;
43346: GO 43970
// for i = 1 to mc_bases do
43348: LD_ADDR_VAR 0 2
43352: PUSH
43353: DOUBLE
43354: LD_INT 1
43356: DEC
43357: ST_TO_ADDR
43358: LD_EXP 80
43362: PUSH
43363: FOR_TO
43364: IFFALSE 43968
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43366: LD_EXP 115
43370: PUSH
43371: LD_VAR 0 2
43375: ARRAY
43376: NOT
43377: PUSH
43378: LD_INT 38
43380: PPUSH
43381: LD_EXP 106
43385: PUSH
43386: LD_VAR 0 2
43390: ARRAY
43391: PPUSH
43392: CALL_OW 321
43396: PUSH
43397: LD_INT 2
43399: NONEQUAL
43400: OR
43401: IFFALSE 43405
// continue ;
43403: GO 43363
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43405: LD_ADDR_VAR 0 8
43409: PUSH
43410: LD_EXP 80
43414: PUSH
43415: LD_VAR 0 2
43419: ARRAY
43420: PPUSH
43421: LD_INT 30
43423: PUSH
43424: LD_INT 34
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PPUSH
43431: CALL_OW 72
43435: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43436: LD_ADDR_VAR 0 9
43440: PUSH
43441: LD_EXP 80
43445: PUSH
43446: LD_VAR 0 2
43450: ARRAY
43451: PPUSH
43452: LD_INT 25
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PPUSH
43462: CALL_OW 72
43466: PPUSH
43467: LD_INT 0
43469: PPUSH
43470: CALL 88837 0 2
43474: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43475: LD_VAR 0 9
43479: NOT
43480: PUSH
43481: LD_VAR 0 8
43485: NOT
43486: OR
43487: PUSH
43488: LD_EXP 80
43492: PUSH
43493: LD_VAR 0 2
43497: ARRAY
43498: PPUSH
43499: LD_INT 124
43501: PPUSH
43502: CALL 88837 0 2
43506: OR
43507: IFFALSE 43511
// continue ;
43509: GO 43363
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43511: LD_EXP 116
43515: PUSH
43516: LD_VAR 0 2
43520: ARRAY
43521: PUSH
43522: LD_EXP 115
43526: PUSH
43527: LD_VAR 0 2
43531: ARRAY
43532: LESS
43533: PUSH
43534: LD_EXP 116
43538: PUSH
43539: LD_VAR 0 2
43543: ARRAY
43544: PUSH
43545: LD_VAR 0 8
43549: LESS
43550: AND
43551: IFFALSE 43966
// begin tmp := sci [ 1 ] ;
43553: LD_ADDR_VAR 0 7
43557: PUSH
43558: LD_VAR 0 9
43562: PUSH
43563: LD_INT 1
43565: ARRAY
43566: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43567: LD_VAR 0 7
43571: PPUSH
43572: LD_INT 124
43574: PPUSH
43575: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43579: LD_ADDR_VAR 0 3
43583: PUSH
43584: DOUBLE
43585: LD_EXP 115
43589: PUSH
43590: LD_VAR 0 2
43594: ARRAY
43595: INC
43596: ST_TO_ADDR
43597: LD_EXP 115
43601: PUSH
43602: LD_VAR 0 2
43606: ARRAY
43607: PUSH
43608: FOR_DOWNTO
43609: IFFALSE 43952
// begin if IsInUnit ( tmp ) then
43611: LD_VAR 0 7
43615: PPUSH
43616: CALL_OW 310
43620: IFFALSE 43631
// ComExitBuilding ( tmp ) ;
43622: LD_VAR 0 7
43626: PPUSH
43627: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43631: LD_INT 35
43633: PPUSH
43634: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43638: LD_VAR 0 7
43642: PPUSH
43643: CALL_OW 310
43647: NOT
43648: PUSH
43649: LD_VAR 0 7
43653: PPUSH
43654: CALL_OW 314
43658: NOT
43659: AND
43660: IFFALSE 43631
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43662: LD_ADDR_VAR 0 6
43666: PUSH
43667: LD_VAR 0 7
43671: PPUSH
43672: CALL_OW 250
43676: PUSH
43677: LD_VAR 0 7
43681: PPUSH
43682: CALL_OW 251
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43691: LD_INT 35
43693: PPUSH
43694: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43698: LD_ADDR_VAR 0 4
43702: PUSH
43703: LD_EXP 115
43707: PUSH
43708: LD_VAR 0 2
43712: ARRAY
43713: PUSH
43714: LD_VAR 0 3
43718: ARRAY
43719: PUSH
43720: LD_INT 1
43722: ARRAY
43723: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43724: LD_ADDR_VAR 0 5
43728: PUSH
43729: LD_EXP 115
43733: PUSH
43734: LD_VAR 0 2
43738: ARRAY
43739: PUSH
43740: LD_VAR 0 3
43744: ARRAY
43745: PUSH
43746: LD_INT 2
43748: ARRAY
43749: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43750: LD_VAR 0 7
43754: PPUSH
43755: LD_INT 10
43757: PPUSH
43758: CALL 61504 0 2
43762: PUSH
43763: LD_INT 4
43765: ARRAY
43766: IFFALSE 43804
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43768: LD_VAR 0 7
43772: PPUSH
43773: LD_VAR 0 6
43777: PUSH
43778: LD_INT 1
43780: ARRAY
43781: PPUSH
43782: LD_VAR 0 6
43786: PUSH
43787: LD_INT 2
43789: ARRAY
43790: PPUSH
43791: CALL_OW 111
// wait ( 0 0$10 ) ;
43795: LD_INT 350
43797: PPUSH
43798: CALL_OW 67
// end else
43802: GO 43830
// begin ComMoveXY ( tmp , x , y ) ;
43804: LD_VAR 0 7
43808: PPUSH
43809: LD_VAR 0 4
43813: PPUSH
43814: LD_VAR 0 5
43818: PPUSH
43819: CALL_OW 111
// wait ( 0 0$3 ) ;
43823: LD_INT 105
43825: PPUSH
43826: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43830: LD_VAR 0 7
43834: PPUSH
43835: LD_VAR 0 4
43839: PPUSH
43840: LD_VAR 0 5
43844: PPUSH
43845: CALL_OW 307
43849: IFFALSE 43691
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43851: LD_VAR 0 7
43855: PPUSH
43856: LD_VAR 0 4
43860: PPUSH
43861: LD_VAR 0 5
43865: PPUSH
43866: LD_VAR 0 8
43870: PUSH
43871: LD_VAR 0 3
43875: ARRAY
43876: PPUSH
43877: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43881: LD_INT 35
43883: PPUSH
43884: CALL_OW 67
// until not HasTask ( tmp ) ;
43888: LD_VAR 0 7
43892: PPUSH
43893: CALL_OW 314
43897: NOT
43898: IFFALSE 43881
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43900: LD_ADDR_EXP 116
43904: PUSH
43905: LD_EXP 116
43909: PPUSH
43910: LD_VAR 0 2
43914: PUSH
43915: LD_EXP 116
43919: PUSH
43920: LD_VAR 0 2
43924: ARRAY
43925: PUSH
43926: LD_INT 1
43928: PLUS
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PPUSH
43934: LD_VAR 0 8
43938: PUSH
43939: LD_VAR 0 3
43943: ARRAY
43944: PPUSH
43945: CALL 58539 0 3
43949: ST_TO_ADDR
// end ;
43950: GO 43608
43952: POP
43953: POP
// MC_Reset ( i , 124 ) ;
43954: LD_VAR 0 2
43958: PPUSH
43959: LD_INT 124
43961: PPUSH
43962: CALL 27038 0 2
// end ; end ;
43966: GO 43363
43968: POP
43969: POP
// end ;
43970: LD_VAR 0 1
43974: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43975: LD_INT 0
43977: PPUSH
43978: PPUSH
43979: PPUSH
// if not mc_bases then
43980: LD_EXP 80
43984: NOT
43985: IFFALSE 43989
// exit ;
43987: GO 44595
// for i = 1 to mc_bases do
43989: LD_ADDR_VAR 0 2
43993: PUSH
43994: DOUBLE
43995: LD_INT 1
43997: DEC
43998: ST_TO_ADDR
43999: LD_EXP 80
44003: PUSH
44004: FOR_TO
44005: IFFALSE 44593
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44007: LD_ADDR_VAR 0 3
44011: PUSH
44012: LD_EXP 80
44016: PUSH
44017: LD_VAR 0 2
44021: ARRAY
44022: PPUSH
44023: LD_INT 25
44025: PUSH
44026: LD_INT 4
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PPUSH
44033: CALL_OW 72
44037: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44038: LD_VAR 0 3
44042: NOT
44043: PUSH
44044: LD_EXP 117
44048: PUSH
44049: LD_VAR 0 2
44053: ARRAY
44054: NOT
44055: OR
44056: PUSH
44057: LD_EXP 80
44061: PUSH
44062: LD_VAR 0 2
44066: ARRAY
44067: PPUSH
44068: LD_INT 2
44070: PUSH
44071: LD_INT 30
44073: PUSH
44074: LD_INT 0
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 30
44083: PUSH
44084: LD_INT 1
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: LIST
44095: PPUSH
44096: CALL_OW 72
44100: NOT
44101: OR
44102: IFFALSE 44152
// begin if mc_deposits_finder [ i ] then
44104: LD_EXP 118
44108: PUSH
44109: LD_VAR 0 2
44113: ARRAY
44114: IFFALSE 44150
// begin MC_Reset ( i , 125 ) ;
44116: LD_VAR 0 2
44120: PPUSH
44121: LD_INT 125
44123: PPUSH
44124: CALL 27038 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44128: LD_ADDR_EXP 118
44132: PUSH
44133: LD_EXP 118
44137: PPUSH
44138: LD_VAR 0 2
44142: PPUSH
44143: EMPTY
44144: PPUSH
44145: CALL_OW 1
44149: ST_TO_ADDR
// end ; continue ;
44150: GO 44004
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44152: LD_EXP 117
44156: PUSH
44157: LD_VAR 0 2
44161: ARRAY
44162: PUSH
44163: LD_INT 1
44165: ARRAY
44166: PUSH
44167: LD_INT 3
44169: ARRAY
44170: PUSH
44171: LD_INT 1
44173: EQUAL
44174: PUSH
44175: LD_INT 20
44177: PPUSH
44178: LD_EXP 106
44182: PUSH
44183: LD_VAR 0 2
44187: ARRAY
44188: PPUSH
44189: CALL_OW 321
44193: PUSH
44194: LD_INT 2
44196: NONEQUAL
44197: AND
44198: IFFALSE 44248
// begin if mc_deposits_finder [ i ] then
44200: LD_EXP 118
44204: PUSH
44205: LD_VAR 0 2
44209: ARRAY
44210: IFFALSE 44246
// begin MC_Reset ( i , 125 ) ;
44212: LD_VAR 0 2
44216: PPUSH
44217: LD_INT 125
44219: PPUSH
44220: CALL 27038 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44224: LD_ADDR_EXP 118
44228: PUSH
44229: LD_EXP 118
44233: PPUSH
44234: LD_VAR 0 2
44238: PPUSH
44239: EMPTY
44240: PPUSH
44241: CALL_OW 1
44245: ST_TO_ADDR
// end ; continue ;
44246: GO 44004
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
44248: LD_EXP 117
44252: PUSH
44253: LD_VAR 0 2
44257: ARRAY
44258: PUSH
44259: LD_INT 1
44261: ARRAY
44262: PUSH
44263: LD_INT 1
44265: ARRAY
44266: PPUSH
44267: LD_EXP 117
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: PUSH
44278: LD_INT 1
44280: ARRAY
44281: PUSH
44282: LD_INT 2
44284: ARRAY
44285: PPUSH
44286: LD_EXP 106
44290: PUSH
44291: LD_VAR 0 2
44295: ARRAY
44296: PPUSH
44297: CALL_OW 440
44301: IFFALSE 44344
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44303: LD_ADDR_EXP 117
44307: PUSH
44308: LD_EXP 117
44312: PPUSH
44313: LD_VAR 0 2
44317: PPUSH
44318: LD_EXP 117
44322: PUSH
44323: LD_VAR 0 2
44327: ARRAY
44328: PPUSH
44329: LD_INT 1
44331: PPUSH
44332: CALL_OW 3
44336: PPUSH
44337: CALL_OW 1
44341: ST_TO_ADDR
44342: GO 44591
// begin if not mc_deposits_finder [ i ] then
44344: LD_EXP 118
44348: PUSH
44349: LD_VAR 0 2
44353: ARRAY
44354: NOT
44355: IFFALSE 44407
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44357: LD_ADDR_EXP 118
44361: PUSH
44362: LD_EXP 118
44366: PPUSH
44367: LD_VAR 0 2
44371: PPUSH
44372: LD_VAR 0 3
44376: PUSH
44377: LD_INT 1
44379: ARRAY
44380: PUSH
44381: EMPTY
44382: LIST
44383: PPUSH
44384: CALL_OW 1
44388: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44389: LD_VAR 0 3
44393: PUSH
44394: LD_INT 1
44396: ARRAY
44397: PPUSH
44398: LD_INT 125
44400: PPUSH
44401: CALL_OW 109
// end else
44405: GO 44591
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44407: LD_EXP 118
44411: PUSH
44412: LD_VAR 0 2
44416: ARRAY
44417: PUSH
44418: LD_INT 1
44420: ARRAY
44421: PPUSH
44422: CALL_OW 310
44426: IFFALSE 44449
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44428: LD_EXP 118
44432: PUSH
44433: LD_VAR 0 2
44437: ARRAY
44438: PUSH
44439: LD_INT 1
44441: ARRAY
44442: PPUSH
44443: CALL_OW 122
44447: GO 44591
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44449: LD_EXP 118
44453: PUSH
44454: LD_VAR 0 2
44458: ARRAY
44459: PUSH
44460: LD_INT 1
44462: ARRAY
44463: PPUSH
44464: CALL_OW 314
44468: NOT
44469: PUSH
44470: LD_EXP 118
44474: PUSH
44475: LD_VAR 0 2
44479: ARRAY
44480: PUSH
44481: LD_INT 1
44483: ARRAY
44484: PPUSH
44485: LD_EXP 117
44489: PUSH
44490: LD_VAR 0 2
44494: ARRAY
44495: PUSH
44496: LD_INT 1
44498: ARRAY
44499: PUSH
44500: LD_INT 1
44502: ARRAY
44503: PPUSH
44504: LD_EXP 117
44508: PUSH
44509: LD_VAR 0 2
44513: ARRAY
44514: PUSH
44515: LD_INT 1
44517: ARRAY
44518: PUSH
44519: LD_INT 2
44521: ARRAY
44522: PPUSH
44523: CALL_OW 297
44527: PUSH
44528: LD_INT 6
44530: GREATER
44531: AND
44532: IFFALSE 44591
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44534: LD_EXP 118
44538: PUSH
44539: LD_VAR 0 2
44543: ARRAY
44544: PUSH
44545: LD_INT 1
44547: ARRAY
44548: PPUSH
44549: LD_EXP 117
44553: PUSH
44554: LD_VAR 0 2
44558: ARRAY
44559: PUSH
44560: LD_INT 1
44562: ARRAY
44563: PUSH
44564: LD_INT 1
44566: ARRAY
44567: PPUSH
44568: LD_EXP 117
44572: PUSH
44573: LD_VAR 0 2
44577: ARRAY
44578: PUSH
44579: LD_INT 1
44581: ARRAY
44582: PUSH
44583: LD_INT 2
44585: ARRAY
44586: PPUSH
44587: CALL_OW 111
// end ; end ; end ;
44591: GO 44004
44593: POP
44594: POP
// end ;
44595: LD_VAR 0 1
44599: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44600: LD_INT 0
44602: PPUSH
44603: PPUSH
44604: PPUSH
44605: PPUSH
44606: PPUSH
44607: PPUSH
44608: PPUSH
44609: PPUSH
44610: PPUSH
44611: PPUSH
44612: PPUSH
// if not mc_bases then
44613: LD_EXP 80
44617: NOT
44618: IFFALSE 44622
// exit ;
44620: GO 45562
// for i = 1 to mc_bases do
44622: LD_ADDR_VAR 0 2
44626: PUSH
44627: DOUBLE
44628: LD_INT 1
44630: DEC
44631: ST_TO_ADDR
44632: LD_EXP 80
44636: PUSH
44637: FOR_TO
44638: IFFALSE 45560
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44640: LD_EXP 80
44644: PUSH
44645: LD_VAR 0 2
44649: ARRAY
44650: NOT
44651: PUSH
44652: LD_EXP 103
44656: PUSH
44657: LD_VAR 0 2
44661: ARRAY
44662: OR
44663: IFFALSE 44667
// continue ;
44665: GO 44637
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44667: LD_ADDR_VAR 0 7
44671: PUSH
44672: LD_EXP 80
44676: PUSH
44677: LD_VAR 0 2
44681: ARRAY
44682: PUSH
44683: LD_INT 1
44685: ARRAY
44686: PPUSH
44687: CALL_OW 248
44691: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44692: LD_VAR 0 7
44696: PUSH
44697: LD_INT 3
44699: EQUAL
44700: PUSH
44701: LD_EXP 99
44705: PUSH
44706: LD_VAR 0 2
44710: ARRAY
44711: PUSH
44712: LD_EXP 102
44716: PUSH
44717: LD_VAR 0 2
44721: ARRAY
44722: UNION
44723: PPUSH
44724: LD_INT 33
44726: PUSH
44727: LD_INT 2
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PPUSH
44734: CALL_OW 72
44738: NOT
44739: OR
44740: IFFALSE 44744
// continue ;
44742: GO 44637
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44744: LD_ADDR_VAR 0 9
44748: PUSH
44749: LD_EXP 80
44753: PUSH
44754: LD_VAR 0 2
44758: ARRAY
44759: PPUSH
44760: LD_INT 30
44762: PUSH
44763: LD_INT 36
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PPUSH
44770: CALL_OW 72
44774: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44775: LD_ADDR_VAR 0 10
44779: PUSH
44780: LD_EXP 99
44784: PUSH
44785: LD_VAR 0 2
44789: ARRAY
44790: PPUSH
44791: LD_INT 34
44793: PUSH
44794: LD_INT 31
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PPUSH
44801: CALL_OW 72
44805: ST_TO_ADDR
// if not cts and not mcts then
44806: LD_VAR 0 9
44810: NOT
44811: PUSH
44812: LD_VAR 0 10
44816: NOT
44817: AND
44818: IFFALSE 44822
// continue ;
44820: GO 44637
// x := cts ;
44822: LD_ADDR_VAR 0 11
44826: PUSH
44827: LD_VAR 0 9
44831: ST_TO_ADDR
// if not x then
44832: LD_VAR 0 11
44836: NOT
44837: IFFALSE 44849
// x := mcts ;
44839: LD_ADDR_VAR 0 11
44843: PUSH
44844: LD_VAR 0 10
44848: ST_TO_ADDR
// if not x then
44849: LD_VAR 0 11
44853: NOT
44854: IFFALSE 44858
// continue ;
44856: GO 44637
// if mc_remote_driver [ i ] then
44858: LD_EXP 120
44862: PUSH
44863: LD_VAR 0 2
44867: ARRAY
44868: IFFALSE 45255
// for j in mc_remote_driver [ i ] do
44870: LD_ADDR_VAR 0 3
44874: PUSH
44875: LD_EXP 120
44879: PUSH
44880: LD_VAR 0 2
44884: ARRAY
44885: PUSH
44886: FOR_IN
44887: IFFALSE 45253
// begin if GetClass ( j ) <> 3 then
44889: LD_VAR 0 3
44893: PPUSH
44894: CALL_OW 257
44898: PUSH
44899: LD_INT 3
44901: NONEQUAL
44902: IFFALSE 44955
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44904: LD_ADDR_EXP 120
44908: PUSH
44909: LD_EXP 120
44913: PPUSH
44914: LD_VAR 0 2
44918: PPUSH
44919: LD_EXP 120
44923: PUSH
44924: LD_VAR 0 2
44928: ARRAY
44929: PUSH
44930: LD_VAR 0 3
44934: DIFF
44935: PPUSH
44936: CALL_OW 1
44940: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44941: LD_VAR 0 3
44945: PPUSH
44946: LD_INT 0
44948: PPUSH
44949: CALL_OW 109
// continue ;
44953: GO 44886
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44955: LD_EXP 99
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PPUSH
44966: LD_INT 34
44968: PUSH
44969: LD_INT 31
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 58
44978: PUSH
44979: EMPTY
44980: LIST
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PPUSH
44986: CALL_OW 72
44990: PUSH
44991: LD_VAR 0 3
44995: PPUSH
44996: CALL 88872 0 1
45000: NOT
45001: AND
45002: IFFALSE 45073
// begin if IsInUnit ( j ) then
45004: LD_VAR 0 3
45008: PPUSH
45009: CALL_OW 310
45013: IFFALSE 45024
// ComExitBuilding ( j ) ;
45015: LD_VAR 0 3
45019: PPUSH
45020: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
45024: LD_VAR 0 3
45028: PPUSH
45029: LD_EXP 99
45033: PUSH
45034: LD_VAR 0 2
45038: ARRAY
45039: PPUSH
45040: LD_INT 34
45042: PUSH
45043: LD_INT 31
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 58
45052: PUSH
45053: EMPTY
45054: LIST
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PPUSH
45060: CALL_OW 72
45064: PUSH
45065: LD_INT 1
45067: ARRAY
45068: PPUSH
45069: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45073: LD_VAR 0 3
45077: PPUSH
45078: CALL_OW 310
45082: NOT
45083: PUSH
45084: LD_VAR 0 3
45088: PPUSH
45089: CALL_OW 310
45093: PPUSH
45094: CALL_OW 266
45098: PUSH
45099: LD_INT 36
45101: NONEQUAL
45102: PUSH
45103: LD_VAR 0 3
45107: PPUSH
45108: CALL 88872 0 1
45112: NOT
45113: AND
45114: OR
45115: IFFALSE 45251
// begin if IsInUnit ( j ) then
45117: LD_VAR 0 3
45121: PPUSH
45122: CALL_OW 310
45126: IFFALSE 45137
// ComExitBuilding ( j ) ;
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 122
// ct := 0 ;
45137: LD_ADDR_VAR 0 8
45141: PUSH
45142: LD_INT 0
45144: ST_TO_ADDR
// for k in x do
45145: LD_ADDR_VAR 0 4
45149: PUSH
45150: LD_VAR 0 11
45154: PUSH
45155: FOR_IN
45156: IFFALSE 45229
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45158: LD_VAR 0 4
45162: PPUSH
45163: CALL_OW 264
45167: PUSH
45168: LD_INT 31
45170: EQUAL
45171: PUSH
45172: LD_VAR 0 4
45176: PPUSH
45177: CALL_OW 311
45181: NOT
45182: AND
45183: PUSH
45184: LD_VAR 0 4
45188: PPUSH
45189: CALL_OW 266
45193: PUSH
45194: LD_INT 36
45196: EQUAL
45197: PUSH
45198: LD_VAR 0 4
45202: PPUSH
45203: CALL_OW 313
45207: PUSH
45208: LD_INT 3
45210: LESS
45211: AND
45212: OR
45213: IFFALSE 45227
// begin ct := k ;
45215: LD_ADDR_VAR 0 8
45219: PUSH
45220: LD_VAR 0 4
45224: ST_TO_ADDR
// break ;
45225: GO 45229
// end ;
45227: GO 45155
45229: POP
45230: POP
// if ct then
45231: LD_VAR 0 8
45235: IFFALSE 45251
// ComEnterUnit ( j , ct ) ;
45237: LD_VAR 0 3
45241: PPUSH
45242: LD_VAR 0 8
45246: PPUSH
45247: CALL_OW 120
// end ; end ;
45251: GO 44886
45253: POP
45254: POP
// places := 0 ;
45255: LD_ADDR_VAR 0 5
45259: PUSH
45260: LD_INT 0
45262: ST_TO_ADDR
// for j = 1 to x do
45263: LD_ADDR_VAR 0 3
45267: PUSH
45268: DOUBLE
45269: LD_INT 1
45271: DEC
45272: ST_TO_ADDR
45273: LD_VAR 0 11
45277: PUSH
45278: FOR_TO
45279: IFFALSE 45355
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45281: LD_VAR 0 11
45285: PUSH
45286: LD_VAR 0 3
45290: ARRAY
45291: PPUSH
45292: CALL_OW 264
45296: PUSH
45297: LD_INT 31
45299: EQUAL
45300: IFFALSE 45318
// places := places + 1 else
45302: LD_ADDR_VAR 0 5
45306: PUSH
45307: LD_VAR 0 5
45311: PUSH
45312: LD_INT 1
45314: PLUS
45315: ST_TO_ADDR
45316: GO 45353
// if GetBType ( x [ j ] ) = b_control_tower then
45318: LD_VAR 0 11
45322: PUSH
45323: LD_VAR 0 3
45327: ARRAY
45328: PPUSH
45329: CALL_OW 266
45333: PUSH
45334: LD_INT 36
45336: EQUAL
45337: IFFALSE 45353
// places := places + 3 ;
45339: LD_ADDR_VAR 0 5
45343: PUSH
45344: LD_VAR 0 5
45348: PUSH
45349: LD_INT 3
45351: PLUS
45352: ST_TO_ADDR
45353: GO 45278
45355: POP
45356: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45357: LD_VAR 0 5
45361: PUSH
45362: LD_INT 0
45364: EQUAL
45365: PUSH
45366: LD_VAR 0 5
45370: PUSH
45371: LD_EXP 120
45375: PUSH
45376: LD_VAR 0 2
45380: ARRAY
45381: LESSEQUAL
45382: OR
45383: IFFALSE 45387
// continue ;
45385: GO 44637
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45387: LD_ADDR_VAR 0 6
45391: PUSH
45392: LD_EXP 80
45396: PUSH
45397: LD_VAR 0 2
45401: ARRAY
45402: PPUSH
45403: LD_INT 25
45405: PUSH
45406: LD_INT 3
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PPUSH
45413: CALL_OW 72
45417: PUSH
45418: LD_EXP 120
45422: PUSH
45423: LD_VAR 0 2
45427: ARRAY
45428: DIFF
45429: PPUSH
45430: LD_INT 3
45432: PPUSH
45433: CALL 89772 0 2
45437: ST_TO_ADDR
// for j in tmp do
45438: LD_ADDR_VAR 0 3
45442: PUSH
45443: LD_VAR 0 6
45447: PUSH
45448: FOR_IN
45449: IFFALSE 45484
// if GetTag ( j ) > 0 then
45451: LD_VAR 0 3
45455: PPUSH
45456: CALL_OW 110
45460: PUSH
45461: LD_INT 0
45463: GREATER
45464: IFFALSE 45482
// tmp := tmp diff j ;
45466: LD_ADDR_VAR 0 6
45470: PUSH
45471: LD_VAR 0 6
45475: PUSH
45476: LD_VAR 0 3
45480: DIFF
45481: ST_TO_ADDR
45482: GO 45448
45484: POP
45485: POP
// if not tmp then
45486: LD_VAR 0 6
45490: NOT
45491: IFFALSE 45495
// continue ;
45493: GO 44637
// if places then
45495: LD_VAR 0 5
45499: IFFALSE 45558
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45501: LD_ADDR_EXP 120
45505: PUSH
45506: LD_EXP 120
45510: PPUSH
45511: LD_VAR 0 2
45515: PPUSH
45516: LD_EXP 120
45520: PUSH
45521: LD_VAR 0 2
45525: ARRAY
45526: PUSH
45527: LD_VAR 0 6
45531: PUSH
45532: LD_INT 1
45534: ARRAY
45535: UNION
45536: PPUSH
45537: CALL_OW 1
45541: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45542: LD_VAR 0 6
45546: PUSH
45547: LD_INT 1
45549: ARRAY
45550: PPUSH
45551: LD_INT 126
45553: PPUSH
45554: CALL_OW 109
// end ; end ;
45558: GO 44637
45560: POP
45561: POP
// end ;
45562: LD_VAR 0 1
45566: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45567: LD_INT 0
45569: PPUSH
45570: PPUSH
45571: PPUSH
45572: PPUSH
45573: PPUSH
45574: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45575: LD_VAR 0 1
45579: NOT
45580: PUSH
45581: LD_VAR 0 2
45585: NOT
45586: OR
45587: PUSH
45588: LD_VAR 0 3
45592: NOT
45593: OR
45594: PUSH
45595: LD_VAR 0 4
45599: PUSH
45600: LD_INT 1
45602: PUSH
45603: LD_INT 2
45605: PUSH
45606: LD_INT 3
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: LD_INT 5
45614: PUSH
45615: LD_INT 8
45617: PUSH
45618: LD_INT 9
45620: PUSH
45621: LD_INT 15
45623: PUSH
45624: LD_INT 16
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: IN
45638: NOT
45639: OR
45640: IFFALSE 45644
// exit ;
45642: GO 46502
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45644: LD_ADDR_VAR 0 2
45648: PUSH
45649: LD_VAR 0 2
45653: PPUSH
45654: LD_INT 21
45656: PUSH
45657: LD_INT 3
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: LD_INT 24
45666: PUSH
45667: LD_INT 250
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PPUSH
45678: CALL_OW 72
45682: ST_TO_ADDR
// case class of 1 , 15 :
45683: LD_VAR 0 4
45687: PUSH
45688: LD_INT 1
45690: DOUBLE
45691: EQUAL
45692: IFTRUE 45702
45694: LD_INT 15
45696: DOUBLE
45697: EQUAL
45698: IFTRUE 45702
45700: GO 45787
45702: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45703: LD_ADDR_VAR 0 8
45707: PUSH
45708: LD_VAR 0 2
45712: PPUSH
45713: LD_INT 2
45715: PUSH
45716: LD_INT 30
45718: PUSH
45719: LD_INT 32
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 30
45728: PUSH
45729: LD_INT 31
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: PPUSH
45741: CALL_OW 72
45745: PUSH
45746: LD_VAR 0 2
45750: PPUSH
45751: LD_INT 2
45753: PUSH
45754: LD_INT 30
45756: PUSH
45757: LD_INT 4
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: PUSH
45764: LD_INT 30
45766: PUSH
45767: LD_INT 5
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: LIST
45778: PPUSH
45779: CALL_OW 72
45783: ADD
45784: ST_TO_ADDR
45785: GO 46033
45787: LD_INT 2
45789: DOUBLE
45790: EQUAL
45791: IFTRUE 45801
45793: LD_INT 16
45795: DOUBLE
45796: EQUAL
45797: IFTRUE 45801
45799: GO 45847
45801: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45802: LD_ADDR_VAR 0 8
45806: PUSH
45807: LD_VAR 0 2
45811: PPUSH
45812: LD_INT 2
45814: PUSH
45815: LD_INT 30
45817: PUSH
45818: LD_INT 0
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PUSH
45825: LD_INT 30
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: LIST
45839: PPUSH
45840: CALL_OW 72
45844: ST_TO_ADDR
45845: GO 46033
45847: LD_INT 3
45849: DOUBLE
45850: EQUAL
45851: IFTRUE 45855
45853: GO 45901
45855: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45856: LD_ADDR_VAR 0 8
45860: PUSH
45861: LD_VAR 0 2
45865: PPUSH
45866: LD_INT 2
45868: PUSH
45869: LD_INT 30
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 30
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: PPUSH
45894: CALL_OW 72
45898: ST_TO_ADDR
45899: GO 46033
45901: LD_INT 4
45903: DOUBLE
45904: EQUAL
45905: IFTRUE 45909
45907: GO 45966
45909: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45910: LD_ADDR_VAR 0 8
45914: PUSH
45915: LD_VAR 0 2
45919: PPUSH
45920: LD_INT 2
45922: PUSH
45923: LD_INT 30
45925: PUSH
45926: LD_INT 6
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 30
45935: PUSH
45936: LD_INT 7
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 30
45945: PUSH
45946: LD_INT 8
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: PPUSH
45959: CALL_OW 72
45963: ST_TO_ADDR
45964: GO 46033
45966: LD_INT 5
45968: DOUBLE
45969: EQUAL
45970: IFTRUE 45986
45972: LD_INT 8
45974: DOUBLE
45975: EQUAL
45976: IFTRUE 45986
45978: LD_INT 9
45980: DOUBLE
45981: EQUAL
45982: IFTRUE 45986
45984: GO 46032
45986: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45987: LD_ADDR_VAR 0 8
45991: PUSH
45992: LD_VAR 0 2
45996: PPUSH
45997: LD_INT 2
45999: PUSH
46000: LD_INT 30
46002: PUSH
46003: LD_INT 4
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: PUSH
46010: LD_INT 30
46012: PUSH
46013: LD_INT 5
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: PPUSH
46025: CALL_OW 72
46029: ST_TO_ADDR
46030: GO 46033
46032: POP
// if not tmp then
46033: LD_VAR 0 8
46037: NOT
46038: IFFALSE 46042
// exit ;
46040: GO 46502
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46042: LD_VAR 0 4
46046: PUSH
46047: LD_INT 1
46049: PUSH
46050: LD_INT 15
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: IN
46057: PUSH
46058: LD_EXP 89
46062: PUSH
46063: LD_VAR 0 1
46067: ARRAY
46068: AND
46069: IFFALSE 46225
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46071: LD_ADDR_VAR 0 9
46075: PUSH
46076: LD_EXP 89
46080: PUSH
46081: LD_VAR 0 1
46085: ARRAY
46086: PUSH
46087: LD_INT 1
46089: ARRAY
46090: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46091: LD_VAR 0 9
46095: PUSH
46096: LD_EXP 90
46100: PUSH
46101: LD_VAR 0 1
46105: ARRAY
46106: IN
46107: NOT
46108: IFFALSE 46223
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46110: LD_ADDR_EXP 90
46114: PUSH
46115: LD_EXP 90
46119: PPUSH
46120: LD_VAR 0 1
46124: PUSH
46125: LD_EXP 90
46129: PUSH
46130: LD_VAR 0 1
46134: ARRAY
46135: PUSH
46136: LD_INT 1
46138: PLUS
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PPUSH
46144: LD_VAR 0 9
46148: PPUSH
46149: CALL 58539 0 3
46153: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46154: LD_ADDR_EXP 89
46158: PUSH
46159: LD_EXP 89
46163: PPUSH
46164: LD_VAR 0 1
46168: PPUSH
46169: LD_EXP 89
46173: PUSH
46174: LD_VAR 0 1
46178: ARRAY
46179: PUSH
46180: LD_VAR 0 9
46184: DIFF
46185: PPUSH
46186: CALL_OW 1
46190: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46191: LD_VAR 0 3
46195: PPUSH
46196: LD_EXP 90
46200: PUSH
46201: LD_VAR 0 1
46205: ARRAY
46206: PUSH
46207: LD_EXP 90
46211: PUSH
46212: LD_VAR 0 1
46216: ARRAY
46217: ARRAY
46218: PPUSH
46219: CALL_OW 120
// end ; exit ;
46223: GO 46502
// end ; if tmp > 1 then
46225: LD_VAR 0 8
46229: PUSH
46230: LD_INT 1
46232: GREATER
46233: IFFALSE 46337
// for i = 2 to tmp do
46235: LD_ADDR_VAR 0 6
46239: PUSH
46240: DOUBLE
46241: LD_INT 2
46243: DEC
46244: ST_TO_ADDR
46245: LD_VAR 0 8
46249: PUSH
46250: FOR_TO
46251: IFFALSE 46335
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46253: LD_VAR 0 8
46257: PUSH
46258: LD_VAR 0 6
46262: ARRAY
46263: PPUSH
46264: CALL_OW 461
46268: PUSH
46269: LD_INT 6
46271: EQUAL
46272: IFFALSE 46333
// begin x := tmp [ i ] ;
46274: LD_ADDR_VAR 0 9
46278: PUSH
46279: LD_VAR 0 8
46283: PUSH
46284: LD_VAR 0 6
46288: ARRAY
46289: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
46290: LD_ADDR_VAR 0 8
46294: PUSH
46295: LD_VAR 0 8
46299: PPUSH
46300: LD_VAR 0 6
46304: PPUSH
46305: CALL_OW 3
46309: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
46310: LD_ADDR_VAR 0 8
46314: PUSH
46315: LD_VAR 0 8
46319: PPUSH
46320: LD_INT 1
46322: PPUSH
46323: LD_VAR 0 9
46327: PPUSH
46328: CALL_OW 2
46332: ST_TO_ADDR
// end ;
46333: GO 46250
46335: POP
46336: POP
// for i in tmp do
46337: LD_ADDR_VAR 0 6
46341: PUSH
46342: LD_VAR 0 8
46346: PUSH
46347: FOR_IN
46348: IFFALSE 46375
// begin if IsNotFull ( i ) then
46350: LD_VAR 0 6
46354: PPUSH
46355: CALL 55761 0 1
46359: IFFALSE 46373
// begin j := i ;
46361: LD_ADDR_VAR 0 7
46365: PUSH
46366: LD_VAR 0 6
46370: ST_TO_ADDR
// break ;
46371: GO 46375
// end ; end ;
46373: GO 46347
46375: POP
46376: POP
// if j then
46377: LD_VAR 0 7
46381: IFFALSE 46399
// ComEnterUnit ( unit , j ) else
46383: LD_VAR 0 3
46387: PPUSH
46388: LD_VAR 0 7
46392: PPUSH
46393: CALL_OW 120
46397: GO 46502
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46399: LD_ADDR_VAR 0 10
46403: PUSH
46404: LD_VAR 0 2
46408: PPUSH
46409: LD_INT 2
46411: PUSH
46412: LD_INT 30
46414: PUSH
46415: LD_INT 0
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 30
46424: PUSH
46425: LD_INT 1
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: LIST
46436: PPUSH
46437: CALL_OW 72
46441: ST_TO_ADDR
// if depot then
46442: LD_VAR 0 10
46446: IFFALSE 46502
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46448: LD_ADDR_VAR 0 10
46452: PUSH
46453: LD_VAR 0 10
46457: PPUSH
46458: LD_VAR 0 3
46462: PPUSH
46463: CALL_OW 74
46467: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46468: LD_VAR 0 3
46472: PPUSH
46473: LD_VAR 0 10
46477: PPUSH
46478: CALL_OW 296
46482: PUSH
46483: LD_INT 10
46485: GREATER
46486: IFFALSE 46502
// ComStandNearbyBuilding ( unit , depot ) ;
46488: LD_VAR 0 3
46492: PPUSH
46493: LD_VAR 0 10
46497: PPUSH
46498: CALL 55141 0 2
// end ; end ; end ;
46502: LD_VAR 0 5
46506: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46507: LD_INT 0
46509: PPUSH
46510: PPUSH
46511: PPUSH
46512: PPUSH
// if not mc_bases then
46513: LD_EXP 80
46517: NOT
46518: IFFALSE 46522
// exit ;
46520: GO 46761
// for i = 1 to mc_bases do
46522: LD_ADDR_VAR 0 2
46526: PUSH
46527: DOUBLE
46528: LD_INT 1
46530: DEC
46531: ST_TO_ADDR
46532: LD_EXP 80
46536: PUSH
46537: FOR_TO
46538: IFFALSE 46759
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46540: LD_ADDR_VAR 0 4
46544: PUSH
46545: LD_EXP 80
46549: PUSH
46550: LD_VAR 0 2
46554: ARRAY
46555: PPUSH
46556: LD_INT 21
46558: PUSH
46559: LD_INT 1
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PPUSH
46566: CALL_OW 72
46570: PUSH
46571: LD_EXP 109
46575: PUSH
46576: LD_VAR 0 2
46580: ARRAY
46581: UNION
46582: ST_TO_ADDR
// if not tmp then
46583: LD_VAR 0 4
46587: NOT
46588: IFFALSE 46592
// continue ;
46590: GO 46537
// for j in tmp do
46592: LD_ADDR_VAR 0 3
46596: PUSH
46597: LD_VAR 0 4
46601: PUSH
46602: FOR_IN
46603: IFFALSE 46755
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46605: LD_VAR 0 3
46609: PPUSH
46610: CALL_OW 110
46614: NOT
46615: PUSH
46616: LD_VAR 0 3
46620: PPUSH
46621: CALL_OW 314
46625: NOT
46626: AND
46627: PUSH
46628: LD_VAR 0 3
46632: PPUSH
46633: CALL_OW 311
46637: NOT
46638: AND
46639: PUSH
46640: LD_VAR 0 3
46644: PPUSH
46645: CALL_OW 310
46649: NOT
46650: AND
46651: PUSH
46652: LD_VAR 0 3
46656: PUSH
46657: LD_EXP 83
46661: PUSH
46662: LD_VAR 0 2
46666: ARRAY
46667: PUSH
46668: LD_INT 1
46670: ARRAY
46671: IN
46672: NOT
46673: AND
46674: PUSH
46675: LD_VAR 0 3
46679: PUSH
46680: LD_EXP 83
46684: PUSH
46685: LD_VAR 0 2
46689: ARRAY
46690: PUSH
46691: LD_INT 2
46693: ARRAY
46694: IN
46695: NOT
46696: AND
46697: PUSH
46698: LD_VAR 0 3
46702: PUSH
46703: LD_EXP 92
46707: PUSH
46708: LD_VAR 0 2
46712: ARRAY
46713: IN
46714: NOT
46715: AND
46716: IFFALSE 46753
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46718: LD_VAR 0 2
46722: PPUSH
46723: LD_EXP 80
46727: PUSH
46728: LD_VAR 0 2
46732: ARRAY
46733: PPUSH
46734: LD_VAR 0 3
46738: PPUSH
46739: LD_VAR 0 3
46743: PPUSH
46744: CALL_OW 257
46748: PPUSH
46749: CALL 45567 0 4
// end ;
46753: GO 46602
46755: POP
46756: POP
// end ;
46757: GO 46537
46759: POP
46760: POP
// end ;
46761: LD_VAR 0 1
46765: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46766: LD_INT 0
46768: PPUSH
46769: PPUSH
46770: PPUSH
46771: PPUSH
46772: PPUSH
46773: PPUSH
// if not mc_bases [ base ] then
46774: LD_EXP 80
46778: PUSH
46779: LD_VAR 0 1
46783: ARRAY
46784: NOT
46785: IFFALSE 46789
// exit ;
46787: GO 46990
// tmp := [ ] ;
46789: LD_ADDR_VAR 0 6
46793: PUSH
46794: EMPTY
46795: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46796: LD_ADDR_VAR 0 7
46800: PUSH
46801: LD_VAR 0 3
46805: PPUSH
46806: LD_INT 0
46808: PPUSH
46809: CALL_OW 517
46813: ST_TO_ADDR
// if not list then
46814: LD_VAR 0 7
46818: NOT
46819: IFFALSE 46823
// exit ;
46821: GO 46990
// c := Count ( list [ 1 ] ) ;
46823: LD_ADDR_VAR 0 9
46827: PUSH
46828: LD_VAR 0 7
46832: PUSH
46833: LD_INT 1
46835: ARRAY
46836: PPUSH
46837: CALL 55679 0 1
46841: ST_TO_ADDR
// if amount > c then
46842: LD_VAR 0 2
46846: PUSH
46847: LD_VAR 0 9
46851: GREATER
46852: IFFALSE 46864
// amount := c ;
46854: LD_ADDR_VAR 0 2
46858: PUSH
46859: LD_VAR 0 9
46863: ST_TO_ADDR
// for i := 1 to amount do
46864: LD_ADDR_VAR 0 5
46868: PUSH
46869: DOUBLE
46870: LD_INT 1
46872: DEC
46873: ST_TO_ADDR
46874: LD_VAR 0 2
46878: PUSH
46879: FOR_TO
46880: IFFALSE 46938
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46882: LD_ADDR_VAR 0 6
46886: PUSH
46887: LD_VAR 0 6
46891: PPUSH
46892: LD_VAR 0 5
46896: PPUSH
46897: LD_VAR 0 7
46901: PUSH
46902: LD_INT 1
46904: ARRAY
46905: PUSH
46906: LD_VAR 0 5
46910: ARRAY
46911: PUSH
46912: LD_VAR 0 7
46916: PUSH
46917: LD_INT 2
46919: ARRAY
46920: PUSH
46921: LD_VAR 0 5
46925: ARRAY
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PPUSH
46931: CALL_OW 1
46935: ST_TO_ADDR
46936: GO 46879
46938: POP
46939: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46940: LD_ADDR_EXP 93
46944: PUSH
46945: LD_EXP 93
46949: PPUSH
46950: LD_VAR 0 1
46954: PPUSH
46955: LD_VAR 0 6
46959: PPUSH
46960: CALL_OW 1
46964: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46965: LD_ADDR_EXP 95
46969: PUSH
46970: LD_EXP 95
46974: PPUSH
46975: LD_VAR 0 1
46979: PPUSH
46980: LD_VAR 0 3
46984: PPUSH
46985: CALL_OW 1
46989: ST_TO_ADDR
// end ;
46990: LD_VAR 0 4
46994: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46995: LD_INT 0
46997: PPUSH
// if not mc_bases [ base ] then
46998: LD_EXP 80
47002: PUSH
47003: LD_VAR 0 1
47007: ARRAY
47008: NOT
47009: IFFALSE 47013
// exit ;
47011: GO 47038
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47013: LD_ADDR_EXP 85
47017: PUSH
47018: LD_EXP 85
47022: PPUSH
47023: LD_VAR 0 1
47027: PPUSH
47028: LD_VAR 0 2
47032: PPUSH
47033: CALL_OW 1
47037: ST_TO_ADDR
// end ;
47038: LD_VAR 0 3
47042: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47043: LD_INT 0
47045: PPUSH
// if not mc_bases [ base ] then
47046: LD_EXP 80
47050: PUSH
47051: LD_VAR 0 1
47055: ARRAY
47056: NOT
47057: IFFALSE 47061
// exit ;
47059: GO 47098
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47061: LD_ADDR_EXP 85
47065: PUSH
47066: LD_EXP 85
47070: PPUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: LD_EXP 85
47080: PUSH
47081: LD_VAR 0 1
47085: ARRAY
47086: PUSH
47087: LD_VAR 0 2
47091: UNION
47092: PPUSH
47093: CALL_OW 1
47097: ST_TO_ADDR
// end ;
47098: LD_VAR 0 3
47102: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47103: LD_INT 0
47105: PPUSH
// if not mc_bases [ base ] then
47106: LD_EXP 80
47110: PUSH
47111: LD_VAR 0 1
47115: ARRAY
47116: NOT
47117: IFFALSE 47121
// exit ;
47119: GO 47146
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47121: LD_ADDR_EXP 101
47125: PUSH
47126: LD_EXP 101
47130: PPUSH
47131: LD_VAR 0 1
47135: PPUSH
47136: LD_VAR 0 2
47140: PPUSH
47141: CALL_OW 1
47145: ST_TO_ADDR
// end ;
47146: LD_VAR 0 3
47150: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47151: LD_INT 0
47153: PPUSH
// if not mc_bases [ base ] then
47154: LD_EXP 80
47158: PUSH
47159: LD_VAR 0 1
47163: ARRAY
47164: NOT
47165: IFFALSE 47169
// exit ;
47167: GO 47206
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47169: LD_ADDR_EXP 101
47173: PUSH
47174: LD_EXP 101
47178: PPUSH
47179: LD_VAR 0 1
47183: PPUSH
47184: LD_EXP 101
47188: PUSH
47189: LD_VAR 0 1
47193: ARRAY
47194: PUSH
47195: LD_VAR 0 2
47199: ADD
47200: PPUSH
47201: CALL_OW 1
47205: ST_TO_ADDR
// end ;
47206: LD_VAR 0 3
47210: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
47211: LD_INT 0
47213: PPUSH
// if not mc_bases [ base ] then
47214: LD_EXP 80
47218: PUSH
47219: LD_VAR 0 1
47223: ARRAY
47224: NOT
47225: IFFALSE 47229
// exit ;
47227: GO 47283
// mc_defender := Replace ( mc_defender , base , deflist ) ;
47229: LD_ADDR_EXP 102
47233: PUSH
47234: LD_EXP 102
47238: PPUSH
47239: LD_VAR 0 1
47243: PPUSH
47244: LD_VAR 0 2
47248: PPUSH
47249: CALL_OW 1
47253: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47254: LD_ADDR_EXP 91
47258: PUSH
47259: LD_EXP 91
47263: PPUSH
47264: LD_VAR 0 1
47268: PPUSH
47269: LD_VAR 0 2
47273: PUSH
47274: LD_INT 0
47276: PLUS
47277: PPUSH
47278: CALL_OW 1
47282: ST_TO_ADDR
// end ;
47283: LD_VAR 0 3
47287: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
47288: LD_INT 0
47290: PPUSH
// if not mc_bases [ base ] then
47291: LD_EXP 80
47295: PUSH
47296: LD_VAR 0 1
47300: ARRAY
47301: NOT
47302: IFFALSE 47306
// exit ;
47304: GO 47331
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
47306: LD_ADDR_EXP 91
47310: PUSH
47311: LD_EXP 91
47315: PPUSH
47316: LD_VAR 0 1
47320: PPUSH
47321: LD_VAR 0 2
47325: PPUSH
47326: CALL_OW 1
47330: ST_TO_ADDR
// end ;
47331: LD_VAR 0 3
47335: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47336: LD_INT 0
47338: PPUSH
47339: PPUSH
47340: PPUSH
47341: PPUSH
// if not mc_bases [ base ] then
47342: LD_EXP 80
47346: PUSH
47347: LD_VAR 0 1
47351: ARRAY
47352: NOT
47353: IFFALSE 47357
// exit ;
47355: GO 47422
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47357: LD_ADDR_EXP 100
47361: PUSH
47362: LD_EXP 100
47366: PPUSH
47367: LD_VAR 0 1
47371: PUSH
47372: LD_EXP 100
47376: PUSH
47377: LD_VAR 0 1
47381: ARRAY
47382: PUSH
47383: LD_INT 1
47385: PLUS
47386: PUSH
47387: EMPTY
47388: LIST
47389: LIST
47390: PPUSH
47391: LD_VAR 0 1
47395: PUSH
47396: LD_VAR 0 2
47400: PUSH
47401: LD_VAR 0 3
47405: PUSH
47406: LD_VAR 0 4
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: PPUSH
47417: CALL 58539 0 3
47421: ST_TO_ADDR
// end ;
47422: LD_VAR 0 5
47426: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47427: LD_INT 0
47429: PPUSH
// if not mc_bases [ base ] then
47430: LD_EXP 80
47434: PUSH
47435: LD_VAR 0 1
47439: ARRAY
47440: NOT
47441: IFFALSE 47445
// exit ;
47443: GO 47470
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47445: LD_ADDR_EXP 117
47449: PUSH
47450: LD_EXP 117
47454: PPUSH
47455: LD_VAR 0 1
47459: PPUSH
47460: LD_VAR 0 2
47464: PPUSH
47465: CALL_OW 1
47469: ST_TO_ADDR
// end ;
47470: LD_VAR 0 3
47474: RET
// export function MC_GetMinesField ( base ) ; begin
47475: LD_INT 0
47477: PPUSH
// result := mc_mines [ base ] ;
47478: LD_ADDR_VAR 0 2
47482: PUSH
47483: LD_EXP 93
47487: PUSH
47488: LD_VAR 0 1
47492: ARRAY
47493: ST_TO_ADDR
// end ;
47494: LD_VAR 0 2
47498: RET
// export function MC_GetProduceList ( base ) ; begin
47499: LD_INT 0
47501: PPUSH
// result := mc_produce [ base ] ;
47502: LD_ADDR_VAR 0 2
47506: PUSH
47507: LD_EXP 101
47511: PUSH
47512: LD_VAR 0 1
47516: ARRAY
47517: ST_TO_ADDR
// end ;
47518: LD_VAR 0 2
47522: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47523: LD_INT 0
47525: PPUSH
47526: PPUSH
// if not mc_bases then
47527: LD_EXP 80
47531: NOT
47532: IFFALSE 47536
// exit ;
47534: GO 47601
// if mc_bases [ base ] then
47536: LD_EXP 80
47540: PUSH
47541: LD_VAR 0 1
47545: ARRAY
47546: IFFALSE 47601
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47548: LD_ADDR_VAR 0 3
47552: PUSH
47553: LD_EXP 80
47557: PUSH
47558: LD_VAR 0 1
47562: ARRAY
47563: PPUSH
47564: LD_INT 30
47566: PUSH
47567: LD_VAR 0 2
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PPUSH
47576: CALL_OW 72
47580: ST_TO_ADDR
// if result then
47581: LD_VAR 0 3
47585: IFFALSE 47601
// result := result [ 1 ] ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_VAR 0 3
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: ST_TO_ADDR
// end ; end ;
47601: LD_VAR 0 3
47605: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47606: LD_INT 0
47608: PPUSH
47609: PPUSH
// if not mc_bases then
47610: LD_EXP 80
47614: NOT
47615: IFFALSE 47619
// exit ;
47617: GO 47664
// if mc_bases [ base ] then
47619: LD_EXP 80
47623: PUSH
47624: LD_VAR 0 1
47628: ARRAY
47629: IFFALSE 47664
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47631: LD_ADDR_VAR 0 3
47635: PUSH
47636: LD_EXP 80
47640: PUSH
47641: LD_VAR 0 1
47645: ARRAY
47646: PPUSH
47647: LD_INT 30
47649: PUSH
47650: LD_VAR 0 2
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: PPUSH
47659: CALL_OW 72
47663: ST_TO_ADDR
// end ;
47664: LD_VAR 0 3
47668: RET
// export function MC_SetTame ( base , area ) ; begin
47669: LD_INT 0
47671: PPUSH
// if not mc_bases or not base then
47672: LD_EXP 80
47676: NOT
47677: PUSH
47678: LD_VAR 0 1
47682: NOT
47683: OR
47684: IFFALSE 47688
// exit ;
47686: GO 47713
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47688: LD_ADDR_EXP 108
47692: PUSH
47693: LD_EXP 108
47697: PPUSH
47698: LD_VAR 0 1
47702: PPUSH
47703: LD_VAR 0 2
47707: PPUSH
47708: CALL_OW 1
47712: ST_TO_ADDR
// end ;
47713: LD_VAR 0 3
47717: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47718: LD_INT 0
47720: PPUSH
47721: PPUSH
// if not mc_bases or not base then
47722: LD_EXP 80
47726: NOT
47727: PUSH
47728: LD_VAR 0 1
47732: NOT
47733: OR
47734: IFFALSE 47738
// exit ;
47736: GO 47840
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47738: LD_ADDR_VAR 0 4
47742: PUSH
47743: LD_EXP 80
47747: PUSH
47748: LD_VAR 0 1
47752: ARRAY
47753: PPUSH
47754: LD_INT 30
47756: PUSH
47757: LD_VAR 0 2
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: CALL_OW 72
47770: ST_TO_ADDR
// if not tmp then
47771: LD_VAR 0 4
47775: NOT
47776: IFFALSE 47780
// exit ;
47778: GO 47840
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47780: LD_ADDR_EXP 112
47784: PUSH
47785: LD_EXP 112
47789: PPUSH
47790: LD_VAR 0 1
47794: PPUSH
47795: LD_EXP 112
47799: PUSH
47800: LD_VAR 0 1
47804: ARRAY
47805: PPUSH
47806: LD_EXP 112
47810: PUSH
47811: LD_VAR 0 1
47815: ARRAY
47816: PUSH
47817: LD_INT 1
47819: PLUS
47820: PPUSH
47821: LD_VAR 0 4
47825: PUSH
47826: LD_INT 1
47828: ARRAY
47829: PPUSH
47830: CALL_OW 2
47834: PPUSH
47835: CALL_OW 1
47839: ST_TO_ADDR
// end ;
47840: LD_VAR 0 3
47844: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47845: LD_INT 0
47847: PPUSH
47848: PPUSH
// if not mc_bases or not base or not kinds then
47849: LD_EXP 80
47853: NOT
47854: PUSH
47855: LD_VAR 0 1
47859: NOT
47860: OR
47861: PUSH
47862: LD_VAR 0 2
47866: NOT
47867: OR
47868: IFFALSE 47872
// exit ;
47870: GO 47933
// for i in kinds do
47872: LD_ADDR_VAR 0 4
47876: PUSH
47877: LD_VAR 0 2
47881: PUSH
47882: FOR_IN
47883: IFFALSE 47931
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47885: LD_ADDR_EXP 114
47889: PUSH
47890: LD_EXP 114
47894: PPUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_EXP 114
47904: PUSH
47905: LD_VAR 0 1
47909: ARRAY
47910: PUSH
47911: LD_INT 1
47913: PLUS
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PPUSH
47919: LD_VAR 0 4
47923: PPUSH
47924: CALL 58539 0 3
47928: ST_TO_ADDR
47929: GO 47882
47931: POP
47932: POP
// end ;
47933: LD_VAR 0 3
47937: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47938: LD_INT 0
47940: PPUSH
// if not mc_bases or not base or not areas then
47941: LD_EXP 80
47945: NOT
47946: PUSH
47947: LD_VAR 0 1
47951: NOT
47952: OR
47953: PUSH
47954: LD_VAR 0 2
47958: NOT
47959: OR
47960: IFFALSE 47964
// exit ;
47962: GO 47989
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47964: LD_ADDR_EXP 98
47968: PUSH
47969: LD_EXP 98
47973: PPUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: LD_VAR 0 2
47983: PPUSH
47984: CALL_OW 1
47988: ST_TO_ADDR
// end ;
47989: LD_VAR 0 3
47993: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47994: LD_INT 0
47996: PPUSH
// if not mc_bases or not base or not teleports_exit then
47997: LD_EXP 80
48001: NOT
48002: PUSH
48003: LD_VAR 0 1
48007: NOT
48008: OR
48009: PUSH
48010: LD_VAR 0 2
48014: NOT
48015: OR
48016: IFFALSE 48020
// exit ;
48018: GO 48045
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48020: LD_ADDR_EXP 115
48024: PUSH
48025: LD_EXP 115
48029: PPUSH
48030: LD_VAR 0 1
48034: PPUSH
48035: LD_VAR 0 2
48039: PPUSH
48040: CALL_OW 1
48044: ST_TO_ADDR
// end ;
48045: LD_VAR 0 3
48049: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
// if not mc_bases or not base or not ext_list then
48055: LD_EXP 80
48059: NOT
48060: PUSH
48061: LD_VAR 0 1
48065: NOT
48066: OR
48067: PUSH
48068: LD_VAR 0 5
48072: NOT
48073: OR
48074: IFFALSE 48078
// exit ;
48076: GO 48251
// tmp := GetFacExtXYD ( x , y , d ) ;
48078: LD_ADDR_VAR 0 8
48082: PUSH
48083: LD_VAR 0 2
48087: PPUSH
48088: LD_VAR 0 3
48092: PPUSH
48093: LD_VAR 0 4
48097: PPUSH
48098: CALL 88902 0 3
48102: ST_TO_ADDR
// if not tmp then
48103: LD_VAR 0 8
48107: NOT
48108: IFFALSE 48112
// exit ;
48110: GO 48251
// for i in tmp do
48112: LD_ADDR_VAR 0 7
48116: PUSH
48117: LD_VAR 0 8
48121: PUSH
48122: FOR_IN
48123: IFFALSE 48249
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48125: LD_ADDR_EXP 85
48129: PUSH
48130: LD_EXP 85
48134: PPUSH
48135: LD_VAR 0 1
48139: PPUSH
48140: LD_EXP 85
48144: PUSH
48145: LD_VAR 0 1
48149: ARRAY
48150: PPUSH
48151: LD_EXP 85
48155: PUSH
48156: LD_VAR 0 1
48160: ARRAY
48161: PUSH
48162: LD_INT 1
48164: PLUS
48165: PPUSH
48166: LD_VAR 0 5
48170: PUSH
48171: LD_INT 1
48173: ARRAY
48174: PUSH
48175: LD_VAR 0 7
48179: PUSH
48180: LD_INT 1
48182: ARRAY
48183: PUSH
48184: LD_VAR 0 7
48188: PUSH
48189: LD_INT 2
48191: ARRAY
48192: PUSH
48193: LD_VAR 0 7
48197: PUSH
48198: LD_INT 3
48200: ARRAY
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: PPUSH
48208: CALL_OW 2
48212: PPUSH
48213: CALL_OW 1
48217: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
48218: LD_ADDR_VAR 0 5
48222: PUSH
48223: LD_VAR 0 5
48227: PPUSH
48228: LD_INT 1
48230: PPUSH
48231: CALL_OW 3
48235: ST_TO_ADDR
// if not ext_list then
48236: LD_VAR 0 5
48240: NOT
48241: IFFALSE 48247
// exit ;
48243: POP
48244: POP
48245: GO 48251
// end ;
48247: GO 48122
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 6
48255: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
48256: LD_INT 0
48258: PPUSH
// if not mc_bases or not base or not weapon_list then
48259: LD_EXP 80
48263: NOT
48264: PUSH
48265: LD_VAR 0 1
48269: NOT
48270: OR
48271: PUSH
48272: LD_VAR 0 2
48276: NOT
48277: OR
48278: IFFALSE 48282
// exit ;
48280: GO 48307
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
48282: LD_ADDR_EXP 119
48286: PUSH
48287: LD_EXP 119
48291: PPUSH
48292: LD_VAR 0 1
48296: PPUSH
48297: LD_VAR 0 2
48301: PPUSH
48302: CALL_OW 1
48306: ST_TO_ADDR
// end ;
48307: LD_VAR 0 3
48311: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
48312: LD_INT 0
48314: PPUSH
// if not mc_bases or not base or not tech_list then
48315: LD_EXP 80
48319: NOT
48320: PUSH
48321: LD_VAR 0 1
48325: NOT
48326: OR
48327: PUSH
48328: LD_VAR 0 2
48332: NOT
48333: OR
48334: IFFALSE 48338
// exit ;
48336: GO 48363
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48338: LD_ADDR_EXP 107
48342: PUSH
48343: LD_EXP 107
48347: PPUSH
48348: LD_VAR 0 1
48352: PPUSH
48353: LD_VAR 0 2
48357: PPUSH
48358: CALL_OW 1
48362: ST_TO_ADDR
// end ;
48363: LD_VAR 0 3
48367: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48368: LD_INT 0
48370: PPUSH
// if not mc_bases or not parking_area or not base then
48371: LD_EXP 80
48375: NOT
48376: PUSH
48377: LD_VAR 0 2
48381: NOT
48382: OR
48383: PUSH
48384: LD_VAR 0 1
48388: NOT
48389: OR
48390: IFFALSE 48394
// exit ;
48392: GO 48419
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48394: LD_ADDR_EXP 104
48398: PUSH
48399: LD_EXP 104
48403: PPUSH
48404: LD_VAR 0 1
48408: PPUSH
48409: LD_VAR 0 2
48413: PPUSH
48414: CALL_OW 1
48418: ST_TO_ADDR
// end ;
48419: LD_VAR 0 3
48423: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48424: LD_INT 0
48426: PPUSH
// if not mc_bases or not base or not scan_area then
48427: LD_EXP 80
48431: NOT
48432: PUSH
48433: LD_VAR 0 1
48437: NOT
48438: OR
48439: PUSH
48440: LD_VAR 0 2
48444: NOT
48445: OR
48446: IFFALSE 48450
// exit ;
48448: GO 48475
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48450: LD_ADDR_EXP 105
48454: PUSH
48455: LD_EXP 105
48459: PPUSH
48460: LD_VAR 0 1
48464: PPUSH
48465: LD_VAR 0 2
48469: PPUSH
48470: CALL_OW 1
48474: ST_TO_ADDR
// end ;
48475: LD_VAR 0 3
48479: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48480: LD_INT 0
48482: PPUSH
48483: PPUSH
// if not mc_bases or not base then
48484: LD_EXP 80
48488: NOT
48489: PUSH
48490: LD_VAR 0 1
48494: NOT
48495: OR
48496: IFFALSE 48500
// exit ;
48498: GO 48564
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48500: LD_ADDR_VAR 0 3
48504: PUSH
48505: LD_INT 1
48507: PUSH
48508: LD_INT 2
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: LD_INT 4
48516: PUSH
48517: LD_INT 11
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48527: LD_ADDR_EXP 107
48531: PUSH
48532: LD_EXP 107
48536: PPUSH
48537: LD_VAR 0 1
48541: PPUSH
48542: LD_EXP 107
48546: PUSH
48547: LD_VAR 0 1
48551: ARRAY
48552: PUSH
48553: LD_VAR 0 3
48557: DIFF
48558: PPUSH
48559: CALL_OW 1
48563: ST_TO_ADDR
// end ;
48564: LD_VAR 0 2
48568: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48569: LD_INT 0
48571: PPUSH
// result := mc_vehicles [ base ] ;
48572: LD_ADDR_VAR 0 3
48576: PUSH
48577: LD_EXP 99
48581: PUSH
48582: LD_VAR 0 1
48586: ARRAY
48587: ST_TO_ADDR
// if onlyCombat then
48588: LD_VAR 0 2
48592: IFFALSE 48764
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48594: LD_ADDR_VAR 0 3
48598: PUSH
48599: LD_VAR 0 3
48603: PUSH
48604: LD_VAR 0 3
48608: PPUSH
48609: LD_INT 2
48611: PUSH
48612: LD_INT 34
48614: PUSH
48615: LD_INT 12
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 34
48624: PUSH
48625: LD_INT 51
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 34
48634: PUSH
48635: LD_INT 89
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: PUSH
48642: LD_INT 34
48644: PUSH
48645: LD_INT 32
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 34
48654: PUSH
48655: LD_INT 13
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: LD_INT 34
48664: PUSH
48665: LD_INT 52
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PUSH
48672: LD_INT 34
48674: PUSH
48675: LD_INT 88
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: PUSH
48682: LD_INT 34
48684: PUSH
48685: LD_INT 14
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 34
48694: PUSH
48695: LD_INT 53
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: LD_INT 34
48704: PUSH
48705: LD_INT 98
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: PUSH
48712: LD_INT 34
48714: PUSH
48715: LD_INT 31
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 34
48724: PUSH
48725: LD_INT 48
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 34
48734: PUSH
48735: LD_INT 8
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: PPUSH
48758: CALL_OW 72
48762: DIFF
48763: ST_TO_ADDR
// end ; end_of_file
48764: LD_VAR 0 3
48768: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48769: LD_INT 0
48771: PPUSH
48772: PPUSH
48773: PPUSH
// if not mc_bases or not skirmish then
48774: LD_EXP 80
48778: NOT
48779: PUSH
48780: LD_EXP 78
48784: NOT
48785: OR
48786: IFFALSE 48790
// exit ;
48788: GO 48955
// for i = 1 to mc_bases do
48790: LD_ADDR_VAR 0 4
48794: PUSH
48795: DOUBLE
48796: LD_INT 1
48798: DEC
48799: ST_TO_ADDR
48800: LD_EXP 80
48804: PUSH
48805: FOR_TO
48806: IFFALSE 48953
// begin if sci in mc_bases [ i ] then
48808: LD_VAR 0 2
48812: PUSH
48813: LD_EXP 80
48817: PUSH
48818: LD_VAR 0 4
48822: ARRAY
48823: IN
48824: IFFALSE 48951
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48826: LD_ADDR_EXP 109
48830: PUSH
48831: LD_EXP 109
48835: PPUSH
48836: LD_VAR 0 4
48840: PUSH
48841: LD_EXP 109
48845: PUSH
48846: LD_VAR 0 4
48850: ARRAY
48851: PUSH
48852: LD_INT 1
48854: PLUS
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PPUSH
48860: LD_VAR 0 1
48864: PPUSH
48865: CALL 58539 0 3
48869: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48870: LD_ADDR_VAR 0 5
48874: PUSH
48875: LD_EXP 80
48879: PUSH
48880: LD_VAR 0 4
48884: ARRAY
48885: PPUSH
48886: LD_INT 2
48888: PUSH
48889: LD_INT 30
48891: PUSH
48892: LD_INT 0
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_INT 30
48901: PUSH
48902: LD_INT 1
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: LIST
48913: PPUSH
48914: CALL_OW 72
48918: PPUSH
48919: LD_VAR 0 1
48923: PPUSH
48924: CALL_OW 74
48928: ST_TO_ADDR
// if tmp then
48929: LD_VAR 0 5
48933: IFFALSE 48949
// ComStandNearbyBuilding ( ape , tmp ) ;
48935: LD_VAR 0 1
48939: PPUSH
48940: LD_VAR 0 5
48944: PPUSH
48945: CALL 55141 0 2
// break ;
48949: GO 48953
// end ; end ;
48951: GO 48805
48953: POP
48954: POP
// end ;
48955: LD_VAR 0 3
48959: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48960: LD_INT 0
48962: PPUSH
48963: PPUSH
48964: PPUSH
// if not mc_bases or not skirmish then
48965: LD_EXP 80
48969: NOT
48970: PUSH
48971: LD_EXP 78
48975: NOT
48976: OR
48977: IFFALSE 48981
// exit ;
48979: GO 49070
// for i = 1 to mc_bases do
48981: LD_ADDR_VAR 0 4
48985: PUSH
48986: DOUBLE
48987: LD_INT 1
48989: DEC
48990: ST_TO_ADDR
48991: LD_EXP 80
48995: PUSH
48996: FOR_TO
48997: IFFALSE 49068
// begin if building in mc_busy_turret_list [ i ] then
48999: LD_VAR 0 1
49003: PUSH
49004: LD_EXP 90
49008: PUSH
49009: LD_VAR 0 4
49013: ARRAY
49014: IN
49015: IFFALSE 49066
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49017: LD_ADDR_VAR 0 5
49021: PUSH
49022: LD_EXP 90
49026: PUSH
49027: LD_VAR 0 4
49031: ARRAY
49032: PUSH
49033: LD_VAR 0 1
49037: DIFF
49038: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49039: LD_ADDR_EXP 90
49043: PUSH
49044: LD_EXP 90
49048: PPUSH
49049: LD_VAR 0 4
49053: PPUSH
49054: LD_VAR 0 5
49058: PPUSH
49059: CALL_OW 1
49063: ST_TO_ADDR
// break ;
49064: GO 49068
// end ; end ;
49066: GO 48996
49068: POP
49069: POP
// end ;
49070: LD_VAR 0 3
49074: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49075: LD_INT 0
49077: PPUSH
49078: PPUSH
49079: PPUSH
// if not mc_bases or not skirmish then
49080: LD_EXP 80
49084: NOT
49085: PUSH
49086: LD_EXP 78
49090: NOT
49091: OR
49092: IFFALSE 49096
// exit ;
49094: GO 49295
// for i = 1 to mc_bases do
49096: LD_ADDR_VAR 0 5
49100: PUSH
49101: DOUBLE
49102: LD_INT 1
49104: DEC
49105: ST_TO_ADDR
49106: LD_EXP 80
49110: PUSH
49111: FOR_TO
49112: IFFALSE 49293
// if building in mc_bases [ i ] then
49114: LD_VAR 0 1
49118: PUSH
49119: LD_EXP 80
49123: PUSH
49124: LD_VAR 0 5
49128: ARRAY
49129: IN
49130: IFFALSE 49291
// begin tmp := mc_bases [ i ] diff building ;
49132: LD_ADDR_VAR 0 6
49136: PUSH
49137: LD_EXP 80
49141: PUSH
49142: LD_VAR 0 5
49146: ARRAY
49147: PUSH
49148: LD_VAR 0 1
49152: DIFF
49153: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49154: LD_ADDR_EXP 80
49158: PUSH
49159: LD_EXP 80
49163: PPUSH
49164: LD_VAR 0 5
49168: PPUSH
49169: LD_VAR 0 6
49173: PPUSH
49174: CALL_OW 1
49178: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49179: LD_VAR 0 1
49183: PUSH
49184: LD_EXP 88
49188: PUSH
49189: LD_VAR 0 5
49193: ARRAY
49194: IN
49195: IFFALSE 49234
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49197: LD_ADDR_EXP 88
49201: PUSH
49202: LD_EXP 88
49206: PPUSH
49207: LD_VAR 0 5
49211: PPUSH
49212: LD_EXP 88
49216: PUSH
49217: LD_VAR 0 5
49221: ARRAY
49222: PUSH
49223: LD_VAR 0 1
49227: DIFF
49228: PPUSH
49229: CALL_OW 1
49233: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
49234: LD_VAR 0 1
49238: PUSH
49239: LD_EXP 89
49243: PUSH
49244: LD_VAR 0 5
49248: ARRAY
49249: IN
49250: IFFALSE 49289
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
49252: LD_ADDR_EXP 89
49256: PUSH
49257: LD_EXP 89
49261: PPUSH
49262: LD_VAR 0 5
49266: PPUSH
49267: LD_EXP 89
49271: PUSH
49272: LD_VAR 0 5
49276: ARRAY
49277: PUSH
49278: LD_VAR 0 1
49282: DIFF
49283: PPUSH
49284: CALL_OW 1
49288: ST_TO_ADDR
// break ;
49289: GO 49293
// end ;
49291: GO 49111
49293: POP
49294: POP
// end ;
49295: LD_VAR 0 4
49299: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
49300: LD_INT 0
49302: PPUSH
49303: PPUSH
49304: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
49305: LD_EXP 80
49309: NOT
49310: PUSH
49311: LD_EXP 78
49315: NOT
49316: OR
49317: PUSH
49318: LD_VAR 0 3
49322: PUSH
49323: LD_EXP 106
49327: IN
49328: NOT
49329: OR
49330: IFFALSE 49334
// exit ;
49332: GO 49457
// for i = 1 to mc_vehicles do
49334: LD_ADDR_VAR 0 6
49338: PUSH
49339: DOUBLE
49340: LD_INT 1
49342: DEC
49343: ST_TO_ADDR
49344: LD_EXP 99
49348: PUSH
49349: FOR_TO
49350: IFFALSE 49455
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49352: LD_VAR 0 2
49356: PUSH
49357: LD_EXP 99
49361: PUSH
49362: LD_VAR 0 6
49366: ARRAY
49367: IN
49368: PUSH
49369: LD_VAR 0 1
49373: PUSH
49374: LD_EXP 99
49378: PUSH
49379: LD_VAR 0 6
49383: ARRAY
49384: IN
49385: OR
49386: IFFALSE 49453
// begin tmp := mc_vehicles [ i ] diff old ;
49388: LD_ADDR_VAR 0 7
49392: PUSH
49393: LD_EXP 99
49397: PUSH
49398: LD_VAR 0 6
49402: ARRAY
49403: PUSH
49404: LD_VAR 0 2
49408: DIFF
49409: ST_TO_ADDR
// tmp := tmp diff new ;
49410: LD_ADDR_VAR 0 7
49414: PUSH
49415: LD_VAR 0 7
49419: PUSH
49420: LD_VAR 0 1
49424: DIFF
49425: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49426: LD_ADDR_EXP 99
49430: PUSH
49431: LD_EXP 99
49435: PPUSH
49436: LD_VAR 0 6
49440: PPUSH
49441: LD_VAR 0 7
49445: PPUSH
49446: CALL_OW 1
49450: ST_TO_ADDR
// break ;
49451: GO 49455
// end ;
49453: GO 49349
49455: POP
49456: POP
// end ;
49457: LD_VAR 0 5
49461: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49462: LD_INT 0
49464: PPUSH
49465: PPUSH
49466: PPUSH
49467: PPUSH
// if not mc_bases or not skirmish then
49468: LD_EXP 80
49472: NOT
49473: PUSH
49474: LD_EXP 78
49478: NOT
49479: OR
49480: IFFALSE 49484
// exit ;
49482: GO 49904
// repeat wait ( 0 0$1 ) ;
49484: LD_INT 35
49486: PPUSH
49487: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49491: LD_EXP 124
49495: NOT
49496: IFFALSE 49484
// mc_block_vehicle_constructed_thread := true ;
49498: LD_ADDR_EXP 124
49502: PUSH
49503: LD_INT 1
49505: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49506: LD_ADDR_VAR 0 5
49510: PUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: CALL_OW 255
49520: ST_TO_ADDR
// for i = 1 to mc_bases do
49521: LD_ADDR_VAR 0 4
49525: PUSH
49526: DOUBLE
49527: LD_INT 1
49529: DEC
49530: ST_TO_ADDR
49531: LD_EXP 80
49535: PUSH
49536: FOR_TO
49537: IFFALSE 49894
// begin if factory in mc_bases [ i ] then
49539: LD_VAR 0 2
49543: PUSH
49544: LD_EXP 80
49548: PUSH
49549: LD_VAR 0 4
49553: ARRAY
49554: IN
49555: IFFALSE 49892
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49557: LD_EXP 102
49561: PUSH
49562: LD_VAR 0 4
49566: ARRAY
49567: PUSH
49568: LD_EXP 91
49572: PUSH
49573: LD_VAR 0 4
49577: ARRAY
49578: LESS
49579: PUSH
49580: LD_VAR 0 1
49584: PPUSH
49585: CALL_OW 264
49589: PUSH
49590: LD_INT 31
49592: PUSH
49593: LD_INT 32
49595: PUSH
49596: LD_INT 51
49598: PUSH
49599: LD_INT 89
49601: PUSH
49602: LD_INT 12
49604: PUSH
49605: LD_INT 30
49607: PUSH
49608: LD_INT 98
49610: PUSH
49611: LD_INT 11
49613: PUSH
49614: LD_INT 53
49616: PUSH
49617: LD_INT 14
49619: PUSH
49620: LD_INT 91
49622: PUSH
49623: LD_INT 29
49625: PUSH
49626: LD_INT 99
49628: PUSH
49629: LD_INT 13
49631: PUSH
49632: LD_INT 52
49634: PUSH
49635: LD_INT 88
49637: PUSH
49638: LD_INT 48
49640: PUSH
49641: LD_INT 8
49643: PUSH
49644: EMPTY
49645: LIST
49646: LIST
49647: LIST
49648: LIST
49649: LIST
49650: LIST
49651: LIST
49652: LIST
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: LIST
49660: LIST
49661: LIST
49662: LIST
49663: IN
49664: NOT
49665: AND
49666: IFFALSE 49714
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49668: LD_ADDR_EXP 102
49672: PUSH
49673: LD_EXP 102
49677: PPUSH
49678: LD_VAR 0 4
49682: PUSH
49683: LD_EXP 102
49687: PUSH
49688: LD_VAR 0 4
49692: ARRAY
49693: PUSH
49694: LD_INT 1
49696: PLUS
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PPUSH
49702: LD_VAR 0 1
49706: PPUSH
49707: CALL 58539 0 3
49711: ST_TO_ADDR
49712: GO 49758
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49714: LD_ADDR_EXP 99
49718: PUSH
49719: LD_EXP 99
49723: PPUSH
49724: LD_VAR 0 4
49728: PUSH
49729: LD_EXP 99
49733: PUSH
49734: LD_VAR 0 4
49738: ARRAY
49739: PUSH
49740: LD_INT 1
49742: PLUS
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: LD_VAR 0 1
49752: PPUSH
49753: CALL 58539 0 3
49757: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49758: LD_ADDR_EXP 124
49762: PUSH
49763: LD_INT 0
49765: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49766: LD_VAR 0 1
49770: PPUSH
49771: CALL_OW 263
49775: PUSH
49776: LD_INT 2
49778: EQUAL
49779: IFFALSE 49808
// begin repeat wait ( 0 0$3 ) ;
49781: LD_INT 105
49783: PPUSH
49784: CALL_OW 67
// Connect ( vehicle ) ;
49788: LD_VAR 0 1
49792: PPUSH
49793: CALL 61885 0 1
// until IsControledBy ( vehicle ) ;
49797: LD_VAR 0 1
49801: PPUSH
49802: CALL_OW 312
49806: IFFALSE 49781
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49808: LD_VAR 0 1
49812: PPUSH
49813: LD_EXP 104
49817: PUSH
49818: LD_VAR 0 4
49822: ARRAY
49823: PPUSH
49824: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49828: LD_VAR 0 1
49832: PPUSH
49833: CALL_OW 263
49837: PUSH
49838: LD_INT 1
49840: NONEQUAL
49841: IFFALSE 49845
// break ;
49843: GO 49894
// repeat wait ( 0 0$1 ) ;
49845: LD_INT 35
49847: PPUSH
49848: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49852: LD_VAR 0 1
49856: PPUSH
49857: LD_EXP 104
49861: PUSH
49862: LD_VAR 0 4
49866: ARRAY
49867: PPUSH
49868: CALL_OW 308
49872: IFFALSE 49845
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49874: LD_VAR 0 1
49878: PPUSH
49879: CALL_OW 311
49883: PPUSH
49884: CALL_OW 121
// exit ;
49888: POP
49889: POP
49890: GO 49904
// end ; end ;
49892: GO 49536
49894: POP
49895: POP
// mc_block_vehicle_constructed_thread := false ;
49896: LD_ADDR_EXP 124
49900: PUSH
49901: LD_INT 0
49903: ST_TO_ADDR
// end ;
49904: LD_VAR 0 3
49908: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49909: LD_INT 0
49911: PPUSH
49912: PPUSH
49913: PPUSH
49914: PPUSH
// if not mc_bases or not skirmish then
49915: LD_EXP 80
49919: NOT
49920: PUSH
49921: LD_EXP 78
49925: NOT
49926: OR
49927: IFFALSE 49931
// exit ;
49929: GO 50284
// repeat wait ( 0 0$1 ) ;
49931: LD_INT 35
49933: PPUSH
49934: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49938: LD_VAR 0 2
49942: PPUSH
49943: LD_VAR 0 3
49947: PPUSH
49948: CALL_OW 284
49952: IFFALSE 49931
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49954: LD_VAR 0 2
49958: PPUSH
49959: LD_VAR 0 3
49963: PPUSH
49964: CALL_OW 283
49968: PUSH
49969: LD_INT 4
49971: EQUAL
49972: IFFALSE 49976
// exit ;
49974: GO 50284
// for i = 1 to mc_bases do
49976: LD_ADDR_VAR 0 7
49980: PUSH
49981: DOUBLE
49982: LD_INT 1
49984: DEC
49985: ST_TO_ADDR
49986: LD_EXP 80
49990: PUSH
49991: FOR_TO
49992: IFFALSE 50282
// begin if mc_crates_area [ i ] then
49994: LD_EXP 98
49998: PUSH
49999: LD_VAR 0 7
50003: ARRAY
50004: IFFALSE 50115
// for j in mc_crates_area [ i ] do
50006: LD_ADDR_VAR 0 8
50010: PUSH
50011: LD_EXP 98
50015: PUSH
50016: LD_VAR 0 7
50020: ARRAY
50021: PUSH
50022: FOR_IN
50023: IFFALSE 50113
// if InArea ( x , y , j ) then
50025: LD_VAR 0 2
50029: PPUSH
50030: LD_VAR 0 3
50034: PPUSH
50035: LD_VAR 0 8
50039: PPUSH
50040: CALL_OW 309
50044: IFFALSE 50111
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50046: LD_ADDR_EXP 96
50050: PUSH
50051: LD_EXP 96
50055: PPUSH
50056: LD_VAR 0 7
50060: PUSH
50061: LD_EXP 96
50065: PUSH
50066: LD_VAR 0 7
50070: ARRAY
50071: PUSH
50072: LD_INT 1
50074: PLUS
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PPUSH
50080: LD_VAR 0 4
50084: PUSH
50085: LD_VAR 0 2
50089: PUSH
50090: LD_VAR 0 3
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: LIST
50099: PPUSH
50100: CALL 58539 0 3
50104: ST_TO_ADDR
// exit ;
50105: POP
50106: POP
50107: POP
50108: POP
50109: GO 50284
// end ;
50111: GO 50022
50113: POP
50114: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50115: LD_ADDR_VAR 0 9
50119: PUSH
50120: LD_EXP 80
50124: PUSH
50125: LD_VAR 0 7
50129: ARRAY
50130: PPUSH
50131: LD_INT 2
50133: PUSH
50134: LD_INT 30
50136: PUSH
50137: LD_INT 0
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 30
50146: PUSH
50147: LD_INT 1
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: LIST
50158: PPUSH
50159: CALL_OW 72
50163: ST_TO_ADDR
// if not depot then
50164: LD_VAR 0 9
50168: NOT
50169: IFFALSE 50173
// continue ;
50171: GO 49991
// for j in depot do
50173: LD_ADDR_VAR 0 8
50177: PUSH
50178: LD_VAR 0 9
50182: PUSH
50183: FOR_IN
50184: IFFALSE 50278
// if GetDistUnitXY ( j , x , y ) < 30 then
50186: LD_VAR 0 8
50190: PPUSH
50191: LD_VAR 0 2
50195: PPUSH
50196: LD_VAR 0 3
50200: PPUSH
50201: CALL_OW 297
50205: PUSH
50206: LD_INT 30
50208: LESS
50209: IFFALSE 50276
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50211: LD_ADDR_EXP 96
50215: PUSH
50216: LD_EXP 96
50220: PPUSH
50221: LD_VAR 0 7
50225: PUSH
50226: LD_EXP 96
50230: PUSH
50231: LD_VAR 0 7
50235: ARRAY
50236: PUSH
50237: LD_INT 1
50239: PLUS
50240: PUSH
50241: EMPTY
50242: LIST
50243: LIST
50244: PPUSH
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 2
50254: PUSH
50255: LD_VAR 0 3
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: LIST
50264: PPUSH
50265: CALL 58539 0 3
50269: ST_TO_ADDR
// exit ;
50270: POP
50271: POP
50272: POP
50273: POP
50274: GO 50284
// end ;
50276: GO 50183
50278: POP
50279: POP
// end ;
50280: GO 49991
50282: POP
50283: POP
// end ;
50284: LD_VAR 0 6
50288: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
50289: LD_INT 0
50291: PPUSH
50292: PPUSH
50293: PPUSH
50294: PPUSH
// if not mc_bases or not skirmish then
50295: LD_EXP 80
50299: NOT
50300: PUSH
50301: LD_EXP 78
50305: NOT
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50588
// side := GetSide ( lab ) ;
50311: LD_ADDR_VAR 0 4
50315: PUSH
50316: LD_VAR 0 2
50320: PPUSH
50321: CALL_OW 255
50325: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50326: LD_VAR 0 4
50330: PUSH
50331: LD_EXP 106
50335: IN
50336: NOT
50337: PUSH
50338: LD_EXP 107
50342: NOT
50343: OR
50344: PUSH
50345: LD_EXP 80
50349: NOT
50350: OR
50351: IFFALSE 50355
// exit ;
50353: GO 50588
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50355: LD_ADDR_EXP 107
50359: PUSH
50360: LD_EXP 107
50364: PPUSH
50365: LD_VAR 0 4
50369: PPUSH
50370: LD_EXP 107
50374: PUSH
50375: LD_VAR 0 4
50379: ARRAY
50380: PUSH
50381: LD_VAR 0 1
50385: DIFF
50386: PPUSH
50387: CALL_OW 1
50391: ST_TO_ADDR
// for i = 1 to mc_bases do
50392: LD_ADDR_VAR 0 5
50396: PUSH
50397: DOUBLE
50398: LD_INT 1
50400: DEC
50401: ST_TO_ADDR
50402: LD_EXP 80
50406: PUSH
50407: FOR_TO
50408: IFFALSE 50586
// begin if lab in mc_bases [ i ] then
50410: LD_VAR 0 2
50414: PUSH
50415: LD_EXP 80
50419: PUSH
50420: LD_VAR 0 5
50424: ARRAY
50425: IN
50426: IFFALSE 50584
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50428: LD_VAR 0 1
50432: PUSH
50433: LD_INT 11
50435: PUSH
50436: LD_INT 4
50438: PUSH
50439: LD_INT 3
50441: PUSH
50442: LD_INT 2
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: IN
50451: PUSH
50452: LD_EXP 110
50456: PUSH
50457: LD_VAR 0 5
50461: ARRAY
50462: AND
50463: IFFALSE 50584
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50465: LD_ADDR_VAR 0 6
50469: PUSH
50470: LD_EXP 110
50474: PUSH
50475: LD_VAR 0 5
50479: ARRAY
50480: PUSH
50481: LD_INT 1
50483: ARRAY
50484: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50485: LD_ADDR_EXP 110
50489: PUSH
50490: LD_EXP 110
50494: PPUSH
50495: LD_VAR 0 5
50499: PPUSH
50500: EMPTY
50501: PPUSH
50502: CALL_OW 1
50506: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50507: LD_VAR 0 6
50511: PPUSH
50512: LD_INT 0
50514: PPUSH
50515: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50519: LD_VAR 0 6
50523: PPUSH
50524: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50528: LD_ADDR_EXP 109
50532: PUSH
50533: LD_EXP 109
50537: PPUSH
50538: LD_VAR 0 5
50542: PPUSH
50543: LD_EXP 109
50547: PUSH
50548: LD_VAR 0 5
50552: ARRAY
50553: PPUSH
50554: LD_INT 1
50556: PPUSH
50557: LD_VAR 0 6
50561: PPUSH
50562: CALL_OW 2
50566: PPUSH
50567: CALL_OW 1
50571: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50572: LD_VAR 0 5
50576: PPUSH
50577: LD_INT 112
50579: PPUSH
50580: CALL 27038 0 2
// end ; end ; end ;
50584: GO 50407
50586: POP
50587: POP
// end ;
50588: LD_VAR 0 3
50592: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50593: LD_INT 0
50595: PPUSH
50596: PPUSH
50597: PPUSH
50598: PPUSH
50599: PPUSH
50600: PPUSH
50601: PPUSH
50602: PPUSH
// if not mc_bases or not skirmish then
50603: LD_EXP 80
50607: NOT
50608: PUSH
50609: LD_EXP 78
50613: NOT
50614: OR
50615: IFFALSE 50619
// exit ;
50617: GO 51988
// for i = 1 to mc_bases do
50619: LD_ADDR_VAR 0 3
50623: PUSH
50624: DOUBLE
50625: LD_INT 1
50627: DEC
50628: ST_TO_ADDR
50629: LD_EXP 80
50633: PUSH
50634: FOR_TO
50635: IFFALSE 51986
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50637: LD_VAR 0 1
50641: PUSH
50642: LD_EXP 80
50646: PUSH
50647: LD_VAR 0 3
50651: ARRAY
50652: IN
50653: PUSH
50654: LD_VAR 0 1
50658: PUSH
50659: LD_EXP 87
50663: PUSH
50664: LD_VAR 0 3
50668: ARRAY
50669: IN
50670: OR
50671: PUSH
50672: LD_VAR 0 1
50676: PUSH
50677: LD_EXP 102
50681: PUSH
50682: LD_VAR 0 3
50686: ARRAY
50687: IN
50688: OR
50689: PUSH
50690: LD_VAR 0 1
50694: PUSH
50695: LD_EXP 99
50699: PUSH
50700: LD_VAR 0 3
50704: ARRAY
50705: IN
50706: OR
50707: PUSH
50708: LD_VAR 0 1
50712: PUSH
50713: LD_EXP 109
50717: PUSH
50718: LD_VAR 0 3
50722: ARRAY
50723: IN
50724: OR
50725: PUSH
50726: LD_VAR 0 1
50730: PUSH
50731: LD_EXP 110
50735: PUSH
50736: LD_VAR 0 3
50740: ARRAY
50741: IN
50742: OR
50743: IFFALSE 51984
// begin if un in mc_ape [ i ] then
50745: LD_VAR 0 1
50749: PUSH
50750: LD_EXP 109
50754: PUSH
50755: LD_VAR 0 3
50759: ARRAY
50760: IN
50761: IFFALSE 50800
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50763: LD_ADDR_EXP 109
50767: PUSH
50768: LD_EXP 109
50772: PPUSH
50773: LD_VAR 0 3
50777: PPUSH
50778: LD_EXP 109
50782: PUSH
50783: LD_VAR 0 3
50787: ARRAY
50788: PUSH
50789: LD_VAR 0 1
50793: DIFF
50794: PPUSH
50795: CALL_OW 1
50799: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50800: LD_VAR 0 1
50804: PUSH
50805: LD_EXP 110
50809: PUSH
50810: LD_VAR 0 3
50814: ARRAY
50815: IN
50816: IFFALSE 50840
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50818: LD_ADDR_EXP 110
50822: PUSH
50823: LD_EXP 110
50827: PPUSH
50828: LD_VAR 0 3
50832: PPUSH
50833: EMPTY
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50840: LD_VAR 0 1
50844: PPUSH
50845: CALL_OW 247
50849: PUSH
50850: LD_INT 2
50852: EQUAL
50853: PUSH
50854: LD_VAR 0 1
50858: PPUSH
50859: CALL_OW 110
50863: PUSH
50864: LD_INT 20
50866: EQUAL
50867: PUSH
50868: LD_VAR 0 1
50872: PUSH
50873: LD_EXP 102
50877: PUSH
50878: LD_VAR 0 3
50882: ARRAY
50883: IN
50884: OR
50885: PUSH
50886: LD_VAR 0 1
50890: PPUSH
50891: CALL_OW 264
50895: PUSH
50896: LD_INT 12
50898: PUSH
50899: LD_INT 51
50901: PUSH
50902: LD_INT 89
50904: PUSH
50905: LD_INT 32
50907: PUSH
50908: LD_INT 13
50910: PUSH
50911: LD_INT 52
50913: PUSH
50914: LD_INT 31
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: IN
50926: OR
50927: AND
50928: IFFALSE 51236
// begin if un in mc_defender [ i ] then
50930: LD_VAR 0 1
50934: PUSH
50935: LD_EXP 102
50939: PUSH
50940: LD_VAR 0 3
50944: ARRAY
50945: IN
50946: IFFALSE 50985
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50948: LD_ADDR_EXP 102
50952: PUSH
50953: LD_EXP 102
50957: PPUSH
50958: LD_VAR 0 3
50962: PPUSH
50963: LD_EXP 102
50967: PUSH
50968: LD_VAR 0 3
50972: ARRAY
50973: PUSH
50974: LD_VAR 0 1
50978: DIFF
50979: PPUSH
50980: CALL_OW 1
50984: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50985: LD_ADDR_VAR 0 8
50989: PUSH
50990: LD_VAR 0 3
50994: PPUSH
50995: LD_INT 3
50997: PPUSH
50998: CALL 47606 0 2
51002: ST_TO_ADDR
// if fac then
51003: LD_VAR 0 8
51007: IFFALSE 51236
// begin for j in fac do
51009: LD_ADDR_VAR 0 4
51013: PUSH
51014: LD_VAR 0 8
51018: PUSH
51019: FOR_IN
51020: IFFALSE 51234
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51022: LD_ADDR_VAR 0 9
51026: PUSH
51027: LD_VAR 0 8
51031: PPUSH
51032: LD_VAR 0 1
51036: PPUSH
51037: CALL_OW 265
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL_OW 262
51051: PPUSH
51052: LD_VAR 0 1
51056: PPUSH
51057: CALL_OW 263
51061: PPUSH
51062: LD_VAR 0 1
51066: PPUSH
51067: CALL_OW 264
51071: PPUSH
51072: CALL 56037 0 5
51076: ST_TO_ADDR
// if components then
51077: LD_VAR 0 9
51081: IFFALSE 51232
// begin if GetWeapon ( un ) = ar_control_tower then
51083: LD_VAR 0 1
51087: PPUSH
51088: CALL_OW 264
51092: PUSH
51093: LD_INT 31
51095: EQUAL
51096: IFFALSE 51213
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
51098: LD_VAR 0 1
51102: PPUSH
51103: CALL_OW 311
51107: PPUSH
51108: LD_INT 0
51110: PPUSH
51111: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51115: LD_ADDR_EXP 120
51119: PUSH
51120: LD_EXP 120
51124: PPUSH
51125: LD_VAR 0 3
51129: PPUSH
51130: LD_EXP 120
51134: PUSH
51135: LD_VAR 0 3
51139: ARRAY
51140: PUSH
51141: LD_VAR 0 1
51145: PPUSH
51146: CALL_OW 311
51150: DIFF
51151: PPUSH
51152: CALL_OW 1
51156: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
51157: LD_ADDR_VAR 0 7
51161: PUSH
51162: LD_EXP 101
51166: PUSH
51167: LD_VAR 0 3
51171: ARRAY
51172: PPUSH
51173: LD_INT 1
51175: PPUSH
51176: LD_VAR 0 9
51180: PPUSH
51181: CALL_OW 2
51185: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51186: LD_ADDR_EXP 101
51190: PUSH
51191: LD_EXP 101
51195: PPUSH
51196: LD_VAR 0 3
51200: PPUSH
51201: LD_VAR 0 7
51205: PPUSH
51206: CALL_OW 1
51210: ST_TO_ADDR
// end else
51211: GO 51230
// MC_InsertProduceList ( i , [ components ] ) ;
51213: LD_VAR 0 3
51217: PPUSH
51218: LD_VAR 0 9
51222: PUSH
51223: EMPTY
51224: LIST
51225: PPUSH
51226: CALL 47151 0 2
// break ;
51230: GO 51234
// end ; end ;
51232: GO 51019
51234: POP
51235: POP
// end ; end ; if GetType ( un ) = unit_building then
51236: LD_VAR 0 1
51240: PPUSH
51241: CALL_OW 247
51245: PUSH
51246: LD_INT 3
51248: EQUAL
51249: IFFALSE 51652
// begin btype := GetBType ( un ) ;
51251: LD_ADDR_VAR 0 5
51255: PUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 266
51265: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
51266: LD_VAR 0 5
51270: PUSH
51271: LD_INT 29
51273: PUSH
51274: LD_INT 30
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: IN
51281: IFFALSE 51354
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
51283: LD_VAR 0 1
51287: PPUSH
51288: CALL_OW 250
51292: PPUSH
51293: LD_VAR 0 1
51297: PPUSH
51298: CALL_OW 251
51302: PPUSH
51303: LD_VAR 0 1
51307: PPUSH
51308: CALL_OW 255
51312: PPUSH
51313: CALL_OW 440
51317: NOT
51318: IFFALSE 51354
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51320: LD_VAR 0 1
51324: PPUSH
51325: CALL_OW 250
51329: PPUSH
51330: LD_VAR 0 1
51334: PPUSH
51335: CALL_OW 251
51339: PPUSH
51340: LD_VAR 0 1
51344: PPUSH
51345: CALL_OW 255
51349: PPUSH
51350: CALL_OW 441
// end ; if btype = b_warehouse then
51354: LD_VAR 0 5
51358: PUSH
51359: LD_INT 1
51361: EQUAL
51362: IFFALSE 51380
// begin btype := b_depot ;
51364: LD_ADDR_VAR 0 5
51368: PUSH
51369: LD_INT 0
51371: ST_TO_ADDR
// pos := 1 ;
51372: LD_ADDR_VAR 0 6
51376: PUSH
51377: LD_INT 1
51379: ST_TO_ADDR
// end ; if btype = b_factory then
51380: LD_VAR 0 5
51384: PUSH
51385: LD_INT 3
51387: EQUAL
51388: IFFALSE 51406
// begin btype := b_workshop ;
51390: LD_ADDR_VAR 0 5
51394: PUSH
51395: LD_INT 2
51397: ST_TO_ADDR
// pos := 1 ;
51398: LD_ADDR_VAR 0 6
51402: PUSH
51403: LD_INT 1
51405: ST_TO_ADDR
// end ; if btype = b_barracks then
51406: LD_VAR 0 5
51410: PUSH
51411: LD_INT 5
51413: EQUAL
51414: IFFALSE 51424
// btype := b_armoury ;
51416: LD_ADDR_VAR 0 5
51420: PUSH
51421: LD_INT 4
51423: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51424: LD_VAR 0 5
51428: PUSH
51429: LD_INT 7
51431: PUSH
51432: LD_INT 8
51434: PUSH
51435: EMPTY
51436: LIST
51437: LIST
51438: IN
51439: IFFALSE 51449
// btype := b_lab ;
51441: LD_ADDR_VAR 0 5
51445: PUSH
51446: LD_INT 6
51448: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51449: LD_ADDR_EXP 85
51453: PUSH
51454: LD_EXP 85
51458: PPUSH
51459: LD_VAR 0 3
51463: PUSH
51464: LD_EXP 85
51468: PUSH
51469: LD_VAR 0 3
51473: ARRAY
51474: PUSH
51475: LD_INT 1
51477: PLUS
51478: PUSH
51479: EMPTY
51480: LIST
51481: LIST
51482: PPUSH
51483: LD_VAR 0 5
51487: PUSH
51488: LD_VAR 0 1
51492: PPUSH
51493: CALL_OW 250
51497: PUSH
51498: LD_VAR 0 1
51502: PPUSH
51503: CALL_OW 251
51507: PUSH
51508: LD_VAR 0 1
51512: PPUSH
51513: CALL_OW 254
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: LIST
51522: LIST
51523: PPUSH
51524: CALL 58539 0 3
51528: ST_TO_ADDR
// if pos = 1 then
51529: LD_VAR 0 6
51533: PUSH
51534: LD_INT 1
51536: EQUAL
51537: IFFALSE 51652
// begin tmp := mc_build_list [ i ] ;
51539: LD_ADDR_VAR 0 7
51543: PUSH
51544: LD_EXP 85
51548: PUSH
51549: LD_VAR 0 3
51553: ARRAY
51554: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51555: LD_VAR 0 7
51559: PPUSH
51560: LD_INT 2
51562: PUSH
51563: LD_INT 30
51565: PUSH
51566: LD_INT 0
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: PUSH
51573: LD_INT 30
51575: PUSH
51576: LD_INT 1
51578: PUSH
51579: EMPTY
51580: LIST
51581: LIST
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: LIST
51587: PPUSH
51588: CALL_OW 72
51592: IFFALSE 51602
// pos := 2 ;
51594: LD_ADDR_VAR 0 6
51598: PUSH
51599: LD_INT 2
51601: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51602: LD_ADDR_VAR 0 7
51606: PUSH
51607: LD_VAR 0 7
51611: PPUSH
51612: LD_VAR 0 6
51616: PPUSH
51617: LD_VAR 0 7
51621: PPUSH
51622: CALL 58865 0 3
51626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51627: LD_ADDR_EXP 85
51631: PUSH
51632: LD_EXP 85
51636: PPUSH
51637: LD_VAR 0 3
51641: PPUSH
51642: LD_VAR 0 7
51646: PPUSH
51647: CALL_OW 1
51651: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51652: LD_VAR 0 1
51656: PUSH
51657: LD_EXP 80
51661: PUSH
51662: LD_VAR 0 3
51666: ARRAY
51667: IN
51668: IFFALSE 51707
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51670: LD_ADDR_EXP 80
51674: PUSH
51675: LD_EXP 80
51679: PPUSH
51680: LD_VAR 0 3
51684: PPUSH
51685: LD_EXP 80
51689: PUSH
51690: LD_VAR 0 3
51694: ARRAY
51695: PUSH
51696: LD_VAR 0 1
51700: DIFF
51701: PPUSH
51702: CALL_OW 1
51706: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51707: LD_VAR 0 1
51711: PUSH
51712: LD_EXP 87
51716: PUSH
51717: LD_VAR 0 3
51721: ARRAY
51722: IN
51723: IFFALSE 51762
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51725: LD_ADDR_EXP 87
51729: PUSH
51730: LD_EXP 87
51734: PPUSH
51735: LD_VAR 0 3
51739: PPUSH
51740: LD_EXP 87
51744: PUSH
51745: LD_VAR 0 3
51749: ARRAY
51750: PUSH
51751: LD_VAR 0 1
51755: DIFF
51756: PPUSH
51757: CALL_OW 1
51761: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51762: LD_VAR 0 1
51766: PUSH
51767: LD_EXP 99
51771: PUSH
51772: LD_VAR 0 3
51776: ARRAY
51777: IN
51778: IFFALSE 51817
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51780: LD_ADDR_EXP 99
51784: PUSH
51785: LD_EXP 99
51789: PPUSH
51790: LD_VAR 0 3
51794: PPUSH
51795: LD_EXP 99
51799: PUSH
51800: LD_VAR 0 3
51804: ARRAY
51805: PUSH
51806: LD_VAR 0 1
51810: DIFF
51811: PPUSH
51812: CALL_OW 1
51816: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51817: LD_VAR 0 1
51821: PUSH
51822: LD_EXP 102
51826: PUSH
51827: LD_VAR 0 3
51831: ARRAY
51832: IN
51833: IFFALSE 51872
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51835: LD_ADDR_EXP 102
51839: PUSH
51840: LD_EXP 102
51844: PPUSH
51845: LD_VAR 0 3
51849: PPUSH
51850: LD_EXP 102
51854: PUSH
51855: LD_VAR 0 3
51859: ARRAY
51860: PUSH
51861: LD_VAR 0 1
51865: DIFF
51866: PPUSH
51867: CALL_OW 1
51871: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51872: LD_VAR 0 1
51876: PUSH
51877: LD_EXP 89
51881: PUSH
51882: LD_VAR 0 3
51886: ARRAY
51887: IN
51888: IFFALSE 51927
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51890: LD_ADDR_EXP 89
51894: PUSH
51895: LD_EXP 89
51899: PPUSH
51900: LD_VAR 0 3
51904: PPUSH
51905: LD_EXP 89
51909: PUSH
51910: LD_VAR 0 3
51914: ARRAY
51915: PUSH
51916: LD_VAR 0 1
51920: DIFF
51921: PPUSH
51922: CALL_OW 1
51926: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51927: LD_VAR 0 1
51931: PUSH
51932: LD_EXP 88
51936: PUSH
51937: LD_VAR 0 3
51941: ARRAY
51942: IN
51943: IFFALSE 51982
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51945: LD_ADDR_EXP 88
51949: PUSH
51950: LD_EXP 88
51954: PPUSH
51955: LD_VAR 0 3
51959: PPUSH
51960: LD_EXP 88
51964: PUSH
51965: LD_VAR 0 3
51969: ARRAY
51970: PUSH
51971: LD_VAR 0 1
51975: DIFF
51976: PPUSH
51977: CALL_OW 1
51981: ST_TO_ADDR
// end ; break ;
51982: GO 51986
// end ;
51984: GO 50634
51986: POP
51987: POP
// end ;
51988: LD_VAR 0 2
51992: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51993: LD_INT 0
51995: PPUSH
51996: PPUSH
51997: PPUSH
// if not mc_bases or not skirmish then
51998: LD_EXP 80
52002: NOT
52003: PUSH
52004: LD_EXP 78
52008: NOT
52009: OR
52010: IFFALSE 52014
// exit ;
52012: GO 52229
// for i = 1 to mc_bases do
52014: LD_ADDR_VAR 0 3
52018: PUSH
52019: DOUBLE
52020: LD_INT 1
52022: DEC
52023: ST_TO_ADDR
52024: LD_EXP 80
52028: PUSH
52029: FOR_TO
52030: IFFALSE 52227
// begin if building in mc_construct_list [ i ] then
52032: LD_VAR 0 1
52036: PUSH
52037: LD_EXP 87
52041: PUSH
52042: LD_VAR 0 3
52046: ARRAY
52047: IN
52048: IFFALSE 52225
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52050: LD_ADDR_EXP 87
52054: PUSH
52055: LD_EXP 87
52059: PPUSH
52060: LD_VAR 0 3
52064: PPUSH
52065: LD_EXP 87
52069: PUSH
52070: LD_VAR 0 3
52074: ARRAY
52075: PUSH
52076: LD_VAR 0 1
52080: DIFF
52081: PPUSH
52082: CALL_OW 1
52086: ST_TO_ADDR
// if building in mc_lab [ i ] then
52087: LD_VAR 0 1
52091: PUSH
52092: LD_EXP 113
52096: PUSH
52097: LD_VAR 0 3
52101: ARRAY
52102: IN
52103: IFFALSE 52158
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52105: LD_ADDR_EXP 114
52109: PUSH
52110: LD_EXP 114
52114: PPUSH
52115: LD_VAR 0 3
52119: PPUSH
52120: LD_EXP 114
52124: PUSH
52125: LD_VAR 0 3
52129: ARRAY
52130: PPUSH
52131: LD_INT 1
52133: PPUSH
52134: LD_EXP 114
52138: PUSH
52139: LD_VAR 0 3
52143: ARRAY
52144: PPUSH
52145: LD_INT 0
52147: PPUSH
52148: CALL 57957 0 4
52152: PPUSH
52153: CALL_OW 1
52157: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52158: LD_VAR 0 1
52162: PUSH
52163: LD_EXP 80
52167: PUSH
52168: LD_VAR 0 3
52172: ARRAY
52173: IN
52174: NOT
52175: IFFALSE 52221
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52177: LD_ADDR_EXP 80
52181: PUSH
52182: LD_EXP 80
52186: PPUSH
52187: LD_VAR 0 3
52191: PUSH
52192: LD_EXP 80
52196: PUSH
52197: LD_VAR 0 3
52201: ARRAY
52202: PUSH
52203: LD_INT 1
52205: PLUS
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: PPUSH
52211: LD_VAR 0 1
52215: PPUSH
52216: CALL 58539 0 3
52220: ST_TO_ADDR
// exit ;
52221: POP
52222: POP
52223: GO 52229
// end ; end ;
52225: GO 52029
52227: POP
52228: POP
// end ;
52229: LD_VAR 0 2
52233: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
52234: LD_INT 0
52236: PPUSH
52237: PPUSH
52238: PPUSH
52239: PPUSH
52240: PPUSH
52241: PPUSH
52242: PPUSH
// if not mc_bases or not skirmish then
52243: LD_EXP 80
52247: NOT
52248: PUSH
52249: LD_EXP 78
52253: NOT
52254: OR
52255: IFFALSE 52259
// exit ;
52257: GO 52920
// for i = 1 to mc_bases do
52259: LD_ADDR_VAR 0 3
52263: PUSH
52264: DOUBLE
52265: LD_INT 1
52267: DEC
52268: ST_TO_ADDR
52269: LD_EXP 80
52273: PUSH
52274: FOR_TO
52275: IFFALSE 52918
// begin if building in mc_construct_list [ i ] then
52277: LD_VAR 0 1
52281: PUSH
52282: LD_EXP 87
52286: PUSH
52287: LD_VAR 0 3
52291: ARRAY
52292: IN
52293: IFFALSE 52916
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52295: LD_ADDR_EXP 87
52299: PUSH
52300: LD_EXP 87
52304: PPUSH
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_EXP 87
52314: PUSH
52315: LD_VAR 0 3
52319: ARRAY
52320: PUSH
52321: LD_VAR 0 1
52325: DIFF
52326: PPUSH
52327: CALL_OW 1
52331: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52332: LD_ADDR_EXP 80
52336: PUSH
52337: LD_EXP 80
52341: PPUSH
52342: LD_VAR 0 3
52346: PUSH
52347: LD_EXP 80
52351: PUSH
52352: LD_VAR 0 3
52356: ARRAY
52357: PUSH
52358: LD_INT 1
52360: PLUS
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: PPUSH
52366: LD_VAR 0 1
52370: PPUSH
52371: CALL 58539 0 3
52375: ST_TO_ADDR
// btype := GetBType ( building ) ;
52376: LD_ADDR_VAR 0 5
52380: PUSH
52381: LD_VAR 0 1
52385: PPUSH
52386: CALL_OW 266
52390: ST_TO_ADDR
// side := GetSide ( building ) ;
52391: LD_ADDR_VAR 0 8
52395: PUSH
52396: LD_VAR 0 1
52400: PPUSH
52401: CALL_OW 255
52405: ST_TO_ADDR
// if btype = b_lab then
52406: LD_VAR 0 5
52410: PUSH
52411: LD_INT 6
52413: EQUAL
52414: IFFALSE 52464
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52416: LD_ADDR_EXP 113
52420: PUSH
52421: LD_EXP 113
52425: PPUSH
52426: LD_VAR 0 3
52430: PUSH
52431: LD_EXP 113
52435: PUSH
52436: LD_VAR 0 3
52440: ARRAY
52441: PUSH
52442: LD_INT 1
52444: PLUS
52445: PUSH
52446: EMPTY
52447: LIST
52448: LIST
52449: PPUSH
52450: LD_VAR 0 1
52454: PPUSH
52455: CALL 58539 0 3
52459: ST_TO_ADDR
// exit ;
52460: POP
52461: POP
52462: GO 52920
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52464: LD_VAR 0 5
52468: PUSH
52469: LD_INT 0
52471: PUSH
52472: LD_INT 2
52474: PUSH
52475: LD_INT 4
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: LIST
52482: IN
52483: IFFALSE 52607
// begin if btype = b_armoury then
52485: LD_VAR 0 5
52489: PUSH
52490: LD_INT 4
52492: EQUAL
52493: IFFALSE 52503
// btype := b_barracks ;
52495: LD_ADDR_VAR 0 5
52499: PUSH
52500: LD_INT 5
52502: ST_TO_ADDR
// if btype = b_depot then
52503: LD_VAR 0 5
52507: PUSH
52508: LD_INT 0
52510: EQUAL
52511: IFFALSE 52521
// btype := b_warehouse ;
52513: LD_ADDR_VAR 0 5
52517: PUSH
52518: LD_INT 1
52520: ST_TO_ADDR
// if btype = b_workshop then
52521: LD_VAR 0 5
52525: PUSH
52526: LD_INT 2
52528: EQUAL
52529: IFFALSE 52539
// btype := b_factory ;
52531: LD_ADDR_VAR 0 5
52535: PUSH
52536: LD_INT 3
52538: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52539: LD_VAR 0 5
52543: PPUSH
52544: LD_VAR 0 8
52548: PPUSH
52549: CALL_OW 323
52553: PUSH
52554: LD_INT 1
52556: EQUAL
52557: IFFALSE 52603
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52559: LD_ADDR_EXP 112
52563: PUSH
52564: LD_EXP 112
52568: PPUSH
52569: LD_VAR 0 3
52573: PUSH
52574: LD_EXP 112
52578: PUSH
52579: LD_VAR 0 3
52583: ARRAY
52584: PUSH
52585: LD_INT 1
52587: PLUS
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: PPUSH
52593: LD_VAR 0 1
52597: PPUSH
52598: CALL 58539 0 3
52602: ST_TO_ADDR
// exit ;
52603: POP
52604: POP
52605: GO 52920
// end ; if btype in [ b_bunker , b_turret ] then
52607: LD_VAR 0 5
52611: PUSH
52612: LD_INT 32
52614: PUSH
52615: LD_INT 33
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: IN
52622: IFFALSE 52912
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52624: LD_ADDR_EXP 88
52628: PUSH
52629: LD_EXP 88
52633: PPUSH
52634: LD_VAR 0 3
52638: PUSH
52639: LD_EXP 88
52643: PUSH
52644: LD_VAR 0 3
52648: ARRAY
52649: PUSH
52650: LD_INT 1
52652: PLUS
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PPUSH
52658: LD_VAR 0 1
52662: PPUSH
52663: CALL 58539 0 3
52667: ST_TO_ADDR
// if btype = b_bunker then
52668: LD_VAR 0 5
52672: PUSH
52673: LD_INT 32
52675: EQUAL
52676: IFFALSE 52912
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52678: LD_ADDR_EXP 89
52682: PUSH
52683: LD_EXP 89
52687: PPUSH
52688: LD_VAR 0 3
52692: PUSH
52693: LD_EXP 89
52697: PUSH
52698: LD_VAR 0 3
52702: ARRAY
52703: PUSH
52704: LD_INT 1
52706: PLUS
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PPUSH
52712: LD_VAR 0 1
52716: PPUSH
52717: CALL 58539 0 3
52721: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52722: LD_ADDR_VAR 0 6
52726: PUSH
52727: LD_EXP 80
52731: PUSH
52732: LD_VAR 0 3
52736: ARRAY
52737: PPUSH
52738: LD_INT 25
52740: PUSH
52741: LD_INT 1
52743: PUSH
52744: EMPTY
52745: LIST
52746: LIST
52747: PUSH
52748: LD_INT 3
52750: PUSH
52751: LD_INT 54
52753: PUSH
52754: EMPTY
52755: LIST
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: PPUSH
52765: CALL_OW 72
52769: ST_TO_ADDR
// if tmp then
52770: LD_VAR 0 6
52774: IFFALSE 52780
// exit ;
52776: POP
52777: POP
52778: GO 52920
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52780: LD_ADDR_VAR 0 6
52784: PUSH
52785: LD_EXP 80
52789: PUSH
52790: LD_VAR 0 3
52794: ARRAY
52795: PPUSH
52796: LD_INT 2
52798: PUSH
52799: LD_INT 30
52801: PUSH
52802: LD_INT 4
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 30
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 72
52828: ST_TO_ADDR
// if not tmp then
52829: LD_VAR 0 6
52833: NOT
52834: IFFALSE 52840
// exit ;
52836: POP
52837: POP
52838: GO 52920
// for j in tmp do
52840: LD_ADDR_VAR 0 4
52844: PUSH
52845: LD_VAR 0 6
52849: PUSH
52850: FOR_IN
52851: IFFALSE 52910
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 4
52862: PPUSH
52863: CALL_OW 313
52867: PPUSH
52868: LD_INT 25
52870: PUSH
52871: LD_INT 1
52873: PUSH
52874: EMPTY
52875: LIST
52876: LIST
52877: PPUSH
52878: CALL_OW 72
52882: ST_TO_ADDR
// if units then
52883: LD_VAR 0 7
52887: IFFALSE 52908
// begin ComExitBuilding ( units [ 1 ] ) ;
52889: LD_VAR 0 7
52893: PUSH
52894: LD_INT 1
52896: ARRAY
52897: PPUSH
52898: CALL_OW 122
// exit ;
52902: POP
52903: POP
52904: POP
52905: POP
52906: GO 52920
// end ; end ;
52908: GO 52850
52910: POP
52911: POP
// end ; end ; exit ;
52912: POP
52913: POP
52914: GO 52920
// end ; end ;
52916: GO 52274
52918: POP
52919: POP
// end ;
52920: LD_VAR 0 2
52924: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52925: LD_INT 0
52927: PPUSH
52928: PPUSH
52929: PPUSH
52930: PPUSH
52931: PPUSH
52932: PPUSH
52933: PPUSH
// if not mc_bases or not skirmish then
52934: LD_EXP 80
52938: NOT
52939: PUSH
52940: LD_EXP 78
52944: NOT
52945: OR
52946: IFFALSE 52950
// exit ;
52948: GO 53215
// btype := GetBType ( building ) ;
52950: LD_ADDR_VAR 0 6
52954: PUSH
52955: LD_VAR 0 1
52959: PPUSH
52960: CALL_OW 266
52964: ST_TO_ADDR
// x := GetX ( building ) ;
52965: LD_ADDR_VAR 0 7
52969: PUSH
52970: LD_VAR 0 1
52974: PPUSH
52975: CALL_OW 250
52979: ST_TO_ADDR
// y := GetY ( building ) ;
52980: LD_ADDR_VAR 0 8
52984: PUSH
52985: LD_VAR 0 1
52989: PPUSH
52990: CALL_OW 251
52994: ST_TO_ADDR
// d := GetDir ( building ) ;
52995: LD_ADDR_VAR 0 9
52999: PUSH
53000: LD_VAR 0 1
53004: PPUSH
53005: CALL_OW 254
53009: ST_TO_ADDR
// for i = 1 to mc_bases do
53010: LD_ADDR_VAR 0 4
53014: PUSH
53015: DOUBLE
53016: LD_INT 1
53018: DEC
53019: ST_TO_ADDR
53020: LD_EXP 80
53024: PUSH
53025: FOR_TO
53026: IFFALSE 53213
// begin if not mc_build_list [ i ] then
53028: LD_EXP 85
53032: PUSH
53033: LD_VAR 0 4
53037: ARRAY
53038: NOT
53039: IFFALSE 53043
// continue ;
53041: GO 53025
// for j := 1 to mc_build_list [ i ] do
53043: LD_ADDR_VAR 0 5
53047: PUSH
53048: DOUBLE
53049: LD_INT 1
53051: DEC
53052: ST_TO_ADDR
53053: LD_EXP 85
53057: PUSH
53058: LD_VAR 0 4
53062: ARRAY
53063: PUSH
53064: FOR_TO
53065: IFFALSE 53209
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
53067: LD_VAR 0 6
53071: PUSH
53072: LD_VAR 0 7
53076: PUSH
53077: LD_VAR 0 8
53081: PUSH
53082: LD_VAR 0 9
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: LIST
53091: LIST
53092: PPUSH
53093: LD_EXP 85
53097: PUSH
53098: LD_VAR 0 4
53102: ARRAY
53103: PUSH
53104: LD_VAR 0 5
53108: ARRAY
53109: PPUSH
53110: CALL 65096 0 2
53114: IFFALSE 53207
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
53116: LD_ADDR_EXP 85
53120: PUSH
53121: LD_EXP 85
53125: PPUSH
53126: LD_VAR 0 4
53130: PPUSH
53131: LD_EXP 85
53135: PUSH
53136: LD_VAR 0 4
53140: ARRAY
53141: PPUSH
53142: LD_VAR 0 5
53146: PPUSH
53147: CALL_OW 3
53151: PPUSH
53152: CALL_OW 1
53156: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53157: LD_ADDR_EXP 87
53161: PUSH
53162: LD_EXP 87
53166: PPUSH
53167: LD_VAR 0 4
53171: PUSH
53172: LD_EXP 87
53176: PUSH
53177: LD_VAR 0 4
53181: ARRAY
53182: PUSH
53183: LD_INT 1
53185: PLUS
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: PPUSH
53191: LD_VAR 0 1
53195: PPUSH
53196: CALL 58539 0 3
53200: ST_TO_ADDR
// exit ;
53201: POP
53202: POP
53203: POP
53204: POP
53205: GO 53215
// end ;
53207: GO 53064
53209: POP
53210: POP
// end ;
53211: GO 53025
53213: POP
53214: POP
// end ;
53215: LD_VAR 0 3
53219: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
53220: LD_INT 0
53222: PPUSH
53223: PPUSH
53224: PPUSH
// if not mc_bases or not skirmish then
53225: LD_EXP 80
53229: NOT
53230: PUSH
53231: LD_EXP 78
53235: NOT
53236: OR
53237: IFFALSE 53241
// exit ;
53239: GO 53431
// for i = 1 to mc_bases do
53241: LD_ADDR_VAR 0 4
53245: PUSH
53246: DOUBLE
53247: LD_INT 1
53249: DEC
53250: ST_TO_ADDR
53251: LD_EXP 80
53255: PUSH
53256: FOR_TO
53257: IFFALSE 53344
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53259: LD_VAR 0 1
53263: PUSH
53264: LD_EXP 88
53268: PUSH
53269: LD_VAR 0 4
53273: ARRAY
53274: IN
53275: PUSH
53276: LD_VAR 0 1
53280: PUSH
53281: LD_EXP 89
53285: PUSH
53286: LD_VAR 0 4
53290: ARRAY
53291: IN
53292: NOT
53293: AND
53294: IFFALSE 53342
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53296: LD_ADDR_EXP 89
53300: PUSH
53301: LD_EXP 89
53305: PPUSH
53306: LD_VAR 0 4
53310: PUSH
53311: LD_EXP 89
53315: PUSH
53316: LD_VAR 0 4
53320: ARRAY
53321: PUSH
53322: LD_INT 1
53324: PLUS
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: LD_VAR 0 1
53334: PPUSH
53335: CALL 58539 0 3
53339: ST_TO_ADDR
// break ;
53340: GO 53344
// end ; end ;
53342: GO 53256
53344: POP
53345: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53346: LD_VAR 0 1
53350: PPUSH
53351: CALL_OW 257
53355: PUSH
53356: LD_EXP 106
53360: IN
53361: PUSH
53362: LD_VAR 0 1
53366: PPUSH
53367: CALL_OW 266
53371: PUSH
53372: LD_INT 5
53374: EQUAL
53375: AND
53376: PUSH
53377: LD_VAR 0 2
53381: PPUSH
53382: CALL_OW 110
53386: PUSH
53387: LD_INT 18
53389: NONEQUAL
53390: AND
53391: IFFALSE 53431
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53393: LD_VAR 0 2
53397: PPUSH
53398: CALL_OW 257
53402: PUSH
53403: LD_INT 5
53405: PUSH
53406: LD_INT 8
53408: PUSH
53409: LD_INT 9
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: LIST
53416: IN
53417: IFFALSE 53431
// SetClass ( unit , 1 ) ;
53419: LD_VAR 0 2
53423: PPUSH
53424: LD_INT 1
53426: PPUSH
53427: CALL_OW 336
// end ;
53431: LD_VAR 0 3
53435: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53436: LD_INT 0
53438: PPUSH
53439: PPUSH
// if not mc_bases or not skirmish then
53440: LD_EXP 80
53444: NOT
53445: PUSH
53446: LD_EXP 78
53450: NOT
53451: OR
53452: IFFALSE 53456
// exit ;
53454: GO 53572
// if GetLives ( abandoned_vehicle ) > 250 then
53456: LD_VAR 0 2
53460: PPUSH
53461: CALL_OW 256
53465: PUSH
53466: LD_INT 250
53468: GREATER
53469: IFFALSE 53473
// exit ;
53471: GO 53572
// for i = 1 to mc_bases do
53473: LD_ADDR_VAR 0 6
53477: PUSH
53478: DOUBLE
53479: LD_INT 1
53481: DEC
53482: ST_TO_ADDR
53483: LD_EXP 80
53487: PUSH
53488: FOR_TO
53489: IFFALSE 53570
// begin if driver in mc_bases [ i ] then
53491: LD_VAR 0 1
53495: PUSH
53496: LD_EXP 80
53500: PUSH
53501: LD_VAR 0 6
53505: ARRAY
53506: IN
53507: IFFALSE 53568
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53509: LD_VAR 0 1
53513: PPUSH
53514: LD_EXP 80
53518: PUSH
53519: LD_VAR 0 6
53523: ARRAY
53524: PPUSH
53525: LD_INT 2
53527: PUSH
53528: LD_INT 30
53530: PUSH
53531: LD_INT 0
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: PUSH
53538: LD_INT 30
53540: PUSH
53541: LD_INT 1
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: LIST
53552: PPUSH
53553: CALL_OW 72
53557: PUSH
53558: LD_INT 1
53560: ARRAY
53561: PPUSH
53562: CALL 92145 0 2
// break ;
53566: GO 53570
// end ; end ;
53568: GO 53488
53570: POP
53571: POP
// end ; end_of_file
53572: LD_VAR 0 5
53576: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53577: LD_INT 0
53579: PPUSH
53580: PPUSH
// if exist_mode then
53581: LD_VAR 0 2
53585: IFFALSE 53610
// unit := CreateCharacter ( prefix & ident ) else
53587: LD_ADDR_VAR 0 5
53591: PUSH
53592: LD_VAR 0 3
53596: PUSH
53597: LD_VAR 0 1
53601: STR
53602: PPUSH
53603: CALL_OW 34
53607: ST_TO_ADDR
53608: GO 53625
// unit := NewCharacter ( ident ) ;
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 1
53619: PPUSH
53620: CALL_OW 25
53624: ST_TO_ADDR
// result := unit ;
53625: LD_ADDR_VAR 0 4
53629: PUSH
53630: LD_VAR 0 5
53634: ST_TO_ADDR
// end ;
53635: LD_VAR 0 4
53639: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53640: LD_INT 0
53642: PPUSH
53643: PPUSH
// if not side or not nation then
53644: LD_VAR 0 1
53648: NOT
53649: PUSH
53650: LD_VAR 0 2
53654: NOT
53655: OR
53656: IFFALSE 53660
// exit ;
53658: GO 54428
// case nation of nation_american :
53660: LD_VAR 0 2
53664: PUSH
53665: LD_INT 1
53667: DOUBLE
53668: EQUAL
53669: IFTRUE 53673
53671: GO 53887
53673: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53674: LD_ADDR_VAR 0 4
53678: PUSH
53679: LD_INT 35
53681: PUSH
53682: LD_INT 45
53684: PUSH
53685: LD_INT 46
53687: PUSH
53688: LD_INT 47
53690: PUSH
53691: LD_INT 82
53693: PUSH
53694: LD_INT 83
53696: PUSH
53697: LD_INT 84
53699: PUSH
53700: LD_INT 85
53702: PUSH
53703: LD_INT 86
53705: PUSH
53706: LD_INT 1
53708: PUSH
53709: LD_INT 2
53711: PUSH
53712: LD_INT 6
53714: PUSH
53715: LD_INT 15
53717: PUSH
53718: LD_INT 16
53720: PUSH
53721: LD_INT 7
53723: PUSH
53724: LD_INT 12
53726: PUSH
53727: LD_INT 13
53729: PUSH
53730: LD_INT 10
53732: PUSH
53733: LD_INT 14
53735: PUSH
53736: LD_INT 20
53738: PUSH
53739: LD_INT 21
53741: PUSH
53742: LD_INT 22
53744: PUSH
53745: LD_INT 25
53747: PUSH
53748: LD_INT 32
53750: PUSH
53751: LD_INT 27
53753: PUSH
53754: LD_INT 36
53756: PUSH
53757: LD_INT 69
53759: PUSH
53760: LD_INT 39
53762: PUSH
53763: LD_INT 34
53765: PUSH
53766: LD_INT 40
53768: PUSH
53769: LD_INT 48
53771: PUSH
53772: LD_INT 49
53774: PUSH
53775: LD_INT 50
53777: PUSH
53778: LD_INT 51
53780: PUSH
53781: LD_INT 52
53783: PUSH
53784: LD_INT 53
53786: PUSH
53787: LD_INT 54
53789: PUSH
53790: LD_INT 55
53792: PUSH
53793: LD_INT 56
53795: PUSH
53796: LD_INT 57
53798: PUSH
53799: LD_INT 58
53801: PUSH
53802: LD_INT 59
53804: PUSH
53805: LD_INT 60
53807: PUSH
53808: LD_INT 61
53810: PUSH
53811: LD_INT 62
53813: PUSH
53814: LD_INT 80
53816: PUSH
53817: LD_INT 82
53819: PUSH
53820: LD_INT 83
53822: PUSH
53823: LD_INT 84
53825: PUSH
53826: LD_INT 85
53828: PUSH
53829: LD_INT 86
53831: PUSH
53832: EMPTY
53833: LIST
53834: LIST
53835: LIST
53836: LIST
53837: LIST
53838: LIST
53839: LIST
53840: LIST
53841: LIST
53842: LIST
53843: LIST
53844: LIST
53845: LIST
53846: LIST
53847: LIST
53848: LIST
53849: LIST
53850: LIST
53851: LIST
53852: LIST
53853: LIST
53854: LIST
53855: LIST
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: LIST
53861: LIST
53862: LIST
53863: LIST
53864: LIST
53865: LIST
53866: LIST
53867: LIST
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: LIST
53873: LIST
53874: LIST
53875: LIST
53876: LIST
53877: LIST
53878: LIST
53879: LIST
53880: LIST
53881: LIST
53882: LIST
53883: LIST
53884: ST_TO_ADDR
53885: GO 54352
53887: LD_INT 2
53889: DOUBLE
53890: EQUAL
53891: IFTRUE 53895
53893: GO 54121
53895: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53896: LD_ADDR_VAR 0 4
53900: PUSH
53901: LD_INT 35
53903: PUSH
53904: LD_INT 45
53906: PUSH
53907: LD_INT 46
53909: PUSH
53910: LD_INT 47
53912: PUSH
53913: LD_INT 82
53915: PUSH
53916: LD_INT 83
53918: PUSH
53919: LD_INT 84
53921: PUSH
53922: LD_INT 85
53924: PUSH
53925: LD_INT 87
53927: PUSH
53928: LD_INT 70
53930: PUSH
53931: LD_INT 1
53933: PUSH
53934: LD_INT 11
53936: PUSH
53937: LD_INT 3
53939: PUSH
53940: LD_INT 4
53942: PUSH
53943: LD_INT 5
53945: PUSH
53946: LD_INT 6
53948: PUSH
53949: LD_INT 15
53951: PUSH
53952: LD_INT 18
53954: PUSH
53955: LD_INT 7
53957: PUSH
53958: LD_INT 17
53960: PUSH
53961: LD_INT 8
53963: PUSH
53964: LD_INT 20
53966: PUSH
53967: LD_INT 21
53969: PUSH
53970: LD_INT 22
53972: PUSH
53973: LD_INT 72
53975: PUSH
53976: LD_INT 26
53978: PUSH
53979: LD_INT 69
53981: PUSH
53982: LD_INT 39
53984: PUSH
53985: LD_INT 40
53987: PUSH
53988: LD_INT 41
53990: PUSH
53991: LD_INT 42
53993: PUSH
53994: LD_INT 43
53996: PUSH
53997: LD_INT 48
53999: PUSH
54000: LD_INT 49
54002: PUSH
54003: LD_INT 50
54005: PUSH
54006: LD_INT 51
54008: PUSH
54009: LD_INT 52
54011: PUSH
54012: LD_INT 53
54014: PUSH
54015: LD_INT 54
54017: PUSH
54018: LD_INT 55
54020: PUSH
54021: LD_INT 56
54023: PUSH
54024: LD_INT 60
54026: PUSH
54027: LD_INT 61
54029: PUSH
54030: LD_INT 62
54032: PUSH
54033: LD_INT 66
54035: PUSH
54036: LD_INT 67
54038: PUSH
54039: LD_INT 68
54041: PUSH
54042: LD_INT 81
54044: PUSH
54045: LD_INT 82
54047: PUSH
54048: LD_INT 83
54050: PUSH
54051: LD_INT 84
54053: PUSH
54054: LD_INT 85
54056: PUSH
54057: LD_INT 87
54059: PUSH
54060: LD_INT 88
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: LIST
54085: LIST
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: LIST
54107: LIST
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: LIST
54113: LIST
54114: LIST
54115: LIST
54116: LIST
54117: LIST
54118: ST_TO_ADDR
54119: GO 54352
54121: LD_INT 3
54123: DOUBLE
54124: EQUAL
54125: IFTRUE 54129
54127: GO 54351
54129: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
54130: LD_ADDR_VAR 0 4
54134: PUSH
54135: LD_INT 46
54137: PUSH
54138: LD_INT 47
54140: PUSH
54141: LD_INT 1
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: LD_INT 82
54149: PUSH
54150: LD_INT 83
54152: PUSH
54153: LD_INT 84
54155: PUSH
54156: LD_INT 85
54158: PUSH
54159: LD_INT 86
54161: PUSH
54162: LD_INT 11
54164: PUSH
54165: LD_INT 9
54167: PUSH
54168: LD_INT 20
54170: PUSH
54171: LD_INT 19
54173: PUSH
54174: LD_INT 21
54176: PUSH
54177: LD_INT 24
54179: PUSH
54180: LD_INT 22
54182: PUSH
54183: LD_INT 25
54185: PUSH
54186: LD_INT 28
54188: PUSH
54189: LD_INT 29
54191: PUSH
54192: LD_INT 30
54194: PUSH
54195: LD_INT 31
54197: PUSH
54198: LD_INT 37
54200: PUSH
54201: LD_INT 38
54203: PUSH
54204: LD_INT 32
54206: PUSH
54207: LD_INT 27
54209: PUSH
54210: LD_INT 33
54212: PUSH
54213: LD_INT 69
54215: PUSH
54216: LD_INT 39
54218: PUSH
54219: LD_INT 34
54221: PUSH
54222: LD_INT 40
54224: PUSH
54225: LD_INT 71
54227: PUSH
54228: LD_INT 23
54230: PUSH
54231: LD_INT 44
54233: PUSH
54234: LD_INT 48
54236: PUSH
54237: LD_INT 49
54239: PUSH
54240: LD_INT 50
54242: PUSH
54243: LD_INT 51
54245: PUSH
54246: LD_INT 52
54248: PUSH
54249: LD_INT 53
54251: PUSH
54252: LD_INT 54
54254: PUSH
54255: LD_INT 55
54257: PUSH
54258: LD_INT 56
54260: PUSH
54261: LD_INT 57
54263: PUSH
54264: LD_INT 58
54266: PUSH
54267: LD_INT 59
54269: PUSH
54270: LD_INT 63
54272: PUSH
54273: LD_INT 64
54275: PUSH
54276: LD_INT 65
54278: PUSH
54279: LD_INT 82
54281: PUSH
54282: LD_INT 83
54284: PUSH
54285: LD_INT 84
54287: PUSH
54288: LD_INT 85
54290: PUSH
54291: LD_INT 86
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: LIST
54300: LIST
54301: LIST
54302: LIST
54303: LIST
54304: LIST
54305: LIST
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: LIST
54315: LIST
54316: LIST
54317: LIST
54318: LIST
54319: LIST
54320: LIST
54321: LIST
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: LIST
54328: LIST
54329: LIST
54330: LIST
54331: LIST
54332: LIST
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: LIST
54338: LIST
54339: LIST
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: LIST
54347: LIST
54348: ST_TO_ADDR
54349: GO 54352
54351: POP
// if state > - 1 and state < 3 then
54352: LD_VAR 0 3
54356: PUSH
54357: LD_INT 1
54359: NEG
54360: GREATER
54361: PUSH
54362: LD_VAR 0 3
54366: PUSH
54367: LD_INT 3
54369: LESS
54370: AND
54371: IFFALSE 54428
// for i in result do
54373: LD_ADDR_VAR 0 5
54377: PUSH
54378: LD_VAR 0 4
54382: PUSH
54383: FOR_IN
54384: IFFALSE 54426
// if GetTech ( i , side ) <> state then
54386: LD_VAR 0 5
54390: PPUSH
54391: LD_VAR 0 1
54395: PPUSH
54396: CALL_OW 321
54400: PUSH
54401: LD_VAR 0 3
54405: NONEQUAL
54406: IFFALSE 54424
// result := result diff i ;
54408: LD_ADDR_VAR 0 4
54412: PUSH
54413: LD_VAR 0 4
54417: PUSH
54418: LD_VAR 0 5
54422: DIFF
54423: ST_TO_ADDR
54424: GO 54383
54426: POP
54427: POP
// end ;
54428: LD_VAR 0 4
54432: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54433: LD_INT 0
54435: PPUSH
54436: PPUSH
54437: PPUSH
// result := true ;
54438: LD_ADDR_VAR 0 3
54442: PUSH
54443: LD_INT 1
54445: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54446: LD_ADDR_VAR 0 5
54450: PUSH
54451: LD_VAR 0 2
54455: PPUSH
54456: CALL_OW 480
54460: ST_TO_ADDR
// if not tmp then
54461: LD_VAR 0 5
54465: NOT
54466: IFFALSE 54470
// exit ;
54468: GO 54519
// for i in tmp do
54470: LD_ADDR_VAR 0 4
54474: PUSH
54475: LD_VAR 0 5
54479: PUSH
54480: FOR_IN
54481: IFFALSE 54517
// if GetTech ( i , side ) <> state_researched then
54483: LD_VAR 0 4
54487: PPUSH
54488: LD_VAR 0 1
54492: PPUSH
54493: CALL_OW 321
54497: PUSH
54498: LD_INT 2
54500: NONEQUAL
54501: IFFALSE 54515
// begin result := false ;
54503: LD_ADDR_VAR 0 3
54507: PUSH
54508: LD_INT 0
54510: ST_TO_ADDR
// exit ;
54511: POP
54512: POP
54513: GO 54519
// end ;
54515: GO 54480
54517: POP
54518: POP
// end ;
54519: LD_VAR 0 3
54523: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54524: LD_INT 0
54526: PPUSH
54527: PPUSH
54528: PPUSH
54529: PPUSH
54530: PPUSH
54531: PPUSH
54532: PPUSH
54533: PPUSH
54534: PPUSH
54535: PPUSH
54536: PPUSH
54537: PPUSH
54538: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54539: LD_VAR 0 1
54543: NOT
54544: PUSH
54545: LD_VAR 0 1
54549: PPUSH
54550: CALL_OW 257
54554: PUSH
54555: LD_INT 9
54557: NONEQUAL
54558: OR
54559: IFFALSE 54563
// exit ;
54561: GO 55136
// side := GetSide ( unit ) ;
54563: LD_ADDR_VAR 0 9
54567: PUSH
54568: LD_VAR 0 1
54572: PPUSH
54573: CALL_OW 255
54577: ST_TO_ADDR
// tech_space := tech_spacanom ;
54578: LD_ADDR_VAR 0 12
54582: PUSH
54583: LD_INT 29
54585: ST_TO_ADDR
// tech_time := tech_taurad ;
54586: LD_ADDR_VAR 0 13
54590: PUSH
54591: LD_INT 28
54593: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54594: LD_ADDR_VAR 0 11
54598: PUSH
54599: LD_VAR 0 1
54603: PPUSH
54604: CALL_OW 310
54608: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54609: LD_VAR 0 11
54613: PPUSH
54614: CALL_OW 247
54618: PUSH
54619: LD_INT 2
54621: EQUAL
54622: IFFALSE 54626
// exit ;
54624: GO 55136
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54626: LD_ADDR_VAR 0 8
54630: PUSH
54631: LD_INT 81
54633: PUSH
54634: LD_VAR 0 9
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: PUSH
54643: LD_INT 3
54645: PUSH
54646: LD_INT 21
54648: PUSH
54649: LD_INT 3
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: PUSH
54656: EMPTY
54657: LIST
54658: LIST
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PPUSH
54664: CALL_OW 69
54668: ST_TO_ADDR
// if not tmp then
54669: LD_VAR 0 8
54673: NOT
54674: IFFALSE 54678
// exit ;
54676: GO 55136
// if in_unit then
54678: LD_VAR 0 11
54682: IFFALSE 54706
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54684: LD_ADDR_VAR 0 10
54688: PUSH
54689: LD_VAR 0 8
54693: PPUSH
54694: LD_VAR 0 11
54698: PPUSH
54699: CALL_OW 74
54703: ST_TO_ADDR
54704: GO 54726
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54706: LD_ADDR_VAR 0 10
54710: PUSH
54711: LD_VAR 0 8
54715: PPUSH
54716: LD_VAR 0 1
54720: PPUSH
54721: CALL_OW 74
54725: ST_TO_ADDR
// if not enemy then
54726: LD_VAR 0 10
54730: NOT
54731: IFFALSE 54735
// exit ;
54733: GO 55136
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54735: LD_VAR 0 11
54739: PUSH
54740: LD_VAR 0 11
54744: PPUSH
54745: LD_VAR 0 10
54749: PPUSH
54750: CALL_OW 296
54754: PUSH
54755: LD_INT 13
54757: GREATER
54758: AND
54759: PUSH
54760: LD_VAR 0 1
54764: PPUSH
54765: LD_VAR 0 10
54769: PPUSH
54770: CALL_OW 296
54774: PUSH
54775: LD_INT 12
54777: GREATER
54778: OR
54779: IFFALSE 54783
// exit ;
54781: GO 55136
// missile := [ 1 ] ;
54783: LD_ADDR_VAR 0 14
54787: PUSH
54788: LD_INT 1
54790: PUSH
54791: EMPTY
54792: LIST
54793: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54794: LD_VAR 0 9
54798: PPUSH
54799: LD_VAR 0 12
54803: PPUSH
54804: CALL_OW 325
54808: IFFALSE 54837
// missile := Replace ( missile , missile + 1 , 2 ) ;
54810: LD_ADDR_VAR 0 14
54814: PUSH
54815: LD_VAR 0 14
54819: PPUSH
54820: LD_VAR 0 14
54824: PUSH
54825: LD_INT 1
54827: PLUS
54828: PPUSH
54829: LD_INT 2
54831: PPUSH
54832: CALL_OW 1
54836: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54837: LD_VAR 0 9
54841: PPUSH
54842: LD_VAR 0 13
54846: PPUSH
54847: CALL_OW 325
54851: PUSH
54852: LD_VAR 0 10
54856: PPUSH
54857: CALL_OW 255
54861: PPUSH
54862: LD_VAR 0 13
54866: PPUSH
54867: CALL_OW 325
54871: NOT
54872: AND
54873: IFFALSE 54902
// missile := Replace ( missile , missile + 1 , 3 ) ;
54875: LD_ADDR_VAR 0 14
54879: PUSH
54880: LD_VAR 0 14
54884: PPUSH
54885: LD_VAR 0 14
54889: PUSH
54890: LD_INT 1
54892: PLUS
54893: PPUSH
54894: LD_INT 3
54896: PPUSH
54897: CALL_OW 1
54901: ST_TO_ADDR
// if missile < 2 then
54902: LD_VAR 0 14
54906: PUSH
54907: LD_INT 2
54909: LESS
54910: IFFALSE 54914
// exit ;
54912: GO 55136
// x := GetX ( enemy ) ;
54914: LD_ADDR_VAR 0 4
54918: PUSH
54919: LD_VAR 0 10
54923: PPUSH
54924: CALL_OW 250
54928: ST_TO_ADDR
// y := GetY ( enemy ) ;
54929: LD_ADDR_VAR 0 5
54933: PUSH
54934: LD_VAR 0 10
54938: PPUSH
54939: CALL_OW 251
54943: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54944: LD_ADDR_VAR 0 6
54948: PUSH
54949: LD_VAR 0 4
54953: PUSH
54954: LD_INT 1
54956: NEG
54957: PPUSH
54958: LD_INT 1
54960: PPUSH
54961: CALL_OW 12
54965: PLUS
54966: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54967: LD_ADDR_VAR 0 7
54971: PUSH
54972: LD_VAR 0 5
54976: PUSH
54977: LD_INT 1
54979: NEG
54980: PPUSH
54981: LD_INT 1
54983: PPUSH
54984: CALL_OW 12
54988: PLUS
54989: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54990: LD_VAR 0 6
54994: PPUSH
54995: LD_VAR 0 7
54999: PPUSH
55000: CALL_OW 488
55004: NOT
55005: IFFALSE 55027
// begin _x := x ;
55007: LD_ADDR_VAR 0 6
55011: PUSH
55012: LD_VAR 0 4
55016: ST_TO_ADDR
// _y := y ;
55017: LD_ADDR_VAR 0 7
55021: PUSH
55022: LD_VAR 0 5
55026: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
55027: LD_ADDR_VAR 0 3
55031: PUSH
55032: LD_INT 1
55034: PPUSH
55035: LD_VAR 0 14
55039: PPUSH
55040: CALL_OW 12
55044: ST_TO_ADDR
// case i of 1 :
55045: LD_VAR 0 3
55049: PUSH
55050: LD_INT 1
55052: DOUBLE
55053: EQUAL
55054: IFTRUE 55058
55056: GO 55075
55058: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
55059: LD_VAR 0 1
55063: PPUSH
55064: LD_VAR 0 10
55068: PPUSH
55069: CALL_OW 115
55073: GO 55136
55075: LD_INT 2
55077: DOUBLE
55078: EQUAL
55079: IFTRUE 55083
55081: GO 55105
55083: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
55084: LD_VAR 0 1
55088: PPUSH
55089: LD_VAR 0 6
55093: PPUSH
55094: LD_VAR 0 7
55098: PPUSH
55099: CALL_OW 153
55103: GO 55136
55105: LD_INT 3
55107: DOUBLE
55108: EQUAL
55109: IFTRUE 55113
55111: GO 55135
55113: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
55114: LD_VAR 0 1
55118: PPUSH
55119: LD_VAR 0 6
55123: PPUSH
55124: LD_VAR 0 7
55128: PPUSH
55129: CALL_OW 154
55133: GO 55136
55135: POP
// end ;
55136: LD_VAR 0 2
55140: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
55141: LD_INT 0
55143: PPUSH
55144: PPUSH
55145: PPUSH
55146: PPUSH
55147: PPUSH
55148: PPUSH
// if not unit or not building then
55149: LD_VAR 0 1
55153: NOT
55154: PUSH
55155: LD_VAR 0 2
55159: NOT
55160: OR
55161: IFFALSE 55165
// exit ;
55163: GO 55323
// x := GetX ( building ) ;
55165: LD_ADDR_VAR 0 5
55169: PUSH
55170: LD_VAR 0 2
55174: PPUSH
55175: CALL_OW 250
55179: ST_TO_ADDR
// y := GetY ( building ) ;
55180: LD_ADDR_VAR 0 6
55184: PUSH
55185: LD_VAR 0 2
55189: PPUSH
55190: CALL_OW 251
55194: ST_TO_ADDR
// for i = 0 to 5 do
55195: LD_ADDR_VAR 0 4
55199: PUSH
55200: DOUBLE
55201: LD_INT 0
55203: DEC
55204: ST_TO_ADDR
55205: LD_INT 5
55207: PUSH
55208: FOR_TO
55209: IFFALSE 55321
// begin _x := ShiftX ( x , i , 3 ) ;
55211: LD_ADDR_VAR 0 7
55215: PUSH
55216: LD_VAR 0 5
55220: PPUSH
55221: LD_VAR 0 4
55225: PPUSH
55226: LD_INT 3
55228: PPUSH
55229: CALL_OW 272
55233: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
55234: LD_ADDR_VAR 0 8
55238: PUSH
55239: LD_VAR 0 6
55243: PPUSH
55244: LD_VAR 0 4
55248: PPUSH
55249: LD_INT 3
55251: PPUSH
55252: CALL_OW 273
55256: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55257: LD_VAR 0 7
55261: PPUSH
55262: LD_VAR 0 8
55266: PPUSH
55267: CALL_OW 488
55271: NOT
55272: IFFALSE 55276
// continue ;
55274: GO 55208
// if HexInfo ( _x , _y ) = 0 then
55276: LD_VAR 0 7
55280: PPUSH
55281: LD_VAR 0 8
55285: PPUSH
55286: CALL_OW 428
55290: PUSH
55291: LD_INT 0
55293: EQUAL
55294: IFFALSE 55319
// begin ComMoveXY ( unit , _x , _y ) ;
55296: LD_VAR 0 1
55300: PPUSH
55301: LD_VAR 0 7
55305: PPUSH
55306: LD_VAR 0 8
55310: PPUSH
55311: CALL_OW 111
// exit ;
55315: POP
55316: POP
55317: GO 55323
// end ; end ;
55319: GO 55208
55321: POP
55322: POP
// end ;
55323: LD_VAR 0 3
55327: RET
// export function ScanBase ( side , base_area ) ; begin
55328: LD_INT 0
55330: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55331: LD_ADDR_VAR 0 3
55335: PUSH
55336: LD_VAR 0 2
55340: PPUSH
55341: LD_INT 81
55343: PUSH
55344: LD_VAR 0 1
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: PPUSH
55353: CALL_OW 70
55357: ST_TO_ADDR
// end ;
55358: LD_VAR 0 3
55362: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55363: LD_INT 0
55365: PPUSH
55366: PPUSH
55367: PPUSH
55368: PPUSH
// result := false ;
55369: LD_ADDR_VAR 0 2
55373: PUSH
55374: LD_INT 0
55376: ST_TO_ADDR
// side := GetSide ( unit ) ;
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_VAR 0 1
55386: PPUSH
55387: CALL_OW 255
55391: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55392: LD_ADDR_VAR 0 4
55396: PUSH
55397: LD_VAR 0 1
55401: PPUSH
55402: CALL_OW 248
55406: ST_TO_ADDR
// case nat of 1 :
55407: LD_VAR 0 4
55411: PUSH
55412: LD_INT 1
55414: DOUBLE
55415: EQUAL
55416: IFTRUE 55420
55418: GO 55431
55420: POP
// tech := tech_lassight ; 2 :
55421: LD_ADDR_VAR 0 5
55425: PUSH
55426: LD_INT 12
55428: ST_TO_ADDR
55429: GO 55470
55431: LD_INT 2
55433: DOUBLE
55434: EQUAL
55435: IFTRUE 55439
55437: GO 55450
55439: POP
// tech := tech_mortar ; 3 :
55440: LD_ADDR_VAR 0 5
55444: PUSH
55445: LD_INT 41
55447: ST_TO_ADDR
55448: GO 55470
55450: LD_INT 3
55452: DOUBLE
55453: EQUAL
55454: IFTRUE 55458
55456: GO 55469
55458: POP
// tech := tech_bazooka ; end ;
55459: LD_ADDR_VAR 0 5
55463: PUSH
55464: LD_INT 44
55466: ST_TO_ADDR
55467: GO 55470
55469: POP
// if Researched ( side , tech ) then
55470: LD_VAR 0 3
55474: PPUSH
55475: LD_VAR 0 5
55479: PPUSH
55480: CALL_OW 325
55484: IFFALSE 55511
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55486: LD_ADDR_VAR 0 2
55490: PUSH
55491: LD_INT 5
55493: PUSH
55494: LD_INT 8
55496: PUSH
55497: LD_INT 9
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: LIST
55504: PUSH
55505: LD_VAR 0 4
55509: ARRAY
55510: ST_TO_ADDR
// end ;
55511: LD_VAR 0 2
55515: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55516: LD_INT 0
55518: PPUSH
55519: PPUSH
55520: PPUSH
// if not mines then
55521: LD_VAR 0 2
55525: NOT
55526: IFFALSE 55530
// exit ;
55528: GO 55674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55530: LD_ADDR_VAR 0 5
55534: PUSH
55535: LD_INT 81
55537: PUSH
55538: LD_VAR 0 1
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: PUSH
55547: LD_INT 3
55549: PUSH
55550: LD_INT 21
55552: PUSH
55553: LD_INT 3
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PPUSH
55568: CALL_OW 69
55572: ST_TO_ADDR
// for i in mines do
55573: LD_ADDR_VAR 0 4
55577: PUSH
55578: LD_VAR 0 2
55582: PUSH
55583: FOR_IN
55584: IFFALSE 55672
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55586: LD_VAR 0 4
55590: PUSH
55591: LD_INT 1
55593: ARRAY
55594: PPUSH
55595: LD_VAR 0 4
55599: PUSH
55600: LD_INT 2
55602: ARRAY
55603: PPUSH
55604: CALL_OW 458
55608: NOT
55609: IFFALSE 55613
// continue ;
55611: GO 55583
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55613: LD_VAR 0 4
55617: PUSH
55618: LD_INT 1
55620: ARRAY
55621: PPUSH
55622: LD_VAR 0 4
55626: PUSH
55627: LD_INT 2
55629: ARRAY
55630: PPUSH
55631: CALL_OW 428
55635: PUSH
55636: LD_VAR 0 5
55640: IN
55641: IFFALSE 55670
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55643: LD_VAR 0 4
55647: PUSH
55648: LD_INT 1
55650: ARRAY
55651: PPUSH
55652: LD_VAR 0 4
55656: PUSH
55657: LD_INT 2
55659: ARRAY
55660: PPUSH
55661: LD_VAR 0 1
55665: PPUSH
55666: CALL_OW 456
// end ;
55670: GO 55583
55672: POP
55673: POP
// end ;
55674: LD_VAR 0 3
55678: RET
// export function Count ( array ) ; begin
55679: LD_INT 0
55681: PPUSH
// result := array + 0 ;
55682: LD_ADDR_VAR 0 2
55686: PUSH
55687: LD_VAR 0 1
55691: PUSH
55692: LD_INT 0
55694: PLUS
55695: ST_TO_ADDR
// end ;
55696: LD_VAR 0 2
55700: RET
// export function IsEmpty ( building ) ; begin
55701: LD_INT 0
55703: PPUSH
// if not building then
55704: LD_VAR 0 1
55708: NOT
55709: IFFALSE 55713
// exit ;
55711: GO 55756
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55713: LD_ADDR_VAR 0 2
55717: PUSH
55718: LD_VAR 0 1
55722: PUSH
55723: LD_INT 22
55725: PUSH
55726: LD_VAR 0 1
55730: PPUSH
55731: CALL_OW 255
55735: PUSH
55736: EMPTY
55737: LIST
55738: LIST
55739: PUSH
55740: LD_INT 58
55742: PUSH
55743: EMPTY
55744: LIST
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: PPUSH
55750: CALL_OW 69
55754: IN
55755: ST_TO_ADDR
// end ;
55756: LD_VAR 0 2
55760: RET
// export function IsNotFull ( building ) ; var places ; begin
55761: LD_INT 0
55763: PPUSH
55764: PPUSH
// if not building then
55765: LD_VAR 0 1
55769: NOT
55770: IFFALSE 55774
// exit ;
55772: GO 55802
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55774: LD_ADDR_VAR 0 2
55778: PUSH
55779: LD_VAR 0 1
55783: PPUSH
55784: LD_INT 3
55786: PUSH
55787: LD_INT 62
55789: PUSH
55790: EMPTY
55791: LIST
55792: PUSH
55793: EMPTY
55794: LIST
55795: LIST
55796: PPUSH
55797: CALL_OW 72
55801: ST_TO_ADDR
// end ;
55802: LD_VAR 0 2
55806: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55807: LD_INT 0
55809: PPUSH
55810: PPUSH
55811: PPUSH
55812: PPUSH
// tmp := [ ] ;
55813: LD_ADDR_VAR 0 3
55817: PUSH
55818: EMPTY
55819: ST_TO_ADDR
// list := [ ] ;
55820: LD_ADDR_VAR 0 5
55824: PUSH
55825: EMPTY
55826: ST_TO_ADDR
// for i = 16 to 25 do
55827: LD_ADDR_VAR 0 4
55831: PUSH
55832: DOUBLE
55833: LD_INT 16
55835: DEC
55836: ST_TO_ADDR
55837: LD_INT 25
55839: PUSH
55840: FOR_TO
55841: IFFALSE 55914
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55843: LD_ADDR_VAR 0 3
55847: PUSH
55848: LD_VAR 0 3
55852: PUSH
55853: LD_INT 22
55855: PUSH
55856: LD_VAR 0 1
55860: PPUSH
55861: CALL_OW 255
55865: PUSH
55866: EMPTY
55867: LIST
55868: LIST
55869: PUSH
55870: LD_INT 91
55872: PUSH
55873: LD_VAR 0 1
55877: PUSH
55878: LD_INT 6
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: PUSH
55886: LD_INT 30
55888: PUSH
55889: LD_VAR 0 4
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: LIST
55902: PUSH
55903: EMPTY
55904: LIST
55905: PPUSH
55906: CALL_OW 69
55910: ADD
55911: ST_TO_ADDR
55912: GO 55840
55914: POP
55915: POP
// for i = 1 to tmp do
55916: LD_ADDR_VAR 0 4
55920: PUSH
55921: DOUBLE
55922: LD_INT 1
55924: DEC
55925: ST_TO_ADDR
55926: LD_VAR 0 3
55930: PUSH
55931: FOR_TO
55932: IFFALSE 56020
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55934: LD_ADDR_VAR 0 5
55938: PUSH
55939: LD_VAR 0 5
55943: PUSH
55944: LD_VAR 0 3
55948: PUSH
55949: LD_VAR 0 4
55953: ARRAY
55954: PPUSH
55955: CALL_OW 266
55959: PUSH
55960: LD_VAR 0 3
55964: PUSH
55965: LD_VAR 0 4
55969: ARRAY
55970: PPUSH
55971: CALL_OW 250
55975: PUSH
55976: LD_VAR 0 3
55980: PUSH
55981: LD_VAR 0 4
55985: ARRAY
55986: PPUSH
55987: CALL_OW 251
55991: PUSH
55992: LD_VAR 0 3
55996: PUSH
55997: LD_VAR 0 4
56001: ARRAY
56002: PPUSH
56003: CALL_OW 254
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: LIST
56012: LIST
56013: PUSH
56014: EMPTY
56015: LIST
56016: ADD
56017: ST_TO_ADDR
56018: GO 55931
56020: POP
56021: POP
// result := list ;
56022: LD_ADDR_VAR 0 2
56026: PUSH
56027: LD_VAR 0 5
56031: ST_TO_ADDR
// end ;
56032: LD_VAR 0 2
56036: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
56037: LD_INT 0
56039: PPUSH
56040: PPUSH
56041: PPUSH
56042: PPUSH
56043: PPUSH
56044: PPUSH
56045: PPUSH
// if not factory then
56046: LD_VAR 0 1
56050: NOT
56051: IFFALSE 56055
// exit ;
56053: GO 56648
// if control = control_apeman then
56055: LD_VAR 0 4
56059: PUSH
56060: LD_INT 5
56062: EQUAL
56063: IFFALSE 56172
// begin tmp := UnitsInside ( factory ) ;
56065: LD_ADDR_VAR 0 8
56069: PUSH
56070: LD_VAR 0 1
56074: PPUSH
56075: CALL_OW 313
56079: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
56080: LD_VAR 0 8
56084: PPUSH
56085: LD_INT 25
56087: PUSH
56088: LD_INT 12
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: PPUSH
56095: CALL_OW 72
56099: NOT
56100: IFFALSE 56110
// control := control_manual ;
56102: LD_ADDR_VAR 0 4
56106: PUSH
56107: LD_INT 1
56109: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
56110: LD_ADDR_VAR 0 8
56114: PUSH
56115: LD_VAR 0 1
56119: PPUSH
56120: CALL 55807 0 1
56124: ST_TO_ADDR
// if tmp then
56125: LD_VAR 0 8
56129: IFFALSE 56172
// begin for i in tmp do
56131: LD_ADDR_VAR 0 7
56135: PUSH
56136: LD_VAR 0 8
56140: PUSH
56141: FOR_IN
56142: IFFALSE 56170
// if i [ 1 ] = b_ext_radio then
56144: LD_VAR 0 7
56148: PUSH
56149: LD_INT 1
56151: ARRAY
56152: PUSH
56153: LD_INT 22
56155: EQUAL
56156: IFFALSE 56168
// begin control := control_remote ;
56158: LD_ADDR_VAR 0 4
56162: PUSH
56163: LD_INT 2
56165: ST_TO_ADDR
// break ;
56166: GO 56170
// end ;
56168: GO 56141
56170: POP
56171: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56172: LD_VAR 0 1
56176: PPUSH
56177: LD_VAR 0 2
56181: PPUSH
56182: LD_VAR 0 3
56186: PPUSH
56187: LD_VAR 0 4
56191: PPUSH
56192: LD_VAR 0 5
56196: PPUSH
56197: CALL_OW 448
56201: IFFALSE 56236
// begin result := [ chassis , engine , control , weapon ] ;
56203: LD_ADDR_VAR 0 6
56207: PUSH
56208: LD_VAR 0 2
56212: PUSH
56213: LD_VAR 0 3
56217: PUSH
56218: LD_VAR 0 4
56222: PUSH
56223: LD_VAR 0 5
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: ST_TO_ADDR
// exit ;
56234: GO 56648
// end ; _chassis := AvailableChassisList ( factory ) ;
56236: LD_ADDR_VAR 0 9
56240: PUSH
56241: LD_VAR 0 1
56245: PPUSH
56246: CALL_OW 475
56250: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
56251: LD_ADDR_VAR 0 11
56255: PUSH
56256: LD_VAR 0 1
56260: PPUSH
56261: CALL_OW 476
56265: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
56266: LD_ADDR_VAR 0 12
56270: PUSH
56271: LD_VAR 0 1
56275: PPUSH
56276: CALL_OW 477
56280: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
56281: LD_ADDR_VAR 0 10
56285: PUSH
56286: LD_VAR 0 1
56290: PPUSH
56291: CALL_OW 478
56295: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
56296: LD_VAR 0 9
56300: NOT
56301: PUSH
56302: LD_VAR 0 11
56306: NOT
56307: OR
56308: PUSH
56309: LD_VAR 0 12
56313: NOT
56314: OR
56315: PUSH
56316: LD_VAR 0 10
56320: NOT
56321: OR
56322: IFFALSE 56357
// begin result := [ chassis , engine , control , weapon ] ;
56324: LD_ADDR_VAR 0 6
56328: PUSH
56329: LD_VAR 0 2
56333: PUSH
56334: LD_VAR 0 3
56338: PUSH
56339: LD_VAR 0 4
56343: PUSH
56344: LD_VAR 0 5
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: LIST
56353: LIST
56354: ST_TO_ADDR
// exit ;
56355: GO 56648
// end ; if not chassis in _chassis then
56357: LD_VAR 0 2
56361: PUSH
56362: LD_VAR 0 9
56366: IN
56367: NOT
56368: IFFALSE 56394
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56370: LD_ADDR_VAR 0 2
56374: PUSH
56375: LD_VAR 0 9
56379: PUSH
56380: LD_INT 1
56382: PPUSH
56383: LD_VAR 0 9
56387: PPUSH
56388: CALL_OW 12
56392: ARRAY
56393: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56394: LD_VAR 0 2
56398: PPUSH
56399: LD_VAR 0 3
56403: PPUSH
56404: CALL 56653 0 2
56408: NOT
56409: IFFALSE 56468
// repeat engine := _engine [ 1 ] ;
56411: LD_ADDR_VAR 0 3
56415: PUSH
56416: LD_VAR 0 11
56420: PUSH
56421: LD_INT 1
56423: ARRAY
56424: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56425: LD_ADDR_VAR 0 11
56429: PUSH
56430: LD_VAR 0 11
56434: PPUSH
56435: LD_INT 1
56437: PPUSH
56438: CALL_OW 3
56442: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56443: LD_VAR 0 2
56447: PPUSH
56448: LD_VAR 0 3
56452: PPUSH
56453: CALL 56653 0 2
56457: PUSH
56458: LD_VAR 0 11
56462: PUSH
56463: EMPTY
56464: EQUAL
56465: OR
56466: IFFALSE 56411
// if not control in _control then
56468: LD_VAR 0 4
56472: PUSH
56473: LD_VAR 0 12
56477: IN
56478: NOT
56479: IFFALSE 56505
// control := _control [ rand ( 1 , _control ) ] ;
56481: LD_ADDR_VAR 0 4
56485: PUSH
56486: LD_VAR 0 12
56490: PUSH
56491: LD_INT 1
56493: PPUSH
56494: LD_VAR 0 12
56498: PPUSH
56499: CALL_OW 12
56503: ARRAY
56504: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56505: LD_VAR 0 2
56509: PPUSH
56510: LD_VAR 0 5
56514: PPUSH
56515: CALL 56873 0 2
56519: NOT
56520: IFFALSE 56579
// repeat weapon := _weapon [ 1 ] ;
56522: LD_ADDR_VAR 0 5
56526: PUSH
56527: LD_VAR 0 10
56531: PUSH
56532: LD_INT 1
56534: ARRAY
56535: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56536: LD_ADDR_VAR 0 10
56540: PUSH
56541: LD_VAR 0 10
56545: PPUSH
56546: LD_INT 1
56548: PPUSH
56549: CALL_OW 3
56553: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56554: LD_VAR 0 2
56558: PPUSH
56559: LD_VAR 0 5
56563: PPUSH
56564: CALL 56873 0 2
56568: PUSH
56569: LD_VAR 0 10
56573: PUSH
56574: EMPTY
56575: EQUAL
56576: OR
56577: IFFALSE 56522
// result := [ ] ;
56579: LD_ADDR_VAR 0 6
56583: PUSH
56584: EMPTY
56585: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56586: LD_VAR 0 1
56590: PPUSH
56591: LD_VAR 0 2
56595: PPUSH
56596: LD_VAR 0 3
56600: PPUSH
56601: LD_VAR 0 4
56605: PPUSH
56606: LD_VAR 0 5
56610: PPUSH
56611: CALL_OW 448
56615: IFFALSE 56648
// result := [ chassis , engine , control , weapon ] ;
56617: LD_ADDR_VAR 0 6
56621: PUSH
56622: LD_VAR 0 2
56626: PUSH
56627: LD_VAR 0 3
56631: PUSH
56632: LD_VAR 0 4
56636: PUSH
56637: LD_VAR 0 5
56641: PUSH
56642: EMPTY
56643: LIST
56644: LIST
56645: LIST
56646: LIST
56647: ST_TO_ADDR
// end ;
56648: LD_VAR 0 6
56652: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56653: LD_INT 0
56655: PPUSH
// if not chassis or not engine then
56656: LD_VAR 0 1
56660: NOT
56661: PUSH
56662: LD_VAR 0 2
56666: NOT
56667: OR
56668: IFFALSE 56672
// exit ;
56670: GO 56868
// case engine of engine_solar :
56672: LD_VAR 0 2
56676: PUSH
56677: LD_INT 2
56679: DOUBLE
56680: EQUAL
56681: IFTRUE 56685
56683: GO 56723
56685: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56686: LD_ADDR_VAR 0 3
56690: PUSH
56691: LD_INT 11
56693: PUSH
56694: LD_INT 12
56696: PUSH
56697: LD_INT 13
56699: PUSH
56700: LD_INT 14
56702: PUSH
56703: LD_INT 1
56705: PUSH
56706: LD_INT 2
56708: PUSH
56709: LD_INT 3
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: LIST
56716: LIST
56717: LIST
56718: LIST
56719: LIST
56720: ST_TO_ADDR
56721: GO 56852
56723: LD_INT 1
56725: DOUBLE
56726: EQUAL
56727: IFTRUE 56731
56729: GO 56793
56731: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56732: LD_ADDR_VAR 0 3
56736: PUSH
56737: LD_INT 11
56739: PUSH
56740: LD_INT 12
56742: PUSH
56743: LD_INT 13
56745: PUSH
56746: LD_INT 14
56748: PUSH
56749: LD_INT 1
56751: PUSH
56752: LD_INT 2
56754: PUSH
56755: LD_INT 3
56757: PUSH
56758: LD_INT 4
56760: PUSH
56761: LD_INT 5
56763: PUSH
56764: LD_INT 21
56766: PUSH
56767: LD_INT 23
56769: PUSH
56770: LD_INT 22
56772: PUSH
56773: LD_INT 24
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: LIST
56784: LIST
56785: LIST
56786: LIST
56787: LIST
56788: LIST
56789: LIST
56790: ST_TO_ADDR
56791: GO 56852
56793: LD_INT 3
56795: DOUBLE
56796: EQUAL
56797: IFTRUE 56801
56799: GO 56851
56801: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56802: LD_ADDR_VAR 0 3
56806: PUSH
56807: LD_INT 13
56809: PUSH
56810: LD_INT 14
56812: PUSH
56813: LD_INT 2
56815: PUSH
56816: LD_INT 3
56818: PUSH
56819: LD_INT 4
56821: PUSH
56822: LD_INT 5
56824: PUSH
56825: LD_INT 21
56827: PUSH
56828: LD_INT 22
56830: PUSH
56831: LD_INT 23
56833: PUSH
56834: LD_INT 24
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: LIST
56841: LIST
56842: LIST
56843: LIST
56844: LIST
56845: LIST
56846: LIST
56847: LIST
56848: ST_TO_ADDR
56849: GO 56852
56851: POP
// result := ( chassis in result ) ;
56852: LD_ADDR_VAR 0 3
56856: PUSH
56857: LD_VAR 0 1
56861: PUSH
56862: LD_VAR 0 3
56866: IN
56867: ST_TO_ADDR
// end ;
56868: LD_VAR 0 3
56872: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56873: LD_INT 0
56875: PPUSH
// if not chassis or not weapon then
56876: LD_VAR 0 1
56880: NOT
56881: PUSH
56882: LD_VAR 0 2
56886: NOT
56887: OR
56888: IFFALSE 56892
// exit ;
56890: GO 57952
// case weapon of us_machine_gun :
56892: LD_VAR 0 2
56896: PUSH
56897: LD_INT 2
56899: DOUBLE
56900: EQUAL
56901: IFTRUE 56905
56903: GO 56935
56905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56906: LD_ADDR_VAR 0 3
56910: PUSH
56911: LD_INT 1
56913: PUSH
56914: LD_INT 2
56916: PUSH
56917: LD_INT 3
56919: PUSH
56920: LD_INT 4
56922: PUSH
56923: LD_INT 5
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: LIST
56930: LIST
56931: LIST
56932: ST_TO_ADDR
56933: GO 57936
56935: LD_INT 3
56937: DOUBLE
56938: EQUAL
56939: IFTRUE 56943
56941: GO 56973
56943: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56944: LD_ADDR_VAR 0 3
56948: PUSH
56949: LD_INT 1
56951: PUSH
56952: LD_INT 2
56954: PUSH
56955: LD_INT 3
56957: PUSH
56958: LD_INT 4
56960: PUSH
56961: LD_INT 5
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: LIST
56968: LIST
56969: LIST
56970: ST_TO_ADDR
56971: GO 57936
56973: LD_INT 11
56975: DOUBLE
56976: EQUAL
56977: IFTRUE 56981
56979: GO 57011
56981: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56982: LD_ADDR_VAR 0 3
56986: PUSH
56987: LD_INT 1
56989: PUSH
56990: LD_INT 2
56992: PUSH
56993: LD_INT 3
56995: PUSH
56996: LD_INT 4
56998: PUSH
56999: LD_INT 5
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: LIST
57006: LIST
57007: LIST
57008: ST_TO_ADDR
57009: GO 57936
57011: LD_INT 4
57013: DOUBLE
57014: EQUAL
57015: IFTRUE 57019
57017: GO 57045
57019: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
57020: LD_ADDR_VAR 0 3
57024: PUSH
57025: LD_INT 2
57027: PUSH
57028: LD_INT 3
57030: PUSH
57031: LD_INT 4
57033: PUSH
57034: LD_INT 5
57036: PUSH
57037: EMPTY
57038: LIST
57039: LIST
57040: LIST
57041: LIST
57042: ST_TO_ADDR
57043: GO 57936
57045: LD_INT 5
57047: DOUBLE
57048: EQUAL
57049: IFTRUE 57053
57051: GO 57079
57053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
57054: LD_ADDR_VAR 0 3
57058: PUSH
57059: LD_INT 2
57061: PUSH
57062: LD_INT 3
57064: PUSH
57065: LD_INT 4
57067: PUSH
57068: LD_INT 5
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: LIST
57075: LIST
57076: ST_TO_ADDR
57077: GO 57936
57079: LD_INT 9
57081: DOUBLE
57082: EQUAL
57083: IFTRUE 57087
57085: GO 57113
57087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
57088: LD_ADDR_VAR 0 3
57092: PUSH
57093: LD_INT 2
57095: PUSH
57096: LD_INT 3
57098: PUSH
57099: LD_INT 4
57101: PUSH
57102: LD_INT 5
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: LIST
57109: LIST
57110: ST_TO_ADDR
57111: GO 57936
57113: LD_INT 7
57115: DOUBLE
57116: EQUAL
57117: IFTRUE 57121
57119: GO 57147
57121: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
57122: LD_ADDR_VAR 0 3
57126: PUSH
57127: LD_INT 2
57129: PUSH
57130: LD_INT 3
57132: PUSH
57133: LD_INT 4
57135: PUSH
57136: LD_INT 5
57138: PUSH
57139: EMPTY
57140: LIST
57141: LIST
57142: LIST
57143: LIST
57144: ST_TO_ADDR
57145: GO 57936
57147: LD_INT 12
57149: DOUBLE
57150: EQUAL
57151: IFTRUE 57155
57153: GO 57181
57155: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
57156: LD_ADDR_VAR 0 3
57160: PUSH
57161: LD_INT 2
57163: PUSH
57164: LD_INT 3
57166: PUSH
57167: LD_INT 4
57169: PUSH
57170: LD_INT 5
57172: PUSH
57173: EMPTY
57174: LIST
57175: LIST
57176: LIST
57177: LIST
57178: ST_TO_ADDR
57179: GO 57936
57181: LD_INT 13
57183: DOUBLE
57184: EQUAL
57185: IFTRUE 57189
57187: GO 57215
57189: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
57190: LD_ADDR_VAR 0 3
57194: PUSH
57195: LD_INT 2
57197: PUSH
57198: LD_INT 3
57200: PUSH
57201: LD_INT 4
57203: PUSH
57204: LD_INT 5
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: LIST
57211: LIST
57212: ST_TO_ADDR
57213: GO 57936
57215: LD_INT 14
57217: DOUBLE
57218: EQUAL
57219: IFTRUE 57223
57221: GO 57241
57223: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
57224: LD_ADDR_VAR 0 3
57228: PUSH
57229: LD_INT 4
57231: PUSH
57232: LD_INT 5
57234: PUSH
57235: EMPTY
57236: LIST
57237: LIST
57238: ST_TO_ADDR
57239: GO 57936
57241: LD_INT 6
57243: DOUBLE
57244: EQUAL
57245: IFTRUE 57249
57247: GO 57267
57249: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
57250: LD_ADDR_VAR 0 3
57254: PUSH
57255: LD_INT 4
57257: PUSH
57258: LD_INT 5
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: ST_TO_ADDR
57265: GO 57936
57267: LD_INT 10
57269: DOUBLE
57270: EQUAL
57271: IFTRUE 57275
57273: GO 57293
57275: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
57276: LD_ADDR_VAR 0 3
57280: PUSH
57281: LD_INT 4
57283: PUSH
57284: LD_INT 5
57286: PUSH
57287: EMPTY
57288: LIST
57289: LIST
57290: ST_TO_ADDR
57291: GO 57936
57293: LD_INT 22
57295: DOUBLE
57296: EQUAL
57297: IFTRUE 57301
57299: GO 57327
57301: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
57302: LD_ADDR_VAR 0 3
57306: PUSH
57307: LD_INT 11
57309: PUSH
57310: LD_INT 12
57312: PUSH
57313: LD_INT 13
57315: PUSH
57316: LD_INT 14
57318: PUSH
57319: EMPTY
57320: LIST
57321: LIST
57322: LIST
57323: LIST
57324: ST_TO_ADDR
57325: GO 57936
57327: LD_INT 23
57329: DOUBLE
57330: EQUAL
57331: IFTRUE 57335
57333: GO 57361
57335: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57336: LD_ADDR_VAR 0 3
57340: PUSH
57341: LD_INT 11
57343: PUSH
57344: LD_INT 12
57346: PUSH
57347: LD_INT 13
57349: PUSH
57350: LD_INT 14
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: LIST
57357: LIST
57358: ST_TO_ADDR
57359: GO 57936
57361: LD_INT 24
57363: DOUBLE
57364: EQUAL
57365: IFTRUE 57369
57367: GO 57395
57369: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57370: LD_ADDR_VAR 0 3
57374: PUSH
57375: LD_INT 11
57377: PUSH
57378: LD_INT 12
57380: PUSH
57381: LD_INT 13
57383: PUSH
57384: LD_INT 14
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: LIST
57391: LIST
57392: ST_TO_ADDR
57393: GO 57936
57395: LD_INT 30
57397: DOUBLE
57398: EQUAL
57399: IFTRUE 57403
57401: GO 57429
57403: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57404: LD_ADDR_VAR 0 3
57408: PUSH
57409: LD_INT 11
57411: PUSH
57412: LD_INT 12
57414: PUSH
57415: LD_INT 13
57417: PUSH
57418: LD_INT 14
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: LIST
57425: LIST
57426: ST_TO_ADDR
57427: GO 57936
57429: LD_INT 25
57431: DOUBLE
57432: EQUAL
57433: IFTRUE 57437
57435: GO 57455
57437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57438: LD_ADDR_VAR 0 3
57442: PUSH
57443: LD_INT 13
57445: PUSH
57446: LD_INT 14
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: ST_TO_ADDR
57453: GO 57936
57455: LD_INT 27
57457: DOUBLE
57458: EQUAL
57459: IFTRUE 57463
57461: GO 57481
57463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57464: LD_ADDR_VAR 0 3
57468: PUSH
57469: LD_INT 13
57471: PUSH
57472: LD_INT 14
57474: PUSH
57475: EMPTY
57476: LIST
57477: LIST
57478: ST_TO_ADDR
57479: GO 57936
57481: LD_INT 92
57483: DOUBLE
57484: EQUAL
57485: IFTRUE 57489
57487: GO 57515
57489: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57490: LD_ADDR_VAR 0 3
57494: PUSH
57495: LD_INT 11
57497: PUSH
57498: LD_INT 12
57500: PUSH
57501: LD_INT 13
57503: PUSH
57504: LD_INT 14
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: LIST
57511: LIST
57512: ST_TO_ADDR
57513: GO 57936
57515: LD_INT 28
57517: DOUBLE
57518: EQUAL
57519: IFTRUE 57523
57521: GO 57541
57523: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57524: LD_ADDR_VAR 0 3
57528: PUSH
57529: LD_INT 13
57531: PUSH
57532: LD_INT 14
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: ST_TO_ADDR
57539: GO 57936
57541: LD_INT 29
57543: DOUBLE
57544: EQUAL
57545: IFTRUE 57549
57547: GO 57567
57549: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57550: LD_ADDR_VAR 0 3
57554: PUSH
57555: LD_INT 13
57557: PUSH
57558: LD_INT 14
57560: PUSH
57561: EMPTY
57562: LIST
57563: LIST
57564: ST_TO_ADDR
57565: GO 57936
57567: LD_INT 31
57569: DOUBLE
57570: EQUAL
57571: IFTRUE 57575
57573: GO 57593
57575: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57576: LD_ADDR_VAR 0 3
57580: PUSH
57581: LD_INT 13
57583: PUSH
57584: LD_INT 14
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: ST_TO_ADDR
57591: GO 57936
57593: LD_INT 26
57595: DOUBLE
57596: EQUAL
57597: IFTRUE 57601
57599: GO 57619
57601: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57602: LD_ADDR_VAR 0 3
57606: PUSH
57607: LD_INT 13
57609: PUSH
57610: LD_INT 14
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: ST_TO_ADDR
57617: GO 57936
57619: LD_INT 42
57621: DOUBLE
57622: EQUAL
57623: IFTRUE 57627
57625: GO 57653
57627: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57628: LD_ADDR_VAR 0 3
57632: PUSH
57633: LD_INT 21
57635: PUSH
57636: LD_INT 22
57638: PUSH
57639: LD_INT 23
57641: PUSH
57642: LD_INT 24
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: LIST
57649: LIST
57650: ST_TO_ADDR
57651: GO 57936
57653: LD_INT 43
57655: DOUBLE
57656: EQUAL
57657: IFTRUE 57661
57659: GO 57687
57661: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57662: LD_ADDR_VAR 0 3
57666: PUSH
57667: LD_INT 21
57669: PUSH
57670: LD_INT 22
57672: PUSH
57673: LD_INT 23
57675: PUSH
57676: LD_INT 24
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: LIST
57683: LIST
57684: ST_TO_ADDR
57685: GO 57936
57687: LD_INT 44
57689: DOUBLE
57690: EQUAL
57691: IFTRUE 57695
57693: GO 57721
57695: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57696: LD_ADDR_VAR 0 3
57700: PUSH
57701: LD_INT 21
57703: PUSH
57704: LD_INT 22
57706: PUSH
57707: LD_INT 23
57709: PUSH
57710: LD_INT 24
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: LIST
57717: LIST
57718: ST_TO_ADDR
57719: GO 57936
57721: LD_INT 45
57723: DOUBLE
57724: EQUAL
57725: IFTRUE 57729
57727: GO 57755
57729: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57730: LD_ADDR_VAR 0 3
57734: PUSH
57735: LD_INT 21
57737: PUSH
57738: LD_INT 22
57740: PUSH
57741: LD_INT 23
57743: PUSH
57744: LD_INT 24
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: LIST
57751: LIST
57752: ST_TO_ADDR
57753: GO 57936
57755: LD_INT 49
57757: DOUBLE
57758: EQUAL
57759: IFTRUE 57763
57761: GO 57789
57763: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57764: LD_ADDR_VAR 0 3
57768: PUSH
57769: LD_INT 21
57771: PUSH
57772: LD_INT 22
57774: PUSH
57775: LD_INT 23
57777: PUSH
57778: LD_INT 24
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: LIST
57785: LIST
57786: ST_TO_ADDR
57787: GO 57936
57789: LD_INT 51
57791: DOUBLE
57792: EQUAL
57793: IFTRUE 57797
57795: GO 57823
57797: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57798: LD_ADDR_VAR 0 3
57802: PUSH
57803: LD_INT 21
57805: PUSH
57806: LD_INT 22
57808: PUSH
57809: LD_INT 23
57811: PUSH
57812: LD_INT 24
57814: PUSH
57815: EMPTY
57816: LIST
57817: LIST
57818: LIST
57819: LIST
57820: ST_TO_ADDR
57821: GO 57936
57823: LD_INT 52
57825: DOUBLE
57826: EQUAL
57827: IFTRUE 57831
57829: GO 57857
57831: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57832: LD_ADDR_VAR 0 3
57836: PUSH
57837: LD_INT 21
57839: PUSH
57840: LD_INT 22
57842: PUSH
57843: LD_INT 23
57845: PUSH
57846: LD_INT 24
57848: PUSH
57849: EMPTY
57850: LIST
57851: LIST
57852: LIST
57853: LIST
57854: ST_TO_ADDR
57855: GO 57936
57857: LD_INT 53
57859: DOUBLE
57860: EQUAL
57861: IFTRUE 57865
57863: GO 57883
57865: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57866: LD_ADDR_VAR 0 3
57870: PUSH
57871: LD_INT 23
57873: PUSH
57874: LD_INT 24
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: ST_TO_ADDR
57881: GO 57936
57883: LD_INT 46
57885: DOUBLE
57886: EQUAL
57887: IFTRUE 57891
57889: GO 57909
57891: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57892: LD_ADDR_VAR 0 3
57896: PUSH
57897: LD_INT 23
57899: PUSH
57900: LD_INT 24
57902: PUSH
57903: EMPTY
57904: LIST
57905: LIST
57906: ST_TO_ADDR
57907: GO 57936
57909: LD_INT 47
57911: DOUBLE
57912: EQUAL
57913: IFTRUE 57917
57915: GO 57935
57917: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57918: LD_ADDR_VAR 0 3
57922: PUSH
57923: LD_INT 23
57925: PUSH
57926: LD_INT 24
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: ST_TO_ADDR
57933: GO 57936
57935: POP
// result := ( chassis in result ) ;
57936: LD_ADDR_VAR 0 3
57940: PUSH
57941: LD_VAR 0 1
57945: PUSH
57946: LD_VAR 0 3
57950: IN
57951: ST_TO_ADDR
// end ;
57952: LD_VAR 0 3
57956: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57957: LD_INT 0
57959: PPUSH
57960: PPUSH
57961: PPUSH
57962: PPUSH
57963: PPUSH
57964: PPUSH
57965: PPUSH
// result := array ;
57966: LD_ADDR_VAR 0 5
57970: PUSH
57971: LD_VAR 0 1
57975: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57976: LD_VAR 0 1
57980: NOT
57981: PUSH
57982: LD_VAR 0 2
57986: NOT
57987: OR
57988: PUSH
57989: LD_VAR 0 3
57993: NOT
57994: OR
57995: PUSH
57996: LD_VAR 0 2
58000: PUSH
58001: LD_VAR 0 1
58005: GREATER
58006: OR
58007: PUSH
58008: LD_VAR 0 3
58012: PUSH
58013: LD_VAR 0 1
58017: GREATER
58018: OR
58019: IFFALSE 58023
// exit ;
58021: GO 58319
// if direction then
58023: LD_VAR 0 4
58027: IFFALSE 58091
// begin d := 1 ;
58029: LD_ADDR_VAR 0 9
58033: PUSH
58034: LD_INT 1
58036: ST_TO_ADDR
// if i_from > i_to then
58037: LD_VAR 0 2
58041: PUSH
58042: LD_VAR 0 3
58046: GREATER
58047: IFFALSE 58073
// length := ( array - i_from ) + i_to else
58049: LD_ADDR_VAR 0 11
58053: PUSH
58054: LD_VAR 0 1
58058: PUSH
58059: LD_VAR 0 2
58063: MINUS
58064: PUSH
58065: LD_VAR 0 3
58069: PLUS
58070: ST_TO_ADDR
58071: GO 58089
// length := i_to - i_from ;
58073: LD_ADDR_VAR 0 11
58077: PUSH
58078: LD_VAR 0 3
58082: PUSH
58083: LD_VAR 0 2
58087: MINUS
58088: ST_TO_ADDR
// end else
58089: GO 58152
// begin d := - 1 ;
58091: LD_ADDR_VAR 0 9
58095: PUSH
58096: LD_INT 1
58098: NEG
58099: ST_TO_ADDR
// if i_from > i_to then
58100: LD_VAR 0 2
58104: PUSH
58105: LD_VAR 0 3
58109: GREATER
58110: IFFALSE 58130
// length := i_from - i_to else
58112: LD_ADDR_VAR 0 11
58116: PUSH
58117: LD_VAR 0 2
58121: PUSH
58122: LD_VAR 0 3
58126: MINUS
58127: ST_TO_ADDR
58128: GO 58152
// length := ( array - i_to ) + i_from ;
58130: LD_ADDR_VAR 0 11
58134: PUSH
58135: LD_VAR 0 1
58139: PUSH
58140: LD_VAR 0 3
58144: MINUS
58145: PUSH
58146: LD_VAR 0 2
58150: PLUS
58151: ST_TO_ADDR
// end ; if not length then
58152: LD_VAR 0 11
58156: NOT
58157: IFFALSE 58161
// exit ;
58159: GO 58319
// tmp := array ;
58161: LD_ADDR_VAR 0 10
58165: PUSH
58166: LD_VAR 0 1
58170: ST_TO_ADDR
// for i = 1 to length do
58171: LD_ADDR_VAR 0 6
58175: PUSH
58176: DOUBLE
58177: LD_INT 1
58179: DEC
58180: ST_TO_ADDR
58181: LD_VAR 0 11
58185: PUSH
58186: FOR_TO
58187: IFFALSE 58307
// begin for j = 1 to array do
58189: LD_ADDR_VAR 0 7
58193: PUSH
58194: DOUBLE
58195: LD_INT 1
58197: DEC
58198: ST_TO_ADDR
58199: LD_VAR 0 1
58203: PUSH
58204: FOR_TO
58205: IFFALSE 58293
// begin k := j + d ;
58207: LD_ADDR_VAR 0 8
58211: PUSH
58212: LD_VAR 0 7
58216: PUSH
58217: LD_VAR 0 9
58221: PLUS
58222: ST_TO_ADDR
// if k > array then
58223: LD_VAR 0 8
58227: PUSH
58228: LD_VAR 0 1
58232: GREATER
58233: IFFALSE 58243
// k := 1 ;
58235: LD_ADDR_VAR 0 8
58239: PUSH
58240: LD_INT 1
58242: ST_TO_ADDR
// if not k then
58243: LD_VAR 0 8
58247: NOT
58248: IFFALSE 58260
// k := array ;
58250: LD_ADDR_VAR 0 8
58254: PUSH
58255: LD_VAR 0 1
58259: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
58260: LD_ADDR_VAR 0 10
58264: PUSH
58265: LD_VAR 0 10
58269: PPUSH
58270: LD_VAR 0 8
58274: PPUSH
58275: LD_VAR 0 1
58279: PUSH
58280: LD_VAR 0 7
58284: ARRAY
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// end ;
58291: GO 58204
58293: POP
58294: POP
// array := tmp ;
58295: LD_ADDR_VAR 0 1
58299: PUSH
58300: LD_VAR 0 10
58304: ST_TO_ADDR
// end ;
58305: GO 58186
58307: POP
58308: POP
// result := array ;
58309: LD_ADDR_VAR 0 5
58313: PUSH
58314: LD_VAR 0 1
58318: ST_TO_ADDR
// end ;
58319: LD_VAR 0 5
58323: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58324: LD_INT 0
58326: PPUSH
58327: PPUSH
// result := 0 ;
58328: LD_ADDR_VAR 0 3
58332: PUSH
58333: LD_INT 0
58335: ST_TO_ADDR
// if not array or not value in array then
58336: LD_VAR 0 1
58340: NOT
58341: PUSH
58342: LD_VAR 0 2
58346: PUSH
58347: LD_VAR 0 1
58351: IN
58352: NOT
58353: OR
58354: IFFALSE 58358
// exit ;
58356: GO 58412
// for i = 1 to array do
58358: LD_ADDR_VAR 0 4
58362: PUSH
58363: DOUBLE
58364: LD_INT 1
58366: DEC
58367: ST_TO_ADDR
58368: LD_VAR 0 1
58372: PUSH
58373: FOR_TO
58374: IFFALSE 58410
// if value = array [ i ] then
58376: LD_VAR 0 2
58380: PUSH
58381: LD_VAR 0 1
58385: PUSH
58386: LD_VAR 0 4
58390: ARRAY
58391: EQUAL
58392: IFFALSE 58408
// begin result := i ;
58394: LD_ADDR_VAR 0 3
58398: PUSH
58399: LD_VAR 0 4
58403: ST_TO_ADDR
// exit ;
58404: POP
58405: POP
58406: GO 58412
// end ;
58408: GO 58373
58410: POP
58411: POP
// end ;
58412: LD_VAR 0 3
58416: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58417: LD_INT 0
58419: PPUSH
// vc_chassis := chassis ;
58420: LD_ADDR_OWVAR 37
58424: PUSH
58425: LD_VAR 0 1
58429: ST_TO_ADDR
// vc_engine := engine ;
58430: LD_ADDR_OWVAR 39
58434: PUSH
58435: LD_VAR 0 2
58439: ST_TO_ADDR
// vc_control := control ;
58440: LD_ADDR_OWVAR 38
58444: PUSH
58445: LD_VAR 0 3
58449: ST_TO_ADDR
// vc_weapon := weapon ;
58450: LD_ADDR_OWVAR 40
58454: PUSH
58455: LD_VAR 0 4
58459: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58460: LD_ADDR_OWVAR 41
58464: PUSH
58465: LD_VAR 0 5
58469: ST_TO_ADDR
// end ;
58470: LD_VAR 0 6
58474: RET
// export function WantPlant ( unit ) ; var task ; begin
58475: LD_INT 0
58477: PPUSH
58478: PPUSH
// result := false ;
58479: LD_ADDR_VAR 0 2
58483: PUSH
58484: LD_INT 0
58486: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58487: LD_ADDR_VAR 0 3
58491: PUSH
58492: LD_VAR 0 1
58496: PPUSH
58497: CALL_OW 437
58501: ST_TO_ADDR
// if task then
58502: LD_VAR 0 3
58506: IFFALSE 58534
// if task [ 1 ] [ 1 ] = p then
58508: LD_VAR 0 3
58512: PUSH
58513: LD_INT 1
58515: ARRAY
58516: PUSH
58517: LD_INT 1
58519: ARRAY
58520: PUSH
58521: LD_STRING p
58523: EQUAL
58524: IFFALSE 58534
// result := true ;
58526: LD_ADDR_VAR 0 2
58530: PUSH
58531: LD_INT 1
58533: ST_TO_ADDR
// end ;
58534: LD_VAR 0 2
58538: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58539: LD_INT 0
58541: PPUSH
58542: PPUSH
58543: PPUSH
58544: PPUSH
// if pos < 1 then
58545: LD_VAR 0 2
58549: PUSH
58550: LD_INT 1
58552: LESS
58553: IFFALSE 58557
// exit ;
58555: GO 58860
// if pos = 1 then
58557: LD_VAR 0 2
58561: PUSH
58562: LD_INT 1
58564: EQUAL
58565: IFFALSE 58598
// result := Replace ( arr , pos [ 1 ] , value ) else
58567: LD_ADDR_VAR 0 4
58571: PUSH
58572: LD_VAR 0 1
58576: PPUSH
58577: LD_VAR 0 2
58581: PUSH
58582: LD_INT 1
58584: ARRAY
58585: PPUSH
58586: LD_VAR 0 3
58590: PPUSH
58591: CALL_OW 1
58595: ST_TO_ADDR
58596: GO 58860
// begin tmp := arr ;
58598: LD_ADDR_VAR 0 6
58602: PUSH
58603: LD_VAR 0 1
58607: ST_TO_ADDR
// s_arr := [ tmp ] ;
58608: LD_ADDR_VAR 0 7
58612: PUSH
58613: LD_VAR 0 6
58617: PUSH
58618: EMPTY
58619: LIST
58620: ST_TO_ADDR
// for i = 1 to pos - 1 do
58621: LD_ADDR_VAR 0 5
58625: PUSH
58626: DOUBLE
58627: LD_INT 1
58629: DEC
58630: ST_TO_ADDR
58631: LD_VAR 0 2
58635: PUSH
58636: LD_INT 1
58638: MINUS
58639: PUSH
58640: FOR_TO
58641: IFFALSE 58686
// begin tmp := tmp [ pos [ i ] ] ;
58643: LD_ADDR_VAR 0 6
58647: PUSH
58648: LD_VAR 0 6
58652: PUSH
58653: LD_VAR 0 2
58657: PUSH
58658: LD_VAR 0 5
58662: ARRAY
58663: ARRAY
58664: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58665: LD_ADDR_VAR 0 7
58669: PUSH
58670: LD_VAR 0 7
58674: PUSH
58675: LD_VAR 0 6
58679: PUSH
58680: EMPTY
58681: LIST
58682: ADD
58683: ST_TO_ADDR
// end ;
58684: GO 58640
58686: POP
58687: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58688: LD_ADDR_VAR 0 6
58692: PUSH
58693: LD_VAR 0 6
58697: PPUSH
58698: LD_VAR 0 2
58702: PUSH
58703: LD_VAR 0 2
58707: ARRAY
58708: PPUSH
58709: LD_VAR 0 3
58713: PPUSH
58714: CALL_OW 1
58718: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58719: LD_ADDR_VAR 0 7
58723: PUSH
58724: LD_VAR 0 7
58728: PPUSH
58729: LD_VAR 0 7
58733: PPUSH
58734: LD_VAR 0 6
58738: PPUSH
58739: CALL_OW 1
58743: ST_TO_ADDR
// for i = s_arr downto 2 do
58744: LD_ADDR_VAR 0 5
58748: PUSH
58749: DOUBLE
58750: LD_VAR 0 7
58754: INC
58755: ST_TO_ADDR
58756: LD_INT 2
58758: PUSH
58759: FOR_DOWNTO
58760: IFFALSE 58844
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58762: LD_ADDR_VAR 0 6
58766: PUSH
58767: LD_VAR 0 7
58771: PUSH
58772: LD_VAR 0 5
58776: PUSH
58777: LD_INT 1
58779: MINUS
58780: ARRAY
58781: PPUSH
58782: LD_VAR 0 2
58786: PUSH
58787: LD_VAR 0 5
58791: PUSH
58792: LD_INT 1
58794: MINUS
58795: ARRAY
58796: PPUSH
58797: LD_VAR 0 7
58801: PUSH
58802: LD_VAR 0 5
58806: ARRAY
58807: PPUSH
58808: CALL_OW 1
58812: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58813: LD_ADDR_VAR 0 7
58817: PUSH
58818: LD_VAR 0 7
58822: PPUSH
58823: LD_VAR 0 5
58827: PUSH
58828: LD_INT 1
58830: MINUS
58831: PPUSH
58832: LD_VAR 0 6
58836: PPUSH
58837: CALL_OW 1
58841: ST_TO_ADDR
// end ;
58842: GO 58759
58844: POP
58845: POP
// result := s_arr [ 1 ] ;
58846: LD_ADDR_VAR 0 4
58850: PUSH
58851: LD_VAR 0 7
58855: PUSH
58856: LD_INT 1
58858: ARRAY
58859: ST_TO_ADDR
// end ; end ;
58860: LD_VAR 0 4
58864: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58865: LD_INT 0
58867: PPUSH
58868: PPUSH
// if not list then
58869: LD_VAR 0 1
58873: NOT
58874: IFFALSE 58878
// exit ;
58876: GO 58969
// i := list [ pos1 ] ;
58878: LD_ADDR_VAR 0 5
58882: PUSH
58883: LD_VAR 0 1
58887: PUSH
58888: LD_VAR 0 2
58892: ARRAY
58893: ST_TO_ADDR
// if not i then
58894: LD_VAR 0 5
58898: NOT
58899: IFFALSE 58903
// exit ;
58901: GO 58969
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58903: LD_ADDR_VAR 0 1
58907: PUSH
58908: LD_VAR 0 1
58912: PPUSH
58913: LD_VAR 0 2
58917: PPUSH
58918: LD_VAR 0 1
58922: PUSH
58923: LD_VAR 0 3
58927: ARRAY
58928: PPUSH
58929: CALL_OW 1
58933: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58934: LD_ADDR_VAR 0 1
58938: PUSH
58939: LD_VAR 0 1
58943: PPUSH
58944: LD_VAR 0 3
58948: PPUSH
58949: LD_VAR 0 5
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// result := list ;
58959: LD_ADDR_VAR 0 4
58963: PUSH
58964: LD_VAR 0 1
58968: ST_TO_ADDR
// end ;
58969: LD_VAR 0 4
58973: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58974: LD_INT 0
58976: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58977: LD_ADDR_VAR 0 5
58981: PUSH
58982: LD_VAR 0 1
58986: PPUSH
58987: CALL_OW 250
58991: PPUSH
58992: LD_VAR 0 1
58996: PPUSH
58997: CALL_OW 251
59001: PPUSH
59002: LD_VAR 0 2
59006: PPUSH
59007: LD_VAR 0 3
59011: PPUSH
59012: LD_VAR 0 4
59016: PPUSH
59017: CALL 59395 0 5
59021: ST_TO_ADDR
// end ;
59022: LD_VAR 0 5
59026: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
59027: LD_INT 0
59029: PPUSH
59030: PPUSH
59031: PPUSH
59032: PPUSH
// if not list or not unit then
59033: LD_VAR 0 2
59037: NOT
59038: PUSH
59039: LD_VAR 0 1
59043: NOT
59044: OR
59045: IFFALSE 59049
// exit ;
59047: GO 59390
// result := [ ] ;
59049: LD_ADDR_VAR 0 5
59053: PUSH
59054: EMPTY
59055: ST_TO_ADDR
// for i in list do
59056: LD_ADDR_VAR 0 6
59060: PUSH
59061: LD_VAR 0 2
59065: PUSH
59066: FOR_IN
59067: IFFALSE 59285
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59069: LD_ADDR_VAR 0 8
59073: PUSH
59074: LD_VAR 0 1
59078: PPUSH
59079: LD_VAR 0 6
59083: PUSH
59084: LD_INT 1
59086: ARRAY
59087: PPUSH
59088: LD_VAR 0 6
59092: PUSH
59093: LD_INT 2
59095: ARRAY
59096: PPUSH
59097: CALL_OW 297
59101: ST_TO_ADDR
// if not Count ( result ) then
59102: LD_VAR 0 5
59106: PPUSH
59107: CALL 55679 0 1
59111: NOT
59112: IFFALSE 59145
// begin result := Join ( result , [ i , tmp ] ) ;
59114: LD_ADDR_VAR 0 5
59118: PUSH
59119: LD_VAR 0 5
59123: PPUSH
59124: LD_VAR 0 6
59128: PUSH
59129: LD_VAR 0 8
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: PPUSH
59138: CALL 91268 0 2
59142: ST_TO_ADDR
// continue ;
59143: GO 59066
// end ; if result [ result ] [ 2 ] <= tmp then
59145: LD_VAR 0 5
59149: PUSH
59150: LD_VAR 0 5
59154: ARRAY
59155: PUSH
59156: LD_INT 2
59158: ARRAY
59159: PUSH
59160: LD_VAR 0 8
59164: LESSEQUAL
59165: IFFALSE 59198
// result := Join ( result , [ i , tmp ] ) else
59167: LD_ADDR_VAR 0 5
59171: PUSH
59172: LD_VAR 0 5
59176: PPUSH
59177: LD_VAR 0 6
59181: PUSH
59182: LD_VAR 0 8
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PPUSH
59191: CALL 91268 0 2
59195: ST_TO_ADDR
59196: GO 59283
// begin for j := 1 to Count ( result ) do
59198: LD_ADDR_VAR 0 7
59202: PUSH
59203: DOUBLE
59204: LD_INT 1
59206: DEC
59207: ST_TO_ADDR
59208: LD_VAR 0 5
59212: PPUSH
59213: CALL 55679 0 1
59217: PUSH
59218: FOR_TO
59219: IFFALSE 59281
// begin if tmp < result [ j ] [ 2 ] then
59221: LD_VAR 0 8
59225: PUSH
59226: LD_VAR 0 5
59230: PUSH
59231: LD_VAR 0 7
59235: ARRAY
59236: PUSH
59237: LD_INT 2
59239: ARRAY
59240: LESS
59241: IFFALSE 59279
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59243: LD_ADDR_VAR 0 5
59247: PUSH
59248: LD_VAR 0 5
59252: PPUSH
59253: LD_VAR 0 7
59257: PPUSH
59258: LD_VAR 0 6
59262: PUSH
59263: LD_VAR 0 8
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PPUSH
59272: CALL_OW 2
59276: ST_TO_ADDR
// break ;
59277: GO 59281
// end ; end ;
59279: GO 59218
59281: POP
59282: POP
// end ; end ;
59283: GO 59066
59285: POP
59286: POP
// if result and not asc then
59287: LD_VAR 0 5
59291: PUSH
59292: LD_VAR 0 3
59296: NOT
59297: AND
59298: IFFALSE 59315
// result := ReverseArray ( result ) ;
59300: LD_ADDR_VAR 0 5
59304: PUSH
59305: LD_VAR 0 5
59309: PPUSH
59310: CALL 86555 0 1
59314: ST_TO_ADDR
// tmp := [ ] ;
59315: LD_ADDR_VAR 0 8
59319: PUSH
59320: EMPTY
59321: ST_TO_ADDR
// if mode then
59322: LD_VAR 0 4
59326: IFFALSE 59390
// begin for i := 1 to result do
59328: LD_ADDR_VAR 0 6
59332: PUSH
59333: DOUBLE
59334: LD_INT 1
59336: DEC
59337: ST_TO_ADDR
59338: LD_VAR 0 5
59342: PUSH
59343: FOR_TO
59344: IFFALSE 59378
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59346: LD_ADDR_VAR 0 8
59350: PUSH
59351: LD_VAR 0 8
59355: PPUSH
59356: LD_VAR 0 5
59360: PUSH
59361: LD_VAR 0 6
59365: ARRAY
59366: PUSH
59367: LD_INT 1
59369: ARRAY
59370: PPUSH
59371: CALL 91268 0 2
59375: ST_TO_ADDR
59376: GO 59343
59378: POP
59379: POP
// result := tmp ;
59380: LD_ADDR_VAR 0 5
59384: PUSH
59385: LD_VAR 0 8
59389: ST_TO_ADDR
// end ; end ;
59390: LD_VAR 0 5
59394: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59395: LD_INT 0
59397: PPUSH
59398: PPUSH
59399: PPUSH
59400: PPUSH
// if not list then
59401: LD_VAR 0 3
59405: NOT
59406: IFFALSE 59410
// exit ;
59408: GO 59798
// result := [ ] ;
59410: LD_ADDR_VAR 0 6
59414: PUSH
59415: EMPTY
59416: ST_TO_ADDR
// for i in list do
59417: LD_ADDR_VAR 0 7
59421: PUSH
59422: LD_VAR 0 3
59426: PUSH
59427: FOR_IN
59428: IFFALSE 59630
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59430: LD_ADDR_VAR 0 9
59434: PUSH
59435: LD_VAR 0 7
59439: PPUSH
59440: LD_VAR 0 1
59444: PPUSH
59445: LD_VAR 0 2
59449: PPUSH
59450: CALL_OW 297
59454: ST_TO_ADDR
// if not result then
59455: LD_VAR 0 6
59459: NOT
59460: IFFALSE 59486
// result := [ [ i , tmp ] ] else
59462: LD_ADDR_VAR 0 6
59466: PUSH
59467: LD_VAR 0 7
59471: PUSH
59472: LD_VAR 0 9
59476: PUSH
59477: EMPTY
59478: LIST
59479: LIST
59480: PUSH
59481: EMPTY
59482: LIST
59483: ST_TO_ADDR
59484: GO 59628
// begin if result [ result ] [ 2 ] < tmp then
59486: LD_VAR 0 6
59490: PUSH
59491: LD_VAR 0 6
59495: ARRAY
59496: PUSH
59497: LD_INT 2
59499: ARRAY
59500: PUSH
59501: LD_VAR 0 9
59505: LESS
59506: IFFALSE 59548
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59508: LD_ADDR_VAR 0 6
59512: PUSH
59513: LD_VAR 0 6
59517: PPUSH
59518: LD_VAR 0 6
59522: PUSH
59523: LD_INT 1
59525: PLUS
59526: PPUSH
59527: LD_VAR 0 7
59531: PUSH
59532: LD_VAR 0 9
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: PPUSH
59541: CALL_OW 2
59545: ST_TO_ADDR
59546: GO 59628
// for j = 1 to result do
59548: LD_ADDR_VAR 0 8
59552: PUSH
59553: DOUBLE
59554: LD_INT 1
59556: DEC
59557: ST_TO_ADDR
59558: LD_VAR 0 6
59562: PUSH
59563: FOR_TO
59564: IFFALSE 59626
// begin if tmp < result [ j ] [ 2 ] then
59566: LD_VAR 0 9
59570: PUSH
59571: LD_VAR 0 6
59575: PUSH
59576: LD_VAR 0 8
59580: ARRAY
59581: PUSH
59582: LD_INT 2
59584: ARRAY
59585: LESS
59586: IFFALSE 59624
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59588: LD_ADDR_VAR 0 6
59592: PUSH
59593: LD_VAR 0 6
59597: PPUSH
59598: LD_VAR 0 8
59602: PPUSH
59603: LD_VAR 0 7
59607: PUSH
59608: LD_VAR 0 9
59612: PUSH
59613: EMPTY
59614: LIST
59615: LIST
59616: PPUSH
59617: CALL_OW 2
59621: ST_TO_ADDR
// break ;
59622: GO 59626
// end ; end ;
59624: GO 59563
59626: POP
59627: POP
// end ; end ;
59628: GO 59427
59630: POP
59631: POP
// if result and not asc then
59632: LD_VAR 0 6
59636: PUSH
59637: LD_VAR 0 4
59641: NOT
59642: AND
59643: IFFALSE 59718
// begin tmp := result ;
59645: LD_ADDR_VAR 0 9
59649: PUSH
59650: LD_VAR 0 6
59654: ST_TO_ADDR
// for i = tmp downto 1 do
59655: LD_ADDR_VAR 0 7
59659: PUSH
59660: DOUBLE
59661: LD_VAR 0 9
59665: INC
59666: ST_TO_ADDR
59667: LD_INT 1
59669: PUSH
59670: FOR_DOWNTO
59671: IFFALSE 59716
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59673: LD_ADDR_VAR 0 6
59677: PUSH
59678: LD_VAR 0 6
59682: PPUSH
59683: LD_VAR 0 9
59687: PUSH
59688: LD_VAR 0 7
59692: MINUS
59693: PUSH
59694: LD_INT 1
59696: PLUS
59697: PPUSH
59698: LD_VAR 0 9
59702: PUSH
59703: LD_VAR 0 7
59707: ARRAY
59708: PPUSH
59709: CALL_OW 1
59713: ST_TO_ADDR
59714: GO 59670
59716: POP
59717: POP
// end ; tmp := [ ] ;
59718: LD_ADDR_VAR 0 9
59722: PUSH
59723: EMPTY
59724: ST_TO_ADDR
// if mode then
59725: LD_VAR 0 5
59729: IFFALSE 59798
// begin for i = 1 to result do
59731: LD_ADDR_VAR 0 7
59735: PUSH
59736: DOUBLE
59737: LD_INT 1
59739: DEC
59740: ST_TO_ADDR
59741: LD_VAR 0 6
59745: PUSH
59746: FOR_TO
59747: IFFALSE 59786
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59749: LD_ADDR_VAR 0 9
59753: PUSH
59754: LD_VAR 0 9
59758: PPUSH
59759: LD_VAR 0 7
59763: PPUSH
59764: LD_VAR 0 6
59768: PUSH
59769: LD_VAR 0 7
59773: ARRAY
59774: PUSH
59775: LD_INT 1
59777: ARRAY
59778: PPUSH
59779: CALL_OW 1
59783: ST_TO_ADDR
59784: GO 59746
59786: POP
59787: POP
// result := tmp ;
59788: LD_ADDR_VAR 0 6
59792: PUSH
59793: LD_VAR 0 9
59797: ST_TO_ADDR
// end ; end ;
59798: LD_VAR 0 6
59802: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59803: LD_INT 0
59805: PPUSH
59806: PPUSH
59807: PPUSH
59808: PPUSH
59809: PPUSH
59810: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59811: LD_ADDR_VAR 0 5
59815: PUSH
59816: LD_INT 0
59818: PUSH
59819: LD_INT 0
59821: PUSH
59822: LD_INT 0
59824: PUSH
59825: EMPTY
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: LIST
59832: ST_TO_ADDR
// if not x or not y then
59833: LD_VAR 0 2
59837: NOT
59838: PUSH
59839: LD_VAR 0 3
59843: NOT
59844: OR
59845: IFFALSE 59849
// exit ;
59847: GO 61499
// if not range then
59849: LD_VAR 0 4
59853: NOT
59854: IFFALSE 59864
// range := 10 ;
59856: LD_ADDR_VAR 0 4
59860: PUSH
59861: LD_INT 10
59863: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59864: LD_ADDR_VAR 0 8
59868: PUSH
59869: LD_INT 81
59871: PUSH
59872: LD_VAR 0 1
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 92
59883: PUSH
59884: LD_VAR 0 2
59888: PUSH
59889: LD_VAR 0 3
59893: PUSH
59894: LD_VAR 0 4
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: LIST
59903: LIST
59904: PUSH
59905: LD_INT 3
59907: PUSH
59908: LD_INT 21
59910: PUSH
59911: LD_INT 3
59913: PUSH
59914: EMPTY
59915: LIST
59916: LIST
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: LIST
59926: PPUSH
59927: CALL_OW 69
59931: ST_TO_ADDR
// if not tmp then
59932: LD_VAR 0 8
59936: NOT
59937: IFFALSE 59941
// exit ;
59939: GO 61499
// for i in tmp do
59941: LD_ADDR_VAR 0 6
59945: PUSH
59946: LD_VAR 0 8
59950: PUSH
59951: FOR_IN
59952: IFFALSE 61474
// begin points := [ 0 , 0 , 0 ] ;
59954: LD_ADDR_VAR 0 9
59958: PUSH
59959: LD_INT 0
59961: PUSH
59962: LD_INT 0
59964: PUSH
59965: LD_INT 0
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: LIST
59972: ST_TO_ADDR
// bpoints := 1 ;
59973: LD_ADDR_VAR 0 10
59977: PUSH
59978: LD_INT 1
59980: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59981: LD_VAR 0 6
59985: PPUSH
59986: CALL_OW 247
59990: PUSH
59991: LD_INT 1
59993: DOUBLE
59994: EQUAL
59995: IFTRUE 59999
59997: GO 60577
59999: POP
// begin if GetClass ( i ) = 1 then
60000: LD_VAR 0 6
60004: PPUSH
60005: CALL_OW 257
60009: PUSH
60010: LD_INT 1
60012: EQUAL
60013: IFFALSE 60034
// points := [ 10 , 5 , 3 ] ;
60015: LD_ADDR_VAR 0 9
60019: PUSH
60020: LD_INT 10
60022: PUSH
60023: LD_INT 5
60025: PUSH
60026: LD_INT 3
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: LIST
60033: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
60034: LD_VAR 0 6
60038: PPUSH
60039: CALL_OW 257
60043: PUSH
60044: LD_INT 2
60046: PUSH
60047: LD_INT 3
60049: PUSH
60050: LD_INT 4
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: LIST
60057: IN
60058: IFFALSE 60079
// points := [ 3 , 2 , 1 ] ;
60060: LD_ADDR_VAR 0 9
60064: PUSH
60065: LD_INT 3
60067: PUSH
60068: LD_INT 2
60070: PUSH
60071: LD_INT 1
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: LIST
60078: ST_TO_ADDR
// if GetClass ( i ) = 5 then
60079: LD_VAR 0 6
60083: PPUSH
60084: CALL_OW 257
60088: PUSH
60089: LD_INT 5
60091: EQUAL
60092: IFFALSE 60113
// points := [ 130 , 5 , 2 ] ;
60094: LD_ADDR_VAR 0 9
60098: PUSH
60099: LD_INT 130
60101: PUSH
60102: LD_INT 5
60104: PUSH
60105: LD_INT 2
60107: PUSH
60108: EMPTY
60109: LIST
60110: LIST
60111: LIST
60112: ST_TO_ADDR
// if GetClass ( i ) = 8 then
60113: LD_VAR 0 6
60117: PPUSH
60118: CALL_OW 257
60122: PUSH
60123: LD_INT 8
60125: EQUAL
60126: IFFALSE 60147
// points := [ 35 , 35 , 30 ] ;
60128: LD_ADDR_VAR 0 9
60132: PUSH
60133: LD_INT 35
60135: PUSH
60136: LD_INT 35
60138: PUSH
60139: LD_INT 30
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: LIST
60146: ST_TO_ADDR
// if GetClass ( i ) = 9 then
60147: LD_VAR 0 6
60151: PPUSH
60152: CALL_OW 257
60156: PUSH
60157: LD_INT 9
60159: EQUAL
60160: IFFALSE 60181
// points := [ 20 , 55 , 40 ] ;
60162: LD_ADDR_VAR 0 9
60166: PUSH
60167: LD_INT 20
60169: PUSH
60170: LD_INT 55
60172: PUSH
60173: LD_INT 40
60175: PUSH
60176: EMPTY
60177: LIST
60178: LIST
60179: LIST
60180: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
60181: LD_VAR 0 6
60185: PPUSH
60186: CALL_OW 257
60190: PUSH
60191: LD_INT 12
60193: PUSH
60194: LD_INT 16
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: IN
60201: IFFALSE 60222
// points := [ 5 , 3 , 2 ] ;
60203: LD_ADDR_VAR 0 9
60207: PUSH
60208: LD_INT 5
60210: PUSH
60211: LD_INT 3
60213: PUSH
60214: LD_INT 2
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: LIST
60221: ST_TO_ADDR
// if GetClass ( i ) = 17 then
60222: LD_VAR 0 6
60226: PPUSH
60227: CALL_OW 257
60231: PUSH
60232: LD_INT 17
60234: EQUAL
60235: IFFALSE 60256
// points := [ 100 , 50 , 75 ] ;
60237: LD_ADDR_VAR 0 9
60241: PUSH
60242: LD_INT 100
60244: PUSH
60245: LD_INT 50
60247: PUSH
60248: LD_INT 75
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: LIST
60255: ST_TO_ADDR
// if GetClass ( i ) = 15 then
60256: LD_VAR 0 6
60260: PPUSH
60261: CALL_OW 257
60265: PUSH
60266: LD_INT 15
60268: EQUAL
60269: IFFALSE 60290
// points := [ 10 , 5 , 3 ] ;
60271: LD_ADDR_VAR 0 9
60275: PUSH
60276: LD_INT 10
60278: PUSH
60279: LD_INT 5
60281: PUSH
60282: LD_INT 3
60284: PUSH
60285: EMPTY
60286: LIST
60287: LIST
60288: LIST
60289: ST_TO_ADDR
// if GetClass ( i ) = 14 then
60290: LD_VAR 0 6
60294: PPUSH
60295: CALL_OW 257
60299: PUSH
60300: LD_INT 14
60302: EQUAL
60303: IFFALSE 60324
// points := [ 10 , 0 , 0 ] ;
60305: LD_ADDR_VAR 0 9
60309: PUSH
60310: LD_INT 10
60312: PUSH
60313: LD_INT 0
60315: PUSH
60316: LD_INT 0
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: LIST
60323: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60324: LD_VAR 0 6
60328: PPUSH
60329: CALL_OW 257
60333: PUSH
60334: LD_INT 11
60336: EQUAL
60337: IFFALSE 60358
// points := [ 30 , 10 , 5 ] ;
60339: LD_ADDR_VAR 0 9
60343: PUSH
60344: LD_INT 30
60346: PUSH
60347: LD_INT 10
60349: PUSH
60350: LD_INT 5
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: LIST
60357: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60358: LD_VAR 0 1
60362: PPUSH
60363: LD_INT 5
60365: PPUSH
60366: CALL_OW 321
60370: PUSH
60371: LD_INT 2
60373: EQUAL
60374: IFFALSE 60391
// bpoints := bpoints * 1.8 ;
60376: LD_ADDR_VAR 0 10
60380: PUSH
60381: LD_VAR 0 10
60385: PUSH
60386: LD_REAL  1.80000000000000E+0000
60389: MUL
60390: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60391: LD_VAR 0 6
60395: PPUSH
60396: CALL_OW 257
60400: PUSH
60401: LD_INT 1
60403: PUSH
60404: LD_INT 2
60406: PUSH
60407: LD_INT 3
60409: PUSH
60410: LD_INT 4
60412: PUSH
60413: EMPTY
60414: LIST
60415: LIST
60416: LIST
60417: LIST
60418: IN
60419: PUSH
60420: LD_VAR 0 1
60424: PPUSH
60425: LD_INT 51
60427: PPUSH
60428: CALL_OW 321
60432: PUSH
60433: LD_INT 2
60435: EQUAL
60436: AND
60437: IFFALSE 60454
// bpoints := bpoints * 1.2 ;
60439: LD_ADDR_VAR 0 10
60443: PUSH
60444: LD_VAR 0 10
60448: PUSH
60449: LD_REAL  1.20000000000000E+0000
60452: MUL
60453: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60454: LD_VAR 0 6
60458: PPUSH
60459: CALL_OW 257
60463: PUSH
60464: LD_INT 5
60466: PUSH
60467: LD_INT 7
60469: PUSH
60470: LD_INT 9
60472: PUSH
60473: EMPTY
60474: LIST
60475: LIST
60476: LIST
60477: IN
60478: PUSH
60479: LD_VAR 0 1
60483: PPUSH
60484: LD_INT 52
60486: PPUSH
60487: CALL_OW 321
60491: PUSH
60492: LD_INT 2
60494: EQUAL
60495: AND
60496: IFFALSE 60513
// bpoints := bpoints * 1.5 ;
60498: LD_ADDR_VAR 0 10
60502: PUSH
60503: LD_VAR 0 10
60507: PUSH
60508: LD_REAL  1.50000000000000E+0000
60511: MUL
60512: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60513: LD_VAR 0 1
60517: PPUSH
60518: LD_INT 66
60520: PPUSH
60521: CALL_OW 321
60525: PUSH
60526: LD_INT 2
60528: EQUAL
60529: IFFALSE 60546
// bpoints := bpoints * 1.1 ;
60531: LD_ADDR_VAR 0 10
60535: PUSH
60536: LD_VAR 0 10
60540: PUSH
60541: LD_REAL  1.10000000000000E+0000
60544: MUL
60545: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60546: LD_ADDR_VAR 0 10
60550: PUSH
60551: LD_VAR 0 10
60555: PUSH
60556: LD_VAR 0 6
60560: PPUSH
60561: LD_INT 1
60563: PPUSH
60564: CALL_OW 259
60568: PUSH
60569: LD_REAL  1.15000000000000E+0000
60572: MUL
60573: MUL
60574: ST_TO_ADDR
// end ; unit_vehicle :
60575: GO 61403
60577: LD_INT 2
60579: DOUBLE
60580: EQUAL
60581: IFTRUE 60585
60583: GO 61391
60585: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60586: LD_VAR 0 6
60590: PPUSH
60591: CALL_OW 264
60595: PUSH
60596: LD_INT 2
60598: PUSH
60599: LD_INT 42
60601: PUSH
60602: LD_INT 24
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: LIST
60609: IN
60610: IFFALSE 60631
// points := [ 25 , 5 , 3 ] ;
60612: LD_ADDR_VAR 0 9
60616: PUSH
60617: LD_INT 25
60619: PUSH
60620: LD_INT 5
60622: PUSH
60623: LD_INT 3
60625: PUSH
60626: EMPTY
60627: LIST
60628: LIST
60629: LIST
60630: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60631: LD_VAR 0 6
60635: PPUSH
60636: CALL_OW 264
60640: PUSH
60641: LD_INT 4
60643: PUSH
60644: LD_INT 43
60646: PUSH
60647: LD_INT 25
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: LIST
60654: IN
60655: IFFALSE 60676
// points := [ 40 , 15 , 5 ] ;
60657: LD_ADDR_VAR 0 9
60661: PUSH
60662: LD_INT 40
60664: PUSH
60665: LD_INT 15
60667: PUSH
60668: LD_INT 5
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: LIST
60675: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60676: LD_VAR 0 6
60680: PPUSH
60681: CALL_OW 264
60685: PUSH
60686: LD_INT 3
60688: PUSH
60689: LD_INT 23
60691: PUSH
60692: EMPTY
60693: LIST
60694: LIST
60695: IN
60696: IFFALSE 60717
// points := [ 7 , 25 , 8 ] ;
60698: LD_ADDR_VAR 0 9
60702: PUSH
60703: LD_INT 7
60705: PUSH
60706: LD_INT 25
60708: PUSH
60709: LD_INT 8
60711: PUSH
60712: EMPTY
60713: LIST
60714: LIST
60715: LIST
60716: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60717: LD_VAR 0 6
60721: PPUSH
60722: CALL_OW 264
60726: PUSH
60727: LD_INT 5
60729: PUSH
60730: LD_INT 27
60732: PUSH
60733: LD_INT 44
60735: PUSH
60736: EMPTY
60737: LIST
60738: LIST
60739: LIST
60740: IN
60741: IFFALSE 60762
// points := [ 14 , 50 , 16 ] ;
60743: LD_ADDR_VAR 0 9
60747: PUSH
60748: LD_INT 14
60750: PUSH
60751: LD_INT 50
60753: PUSH
60754: LD_INT 16
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: LIST
60761: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60762: LD_VAR 0 6
60766: PPUSH
60767: CALL_OW 264
60771: PUSH
60772: LD_INT 6
60774: PUSH
60775: LD_INT 46
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: IN
60782: IFFALSE 60803
// points := [ 32 , 120 , 70 ] ;
60784: LD_ADDR_VAR 0 9
60788: PUSH
60789: LD_INT 32
60791: PUSH
60792: LD_INT 120
60794: PUSH
60795: LD_INT 70
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: LIST
60802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60803: LD_VAR 0 6
60807: PPUSH
60808: CALL_OW 264
60812: PUSH
60813: LD_INT 7
60815: PUSH
60816: LD_INT 28
60818: PUSH
60819: LD_INT 45
60821: PUSH
60822: LD_INT 92
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: LIST
60829: LIST
60830: IN
60831: IFFALSE 60852
// points := [ 35 , 20 , 45 ] ;
60833: LD_ADDR_VAR 0 9
60837: PUSH
60838: LD_INT 35
60840: PUSH
60841: LD_INT 20
60843: PUSH
60844: LD_INT 45
60846: PUSH
60847: EMPTY
60848: LIST
60849: LIST
60850: LIST
60851: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60852: LD_VAR 0 6
60856: PPUSH
60857: CALL_OW 264
60861: PUSH
60862: LD_INT 47
60864: PUSH
60865: EMPTY
60866: LIST
60867: IN
60868: IFFALSE 60889
// points := [ 67 , 45 , 75 ] ;
60870: LD_ADDR_VAR 0 9
60874: PUSH
60875: LD_INT 67
60877: PUSH
60878: LD_INT 45
60880: PUSH
60881: LD_INT 75
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: LIST
60888: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60889: LD_VAR 0 6
60893: PPUSH
60894: CALL_OW 264
60898: PUSH
60899: LD_INT 26
60901: PUSH
60902: EMPTY
60903: LIST
60904: IN
60905: IFFALSE 60926
// points := [ 120 , 30 , 80 ] ;
60907: LD_ADDR_VAR 0 9
60911: PUSH
60912: LD_INT 120
60914: PUSH
60915: LD_INT 30
60917: PUSH
60918: LD_INT 80
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: LIST
60925: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60926: LD_VAR 0 6
60930: PPUSH
60931: CALL_OW 264
60935: PUSH
60936: LD_INT 22
60938: PUSH
60939: EMPTY
60940: LIST
60941: IN
60942: IFFALSE 60963
// points := [ 40 , 1 , 1 ] ;
60944: LD_ADDR_VAR 0 9
60948: PUSH
60949: LD_INT 40
60951: PUSH
60952: LD_INT 1
60954: PUSH
60955: LD_INT 1
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: LIST
60962: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60963: LD_VAR 0 6
60967: PPUSH
60968: CALL_OW 264
60972: PUSH
60973: LD_INT 29
60975: PUSH
60976: EMPTY
60977: LIST
60978: IN
60979: IFFALSE 61000
// points := [ 70 , 200 , 400 ] ;
60981: LD_ADDR_VAR 0 9
60985: PUSH
60986: LD_INT 70
60988: PUSH
60989: LD_INT 200
60991: PUSH
60992: LD_INT 400
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: LIST
60999: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
61000: LD_VAR 0 6
61004: PPUSH
61005: CALL_OW 264
61009: PUSH
61010: LD_INT 14
61012: PUSH
61013: LD_INT 53
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: IN
61020: IFFALSE 61041
// points := [ 40 , 10 , 20 ] ;
61022: LD_ADDR_VAR 0 9
61026: PUSH
61027: LD_INT 40
61029: PUSH
61030: LD_INT 10
61032: PUSH
61033: LD_INT 20
61035: PUSH
61036: EMPTY
61037: LIST
61038: LIST
61039: LIST
61040: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
61041: LD_VAR 0 6
61045: PPUSH
61046: CALL_OW 264
61050: PUSH
61051: LD_INT 9
61053: PUSH
61054: EMPTY
61055: LIST
61056: IN
61057: IFFALSE 61078
// points := [ 5 , 70 , 20 ] ;
61059: LD_ADDR_VAR 0 9
61063: PUSH
61064: LD_INT 5
61066: PUSH
61067: LD_INT 70
61069: PUSH
61070: LD_INT 20
61072: PUSH
61073: EMPTY
61074: LIST
61075: LIST
61076: LIST
61077: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
61078: LD_VAR 0 6
61082: PPUSH
61083: CALL_OW 264
61087: PUSH
61088: LD_INT 10
61090: PUSH
61091: EMPTY
61092: LIST
61093: IN
61094: IFFALSE 61115
// points := [ 35 , 110 , 70 ] ;
61096: LD_ADDR_VAR 0 9
61100: PUSH
61101: LD_INT 35
61103: PUSH
61104: LD_INT 110
61106: PUSH
61107: LD_INT 70
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: LIST
61114: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
61115: LD_VAR 0 6
61119: PPUSH
61120: CALL_OW 265
61124: PUSH
61125: LD_INT 25
61127: EQUAL
61128: IFFALSE 61149
// points := [ 80 , 65 , 100 ] ;
61130: LD_ADDR_VAR 0 9
61134: PUSH
61135: LD_INT 80
61137: PUSH
61138: LD_INT 65
61140: PUSH
61141: LD_INT 100
61143: PUSH
61144: EMPTY
61145: LIST
61146: LIST
61147: LIST
61148: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
61149: LD_VAR 0 6
61153: PPUSH
61154: CALL_OW 263
61158: PUSH
61159: LD_INT 1
61161: EQUAL
61162: IFFALSE 61197
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
61164: LD_ADDR_VAR 0 10
61168: PUSH
61169: LD_VAR 0 10
61173: PUSH
61174: LD_VAR 0 6
61178: PPUSH
61179: CALL_OW 311
61183: PPUSH
61184: LD_INT 3
61186: PPUSH
61187: CALL_OW 259
61191: PUSH
61192: LD_INT 4
61194: MUL
61195: MUL
61196: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
61197: LD_VAR 0 6
61201: PPUSH
61202: CALL_OW 263
61206: PUSH
61207: LD_INT 2
61209: EQUAL
61210: IFFALSE 61261
// begin j := IsControledBy ( i ) ;
61212: LD_ADDR_VAR 0 7
61216: PUSH
61217: LD_VAR 0 6
61221: PPUSH
61222: CALL_OW 312
61226: ST_TO_ADDR
// if j then
61227: LD_VAR 0 7
61231: IFFALSE 61261
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
61233: LD_ADDR_VAR 0 10
61237: PUSH
61238: LD_VAR 0 10
61242: PUSH
61243: LD_VAR 0 7
61247: PPUSH
61248: LD_INT 3
61250: PPUSH
61251: CALL_OW 259
61255: PUSH
61256: LD_INT 3
61258: MUL
61259: MUL
61260: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
61261: LD_VAR 0 6
61265: PPUSH
61266: CALL_OW 264
61270: PUSH
61271: LD_INT 5
61273: PUSH
61274: LD_INT 6
61276: PUSH
61277: LD_INT 46
61279: PUSH
61280: LD_INT 44
61282: PUSH
61283: LD_INT 47
61285: PUSH
61286: LD_INT 45
61288: PUSH
61289: LD_INT 28
61291: PUSH
61292: LD_INT 7
61294: PUSH
61295: LD_INT 27
61297: PUSH
61298: LD_INT 29
61300: PUSH
61301: EMPTY
61302: LIST
61303: LIST
61304: LIST
61305: LIST
61306: LIST
61307: LIST
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: IN
61313: PUSH
61314: LD_VAR 0 1
61318: PPUSH
61319: LD_INT 52
61321: PPUSH
61322: CALL_OW 321
61326: PUSH
61327: LD_INT 2
61329: EQUAL
61330: AND
61331: IFFALSE 61348
// bpoints := bpoints * 1.2 ;
61333: LD_ADDR_VAR 0 10
61337: PUSH
61338: LD_VAR 0 10
61342: PUSH
61343: LD_REAL  1.20000000000000E+0000
61346: MUL
61347: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61348: LD_VAR 0 6
61352: PPUSH
61353: CALL_OW 264
61357: PUSH
61358: LD_INT 6
61360: PUSH
61361: LD_INT 46
61363: PUSH
61364: LD_INT 47
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: LIST
61371: IN
61372: IFFALSE 61389
// bpoints := bpoints * 1.2 ;
61374: LD_ADDR_VAR 0 10
61378: PUSH
61379: LD_VAR 0 10
61383: PUSH
61384: LD_REAL  1.20000000000000E+0000
61387: MUL
61388: ST_TO_ADDR
// end ; unit_building :
61389: GO 61403
61391: LD_INT 3
61393: DOUBLE
61394: EQUAL
61395: IFTRUE 61399
61397: GO 61402
61399: POP
// ; end ;
61400: GO 61403
61402: POP
// for j = 1 to 3 do
61403: LD_ADDR_VAR 0 7
61407: PUSH
61408: DOUBLE
61409: LD_INT 1
61411: DEC
61412: ST_TO_ADDR
61413: LD_INT 3
61415: PUSH
61416: FOR_TO
61417: IFFALSE 61470
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61419: LD_ADDR_VAR 0 5
61423: PUSH
61424: LD_VAR 0 5
61428: PPUSH
61429: LD_VAR 0 7
61433: PPUSH
61434: LD_VAR 0 5
61438: PUSH
61439: LD_VAR 0 7
61443: ARRAY
61444: PUSH
61445: LD_VAR 0 9
61449: PUSH
61450: LD_VAR 0 7
61454: ARRAY
61455: PUSH
61456: LD_VAR 0 10
61460: MUL
61461: PLUS
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
61468: GO 61416
61470: POP
61471: POP
// end ;
61472: GO 59951
61474: POP
61475: POP
// result := Replace ( result , 4 , tmp ) ;
61476: LD_ADDR_VAR 0 5
61480: PUSH
61481: LD_VAR 0 5
61485: PPUSH
61486: LD_INT 4
61488: PPUSH
61489: LD_VAR 0 8
61493: PPUSH
61494: CALL_OW 1
61498: ST_TO_ADDR
// end ;
61499: LD_VAR 0 5
61503: RET
// export function DangerAtRange ( unit , range ) ; begin
61504: LD_INT 0
61506: PPUSH
// if not unit then
61507: LD_VAR 0 1
61511: NOT
61512: IFFALSE 61516
// exit ;
61514: GO 61561
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61516: LD_ADDR_VAR 0 3
61520: PUSH
61521: LD_VAR 0 1
61525: PPUSH
61526: CALL_OW 255
61530: PPUSH
61531: LD_VAR 0 1
61535: PPUSH
61536: CALL_OW 250
61540: PPUSH
61541: LD_VAR 0 1
61545: PPUSH
61546: CALL_OW 251
61550: PPUSH
61551: LD_VAR 0 2
61555: PPUSH
61556: CALL 59803 0 4
61560: ST_TO_ADDR
// end ;
61561: LD_VAR 0 3
61565: RET
// export function DangerInArea ( side , area ) ; begin
61566: LD_INT 0
61568: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61569: LD_ADDR_VAR 0 3
61573: PUSH
61574: LD_VAR 0 2
61578: PPUSH
61579: LD_INT 81
61581: PUSH
61582: LD_VAR 0 1
61586: PUSH
61587: EMPTY
61588: LIST
61589: LIST
61590: PPUSH
61591: CALL_OW 70
61595: ST_TO_ADDR
// end ;
61596: LD_VAR 0 3
61600: RET
// export function IsExtension ( b ) ; begin
61601: LD_INT 0
61603: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61604: LD_ADDR_VAR 0 2
61608: PUSH
61609: LD_VAR 0 1
61613: PUSH
61614: LD_INT 23
61616: PUSH
61617: LD_INT 20
61619: PUSH
61620: LD_INT 22
61622: PUSH
61623: LD_INT 17
61625: PUSH
61626: LD_INT 24
61628: PUSH
61629: LD_INT 21
61631: PUSH
61632: LD_INT 19
61634: PUSH
61635: LD_INT 16
61637: PUSH
61638: LD_INT 25
61640: PUSH
61641: LD_INT 18
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: LIST
61652: LIST
61653: LIST
61654: LIST
61655: IN
61656: ST_TO_ADDR
// end ;
61657: LD_VAR 0 2
61661: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61662: LD_INT 0
61664: PPUSH
61665: PPUSH
61666: PPUSH
// result := [ ] ;
61667: LD_ADDR_VAR 0 4
61671: PUSH
61672: EMPTY
61673: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61674: LD_ADDR_VAR 0 5
61678: PUSH
61679: LD_VAR 0 2
61683: PPUSH
61684: LD_INT 21
61686: PUSH
61687: LD_INT 3
61689: PUSH
61690: EMPTY
61691: LIST
61692: LIST
61693: PPUSH
61694: CALL_OW 70
61698: ST_TO_ADDR
// if not tmp then
61699: LD_VAR 0 5
61703: NOT
61704: IFFALSE 61708
// exit ;
61706: GO 61772
// if checkLink then
61708: LD_VAR 0 3
61712: IFFALSE 61762
// begin for i in tmp do
61714: LD_ADDR_VAR 0 6
61718: PUSH
61719: LD_VAR 0 5
61723: PUSH
61724: FOR_IN
61725: IFFALSE 61760
// if GetBase ( i ) <> base then
61727: LD_VAR 0 6
61731: PPUSH
61732: CALL_OW 274
61736: PUSH
61737: LD_VAR 0 1
61741: NONEQUAL
61742: IFFALSE 61758
// ComLinkToBase ( base , i ) ;
61744: LD_VAR 0 1
61748: PPUSH
61749: LD_VAR 0 6
61753: PPUSH
61754: CALL_OW 169
61758: GO 61724
61760: POP
61761: POP
// end ; result := tmp ;
61762: LD_ADDR_VAR 0 4
61766: PUSH
61767: LD_VAR 0 5
61771: ST_TO_ADDR
// end ;
61772: LD_VAR 0 4
61776: RET
// export function ComComplete ( units , b ) ; var i ; begin
61777: LD_INT 0
61779: PPUSH
61780: PPUSH
// if not units then
61781: LD_VAR 0 1
61785: NOT
61786: IFFALSE 61790
// exit ;
61788: GO 61880
// for i in units do
61790: LD_ADDR_VAR 0 4
61794: PUSH
61795: LD_VAR 0 1
61799: PUSH
61800: FOR_IN
61801: IFFALSE 61878
// if BuildingStatus ( b ) = bs_build then
61803: LD_VAR 0 2
61807: PPUSH
61808: CALL_OW 461
61812: PUSH
61813: LD_INT 1
61815: EQUAL
61816: IFFALSE 61876
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61818: LD_VAR 0 4
61822: PPUSH
61823: LD_STRING h
61825: PUSH
61826: LD_VAR 0 2
61830: PPUSH
61831: CALL_OW 250
61835: PUSH
61836: LD_VAR 0 2
61840: PPUSH
61841: CALL_OW 251
61845: PUSH
61846: LD_VAR 0 2
61850: PUSH
61851: LD_INT 0
61853: PUSH
61854: LD_INT 0
61856: PUSH
61857: LD_INT 0
61859: PUSH
61860: EMPTY
61861: LIST
61862: LIST
61863: LIST
61864: LIST
61865: LIST
61866: LIST
61867: LIST
61868: PUSH
61869: EMPTY
61870: LIST
61871: PPUSH
61872: CALL_OW 446
61876: GO 61800
61878: POP
61879: POP
// end ;
61880: LD_VAR 0 3
61884: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61885: LD_INT 0
61887: PPUSH
61888: PPUSH
61889: PPUSH
61890: PPUSH
61891: PPUSH
61892: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61893: LD_VAR 0 1
61897: NOT
61898: PUSH
61899: LD_VAR 0 1
61903: PPUSH
61904: CALL_OW 263
61908: PUSH
61909: LD_INT 2
61911: NONEQUAL
61912: OR
61913: IFFALSE 61917
// exit ;
61915: GO 62233
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61917: LD_ADDR_VAR 0 6
61921: PUSH
61922: LD_INT 22
61924: PUSH
61925: LD_VAR 0 1
61929: PPUSH
61930: CALL_OW 255
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PUSH
61939: LD_INT 2
61941: PUSH
61942: LD_INT 30
61944: PUSH
61945: LD_INT 36
61947: PUSH
61948: EMPTY
61949: LIST
61950: LIST
61951: PUSH
61952: LD_INT 34
61954: PUSH
61955: LD_INT 31
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PUSH
61962: EMPTY
61963: LIST
61964: LIST
61965: LIST
61966: PUSH
61967: EMPTY
61968: LIST
61969: LIST
61970: PPUSH
61971: CALL_OW 69
61975: ST_TO_ADDR
// if not tmp then
61976: LD_VAR 0 6
61980: NOT
61981: IFFALSE 61985
// exit ;
61983: GO 62233
// result := [ ] ;
61985: LD_ADDR_VAR 0 2
61989: PUSH
61990: EMPTY
61991: ST_TO_ADDR
// for i in tmp do
61992: LD_ADDR_VAR 0 3
61996: PUSH
61997: LD_VAR 0 6
62001: PUSH
62002: FOR_IN
62003: IFFALSE 62074
// begin t := UnitsInside ( i ) ;
62005: LD_ADDR_VAR 0 4
62009: PUSH
62010: LD_VAR 0 3
62014: PPUSH
62015: CALL_OW 313
62019: ST_TO_ADDR
// if t then
62020: LD_VAR 0 4
62024: IFFALSE 62072
// for j in t do
62026: LD_ADDR_VAR 0 7
62030: PUSH
62031: LD_VAR 0 4
62035: PUSH
62036: FOR_IN
62037: IFFALSE 62070
// result := Replace ( result , result + 1 , j ) ;
62039: LD_ADDR_VAR 0 2
62043: PUSH
62044: LD_VAR 0 2
62048: PPUSH
62049: LD_VAR 0 2
62053: PUSH
62054: LD_INT 1
62056: PLUS
62057: PPUSH
62058: LD_VAR 0 7
62062: PPUSH
62063: CALL_OW 1
62067: ST_TO_ADDR
62068: GO 62036
62070: POP
62071: POP
// end ;
62072: GO 62002
62074: POP
62075: POP
// if not result then
62076: LD_VAR 0 2
62080: NOT
62081: IFFALSE 62085
// exit ;
62083: GO 62233
// mech := result [ 1 ] ;
62085: LD_ADDR_VAR 0 5
62089: PUSH
62090: LD_VAR 0 2
62094: PUSH
62095: LD_INT 1
62097: ARRAY
62098: ST_TO_ADDR
// if result > 1 then
62099: LD_VAR 0 2
62103: PUSH
62104: LD_INT 1
62106: GREATER
62107: IFFALSE 62219
// begin for i = 2 to result do
62109: LD_ADDR_VAR 0 3
62113: PUSH
62114: DOUBLE
62115: LD_INT 2
62117: DEC
62118: ST_TO_ADDR
62119: LD_VAR 0 2
62123: PUSH
62124: FOR_TO
62125: IFFALSE 62217
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
62127: LD_ADDR_VAR 0 4
62131: PUSH
62132: LD_VAR 0 2
62136: PUSH
62137: LD_VAR 0 3
62141: ARRAY
62142: PPUSH
62143: LD_INT 3
62145: PPUSH
62146: CALL_OW 259
62150: PUSH
62151: LD_VAR 0 2
62155: PUSH
62156: LD_VAR 0 3
62160: ARRAY
62161: PPUSH
62162: CALL_OW 432
62166: MINUS
62167: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
62168: LD_VAR 0 4
62172: PUSH
62173: LD_VAR 0 5
62177: PPUSH
62178: LD_INT 3
62180: PPUSH
62181: CALL_OW 259
62185: PUSH
62186: LD_VAR 0 5
62190: PPUSH
62191: CALL_OW 432
62195: MINUS
62196: GREATEREQUAL
62197: IFFALSE 62215
// mech := result [ i ] ;
62199: LD_ADDR_VAR 0 5
62203: PUSH
62204: LD_VAR 0 2
62208: PUSH
62209: LD_VAR 0 3
62213: ARRAY
62214: ST_TO_ADDR
// end ;
62215: GO 62124
62217: POP
62218: POP
// end ; ComLinkTo ( vehicle , mech ) ;
62219: LD_VAR 0 1
62223: PPUSH
62224: LD_VAR 0 5
62228: PPUSH
62229: CALL_OW 135
// end ;
62233: LD_VAR 0 2
62237: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
62238: LD_INT 0
62240: PPUSH
62241: PPUSH
62242: PPUSH
62243: PPUSH
62244: PPUSH
62245: PPUSH
62246: PPUSH
62247: PPUSH
62248: PPUSH
62249: PPUSH
62250: PPUSH
62251: PPUSH
62252: PPUSH
// result := [ ] ;
62253: LD_ADDR_VAR 0 7
62257: PUSH
62258: EMPTY
62259: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
62260: LD_VAR 0 1
62264: PPUSH
62265: CALL_OW 266
62269: PUSH
62270: LD_INT 0
62272: PUSH
62273: LD_INT 1
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: IN
62280: NOT
62281: IFFALSE 62285
// exit ;
62283: GO 63919
// if name then
62285: LD_VAR 0 3
62289: IFFALSE 62305
// SetBName ( base_dep , name ) ;
62291: LD_VAR 0 1
62295: PPUSH
62296: LD_VAR 0 3
62300: PPUSH
62301: CALL_OW 500
// base := GetBase ( base_dep ) ;
62305: LD_ADDR_VAR 0 15
62309: PUSH
62310: LD_VAR 0 1
62314: PPUSH
62315: CALL_OW 274
62319: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62320: LD_ADDR_VAR 0 16
62324: PUSH
62325: LD_VAR 0 1
62329: PPUSH
62330: CALL_OW 255
62334: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62335: LD_ADDR_VAR 0 17
62339: PUSH
62340: LD_VAR 0 1
62344: PPUSH
62345: CALL_OW 248
62349: ST_TO_ADDR
// if sources then
62350: LD_VAR 0 5
62354: IFFALSE 62401
// for i = 1 to 3 do
62356: LD_ADDR_VAR 0 8
62360: PUSH
62361: DOUBLE
62362: LD_INT 1
62364: DEC
62365: ST_TO_ADDR
62366: LD_INT 3
62368: PUSH
62369: FOR_TO
62370: IFFALSE 62399
// AddResourceType ( base , i , sources [ i ] ) ;
62372: LD_VAR 0 15
62376: PPUSH
62377: LD_VAR 0 8
62381: PPUSH
62382: LD_VAR 0 5
62386: PUSH
62387: LD_VAR 0 8
62391: ARRAY
62392: PPUSH
62393: CALL_OW 276
62397: GO 62369
62399: POP
62400: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62401: LD_ADDR_VAR 0 18
62405: PUSH
62406: LD_VAR 0 15
62410: PPUSH
62411: LD_VAR 0 2
62415: PPUSH
62416: LD_INT 1
62418: PPUSH
62419: CALL 61662 0 3
62423: ST_TO_ADDR
// InitHc ;
62424: CALL_OW 19
// InitUc ;
62428: CALL_OW 18
// uc_side := side ;
62432: LD_ADDR_OWVAR 20
62436: PUSH
62437: LD_VAR 0 16
62441: ST_TO_ADDR
// uc_nation := nation ;
62442: LD_ADDR_OWVAR 21
62446: PUSH
62447: LD_VAR 0 17
62451: ST_TO_ADDR
// if buildings then
62452: LD_VAR 0 18
62456: IFFALSE 63778
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62458: LD_ADDR_VAR 0 19
62462: PUSH
62463: LD_VAR 0 18
62467: PPUSH
62468: LD_INT 2
62470: PUSH
62471: LD_INT 30
62473: PUSH
62474: LD_INT 29
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 30
62483: PUSH
62484: LD_INT 30
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: LIST
62495: PPUSH
62496: CALL_OW 72
62500: ST_TO_ADDR
// if tmp then
62501: LD_VAR 0 19
62505: IFFALSE 62553
// for i in tmp do
62507: LD_ADDR_VAR 0 8
62511: PUSH
62512: LD_VAR 0 19
62516: PUSH
62517: FOR_IN
62518: IFFALSE 62551
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62520: LD_VAR 0 8
62524: PPUSH
62525: CALL_OW 250
62529: PPUSH
62530: LD_VAR 0 8
62534: PPUSH
62535: CALL_OW 251
62539: PPUSH
62540: LD_VAR 0 16
62544: PPUSH
62545: CALL_OW 441
62549: GO 62517
62551: POP
62552: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62553: LD_VAR 0 18
62557: PPUSH
62558: LD_INT 2
62560: PUSH
62561: LD_INT 30
62563: PUSH
62564: LD_INT 32
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PUSH
62571: LD_INT 30
62573: PUSH
62574: LD_INT 33
62576: PUSH
62577: EMPTY
62578: LIST
62579: LIST
62580: PUSH
62581: EMPTY
62582: LIST
62583: LIST
62584: LIST
62585: PPUSH
62586: CALL_OW 72
62590: IFFALSE 62678
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62592: LD_ADDR_VAR 0 8
62596: PUSH
62597: LD_VAR 0 18
62601: PPUSH
62602: LD_INT 2
62604: PUSH
62605: LD_INT 30
62607: PUSH
62608: LD_INT 32
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PUSH
62615: LD_INT 30
62617: PUSH
62618: LD_INT 33
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: LIST
62629: PPUSH
62630: CALL_OW 72
62634: PUSH
62635: FOR_IN
62636: IFFALSE 62676
// begin if not GetBWeapon ( i ) then
62638: LD_VAR 0 8
62642: PPUSH
62643: CALL_OW 269
62647: NOT
62648: IFFALSE 62674
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62650: LD_VAR 0 8
62654: PPUSH
62655: LD_VAR 0 8
62659: PPUSH
62660: LD_VAR 0 2
62664: PPUSH
62665: CALL 63924 0 2
62669: PPUSH
62670: CALL_OW 431
// end ;
62674: GO 62635
62676: POP
62677: POP
// end ; for i = 1 to personel do
62678: LD_ADDR_VAR 0 8
62682: PUSH
62683: DOUBLE
62684: LD_INT 1
62686: DEC
62687: ST_TO_ADDR
62688: LD_VAR 0 6
62692: PUSH
62693: FOR_TO
62694: IFFALSE 63758
// begin if i > 4 then
62696: LD_VAR 0 8
62700: PUSH
62701: LD_INT 4
62703: GREATER
62704: IFFALSE 62708
// break ;
62706: GO 63758
// case i of 1 :
62708: LD_VAR 0 8
62712: PUSH
62713: LD_INT 1
62715: DOUBLE
62716: EQUAL
62717: IFTRUE 62721
62719: GO 62801
62721: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62722: LD_ADDR_VAR 0 12
62726: PUSH
62727: LD_VAR 0 18
62731: PPUSH
62732: LD_INT 22
62734: PUSH
62735: LD_VAR 0 16
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PUSH
62744: LD_INT 58
62746: PUSH
62747: EMPTY
62748: LIST
62749: PUSH
62750: LD_INT 2
62752: PUSH
62753: LD_INT 30
62755: PUSH
62756: LD_INT 32
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 30
62765: PUSH
62766: LD_INT 4
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 30
62775: PUSH
62776: LD_INT 5
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: LIST
62793: PPUSH
62794: CALL_OW 72
62798: ST_TO_ADDR
62799: GO 63023
62801: LD_INT 2
62803: DOUBLE
62804: EQUAL
62805: IFTRUE 62809
62807: GO 62871
62809: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62810: LD_ADDR_VAR 0 12
62814: PUSH
62815: LD_VAR 0 18
62819: PPUSH
62820: LD_INT 22
62822: PUSH
62823: LD_VAR 0 16
62827: PUSH
62828: EMPTY
62829: LIST
62830: LIST
62831: PUSH
62832: LD_INT 2
62834: PUSH
62835: LD_INT 30
62837: PUSH
62838: LD_INT 0
62840: PUSH
62841: EMPTY
62842: LIST
62843: LIST
62844: PUSH
62845: LD_INT 30
62847: PUSH
62848: LD_INT 1
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: PUSH
62855: EMPTY
62856: LIST
62857: LIST
62858: LIST
62859: PUSH
62860: EMPTY
62861: LIST
62862: LIST
62863: PPUSH
62864: CALL_OW 72
62868: ST_TO_ADDR
62869: GO 63023
62871: LD_INT 3
62873: DOUBLE
62874: EQUAL
62875: IFTRUE 62879
62877: GO 62941
62879: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62880: LD_ADDR_VAR 0 12
62884: PUSH
62885: LD_VAR 0 18
62889: PPUSH
62890: LD_INT 22
62892: PUSH
62893: LD_VAR 0 16
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: LD_INT 2
62904: PUSH
62905: LD_INT 30
62907: PUSH
62908: LD_INT 2
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 30
62917: PUSH
62918: LD_INT 3
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: LIST
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PPUSH
62934: CALL_OW 72
62938: ST_TO_ADDR
62939: GO 63023
62941: LD_INT 4
62943: DOUBLE
62944: EQUAL
62945: IFTRUE 62949
62947: GO 63022
62949: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62950: LD_ADDR_VAR 0 12
62954: PUSH
62955: LD_VAR 0 18
62959: PPUSH
62960: LD_INT 22
62962: PUSH
62963: LD_VAR 0 16
62967: PUSH
62968: EMPTY
62969: LIST
62970: LIST
62971: PUSH
62972: LD_INT 2
62974: PUSH
62975: LD_INT 30
62977: PUSH
62978: LD_INT 6
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PUSH
62985: LD_INT 30
62987: PUSH
62988: LD_INT 7
62990: PUSH
62991: EMPTY
62992: LIST
62993: LIST
62994: PUSH
62995: LD_INT 30
62997: PUSH
62998: LD_INT 8
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PPUSH
63015: CALL_OW 72
63019: ST_TO_ADDR
63020: GO 63023
63022: POP
// if i = 1 then
63023: LD_VAR 0 8
63027: PUSH
63028: LD_INT 1
63030: EQUAL
63031: IFFALSE 63142
// begin tmp := [ ] ;
63033: LD_ADDR_VAR 0 19
63037: PUSH
63038: EMPTY
63039: ST_TO_ADDR
// for j in f do
63040: LD_ADDR_VAR 0 9
63044: PUSH
63045: LD_VAR 0 12
63049: PUSH
63050: FOR_IN
63051: IFFALSE 63124
// if GetBType ( j ) = b_bunker then
63053: LD_VAR 0 9
63057: PPUSH
63058: CALL_OW 266
63062: PUSH
63063: LD_INT 32
63065: EQUAL
63066: IFFALSE 63093
// tmp := Insert ( tmp , 1 , j ) else
63068: LD_ADDR_VAR 0 19
63072: PUSH
63073: LD_VAR 0 19
63077: PPUSH
63078: LD_INT 1
63080: PPUSH
63081: LD_VAR 0 9
63085: PPUSH
63086: CALL_OW 2
63090: ST_TO_ADDR
63091: GO 63122
// tmp := Insert ( tmp , tmp + 1 , j ) ;
63093: LD_ADDR_VAR 0 19
63097: PUSH
63098: LD_VAR 0 19
63102: PPUSH
63103: LD_VAR 0 19
63107: PUSH
63108: LD_INT 1
63110: PLUS
63111: PPUSH
63112: LD_VAR 0 9
63116: PPUSH
63117: CALL_OW 2
63121: ST_TO_ADDR
63122: GO 63050
63124: POP
63125: POP
// if tmp then
63126: LD_VAR 0 19
63130: IFFALSE 63142
// f := tmp ;
63132: LD_ADDR_VAR 0 12
63136: PUSH
63137: LD_VAR 0 19
63141: ST_TO_ADDR
// end ; x := personel [ i ] ;
63142: LD_ADDR_VAR 0 13
63146: PUSH
63147: LD_VAR 0 6
63151: PUSH
63152: LD_VAR 0 8
63156: ARRAY
63157: ST_TO_ADDR
// if x = - 1 then
63158: LD_VAR 0 13
63162: PUSH
63163: LD_INT 1
63165: NEG
63166: EQUAL
63167: IFFALSE 63376
// begin for j in f do
63169: LD_ADDR_VAR 0 9
63173: PUSH
63174: LD_VAR 0 12
63178: PUSH
63179: FOR_IN
63180: IFFALSE 63372
// repeat InitHc ;
63182: CALL_OW 19
// if GetBType ( j ) = b_barracks then
63186: LD_VAR 0 9
63190: PPUSH
63191: CALL_OW 266
63195: PUSH
63196: LD_INT 5
63198: EQUAL
63199: IFFALSE 63269
// begin if UnitsInside ( j ) < 3 then
63201: LD_VAR 0 9
63205: PPUSH
63206: CALL_OW 313
63210: PUSH
63211: LD_INT 3
63213: LESS
63214: IFFALSE 63250
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63216: LD_INT 0
63218: PPUSH
63219: LD_INT 5
63221: PUSH
63222: LD_INT 8
63224: PUSH
63225: LD_INT 9
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: LIST
63232: PUSH
63233: LD_VAR 0 17
63237: ARRAY
63238: PPUSH
63239: LD_VAR 0 4
63243: PPUSH
63244: CALL_OW 380
63248: GO 63267
// PrepareHuman ( false , i , skill ) ;
63250: LD_INT 0
63252: PPUSH
63253: LD_VAR 0 8
63257: PPUSH
63258: LD_VAR 0 4
63262: PPUSH
63263: CALL_OW 380
// end else
63267: GO 63286
// PrepareHuman ( false , i , skill ) ;
63269: LD_INT 0
63271: PPUSH
63272: LD_VAR 0 8
63276: PPUSH
63277: LD_VAR 0 4
63281: PPUSH
63282: CALL_OW 380
// un := CreateHuman ;
63286: LD_ADDR_VAR 0 14
63290: PUSH
63291: CALL_OW 44
63295: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63296: LD_ADDR_VAR 0 7
63300: PUSH
63301: LD_VAR 0 7
63305: PPUSH
63306: LD_INT 1
63308: PPUSH
63309: LD_VAR 0 14
63313: PPUSH
63314: CALL_OW 2
63318: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63319: LD_VAR 0 14
63323: PPUSH
63324: LD_VAR 0 9
63328: PPUSH
63329: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63333: LD_VAR 0 9
63337: PPUSH
63338: CALL_OW 313
63342: PUSH
63343: LD_INT 6
63345: EQUAL
63346: PUSH
63347: LD_VAR 0 9
63351: PPUSH
63352: CALL_OW 266
63356: PUSH
63357: LD_INT 32
63359: PUSH
63360: LD_INT 31
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: IN
63367: OR
63368: IFFALSE 63182
63370: GO 63179
63372: POP
63373: POP
// end else
63374: GO 63756
// for j = 1 to x do
63376: LD_ADDR_VAR 0 9
63380: PUSH
63381: DOUBLE
63382: LD_INT 1
63384: DEC
63385: ST_TO_ADDR
63386: LD_VAR 0 13
63390: PUSH
63391: FOR_TO
63392: IFFALSE 63754
// begin InitHc ;
63394: CALL_OW 19
// if not f then
63398: LD_VAR 0 12
63402: NOT
63403: IFFALSE 63492
// begin PrepareHuman ( false , i , skill ) ;
63405: LD_INT 0
63407: PPUSH
63408: LD_VAR 0 8
63412: PPUSH
63413: LD_VAR 0 4
63417: PPUSH
63418: CALL_OW 380
// un := CreateHuman ;
63422: LD_ADDR_VAR 0 14
63426: PUSH
63427: CALL_OW 44
63431: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63432: LD_ADDR_VAR 0 7
63436: PUSH
63437: LD_VAR 0 7
63441: PPUSH
63442: LD_INT 1
63444: PPUSH
63445: LD_VAR 0 14
63449: PPUSH
63450: CALL_OW 2
63454: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63455: LD_VAR 0 14
63459: PPUSH
63460: LD_VAR 0 1
63464: PPUSH
63465: CALL_OW 250
63469: PPUSH
63470: LD_VAR 0 1
63474: PPUSH
63475: CALL_OW 251
63479: PPUSH
63480: LD_INT 10
63482: PPUSH
63483: LD_INT 0
63485: PPUSH
63486: CALL_OW 50
// continue ;
63490: GO 63391
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63492: LD_VAR 0 12
63496: PUSH
63497: LD_INT 1
63499: ARRAY
63500: PPUSH
63501: CALL_OW 313
63505: PUSH
63506: LD_VAR 0 12
63510: PUSH
63511: LD_INT 1
63513: ARRAY
63514: PPUSH
63515: CALL_OW 266
63519: PUSH
63520: LD_INT 32
63522: PUSH
63523: LD_INT 31
63525: PUSH
63526: EMPTY
63527: LIST
63528: LIST
63529: IN
63530: AND
63531: PUSH
63532: LD_VAR 0 12
63536: PUSH
63537: LD_INT 1
63539: ARRAY
63540: PPUSH
63541: CALL_OW 313
63545: PUSH
63546: LD_INT 6
63548: EQUAL
63549: OR
63550: IFFALSE 63570
// f := Delete ( f , 1 ) ;
63552: LD_ADDR_VAR 0 12
63556: PUSH
63557: LD_VAR 0 12
63561: PPUSH
63562: LD_INT 1
63564: PPUSH
63565: CALL_OW 3
63569: ST_TO_ADDR
// if not f then
63570: LD_VAR 0 12
63574: NOT
63575: IFFALSE 63593
// begin x := x + 2 ;
63577: LD_ADDR_VAR 0 13
63581: PUSH
63582: LD_VAR 0 13
63586: PUSH
63587: LD_INT 2
63589: PLUS
63590: ST_TO_ADDR
// continue ;
63591: GO 63391
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63593: LD_VAR 0 12
63597: PUSH
63598: LD_INT 1
63600: ARRAY
63601: PPUSH
63602: CALL_OW 266
63606: PUSH
63607: LD_INT 5
63609: EQUAL
63610: IFFALSE 63684
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63612: LD_VAR 0 12
63616: PUSH
63617: LD_INT 1
63619: ARRAY
63620: PPUSH
63621: CALL_OW 313
63625: PUSH
63626: LD_INT 3
63628: LESS
63629: IFFALSE 63665
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63631: LD_INT 0
63633: PPUSH
63634: LD_INT 5
63636: PUSH
63637: LD_INT 8
63639: PUSH
63640: LD_INT 9
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: LIST
63647: PUSH
63648: LD_VAR 0 17
63652: ARRAY
63653: PPUSH
63654: LD_VAR 0 4
63658: PPUSH
63659: CALL_OW 380
63663: GO 63682
// PrepareHuman ( false , i , skill ) ;
63665: LD_INT 0
63667: PPUSH
63668: LD_VAR 0 8
63672: PPUSH
63673: LD_VAR 0 4
63677: PPUSH
63678: CALL_OW 380
// end else
63682: GO 63701
// PrepareHuman ( false , i , skill ) ;
63684: LD_INT 0
63686: PPUSH
63687: LD_VAR 0 8
63691: PPUSH
63692: LD_VAR 0 4
63696: PPUSH
63697: CALL_OW 380
// un := CreateHuman ;
63701: LD_ADDR_VAR 0 14
63705: PUSH
63706: CALL_OW 44
63710: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63711: LD_ADDR_VAR 0 7
63715: PUSH
63716: LD_VAR 0 7
63720: PPUSH
63721: LD_INT 1
63723: PPUSH
63724: LD_VAR 0 14
63728: PPUSH
63729: CALL_OW 2
63733: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63734: LD_VAR 0 14
63738: PPUSH
63739: LD_VAR 0 12
63743: PUSH
63744: LD_INT 1
63746: ARRAY
63747: PPUSH
63748: CALL_OW 52
// end ;
63752: GO 63391
63754: POP
63755: POP
// end ;
63756: GO 62693
63758: POP
63759: POP
// result := result ^ buildings ;
63760: LD_ADDR_VAR 0 7
63764: PUSH
63765: LD_VAR 0 7
63769: PUSH
63770: LD_VAR 0 18
63774: ADD
63775: ST_TO_ADDR
// end else
63776: GO 63919
// begin for i = 1 to personel do
63778: LD_ADDR_VAR 0 8
63782: PUSH
63783: DOUBLE
63784: LD_INT 1
63786: DEC
63787: ST_TO_ADDR
63788: LD_VAR 0 6
63792: PUSH
63793: FOR_TO
63794: IFFALSE 63917
// begin if i > 4 then
63796: LD_VAR 0 8
63800: PUSH
63801: LD_INT 4
63803: GREATER
63804: IFFALSE 63808
// break ;
63806: GO 63917
// x := personel [ i ] ;
63808: LD_ADDR_VAR 0 13
63812: PUSH
63813: LD_VAR 0 6
63817: PUSH
63818: LD_VAR 0 8
63822: ARRAY
63823: ST_TO_ADDR
// if x = - 1 then
63824: LD_VAR 0 13
63828: PUSH
63829: LD_INT 1
63831: NEG
63832: EQUAL
63833: IFFALSE 63837
// continue ;
63835: GO 63793
// PrepareHuman ( false , i , skill ) ;
63837: LD_INT 0
63839: PPUSH
63840: LD_VAR 0 8
63844: PPUSH
63845: LD_VAR 0 4
63849: PPUSH
63850: CALL_OW 380
// un := CreateHuman ;
63854: LD_ADDR_VAR 0 14
63858: PUSH
63859: CALL_OW 44
63863: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63864: LD_VAR 0 14
63868: PPUSH
63869: LD_VAR 0 1
63873: PPUSH
63874: CALL_OW 250
63878: PPUSH
63879: LD_VAR 0 1
63883: PPUSH
63884: CALL_OW 251
63888: PPUSH
63889: LD_INT 10
63891: PPUSH
63892: LD_INT 0
63894: PPUSH
63895: CALL_OW 50
// result := result ^ un ;
63899: LD_ADDR_VAR 0 7
63903: PUSH
63904: LD_VAR 0 7
63908: PUSH
63909: LD_VAR 0 14
63913: ADD
63914: ST_TO_ADDR
// end ;
63915: GO 63793
63917: POP
63918: POP
// end ; end ;
63919: LD_VAR 0 7
63923: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63924: LD_INT 0
63926: PPUSH
63927: PPUSH
63928: PPUSH
63929: PPUSH
63930: PPUSH
63931: PPUSH
63932: PPUSH
63933: PPUSH
63934: PPUSH
63935: PPUSH
63936: PPUSH
63937: PPUSH
63938: PPUSH
63939: PPUSH
63940: PPUSH
63941: PPUSH
// result := false ;
63942: LD_ADDR_VAR 0 3
63946: PUSH
63947: LD_INT 0
63949: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63950: LD_VAR 0 1
63954: NOT
63955: PUSH
63956: LD_VAR 0 1
63960: PPUSH
63961: CALL_OW 266
63965: PUSH
63966: LD_INT 32
63968: PUSH
63969: LD_INT 33
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: IN
63976: NOT
63977: OR
63978: IFFALSE 63982
// exit ;
63980: GO 65091
// nat := GetNation ( tower ) ;
63982: LD_ADDR_VAR 0 12
63986: PUSH
63987: LD_VAR 0 1
63991: PPUSH
63992: CALL_OW 248
63996: ST_TO_ADDR
// side := GetSide ( tower ) ;
63997: LD_ADDR_VAR 0 16
64001: PUSH
64002: LD_VAR 0 1
64006: PPUSH
64007: CALL_OW 255
64011: ST_TO_ADDR
// x := GetX ( tower ) ;
64012: LD_ADDR_VAR 0 10
64016: PUSH
64017: LD_VAR 0 1
64021: PPUSH
64022: CALL_OW 250
64026: ST_TO_ADDR
// y := GetY ( tower ) ;
64027: LD_ADDR_VAR 0 11
64031: PUSH
64032: LD_VAR 0 1
64036: PPUSH
64037: CALL_OW 251
64041: ST_TO_ADDR
// if not x or not y then
64042: LD_VAR 0 10
64046: NOT
64047: PUSH
64048: LD_VAR 0 11
64052: NOT
64053: OR
64054: IFFALSE 64058
// exit ;
64056: GO 65091
// weapon := 0 ;
64058: LD_ADDR_VAR 0 18
64062: PUSH
64063: LD_INT 0
64065: ST_TO_ADDR
// fac_list := [ ] ;
64066: LD_ADDR_VAR 0 17
64070: PUSH
64071: EMPTY
64072: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
64073: LD_ADDR_VAR 0 6
64077: PUSH
64078: LD_VAR 0 1
64082: PPUSH
64083: CALL_OW 274
64087: PPUSH
64088: LD_VAR 0 2
64092: PPUSH
64093: LD_INT 0
64095: PPUSH
64096: CALL 61662 0 3
64100: PPUSH
64101: LD_INT 30
64103: PUSH
64104: LD_INT 3
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PPUSH
64111: CALL_OW 72
64115: ST_TO_ADDR
// if not factories then
64116: LD_VAR 0 6
64120: NOT
64121: IFFALSE 64125
// exit ;
64123: GO 65091
// for i in factories do
64125: LD_ADDR_VAR 0 8
64129: PUSH
64130: LD_VAR 0 6
64134: PUSH
64135: FOR_IN
64136: IFFALSE 64161
// fac_list := fac_list union AvailableWeaponList ( i ) ;
64138: LD_ADDR_VAR 0 17
64142: PUSH
64143: LD_VAR 0 17
64147: PUSH
64148: LD_VAR 0 8
64152: PPUSH
64153: CALL_OW 478
64157: UNION
64158: ST_TO_ADDR
64159: GO 64135
64161: POP
64162: POP
// if not fac_list then
64163: LD_VAR 0 17
64167: NOT
64168: IFFALSE 64172
// exit ;
64170: GO 65091
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
64172: LD_ADDR_VAR 0 5
64176: PUSH
64177: LD_INT 4
64179: PUSH
64180: LD_INT 5
64182: PUSH
64183: LD_INT 9
64185: PUSH
64186: LD_INT 10
64188: PUSH
64189: LD_INT 6
64191: PUSH
64192: LD_INT 7
64194: PUSH
64195: LD_INT 11
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: LIST
64202: LIST
64203: LIST
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 27
64209: PUSH
64210: LD_INT 28
64212: PUSH
64213: LD_INT 26
64215: PUSH
64216: LD_INT 30
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 43
64227: PUSH
64228: LD_INT 44
64230: PUSH
64231: LD_INT 46
64233: PUSH
64234: LD_INT 45
64236: PUSH
64237: LD_INT 47
64239: PUSH
64240: LD_INT 49
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: LIST
64255: PUSH
64256: LD_VAR 0 12
64260: ARRAY
64261: ST_TO_ADDR
// list := list isect fac_list ;
64262: LD_ADDR_VAR 0 5
64266: PUSH
64267: LD_VAR 0 5
64271: PUSH
64272: LD_VAR 0 17
64276: ISECT
64277: ST_TO_ADDR
// if not list then
64278: LD_VAR 0 5
64282: NOT
64283: IFFALSE 64287
// exit ;
64285: GO 65091
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
64287: LD_VAR 0 12
64291: PUSH
64292: LD_INT 3
64294: EQUAL
64295: PUSH
64296: LD_INT 49
64298: PUSH
64299: LD_VAR 0 5
64303: IN
64304: AND
64305: PUSH
64306: LD_INT 31
64308: PPUSH
64309: LD_VAR 0 16
64313: PPUSH
64314: CALL_OW 321
64318: PUSH
64319: LD_INT 2
64321: EQUAL
64322: AND
64323: IFFALSE 64383
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64325: LD_INT 22
64327: PUSH
64328: LD_VAR 0 16
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 35
64339: PUSH
64340: LD_INT 49
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 91
64349: PUSH
64350: LD_VAR 0 1
64354: PUSH
64355: LD_INT 10
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: LIST
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: LIST
64367: PPUSH
64368: CALL_OW 69
64372: NOT
64373: IFFALSE 64383
// weapon := ru_time_lapser ;
64375: LD_ADDR_VAR 0 18
64379: PUSH
64380: LD_INT 49
64382: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64383: LD_VAR 0 12
64387: PUSH
64388: LD_INT 1
64390: PUSH
64391: LD_INT 2
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: IN
64398: PUSH
64399: LD_INT 11
64401: PUSH
64402: LD_VAR 0 5
64406: IN
64407: PUSH
64408: LD_INT 30
64410: PUSH
64411: LD_VAR 0 5
64415: IN
64416: OR
64417: AND
64418: PUSH
64419: LD_INT 6
64421: PPUSH
64422: LD_VAR 0 16
64426: PPUSH
64427: CALL_OW 321
64431: PUSH
64432: LD_INT 2
64434: EQUAL
64435: AND
64436: IFFALSE 64601
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64438: LD_INT 22
64440: PUSH
64441: LD_VAR 0 16
64445: PUSH
64446: EMPTY
64447: LIST
64448: LIST
64449: PUSH
64450: LD_INT 2
64452: PUSH
64453: LD_INT 35
64455: PUSH
64456: LD_INT 11
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 35
64465: PUSH
64466: LD_INT 30
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: LIST
64477: PUSH
64478: LD_INT 91
64480: PUSH
64481: LD_VAR 0 1
64485: PUSH
64486: LD_INT 18
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: LIST
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: LIST
64498: PPUSH
64499: CALL_OW 69
64503: NOT
64504: PUSH
64505: LD_INT 22
64507: PUSH
64508: LD_VAR 0 16
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 2
64519: PUSH
64520: LD_INT 30
64522: PUSH
64523: LD_INT 32
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 30
64532: PUSH
64533: LD_INT 33
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: LIST
64544: PUSH
64545: LD_INT 91
64547: PUSH
64548: LD_VAR 0 1
64552: PUSH
64553: LD_INT 12
64555: PUSH
64556: EMPTY
64557: LIST
64558: LIST
64559: LIST
64560: PUSH
64561: EMPTY
64562: LIST
64563: LIST
64564: LIST
64565: PUSH
64566: EMPTY
64567: LIST
64568: PPUSH
64569: CALL_OW 69
64573: PUSH
64574: LD_INT 2
64576: GREATER
64577: AND
64578: IFFALSE 64601
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64580: LD_ADDR_VAR 0 18
64584: PUSH
64585: LD_INT 11
64587: PUSH
64588: LD_INT 30
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_VAR 0 12
64599: ARRAY
64600: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64601: LD_VAR 0 18
64605: NOT
64606: PUSH
64607: LD_INT 40
64609: PPUSH
64610: LD_VAR 0 16
64614: PPUSH
64615: CALL_OW 321
64619: PUSH
64620: LD_INT 2
64622: EQUAL
64623: AND
64624: PUSH
64625: LD_INT 7
64627: PUSH
64628: LD_VAR 0 5
64632: IN
64633: PUSH
64634: LD_INT 28
64636: PUSH
64637: LD_VAR 0 5
64641: IN
64642: OR
64643: PUSH
64644: LD_INT 45
64646: PUSH
64647: LD_VAR 0 5
64651: IN
64652: OR
64653: AND
64654: IFFALSE 64908
// begin hex := GetHexInfo ( x , y ) ;
64656: LD_ADDR_VAR 0 4
64660: PUSH
64661: LD_VAR 0 10
64665: PPUSH
64666: LD_VAR 0 11
64670: PPUSH
64671: CALL_OW 546
64675: ST_TO_ADDR
// if hex [ 1 ] then
64676: LD_VAR 0 4
64680: PUSH
64681: LD_INT 1
64683: ARRAY
64684: IFFALSE 64688
// exit ;
64686: GO 65091
// height := hex [ 2 ] ;
64688: LD_ADDR_VAR 0 15
64692: PUSH
64693: LD_VAR 0 4
64697: PUSH
64698: LD_INT 2
64700: ARRAY
64701: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64702: LD_ADDR_VAR 0 14
64706: PUSH
64707: LD_INT 0
64709: PUSH
64710: LD_INT 2
64712: PUSH
64713: LD_INT 3
64715: PUSH
64716: LD_INT 5
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: ST_TO_ADDR
// for i in tmp do
64725: LD_ADDR_VAR 0 8
64729: PUSH
64730: LD_VAR 0 14
64734: PUSH
64735: FOR_IN
64736: IFFALSE 64906
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64738: LD_ADDR_VAR 0 9
64742: PUSH
64743: LD_VAR 0 10
64747: PPUSH
64748: LD_VAR 0 8
64752: PPUSH
64753: LD_INT 5
64755: PPUSH
64756: CALL_OW 272
64760: PUSH
64761: LD_VAR 0 11
64765: PPUSH
64766: LD_VAR 0 8
64770: PPUSH
64771: LD_INT 5
64773: PPUSH
64774: CALL_OW 273
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64783: LD_VAR 0 9
64787: PUSH
64788: LD_INT 1
64790: ARRAY
64791: PPUSH
64792: LD_VAR 0 9
64796: PUSH
64797: LD_INT 2
64799: ARRAY
64800: PPUSH
64801: CALL_OW 488
64805: IFFALSE 64904
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64807: LD_ADDR_VAR 0 4
64811: PUSH
64812: LD_VAR 0 9
64816: PUSH
64817: LD_INT 1
64819: ARRAY
64820: PPUSH
64821: LD_VAR 0 9
64825: PUSH
64826: LD_INT 2
64828: ARRAY
64829: PPUSH
64830: CALL_OW 546
64834: ST_TO_ADDR
// if hex [ 1 ] then
64835: LD_VAR 0 4
64839: PUSH
64840: LD_INT 1
64842: ARRAY
64843: IFFALSE 64847
// continue ;
64845: GO 64735
// h := hex [ 2 ] ;
64847: LD_ADDR_VAR 0 13
64851: PUSH
64852: LD_VAR 0 4
64856: PUSH
64857: LD_INT 2
64859: ARRAY
64860: ST_TO_ADDR
// if h + 7 < height then
64861: LD_VAR 0 13
64865: PUSH
64866: LD_INT 7
64868: PLUS
64869: PUSH
64870: LD_VAR 0 15
64874: LESS
64875: IFFALSE 64904
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64877: LD_ADDR_VAR 0 18
64881: PUSH
64882: LD_INT 7
64884: PUSH
64885: LD_INT 28
64887: PUSH
64888: LD_INT 45
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: LIST
64895: PUSH
64896: LD_VAR 0 12
64900: ARRAY
64901: ST_TO_ADDR
// break ;
64902: GO 64906
// end ; end ; end ;
64904: GO 64735
64906: POP
64907: POP
// end ; if not weapon then
64908: LD_VAR 0 18
64912: NOT
64913: IFFALSE 64973
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64915: LD_ADDR_VAR 0 5
64919: PUSH
64920: LD_VAR 0 5
64924: PUSH
64925: LD_INT 11
64927: PUSH
64928: LD_INT 30
64930: PUSH
64931: LD_INT 49
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: LIST
64938: DIFF
64939: ST_TO_ADDR
// if not list then
64940: LD_VAR 0 5
64944: NOT
64945: IFFALSE 64949
// exit ;
64947: GO 65091
// weapon := list [ rand ( 1 , list ) ] ;
64949: LD_ADDR_VAR 0 18
64953: PUSH
64954: LD_VAR 0 5
64958: PUSH
64959: LD_INT 1
64961: PPUSH
64962: LD_VAR 0 5
64966: PPUSH
64967: CALL_OW 12
64971: ARRAY
64972: ST_TO_ADDR
// end ; if weapon then
64973: LD_VAR 0 18
64977: IFFALSE 65091
// begin tmp := CostOfWeapon ( weapon ) ;
64979: LD_ADDR_VAR 0 14
64983: PUSH
64984: LD_VAR 0 18
64988: PPUSH
64989: CALL_OW 451
64993: ST_TO_ADDR
// j := GetBase ( tower ) ;
64994: LD_ADDR_VAR 0 9
64998: PUSH
64999: LD_VAR 0 1
65003: PPUSH
65004: CALL_OW 274
65008: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
65009: LD_VAR 0 9
65013: PPUSH
65014: LD_INT 1
65016: PPUSH
65017: CALL_OW 275
65021: PUSH
65022: LD_VAR 0 14
65026: PUSH
65027: LD_INT 1
65029: ARRAY
65030: GREATEREQUAL
65031: PUSH
65032: LD_VAR 0 9
65036: PPUSH
65037: LD_INT 2
65039: PPUSH
65040: CALL_OW 275
65044: PUSH
65045: LD_VAR 0 14
65049: PUSH
65050: LD_INT 2
65052: ARRAY
65053: GREATEREQUAL
65054: AND
65055: PUSH
65056: LD_VAR 0 9
65060: PPUSH
65061: LD_INT 3
65063: PPUSH
65064: CALL_OW 275
65068: PUSH
65069: LD_VAR 0 14
65073: PUSH
65074: LD_INT 3
65076: ARRAY
65077: GREATEREQUAL
65078: AND
65079: IFFALSE 65091
// result := weapon ;
65081: LD_ADDR_VAR 0 3
65085: PUSH
65086: LD_VAR 0 18
65090: ST_TO_ADDR
// end ; end ;
65091: LD_VAR 0 3
65095: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
65096: LD_INT 0
65098: PPUSH
65099: PPUSH
// result := true ;
65100: LD_ADDR_VAR 0 3
65104: PUSH
65105: LD_INT 1
65107: ST_TO_ADDR
// if array1 = array2 then
65108: LD_VAR 0 1
65112: PUSH
65113: LD_VAR 0 2
65117: EQUAL
65118: IFFALSE 65178
// begin for i = 1 to array1 do
65120: LD_ADDR_VAR 0 4
65124: PUSH
65125: DOUBLE
65126: LD_INT 1
65128: DEC
65129: ST_TO_ADDR
65130: LD_VAR 0 1
65134: PUSH
65135: FOR_TO
65136: IFFALSE 65174
// if array1 [ i ] <> array2 [ i ] then
65138: LD_VAR 0 1
65142: PUSH
65143: LD_VAR 0 4
65147: ARRAY
65148: PUSH
65149: LD_VAR 0 2
65153: PUSH
65154: LD_VAR 0 4
65158: ARRAY
65159: NONEQUAL
65160: IFFALSE 65172
// begin result := false ;
65162: LD_ADDR_VAR 0 3
65166: PUSH
65167: LD_INT 0
65169: ST_TO_ADDR
// break ;
65170: GO 65174
// end ;
65172: GO 65135
65174: POP
65175: POP
// end else
65176: GO 65186
// result := false ;
65178: LD_ADDR_VAR 0 3
65182: PUSH
65183: LD_INT 0
65185: ST_TO_ADDR
// end ;
65186: LD_VAR 0 3
65190: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
65191: LD_INT 0
65193: PPUSH
65194: PPUSH
// if not array1 or not array2 then
65195: LD_VAR 0 1
65199: NOT
65200: PUSH
65201: LD_VAR 0 2
65205: NOT
65206: OR
65207: IFFALSE 65211
// exit ;
65209: GO 65275
// result := true ;
65211: LD_ADDR_VAR 0 3
65215: PUSH
65216: LD_INT 1
65218: ST_TO_ADDR
// for i = 1 to array1 do
65219: LD_ADDR_VAR 0 4
65223: PUSH
65224: DOUBLE
65225: LD_INT 1
65227: DEC
65228: ST_TO_ADDR
65229: LD_VAR 0 1
65233: PUSH
65234: FOR_TO
65235: IFFALSE 65273
// if array1 [ i ] <> array2 [ i ] then
65237: LD_VAR 0 1
65241: PUSH
65242: LD_VAR 0 4
65246: ARRAY
65247: PUSH
65248: LD_VAR 0 2
65252: PUSH
65253: LD_VAR 0 4
65257: ARRAY
65258: NONEQUAL
65259: IFFALSE 65271
// begin result := false ;
65261: LD_ADDR_VAR 0 3
65265: PUSH
65266: LD_INT 0
65268: ST_TO_ADDR
// break ;
65269: GO 65273
// end ;
65271: GO 65234
65273: POP
65274: POP
// end ;
65275: LD_VAR 0 3
65279: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
65280: LD_INT 0
65282: PPUSH
65283: PPUSH
65284: PPUSH
// pom := GetBase ( fac ) ;
65285: LD_ADDR_VAR 0 5
65289: PUSH
65290: LD_VAR 0 1
65294: PPUSH
65295: CALL_OW 274
65299: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
65300: LD_ADDR_VAR 0 4
65304: PUSH
65305: LD_VAR 0 2
65309: PUSH
65310: LD_INT 1
65312: ARRAY
65313: PPUSH
65314: LD_VAR 0 2
65318: PUSH
65319: LD_INT 2
65321: ARRAY
65322: PPUSH
65323: LD_VAR 0 2
65327: PUSH
65328: LD_INT 3
65330: ARRAY
65331: PPUSH
65332: LD_VAR 0 2
65336: PUSH
65337: LD_INT 4
65339: ARRAY
65340: PPUSH
65341: CALL_OW 449
65345: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65346: LD_ADDR_VAR 0 3
65350: PUSH
65351: LD_VAR 0 5
65355: PPUSH
65356: LD_INT 1
65358: PPUSH
65359: CALL_OW 275
65363: PUSH
65364: LD_VAR 0 4
65368: PUSH
65369: LD_INT 1
65371: ARRAY
65372: GREATEREQUAL
65373: PUSH
65374: LD_VAR 0 5
65378: PPUSH
65379: LD_INT 2
65381: PPUSH
65382: CALL_OW 275
65386: PUSH
65387: LD_VAR 0 4
65391: PUSH
65392: LD_INT 2
65394: ARRAY
65395: GREATEREQUAL
65396: AND
65397: PUSH
65398: LD_VAR 0 5
65402: PPUSH
65403: LD_INT 3
65405: PPUSH
65406: CALL_OW 275
65410: PUSH
65411: LD_VAR 0 4
65415: PUSH
65416: LD_INT 3
65418: ARRAY
65419: GREATEREQUAL
65420: AND
65421: ST_TO_ADDR
// end ;
65422: LD_VAR 0 3
65426: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65427: LD_INT 0
65429: PPUSH
65430: PPUSH
65431: PPUSH
65432: PPUSH
// pom := GetBase ( building ) ;
65433: LD_ADDR_VAR 0 3
65437: PUSH
65438: LD_VAR 0 1
65442: PPUSH
65443: CALL_OW 274
65447: ST_TO_ADDR
// if not pom then
65448: LD_VAR 0 3
65452: NOT
65453: IFFALSE 65457
// exit ;
65455: GO 65627
// btype := GetBType ( building ) ;
65457: LD_ADDR_VAR 0 5
65461: PUSH
65462: LD_VAR 0 1
65466: PPUSH
65467: CALL_OW 266
65471: ST_TO_ADDR
// if btype = b_armoury then
65472: LD_VAR 0 5
65476: PUSH
65477: LD_INT 4
65479: EQUAL
65480: IFFALSE 65490
// btype := b_barracks ;
65482: LD_ADDR_VAR 0 5
65486: PUSH
65487: LD_INT 5
65489: ST_TO_ADDR
// if btype = b_depot then
65490: LD_VAR 0 5
65494: PUSH
65495: LD_INT 0
65497: EQUAL
65498: IFFALSE 65508
// btype := b_warehouse ;
65500: LD_ADDR_VAR 0 5
65504: PUSH
65505: LD_INT 1
65507: ST_TO_ADDR
// if btype = b_workshop then
65508: LD_VAR 0 5
65512: PUSH
65513: LD_INT 2
65515: EQUAL
65516: IFFALSE 65526
// btype := b_factory ;
65518: LD_ADDR_VAR 0 5
65522: PUSH
65523: LD_INT 3
65525: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65526: LD_ADDR_VAR 0 4
65530: PUSH
65531: LD_VAR 0 5
65535: PPUSH
65536: LD_VAR 0 1
65540: PPUSH
65541: CALL_OW 248
65545: PPUSH
65546: CALL_OW 450
65550: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65551: LD_ADDR_VAR 0 2
65555: PUSH
65556: LD_VAR 0 3
65560: PPUSH
65561: LD_INT 1
65563: PPUSH
65564: CALL_OW 275
65568: PUSH
65569: LD_VAR 0 4
65573: PUSH
65574: LD_INT 1
65576: ARRAY
65577: GREATEREQUAL
65578: PUSH
65579: LD_VAR 0 3
65583: PPUSH
65584: LD_INT 2
65586: PPUSH
65587: CALL_OW 275
65591: PUSH
65592: LD_VAR 0 4
65596: PUSH
65597: LD_INT 2
65599: ARRAY
65600: GREATEREQUAL
65601: AND
65602: PUSH
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_INT 3
65610: PPUSH
65611: CALL_OW 275
65615: PUSH
65616: LD_VAR 0 4
65620: PUSH
65621: LD_INT 3
65623: ARRAY
65624: GREATEREQUAL
65625: AND
65626: ST_TO_ADDR
// end ;
65627: LD_VAR 0 2
65631: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65632: LD_INT 0
65634: PPUSH
65635: PPUSH
65636: PPUSH
// pom := GetBase ( building ) ;
65637: LD_ADDR_VAR 0 4
65641: PUSH
65642: LD_VAR 0 1
65646: PPUSH
65647: CALL_OW 274
65651: ST_TO_ADDR
// if not pom then
65652: LD_VAR 0 4
65656: NOT
65657: IFFALSE 65661
// exit ;
65659: GO 65762
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65661: LD_ADDR_VAR 0 5
65665: PUSH
65666: LD_VAR 0 2
65670: PPUSH
65671: LD_VAR 0 1
65675: PPUSH
65676: CALL_OW 248
65680: PPUSH
65681: CALL_OW 450
65685: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65686: LD_ADDR_VAR 0 3
65690: PUSH
65691: LD_VAR 0 4
65695: PPUSH
65696: LD_INT 1
65698: PPUSH
65699: CALL_OW 275
65703: PUSH
65704: LD_VAR 0 5
65708: PUSH
65709: LD_INT 1
65711: ARRAY
65712: GREATEREQUAL
65713: PUSH
65714: LD_VAR 0 4
65718: PPUSH
65719: LD_INT 2
65721: PPUSH
65722: CALL_OW 275
65726: PUSH
65727: LD_VAR 0 5
65731: PUSH
65732: LD_INT 2
65734: ARRAY
65735: GREATEREQUAL
65736: AND
65737: PUSH
65738: LD_VAR 0 4
65742: PPUSH
65743: LD_INT 3
65745: PPUSH
65746: CALL_OW 275
65750: PUSH
65751: LD_VAR 0 5
65755: PUSH
65756: LD_INT 3
65758: ARRAY
65759: GREATEREQUAL
65760: AND
65761: ST_TO_ADDR
// end ;
65762: LD_VAR 0 3
65766: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65767: LD_INT 0
65769: PPUSH
65770: PPUSH
65771: PPUSH
65772: PPUSH
65773: PPUSH
65774: PPUSH
65775: PPUSH
65776: PPUSH
65777: PPUSH
65778: PPUSH
65779: PPUSH
// result := false ;
65780: LD_ADDR_VAR 0 8
65784: PUSH
65785: LD_INT 0
65787: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65788: LD_VAR 0 5
65792: NOT
65793: PUSH
65794: LD_VAR 0 1
65798: NOT
65799: OR
65800: PUSH
65801: LD_VAR 0 2
65805: NOT
65806: OR
65807: PUSH
65808: LD_VAR 0 3
65812: NOT
65813: OR
65814: IFFALSE 65818
// exit ;
65816: GO 66632
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65818: LD_ADDR_VAR 0 14
65822: PUSH
65823: LD_VAR 0 1
65827: PPUSH
65828: LD_VAR 0 2
65832: PPUSH
65833: LD_VAR 0 3
65837: PPUSH
65838: LD_VAR 0 4
65842: PPUSH
65843: LD_VAR 0 5
65847: PUSH
65848: LD_INT 1
65850: ARRAY
65851: PPUSH
65852: CALL_OW 248
65856: PPUSH
65857: LD_INT 0
65859: PPUSH
65860: CALL 67885 0 6
65864: ST_TO_ADDR
// if not hexes then
65865: LD_VAR 0 14
65869: NOT
65870: IFFALSE 65874
// exit ;
65872: GO 66632
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65874: LD_ADDR_VAR 0 17
65878: PUSH
65879: LD_VAR 0 5
65883: PPUSH
65884: LD_INT 22
65886: PUSH
65887: LD_VAR 0 13
65891: PPUSH
65892: CALL_OW 255
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 2
65903: PUSH
65904: LD_INT 30
65906: PUSH
65907: LD_INT 0
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: LD_INT 30
65916: PUSH
65917: LD_INT 1
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: LIST
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PPUSH
65933: CALL_OW 72
65937: ST_TO_ADDR
// for i = 1 to hexes do
65938: LD_ADDR_VAR 0 9
65942: PUSH
65943: DOUBLE
65944: LD_INT 1
65946: DEC
65947: ST_TO_ADDR
65948: LD_VAR 0 14
65952: PUSH
65953: FOR_TO
65954: IFFALSE 66630
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65956: LD_ADDR_VAR 0 13
65960: PUSH
65961: LD_VAR 0 14
65965: PUSH
65966: LD_VAR 0 9
65970: ARRAY
65971: PUSH
65972: LD_INT 1
65974: ARRAY
65975: PPUSH
65976: LD_VAR 0 14
65980: PUSH
65981: LD_VAR 0 9
65985: ARRAY
65986: PUSH
65987: LD_INT 2
65989: ARRAY
65990: PPUSH
65991: CALL_OW 428
65995: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65996: LD_VAR 0 14
66000: PUSH
66001: LD_VAR 0 9
66005: ARRAY
66006: PUSH
66007: LD_INT 1
66009: ARRAY
66010: PPUSH
66011: LD_VAR 0 14
66015: PUSH
66016: LD_VAR 0 9
66020: ARRAY
66021: PUSH
66022: LD_INT 2
66024: ARRAY
66025: PPUSH
66026: CALL_OW 351
66030: PUSH
66031: LD_VAR 0 14
66035: PUSH
66036: LD_VAR 0 9
66040: ARRAY
66041: PUSH
66042: LD_INT 1
66044: ARRAY
66045: PPUSH
66046: LD_VAR 0 14
66050: PUSH
66051: LD_VAR 0 9
66055: ARRAY
66056: PUSH
66057: LD_INT 2
66059: ARRAY
66060: PPUSH
66061: CALL_OW 488
66065: NOT
66066: OR
66067: PUSH
66068: LD_VAR 0 13
66072: PPUSH
66073: CALL_OW 247
66077: PUSH
66078: LD_INT 3
66080: EQUAL
66081: OR
66082: IFFALSE 66088
// exit ;
66084: POP
66085: POP
66086: GO 66632
// if not tmp then
66088: LD_VAR 0 13
66092: NOT
66093: IFFALSE 66097
// continue ;
66095: GO 65953
// result := true ;
66097: LD_ADDR_VAR 0 8
66101: PUSH
66102: LD_INT 1
66104: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
66105: LD_VAR 0 6
66109: PUSH
66110: LD_VAR 0 13
66114: PPUSH
66115: CALL_OW 247
66119: PUSH
66120: LD_INT 2
66122: EQUAL
66123: AND
66124: PUSH
66125: LD_VAR 0 13
66129: PPUSH
66130: CALL_OW 263
66134: PUSH
66135: LD_INT 1
66137: EQUAL
66138: AND
66139: IFFALSE 66303
// begin if IsDrivenBy ( tmp ) then
66141: LD_VAR 0 13
66145: PPUSH
66146: CALL_OW 311
66150: IFFALSE 66154
// continue ;
66152: GO 65953
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
66154: LD_VAR 0 6
66158: PPUSH
66159: LD_INT 3
66161: PUSH
66162: LD_INT 60
66164: PUSH
66165: EMPTY
66166: LIST
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 3
66174: PUSH
66175: LD_INT 55
66177: PUSH
66178: EMPTY
66179: LIST
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PPUSH
66189: CALL_OW 72
66193: IFFALSE 66301
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
66195: LD_ADDR_VAR 0 18
66199: PUSH
66200: LD_VAR 0 6
66204: PPUSH
66205: LD_INT 3
66207: PUSH
66208: LD_INT 60
66210: PUSH
66211: EMPTY
66212: LIST
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 3
66220: PUSH
66221: LD_INT 55
66223: PUSH
66224: EMPTY
66225: LIST
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: EMPTY
66232: LIST
66233: LIST
66234: PPUSH
66235: CALL_OW 72
66239: PUSH
66240: LD_INT 1
66242: ARRAY
66243: ST_TO_ADDR
// if IsInUnit ( driver ) then
66244: LD_VAR 0 18
66248: PPUSH
66249: CALL_OW 310
66253: IFFALSE 66264
// ComExit ( driver ) ;
66255: LD_VAR 0 18
66259: PPUSH
66260: CALL 91666 0 1
// AddComEnterUnit ( driver , tmp ) ;
66264: LD_VAR 0 18
66268: PPUSH
66269: LD_VAR 0 13
66273: PPUSH
66274: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
66278: LD_VAR 0 18
66282: PPUSH
66283: LD_VAR 0 7
66287: PPUSH
66288: CALL_OW 173
// AddComExitVehicle ( driver ) ;
66292: LD_VAR 0 18
66296: PPUSH
66297: CALL_OW 181
// end ; continue ;
66301: GO 65953
// end ; if not cleaners or not tmp in cleaners then
66303: LD_VAR 0 6
66307: NOT
66308: PUSH
66309: LD_VAR 0 13
66313: PUSH
66314: LD_VAR 0 6
66318: IN
66319: NOT
66320: OR
66321: IFFALSE 66628
// begin if dep then
66323: LD_VAR 0 17
66327: IFFALSE 66463
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66329: LD_ADDR_VAR 0 16
66333: PUSH
66334: LD_VAR 0 17
66338: PUSH
66339: LD_INT 1
66341: ARRAY
66342: PPUSH
66343: CALL_OW 250
66347: PPUSH
66348: LD_VAR 0 17
66352: PUSH
66353: LD_INT 1
66355: ARRAY
66356: PPUSH
66357: CALL_OW 254
66361: PPUSH
66362: LD_INT 5
66364: PPUSH
66365: CALL_OW 272
66369: PUSH
66370: LD_VAR 0 17
66374: PUSH
66375: LD_INT 1
66377: ARRAY
66378: PPUSH
66379: CALL_OW 251
66383: PPUSH
66384: LD_VAR 0 17
66388: PUSH
66389: LD_INT 1
66391: ARRAY
66392: PPUSH
66393: CALL_OW 254
66397: PPUSH
66398: LD_INT 5
66400: PPUSH
66401: CALL_OW 273
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66410: LD_VAR 0 16
66414: PUSH
66415: LD_INT 1
66417: ARRAY
66418: PPUSH
66419: LD_VAR 0 16
66423: PUSH
66424: LD_INT 2
66426: ARRAY
66427: PPUSH
66428: CALL_OW 488
66432: IFFALSE 66463
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66434: LD_VAR 0 13
66438: PPUSH
66439: LD_VAR 0 16
66443: PUSH
66444: LD_INT 1
66446: ARRAY
66447: PPUSH
66448: LD_VAR 0 16
66452: PUSH
66453: LD_INT 2
66455: ARRAY
66456: PPUSH
66457: CALL_OW 111
// continue ;
66461: GO 65953
// end ; end ; r := GetDir ( tmp ) ;
66463: LD_ADDR_VAR 0 15
66467: PUSH
66468: LD_VAR 0 13
66472: PPUSH
66473: CALL_OW 254
66477: ST_TO_ADDR
// if r = 5 then
66478: LD_VAR 0 15
66482: PUSH
66483: LD_INT 5
66485: EQUAL
66486: IFFALSE 66496
// r := 0 ;
66488: LD_ADDR_VAR 0 15
66492: PUSH
66493: LD_INT 0
66495: ST_TO_ADDR
// for j = r to 5 do
66496: LD_ADDR_VAR 0 10
66500: PUSH
66501: DOUBLE
66502: LD_VAR 0 15
66506: DEC
66507: ST_TO_ADDR
66508: LD_INT 5
66510: PUSH
66511: FOR_TO
66512: IFFALSE 66626
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66514: LD_ADDR_VAR 0 11
66518: PUSH
66519: LD_VAR 0 13
66523: PPUSH
66524: CALL_OW 250
66528: PPUSH
66529: LD_VAR 0 10
66533: PPUSH
66534: LD_INT 2
66536: PPUSH
66537: CALL_OW 272
66541: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66542: LD_ADDR_VAR 0 12
66546: PUSH
66547: LD_VAR 0 13
66551: PPUSH
66552: CALL_OW 251
66556: PPUSH
66557: LD_VAR 0 10
66561: PPUSH
66562: LD_INT 2
66564: PPUSH
66565: CALL_OW 273
66569: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66570: LD_VAR 0 11
66574: PPUSH
66575: LD_VAR 0 12
66579: PPUSH
66580: CALL_OW 488
66584: PUSH
66585: LD_VAR 0 11
66589: PPUSH
66590: LD_VAR 0 12
66594: PPUSH
66595: CALL_OW 428
66599: NOT
66600: AND
66601: IFFALSE 66624
// begin ComMoveXY ( tmp , _x , _y ) ;
66603: LD_VAR 0 13
66607: PPUSH
66608: LD_VAR 0 11
66612: PPUSH
66613: LD_VAR 0 12
66617: PPUSH
66618: CALL_OW 111
// break ;
66622: GO 66626
// end ; end ;
66624: GO 66511
66626: POP
66627: POP
// end ; end ;
66628: GO 65953
66630: POP
66631: POP
// end ;
66632: LD_VAR 0 8
66636: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66637: LD_INT 0
66639: PPUSH
// result := true ;
66640: LD_ADDR_VAR 0 3
66644: PUSH
66645: LD_INT 1
66647: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66648: LD_VAR 0 2
66652: PUSH
66653: LD_INT 24
66655: DOUBLE
66656: EQUAL
66657: IFTRUE 66667
66659: LD_INT 33
66661: DOUBLE
66662: EQUAL
66663: IFTRUE 66667
66665: GO 66692
66667: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66668: LD_ADDR_VAR 0 3
66672: PUSH
66673: LD_INT 32
66675: PPUSH
66676: LD_VAR 0 1
66680: PPUSH
66681: CALL_OW 321
66685: PUSH
66686: LD_INT 2
66688: EQUAL
66689: ST_TO_ADDR
66690: GO 67008
66692: LD_INT 20
66694: DOUBLE
66695: EQUAL
66696: IFTRUE 66700
66698: GO 66725
66700: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66701: LD_ADDR_VAR 0 3
66705: PUSH
66706: LD_INT 6
66708: PPUSH
66709: LD_VAR 0 1
66713: PPUSH
66714: CALL_OW 321
66718: PUSH
66719: LD_INT 2
66721: EQUAL
66722: ST_TO_ADDR
66723: GO 67008
66725: LD_INT 22
66727: DOUBLE
66728: EQUAL
66729: IFTRUE 66739
66731: LD_INT 36
66733: DOUBLE
66734: EQUAL
66735: IFTRUE 66739
66737: GO 66764
66739: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66740: LD_ADDR_VAR 0 3
66744: PUSH
66745: LD_INT 15
66747: PPUSH
66748: LD_VAR 0 1
66752: PPUSH
66753: CALL_OW 321
66757: PUSH
66758: LD_INT 2
66760: EQUAL
66761: ST_TO_ADDR
66762: GO 67008
66764: LD_INT 30
66766: DOUBLE
66767: EQUAL
66768: IFTRUE 66772
66770: GO 66797
66772: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66773: LD_ADDR_VAR 0 3
66777: PUSH
66778: LD_INT 20
66780: PPUSH
66781: LD_VAR 0 1
66785: PPUSH
66786: CALL_OW 321
66790: PUSH
66791: LD_INT 2
66793: EQUAL
66794: ST_TO_ADDR
66795: GO 67008
66797: LD_INT 28
66799: DOUBLE
66800: EQUAL
66801: IFTRUE 66811
66803: LD_INT 21
66805: DOUBLE
66806: EQUAL
66807: IFTRUE 66811
66809: GO 66836
66811: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66812: LD_ADDR_VAR 0 3
66816: PUSH
66817: LD_INT 21
66819: PPUSH
66820: LD_VAR 0 1
66824: PPUSH
66825: CALL_OW 321
66829: PUSH
66830: LD_INT 2
66832: EQUAL
66833: ST_TO_ADDR
66834: GO 67008
66836: LD_INT 16
66838: DOUBLE
66839: EQUAL
66840: IFTRUE 66844
66842: GO 66869
66844: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66845: LD_ADDR_VAR 0 3
66849: PUSH
66850: LD_INT 84
66852: PPUSH
66853: LD_VAR 0 1
66857: PPUSH
66858: CALL_OW 321
66862: PUSH
66863: LD_INT 2
66865: EQUAL
66866: ST_TO_ADDR
66867: GO 67008
66869: LD_INT 19
66871: DOUBLE
66872: EQUAL
66873: IFTRUE 66883
66875: LD_INT 23
66877: DOUBLE
66878: EQUAL
66879: IFTRUE 66883
66881: GO 66908
66883: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66884: LD_ADDR_VAR 0 3
66888: PUSH
66889: LD_INT 83
66891: PPUSH
66892: LD_VAR 0 1
66896: PPUSH
66897: CALL_OW 321
66901: PUSH
66902: LD_INT 2
66904: EQUAL
66905: ST_TO_ADDR
66906: GO 67008
66908: LD_INT 17
66910: DOUBLE
66911: EQUAL
66912: IFTRUE 66916
66914: GO 66941
66916: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66917: LD_ADDR_VAR 0 3
66921: PUSH
66922: LD_INT 39
66924: PPUSH
66925: LD_VAR 0 1
66929: PPUSH
66930: CALL_OW 321
66934: PUSH
66935: LD_INT 2
66937: EQUAL
66938: ST_TO_ADDR
66939: GO 67008
66941: LD_INT 18
66943: DOUBLE
66944: EQUAL
66945: IFTRUE 66949
66947: GO 66974
66949: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66950: LD_ADDR_VAR 0 3
66954: PUSH
66955: LD_INT 40
66957: PPUSH
66958: LD_VAR 0 1
66962: PPUSH
66963: CALL_OW 321
66967: PUSH
66968: LD_INT 2
66970: EQUAL
66971: ST_TO_ADDR
66972: GO 67008
66974: LD_INT 27
66976: DOUBLE
66977: EQUAL
66978: IFTRUE 66982
66980: GO 67007
66982: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66983: LD_ADDR_VAR 0 3
66987: PUSH
66988: LD_INT 35
66990: PPUSH
66991: LD_VAR 0 1
66995: PPUSH
66996: CALL_OW 321
67000: PUSH
67001: LD_INT 2
67003: EQUAL
67004: ST_TO_ADDR
67005: GO 67008
67007: POP
// end ;
67008: LD_VAR 0 3
67012: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
67013: LD_INT 0
67015: PPUSH
67016: PPUSH
67017: PPUSH
67018: PPUSH
67019: PPUSH
67020: PPUSH
67021: PPUSH
67022: PPUSH
67023: PPUSH
67024: PPUSH
67025: PPUSH
// result := false ;
67026: LD_ADDR_VAR 0 6
67030: PUSH
67031: LD_INT 0
67033: ST_TO_ADDR
// if btype = b_depot then
67034: LD_VAR 0 2
67038: PUSH
67039: LD_INT 0
67041: EQUAL
67042: IFFALSE 67054
// begin result := true ;
67044: LD_ADDR_VAR 0 6
67048: PUSH
67049: LD_INT 1
67051: ST_TO_ADDR
// exit ;
67052: GO 67880
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
67054: LD_VAR 0 1
67058: NOT
67059: PUSH
67060: LD_VAR 0 1
67064: PPUSH
67065: CALL_OW 266
67069: PUSH
67070: LD_INT 0
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: IN
67080: NOT
67081: OR
67082: PUSH
67083: LD_VAR 0 2
67087: NOT
67088: OR
67089: PUSH
67090: LD_VAR 0 5
67094: PUSH
67095: LD_INT 0
67097: PUSH
67098: LD_INT 1
67100: PUSH
67101: LD_INT 2
67103: PUSH
67104: LD_INT 3
67106: PUSH
67107: LD_INT 4
67109: PUSH
67110: LD_INT 5
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: IN
67121: NOT
67122: OR
67123: PUSH
67124: LD_VAR 0 3
67128: PPUSH
67129: LD_VAR 0 4
67133: PPUSH
67134: CALL_OW 488
67138: NOT
67139: OR
67140: IFFALSE 67144
// exit ;
67142: GO 67880
// side := GetSide ( depot ) ;
67144: LD_ADDR_VAR 0 9
67148: PUSH
67149: LD_VAR 0 1
67153: PPUSH
67154: CALL_OW 255
67158: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
67159: LD_VAR 0 9
67163: PPUSH
67164: LD_VAR 0 2
67168: PPUSH
67169: CALL 66637 0 2
67173: NOT
67174: IFFALSE 67178
// exit ;
67176: GO 67880
// pom := GetBase ( depot ) ;
67178: LD_ADDR_VAR 0 10
67182: PUSH
67183: LD_VAR 0 1
67187: PPUSH
67188: CALL_OW 274
67192: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
67193: LD_ADDR_VAR 0 11
67197: PUSH
67198: LD_VAR 0 2
67202: PPUSH
67203: LD_VAR 0 1
67207: PPUSH
67208: CALL_OW 248
67212: PPUSH
67213: CALL_OW 450
67217: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
67218: LD_VAR 0 10
67222: PPUSH
67223: LD_INT 1
67225: PPUSH
67226: CALL_OW 275
67230: PUSH
67231: LD_VAR 0 11
67235: PUSH
67236: LD_INT 1
67238: ARRAY
67239: GREATEREQUAL
67240: PUSH
67241: LD_VAR 0 10
67245: PPUSH
67246: LD_INT 2
67248: PPUSH
67249: CALL_OW 275
67253: PUSH
67254: LD_VAR 0 11
67258: PUSH
67259: LD_INT 2
67261: ARRAY
67262: GREATEREQUAL
67263: AND
67264: PUSH
67265: LD_VAR 0 10
67269: PPUSH
67270: LD_INT 3
67272: PPUSH
67273: CALL_OW 275
67277: PUSH
67278: LD_VAR 0 11
67282: PUSH
67283: LD_INT 3
67285: ARRAY
67286: GREATEREQUAL
67287: AND
67288: NOT
67289: IFFALSE 67293
// exit ;
67291: GO 67880
// if GetBType ( depot ) = b_depot then
67293: LD_VAR 0 1
67297: PPUSH
67298: CALL_OW 266
67302: PUSH
67303: LD_INT 0
67305: EQUAL
67306: IFFALSE 67318
// dist := 28 else
67308: LD_ADDR_VAR 0 14
67312: PUSH
67313: LD_INT 28
67315: ST_TO_ADDR
67316: GO 67326
// dist := 36 ;
67318: LD_ADDR_VAR 0 14
67322: PUSH
67323: LD_INT 36
67325: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67326: LD_VAR 0 1
67330: PPUSH
67331: LD_VAR 0 3
67335: PPUSH
67336: LD_VAR 0 4
67340: PPUSH
67341: CALL_OW 297
67345: PUSH
67346: LD_VAR 0 14
67350: GREATER
67351: IFFALSE 67355
// exit ;
67353: GO 67880
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67355: LD_ADDR_VAR 0 12
67359: PUSH
67360: LD_VAR 0 2
67364: PPUSH
67365: LD_VAR 0 3
67369: PPUSH
67370: LD_VAR 0 4
67374: PPUSH
67375: LD_VAR 0 5
67379: PPUSH
67380: LD_VAR 0 1
67384: PPUSH
67385: CALL_OW 248
67389: PPUSH
67390: LD_INT 0
67392: PPUSH
67393: CALL 67885 0 6
67397: ST_TO_ADDR
// if not hexes then
67398: LD_VAR 0 12
67402: NOT
67403: IFFALSE 67407
// exit ;
67405: GO 67880
// hex := GetHexInfo ( x , y ) ;
67407: LD_ADDR_VAR 0 15
67411: PUSH
67412: LD_VAR 0 3
67416: PPUSH
67417: LD_VAR 0 4
67421: PPUSH
67422: CALL_OW 546
67426: ST_TO_ADDR
// if hex [ 1 ] then
67427: LD_VAR 0 15
67431: PUSH
67432: LD_INT 1
67434: ARRAY
67435: IFFALSE 67439
// exit ;
67437: GO 67880
// height := hex [ 2 ] ;
67439: LD_ADDR_VAR 0 13
67443: PUSH
67444: LD_VAR 0 15
67448: PUSH
67449: LD_INT 2
67451: ARRAY
67452: ST_TO_ADDR
// for i = 1 to hexes do
67453: LD_ADDR_VAR 0 7
67457: PUSH
67458: DOUBLE
67459: LD_INT 1
67461: DEC
67462: ST_TO_ADDR
67463: LD_VAR 0 12
67467: PUSH
67468: FOR_TO
67469: IFFALSE 67799
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67471: LD_VAR 0 12
67475: PUSH
67476: LD_VAR 0 7
67480: ARRAY
67481: PUSH
67482: LD_INT 1
67484: ARRAY
67485: PPUSH
67486: LD_VAR 0 12
67490: PUSH
67491: LD_VAR 0 7
67495: ARRAY
67496: PUSH
67497: LD_INT 2
67499: ARRAY
67500: PPUSH
67501: CALL_OW 488
67505: NOT
67506: PUSH
67507: LD_VAR 0 12
67511: PUSH
67512: LD_VAR 0 7
67516: ARRAY
67517: PUSH
67518: LD_INT 1
67520: ARRAY
67521: PPUSH
67522: LD_VAR 0 12
67526: PUSH
67527: LD_VAR 0 7
67531: ARRAY
67532: PUSH
67533: LD_INT 2
67535: ARRAY
67536: PPUSH
67537: CALL_OW 428
67541: PUSH
67542: LD_INT 0
67544: GREATER
67545: OR
67546: PUSH
67547: LD_VAR 0 12
67551: PUSH
67552: LD_VAR 0 7
67556: ARRAY
67557: PUSH
67558: LD_INT 1
67560: ARRAY
67561: PPUSH
67562: LD_VAR 0 12
67566: PUSH
67567: LD_VAR 0 7
67571: ARRAY
67572: PUSH
67573: LD_INT 2
67575: ARRAY
67576: PPUSH
67577: CALL_OW 351
67581: OR
67582: IFFALSE 67588
// exit ;
67584: POP
67585: POP
67586: GO 67880
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67588: LD_ADDR_VAR 0 8
67592: PUSH
67593: LD_VAR 0 12
67597: PUSH
67598: LD_VAR 0 7
67602: ARRAY
67603: PUSH
67604: LD_INT 1
67606: ARRAY
67607: PPUSH
67608: LD_VAR 0 12
67612: PUSH
67613: LD_VAR 0 7
67617: ARRAY
67618: PUSH
67619: LD_INT 2
67621: ARRAY
67622: PPUSH
67623: CALL_OW 546
67627: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67628: LD_VAR 0 8
67632: PUSH
67633: LD_INT 1
67635: ARRAY
67636: PUSH
67637: LD_VAR 0 8
67641: PUSH
67642: LD_INT 2
67644: ARRAY
67645: PUSH
67646: LD_VAR 0 13
67650: PUSH
67651: LD_INT 2
67653: PLUS
67654: GREATER
67655: OR
67656: PUSH
67657: LD_VAR 0 8
67661: PUSH
67662: LD_INT 2
67664: ARRAY
67665: PUSH
67666: LD_VAR 0 13
67670: PUSH
67671: LD_INT 2
67673: MINUS
67674: LESS
67675: OR
67676: PUSH
67677: LD_VAR 0 8
67681: PUSH
67682: LD_INT 3
67684: ARRAY
67685: PUSH
67686: LD_INT 0
67688: PUSH
67689: LD_INT 8
67691: PUSH
67692: LD_INT 9
67694: PUSH
67695: LD_INT 10
67697: PUSH
67698: LD_INT 11
67700: PUSH
67701: LD_INT 12
67703: PUSH
67704: LD_INT 13
67706: PUSH
67707: LD_INT 16
67709: PUSH
67710: LD_INT 17
67712: PUSH
67713: LD_INT 18
67715: PUSH
67716: LD_INT 19
67718: PUSH
67719: LD_INT 20
67721: PUSH
67722: LD_INT 21
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: IN
67740: NOT
67741: OR
67742: PUSH
67743: LD_VAR 0 8
67747: PUSH
67748: LD_INT 5
67750: ARRAY
67751: NOT
67752: OR
67753: PUSH
67754: LD_VAR 0 8
67758: PUSH
67759: LD_INT 6
67761: ARRAY
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: LD_INT 2
67768: PUSH
67769: LD_INT 7
67771: PUSH
67772: LD_INT 9
67774: PUSH
67775: LD_INT 10
67777: PUSH
67778: LD_INT 11
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: IN
67789: NOT
67790: OR
67791: IFFALSE 67797
// exit ;
67793: POP
67794: POP
67795: GO 67880
// end ;
67797: GO 67468
67799: POP
67800: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67801: LD_VAR 0 9
67805: PPUSH
67806: LD_VAR 0 3
67810: PPUSH
67811: LD_VAR 0 4
67815: PPUSH
67816: LD_INT 20
67818: PPUSH
67819: CALL 59803 0 4
67823: PUSH
67824: LD_INT 4
67826: ARRAY
67827: IFFALSE 67831
// exit ;
67829: GO 67880
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67831: LD_VAR 0 2
67835: PUSH
67836: LD_INT 29
67838: PUSH
67839: LD_INT 30
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: IN
67846: PUSH
67847: LD_VAR 0 3
67851: PPUSH
67852: LD_VAR 0 4
67856: PPUSH
67857: LD_VAR 0 9
67861: PPUSH
67862: CALL_OW 440
67866: NOT
67867: AND
67868: IFFALSE 67872
// exit ;
67870: GO 67880
// result := true ;
67872: LD_ADDR_VAR 0 6
67876: PUSH
67877: LD_INT 1
67879: ST_TO_ADDR
// end ;
67880: LD_VAR 0 6
67884: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67885: LD_INT 0
67887: PPUSH
67888: PPUSH
67889: PPUSH
67890: PPUSH
67891: PPUSH
67892: PPUSH
67893: PPUSH
67894: PPUSH
67895: PPUSH
67896: PPUSH
67897: PPUSH
67898: PPUSH
67899: PPUSH
67900: PPUSH
67901: PPUSH
67902: PPUSH
67903: PPUSH
67904: PPUSH
67905: PPUSH
67906: PPUSH
67907: PPUSH
67908: PPUSH
67909: PPUSH
67910: PPUSH
67911: PPUSH
67912: PPUSH
67913: PPUSH
67914: PPUSH
67915: PPUSH
67916: PPUSH
67917: PPUSH
67918: PPUSH
67919: PPUSH
67920: PPUSH
67921: PPUSH
67922: PPUSH
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
67928: PPUSH
67929: PPUSH
67930: PPUSH
67931: PPUSH
67932: PPUSH
67933: PPUSH
67934: PPUSH
67935: PPUSH
67936: PPUSH
67937: PPUSH
67938: PPUSH
67939: PPUSH
67940: PPUSH
67941: PPUSH
67942: PPUSH
67943: PPUSH
67944: PPUSH
// result = [ ] ;
67945: LD_ADDR_VAR 0 7
67949: PUSH
67950: EMPTY
67951: ST_TO_ADDR
// temp_list = [ ] ;
67952: LD_ADDR_VAR 0 9
67956: PUSH
67957: EMPTY
67958: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67959: LD_VAR 0 4
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: LD_INT 1
67969: PUSH
67970: LD_INT 2
67972: PUSH
67973: LD_INT 3
67975: PUSH
67976: LD_INT 4
67978: PUSH
67979: LD_INT 5
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: IN
67990: NOT
67991: PUSH
67992: LD_VAR 0 1
67996: PUSH
67997: LD_INT 0
67999: PUSH
68000: LD_INT 1
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: IN
68007: PUSH
68008: LD_VAR 0 5
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: LD_INT 3
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: LIST
68026: IN
68027: NOT
68028: AND
68029: OR
68030: IFFALSE 68034
// exit ;
68032: GO 86425
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
68034: LD_VAR 0 1
68038: PUSH
68039: LD_INT 6
68041: PUSH
68042: LD_INT 7
68044: PUSH
68045: LD_INT 8
68047: PUSH
68048: LD_INT 13
68050: PUSH
68051: LD_INT 12
68053: PUSH
68054: LD_INT 15
68056: PUSH
68057: LD_INT 11
68059: PUSH
68060: LD_INT 14
68062: PUSH
68063: LD_INT 10
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: IN
68077: IFFALSE 68087
// btype = b_lab ;
68079: LD_ADDR_VAR 0 1
68083: PUSH
68084: LD_INT 6
68086: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
68087: LD_VAR 0 6
68091: PUSH
68092: LD_INT 0
68094: PUSH
68095: LD_INT 1
68097: PUSH
68098: LD_INT 2
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: LIST
68105: IN
68106: NOT
68107: PUSH
68108: LD_VAR 0 1
68112: PUSH
68113: LD_INT 0
68115: PUSH
68116: LD_INT 1
68118: PUSH
68119: LD_INT 2
68121: PUSH
68122: LD_INT 3
68124: PUSH
68125: LD_INT 6
68127: PUSH
68128: LD_INT 36
68130: PUSH
68131: LD_INT 4
68133: PUSH
68134: LD_INT 5
68136: PUSH
68137: LD_INT 31
68139: PUSH
68140: LD_INT 32
68142: PUSH
68143: LD_INT 33
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: IN
68159: NOT
68160: PUSH
68161: LD_VAR 0 6
68165: PUSH
68166: LD_INT 1
68168: EQUAL
68169: AND
68170: OR
68171: PUSH
68172: LD_VAR 0 1
68176: PUSH
68177: LD_INT 2
68179: PUSH
68180: LD_INT 3
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: IN
68187: NOT
68188: PUSH
68189: LD_VAR 0 6
68193: PUSH
68194: LD_INT 2
68196: EQUAL
68197: AND
68198: OR
68199: IFFALSE 68209
// mode = 0 ;
68201: LD_ADDR_VAR 0 6
68205: PUSH
68206: LD_INT 0
68208: ST_TO_ADDR
// case mode of 0 :
68209: LD_VAR 0 6
68213: PUSH
68214: LD_INT 0
68216: DOUBLE
68217: EQUAL
68218: IFTRUE 68222
68220: GO 79675
68222: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
68223: LD_ADDR_VAR 0 11
68227: PUSH
68228: LD_INT 0
68230: PUSH
68231: LD_INT 0
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: PUSH
68252: LD_INT 0
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: LD_INT 1
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: LD_INT 1
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 1
68281: NEG
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: NEG
68293: PUSH
68294: LD_INT 1
68296: NEG
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: PUSH
68302: LD_INT 1
68304: NEG
68305: PUSH
68306: LD_INT 2
68308: NEG
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: PUSH
68314: LD_INT 0
68316: PUSH
68317: LD_INT 2
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 1
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: LD_INT 2
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 1
68358: NEG
68359: PUSH
68360: LD_INT 1
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 1
68369: PUSH
68370: LD_INT 3
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: LD_INT 3
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PUSH
68387: LD_INT 1
68389: NEG
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68416: LD_ADDR_VAR 0 12
68420: PUSH
68421: LD_INT 0
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 0
68433: PUSH
68434: LD_INT 1
68436: NEG
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: LD_INT 1
68444: PUSH
68445: LD_INT 0
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 1
68454: PUSH
68455: LD_INT 1
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 0
68464: PUSH
68465: LD_INT 1
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 1
68474: NEG
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 1
68485: NEG
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 1
68497: PUSH
68498: LD_INT 1
68500: NEG
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 2
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 2
68518: PUSH
68519: LD_INT 1
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 1
68528: NEG
68529: PUSH
68530: LD_INT 1
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 2
68539: NEG
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 2
68550: NEG
68551: PUSH
68552: LD_INT 1
68554: NEG
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 2
68562: NEG
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 3
68573: NEG
68574: PUSH
68575: LD_INT 0
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 3
68584: NEG
68585: PUSH
68586: LD_INT 1
68588: NEG
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68612: LD_ADDR_VAR 0 13
68616: PUSH
68617: LD_INT 0
68619: PUSH
68620: LD_INT 0
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 0
68629: PUSH
68630: LD_INT 1
68632: NEG
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 1
68640: PUSH
68641: LD_INT 0
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 1
68650: PUSH
68651: LD_INT 1
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 0
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: LD_INT 0
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 1
68681: NEG
68682: PUSH
68683: LD_INT 1
68685: NEG
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 1
68693: NEG
68694: PUSH
68695: LD_INT 2
68697: NEG
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 2
68705: PUSH
68706: LD_INT 1
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 2
68715: PUSH
68716: LD_INT 2
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 1
68725: PUSH
68726: LD_INT 2
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 2
68735: NEG
68736: PUSH
68737: LD_INT 1
68739: NEG
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 2
68747: NEG
68748: PUSH
68749: LD_INT 2
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 2
68759: NEG
68760: PUSH
68761: LD_INT 3
68763: NEG
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 3
68771: NEG
68772: PUSH
68773: LD_INT 2
68775: NEG
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 3
68783: NEG
68784: PUSH
68785: LD_INT 3
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68811: LD_ADDR_VAR 0 14
68815: PUSH
68816: LD_INT 0
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 0
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 1
68849: PUSH
68850: LD_INT 1
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 0
68859: PUSH
68860: LD_INT 1
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: PUSH
68867: LD_INT 1
68869: NEG
68870: PUSH
68871: LD_INT 0
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: LD_INT 1
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 1
68892: NEG
68893: PUSH
68894: LD_INT 2
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 0
68904: PUSH
68905: LD_INT 2
68907: NEG
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 1
68915: PUSH
68916: LD_INT 1
68918: NEG
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: LD_INT 2
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: LD_INT 1
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 1
68957: NEG
68958: PUSH
68959: LD_INT 3
68961: NEG
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: LD_INT 3
68972: NEG
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 1
68980: PUSH
68981: LD_INT 2
68983: NEG
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69007: LD_ADDR_VAR 0 15
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: LD_INT 1
69027: NEG
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 0
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 1
69045: PUSH
69046: LD_INT 1
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: LD_INT 0
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: LD_INT 1
69080: NEG
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: PUSH
69089: LD_INT 1
69091: NEG
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 2
69099: PUSH
69100: LD_INT 0
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 2
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 1
69119: NEG
69120: PUSH
69121: LD_INT 1
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 2
69130: NEG
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 2
69141: NEG
69142: PUSH
69143: LD_INT 1
69145: NEG
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 2
69153: PUSH
69154: LD_INT 1
69156: NEG
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 3
69164: PUSH
69165: LD_INT 0
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 3
69174: PUSH
69175: LD_INT 1
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69200: LD_ADDR_VAR 0 16
69204: PUSH
69205: LD_INT 0
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 0
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 1
69238: PUSH
69239: LD_INT 1
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 0
69248: PUSH
69249: LD_INT 1
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 1
69258: NEG
69259: PUSH
69260: LD_INT 0
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: LD_INT 1
69273: NEG
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: LD_INT 2
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: LD_INT 1
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 2
69303: PUSH
69304: LD_INT 2
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: LD_INT 2
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 2
69323: NEG
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 2
69335: NEG
69336: PUSH
69337: LD_INT 2
69339: NEG
69340: PUSH
69341: EMPTY
69342: LIST
69343: LIST
69344: PUSH
69345: LD_INT 3
69347: PUSH
69348: LD_INT 2
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 3
69357: PUSH
69358: LD_INT 3
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: LD_INT 2
69367: PUSH
69368: LD_INT 3
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: LIST
69381: LIST
69382: LIST
69383: LIST
69384: LIST
69385: LIST
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69393: LD_ADDR_VAR 0 17
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 0
69410: PUSH
69411: LD_INT 1
69413: NEG
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 1
69431: PUSH
69432: LD_INT 1
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: LD_INT 1
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: LD_INT 0
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: NEG
69463: PUSH
69464: LD_INT 1
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: NEG
69475: PUSH
69476: LD_INT 2
69478: NEG
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 0
69486: PUSH
69487: LD_INT 2
69489: NEG
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 1
69497: PUSH
69498: LD_INT 1
69500: NEG
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 2
69508: PUSH
69509: LD_INT 0
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 2
69518: PUSH
69519: LD_INT 1
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 2
69528: PUSH
69529: LD_INT 2
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 1
69538: PUSH
69539: LD_INT 2
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 0
69548: PUSH
69549: LD_INT 2
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 1
69558: NEG
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 2
69569: NEG
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 2
69580: NEG
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 2
69592: NEG
69593: PUSH
69594: LD_INT 2
69596: NEG
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69623: LD_ADDR_VAR 0 18
69627: PUSH
69628: LD_INT 0
69630: PUSH
69631: LD_INT 0
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 1
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 1
69661: PUSH
69662: LD_INT 1
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 0
69671: PUSH
69672: LD_INT 1
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 1
69681: NEG
69682: PUSH
69683: LD_INT 0
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 1
69692: NEG
69693: PUSH
69694: LD_INT 1
69696: NEG
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: PUSH
69706: LD_INT 2
69708: NEG
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 0
69716: PUSH
69717: LD_INT 2
69719: NEG
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 1
69727: PUSH
69728: LD_INT 1
69730: NEG
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 2
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 2
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 2
69758: PUSH
69759: LD_INT 2
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 1
69768: PUSH
69769: LD_INT 2
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 2
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 1
69788: NEG
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: NEG
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 2
69822: NEG
69823: PUSH
69824: LD_INT 2
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69853: LD_ADDR_VAR 0 19
69857: PUSH
69858: LD_INT 0
69860: PUSH
69861: LD_INT 0
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 0
69870: PUSH
69871: LD_INT 1
69873: NEG
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 1
69881: PUSH
69882: LD_INT 0
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: PUSH
69892: LD_INT 1
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 1
69922: NEG
69923: PUSH
69924: LD_INT 1
69926: NEG
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: NEG
69935: PUSH
69936: LD_INT 2
69938: NEG
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 0
69946: PUSH
69947: LD_INT 2
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: PUSH
69958: LD_INT 1
69960: NEG
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 2
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 2
69978: PUSH
69979: LD_INT 1
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 2
69988: PUSH
69989: LD_INT 2
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 1
69998: PUSH
69999: LD_INT 2
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: LD_INT 2
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 2
70029: NEG
70030: PUSH
70031: LD_INT 0
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 2
70040: NEG
70041: PUSH
70042: LD_INT 1
70044: NEG
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 2
70052: NEG
70053: PUSH
70054: LD_INT 2
70056: NEG
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70083: LD_ADDR_VAR 0 20
70087: PUSH
70088: LD_INT 0
70090: PUSH
70091: LD_INT 0
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 0
70100: PUSH
70101: LD_INT 1
70103: NEG
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: LD_INT 0
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 1
70121: PUSH
70122: LD_INT 1
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 0
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 1
70141: NEG
70142: PUSH
70143: LD_INT 0
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: LD_INT 1
70156: NEG
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: LD_INT 1
70164: NEG
70165: PUSH
70166: LD_INT 2
70168: NEG
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: LD_INT 2
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 1
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 2
70198: PUSH
70199: LD_INT 0
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 2
70208: PUSH
70209: LD_INT 1
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 2
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: LD_INT 1
70228: PUSH
70229: LD_INT 2
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: LD_INT 2
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: LD_INT 1
70248: NEG
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 2
70259: NEG
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 2
70270: NEG
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 2
70282: NEG
70283: PUSH
70284: LD_INT 2
70286: NEG
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70313: LD_ADDR_VAR 0 21
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: NEG
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 0
70406: PUSH
70407: LD_INT 2
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: LD_INT 1
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 2
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 2
70438: PUSH
70439: LD_INT 1
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 2
70448: PUSH
70449: LD_INT 2
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 1
70458: PUSH
70459: LD_INT 2
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: LD_INT 2
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 1
70478: NEG
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 2
70489: NEG
70490: PUSH
70491: LD_INT 0
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 2
70500: NEG
70501: PUSH
70502: LD_INT 1
70504: NEG
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 2
70512: NEG
70513: PUSH
70514: LD_INT 2
70516: NEG
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70543: LD_ADDR_VAR 0 22
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: LD_INT 0
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 1
70571: PUSH
70572: LD_INT 0
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: PUSH
70582: LD_INT 1
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 0
70591: PUSH
70592: LD_INT 1
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: LD_INT 0
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: LD_INT 1
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: NEG
70625: PUSH
70626: LD_INT 2
70628: NEG
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 0
70636: PUSH
70637: LD_INT 2
70639: NEG
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 1
70647: PUSH
70648: LD_INT 1
70650: NEG
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 2
70658: PUSH
70659: LD_INT 0
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 2
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 2
70678: PUSH
70679: LD_INT 2
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 1
70688: PUSH
70689: LD_INT 2
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 0
70698: PUSH
70699: LD_INT 2
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 1
70708: NEG
70709: PUSH
70710: LD_INT 1
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 0
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 2
70730: NEG
70731: PUSH
70732: LD_INT 1
70734: NEG
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 2
70742: NEG
70743: PUSH
70744: LD_INT 2
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70773: LD_ADDR_VAR 0 23
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: LD_INT 0
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: LD_INT 1
70793: NEG
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 1
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 1
70811: PUSH
70812: LD_INT 1
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: LD_INT 0
70821: PUSH
70822: LD_INT 1
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 1
70831: NEG
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 1
70842: NEG
70843: PUSH
70844: LD_INT 1
70846: NEG
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 1
70854: NEG
70855: PUSH
70856: LD_INT 2
70858: NEG
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 0
70866: PUSH
70867: LD_INT 2
70869: NEG
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 1
70877: PUSH
70878: LD_INT 1
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 0
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 2
70898: PUSH
70899: LD_INT 1
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 2
70908: PUSH
70909: LD_INT 2
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 1
70918: PUSH
70919: LD_INT 2
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 0
70928: PUSH
70929: LD_INT 2
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: PUSH
70936: LD_INT 1
70938: NEG
70939: PUSH
70940: LD_INT 1
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 2
70949: NEG
70950: PUSH
70951: LD_INT 0
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 2
70960: NEG
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: NEG
70973: PUSH
70974: LD_INT 2
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: LD_INT 3
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: NEG
70997: PUSH
70998: LD_INT 3
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: LD_INT 2
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 2
71019: PUSH
71020: LD_INT 1
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
71053: LD_ADDR_VAR 0 24
71057: PUSH
71058: LD_INT 0
71060: PUSH
71061: LD_INT 0
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: LD_INT 1
71073: NEG
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 1
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 1
71091: PUSH
71092: LD_INT 1
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: LD_INT 1
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 1
71111: NEG
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: LD_INT 1
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: LD_INT 2
71138: NEG
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 0
71146: PUSH
71147: LD_INT 2
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: LD_INT 1
71160: NEG
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 2
71168: PUSH
71169: LD_INT 0
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 2
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 2
71188: PUSH
71189: LD_INT 2
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: LD_INT 2
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 0
71208: PUSH
71209: LD_INT 2
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: NEG
71219: PUSH
71220: LD_INT 1
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 2
71229: NEG
71230: PUSH
71231: LD_INT 0
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 2
71240: NEG
71241: PUSH
71242: LD_INT 1
71244: NEG
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: LD_INT 2
71252: NEG
71253: PUSH
71254: LD_INT 2
71256: NEG
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 2
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: LD_INT 1
71278: NEG
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: LD_INT 3
71286: PUSH
71287: LD_INT 1
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 3
71296: PUSH
71297: LD_INT 2
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71329: LD_ADDR_VAR 0 25
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: LD_INT 0
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 0
71346: PUSH
71347: LD_INT 1
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 1
71367: PUSH
71368: LD_INT 1
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 0
71377: PUSH
71378: LD_INT 1
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: LD_INT 1
71387: NEG
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 1
71398: NEG
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 1
71410: NEG
71411: PUSH
71412: LD_INT 2
71414: NEG
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 0
71422: PUSH
71423: LD_INT 2
71425: NEG
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 2
71444: PUSH
71445: LD_INT 0
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: LD_INT 1
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: PUSH
71465: LD_INT 2
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 1
71474: PUSH
71475: LD_INT 2
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 0
71484: PUSH
71485: LD_INT 2
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 1
71494: NEG
71495: PUSH
71496: LD_INT 1
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 2
71505: NEG
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 2
71516: NEG
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 2
71528: NEG
71529: PUSH
71530: LD_INT 2
71532: NEG
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 3
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 3
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 2
71560: PUSH
71561: LD_INT 3
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 1
71570: PUSH
71571: LD_INT 3
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71603: LD_ADDR_VAR 0 26
71607: PUSH
71608: LD_INT 0
71610: PUSH
71611: LD_INT 0
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: LD_INT 1
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 1
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 1
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 1
71661: NEG
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PUSH
71686: LD_INT 2
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 0
71696: PUSH
71697: LD_INT 2
71699: NEG
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: LD_INT 1
71710: NEG
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 2
71718: PUSH
71719: LD_INT 0
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 2
71728: PUSH
71729: LD_INT 1
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 2
71738: PUSH
71739: LD_INT 2
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: LD_INT 2
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 0
71758: PUSH
71759: LD_INT 2
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 1
71768: NEG
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: LD_INT 2
71779: NEG
71780: PUSH
71781: LD_INT 0
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 2
71790: NEG
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 2
71802: NEG
71803: PUSH
71804: LD_INT 2
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: PUSH
71815: LD_INT 3
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: LD_INT 1
71824: PUSH
71825: LD_INT 3
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 1
71834: NEG
71835: PUSH
71836: LD_INT 2
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 2
71845: NEG
71846: PUSH
71847: LD_INT 1
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71879: LD_ADDR_VAR 0 27
71883: PUSH
71884: LD_INT 0
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 0
71896: PUSH
71897: LD_INT 1
71899: NEG
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 1
71907: PUSH
71908: LD_INT 0
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 1
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 0
71927: PUSH
71928: LD_INT 1
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 1
71937: NEG
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 1
71948: NEG
71949: PUSH
71950: LD_INT 1
71952: NEG
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 1
71960: NEG
71961: PUSH
71962: LD_INT 2
71964: NEG
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 0
71972: PUSH
71973: LD_INT 2
71975: NEG
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 1
71983: PUSH
71984: LD_INT 1
71986: NEG
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 2
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 2
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 2
72014: PUSH
72015: LD_INT 2
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 1
72024: PUSH
72025: LD_INT 2
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 0
72034: PUSH
72035: LD_INT 2
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 1
72044: NEG
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 2
72055: NEG
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 2
72066: NEG
72067: PUSH
72068: LD_INT 1
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 2
72078: NEG
72079: PUSH
72080: LD_INT 2
72082: NEG
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: LD_INT 2
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 2
72101: NEG
72102: PUSH
72103: LD_INT 1
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 3
72112: NEG
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 3
72124: NEG
72125: PUSH
72126: LD_INT 2
72128: NEG
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72159: LD_ADDR_VAR 0 28
72163: PUSH
72164: LD_INT 0
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 0
72176: PUSH
72177: LD_INT 1
72179: NEG
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 1
72187: PUSH
72188: LD_INT 0
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 1
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: LD_INT 1
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 1
72217: NEG
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 1
72228: NEG
72229: PUSH
72230: LD_INT 1
72232: NEG
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 1
72240: NEG
72241: PUSH
72242: LD_INT 2
72244: NEG
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 0
72252: PUSH
72253: LD_INT 2
72255: NEG
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: LD_INT 1
72266: NEG
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 2
72274: PUSH
72275: LD_INT 0
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 2
72284: PUSH
72285: LD_INT 1
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 2
72294: PUSH
72295: LD_INT 2
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: PUSH
72305: LD_INT 2
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 0
72314: PUSH
72315: LD_INT 2
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 1
72324: NEG
72325: PUSH
72326: LD_INT 1
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 2
72335: NEG
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 2
72346: NEG
72347: PUSH
72348: LD_INT 1
72350: NEG
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 2
72358: NEG
72359: PUSH
72360: LD_INT 2
72362: NEG
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: LD_INT 3
72374: NEG
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: LD_INT 3
72386: NEG
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 3
72394: NEG
72395: PUSH
72396: LD_INT 1
72398: NEG
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 3
72406: NEG
72407: PUSH
72408: LD_INT 2
72410: NEG
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72441: LD_ADDR_VAR 0 29
72445: PUSH
72446: LD_INT 0
72448: PUSH
72449: LD_INT 0
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 0
72458: PUSH
72459: LD_INT 1
72461: NEG
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 1
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 1
72479: PUSH
72480: LD_INT 1
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: LD_INT 1
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 1
72499: NEG
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 1
72510: NEG
72511: PUSH
72512: LD_INT 1
72514: NEG
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: LD_INT 1
72522: NEG
72523: PUSH
72524: LD_INT 2
72526: NEG
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 2
72537: NEG
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 2
72556: PUSH
72557: LD_INT 0
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 2
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 1
72576: PUSH
72577: LD_INT 2
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 0
72586: PUSH
72587: LD_INT 2
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: LD_INT 1
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 2
72607: NEG
72608: PUSH
72609: LD_INT 1
72611: NEG
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 2
72619: NEG
72620: PUSH
72621: LD_INT 2
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 2
72631: NEG
72632: PUSH
72633: LD_INT 3
72635: NEG
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 2
72643: PUSH
72644: LD_INT 1
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 3
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: PUSH
72665: LD_INT 3
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 1
72674: NEG
72675: PUSH
72676: LD_INT 2
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 3
72685: NEG
72686: PUSH
72687: LD_INT 2
72689: NEG
72690: PUSH
72691: EMPTY
72692: LIST
72693: LIST
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: LIST
72714: LIST
72715: LIST
72716: LIST
72717: LIST
72718: LIST
72719: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72720: LD_ADDR_VAR 0 30
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 0
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 0
72737: PUSH
72738: LD_INT 1
72740: NEG
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: PUSH
72749: LD_INT 0
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: LD_INT 1
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 0
72768: PUSH
72769: LD_INT 1
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: NEG
72779: PUSH
72780: LD_INT 0
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 1
72789: NEG
72790: PUSH
72791: LD_INT 1
72793: NEG
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 1
72801: NEG
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 0
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 1
72824: PUSH
72825: LD_INT 1
72827: NEG
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 2
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 2
72845: PUSH
72846: LD_INT 1
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: PUSH
72853: LD_INT 2
72855: PUSH
72856: LD_INT 2
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 1
72865: PUSH
72866: LD_INT 2
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: PUSH
72873: LD_INT 1
72875: NEG
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 2
72897: NEG
72898: PUSH
72899: LD_INT 1
72901: NEG
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 3
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 3
72932: PUSH
72933: LD_INT 2
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 2
72942: PUSH
72943: LD_INT 3
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 2
72952: NEG
72953: PUSH
72954: LD_INT 1
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 3
72963: NEG
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72998: LD_ADDR_VAR 0 31
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: LD_INT 0
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: LD_INT 1
73018: NEG
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 1
73026: PUSH
73027: LD_INT 0
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: LD_INT 1
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: LD_INT 1
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 1
73056: NEG
73057: PUSH
73058: LD_INT 0
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: NEG
73068: PUSH
73069: LD_INT 1
73071: NEG
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 1
73079: NEG
73080: PUSH
73081: LD_INT 2
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 1
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 2
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 2
73112: PUSH
73113: LD_INT 1
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 2
73122: PUSH
73123: LD_INT 2
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 1
73132: PUSH
73133: LD_INT 2
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 0
73142: PUSH
73143: LD_INT 2
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 1
73152: NEG
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 2
73163: NEG
73164: PUSH
73165: LD_INT 1
73167: NEG
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 2
73175: NEG
73176: PUSH
73177: LD_INT 2
73179: NEG
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 2
73187: NEG
73188: PUSH
73189: LD_INT 3
73191: NEG
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 2
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 3
73210: PUSH
73211: LD_INT 1
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 1
73220: PUSH
73221: LD_INT 3
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 1
73230: NEG
73231: PUSH
73232: LD_INT 2
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 3
73241: NEG
73242: PUSH
73243: LD_INT 2
73245: NEG
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: LIST
73255: LIST
73256: LIST
73257: LIST
73258: LIST
73259: LIST
73260: LIST
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73276: LD_ADDR_VAR 0 32
73280: PUSH
73281: LD_INT 0
73283: PUSH
73284: LD_INT 0
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: LD_INT 1
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: PUSH
73305: LD_INT 0
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: PUSH
73315: LD_INT 1
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: LD_INT 1
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 1
73334: NEG
73335: PUSH
73336: LD_INT 0
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 1
73345: NEG
73346: PUSH
73347: LD_INT 1
73349: NEG
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 1
73357: NEG
73358: PUSH
73359: LD_INT 2
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 0
73369: PUSH
73370: LD_INT 2
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 1
73380: PUSH
73381: LD_INT 1
73383: NEG
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 2
73391: PUSH
73392: LD_INT 1
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 2
73401: PUSH
73402: LD_INT 2
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 1
73411: PUSH
73412: LD_INT 2
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 0
73421: PUSH
73422: LD_INT 2
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: LD_INT 1
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 2
73442: NEG
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 2
73453: NEG
73454: PUSH
73455: LD_INT 1
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: NEG
73466: PUSH
73467: LD_INT 3
73469: NEG
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 3
73488: PUSH
73489: LD_INT 2
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: PUSH
73499: LD_INT 3
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 2
73508: NEG
73509: PUSH
73510: LD_INT 1
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 3
73519: NEG
73520: PUSH
73521: LD_INT 1
73523: NEG
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73554: LD_ADDR_VAR 0 33
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: LD_INT 0
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: LD_INT 1
73574: NEG
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: LD_INT 1
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 0
73602: PUSH
73603: LD_INT 1
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 1
73612: NEG
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 1
73623: NEG
73624: PUSH
73625: LD_INT 1
73627: NEG
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: LD_INT 2
73639: NEG
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: LD_INT 1
73647: PUSH
73648: LD_INT 1
73650: NEG
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 2
73658: PUSH
73659: LD_INT 0
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 2
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: LD_INT 2
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 0
73688: PUSH
73689: LD_INT 2
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 1
73698: NEG
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: LD_INT 2
73709: NEG
73710: PUSH
73711: LD_INT 0
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 2
73720: NEG
73721: PUSH
73722: LD_INT 1
73724: NEG
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 2
73732: NEG
73733: PUSH
73734: LD_INT 2
73736: NEG
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: LD_INT 3
73748: NEG
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 2
73756: PUSH
73757: LD_INT 1
73759: NEG
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 3
73767: PUSH
73768: LD_INT 1
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 1
73777: PUSH
73778: LD_INT 3
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 1
73787: NEG
73788: PUSH
73789: LD_INT 2
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 3
73798: NEG
73799: PUSH
73800: LD_INT 2
73802: NEG
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73833: LD_ADDR_VAR 0 34
73837: PUSH
73838: LD_INT 0
73840: PUSH
73841: LD_INT 0
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 0
73850: PUSH
73851: LD_INT 1
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: PUSH
73872: LD_INT 1
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 0
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 1
73891: NEG
73892: PUSH
73893: LD_INT 0
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 1
73902: NEG
73903: PUSH
73904: LD_INT 1
73906: NEG
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 2
73918: NEG
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 0
73926: PUSH
73927: LD_INT 2
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: LD_INT 1
73940: NEG
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: LD_INT 1
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: LD_INT 2
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 1
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 1
73978: NEG
73979: PUSH
73980: LD_INT 1
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 2
73989: NEG
73990: PUSH
73991: LD_INT 0
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 2
74000: NEG
74001: PUSH
74002: LD_INT 1
74004: NEG
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 2
74012: NEG
74013: PUSH
74014: LD_INT 2
74016: NEG
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 1
74024: NEG
74025: PUSH
74026: LD_INT 3
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 1
74036: PUSH
74037: LD_INT 2
74039: NEG
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 3
74047: PUSH
74048: LD_INT 2
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 2
74057: PUSH
74058: LD_INT 3
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 2
74067: NEG
74068: PUSH
74069: LD_INT 1
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 3
74078: NEG
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: LIST
74092: LIST
74093: LIST
74094: LIST
74095: LIST
74096: LIST
74097: LIST
74098: LIST
74099: LIST
74100: LIST
74101: LIST
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: LIST
74107: LIST
74108: LIST
74109: LIST
74110: LIST
74111: LIST
74112: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74113: LD_ADDR_VAR 0 35
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: LD_INT 0
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 0
74130: PUSH
74131: LD_INT 1
74133: NEG
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: PUSH
74139: LD_INT 1
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 1
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 0
74161: PUSH
74162: LD_INT 1
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 1
74171: NEG
74172: PUSH
74173: LD_INT 0
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 1
74182: NEG
74183: PUSH
74184: LD_INT 1
74186: NEG
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 2
74194: PUSH
74195: LD_INT 1
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 2
74204: NEG
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74225: LD_ADDR_VAR 0 36
74229: PUSH
74230: LD_INT 0
74232: PUSH
74233: LD_INT 0
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 0
74242: PUSH
74243: LD_INT 1
74245: NEG
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 1
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 1
74263: PUSH
74264: LD_INT 1
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 0
74273: PUSH
74274: LD_INT 1
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 1
74283: NEG
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: LD_INT 1
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 1
74306: NEG
74307: PUSH
74308: LD_INT 2
74310: NEG
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 1
74318: PUSH
74319: LD_INT 2
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: LIST
74335: LIST
74336: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74337: LD_ADDR_VAR 0 37
74341: PUSH
74342: LD_INT 0
74344: PUSH
74345: LD_INT 0
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 0
74354: PUSH
74355: LD_INT 1
74357: NEG
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: LD_INT 1
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 1
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 1
74406: NEG
74407: PUSH
74408: LD_INT 1
74410: NEG
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 1
74418: PUSH
74419: LD_INT 1
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 1
74429: NEG
74430: PUSH
74431: LD_INT 1
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: LIST
74448: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74449: LD_ADDR_VAR 0 38
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: LD_INT 0
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 0
74466: PUSH
74467: LD_INT 1
74469: NEG
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 1
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: LD_INT 0
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 1
74518: NEG
74519: PUSH
74520: LD_INT 1
74522: NEG
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 2
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 2
74540: NEG
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: LIST
74554: LIST
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: LIST
74560: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74561: LD_ADDR_VAR 0 39
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: LD_INT 0
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 0
74578: PUSH
74579: LD_INT 1
74581: NEG
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 1
74589: PUSH
74590: LD_INT 0
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 1
74599: PUSH
74600: LD_INT 1
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 0
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 1
74619: NEG
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 1
74630: NEG
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 1
74642: NEG
74643: PUSH
74644: LD_INT 2
74646: NEG
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: LD_INT 1
74654: PUSH
74655: LD_INT 2
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74673: LD_ADDR_VAR 0 40
74677: PUSH
74678: LD_INT 0
74680: PUSH
74681: LD_INT 0
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 1
74731: NEG
74732: PUSH
74733: LD_INT 0
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 1
74742: NEG
74743: PUSH
74744: LD_INT 1
74746: NEG
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 1
74754: PUSH
74755: LD_INT 1
74757: NEG
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: LD_INT 1
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74785: LD_ADDR_VAR 0 41
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: LD_INT 0
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: LD_INT 1
74805: NEG
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: LD_INT 1
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: LD_INT 0
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: NEG
74855: PUSH
74856: LD_INT 1
74858: NEG
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: LD_INT 2
74870: NEG
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 1
74878: PUSH
74879: LD_INT 1
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 2
74889: PUSH
74890: LD_INT 0
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 2
74899: PUSH
74900: LD_INT 1
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 2
74909: PUSH
74910: LD_INT 2
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: LD_INT 2
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 1
74929: NEG
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 2
74940: NEG
74941: PUSH
74942: LD_INT 0
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 2
74951: NEG
74952: PUSH
74953: LD_INT 1
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 2
74963: NEG
74964: PUSH
74965: LD_INT 2
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 2
74975: NEG
74976: PUSH
74977: LD_INT 3
74979: NEG
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 2
74987: PUSH
74988: LD_INT 1
74990: NEG
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 3
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 3
75008: PUSH
75009: LD_INT 1
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 3
75018: PUSH
75019: LD_INT 2
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 3
75028: PUSH
75029: LD_INT 3
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 2
75038: PUSH
75039: LD_INT 3
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: LD_INT 1
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: LD_INT 0
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 3
75070: NEG
75071: PUSH
75072: LD_INT 1
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 3
75082: NEG
75083: PUSH
75084: LD_INT 2
75086: NEG
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 3
75094: NEG
75095: PUSH
75096: LD_INT 3
75098: NEG
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75135: LD_ADDR_VAR 0 42
75139: PUSH
75140: LD_INT 0
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 0
75152: PUSH
75153: LD_INT 1
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 1
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 1
75173: PUSH
75174: LD_INT 1
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 0
75183: PUSH
75184: LD_INT 1
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 1
75193: NEG
75194: PUSH
75195: LD_INT 0
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 1
75204: NEG
75205: PUSH
75206: LD_INT 1
75208: NEG
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 1
75216: NEG
75217: PUSH
75218: LD_INT 2
75220: NEG
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 0
75228: PUSH
75229: LD_INT 2
75231: NEG
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 1
75239: PUSH
75240: LD_INT 1
75242: NEG
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 2
75250: PUSH
75251: LD_INT 1
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 2
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: PUSH
75271: LD_INT 2
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: LD_INT 2
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: LD_INT 1
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 2
75301: NEG
75302: PUSH
75303: LD_INT 1
75305: NEG
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 2
75313: NEG
75314: PUSH
75315: LD_INT 2
75317: NEG
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: LD_INT 3
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: NEG
75338: PUSH
75339: LD_INT 3
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 0
75349: PUSH
75350: LD_INT 3
75352: NEG
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: LD_INT 2
75363: NEG
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_INT 3
75371: PUSH
75372: LD_INT 2
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 3
75381: PUSH
75382: LD_INT 3
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 2
75391: PUSH
75392: LD_INT 3
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 1
75401: PUSH
75402: LD_INT 3
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 0
75411: PUSH
75412: LD_INT 3
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 1
75421: NEG
75422: PUSH
75423: LD_INT 2
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 3
75432: NEG
75433: PUSH
75434: LD_INT 2
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 3
75444: NEG
75445: PUSH
75446: LD_INT 3
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: LIST
75474: LIST
75475: LIST
75476: LIST
75477: LIST
75478: LIST
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75485: LD_ADDR_VAR 0 43
75489: PUSH
75490: LD_INT 0
75492: PUSH
75493: LD_INT 0
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: PUSH
75500: LD_INT 0
75502: PUSH
75503: LD_INT 1
75505: NEG
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 1
75523: PUSH
75524: LD_INT 1
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: LD_INT 1
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 1
75543: NEG
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 1
75554: NEG
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: LD_INT 2
75570: NEG
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 0
75578: PUSH
75579: LD_INT 2
75581: NEG
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: PUSH
75590: LD_INT 1
75592: NEG
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 2
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 2
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: PUSH
75621: LD_INT 2
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 0
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 1
75640: NEG
75641: PUSH
75642: LD_INT 1
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 2
75651: NEG
75652: PUSH
75653: LD_INT 0
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 2
75662: NEG
75663: PUSH
75664: LD_INT 1
75666: NEG
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 1
75674: NEG
75675: PUSH
75676: LD_INT 3
75678: NEG
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: LD_INT 3
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 1
75697: PUSH
75698: LD_INT 2
75700: NEG
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 2
75708: PUSH
75709: LD_INT 1
75711: NEG
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 3
75719: PUSH
75720: LD_INT 0
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 3
75729: PUSH
75730: LD_INT 1
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 1
75739: PUSH
75740: LD_INT 3
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 0
75749: PUSH
75750: LD_INT 3
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 1
75759: NEG
75760: PUSH
75761: LD_INT 2
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 2
75770: NEG
75771: PUSH
75772: LD_INT 1
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: PUSH
75779: LD_INT 3
75781: NEG
75782: PUSH
75783: LD_INT 0
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 3
75792: NEG
75793: PUSH
75794: LD_INT 1
75796: NEG
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: LIST
75820: LIST
75821: LIST
75822: LIST
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75833: LD_ADDR_VAR 0 44
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: LD_INT 0
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 0
75850: PUSH
75851: LD_INT 1
75853: NEG
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 1
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 1
75871: PUSH
75872: LD_INT 1
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: LD_INT 1
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: NEG
75903: PUSH
75904: LD_INT 1
75906: NEG
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 1
75914: NEG
75915: PUSH
75916: LD_INT 2
75918: NEG
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 1
75926: PUSH
75927: LD_INT 1
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 2
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 2
75947: PUSH
75948: LD_INT 1
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 2
75957: PUSH
75958: LD_INT 2
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: LD_INT 2
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 1
75977: NEG
75978: PUSH
75979: LD_INT 1
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 2
75988: NEG
75989: PUSH
75990: LD_INT 0
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 2
75999: NEG
76000: PUSH
76001: LD_INT 1
76003: NEG
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 2
76011: NEG
76012: PUSH
76013: LD_INT 2
76015: NEG
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 2
76023: NEG
76024: PUSH
76025: LD_INT 3
76027: NEG
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 1
76038: NEG
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 3
76046: PUSH
76047: LD_INT 0
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 3
76056: PUSH
76057: LD_INT 1
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 3
76066: PUSH
76067: LD_INT 2
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 3
76076: PUSH
76077: LD_INT 3
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 2
76086: PUSH
76087: LD_INT 3
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 2
76096: NEG
76097: PUSH
76098: LD_INT 1
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 3
76107: NEG
76108: PUSH
76109: LD_INT 0
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 3
76118: NEG
76119: PUSH
76120: LD_INT 1
76122: NEG
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 3
76130: NEG
76131: PUSH
76132: LD_INT 2
76134: NEG
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 3
76142: NEG
76143: PUSH
76144: LD_INT 3
76146: NEG
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: LIST
76163: LIST
76164: LIST
76165: LIST
76166: LIST
76167: LIST
76168: LIST
76169: LIST
76170: LIST
76171: LIST
76172: LIST
76173: LIST
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76183: LD_ADDR_VAR 0 45
76187: PUSH
76188: LD_INT 0
76190: PUSH
76191: LD_INT 0
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: PUSH
76198: LD_INT 0
76200: PUSH
76201: LD_INT 1
76203: NEG
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 1
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 1
76221: PUSH
76222: LD_INT 1
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 0
76231: PUSH
76232: LD_INT 1
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 1
76241: NEG
76242: PUSH
76243: LD_INT 0
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 1
76252: NEG
76253: PUSH
76254: LD_INT 1
76256: NEG
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 1
76264: NEG
76265: PUSH
76266: LD_INT 2
76268: NEG
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 0
76276: PUSH
76277: LD_INT 2
76279: NEG
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 1
76287: PUSH
76288: LD_INT 1
76290: NEG
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: LD_INT 1
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: LD_INT 2
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 1
76318: PUSH
76319: LD_INT 2
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 0
76328: PUSH
76329: LD_INT 2
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 2
76349: NEG
76350: PUSH
76351: LD_INT 1
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 2
76361: NEG
76362: PUSH
76363: LD_INT 2
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 2
76373: NEG
76374: PUSH
76375: LD_INT 3
76377: NEG
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: LD_INT 3
76389: NEG
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 3
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 2
76411: NEG
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 3
76419: PUSH
76420: LD_INT 2
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 3
76429: PUSH
76430: LD_INT 3
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: LD_INT 3
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 1
76449: PUSH
76450: LD_INT 3
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 0
76459: PUSH
76460: LD_INT 3
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 1
76469: NEG
76470: PUSH
76471: LD_INT 2
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 3
76480: NEG
76481: PUSH
76482: LD_INT 2
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 3
76492: NEG
76493: PUSH
76494: LD_INT 3
76496: NEG
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: LIST
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76533: LD_ADDR_VAR 0 46
76537: PUSH
76538: LD_INT 0
76540: PUSH
76541: LD_INT 0
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: LD_INT 1
76553: NEG
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: PUSH
76559: LD_INT 1
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: LD_INT 1
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: LD_INT 1
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 1
76591: NEG
76592: PUSH
76593: LD_INT 0
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 1
76602: NEG
76603: PUSH
76604: LD_INT 1
76606: NEG
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 1
76614: NEG
76615: PUSH
76616: LD_INT 2
76618: NEG
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 0
76626: PUSH
76627: LD_INT 2
76629: NEG
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 1
76637: PUSH
76638: LD_INT 1
76640: NEG
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 2
76648: PUSH
76649: LD_INT 0
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 2
76658: PUSH
76659: LD_INT 1
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: LD_INT 2
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 0
76678: PUSH
76679: LD_INT 2
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 1
76688: NEG
76689: PUSH
76690: LD_INT 1
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: LD_INT 0
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 2
76710: NEG
76711: PUSH
76712: LD_INT 1
76714: NEG
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 1
76722: NEG
76723: PUSH
76724: LD_INT 3
76726: NEG
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: LD_INT 3
76737: NEG
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 1
76745: PUSH
76746: LD_INT 2
76748: NEG
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 2
76756: PUSH
76757: LD_INT 1
76759: NEG
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 3
76767: PUSH
76768: LD_INT 0
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 3
76777: PUSH
76778: LD_INT 1
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: PUSH
76788: LD_INT 3
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 0
76797: PUSH
76798: LD_INT 3
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 1
76807: NEG
76808: PUSH
76809: LD_INT 2
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 3
76840: NEG
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76881: LD_ADDR_VAR 0 47
76885: PUSH
76886: LD_INT 0
76888: PUSH
76889: LD_INT 0
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 0
76898: PUSH
76899: LD_INT 1
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 0
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 1
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 0
76929: PUSH
76930: LD_INT 1
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: NEG
76951: PUSH
76952: LD_INT 1
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 1
76962: NEG
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: LD_INT 2
76977: NEG
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 1
76985: PUSH
76986: LD_INT 1
76988: NEG
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 2
76996: NEG
76997: PUSH
76998: LD_INT 1
77000: NEG
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: LD_INT 2
77012: NEG
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: LIST
77022: LIST
77023: LIST
77024: LIST
77025: LIST
77026: LIST
77027: LIST
77028: LIST
77029: LIST
77030: LIST
77031: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77032: LD_ADDR_VAR 0 48
77036: PUSH
77037: LD_INT 0
77039: PUSH
77040: LD_INT 0
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 0
77049: PUSH
77050: LD_INT 1
77052: NEG
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 1
77060: PUSH
77061: LD_INT 0
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 1
77070: PUSH
77071: LD_INT 1
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: LD_INT 1
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 1
77090: NEG
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: NEG
77102: PUSH
77103: LD_INT 1
77105: NEG
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 1
77113: NEG
77114: PUSH
77115: LD_INT 2
77117: NEG
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 0
77125: PUSH
77126: LD_INT 2
77128: NEG
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 1
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 2
77147: PUSH
77148: LD_INT 0
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 2
77157: PUSH
77158: LD_INT 1
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77179: LD_ADDR_VAR 0 49
77183: PUSH
77184: LD_INT 0
77186: PUSH
77187: LD_INT 0
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 0
77196: PUSH
77197: LD_INT 1
77199: NEG
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 1
77207: PUSH
77208: LD_INT 0
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 1
77217: PUSH
77218: LD_INT 1
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 0
77227: PUSH
77228: LD_INT 1
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 1
77237: NEG
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 1
77248: NEG
77249: PUSH
77250: LD_INT 1
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 1
77260: PUSH
77261: LD_INT 1
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 2
77271: PUSH
77272: LD_INT 0
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: LD_INT 1
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: PUSH
77289: LD_INT 2
77291: PUSH
77292: LD_INT 2
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PUSH
77299: LD_INT 1
77301: PUSH
77302: LD_INT 2
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77323: LD_ADDR_VAR 0 50
77327: PUSH
77328: LD_INT 0
77330: PUSH
77331: LD_INT 0
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 0
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: PUSH
77352: LD_INT 0
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 1
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 0
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 1
77381: NEG
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 2
77404: PUSH
77405: LD_INT 1
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 2
77414: PUSH
77415: LD_INT 2
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 1
77424: PUSH
77425: LD_INT 2
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: LD_INT 2
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 1
77444: NEG
77445: PUSH
77446: LD_INT 1
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77467: LD_ADDR_VAR 0 51
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: LD_INT 0
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: LD_INT 1
77487: NEG
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 1
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 1
77505: PUSH
77506: LD_INT 1
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 0
77515: PUSH
77516: LD_INT 1
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: LD_INT 1
77525: NEG
77526: PUSH
77527: LD_INT 0
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 1
77536: NEG
77537: PUSH
77538: LD_INT 1
77540: NEG
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 1
77548: PUSH
77549: LD_INT 2
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: LD_INT 2
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 1
77568: NEG
77569: PUSH
77570: LD_INT 1
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 2
77579: NEG
77580: PUSH
77581: LD_INT 0
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 2
77590: NEG
77591: PUSH
77592: LD_INT 1
77594: NEG
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77614: LD_ADDR_VAR 0 52
77618: PUSH
77619: LD_INT 0
77621: PUSH
77622: LD_INT 0
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 0
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 1
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 1
77652: PUSH
77653: LD_INT 1
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: LD_INT 1
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 1
77672: NEG
77673: PUSH
77674: LD_INT 0
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 1
77683: NEG
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: NEG
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 1
77707: NEG
77708: PUSH
77709: LD_INT 1
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 2
77718: NEG
77719: PUSH
77720: LD_INT 0
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 2
77729: NEG
77730: PUSH
77731: LD_INT 1
77733: NEG
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 2
77741: NEG
77742: PUSH
77743: LD_INT 2
77745: NEG
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77765: LD_ADDR_VAR 0 53
77769: PUSH
77770: LD_INT 0
77772: PUSH
77773: LD_INT 0
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: LD_INT 1
77785: NEG
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 1
77793: PUSH
77794: LD_INT 0
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 1
77803: PUSH
77804: LD_INT 1
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 0
77813: PUSH
77814: LD_INT 1
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: NEG
77824: PUSH
77825: LD_INT 0
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 1
77834: NEG
77835: PUSH
77836: LD_INT 1
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: LD_INT 2
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: LD_INT 2
77861: NEG
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 1
77869: PUSH
77870: LD_INT 1
77872: NEG
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: LD_INT 0
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 2
77890: PUSH
77891: LD_INT 1
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 2
77900: PUSH
77901: LD_INT 2
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 1
77910: PUSH
77911: LD_INT 2
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 0
77920: PUSH
77921: LD_INT 2
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 1
77930: NEG
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 2
77941: NEG
77942: PUSH
77943: LD_INT 0
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 2
77952: NEG
77953: PUSH
77954: LD_INT 1
77956: NEG
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 2
77964: NEG
77965: PUSH
77966: LD_INT 2
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77995: LD_ADDR_VAR 0 54
77999: PUSH
78000: LD_INT 0
78002: PUSH
78003: LD_INT 0
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: LD_INT 1
78015: NEG
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 1
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 1
78033: PUSH
78034: LD_INT 1
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 0
78043: PUSH
78044: LD_INT 1
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 1
78053: NEG
78054: PUSH
78055: LD_INT 0
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 1
78064: NEG
78065: PUSH
78066: LD_INT 1
78068: NEG
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: LD_INT 2
78080: NEG
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 2
78091: NEG
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 1
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 2
78110: PUSH
78111: LD_INT 0
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 2
78130: PUSH
78131: LD_INT 2
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: PUSH
78141: LD_INT 2
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: LD_INT 2
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: LD_INT 0
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 2
78182: NEG
78183: PUSH
78184: LD_INT 1
78186: NEG
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: LD_INT 2
78198: NEG
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78225: LD_ADDR_VAR 0 55
78229: PUSH
78230: LD_INT 0
78232: PUSH
78233: LD_INT 0
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 0
78242: PUSH
78243: LD_INT 1
78245: NEG
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 1
78253: PUSH
78254: LD_INT 0
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 1
78263: PUSH
78264: LD_INT 1
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 1
78283: NEG
78284: PUSH
78285: LD_INT 0
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 1
78294: NEG
78295: PUSH
78296: LD_INT 1
78298: NEG
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 1
78306: NEG
78307: PUSH
78308: LD_INT 2
78310: NEG
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 0
78318: PUSH
78319: LD_INT 2
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 1
78329: PUSH
78330: LD_INT 1
78332: NEG
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 2
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 2
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 2
78360: PUSH
78361: LD_INT 2
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 1
78370: PUSH
78371: LD_INT 2
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: LD_INT 2
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 1
78390: NEG
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 2
78401: NEG
78402: PUSH
78403: LD_INT 0
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 2
78412: NEG
78413: PUSH
78414: LD_INT 1
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 2
78424: NEG
78425: PUSH
78426: LD_INT 2
78428: NEG
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78455: LD_ADDR_VAR 0 56
78459: PUSH
78460: LD_INT 0
78462: PUSH
78463: LD_INT 0
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 0
78472: PUSH
78473: LD_INT 1
78475: NEG
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 1
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 1
78493: PUSH
78494: LD_INT 1
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 0
78503: PUSH
78504: LD_INT 1
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: LD_INT 1
78513: NEG
78514: PUSH
78515: LD_INT 0
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 1
78524: NEG
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 1
78536: NEG
78537: PUSH
78538: LD_INT 2
78540: NEG
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 0
78548: PUSH
78549: LD_INT 2
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 1
78559: PUSH
78560: LD_INT 1
78562: NEG
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 2
78570: PUSH
78571: LD_INT 0
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 2
78580: PUSH
78581: LD_INT 1
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 2
78590: PUSH
78591: LD_INT 2
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 1
78600: PUSH
78601: LD_INT 2
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 0
78610: PUSH
78611: LD_INT 2
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 1
78620: NEG
78621: PUSH
78622: LD_INT 1
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 2
78631: NEG
78632: PUSH
78633: LD_INT 0
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 2
78642: NEG
78643: PUSH
78644: LD_INT 1
78646: NEG
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 2
78654: NEG
78655: PUSH
78656: LD_INT 2
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78685: LD_ADDR_VAR 0 57
78689: PUSH
78690: LD_INT 0
78692: PUSH
78693: LD_INT 0
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: LD_INT 1
78705: NEG
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: LD_INT 1
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: LD_INT 1
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 1
78743: NEG
78744: PUSH
78745: LD_INT 0
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: NEG
78755: PUSH
78756: LD_INT 1
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 1
78766: NEG
78767: PUSH
78768: LD_INT 2
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: LD_INT 2
78781: NEG
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 1
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 2
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 2
78820: PUSH
78821: LD_INT 2
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 1
78830: PUSH
78831: LD_INT 2
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 0
78840: PUSH
78841: LD_INT 2
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: NEG
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 2
78861: NEG
78862: PUSH
78863: LD_INT 0
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 2
78872: NEG
78873: PUSH
78874: LD_INT 1
78876: NEG
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 2
78884: NEG
78885: PUSH
78886: LD_INT 2
78888: NEG
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78915: LD_ADDR_VAR 0 58
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: LD_INT 0
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 0
78932: PUSH
78933: LD_INT 1
78935: NEG
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 1
78943: PUSH
78944: LD_INT 0
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 1
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 1
78973: NEG
78974: PUSH
78975: LD_INT 0
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 1
78984: NEG
78985: PUSH
78986: LD_INT 1
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: LD_INT 2
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 0
79008: PUSH
79009: LD_INT 2
79011: NEG
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 1
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 2
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 2
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 2
79050: PUSH
79051: LD_INT 2
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: LD_INT 2
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 0
79070: PUSH
79071: LD_INT 2
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 1
79080: NEG
79081: PUSH
79082: LD_INT 1
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 2
79091: NEG
79092: PUSH
79093: LD_INT 0
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 2
79102: NEG
79103: PUSH
79104: LD_INT 1
79106: NEG
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 2
79114: NEG
79115: PUSH
79116: LD_INT 2
79118: NEG
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79145: LD_ADDR_VAR 0 59
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: LD_INT 0
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 0
79162: PUSH
79163: LD_INT 1
79165: NEG
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 1
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 1
79183: PUSH
79184: LD_INT 1
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: LD_INT 1
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 1
79203: NEG
79204: PUSH
79205: LD_INT 0
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 1
79214: NEG
79215: PUSH
79216: LD_INT 1
79218: NEG
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79233: LD_ADDR_VAR 0 60
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 0
79250: PUSH
79251: LD_INT 1
79253: NEG
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 1
79261: PUSH
79262: LD_INT 0
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 1
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 0
79281: PUSH
79282: LD_INT 1
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 1
79291: NEG
79292: PUSH
79293: LD_INT 0
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 1
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79321: LD_ADDR_VAR 0 61
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: LD_INT 0
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 0
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 1
79359: PUSH
79360: LD_INT 1
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: LD_INT 1
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 1
79379: NEG
79380: PUSH
79381: LD_INT 0
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79409: LD_ADDR_VAR 0 62
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: LD_INT 0
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 0
79426: PUSH
79427: LD_INT 1
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 1
79447: PUSH
79448: LD_INT 1
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 0
79457: PUSH
79458: LD_INT 1
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: NEG
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: NEG
79479: PUSH
79480: LD_INT 1
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79497: LD_ADDR_VAR 0 63
79501: PUSH
79502: LD_INT 0
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 0
79514: PUSH
79515: LD_INT 1
79517: NEG
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 1
79525: PUSH
79526: LD_INT 0
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: LD_INT 1
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: LD_INT 1
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79585: LD_ADDR_VAR 0 64
79589: PUSH
79590: LD_INT 0
79592: PUSH
79593: LD_INT 0
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 0
79602: PUSH
79603: LD_INT 1
79605: NEG
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 1
79613: PUSH
79614: LD_INT 0
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 1
79623: PUSH
79624: LD_INT 1
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 0
79633: PUSH
79634: LD_INT 1
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 1
79643: NEG
79644: PUSH
79645: LD_INT 0
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: ST_TO_ADDR
// end ; 1 :
79673: GO 85570
79675: LD_INT 1
79677: DOUBLE
79678: EQUAL
79679: IFTRUE 79683
79681: GO 82306
79683: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79684: LD_ADDR_VAR 0 11
79688: PUSH
79689: LD_INT 1
79691: NEG
79692: PUSH
79693: LD_INT 3
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: LD_INT 3
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 2
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: LIST
79727: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79728: LD_ADDR_VAR 0 12
79732: PUSH
79733: LD_INT 2
79735: PUSH
79736: LD_INT 1
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 3
79746: PUSH
79747: LD_INT 0
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 3
79756: PUSH
79757: LD_INT 1
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: LIST
79768: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79769: LD_ADDR_VAR 0 13
79773: PUSH
79774: LD_INT 3
79776: PUSH
79777: LD_INT 2
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 3
79786: PUSH
79787: LD_INT 3
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 2
79796: PUSH
79797: LD_INT 3
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: LIST
79808: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79809: LD_ADDR_VAR 0 14
79813: PUSH
79814: LD_INT 1
79816: PUSH
79817: LD_INT 3
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 0
79826: PUSH
79827: LD_INT 3
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 1
79836: NEG
79837: PUSH
79838: LD_INT 2
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: LIST
79849: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79850: LD_ADDR_VAR 0 15
79854: PUSH
79855: LD_INT 2
79857: NEG
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 3
79868: NEG
79869: PUSH
79870: LD_INT 0
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PUSH
79877: LD_INT 3
79879: NEG
79880: PUSH
79881: LD_INT 1
79883: NEG
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: LIST
79893: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79894: LD_ADDR_VAR 0 16
79898: PUSH
79899: LD_INT 2
79901: NEG
79902: PUSH
79903: LD_INT 3
79905: NEG
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 3
79913: NEG
79914: PUSH
79915: LD_INT 2
79917: NEG
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 3
79925: NEG
79926: PUSH
79927: LD_INT 3
79929: NEG
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: LIST
79939: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79940: LD_ADDR_VAR 0 17
79944: PUSH
79945: LD_INT 1
79947: NEG
79948: PUSH
79949: LD_INT 3
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: LD_INT 3
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: PUSH
79971: LD_INT 2
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: LIST
79983: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79984: LD_ADDR_VAR 0 18
79988: PUSH
79989: LD_INT 2
79991: PUSH
79992: LD_INT 1
79994: NEG
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 3
80002: PUSH
80003: LD_INT 0
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: LD_INT 1
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: LIST
80024: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80025: LD_ADDR_VAR 0 19
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: LD_INT 2
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: LD_INT 3
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: PUSH
80050: LD_INT 2
80052: PUSH
80053: LD_INT 3
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: LIST
80064: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80065: LD_ADDR_VAR 0 20
80069: PUSH
80070: LD_INT 1
80072: PUSH
80073: LD_INT 3
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 0
80082: PUSH
80083: LD_INT 3
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 1
80092: NEG
80093: PUSH
80094: LD_INT 2
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: LIST
80105: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80106: LD_ADDR_VAR 0 21
80110: PUSH
80111: LD_INT 2
80113: NEG
80114: PUSH
80115: LD_INT 1
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: LD_INT 3
80124: NEG
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 3
80135: NEG
80136: PUSH
80137: LD_INT 1
80139: NEG
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: LIST
80149: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80150: LD_ADDR_VAR 0 22
80154: PUSH
80155: LD_INT 2
80157: NEG
80158: PUSH
80159: LD_INT 3
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 3
80169: NEG
80170: PUSH
80171: LD_INT 2
80173: NEG
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 3
80181: NEG
80182: PUSH
80183: LD_INT 3
80185: NEG
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: LIST
80195: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
80196: LD_ADDR_VAR 0 23
80200: PUSH
80201: LD_INT 0
80203: PUSH
80204: LD_INT 3
80206: NEG
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: LD_INT 4
80218: NEG
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: LD_INT 3
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: LIST
80239: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
80240: LD_ADDR_VAR 0 24
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: LD_INT 0
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 3
80257: PUSH
80258: LD_INT 1
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 4
80268: PUSH
80269: LD_INT 1
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: LIST
80280: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
80281: LD_ADDR_VAR 0 25
80285: PUSH
80286: LD_INT 3
80288: PUSH
80289: LD_INT 3
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 4
80298: PUSH
80299: LD_INT 3
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 3
80308: PUSH
80309: LD_INT 4
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: LIST
80320: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80321: LD_ADDR_VAR 0 26
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: LD_INT 3
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: LD_INT 4
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 1
80348: NEG
80349: PUSH
80350: LD_INT 3
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: LIST
80361: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80362: LD_ADDR_VAR 0 27
80366: PUSH
80367: LD_INT 3
80369: NEG
80370: PUSH
80371: LD_INT 0
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 3
80380: NEG
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 4
80391: NEG
80392: PUSH
80393: LD_INT 1
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: LIST
80405: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80406: LD_ADDR_VAR 0 28
80410: PUSH
80411: LD_INT 3
80413: NEG
80414: PUSH
80415: LD_INT 3
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 3
80425: NEG
80426: PUSH
80427: LD_INT 4
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 4
80437: NEG
80438: PUSH
80439: LD_INT 3
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: LIST
80451: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80452: LD_ADDR_VAR 0 29
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: LD_INT 3
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 0
80471: PUSH
80472: LD_INT 3
80474: NEG
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 1
80482: PUSH
80483: LD_INT 2
80485: NEG
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 1
80493: NEG
80494: PUSH
80495: LD_INT 4
80497: NEG
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 0
80505: PUSH
80506: LD_INT 4
80508: NEG
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 1
80516: PUSH
80517: LD_INT 3
80519: NEG
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 1
80527: NEG
80528: PUSH
80529: LD_INT 5
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 0
80539: PUSH
80540: LD_INT 5
80542: NEG
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PUSH
80548: LD_INT 1
80550: PUSH
80551: LD_INT 4
80553: NEG
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 1
80561: NEG
80562: PUSH
80563: LD_INT 6
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: LD_INT 6
80576: NEG
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 1
80584: PUSH
80585: LD_INT 5
80587: NEG
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80607: LD_ADDR_VAR 0 30
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: LD_INT 1
80617: NEG
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 3
80625: PUSH
80626: LD_INT 0
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 3
80635: PUSH
80636: LD_INT 1
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 3
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 4
80656: PUSH
80657: LD_INT 0
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 4
80666: PUSH
80667: LD_INT 1
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 4
80676: PUSH
80677: LD_INT 1
80679: NEG
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 5
80687: PUSH
80688: LD_INT 0
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 5
80697: PUSH
80698: LD_INT 1
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 5
80707: PUSH
80708: LD_INT 1
80710: NEG
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 6
80718: PUSH
80719: LD_INT 0
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 6
80728: PUSH
80729: LD_INT 1
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80750: LD_ADDR_VAR 0 31
80754: PUSH
80755: LD_INT 3
80757: PUSH
80758: LD_INT 2
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 3
80767: PUSH
80768: LD_INT 3
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: PUSH
80778: LD_INT 3
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 4
80787: PUSH
80788: LD_INT 3
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 4
80797: PUSH
80798: LD_INT 4
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 3
80807: PUSH
80808: LD_INT 4
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 5
80817: PUSH
80818: LD_INT 4
80820: PUSH
80821: EMPTY
80822: LIST
80823: LIST
80824: PUSH
80825: LD_INT 5
80827: PUSH
80828: LD_INT 5
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 4
80837: PUSH
80838: LD_INT 5
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 6
80847: PUSH
80848: LD_INT 5
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 6
80857: PUSH
80858: LD_INT 6
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 5
80867: PUSH
80868: LD_INT 6
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80889: LD_ADDR_VAR 0 32
80893: PUSH
80894: LD_INT 1
80896: PUSH
80897: LD_INT 3
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 0
80906: PUSH
80907: LD_INT 3
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 1
80927: PUSH
80928: LD_INT 4
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 0
80937: PUSH
80938: LD_INT 4
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: NEG
80948: PUSH
80949: LD_INT 3
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 1
80958: PUSH
80959: LD_INT 5
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 0
80968: PUSH
80969: LD_INT 5
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: NEG
80979: PUSH
80980: LD_INT 4
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: LD_INT 6
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 0
80999: PUSH
81000: LD_INT 6
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 5
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
81032: LD_ADDR_VAR 0 33
81036: PUSH
81037: LD_INT 2
81039: NEG
81040: PUSH
81041: LD_INT 1
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 3
81050: NEG
81051: PUSH
81052: LD_INT 0
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 3
81061: NEG
81062: PUSH
81063: LD_INT 1
81065: NEG
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 3
81073: NEG
81074: PUSH
81075: LD_INT 1
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 4
81084: NEG
81085: PUSH
81086: LD_INT 0
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 4
81095: NEG
81096: PUSH
81097: LD_INT 1
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 4
81107: NEG
81108: PUSH
81109: LD_INT 1
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 5
81118: NEG
81119: PUSH
81120: LD_INT 0
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 5
81129: NEG
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 5
81141: NEG
81142: PUSH
81143: LD_INT 1
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 6
81152: NEG
81153: PUSH
81154: LD_INT 0
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 6
81163: NEG
81164: PUSH
81165: LD_INT 1
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
81187: LD_ADDR_VAR 0 34
81191: PUSH
81192: LD_INT 2
81194: NEG
81195: PUSH
81196: LD_INT 3
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 3
81206: NEG
81207: PUSH
81208: LD_INT 2
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 3
81218: NEG
81219: PUSH
81220: LD_INT 3
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 3
81230: NEG
81231: PUSH
81232: LD_INT 4
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 4
81242: NEG
81243: PUSH
81244: LD_INT 3
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 4
81254: NEG
81255: PUSH
81256: LD_INT 4
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 4
81266: NEG
81267: PUSH
81268: LD_INT 5
81270: NEG
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 5
81278: NEG
81279: PUSH
81280: LD_INT 4
81282: NEG
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 5
81290: NEG
81291: PUSH
81292: LD_INT 5
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 5
81302: NEG
81303: PUSH
81304: LD_INT 6
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 6
81314: NEG
81315: PUSH
81316: LD_INT 5
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 6
81326: NEG
81327: PUSH
81328: LD_INT 6
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81350: LD_ADDR_VAR 0 41
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: NEG
81369: PUSH
81370: LD_INT 3
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: LIST
81393: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81394: LD_ADDR_VAR 0 42
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: LD_INT 0
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 2
81411: PUSH
81412: LD_INT 1
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 3
81422: PUSH
81423: LD_INT 1
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: LIST
81434: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81435: LD_ADDR_VAR 0 43
81439: PUSH
81440: LD_INT 2
81442: PUSH
81443: LD_INT 2
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 3
81452: PUSH
81453: LD_INT 2
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 2
81462: PUSH
81463: LD_INT 3
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: LIST
81474: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81475: LD_ADDR_VAR 0 44
81479: PUSH
81480: LD_INT 0
81482: PUSH
81483: LD_INT 2
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 1
81492: PUSH
81493: LD_INT 3
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 1
81502: NEG
81503: PUSH
81504: LD_INT 2
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: LIST
81515: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81516: LD_ADDR_VAR 0 45
81520: PUSH
81521: LD_INT 2
81523: NEG
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 2
81534: NEG
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 3
81545: NEG
81546: PUSH
81547: LD_INT 1
81549: NEG
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: LIST
81559: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81560: LD_ADDR_VAR 0 46
81564: PUSH
81565: LD_INT 2
81567: NEG
81568: PUSH
81569: LD_INT 2
81571: NEG
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: LD_INT 3
81583: NEG
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 3
81591: NEG
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: LIST
81605: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81606: LD_ADDR_VAR 0 47
81610: PUSH
81611: LD_INT 2
81613: NEG
81614: PUSH
81615: LD_INT 3
81617: NEG
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: NEG
81626: PUSH
81627: LD_INT 3
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81639: LD_ADDR_VAR 0 48
81643: PUSH
81644: LD_INT 1
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 2
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81670: LD_ADDR_VAR 0 49
81674: PUSH
81675: LD_INT 3
81677: PUSH
81678: LD_INT 1
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 3
81687: PUSH
81688: LD_INT 2
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81699: LD_ADDR_VAR 0 50
81703: PUSH
81704: LD_INT 2
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 1
81716: PUSH
81717: LD_INT 3
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81728: LD_ADDR_VAR 0 51
81732: PUSH
81733: LD_INT 1
81735: NEG
81736: PUSH
81737: LD_INT 2
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 2
81746: NEG
81747: PUSH
81748: LD_INT 1
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81759: LD_ADDR_VAR 0 52
81763: PUSH
81764: LD_INT 3
81766: NEG
81767: PUSH
81768: LD_INT 1
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 3
81778: NEG
81779: PUSH
81780: LD_INT 2
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81792: LD_ADDR_VAR 0 53
81796: PUSH
81797: LD_INT 1
81799: NEG
81800: PUSH
81801: LD_INT 3
81803: NEG
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: LD_INT 3
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: PUSH
81823: LD_INT 2
81825: NEG
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: LIST
81835: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81836: LD_ADDR_VAR 0 54
81840: PUSH
81841: LD_INT 2
81843: PUSH
81844: LD_INT 1
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 3
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 3
81864: PUSH
81865: LD_INT 1
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: LIST
81876: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81877: LD_ADDR_VAR 0 55
81881: PUSH
81882: LD_INT 3
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 3
81894: PUSH
81895: LD_INT 3
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 2
81904: PUSH
81905: LD_INT 3
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: LIST
81916: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81917: LD_ADDR_VAR 0 56
81921: PUSH
81922: LD_INT 1
81924: PUSH
81925: LD_INT 3
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: LD_INT 3
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 1
81944: NEG
81945: PUSH
81946: LD_INT 2
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: LIST
81957: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81958: LD_ADDR_VAR 0 57
81962: PUSH
81963: LD_INT 2
81965: NEG
81966: PUSH
81967: LD_INT 1
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 3
81976: NEG
81977: PUSH
81978: LD_INT 0
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 3
81987: NEG
81988: PUSH
81989: LD_INT 1
81991: NEG
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: LIST
82001: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82002: LD_ADDR_VAR 0 58
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: LD_INT 3
82013: NEG
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 3
82021: NEG
82022: PUSH
82023: LD_INT 2
82025: NEG
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 3
82033: NEG
82034: PUSH
82035: LD_INT 3
82037: NEG
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: LIST
82047: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
82048: LD_ADDR_VAR 0 59
82052: PUSH
82053: LD_INT 1
82055: NEG
82056: PUSH
82057: LD_INT 2
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 0
82067: PUSH
82068: LD_INT 2
82070: NEG
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 1
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: LIST
82091: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
82092: LD_ADDR_VAR 0 60
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: LD_INT 1
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 2
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 2
82120: PUSH
82121: LD_INT 1
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: LIST
82132: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
82133: LD_ADDR_VAR 0 61
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 2
82150: PUSH
82151: LD_INT 2
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: LD_INT 2
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: LIST
82172: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
82173: LD_ADDR_VAR 0 62
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: LD_INT 2
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: LD_INT 2
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 1
82200: NEG
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: LIST
82213: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
82214: LD_ADDR_VAR 0 63
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: LD_INT 1
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 2
82232: NEG
82233: PUSH
82234: LD_INT 0
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 2
82243: NEG
82244: PUSH
82245: LD_INT 1
82247: NEG
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: LIST
82257: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82258: LD_ADDR_VAR 0 64
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 2
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 2
82277: NEG
82278: PUSH
82279: LD_INT 1
82281: NEG
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 2
82289: NEG
82290: PUSH
82291: LD_INT 2
82293: NEG
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: LIST
82303: ST_TO_ADDR
// end ; 2 :
82304: GO 85570
82306: LD_INT 2
82308: DOUBLE
82309: EQUAL
82310: IFTRUE 82314
82312: GO 85569
82314: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
82315: LD_ADDR_VAR 0 29
82319: PUSH
82320: LD_INT 4
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 4
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 5
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 5
82353: PUSH
82354: LD_INT 1
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 4
82363: PUSH
82364: LD_INT 1
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 3
82373: PUSH
82374: LD_INT 0
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 3
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 5
82405: PUSH
82406: LD_INT 2
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 3
82415: PUSH
82416: LD_INT 3
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 3
82425: PUSH
82426: LD_INT 2
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 4
82435: PUSH
82436: LD_INT 3
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 4
82445: PUSH
82446: LD_INT 4
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 3
82455: PUSH
82456: LD_INT 4
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: LD_INT 3
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 2
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 4
82485: PUSH
82486: LD_INT 2
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 2
82495: PUSH
82496: LD_INT 4
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 0
82505: PUSH
82506: LD_INT 4
82508: PUSH
82509: EMPTY
82510: LIST
82511: LIST
82512: PUSH
82513: LD_INT 0
82515: PUSH
82516: LD_INT 3
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: LD_INT 4
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 1
82535: PUSH
82536: LD_INT 5
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 0
82545: PUSH
82546: LD_INT 5
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 1
82555: NEG
82556: PUSH
82557: LD_INT 4
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 1
82566: NEG
82567: PUSH
82568: LD_INT 3
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: LD_INT 5
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 2
82587: NEG
82588: PUSH
82589: LD_INT 3
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 3
82598: NEG
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 3
82609: NEG
82610: PUSH
82611: LD_INT 1
82613: NEG
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 2
82621: NEG
82622: PUSH
82623: LD_INT 0
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 2
82632: NEG
82633: PUSH
82634: LD_INT 1
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: LD_INT 1
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 4
82654: NEG
82655: PUSH
82656: LD_INT 0
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 4
82665: NEG
82666: PUSH
82667: LD_INT 1
82669: NEG
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 4
82677: NEG
82678: PUSH
82679: LD_INT 2
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: NEG
82690: PUSH
82691: LD_INT 2
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 4
82700: NEG
82701: PUSH
82702: LD_INT 4
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 4
82712: NEG
82713: PUSH
82714: LD_INT 5
82716: NEG
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 3
82724: NEG
82725: PUSH
82726: LD_INT 4
82728: NEG
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 3
82736: NEG
82737: PUSH
82738: LD_INT 3
82740: NEG
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 4
82748: NEG
82749: PUSH
82750: LD_INT 3
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 5
82760: NEG
82761: PUSH
82762: LD_INT 4
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 5
82772: NEG
82773: PUSH
82774: LD_INT 5
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 3
82784: NEG
82785: PUSH
82786: LD_INT 5
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 5
82796: NEG
82797: PUSH
82798: LD_INT 3
82800: NEG
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82853: LD_ADDR_VAR 0 30
82857: PUSH
82858: LD_INT 4
82860: PUSH
82861: LD_INT 4
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 4
82870: PUSH
82871: LD_INT 3
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 5
82880: PUSH
82881: LD_INT 4
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 5
82890: PUSH
82891: LD_INT 5
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 4
82900: PUSH
82901: LD_INT 5
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 3
82910: PUSH
82911: LD_INT 4
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: LD_INT 3
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 5
82930: PUSH
82931: LD_INT 3
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 3
82940: PUSH
82941: LD_INT 5
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: LD_INT 3
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: LD_INT 2
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 1
82970: PUSH
82971: LD_INT 3
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: LD_INT 4
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 0
82990: PUSH
82991: LD_INT 4
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 1
83000: NEG
83001: PUSH
83002: LD_INT 3
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: NEG
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 2
83022: PUSH
83023: LD_INT 4
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 2
83032: NEG
83033: PUSH
83034: LD_INT 2
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 4
83043: NEG
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 4
83054: NEG
83055: PUSH
83056: LD_INT 1
83058: NEG
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 3
83066: NEG
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 3
83077: NEG
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 4
83088: NEG
83089: PUSH
83090: LD_INT 1
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 5
83099: NEG
83100: PUSH
83101: LD_INT 0
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 5
83110: NEG
83111: PUSH
83112: LD_INT 1
83114: NEG
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 5
83122: NEG
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 3
83134: NEG
83135: PUSH
83136: LD_INT 2
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 3
83145: NEG
83146: PUSH
83147: LD_INT 3
83149: NEG
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 3
83157: NEG
83158: PUSH
83159: LD_INT 4
83161: NEG
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 2
83169: NEG
83170: PUSH
83171: LD_INT 3
83173: NEG
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 2
83181: NEG
83182: PUSH
83183: LD_INT 2
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 3
83193: NEG
83194: PUSH
83195: LD_INT 2
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 4
83205: NEG
83206: PUSH
83207: LD_INT 3
83209: NEG
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 4
83217: NEG
83218: PUSH
83219: LD_INT 4
83221: NEG
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 2
83229: NEG
83230: PUSH
83231: LD_INT 4
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 4
83241: NEG
83242: PUSH
83243: LD_INT 2
83245: NEG
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 0
83253: PUSH
83254: LD_INT 4
83256: NEG
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 0
83264: PUSH
83265: LD_INT 5
83267: NEG
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: LD_INT 4
83278: NEG
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 1
83286: PUSH
83287: LD_INT 3
83289: NEG
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 0
83297: PUSH
83298: LD_INT 3
83300: NEG
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: NEG
83309: PUSH
83310: LD_INT 4
83312: NEG
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: LD_INT 5
83324: NEG
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 2
83332: PUSH
83333: LD_INT 3
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 2
83343: NEG
83344: PUSH
83345: LD_INT 5
83347: NEG
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83400: LD_ADDR_VAR 0 31
83404: PUSH
83405: LD_INT 0
83407: PUSH
83408: LD_INT 4
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 0
83417: PUSH
83418: LD_INT 3
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: PUSH
83428: LD_INT 4
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 1
83437: PUSH
83438: LD_INT 5
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: LD_INT 5
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 1
83457: NEG
83458: PUSH
83459: LD_INT 4
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: LD_INT 3
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 2
83479: PUSH
83480: LD_INT 5
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 2
83489: NEG
83490: PUSH
83491: LD_INT 3
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 3
83500: NEG
83501: PUSH
83502: LD_INT 0
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 3
83511: NEG
83512: PUSH
83513: LD_INT 1
83515: NEG
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: NEG
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 2
83534: NEG
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 3
83545: NEG
83546: PUSH
83547: LD_INT 1
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 4
83556: NEG
83557: PUSH
83558: LD_INT 0
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 4
83567: NEG
83568: PUSH
83569: LD_INT 1
83571: NEG
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 4
83579: NEG
83580: PUSH
83581: LD_INT 2
83583: NEG
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 2
83591: NEG
83592: PUSH
83593: LD_INT 2
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 4
83602: NEG
83603: PUSH
83604: LD_INT 4
83606: NEG
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 4
83614: NEG
83615: PUSH
83616: LD_INT 5
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 3
83626: NEG
83627: PUSH
83628: LD_INT 4
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 3
83638: NEG
83639: PUSH
83640: LD_INT 3
83642: NEG
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 4
83650: NEG
83651: PUSH
83652: LD_INT 3
83654: NEG
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 5
83662: NEG
83663: PUSH
83664: LD_INT 4
83666: NEG
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 5
83674: NEG
83675: PUSH
83676: LD_INT 5
83678: NEG
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 3
83686: NEG
83687: PUSH
83688: LD_INT 5
83690: NEG
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 5
83698: NEG
83699: PUSH
83700: LD_INT 3
83702: NEG
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 0
83710: PUSH
83711: LD_INT 3
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 0
83721: PUSH
83722: LD_INT 4
83724: NEG
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 3
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 1
83743: PUSH
83744: LD_INT 2
83746: NEG
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 0
83754: PUSH
83755: LD_INT 2
83757: NEG
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: NEG
83766: PUSH
83767: LD_INT 3
83769: NEG
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 1
83777: NEG
83778: PUSH
83779: LD_INT 4
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 2
83789: PUSH
83790: LD_INT 2
83792: NEG
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 2
83800: NEG
83801: PUSH
83802: LD_INT 4
83804: NEG
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 4
83812: PUSH
83813: LD_INT 0
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 4
83822: PUSH
83823: LD_INT 1
83825: NEG
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 5
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 5
83843: PUSH
83844: LD_INT 1
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 4
83853: PUSH
83854: LD_INT 1
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 3
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 3
83873: PUSH
83874: LD_INT 1
83876: NEG
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 3
83884: PUSH
83885: LD_INT 2
83887: NEG
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 5
83895: PUSH
83896: LD_INT 2
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83950: LD_ADDR_VAR 0 32
83954: PUSH
83955: LD_INT 4
83957: NEG
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 4
83968: NEG
83969: PUSH
83970: LD_INT 1
83972: NEG
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 3
83980: NEG
83981: PUSH
83982: LD_INT 0
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 3
83991: NEG
83992: PUSH
83993: LD_INT 1
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 4
84002: NEG
84003: PUSH
84004: LD_INT 1
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PUSH
84011: LD_INT 5
84013: NEG
84014: PUSH
84015: LD_INT 0
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 5
84024: NEG
84025: PUSH
84026: LD_INT 1
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 5
84036: NEG
84037: PUSH
84038: LD_INT 2
84040: NEG
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 3
84048: NEG
84049: PUSH
84050: LD_INT 2
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 3
84059: NEG
84060: PUSH
84061: LD_INT 3
84063: NEG
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 3
84071: NEG
84072: PUSH
84073: LD_INT 4
84075: NEG
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 2
84083: NEG
84084: PUSH
84085: LD_INT 3
84087: NEG
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 2
84095: NEG
84096: PUSH
84097: LD_INT 2
84099: NEG
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: LD_INT 3
84107: NEG
84108: PUSH
84109: LD_INT 2
84111: NEG
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 4
84119: NEG
84120: PUSH
84121: LD_INT 3
84123: NEG
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 4
84131: NEG
84132: PUSH
84133: LD_INT 4
84135: NEG
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 2
84143: NEG
84144: PUSH
84145: LD_INT 4
84147: NEG
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: LD_INT 4
84155: NEG
84156: PUSH
84157: LD_INT 2
84159: NEG
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 0
84167: PUSH
84168: LD_INT 4
84170: NEG
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 0
84178: PUSH
84179: LD_INT 5
84181: NEG
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: LD_INT 4
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 3
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 0
84211: PUSH
84212: LD_INT 3
84214: NEG
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: LD_INT 1
84222: NEG
84223: PUSH
84224: LD_INT 4
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: NEG
84235: PUSH
84236: LD_INT 5
84238: NEG
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 2
84246: PUSH
84247: LD_INT 3
84249: NEG
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 2
84257: NEG
84258: PUSH
84259: LD_INT 5
84261: NEG
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 3
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 3
84279: PUSH
84280: LD_INT 1
84282: NEG
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 4
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 4
84300: PUSH
84301: LD_INT 1
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 3
84310: PUSH
84311: LD_INT 1
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 2
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 2
84330: PUSH
84331: LD_INT 1
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 2
84341: PUSH
84342: LD_INT 2
84344: NEG
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 4
84352: PUSH
84353: LD_INT 2
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 4
84362: PUSH
84363: LD_INT 4
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 4
84372: PUSH
84373: LD_INT 3
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 5
84382: PUSH
84383: LD_INT 4
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 5
84392: PUSH
84393: LD_INT 5
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 4
84402: PUSH
84403: LD_INT 5
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 3
84412: PUSH
84413: LD_INT 4
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 3
84422: PUSH
84423: LD_INT 3
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 5
84432: PUSH
84433: LD_INT 3
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 3
84442: PUSH
84443: LD_INT 5
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84497: LD_ADDR_VAR 0 33
84501: PUSH
84502: LD_INT 4
84504: NEG
84505: PUSH
84506: LD_INT 4
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 4
84516: NEG
84517: PUSH
84518: LD_INT 5
84520: NEG
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 3
84528: NEG
84529: PUSH
84530: LD_INT 4
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 3
84540: NEG
84541: PUSH
84542: LD_INT 3
84544: NEG
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 4
84552: NEG
84553: PUSH
84554: LD_INT 3
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 5
84564: NEG
84565: PUSH
84566: LD_INT 4
84568: NEG
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 5
84576: NEG
84577: PUSH
84578: LD_INT 5
84580: NEG
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 3
84588: NEG
84589: PUSH
84590: LD_INT 5
84592: NEG
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 5
84600: NEG
84601: PUSH
84602: LD_INT 3
84604: NEG
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: LD_INT 3
84615: NEG
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 0
84623: PUSH
84624: LD_INT 4
84626: NEG
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 1
84634: PUSH
84635: LD_INT 3
84637: NEG
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 1
84645: PUSH
84646: LD_INT 2
84648: NEG
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: LD_INT 2
84659: NEG
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: NEG
84668: PUSH
84669: LD_INT 3
84671: NEG
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: LD_INT 1
84679: NEG
84680: PUSH
84681: LD_INT 4
84683: NEG
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 2
84691: PUSH
84692: LD_INT 2
84694: NEG
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 2
84702: NEG
84703: PUSH
84704: LD_INT 4
84706: NEG
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 4
84714: PUSH
84715: LD_INT 0
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 4
84724: PUSH
84725: LD_INT 1
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 5
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 5
84745: PUSH
84746: LD_INT 1
84748: PUSH
84749: EMPTY
84750: LIST
84751: LIST
84752: PUSH
84753: LD_INT 4
84755: PUSH
84756: LD_INT 1
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 3
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 3
84775: PUSH
84776: LD_INT 1
84778: NEG
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 3
84786: PUSH
84787: LD_INT 2
84789: NEG
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 5
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 3
84807: PUSH
84808: LD_INT 3
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 3
84817: PUSH
84818: LD_INT 2
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 4
84827: PUSH
84828: LD_INT 3
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 4
84837: PUSH
84838: LD_INT 4
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 3
84847: PUSH
84848: LD_INT 4
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 2
84857: PUSH
84858: LD_INT 3
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 2
84867: PUSH
84868: LD_INT 2
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 4
84877: PUSH
84878: LD_INT 2
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 2
84887: PUSH
84888: LD_INT 4
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 4
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: LD_INT 3
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: PUSH
84918: LD_INT 4
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: PUSH
84928: LD_INT 5
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 0
84937: PUSH
84938: LD_INT 5
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: LD_INT 4
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 1
84958: NEG
84959: PUSH
84960: LD_INT 3
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 2
84969: PUSH
84970: LD_INT 5
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 2
84979: NEG
84980: PUSH
84981: LD_INT 3
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
85035: LD_ADDR_VAR 0 34
85039: PUSH
85040: LD_INT 0
85042: PUSH
85043: LD_INT 4
85045: NEG
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 0
85053: PUSH
85054: LD_INT 5
85056: NEG
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 1
85064: PUSH
85065: LD_INT 4
85067: NEG
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 1
85075: PUSH
85076: LD_INT 3
85078: NEG
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 0
85086: PUSH
85087: LD_INT 3
85089: NEG
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 1
85097: NEG
85098: PUSH
85099: LD_INT 4
85101: NEG
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: LD_INT 5
85113: NEG
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 2
85121: PUSH
85122: LD_INT 3
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 2
85132: NEG
85133: PUSH
85134: LD_INT 5
85136: NEG
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 3
85144: PUSH
85145: LD_INT 0
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 3
85154: PUSH
85155: LD_INT 1
85157: NEG
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 4
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 4
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 3
85185: PUSH
85186: LD_INT 1
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 2
85195: PUSH
85196: LD_INT 0
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 2
85205: PUSH
85206: LD_INT 1
85208: NEG
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 2
85216: PUSH
85217: LD_INT 2
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 4
85227: PUSH
85228: LD_INT 2
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 4
85237: PUSH
85238: LD_INT 4
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 4
85247: PUSH
85248: LD_INT 3
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 5
85257: PUSH
85258: LD_INT 4
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 5
85267: PUSH
85268: LD_INT 5
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 4
85277: PUSH
85278: LD_INT 5
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 3
85287: PUSH
85288: LD_INT 4
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 3
85297: PUSH
85298: LD_INT 3
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 5
85307: PUSH
85308: LD_INT 3
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 3
85317: PUSH
85318: LD_INT 5
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 0
85327: PUSH
85328: LD_INT 3
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: PUSH
85335: LD_INT 0
85337: PUSH
85338: LD_INT 2
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 1
85347: PUSH
85348: LD_INT 3
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 1
85357: PUSH
85358: LD_INT 4
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 0
85367: PUSH
85368: LD_INT 4
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 1
85377: NEG
85378: PUSH
85379: LD_INT 3
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 1
85388: NEG
85389: PUSH
85390: LD_INT 2
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: LD_INT 4
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 2
85409: NEG
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 4
85420: NEG
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 4
85431: NEG
85432: PUSH
85433: LD_INT 1
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 3
85454: NEG
85455: PUSH
85456: LD_INT 1
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 4
85465: NEG
85466: PUSH
85467: LD_INT 1
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 5
85476: NEG
85477: PUSH
85478: LD_INT 0
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 5
85487: NEG
85488: PUSH
85489: LD_INT 1
85491: NEG
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 5
85499: NEG
85500: PUSH
85501: LD_INT 2
85503: NEG
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 3
85511: NEG
85512: PUSH
85513: LD_INT 2
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: ST_TO_ADDR
// end ; end ;
85567: GO 85570
85569: POP
// case btype of b_depot , b_warehouse :
85570: LD_VAR 0 1
85574: PUSH
85575: LD_INT 0
85577: DOUBLE
85578: EQUAL
85579: IFTRUE 85589
85581: LD_INT 1
85583: DOUBLE
85584: EQUAL
85585: IFTRUE 85589
85587: GO 85790
85589: POP
// case nation of nation_american :
85590: LD_VAR 0 5
85594: PUSH
85595: LD_INT 1
85597: DOUBLE
85598: EQUAL
85599: IFTRUE 85603
85601: GO 85659
85603: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85604: LD_ADDR_VAR 0 9
85608: PUSH
85609: LD_VAR 0 11
85613: PUSH
85614: LD_VAR 0 12
85618: PUSH
85619: LD_VAR 0 13
85623: PUSH
85624: LD_VAR 0 14
85628: PUSH
85629: LD_VAR 0 15
85633: PUSH
85634: LD_VAR 0 16
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: PUSH
85647: LD_VAR 0 4
85651: PUSH
85652: LD_INT 1
85654: PLUS
85655: ARRAY
85656: ST_TO_ADDR
85657: GO 85788
85659: LD_INT 2
85661: DOUBLE
85662: EQUAL
85663: IFTRUE 85667
85665: GO 85723
85667: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85668: LD_ADDR_VAR 0 9
85672: PUSH
85673: LD_VAR 0 17
85677: PUSH
85678: LD_VAR 0 18
85682: PUSH
85683: LD_VAR 0 19
85687: PUSH
85688: LD_VAR 0 20
85692: PUSH
85693: LD_VAR 0 21
85697: PUSH
85698: LD_VAR 0 22
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: PUSH
85711: LD_VAR 0 4
85715: PUSH
85716: LD_INT 1
85718: PLUS
85719: ARRAY
85720: ST_TO_ADDR
85721: GO 85788
85723: LD_INT 3
85725: DOUBLE
85726: EQUAL
85727: IFTRUE 85731
85729: GO 85787
85731: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85732: LD_ADDR_VAR 0 9
85736: PUSH
85737: LD_VAR 0 23
85741: PUSH
85742: LD_VAR 0 24
85746: PUSH
85747: LD_VAR 0 25
85751: PUSH
85752: LD_VAR 0 26
85756: PUSH
85757: LD_VAR 0 27
85761: PUSH
85762: LD_VAR 0 28
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: PUSH
85775: LD_VAR 0 4
85779: PUSH
85780: LD_INT 1
85782: PLUS
85783: ARRAY
85784: ST_TO_ADDR
85785: GO 85788
85787: POP
85788: GO 86343
85790: LD_INT 2
85792: DOUBLE
85793: EQUAL
85794: IFTRUE 85804
85796: LD_INT 3
85798: DOUBLE
85799: EQUAL
85800: IFTRUE 85804
85802: GO 85860
85804: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85805: LD_ADDR_VAR 0 9
85809: PUSH
85810: LD_VAR 0 29
85814: PUSH
85815: LD_VAR 0 30
85819: PUSH
85820: LD_VAR 0 31
85824: PUSH
85825: LD_VAR 0 32
85829: PUSH
85830: LD_VAR 0 33
85834: PUSH
85835: LD_VAR 0 34
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: PUSH
85848: LD_VAR 0 4
85852: PUSH
85853: LD_INT 1
85855: PLUS
85856: ARRAY
85857: ST_TO_ADDR
85858: GO 86343
85860: LD_INT 16
85862: DOUBLE
85863: EQUAL
85864: IFTRUE 85922
85866: LD_INT 17
85868: DOUBLE
85869: EQUAL
85870: IFTRUE 85922
85872: LD_INT 18
85874: DOUBLE
85875: EQUAL
85876: IFTRUE 85922
85878: LD_INT 19
85880: DOUBLE
85881: EQUAL
85882: IFTRUE 85922
85884: LD_INT 22
85886: DOUBLE
85887: EQUAL
85888: IFTRUE 85922
85890: LD_INT 20
85892: DOUBLE
85893: EQUAL
85894: IFTRUE 85922
85896: LD_INT 21
85898: DOUBLE
85899: EQUAL
85900: IFTRUE 85922
85902: LD_INT 23
85904: DOUBLE
85905: EQUAL
85906: IFTRUE 85922
85908: LD_INT 24
85910: DOUBLE
85911: EQUAL
85912: IFTRUE 85922
85914: LD_INT 25
85916: DOUBLE
85917: EQUAL
85918: IFTRUE 85922
85920: GO 85978
85922: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85923: LD_ADDR_VAR 0 9
85927: PUSH
85928: LD_VAR 0 35
85932: PUSH
85933: LD_VAR 0 36
85937: PUSH
85938: LD_VAR 0 37
85942: PUSH
85943: LD_VAR 0 38
85947: PUSH
85948: LD_VAR 0 39
85952: PUSH
85953: LD_VAR 0 40
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: PUSH
85966: LD_VAR 0 4
85970: PUSH
85971: LD_INT 1
85973: PLUS
85974: ARRAY
85975: ST_TO_ADDR
85976: GO 86343
85978: LD_INT 6
85980: DOUBLE
85981: EQUAL
85982: IFTRUE 86034
85984: LD_INT 7
85986: DOUBLE
85987: EQUAL
85988: IFTRUE 86034
85990: LD_INT 8
85992: DOUBLE
85993: EQUAL
85994: IFTRUE 86034
85996: LD_INT 13
85998: DOUBLE
85999: EQUAL
86000: IFTRUE 86034
86002: LD_INT 12
86004: DOUBLE
86005: EQUAL
86006: IFTRUE 86034
86008: LD_INT 15
86010: DOUBLE
86011: EQUAL
86012: IFTRUE 86034
86014: LD_INT 11
86016: DOUBLE
86017: EQUAL
86018: IFTRUE 86034
86020: LD_INT 14
86022: DOUBLE
86023: EQUAL
86024: IFTRUE 86034
86026: LD_INT 10
86028: DOUBLE
86029: EQUAL
86030: IFTRUE 86034
86032: GO 86090
86034: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
86035: LD_ADDR_VAR 0 9
86039: PUSH
86040: LD_VAR 0 41
86044: PUSH
86045: LD_VAR 0 42
86049: PUSH
86050: LD_VAR 0 43
86054: PUSH
86055: LD_VAR 0 44
86059: PUSH
86060: LD_VAR 0 45
86064: PUSH
86065: LD_VAR 0 46
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: PUSH
86078: LD_VAR 0 4
86082: PUSH
86083: LD_INT 1
86085: PLUS
86086: ARRAY
86087: ST_TO_ADDR
86088: GO 86343
86090: LD_INT 36
86092: DOUBLE
86093: EQUAL
86094: IFTRUE 86098
86096: GO 86154
86098: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
86099: LD_ADDR_VAR 0 9
86103: PUSH
86104: LD_VAR 0 47
86108: PUSH
86109: LD_VAR 0 48
86113: PUSH
86114: LD_VAR 0 49
86118: PUSH
86119: LD_VAR 0 50
86123: PUSH
86124: LD_VAR 0 51
86128: PUSH
86129: LD_VAR 0 52
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: PUSH
86142: LD_VAR 0 4
86146: PUSH
86147: LD_INT 1
86149: PLUS
86150: ARRAY
86151: ST_TO_ADDR
86152: GO 86343
86154: LD_INT 4
86156: DOUBLE
86157: EQUAL
86158: IFTRUE 86180
86160: LD_INT 5
86162: DOUBLE
86163: EQUAL
86164: IFTRUE 86180
86166: LD_INT 34
86168: DOUBLE
86169: EQUAL
86170: IFTRUE 86180
86172: LD_INT 37
86174: DOUBLE
86175: EQUAL
86176: IFTRUE 86180
86178: GO 86236
86180: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
86181: LD_ADDR_VAR 0 9
86185: PUSH
86186: LD_VAR 0 53
86190: PUSH
86191: LD_VAR 0 54
86195: PUSH
86196: LD_VAR 0 55
86200: PUSH
86201: LD_VAR 0 56
86205: PUSH
86206: LD_VAR 0 57
86210: PUSH
86211: LD_VAR 0 58
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: PUSH
86224: LD_VAR 0 4
86228: PUSH
86229: LD_INT 1
86231: PLUS
86232: ARRAY
86233: ST_TO_ADDR
86234: GO 86343
86236: LD_INT 31
86238: DOUBLE
86239: EQUAL
86240: IFTRUE 86286
86242: LD_INT 32
86244: DOUBLE
86245: EQUAL
86246: IFTRUE 86286
86248: LD_INT 33
86250: DOUBLE
86251: EQUAL
86252: IFTRUE 86286
86254: LD_INT 27
86256: DOUBLE
86257: EQUAL
86258: IFTRUE 86286
86260: LD_INT 26
86262: DOUBLE
86263: EQUAL
86264: IFTRUE 86286
86266: LD_INT 28
86268: DOUBLE
86269: EQUAL
86270: IFTRUE 86286
86272: LD_INT 29
86274: DOUBLE
86275: EQUAL
86276: IFTRUE 86286
86278: LD_INT 30
86280: DOUBLE
86281: EQUAL
86282: IFTRUE 86286
86284: GO 86342
86286: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
86287: LD_ADDR_VAR 0 9
86291: PUSH
86292: LD_VAR 0 59
86296: PUSH
86297: LD_VAR 0 60
86301: PUSH
86302: LD_VAR 0 61
86306: PUSH
86307: LD_VAR 0 62
86311: PUSH
86312: LD_VAR 0 63
86316: PUSH
86317: LD_VAR 0 64
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: PUSH
86330: LD_VAR 0 4
86334: PUSH
86335: LD_INT 1
86337: PLUS
86338: ARRAY
86339: ST_TO_ADDR
86340: GO 86343
86342: POP
// temp_list2 = [ ] ;
86343: LD_ADDR_VAR 0 10
86347: PUSH
86348: EMPTY
86349: ST_TO_ADDR
// for i in temp_list do
86350: LD_ADDR_VAR 0 8
86354: PUSH
86355: LD_VAR 0 9
86359: PUSH
86360: FOR_IN
86361: IFFALSE 86413
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86363: LD_ADDR_VAR 0 10
86367: PUSH
86368: LD_VAR 0 10
86372: PUSH
86373: LD_VAR 0 8
86377: PUSH
86378: LD_INT 1
86380: ARRAY
86381: PUSH
86382: LD_VAR 0 2
86386: PLUS
86387: PUSH
86388: LD_VAR 0 8
86392: PUSH
86393: LD_INT 2
86395: ARRAY
86396: PUSH
86397: LD_VAR 0 3
86401: PLUS
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: PUSH
86407: EMPTY
86408: LIST
86409: ADD
86410: ST_TO_ADDR
86411: GO 86360
86413: POP
86414: POP
// result = temp_list2 ;
86415: LD_ADDR_VAR 0 7
86419: PUSH
86420: LD_VAR 0 10
86424: ST_TO_ADDR
// end ;
86425: LD_VAR 0 7
86429: RET
// export function EnemyInRange ( unit , dist ) ; begin
86430: LD_INT 0
86432: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86433: LD_ADDR_VAR 0 3
86437: PUSH
86438: LD_VAR 0 1
86442: PPUSH
86443: CALL_OW 255
86447: PPUSH
86448: LD_VAR 0 1
86452: PPUSH
86453: CALL_OW 250
86457: PPUSH
86458: LD_VAR 0 1
86462: PPUSH
86463: CALL_OW 251
86467: PPUSH
86468: LD_VAR 0 2
86472: PPUSH
86473: CALL 59803 0 4
86477: PUSH
86478: LD_INT 4
86480: ARRAY
86481: ST_TO_ADDR
// end ;
86482: LD_VAR 0 3
86486: RET
// export function PlayerSeeMe ( unit ) ; begin
86487: LD_INT 0
86489: PPUSH
// result := See ( your_side , unit ) ;
86490: LD_ADDR_VAR 0 2
86494: PUSH
86495: LD_OWVAR 2
86499: PPUSH
86500: LD_VAR 0 1
86504: PPUSH
86505: CALL_OW 292
86509: ST_TO_ADDR
// end ;
86510: LD_VAR 0 2
86514: RET
// export function ReverseDir ( unit ) ; begin
86515: LD_INT 0
86517: PPUSH
// if not unit then
86518: LD_VAR 0 1
86522: NOT
86523: IFFALSE 86527
// exit ;
86525: GO 86550
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86527: LD_ADDR_VAR 0 2
86531: PUSH
86532: LD_VAR 0 1
86536: PPUSH
86537: CALL_OW 254
86541: PUSH
86542: LD_INT 3
86544: PLUS
86545: PUSH
86546: LD_INT 6
86548: MOD
86549: ST_TO_ADDR
// end ;
86550: LD_VAR 0 2
86554: RET
// export function ReverseArray ( array ) ; var i ; begin
86555: LD_INT 0
86557: PPUSH
86558: PPUSH
// if not array then
86559: LD_VAR 0 1
86563: NOT
86564: IFFALSE 86568
// exit ;
86566: GO 86623
// result := [ ] ;
86568: LD_ADDR_VAR 0 2
86572: PUSH
86573: EMPTY
86574: ST_TO_ADDR
// for i := array downto 1 do
86575: LD_ADDR_VAR 0 3
86579: PUSH
86580: DOUBLE
86581: LD_VAR 0 1
86585: INC
86586: ST_TO_ADDR
86587: LD_INT 1
86589: PUSH
86590: FOR_DOWNTO
86591: IFFALSE 86621
// result := Join ( result , array [ i ] ) ;
86593: LD_ADDR_VAR 0 2
86597: PUSH
86598: LD_VAR 0 2
86602: PPUSH
86603: LD_VAR 0 1
86607: PUSH
86608: LD_VAR 0 3
86612: ARRAY
86613: PPUSH
86614: CALL 91268 0 2
86618: ST_TO_ADDR
86619: GO 86590
86621: POP
86622: POP
// end ;
86623: LD_VAR 0 2
86627: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86628: LD_INT 0
86630: PPUSH
86631: PPUSH
86632: PPUSH
86633: PPUSH
86634: PPUSH
86635: PPUSH
// if not unit or not hexes then
86636: LD_VAR 0 1
86640: NOT
86641: PUSH
86642: LD_VAR 0 2
86646: NOT
86647: OR
86648: IFFALSE 86652
// exit ;
86650: GO 86775
// dist := 9999 ;
86652: LD_ADDR_VAR 0 5
86656: PUSH
86657: LD_INT 9999
86659: ST_TO_ADDR
// for i = 1 to hexes do
86660: LD_ADDR_VAR 0 4
86664: PUSH
86665: DOUBLE
86666: LD_INT 1
86668: DEC
86669: ST_TO_ADDR
86670: LD_VAR 0 2
86674: PUSH
86675: FOR_TO
86676: IFFALSE 86763
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86678: LD_ADDR_VAR 0 6
86682: PUSH
86683: LD_VAR 0 1
86687: PPUSH
86688: LD_VAR 0 2
86692: PUSH
86693: LD_VAR 0 4
86697: ARRAY
86698: PUSH
86699: LD_INT 1
86701: ARRAY
86702: PPUSH
86703: LD_VAR 0 2
86707: PUSH
86708: LD_VAR 0 4
86712: ARRAY
86713: PUSH
86714: LD_INT 2
86716: ARRAY
86717: PPUSH
86718: CALL_OW 297
86722: ST_TO_ADDR
// if tdist < dist then
86723: LD_VAR 0 6
86727: PUSH
86728: LD_VAR 0 5
86732: LESS
86733: IFFALSE 86761
// begin hex := hexes [ i ] ;
86735: LD_ADDR_VAR 0 8
86739: PUSH
86740: LD_VAR 0 2
86744: PUSH
86745: LD_VAR 0 4
86749: ARRAY
86750: ST_TO_ADDR
// dist := tdist ;
86751: LD_ADDR_VAR 0 5
86755: PUSH
86756: LD_VAR 0 6
86760: ST_TO_ADDR
// end ; end ;
86761: GO 86675
86763: POP
86764: POP
// result := hex ;
86765: LD_ADDR_VAR 0 3
86769: PUSH
86770: LD_VAR 0 8
86774: ST_TO_ADDR
// end ;
86775: LD_VAR 0 3
86779: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86780: LD_INT 0
86782: PPUSH
86783: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86784: LD_VAR 0 1
86788: NOT
86789: PUSH
86790: LD_VAR 0 1
86794: PUSH
86795: LD_INT 21
86797: PUSH
86798: LD_INT 2
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 23
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PPUSH
86819: CALL_OW 69
86823: IN
86824: NOT
86825: OR
86826: IFFALSE 86830
// exit ;
86828: GO 86877
// for i = 1 to 3 do
86830: LD_ADDR_VAR 0 3
86834: PUSH
86835: DOUBLE
86836: LD_INT 1
86838: DEC
86839: ST_TO_ADDR
86840: LD_INT 3
86842: PUSH
86843: FOR_TO
86844: IFFALSE 86875
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86846: LD_VAR 0 1
86850: PPUSH
86851: CALL_OW 250
86855: PPUSH
86856: LD_VAR 0 1
86860: PPUSH
86861: CALL_OW 251
86865: PPUSH
86866: LD_INT 1
86868: PPUSH
86869: CALL_OW 453
86873: GO 86843
86875: POP
86876: POP
// end ;
86877: LD_VAR 0 2
86881: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86882: LD_INT 0
86884: PPUSH
86885: PPUSH
86886: PPUSH
86887: PPUSH
86888: PPUSH
86889: PPUSH
// if not unit or not enemy_unit then
86890: LD_VAR 0 1
86894: NOT
86895: PUSH
86896: LD_VAR 0 2
86900: NOT
86901: OR
86902: IFFALSE 86906
// exit ;
86904: GO 87373
// if GetLives ( i ) < 250 then
86906: LD_VAR 0 4
86910: PPUSH
86911: CALL_OW 256
86915: PUSH
86916: LD_INT 250
86918: LESS
86919: IFFALSE 86932
// begin ComAutodestruct ( i ) ;
86921: LD_VAR 0 4
86925: PPUSH
86926: CALL 86780 0 1
// exit ;
86930: GO 87373
// end ; x := GetX ( enemy_unit ) ;
86932: LD_ADDR_VAR 0 7
86936: PUSH
86937: LD_VAR 0 2
86941: PPUSH
86942: CALL_OW 250
86946: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86947: LD_ADDR_VAR 0 8
86951: PUSH
86952: LD_VAR 0 2
86956: PPUSH
86957: CALL_OW 251
86961: ST_TO_ADDR
// if not x or not y then
86962: LD_VAR 0 7
86966: NOT
86967: PUSH
86968: LD_VAR 0 8
86972: NOT
86973: OR
86974: IFFALSE 86978
// exit ;
86976: GO 87373
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86978: LD_ADDR_VAR 0 6
86982: PUSH
86983: LD_VAR 0 7
86987: PPUSH
86988: LD_INT 0
86990: PPUSH
86991: LD_INT 4
86993: PPUSH
86994: CALL_OW 272
86998: PUSH
86999: LD_VAR 0 8
87003: PPUSH
87004: LD_INT 0
87006: PPUSH
87007: LD_INT 4
87009: PPUSH
87010: CALL_OW 273
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_VAR 0 7
87023: PPUSH
87024: LD_INT 1
87026: PPUSH
87027: LD_INT 4
87029: PPUSH
87030: CALL_OW 272
87034: PUSH
87035: LD_VAR 0 8
87039: PPUSH
87040: LD_INT 1
87042: PPUSH
87043: LD_INT 4
87045: PPUSH
87046: CALL_OW 273
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_VAR 0 7
87059: PPUSH
87060: LD_INT 2
87062: PPUSH
87063: LD_INT 4
87065: PPUSH
87066: CALL_OW 272
87070: PUSH
87071: LD_VAR 0 8
87075: PPUSH
87076: LD_INT 2
87078: PPUSH
87079: LD_INT 4
87081: PPUSH
87082: CALL_OW 273
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_VAR 0 7
87095: PPUSH
87096: LD_INT 3
87098: PPUSH
87099: LD_INT 4
87101: PPUSH
87102: CALL_OW 272
87106: PUSH
87107: LD_VAR 0 8
87111: PPUSH
87112: LD_INT 3
87114: PPUSH
87115: LD_INT 4
87117: PPUSH
87118: CALL_OW 273
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_VAR 0 7
87131: PPUSH
87132: LD_INT 4
87134: PPUSH
87135: LD_INT 4
87137: PPUSH
87138: CALL_OW 272
87142: PUSH
87143: LD_VAR 0 8
87147: PPUSH
87148: LD_INT 4
87150: PPUSH
87151: LD_INT 4
87153: PPUSH
87154: CALL_OW 273
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_VAR 0 7
87167: PPUSH
87168: LD_INT 5
87170: PPUSH
87171: LD_INT 4
87173: PPUSH
87174: CALL_OW 272
87178: PUSH
87179: LD_VAR 0 8
87183: PPUSH
87184: LD_INT 5
87186: PPUSH
87187: LD_INT 4
87189: PPUSH
87190: CALL_OW 273
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: ST_TO_ADDR
// for i = tmp downto 1 do
87207: LD_ADDR_VAR 0 4
87211: PUSH
87212: DOUBLE
87213: LD_VAR 0 6
87217: INC
87218: ST_TO_ADDR
87219: LD_INT 1
87221: PUSH
87222: FOR_DOWNTO
87223: IFFALSE 87324
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
87225: LD_VAR 0 6
87229: PUSH
87230: LD_VAR 0 4
87234: ARRAY
87235: PUSH
87236: LD_INT 1
87238: ARRAY
87239: PPUSH
87240: LD_VAR 0 6
87244: PUSH
87245: LD_VAR 0 4
87249: ARRAY
87250: PUSH
87251: LD_INT 2
87253: ARRAY
87254: PPUSH
87255: CALL_OW 488
87259: NOT
87260: PUSH
87261: LD_VAR 0 6
87265: PUSH
87266: LD_VAR 0 4
87270: ARRAY
87271: PUSH
87272: LD_INT 1
87274: ARRAY
87275: PPUSH
87276: LD_VAR 0 6
87280: PUSH
87281: LD_VAR 0 4
87285: ARRAY
87286: PUSH
87287: LD_INT 2
87289: ARRAY
87290: PPUSH
87291: CALL_OW 428
87295: PUSH
87296: LD_INT 0
87298: NONEQUAL
87299: OR
87300: IFFALSE 87322
// tmp := Delete ( tmp , i ) ;
87302: LD_ADDR_VAR 0 6
87306: PUSH
87307: LD_VAR 0 6
87311: PPUSH
87312: LD_VAR 0 4
87316: PPUSH
87317: CALL_OW 3
87321: ST_TO_ADDR
87322: GO 87222
87324: POP
87325: POP
// j := GetClosestHex ( unit , tmp ) ;
87326: LD_ADDR_VAR 0 5
87330: PUSH
87331: LD_VAR 0 1
87335: PPUSH
87336: LD_VAR 0 6
87340: PPUSH
87341: CALL 86628 0 2
87345: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87346: LD_VAR 0 1
87350: PPUSH
87351: LD_VAR 0 5
87355: PUSH
87356: LD_INT 1
87358: ARRAY
87359: PPUSH
87360: LD_VAR 0 5
87364: PUSH
87365: LD_INT 2
87367: ARRAY
87368: PPUSH
87369: CALL_OW 111
// end ;
87373: LD_VAR 0 3
87377: RET
// export function PrepareApemanSoldier ( ) ; begin
87378: LD_INT 0
87380: PPUSH
// uc_nation := 0 ;
87381: LD_ADDR_OWVAR 21
87385: PUSH
87386: LD_INT 0
87388: ST_TO_ADDR
// hc_sex := sex_male ;
87389: LD_ADDR_OWVAR 27
87393: PUSH
87394: LD_INT 1
87396: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87397: LD_ADDR_OWVAR 28
87401: PUSH
87402: LD_INT 15
87404: ST_TO_ADDR
// hc_gallery :=  ;
87405: LD_ADDR_OWVAR 33
87409: PUSH
87410: LD_STRING 
87412: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87413: LD_ADDR_OWVAR 31
87417: PUSH
87418: LD_INT 0
87420: PPUSH
87421: LD_INT 3
87423: PPUSH
87424: CALL_OW 12
87428: PUSH
87429: LD_INT 0
87431: PPUSH
87432: LD_INT 3
87434: PPUSH
87435: CALL_OW 12
87439: PUSH
87440: LD_INT 0
87442: PUSH
87443: LD_INT 0
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: ST_TO_ADDR
// end ;
87452: LD_VAR 0 1
87456: RET
// export function PrepareApemanEngineer ( ) ; begin
87457: LD_INT 0
87459: PPUSH
// uc_nation := 0 ;
87460: LD_ADDR_OWVAR 21
87464: PUSH
87465: LD_INT 0
87467: ST_TO_ADDR
// hc_sex := sex_male ;
87468: LD_ADDR_OWVAR 27
87472: PUSH
87473: LD_INT 1
87475: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87476: LD_ADDR_OWVAR 28
87480: PUSH
87481: LD_INT 16
87483: ST_TO_ADDR
// hc_gallery :=  ;
87484: LD_ADDR_OWVAR 33
87488: PUSH
87489: LD_STRING 
87491: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87492: LD_ADDR_OWVAR 31
87496: PUSH
87497: LD_INT 0
87499: PPUSH
87500: LD_INT 3
87502: PPUSH
87503: CALL_OW 12
87507: PUSH
87508: LD_INT 0
87510: PPUSH
87511: LD_INT 3
87513: PPUSH
87514: CALL_OW 12
87518: PUSH
87519: LD_INT 0
87521: PUSH
87522: LD_INT 0
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: ST_TO_ADDR
// end ;
87531: LD_VAR 0 1
87535: RET
// export function PrepareApeman ( agressivity ) ; begin
87536: LD_INT 0
87538: PPUSH
// uc_side := 0 ;
87539: LD_ADDR_OWVAR 20
87543: PUSH
87544: LD_INT 0
87546: ST_TO_ADDR
// uc_nation := 0 ;
87547: LD_ADDR_OWVAR 21
87551: PUSH
87552: LD_INT 0
87554: ST_TO_ADDR
// hc_sex := sex_male ;
87555: LD_ADDR_OWVAR 27
87559: PUSH
87560: LD_INT 1
87562: ST_TO_ADDR
// hc_class := class_apeman ;
87563: LD_ADDR_OWVAR 28
87567: PUSH
87568: LD_INT 12
87570: ST_TO_ADDR
// hc_gallery :=  ;
87571: LD_ADDR_OWVAR 33
87575: PUSH
87576: LD_STRING 
87578: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87579: LD_ADDR_OWVAR 35
87583: PUSH
87584: LD_VAR 0 1
87588: NEG
87589: PPUSH
87590: LD_VAR 0 1
87594: PPUSH
87595: CALL_OW 12
87599: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87600: LD_ADDR_OWVAR 31
87604: PUSH
87605: LD_INT 0
87607: PPUSH
87608: LD_INT 3
87610: PPUSH
87611: CALL_OW 12
87615: PUSH
87616: LD_INT 0
87618: PPUSH
87619: LD_INT 3
87621: PPUSH
87622: CALL_OW 12
87626: PUSH
87627: LD_INT 0
87629: PUSH
87630: LD_INT 0
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: ST_TO_ADDR
// end ;
87639: LD_VAR 0 2
87643: RET
// export function PrepareTiger ( agressivity ) ; begin
87644: LD_INT 0
87646: PPUSH
// uc_side := 0 ;
87647: LD_ADDR_OWVAR 20
87651: PUSH
87652: LD_INT 0
87654: ST_TO_ADDR
// uc_nation := 0 ;
87655: LD_ADDR_OWVAR 21
87659: PUSH
87660: LD_INT 0
87662: ST_TO_ADDR
// hc_class := class_tiger ;
87663: LD_ADDR_OWVAR 28
87667: PUSH
87668: LD_INT 14
87670: ST_TO_ADDR
// hc_gallery :=  ;
87671: LD_ADDR_OWVAR 33
87675: PUSH
87676: LD_STRING 
87678: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87679: LD_ADDR_OWVAR 35
87683: PUSH
87684: LD_VAR 0 1
87688: NEG
87689: PPUSH
87690: LD_VAR 0 1
87694: PPUSH
87695: CALL_OW 12
87699: ST_TO_ADDR
// end ;
87700: LD_VAR 0 2
87704: RET
// export function PrepareEnchidna ( ) ; begin
87705: LD_INT 0
87707: PPUSH
// uc_side := 0 ;
87708: LD_ADDR_OWVAR 20
87712: PUSH
87713: LD_INT 0
87715: ST_TO_ADDR
// uc_nation := 0 ;
87716: LD_ADDR_OWVAR 21
87720: PUSH
87721: LD_INT 0
87723: ST_TO_ADDR
// hc_class := class_baggie ;
87724: LD_ADDR_OWVAR 28
87728: PUSH
87729: LD_INT 13
87731: ST_TO_ADDR
// hc_gallery :=  ;
87732: LD_ADDR_OWVAR 33
87736: PUSH
87737: LD_STRING 
87739: ST_TO_ADDR
// end ;
87740: LD_VAR 0 1
87744: RET
// export function PrepareFrog ( ) ; begin
87745: LD_INT 0
87747: PPUSH
// uc_side := 0 ;
87748: LD_ADDR_OWVAR 20
87752: PUSH
87753: LD_INT 0
87755: ST_TO_ADDR
// uc_nation := 0 ;
87756: LD_ADDR_OWVAR 21
87760: PUSH
87761: LD_INT 0
87763: ST_TO_ADDR
// hc_class := class_frog ;
87764: LD_ADDR_OWVAR 28
87768: PUSH
87769: LD_INT 19
87771: ST_TO_ADDR
// hc_gallery :=  ;
87772: LD_ADDR_OWVAR 33
87776: PUSH
87777: LD_STRING 
87779: ST_TO_ADDR
// end ;
87780: LD_VAR 0 1
87784: RET
// export function PrepareFish ( ) ; begin
87785: LD_INT 0
87787: PPUSH
// uc_side := 0 ;
87788: LD_ADDR_OWVAR 20
87792: PUSH
87793: LD_INT 0
87795: ST_TO_ADDR
// uc_nation := 0 ;
87796: LD_ADDR_OWVAR 21
87800: PUSH
87801: LD_INT 0
87803: ST_TO_ADDR
// hc_class := class_fish ;
87804: LD_ADDR_OWVAR 28
87808: PUSH
87809: LD_INT 20
87811: ST_TO_ADDR
// hc_gallery :=  ;
87812: LD_ADDR_OWVAR 33
87816: PUSH
87817: LD_STRING 
87819: ST_TO_ADDR
// end ;
87820: LD_VAR 0 1
87824: RET
// export function PrepareBird ( ) ; begin
87825: LD_INT 0
87827: PPUSH
// uc_side := 0 ;
87828: LD_ADDR_OWVAR 20
87832: PUSH
87833: LD_INT 0
87835: ST_TO_ADDR
// uc_nation := 0 ;
87836: LD_ADDR_OWVAR 21
87840: PUSH
87841: LD_INT 0
87843: ST_TO_ADDR
// hc_class := class_phororhacos ;
87844: LD_ADDR_OWVAR 28
87848: PUSH
87849: LD_INT 18
87851: ST_TO_ADDR
// hc_gallery :=  ;
87852: LD_ADDR_OWVAR 33
87856: PUSH
87857: LD_STRING 
87859: ST_TO_ADDR
// end ;
87860: LD_VAR 0 1
87864: RET
// export function PrepareHorse ( ) ; begin
87865: LD_INT 0
87867: PPUSH
// uc_side := 0 ;
87868: LD_ADDR_OWVAR 20
87872: PUSH
87873: LD_INT 0
87875: ST_TO_ADDR
// uc_nation := 0 ;
87876: LD_ADDR_OWVAR 21
87880: PUSH
87881: LD_INT 0
87883: ST_TO_ADDR
// hc_class := class_horse ;
87884: LD_ADDR_OWVAR 28
87888: PUSH
87889: LD_INT 21
87891: ST_TO_ADDR
// hc_gallery :=  ;
87892: LD_ADDR_OWVAR 33
87896: PUSH
87897: LD_STRING 
87899: ST_TO_ADDR
// end ;
87900: LD_VAR 0 1
87904: RET
// export function PrepareMastodont ( ) ; begin
87905: LD_INT 0
87907: PPUSH
// uc_side := 0 ;
87908: LD_ADDR_OWVAR 20
87912: PUSH
87913: LD_INT 0
87915: ST_TO_ADDR
// uc_nation := 0 ;
87916: LD_ADDR_OWVAR 21
87920: PUSH
87921: LD_INT 0
87923: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87924: LD_ADDR_OWVAR 37
87928: PUSH
87929: LD_INT 31
87931: ST_TO_ADDR
// vc_control := control_rider ;
87932: LD_ADDR_OWVAR 38
87936: PUSH
87937: LD_INT 4
87939: ST_TO_ADDR
// end ;
87940: LD_VAR 0 1
87944: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87945: LD_INT 0
87947: PPUSH
87948: PPUSH
87949: PPUSH
// uc_side = 0 ;
87950: LD_ADDR_OWVAR 20
87954: PUSH
87955: LD_INT 0
87957: ST_TO_ADDR
// uc_nation = 0 ;
87958: LD_ADDR_OWVAR 21
87962: PUSH
87963: LD_INT 0
87965: ST_TO_ADDR
// InitHc_All ( ) ;
87966: CALL_OW 584
// InitVc ;
87970: CALL_OW 20
// if mastodonts then
87974: LD_VAR 0 6
87978: IFFALSE 88045
// for i = 1 to mastodonts do
87980: LD_ADDR_VAR 0 11
87984: PUSH
87985: DOUBLE
87986: LD_INT 1
87988: DEC
87989: ST_TO_ADDR
87990: LD_VAR 0 6
87994: PUSH
87995: FOR_TO
87996: IFFALSE 88043
// begin vc_chassis := 31 ;
87998: LD_ADDR_OWVAR 37
88002: PUSH
88003: LD_INT 31
88005: ST_TO_ADDR
// vc_control := control_rider ;
88006: LD_ADDR_OWVAR 38
88010: PUSH
88011: LD_INT 4
88013: ST_TO_ADDR
// animal := CreateVehicle ;
88014: LD_ADDR_VAR 0 12
88018: PUSH
88019: CALL_OW 45
88023: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88024: LD_VAR 0 12
88028: PPUSH
88029: LD_VAR 0 8
88033: PPUSH
88034: LD_INT 0
88036: PPUSH
88037: CALL 90173 0 3
// end ;
88041: GO 87995
88043: POP
88044: POP
// if horses then
88045: LD_VAR 0 5
88049: IFFALSE 88116
// for i = 1 to horses do
88051: LD_ADDR_VAR 0 11
88055: PUSH
88056: DOUBLE
88057: LD_INT 1
88059: DEC
88060: ST_TO_ADDR
88061: LD_VAR 0 5
88065: PUSH
88066: FOR_TO
88067: IFFALSE 88114
// begin hc_class := 21 ;
88069: LD_ADDR_OWVAR 28
88073: PUSH
88074: LD_INT 21
88076: ST_TO_ADDR
// hc_gallery :=  ;
88077: LD_ADDR_OWVAR 33
88081: PUSH
88082: LD_STRING 
88084: ST_TO_ADDR
// animal := CreateHuman ;
88085: LD_ADDR_VAR 0 12
88089: PUSH
88090: CALL_OW 44
88094: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88095: LD_VAR 0 12
88099: PPUSH
88100: LD_VAR 0 8
88104: PPUSH
88105: LD_INT 0
88107: PPUSH
88108: CALL 90173 0 3
// end ;
88112: GO 88066
88114: POP
88115: POP
// if birds then
88116: LD_VAR 0 1
88120: IFFALSE 88187
// for i = 1 to birds do
88122: LD_ADDR_VAR 0 11
88126: PUSH
88127: DOUBLE
88128: LD_INT 1
88130: DEC
88131: ST_TO_ADDR
88132: LD_VAR 0 1
88136: PUSH
88137: FOR_TO
88138: IFFALSE 88185
// begin hc_class := 18 ;
88140: LD_ADDR_OWVAR 28
88144: PUSH
88145: LD_INT 18
88147: ST_TO_ADDR
// hc_gallery =  ;
88148: LD_ADDR_OWVAR 33
88152: PUSH
88153: LD_STRING 
88155: ST_TO_ADDR
// animal := CreateHuman ;
88156: LD_ADDR_VAR 0 12
88160: PUSH
88161: CALL_OW 44
88165: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88166: LD_VAR 0 12
88170: PPUSH
88171: LD_VAR 0 8
88175: PPUSH
88176: LD_INT 0
88178: PPUSH
88179: CALL 90173 0 3
// end ;
88183: GO 88137
88185: POP
88186: POP
// if tigers then
88187: LD_VAR 0 2
88191: IFFALSE 88275
// for i = 1 to tigers do
88193: LD_ADDR_VAR 0 11
88197: PUSH
88198: DOUBLE
88199: LD_INT 1
88201: DEC
88202: ST_TO_ADDR
88203: LD_VAR 0 2
88207: PUSH
88208: FOR_TO
88209: IFFALSE 88273
// begin hc_class = class_tiger ;
88211: LD_ADDR_OWVAR 28
88215: PUSH
88216: LD_INT 14
88218: ST_TO_ADDR
// hc_gallery =  ;
88219: LD_ADDR_OWVAR 33
88223: PUSH
88224: LD_STRING 
88226: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
88227: LD_ADDR_OWVAR 35
88231: PUSH
88232: LD_INT 7
88234: NEG
88235: PPUSH
88236: LD_INT 7
88238: PPUSH
88239: CALL_OW 12
88243: ST_TO_ADDR
// animal := CreateHuman ;
88244: LD_ADDR_VAR 0 12
88248: PUSH
88249: CALL_OW 44
88253: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88254: LD_VAR 0 12
88258: PPUSH
88259: LD_VAR 0 8
88263: PPUSH
88264: LD_INT 0
88266: PPUSH
88267: CALL 90173 0 3
// end ;
88271: GO 88208
88273: POP
88274: POP
// if apemans then
88275: LD_VAR 0 3
88279: IFFALSE 88402
// for i = 1 to apemans do
88281: LD_ADDR_VAR 0 11
88285: PUSH
88286: DOUBLE
88287: LD_INT 1
88289: DEC
88290: ST_TO_ADDR
88291: LD_VAR 0 3
88295: PUSH
88296: FOR_TO
88297: IFFALSE 88400
// begin hc_class = class_apeman ;
88299: LD_ADDR_OWVAR 28
88303: PUSH
88304: LD_INT 12
88306: ST_TO_ADDR
// hc_gallery =  ;
88307: LD_ADDR_OWVAR 33
88311: PUSH
88312: LD_STRING 
88314: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88315: LD_ADDR_OWVAR 35
88319: PUSH
88320: LD_INT 2
88322: NEG
88323: PPUSH
88324: LD_INT 2
88326: PPUSH
88327: CALL_OW 12
88331: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88332: LD_ADDR_OWVAR 31
88336: PUSH
88337: LD_INT 1
88339: PPUSH
88340: LD_INT 3
88342: PPUSH
88343: CALL_OW 12
88347: PUSH
88348: LD_INT 1
88350: PPUSH
88351: LD_INT 3
88353: PPUSH
88354: CALL_OW 12
88358: PUSH
88359: LD_INT 0
88361: PUSH
88362: LD_INT 0
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: ST_TO_ADDR
// animal := CreateHuman ;
88371: LD_ADDR_VAR 0 12
88375: PUSH
88376: CALL_OW 44
88380: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88381: LD_VAR 0 12
88385: PPUSH
88386: LD_VAR 0 8
88390: PPUSH
88391: LD_INT 0
88393: PPUSH
88394: CALL 90173 0 3
// end ;
88398: GO 88296
88400: POP
88401: POP
// if enchidnas then
88402: LD_VAR 0 4
88406: IFFALSE 88473
// for i = 1 to enchidnas do
88408: LD_ADDR_VAR 0 11
88412: PUSH
88413: DOUBLE
88414: LD_INT 1
88416: DEC
88417: ST_TO_ADDR
88418: LD_VAR 0 4
88422: PUSH
88423: FOR_TO
88424: IFFALSE 88471
// begin hc_class = 13 ;
88426: LD_ADDR_OWVAR 28
88430: PUSH
88431: LD_INT 13
88433: ST_TO_ADDR
// hc_gallery =  ;
88434: LD_ADDR_OWVAR 33
88438: PUSH
88439: LD_STRING 
88441: ST_TO_ADDR
// animal := CreateHuman ;
88442: LD_ADDR_VAR 0 12
88446: PUSH
88447: CALL_OW 44
88451: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88452: LD_VAR 0 12
88456: PPUSH
88457: LD_VAR 0 8
88461: PPUSH
88462: LD_INT 0
88464: PPUSH
88465: CALL 90173 0 3
// end ;
88469: GO 88423
88471: POP
88472: POP
// if fishes then
88473: LD_VAR 0 7
88477: IFFALSE 88544
// for i = 1 to fishes do
88479: LD_ADDR_VAR 0 11
88483: PUSH
88484: DOUBLE
88485: LD_INT 1
88487: DEC
88488: ST_TO_ADDR
88489: LD_VAR 0 7
88493: PUSH
88494: FOR_TO
88495: IFFALSE 88542
// begin hc_class = 20 ;
88497: LD_ADDR_OWVAR 28
88501: PUSH
88502: LD_INT 20
88504: ST_TO_ADDR
// hc_gallery =  ;
88505: LD_ADDR_OWVAR 33
88509: PUSH
88510: LD_STRING 
88512: ST_TO_ADDR
// animal := CreateHuman ;
88513: LD_ADDR_VAR 0 12
88517: PUSH
88518: CALL_OW 44
88522: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88523: LD_VAR 0 12
88527: PPUSH
88528: LD_VAR 0 9
88532: PPUSH
88533: LD_INT 0
88535: PPUSH
88536: CALL 90173 0 3
// end ;
88540: GO 88494
88542: POP
88543: POP
// end ;
88544: LD_VAR 0 10
88548: RET
// export function WantHeal ( sci , unit ) ; begin
88549: LD_INT 0
88551: PPUSH
// if GetTaskList ( sci ) > 0 then
88552: LD_VAR 0 1
88556: PPUSH
88557: CALL_OW 437
88561: PUSH
88562: LD_INT 0
88564: GREATER
88565: IFFALSE 88635
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88567: LD_VAR 0 1
88571: PPUSH
88572: CALL_OW 437
88576: PUSH
88577: LD_INT 1
88579: ARRAY
88580: PUSH
88581: LD_INT 1
88583: ARRAY
88584: PUSH
88585: LD_STRING l
88587: EQUAL
88588: PUSH
88589: LD_VAR 0 1
88593: PPUSH
88594: CALL_OW 437
88598: PUSH
88599: LD_INT 1
88601: ARRAY
88602: PUSH
88603: LD_INT 4
88605: ARRAY
88606: PUSH
88607: LD_VAR 0 2
88611: EQUAL
88612: AND
88613: IFFALSE 88625
// result := true else
88615: LD_ADDR_VAR 0 3
88619: PUSH
88620: LD_INT 1
88622: ST_TO_ADDR
88623: GO 88633
// result := false ;
88625: LD_ADDR_VAR 0 3
88629: PUSH
88630: LD_INT 0
88632: ST_TO_ADDR
// end else
88633: GO 88643
// result := false ;
88635: LD_ADDR_VAR 0 3
88639: PUSH
88640: LD_INT 0
88642: ST_TO_ADDR
// end ;
88643: LD_VAR 0 3
88647: RET
// export function HealTarget ( sci ) ; begin
88648: LD_INT 0
88650: PPUSH
// if not sci then
88651: LD_VAR 0 1
88655: NOT
88656: IFFALSE 88660
// exit ;
88658: GO 88725
// result := 0 ;
88660: LD_ADDR_VAR 0 2
88664: PUSH
88665: LD_INT 0
88667: ST_TO_ADDR
// if GetTaskList ( sci ) then
88668: LD_VAR 0 1
88672: PPUSH
88673: CALL_OW 437
88677: IFFALSE 88725
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88679: LD_VAR 0 1
88683: PPUSH
88684: CALL_OW 437
88688: PUSH
88689: LD_INT 1
88691: ARRAY
88692: PUSH
88693: LD_INT 1
88695: ARRAY
88696: PUSH
88697: LD_STRING l
88699: EQUAL
88700: IFFALSE 88725
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88702: LD_ADDR_VAR 0 2
88706: PUSH
88707: LD_VAR 0 1
88711: PPUSH
88712: CALL_OW 437
88716: PUSH
88717: LD_INT 1
88719: ARRAY
88720: PUSH
88721: LD_INT 4
88723: ARRAY
88724: ST_TO_ADDR
// end ;
88725: LD_VAR 0 2
88729: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88730: LD_INT 0
88732: PPUSH
88733: PPUSH
88734: PPUSH
88735: PPUSH
// if not base_units then
88736: LD_VAR 0 1
88740: NOT
88741: IFFALSE 88745
// exit ;
88743: GO 88832
// result := false ;
88745: LD_ADDR_VAR 0 2
88749: PUSH
88750: LD_INT 0
88752: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88753: LD_ADDR_VAR 0 5
88757: PUSH
88758: LD_VAR 0 1
88762: PPUSH
88763: LD_INT 21
88765: PUSH
88766: LD_INT 3
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PPUSH
88773: CALL_OW 72
88777: ST_TO_ADDR
// if not tmp then
88778: LD_VAR 0 5
88782: NOT
88783: IFFALSE 88787
// exit ;
88785: GO 88832
// for i in tmp do
88787: LD_ADDR_VAR 0 3
88791: PUSH
88792: LD_VAR 0 5
88796: PUSH
88797: FOR_IN
88798: IFFALSE 88830
// begin result := EnemyInRange ( i , 22 ) ;
88800: LD_ADDR_VAR 0 2
88804: PUSH
88805: LD_VAR 0 3
88809: PPUSH
88810: LD_INT 22
88812: PPUSH
88813: CALL 86430 0 2
88817: ST_TO_ADDR
// if result then
88818: LD_VAR 0 2
88822: IFFALSE 88828
// exit ;
88824: POP
88825: POP
88826: GO 88832
// end ;
88828: GO 88797
88830: POP
88831: POP
// end ;
88832: LD_VAR 0 2
88836: RET
// export function FilterByTag ( units , tag ) ; begin
88837: LD_INT 0
88839: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88840: LD_ADDR_VAR 0 3
88844: PUSH
88845: LD_VAR 0 1
88849: PPUSH
88850: LD_INT 120
88852: PUSH
88853: LD_VAR 0 2
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: PPUSH
88862: CALL_OW 72
88866: ST_TO_ADDR
// end ;
88867: LD_VAR 0 3
88871: RET
// export function IsDriver ( un ) ; begin
88872: LD_INT 0
88874: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88875: LD_ADDR_VAR 0 2
88879: PUSH
88880: LD_VAR 0 1
88884: PUSH
88885: LD_INT 55
88887: PUSH
88888: EMPTY
88889: LIST
88890: PPUSH
88891: CALL_OW 69
88895: IN
88896: ST_TO_ADDR
// end ;
88897: LD_VAR 0 2
88901: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88902: LD_INT 0
88904: PPUSH
88905: PPUSH
// list := [ ] ;
88906: LD_ADDR_VAR 0 5
88910: PUSH
88911: EMPTY
88912: ST_TO_ADDR
// case d of 0 :
88913: LD_VAR 0 3
88917: PUSH
88918: LD_INT 0
88920: DOUBLE
88921: EQUAL
88922: IFTRUE 88926
88924: GO 89059
88926: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88927: LD_ADDR_VAR 0 5
88931: PUSH
88932: LD_VAR 0 1
88936: PUSH
88937: LD_INT 4
88939: MINUS
88940: PUSH
88941: LD_VAR 0 2
88945: PUSH
88946: LD_INT 4
88948: MINUS
88949: PUSH
88950: LD_INT 2
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: LIST
88957: PUSH
88958: LD_VAR 0 1
88962: PUSH
88963: LD_INT 3
88965: MINUS
88966: PUSH
88967: LD_VAR 0 2
88971: PUSH
88972: LD_INT 1
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: LIST
88979: PUSH
88980: LD_VAR 0 1
88984: PUSH
88985: LD_INT 4
88987: PLUS
88988: PUSH
88989: LD_VAR 0 2
88993: PUSH
88994: LD_INT 4
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: LIST
89001: PUSH
89002: LD_VAR 0 1
89006: PUSH
89007: LD_INT 3
89009: PLUS
89010: PUSH
89011: LD_VAR 0 2
89015: PUSH
89016: LD_INT 3
89018: PLUS
89019: PUSH
89020: LD_INT 5
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: LIST
89027: PUSH
89028: LD_VAR 0 1
89032: PUSH
89033: LD_VAR 0 2
89037: PUSH
89038: LD_INT 4
89040: PLUS
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: LIST
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: ST_TO_ADDR
// end ; 1 :
89057: GO 89757
89059: LD_INT 1
89061: DOUBLE
89062: EQUAL
89063: IFTRUE 89067
89065: GO 89200
89067: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
89068: LD_ADDR_VAR 0 5
89072: PUSH
89073: LD_VAR 0 1
89077: PUSH
89078: LD_VAR 0 2
89082: PUSH
89083: LD_INT 4
89085: MINUS
89086: PUSH
89087: LD_INT 3
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: LIST
89094: PUSH
89095: LD_VAR 0 1
89099: PUSH
89100: LD_INT 3
89102: MINUS
89103: PUSH
89104: LD_VAR 0 2
89108: PUSH
89109: LD_INT 3
89111: MINUS
89112: PUSH
89113: LD_INT 2
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: LIST
89120: PUSH
89121: LD_VAR 0 1
89125: PUSH
89126: LD_INT 4
89128: MINUS
89129: PUSH
89130: LD_VAR 0 2
89134: PUSH
89135: LD_INT 1
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: LIST
89142: PUSH
89143: LD_VAR 0 1
89147: PUSH
89148: LD_VAR 0 2
89152: PUSH
89153: LD_INT 3
89155: PLUS
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: LIST
89164: PUSH
89165: LD_VAR 0 1
89169: PUSH
89170: LD_INT 4
89172: PLUS
89173: PUSH
89174: LD_VAR 0 2
89178: PUSH
89179: LD_INT 4
89181: PLUS
89182: PUSH
89183: LD_INT 5
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: LIST
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: ST_TO_ADDR
// end ; 2 :
89198: GO 89757
89200: LD_INT 2
89202: DOUBLE
89203: EQUAL
89204: IFTRUE 89208
89206: GO 89337
89208: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89209: LD_ADDR_VAR 0 5
89213: PUSH
89214: LD_VAR 0 1
89218: PUSH
89219: LD_VAR 0 2
89223: PUSH
89224: LD_INT 3
89226: MINUS
89227: PUSH
89228: LD_INT 3
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: LIST
89235: PUSH
89236: LD_VAR 0 1
89240: PUSH
89241: LD_INT 4
89243: PLUS
89244: PUSH
89245: LD_VAR 0 2
89249: PUSH
89250: LD_INT 4
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: LIST
89257: PUSH
89258: LD_VAR 0 1
89262: PUSH
89263: LD_VAR 0 2
89267: PUSH
89268: LD_INT 4
89270: PLUS
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: LIST
89279: PUSH
89280: LD_VAR 0 1
89284: PUSH
89285: LD_INT 3
89287: MINUS
89288: PUSH
89289: LD_VAR 0 2
89293: PUSH
89294: LD_INT 1
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: LIST
89301: PUSH
89302: LD_VAR 0 1
89306: PUSH
89307: LD_INT 4
89309: MINUS
89310: PUSH
89311: LD_VAR 0 2
89315: PUSH
89316: LD_INT 4
89318: MINUS
89319: PUSH
89320: LD_INT 2
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: LIST
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: ST_TO_ADDR
// end ; 3 :
89335: GO 89757
89337: LD_INT 3
89339: DOUBLE
89340: EQUAL
89341: IFTRUE 89345
89343: GO 89478
89345: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89346: LD_ADDR_VAR 0 5
89350: PUSH
89351: LD_VAR 0 1
89355: PUSH
89356: LD_INT 3
89358: PLUS
89359: PUSH
89360: LD_VAR 0 2
89364: PUSH
89365: LD_INT 4
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: LIST
89372: PUSH
89373: LD_VAR 0 1
89377: PUSH
89378: LD_INT 4
89380: PLUS
89381: PUSH
89382: LD_VAR 0 2
89386: PUSH
89387: LD_INT 4
89389: PLUS
89390: PUSH
89391: LD_INT 5
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: LIST
89398: PUSH
89399: LD_VAR 0 1
89403: PUSH
89404: LD_INT 4
89406: MINUS
89407: PUSH
89408: LD_VAR 0 2
89412: PUSH
89413: LD_INT 1
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: LIST
89420: PUSH
89421: LD_VAR 0 1
89425: PUSH
89426: LD_VAR 0 2
89430: PUSH
89431: LD_INT 4
89433: MINUS
89434: PUSH
89435: LD_INT 3
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: LIST
89442: PUSH
89443: LD_VAR 0 1
89447: PUSH
89448: LD_INT 3
89450: MINUS
89451: PUSH
89452: LD_VAR 0 2
89456: PUSH
89457: LD_INT 3
89459: MINUS
89460: PUSH
89461: LD_INT 2
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: LIST
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: ST_TO_ADDR
// end ; 4 :
89476: GO 89757
89478: LD_INT 4
89480: DOUBLE
89481: EQUAL
89482: IFTRUE 89486
89484: GO 89619
89486: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89487: LD_ADDR_VAR 0 5
89491: PUSH
89492: LD_VAR 0 1
89496: PUSH
89497: LD_VAR 0 2
89501: PUSH
89502: LD_INT 4
89504: PLUS
89505: PUSH
89506: LD_INT 0
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: LIST
89513: PUSH
89514: LD_VAR 0 1
89518: PUSH
89519: LD_INT 3
89521: PLUS
89522: PUSH
89523: LD_VAR 0 2
89527: PUSH
89528: LD_INT 3
89530: PLUS
89531: PUSH
89532: LD_INT 5
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: LIST
89539: PUSH
89540: LD_VAR 0 1
89544: PUSH
89545: LD_INT 4
89547: PLUS
89548: PUSH
89549: LD_VAR 0 2
89553: PUSH
89554: LD_INT 4
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: LIST
89561: PUSH
89562: LD_VAR 0 1
89566: PUSH
89567: LD_VAR 0 2
89571: PUSH
89572: LD_INT 3
89574: MINUS
89575: PUSH
89576: LD_INT 3
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: LIST
89583: PUSH
89584: LD_VAR 0 1
89588: PUSH
89589: LD_INT 4
89591: MINUS
89592: PUSH
89593: LD_VAR 0 2
89597: PUSH
89598: LD_INT 4
89600: MINUS
89601: PUSH
89602: LD_INT 2
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: LIST
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: ST_TO_ADDR
// end ; 5 :
89617: GO 89757
89619: LD_INT 5
89621: DOUBLE
89622: EQUAL
89623: IFTRUE 89627
89625: GO 89756
89627: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89628: LD_ADDR_VAR 0 5
89632: PUSH
89633: LD_VAR 0 1
89637: PUSH
89638: LD_INT 4
89640: MINUS
89641: PUSH
89642: LD_VAR 0 2
89646: PUSH
89647: LD_INT 1
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: LIST
89654: PUSH
89655: LD_VAR 0 1
89659: PUSH
89660: LD_VAR 0 2
89664: PUSH
89665: LD_INT 4
89667: MINUS
89668: PUSH
89669: LD_INT 3
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: LIST
89676: PUSH
89677: LD_VAR 0 1
89681: PUSH
89682: LD_INT 4
89684: PLUS
89685: PUSH
89686: LD_VAR 0 2
89690: PUSH
89691: LD_INT 4
89693: PLUS
89694: PUSH
89695: LD_INT 5
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: LIST
89702: PUSH
89703: LD_VAR 0 1
89707: PUSH
89708: LD_INT 3
89710: PLUS
89711: PUSH
89712: LD_VAR 0 2
89716: PUSH
89717: LD_INT 4
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: LIST
89724: PUSH
89725: LD_VAR 0 1
89729: PUSH
89730: LD_VAR 0 2
89734: PUSH
89735: LD_INT 3
89737: PLUS
89738: PUSH
89739: LD_INT 0
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: LIST
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: ST_TO_ADDR
// end ; end ;
89754: GO 89757
89756: POP
// result := list ;
89757: LD_ADDR_VAR 0 4
89761: PUSH
89762: LD_VAR 0 5
89766: ST_TO_ADDR
// end ;
89767: LD_VAR 0 4
89771: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89772: LD_INT 0
89774: PPUSH
89775: PPUSH
89776: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89777: LD_VAR 0 1
89781: NOT
89782: PUSH
89783: LD_VAR 0 2
89787: PUSH
89788: LD_INT 1
89790: PUSH
89791: LD_INT 2
89793: PUSH
89794: LD_INT 3
89796: PUSH
89797: LD_INT 4
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: IN
89806: NOT
89807: OR
89808: IFFALSE 89812
// exit ;
89810: GO 89895
// tmp := [ ] ;
89812: LD_ADDR_VAR 0 5
89816: PUSH
89817: EMPTY
89818: ST_TO_ADDR
// for i in units do
89819: LD_ADDR_VAR 0 4
89823: PUSH
89824: LD_VAR 0 1
89828: PUSH
89829: FOR_IN
89830: IFFALSE 89864
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89832: LD_ADDR_VAR 0 5
89836: PUSH
89837: LD_VAR 0 5
89841: PPUSH
89842: LD_VAR 0 4
89846: PPUSH
89847: LD_VAR 0 2
89851: PPUSH
89852: CALL_OW 259
89856: PPUSH
89857: CALL 91268 0 2
89861: ST_TO_ADDR
89862: GO 89829
89864: POP
89865: POP
// if not tmp then
89866: LD_VAR 0 5
89870: NOT
89871: IFFALSE 89875
// exit ;
89873: GO 89895
// result := SortListByListDesc ( units , tmp ) ;
89875: LD_ADDR_VAR 0 3
89879: PUSH
89880: LD_VAR 0 1
89884: PPUSH
89885: LD_VAR 0 5
89889: PPUSH
89890: CALL_OW 77
89894: ST_TO_ADDR
// end ;
89895: LD_VAR 0 3
89899: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89900: LD_INT 0
89902: PPUSH
89903: PPUSH
89904: PPUSH
// result := false ;
89905: LD_ADDR_VAR 0 3
89909: PUSH
89910: LD_INT 0
89912: ST_TO_ADDR
// if not building then
89913: LD_VAR 0 2
89917: NOT
89918: IFFALSE 89922
// exit ;
89920: GO 90060
// x := GetX ( building ) ;
89922: LD_ADDR_VAR 0 4
89926: PUSH
89927: LD_VAR 0 2
89931: PPUSH
89932: CALL_OW 250
89936: ST_TO_ADDR
// y := GetY ( building ) ;
89937: LD_ADDR_VAR 0 5
89941: PUSH
89942: LD_VAR 0 2
89946: PPUSH
89947: CALL_OW 251
89951: ST_TO_ADDR
// if not x or not y then
89952: LD_VAR 0 4
89956: NOT
89957: PUSH
89958: LD_VAR 0 5
89962: NOT
89963: OR
89964: IFFALSE 89968
// exit ;
89966: GO 90060
// if GetTaskList ( unit ) then
89968: LD_VAR 0 1
89972: PPUSH
89973: CALL_OW 437
89977: IFFALSE 90060
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89979: LD_STRING e
89981: PUSH
89982: LD_VAR 0 1
89986: PPUSH
89987: CALL_OW 437
89991: PUSH
89992: LD_INT 1
89994: ARRAY
89995: PUSH
89996: LD_INT 1
89998: ARRAY
89999: EQUAL
90000: PUSH
90001: LD_VAR 0 4
90005: PUSH
90006: LD_VAR 0 1
90010: PPUSH
90011: CALL_OW 437
90015: PUSH
90016: LD_INT 1
90018: ARRAY
90019: PUSH
90020: LD_INT 2
90022: ARRAY
90023: EQUAL
90024: AND
90025: PUSH
90026: LD_VAR 0 5
90030: PUSH
90031: LD_VAR 0 1
90035: PPUSH
90036: CALL_OW 437
90040: PUSH
90041: LD_INT 1
90043: ARRAY
90044: PUSH
90045: LD_INT 3
90047: ARRAY
90048: EQUAL
90049: AND
90050: IFFALSE 90060
// result := true end ;
90052: LD_ADDR_VAR 0 3
90056: PUSH
90057: LD_INT 1
90059: ST_TO_ADDR
// end ;
90060: LD_VAR 0 3
90064: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
90065: LD_INT 0
90067: PPUSH
// result := false ;
90068: LD_ADDR_VAR 0 4
90072: PUSH
90073: LD_INT 0
90075: ST_TO_ADDR
// if GetTaskList ( unit ) then
90076: LD_VAR 0 1
90080: PPUSH
90081: CALL_OW 437
90085: IFFALSE 90168
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90087: LD_STRING M
90089: PUSH
90090: LD_VAR 0 1
90094: PPUSH
90095: CALL_OW 437
90099: PUSH
90100: LD_INT 1
90102: ARRAY
90103: PUSH
90104: LD_INT 1
90106: ARRAY
90107: EQUAL
90108: PUSH
90109: LD_VAR 0 2
90113: PUSH
90114: LD_VAR 0 1
90118: PPUSH
90119: CALL_OW 437
90123: PUSH
90124: LD_INT 1
90126: ARRAY
90127: PUSH
90128: LD_INT 2
90130: ARRAY
90131: EQUAL
90132: AND
90133: PUSH
90134: LD_VAR 0 3
90138: PUSH
90139: LD_VAR 0 1
90143: PPUSH
90144: CALL_OW 437
90148: PUSH
90149: LD_INT 1
90151: ARRAY
90152: PUSH
90153: LD_INT 3
90155: ARRAY
90156: EQUAL
90157: AND
90158: IFFALSE 90168
// result := true ;
90160: LD_ADDR_VAR 0 4
90164: PUSH
90165: LD_INT 1
90167: ST_TO_ADDR
// end ; end ;
90168: LD_VAR 0 4
90172: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90173: LD_INT 0
90175: PPUSH
90176: PPUSH
90177: PPUSH
90178: PPUSH
// if not unit or not area then
90179: LD_VAR 0 1
90183: NOT
90184: PUSH
90185: LD_VAR 0 2
90189: NOT
90190: OR
90191: IFFALSE 90195
// exit ;
90193: GO 90371
// tmp := AreaToList ( area , i ) ;
90195: LD_ADDR_VAR 0 6
90199: PUSH
90200: LD_VAR 0 2
90204: PPUSH
90205: LD_VAR 0 5
90209: PPUSH
90210: CALL_OW 517
90214: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90215: LD_ADDR_VAR 0 5
90219: PUSH
90220: DOUBLE
90221: LD_INT 1
90223: DEC
90224: ST_TO_ADDR
90225: LD_VAR 0 6
90229: PUSH
90230: LD_INT 1
90232: ARRAY
90233: PUSH
90234: FOR_TO
90235: IFFALSE 90369
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90237: LD_ADDR_VAR 0 7
90241: PUSH
90242: LD_VAR 0 6
90246: PUSH
90247: LD_INT 1
90249: ARRAY
90250: PUSH
90251: LD_VAR 0 5
90255: ARRAY
90256: PUSH
90257: LD_VAR 0 6
90261: PUSH
90262: LD_INT 2
90264: ARRAY
90265: PUSH
90266: LD_VAR 0 5
90270: ARRAY
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
90276: LD_INT 92
90278: PUSH
90279: LD_VAR 0 7
90283: PUSH
90284: LD_INT 1
90286: ARRAY
90287: PUSH
90288: LD_VAR 0 7
90292: PUSH
90293: LD_INT 2
90295: ARRAY
90296: PUSH
90297: LD_INT 2
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: PPUSH
90306: CALL_OW 69
90310: PUSH
90311: LD_INT 0
90313: EQUAL
90314: IFFALSE 90367
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90316: LD_VAR 0 1
90320: PPUSH
90321: LD_VAR 0 7
90325: PUSH
90326: LD_INT 1
90328: ARRAY
90329: PPUSH
90330: LD_VAR 0 7
90334: PUSH
90335: LD_INT 2
90337: ARRAY
90338: PPUSH
90339: LD_VAR 0 3
90343: PPUSH
90344: CALL_OW 48
// result := IsPlaced ( unit ) ;
90348: LD_ADDR_VAR 0 4
90352: PUSH
90353: LD_VAR 0 1
90357: PPUSH
90358: CALL_OW 305
90362: ST_TO_ADDR
// exit ;
90363: POP
90364: POP
90365: GO 90371
// end ; end ;
90367: GO 90234
90369: POP
90370: POP
// end ;
90371: LD_VAR 0 4
90375: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90376: LD_INT 0
90378: PPUSH
90379: PPUSH
90380: PPUSH
// if not side or side > 8 then
90381: LD_VAR 0 1
90385: NOT
90386: PUSH
90387: LD_VAR 0 1
90391: PUSH
90392: LD_INT 8
90394: GREATER
90395: OR
90396: IFFALSE 90400
// exit ;
90398: GO 90587
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90400: LD_ADDR_VAR 0 4
90404: PUSH
90405: LD_INT 22
90407: PUSH
90408: LD_VAR 0 1
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 21
90419: PUSH
90420: LD_INT 3
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PPUSH
90431: CALL_OW 69
90435: ST_TO_ADDR
// if not tmp then
90436: LD_VAR 0 4
90440: NOT
90441: IFFALSE 90445
// exit ;
90443: GO 90587
// enable_addtolog := true ;
90445: LD_ADDR_OWVAR 81
90449: PUSH
90450: LD_INT 1
90452: ST_TO_ADDR
// AddToLog ( [ ) ;
90453: LD_STRING [
90455: PPUSH
90456: CALL_OW 561
// for i in tmp do
90460: LD_ADDR_VAR 0 3
90464: PUSH
90465: LD_VAR 0 4
90469: PUSH
90470: FOR_IN
90471: IFFALSE 90578
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90473: LD_STRING [
90475: PUSH
90476: LD_VAR 0 3
90480: PPUSH
90481: CALL_OW 266
90485: STR
90486: PUSH
90487: LD_STRING , 
90489: STR
90490: PUSH
90491: LD_VAR 0 3
90495: PPUSH
90496: CALL_OW 250
90500: STR
90501: PUSH
90502: LD_STRING , 
90504: STR
90505: PUSH
90506: LD_VAR 0 3
90510: PPUSH
90511: CALL_OW 251
90515: STR
90516: PUSH
90517: LD_STRING , 
90519: STR
90520: PUSH
90521: LD_VAR 0 3
90525: PPUSH
90526: CALL_OW 254
90530: STR
90531: PUSH
90532: LD_STRING , 
90534: STR
90535: PUSH
90536: LD_VAR 0 3
90540: PPUSH
90541: LD_INT 1
90543: PPUSH
90544: CALL_OW 268
90548: STR
90549: PUSH
90550: LD_STRING , 
90552: STR
90553: PUSH
90554: LD_VAR 0 3
90558: PPUSH
90559: LD_INT 2
90561: PPUSH
90562: CALL_OW 268
90566: STR
90567: PUSH
90568: LD_STRING ],
90570: STR
90571: PPUSH
90572: CALL_OW 561
// end ;
90576: GO 90470
90578: POP
90579: POP
// AddToLog ( ]; ) ;
90580: LD_STRING ];
90582: PPUSH
90583: CALL_OW 561
// end ;
90587: LD_VAR 0 2
90591: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90592: LD_INT 0
90594: PPUSH
90595: PPUSH
90596: PPUSH
90597: PPUSH
90598: PPUSH
// if not area or not rate or not max then
90599: LD_VAR 0 1
90603: NOT
90604: PUSH
90605: LD_VAR 0 2
90609: NOT
90610: OR
90611: PUSH
90612: LD_VAR 0 4
90616: NOT
90617: OR
90618: IFFALSE 90622
// exit ;
90620: GO 90811
// while 1 do
90622: LD_INT 1
90624: IFFALSE 90811
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90626: LD_ADDR_VAR 0 9
90630: PUSH
90631: LD_VAR 0 1
90635: PPUSH
90636: LD_INT 1
90638: PPUSH
90639: CALL_OW 287
90643: PUSH
90644: LD_INT 10
90646: MUL
90647: ST_TO_ADDR
// r := rate / 10 ;
90648: LD_ADDR_VAR 0 7
90652: PUSH
90653: LD_VAR 0 2
90657: PUSH
90658: LD_INT 10
90660: DIVREAL
90661: ST_TO_ADDR
// time := 1 1$00 ;
90662: LD_ADDR_VAR 0 8
90666: PUSH
90667: LD_INT 2100
90669: ST_TO_ADDR
// if amount < min then
90670: LD_VAR 0 9
90674: PUSH
90675: LD_VAR 0 3
90679: LESS
90680: IFFALSE 90698
// r := r * 2 else
90682: LD_ADDR_VAR 0 7
90686: PUSH
90687: LD_VAR 0 7
90691: PUSH
90692: LD_INT 2
90694: MUL
90695: ST_TO_ADDR
90696: GO 90724
// if amount > max then
90698: LD_VAR 0 9
90702: PUSH
90703: LD_VAR 0 4
90707: GREATER
90708: IFFALSE 90724
// r := r / 2 ;
90710: LD_ADDR_VAR 0 7
90714: PUSH
90715: LD_VAR 0 7
90719: PUSH
90720: LD_INT 2
90722: DIVREAL
90723: ST_TO_ADDR
// time := time / r ;
90724: LD_ADDR_VAR 0 8
90728: PUSH
90729: LD_VAR 0 8
90733: PUSH
90734: LD_VAR 0 7
90738: DIVREAL
90739: ST_TO_ADDR
// if time < 0 then
90740: LD_VAR 0 8
90744: PUSH
90745: LD_INT 0
90747: LESS
90748: IFFALSE 90765
// time := time * - 1 ;
90750: LD_ADDR_VAR 0 8
90754: PUSH
90755: LD_VAR 0 8
90759: PUSH
90760: LD_INT 1
90762: NEG
90763: MUL
90764: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90765: LD_VAR 0 8
90769: PUSH
90770: LD_INT 35
90772: PPUSH
90773: LD_INT 875
90775: PPUSH
90776: CALL_OW 12
90780: PLUS
90781: PPUSH
90782: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90786: LD_INT 1
90788: PPUSH
90789: LD_INT 5
90791: PPUSH
90792: CALL_OW 12
90796: PPUSH
90797: LD_VAR 0 1
90801: PPUSH
90802: LD_INT 1
90804: PPUSH
90805: CALL_OW 55
// end ;
90809: GO 90622
// end ;
90811: LD_VAR 0 5
90815: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90816: LD_INT 0
90818: PPUSH
90819: PPUSH
90820: PPUSH
90821: PPUSH
90822: PPUSH
90823: PPUSH
90824: PPUSH
90825: PPUSH
// if not turrets or not factories then
90826: LD_VAR 0 1
90830: NOT
90831: PUSH
90832: LD_VAR 0 2
90836: NOT
90837: OR
90838: IFFALSE 90842
// exit ;
90840: GO 91149
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90842: LD_ADDR_VAR 0 10
90846: PUSH
90847: LD_INT 5
90849: PUSH
90850: LD_INT 6
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 2
90859: PUSH
90860: LD_INT 4
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 3
90869: PUSH
90870: LD_INT 5
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 24
90884: PUSH
90885: LD_INT 25
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 23
90894: PUSH
90895: LD_INT 27
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 42
90908: PUSH
90909: LD_INT 43
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 44
90918: PUSH
90919: LD_INT 46
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 45
90928: PUSH
90929: LD_INT 47
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: PUSH
90936: EMPTY
90937: LIST
90938: LIST
90939: LIST
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: LIST
90945: ST_TO_ADDR
// result := [ ] ;
90946: LD_ADDR_VAR 0 3
90950: PUSH
90951: EMPTY
90952: ST_TO_ADDR
// for i in turrets do
90953: LD_ADDR_VAR 0 4
90957: PUSH
90958: LD_VAR 0 1
90962: PUSH
90963: FOR_IN
90964: IFFALSE 91147
// begin nat := GetNation ( i ) ;
90966: LD_ADDR_VAR 0 7
90970: PUSH
90971: LD_VAR 0 4
90975: PPUSH
90976: CALL_OW 248
90980: ST_TO_ADDR
// weapon := 0 ;
90981: LD_ADDR_VAR 0 8
90985: PUSH
90986: LD_INT 0
90988: ST_TO_ADDR
// if not nat then
90989: LD_VAR 0 7
90993: NOT
90994: IFFALSE 90998
// continue ;
90996: GO 90963
// for j in list [ nat ] do
90998: LD_ADDR_VAR 0 5
91002: PUSH
91003: LD_VAR 0 10
91007: PUSH
91008: LD_VAR 0 7
91012: ARRAY
91013: PUSH
91014: FOR_IN
91015: IFFALSE 91056
// if GetBWeapon ( i ) = j [ 1 ] then
91017: LD_VAR 0 4
91021: PPUSH
91022: CALL_OW 269
91026: PUSH
91027: LD_VAR 0 5
91031: PUSH
91032: LD_INT 1
91034: ARRAY
91035: EQUAL
91036: IFFALSE 91054
// begin weapon := j [ 2 ] ;
91038: LD_ADDR_VAR 0 8
91042: PUSH
91043: LD_VAR 0 5
91047: PUSH
91048: LD_INT 2
91050: ARRAY
91051: ST_TO_ADDR
// break ;
91052: GO 91056
// end ;
91054: GO 91014
91056: POP
91057: POP
// if not weapon then
91058: LD_VAR 0 8
91062: NOT
91063: IFFALSE 91067
// continue ;
91065: GO 90963
// for k in factories do
91067: LD_ADDR_VAR 0 6
91071: PUSH
91072: LD_VAR 0 2
91076: PUSH
91077: FOR_IN
91078: IFFALSE 91143
// begin weapons := AvailableWeaponList ( k ) ;
91080: LD_ADDR_VAR 0 9
91084: PUSH
91085: LD_VAR 0 6
91089: PPUSH
91090: CALL_OW 478
91094: ST_TO_ADDR
// if not weapons then
91095: LD_VAR 0 9
91099: NOT
91100: IFFALSE 91104
// continue ;
91102: GO 91077
// if weapon in weapons then
91104: LD_VAR 0 8
91108: PUSH
91109: LD_VAR 0 9
91113: IN
91114: IFFALSE 91141
// begin result := [ i , weapon ] ;
91116: LD_ADDR_VAR 0 3
91120: PUSH
91121: LD_VAR 0 4
91125: PUSH
91126: LD_VAR 0 8
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: ST_TO_ADDR
// exit ;
91135: POP
91136: POP
91137: POP
91138: POP
91139: GO 91149
// end ; end ;
91141: GO 91077
91143: POP
91144: POP
// end ;
91145: GO 90963
91147: POP
91148: POP
// end ;
91149: LD_VAR 0 3
91153: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91154: LD_INT 0
91156: PPUSH
// if not side or side > 8 then
91157: LD_VAR 0 3
91161: NOT
91162: PUSH
91163: LD_VAR 0 3
91167: PUSH
91168: LD_INT 8
91170: GREATER
91171: OR
91172: IFFALSE 91176
// exit ;
91174: GO 91235
// if not range then
91176: LD_VAR 0 4
91180: NOT
91181: IFFALSE 91192
// range := - 12 ;
91183: LD_ADDR_VAR 0 4
91187: PUSH
91188: LD_INT 12
91190: NEG
91191: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91192: LD_VAR 0 1
91196: PPUSH
91197: LD_VAR 0 2
91201: PPUSH
91202: LD_VAR 0 3
91206: PPUSH
91207: LD_VAR 0 4
91211: PPUSH
91212: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91216: LD_VAR 0 1
91220: PPUSH
91221: LD_VAR 0 2
91225: PPUSH
91226: LD_VAR 0 3
91230: PPUSH
91231: CALL_OW 331
// end ;
91235: LD_VAR 0 5
91239: RET
// export function Video ( mode ) ; begin
91240: LD_INT 0
91242: PPUSH
// ingame_video = mode ;
91243: LD_ADDR_OWVAR 52
91247: PUSH
91248: LD_VAR 0 1
91252: ST_TO_ADDR
// interface_hidden = mode ;
91253: LD_ADDR_OWVAR 54
91257: PUSH
91258: LD_VAR 0 1
91262: ST_TO_ADDR
// end ;
91263: LD_VAR 0 2
91267: RET
// export function Join ( array , element ) ; begin
91268: LD_INT 0
91270: PPUSH
// result := Replace ( array , array + 1 , element ) ;
91271: LD_ADDR_VAR 0 3
91275: PUSH
91276: LD_VAR 0 1
91280: PPUSH
91281: LD_VAR 0 1
91285: PUSH
91286: LD_INT 1
91288: PLUS
91289: PPUSH
91290: LD_VAR 0 2
91294: PPUSH
91295: CALL_OW 1
91299: ST_TO_ADDR
// end ;
91300: LD_VAR 0 3
91304: RET
// export function JoinUnion ( array , element ) ; begin
91305: LD_INT 0
91307: PPUSH
// result := array union element ;
91308: LD_ADDR_VAR 0 3
91312: PUSH
91313: LD_VAR 0 1
91317: PUSH
91318: LD_VAR 0 2
91322: UNION
91323: ST_TO_ADDR
// end ;
91324: LD_VAR 0 3
91328: RET
// export function GetBehemoths ( side ) ; begin
91329: LD_INT 0
91331: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91332: LD_ADDR_VAR 0 2
91336: PUSH
91337: LD_INT 22
91339: PUSH
91340: LD_VAR 0 1
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 31
91351: PUSH
91352: LD_INT 25
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PPUSH
91363: CALL_OW 69
91367: ST_TO_ADDR
// end ;
91368: LD_VAR 0 2
91372: RET
// export function Shuffle ( array ) ; var i , index ; begin
91373: LD_INT 0
91375: PPUSH
91376: PPUSH
91377: PPUSH
// result := [ ] ;
91378: LD_ADDR_VAR 0 2
91382: PUSH
91383: EMPTY
91384: ST_TO_ADDR
// if not array then
91385: LD_VAR 0 1
91389: NOT
91390: IFFALSE 91394
// exit ;
91392: GO 91493
// Randomize ;
91394: CALL_OW 10
// for i = array downto 1 do
91398: LD_ADDR_VAR 0 3
91402: PUSH
91403: DOUBLE
91404: LD_VAR 0 1
91408: INC
91409: ST_TO_ADDR
91410: LD_INT 1
91412: PUSH
91413: FOR_DOWNTO
91414: IFFALSE 91491
// begin index := rand ( 1 , array ) ;
91416: LD_ADDR_VAR 0 4
91420: PUSH
91421: LD_INT 1
91423: PPUSH
91424: LD_VAR 0 1
91428: PPUSH
91429: CALL_OW 12
91433: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91434: LD_ADDR_VAR 0 2
91438: PUSH
91439: LD_VAR 0 2
91443: PPUSH
91444: LD_VAR 0 2
91448: PUSH
91449: LD_INT 1
91451: PLUS
91452: PPUSH
91453: LD_VAR 0 1
91457: PUSH
91458: LD_VAR 0 4
91462: ARRAY
91463: PPUSH
91464: CALL_OW 2
91468: ST_TO_ADDR
// array := Delete ( array , index ) ;
91469: LD_ADDR_VAR 0 1
91473: PUSH
91474: LD_VAR 0 1
91478: PPUSH
91479: LD_VAR 0 4
91483: PPUSH
91484: CALL_OW 3
91488: ST_TO_ADDR
// end ;
91489: GO 91413
91491: POP
91492: POP
// end ;
91493: LD_VAR 0 2
91497: RET
// export function GetBaseMaterials ( base ) ; begin
91498: LD_INT 0
91500: PPUSH
// result := [ 0 , 0 , 0 ] ;
91501: LD_ADDR_VAR 0 2
91505: PUSH
91506: LD_INT 0
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: LD_INT 0
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: LIST
91519: ST_TO_ADDR
// if not base then
91520: LD_VAR 0 1
91524: NOT
91525: IFFALSE 91529
// exit ;
91527: GO 91578
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91529: LD_ADDR_VAR 0 2
91533: PUSH
91534: LD_VAR 0 1
91538: PPUSH
91539: LD_INT 1
91541: PPUSH
91542: CALL_OW 275
91546: PUSH
91547: LD_VAR 0 1
91551: PPUSH
91552: LD_INT 2
91554: PPUSH
91555: CALL_OW 275
91559: PUSH
91560: LD_VAR 0 1
91564: PPUSH
91565: LD_INT 3
91567: PPUSH
91568: CALL_OW 275
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: LIST
91577: ST_TO_ADDR
// end ;
91578: LD_VAR 0 2
91582: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91583: LD_INT 0
91585: PPUSH
91586: PPUSH
// result := array ;
91587: LD_ADDR_VAR 0 3
91591: PUSH
91592: LD_VAR 0 1
91596: ST_TO_ADDR
// if size >= result then
91597: LD_VAR 0 2
91601: PUSH
91602: LD_VAR 0 3
91606: GREATEREQUAL
91607: IFFALSE 91611
// exit ;
91609: GO 91661
// if size then
91611: LD_VAR 0 2
91615: IFFALSE 91661
// for i := array downto size do
91617: LD_ADDR_VAR 0 4
91621: PUSH
91622: DOUBLE
91623: LD_VAR 0 1
91627: INC
91628: ST_TO_ADDR
91629: LD_VAR 0 2
91633: PUSH
91634: FOR_DOWNTO
91635: IFFALSE 91659
// result := Delete ( result , result ) ;
91637: LD_ADDR_VAR 0 3
91641: PUSH
91642: LD_VAR 0 3
91646: PPUSH
91647: LD_VAR 0 3
91651: PPUSH
91652: CALL_OW 3
91656: ST_TO_ADDR
91657: GO 91634
91659: POP
91660: POP
// end ;
91661: LD_VAR 0 3
91665: RET
// export function ComExit ( unit ) ; var tmp ; begin
91666: LD_INT 0
91668: PPUSH
91669: PPUSH
// if not IsInUnit ( unit ) then
91670: LD_VAR 0 1
91674: PPUSH
91675: CALL_OW 310
91679: NOT
91680: IFFALSE 91684
// exit ;
91682: GO 91744
// tmp := IsInUnit ( unit ) ;
91684: LD_ADDR_VAR 0 3
91688: PUSH
91689: LD_VAR 0 1
91693: PPUSH
91694: CALL_OW 310
91698: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91699: LD_VAR 0 3
91703: PPUSH
91704: CALL_OW 247
91708: PUSH
91709: LD_INT 2
91711: EQUAL
91712: IFFALSE 91725
// ComExitVehicle ( unit ) else
91714: LD_VAR 0 1
91718: PPUSH
91719: CALL_OW 121
91723: GO 91734
// ComExitBuilding ( unit ) ;
91725: LD_VAR 0 1
91729: PPUSH
91730: CALL_OW 122
// result := tmp ;
91734: LD_ADDR_VAR 0 2
91738: PUSH
91739: LD_VAR 0 3
91743: ST_TO_ADDR
// end ;
91744: LD_VAR 0 2
91748: RET
// export function ComExitAll ( units ) ; var i ; begin
91749: LD_INT 0
91751: PPUSH
91752: PPUSH
// if not units then
91753: LD_VAR 0 1
91757: NOT
91758: IFFALSE 91762
// exit ;
91760: GO 91788
// for i in units do
91762: LD_ADDR_VAR 0 3
91766: PUSH
91767: LD_VAR 0 1
91771: PUSH
91772: FOR_IN
91773: IFFALSE 91786
// ComExit ( i ) ;
91775: LD_VAR 0 3
91779: PPUSH
91780: CALL 91666 0 1
91784: GO 91772
91786: POP
91787: POP
// end ;
91788: LD_VAR 0 2
91792: RET
// export function ResetHc ; begin
91793: LD_INT 0
91795: PPUSH
// InitHc ;
91796: CALL_OW 19
// hc_importance := 0 ;
91800: LD_ADDR_OWVAR 32
91804: PUSH
91805: LD_INT 0
91807: ST_TO_ADDR
// end ;
91808: LD_VAR 0 1
91812: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91813: LD_INT 0
91815: PPUSH
91816: PPUSH
91817: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91818: LD_ADDR_VAR 0 6
91822: PUSH
91823: LD_VAR 0 1
91827: PUSH
91828: LD_VAR 0 3
91832: PLUS
91833: PUSH
91834: LD_INT 2
91836: DIV
91837: ST_TO_ADDR
// if _x < 0 then
91838: LD_VAR 0 6
91842: PUSH
91843: LD_INT 0
91845: LESS
91846: IFFALSE 91863
// _x := _x * - 1 ;
91848: LD_ADDR_VAR 0 6
91852: PUSH
91853: LD_VAR 0 6
91857: PUSH
91858: LD_INT 1
91860: NEG
91861: MUL
91862: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91863: LD_ADDR_VAR 0 7
91867: PUSH
91868: LD_VAR 0 2
91872: PUSH
91873: LD_VAR 0 4
91877: PLUS
91878: PUSH
91879: LD_INT 2
91881: DIV
91882: ST_TO_ADDR
// if _y < 0 then
91883: LD_VAR 0 7
91887: PUSH
91888: LD_INT 0
91890: LESS
91891: IFFALSE 91908
// _y := _y * - 1 ;
91893: LD_ADDR_VAR 0 7
91897: PUSH
91898: LD_VAR 0 7
91902: PUSH
91903: LD_INT 1
91905: NEG
91906: MUL
91907: ST_TO_ADDR
// result := [ _x , _y ] ;
91908: LD_ADDR_VAR 0 5
91912: PUSH
91913: LD_VAR 0 6
91917: PUSH
91918: LD_VAR 0 7
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: ST_TO_ADDR
// end ;
91927: LD_VAR 0 5
91931: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91932: LD_INT 0
91934: PPUSH
91935: PPUSH
91936: PPUSH
91937: PPUSH
// task := GetTaskList ( unit ) ;
91938: LD_ADDR_VAR 0 7
91942: PUSH
91943: LD_VAR 0 1
91947: PPUSH
91948: CALL_OW 437
91952: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91953: LD_VAR 0 7
91957: NOT
91958: PUSH
91959: LD_VAR 0 1
91963: PPUSH
91964: LD_VAR 0 2
91968: PPUSH
91969: CALL_OW 308
91973: NOT
91974: AND
91975: IFFALSE 91979
// exit ;
91977: GO 92097
// if IsInArea ( unit , area ) then
91979: LD_VAR 0 1
91983: PPUSH
91984: LD_VAR 0 2
91988: PPUSH
91989: CALL_OW 308
91993: IFFALSE 92011
// begin ComMoveToArea ( unit , goAway ) ;
91995: LD_VAR 0 1
91999: PPUSH
92000: LD_VAR 0 3
92004: PPUSH
92005: CALL_OW 113
// exit ;
92009: GO 92097
// end ; if task [ 1 ] [ 1 ] <> M then
92011: LD_VAR 0 7
92015: PUSH
92016: LD_INT 1
92018: ARRAY
92019: PUSH
92020: LD_INT 1
92022: ARRAY
92023: PUSH
92024: LD_STRING M
92026: NONEQUAL
92027: IFFALSE 92031
// exit ;
92029: GO 92097
// x := task [ 1 ] [ 2 ] ;
92031: LD_ADDR_VAR 0 5
92035: PUSH
92036: LD_VAR 0 7
92040: PUSH
92041: LD_INT 1
92043: ARRAY
92044: PUSH
92045: LD_INT 2
92047: ARRAY
92048: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
92049: LD_ADDR_VAR 0 6
92053: PUSH
92054: LD_VAR 0 7
92058: PUSH
92059: LD_INT 1
92061: ARRAY
92062: PUSH
92063: LD_INT 3
92065: ARRAY
92066: ST_TO_ADDR
// if InArea ( x , y , area ) then
92067: LD_VAR 0 5
92071: PPUSH
92072: LD_VAR 0 6
92076: PPUSH
92077: LD_VAR 0 2
92081: PPUSH
92082: CALL_OW 309
92086: IFFALSE 92097
// ComStop ( unit ) ;
92088: LD_VAR 0 1
92092: PPUSH
92093: CALL_OW 141
// end ;
92097: LD_VAR 0 4
92101: RET
// export function Abs ( value ) ; begin
92102: LD_INT 0
92104: PPUSH
// result := value ;
92105: LD_ADDR_VAR 0 2
92109: PUSH
92110: LD_VAR 0 1
92114: ST_TO_ADDR
// if value < 0 then
92115: LD_VAR 0 1
92119: PUSH
92120: LD_INT 0
92122: LESS
92123: IFFALSE 92140
// result := value * - 1 ;
92125: LD_ADDR_VAR 0 2
92129: PUSH
92130: LD_VAR 0 1
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: MUL
92139: ST_TO_ADDR
// end ;
92140: LD_VAR 0 2
92144: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
92145: LD_INT 0
92147: PPUSH
92148: PPUSH
92149: PPUSH
92150: PPUSH
92151: PPUSH
92152: PPUSH
92153: PPUSH
92154: PPUSH
// if not unit or not building then
92155: LD_VAR 0 1
92159: NOT
92160: PUSH
92161: LD_VAR 0 2
92165: NOT
92166: OR
92167: IFFALSE 92171
// exit ;
92169: GO 92397
// x := GetX ( building ) ;
92171: LD_ADDR_VAR 0 4
92175: PUSH
92176: LD_VAR 0 2
92180: PPUSH
92181: CALL_OW 250
92185: ST_TO_ADDR
// y := GetY ( building ) ;
92186: LD_ADDR_VAR 0 6
92190: PUSH
92191: LD_VAR 0 2
92195: PPUSH
92196: CALL_OW 251
92200: ST_TO_ADDR
// d := GetDir ( building ) ;
92201: LD_ADDR_VAR 0 8
92205: PUSH
92206: LD_VAR 0 2
92210: PPUSH
92211: CALL_OW 254
92215: ST_TO_ADDR
// r := 4 ;
92216: LD_ADDR_VAR 0 9
92220: PUSH
92221: LD_INT 4
92223: ST_TO_ADDR
// for i := 1 to 5 do
92224: LD_ADDR_VAR 0 10
92228: PUSH
92229: DOUBLE
92230: LD_INT 1
92232: DEC
92233: ST_TO_ADDR
92234: LD_INT 5
92236: PUSH
92237: FOR_TO
92238: IFFALSE 92395
// begin _x := ShiftX ( x , d , r + i ) ;
92240: LD_ADDR_VAR 0 5
92244: PUSH
92245: LD_VAR 0 4
92249: PPUSH
92250: LD_VAR 0 8
92254: PPUSH
92255: LD_VAR 0 9
92259: PUSH
92260: LD_VAR 0 10
92264: PLUS
92265: PPUSH
92266: CALL_OW 272
92270: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
92271: LD_ADDR_VAR 0 7
92275: PUSH
92276: LD_VAR 0 6
92280: PPUSH
92281: LD_VAR 0 8
92285: PPUSH
92286: LD_VAR 0 9
92290: PUSH
92291: LD_VAR 0 10
92295: PLUS
92296: PPUSH
92297: CALL_OW 273
92301: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
92302: LD_VAR 0 5
92306: PPUSH
92307: LD_VAR 0 7
92311: PPUSH
92312: CALL_OW 488
92316: PUSH
92317: LD_VAR 0 5
92321: PPUSH
92322: LD_VAR 0 7
92326: PPUSH
92327: CALL_OW 428
92331: PPUSH
92332: CALL_OW 247
92336: PUSH
92337: LD_INT 3
92339: PUSH
92340: LD_INT 2
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: IN
92347: NOT
92348: AND
92349: IFFALSE 92393
// begin ComMoveXY ( unit , _x , _y ) ;
92351: LD_VAR 0 1
92355: PPUSH
92356: LD_VAR 0 5
92360: PPUSH
92361: LD_VAR 0 7
92365: PPUSH
92366: CALL_OW 111
// result := [ _x , _y ] ;
92370: LD_ADDR_VAR 0 3
92374: PUSH
92375: LD_VAR 0 5
92379: PUSH
92380: LD_VAR 0 7
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: ST_TO_ADDR
// exit ;
92389: POP
92390: POP
92391: GO 92397
// end ; end ;
92393: GO 92237
92395: POP
92396: POP
// end ;
92397: LD_VAR 0 3
92401: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92402: LD_INT 0
92404: PPUSH
92405: PPUSH
92406: PPUSH
// result := 0 ;
92407: LD_ADDR_VAR 0 3
92411: PUSH
92412: LD_INT 0
92414: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92415: LD_VAR 0 1
92419: PUSH
92420: LD_INT 0
92422: LESS
92423: PUSH
92424: LD_VAR 0 1
92428: PUSH
92429: LD_INT 8
92431: GREATER
92432: OR
92433: PUSH
92434: LD_VAR 0 2
92438: PUSH
92439: LD_INT 0
92441: LESS
92442: OR
92443: PUSH
92444: LD_VAR 0 2
92448: PUSH
92449: LD_INT 8
92451: GREATER
92452: OR
92453: IFFALSE 92457
// exit ;
92455: GO 92532
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92457: LD_ADDR_VAR 0 4
92461: PUSH
92462: LD_INT 22
92464: PUSH
92465: LD_VAR 0 2
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PPUSH
92474: CALL_OW 69
92478: PUSH
92479: FOR_IN
92480: IFFALSE 92530
// begin un := UnitShoot ( i ) ;
92482: LD_ADDR_VAR 0 5
92486: PUSH
92487: LD_VAR 0 4
92491: PPUSH
92492: CALL_OW 504
92496: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92497: LD_VAR 0 5
92501: PPUSH
92502: CALL_OW 255
92506: PUSH
92507: LD_VAR 0 1
92511: EQUAL
92512: IFFALSE 92528
// begin result := un ;
92514: LD_ADDR_VAR 0 3
92518: PUSH
92519: LD_VAR 0 5
92523: ST_TO_ADDR
// exit ;
92524: POP
92525: POP
92526: GO 92532
// end ; end ;
92528: GO 92479
92530: POP
92531: POP
// end ;
92532: LD_VAR 0 3
92536: RET
// export function GetCargoBay ( units ) ; begin
92537: LD_INT 0
92539: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92540: LD_ADDR_VAR 0 2
92544: PUSH
92545: LD_VAR 0 1
92549: PPUSH
92550: LD_INT 2
92552: PUSH
92553: LD_INT 34
92555: PUSH
92556: LD_INT 12
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 34
92565: PUSH
92566: LD_INT 51
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 34
92575: PUSH
92576: LD_INT 32
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 34
92585: PUSH
92586: LD_INT 89
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: PPUSH
92600: CALL_OW 72
92604: ST_TO_ADDR
// end ;
92605: LD_VAR 0 2
92609: RET
// export function Negate ( value ) ; begin
92610: LD_INT 0
92612: PPUSH
// result := not value ;
92613: LD_ADDR_VAR 0 2
92617: PUSH
92618: LD_VAR 0 1
92622: NOT
92623: ST_TO_ADDR
// end ;
92624: LD_VAR 0 2
92628: RET
// export function Inc ( value ) ; begin
92629: LD_INT 0
92631: PPUSH
// result := value + 1 ;
92632: LD_ADDR_VAR 0 2
92636: PUSH
92637: LD_VAR 0 1
92641: PUSH
92642: LD_INT 1
92644: PLUS
92645: ST_TO_ADDR
// end ;
92646: LD_VAR 0 2
92650: RET
// export function Dec ( value ) ; begin
92651: LD_INT 0
92653: PPUSH
// result := value - 1 ;
92654: LD_ADDR_VAR 0 2
92658: PUSH
92659: LD_VAR 0 1
92663: PUSH
92664: LD_INT 1
92666: MINUS
92667: ST_TO_ADDR
// end ;
92668: LD_VAR 0 2
92672: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92673: LD_INT 0
92675: PPUSH
92676: PPUSH
92677: PPUSH
92678: PPUSH
92679: PPUSH
92680: PPUSH
92681: PPUSH
92682: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92683: LD_VAR 0 1
92687: PPUSH
92688: LD_VAR 0 2
92692: PPUSH
92693: CALL_OW 488
92697: NOT
92698: PUSH
92699: LD_VAR 0 3
92703: PPUSH
92704: LD_VAR 0 4
92708: PPUSH
92709: CALL_OW 488
92713: NOT
92714: OR
92715: IFFALSE 92728
// begin result := - 1 ;
92717: LD_ADDR_VAR 0 5
92721: PUSH
92722: LD_INT 1
92724: NEG
92725: ST_TO_ADDR
// exit ;
92726: GO 92963
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92728: LD_ADDR_VAR 0 12
92732: PUSH
92733: LD_VAR 0 1
92737: PPUSH
92738: LD_VAR 0 2
92742: PPUSH
92743: LD_VAR 0 3
92747: PPUSH
92748: LD_VAR 0 4
92752: PPUSH
92753: CALL 91813 0 4
92757: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92758: LD_ADDR_VAR 0 11
92762: PUSH
92763: LD_VAR 0 1
92767: PPUSH
92768: LD_VAR 0 2
92772: PPUSH
92773: LD_VAR 0 12
92777: PUSH
92778: LD_INT 1
92780: ARRAY
92781: PPUSH
92782: LD_VAR 0 12
92786: PUSH
92787: LD_INT 2
92789: ARRAY
92790: PPUSH
92791: CALL_OW 298
92795: ST_TO_ADDR
// distance := 9999 ;
92796: LD_ADDR_VAR 0 10
92800: PUSH
92801: LD_INT 9999
92803: ST_TO_ADDR
// for i := 0 to 5 do
92804: LD_ADDR_VAR 0 6
92808: PUSH
92809: DOUBLE
92810: LD_INT 0
92812: DEC
92813: ST_TO_ADDR
92814: LD_INT 5
92816: PUSH
92817: FOR_TO
92818: IFFALSE 92961
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92820: LD_ADDR_VAR 0 7
92824: PUSH
92825: LD_VAR 0 1
92829: PPUSH
92830: LD_VAR 0 6
92834: PPUSH
92835: LD_VAR 0 11
92839: PPUSH
92840: CALL_OW 272
92844: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92845: LD_ADDR_VAR 0 8
92849: PUSH
92850: LD_VAR 0 2
92854: PPUSH
92855: LD_VAR 0 6
92859: PPUSH
92860: LD_VAR 0 11
92864: PPUSH
92865: CALL_OW 273
92869: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92870: LD_VAR 0 7
92874: PPUSH
92875: LD_VAR 0 8
92879: PPUSH
92880: CALL_OW 488
92884: NOT
92885: IFFALSE 92889
// continue ;
92887: GO 92817
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92889: LD_ADDR_VAR 0 9
92893: PUSH
92894: LD_VAR 0 12
92898: PUSH
92899: LD_INT 1
92901: ARRAY
92902: PPUSH
92903: LD_VAR 0 12
92907: PUSH
92908: LD_INT 2
92910: ARRAY
92911: PPUSH
92912: LD_VAR 0 7
92916: PPUSH
92917: LD_VAR 0 8
92921: PPUSH
92922: CALL_OW 298
92926: ST_TO_ADDR
// if tmp < distance then
92927: LD_VAR 0 9
92931: PUSH
92932: LD_VAR 0 10
92936: LESS
92937: IFFALSE 92959
// begin result := i ;
92939: LD_ADDR_VAR 0 5
92943: PUSH
92944: LD_VAR 0 6
92948: ST_TO_ADDR
// distance := tmp ;
92949: LD_ADDR_VAR 0 10
92953: PUSH
92954: LD_VAR 0 9
92958: ST_TO_ADDR
// end ; end ;
92959: GO 92817
92961: POP
92962: POP
// end ;
92963: LD_VAR 0 5
92967: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92968: LD_INT 0
92970: PPUSH
92971: PPUSH
// if not driver or not IsInUnit ( driver ) then
92972: LD_VAR 0 1
92976: NOT
92977: PUSH
92978: LD_VAR 0 1
92982: PPUSH
92983: CALL_OW 310
92987: NOT
92988: OR
92989: IFFALSE 92993
// exit ;
92991: GO 93083
// vehicle := IsInUnit ( driver ) ;
92993: LD_ADDR_VAR 0 3
92997: PUSH
92998: LD_VAR 0 1
93002: PPUSH
93003: CALL_OW 310
93007: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93008: LD_VAR 0 1
93012: PPUSH
93013: LD_STRING \
93015: PUSH
93016: LD_INT 0
93018: PUSH
93019: LD_INT 0
93021: PUSH
93022: LD_INT 0
93024: PUSH
93025: LD_INT 0
93027: PUSH
93028: LD_INT 0
93030: PUSH
93031: LD_INT 0
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: PUSH
93043: LD_STRING E
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: LD_INT 0
93051: PUSH
93052: LD_VAR 0 3
93056: PUSH
93057: LD_INT 0
93059: PUSH
93060: LD_INT 0
93062: PUSH
93063: LD_INT 0
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PPUSH
93079: CALL_OW 446
// end ;
93083: LD_VAR 0 2
93087: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
93088: LD_INT 0
93090: PPUSH
93091: PPUSH
// if not driver or not IsInUnit ( driver ) then
93092: LD_VAR 0 1
93096: NOT
93097: PUSH
93098: LD_VAR 0 1
93102: PPUSH
93103: CALL_OW 310
93107: NOT
93108: OR
93109: IFFALSE 93113
// exit ;
93111: GO 93203
// vehicle := IsInUnit ( driver ) ;
93113: LD_ADDR_VAR 0 3
93117: PUSH
93118: LD_VAR 0 1
93122: PPUSH
93123: CALL_OW 310
93127: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93128: LD_VAR 0 1
93132: PPUSH
93133: LD_STRING \
93135: PUSH
93136: LD_INT 0
93138: PUSH
93139: LD_INT 0
93141: PUSH
93142: LD_INT 0
93144: PUSH
93145: LD_INT 0
93147: PUSH
93148: LD_INT 0
93150: PUSH
93151: LD_INT 0
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: PUSH
93163: LD_STRING E
93165: PUSH
93166: LD_INT 0
93168: PUSH
93169: LD_INT 0
93171: PUSH
93172: LD_VAR 0 3
93176: PUSH
93177: LD_INT 0
93179: PUSH
93180: LD_INT 0
93182: PUSH
93183: LD_INT 0
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PPUSH
93199: CALL_OW 447
// end ;
93203: LD_VAR 0 2
93207: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
93208: LD_INT 0
93210: PPUSH
93211: PPUSH
93212: PPUSH
// tmp := [ ] ;
93213: LD_ADDR_VAR 0 5
93217: PUSH
93218: EMPTY
93219: ST_TO_ADDR
// for i in units do
93220: LD_ADDR_VAR 0 4
93224: PUSH
93225: LD_VAR 0 1
93229: PUSH
93230: FOR_IN
93231: IFFALSE 93269
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
93233: LD_ADDR_VAR 0 5
93237: PUSH
93238: LD_VAR 0 5
93242: PPUSH
93243: LD_VAR 0 5
93247: PUSH
93248: LD_INT 1
93250: PLUS
93251: PPUSH
93252: LD_VAR 0 4
93256: PPUSH
93257: CALL_OW 256
93261: PPUSH
93262: CALL_OW 2
93266: ST_TO_ADDR
93267: GO 93230
93269: POP
93270: POP
// if not tmp then
93271: LD_VAR 0 5
93275: NOT
93276: IFFALSE 93280
// exit ;
93278: GO 93328
// if asc then
93280: LD_VAR 0 2
93284: IFFALSE 93308
// result := SortListByListAsc ( units , tmp ) else
93286: LD_ADDR_VAR 0 3
93290: PUSH
93291: LD_VAR 0 1
93295: PPUSH
93296: LD_VAR 0 5
93300: PPUSH
93301: CALL_OW 76
93305: ST_TO_ADDR
93306: GO 93328
// result := SortListByListDesc ( units , tmp ) ;
93308: LD_ADDR_VAR 0 3
93312: PUSH
93313: LD_VAR 0 1
93317: PPUSH
93318: LD_VAR 0 5
93322: PPUSH
93323: CALL_OW 77
93327: ST_TO_ADDR
// end ;
93328: LD_VAR 0 3
93332: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93333: LD_INT 0
93335: PPUSH
93336: PPUSH
// task := GetTaskList ( mech ) ;
93337: LD_ADDR_VAR 0 4
93341: PUSH
93342: LD_VAR 0 1
93346: PPUSH
93347: CALL_OW 437
93351: ST_TO_ADDR
// if not task then
93352: LD_VAR 0 4
93356: NOT
93357: IFFALSE 93361
// exit ;
93359: GO 93403
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93361: LD_ADDR_VAR 0 3
93365: PUSH
93366: LD_VAR 0 4
93370: PUSH
93371: LD_INT 1
93373: ARRAY
93374: PUSH
93375: LD_INT 1
93377: ARRAY
93378: PUSH
93379: LD_STRING r
93381: EQUAL
93382: PUSH
93383: LD_VAR 0 4
93387: PUSH
93388: LD_INT 1
93390: ARRAY
93391: PUSH
93392: LD_INT 4
93394: ARRAY
93395: PUSH
93396: LD_VAR 0 2
93400: EQUAL
93401: AND
93402: ST_TO_ADDR
// end ;
93403: LD_VAR 0 3
93407: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93408: LD_INT 0
93410: PPUSH
// SetDir ( unit , d ) ;
93411: LD_VAR 0 1
93415: PPUSH
93416: LD_VAR 0 4
93420: PPUSH
93421: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
93425: LD_VAR 0 1
93429: PPUSH
93430: LD_VAR 0 2
93434: PPUSH
93435: LD_VAR 0 3
93439: PPUSH
93440: LD_VAR 0 5
93444: PPUSH
93445: CALL_OW 48
// end ;
93449: LD_VAR 0 6
93453: RET
// export function ToNaturalNumber ( number ) ; begin
93454: LD_INT 0
93456: PPUSH
// result := number div 1 ;
93457: LD_ADDR_VAR 0 2
93461: PUSH
93462: LD_VAR 0 1
93466: PUSH
93467: LD_INT 1
93469: DIV
93470: ST_TO_ADDR
// if number < 0 then
93471: LD_VAR 0 1
93475: PUSH
93476: LD_INT 0
93478: LESS
93479: IFFALSE 93489
// result := 0 ;
93481: LD_ADDR_VAR 0 2
93485: PUSH
93486: LD_INT 0
93488: ST_TO_ADDR
// end ;
93489: LD_VAR 0 2
93493: RET
// export function SortByClass ( units , class ) ; var un ; begin
93494: LD_INT 0
93496: PPUSH
93497: PPUSH
// if not units or not class then
93498: LD_VAR 0 1
93502: NOT
93503: PUSH
93504: LD_VAR 0 2
93508: NOT
93509: OR
93510: IFFALSE 93514
// exit ;
93512: GO 93609
// result := [ ] ;
93514: LD_ADDR_VAR 0 3
93518: PUSH
93519: EMPTY
93520: ST_TO_ADDR
// for un in units do
93521: LD_ADDR_VAR 0 4
93525: PUSH
93526: LD_VAR 0 1
93530: PUSH
93531: FOR_IN
93532: IFFALSE 93607
// if GetClass ( un ) = class then
93534: LD_VAR 0 4
93538: PPUSH
93539: CALL_OW 257
93543: PUSH
93544: LD_VAR 0 2
93548: EQUAL
93549: IFFALSE 93576
// result := Insert ( result , 1 , un ) else
93551: LD_ADDR_VAR 0 3
93555: PUSH
93556: LD_VAR 0 3
93560: PPUSH
93561: LD_INT 1
93563: PPUSH
93564: LD_VAR 0 4
93568: PPUSH
93569: CALL_OW 2
93573: ST_TO_ADDR
93574: GO 93605
// result := Replace ( result , result + 1 , un ) ;
93576: LD_ADDR_VAR 0 3
93580: PUSH
93581: LD_VAR 0 3
93585: PPUSH
93586: LD_VAR 0 3
93590: PUSH
93591: LD_INT 1
93593: PLUS
93594: PPUSH
93595: LD_VAR 0 4
93599: PPUSH
93600: CALL_OW 1
93604: ST_TO_ADDR
93605: GO 93531
93607: POP
93608: POP
// end ;
93609: LD_VAR 0 3
93613: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93614: LD_INT 0
93616: PPUSH
93617: PPUSH
93618: PPUSH
93619: PPUSH
93620: PPUSH
93621: PPUSH
93622: PPUSH
// result := [ ] ;
93623: LD_ADDR_VAR 0 4
93627: PUSH
93628: EMPTY
93629: ST_TO_ADDR
// if x - r < 0 then
93630: LD_VAR 0 1
93634: PUSH
93635: LD_VAR 0 3
93639: MINUS
93640: PUSH
93641: LD_INT 0
93643: LESS
93644: IFFALSE 93656
// min_x := 0 else
93646: LD_ADDR_VAR 0 8
93650: PUSH
93651: LD_INT 0
93653: ST_TO_ADDR
93654: GO 93672
// min_x := x - r ;
93656: LD_ADDR_VAR 0 8
93660: PUSH
93661: LD_VAR 0 1
93665: PUSH
93666: LD_VAR 0 3
93670: MINUS
93671: ST_TO_ADDR
// if y - r < 0 then
93672: LD_VAR 0 2
93676: PUSH
93677: LD_VAR 0 3
93681: MINUS
93682: PUSH
93683: LD_INT 0
93685: LESS
93686: IFFALSE 93698
// min_y := 0 else
93688: LD_ADDR_VAR 0 7
93692: PUSH
93693: LD_INT 0
93695: ST_TO_ADDR
93696: GO 93714
// min_y := y - r ;
93698: LD_ADDR_VAR 0 7
93702: PUSH
93703: LD_VAR 0 2
93707: PUSH
93708: LD_VAR 0 3
93712: MINUS
93713: ST_TO_ADDR
// max_x := x + r ;
93714: LD_ADDR_VAR 0 9
93718: PUSH
93719: LD_VAR 0 1
93723: PUSH
93724: LD_VAR 0 3
93728: PLUS
93729: ST_TO_ADDR
// max_y := y + r ;
93730: LD_ADDR_VAR 0 10
93734: PUSH
93735: LD_VAR 0 2
93739: PUSH
93740: LD_VAR 0 3
93744: PLUS
93745: ST_TO_ADDR
// for _x = min_x to max_x do
93746: LD_ADDR_VAR 0 5
93750: PUSH
93751: DOUBLE
93752: LD_VAR 0 8
93756: DEC
93757: ST_TO_ADDR
93758: LD_VAR 0 9
93762: PUSH
93763: FOR_TO
93764: IFFALSE 93865
// for _y = min_y to max_y do
93766: LD_ADDR_VAR 0 6
93770: PUSH
93771: DOUBLE
93772: LD_VAR 0 7
93776: DEC
93777: ST_TO_ADDR
93778: LD_VAR 0 10
93782: PUSH
93783: FOR_TO
93784: IFFALSE 93861
// begin if not ValidHex ( _x , _y ) then
93786: LD_VAR 0 5
93790: PPUSH
93791: LD_VAR 0 6
93795: PPUSH
93796: CALL_OW 488
93800: NOT
93801: IFFALSE 93805
// continue ;
93803: GO 93783
// if GetResourceTypeXY ( _x , _y ) then
93805: LD_VAR 0 5
93809: PPUSH
93810: LD_VAR 0 6
93814: PPUSH
93815: CALL_OW 283
93819: IFFALSE 93859
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93821: LD_ADDR_VAR 0 4
93825: PUSH
93826: LD_VAR 0 4
93830: PPUSH
93831: LD_VAR 0 4
93835: PUSH
93836: LD_INT 1
93838: PLUS
93839: PPUSH
93840: LD_VAR 0 5
93844: PUSH
93845: LD_VAR 0 6
93849: PUSH
93850: EMPTY
93851: LIST
93852: LIST
93853: PPUSH
93854: CALL_OW 1
93858: ST_TO_ADDR
// end ;
93859: GO 93783
93861: POP
93862: POP
93863: GO 93763
93865: POP
93866: POP
// end ;
93867: LD_VAR 0 4
93871: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93872: LD_INT 0
93874: PPUSH
93875: PPUSH
93876: PPUSH
93877: PPUSH
93878: PPUSH
93879: PPUSH
93880: PPUSH
93881: PPUSH
// if not units then
93882: LD_VAR 0 1
93886: NOT
93887: IFFALSE 93891
// exit ;
93889: GO 94419
// result := UnitFilter ( units , [ f_ok ] ) ;
93891: LD_ADDR_VAR 0 3
93895: PUSH
93896: LD_VAR 0 1
93900: PPUSH
93901: LD_INT 50
93903: PUSH
93904: EMPTY
93905: LIST
93906: PPUSH
93907: CALL_OW 72
93911: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93912: LD_ADDR_VAR 0 8
93916: PUSH
93917: LD_VAR 0 1
93921: PUSH
93922: LD_INT 1
93924: ARRAY
93925: PPUSH
93926: CALL_OW 255
93930: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93931: LD_ADDR_VAR 0 10
93935: PUSH
93936: LD_INT 29
93938: PUSH
93939: LD_INT 91
93941: PUSH
93942: LD_INT 49
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: LIST
93949: ST_TO_ADDR
// if not result then
93950: LD_VAR 0 3
93954: NOT
93955: IFFALSE 93959
// exit ;
93957: GO 94419
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93959: LD_ADDR_VAR 0 5
93963: PUSH
93964: LD_INT 81
93966: PUSH
93967: LD_VAR 0 8
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PPUSH
93976: CALL_OW 69
93980: ST_TO_ADDR
// for i in result do
93981: LD_ADDR_VAR 0 4
93985: PUSH
93986: LD_VAR 0 3
93990: PUSH
93991: FOR_IN
93992: IFFALSE 94417
// begin tag := GetTag ( i ) + 1 ;
93994: LD_ADDR_VAR 0 9
93998: PUSH
93999: LD_VAR 0 4
94003: PPUSH
94004: CALL_OW 110
94008: PUSH
94009: LD_INT 1
94011: PLUS
94012: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
94013: LD_ADDR_VAR 0 7
94017: PUSH
94018: LD_VAR 0 4
94022: PPUSH
94023: CALL_OW 250
94027: PPUSH
94028: LD_VAR 0 4
94032: PPUSH
94033: CALL_OW 251
94037: PPUSH
94038: LD_INT 4
94040: PPUSH
94041: CALL 93614 0 3
94045: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
94046: LD_VAR 0 4
94050: PPUSH
94051: CALL_OW 247
94055: PUSH
94056: LD_INT 2
94058: EQUAL
94059: PUSH
94060: LD_VAR 0 7
94064: PUSH
94065: LD_INT 2
94067: GREATER
94068: AND
94069: PUSH
94070: LD_VAR 0 4
94074: PPUSH
94075: CALL_OW 264
94079: PUSH
94080: LD_VAR 0 10
94084: IN
94085: NOT
94086: AND
94087: IFFALSE 94126
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
94089: LD_VAR 0 4
94093: PPUSH
94094: LD_VAR 0 7
94098: PUSH
94099: LD_INT 1
94101: ARRAY
94102: PUSH
94103: LD_INT 1
94105: ARRAY
94106: PPUSH
94107: LD_VAR 0 7
94111: PUSH
94112: LD_INT 1
94114: ARRAY
94115: PUSH
94116: LD_INT 2
94118: ARRAY
94119: PPUSH
94120: CALL_OW 116
94124: GO 94415
// if path > tag then
94126: LD_VAR 0 2
94130: PUSH
94131: LD_VAR 0 9
94135: GREATER
94136: IFFALSE 94344
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
94138: LD_ADDR_VAR 0 6
94142: PUSH
94143: LD_VAR 0 5
94147: PPUSH
94148: LD_INT 91
94150: PUSH
94151: LD_VAR 0 4
94155: PUSH
94156: LD_INT 8
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: LIST
94163: PPUSH
94164: CALL_OW 72
94168: ST_TO_ADDR
// if nearEnemy then
94169: LD_VAR 0 6
94173: IFFALSE 94242
// begin if GetWeapon ( i ) = ru_time_lapser then
94175: LD_VAR 0 4
94179: PPUSH
94180: CALL_OW 264
94184: PUSH
94185: LD_INT 49
94187: EQUAL
94188: IFFALSE 94216
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
94190: LD_VAR 0 4
94194: PPUSH
94195: LD_VAR 0 6
94199: PPUSH
94200: LD_VAR 0 4
94204: PPUSH
94205: CALL_OW 74
94209: PPUSH
94210: CALL_OW 112
94214: GO 94240
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
94216: LD_VAR 0 4
94220: PPUSH
94221: LD_VAR 0 6
94225: PPUSH
94226: LD_VAR 0 4
94230: PPUSH
94231: CALL_OW 74
94235: PPUSH
94236: CALL 95490 0 2
// end else
94240: GO 94342
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
94242: LD_VAR 0 4
94246: PPUSH
94247: LD_VAR 0 2
94251: PUSH
94252: LD_VAR 0 9
94256: ARRAY
94257: PUSH
94258: LD_INT 1
94260: ARRAY
94261: PPUSH
94262: LD_VAR 0 2
94266: PUSH
94267: LD_VAR 0 9
94271: ARRAY
94272: PUSH
94273: LD_INT 2
94275: ARRAY
94276: PPUSH
94277: CALL_OW 297
94281: PUSH
94282: LD_INT 6
94284: GREATER
94285: IFFALSE 94328
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
94287: LD_VAR 0 4
94291: PPUSH
94292: LD_VAR 0 2
94296: PUSH
94297: LD_VAR 0 9
94301: ARRAY
94302: PUSH
94303: LD_INT 1
94305: ARRAY
94306: PPUSH
94307: LD_VAR 0 2
94311: PUSH
94312: LD_VAR 0 9
94316: ARRAY
94317: PUSH
94318: LD_INT 2
94320: ARRAY
94321: PPUSH
94322: CALL_OW 114
94326: GO 94342
// SetTag ( i , tag ) ;
94328: LD_VAR 0 4
94332: PPUSH
94333: LD_VAR 0 9
94337: PPUSH
94338: CALL_OW 109
// end else
94342: GO 94415
// if enemy then
94344: LD_VAR 0 5
94348: IFFALSE 94415
// begin if GetWeapon ( i ) = ru_time_lapser then
94350: LD_VAR 0 4
94354: PPUSH
94355: CALL_OW 264
94359: PUSH
94360: LD_INT 49
94362: EQUAL
94363: IFFALSE 94391
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94365: LD_VAR 0 4
94369: PPUSH
94370: LD_VAR 0 5
94374: PPUSH
94375: LD_VAR 0 4
94379: PPUSH
94380: CALL_OW 74
94384: PPUSH
94385: CALL_OW 112
94389: GO 94415
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94391: LD_VAR 0 4
94395: PPUSH
94396: LD_VAR 0 5
94400: PPUSH
94401: LD_VAR 0 4
94405: PPUSH
94406: CALL_OW 74
94410: PPUSH
94411: CALL 95490 0 2
// end ; end ;
94415: GO 93991
94417: POP
94418: POP
// end ;
94419: LD_VAR 0 3
94423: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94424: LD_INT 0
94426: PPUSH
94427: PPUSH
94428: PPUSH
// if not unit or IsInUnit ( unit ) then
94429: LD_VAR 0 1
94433: NOT
94434: PUSH
94435: LD_VAR 0 1
94439: PPUSH
94440: CALL_OW 310
94444: OR
94445: IFFALSE 94449
// exit ;
94447: GO 94540
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94449: LD_ADDR_VAR 0 4
94453: PUSH
94454: LD_VAR 0 1
94458: PPUSH
94459: CALL_OW 250
94463: PPUSH
94464: LD_VAR 0 2
94468: PPUSH
94469: LD_INT 1
94471: PPUSH
94472: CALL_OW 272
94476: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94477: LD_ADDR_VAR 0 5
94481: PUSH
94482: LD_VAR 0 1
94486: PPUSH
94487: CALL_OW 251
94491: PPUSH
94492: LD_VAR 0 2
94496: PPUSH
94497: LD_INT 1
94499: PPUSH
94500: CALL_OW 273
94504: ST_TO_ADDR
// if ValidHex ( x , y ) then
94505: LD_VAR 0 4
94509: PPUSH
94510: LD_VAR 0 5
94514: PPUSH
94515: CALL_OW 488
94519: IFFALSE 94540
// ComTurnXY ( unit , x , y ) ;
94521: LD_VAR 0 1
94525: PPUSH
94526: LD_VAR 0 4
94530: PPUSH
94531: LD_VAR 0 5
94535: PPUSH
94536: CALL_OW 118
// end ;
94540: LD_VAR 0 3
94544: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94545: LD_INT 0
94547: PPUSH
94548: PPUSH
// result := false ;
94549: LD_ADDR_VAR 0 3
94553: PUSH
94554: LD_INT 0
94556: ST_TO_ADDR
// if not units then
94557: LD_VAR 0 2
94561: NOT
94562: IFFALSE 94566
// exit ;
94564: GO 94611
// for i in units do
94566: LD_ADDR_VAR 0 4
94570: PUSH
94571: LD_VAR 0 2
94575: PUSH
94576: FOR_IN
94577: IFFALSE 94609
// if See ( side , i ) then
94579: LD_VAR 0 1
94583: PPUSH
94584: LD_VAR 0 4
94588: PPUSH
94589: CALL_OW 292
94593: IFFALSE 94607
// begin result := true ;
94595: LD_ADDR_VAR 0 3
94599: PUSH
94600: LD_INT 1
94602: ST_TO_ADDR
// exit ;
94603: POP
94604: POP
94605: GO 94611
// end ;
94607: GO 94576
94609: POP
94610: POP
// end ;
94611: LD_VAR 0 3
94615: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94616: LD_INT 0
94618: PPUSH
94619: PPUSH
94620: PPUSH
94621: PPUSH
// if not unit or not points then
94622: LD_VAR 0 1
94626: NOT
94627: PUSH
94628: LD_VAR 0 2
94632: NOT
94633: OR
94634: IFFALSE 94638
// exit ;
94636: GO 94728
// dist := 99999 ;
94638: LD_ADDR_VAR 0 5
94642: PUSH
94643: LD_INT 99999
94645: ST_TO_ADDR
// for i in points do
94646: LD_ADDR_VAR 0 4
94650: PUSH
94651: LD_VAR 0 2
94655: PUSH
94656: FOR_IN
94657: IFFALSE 94726
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94659: LD_ADDR_VAR 0 6
94663: PUSH
94664: LD_VAR 0 1
94668: PPUSH
94669: LD_VAR 0 4
94673: PUSH
94674: LD_INT 1
94676: ARRAY
94677: PPUSH
94678: LD_VAR 0 4
94682: PUSH
94683: LD_INT 2
94685: ARRAY
94686: PPUSH
94687: CALL_OW 297
94691: ST_TO_ADDR
// if tmpDist < dist then
94692: LD_VAR 0 6
94696: PUSH
94697: LD_VAR 0 5
94701: LESS
94702: IFFALSE 94724
// begin result := i ;
94704: LD_ADDR_VAR 0 3
94708: PUSH
94709: LD_VAR 0 4
94713: ST_TO_ADDR
// dist := tmpDist ;
94714: LD_ADDR_VAR 0 5
94718: PUSH
94719: LD_VAR 0 6
94723: ST_TO_ADDR
// end ; end ;
94724: GO 94656
94726: POP
94727: POP
// end ;
94728: LD_VAR 0 3
94732: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94733: LD_INT 0
94735: PPUSH
// uc_side := side ;
94736: LD_ADDR_OWVAR 20
94740: PUSH
94741: LD_VAR 0 1
94745: ST_TO_ADDR
// uc_nation := 3 ;
94746: LD_ADDR_OWVAR 21
94750: PUSH
94751: LD_INT 3
94753: ST_TO_ADDR
// vc_chassis := 25 ;
94754: LD_ADDR_OWVAR 37
94758: PUSH
94759: LD_INT 25
94761: ST_TO_ADDR
// vc_engine := engine_siberite ;
94762: LD_ADDR_OWVAR 39
94766: PUSH
94767: LD_INT 3
94769: ST_TO_ADDR
// vc_control := control_computer ;
94770: LD_ADDR_OWVAR 38
94774: PUSH
94775: LD_INT 3
94777: ST_TO_ADDR
// vc_weapon := 59 ;
94778: LD_ADDR_OWVAR 40
94782: PUSH
94783: LD_INT 59
94785: ST_TO_ADDR
// result := CreateVehicle ;
94786: LD_ADDR_VAR 0 5
94790: PUSH
94791: CALL_OW 45
94795: ST_TO_ADDR
// SetDir ( result , d ) ;
94796: LD_VAR 0 5
94800: PPUSH
94801: LD_VAR 0 4
94805: PPUSH
94806: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94810: LD_VAR 0 5
94814: PPUSH
94815: LD_VAR 0 2
94819: PPUSH
94820: LD_VAR 0 3
94824: PPUSH
94825: LD_INT 0
94827: PPUSH
94828: CALL_OW 48
// end ;
94832: LD_VAR 0 5
94836: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94837: LD_INT 0
94839: PPUSH
94840: PPUSH
94841: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94842: LD_ADDR_VAR 0 2
94846: PUSH
94847: LD_INT 0
94849: PUSH
94850: LD_INT 0
94852: PUSH
94853: LD_INT 0
94855: PUSH
94856: LD_INT 0
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94865: LD_VAR 0 1
94869: NOT
94870: PUSH
94871: LD_VAR 0 1
94875: PPUSH
94876: CALL_OW 264
94880: PUSH
94881: LD_INT 12
94883: PUSH
94884: LD_INT 51
94886: PUSH
94887: LD_INT 32
94889: PUSH
94890: LD_INT 89
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: IN
94899: NOT
94900: OR
94901: IFFALSE 94905
// exit ;
94903: GO 95003
// for i := 1 to 3 do
94905: LD_ADDR_VAR 0 3
94909: PUSH
94910: DOUBLE
94911: LD_INT 1
94913: DEC
94914: ST_TO_ADDR
94915: LD_INT 3
94917: PUSH
94918: FOR_TO
94919: IFFALSE 95001
// begin tmp := GetCargo ( cargo , i ) ;
94921: LD_ADDR_VAR 0 4
94925: PUSH
94926: LD_VAR 0 1
94930: PPUSH
94931: LD_VAR 0 3
94935: PPUSH
94936: CALL_OW 289
94940: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94941: LD_ADDR_VAR 0 2
94945: PUSH
94946: LD_VAR 0 2
94950: PPUSH
94951: LD_VAR 0 3
94955: PPUSH
94956: LD_VAR 0 4
94960: PPUSH
94961: CALL_OW 1
94965: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94966: LD_ADDR_VAR 0 2
94970: PUSH
94971: LD_VAR 0 2
94975: PPUSH
94976: LD_INT 4
94978: PPUSH
94979: LD_VAR 0 2
94983: PUSH
94984: LD_INT 4
94986: ARRAY
94987: PUSH
94988: LD_VAR 0 4
94992: PLUS
94993: PPUSH
94994: CALL_OW 1
94998: ST_TO_ADDR
// end ;
94999: GO 94918
95001: POP
95002: POP
// end ;
95003: LD_VAR 0 2
95007: RET
// export function Length ( array ) ; begin
95008: LD_INT 0
95010: PPUSH
// result := array + 0 ;
95011: LD_ADDR_VAR 0 2
95015: PUSH
95016: LD_VAR 0 1
95020: PUSH
95021: LD_INT 0
95023: PLUS
95024: ST_TO_ADDR
// end ;
95025: LD_VAR 0 2
95029: RET
// export function PrepareArray ( array ) ; begin
95030: LD_INT 0
95032: PPUSH
// result := array diff 0 ;
95033: LD_ADDR_VAR 0 2
95037: PUSH
95038: LD_VAR 0 1
95042: PUSH
95043: LD_INT 0
95045: DIFF
95046: ST_TO_ADDR
// if not result [ 1 ] then
95047: LD_VAR 0 2
95051: PUSH
95052: LD_INT 1
95054: ARRAY
95055: NOT
95056: IFFALSE 95076
// result := Delete ( result , 1 ) ;
95058: LD_ADDR_VAR 0 2
95062: PUSH
95063: LD_VAR 0 2
95067: PPUSH
95068: LD_INT 1
95070: PPUSH
95071: CALL_OW 3
95075: ST_TO_ADDR
// end ;
95076: LD_VAR 0 2
95080: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
95081: LD_INT 0
95083: PPUSH
95084: PPUSH
95085: PPUSH
95086: PPUSH
// sibRocketRange := 25 ;
95087: LD_ADDR_VAR 0 6
95091: PUSH
95092: LD_INT 25
95094: ST_TO_ADDR
// result := false ;
95095: LD_ADDR_VAR 0 4
95099: PUSH
95100: LD_INT 0
95102: ST_TO_ADDR
// for i := 0 to 5 do
95103: LD_ADDR_VAR 0 5
95107: PUSH
95108: DOUBLE
95109: LD_INT 0
95111: DEC
95112: ST_TO_ADDR
95113: LD_INT 5
95115: PUSH
95116: FOR_TO
95117: IFFALSE 95184
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
95119: LD_VAR 0 1
95123: PPUSH
95124: LD_VAR 0 5
95128: PPUSH
95129: LD_VAR 0 6
95133: PPUSH
95134: CALL_OW 272
95138: PPUSH
95139: LD_VAR 0 2
95143: PPUSH
95144: LD_VAR 0 5
95148: PPUSH
95149: LD_VAR 0 6
95153: PPUSH
95154: CALL_OW 273
95158: PPUSH
95159: LD_VAR 0 3
95163: PPUSH
95164: CALL_OW 309
95168: IFFALSE 95182
// begin result := true ;
95170: LD_ADDR_VAR 0 4
95174: PUSH
95175: LD_INT 1
95177: ST_TO_ADDR
// exit ;
95178: POP
95179: POP
95180: GO 95186
// end ;
95182: GO 95116
95184: POP
95185: POP
// end ;
95186: LD_VAR 0 4
95190: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
95191: LD_INT 0
95193: PPUSH
95194: PPUSH
95195: PPUSH
// if btype = b_depot then
95196: LD_VAR 0 2
95200: PUSH
95201: LD_INT 0
95203: EQUAL
95204: IFFALSE 95216
// begin result := true ;
95206: LD_ADDR_VAR 0 3
95210: PUSH
95211: LD_INT 1
95213: ST_TO_ADDR
// exit ;
95214: GO 95332
// end ; pom := GetBase ( depot ) ;
95216: LD_ADDR_VAR 0 4
95220: PUSH
95221: LD_VAR 0 1
95225: PPUSH
95226: CALL_OW 274
95230: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
95231: LD_ADDR_VAR 0 5
95235: PUSH
95236: LD_VAR 0 2
95240: PPUSH
95241: LD_VAR 0 1
95245: PPUSH
95246: CALL_OW 248
95250: PPUSH
95251: CALL_OW 450
95255: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
95256: LD_ADDR_VAR 0 3
95260: PUSH
95261: LD_VAR 0 4
95265: PPUSH
95266: LD_INT 1
95268: PPUSH
95269: CALL_OW 275
95273: PUSH
95274: LD_VAR 0 5
95278: PUSH
95279: LD_INT 1
95281: ARRAY
95282: GREATEREQUAL
95283: PUSH
95284: LD_VAR 0 4
95288: PPUSH
95289: LD_INT 2
95291: PPUSH
95292: CALL_OW 275
95296: PUSH
95297: LD_VAR 0 5
95301: PUSH
95302: LD_INT 2
95304: ARRAY
95305: GREATEREQUAL
95306: AND
95307: PUSH
95308: LD_VAR 0 4
95312: PPUSH
95313: LD_INT 3
95315: PPUSH
95316: CALL_OW 275
95320: PUSH
95321: LD_VAR 0 5
95325: PUSH
95326: LD_INT 3
95328: ARRAY
95329: GREATEREQUAL
95330: AND
95331: ST_TO_ADDR
// end ;
95332: LD_VAR 0 3
95336: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
95337: LD_INT 0
95339: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
95340: LD_VAR 0 1
95344: PPUSH
95345: LD_VAR 0 2
95349: PPUSH
95350: LD_INT 0
95352: PPUSH
95353: LD_INT 0
95355: PPUSH
95356: LD_INT 1
95358: PPUSH
95359: LD_INT 0
95361: PPUSH
95362: CALL_OW 587
// end ;
95366: LD_VAR 0 3
95370: RET
// export function CenterOnNow ( unit ) ; begin
95371: LD_INT 0
95373: PPUSH
// result := IsInUnit ( unit ) ;
95374: LD_ADDR_VAR 0 2
95378: PUSH
95379: LD_VAR 0 1
95383: PPUSH
95384: CALL_OW 310
95388: ST_TO_ADDR
// if not result then
95389: LD_VAR 0 2
95393: NOT
95394: IFFALSE 95406
// result := unit ;
95396: LD_ADDR_VAR 0 2
95400: PUSH
95401: LD_VAR 0 1
95405: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
95406: LD_VAR 0 1
95410: PPUSH
95411: CALL_OW 87
// end ;
95415: LD_VAR 0 2
95419: RET
// export function ComMoveHex ( unit , hex ) ; begin
95420: LD_INT 0
95422: PPUSH
// if not hex then
95423: LD_VAR 0 2
95427: NOT
95428: IFFALSE 95432
// exit ;
95430: GO 95485
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
95432: LD_VAR 0 2
95436: PUSH
95437: LD_INT 1
95439: ARRAY
95440: PPUSH
95441: LD_VAR 0 2
95445: PUSH
95446: LD_INT 2
95448: ARRAY
95449: PPUSH
95450: CALL_OW 428
95454: IFFALSE 95458
// exit ;
95456: GO 95485
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95458: LD_VAR 0 1
95462: PPUSH
95463: LD_VAR 0 2
95467: PUSH
95468: LD_INT 1
95470: ARRAY
95471: PPUSH
95472: LD_VAR 0 2
95476: PUSH
95477: LD_INT 2
95479: ARRAY
95480: PPUSH
95481: CALL_OW 111
// end ;
95485: LD_VAR 0 3
95489: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95490: LD_INT 0
95492: PPUSH
95493: PPUSH
95494: PPUSH
// if not unit or not enemy then
95495: LD_VAR 0 1
95499: NOT
95500: PUSH
95501: LD_VAR 0 2
95505: NOT
95506: OR
95507: IFFALSE 95511
// exit ;
95509: GO 95635
// x := GetX ( enemy ) ;
95511: LD_ADDR_VAR 0 4
95515: PUSH
95516: LD_VAR 0 2
95520: PPUSH
95521: CALL_OW 250
95525: ST_TO_ADDR
// y := GetY ( enemy ) ;
95526: LD_ADDR_VAR 0 5
95530: PUSH
95531: LD_VAR 0 2
95535: PPUSH
95536: CALL_OW 251
95540: ST_TO_ADDR
// if ValidHex ( x , y ) then
95541: LD_VAR 0 4
95545: PPUSH
95546: LD_VAR 0 5
95550: PPUSH
95551: CALL_OW 488
95555: IFFALSE 95635
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
95557: LD_VAR 0 2
95561: PPUSH
95562: CALL_OW 247
95566: PUSH
95567: LD_INT 3
95569: PUSH
95570: LD_INT 2
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: IN
95577: PUSH
95578: LD_VAR 0 1
95582: PPUSH
95583: CALL_OW 255
95587: PPUSH
95588: LD_VAR 0 2
95592: PPUSH
95593: CALL_OW 292
95597: OR
95598: IFFALSE 95616
// ComAttackUnit ( unit , enemy ) else
95600: LD_VAR 0 1
95604: PPUSH
95605: LD_VAR 0 2
95609: PPUSH
95610: CALL_OW 115
95614: GO 95635
// ComAgressiveMove ( unit , x , y ) ;
95616: LD_VAR 0 1
95620: PPUSH
95621: LD_VAR 0 4
95625: PPUSH
95626: LD_VAR 0 5
95630: PPUSH
95631: CALL_OW 114
// end ;
95635: LD_VAR 0 3
95639: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95640: LD_INT 0
95642: PPUSH
95643: PPUSH
95644: PPUSH
// list := AreaToList ( area , 0 ) ;
95645: LD_ADDR_VAR 0 5
95649: PUSH
95650: LD_VAR 0 1
95654: PPUSH
95655: LD_INT 0
95657: PPUSH
95658: CALL_OW 517
95662: ST_TO_ADDR
// if not list then
95663: LD_VAR 0 5
95667: NOT
95668: IFFALSE 95672
// exit ;
95670: GO 95802
// if all then
95672: LD_VAR 0 2
95676: IFFALSE 95764
// begin for i := 1 to list [ 1 ] do
95678: LD_ADDR_VAR 0 4
95682: PUSH
95683: DOUBLE
95684: LD_INT 1
95686: DEC
95687: ST_TO_ADDR
95688: LD_VAR 0 5
95692: PUSH
95693: LD_INT 1
95695: ARRAY
95696: PUSH
95697: FOR_TO
95698: IFFALSE 95760
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95700: LD_ADDR_VAR 0 3
95704: PUSH
95705: LD_VAR 0 3
95709: PPUSH
95710: LD_VAR 0 3
95714: PUSH
95715: LD_INT 1
95717: PLUS
95718: PPUSH
95719: LD_VAR 0 5
95723: PUSH
95724: LD_INT 1
95726: ARRAY
95727: PUSH
95728: LD_VAR 0 4
95732: ARRAY
95733: PUSH
95734: LD_VAR 0 5
95738: PUSH
95739: LD_INT 2
95741: ARRAY
95742: PUSH
95743: LD_VAR 0 4
95747: ARRAY
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PPUSH
95753: CALL_OW 1
95757: ST_TO_ADDR
95758: GO 95697
95760: POP
95761: POP
// exit ;
95762: GO 95802
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
95764: LD_ADDR_VAR 0 3
95768: PUSH
95769: LD_VAR 0 5
95773: PUSH
95774: LD_INT 1
95776: ARRAY
95777: PUSH
95778: LD_INT 1
95780: ARRAY
95781: PUSH
95782: LD_VAR 0 5
95786: PUSH
95787: LD_INT 2
95789: ARRAY
95790: PUSH
95791: LD_INT 1
95793: ARRAY
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: EMPTY
95800: LIST
95801: ST_TO_ADDR
// end ;
95802: LD_VAR 0 3
95806: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
95807: LD_INT 0
95809: PPUSH
95810: PPUSH
// list := AreaToList ( area , 0 ) ;
95811: LD_ADDR_VAR 0 4
95815: PUSH
95816: LD_VAR 0 1
95820: PPUSH
95821: LD_INT 0
95823: PPUSH
95824: CALL_OW 517
95828: ST_TO_ADDR
// if not list then
95829: LD_VAR 0 4
95833: NOT
95834: IFFALSE 95838
// exit ;
95836: GO 95879
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95838: LD_ADDR_VAR 0 3
95842: PUSH
95843: LD_VAR 0 4
95847: PUSH
95848: LD_INT 1
95850: ARRAY
95851: PUSH
95852: LD_INT 1
95854: ARRAY
95855: PUSH
95856: LD_VAR 0 4
95860: PUSH
95861: LD_INT 2
95863: ARRAY
95864: PUSH
95865: LD_INT 1
95867: ARRAY
95868: PUSH
95869: LD_VAR 0 2
95873: PUSH
95874: EMPTY
95875: LIST
95876: LIST
95877: LIST
95878: ST_TO_ADDR
// end ;
95879: LD_VAR 0 3
95883: RET
// export function First ( array ) ; begin
95884: LD_INT 0
95886: PPUSH
// if not array then
95887: LD_VAR 0 1
95891: NOT
95892: IFFALSE 95896
// exit ;
95894: GO 95910
// result := array [ 1 ] ;
95896: LD_ADDR_VAR 0 2
95900: PUSH
95901: LD_VAR 0 1
95905: PUSH
95906: LD_INT 1
95908: ARRAY
95909: ST_TO_ADDR
// end ;
95910: LD_VAR 0 2
95914: RET
// export function Last ( array ) ; begin
95915: LD_INT 0
95917: PPUSH
// if not array then
95918: LD_VAR 0 1
95922: NOT
95923: IFFALSE 95927
// exit ;
95925: GO 95943
// result := array [ array ] ;
95927: LD_ADDR_VAR 0 2
95931: PUSH
95932: LD_VAR 0 1
95936: PUSH
95937: LD_VAR 0 1
95941: ARRAY
95942: ST_TO_ADDR
// end ;
95943: LD_VAR 0 2
95947: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
95948: LD_INT 0
95950: PPUSH
95951: PPUSH
// result := [ ] ;
95952: LD_ADDR_VAR 0 5
95956: PUSH
95957: EMPTY
95958: ST_TO_ADDR
// if not array then
95959: LD_VAR 0 1
95963: NOT
95964: IFFALSE 95968
// exit ;
95966: GO 96080
// for i := 1 to array do
95968: LD_ADDR_VAR 0 6
95972: PUSH
95973: DOUBLE
95974: LD_INT 1
95976: DEC
95977: ST_TO_ADDR
95978: LD_VAR 0 1
95982: PUSH
95983: FOR_TO
95984: IFFALSE 96078
// if array [ i ] [ index ] = value then
95986: LD_VAR 0 1
95990: PUSH
95991: LD_VAR 0 6
95995: ARRAY
95996: PUSH
95997: LD_VAR 0 2
96001: ARRAY
96002: PUSH
96003: LD_VAR 0 3
96007: EQUAL
96008: IFFALSE 96076
// begin if indexColumn then
96010: LD_VAR 0 4
96014: IFFALSE 96050
// result := Join ( result , array [ i ] [ indexColumn ] ) else
96016: LD_ADDR_VAR 0 5
96020: PUSH
96021: LD_VAR 0 5
96025: PPUSH
96026: LD_VAR 0 1
96030: PUSH
96031: LD_VAR 0 6
96035: ARRAY
96036: PUSH
96037: LD_VAR 0 4
96041: ARRAY
96042: PPUSH
96043: CALL 91268 0 2
96047: ST_TO_ADDR
96048: GO 96076
// result := Join ( result , array [ i ] ) ;
96050: LD_ADDR_VAR 0 5
96054: PUSH
96055: LD_VAR 0 5
96059: PPUSH
96060: LD_VAR 0 1
96064: PUSH
96065: LD_VAR 0 6
96069: ARRAY
96070: PPUSH
96071: CALL 91268 0 2
96075: ST_TO_ADDR
// end ;
96076: GO 95983
96078: POP
96079: POP
// end ;
96080: LD_VAR 0 5
96084: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
96085: LD_INT 0
96087: PPUSH
// if not vehicles or not parkingPoint then
96088: LD_VAR 0 1
96092: NOT
96093: PUSH
96094: LD_VAR 0 2
96098: NOT
96099: OR
96100: IFFALSE 96104
// exit ;
96102: GO 96202
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
96104: LD_ADDR_VAR 0 1
96108: PUSH
96109: LD_VAR 0 1
96113: PPUSH
96114: LD_INT 50
96116: PUSH
96117: EMPTY
96118: LIST
96119: PUSH
96120: LD_INT 3
96122: PUSH
96123: LD_INT 92
96125: PUSH
96126: LD_VAR 0 2
96130: PUSH
96131: LD_INT 1
96133: ARRAY
96134: PUSH
96135: LD_VAR 0 2
96139: PUSH
96140: LD_INT 2
96142: ARRAY
96143: PUSH
96144: LD_INT 8
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PPUSH
96161: CALL_OW 72
96165: ST_TO_ADDR
// if not vehicles then
96166: LD_VAR 0 1
96170: NOT
96171: IFFALSE 96175
// exit ;
96173: GO 96202
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
96175: LD_VAR 0 1
96179: PPUSH
96180: LD_VAR 0 2
96184: PUSH
96185: LD_INT 1
96187: ARRAY
96188: PPUSH
96189: LD_VAR 0 2
96193: PUSH
96194: LD_INT 2
96196: ARRAY
96197: PPUSH
96198: CALL_OW 111
// end ;
96202: LD_VAR 0 3
96206: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
96207: LD_INT 0
96209: PPUSH
96210: PPUSH
96211: PPUSH
// if not side or not area then
96212: LD_VAR 0 1
96216: NOT
96217: PUSH
96218: LD_VAR 0 2
96222: NOT
96223: OR
96224: IFFALSE 96228
// exit ;
96226: GO 96347
// tmp := AreaToList ( area , 0 ) ;
96228: LD_ADDR_VAR 0 5
96232: PUSH
96233: LD_VAR 0 2
96237: PPUSH
96238: LD_INT 0
96240: PPUSH
96241: CALL_OW 517
96245: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
96246: LD_ADDR_VAR 0 4
96250: PUSH
96251: DOUBLE
96252: LD_INT 1
96254: DEC
96255: ST_TO_ADDR
96256: LD_VAR 0 5
96260: PUSH
96261: LD_INT 1
96263: ARRAY
96264: PUSH
96265: FOR_TO
96266: IFFALSE 96345
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
96268: LD_VAR 0 5
96272: PUSH
96273: LD_INT 1
96275: ARRAY
96276: PUSH
96277: LD_VAR 0 4
96281: ARRAY
96282: PPUSH
96283: LD_VAR 0 5
96287: PUSH
96288: LD_INT 2
96290: ARRAY
96291: PUSH
96292: LD_VAR 0 4
96296: ARRAY
96297: PPUSH
96298: CALL_OW 351
96302: IFFALSE 96343
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
96304: LD_VAR 0 5
96308: PUSH
96309: LD_INT 1
96311: ARRAY
96312: PUSH
96313: LD_VAR 0 4
96317: ARRAY
96318: PPUSH
96319: LD_VAR 0 5
96323: PUSH
96324: LD_INT 2
96326: ARRAY
96327: PUSH
96328: LD_VAR 0 4
96332: ARRAY
96333: PPUSH
96334: LD_VAR 0 1
96338: PPUSH
96339: CALL_OW 244
// end ;
96343: GO 96265
96345: POP
96346: POP
// end ; end_of_file end_of_file
96347: LD_VAR 0 3
96351: RET
// export globalGameSaveCounter ; every 0 0$1 do
96352: GO 96354
96354: DISABLE
// begin enable ;
96355: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96356: LD_STRING updateTimer(
96358: PUSH
96359: LD_OWVAR 1
96363: STR
96364: PUSH
96365: LD_STRING );
96367: STR
96368: PPUSH
96369: CALL_OW 559
// end ;
96373: END
// every 0 0$1 do
96374: GO 96376
96376: DISABLE
// begin globalGameSaveCounter := 0 ;
96377: LD_ADDR_EXP 125
96381: PUSH
96382: LD_INT 0
96384: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96385: LD_STRING setGameSaveCounter(0)
96387: PPUSH
96388: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96392: LD_STRING initStreamRollete();
96394: PPUSH
96395: CALL_OW 559
// InitStreamMode ;
96399: CALL 97742 0 0
// DefineStreamItems ( false ) ;
96403: LD_INT 0
96405: PPUSH
96406: CALL 98206 0 1
// end ;
96410: END
// export function SOS_MapStart ( ) ; begin
96411: LD_INT 0
96413: PPUSH
// if streamModeActive then
96414: LD_EXP 126
96418: IFFALSE 96427
// DefineStreamItems ( true ) ;
96420: LD_INT 1
96422: PPUSH
96423: CALL 98206 0 1
// UpdateLuaVariables ( ) ;
96427: CALL 96444 0 0
// UpdateFactoryWaypoints ( ) ;
96431: CALL 111075 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96435: CALL 111332 0 0
// end ;
96439: LD_VAR 0 1
96443: RET
// function UpdateLuaVariables ( ) ; begin
96444: LD_INT 0
96446: PPUSH
// if globalGameSaveCounter then
96447: LD_EXP 125
96451: IFFALSE 96485
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96453: LD_ADDR_EXP 125
96457: PUSH
96458: LD_EXP 125
96462: PPUSH
96463: CALL 92629 0 1
96467: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96468: LD_STRING setGameSaveCounter(
96470: PUSH
96471: LD_EXP 125
96475: STR
96476: PUSH
96477: LD_STRING )
96479: STR
96480: PPUSH
96481: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96485: LD_STRING setGameDifficulty(
96487: PUSH
96488: LD_OWVAR 67
96492: STR
96493: PUSH
96494: LD_STRING )
96496: STR
96497: PPUSH
96498: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
96502: LD_STRING displayDifficulty(
96504: PUSH
96505: LD_OWVAR 67
96509: STR
96510: PUSH
96511: LD_STRING )
96513: STR
96514: PPUSH
96515: CALL_OW 559
// end ;
96519: LD_VAR 0 1
96523: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96524: LD_INT 0
96526: PPUSH
// if p2 = stream_mode then
96527: LD_VAR 0 2
96531: PUSH
96532: LD_INT 100
96534: EQUAL
96535: IFFALSE 97538
// begin if not StreamModeActive then
96537: LD_EXP 126
96541: NOT
96542: IFFALSE 96552
// StreamModeActive := true ;
96544: LD_ADDR_EXP 126
96548: PUSH
96549: LD_INT 1
96551: ST_TO_ADDR
// if p3 = 0 then
96552: LD_VAR 0 3
96556: PUSH
96557: LD_INT 0
96559: EQUAL
96560: IFFALSE 96566
// InitStreamMode ;
96562: CALL 97742 0 0
// if p3 = 1 then
96566: LD_VAR 0 3
96570: PUSH
96571: LD_INT 1
96573: EQUAL
96574: IFFALSE 96584
// sRocket := true ;
96576: LD_ADDR_EXP 131
96580: PUSH
96581: LD_INT 1
96583: ST_TO_ADDR
// if p3 = 2 then
96584: LD_VAR 0 3
96588: PUSH
96589: LD_INT 2
96591: EQUAL
96592: IFFALSE 96602
// sSpeed := true ;
96594: LD_ADDR_EXP 130
96598: PUSH
96599: LD_INT 1
96601: ST_TO_ADDR
// if p3 = 3 then
96602: LD_VAR 0 3
96606: PUSH
96607: LD_INT 3
96609: EQUAL
96610: IFFALSE 96620
// sEngine := true ;
96612: LD_ADDR_EXP 132
96616: PUSH
96617: LD_INT 1
96619: ST_TO_ADDR
// if p3 = 4 then
96620: LD_VAR 0 3
96624: PUSH
96625: LD_INT 4
96627: EQUAL
96628: IFFALSE 96638
// sSpec := true ;
96630: LD_ADDR_EXP 129
96634: PUSH
96635: LD_INT 1
96637: ST_TO_ADDR
// if p3 = 5 then
96638: LD_VAR 0 3
96642: PUSH
96643: LD_INT 5
96645: EQUAL
96646: IFFALSE 96656
// sLevel := true ;
96648: LD_ADDR_EXP 133
96652: PUSH
96653: LD_INT 1
96655: ST_TO_ADDR
// if p3 = 6 then
96656: LD_VAR 0 3
96660: PUSH
96661: LD_INT 6
96663: EQUAL
96664: IFFALSE 96674
// sArmoury := true ;
96666: LD_ADDR_EXP 134
96670: PUSH
96671: LD_INT 1
96673: ST_TO_ADDR
// if p3 = 7 then
96674: LD_VAR 0 3
96678: PUSH
96679: LD_INT 7
96681: EQUAL
96682: IFFALSE 96692
// sRadar := true ;
96684: LD_ADDR_EXP 135
96688: PUSH
96689: LD_INT 1
96691: ST_TO_ADDR
// if p3 = 8 then
96692: LD_VAR 0 3
96696: PUSH
96697: LD_INT 8
96699: EQUAL
96700: IFFALSE 96710
// sBunker := true ;
96702: LD_ADDR_EXP 136
96706: PUSH
96707: LD_INT 1
96709: ST_TO_ADDR
// if p3 = 9 then
96710: LD_VAR 0 3
96714: PUSH
96715: LD_INT 9
96717: EQUAL
96718: IFFALSE 96728
// sHack := true ;
96720: LD_ADDR_EXP 137
96724: PUSH
96725: LD_INT 1
96727: ST_TO_ADDR
// if p3 = 10 then
96728: LD_VAR 0 3
96732: PUSH
96733: LD_INT 10
96735: EQUAL
96736: IFFALSE 96746
// sFire := true ;
96738: LD_ADDR_EXP 138
96742: PUSH
96743: LD_INT 1
96745: ST_TO_ADDR
// if p3 = 11 then
96746: LD_VAR 0 3
96750: PUSH
96751: LD_INT 11
96753: EQUAL
96754: IFFALSE 96764
// sRefresh := true ;
96756: LD_ADDR_EXP 139
96760: PUSH
96761: LD_INT 1
96763: ST_TO_ADDR
// if p3 = 12 then
96764: LD_VAR 0 3
96768: PUSH
96769: LD_INT 12
96771: EQUAL
96772: IFFALSE 96782
// sExp := true ;
96774: LD_ADDR_EXP 140
96778: PUSH
96779: LD_INT 1
96781: ST_TO_ADDR
// if p3 = 13 then
96782: LD_VAR 0 3
96786: PUSH
96787: LD_INT 13
96789: EQUAL
96790: IFFALSE 96800
// sDepot := true ;
96792: LD_ADDR_EXP 141
96796: PUSH
96797: LD_INT 1
96799: ST_TO_ADDR
// if p3 = 14 then
96800: LD_VAR 0 3
96804: PUSH
96805: LD_INT 14
96807: EQUAL
96808: IFFALSE 96818
// sFlag := true ;
96810: LD_ADDR_EXP 142
96814: PUSH
96815: LD_INT 1
96817: ST_TO_ADDR
// if p3 = 15 then
96818: LD_VAR 0 3
96822: PUSH
96823: LD_INT 15
96825: EQUAL
96826: IFFALSE 96836
// sKamikadze := true ;
96828: LD_ADDR_EXP 150
96832: PUSH
96833: LD_INT 1
96835: ST_TO_ADDR
// if p3 = 16 then
96836: LD_VAR 0 3
96840: PUSH
96841: LD_INT 16
96843: EQUAL
96844: IFFALSE 96854
// sTroll := true ;
96846: LD_ADDR_EXP 151
96850: PUSH
96851: LD_INT 1
96853: ST_TO_ADDR
// if p3 = 17 then
96854: LD_VAR 0 3
96858: PUSH
96859: LD_INT 17
96861: EQUAL
96862: IFFALSE 96872
// sSlow := true ;
96864: LD_ADDR_EXP 152
96868: PUSH
96869: LD_INT 1
96871: ST_TO_ADDR
// if p3 = 18 then
96872: LD_VAR 0 3
96876: PUSH
96877: LD_INT 18
96879: EQUAL
96880: IFFALSE 96890
// sLack := true ;
96882: LD_ADDR_EXP 153
96886: PUSH
96887: LD_INT 1
96889: ST_TO_ADDR
// if p3 = 19 then
96890: LD_VAR 0 3
96894: PUSH
96895: LD_INT 19
96897: EQUAL
96898: IFFALSE 96908
// sTank := true ;
96900: LD_ADDR_EXP 155
96904: PUSH
96905: LD_INT 1
96907: ST_TO_ADDR
// if p3 = 20 then
96908: LD_VAR 0 3
96912: PUSH
96913: LD_INT 20
96915: EQUAL
96916: IFFALSE 96926
// sRemote := true ;
96918: LD_ADDR_EXP 156
96922: PUSH
96923: LD_INT 1
96925: ST_TO_ADDR
// if p3 = 21 then
96926: LD_VAR 0 3
96930: PUSH
96931: LD_INT 21
96933: EQUAL
96934: IFFALSE 96944
// sPowell := true ;
96936: LD_ADDR_EXP 157
96940: PUSH
96941: LD_INT 1
96943: ST_TO_ADDR
// if p3 = 22 then
96944: LD_VAR 0 3
96948: PUSH
96949: LD_INT 22
96951: EQUAL
96952: IFFALSE 96962
// sTeleport := true ;
96954: LD_ADDR_EXP 160
96958: PUSH
96959: LD_INT 1
96961: ST_TO_ADDR
// if p3 = 23 then
96962: LD_VAR 0 3
96966: PUSH
96967: LD_INT 23
96969: EQUAL
96970: IFFALSE 96980
// sOilTower := true ;
96972: LD_ADDR_EXP 162
96976: PUSH
96977: LD_INT 1
96979: ST_TO_ADDR
// if p3 = 24 then
96980: LD_VAR 0 3
96984: PUSH
96985: LD_INT 24
96987: EQUAL
96988: IFFALSE 96998
// sShovel := true ;
96990: LD_ADDR_EXP 163
96994: PUSH
96995: LD_INT 1
96997: ST_TO_ADDR
// if p3 = 25 then
96998: LD_VAR 0 3
97002: PUSH
97003: LD_INT 25
97005: EQUAL
97006: IFFALSE 97016
// sSheik := true ;
97008: LD_ADDR_EXP 164
97012: PUSH
97013: LD_INT 1
97015: ST_TO_ADDR
// if p3 = 26 then
97016: LD_VAR 0 3
97020: PUSH
97021: LD_INT 26
97023: EQUAL
97024: IFFALSE 97034
// sEarthquake := true ;
97026: LD_ADDR_EXP 166
97030: PUSH
97031: LD_INT 1
97033: ST_TO_ADDR
// if p3 = 27 then
97034: LD_VAR 0 3
97038: PUSH
97039: LD_INT 27
97041: EQUAL
97042: IFFALSE 97052
// sAI := true ;
97044: LD_ADDR_EXP 167
97048: PUSH
97049: LD_INT 1
97051: ST_TO_ADDR
// if p3 = 28 then
97052: LD_VAR 0 3
97056: PUSH
97057: LD_INT 28
97059: EQUAL
97060: IFFALSE 97070
// sCargo := true ;
97062: LD_ADDR_EXP 170
97066: PUSH
97067: LD_INT 1
97069: ST_TO_ADDR
// if p3 = 29 then
97070: LD_VAR 0 3
97074: PUSH
97075: LD_INT 29
97077: EQUAL
97078: IFFALSE 97088
// sDLaser := true ;
97080: LD_ADDR_EXP 171
97084: PUSH
97085: LD_INT 1
97087: ST_TO_ADDR
// if p3 = 30 then
97088: LD_VAR 0 3
97092: PUSH
97093: LD_INT 30
97095: EQUAL
97096: IFFALSE 97106
// sExchange := true ;
97098: LD_ADDR_EXP 172
97102: PUSH
97103: LD_INT 1
97105: ST_TO_ADDR
// if p3 = 31 then
97106: LD_VAR 0 3
97110: PUSH
97111: LD_INT 31
97113: EQUAL
97114: IFFALSE 97124
// sFac := true ;
97116: LD_ADDR_EXP 173
97120: PUSH
97121: LD_INT 1
97123: ST_TO_ADDR
// if p3 = 32 then
97124: LD_VAR 0 3
97128: PUSH
97129: LD_INT 32
97131: EQUAL
97132: IFFALSE 97142
// sPower := true ;
97134: LD_ADDR_EXP 174
97138: PUSH
97139: LD_INT 1
97141: ST_TO_ADDR
// if p3 = 33 then
97142: LD_VAR 0 3
97146: PUSH
97147: LD_INT 33
97149: EQUAL
97150: IFFALSE 97160
// sRandom := true ;
97152: LD_ADDR_EXP 175
97156: PUSH
97157: LD_INT 1
97159: ST_TO_ADDR
// if p3 = 34 then
97160: LD_VAR 0 3
97164: PUSH
97165: LD_INT 34
97167: EQUAL
97168: IFFALSE 97178
// sShield := true ;
97170: LD_ADDR_EXP 176
97174: PUSH
97175: LD_INT 1
97177: ST_TO_ADDR
// if p3 = 35 then
97178: LD_VAR 0 3
97182: PUSH
97183: LD_INT 35
97185: EQUAL
97186: IFFALSE 97196
// sTime := true ;
97188: LD_ADDR_EXP 177
97192: PUSH
97193: LD_INT 1
97195: ST_TO_ADDR
// if p3 = 36 then
97196: LD_VAR 0 3
97200: PUSH
97201: LD_INT 36
97203: EQUAL
97204: IFFALSE 97214
// sTools := true ;
97206: LD_ADDR_EXP 178
97210: PUSH
97211: LD_INT 1
97213: ST_TO_ADDR
// if p3 = 101 then
97214: LD_VAR 0 3
97218: PUSH
97219: LD_INT 101
97221: EQUAL
97222: IFFALSE 97232
// sSold := true ;
97224: LD_ADDR_EXP 143
97228: PUSH
97229: LD_INT 1
97231: ST_TO_ADDR
// if p3 = 102 then
97232: LD_VAR 0 3
97236: PUSH
97237: LD_INT 102
97239: EQUAL
97240: IFFALSE 97250
// sDiff := true ;
97242: LD_ADDR_EXP 144
97246: PUSH
97247: LD_INT 1
97249: ST_TO_ADDR
// if p3 = 103 then
97250: LD_VAR 0 3
97254: PUSH
97255: LD_INT 103
97257: EQUAL
97258: IFFALSE 97268
// sFog := true ;
97260: LD_ADDR_EXP 147
97264: PUSH
97265: LD_INT 1
97267: ST_TO_ADDR
// if p3 = 104 then
97268: LD_VAR 0 3
97272: PUSH
97273: LD_INT 104
97275: EQUAL
97276: IFFALSE 97286
// sReset := true ;
97278: LD_ADDR_EXP 148
97282: PUSH
97283: LD_INT 1
97285: ST_TO_ADDR
// if p3 = 105 then
97286: LD_VAR 0 3
97290: PUSH
97291: LD_INT 105
97293: EQUAL
97294: IFFALSE 97304
// sSun := true ;
97296: LD_ADDR_EXP 149
97300: PUSH
97301: LD_INT 1
97303: ST_TO_ADDR
// if p3 = 106 then
97304: LD_VAR 0 3
97308: PUSH
97309: LD_INT 106
97311: EQUAL
97312: IFFALSE 97322
// sTiger := true ;
97314: LD_ADDR_EXP 145
97318: PUSH
97319: LD_INT 1
97321: ST_TO_ADDR
// if p3 = 107 then
97322: LD_VAR 0 3
97326: PUSH
97327: LD_INT 107
97329: EQUAL
97330: IFFALSE 97340
// sBomb := true ;
97332: LD_ADDR_EXP 146
97336: PUSH
97337: LD_INT 1
97339: ST_TO_ADDR
// if p3 = 108 then
97340: LD_VAR 0 3
97344: PUSH
97345: LD_INT 108
97347: EQUAL
97348: IFFALSE 97358
// sWound := true ;
97350: LD_ADDR_EXP 154
97354: PUSH
97355: LD_INT 1
97357: ST_TO_ADDR
// if p3 = 109 then
97358: LD_VAR 0 3
97362: PUSH
97363: LD_INT 109
97365: EQUAL
97366: IFFALSE 97376
// sBetray := true ;
97368: LD_ADDR_EXP 158
97372: PUSH
97373: LD_INT 1
97375: ST_TO_ADDR
// if p3 = 110 then
97376: LD_VAR 0 3
97380: PUSH
97381: LD_INT 110
97383: EQUAL
97384: IFFALSE 97394
// sContamin := true ;
97386: LD_ADDR_EXP 159
97390: PUSH
97391: LD_INT 1
97393: ST_TO_ADDR
// if p3 = 111 then
97394: LD_VAR 0 3
97398: PUSH
97399: LD_INT 111
97401: EQUAL
97402: IFFALSE 97412
// sOil := true ;
97404: LD_ADDR_EXP 161
97408: PUSH
97409: LD_INT 1
97411: ST_TO_ADDR
// if p3 = 112 then
97412: LD_VAR 0 3
97416: PUSH
97417: LD_INT 112
97419: EQUAL
97420: IFFALSE 97430
// sStu := true ;
97422: LD_ADDR_EXP 165
97426: PUSH
97427: LD_INT 1
97429: ST_TO_ADDR
// if p3 = 113 then
97430: LD_VAR 0 3
97434: PUSH
97435: LD_INT 113
97437: EQUAL
97438: IFFALSE 97448
// sBazooka := true ;
97440: LD_ADDR_EXP 168
97444: PUSH
97445: LD_INT 1
97447: ST_TO_ADDR
// if p3 = 114 then
97448: LD_VAR 0 3
97452: PUSH
97453: LD_INT 114
97455: EQUAL
97456: IFFALSE 97466
// sMortar := true ;
97458: LD_ADDR_EXP 169
97462: PUSH
97463: LD_INT 1
97465: ST_TO_ADDR
// if p3 = 115 then
97466: LD_VAR 0 3
97470: PUSH
97471: LD_INT 115
97473: EQUAL
97474: IFFALSE 97484
// sRanger := true ;
97476: LD_ADDR_EXP 179
97480: PUSH
97481: LD_INT 1
97483: ST_TO_ADDR
// if p3 = 116 then
97484: LD_VAR 0 3
97488: PUSH
97489: LD_INT 116
97491: EQUAL
97492: IFFALSE 97502
// sComputer := true ;
97494: LD_ADDR_EXP 180
97498: PUSH
97499: LD_INT 1
97501: ST_TO_ADDR
// if p3 = 117 then
97502: LD_VAR 0 3
97506: PUSH
97507: LD_INT 117
97509: EQUAL
97510: IFFALSE 97520
// s30 := true ;
97512: LD_ADDR_EXP 181
97516: PUSH
97517: LD_INT 1
97519: ST_TO_ADDR
// if p3 = 118 then
97520: LD_VAR 0 3
97524: PUSH
97525: LD_INT 118
97527: EQUAL
97528: IFFALSE 97538
// s60 := true ;
97530: LD_ADDR_EXP 182
97534: PUSH
97535: LD_INT 1
97537: ST_TO_ADDR
// end ; if p2 = hack_mode then
97538: LD_VAR 0 2
97542: PUSH
97543: LD_INT 101
97545: EQUAL
97546: IFFALSE 97674
// begin case p3 of 1 :
97548: LD_VAR 0 3
97552: PUSH
97553: LD_INT 1
97555: DOUBLE
97556: EQUAL
97557: IFTRUE 97561
97559: GO 97568
97561: POP
// hHackUnlimitedResources ; 2 :
97562: CALL 109821 0 0
97566: GO 97674
97568: LD_INT 2
97570: DOUBLE
97571: EQUAL
97572: IFTRUE 97576
97574: GO 97583
97576: POP
// hHackSetLevel10 ; 3 :
97577: CALL 109954 0 0
97581: GO 97674
97583: LD_INT 3
97585: DOUBLE
97586: EQUAL
97587: IFTRUE 97591
97589: GO 97598
97591: POP
// hHackSetLevel10YourUnits ; 4 :
97592: CALL 110039 0 0
97596: GO 97674
97598: LD_INT 4
97600: DOUBLE
97601: EQUAL
97602: IFTRUE 97606
97604: GO 97613
97606: POP
// hHackInvincible ; 5 :
97607: CALL 110487 0 0
97611: GO 97674
97613: LD_INT 5
97615: DOUBLE
97616: EQUAL
97617: IFTRUE 97621
97619: GO 97628
97621: POP
// hHackInvisible ; 6 :
97622: CALL 110598 0 0
97626: GO 97674
97628: LD_INT 6
97630: DOUBLE
97631: EQUAL
97632: IFTRUE 97636
97634: GO 97643
97636: POP
// hHackChangeYourSide ; 7 :
97637: CALL 110655 0 0
97641: GO 97674
97643: LD_INT 7
97645: DOUBLE
97646: EQUAL
97647: IFTRUE 97651
97649: GO 97658
97651: POP
// hHackChangeUnitSide ; 8 :
97652: CALL 110697 0 0
97656: GO 97674
97658: LD_INT 8
97660: DOUBLE
97661: EQUAL
97662: IFTRUE 97666
97664: GO 97673
97666: POP
// hHackFog ; end ;
97667: CALL 110798 0 0
97671: GO 97674
97673: POP
// end ; if p2 = game_save_mode then
97674: LD_VAR 0 2
97678: PUSH
97679: LD_INT 102
97681: EQUAL
97682: IFFALSE 97737
// begin if p3 = 1 then
97684: LD_VAR 0 3
97688: PUSH
97689: LD_INT 1
97691: EQUAL
97692: IFFALSE 97704
// globalGameSaveCounter := p4 ;
97694: LD_ADDR_EXP 125
97698: PUSH
97699: LD_VAR 0 4
97703: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97704: LD_VAR 0 3
97708: PUSH
97709: LD_INT 2
97711: EQUAL
97712: PUSH
97713: LD_EXP 125
97717: AND
97718: IFFALSE 97737
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97720: LD_STRING setGameSaveCounter(
97722: PUSH
97723: LD_EXP 125
97727: STR
97728: PUSH
97729: LD_STRING )
97731: STR
97732: PPUSH
97733: CALL_OW 559
// end ; end ;
97737: LD_VAR 0 7
97741: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
97742: LD_INT 0
97744: PPUSH
// streamModeActive := false ;
97745: LD_ADDR_EXP 126
97749: PUSH
97750: LD_INT 0
97752: ST_TO_ADDR
// normalCounter := 36 ;
97753: LD_ADDR_EXP 127
97757: PUSH
97758: LD_INT 36
97760: ST_TO_ADDR
// hardcoreCounter := 18 ;
97761: LD_ADDR_EXP 128
97765: PUSH
97766: LD_INT 18
97768: ST_TO_ADDR
// sRocket := false ;
97769: LD_ADDR_EXP 131
97773: PUSH
97774: LD_INT 0
97776: ST_TO_ADDR
// sSpeed := false ;
97777: LD_ADDR_EXP 130
97781: PUSH
97782: LD_INT 0
97784: ST_TO_ADDR
// sEngine := false ;
97785: LD_ADDR_EXP 132
97789: PUSH
97790: LD_INT 0
97792: ST_TO_ADDR
// sSpec := false ;
97793: LD_ADDR_EXP 129
97797: PUSH
97798: LD_INT 0
97800: ST_TO_ADDR
// sLevel := false ;
97801: LD_ADDR_EXP 133
97805: PUSH
97806: LD_INT 0
97808: ST_TO_ADDR
// sArmoury := false ;
97809: LD_ADDR_EXP 134
97813: PUSH
97814: LD_INT 0
97816: ST_TO_ADDR
// sRadar := false ;
97817: LD_ADDR_EXP 135
97821: PUSH
97822: LD_INT 0
97824: ST_TO_ADDR
// sBunker := false ;
97825: LD_ADDR_EXP 136
97829: PUSH
97830: LD_INT 0
97832: ST_TO_ADDR
// sHack := false ;
97833: LD_ADDR_EXP 137
97837: PUSH
97838: LD_INT 0
97840: ST_TO_ADDR
// sFire := false ;
97841: LD_ADDR_EXP 138
97845: PUSH
97846: LD_INT 0
97848: ST_TO_ADDR
// sRefresh := false ;
97849: LD_ADDR_EXP 139
97853: PUSH
97854: LD_INT 0
97856: ST_TO_ADDR
// sExp := false ;
97857: LD_ADDR_EXP 140
97861: PUSH
97862: LD_INT 0
97864: ST_TO_ADDR
// sDepot := false ;
97865: LD_ADDR_EXP 141
97869: PUSH
97870: LD_INT 0
97872: ST_TO_ADDR
// sFlag := false ;
97873: LD_ADDR_EXP 142
97877: PUSH
97878: LD_INT 0
97880: ST_TO_ADDR
// sKamikadze := false ;
97881: LD_ADDR_EXP 150
97885: PUSH
97886: LD_INT 0
97888: ST_TO_ADDR
// sTroll := false ;
97889: LD_ADDR_EXP 151
97893: PUSH
97894: LD_INT 0
97896: ST_TO_ADDR
// sSlow := false ;
97897: LD_ADDR_EXP 152
97901: PUSH
97902: LD_INT 0
97904: ST_TO_ADDR
// sLack := false ;
97905: LD_ADDR_EXP 153
97909: PUSH
97910: LD_INT 0
97912: ST_TO_ADDR
// sTank := false ;
97913: LD_ADDR_EXP 155
97917: PUSH
97918: LD_INT 0
97920: ST_TO_ADDR
// sRemote := false ;
97921: LD_ADDR_EXP 156
97925: PUSH
97926: LD_INT 0
97928: ST_TO_ADDR
// sPowell := false ;
97929: LD_ADDR_EXP 157
97933: PUSH
97934: LD_INT 0
97936: ST_TO_ADDR
// sTeleport := false ;
97937: LD_ADDR_EXP 160
97941: PUSH
97942: LD_INT 0
97944: ST_TO_ADDR
// sOilTower := false ;
97945: LD_ADDR_EXP 162
97949: PUSH
97950: LD_INT 0
97952: ST_TO_ADDR
// sShovel := false ;
97953: LD_ADDR_EXP 163
97957: PUSH
97958: LD_INT 0
97960: ST_TO_ADDR
// sSheik := false ;
97961: LD_ADDR_EXP 164
97965: PUSH
97966: LD_INT 0
97968: ST_TO_ADDR
// sEarthquake := false ;
97969: LD_ADDR_EXP 166
97973: PUSH
97974: LD_INT 0
97976: ST_TO_ADDR
// sAI := false ;
97977: LD_ADDR_EXP 167
97981: PUSH
97982: LD_INT 0
97984: ST_TO_ADDR
// sCargo := false ;
97985: LD_ADDR_EXP 170
97989: PUSH
97990: LD_INT 0
97992: ST_TO_ADDR
// sDLaser := false ;
97993: LD_ADDR_EXP 171
97997: PUSH
97998: LD_INT 0
98000: ST_TO_ADDR
// sExchange := false ;
98001: LD_ADDR_EXP 172
98005: PUSH
98006: LD_INT 0
98008: ST_TO_ADDR
// sFac := false ;
98009: LD_ADDR_EXP 173
98013: PUSH
98014: LD_INT 0
98016: ST_TO_ADDR
// sPower := false ;
98017: LD_ADDR_EXP 174
98021: PUSH
98022: LD_INT 0
98024: ST_TO_ADDR
// sRandom := false ;
98025: LD_ADDR_EXP 175
98029: PUSH
98030: LD_INT 0
98032: ST_TO_ADDR
// sShield := false ;
98033: LD_ADDR_EXP 176
98037: PUSH
98038: LD_INT 0
98040: ST_TO_ADDR
// sTime := false ;
98041: LD_ADDR_EXP 177
98045: PUSH
98046: LD_INT 0
98048: ST_TO_ADDR
// sTools := false ;
98049: LD_ADDR_EXP 178
98053: PUSH
98054: LD_INT 0
98056: ST_TO_ADDR
// sSold := false ;
98057: LD_ADDR_EXP 143
98061: PUSH
98062: LD_INT 0
98064: ST_TO_ADDR
// sDiff := false ;
98065: LD_ADDR_EXP 144
98069: PUSH
98070: LD_INT 0
98072: ST_TO_ADDR
// sFog := false ;
98073: LD_ADDR_EXP 147
98077: PUSH
98078: LD_INT 0
98080: ST_TO_ADDR
// sReset := false ;
98081: LD_ADDR_EXP 148
98085: PUSH
98086: LD_INT 0
98088: ST_TO_ADDR
// sSun := false ;
98089: LD_ADDR_EXP 149
98093: PUSH
98094: LD_INT 0
98096: ST_TO_ADDR
// sTiger := false ;
98097: LD_ADDR_EXP 145
98101: PUSH
98102: LD_INT 0
98104: ST_TO_ADDR
// sBomb := false ;
98105: LD_ADDR_EXP 146
98109: PUSH
98110: LD_INT 0
98112: ST_TO_ADDR
// sWound := false ;
98113: LD_ADDR_EXP 154
98117: PUSH
98118: LD_INT 0
98120: ST_TO_ADDR
// sBetray := false ;
98121: LD_ADDR_EXP 158
98125: PUSH
98126: LD_INT 0
98128: ST_TO_ADDR
// sContamin := false ;
98129: LD_ADDR_EXP 159
98133: PUSH
98134: LD_INT 0
98136: ST_TO_ADDR
// sOil := false ;
98137: LD_ADDR_EXP 161
98141: PUSH
98142: LD_INT 0
98144: ST_TO_ADDR
// sStu := false ;
98145: LD_ADDR_EXP 165
98149: PUSH
98150: LD_INT 0
98152: ST_TO_ADDR
// sBazooka := false ;
98153: LD_ADDR_EXP 168
98157: PUSH
98158: LD_INT 0
98160: ST_TO_ADDR
// sMortar := false ;
98161: LD_ADDR_EXP 169
98165: PUSH
98166: LD_INT 0
98168: ST_TO_ADDR
// sRanger := false ;
98169: LD_ADDR_EXP 179
98173: PUSH
98174: LD_INT 0
98176: ST_TO_ADDR
// sComputer := false ;
98177: LD_ADDR_EXP 180
98181: PUSH
98182: LD_INT 0
98184: ST_TO_ADDR
// s30 := false ;
98185: LD_ADDR_EXP 181
98189: PUSH
98190: LD_INT 0
98192: ST_TO_ADDR
// s60 := false ;
98193: LD_ADDR_EXP 182
98197: PUSH
98198: LD_INT 0
98200: ST_TO_ADDR
// end ;
98201: LD_VAR 0 1
98205: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
98206: LD_INT 0
98208: PPUSH
98209: PPUSH
98210: PPUSH
98211: PPUSH
98212: PPUSH
98213: PPUSH
98214: PPUSH
// result := [ ] ;
98215: LD_ADDR_VAR 0 2
98219: PUSH
98220: EMPTY
98221: ST_TO_ADDR
// if campaign_id = 1 then
98222: LD_OWVAR 69
98226: PUSH
98227: LD_INT 1
98229: EQUAL
98230: IFFALSE 101396
// begin case mission_number of 1 :
98232: LD_OWVAR 70
98236: PUSH
98237: LD_INT 1
98239: DOUBLE
98240: EQUAL
98241: IFTRUE 98245
98243: GO 98321
98245: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
98246: LD_ADDR_VAR 0 2
98250: PUSH
98251: LD_INT 2
98253: PUSH
98254: LD_INT 4
98256: PUSH
98257: LD_INT 11
98259: PUSH
98260: LD_INT 12
98262: PUSH
98263: LD_INT 15
98265: PUSH
98266: LD_INT 16
98268: PUSH
98269: LD_INT 22
98271: PUSH
98272: LD_INT 23
98274: PUSH
98275: LD_INT 26
98277: PUSH
98278: EMPTY
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: LIST
98287: LIST
98288: PUSH
98289: LD_INT 101
98291: PUSH
98292: LD_INT 102
98294: PUSH
98295: LD_INT 106
98297: PUSH
98298: LD_INT 116
98300: PUSH
98301: LD_INT 117
98303: PUSH
98304: LD_INT 118
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: ST_TO_ADDR
98319: GO 101394
98321: LD_INT 2
98323: DOUBLE
98324: EQUAL
98325: IFTRUE 98329
98327: GO 98413
98329: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98330: LD_ADDR_VAR 0 2
98334: PUSH
98335: LD_INT 2
98337: PUSH
98338: LD_INT 4
98340: PUSH
98341: LD_INT 11
98343: PUSH
98344: LD_INT 12
98346: PUSH
98347: LD_INT 15
98349: PUSH
98350: LD_INT 16
98352: PUSH
98353: LD_INT 22
98355: PUSH
98356: LD_INT 23
98358: PUSH
98359: LD_INT 26
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: PUSH
98373: LD_INT 101
98375: PUSH
98376: LD_INT 102
98378: PUSH
98379: LD_INT 105
98381: PUSH
98382: LD_INT 106
98384: PUSH
98385: LD_INT 108
98387: PUSH
98388: LD_INT 116
98390: PUSH
98391: LD_INT 117
98393: PUSH
98394: LD_INT 118
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: ST_TO_ADDR
98411: GO 101394
98413: LD_INT 3
98415: DOUBLE
98416: EQUAL
98417: IFTRUE 98421
98419: GO 98509
98421: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
98422: LD_ADDR_VAR 0 2
98426: PUSH
98427: LD_INT 2
98429: PUSH
98430: LD_INT 4
98432: PUSH
98433: LD_INT 5
98435: PUSH
98436: LD_INT 11
98438: PUSH
98439: LD_INT 12
98441: PUSH
98442: LD_INT 15
98444: PUSH
98445: LD_INT 16
98447: PUSH
98448: LD_INT 22
98450: PUSH
98451: LD_INT 26
98453: PUSH
98454: LD_INT 36
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 101
98471: PUSH
98472: LD_INT 102
98474: PUSH
98475: LD_INT 105
98477: PUSH
98478: LD_INT 106
98480: PUSH
98481: LD_INT 108
98483: PUSH
98484: LD_INT 116
98486: PUSH
98487: LD_INT 117
98489: PUSH
98490: LD_INT 118
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: ST_TO_ADDR
98507: GO 101394
98509: LD_INT 4
98511: DOUBLE
98512: EQUAL
98513: IFTRUE 98517
98515: GO 98613
98517: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98518: LD_ADDR_VAR 0 2
98522: PUSH
98523: LD_INT 2
98525: PUSH
98526: LD_INT 4
98528: PUSH
98529: LD_INT 5
98531: PUSH
98532: LD_INT 8
98534: PUSH
98535: LD_INT 11
98537: PUSH
98538: LD_INT 12
98540: PUSH
98541: LD_INT 15
98543: PUSH
98544: LD_INT 16
98546: PUSH
98547: LD_INT 22
98549: PUSH
98550: LD_INT 23
98552: PUSH
98553: LD_INT 26
98555: PUSH
98556: LD_INT 36
98558: PUSH
98559: EMPTY
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: PUSH
98573: LD_INT 101
98575: PUSH
98576: LD_INT 102
98578: PUSH
98579: LD_INT 105
98581: PUSH
98582: LD_INT 106
98584: PUSH
98585: LD_INT 108
98587: PUSH
98588: LD_INT 116
98590: PUSH
98591: LD_INT 117
98593: PUSH
98594: LD_INT 118
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: ST_TO_ADDR
98611: GO 101394
98613: LD_INT 5
98615: DOUBLE
98616: EQUAL
98617: IFTRUE 98621
98619: GO 98733
98621: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98622: LD_ADDR_VAR 0 2
98626: PUSH
98627: LD_INT 2
98629: PUSH
98630: LD_INT 4
98632: PUSH
98633: LD_INT 5
98635: PUSH
98636: LD_INT 6
98638: PUSH
98639: LD_INT 8
98641: PUSH
98642: LD_INT 11
98644: PUSH
98645: LD_INT 12
98647: PUSH
98648: LD_INT 15
98650: PUSH
98651: LD_INT 16
98653: PUSH
98654: LD_INT 22
98656: PUSH
98657: LD_INT 23
98659: PUSH
98660: LD_INT 25
98662: PUSH
98663: LD_INT 26
98665: PUSH
98666: LD_INT 36
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: LIST
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: PUSH
98685: LD_INT 101
98687: PUSH
98688: LD_INT 102
98690: PUSH
98691: LD_INT 105
98693: PUSH
98694: LD_INT 106
98696: PUSH
98697: LD_INT 108
98699: PUSH
98700: LD_INT 109
98702: PUSH
98703: LD_INT 112
98705: PUSH
98706: LD_INT 116
98708: PUSH
98709: LD_INT 117
98711: PUSH
98712: LD_INT 118
98714: PUSH
98715: EMPTY
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: PUSH
98727: EMPTY
98728: LIST
98729: LIST
98730: ST_TO_ADDR
98731: GO 101394
98733: LD_INT 6
98735: DOUBLE
98736: EQUAL
98737: IFTRUE 98741
98739: GO 98873
98741: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
98742: LD_ADDR_VAR 0 2
98746: PUSH
98747: LD_INT 2
98749: PUSH
98750: LD_INT 4
98752: PUSH
98753: LD_INT 5
98755: PUSH
98756: LD_INT 6
98758: PUSH
98759: LD_INT 8
98761: PUSH
98762: LD_INT 11
98764: PUSH
98765: LD_INT 12
98767: PUSH
98768: LD_INT 15
98770: PUSH
98771: LD_INT 16
98773: PUSH
98774: LD_INT 20
98776: PUSH
98777: LD_INT 21
98779: PUSH
98780: LD_INT 22
98782: PUSH
98783: LD_INT 23
98785: PUSH
98786: LD_INT 25
98788: PUSH
98789: LD_INT 26
98791: PUSH
98792: LD_INT 30
98794: PUSH
98795: LD_INT 31
98797: PUSH
98798: LD_INT 32
98800: PUSH
98801: LD_INT 36
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 101
98827: PUSH
98828: LD_INT 102
98830: PUSH
98831: LD_INT 105
98833: PUSH
98834: LD_INT 106
98836: PUSH
98837: LD_INT 108
98839: PUSH
98840: LD_INT 109
98842: PUSH
98843: LD_INT 112
98845: PUSH
98846: LD_INT 116
98848: PUSH
98849: LD_INT 117
98851: PUSH
98852: LD_INT 118
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: PUSH
98867: EMPTY
98868: LIST
98869: LIST
98870: ST_TO_ADDR
98871: GO 101394
98873: LD_INT 7
98875: DOUBLE
98876: EQUAL
98877: IFTRUE 98881
98879: GO 98993
98881: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98882: LD_ADDR_VAR 0 2
98886: PUSH
98887: LD_INT 2
98889: PUSH
98890: LD_INT 4
98892: PUSH
98893: LD_INT 5
98895: PUSH
98896: LD_INT 7
98898: PUSH
98899: LD_INT 11
98901: PUSH
98902: LD_INT 12
98904: PUSH
98905: LD_INT 15
98907: PUSH
98908: LD_INT 16
98910: PUSH
98911: LD_INT 20
98913: PUSH
98914: LD_INT 21
98916: PUSH
98917: LD_INT 22
98919: PUSH
98920: LD_INT 23
98922: PUSH
98923: LD_INT 25
98925: PUSH
98926: LD_INT 26
98928: PUSH
98929: EMPTY
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: PUSH
98945: LD_INT 101
98947: PUSH
98948: LD_INT 102
98950: PUSH
98951: LD_INT 103
98953: PUSH
98954: LD_INT 105
98956: PUSH
98957: LD_INT 106
98959: PUSH
98960: LD_INT 108
98962: PUSH
98963: LD_INT 112
98965: PUSH
98966: LD_INT 116
98968: PUSH
98969: LD_INT 117
98971: PUSH
98972: LD_INT 118
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: ST_TO_ADDR
98991: GO 101394
98993: LD_INT 8
98995: DOUBLE
98996: EQUAL
98997: IFTRUE 99001
98999: GO 99141
99001: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
99002: LD_ADDR_VAR 0 2
99006: PUSH
99007: LD_INT 2
99009: PUSH
99010: LD_INT 4
99012: PUSH
99013: LD_INT 5
99015: PUSH
99016: LD_INT 6
99018: PUSH
99019: LD_INT 7
99021: PUSH
99022: LD_INT 8
99024: PUSH
99025: LD_INT 11
99027: PUSH
99028: LD_INT 12
99030: PUSH
99031: LD_INT 15
99033: PUSH
99034: LD_INT 16
99036: PUSH
99037: LD_INT 20
99039: PUSH
99040: LD_INT 21
99042: PUSH
99043: LD_INT 22
99045: PUSH
99046: LD_INT 23
99048: PUSH
99049: LD_INT 25
99051: PUSH
99052: LD_INT 26
99054: PUSH
99055: LD_INT 30
99057: PUSH
99058: LD_INT 31
99060: PUSH
99061: LD_INT 32
99063: PUSH
99064: LD_INT 36
99066: PUSH
99067: EMPTY
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 101
99091: PUSH
99092: LD_INT 102
99094: PUSH
99095: LD_INT 103
99097: PUSH
99098: LD_INT 105
99100: PUSH
99101: LD_INT 106
99103: PUSH
99104: LD_INT 108
99106: PUSH
99107: LD_INT 109
99109: PUSH
99110: LD_INT 112
99112: PUSH
99113: LD_INT 116
99115: PUSH
99116: LD_INT 117
99118: PUSH
99119: LD_INT 118
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: LIST
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: ST_TO_ADDR
99139: GO 101394
99141: LD_INT 9
99143: DOUBLE
99144: EQUAL
99145: IFTRUE 99149
99147: GO 99297
99149: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
99150: LD_ADDR_VAR 0 2
99154: PUSH
99155: LD_INT 2
99157: PUSH
99158: LD_INT 4
99160: PUSH
99161: LD_INT 5
99163: PUSH
99164: LD_INT 6
99166: PUSH
99167: LD_INT 7
99169: PUSH
99170: LD_INT 8
99172: PUSH
99173: LD_INT 11
99175: PUSH
99176: LD_INT 12
99178: PUSH
99179: LD_INT 15
99181: PUSH
99182: LD_INT 16
99184: PUSH
99185: LD_INT 20
99187: PUSH
99188: LD_INT 21
99190: PUSH
99191: LD_INT 22
99193: PUSH
99194: LD_INT 23
99196: PUSH
99197: LD_INT 25
99199: PUSH
99200: LD_INT 26
99202: PUSH
99203: LD_INT 28
99205: PUSH
99206: LD_INT 30
99208: PUSH
99209: LD_INT 31
99211: PUSH
99212: LD_INT 32
99214: PUSH
99215: LD_INT 36
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: PUSH
99241: LD_INT 101
99243: PUSH
99244: LD_INT 102
99246: PUSH
99247: LD_INT 103
99249: PUSH
99250: LD_INT 105
99252: PUSH
99253: LD_INT 106
99255: PUSH
99256: LD_INT 108
99258: PUSH
99259: LD_INT 109
99261: PUSH
99262: LD_INT 112
99264: PUSH
99265: LD_INT 114
99267: PUSH
99268: LD_INT 116
99270: PUSH
99271: LD_INT 117
99273: PUSH
99274: LD_INT 118
99276: PUSH
99277: EMPTY
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: LIST
99288: LIST
99289: LIST
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: ST_TO_ADDR
99295: GO 101394
99297: LD_INT 10
99299: DOUBLE
99300: EQUAL
99301: IFTRUE 99305
99303: GO 99501
99305: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99306: LD_ADDR_VAR 0 2
99310: PUSH
99311: LD_INT 2
99313: PUSH
99314: LD_INT 4
99316: PUSH
99317: LD_INT 5
99319: PUSH
99320: LD_INT 6
99322: PUSH
99323: LD_INT 7
99325: PUSH
99326: LD_INT 8
99328: PUSH
99329: LD_INT 9
99331: PUSH
99332: LD_INT 10
99334: PUSH
99335: LD_INT 11
99337: PUSH
99338: LD_INT 12
99340: PUSH
99341: LD_INT 13
99343: PUSH
99344: LD_INT 14
99346: PUSH
99347: LD_INT 15
99349: PUSH
99350: LD_INT 16
99352: PUSH
99353: LD_INT 17
99355: PUSH
99356: LD_INT 18
99358: PUSH
99359: LD_INT 19
99361: PUSH
99362: LD_INT 20
99364: PUSH
99365: LD_INT 21
99367: PUSH
99368: LD_INT 22
99370: PUSH
99371: LD_INT 23
99373: PUSH
99374: LD_INT 24
99376: PUSH
99377: LD_INT 25
99379: PUSH
99380: LD_INT 26
99382: PUSH
99383: LD_INT 28
99385: PUSH
99386: LD_INT 30
99388: PUSH
99389: LD_INT 31
99391: PUSH
99392: LD_INT 32
99394: PUSH
99395: LD_INT 36
99397: PUSH
99398: EMPTY
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: PUSH
99429: LD_INT 101
99431: PUSH
99432: LD_INT 102
99434: PUSH
99435: LD_INT 103
99437: PUSH
99438: LD_INT 104
99440: PUSH
99441: LD_INT 105
99443: PUSH
99444: LD_INT 106
99446: PUSH
99447: LD_INT 107
99449: PUSH
99450: LD_INT 108
99452: PUSH
99453: LD_INT 109
99455: PUSH
99456: LD_INT 110
99458: PUSH
99459: LD_INT 111
99461: PUSH
99462: LD_INT 112
99464: PUSH
99465: LD_INT 114
99467: PUSH
99468: LD_INT 116
99470: PUSH
99471: LD_INT 117
99473: PUSH
99474: LD_INT 118
99476: PUSH
99477: EMPTY
99478: LIST
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: LIST
99486: LIST
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: LIST
99494: PUSH
99495: EMPTY
99496: LIST
99497: LIST
99498: ST_TO_ADDR
99499: GO 101394
99501: LD_INT 11
99503: DOUBLE
99504: EQUAL
99505: IFTRUE 99509
99507: GO 99713
99509: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99510: LD_ADDR_VAR 0 2
99514: PUSH
99515: LD_INT 2
99517: PUSH
99518: LD_INT 3
99520: PUSH
99521: LD_INT 4
99523: PUSH
99524: LD_INT 5
99526: PUSH
99527: LD_INT 6
99529: PUSH
99530: LD_INT 7
99532: PUSH
99533: LD_INT 8
99535: PUSH
99536: LD_INT 9
99538: PUSH
99539: LD_INT 10
99541: PUSH
99542: LD_INT 11
99544: PUSH
99545: LD_INT 12
99547: PUSH
99548: LD_INT 13
99550: PUSH
99551: LD_INT 14
99553: PUSH
99554: LD_INT 15
99556: PUSH
99557: LD_INT 16
99559: PUSH
99560: LD_INT 17
99562: PUSH
99563: LD_INT 18
99565: PUSH
99566: LD_INT 19
99568: PUSH
99569: LD_INT 20
99571: PUSH
99572: LD_INT 21
99574: PUSH
99575: LD_INT 22
99577: PUSH
99578: LD_INT 23
99580: PUSH
99581: LD_INT 24
99583: PUSH
99584: LD_INT 25
99586: PUSH
99587: LD_INT 26
99589: PUSH
99590: LD_INT 28
99592: PUSH
99593: LD_INT 30
99595: PUSH
99596: LD_INT 31
99598: PUSH
99599: LD_INT 32
99601: PUSH
99602: LD_INT 34
99604: PUSH
99605: LD_INT 36
99607: PUSH
99608: EMPTY
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: LIST
99620: LIST
99621: LIST
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: PUSH
99641: LD_INT 101
99643: PUSH
99644: LD_INT 102
99646: PUSH
99647: LD_INT 103
99649: PUSH
99650: LD_INT 104
99652: PUSH
99653: LD_INT 105
99655: PUSH
99656: LD_INT 106
99658: PUSH
99659: LD_INT 107
99661: PUSH
99662: LD_INT 108
99664: PUSH
99665: LD_INT 109
99667: PUSH
99668: LD_INT 110
99670: PUSH
99671: LD_INT 111
99673: PUSH
99674: LD_INT 112
99676: PUSH
99677: LD_INT 114
99679: PUSH
99680: LD_INT 116
99682: PUSH
99683: LD_INT 117
99685: PUSH
99686: LD_INT 118
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: LIST
99693: LIST
99694: LIST
99695: LIST
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: LIST
99703: LIST
99704: LIST
99705: LIST
99706: PUSH
99707: EMPTY
99708: LIST
99709: LIST
99710: ST_TO_ADDR
99711: GO 101394
99713: LD_INT 12
99715: DOUBLE
99716: EQUAL
99717: IFTRUE 99721
99719: GO 99941
99721: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99722: LD_ADDR_VAR 0 2
99726: PUSH
99727: LD_INT 1
99729: PUSH
99730: LD_INT 2
99732: PUSH
99733: LD_INT 3
99735: PUSH
99736: LD_INT 4
99738: PUSH
99739: LD_INT 5
99741: PUSH
99742: LD_INT 6
99744: PUSH
99745: LD_INT 7
99747: PUSH
99748: LD_INT 8
99750: PUSH
99751: LD_INT 9
99753: PUSH
99754: LD_INT 10
99756: PUSH
99757: LD_INT 11
99759: PUSH
99760: LD_INT 12
99762: PUSH
99763: LD_INT 13
99765: PUSH
99766: LD_INT 14
99768: PUSH
99769: LD_INT 15
99771: PUSH
99772: LD_INT 16
99774: PUSH
99775: LD_INT 17
99777: PUSH
99778: LD_INT 18
99780: PUSH
99781: LD_INT 19
99783: PUSH
99784: LD_INT 20
99786: PUSH
99787: LD_INT 21
99789: PUSH
99790: LD_INT 22
99792: PUSH
99793: LD_INT 23
99795: PUSH
99796: LD_INT 24
99798: PUSH
99799: LD_INT 25
99801: PUSH
99802: LD_INT 26
99804: PUSH
99805: LD_INT 27
99807: PUSH
99808: LD_INT 28
99810: PUSH
99811: LD_INT 30
99813: PUSH
99814: LD_INT 31
99816: PUSH
99817: LD_INT 32
99819: PUSH
99820: LD_INT 33
99822: PUSH
99823: LD_INT 34
99825: PUSH
99826: LD_INT 36
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: LIST
99848: LIST
99849: LIST
99850: LIST
99851: LIST
99852: LIST
99853: LIST
99854: LIST
99855: LIST
99856: LIST
99857: LIST
99858: LIST
99859: LIST
99860: LIST
99861: LIST
99862: LIST
99863: LIST
99864: PUSH
99865: LD_INT 101
99867: PUSH
99868: LD_INT 102
99870: PUSH
99871: LD_INT 103
99873: PUSH
99874: LD_INT 104
99876: PUSH
99877: LD_INT 105
99879: PUSH
99880: LD_INT 106
99882: PUSH
99883: LD_INT 107
99885: PUSH
99886: LD_INT 108
99888: PUSH
99889: LD_INT 109
99891: PUSH
99892: LD_INT 110
99894: PUSH
99895: LD_INT 111
99897: PUSH
99898: LD_INT 112
99900: PUSH
99901: LD_INT 113
99903: PUSH
99904: LD_INT 114
99906: PUSH
99907: LD_INT 116
99909: PUSH
99910: LD_INT 117
99912: PUSH
99913: LD_INT 118
99915: PUSH
99916: EMPTY
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: PUSH
99935: EMPTY
99936: LIST
99937: LIST
99938: ST_TO_ADDR
99939: GO 101394
99941: LD_INT 13
99943: DOUBLE
99944: EQUAL
99945: IFTRUE 99949
99947: GO 100157
99949: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99950: LD_ADDR_VAR 0 2
99954: PUSH
99955: LD_INT 1
99957: PUSH
99958: LD_INT 2
99960: PUSH
99961: LD_INT 3
99963: PUSH
99964: LD_INT 4
99966: PUSH
99967: LD_INT 5
99969: PUSH
99970: LD_INT 8
99972: PUSH
99973: LD_INT 9
99975: PUSH
99976: LD_INT 10
99978: PUSH
99979: LD_INT 11
99981: PUSH
99982: LD_INT 12
99984: PUSH
99985: LD_INT 14
99987: PUSH
99988: LD_INT 15
99990: PUSH
99991: LD_INT 16
99993: PUSH
99994: LD_INT 17
99996: PUSH
99997: LD_INT 18
99999: PUSH
100000: LD_INT 19
100002: PUSH
100003: LD_INT 20
100005: PUSH
100006: LD_INT 21
100008: PUSH
100009: LD_INT 22
100011: PUSH
100012: LD_INT 23
100014: PUSH
100015: LD_INT 24
100017: PUSH
100018: LD_INT 25
100020: PUSH
100021: LD_INT 26
100023: PUSH
100024: LD_INT 27
100026: PUSH
100027: LD_INT 28
100029: PUSH
100030: LD_INT 30
100032: PUSH
100033: LD_INT 31
100035: PUSH
100036: LD_INT 32
100038: PUSH
100039: LD_INT 33
100041: PUSH
100042: LD_INT 34
100044: PUSH
100045: LD_INT 36
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: PUSH
100081: LD_INT 101
100083: PUSH
100084: LD_INT 102
100086: PUSH
100087: LD_INT 103
100089: PUSH
100090: LD_INT 104
100092: PUSH
100093: LD_INT 105
100095: PUSH
100096: LD_INT 106
100098: PUSH
100099: LD_INT 107
100101: PUSH
100102: LD_INT 108
100104: PUSH
100105: LD_INT 109
100107: PUSH
100108: LD_INT 110
100110: PUSH
100111: LD_INT 111
100113: PUSH
100114: LD_INT 112
100116: PUSH
100117: LD_INT 113
100119: PUSH
100120: LD_INT 114
100122: PUSH
100123: LD_INT 116
100125: PUSH
100126: LD_INT 117
100128: PUSH
100129: LD_INT 118
100131: PUSH
100132: EMPTY
100133: LIST
100134: LIST
100135: LIST
100136: LIST
100137: LIST
100138: LIST
100139: LIST
100140: LIST
100141: LIST
100142: LIST
100143: LIST
100144: LIST
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: LIST
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: ST_TO_ADDR
100155: GO 101394
100157: LD_INT 14
100159: DOUBLE
100160: EQUAL
100161: IFTRUE 100165
100163: GO 100389
100165: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
100166: LD_ADDR_VAR 0 2
100170: PUSH
100171: LD_INT 1
100173: PUSH
100174: LD_INT 2
100176: PUSH
100177: LD_INT 3
100179: PUSH
100180: LD_INT 4
100182: PUSH
100183: LD_INT 5
100185: PUSH
100186: LD_INT 6
100188: PUSH
100189: LD_INT 7
100191: PUSH
100192: LD_INT 8
100194: PUSH
100195: LD_INT 9
100197: PUSH
100198: LD_INT 10
100200: PUSH
100201: LD_INT 11
100203: PUSH
100204: LD_INT 12
100206: PUSH
100207: LD_INT 13
100209: PUSH
100210: LD_INT 14
100212: PUSH
100213: LD_INT 15
100215: PUSH
100216: LD_INT 16
100218: PUSH
100219: LD_INT 17
100221: PUSH
100222: LD_INT 18
100224: PUSH
100225: LD_INT 19
100227: PUSH
100228: LD_INT 20
100230: PUSH
100231: LD_INT 21
100233: PUSH
100234: LD_INT 22
100236: PUSH
100237: LD_INT 23
100239: PUSH
100240: LD_INT 24
100242: PUSH
100243: LD_INT 25
100245: PUSH
100246: LD_INT 26
100248: PUSH
100249: LD_INT 27
100251: PUSH
100252: LD_INT 28
100254: PUSH
100255: LD_INT 29
100257: PUSH
100258: LD_INT 30
100260: PUSH
100261: LD_INT 31
100263: PUSH
100264: LD_INT 32
100266: PUSH
100267: LD_INT 33
100269: PUSH
100270: LD_INT 34
100272: PUSH
100273: LD_INT 36
100275: PUSH
100276: EMPTY
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: LIST
100290: LIST
100291: LIST
100292: LIST
100293: LIST
100294: LIST
100295: LIST
100296: LIST
100297: LIST
100298: LIST
100299: LIST
100300: LIST
100301: LIST
100302: LIST
100303: LIST
100304: LIST
100305: LIST
100306: LIST
100307: LIST
100308: LIST
100309: LIST
100310: LIST
100311: LIST
100312: PUSH
100313: LD_INT 101
100315: PUSH
100316: LD_INT 102
100318: PUSH
100319: LD_INT 103
100321: PUSH
100322: LD_INT 104
100324: PUSH
100325: LD_INT 105
100327: PUSH
100328: LD_INT 106
100330: PUSH
100331: LD_INT 107
100333: PUSH
100334: LD_INT 108
100336: PUSH
100337: LD_INT 109
100339: PUSH
100340: LD_INT 110
100342: PUSH
100343: LD_INT 111
100345: PUSH
100346: LD_INT 112
100348: PUSH
100349: LD_INT 113
100351: PUSH
100352: LD_INT 114
100354: PUSH
100355: LD_INT 116
100357: PUSH
100358: LD_INT 117
100360: PUSH
100361: LD_INT 118
100363: PUSH
100364: EMPTY
100365: LIST
100366: LIST
100367: LIST
100368: LIST
100369: LIST
100370: LIST
100371: LIST
100372: LIST
100373: LIST
100374: LIST
100375: LIST
100376: LIST
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: LIST
100382: PUSH
100383: EMPTY
100384: LIST
100385: LIST
100386: ST_TO_ADDR
100387: GO 101394
100389: LD_INT 15
100391: DOUBLE
100392: EQUAL
100393: IFTRUE 100397
100395: GO 100621
100397: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100398: LD_ADDR_VAR 0 2
100402: PUSH
100403: LD_INT 1
100405: PUSH
100406: LD_INT 2
100408: PUSH
100409: LD_INT 3
100411: PUSH
100412: LD_INT 4
100414: PUSH
100415: LD_INT 5
100417: PUSH
100418: LD_INT 6
100420: PUSH
100421: LD_INT 7
100423: PUSH
100424: LD_INT 8
100426: PUSH
100427: LD_INT 9
100429: PUSH
100430: LD_INT 10
100432: PUSH
100433: LD_INT 11
100435: PUSH
100436: LD_INT 12
100438: PUSH
100439: LD_INT 13
100441: PUSH
100442: LD_INT 14
100444: PUSH
100445: LD_INT 15
100447: PUSH
100448: LD_INT 16
100450: PUSH
100451: LD_INT 17
100453: PUSH
100454: LD_INT 18
100456: PUSH
100457: LD_INT 19
100459: PUSH
100460: LD_INT 20
100462: PUSH
100463: LD_INT 21
100465: PUSH
100466: LD_INT 22
100468: PUSH
100469: LD_INT 23
100471: PUSH
100472: LD_INT 24
100474: PUSH
100475: LD_INT 25
100477: PUSH
100478: LD_INT 26
100480: PUSH
100481: LD_INT 27
100483: PUSH
100484: LD_INT 28
100486: PUSH
100487: LD_INT 29
100489: PUSH
100490: LD_INT 30
100492: PUSH
100493: LD_INT 31
100495: PUSH
100496: LD_INT 32
100498: PUSH
100499: LD_INT 33
100501: PUSH
100502: LD_INT 34
100504: PUSH
100505: LD_INT 36
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: LIST
100512: LIST
100513: LIST
100514: LIST
100515: LIST
100516: LIST
100517: LIST
100518: LIST
100519: LIST
100520: LIST
100521: LIST
100522: LIST
100523: LIST
100524: LIST
100525: LIST
100526: LIST
100527: LIST
100528: LIST
100529: LIST
100530: LIST
100531: LIST
100532: LIST
100533: LIST
100534: LIST
100535: LIST
100536: LIST
100537: LIST
100538: LIST
100539: LIST
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: PUSH
100545: LD_INT 101
100547: PUSH
100548: LD_INT 102
100550: PUSH
100551: LD_INT 103
100553: PUSH
100554: LD_INT 104
100556: PUSH
100557: LD_INT 105
100559: PUSH
100560: LD_INT 106
100562: PUSH
100563: LD_INT 107
100565: PUSH
100566: LD_INT 108
100568: PUSH
100569: LD_INT 109
100571: PUSH
100572: LD_INT 110
100574: PUSH
100575: LD_INT 111
100577: PUSH
100578: LD_INT 112
100580: PUSH
100581: LD_INT 113
100583: PUSH
100584: LD_INT 114
100586: PUSH
100587: LD_INT 116
100589: PUSH
100590: LD_INT 117
100592: PUSH
100593: LD_INT 118
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: LIST
100605: LIST
100606: LIST
100607: LIST
100608: LIST
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: ST_TO_ADDR
100619: GO 101394
100621: LD_INT 16
100623: DOUBLE
100624: EQUAL
100625: IFTRUE 100629
100627: GO 100765
100629: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100630: LD_ADDR_VAR 0 2
100634: PUSH
100635: LD_INT 2
100637: PUSH
100638: LD_INT 4
100640: PUSH
100641: LD_INT 5
100643: PUSH
100644: LD_INT 7
100646: PUSH
100647: LD_INT 11
100649: PUSH
100650: LD_INT 12
100652: PUSH
100653: LD_INT 15
100655: PUSH
100656: LD_INT 16
100658: PUSH
100659: LD_INT 20
100661: PUSH
100662: LD_INT 21
100664: PUSH
100665: LD_INT 22
100667: PUSH
100668: LD_INT 23
100670: PUSH
100671: LD_INT 25
100673: PUSH
100674: LD_INT 26
100676: PUSH
100677: LD_INT 30
100679: PUSH
100680: LD_INT 31
100682: PUSH
100683: LD_INT 32
100685: PUSH
100686: LD_INT 33
100688: PUSH
100689: LD_INT 34
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: LIST
100696: LIST
100697: LIST
100698: LIST
100699: LIST
100700: LIST
100701: LIST
100702: LIST
100703: LIST
100704: LIST
100705: LIST
100706: LIST
100707: LIST
100708: LIST
100709: LIST
100710: LIST
100711: LIST
100712: PUSH
100713: LD_INT 101
100715: PUSH
100716: LD_INT 102
100718: PUSH
100719: LD_INT 103
100721: PUSH
100722: LD_INT 106
100724: PUSH
100725: LD_INT 108
100727: PUSH
100728: LD_INT 112
100730: PUSH
100731: LD_INT 113
100733: PUSH
100734: LD_INT 114
100736: PUSH
100737: LD_INT 116
100739: PUSH
100740: LD_INT 117
100742: PUSH
100743: LD_INT 118
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: LIST
100750: LIST
100751: LIST
100752: LIST
100753: LIST
100754: LIST
100755: LIST
100756: LIST
100757: LIST
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: ST_TO_ADDR
100763: GO 101394
100765: LD_INT 17
100767: DOUBLE
100768: EQUAL
100769: IFTRUE 100773
100771: GO 100997
100773: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
100774: LD_ADDR_VAR 0 2
100778: PUSH
100779: LD_INT 1
100781: PUSH
100782: LD_INT 2
100784: PUSH
100785: LD_INT 3
100787: PUSH
100788: LD_INT 4
100790: PUSH
100791: LD_INT 5
100793: PUSH
100794: LD_INT 6
100796: PUSH
100797: LD_INT 7
100799: PUSH
100800: LD_INT 8
100802: PUSH
100803: LD_INT 9
100805: PUSH
100806: LD_INT 10
100808: PUSH
100809: LD_INT 11
100811: PUSH
100812: LD_INT 12
100814: PUSH
100815: LD_INT 13
100817: PUSH
100818: LD_INT 14
100820: PUSH
100821: LD_INT 15
100823: PUSH
100824: LD_INT 16
100826: PUSH
100827: LD_INT 17
100829: PUSH
100830: LD_INT 18
100832: PUSH
100833: LD_INT 19
100835: PUSH
100836: LD_INT 20
100838: PUSH
100839: LD_INT 21
100841: PUSH
100842: LD_INT 22
100844: PUSH
100845: LD_INT 23
100847: PUSH
100848: LD_INT 24
100850: PUSH
100851: LD_INT 25
100853: PUSH
100854: LD_INT 26
100856: PUSH
100857: LD_INT 27
100859: PUSH
100860: LD_INT 28
100862: PUSH
100863: LD_INT 29
100865: PUSH
100866: LD_INT 30
100868: PUSH
100869: LD_INT 31
100871: PUSH
100872: LD_INT 32
100874: PUSH
100875: LD_INT 33
100877: PUSH
100878: LD_INT 34
100880: PUSH
100881: LD_INT 36
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: LIST
100902: LIST
100903: LIST
100904: LIST
100905: LIST
100906: LIST
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: LIST
100912: LIST
100913: LIST
100914: LIST
100915: LIST
100916: LIST
100917: LIST
100918: LIST
100919: LIST
100920: PUSH
100921: LD_INT 101
100923: PUSH
100924: LD_INT 102
100926: PUSH
100927: LD_INT 103
100929: PUSH
100930: LD_INT 104
100932: PUSH
100933: LD_INT 105
100935: PUSH
100936: LD_INT 106
100938: PUSH
100939: LD_INT 107
100941: PUSH
100942: LD_INT 108
100944: PUSH
100945: LD_INT 109
100947: PUSH
100948: LD_INT 110
100950: PUSH
100951: LD_INT 111
100953: PUSH
100954: LD_INT 112
100956: PUSH
100957: LD_INT 113
100959: PUSH
100960: LD_INT 114
100962: PUSH
100963: LD_INT 116
100965: PUSH
100966: LD_INT 117
100968: PUSH
100969: LD_INT 118
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: LIST
100983: LIST
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: PUSH
100991: EMPTY
100992: LIST
100993: LIST
100994: ST_TO_ADDR
100995: GO 101394
100997: LD_INT 18
100999: DOUBLE
101000: EQUAL
101001: IFTRUE 101005
101003: GO 101153
101005: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
101006: LD_ADDR_VAR 0 2
101010: PUSH
101011: LD_INT 2
101013: PUSH
101014: LD_INT 4
101016: PUSH
101017: LD_INT 5
101019: PUSH
101020: LD_INT 7
101022: PUSH
101023: LD_INT 11
101025: PUSH
101026: LD_INT 12
101028: PUSH
101029: LD_INT 15
101031: PUSH
101032: LD_INT 16
101034: PUSH
101035: LD_INT 20
101037: PUSH
101038: LD_INT 21
101040: PUSH
101041: LD_INT 22
101043: PUSH
101044: LD_INT 23
101046: PUSH
101047: LD_INT 25
101049: PUSH
101050: LD_INT 26
101052: PUSH
101053: LD_INT 30
101055: PUSH
101056: LD_INT 31
101058: PUSH
101059: LD_INT 32
101061: PUSH
101062: LD_INT 33
101064: PUSH
101065: LD_INT 34
101067: PUSH
101068: LD_INT 35
101070: PUSH
101071: LD_INT 36
101073: PUSH
101074: EMPTY
101075: LIST
101076: LIST
101077: LIST
101078: LIST
101079: LIST
101080: LIST
101081: LIST
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: PUSH
101097: LD_INT 101
101099: PUSH
101100: LD_INT 102
101102: PUSH
101103: LD_INT 103
101105: PUSH
101106: LD_INT 106
101108: PUSH
101109: LD_INT 108
101111: PUSH
101112: LD_INT 112
101114: PUSH
101115: LD_INT 113
101117: PUSH
101118: LD_INT 114
101120: PUSH
101121: LD_INT 115
101123: PUSH
101124: LD_INT 116
101126: PUSH
101127: LD_INT 117
101129: PUSH
101130: LD_INT 118
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: LIST
101137: LIST
101138: LIST
101139: LIST
101140: LIST
101141: LIST
101142: LIST
101143: LIST
101144: LIST
101145: LIST
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: ST_TO_ADDR
101151: GO 101394
101153: LD_INT 19
101155: DOUBLE
101156: EQUAL
101157: IFTRUE 101161
101159: GO 101393
101161: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
101162: LD_ADDR_VAR 0 2
101166: PUSH
101167: LD_INT 1
101169: PUSH
101170: LD_INT 2
101172: PUSH
101173: LD_INT 3
101175: PUSH
101176: LD_INT 4
101178: PUSH
101179: LD_INT 5
101181: PUSH
101182: LD_INT 6
101184: PUSH
101185: LD_INT 7
101187: PUSH
101188: LD_INT 8
101190: PUSH
101191: LD_INT 9
101193: PUSH
101194: LD_INT 10
101196: PUSH
101197: LD_INT 11
101199: PUSH
101200: LD_INT 12
101202: PUSH
101203: LD_INT 13
101205: PUSH
101206: LD_INT 14
101208: PUSH
101209: LD_INT 15
101211: PUSH
101212: LD_INT 16
101214: PUSH
101215: LD_INT 17
101217: PUSH
101218: LD_INT 18
101220: PUSH
101221: LD_INT 19
101223: PUSH
101224: LD_INT 20
101226: PUSH
101227: LD_INT 21
101229: PUSH
101230: LD_INT 22
101232: PUSH
101233: LD_INT 23
101235: PUSH
101236: LD_INT 24
101238: PUSH
101239: LD_INT 25
101241: PUSH
101242: LD_INT 26
101244: PUSH
101245: LD_INT 27
101247: PUSH
101248: LD_INT 28
101250: PUSH
101251: LD_INT 29
101253: PUSH
101254: LD_INT 30
101256: PUSH
101257: LD_INT 31
101259: PUSH
101260: LD_INT 32
101262: PUSH
101263: LD_INT 33
101265: PUSH
101266: LD_INT 34
101268: PUSH
101269: LD_INT 35
101271: PUSH
101272: LD_INT 36
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: LIST
101284: LIST
101285: LIST
101286: LIST
101287: LIST
101288: LIST
101289: LIST
101290: LIST
101291: LIST
101292: LIST
101293: LIST
101294: LIST
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: PUSH
101313: LD_INT 101
101315: PUSH
101316: LD_INT 102
101318: PUSH
101319: LD_INT 103
101321: PUSH
101322: LD_INT 104
101324: PUSH
101325: LD_INT 105
101327: PUSH
101328: LD_INT 106
101330: PUSH
101331: LD_INT 107
101333: PUSH
101334: LD_INT 108
101336: PUSH
101337: LD_INT 109
101339: PUSH
101340: LD_INT 110
101342: PUSH
101343: LD_INT 111
101345: PUSH
101346: LD_INT 112
101348: PUSH
101349: LD_INT 113
101351: PUSH
101352: LD_INT 114
101354: PUSH
101355: LD_INT 115
101357: PUSH
101358: LD_INT 116
101360: PUSH
101361: LD_INT 117
101363: PUSH
101364: LD_INT 118
101366: PUSH
101367: EMPTY
101368: LIST
101369: LIST
101370: LIST
101371: LIST
101372: LIST
101373: LIST
101374: LIST
101375: LIST
101376: LIST
101377: LIST
101378: LIST
101379: LIST
101380: LIST
101381: LIST
101382: LIST
101383: LIST
101384: LIST
101385: LIST
101386: PUSH
101387: EMPTY
101388: LIST
101389: LIST
101390: ST_TO_ADDR
101391: GO 101394
101393: POP
// end else
101394: GO 101625
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101396: LD_ADDR_VAR 0 2
101400: PUSH
101401: LD_INT 1
101403: PUSH
101404: LD_INT 2
101406: PUSH
101407: LD_INT 3
101409: PUSH
101410: LD_INT 4
101412: PUSH
101413: LD_INT 5
101415: PUSH
101416: LD_INT 6
101418: PUSH
101419: LD_INT 7
101421: PUSH
101422: LD_INT 8
101424: PUSH
101425: LD_INT 9
101427: PUSH
101428: LD_INT 10
101430: PUSH
101431: LD_INT 11
101433: PUSH
101434: LD_INT 12
101436: PUSH
101437: LD_INT 13
101439: PUSH
101440: LD_INT 14
101442: PUSH
101443: LD_INT 15
101445: PUSH
101446: LD_INT 16
101448: PUSH
101449: LD_INT 17
101451: PUSH
101452: LD_INT 18
101454: PUSH
101455: LD_INT 19
101457: PUSH
101458: LD_INT 20
101460: PUSH
101461: LD_INT 21
101463: PUSH
101464: LD_INT 22
101466: PUSH
101467: LD_INT 23
101469: PUSH
101470: LD_INT 24
101472: PUSH
101473: LD_INT 25
101475: PUSH
101476: LD_INT 26
101478: PUSH
101479: LD_INT 27
101481: PUSH
101482: LD_INT 28
101484: PUSH
101485: LD_INT 29
101487: PUSH
101488: LD_INT 30
101490: PUSH
101491: LD_INT 31
101493: PUSH
101494: LD_INT 32
101496: PUSH
101497: LD_INT 33
101499: PUSH
101500: LD_INT 34
101502: PUSH
101503: LD_INT 35
101505: PUSH
101506: LD_INT 36
101508: PUSH
101509: EMPTY
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: LIST
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: PUSH
101547: LD_INT 101
101549: PUSH
101550: LD_INT 102
101552: PUSH
101553: LD_INT 103
101555: PUSH
101556: LD_INT 104
101558: PUSH
101559: LD_INT 105
101561: PUSH
101562: LD_INT 106
101564: PUSH
101565: LD_INT 107
101567: PUSH
101568: LD_INT 108
101570: PUSH
101571: LD_INT 109
101573: PUSH
101574: LD_INT 110
101576: PUSH
101577: LD_INT 111
101579: PUSH
101580: LD_INT 112
101582: PUSH
101583: LD_INT 113
101585: PUSH
101586: LD_INT 114
101588: PUSH
101589: LD_INT 115
101591: PUSH
101592: LD_INT 116
101594: PUSH
101595: LD_INT 117
101597: PUSH
101598: LD_INT 118
101600: PUSH
101601: EMPTY
101602: LIST
101603: LIST
101604: LIST
101605: LIST
101606: LIST
101607: LIST
101608: LIST
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: LIST
101614: LIST
101615: LIST
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: ST_TO_ADDR
// if result then
101625: LD_VAR 0 2
101629: IFFALSE 102415
// begin normal :=  ;
101631: LD_ADDR_VAR 0 5
101635: PUSH
101636: LD_STRING 
101638: ST_TO_ADDR
// hardcore :=  ;
101639: LD_ADDR_VAR 0 6
101643: PUSH
101644: LD_STRING 
101646: ST_TO_ADDR
// active :=  ;
101647: LD_ADDR_VAR 0 7
101651: PUSH
101652: LD_STRING 
101654: ST_TO_ADDR
// for i = 1 to normalCounter do
101655: LD_ADDR_VAR 0 8
101659: PUSH
101660: DOUBLE
101661: LD_INT 1
101663: DEC
101664: ST_TO_ADDR
101665: LD_EXP 127
101669: PUSH
101670: FOR_TO
101671: IFFALSE 101772
// begin tmp := 0 ;
101673: LD_ADDR_VAR 0 3
101677: PUSH
101678: LD_STRING 0
101680: ST_TO_ADDR
// if result [ 1 ] then
101681: LD_VAR 0 2
101685: PUSH
101686: LD_INT 1
101688: ARRAY
101689: IFFALSE 101754
// if result [ 1 ] [ 1 ] = i then
101691: LD_VAR 0 2
101695: PUSH
101696: LD_INT 1
101698: ARRAY
101699: PUSH
101700: LD_INT 1
101702: ARRAY
101703: PUSH
101704: LD_VAR 0 8
101708: EQUAL
101709: IFFALSE 101754
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101711: LD_ADDR_VAR 0 2
101715: PUSH
101716: LD_VAR 0 2
101720: PPUSH
101721: LD_INT 1
101723: PPUSH
101724: LD_VAR 0 2
101728: PUSH
101729: LD_INT 1
101731: ARRAY
101732: PPUSH
101733: LD_INT 1
101735: PPUSH
101736: CALL_OW 3
101740: PPUSH
101741: CALL_OW 1
101745: ST_TO_ADDR
// tmp := 1 ;
101746: LD_ADDR_VAR 0 3
101750: PUSH
101751: LD_STRING 1
101753: ST_TO_ADDR
// end ; normal := normal & tmp ;
101754: LD_ADDR_VAR 0 5
101758: PUSH
101759: LD_VAR 0 5
101763: PUSH
101764: LD_VAR 0 3
101768: STR
101769: ST_TO_ADDR
// end ;
101770: GO 101670
101772: POP
101773: POP
// for i = 1 to hardcoreCounter do
101774: LD_ADDR_VAR 0 8
101778: PUSH
101779: DOUBLE
101780: LD_INT 1
101782: DEC
101783: ST_TO_ADDR
101784: LD_EXP 128
101788: PUSH
101789: FOR_TO
101790: IFFALSE 101895
// begin tmp := 0 ;
101792: LD_ADDR_VAR 0 3
101796: PUSH
101797: LD_STRING 0
101799: ST_TO_ADDR
// if result [ 2 ] then
101800: LD_VAR 0 2
101804: PUSH
101805: LD_INT 2
101807: ARRAY
101808: IFFALSE 101877
// if result [ 2 ] [ 1 ] = 100 + i then
101810: LD_VAR 0 2
101814: PUSH
101815: LD_INT 2
101817: ARRAY
101818: PUSH
101819: LD_INT 1
101821: ARRAY
101822: PUSH
101823: LD_INT 100
101825: PUSH
101826: LD_VAR 0 8
101830: PLUS
101831: EQUAL
101832: IFFALSE 101877
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
101834: LD_ADDR_VAR 0 2
101838: PUSH
101839: LD_VAR 0 2
101843: PPUSH
101844: LD_INT 2
101846: PPUSH
101847: LD_VAR 0 2
101851: PUSH
101852: LD_INT 2
101854: ARRAY
101855: PPUSH
101856: LD_INT 1
101858: PPUSH
101859: CALL_OW 3
101863: PPUSH
101864: CALL_OW 1
101868: ST_TO_ADDR
// tmp := 1 ;
101869: LD_ADDR_VAR 0 3
101873: PUSH
101874: LD_STRING 1
101876: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
101877: LD_ADDR_VAR 0 6
101881: PUSH
101882: LD_VAR 0 6
101886: PUSH
101887: LD_VAR 0 3
101891: STR
101892: ST_TO_ADDR
// end ;
101893: GO 101789
101895: POP
101896: POP
// if isGameLoad then
101897: LD_VAR 0 1
101901: IFFALSE 102376
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101903: LD_ADDR_VAR 0 4
101907: PUSH
101908: LD_EXP 131
101912: PUSH
101913: LD_EXP 130
101917: PUSH
101918: LD_EXP 132
101922: PUSH
101923: LD_EXP 129
101927: PUSH
101928: LD_EXP 133
101932: PUSH
101933: LD_EXP 134
101937: PUSH
101938: LD_EXP 135
101942: PUSH
101943: LD_EXP 136
101947: PUSH
101948: LD_EXP 137
101952: PUSH
101953: LD_EXP 138
101957: PUSH
101958: LD_EXP 139
101962: PUSH
101963: LD_EXP 140
101967: PUSH
101968: LD_EXP 141
101972: PUSH
101973: LD_EXP 142
101977: PUSH
101978: LD_EXP 150
101982: PUSH
101983: LD_EXP 151
101987: PUSH
101988: LD_EXP 152
101992: PUSH
101993: LD_EXP 153
101997: PUSH
101998: LD_EXP 155
102002: PUSH
102003: LD_EXP 156
102007: PUSH
102008: LD_EXP 157
102012: PUSH
102013: LD_EXP 160
102017: PUSH
102018: LD_EXP 162
102022: PUSH
102023: LD_EXP 163
102027: PUSH
102028: LD_EXP 164
102032: PUSH
102033: LD_EXP 166
102037: PUSH
102038: LD_EXP 167
102042: PUSH
102043: LD_EXP 170
102047: PUSH
102048: LD_EXP 171
102052: PUSH
102053: LD_EXP 172
102057: PUSH
102058: LD_EXP 173
102062: PUSH
102063: LD_EXP 174
102067: PUSH
102068: LD_EXP 175
102072: PUSH
102073: LD_EXP 176
102077: PUSH
102078: LD_EXP 177
102082: PUSH
102083: LD_EXP 178
102087: PUSH
102088: LD_EXP 143
102092: PUSH
102093: LD_EXP 144
102097: PUSH
102098: LD_EXP 147
102102: PUSH
102103: LD_EXP 148
102107: PUSH
102108: LD_EXP 149
102112: PUSH
102113: LD_EXP 145
102117: PUSH
102118: LD_EXP 146
102122: PUSH
102123: LD_EXP 154
102127: PUSH
102128: LD_EXP 158
102132: PUSH
102133: LD_EXP 159
102137: PUSH
102138: LD_EXP 161
102142: PUSH
102143: LD_EXP 165
102147: PUSH
102148: LD_EXP 168
102152: PUSH
102153: LD_EXP 169
102157: PUSH
102158: LD_EXP 179
102162: PUSH
102163: LD_EXP 180
102167: PUSH
102168: LD_EXP 181
102172: PUSH
102173: LD_EXP 182
102177: PUSH
102178: EMPTY
102179: LIST
102180: LIST
102181: LIST
102182: LIST
102183: LIST
102184: LIST
102185: LIST
102186: LIST
102187: LIST
102188: LIST
102189: LIST
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: LIST
102195: LIST
102196: LIST
102197: LIST
102198: LIST
102199: LIST
102200: LIST
102201: LIST
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: LIST
102219: LIST
102220: LIST
102221: LIST
102222: LIST
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: LIST
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: ST_TO_ADDR
// tmp :=  ;
102234: LD_ADDR_VAR 0 3
102238: PUSH
102239: LD_STRING 
102241: ST_TO_ADDR
// for i = 1 to normalCounter do
102242: LD_ADDR_VAR 0 8
102246: PUSH
102247: DOUBLE
102248: LD_INT 1
102250: DEC
102251: ST_TO_ADDR
102252: LD_EXP 127
102256: PUSH
102257: FOR_TO
102258: IFFALSE 102294
// begin if flags [ i ] then
102260: LD_VAR 0 4
102264: PUSH
102265: LD_VAR 0 8
102269: ARRAY
102270: IFFALSE 102292
// tmp := tmp & i & ; ;
102272: LD_ADDR_VAR 0 3
102276: PUSH
102277: LD_VAR 0 3
102281: PUSH
102282: LD_VAR 0 8
102286: STR
102287: PUSH
102288: LD_STRING ;
102290: STR
102291: ST_TO_ADDR
// end ;
102292: GO 102257
102294: POP
102295: POP
// for i = 1 to hardcoreCounter do
102296: LD_ADDR_VAR 0 8
102300: PUSH
102301: DOUBLE
102302: LD_INT 1
102304: DEC
102305: ST_TO_ADDR
102306: LD_EXP 128
102310: PUSH
102311: FOR_TO
102312: IFFALSE 102358
// begin if flags [ normalCounter + i ] then
102314: LD_VAR 0 4
102318: PUSH
102319: LD_EXP 127
102323: PUSH
102324: LD_VAR 0 8
102328: PLUS
102329: ARRAY
102330: IFFALSE 102356
// tmp := tmp & ( 100 + i ) & ; ;
102332: LD_ADDR_VAR 0 3
102336: PUSH
102337: LD_VAR 0 3
102341: PUSH
102342: LD_INT 100
102344: PUSH
102345: LD_VAR 0 8
102349: PLUS
102350: STR
102351: PUSH
102352: LD_STRING ;
102354: STR
102355: ST_TO_ADDR
// end ;
102356: GO 102311
102358: POP
102359: POP
// if tmp then
102360: LD_VAR 0 3
102364: IFFALSE 102376
// active := tmp ;
102366: LD_ADDR_VAR 0 7
102370: PUSH
102371: LD_VAR 0 3
102375: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102376: LD_STRING getStreamItemsFromMission("
102378: PUSH
102379: LD_VAR 0 5
102383: STR
102384: PUSH
102385: LD_STRING ","
102387: STR
102388: PUSH
102389: LD_VAR 0 6
102393: STR
102394: PUSH
102395: LD_STRING ","
102397: STR
102398: PUSH
102399: LD_VAR 0 7
102403: STR
102404: PUSH
102405: LD_STRING ")
102407: STR
102408: PPUSH
102409: CALL_OW 559
// end else
102413: GO 102422
// ToLua ( getStreamItemsFromMission("","","") ) ;
102415: LD_STRING getStreamItemsFromMission("","","")
102417: PPUSH
102418: CALL_OW 559
// end ;
102422: LD_VAR 0 2
102426: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
102427: LD_EXP 126
102431: PUSH
102432: LD_EXP 131
102436: AND
102437: IFFALSE 102561
102439: GO 102441
102441: DISABLE
102442: LD_INT 0
102444: PPUSH
102445: PPUSH
// begin enable ;
102446: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102447: LD_ADDR_VAR 0 2
102451: PUSH
102452: LD_INT 22
102454: PUSH
102455: LD_OWVAR 2
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: PUSH
102464: LD_INT 2
102466: PUSH
102467: LD_INT 34
102469: PUSH
102470: LD_INT 7
102472: PUSH
102473: EMPTY
102474: LIST
102475: LIST
102476: PUSH
102477: LD_INT 34
102479: PUSH
102480: LD_INT 45
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: PUSH
102487: LD_INT 34
102489: PUSH
102490: LD_INT 28
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PUSH
102497: LD_INT 34
102499: PUSH
102500: LD_INT 47
102502: PUSH
102503: EMPTY
102504: LIST
102505: LIST
102506: PUSH
102507: EMPTY
102508: LIST
102509: LIST
102510: LIST
102511: LIST
102512: LIST
102513: PUSH
102514: EMPTY
102515: LIST
102516: LIST
102517: PPUSH
102518: CALL_OW 69
102522: ST_TO_ADDR
// if not tmp then
102523: LD_VAR 0 2
102527: NOT
102528: IFFALSE 102532
// exit ;
102530: GO 102561
// for i in tmp do
102532: LD_ADDR_VAR 0 1
102536: PUSH
102537: LD_VAR 0 2
102541: PUSH
102542: FOR_IN
102543: IFFALSE 102559
// begin SetLives ( i , 0 ) ;
102545: LD_VAR 0 1
102549: PPUSH
102550: LD_INT 0
102552: PPUSH
102553: CALL_OW 234
// end ;
102557: GO 102542
102559: POP
102560: POP
// end ;
102561: PPOPN 2
102563: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102564: LD_EXP 126
102568: PUSH
102569: LD_EXP 132
102573: AND
102574: IFFALSE 102658
102576: GO 102578
102578: DISABLE
102579: LD_INT 0
102581: PPUSH
102582: PPUSH
// begin enable ;
102583: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102584: LD_ADDR_VAR 0 2
102588: PUSH
102589: LD_INT 22
102591: PUSH
102592: LD_OWVAR 2
102596: PUSH
102597: EMPTY
102598: LIST
102599: LIST
102600: PUSH
102601: LD_INT 32
102603: PUSH
102604: LD_INT 3
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: PUSH
102611: EMPTY
102612: LIST
102613: LIST
102614: PPUSH
102615: CALL_OW 69
102619: ST_TO_ADDR
// if not tmp then
102620: LD_VAR 0 2
102624: NOT
102625: IFFALSE 102629
// exit ;
102627: GO 102658
// for i in tmp do
102629: LD_ADDR_VAR 0 1
102633: PUSH
102634: LD_VAR 0 2
102638: PUSH
102639: FOR_IN
102640: IFFALSE 102656
// begin SetLives ( i , 0 ) ;
102642: LD_VAR 0 1
102646: PPUSH
102647: LD_INT 0
102649: PPUSH
102650: CALL_OW 234
// end ;
102654: GO 102639
102656: POP
102657: POP
// end ;
102658: PPOPN 2
102660: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102661: LD_EXP 126
102665: PUSH
102666: LD_EXP 129
102670: AND
102671: IFFALSE 102764
102673: GO 102675
102675: DISABLE
102676: LD_INT 0
102678: PPUSH
// begin enable ;
102679: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102680: LD_ADDR_VAR 0 1
102684: PUSH
102685: LD_INT 22
102687: PUSH
102688: LD_OWVAR 2
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: PUSH
102697: LD_INT 2
102699: PUSH
102700: LD_INT 25
102702: PUSH
102703: LD_INT 5
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: PUSH
102710: LD_INT 25
102712: PUSH
102713: LD_INT 9
102715: PUSH
102716: EMPTY
102717: LIST
102718: LIST
102719: PUSH
102720: LD_INT 25
102722: PUSH
102723: LD_INT 8
102725: PUSH
102726: EMPTY
102727: LIST
102728: LIST
102729: PUSH
102730: EMPTY
102731: LIST
102732: LIST
102733: LIST
102734: LIST
102735: PUSH
102736: EMPTY
102737: LIST
102738: LIST
102739: PPUSH
102740: CALL_OW 69
102744: PUSH
102745: FOR_IN
102746: IFFALSE 102762
// begin SetClass ( i , 1 ) ;
102748: LD_VAR 0 1
102752: PPUSH
102753: LD_INT 1
102755: PPUSH
102756: CALL_OW 336
// end ;
102760: GO 102745
102762: POP
102763: POP
// end ;
102764: PPOPN 1
102766: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
102767: LD_EXP 126
102771: PUSH
102772: LD_EXP 130
102776: AND
102777: PUSH
102778: LD_OWVAR 65
102782: PUSH
102783: LD_INT 7
102785: LESS
102786: AND
102787: IFFALSE 102801
102789: GO 102791
102791: DISABLE
// begin enable ;
102792: ENABLE
// game_speed := 7 ;
102793: LD_ADDR_OWVAR 65
102797: PUSH
102798: LD_INT 7
102800: ST_TO_ADDR
// end ;
102801: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
102802: LD_EXP 126
102806: PUSH
102807: LD_EXP 133
102811: AND
102812: IFFALSE 103014
102814: GO 102816
102816: DISABLE
102817: LD_INT 0
102819: PPUSH
102820: PPUSH
102821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102822: LD_ADDR_VAR 0 3
102826: PUSH
102827: LD_INT 81
102829: PUSH
102830: LD_OWVAR 2
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: PUSH
102839: LD_INT 21
102841: PUSH
102842: LD_INT 1
102844: PUSH
102845: EMPTY
102846: LIST
102847: LIST
102848: PUSH
102849: EMPTY
102850: LIST
102851: LIST
102852: PPUSH
102853: CALL_OW 69
102857: ST_TO_ADDR
// if not tmp then
102858: LD_VAR 0 3
102862: NOT
102863: IFFALSE 102867
// exit ;
102865: GO 103014
// if tmp > 5 then
102867: LD_VAR 0 3
102871: PUSH
102872: LD_INT 5
102874: GREATER
102875: IFFALSE 102887
// k := 5 else
102877: LD_ADDR_VAR 0 2
102881: PUSH
102882: LD_INT 5
102884: ST_TO_ADDR
102885: GO 102897
// k := tmp ;
102887: LD_ADDR_VAR 0 2
102891: PUSH
102892: LD_VAR 0 3
102896: ST_TO_ADDR
// for i := 1 to k do
102897: LD_ADDR_VAR 0 1
102901: PUSH
102902: DOUBLE
102903: LD_INT 1
102905: DEC
102906: ST_TO_ADDR
102907: LD_VAR 0 2
102911: PUSH
102912: FOR_TO
102913: IFFALSE 103012
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102915: LD_VAR 0 3
102919: PUSH
102920: LD_VAR 0 1
102924: ARRAY
102925: PPUSH
102926: LD_VAR 0 1
102930: PUSH
102931: LD_INT 4
102933: MOD
102934: PUSH
102935: LD_INT 1
102937: PLUS
102938: PPUSH
102939: CALL_OW 259
102943: PUSH
102944: LD_INT 10
102946: LESS
102947: IFFALSE 103010
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102949: LD_VAR 0 3
102953: PUSH
102954: LD_VAR 0 1
102958: ARRAY
102959: PPUSH
102960: LD_VAR 0 1
102964: PUSH
102965: LD_INT 4
102967: MOD
102968: PUSH
102969: LD_INT 1
102971: PLUS
102972: PPUSH
102973: LD_VAR 0 3
102977: PUSH
102978: LD_VAR 0 1
102982: ARRAY
102983: PPUSH
102984: LD_VAR 0 1
102988: PUSH
102989: LD_INT 4
102991: MOD
102992: PUSH
102993: LD_INT 1
102995: PLUS
102996: PPUSH
102997: CALL_OW 259
103001: PUSH
103002: LD_INT 1
103004: PLUS
103005: PPUSH
103006: CALL_OW 237
103010: GO 102912
103012: POP
103013: POP
// end ;
103014: PPOPN 3
103016: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
103017: LD_EXP 126
103021: PUSH
103022: LD_EXP 134
103026: AND
103027: IFFALSE 103047
103029: GO 103031
103031: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
103032: LD_INT 4
103034: PPUSH
103035: LD_OWVAR 2
103039: PPUSH
103040: LD_INT 0
103042: PPUSH
103043: CALL_OW 324
103047: END
// every 0 0$1 trigger StreamModeActive and sShovel do
103048: LD_EXP 126
103052: PUSH
103053: LD_EXP 163
103057: AND
103058: IFFALSE 103078
103060: GO 103062
103062: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
103063: LD_INT 19
103065: PPUSH
103066: LD_OWVAR 2
103070: PPUSH
103071: LD_INT 0
103073: PPUSH
103074: CALL_OW 324
103078: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
103079: LD_EXP 126
103083: PUSH
103084: LD_EXP 135
103088: AND
103089: IFFALSE 103191
103091: GO 103093
103093: DISABLE
103094: LD_INT 0
103096: PPUSH
103097: PPUSH
// begin enable ;
103098: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
103099: LD_ADDR_VAR 0 2
103103: PUSH
103104: LD_INT 22
103106: PUSH
103107: LD_OWVAR 2
103111: PUSH
103112: EMPTY
103113: LIST
103114: LIST
103115: PUSH
103116: LD_INT 2
103118: PUSH
103119: LD_INT 34
103121: PUSH
103122: LD_INT 11
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: PUSH
103129: LD_INT 34
103131: PUSH
103132: LD_INT 30
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: PUSH
103139: EMPTY
103140: LIST
103141: LIST
103142: LIST
103143: PUSH
103144: EMPTY
103145: LIST
103146: LIST
103147: PPUSH
103148: CALL_OW 69
103152: ST_TO_ADDR
// if not tmp then
103153: LD_VAR 0 2
103157: NOT
103158: IFFALSE 103162
// exit ;
103160: GO 103191
// for i in tmp do
103162: LD_ADDR_VAR 0 1
103166: PUSH
103167: LD_VAR 0 2
103171: PUSH
103172: FOR_IN
103173: IFFALSE 103189
// begin SetLives ( i , 0 ) ;
103175: LD_VAR 0 1
103179: PPUSH
103180: LD_INT 0
103182: PPUSH
103183: CALL_OW 234
// end ;
103187: GO 103172
103189: POP
103190: POP
// end ;
103191: PPOPN 2
103193: END
// every 0 0$1 trigger StreamModeActive and sBunker do
103194: LD_EXP 126
103198: PUSH
103199: LD_EXP 136
103203: AND
103204: IFFALSE 103224
103206: GO 103208
103208: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
103209: LD_INT 32
103211: PPUSH
103212: LD_OWVAR 2
103216: PPUSH
103217: LD_INT 0
103219: PPUSH
103220: CALL_OW 324
103224: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
103225: LD_EXP 126
103229: PUSH
103230: LD_EXP 137
103234: AND
103235: IFFALSE 103416
103237: GO 103239
103239: DISABLE
103240: LD_INT 0
103242: PPUSH
103243: PPUSH
103244: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
103245: LD_ADDR_VAR 0 2
103249: PUSH
103250: LD_INT 22
103252: PUSH
103253: LD_OWVAR 2
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PUSH
103262: LD_INT 33
103264: PUSH
103265: LD_INT 3
103267: PUSH
103268: EMPTY
103269: LIST
103270: LIST
103271: PUSH
103272: EMPTY
103273: LIST
103274: LIST
103275: PPUSH
103276: CALL_OW 69
103280: ST_TO_ADDR
// if not tmp then
103281: LD_VAR 0 2
103285: NOT
103286: IFFALSE 103290
// exit ;
103288: GO 103416
// side := 0 ;
103290: LD_ADDR_VAR 0 3
103294: PUSH
103295: LD_INT 0
103297: ST_TO_ADDR
// for i := 1 to 8 do
103298: LD_ADDR_VAR 0 1
103302: PUSH
103303: DOUBLE
103304: LD_INT 1
103306: DEC
103307: ST_TO_ADDR
103308: LD_INT 8
103310: PUSH
103311: FOR_TO
103312: IFFALSE 103360
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103314: LD_OWVAR 2
103318: PUSH
103319: LD_VAR 0 1
103323: NONEQUAL
103324: PUSH
103325: LD_OWVAR 2
103329: PPUSH
103330: LD_VAR 0 1
103334: PPUSH
103335: CALL_OW 81
103339: PUSH
103340: LD_INT 2
103342: EQUAL
103343: AND
103344: IFFALSE 103358
// begin side := i ;
103346: LD_ADDR_VAR 0 3
103350: PUSH
103351: LD_VAR 0 1
103355: ST_TO_ADDR
// break ;
103356: GO 103360
// end ;
103358: GO 103311
103360: POP
103361: POP
// if not side then
103362: LD_VAR 0 3
103366: NOT
103367: IFFALSE 103371
// exit ;
103369: GO 103416
// for i := 1 to tmp do
103371: LD_ADDR_VAR 0 1
103375: PUSH
103376: DOUBLE
103377: LD_INT 1
103379: DEC
103380: ST_TO_ADDR
103381: LD_VAR 0 2
103385: PUSH
103386: FOR_TO
103387: IFFALSE 103414
// if Prob ( 60 ) then
103389: LD_INT 60
103391: PPUSH
103392: CALL_OW 13
103396: IFFALSE 103412
// SetSide ( i , side ) ;
103398: LD_VAR 0 1
103402: PPUSH
103403: LD_VAR 0 3
103407: PPUSH
103408: CALL_OW 235
103412: GO 103386
103414: POP
103415: POP
// end ;
103416: PPOPN 3
103418: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
103419: LD_EXP 126
103423: PUSH
103424: LD_EXP 139
103428: AND
103429: IFFALSE 103548
103431: GO 103433
103433: DISABLE
103434: LD_INT 0
103436: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103437: LD_ADDR_VAR 0 1
103441: PUSH
103442: LD_INT 22
103444: PUSH
103445: LD_OWVAR 2
103449: PUSH
103450: EMPTY
103451: LIST
103452: LIST
103453: PUSH
103454: LD_INT 21
103456: PUSH
103457: LD_INT 1
103459: PUSH
103460: EMPTY
103461: LIST
103462: LIST
103463: PUSH
103464: LD_INT 3
103466: PUSH
103467: LD_INT 23
103469: PUSH
103470: LD_INT 0
103472: PUSH
103473: EMPTY
103474: LIST
103475: LIST
103476: PUSH
103477: EMPTY
103478: LIST
103479: LIST
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: LIST
103485: PPUSH
103486: CALL_OW 69
103490: PUSH
103491: FOR_IN
103492: IFFALSE 103546
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103494: LD_VAR 0 1
103498: PPUSH
103499: CALL_OW 257
103503: PUSH
103504: LD_INT 1
103506: PUSH
103507: LD_INT 2
103509: PUSH
103510: LD_INT 3
103512: PUSH
103513: LD_INT 4
103515: PUSH
103516: EMPTY
103517: LIST
103518: LIST
103519: LIST
103520: LIST
103521: IN
103522: IFFALSE 103544
// SetClass ( un , rand ( 1 , 4 ) ) ;
103524: LD_VAR 0 1
103528: PPUSH
103529: LD_INT 1
103531: PPUSH
103532: LD_INT 4
103534: PPUSH
103535: CALL_OW 12
103539: PPUSH
103540: CALL_OW 336
103544: GO 103491
103546: POP
103547: POP
// end ;
103548: PPOPN 1
103550: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103551: LD_EXP 126
103555: PUSH
103556: LD_EXP 138
103560: AND
103561: IFFALSE 103640
103563: GO 103565
103565: DISABLE
103566: LD_INT 0
103568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103569: LD_ADDR_VAR 0 1
103573: PUSH
103574: LD_INT 22
103576: PUSH
103577: LD_OWVAR 2
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: PUSH
103586: LD_INT 21
103588: PUSH
103589: LD_INT 3
103591: PUSH
103592: EMPTY
103593: LIST
103594: LIST
103595: PUSH
103596: EMPTY
103597: LIST
103598: LIST
103599: PPUSH
103600: CALL_OW 69
103604: ST_TO_ADDR
// if not tmp then
103605: LD_VAR 0 1
103609: NOT
103610: IFFALSE 103614
// exit ;
103612: GO 103640
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103614: LD_VAR 0 1
103618: PUSH
103619: LD_INT 1
103621: PPUSH
103622: LD_VAR 0 1
103626: PPUSH
103627: CALL_OW 12
103631: ARRAY
103632: PPUSH
103633: LD_INT 100
103635: PPUSH
103636: CALL_OW 234
// end ;
103640: PPOPN 1
103642: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103643: LD_EXP 126
103647: PUSH
103648: LD_EXP 140
103652: AND
103653: IFFALSE 103751
103655: GO 103657
103657: DISABLE
103658: LD_INT 0
103660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103661: LD_ADDR_VAR 0 1
103665: PUSH
103666: LD_INT 22
103668: PUSH
103669: LD_OWVAR 2
103673: PUSH
103674: EMPTY
103675: LIST
103676: LIST
103677: PUSH
103678: LD_INT 21
103680: PUSH
103681: LD_INT 1
103683: PUSH
103684: EMPTY
103685: LIST
103686: LIST
103687: PUSH
103688: EMPTY
103689: LIST
103690: LIST
103691: PPUSH
103692: CALL_OW 69
103696: ST_TO_ADDR
// if not tmp then
103697: LD_VAR 0 1
103701: NOT
103702: IFFALSE 103706
// exit ;
103704: GO 103751
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103706: LD_VAR 0 1
103710: PUSH
103711: LD_INT 1
103713: PPUSH
103714: LD_VAR 0 1
103718: PPUSH
103719: CALL_OW 12
103723: ARRAY
103724: PPUSH
103725: LD_INT 1
103727: PPUSH
103728: LD_INT 4
103730: PPUSH
103731: CALL_OW 12
103735: PPUSH
103736: LD_INT 3000
103738: PPUSH
103739: LD_INT 9000
103741: PPUSH
103742: CALL_OW 12
103746: PPUSH
103747: CALL_OW 492
// end ;
103751: PPOPN 1
103753: END
// every 0 0$1 trigger StreamModeActive and sDepot do
103754: LD_EXP 126
103758: PUSH
103759: LD_EXP 141
103763: AND
103764: IFFALSE 103784
103766: GO 103768
103768: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
103769: LD_INT 1
103771: PPUSH
103772: LD_OWVAR 2
103776: PPUSH
103777: LD_INT 0
103779: PPUSH
103780: CALL_OW 324
103784: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
103785: LD_EXP 126
103789: PUSH
103790: LD_EXP 142
103794: AND
103795: IFFALSE 103878
103797: GO 103799
103799: DISABLE
103800: LD_INT 0
103802: PPUSH
103803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103804: LD_ADDR_VAR 0 2
103808: PUSH
103809: LD_INT 22
103811: PUSH
103812: LD_OWVAR 2
103816: PUSH
103817: EMPTY
103818: LIST
103819: LIST
103820: PUSH
103821: LD_INT 21
103823: PUSH
103824: LD_INT 3
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: PUSH
103831: EMPTY
103832: LIST
103833: LIST
103834: PPUSH
103835: CALL_OW 69
103839: ST_TO_ADDR
// if not tmp then
103840: LD_VAR 0 2
103844: NOT
103845: IFFALSE 103849
// exit ;
103847: GO 103878
// for i in tmp do
103849: LD_ADDR_VAR 0 1
103853: PUSH
103854: LD_VAR 0 2
103858: PUSH
103859: FOR_IN
103860: IFFALSE 103876
// SetBLevel ( i , 10 ) ;
103862: LD_VAR 0 1
103866: PPUSH
103867: LD_INT 10
103869: PPUSH
103870: CALL_OW 241
103874: GO 103859
103876: POP
103877: POP
// end ;
103878: PPOPN 2
103880: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103881: LD_EXP 126
103885: PUSH
103886: LD_EXP 143
103890: AND
103891: IFFALSE 104002
103893: GO 103895
103895: DISABLE
103896: LD_INT 0
103898: PPUSH
103899: PPUSH
103900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103901: LD_ADDR_VAR 0 3
103905: PUSH
103906: LD_INT 22
103908: PUSH
103909: LD_OWVAR 2
103913: PUSH
103914: EMPTY
103915: LIST
103916: LIST
103917: PUSH
103918: LD_INT 25
103920: PUSH
103921: LD_INT 1
103923: PUSH
103924: EMPTY
103925: LIST
103926: LIST
103927: PUSH
103928: EMPTY
103929: LIST
103930: LIST
103931: PPUSH
103932: CALL_OW 69
103936: ST_TO_ADDR
// if not tmp then
103937: LD_VAR 0 3
103941: NOT
103942: IFFALSE 103946
// exit ;
103944: GO 104002
// un := tmp [ rand ( 1 , tmp ) ] ;
103946: LD_ADDR_VAR 0 2
103950: PUSH
103951: LD_VAR 0 3
103955: PUSH
103956: LD_INT 1
103958: PPUSH
103959: LD_VAR 0 3
103963: PPUSH
103964: CALL_OW 12
103968: ARRAY
103969: ST_TO_ADDR
// if Crawls ( un ) then
103970: LD_VAR 0 2
103974: PPUSH
103975: CALL_OW 318
103979: IFFALSE 103990
// ComWalk ( un ) ;
103981: LD_VAR 0 2
103985: PPUSH
103986: CALL_OW 138
// SetClass ( un , class_sniper ) ;
103990: LD_VAR 0 2
103994: PPUSH
103995: LD_INT 5
103997: PPUSH
103998: CALL_OW 336
// end ;
104002: PPOPN 3
104004: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
104005: LD_EXP 126
104009: PUSH
104010: LD_EXP 144
104014: AND
104015: PUSH
104016: LD_OWVAR 67
104020: PUSH
104021: LD_INT 4
104023: LESS
104024: AND
104025: IFFALSE 104044
104027: GO 104029
104029: DISABLE
// begin Difficulty := Difficulty + 1 ;
104030: LD_ADDR_OWVAR 67
104034: PUSH
104035: LD_OWVAR 67
104039: PUSH
104040: LD_INT 1
104042: PLUS
104043: ST_TO_ADDR
// end ;
104044: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
104045: LD_EXP 126
104049: PUSH
104050: LD_EXP 145
104054: AND
104055: IFFALSE 104158
104057: GO 104059
104059: DISABLE
104060: LD_INT 0
104062: PPUSH
// begin for i := 1 to 5 do
104063: LD_ADDR_VAR 0 1
104067: PUSH
104068: DOUBLE
104069: LD_INT 1
104071: DEC
104072: ST_TO_ADDR
104073: LD_INT 5
104075: PUSH
104076: FOR_TO
104077: IFFALSE 104156
// begin uc_nation := nation_nature ;
104079: LD_ADDR_OWVAR 21
104083: PUSH
104084: LD_INT 0
104086: ST_TO_ADDR
// uc_side := 0 ;
104087: LD_ADDR_OWVAR 20
104091: PUSH
104092: LD_INT 0
104094: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104095: LD_ADDR_OWVAR 29
104099: PUSH
104100: LD_INT 12
104102: PUSH
104103: LD_INT 12
104105: PUSH
104106: EMPTY
104107: LIST
104108: LIST
104109: ST_TO_ADDR
// hc_agressivity := 20 ;
104110: LD_ADDR_OWVAR 35
104114: PUSH
104115: LD_INT 20
104117: ST_TO_ADDR
// hc_class := class_tiger ;
104118: LD_ADDR_OWVAR 28
104122: PUSH
104123: LD_INT 14
104125: ST_TO_ADDR
// hc_gallery :=  ;
104126: LD_ADDR_OWVAR 33
104130: PUSH
104131: LD_STRING 
104133: ST_TO_ADDR
// hc_name :=  ;
104134: LD_ADDR_OWVAR 26
104138: PUSH
104139: LD_STRING 
104141: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
104142: CALL_OW 44
104146: PPUSH
104147: LD_INT 0
104149: PPUSH
104150: CALL_OW 51
// end ;
104154: GO 104076
104156: POP
104157: POP
// end ;
104158: PPOPN 1
104160: END
// every 0 0$1 trigger StreamModeActive and sBomb do
104161: LD_EXP 126
104165: PUSH
104166: LD_EXP 146
104170: AND
104171: IFFALSE 104180
104173: GO 104175
104175: DISABLE
// StreamSibBomb ;
104176: CALL 104181 0 0
104180: END
// export function StreamSibBomb ; var i , x , y ; begin
104181: LD_INT 0
104183: PPUSH
104184: PPUSH
104185: PPUSH
104186: PPUSH
// result := false ;
104187: LD_ADDR_VAR 0 1
104191: PUSH
104192: LD_INT 0
104194: ST_TO_ADDR
// for i := 1 to 16 do
104195: LD_ADDR_VAR 0 2
104199: PUSH
104200: DOUBLE
104201: LD_INT 1
104203: DEC
104204: ST_TO_ADDR
104205: LD_INT 16
104207: PUSH
104208: FOR_TO
104209: IFFALSE 104408
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104211: LD_ADDR_VAR 0 3
104215: PUSH
104216: LD_INT 10
104218: PUSH
104219: LD_INT 20
104221: PUSH
104222: LD_INT 30
104224: PUSH
104225: LD_INT 40
104227: PUSH
104228: LD_INT 50
104230: PUSH
104231: LD_INT 60
104233: PUSH
104234: LD_INT 70
104236: PUSH
104237: LD_INT 80
104239: PUSH
104240: LD_INT 90
104242: PUSH
104243: LD_INT 100
104245: PUSH
104246: LD_INT 110
104248: PUSH
104249: LD_INT 120
104251: PUSH
104252: LD_INT 130
104254: PUSH
104255: LD_INT 140
104257: PUSH
104258: LD_INT 150
104260: PUSH
104261: EMPTY
104262: LIST
104263: LIST
104264: LIST
104265: LIST
104266: LIST
104267: LIST
104268: LIST
104269: LIST
104270: LIST
104271: LIST
104272: LIST
104273: LIST
104274: LIST
104275: LIST
104276: LIST
104277: PUSH
104278: LD_INT 1
104280: PPUSH
104281: LD_INT 15
104283: PPUSH
104284: CALL_OW 12
104288: ARRAY
104289: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104290: LD_ADDR_VAR 0 4
104294: PUSH
104295: LD_INT 10
104297: PUSH
104298: LD_INT 20
104300: PUSH
104301: LD_INT 30
104303: PUSH
104304: LD_INT 40
104306: PUSH
104307: LD_INT 50
104309: PUSH
104310: LD_INT 60
104312: PUSH
104313: LD_INT 70
104315: PUSH
104316: LD_INT 80
104318: PUSH
104319: LD_INT 90
104321: PUSH
104322: LD_INT 100
104324: PUSH
104325: LD_INT 110
104327: PUSH
104328: LD_INT 120
104330: PUSH
104331: LD_INT 130
104333: PUSH
104334: LD_INT 140
104336: PUSH
104337: LD_INT 150
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: LIST
104344: LIST
104345: LIST
104346: LIST
104347: LIST
104348: LIST
104349: LIST
104350: LIST
104351: LIST
104352: LIST
104353: LIST
104354: LIST
104355: LIST
104356: PUSH
104357: LD_INT 1
104359: PPUSH
104360: LD_INT 15
104362: PPUSH
104363: CALL_OW 12
104367: ARRAY
104368: ST_TO_ADDR
// if ValidHex ( x , y ) then
104369: LD_VAR 0 3
104373: PPUSH
104374: LD_VAR 0 4
104378: PPUSH
104379: CALL_OW 488
104383: IFFALSE 104406
// begin result := [ x , y ] ;
104385: LD_ADDR_VAR 0 1
104389: PUSH
104390: LD_VAR 0 3
104394: PUSH
104395: LD_VAR 0 4
104399: PUSH
104400: EMPTY
104401: LIST
104402: LIST
104403: ST_TO_ADDR
// break ;
104404: GO 104408
// end ; end ;
104406: GO 104208
104408: POP
104409: POP
// if result then
104410: LD_VAR 0 1
104414: IFFALSE 104474
// begin ToLua ( playSibBomb() ) ;
104416: LD_STRING playSibBomb()
104418: PPUSH
104419: CALL_OW 559
// wait ( 0 0$14 ) ;
104423: LD_INT 490
104425: PPUSH
104426: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104430: LD_VAR 0 1
104434: PUSH
104435: LD_INT 1
104437: ARRAY
104438: PPUSH
104439: LD_VAR 0 1
104443: PUSH
104444: LD_INT 2
104446: ARRAY
104447: PPUSH
104448: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104452: LD_VAR 0 1
104456: PUSH
104457: LD_INT 1
104459: ARRAY
104460: PPUSH
104461: LD_VAR 0 1
104465: PUSH
104466: LD_INT 2
104468: ARRAY
104469: PPUSH
104470: CALL_OW 429
// end ; end ;
104474: LD_VAR 0 1
104478: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104479: LD_EXP 126
104483: PUSH
104484: LD_EXP 148
104488: AND
104489: IFFALSE 104501
104491: GO 104493
104493: DISABLE
// YouLost (  ) ;
104494: LD_STRING 
104496: PPUSH
104497: CALL_OW 104
104501: END
// every 0 0$1 trigger StreamModeActive and sFog do
104502: LD_EXP 126
104506: PUSH
104507: LD_EXP 147
104511: AND
104512: IFFALSE 104526
104514: GO 104516
104516: DISABLE
// FogOff ( your_side ) ;
104517: LD_OWVAR 2
104521: PPUSH
104522: CALL_OW 344
104526: END
// every 0 0$1 trigger StreamModeActive and sSun do
104527: LD_EXP 126
104531: PUSH
104532: LD_EXP 149
104536: AND
104537: IFFALSE 104565
104539: GO 104541
104541: DISABLE
// begin solar_recharge_percent := 0 ;
104542: LD_ADDR_OWVAR 79
104546: PUSH
104547: LD_INT 0
104549: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104550: LD_INT 10500
104552: PPUSH
104553: CALL_OW 67
// solar_recharge_percent := 100 ;
104557: LD_ADDR_OWVAR 79
104561: PUSH
104562: LD_INT 100
104564: ST_TO_ADDR
// end ;
104565: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104566: LD_EXP 126
104570: PUSH
104571: LD_EXP 150
104575: AND
104576: IFFALSE 104815
104578: GO 104580
104580: DISABLE
104581: LD_INT 0
104583: PPUSH
104584: PPUSH
104585: PPUSH
// begin tmp := [ ] ;
104586: LD_ADDR_VAR 0 3
104590: PUSH
104591: EMPTY
104592: ST_TO_ADDR
// for i := 1 to 6 do
104593: LD_ADDR_VAR 0 1
104597: PUSH
104598: DOUBLE
104599: LD_INT 1
104601: DEC
104602: ST_TO_ADDR
104603: LD_INT 6
104605: PUSH
104606: FOR_TO
104607: IFFALSE 104712
// begin uc_nation := nation_nature ;
104609: LD_ADDR_OWVAR 21
104613: PUSH
104614: LD_INT 0
104616: ST_TO_ADDR
// uc_side := 0 ;
104617: LD_ADDR_OWVAR 20
104621: PUSH
104622: LD_INT 0
104624: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104625: LD_ADDR_OWVAR 29
104629: PUSH
104630: LD_INT 12
104632: PUSH
104633: LD_INT 12
104635: PUSH
104636: EMPTY
104637: LIST
104638: LIST
104639: ST_TO_ADDR
// hc_agressivity := 20 ;
104640: LD_ADDR_OWVAR 35
104644: PUSH
104645: LD_INT 20
104647: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104648: LD_ADDR_OWVAR 28
104652: PUSH
104653: LD_INT 17
104655: ST_TO_ADDR
// hc_gallery :=  ;
104656: LD_ADDR_OWVAR 33
104660: PUSH
104661: LD_STRING 
104663: ST_TO_ADDR
// hc_name :=  ;
104664: LD_ADDR_OWVAR 26
104668: PUSH
104669: LD_STRING 
104671: ST_TO_ADDR
// un := CreateHuman ;
104672: LD_ADDR_VAR 0 2
104676: PUSH
104677: CALL_OW 44
104681: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104682: LD_VAR 0 2
104686: PPUSH
104687: LD_INT 1
104689: PPUSH
104690: CALL_OW 51
// tmp := tmp ^ un ;
104694: LD_ADDR_VAR 0 3
104698: PUSH
104699: LD_VAR 0 3
104703: PUSH
104704: LD_VAR 0 2
104708: ADD
104709: ST_TO_ADDR
// end ;
104710: GO 104606
104712: POP
104713: POP
// repeat wait ( 0 0$1 ) ;
104714: LD_INT 35
104716: PPUSH
104717: CALL_OW 67
// for un in tmp do
104721: LD_ADDR_VAR 0 2
104725: PUSH
104726: LD_VAR 0 3
104730: PUSH
104731: FOR_IN
104732: IFFALSE 104806
// begin if IsDead ( un ) then
104734: LD_VAR 0 2
104738: PPUSH
104739: CALL_OW 301
104743: IFFALSE 104763
// begin tmp := tmp diff un ;
104745: LD_ADDR_VAR 0 3
104749: PUSH
104750: LD_VAR 0 3
104754: PUSH
104755: LD_VAR 0 2
104759: DIFF
104760: ST_TO_ADDR
// continue ;
104761: GO 104731
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
104763: LD_VAR 0 2
104767: PPUSH
104768: LD_INT 3
104770: PUSH
104771: LD_INT 22
104773: PUSH
104774: LD_INT 0
104776: PUSH
104777: EMPTY
104778: LIST
104779: LIST
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: PPUSH
104785: CALL_OW 69
104789: PPUSH
104790: LD_VAR 0 2
104794: PPUSH
104795: CALL_OW 74
104799: PPUSH
104800: CALL_OW 115
// end ;
104804: GO 104731
104806: POP
104807: POP
// until not tmp ;
104808: LD_VAR 0 3
104812: NOT
104813: IFFALSE 104714
// end ;
104815: PPOPN 3
104817: END
// every 0 0$1 trigger StreamModeActive and sTroll do
104818: LD_EXP 126
104822: PUSH
104823: LD_EXP 151
104827: AND
104828: IFFALSE 104882
104830: GO 104832
104832: DISABLE
// begin ToLua ( displayTroll(); ) ;
104833: LD_STRING displayTroll();
104835: PPUSH
104836: CALL_OW 559
// wait ( 3 3$00 ) ;
104840: LD_INT 6300
104842: PPUSH
104843: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104847: LD_STRING hideTroll();
104849: PPUSH
104850: CALL_OW 559
// wait ( 1 1$00 ) ;
104854: LD_INT 2100
104856: PPUSH
104857: CALL_OW 67
// ToLua ( displayTroll(); ) ;
104861: LD_STRING displayTroll();
104863: PPUSH
104864: CALL_OW 559
// wait ( 1 1$00 ) ;
104868: LD_INT 2100
104870: PPUSH
104871: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104875: LD_STRING hideTroll();
104877: PPUSH
104878: CALL_OW 559
// end ;
104882: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104883: LD_EXP 126
104887: PUSH
104888: LD_EXP 152
104892: AND
104893: IFFALSE 104956
104895: GO 104897
104897: DISABLE
104898: LD_INT 0
104900: PPUSH
// begin p := 0 ;
104901: LD_ADDR_VAR 0 1
104905: PUSH
104906: LD_INT 0
104908: ST_TO_ADDR
// repeat game_speed := 1 ;
104909: LD_ADDR_OWVAR 65
104913: PUSH
104914: LD_INT 1
104916: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104917: LD_INT 35
104919: PPUSH
104920: CALL_OW 67
// p := p + 1 ;
104924: LD_ADDR_VAR 0 1
104928: PUSH
104929: LD_VAR 0 1
104933: PUSH
104934: LD_INT 1
104936: PLUS
104937: ST_TO_ADDR
// until p >= 60 ;
104938: LD_VAR 0 1
104942: PUSH
104943: LD_INT 60
104945: GREATEREQUAL
104946: IFFALSE 104909
// game_speed := 4 ;
104948: LD_ADDR_OWVAR 65
104952: PUSH
104953: LD_INT 4
104955: ST_TO_ADDR
// end ;
104956: PPOPN 1
104958: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
104959: LD_EXP 126
104963: PUSH
104964: LD_EXP 153
104968: AND
104969: IFFALSE 105115
104971: GO 104973
104973: DISABLE
104974: LD_INT 0
104976: PPUSH
104977: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104978: LD_ADDR_VAR 0 1
104982: PUSH
104983: LD_INT 22
104985: PUSH
104986: LD_OWVAR 2
104990: PUSH
104991: EMPTY
104992: LIST
104993: LIST
104994: PUSH
104995: LD_INT 2
104997: PUSH
104998: LD_INT 30
105000: PUSH
105001: LD_INT 0
105003: PUSH
105004: EMPTY
105005: LIST
105006: LIST
105007: PUSH
105008: LD_INT 30
105010: PUSH
105011: LD_INT 1
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PUSH
105018: EMPTY
105019: LIST
105020: LIST
105021: LIST
105022: PUSH
105023: EMPTY
105024: LIST
105025: LIST
105026: PPUSH
105027: CALL_OW 69
105031: ST_TO_ADDR
// if not depot then
105032: LD_VAR 0 1
105036: NOT
105037: IFFALSE 105041
// exit ;
105039: GO 105115
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
105041: LD_ADDR_VAR 0 2
105045: PUSH
105046: LD_VAR 0 1
105050: PUSH
105051: LD_INT 1
105053: PPUSH
105054: LD_VAR 0 1
105058: PPUSH
105059: CALL_OW 12
105063: ARRAY
105064: PPUSH
105065: CALL_OW 274
105069: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
105070: LD_VAR 0 2
105074: PPUSH
105075: LD_INT 1
105077: PPUSH
105078: LD_INT 0
105080: PPUSH
105081: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
105085: LD_VAR 0 2
105089: PPUSH
105090: LD_INT 2
105092: PPUSH
105093: LD_INT 0
105095: PPUSH
105096: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
105100: LD_VAR 0 2
105104: PPUSH
105105: LD_INT 3
105107: PPUSH
105108: LD_INT 0
105110: PPUSH
105111: CALL_OW 277
// end ;
105115: PPOPN 2
105117: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
105118: LD_EXP 126
105122: PUSH
105123: LD_EXP 154
105127: AND
105128: IFFALSE 105225
105130: GO 105132
105132: DISABLE
105133: LD_INT 0
105135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105136: LD_ADDR_VAR 0 1
105140: PUSH
105141: LD_INT 22
105143: PUSH
105144: LD_OWVAR 2
105148: PUSH
105149: EMPTY
105150: LIST
105151: LIST
105152: PUSH
105153: LD_INT 21
105155: PUSH
105156: LD_INT 1
105158: PUSH
105159: EMPTY
105160: LIST
105161: LIST
105162: PUSH
105163: LD_INT 3
105165: PUSH
105166: LD_INT 23
105168: PUSH
105169: LD_INT 0
105171: PUSH
105172: EMPTY
105173: LIST
105174: LIST
105175: PUSH
105176: EMPTY
105177: LIST
105178: LIST
105179: PUSH
105180: EMPTY
105181: LIST
105182: LIST
105183: LIST
105184: PPUSH
105185: CALL_OW 69
105189: ST_TO_ADDR
// if not tmp then
105190: LD_VAR 0 1
105194: NOT
105195: IFFALSE 105199
// exit ;
105197: GO 105225
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
105199: LD_VAR 0 1
105203: PUSH
105204: LD_INT 1
105206: PPUSH
105207: LD_VAR 0 1
105211: PPUSH
105212: CALL_OW 12
105216: ARRAY
105217: PPUSH
105218: LD_INT 200
105220: PPUSH
105221: CALL_OW 234
// end ;
105225: PPOPN 1
105227: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
105228: LD_EXP 126
105232: PUSH
105233: LD_EXP 155
105237: AND
105238: IFFALSE 105317
105240: GO 105242
105242: DISABLE
105243: LD_INT 0
105245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
105246: LD_ADDR_VAR 0 1
105250: PUSH
105251: LD_INT 22
105253: PUSH
105254: LD_OWVAR 2
105258: PUSH
105259: EMPTY
105260: LIST
105261: LIST
105262: PUSH
105263: LD_INT 21
105265: PUSH
105266: LD_INT 2
105268: PUSH
105269: EMPTY
105270: LIST
105271: LIST
105272: PUSH
105273: EMPTY
105274: LIST
105275: LIST
105276: PPUSH
105277: CALL_OW 69
105281: ST_TO_ADDR
// if not tmp then
105282: LD_VAR 0 1
105286: NOT
105287: IFFALSE 105291
// exit ;
105289: GO 105317
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105291: LD_VAR 0 1
105295: PUSH
105296: LD_INT 1
105298: PPUSH
105299: LD_VAR 0 1
105303: PPUSH
105304: CALL_OW 12
105308: ARRAY
105309: PPUSH
105310: LD_INT 60
105312: PPUSH
105313: CALL_OW 234
// end ;
105317: PPOPN 1
105319: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105320: LD_EXP 126
105324: PUSH
105325: LD_EXP 156
105329: AND
105330: IFFALSE 105429
105332: GO 105334
105334: DISABLE
105335: LD_INT 0
105337: PPUSH
105338: PPUSH
// begin enable ;
105339: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105340: LD_ADDR_VAR 0 1
105344: PUSH
105345: LD_INT 22
105347: PUSH
105348: LD_OWVAR 2
105352: PUSH
105353: EMPTY
105354: LIST
105355: LIST
105356: PUSH
105357: LD_INT 61
105359: PUSH
105360: EMPTY
105361: LIST
105362: PUSH
105363: LD_INT 33
105365: PUSH
105366: LD_INT 2
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: PUSH
105373: EMPTY
105374: LIST
105375: LIST
105376: LIST
105377: PPUSH
105378: CALL_OW 69
105382: ST_TO_ADDR
// if not tmp then
105383: LD_VAR 0 1
105387: NOT
105388: IFFALSE 105392
// exit ;
105390: GO 105429
// for i in tmp do
105392: LD_ADDR_VAR 0 2
105396: PUSH
105397: LD_VAR 0 1
105401: PUSH
105402: FOR_IN
105403: IFFALSE 105427
// if IsControledBy ( i ) then
105405: LD_VAR 0 2
105409: PPUSH
105410: CALL_OW 312
105414: IFFALSE 105425
// ComUnlink ( i ) ;
105416: LD_VAR 0 2
105420: PPUSH
105421: CALL_OW 136
105425: GO 105402
105427: POP
105428: POP
// end ;
105429: PPOPN 2
105431: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105432: LD_EXP 126
105436: PUSH
105437: LD_EXP 157
105441: AND
105442: IFFALSE 105582
105444: GO 105446
105446: DISABLE
105447: LD_INT 0
105449: PPUSH
105450: PPUSH
// begin ToLua ( displayPowell(); ) ;
105451: LD_STRING displayPowell();
105453: PPUSH
105454: CALL_OW 559
// uc_side := 0 ;
105458: LD_ADDR_OWVAR 20
105462: PUSH
105463: LD_INT 0
105465: ST_TO_ADDR
// uc_nation := 2 ;
105466: LD_ADDR_OWVAR 21
105470: PUSH
105471: LD_INT 2
105473: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105474: LD_ADDR_OWVAR 37
105478: PUSH
105479: LD_INT 14
105481: ST_TO_ADDR
// vc_engine := engine_siberite ;
105482: LD_ADDR_OWVAR 39
105486: PUSH
105487: LD_INT 3
105489: ST_TO_ADDR
// vc_control := control_apeman ;
105490: LD_ADDR_OWVAR 38
105494: PUSH
105495: LD_INT 5
105497: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105498: LD_ADDR_OWVAR 40
105502: PUSH
105503: LD_INT 29
105505: ST_TO_ADDR
// un := CreateVehicle ;
105506: LD_ADDR_VAR 0 2
105510: PUSH
105511: CALL_OW 45
105515: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105516: LD_VAR 0 2
105520: PPUSH
105521: LD_INT 1
105523: PPUSH
105524: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105528: LD_INT 35
105530: PPUSH
105531: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105535: LD_VAR 0 2
105539: PPUSH
105540: LD_INT 22
105542: PUSH
105543: LD_OWVAR 2
105547: PUSH
105548: EMPTY
105549: LIST
105550: LIST
105551: PPUSH
105552: CALL_OW 69
105556: PPUSH
105557: LD_VAR 0 2
105561: PPUSH
105562: CALL_OW 74
105566: PPUSH
105567: CALL_OW 115
// until IsDead ( un ) ;
105571: LD_VAR 0 2
105575: PPUSH
105576: CALL_OW 301
105580: IFFALSE 105528
// end ;
105582: PPOPN 2
105584: END
// every 0 0$1 trigger StreamModeActive and sStu do
105585: LD_EXP 126
105589: PUSH
105590: LD_EXP 165
105594: AND
105595: IFFALSE 105611
105597: GO 105599
105599: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105600: LD_STRING displayStucuk();
105602: PPUSH
105603: CALL_OW 559
// ResetFog ;
105607: CALL_OW 335
// end ;
105611: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105612: LD_EXP 126
105616: PUSH
105617: LD_EXP 158
105621: AND
105622: IFFALSE 105763
105624: GO 105626
105626: DISABLE
105627: LD_INT 0
105629: PPUSH
105630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105631: LD_ADDR_VAR 0 2
105635: PUSH
105636: LD_INT 22
105638: PUSH
105639: LD_OWVAR 2
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: PUSH
105648: LD_INT 21
105650: PUSH
105651: LD_INT 1
105653: PUSH
105654: EMPTY
105655: LIST
105656: LIST
105657: PUSH
105658: EMPTY
105659: LIST
105660: LIST
105661: PPUSH
105662: CALL_OW 69
105666: ST_TO_ADDR
// if not tmp then
105667: LD_VAR 0 2
105671: NOT
105672: IFFALSE 105676
// exit ;
105674: GO 105763
// un := tmp [ rand ( 1 , tmp ) ] ;
105676: LD_ADDR_VAR 0 1
105680: PUSH
105681: LD_VAR 0 2
105685: PUSH
105686: LD_INT 1
105688: PPUSH
105689: LD_VAR 0 2
105693: PPUSH
105694: CALL_OW 12
105698: ARRAY
105699: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105700: LD_VAR 0 1
105704: PPUSH
105705: LD_INT 0
105707: PPUSH
105708: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105712: LD_VAR 0 1
105716: PPUSH
105717: LD_OWVAR 3
105721: PUSH
105722: LD_VAR 0 1
105726: DIFF
105727: PPUSH
105728: LD_VAR 0 1
105732: PPUSH
105733: CALL_OW 74
105737: PPUSH
105738: CALL_OW 115
// wait ( 0 0$20 ) ;
105742: LD_INT 700
105744: PPUSH
105745: CALL_OW 67
// SetSide ( un , your_side ) ;
105749: LD_VAR 0 1
105753: PPUSH
105754: LD_OWVAR 2
105758: PPUSH
105759: CALL_OW 235
// end ;
105763: PPOPN 2
105765: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
105766: LD_EXP 126
105770: PUSH
105771: LD_EXP 159
105775: AND
105776: IFFALSE 105882
105778: GO 105780
105780: DISABLE
105781: LD_INT 0
105783: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105784: LD_ADDR_VAR 0 1
105788: PUSH
105789: LD_INT 22
105791: PUSH
105792: LD_OWVAR 2
105796: PUSH
105797: EMPTY
105798: LIST
105799: LIST
105800: PUSH
105801: LD_INT 2
105803: PUSH
105804: LD_INT 30
105806: PUSH
105807: LD_INT 0
105809: PUSH
105810: EMPTY
105811: LIST
105812: LIST
105813: PUSH
105814: LD_INT 30
105816: PUSH
105817: LD_INT 1
105819: PUSH
105820: EMPTY
105821: LIST
105822: LIST
105823: PUSH
105824: EMPTY
105825: LIST
105826: LIST
105827: LIST
105828: PUSH
105829: EMPTY
105830: LIST
105831: LIST
105832: PPUSH
105833: CALL_OW 69
105837: ST_TO_ADDR
// if not depot then
105838: LD_VAR 0 1
105842: NOT
105843: IFFALSE 105847
// exit ;
105845: GO 105882
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
105847: LD_VAR 0 1
105851: PUSH
105852: LD_INT 1
105854: ARRAY
105855: PPUSH
105856: CALL_OW 250
105860: PPUSH
105861: LD_VAR 0 1
105865: PUSH
105866: LD_INT 1
105868: ARRAY
105869: PPUSH
105870: CALL_OW 251
105874: PPUSH
105875: LD_INT 70
105877: PPUSH
105878: CALL_OW 495
// end ;
105882: PPOPN 1
105884: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105885: LD_EXP 126
105889: PUSH
105890: LD_EXP 160
105894: AND
105895: IFFALSE 106106
105897: GO 105899
105899: DISABLE
105900: LD_INT 0
105902: PPUSH
105903: PPUSH
105904: PPUSH
105905: PPUSH
105906: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105907: LD_ADDR_VAR 0 5
105911: PUSH
105912: LD_INT 22
105914: PUSH
105915: LD_OWVAR 2
105919: PUSH
105920: EMPTY
105921: LIST
105922: LIST
105923: PUSH
105924: LD_INT 21
105926: PUSH
105927: LD_INT 1
105929: PUSH
105930: EMPTY
105931: LIST
105932: LIST
105933: PUSH
105934: EMPTY
105935: LIST
105936: LIST
105937: PPUSH
105938: CALL_OW 69
105942: ST_TO_ADDR
// if not tmp then
105943: LD_VAR 0 5
105947: NOT
105948: IFFALSE 105952
// exit ;
105950: GO 106106
// for i in tmp do
105952: LD_ADDR_VAR 0 1
105956: PUSH
105957: LD_VAR 0 5
105961: PUSH
105962: FOR_IN
105963: IFFALSE 106104
// begin d := rand ( 0 , 5 ) ;
105965: LD_ADDR_VAR 0 4
105969: PUSH
105970: LD_INT 0
105972: PPUSH
105973: LD_INT 5
105975: PPUSH
105976: CALL_OW 12
105980: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
105981: LD_ADDR_VAR 0 2
105985: PUSH
105986: LD_VAR 0 1
105990: PPUSH
105991: CALL_OW 250
105995: PPUSH
105996: LD_VAR 0 4
106000: PPUSH
106001: LD_INT 3
106003: PPUSH
106004: LD_INT 12
106006: PPUSH
106007: CALL_OW 12
106011: PPUSH
106012: CALL_OW 272
106016: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
106017: LD_ADDR_VAR 0 3
106021: PUSH
106022: LD_VAR 0 1
106026: PPUSH
106027: CALL_OW 251
106031: PPUSH
106032: LD_VAR 0 4
106036: PPUSH
106037: LD_INT 3
106039: PPUSH
106040: LD_INT 12
106042: PPUSH
106043: CALL_OW 12
106047: PPUSH
106048: CALL_OW 273
106052: ST_TO_ADDR
// if ValidHex ( x , y ) then
106053: LD_VAR 0 2
106057: PPUSH
106058: LD_VAR 0 3
106062: PPUSH
106063: CALL_OW 488
106067: IFFALSE 106102
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
106069: LD_VAR 0 1
106073: PPUSH
106074: LD_VAR 0 2
106078: PPUSH
106079: LD_VAR 0 3
106083: PPUSH
106084: LD_INT 3
106086: PPUSH
106087: LD_INT 6
106089: PPUSH
106090: CALL_OW 12
106094: PPUSH
106095: LD_INT 1
106097: PPUSH
106098: CALL_OW 483
// end ;
106102: GO 105962
106104: POP
106105: POP
// end ;
106106: PPOPN 5
106108: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
106109: LD_EXP 126
106113: PUSH
106114: LD_EXP 161
106118: AND
106119: IFFALSE 106213
106121: GO 106123
106123: DISABLE
106124: LD_INT 0
106126: PPUSH
106127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
106128: LD_ADDR_VAR 0 2
106132: PUSH
106133: LD_INT 22
106135: PUSH
106136: LD_OWVAR 2
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: PUSH
106145: LD_INT 32
106147: PUSH
106148: LD_INT 1
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: PUSH
106155: LD_INT 21
106157: PUSH
106158: LD_INT 2
106160: PUSH
106161: EMPTY
106162: LIST
106163: LIST
106164: PUSH
106165: EMPTY
106166: LIST
106167: LIST
106168: LIST
106169: PPUSH
106170: CALL_OW 69
106174: ST_TO_ADDR
// if not tmp then
106175: LD_VAR 0 2
106179: NOT
106180: IFFALSE 106184
// exit ;
106182: GO 106213
// for i in tmp do
106184: LD_ADDR_VAR 0 1
106188: PUSH
106189: LD_VAR 0 2
106193: PUSH
106194: FOR_IN
106195: IFFALSE 106211
// SetFuel ( i , 0 ) ;
106197: LD_VAR 0 1
106201: PPUSH
106202: LD_INT 0
106204: PPUSH
106205: CALL_OW 240
106209: GO 106194
106211: POP
106212: POP
// end ;
106213: PPOPN 2
106215: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
106216: LD_EXP 126
106220: PUSH
106221: LD_EXP 162
106225: AND
106226: IFFALSE 106292
106228: GO 106230
106230: DISABLE
106231: LD_INT 0
106233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106234: LD_ADDR_VAR 0 1
106238: PUSH
106239: LD_INT 22
106241: PUSH
106242: LD_OWVAR 2
106246: PUSH
106247: EMPTY
106248: LIST
106249: LIST
106250: PUSH
106251: LD_INT 30
106253: PUSH
106254: LD_INT 29
106256: PUSH
106257: EMPTY
106258: LIST
106259: LIST
106260: PUSH
106261: EMPTY
106262: LIST
106263: LIST
106264: PPUSH
106265: CALL_OW 69
106269: ST_TO_ADDR
// if not tmp then
106270: LD_VAR 0 1
106274: NOT
106275: IFFALSE 106279
// exit ;
106277: GO 106292
// DestroyUnit ( tmp [ 1 ] ) ;
106279: LD_VAR 0 1
106283: PUSH
106284: LD_INT 1
106286: ARRAY
106287: PPUSH
106288: CALL_OW 65
// end ;
106292: PPOPN 1
106294: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106295: LD_EXP 126
106299: PUSH
106300: LD_EXP 164
106304: AND
106305: IFFALSE 106434
106307: GO 106309
106309: DISABLE
106310: LD_INT 0
106312: PPUSH
// begin uc_side := 0 ;
106313: LD_ADDR_OWVAR 20
106317: PUSH
106318: LD_INT 0
106320: ST_TO_ADDR
// uc_nation := nation_arabian ;
106321: LD_ADDR_OWVAR 21
106325: PUSH
106326: LD_INT 2
106328: ST_TO_ADDR
// hc_gallery :=  ;
106329: LD_ADDR_OWVAR 33
106333: PUSH
106334: LD_STRING 
106336: ST_TO_ADDR
// hc_name :=  ;
106337: LD_ADDR_OWVAR 26
106341: PUSH
106342: LD_STRING 
106344: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106345: LD_INT 1
106347: PPUSH
106348: LD_INT 11
106350: PPUSH
106351: LD_INT 10
106353: PPUSH
106354: CALL_OW 380
// un := CreateHuman ;
106358: LD_ADDR_VAR 0 1
106362: PUSH
106363: CALL_OW 44
106367: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106368: LD_VAR 0 1
106372: PPUSH
106373: LD_INT 1
106375: PPUSH
106376: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106380: LD_INT 35
106382: PPUSH
106383: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106387: LD_VAR 0 1
106391: PPUSH
106392: LD_INT 22
106394: PUSH
106395: LD_OWVAR 2
106399: PUSH
106400: EMPTY
106401: LIST
106402: LIST
106403: PPUSH
106404: CALL_OW 69
106408: PPUSH
106409: LD_VAR 0 1
106413: PPUSH
106414: CALL_OW 74
106418: PPUSH
106419: CALL_OW 115
// until IsDead ( un ) ;
106423: LD_VAR 0 1
106427: PPUSH
106428: CALL_OW 301
106432: IFFALSE 106380
// end ;
106434: PPOPN 1
106436: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106437: LD_EXP 126
106441: PUSH
106442: LD_EXP 166
106446: AND
106447: IFFALSE 106459
106449: GO 106451
106451: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106452: LD_STRING earthquake(getX(game), 0, 32)
106454: PPUSH
106455: CALL_OW 559
106459: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106460: LD_EXP 126
106464: PUSH
106465: LD_EXP 167
106469: AND
106470: IFFALSE 106561
106472: GO 106474
106474: DISABLE
106475: LD_INT 0
106477: PPUSH
// begin enable ;
106478: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106479: LD_ADDR_VAR 0 1
106483: PUSH
106484: LD_INT 22
106486: PUSH
106487: LD_OWVAR 2
106491: PUSH
106492: EMPTY
106493: LIST
106494: LIST
106495: PUSH
106496: LD_INT 21
106498: PUSH
106499: LD_INT 2
106501: PUSH
106502: EMPTY
106503: LIST
106504: LIST
106505: PUSH
106506: LD_INT 33
106508: PUSH
106509: LD_INT 3
106511: PUSH
106512: EMPTY
106513: LIST
106514: LIST
106515: PUSH
106516: EMPTY
106517: LIST
106518: LIST
106519: LIST
106520: PPUSH
106521: CALL_OW 69
106525: ST_TO_ADDR
// if not tmp then
106526: LD_VAR 0 1
106530: NOT
106531: IFFALSE 106535
// exit ;
106533: GO 106561
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106535: LD_VAR 0 1
106539: PUSH
106540: LD_INT 1
106542: PPUSH
106543: LD_VAR 0 1
106547: PPUSH
106548: CALL_OW 12
106552: ARRAY
106553: PPUSH
106554: LD_INT 1
106556: PPUSH
106557: CALL_OW 234
// end ;
106561: PPOPN 1
106563: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106564: LD_EXP 126
106568: PUSH
106569: LD_EXP 168
106573: AND
106574: IFFALSE 106715
106576: GO 106578
106578: DISABLE
106579: LD_INT 0
106581: PPUSH
106582: PPUSH
106583: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106584: LD_ADDR_VAR 0 3
106588: PUSH
106589: LD_INT 22
106591: PUSH
106592: LD_OWVAR 2
106596: PUSH
106597: EMPTY
106598: LIST
106599: LIST
106600: PUSH
106601: LD_INT 25
106603: PUSH
106604: LD_INT 1
106606: PUSH
106607: EMPTY
106608: LIST
106609: LIST
106610: PUSH
106611: EMPTY
106612: LIST
106613: LIST
106614: PPUSH
106615: CALL_OW 69
106619: ST_TO_ADDR
// if not tmp then
106620: LD_VAR 0 3
106624: NOT
106625: IFFALSE 106629
// exit ;
106627: GO 106715
// un := tmp [ rand ( 1 , tmp ) ] ;
106629: LD_ADDR_VAR 0 2
106633: PUSH
106634: LD_VAR 0 3
106638: PUSH
106639: LD_INT 1
106641: PPUSH
106642: LD_VAR 0 3
106646: PPUSH
106647: CALL_OW 12
106651: ARRAY
106652: ST_TO_ADDR
// if Crawls ( un ) then
106653: LD_VAR 0 2
106657: PPUSH
106658: CALL_OW 318
106662: IFFALSE 106673
// ComWalk ( un ) ;
106664: LD_VAR 0 2
106668: PPUSH
106669: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106673: LD_VAR 0 2
106677: PPUSH
106678: LD_INT 9
106680: PPUSH
106681: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106685: LD_INT 28
106687: PPUSH
106688: LD_OWVAR 2
106692: PPUSH
106693: LD_INT 2
106695: PPUSH
106696: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106700: LD_INT 29
106702: PPUSH
106703: LD_OWVAR 2
106707: PPUSH
106708: LD_INT 2
106710: PPUSH
106711: CALL_OW 322
// end ;
106715: PPOPN 3
106717: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106718: LD_EXP 126
106722: PUSH
106723: LD_EXP 169
106727: AND
106728: IFFALSE 106839
106730: GO 106732
106732: DISABLE
106733: LD_INT 0
106735: PPUSH
106736: PPUSH
106737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106738: LD_ADDR_VAR 0 3
106742: PUSH
106743: LD_INT 22
106745: PUSH
106746: LD_OWVAR 2
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: PUSH
106755: LD_INT 25
106757: PUSH
106758: LD_INT 1
106760: PUSH
106761: EMPTY
106762: LIST
106763: LIST
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: PPUSH
106769: CALL_OW 69
106773: ST_TO_ADDR
// if not tmp then
106774: LD_VAR 0 3
106778: NOT
106779: IFFALSE 106783
// exit ;
106781: GO 106839
// un := tmp [ rand ( 1 , tmp ) ] ;
106783: LD_ADDR_VAR 0 2
106787: PUSH
106788: LD_VAR 0 3
106792: PUSH
106793: LD_INT 1
106795: PPUSH
106796: LD_VAR 0 3
106800: PPUSH
106801: CALL_OW 12
106805: ARRAY
106806: ST_TO_ADDR
// if Crawls ( un ) then
106807: LD_VAR 0 2
106811: PPUSH
106812: CALL_OW 318
106816: IFFALSE 106827
// ComWalk ( un ) ;
106818: LD_VAR 0 2
106822: PPUSH
106823: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106827: LD_VAR 0 2
106831: PPUSH
106832: LD_INT 8
106834: PPUSH
106835: CALL_OW 336
// end ;
106839: PPOPN 3
106841: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
106842: LD_EXP 126
106846: PUSH
106847: LD_EXP 170
106851: AND
106852: IFFALSE 106996
106854: GO 106856
106856: DISABLE
106857: LD_INT 0
106859: PPUSH
106860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
106861: LD_ADDR_VAR 0 2
106865: PUSH
106866: LD_INT 22
106868: PUSH
106869: LD_OWVAR 2
106873: PUSH
106874: EMPTY
106875: LIST
106876: LIST
106877: PUSH
106878: LD_INT 21
106880: PUSH
106881: LD_INT 2
106883: PUSH
106884: EMPTY
106885: LIST
106886: LIST
106887: PUSH
106888: LD_INT 2
106890: PUSH
106891: LD_INT 34
106893: PUSH
106894: LD_INT 12
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: PUSH
106901: LD_INT 34
106903: PUSH
106904: LD_INT 51
106906: PUSH
106907: EMPTY
106908: LIST
106909: LIST
106910: PUSH
106911: LD_INT 34
106913: PUSH
106914: LD_INT 32
106916: PUSH
106917: EMPTY
106918: LIST
106919: LIST
106920: PUSH
106921: EMPTY
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: PUSH
106927: EMPTY
106928: LIST
106929: LIST
106930: LIST
106931: PPUSH
106932: CALL_OW 69
106936: ST_TO_ADDR
// if not tmp then
106937: LD_VAR 0 2
106941: NOT
106942: IFFALSE 106946
// exit ;
106944: GO 106996
// for i in tmp do
106946: LD_ADDR_VAR 0 1
106950: PUSH
106951: LD_VAR 0 2
106955: PUSH
106956: FOR_IN
106957: IFFALSE 106994
// if GetCargo ( i , mat_artifact ) = 0 then
106959: LD_VAR 0 1
106963: PPUSH
106964: LD_INT 4
106966: PPUSH
106967: CALL_OW 289
106971: PUSH
106972: LD_INT 0
106974: EQUAL
106975: IFFALSE 106992
// SetCargo ( i , mat_siberit , 100 ) ;
106977: LD_VAR 0 1
106981: PPUSH
106982: LD_INT 3
106984: PPUSH
106985: LD_INT 100
106987: PPUSH
106988: CALL_OW 290
106992: GO 106956
106994: POP
106995: POP
// end ;
106996: PPOPN 2
106998: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
106999: LD_EXP 126
107003: PUSH
107004: LD_EXP 171
107008: AND
107009: IFFALSE 107192
107011: GO 107013
107013: DISABLE
107014: LD_INT 0
107016: PPUSH
107017: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107018: LD_ADDR_VAR 0 2
107022: PUSH
107023: LD_INT 22
107025: PUSH
107026: LD_OWVAR 2
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: PPUSH
107035: CALL_OW 69
107039: ST_TO_ADDR
// if not tmp then
107040: LD_VAR 0 2
107044: NOT
107045: IFFALSE 107049
// exit ;
107047: GO 107192
// for i := 1 to 2 do
107049: LD_ADDR_VAR 0 1
107053: PUSH
107054: DOUBLE
107055: LD_INT 1
107057: DEC
107058: ST_TO_ADDR
107059: LD_INT 2
107061: PUSH
107062: FOR_TO
107063: IFFALSE 107190
// begin uc_side := your_side ;
107065: LD_ADDR_OWVAR 20
107069: PUSH
107070: LD_OWVAR 2
107074: ST_TO_ADDR
// uc_nation := nation_american ;
107075: LD_ADDR_OWVAR 21
107079: PUSH
107080: LD_INT 1
107082: ST_TO_ADDR
// vc_chassis := us_morphling ;
107083: LD_ADDR_OWVAR 37
107087: PUSH
107088: LD_INT 5
107090: ST_TO_ADDR
// vc_engine := engine_siberite ;
107091: LD_ADDR_OWVAR 39
107095: PUSH
107096: LD_INT 3
107098: ST_TO_ADDR
// vc_control := control_computer ;
107099: LD_ADDR_OWVAR 38
107103: PUSH
107104: LD_INT 3
107106: ST_TO_ADDR
// vc_weapon := us_double_laser ;
107107: LD_ADDR_OWVAR 40
107111: PUSH
107112: LD_INT 10
107114: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
107115: LD_VAR 0 2
107119: PUSH
107120: LD_INT 1
107122: ARRAY
107123: PPUSH
107124: CALL_OW 310
107128: NOT
107129: IFFALSE 107176
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
107131: CALL_OW 45
107135: PPUSH
107136: LD_VAR 0 2
107140: PUSH
107141: LD_INT 1
107143: ARRAY
107144: PPUSH
107145: CALL_OW 250
107149: PPUSH
107150: LD_VAR 0 2
107154: PUSH
107155: LD_INT 1
107157: ARRAY
107158: PPUSH
107159: CALL_OW 251
107163: PPUSH
107164: LD_INT 12
107166: PPUSH
107167: LD_INT 1
107169: PPUSH
107170: CALL_OW 50
107174: GO 107188
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
107176: CALL_OW 45
107180: PPUSH
107181: LD_INT 1
107183: PPUSH
107184: CALL_OW 51
// end ;
107188: GO 107062
107190: POP
107191: POP
// end ;
107192: PPOPN 2
107194: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
107195: LD_EXP 126
107199: PUSH
107200: LD_EXP 172
107204: AND
107205: IFFALSE 107427
107207: GO 107209
107209: DISABLE
107210: LD_INT 0
107212: PPUSH
107213: PPUSH
107214: PPUSH
107215: PPUSH
107216: PPUSH
107217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107218: LD_ADDR_VAR 0 6
107222: PUSH
107223: LD_INT 22
107225: PUSH
107226: LD_OWVAR 2
107230: PUSH
107231: EMPTY
107232: LIST
107233: LIST
107234: PUSH
107235: LD_INT 21
107237: PUSH
107238: LD_INT 1
107240: PUSH
107241: EMPTY
107242: LIST
107243: LIST
107244: PUSH
107245: LD_INT 3
107247: PUSH
107248: LD_INT 23
107250: PUSH
107251: LD_INT 0
107253: PUSH
107254: EMPTY
107255: LIST
107256: LIST
107257: PUSH
107258: EMPTY
107259: LIST
107260: LIST
107261: PUSH
107262: EMPTY
107263: LIST
107264: LIST
107265: LIST
107266: PPUSH
107267: CALL_OW 69
107271: ST_TO_ADDR
// if not tmp then
107272: LD_VAR 0 6
107276: NOT
107277: IFFALSE 107281
// exit ;
107279: GO 107427
// s1 := rand ( 1 , 4 ) ;
107281: LD_ADDR_VAR 0 2
107285: PUSH
107286: LD_INT 1
107288: PPUSH
107289: LD_INT 4
107291: PPUSH
107292: CALL_OW 12
107296: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107297: LD_ADDR_VAR 0 4
107301: PUSH
107302: LD_VAR 0 6
107306: PUSH
107307: LD_INT 1
107309: ARRAY
107310: PPUSH
107311: LD_VAR 0 2
107315: PPUSH
107316: CALL_OW 259
107320: ST_TO_ADDR
// if s1 = 1 then
107321: LD_VAR 0 2
107325: PUSH
107326: LD_INT 1
107328: EQUAL
107329: IFFALSE 107349
// s2 := rand ( 2 , 4 ) else
107331: LD_ADDR_VAR 0 3
107335: PUSH
107336: LD_INT 2
107338: PPUSH
107339: LD_INT 4
107341: PPUSH
107342: CALL_OW 12
107346: ST_TO_ADDR
107347: GO 107357
// s2 := 1 ;
107349: LD_ADDR_VAR 0 3
107353: PUSH
107354: LD_INT 1
107356: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107357: LD_ADDR_VAR 0 5
107361: PUSH
107362: LD_VAR 0 6
107366: PUSH
107367: LD_INT 1
107369: ARRAY
107370: PPUSH
107371: LD_VAR 0 3
107375: PPUSH
107376: CALL_OW 259
107380: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107381: LD_VAR 0 6
107385: PUSH
107386: LD_INT 1
107388: ARRAY
107389: PPUSH
107390: LD_VAR 0 2
107394: PPUSH
107395: LD_VAR 0 5
107399: PPUSH
107400: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
107404: LD_VAR 0 6
107408: PUSH
107409: LD_INT 1
107411: ARRAY
107412: PPUSH
107413: LD_VAR 0 3
107417: PPUSH
107418: LD_VAR 0 4
107422: PPUSH
107423: CALL_OW 237
// end ;
107427: PPOPN 6
107429: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107430: LD_EXP 126
107434: PUSH
107435: LD_EXP 173
107439: AND
107440: IFFALSE 107519
107442: GO 107444
107444: DISABLE
107445: LD_INT 0
107447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107448: LD_ADDR_VAR 0 1
107452: PUSH
107453: LD_INT 22
107455: PUSH
107456: LD_OWVAR 2
107460: PUSH
107461: EMPTY
107462: LIST
107463: LIST
107464: PUSH
107465: LD_INT 30
107467: PUSH
107468: LD_INT 3
107470: PUSH
107471: EMPTY
107472: LIST
107473: LIST
107474: PUSH
107475: EMPTY
107476: LIST
107477: LIST
107478: PPUSH
107479: CALL_OW 69
107483: ST_TO_ADDR
// if not tmp then
107484: LD_VAR 0 1
107488: NOT
107489: IFFALSE 107493
// exit ;
107491: GO 107519
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107493: LD_VAR 0 1
107497: PUSH
107498: LD_INT 1
107500: PPUSH
107501: LD_VAR 0 1
107505: PPUSH
107506: CALL_OW 12
107510: ARRAY
107511: PPUSH
107512: LD_INT 1
107514: PPUSH
107515: CALL_OW 234
// end ;
107519: PPOPN 1
107521: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107522: LD_EXP 126
107526: PUSH
107527: LD_EXP 174
107531: AND
107532: IFFALSE 107644
107534: GO 107536
107536: DISABLE
107537: LD_INT 0
107539: PPUSH
107540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107541: LD_ADDR_VAR 0 2
107545: PUSH
107546: LD_INT 22
107548: PUSH
107549: LD_OWVAR 2
107553: PUSH
107554: EMPTY
107555: LIST
107556: LIST
107557: PUSH
107558: LD_INT 2
107560: PUSH
107561: LD_INT 30
107563: PUSH
107564: LD_INT 27
107566: PUSH
107567: EMPTY
107568: LIST
107569: LIST
107570: PUSH
107571: LD_INT 30
107573: PUSH
107574: LD_INT 26
107576: PUSH
107577: EMPTY
107578: LIST
107579: LIST
107580: PUSH
107581: LD_INT 30
107583: PUSH
107584: LD_INT 28
107586: PUSH
107587: EMPTY
107588: LIST
107589: LIST
107590: PUSH
107591: EMPTY
107592: LIST
107593: LIST
107594: LIST
107595: LIST
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: PPUSH
107601: CALL_OW 69
107605: ST_TO_ADDR
// if not tmp then
107606: LD_VAR 0 2
107610: NOT
107611: IFFALSE 107615
// exit ;
107613: GO 107644
// for i in tmp do
107615: LD_ADDR_VAR 0 1
107619: PUSH
107620: LD_VAR 0 2
107624: PUSH
107625: FOR_IN
107626: IFFALSE 107642
// SetLives ( i , 1 ) ;
107628: LD_VAR 0 1
107632: PPUSH
107633: LD_INT 1
107635: PPUSH
107636: CALL_OW 234
107640: GO 107625
107642: POP
107643: POP
// end ;
107644: PPOPN 2
107646: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107647: LD_EXP 126
107651: PUSH
107652: LD_EXP 175
107656: AND
107657: IFFALSE 107944
107659: GO 107661
107661: DISABLE
107662: LD_INT 0
107664: PPUSH
107665: PPUSH
107666: PPUSH
// begin i := rand ( 1 , 7 ) ;
107667: LD_ADDR_VAR 0 1
107671: PUSH
107672: LD_INT 1
107674: PPUSH
107675: LD_INT 7
107677: PPUSH
107678: CALL_OW 12
107682: ST_TO_ADDR
// case i of 1 :
107683: LD_VAR 0 1
107687: PUSH
107688: LD_INT 1
107690: DOUBLE
107691: EQUAL
107692: IFTRUE 107696
107694: GO 107706
107696: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107697: LD_STRING earthquake(getX(game), 0, 32)
107699: PPUSH
107700: CALL_OW 559
107704: GO 107944
107706: LD_INT 2
107708: DOUBLE
107709: EQUAL
107710: IFTRUE 107714
107712: GO 107728
107714: POP
// begin ToLua ( displayStucuk(); ) ;
107715: LD_STRING displayStucuk();
107717: PPUSH
107718: CALL_OW 559
// ResetFog ;
107722: CALL_OW 335
// end ; 3 :
107726: GO 107944
107728: LD_INT 3
107730: DOUBLE
107731: EQUAL
107732: IFTRUE 107736
107734: GO 107840
107736: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107737: LD_ADDR_VAR 0 2
107741: PUSH
107742: LD_INT 22
107744: PUSH
107745: LD_OWVAR 2
107749: PUSH
107750: EMPTY
107751: LIST
107752: LIST
107753: PUSH
107754: LD_INT 25
107756: PUSH
107757: LD_INT 1
107759: PUSH
107760: EMPTY
107761: LIST
107762: LIST
107763: PUSH
107764: EMPTY
107765: LIST
107766: LIST
107767: PPUSH
107768: CALL_OW 69
107772: ST_TO_ADDR
// if not tmp then
107773: LD_VAR 0 2
107777: NOT
107778: IFFALSE 107782
// exit ;
107780: GO 107944
// un := tmp [ rand ( 1 , tmp ) ] ;
107782: LD_ADDR_VAR 0 3
107786: PUSH
107787: LD_VAR 0 2
107791: PUSH
107792: LD_INT 1
107794: PPUSH
107795: LD_VAR 0 2
107799: PPUSH
107800: CALL_OW 12
107804: ARRAY
107805: ST_TO_ADDR
// if Crawls ( un ) then
107806: LD_VAR 0 3
107810: PPUSH
107811: CALL_OW 318
107815: IFFALSE 107826
// ComWalk ( un ) ;
107817: LD_VAR 0 3
107821: PPUSH
107822: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107826: LD_VAR 0 3
107830: PPUSH
107831: LD_INT 8
107833: PPUSH
107834: CALL_OW 336
// end ; 4 :
107838: GO 107944
107840: LD_INT 4
107842: DOUBLE
107843: EQUAL
107844: IFTRUE 107848
107846: GO 107922
107848: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107849: LD_ADDR_VAR 0 2
107853: PUSH
107854: LD_INT 22
107856: PUSH
107857: LD_OWVAR 2
107861: PUSH
107862: EMPTY
107863: LIST
107864: LIST
107865: PUSH
107866: LD_INT 30
107868: PUSH
107869: LD_INT 29
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: PUSH
107876: EMPTY
107877: LIST
107878: LIST
107879: PPUSH
107880: CALL_OW 69
107884: ST_TO_ADDR
// if not tmp then
107885: LD_VAR 0 2
107889: NOT
107890: IFFALSE 107894
// exit ;
107892: GO 107944
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107894: LD_VAR 0 2
107898: PUSH
107899: LD_INT 1
107901: ARRAY
107902: PPUSH
107903: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107907: LD_VAR 0 2
107911: PUSH
107912: LD_INT 1
107914: ARRAY
107915: PPUSH
107916: CALL_OW 65
// end ; 5 .. 7 :
107920: GO 107944
107922: LD_INT 5
107924: DOUBLE
107925: GREATEREQUAL
107926: IFFALSE 107934
107928: LD_INT 7
107930: DOUBLE
107931: LESSEQUAL
107932: IFTRUE 107936
107934: GO 107943
107936: POP
// StreamSibBomb ; end ;
107937: CALL 104181 0 0
107941: GO 107944
107943: POP
// end ;
107944: PPOPN 3
107946: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107947: LD_EXP 126
107951: PUSH
107952: LD_EXP 176
107956: AND
107957: IFFALSE 108113
107959: GO 107961
107961: DISABLE
107962: LD_INT 0
107964: PPUSH
107965: PPUSH
107966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
107967: LD_ADDR_VAR 0 2
107971: PUSH
107972: LD_INT 81
107974: PUSH
107975: LD_OWVAR 2
107979: PUSH
107980: EMPTY
107981: LIST
107982: LIST
107983: PUSH
107984: LD_INT 2
107986: PUSH
107987: LD_INT 21
107989: PUSH
107990: LD_INT 1
107992: PUSH
107993: EMPTY
107994: LIST
107995: LIST
107996: PUSH
107997: LD_INT 21
107999: PUSH
108000: LD_INT 2
108002: PUSH
108003: EMPTY
108004: LIST
108005: LIST
108006: PUSH
108007: EMPTY
108008: LIST
108009: LIST
108010: LIST
108011: PUSH
108012: EMPTY
108013: LIST
108014: LIST
108015: PPUSH
108016: CALL_OW 69
108020: ST_TO_ADDR
// if not tmp then
108021: LD_VAR 0 2
108025: NOT
108026: IFFALSE 108030
// exit ;
108028: GO 108113
// p := 0 ;
108030: LD_ADDR_VAR 0 3
108034: PUSH
108035: LD_INT 0
108037: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108038: LD_INT 35
108040: PPUSH
108041: CALL_OW 67
// p := p + 1 ;
108045: LD_ADDR_VAR 0 3
108049: PUSH
108050: LD_VAR 0 3
108054: PUSH
108055: LD_INT 1
108057: PLUS
108058: ST_TO_ADDR
// for i in tmp do
108059: LD_ADDR_VAR 0 1
108063: PUSH
108064: LD_VAR 0 2
108068: PUSH
108069: FOR_IN
108070: IFFALSE 108101
// if GetLives ( i ) < 1000 then
108072: LD_VAR 0 1
108076: PPUSH
108077: CALL_OW 256
108081: PUSH
108082: LD_INT 1000
108084: LESS
108085: IFFALSE 108099
// SetLives ( i , 1000 ) ;
108087: LD_VAR 0 1
108091: PPUSH
108092: LD_INT 1000
108094: PPUSH
108095: CALL_OW 234
108099: GO 108069
108101: POP
108102: POP
// until p > 20 ;
108103: LD_VAR 0 3
108107: PUSH
108108: LD_INT 20
108110: GREATER
108111: IFFALSE 108038
// end ;
108113: PPOPN 3
108115: END
// every 0 0$1 trigger StreamModeActive and sTime do
108116: LD_EXP 126
108120: PUSH
108121: LD_EXP 177
108125: AND
108126: IFFALSE 108161
108128: GO 108130
108130: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
108131: LD_INT 28
108133: PPUSH
108134: LD_OWVAR 2
108138: PPUSH
108139: LD_INT 2
108141: PPUSH
108142: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
108146: LD_INT 30
108148: PPUSH
108149: LD_OWVAR 2
108153: PPUSH
108154: LD_INT 2
108156: PPUSH
108157: CALL_OW 322
// end ;
108161: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
108162: LD_EXP 126
108166: PUSH
108167: LD_EXP 178
108171: AND
108172: IFFALSE 108293
108174: GO 108176
108176: DISABLE
108177: LD_INT 0
108179: PPUSH
108180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108181: LD_ADDR_VAR 0 2
108185: PUSH
108186: LD_INT 22
108188: PUSH
108189: LD_OWVAR 2
108193: PUSH
108194: EMPTY
108195: LIST
108196: LIST
108197: PUSH
108198: LD_INT 21
108200: PUSH
108201: LD_INT 1
108203: PUSH
108204: EMPTY
108205: LIST
108206: LIST
108207: PUSH
108208: LD_INT 3
108210: PUSH
108211: LD_INT 23
108213: PUSH
108214: LD_INT 0
108216: PUSH
108217: EMPTY
108218: LIST
108219: LIST
108220: PUSH
108221: EMPTY
108222: LIST
108223: LIST
108224: PUSH
108225: EMPTY
108226: LIST
108227: LIST
108228: LIST
108229: PPUSH
108230: CALL_OW 69
108234: ST_TO_ADDR
// if not tmp then
108235: LD_VAR 0 2
108239: NOT
108240: IFFALSE 108244
// exit ;
108242: GO 108293
// for i in tmp do
108244: LD_ADDR_VAR 0 1
108248: PUSH
108249: LD_VAR 0 2
108253: PUSH
108254: FOR_IN
108255: IFFALSE 108291
// begin if Crawls ( i ) then
108257: LD_VAR 0 1
108261: PPUSH
108262: CALL_OW 318
108266: IFFALSE 108277
// ComWalk ( i ) ;
108268: LD_VAR 0 1
108272: PPUSH
108273: CALL_OW 138
// SetClass ( i , 2 ) ;
108277: LD_VAR 0 1
108281: PPUSH
108282: LD_INT 2
108284: PPUSH
108285: CALL_OW 336
// end ;
108289: GO 108254
108291: POP
108292: POP
// end ;
108293: PPOPN 2
108295: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108296: LD_EXP 126
108300: PUSH
108301: LD_EXP 179
108305: AND
108306: IFFALSE 108594
108308: GO 108310
108310: DISABLE
108311: LD_INT 0
108313: PPUSH
108314: PPUSH
108315: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108316: LD_OWVAR 2
108320: PPUSH
108321: LD_INT 9
108323: PPUSH
108324: LD_INT 1
108326: PPUSH
108327: LD_INT 1
108329: PPUSH
108330: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108334: LD_INT 9
108336: PPUSH
108337: LD_OWVAR 2
108341: PPUSH
108342: CALL_OW 343
// uc_side := 9 ;
108346: LD_ADDR_OWVAR 20
108350: PUSH
108351: LD_INT 9
108353: ST_TO_ADDR
// uc_nation := 2 ;
108354: LD_ADDR_OWVAR 21
108358: PUSH
108359: LD_INT 2
108361: ST_TO_ADDR
// hc_name := Dark Warrior ;
108362: LD_ADDR_OWVAR 26
108366: PUSH
108367: LD_STRING Dark Warrior
108369: ST_TO_ADDR
// hc_gallery :=  ;
108370: LD_ADDR_OWVAR 33
108374: PUSH
108375: LD_STRING 
108377: ST_TO_ADDR
// hc_noskilllimit := true ;
108378: LD_ADDR_OWVAR 76
108382: PUSH
108383: LD_INT 1
108385: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108386: LD_ADDR_OWVAR 31
108390: PUSH
108391: LD_INT 30
108393: PUSH
108394: LD_INT 30
108396: PUSH
108397: LD_INT 30
108399: PUSH
108400: LD_INT 30
108402: PUSH
108403: EMPTY
108404: LIST
108405: LIST
108406: LIST
108407: LIST
108408: ST_TO_ADDR
// un := CreateHuman ;
108409: LD_ADDR_VAR 0 3
108413: PUSH
108414: CALL_OW 44
108418: ST_TO_ADDR
// hc_noskilllimit := false ;
108419: LD_ADDR_OWVAR 76
108423: PUSH
108424: LD_INT 0
108426: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108427: LD_VAR 0 3
108431: PPUSH
108432: LD_INT 1
108434: PPUSH
108435: CALL_OW 51
// ToLua ( playRanger() ) ;
108439: LD_STRING playRanger()
108441: PPUSH
108442: CALL_OW 559
// p := 0 ;
108446: LD_ADDR_VAR 0 2
108450: PUSH
108451: LD_INT 0
108453: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108454: LD_INT 35
108456: PPUSH
108457: CALL_OW 67
// p := p + 1 ;
108461: LD_ADDR_VAR 0 2
108465: PUSH
108466: LD_VAR 0 2
108470: PUSH
108471: LD_INT 1
108473: PLUS
108474: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108475: LD_VAR 0 3
108479: PPUSH
108480: CALL_OW 256
108484: PUSH
108485: LD_INT 1000
108487: LESS
108488: IFFALSE 108502
// SetLives ( un , 1000 ) ;
108490: LD_VAR 0 3
108494: PPUSH
108495: LD_INT 1000
108497: PPUSH
108498: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108502: LD_VAR 0 3
108506: PPUSH
108507: LD_INT 81
108509: PUSH
108510: LD_OWVAR 2
108514: PUSH
108515: EMPTY
108516: LIST
108517: LIST
108518: PUSH
108519: LD_INT 91
108521: PUSH
108522: LD_VAR 0 3
108526: PUSH
108527: LD_INT 30
108529: PUSH
108530: EMPTY
108531: LIST
108532: LIST
108533: LIST
108534: PUSH
108535: EMPTY
108536: LIST
108537: LIST
108538: PPUSH
108539: CALL_OW 69
108543: PPUSH
108544: LD_VAR 0 3
108548: PPUSH
108549: CALL_OW 74
108553: PPUSH
108554: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108558: LD_VAR 0 2
108562: PUSH
108563: LD_INT 80
108565: GREATER
108566: PUSH
108567: LD_VAR 0 3
108571: PPUSH
108572: CALL_OW 301
108576: OR
108577: IFFALSE 108454
// if un then
108579: LD_VAR 0 3
108583: IFFALSE 108594
// RemoveUnit ( un ) ;
108585: LD_VAR 0 3
108589: PPUSH
108590: CALL_OW 64
// end ;
108594: PPOPN 3
108596: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108597: LD_EXP 180
108601: IFFALSE 108717
108603: GO 108605
108605: DISABLE
108606: LD_INT 0
108608: PPUSH
108609: PPUSH
108610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108611: LD_ADDR_VAR 0 2
108615: PUSH
108616: LD_INT 81
108618: PUSH
108619: LD_OWVAR 2
108623: PUSH
108624: EMPTY
108625: LIST
108626: LIST
108627: PUSH
108628: LD_INT 21
108630: PUSH
108631: LD_INT 1
108633: PUSH
108634: EMPTY
108635: LIST
108636: LIST
108637: PUSH
108638: EMPTY
108639: LIST
108640: LIST
108641: PPUSH
108642: CALL_OW 69
108646: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108647: LD_STRING playComputer()
108649: PPUSH
108650: CALL_OW 559
// if not tmp then
108654: LD_VAR 0 2
108658: NOT
108659: IFFALSE 108663
// exit ;
108661: GO 108717
// for i in tmp do
108663: LD_ADDR_VAR 0 1
108667: PUSH
108668: LD_VAR 0 2
108672: PUSH
108673: FOR_IN
108674: IFFALSE 108715
// for j := 1 to 4 do
108676: LD_ADDR_VAR 0 3
108680: PUSH
108681: DOUBLE
108682: LD_INT 1
108684: DEC
108685: ST_TO_ADDR
108686: LD_INT 4
108688: PUSH
108689: FOR_TO
108690: IFFALSE 108711
// SetSkill ( i , j , 10 ) ;
108692: LD_VAR 0 1
108696: PPUSH
108697: LD_VAR 0 3
108701: PPUSH
108702: LD_INT 10
108704: PPUSH
108705: CALL_OW 237
108709: GO 108689
108711: POP
108712: POP
108713: GO 108673
108715: POP
108716: POP
// end ;
108717: PPOPN 3
108719: END
// every 0 0$1 trigger s30 do var i , tmp ;
108720: LD_EXP 181
108724: IFFALSE 108793
108726: GO 108728
108728: DISABLE
108729: LD_INT 0
108731: PPUSH
108732: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108733: LD_ADDR_VAR 0 2
108737: PUSH
108738: LD_INT 22
108740: PUSH
108741: LD_OWVAR 2
108745: PUSH
108746: EMPTY
108747: LIST
108748: LIST
108749: PPUSH
108750: CALL_OW 69
108754: ST_TO_ADDR
// if not tmp then
108755: LD_VAR 0 2
108759: NOT
108760: IFFALSE 108764
// exit ;
108762: GO 108793
// for i in tmp do
108764: LD_ADDR_VAR 0 1
108768: PUSH
108769: LD_VAR 0 2
108773: PUSH
108774: FOR_IN
108775: IFFALSE 108791
// SetLives ( i , 300 ) ;
108777: LD_VAR 0 1
108781: PPUSH
108782: LD_INT 300
108784: PPUSH
108785: CALL_OW 234
108789: GO 108774
108791: POP
108792: POP
// end ;
108793: PPOPN 2
108795: END
// every 0 0$1 trigger s60 do var i , tmp ;
108796: LD_EXP 182
108800: IFFALSE 108869
108802: GO 108804
108804: DISABLE
108805: LD_INT 0
108807: PPUSH
108808: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108809: LD_ADDR_VAR 0 2
108813: PUSH
108814: LD_INT 22
108816: PUSH
108817: LD_OWVAR 2
108821: PUSH
108822: EMPTY
108823: LIST
108824: LIST
108825: PPUSH
108826: CALL_OW 69
108830: ST_TO_ADDR
// if not tmp then
108831: LD_VAR 0 2
108835: NOT
108836: IFFALSE 108840
// exit ;
108838: GO 108869
// for i in tmp do
108840: LD_ADDR_VAR 0 1
108844: PUSH
108845: LD_VAR 0 2
108849: PUSH
108850: FOR_IN
108851: IFFALSE 108867
// SetLives ( i , 600 ) ;
108853: LD_VAR 0 1
108857: PPUSH
108858: LD_INT 600
108860: PPUSH
108861: CALL_OW 234
108865: GO 108850
108867: POP
108868: POP
// end ;
108869: PPOPN 2
108871: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108872: LD_INT 0
108874: PPUSH
// case cmd of 301 :
108875: LD_VAR 0 1
108879: PUSH
108880: LD_INT 301
108882: DOUBLE
108883: EQUAL
108884: IFTRUE 108888
108886: GO 108920
108888: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108889: LD_VAR 0 6
108893: PPUSH
108894: LD_VAR 0 7
108898: PPUSH
108899: LD_VAR 0 8
108903: PPUSH
108904: LD_VAR 0 4
108908: PPUSH
108909: LD_VAR 0 5
108913: PPUSH
108914: CALL 110129 0 5
108918: GO 109041
108920: LD_INT 302
108922: DOUBLE
108923: EQUAL
108924: IFTRUE 108928
108926: GO 108965
108928: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108929: LD_VAR 0 6
108933: PPUSH
108934: LD_VAR 0 7
108938: PPUSH
108939: LD_VAR 0 8
108943: PPUSH
108944: LD_VAR 0 9
108948: PPUSH
108949: LD_VAR 0 4
108953: PPUSH
108954: LD_VAR 0 5
108958: PPUSH
108959: CALL 110220 0 6
108963: GO 109041
108965: LD_INT 303
108967: DOUBLE
108968: EQUAL
108969: IFTRUE 108973
108971: GO 109010
108973: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
108974: LD_VAR 0 6
108978: PPUSH
108979: LD_VAR 0 7
108983: PPUSH
108984: LD_VAR 0 8
108988: PPUSH
108989: LD_VAR 0 9
108993: PPUSH
108994: LD_VAR 0 4
108998: PPUSH
108999: LD_VAR 0 5
109003: PPUSH
109004: CALL 109046 0 6
109008: GO 109041
109010: LD_INT 304
109012: DOUBLE
109013: EQUAL
109014: IFTRUE 109018
109016: GO 109040
109018: POP
// hHackTeleport ( unit , x , y ) ; end ;
109019: LD_VAR 0 2
109023: PPUSH
109024: LD_VAR 0 4
109028: PPUSH
109029: LD_VAR 0 5
109033: PPUSH
109034: CALL 110813 0 3
109038: GO 109041
109040: POP
// end ;
109041: LD_VAR 0 12
109045: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
109046: LD_INT 0
109048: PPUSH
109049: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
109050: LD_VAR 0 1
109054: PUSH
109055: LD_INT 1
109057: LESS
109058: PUSH
109059: LD_VAR 0 1
109063: PUSH
109064: LD_INT 3
109066: GREATER
109067: OR
109068: PUSH
109069: LD_VAR 0 5
109073: PPUSH
109074: LD_VAR 0 6
109078: PPUSH
109079: CALL_OW 428
109083: OR
109084: IFFALSE 109088
// exit ;
109086: GO 109816
// uc_side := your_side ;
109088: LD_ADDR_OWVAR 20
109092: PUSH
109093: LD_OWVAR 2
109097: ST_TO_ADDR
// uc_nation := nation ;
109098: LD_ADDR_OWVAR 21
109102: PUSH
109103: LD_VAR 0 1
109107: ST_TO_ADDR
// bc_level = 1 ;
109108: LD_ADDR_OWVAR 43
109112: PUSH
109113: LD_INT 1
109115: ST_TO_ADDR
// case btype of 1 :
109116: LD_VAR 0 2
109120: PUSH
109121: LD_INT 1
109123: DOUBLE
109124: EQUAL
109125: IFTRUE 109129
109127: GO 109140
109129: POP
// bc_type := b_depot ; 2 :
109130: LD_ADDR_OWVAR 42
109134: PUSH
109135: LD_INT 0
109137: ST_TO_ADDR
109138: GO 109760
109140: LD_INT 2
109142: DOUBLE
109143: EQUAL
109144: IFTRUE 109148
109146: GO 109159
109148: POP
// bc_type := b_warehouse ; 3 :
109149: LD_ADDR_OWVAR 42
109153: PUSH
109154: LD_INT 1
109156: ST_TO_ADDR
109157: GO 109760
109159: LD_INT 3
109161: DOUBLE
109162: EQUAL
109163: IFTRUE 109167
109165: GO 109178
109167: POP
// bc_type := b_lab ; 4 .. 9 :
109168: LD_ADDR_OWVAR 42
109172: PUSH
109173: LD_INT 6
109175: ST_TO_ADDR
109176: GO 109760
109178: LD_INT 4
109180: DOUBLE
109181: GREATEREQUAL
109182: IFFALSE 109190
109184: LD_INT 9
109186: DOUBLE
109187: LESSEQUAL
109188: IFTRUE 109192
109190: GO 109252
109192: POP
// begin bc_type := b_lab_half ;
109193: LD_ADDR_OWVAR 42
109197: PUSH
109198: LD_INT 7
109200: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
109201: LD_ADDR_OWVAR 44
109205: PUSH
109206: LD_INT 10
109208: PUSH
109209: LD_INT 11
109211: PUSH
109212: LD_INT 12
109214: PUSH
109215: LD_INT 15
109217: PUSH
109218: LD_INT 14
109220: PUSH
109221: LD_INT 13
109223: PUSH
109224: EMPTY
109225: LIST
109226: LIST
109227: LIST
109228: LIST
109229: LIST
109230: LIST
109231: PUSH
109232: LD_VAR 0 2
109236: PUSH
109237: LD_INT 3
109239: MINUS
109240: ARRAY
109241: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
109242: LD_ADDR_OWVAR 45
109246: PUSH
109247: LD_INT 9
109249: ST_TO_ADDR
// end ; 10 .. 13 :
109250: GO 109760
109252: LD_INT 10
109254: DOUBLE
109255: GREATEREQUAL
109256: IFFALSE 109264
109258: LD_INT 13
109260: DOUBLE
109261: LESSEQUAL
109262: IFTRUE 109266
109264: GO 109343
109266: POP
// begin bc_type := b_lab_full ;
109267: LD_ADDR_OWVAR 42
109271: PUSH
109272: LD_INT 8
109274: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109275: LD_ADDR_OWVAR 44
109279: PUSH
109280: LD_INT 10
109282: PUSH
109283: LD_INT 12
109285: PUSH
109286: LD_INT 14
109288: PUSH
109289: LD_INT 13
109291: PUSH
109292: EMPTY
109293: LIST
109294: LIST
109295: LIST
109296: LIST
109297: PUSH
109298: LD_VAR 0 2
109302: PUSH
109303: LD_INT 9
109305: MINUS
109306: ARRAY
109307: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109308: LD_ADDR_OWVAR 45
109312: PUSH
109313: LD_INT 11
109315: PUSH
109316: LD_INT 15
109318: PUSH
109319: LD_INT 12
109321: PUSH
109322: LD_INT 15
109324: PUSH
109325: EMPTY
109326: LIST
109327: LIST
109328: LIST
109329: LIST
109330: PUSH
109331: LD_VAR 0 2
109335: PUSH
109336: LD_INT 9
109338: MINUS
109339: ARRAY
109340: ST_TO_ADDR
// end ; 14 :
109341: GO 109760
109343: LD_INT 14
109345: DOUBLE
109346: EQUAL
109347: IFTRUE 109351
109349: GO 109362
109351: POP
// bc_type := b_workshop ; 15 :
109352: LD_ADDR_OWVAR 42
109356: PUSH
109357: LD_INT 2
109359: ST_TO_ADDR
109360: GO 109760
109362: LD_INT 15
109364: DOUBLE
109365: EQUAL
109366: IFTRUE 109370
109368: GO 109381
109370: POP
// bc_type := b_factory ; 16 :
109371: LD_ADDR_OWVAR 42
109375: PUSH
109376: LD_INT 3
109378: ST_TO_ADDR
109379: GO 109760
109381: LD_INT 16
109383: DOUBLE
109384: EQUAL
109385: IFTRUE 109389
109387: GO 109400
109389: POP
// bc_type := b_ext_gun ; 17 :
109390: LD_ADDR_OWVAR 42
109394: PUSH
109395: LD_INT 17
109397: ST_TO_ADDR
109398: GO 109760
109400: LD_INT 17
109402: DOUBLE
109403: EQUAL
109404: IFTRUE 109408
109406: GO 109436
109408: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
109409: LD_ADDR_OWVAR 42
109413: PUSH
109414: LD_INT 19
109416: PUSH
109417: LD_INT 23
109419: PUSH
109420: LD_INT 19
109422: PUSH
109423: EMPTY
109424: LIST
109425: LIST
109426: LIST
109427: PUSH
109428: LD_VAR 0 1
109432: ARRAY
109433: ST_TO_ADDR
109434: GO 109760
109436: LD_INT 18
109438: DOUBLE
109439: EQUAL
109440: IFTRUE 109444
109442: GO 109455
109444: POP
// bc_type := b_ext_radar ; 19 :
109445: LD_ADDR_OWVAR 42
109449: PUSH
109450: LD_INT 20
109452: ST_TO_ADDR
109453: GO 109760
109455: LD_INT 19
109457: DOUBLE
109458: EQUAL
109459: IFTRUE 109463
109461: GO 109474
109463: POP
// bc_type := b_ext_radio ; 20 :
109464: LD_ADDR_OWVAR 42
109468: PUSH
109469: LD_INT 22
109471: ST_TO_ADDR
109472: GO 109760
109474: LD_INT 20
109476: DOUBLE
109477: EQUAL
109478: IFTRUE 109482
109480: GO 109493
109482: POP
// bc_type := b_ext_siberium ; 21 :
109483: LD_ADDR_OWVAR 42
109487: PUSH
109488: LD_INT 21
109490: ST_TO_ADDR
109491: GO 109760
109493: LD_INT 21
109495: DOUBLE
109496: EQUAL
109497: IFTRUE 109501
109499: GO 109512
109501: POP
// bc_type := b_ext_computer ; 22 :
109502: LD_ADDR_OWVAR 42
109506: PUSH
109507: LD_INT 24
109509: ST_TO_ADDR
109510: GO 109760
109512: LD_INT 22
109514: DOUBLE
109515: EQUAL
109516: IFTRUE 109520
109518: GO 109531
109520: POP
// bc_type := b_ext_track ; 23 :
109521: LD_ADDR_OWVAR 42
109525: PUSH
109526: LD_INT 16
109528: ST_TO_ADDR
109529: GO 109760
109531: LD_INT 23
109533: DOUBLE
109534: EQUAL
109535: IFTRUE 109539
109537: GO 109550
109539: POP
// bc_type := b_ext_laser ; 24 :
109540: LD_ADDR_OWVAR 42
109544: PUSH
109545: LD_INT 25
109547: ST_TO_ADDR
109548: GO 109760
109550: LD_INT 24
109552: DOUBLE
109553: EQUAL
109554: IFTRUE 109558
109556: GO 109569
109558: POP
// bc_type := b_control_tower ; 25 :
109559: LD_ADDR_OWVAR 42
109563: PUSH
109564: LD_INT 36
109566: ST_TO_ADDR
109567: GO 109760
109569: LD_INT 25
109571: DOUBLE
109572: EQUAL
109573: IFTRUE 109577
109575: GO 109588
109577: POP
// bc_type := b_breastwork ; 26 :
109578: LD_ADDR_OWVAR 42
109582: PUSH
109583: LD_INT 31
109585: ST_TO_ADDR
109586: GO 109760
109588: LD_INT 26
109590: DOUBLE
109591: EQUAL
109592: IFTRUE 109596
109594: GO 109607
109596: POP
// bc_type := b_bunker ; 27 :
109597: LD_ADDR_OWVAR 42
109601: PUSH
109602: LD_INT 32
109604: ST_TO_ADDR
109605: GO 109760
109607: LD_INT 27
109609: DOUBLE
109610: EQUAL
109611: IFTRUE 109615
109613: GO 109626
109615: POP
// bc_type := b_turret ; 28 :
109616: LD_ADDR_OWVAR 42
109620: PUSH
109621: LD_INT 33
109623: ST_TO_ADDR
109624: GO 109760
109626: LD_INT 28
109628: DOUBLE
109629: EQUAL
109630: IFTRUE 109634
109632: GO 109645
109634: POP
// bc_type := b_armoury ; 29 :
109635: LD_ADDR_OWVAR 42
109639: PUSH
109640: LD_INT 4
109642: ST_TO_ADDR
109643: GO 109760
109645: LD_INT 29
109647: DOUBLE
109648: EQUAL
109649: IFTRUE 109653
109651: GO 109664
109653: POP
// bc_type := b_barracks ; 30 :
109654: LD_ADDR_OWVAR 42
109658: PUSH
109659: LD_INT 5
109661: ST_TO_ADDR
109662: GO 109760
109664: LD_INT 30
109666: DOUBLE
109667: EQUAL
109668: IFTRUE 109672
109670: GO 109683
109672: POP
// bc_type := b_solar_power ; 31 :
109673: LD_ADDR_OWVAR 42
109677: PUSH
109678: LD_INT 27
109680: ST_TO_ADDR
109681: GO 109760
109683: LD_INT 31
109685: DOUBLE
109686: EQUAL
109687: IFTRUE 109691
109689: GO 109702
109691: POP
// bc_type := b_oil_power ; 32 :
109692: LD_ADDR_OWVAR 42
109696: PUSH
109697: LD_INT 26
109699: ST_TO_ADDR
109700: GO 109760
109702: LD_INT 32
109704: DOUBLE
109705: EQUAL
109706: IFTRUE 109710
109708: GO 109721
109710: POP
// bc_type := b_siberite_power ; 33 :
109711: LD_ADDR_OWVAR 42
109715: PUSH
109716: LD_INT 28
109718: ST_TO_ADDR
109719: GO 109760
109721: LD_INT 33
109723: DOUBLE
109724: EQUAL
109725: IFTRUE 109729
109727: GO 109740
109729: POP
// bc_type := b_oil_mine ; 34 :
109730: LD_ADDR_OWVAR 42
109734: PUSH
109735: LD_INT 29
109737: ST_TO_ADDR
109738: GO 109760
109740: LD_INT 34
109742: DOUBLE
109743: EQUAL
109744: IFTRUE 109748
109746: GO 109759
109748: POP
// bc_type := b_siberite_mine ; end ;
109749: LD_ADDR_OWVAR 42
109753: PUSH
109754: LD_INT 30
109756: ST_TO_ADDR
109757: GO 109760
109759: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
109760: LD_ADDR_VAR 0 8
109764: PUSH
109765: LD_VAR 0 5
109769: PPUSH
109770: LD_VAR 0 6
109774: PPUSH
109775: LD_VAR 0 3
109779: PPUSH
109780: CALL_OW 47
109784: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
109785: LD_OWVAR 42
109789: PUSH
109790: LD_INT 32
109792: PUSH
109793: LD_INT 33
109795: PUSH
109796: EMPTY
109797: LIST
109798: LIST
109799: IN
109800: IFFALSE 109816
// PlaceWeaponTurret ( b , weapon ) ;
109802: LD_VAR 0 8
109806: PPUSH
109807: LD_VAR 0 4
109811: PPUSH
109812: CALL_OW 431
// end ;
109816: LD_VAR 0 7
109820: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
109821: LD_INT 0
109823: PPUSH
109824: PPUSH
109825: PPUSH
109826: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109827: LD_ADDR_VAR 0 4
109831: PUSH
109832: LD_INT 22
109834: PUSH
109835: LD_OWVAR 2
109839: PUSH
109840: EMPTY
109841: LIST
109842: LIST
109843: PUSH
109844: LD_INT 2
109846: PUSH
109847: LD_INT 30
109849: PUSH
109850: LD_INT 0
109852: PUSH
109853: EMPTY
109854: LIST
109855: LIST
109856: PUSH
109857: LD_INT 30
109859: PUSH
109860: LD_INT 1
109862: PUSH
109863: EMPTY
109864: LIST
109865: LIST
109866: PUSH
109867: EMPTY
109868: LIST
109869: LIST
109870: LIST
109871: PUSH
109872: EMPTY
109873: LIST
109874: LIST
109875: PPUSH
109876: CALL_OW 69
109880: ST_TO_ADDR
// if not tmp then
109881: LD_VAR 0 4
109885: NOT
109886: IFFALSE 109890
// exit ;
109888: GO 109949
// for i in tmp do
109890: LD_ADDR_VAR 0 2
109894: PUSH
109895: LD_VAR 0 4
109899: PUSH
109900: FOR_IN
109901: IFFALSE 109947
// for j = 1 to 3 do
109903: LD_ADDR_VAR 0 3
109907: PUSH
109908: DOUBLE
109909: LD_INT 1
109911: DEC
109912: ST_TO_ADDR
109913: LD_INT 3
109915: PUSH
109916: FOR_TO
109917: IFFALSE 109943
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109919: LD_VAR 0 2
109923: PPUSH
109924: CALL_OW 274
109928: PPUSH
109929: LD_VAR 0 3
109933: PPUSH
109934: LD_INT 99999
109936: PPUSH
109937: CALL_OW 277
109941: GO 109916
109943: POP
109944: POP
109945: GO 109900
109947: POP
109948: POP
// end ;
109949: LD_VAR 0 1
109953: RET
// export function hHackSetLevel10 ; var i , j ; begin
109954: LD_INT 0
109956: PPUSH
109957: PPUSH
109958: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109959: LD_ADDR_VAR 0 2
109963: PUSH
109964: LD_INT 21
109966: PUSH
109967: LD_INT 1
109969: PUSH
109970: EMPTY
109971: LIST
109972: LIST
109973: PPUSH
109974: CALL_OW 69
109978: PUSH
109979: FOR_IN
109980: IFFALSE 110032
// if IsSelected ( i ) then
109982: LD_VAR 0 2
109986: PPUSH
109987: CALL_OW 306
109991: IFFALSE 110030
// begin for j := 1 to 4 do
109993: LD_ADDR_VAR 0 3
109997: PUSH
109998: DOUBLE
109999: LD_INT 1
110001: DEC
110002: ST_TO_ADDR
110003: LD_INT 4
110005: PUSH
110006: FOR_TO
110007: IFFALSE 110028
// SetSkill ( i , j , 10 ) ;
110009: LD_VAR 0 2
110013: PPUSH
110014: LD_VAR 0 3
110018: PPUSH
110019: LD_INT 10
110021: PPUSH
110022: CALL_OW 237
110026: GO 110006
110028: POP
110029: POP
// end ;
110030: GO 109979
110032: POP
110033: POP
// end ;
110034: LD_VAR 0 1
110038: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
110039: LD_INT 0
110041: PPUSH
110042: PPUSH
110043: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
110044: LD_ADDR_VAR 0 2
110048: PUSH
110049: LD_INT 22
110051: PUSH
110052: LD_OWVAR 2
110056: PUSH
110057: EMPTY
110058: LIST
110059: LIST
110060: PUSH
110061: LD_INT 21
110063: PUSH
110064: LD_INT 1
110066: PUSH
110067: EMPTY
110068: LIST
110069: LIST
110070: PUSH
110071: EMPTY
110072: LIST
110073: LIST
110074: PPUSH
110075: CALL_OW 69
110079: PUSH
110080: FOR_IN
110081: IFFALSE 110122
// begin for j := 1 to 4 do
110083: LD_ADDR_VAR 0 3
110087: PUSH
110088: DOUBLE
110089: LD_INT 1
110091: DEC
110092: ST_TO_ADDR
110093: LD_INT 4
110095: PUSH
110096: FOR_TO
110097: IFFALSE 110118
// SetSkill ( i , j , 10 ) ;
110099: LD_VAR 0 2
110103: PPUSH
110104: LD_VAR 0 3
110108: PPUSH
110109: LD_INT 10
110111: PPUSH
110112: CALL_OW 237
110116: GO 110096
110118: POP
110119: POP
// end ;
110120: GO 110080
110122: POP
110123: POP
// end ;
110124: LD_VAR 0 1
110128: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
110129: LD_INT 0
110131: PPUSH
// uc_side := your_side ;
110132: LD_ADDR_OWVAR 20
110136: PUSH
110137: LD_OWVAR 2
110141: ST_TO_ADDR
// uc_nation := nation ;
110142: LD_ADDR_OWVAR 21
110146: PUSH
110147: LD_VAR 0 1
110151: ST_TO_ADDR
// InitHc ;
110152: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
110156: LD_INT 0
110158: PPUSH
110159: LD_VAR 0 2
110163: PPUSH
110164: LD_VAR 0 3
110168: PPUSH
110169: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
110173: LD_VAR 0 4
110177: PPUSH
110178: LD_VAR 0 5
110182: PPUSH
110183: CALL_OW 428
110187: PUSH
110188: LD_INT 0
110190: EQUAL
110191: IFFALSE 110215
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
110193: CALL_OW 44
110197: PPUSH
110198: LD_VAR 0 4
110202: PPUSH
110203: LD_VAR 0 5
110207: PPUSH
110208: LD_INT 1
110210: PPUSH
110211: CALL_OW 48
// end ;
110215: LD_VAR 0 6
110219: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
110220: LD_INT 0
110222: PPUSH
110223: PPUSH
// uc_side := your_side ;
110224: LD_ADDR_OWVAR 20
110228: PUSH
110229: LD_OWVAR 2
110233: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
110234: LD_VAR 0 1
110238: PUSH
110239: LD_INT 1
110241: PUSH
110242: LD_INT 2
110244: PUSH
110245: LD_INT 3
110247: PUSH
110248: LD_INT 4
110250: PUSH
110251: LD_INT 5
110253: PUSH
110254: EMPTY
110255: LIST
110256: LIST
110257: LIST
110258: LIST
110259: LIST
110260: IN
110261: IFFALSE 110273
// uc_nation := nation_american else
110263: LD_ADDR_OWVAR 21
110267: PUSH
110268: LD_INT 1
110270: ST_TO_ADDR
110271: GO 110316
// if chassis in [ 11 , 12 , 13 , 14 ] then
110273: LD_VAR 0 1
110277: PUSH
110278: LD_INT 11
110280: PUSH
110281: LD_INT 12
110283: PUSH
110284: LD_INT 13
110286: PUSH
110287: LD_INT 14
110289: PUSH
110290: EMPTY
110291: LIST
110292: LIST
110293: LIST
110294: LIST
110295: IN
110296: IFFALSE 110308
// uc_nation := nation_arabian else
110298: LD_ADDR_OWVAR 21
110302: PUSH
110303: LD_INT 2
110305: ST_TO_ADDR
110306: GO 110316
// uc_nation := nation_russian ;
110308: LD_ADDR_OWVAR 21
110312: PUSH
110313: LD_INT 3
110315: ST_TO_ADDR
// vc_chassis := chassis ;
110316: LD_ADDR_OWVAR 37
110320: PUSH
110321: LD_VAR 0 1
110325: ST_TO_ADDR
// vc_engine := engine ;
110326: LD_ADDR_OWVAR 39
110330: PUSH
110331: LD_VAR 0 2
110335: ST_TO_ADDR
// vc_control := control ;
110336: LD_ADDR_OWVAR 38
110340: PUSH
110341: LD_VAR 0 3
110345: ST_TO_ADDR
// vc_weapon := weapon ;
110346: LD_ADDR_OWVAR 40
110350: PUSH
110351: LD_VAR 0 4
110355: ST_TO_ADDR
// un := CreateVehicle ;
110356: LD_ADDR_VAR 0 8
110360: PUSH
110361: CALL_OW 45
110365: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110366: LD_VAR 0 8
110370: PPUSH
110371: LD_INT 0
110373: PPUSH
110374: LD_INT 5
110376: PPUSH
110377: CALL_OW 12
110381: PPUSH
110382: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110386: LD_VAR 0 8
110390: PPUSH
110391: LD_VAR 0 5
110395: PPUSH
110396: LD_VAR 0 6
110400: PPUSH
110401: LD_INT 1
110403: PPUSH
110404: CALL_OW 48
// end ;
110408: LD_VAR 0 7
110412: RET
// export hInvincible ; every 1 do
110413: GO 110415
110415: DISABLE
// hInvincible := [ ] ;
110416: LD_ADDR_EXP 183
110420: PUSH
110421: EMPTY
110422: ST_TO_ADDR
110423: END
// every 10 do var i ;
110424: GO 110426
110426: DISABLE
110427: LD_INT 0
110429: PPUSH
// begin enable ;
110430: ENABLE
// if not hInvincible then
110431: LD_EXP 183
110435: NOT
110436: IFFALSE 110440
// exit ;
110438: GO 110484
// for i in hInvincible do
110440: LD_ADDR_VAR 0 1
110444: PUSH
110445: LD_EXP 183
110449: PUSH
110450: FOR_IN
110451: IFFALSE 110482
// if GetLives ( i ) < 1000 then
110453: LD_VAR 0 1
110457: PPUSH
110458: CALL_OW 256
110462: PUSH
110463: LD_INT 1000
110465: LESS
110466: IFFALSE 110480
// SetLives ( i , 1000 ) ;
110468: LD_VAR 0 1
110472: PPUSH
110473: LD_INT 1000
110475: PPUSH
110476: CALL_OW 234
110480: GO 110450
110482: POP
110483: POP
// end ;
110484: PPOPN 1
110486: END
// export function hHackInvincible ; var i ; begin
110487: LD_INT 0
110489: PPUSH
110490: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110491: LD_ADDR_VAR 0 2
110495: PUSH
110496: LD_INT 2
110498: PUSH
110499: LD_INT 21
110501: PUSH
110502: LD_INT 1
110504: PUSH
110505: EMPTY
110506: LIST
110507: LIST
110508: PUSH
110509: LD_INT 21
110511: PUSH
110512: LD_INT 2
110514: PUSH
110515: EMPTY
110516: LIST
110517: LIST
110518: PUSH
110519: EMPTY
110520: LIST
110521: LIST
110522: LIST
110523: PPUSH
110524: CALL_OW 69
110528: PUSH
110529: FOR_IN
110530: IFFALSE 110591
// if IsSelected ( i ) then
110532: LD_VAR 0 2
110536: PPUSH
110537: CALL_OW 306
110541: IFFALSE 110589
// begin if i in hInvincible then
110543: LD_VAR 0 2
110547: PUSH
110548: LD_EXP 183
110552: IN
110553: IFFALSE 110573
// hInvincible := hInvincible diff i else
110555: LD_ADDR_EXP 183
110559: PUSH
110560: LD_EXP 183
110564: PUSH
110565: LD_VAR 0 2
110569: DIFF
110570: ST_TO_ADDR
110571: GO 110589
// hInvincible := hInvincible union i ;
110573: LD_ADDR_EXP 183
110577: PUSH
110578: LD_EXP 183
110582: PUSH
110583: LD_VAR 0 2
110587: UNION
110588: ST_TO_ADDR
// end ;
110589: GO 110529
110591: POP
110592: POP
// end ;
110593: LD_VAR 0 1
110597: RET
// export function hHackInvisible ; var i , j ; begin
110598: LD_INT 0
110600: PPUSH
110601: PPUSH
110602: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110603: LD_ADDR_VAR 0 2
110607: PUSH
110608: LD_INT 21
110610: PUSH
110611: LD_INT 1
110613: PUSH
110614: EMPTY
110615: LIST
110616: LIST
110617: PPUSH
110618: CALL_OW 69
110622: PUSH
110623: FOR_IN
110624: IFFALSE 110648
// if IsSelected ( i ) then
110626: LD_VAR 0 2
110630: PPUSH
110631: CALL_OW 306
110635: IFFALSE 110646
// ComForceInvisible ( i ) ;
110637: LD_VAR 0 2
110641: PPUSH
110642: CALL_OW 496
110646: GO 110623
110648: POP
110649: POP
// end ;
110650: LD_VAR 0 1
110654: RET
// export function hHackChangeYourSide ; begin
110655: LD_INT 0
110657: PPUSH
// if your_side = 8 then
110658: LD_OWVAR 2
110662: PUSH
110663: LD_INT 8
110665: EQUAL
110666: IFFALSE 110678
// your_side := 0 else
110668: LD_ADDR_OWVAR 2
110672: PUSH
110673: LD_INT 0
110675: ST_TO_ADDR
110676: GO 110692
// your_side := your_side + 1 ;
110678: LD_ADDR_OWVAR 2
110682: PUSH
110683: LD_OWVAR 2
110687: PUSH
110688: LD_INT 1
110690: PLUS
110691: ST_TO_ADDR
// end ;
110692: LD_VAR 0 1
110696: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110697: LD_INT 0
110699: PPUSH
110700: PPUSH
110701: PPUSH
// for i in all_units do
110702: LD_ADDR_VAR 0 2
110706: PUSH
110707: LD_OWVAR 3
110711: PUSH
110712: FOR_IN
110713: IFFALSE 110791
// if IsSelected ( i ) then
110715: LD_VAR 0 2
110719: PPUSH
110720: CALL_OW 306
110724: IFFALSE 110789
// begin j := GetSide ( i ) ;
110726: LD_ADDR_VAR 0 3
110730: PUSH
110731: LD_VAR 0 2
110735: PPUSH
110736: CALL_OW 255
110740: ST_TO_ADDR
// if j = 8 then
110741: LD_VAR 0 3
110745: PUSH
110746: LD_INT 8
110748: EQUAL
110749: IFFALSE 110761
// j := 0 else
110751: LD_ADDR_VAR 0 3
110755: PUSH
110756: LD_INT 0
110758: ST_TO_ADDR
110759: GO 110775
// j := j + 1 ;
110761: LD_ADDR_VAR 0 3
110765: PUSH
110766: LD_VAR 0 3
110770: PUSH
110771: LD_INT 1
110773: PLUS
110774: ST_TO_ADDR
// SetSide ( i , j ) ;
110775: LD_VAR 0 2
110779: PPUSH
110780: LD_VAR 0 3
110784: PPUSH
110785: CALL_OW 235
// end ;
110789: GO 110712
110791: POP
110792: POP
// end ;
110793: LD_VAR 0 1
110797: RET
// export function hHackFog ; begin
110798: LD_INT 0
110800: PPUSH
// FogOff ( true ) ;
110801: LD_INT 1
110803: PPUSH
110804: CALL_OW 344
// end ;
110808: LD_VAR 0 1
110812: RET
// export function hHackTeleport ( unit , x , y ) ; begin
110813: LD_INT 0
110815: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
110816: LD_VAR 0 1
110820: PPUSH
110821: LD_VAR 0 2
110825: PPUSH
110826: LD_VAR 0 3
110830: PPUSH
110831: LD_INT 1
110833: PPUSH
110834: LD_INT 1
110836: PPUSH
110837: CALL_OW 483
// CenterOnXY ( x , y ) ;
110841: LD_VAR 0 2
110845: PPUSH
110846: LD_VAR 0 3
110850: PPUSH
110851: CALL_OW 84
// end ;
110855: LD_VAR 0 4
110859: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
110860: LD_INT 0
110862: PPUSH
110863: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
110864: LD_VAR 0 1
110868: NOT
110869: PUSH
110870: LD_VAR 0 2
110874: PPUSH
110875: LD_VAR 0 3
110879: PPUSH
110880: CALL_OW 488
110884: NOT
110885: OR
110886: PUSH
110887: LD_VAR 0 1
110891: PPUSH
110892: CALL_OW 266
110896: PUSH
110897: LD_INT 3
110899: NONEQUAL
110900: PUSH
110901: LD_VAR 0 1
110905: PPUSH
110906: CALL_OW 247
110910: PUSH
110911: LD_INT 1
110913: EQUAL
110914: NOT
110915: AND
110916: OR
110917: IFFALSE 110921
// exit ;
110919: GO 111070
// if GetType ( factory ) = unit_human then
110921: LD_VAR 0 1
110925: PPUSH
110926: CALL_OW 247
110930: PUSH
110931: LD_INT 1
110933: EQUAL
110934: IFFALSE 110951
// factory := IsInUnit ( factory ) ;
110936: LD_ADDR_VAR 0 1
110940: PUSH
110941: LD_VAR 0 1
110945: PPUSH
110946: CALL_OW 310
110950: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110951: LD_VAR 0 1
110955: PPUSH
110956: CALL_OW 266
110960: PUSH
110961: LD_INT 3
110963: NONEQUAL
110964: IFFALSE 110968
// exit ;
110966: GO 111070
// if HexInfo ( x , y ) = factory then
110968: LD_VAR 0 2
110972: PPUSH
110973: LD_VAR 0 3
110977: PPUSH
110978: CALL_OW 428
110982: PUSH
110983: LD_VAR 0 1
110987: EQUAL
110988: IFFALSE 111015
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
110990: LD_ADDR_EXP 184
110994: PUSH
110995: LD_EXP 184
110999: PPUSH
111000: LD_VAR 0 1
111004: PPUSH
111005: LD_INT 0
111007: PPUSH
111008: CALL_OW 1
111012: ST_TO_ADDR
111013: GO 111066
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
111015: LD_ADDR_EXP 184
111019: PUSH
111020: LD_EXP 184
111024: PPUSH
111025: LD_VAR 0 1
111029: PPUSH
111030: LD_VAR 0 1
111034: PPUSH
111035: CALL_OW 255
111039: PUSH
111040: LD_VAR 0 1
111044: PUSH
111045: LD_VAR 0 2
111049: PUSH
111050: LD_VAR 0 3
111054: PUSH
111055: EMPTY
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: PPUSH
111061: CALL_OW 1
111065: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111066: CALL 111075 0 0
// end ;
111070: LD_VAR 0 4
111074: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
111075: LD_INT 0
111077: PPUSH
111078: PPUSH
111079: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
111080: LD_STRING resetFactoryWaypoint();
111082: PPUSH
111083: CALL_OW 559
// if factoryWaypoints then
111087: LD_EXP 184
111091: IFFALSE 111217
// begin list := PrepareArray ( factoryWaypoints ) ;
111093: LD_ADDR_VAR 0 3
111097: PUSH
111098: LD_EXP 184
111102: PPUSH
111103: CALL 95030 0 1
111107: ST_TO_ADDR
// for i := 1 to list do
111108: LD_ADDR_VAR 0 2
111112: PUSH
111113: DOUBLE
111114: LD_INT 1
111116: DEC
111117: ST_TO_ADDR
111118: LD_VAR 0 3
111122: PUSH
111123: FOR_TO
111124: IFFALSE 111215
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111126: LD_STRING setFactoryWaypointXY(
111128: PUSH
111129: LD_VAR 0 3
111133: PUSH
111134: LD_VAR 0 2
111138: ARRAY
111139: PUSH
111140: LD_INT 1
111142: ARRAY
111143: STR
111144: PUSH
111145: LD_STRING ,
111147: STR
111148: PUSH
111149: LD_VAR 0 3
111153: PUSH
111154: LD_VAR 0 2
111158: ARRAY
111159: PUSH
111160: LD_INT 2
111162: ARRAY
111163: STR
111164: PUSH
111165: LD_STRING ,
111167: STR
111168: PUSH
111169: LD_VAR 0 3
111173: PUSH
111174: LD_VAR 0 2
111178: ARRAY
111179: PUSH
111180: LD_INT 3
111182: ARRAY
111183: STR
111184: PUSH
111185: LD_STRING ,
111187: STR
111188: PUSH
111189: LD_VAR 0 3
111193: PUSH
111194: LD_VAR 0 2
111198: ARRAY
111199: PUSH
111200: LD_INT 4
111202: ARRAY
111203: STR
111204: PUSH
111205: LD_STRING )
111207: STR
111208: PPUSH
111209: CALL_OW 559
111213: GO 111123
111215: POP
111216: POP
// end ; end ;
111217: LD_VAR 0 1
111221: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
111222: LD_INT 0
111224: PPUSH
// if HexInfo ( x , y ) = warehouse then
111225: LD_VAR 0 2
111229: PPUSH
111230: LD_VAR 0 3
111234: PPUSH
111235: CALL_OW 428
111239: PUSH
111240: LD_VAR 0 1
111244: EQUAL
111245: IFFALSE 111272
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
111247: LD_ADDR_EXP 185
111251: PUSH
111252: LD_EXP 185
111256: PPUSH
111257: LD_VAR 0 1
111261: PPUSH
111262: LD_INT 0
111264: PPUSH
111265: CALL_OW 1
111269: ST_TO_ADDR
111270: GO 111323
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111272: LD_ADDR_EXP 185
111276: PUSH
111277: LD_EXP 185
111281: PPUSH
111282: LD_VAR 0 1
111286: PPUSH
111287: LD_VAR 0 1
111291: PPUSH
111292: CALL_OW 255
111296: PUSH
111297: LD_VAR 0 1
111301: PUSH
111302: LD_VAR 0 2
111306: PUSH
111307: LD_VAR 0 3
111311: PUSH
111312: EMPTY
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: PPUSH
111318: CALL_OW 1
111322: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111323: CALL 111332 0 0
// end ;
111327: LD_VAR 0 4
111331: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111332: LD_INT 0
111334: PPUSH
111335: PPUSH
111336: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111337: LD_STRING resetWarehouseGatheringPoints();
111339: PPUSH
111340: CALL_OW 559
// if warehouseGatheringPoints then
111344: LD_EXP 185
111348: IFFALSE 111474
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111350: LD_ADDR_VAR 0 3
111354: PUSH
111355: LD_EXP 185
111359: PPUSH
111360: CALL 95030 0 1
111364: ST_TO_ADDR
// for i := 1 to list do
111365: LD_ADDR_VAR 0 2
111369: PUSH
111370: DOUBLE
111371: LD_INT 1
111373: DEC
111374: ST_TO_ADDR
111375: LD_VAR 0 3
111379: PUSH
111380: FOR_TO
111381: IFFALSE 111472
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111383: LD_STRING setWarehouseGatheringPointXY(
111385: PUSH
111386: LD_VAR 0 3
111390: PUSH
111391: LD_VAR 0 2
111395: ARRAY
111396: PUSH
111397: LD_INT 1
111399: ARRAY
111400: STR
111401: PUSH
111402: LD_STRING ,
111404: STR
111405: PUSH
111406: LD_VAR 0 3
111410: PUSH
111411: LD_VAR 0 2
111415: ARRAY
111416: PUSH
111417: LD_INT 2
111419: ARRAY
111420: STR
111421: PUSH
111422: LD_STRING ,
111424: STR
111425: PUSH
111426: LD_VAR 0 3
111430: PUSH
111431: LD_VAR 0 2
111435: ARRAY
111436: PUSH
111437: LD_INT 3
111439: ARRAY
111440: STR
111441: PUSH
111442: LD_STRING ,
111444: STR
111445: PUSH
111446: LD_VAR 0 3
111450: PUSH
111451: LD_VAR 0 2
111455: ARRAY
111456: PUSH
111457: LD_INT 4
111459: ARRAY
111460: STR
111461: PUSH
111462: LD_STRING )
111464: STR
111465: PPUSH
111466: CALL_OW 559
111470: GO 111380
111472: POP
111473: POP
// end ; end ;
111474: LD_VAR 0 1
111478: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111479: LD_EXP 185
111483: IFFALSE 112168
111485: GO 111487
111487: DISABLE
111488: LD_INT 0
111490: PPUSH
111491: PPUSH
111492: PPUSH
111493: PPUSH
111494: PPUSH
111495: PPUSH
111496: PPUSH
111497: PPUSH
111498: PPUSH
// begin enable ;
111499: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111500: LD_ADDR_VAR 0 3
111504: PUSH
111505: LD_EXP 185
111509: PPUSH
111510: CALL 95030 0 1
111514: ST_TO_ADDR
// if not list then
111515: LD_VAR 0 3
111519: NOT
111520: IFFALSE 111524
// exit ;
111522: GO 112168
// for i := 1 to list do
111524: LD_ADDR_VAR 0 1
111528: PUSH
111529: DOUBLE
111530: LD_INT 1
111532: DEC
111533: ST_TO_ADDR
111534: LD_VAR 0 3
111538: PUSH
111539: FOR_TO
111540: IFFALSE 112166
// begin depot := list [ i ] [ 2 ] ;
111542: LD_ADDR_VAR 0 8
111546: PUSH
111547: LD_VAR 0 3
111551: PUSH
111552: LD_VAR 0 1
111556: ARRAY
111557: PUSH
111558: LD_INT 2
111560: ARRAY
111561: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111562: LD_ADDR_VAR 0 5
111566: PUSH
111567: LD_VAR 0 3
111571: PUSH
111572: LD_VAR 0 1
111576: ARRAY
111577: PUSH
111578: LD_INT 1
111580: ARRAY
111581: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111582: LD_VAR 0 8
111586: PPUSH
111587: CALL_OW 301
111591: PUSH
111592: LD_VAR 0 5
111596: PUSH
111597: LD_VAR 0 8
111601: PPUSH
111602: CALL_OW 255
111606: NONEQUAL
111607: OR
111608: IFFALSE 111637
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111610: LD_ADDR_EXP 185
111614: PUSH
111615: LD_EXP 185
111619: PPUSH
111620: LD_VAR 0 8
111624: PPUSH
111625: LD_INT 0
111627: PPUSH
111628: CALL_OW 1
111632: ST_TO_ADDR
// exit ;
111633: POP
111634: POP
111635: GO 112168
// end ; x := list [ i ] [ 3 ] ;
111637: LD_ADDR_VAR 0 6
111641: PUSH
111642: LD_VAR 0 3
111646: PUSH
111647: LD_VAR 0 1
111651: ARRAY
111652: PUSH
111653: LD_INT 3
111655: ARRAY
111656: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
111657: LD_ADDR_VAR 0 7
111661: PUSH
111662: LD_VAR 0 3
111666: PUSH
111667: LD_VAR 0 1
111671: ARRAY
111672: PUSH
111673: LD_INT 4
111675: ARRAY
111676: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
111677: LD_ADDR_VAR 0 9
111681: PUSH
111682: LD_VAR 0 6
111686: PPUSH
111687: LD_VAR 0 7
111691: PPUSH
111692: LD_INT 16
111694: PPUSH
111695: CALL 93614 0 3
111699: ST_TO_ADDR
// if not cratesNearbyPoint then
111700: LD_VAR 0 9
111704: NOT
111705: IFFALSE 111711
// exit ;
111707: POP
111708: POP
111709: GO 112168
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
111711: LD_ADDR_VAR 0 4
111715: PUSH
111716: LD_INT 22
111718: PUSH
111719: LD_VAR 0 5
111723: PUSH
111724: EMPTY
111725: LIST
111726: LIST
111727: PUSH
111728: LD_INT 3
111730: PUSH
111731: LD_INT 60
111733: PUSH
111734: EMPTY
111735: LIST
111736: PUSH
111737: EMPTY
111738: LIST
111739: LIST
111740: PUSH
111741: LD_INT 91
111743: PUSH
111744: LD_VAR 0 8
111748: PUSH
111749: LD_INT 6
111751: PUSH
111752: EMPTY
111753: LIST
111754: LIST
111755: LIST
111756: PUSH
111757: LD_INT 2
111759: PUSH
111760: LD_INT 25
111762: PUSH
111763: LD_INT 2
111765: PUSH
111766: EMPTY
111767: LIST
111768: LIST
111769: PUSH
111770: LD_INT 25
111772: PUSH
111773: LD_INT 16
111775: PUSH
111776: EMPTY
111777: LIST
111778: LIST
111779: PUSH
111780: EMPTY
111781: LIST
111782: LIST
111783: LIST
111784: PUSH
111785: EMPTY
111786: LIST
111787: LIST
111788: LIST
111789: LIST
111790: PPUSH
111791: CALL_OW 69
111795: PUSH
111796: LD_VAR 0 8
111800: PPUSH
111801: CALL_OW 313
111805: PPUSH
111806: LD_INT 3
111808: PUSH
111809: LD_INT 60
111811: PUSH
111812: EMPTY
111813: LIST
111814: PUSH
111815: EMPTY
111816: LIST
111817: LIST
111818: PUSH
111819: LD_INT 2
111821: PUSH
111822: LD_INT 25
111824: PUSH
111825: LD_INT 2
111827: PUSH
111828: EMPTY
111829: LIST
111830: LIST
111831: PUSH
111832: LD_INT 25
111834: PUSH
111835: LD_INT 16
111837: PUSH
111838: EMPTY
111839: LIST
111840: LIST
111841: PUSH
111842: EMPTY
111843: LIST
111844: LIST
111845: LIST
111846: PUSH
111847: EMPTY
111848: LIST
111849: LIST
111850: PPUSH
111851: CALL_OW 72
111855: UNION
111856: ST_TO_ADDR
// if tmp then
111857: LD_VAR 0 4
111861: IFFALSE 111941
// begin tmp := ShrinkArray ( tmp , 3 ) ;
111863: LD_ADDR_VAR 0 4
111867: PUSH
111868: LD_VAR 0 4
111872: PPUSH
111873: LD_INT 3
111875: PPUSH
111876: CALL 91583 0 2
111880: ST_TO_ADDR
// for j in tmp do
111881: LD_ADDR_VAR 0 2
111885: PUSH
111886: LD_VAR 0 4
111890: PUSH
111891: FOR_IN
111892: IFFALSE 111935
// begin if IsInUnit ( j ) then
111894: LD_VAR 0 2
111898: PPUSH
111899: CALL_OW 310
111903: IFFALSE 111914
// ComExit ( j ) ;
111905: LD_VAR 0 2
111909: PPUSH
111910: CALL 91666 0 1
// AddComCollect ( j , x , y ) ;
111914: LD_VAR 0 2
111918: PPUSH
111919: LD_VAR 0 6
111923: PPUSH
111924: LD_VAR 0 7
111928: PPUSH
111929: CALL_OW 177
// end ;
111933: GO 111891
111935: POP
111936: POP
// exit ;
111937: POP
111938: POP
111939: GO 112168
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
111941: LD_ADDR_VAR 0 4
111945: PUSH
111946: LD_INT 22
111948: PUSH
111949: LD_VAR 0 5
111953: PUSH
111954: EMPTY
111955: LIST
111956: LIST
111957: PUSH
111958: LD_INT 91
111960: PUSH
111961: LD_VAR 0 8
111965: PUSH
111966: LD_INT 8
111968: PUSH
111969: EMPTY
111970: LIST
111971: LIST
111972: LIST
111973: PUSH
111974: LD_INT 2
111976: PUSH
111977: LD_INT 34
111979: PUSH
111980: LD_INT 12
111982: PUSH
111983: EMPTY
111984: LIST
111985: LIST
111986: PUSH
111987: LD_INT 34
111989: PUSH
111990: LD_INT 51
111992: PUSH
111993: EMPTY
111994: LIST
111995: LIST
111996: PUSH
111997: LD_INT 34
111999: PUSH
112000: LD_INT 32
112002: PUSH
112003: EMPTY
112004: LIST
112005: LIST
112006: PUSH
112007: LD_INT 34
112009: PUSH
112010: LD_INT 89
112012: PUSH
112013: EMPTY
112014: LIST
112015: LIST
112016: PUSH
112017: EMPTY
112018: LIST
112019: LIST
112020: LIST
112021: LIST
112022: LIST
112023: PUSH
112024: EMPTY
112025: LIST
112026: LIST
112027: LIST
112028: PPUSH
112029: CALL_OW 69
112033: ST_TO_ADDR
// if tmp then
112034: LD_VAR 0 4
112038: IFFALSE 112164
// begin for j in tmp do
112040: LD_ADDR_VAR 0 2
112044: PUSH
112045: LD_VAR 0 4
112049: PUSH
112050: FOR_IN
112051: IFFALSE 112162
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
112053: LD_VAR 0 2
112057: PPUSH
112058: CALL_OW 262
112062: PUSH
112063: LD_INT 3
112065: EQUAL
112066: PUSH
112067: LD_VAR 0 2
112071: PPUSH
112072: CALL_OW 261
112076: PUSH
112077: LD_INT 20
112079: GREATER
112080: OR
112081: PUSH
112082: LD_VAR 0 2
112086: PPUSH
112087: CALL_OW 314
112091: NOT
112092: AND
112093: PUSH
112094: LD_VAR 0 2
112098: PPUSH
112099: CALL_OW 263
112103: PUSH
112104: LD_INT 1
112106: NONEQUAL
112107: PUSH
112108: LD_VAR 0 2
112112: PPUSH
112113: CALL_OW 311
112117: OR
112118: AND
112119: IFFALSE 112160
// begin ComCollect ( j , x , y ) ;
112121: LD_VAR 0 2
112125: PPUSH
112126: LD_VAR 0 6
112130: PPUSH
112131: LD_VAR 0 7
112135: PPUSH
112136: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
112140: LD_VAR 0 2
112144: PPUSH
112145: LD_VAR 0 8
112149: PPUSH
112150: CALL_OW 172
// exit ;
112154: POP
112155: POP
112156: POP
112157: POP
112158: GO 112168
// end ;
112160: GO 112050
112162: POP
112163: POP
// end ; end ;
112164: GO 111539
112166: POP
112167: POP
// end ; end_of_file
112168: PPOPN 9
112170: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112171: LD_INT 0
112173: PPUSH
112174: PPUSH
112175: PPUSH
112176: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112177: LD_VAR 0 1
112181: PPUSH
112182: CALL_OW 264
112186: PUSH
112187: LD_INT 91
112189: EQUAL
112190: IFFALSE 112262
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112192: LD_INT 68
112194: PPUSH
112195: LD_VAR 0 1
112199: PPUSH
112200: CALL_OW 255
112204: PPUSH
112205: CALL_OW 321
112209: PUSH
112210: LD_INT 2
112212: EQUAL
112213: IFFALSE 112225
// eff := 70 else
112215: LD_ADDR_VAR 0 4
112219: PUSH
112220: LD_INT 70
112222: ST_TO_ADDR
112223: GO 112233
// eff := 30 ;
112225: LD_ADDR_VAR 0 4
112229: PUSH
112230: LD_INT 30
112232: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112233: LD_VAR 0 1
112237: PPUSH
112238: CALL_OW 250
112242: PPUSH
112243: LD_VAR 0 1
112247: PPUSH
112248: CALL_OW 251
112252: PPUSH
112253: LD_VAR 0 4
112257: PPUSH
112258: CALL_OW 495
// end ; end ;
112262: LD_VAR 0 2
112266: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112267: LD_INT 0
112269: PPUSH
// end ;
112270: LD_VAR 0 4
112274: RET
// export function SOS_Command ( cmd ) ; begin
112275: LD_INT 0
112277: PPUSH
// end ;
112278: LD_VAR 0 2
112282: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
112283: LD_INT 0
112285: PPUSH
// end ;
112286: LD_VAR 0 6
112290: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var tag , driver ; begin
112291: LD_INT 0
112293: PPUSH
112294: PPUSH
112295: PPUSH
// if not vehicle or not factory then
112296: LD_VAR 0 1
112300: NOT
112301: PUSH
112302: LD_VAR 0 2
112306: NOT
112307: OR
112308: IFFALSE 112312
// exit ;
112310: GO 112615
// if factoryWaypoints >= factory then
112312: LD_EXP 184
112316: PUSH
112317: LD_VAR 0 2
112321: GREATEREQUAL
112322: IFFALSE 112615
// if factoryWaypoints [ factory ] then
112324: LD_EXP 184
112328: PUSH
112329: LD_VAR 0 2
112333: ARRAY
112334: IFFALSE 112615
// begin if GetControl ( vehicle ) = control_manual then
112336: LD_VAR 0 1
112340: PPUSH
112341: CALL_OW 263
112345: PUSH
112346: LD_INT 1
112348: EQUAL
112349: IFFALSE 112502
// begin driver := IsDrivenBy ( vehicle ) ;
112351: LD_ADDR_VAR 0 5
112355: PUSH
112356: LD_VAR 0 1
112360: PPUSH
112361: CALL_OW 311
112365: ST_TO_ADDR
// tag := GetTag ( driver ) ;
112366: LD_ADDR_VAR 0 4
112370: PUSH
112371: LD_VAR 0 5
112375: PPUSH
112376: CALL_OW 110
112380: ST_TO_ADDR
// if tag = tDriver then
112381: LD_VAR 0 4
112385: PUSH
112386: LD_INT 501
112388: EQUAL
112389: IFFALSE 112393
// exit ;
112391: GO 112615
// if not HasTask ( driver ) then
112393: LD_VAR 0 5
112397: PPUSH
112398: CALL_OW 314
112402: NOT
112403: IFFALSE 112500
// begin SetTag ( driver , tDriver ) ;
112405: LD_VAR 0 5
112409: PPUSH
112410: LD_INT 501
112412: PPUSH
112413: CALL_OW 109
// ComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112417: LD_VAR 0 5
112421: PPUSH
112422: LD_EXP 184
112426: PUSH
112427: LD_VAR 0 2
112431: ARRAY
112432: PUSH
112433: LD_INT 3
112435: ARRAY
112436: PPUSH
112437: LD_EXP 184
112441: PUSH
112442: LD_VAR 0 2
112446: ARRAY
112447: PUSH
112448: LD_INT 4
112450: ARRAY
112451: PPUSH
112452: CALL_OW 111
// AddComExitVehicle ( driver ) ;
112456: LD_VAR 0 5
112460: PPUSH
112461: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
112465: LD_VAR 0 5
112469: PPUSH
112470: LD_VAR 0 2
112474: PPUSH
112475: CALL_OW 180
// wait ( 0 0$1 ) ;
112479: LD_INT 35
112481: PPUSH
112482: CALL_OW 67
// SetTag ( driver , tag ) ;
112486: LD_VAR 0 5
112490: PPUSH
112491: LD_VAR 0 4
112495: PPUSH
112496: CALL_OW 109
// end ; end else
112500: GO 112615
// if GetControl ( vehicle ) = control_remote then
112502: LD_VAR 0 1
112506: PPUSH
112507: CALL_OW 263
112511: PUSH
112512: LD_INT 2
112514: EQUAL
112515: IFFALSE 112576
// begin wait ( 0 0$2 ) ;
112517: LD_INT 70
112519: PPUSH
112520: CALL_OW 67
// if Connect ( vehicle ) then
112524: LD_VAR 0 1
112528: PPUSH
112529: CALL 61885 0 1
112533: IFFALSE 112574
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112535: LD_VAR 0 1
112539: PPUSH
112540: LD_EXP 184
112544: PUSH
112545: LD_VAR 0 2
112549: ARRAY
112550: PUSH
112551: LD_INT 3
112553: ARRAY
112554: PPUSH
112555: LD_EXP 184
112559: PUSH
112560: LD_VAR 0 2
112564: ARRAY
112565: PUSH
112566: LD_INT 4
112568: ARRAY
112569: PPUSH
112570: CALL_OW 171
// end else
112574: GO 112615
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112576: LD_VAR 0 1
112580: PPUSH
112581: LD_EXP 184
112585: PUSH
112586: LD_VAR 0 2
112590: ARRAY
112591: PUSH
112592: LD_INT 3
112594: ARRAY
112595: PPUSH
112596: LD_EXP 184
112600: PUSH
112601: LD_VAR 0 2
112605: ARRAY
112606: PUSH
112607: LD_INT 4
112609: ARRAY
112610: PPUSH
112611: CALL_OW 171
// end ; end ;
112615: LD_VAR 0 3
112619: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
112620: LD_INT 0
112622: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
112623: LD_VAR 0 1
112627: PUSH
112628: LD_INT 250
112630: EQUAL
112631: PUSH
112632: LD_VAR 0 2
112636: PPUSH
112637: CALL_OW 264
112641: PUSH
112642: LD_INT 81
112644: EQUAL
112645: AND
112646: IFFALSE 112667
// MinerPlaceMine ( unit , x , y ) ;
112648: LD_VAR 0 2
112652: PPUSH
112653: LD_VAR 0 4
112657: PPUSH
112658: LD_VAR 0 5
112662: PPUSH
112663: CALL 115657 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
112667: LD_VAR 0 1
112671: PUSH
112672: LD_INT 251
112674: EQUAL
112675: PUSH
112676: LD_VAR 0 2
112680: PPUSH
112681: CALL_OW 264
112685: PUSH
112686: LD_INT 81
112688: EQUAL
112689: AND
112690: IFFALSE 112711
// MinerDetonateMine ( unit , x , y ) ;
112692: LD_VAR 0 2
112696: PPUSH
112697: LD_VAR 0 4
112701: PPUSH
112702: LD_VAR 0 5
112706: PPUSH
112707: CALL 115932 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
112711: LD_VAR 0 1
112715: PUSH
112716: LD_INT 252
112718: EQUAL
112719: PUSH
112720: LD_VAR 0 2
112724: PPUSH
112725: CALL_OW 264
112729: PUSH
112730: LD_INT 81
112732: EQUAL
112733: AND
112734: IFFALSE 112755
// MinerCreateMinefield ( unit , x , y ) ;
112736: LD_VAR 0 2
112740: PPUSH
112741: LD_VAR 0 4
112745: PPUSH
112746: LD_VAR 0 5
112750: PPUSH
112751: CALL 116349 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
112755: LD_VAR 0 1
112759: PUSH
112760: LD_INT 253
112762: EQUAL
112763: PUSH
112764: LD_VAR 0 2
112768: PPUSH
112769: CALL_OW 257
112773: PUSH
112774: LD_INT 5
112776: EQUAL
112777: AND
112778: IFFALSE 112799
// ComBinocular ( unit , x , y ) ;
112780: LD_VAR 0 2
112784: PPUSH
112785: LD_VAR 0 4
112789: PPUSH
112790: LD_VAR 0 5
112794: PPUSH
112795: CALL 116718 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
112799: LD_VAR 0 1
112803: PUSH
112804: LD_INT 254
112806: EQUAL
112807: PUSH
112808: LD_VAR 0 2
112812: PPUSH
112813: CALL_OW 264
112817: PUSH
112818: LD_INT 99
112820: EQUAL
112821: AND
112822: PUSH
112823: LD_VAR 0 3
112827: PPUSH
112828: CALL_OW 263
112832: PUSH
112833: LD_INT 3
112835: EQUAL
112836: AND
112837: IFFALSE 112853
// HackDestroyVehicle ( unit , selectedUnit ) ;
112839: LD_VAR 0 2
112843: PPUSH
112844: LD_VAR 0 3
112848: PPUSH
112849: CALL 115021 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112853: LD_VAR 0 1
112857: PUSH
112858: LD_INT 255
112860: EQUAL
112861: PUSH
112862: LD_VAR 0 2
112866: PPUSH
112867: CALL_OW 264
112871: PUSH
112872: LD_INT 14
112874: PUSH
112875: LD_INT 53
112877: PUSH
112878: EMPTY
112879: LIST
112880: LIST
112881: IN
112882: AND
112883: PUSH
112884: LD_VAR 0 4
112888: PPUSH
112889: LD_VAR 0 5
112893: PPUSH
112894: CALL_OW 488
112898: AND
112899: IFFALSE 112923
// CutTreeXYR ( unit , x , y , 12 ) ;
112901: LD_VAR 0 2
112905: PPUSH
112906: LD_VAR 0 4
112910: PPUSH
112911: LD_VAR 0 5
112915: PPUSH
112916: LD_INT 12
112918: PPUSH
112919: CALL 113018 0 4
// if cmd = 256 then
112923: LD_VAR 0 1
112927: PUSH
112928: LD_INT 256
112930: EQUAL
112931: IFFALSE 112952
// SetFactoryWaypoint ( unit , x , y ) ;
112933: LD_VAR 0 2
112937: PPUSH
112938: LD_VAR 0 4
112942: PPUSH
112943: LD_VAR 0 5
112947: PPUSH
112948: CALL 110860 0 3
// if cmd = 257 then
112952: LD_VAR 0 1
112956: PUSH
112957: LD_INT 257
112959: EQUAL
112960: IFFALSE 112981
// SetWarehouseGatheringPoint ( unit , x , y ) ;
112962: LD_VAR 0 2
112966: PPUSH
112967: LD_VAR 0 4
112971: PPUSH
112972: LD_VAR 0 5
112976: PPUSH
112977: CALL 111222 0 3
// if cmd = 258 then
112981: LD_VAR 0 1
112985: PUSH
112986: LD_INT 258
112988: EQUAL
112989: IFFALSE 113013
// BurnTreeXYR ( unit , x , y , 8 ) ;
112991: LD_VAR 0 2
112995: PPUSH
112996: LD_VAR 0 4
113000: PPUSH
113001: LD_VAR 0 5
113005: PPUSH
113006: LD_INT 8
113008: PPUSH
113009: CALL 113412 0 4
// end ;
113013: LD_VAR 0 6
113017: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
113018: LD_INT 0
113020: PPUSH
113021: PPUSH
113022: PPUSH
113023: PPUSH
113024: PPUSH
113025: PPUSH
113026: PPUSH
113027: PPUSH
113028: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
113029: LD_VAR 0 1
113033: PPUSH
113034: CALL_OW 302
113038: NOT
113039: PUSH
113040: LD_VAR 0 2
113044: PPUSH
113045: LD_VAR 0 3
113049: PPUSH
113050: CALL_OW 488
113054: NOT
113055: OR
113056: PUSH
113057: LD_VAR 0 4
113061: NOT
113062: OR
113063: IFFALSE 113067
// exit ;
113065: GO 113407
// list := [ ] ;
113067: LD_ADDR_VAR 0 13
113071: PUSH
113072: EMPTY
113073: ST_TO_ADDR
// if x - r < 0 then
113074: LD_VAR 0 2
113078: PUSH
113079: LD_VAR 0 4
113083: MINUS
113084: PUSH
113085: LD_INT 0
113087: LESS
113088: IFFALSE 113100
// min_x := 0 else
113090: LD_ADDR_VAR 0 7
113094: PUSH
113095: LD_INT 0
113097: ST_TO_ADDR
113098: GO 113116
// min_x := x - r ;
113100: LD_ADDR_VAR 0 7
113104: PUSH
113105: LD_VAR 0 2
113109: PUSH
113110: LD_VAR 0 4
113114: MINUS
113115: ST_TO_ADDR
// if y - r < 0 then
113116: LD_VAR 0 3
113120: PUSH
113121: LD_VAR 0 4
113125: MINUS
113126: PUSH
113127: LD_INT 0
113129: LESS
113130: IFFALSE 113142
// min_y := 0 else
113132: LD_ADDR_VAR 0 8
113136: PUSH
113137: LD_INT 0
113139: ST_TO_ADDR
113140: GO 113158
// min_y := y - r ;
113142: LD_ADDR_VAR 0 8
113146: PUSH
113147: LD_VAR 0 3
113151: PUSH
113152: LD_VAR 0 4
113156: MINUS
113157: ST_TO_ADDR
// max_x := x + r ;
113158: LD_ADDR_VAR 0 9
113162: PUSH
113163: LD_VAR 0 2
113167: PUSH
113168: LD_VAR 0 4
113172: PLUS
113173: ST_TO_ADDR
// max_y := y + r ;
113174: LD_ADDR_VAR 0 10
113178: PUSH
113179: LD_VAR 0 3
113183: PUSH
113184: LD_VAR 0 4
113188: PLUS
113189: ST_TO_ADDR
// for _x = min_x to max_x do
113190: LD_ADDR_VAR 0 11
113194: PUSH
113195: DOUBLE
113196: LD_VAR 0 7
113200: DEC
113201: ST_TO_ADDR
113202: LD_VAR 0 9
113206: PUSH
113207: FOR_TO
113208: IFFALSE 113325
// for _y = min_y to max_y do
113210: LD_ADDR_VAR 0 12
113214: PUSH
113215: DOUBLE
113216: LD_VAR 0 8
113220: DEC
113221: ST_TO_ADDR
113222: LD_VAR 0 10
113226: PUSH
113227: FOR_TO
113228: IFFALSE 113321
// begin if not ValidHex ( _x , _y ) then
113230: LD_VAR 0 11
113234: PPUSH
113235: LD_VAR 0 12
113239: PPUSH
113240: CALL_OW 488
113244: NOT
113245: IFFALSE 113249
// continue ;
113247: GO 113227
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113249: LD_VAR 0 11
113253: PPUSH
113254: LD_VAR 0 12
113258: PPUSH
113259: CALL_OW 351
113263: PUSH
113264: LD_VAR 0 11
113268: PPUSH
113269: LD_VAR 0 12
113273: PPUSH
113274: CALL_OW 554
113278: AND
113279: IFFALSE 113319
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113281: LD_ADDR_VAR 0 13
113285: PUSH
113286: LD_VAR 0 13
113290: PPUSH
113291: LD_VAR 0 13
113295: PUSH
113296: LD_INT 1
113298: PLUS
113299: PPUSH
113300: LD_VAR 0 11
113304: PUSH
113305: LD_VAR 0 12
113309: PUSH
113310: EMPTY
113311: LIST
113312: LIST
113313: PPUSH
113314: CALL_OW 2
113318: ST_TO_ADDR
// end ;
113319: GO 113227
113321: POP
113322: POP
113323: GO 113207
113325: POP
113326: POP
// if not list then
113327: LD_VAR 0 13
113331: NOT
113332: IFFALSE 113336
// exit ;
113334: GO 113407
// for i in list do
113336: LD_ADDR_VAR 0 6
113340: PUSH
113341: LD_VAR 0 13
113345: PUSH
113346: FOR_IN
113347: IFFALSE 113405
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
113349: LD_VAR 0 1
113353: PPUSH
113354: LD_STRING M
113356: PUSH
113357: LD_VAR 0 6
113361: PUSH
113362: LD_INT 1
113364: ARRAY
113365: PUSH
113366: LD_VAR 0 6
113370: PUSH
113371: LD_INT 2
113373: ARRAY
113374: PUSH
113375: LD_INT 0
113377: PUSH
113378: LD_INT 0
113380: PUSH
113381: LD_INT 0
113383: PUSH
113384: LD_INT 0
113386: PUSH
113387: EMPTY
113388: LIST
113389: LIST
113390: LIST
113391: LIST
113392: LIST
113393: LIST
113394: LIST
113395: PUSH
113396: EMPTY
113397: LIST
113398: PPUSH
113399: CALL_OW 447
113403: GO 113346
113405: POP
113406: POP
// end ;
113407: LD_VAR 0 5
113411: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
113412: LD_INT 0
113414: PPUSH
113415: PPUSH
113416: PPUSH
113417: PPUSH
113418: PPUSH
113419: PPUSH
113420: PPUSH
113421: PPUSH
113422: PPUSH
113423: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
113424: LD_VAR 0 1
113428: PPUSH
113429: CALL_OW 302
113433: NOT
113434: PUSH
113435: LD_VAR 0 2
113439: PPUSH
113440: LD_VAR 0 3
113444: PPUSH
113445: CALL_OW 488
113449: NOT
113450: OR
113451: PUSH
113452: LD_VAR 0 4
113456: NOT
113457: OR
113458: IFFALSE 113462
// exit ;
113460: GO 113975
// list := [ ] ;
113462: LD_ADDR_VAR 0 13
113466: PUSH
113467: EMPTY
113468: ST_TO_ADDR
// if x - r < 0 then
113469: LD_VAR 0 2
113473: PUSH
113474: LD_VAR 0 4
113478: MINUS
113479: PUSH
113480: LD_INT 0
113482: LESS
113483: IFFALSE 113495
// min_x := 0 else
113485: LD_ADDR_VAR 0 7
113489: PUSH
113490: LD_INT 0
113492: ST_TO_ADDR
113493: GO 113511
// min_x := x - r ;
113495: LD_ADDR_VAR 0 7
113499: PUSH
113500: LD_VAR 0 2
113504: PUSH
113505: LD_VAR 0 4
113509: MINUS
113510: ST_TO_ADDR
// if y - r < 0 then
113511: LD_VAR 0 3
113515: PUSH
113516: LD_VAR 0 4
113520: MINUS
113521: PUSH
113522: LD_INT 0
113524: LESS
113525: IFFALSE 113537
// min_y := 0 else
113527: LD_ADDR_VAR 0 8
113531: PUSH
113532: LD_INT 0
113534: ST_TO_ADDR
113535: GO 113553
// min_y := y - r ;
113537: LD_ADDR_VAR 0 8
113541: PUSH
113542: LD_VAR 0 3
113546: PUSH
113547: LD_VAR 0 4
113551: MINUS
113552: ST_TO_ADDR
// max_x := x + r ;
113553: LD_ADDR_VAR 0 9
113557: PUSH
113558: LD_VAR 0 2
113562: PUSH
113563: LD_VAR 0 4
113567: PLUS
113568: ST_TO_ADDR
// max_y := y + r ;
113569: LD_ADDR_VAR 0 10
113573: PUSH
113574: LD_VAR 0 3
113578: PUSH
113579: LD_VAR 0 4
113583: PLUS
113584: ST_TO_ADDR
// for _x = min_x to max_x do
113585: LD_ADDR_VAR 0 11
113589: PUSH
113590: DOUBLE
113591: LD_VAR 0 7
113595: DEC
113596: ST_TO_ADDR
113597: LD_VAR 0 9
113601: PUSH
113602: FOR_TO
113603: IFFALSE 113720
// for _y = min_y to max_y do
113605: LD_ADDR_VAR 0 12
113609: PUSH
113610: DOUBLE
113611: LD_VAR 0 8
113615: DEC
113616: ST_TO_ADDR
113617: LD_VAR 0 10
113621: PUSH
113622: FOR_TO
113623: IFFALSE 113716
// begin if not ValidHex ( _x , _y ) then
113625: LD_VAR 0 11
113629: PPUSH
113630: LD_VAR 0 12
113634: PPUSH
113635: CALL_OW 488
113639: NOT
113640: IFFALSE 113644
// continue ;
113642: GO 113622
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113644: LD_VAR 0 11
113648: PPUSH
113649: LD_VAR 0 12
113653: PPUSH
113654: CALL_OW 351
113658: PUSH
113659: LD_VAR 0 11
113663: PPUSH
113664: LD_VAR 0 12
113668: PPUSH
113669: CALL_OW 554
113673: AND
113674: IFFALSE 113714
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113676: LD_ADDR_VAR 0 13
113680: PUSH
113681: LD_VAR 0 13
113685: PPUSH
113686: LD_VAR 0 13
113690: PUSH
113691: LD_INT 1
113693: PLUS
113694: PPUSH
113695: LD_VAR 0 11
113699: PUSH
113700: LD_VAR 0 12
113704: PUSH
113705: EMPTY
113706: LIST
113707: LIST
113708: PPUSH
113709: CALL_OW 2
113713: ST_TO_ADDR
// end ;
113714: GO 113622
113716: POP
113717: POP
113718: GO 113602
113720: POP
113721: POP
// if not list then
113722: LD_VAR 0 13
113726: NOT
113727: IFFALSE 113731
// exit ;
113729: GO 113975
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
113731: LD_ADDR_VAR 0 13
113735: PUSH
113736: LD_VAR 0 1
113740: PPUSH
113741: LD_VAR 0 13
113745: PPUSH
113746: LD_INT 1
113748: PPUSH
113749: LD_INT 1
113751: PPUSH
113752: CALL 59027 0 4
113756: ST_TO_ADDR
// ComStop ( flame ) ;
113757: LD_VAR 0 1
113761: PPUSH
113762: CALL_OW 141
// for i in list do
113766: LD_ADDR_VAR 0 6
113770: PUSH
113771: LD_VAR 0 13
113775: PUSH
113776: FOR_IN
113777: IFFALSE 113808
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
113779: LD_VAR 0 1
113783: PPUSH
113784: LD_VAR 0 6
113788: PUSH
113789: LD_INT 1
113791: ARRAY
113792: PPUSH
113793: LD_VAR 0 6
113797: PUSH
113798: LD_INT 2
113800: ARRAY
113801: PPUSH
113802: CALL_OW 176
113806: GO 113776
113808: POP
113809: POP
// repeat wait ( 0 0$1 ) ;
113810: LD_INT 35
113812: PPUSH
113813: CALL_OW 67
// task := GetTaskList ( flame ) ;
113817: LD_ADDR_VAR 0 14
113821: PUSH
113822: LD_VAR 0 1
113826: PPUSH
113827: CALL_OW 437
113831: ST_TO_ADDR
// if not task then
113832: LD_VAR 0 14
113836: NOT
113837: IFFALSE 113841
// exit ;
113839: GO 113975
// if task [ 1 ] [ 1 ] <> | then
113841: LD_VAR 0 14
113845: PUSH
113846: LD_INT 1
113848: ARRAY
113849: PUSH
113850: LD_INT 1
113852: ARRAY
113853: PUSH
113854: LD_STRING |
113856: NONEQUAL
113857: IFFALSE 113861
// exit ;
113859: GO 113975
// _x := task [ 1 ] [ 2 ] ;
113861: LD_ADDR_VAR 0 11
113865: PUSH
113866: LD_VAR 0 14
113870: PUSH
113871: LD_INT 1
113873: ARRAY
113874: PUSH
113875: LD_INT 2
113877: ARRAY
113878: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
113879: LD_ADDR_VAR 0 12
113883: PUSH
113884: LD_VAR 0 14
113888: PUSH
113889: LD_INT 1
113891: ARRAY
113892: PUSH
113893: LD_INT 3
113895: ARRAY
113896: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
113897: LD_VAR 0 11
113901: PPUSH
113902: LD_VAR 0 12
113906: PPUSH
113907: CALL_OW 351
113911: NOT
113912: PUSH
113913: LD_VAR 0 11
113917: PPUSH
113918: LD_VAR 0 12
113922: PPUSH
113923: CALL_OW 554
113927: NOT
113928: OR
113929: IFFALSE 113963
// begin task := Delete ( task , 1 ) ;
113931: LD_ADDR_VAR 0 14
113935: PUSH
113936: LD_VAR 0 14
113940: PPUSH
113941: LD_INT 1
113943: PPUSH
113944: CALL_OW 3
113948: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
113949: LD_VAR 0 1
113953: PPUSH
113954: LD_VAR 0 14
113958: PPUSH
113959: CALL_OW 446
// end ; until not HasTask ( flame ) ;
113963: LD_VAR 0 1
113967: PPUSH
113968: CALL_OW 314
113972: NOT
113973: IFFALSE 113810
// end ;
113975: LD_VAR 0 5
113979: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
113980: LD_EXP 187
113984: NOT
113985: IFFALSE 114035
113987: GO 113989
113989: DISABLE
// begin initHack := true ;
113990: LD_ADDR_EXP 187
113994: PUSH
113995: LD_INT 1
113997: ST_TO_ADDR
// hackTanks := [ ] ;
113998: LD_ADDR_EXP 188
114002: PUSH
114003: EMPTY
114004: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
114005: LD_ADDR_EXP 189
114009: PUSH
114010: EMPTY
114011: ST_TO_ADDR
// hackLimit := 3 ;
114012: LD_ADDR_EXP 190
114016: PUSH
114017: LD_INT 3
114019: ST_TO_ADDR
// hackDist := 12 ;
114020: LD_ADDR_EXP 191
114024: PUSH
114025: LD_INT 12
114027: ST_TO_ADDR
// hackCounter := [ ] ;
114028: LD_ADDR_EXP 192
114032: PUSH
114033: EMPTY
114034: ST_TO_ADDR
// end ;
114035: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
114036: LD_EXP 187
114040: PUSH
114041: LD_INT 34
114043: PUSH
114044: LD_INT 99
114046: PUSH
114047: EMPTY
114048: LIST
114049: LIST
114050: PPUSH
114051: CALL_OW 69
114055: AND
114056: IFFALSE 114309
114058: GO 114060
114060: DISABLE
114061: LD_INT 0
114063: PPUSH
114064: PPUSH
// begin enable ;
114065: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
114066: LD_ADDR_VAR 0 1
114070: PUSH
114071: LD_INT 34
114073: PUSH
114074: LD_INT 99
114076: PUSH
114077: EMPTY
114078: LIST
114079: LIST
114080: PPUSH
114081: CALL_OW 69
114085: PUSH
114086: FOR_IN
114087: IFFALSE 114307
// begin if not i in hackTanks then
114089: LD_VAR 0 1
114093: PUSH
114094: LD_EXP 188
114098: IN
114099: NOT
114100: IFFALSE 114183
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
114102: LD_ADDR_EXP 188
114106: PUSH
114107: LD_EXP 188
114111: PPUSH
114112: LD_EXP 188
114116: PUSH
114117: LD_INT 1
114119: PLUS
114120: PPUSH
114121: LD_VAR 0 1
114125: PPUSH
114126: CALL_OW 1
114130: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
114131: LD_ADDR_EXP 189
114135: PUSH
114136: LD_EXP 189
114140: PPUSH
114141: LD_EXP 189
114145: PUSH
114146: LD_INT 1
114148: PLUS
114149: PPUSH
114150: EMPTY
114151: PPUSH
114152: CALL_OW 1
114156: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
114157: LD_ADDR_EXP 192
114161: PUSH
114162: LD_EXP 192
114166: PPUSH
114167: LD_EXP 192
114171: PUSH
114172: LD_INT 1
114174: PLUS
114175: PPUSH
114176: EMPTY
114177: PPUSH
114178: CALL_OW 1
114182: ST_TO_ADDR
// end ; if not IsOk ( i ) then
114183: LD_VAR 0 1
114187: PPUSH
114188: CALL_OW 302
114192: NOT
114193: IFFALSE 114206
// begin HackUnlinkAll ( i ) ;
114195: LD_VAR 0 1
114199: PPUSH
114200: CALL 114312 0 1
// continue ;
114204: GO 114086
// end ; HackCheckCapturedStatus ( i ) ;
114206: LD_VAR 0 1
114210: PPUSH
114211: CALL 114755 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
114215: LD_ADDR_VAR 0 2
114219: PUSH
114220: LD_INT 81
114222: PUSH
114223: LD_VAR 0 1
114227: PPUSH
114228: CALL_OW 255
114232: PUSH
114233: EMPTY
114234: LIST
114235: LIST
114236: PUSH
114237: LD_INT 33
114239: PUSH
114240: LD_INT 3
114242: PUSH
114243: EMPTY
114244: LIST
114245: LIST
114246: PUSH
114247: LD_INT 91
114249: PUSH
114250: LD_VAR 0 1
114254: PUSH
114255: LD_EXP 191
114259: PUSH
114260: EMPTY
114261: LIST
114262: LIST
114263: LIST
114264: PUSH
114265: LD_INT 50
114267: PUSH
114268: EMPTY
114269: LIST
114270: PUSH
114271: EMPTY
114272: LIST
114273: LIST
114274: LIST
114275: LIST
114276: PPUSH
114277: CALL_OW 69
114281: ST_TO_ADDR
// if not tmp then
114282: LD_VAR 0 2
114286: NOT
114287: IFFALSE 114291
// continue ;
114289: GO 114086
// HackLink ( i , tmp ) ;
114291: LD_VAR 0 1
114295: PPUSH
114296: LD_VAR 0 2
114300: PPUSH
114301: CALL 114448 0 2
// end ;
114305: GO 114086
114307: POP
114308: POP
// end ;
114309: PPOPN 2
114311: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
114312: LD_INT 0
114314: PPUSH
114315: PPUSH
114316: PPUSH
// if not hack in hackTanks then
114317: LD_VAR 0 1
114321: PUSH
114322: LD_EXP 188
114326: IN
114327: NOT
114328: IFFALSE 114332
// exit ;
114330: GO 114443
// index := GetElementIndex ( hackTanks , hack ) ;
114332: LD_ADDR_VAR 0 4
114336: PUSH
114337: LD_EXP 188
114341: PPUSH
114342: LD_VAR 0 1
114346: PPUSH
114347: CALL 58324 0 2
114351: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
114352: LD_EXP 189
114356: PUSH
114357: LD_VAR 0 4
114361: ARRAY
114362: IFFALSE 114443
// begin for i in hackTanksCaptured [ index ] do
114364: LD_ADDR_VAR 0 3
114368: PUSH
114369: LD_EXP 189
114373: PUSH
114374: LD_VAR 0 4
114378: ARRAY
114379: PUSH
114380: FOR_IN
114381: IFFALSE 114407
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
114383: LD_VAR 0 3
114387: PUSH
114388: LD_INT 1
114390: ARRAY
114391: PPUSH
114392: LD_VAR 0 3
114396: PUSH
114397: LD_INT 2
114399: ARRAY
114400: PPUSH
114401: CALL_OW 235
114405: GO 114380
114407: POP
114408: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
114409: LD_ADDR_EXP 189
114413: PUSH
114414: LD_EXP 189
114418: PPUSH
114419: LD_VAR 0 4
114423: PPUSH
114424: EMPTY
114425: PPUSH
114426: CALL_OW 1
114430: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
114431: LD_VAR 0 1
114435: PPUSH
114436: LD_INT 0
114438: PPUSH
114439: CALL_OW 505
// end ; end ;
114443: LD_VAR 0 2
114447: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
114448: LD_INT 0
114450: PPUSH
114451: PPUSH
114452: PPUSH
// if not hack in hackTanks or not vehicles then
114453: LD_VAR 0 1
114457: PUSH
114458: LD_EXP 188
114462: IN
114463: NOT
114464: PUSH
114465: LD_VAR 0 2
114469: NOT
114470: OR
114471: IFFALSE 114475
// exit ;
114473: GO 114750
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
114475: LD_ADDR_VAR 0 2
114479: PUSH
114480: LD_VAR 0 1
114484: PPUSH
114485: LD_VAR 0 2
114489: PPUSH
114490: LD_INT 1
114492: PPUSH
114493: LD_INT 1
114495: PPUSH
114496: CALL 58974 0 4
114500: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
114501: LD_ADDR_VAR 0 5
114505: PUSH
114506: LD_EXP 188
114510: PPUSH
114511: LD_VAR 0 1
114515: PPUSH
114516: CALL 58324 0 2
114520: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
114521: LD_EXP 189
114525: PUSH
114526: LD_VAR 0 5
114530: ARRAY
114531: PUSH
114532: LD_EXP 190
114536: LESS
114537: IFFALSE 114726
// begin for i := 1 to vehicles do
114539: LD_ADDR_VAR 0 4
114543: PUSH
114544: DOUBLE
114545: LD_INT 1
114547: DEC
114548: ST_TO_ADDR
114549: LD_VAR 0 2
114553: PUSH
114554: FOR_TO
114555: IFFALSE 114724
// begin if hackTanksCaptured [ index ] = hackLimit then
114557: LD_EXP 189
114561: PUSH
114562: LD_VAR 0 5
114566: ARRAY
114567: PUSH
114568: LD_EXP 190
114572: EQUAL
114573: IFFALSE 114577
// break ;
114575: GO 114724
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
114577: LD_ADDR_EXP 192
114581: PUSH
114582: LD_EXP 192
114586: PPUSH
114587: LD_VAR 0 5
114591: PPUSH
114592: LD_EXP 192
114596: PUSH
114597: LD_VAR 0 5
114601: ARRAY
114602: PUSH
114603: LD_INT 1
114605: PLUS
114606: PPUSH
114607: CALL_OW 1
114611: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
114612: LD_ADDR_EXP 189
114616: PUSH
114617: LD_EXP 189
114621: PPUSH
114622: LD_VAR 0 5
114626: PUSH
114627: LD_EXP 189
114631: PUSH
114632: LD_VAR 0 5
114636: ARRAY
114637: PUSH
114638: LD_INT 1
114640: PLUS
114641: PUSH
114642: EMPTY
114643: LIST
114644: LIST
114645: PPUSH
114646: LD_VAR 0 2
114650: PUSH
114651: LD_VAR 0 4
114655: ARRAY
114656: PUSH
114657: LD_VAR 0 2
114661: PUSH
114662: LD_VAR 0 4
114666: ARRAY
114667: PPUSH
114668: CALL_OW 255
114672: PUSH
114673: EMPTY
114674: LIST
114675: LIST
114676: PPUSH
114677: CALL 58539 0 3
114681: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
114682: LD_VAR 0 2
114686: PUSH
114687: LD_VAR 0 4
114691: ARRAY
114692: PPUSH
114693: LD_VAR 0 1
114697: PPUSH
114698: CALL_OW 255
114702: PPUSH
114703: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
114707: LD_VAR 0 2
114711: PUSH
114712: LD_VAR 0 4
114716: ARRAY
114717: PPUSH
114718: CALL_OW 141
// end ;
114722: GO 114554
114724: POP
114725: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114726: LD_VAR 0 1
114730: PPUSH
114731: LD_EXP 189
114735: PUSH
114736: LD_VAR 0 5
114740: ARRAY
114741: PUSH
114742: LD_INT 0
114744: PLUS
114745: PPUSH
114746: CALL_OW 505
// end ;
114750: LD_VAR 0 3
114754: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
114755: LD_INT 0
114757: PPUSH
114758: PPUSH
114759: PPUSH
114760: PPUSH
// if not hack in hackTanks then
114761: LD_VAR 0 1
114765: PUSH
114766: LD_EXP 188
114770: IN
114771: NOT
114772: IFFALSE 114776
// exit ;
114774: GO 115016
// index := GetElementIndex ( hackTanks , hack ) ;
114776: LD_ADDR_VAR 0 4
114780: PUSH
114781: LD_EXP 188
114785: PPUSH
114786: LD_VAR 0 1
114790: PPUSH
114791: CALL 58324 0 2
114795: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
114796: LD_ADDR_VAR 0 3
114800: PUSH
114801: DOUBLE
114802: LD_EXP 189
114806: PUSH
114807: LD_VAR 0 4
114811: ARRAY
114812: INC
114813: ST_TO_ADDR
114814: LD_INT 1
114816: PUSH
114817: FOR_DOWNTO
114818: IFFALSE 114990
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
114820: LD_ADDR_VAR 0 5
114824: PUSH
114825: LD_EXP 189
114829: PUSH
114830: LD_VAR 0 4
114834: ARRAY
114835: PUSH
114836: LD_VAR 0 3
114840: ARRAY
114841: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
114842: LD_VAR 0 5
114846: PUSH
114847: LD_INT 1
114849: ARRAY
114850: PPUSH
114851: CALL_OW 302
114855: NOT
114856: PUSH
114857: LD_VAR 0 5
114861: PUSH
114862: LD_INT 1
114864: ARRAY
114865: PPUSH
114866: CALL_OW 255
114870: PUSH
114871: LD_VAR 0 1
114875: PPUSH
114876: CALL_OW 255
114880: NONEQUAL
114881: OR
114882: IFFALSE 114988
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
114884: LD_VAR 0 5
114888: PUSH
114889: LD_INT 1
114891: ARRAY
114892: PPUSH
114893: CALL_OW 305
114897: PUSH
114898: LD_VAR 0 5
114902: PUSH
114903: LD_INT 1
114905: ARRAY
114906: PPUSH
114907: CALL_OW 255
114911: PUSH
114912: LD_VAR 0 1
114916: PPUSH
114917: CALL_OW 255
114921: EQUAL
114922: AND
114923: IFFALSE 114947
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
114925: LD_VAR 0 5
114929: PUSH
114930: LD_INT 1
114932: ARRAY
114933: PPUSH
114934: LD_VAR 0 5
114938: PUSH
114939: LD_INT 2
114941: ARRAY
114942: PPUSH
114943: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
114947: LD_ADDR_EXP 189
114951: PUSH
114952: LD_EXP 189
114956: PPUSH
114957: LD_VAR 0 4
114961: PPUSH
114962: LD_EXP 189
114966: PUSH
114967: LD_VAR 0 4
114971: ARRAY
114972: PPUSH
114973: LD_VAR 0 3
114977: PPUSH
114978: CALL_OW 3
114982: PPUSH
114983: CALL_OW 1
114987: ST_TO_ADDR
// end ; end ;
114988: GO 114817
114990: POP
114991: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114992: LD_VAR 0 1
114996: PPUSH
114997: LD_EXP 189
115001: PUSH
115002: LD_VAR 0 4
115006: ARRAY
115007: PUSH
115008: LD_INT 0
115010: PLUS
115011: PPUSH
115012: CALL_OW 505
// end ;
115016: LD_VAR 0 2
115020: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
115021: LD_INT 0
115023: PPUSH
115024: PPUSH
115025: PPUSH
115026: PPUSH
// if not hack in hackTanks then
115027: LD_VAR 0 1
115031: PUSH
115032: LD_EXP 188
115036: IN
115037: NOT
115038: IFFALSE 115042
// exit ;
115040: GO 115127
// index := GetElementIndex ( hackTanks , hack ) ;
115042: LD_ADDR_VAR 0 5
115046: PUSH
115047: LD_EXP 188
115051: PPUSH
115052: LD_VAR 0 1
115056: PPUSH
115057: CALL 58324 0 2
115061: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
115062: LD_ADDR_VAR 0 4
115066: PUSH
115067: DOUBLE
115068: LD_INT 1
115070: DEC
115071: ST_TO_ADDR
115072: LD_EXP 189
115076: PUSH
115077: LD_VAR 0 5
115081: ARRAY
115082: PUSH
115083: FOR_TO
115084: IFFALSE 115125
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
115086: LD_EXP 189
115090: PUSH
115091: LD_VAR 0 5
115095: ARRAY
115096: PUSH
115097: LD_VAR 0 4
115101: ARRAY
115102: PUSH
115103: LD_INT 1
115105: ARRAY
115106: PUSH
115107: LD_VAR 0 2
115111: EQUAL
115112: IFFALSE 115123
// KillUnit ( vehicle ) ;
115114: LD_VAR 0 2
115118: PPUSH
115119: CALL_OW 66
115123: GO 115083
115125: POP
115126: POP
// end ;
115127: LD_VAR 0 3
115131: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
115132: LD_EXP 193
115136: NOT
115137: IFFALSE 115172
115139: GO 115141
115141: DISABLE
// begin initMiner := true ;
115142: LD_ADDR_EXP 193
115146: PUSH
115147: LD_INT 1
115149: ST_TO_ADDR
// minersList := [ ] ;
115150: LD_ADDR_EXP 194
115154: PUSH
115155: EMPTY
115156: ST_TO_ADDR
// minerMinesList := [ ] ;
115157: LD_ADDR_EXP 195
115161: PUSH
115162: EMPTY
115163: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
115164: LD_ADDR_EXP 196
115168: PUSH
115169: LD_INT 5
115171: ST_TO_ADDR
// end ;
115172: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
115173: LD_EXP 193
115177: PUSH
115178: LD_INT 34
115180: PUSH
115181: LD_INT 81
115183: PUSH
115184: EMPTY
115185: LIST
115186: LIST
115187: PPUSH
115188: CALL_OW 69
115192: AND
115193: IFFALSE 115654
115195: GO 115197
115197: DISABLE
115198: LD_INT 0
115200: PPUSH
115201: PPUSH
115202: PPUSH
115203: PPUSH
// begin enable ;
115204: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
115205: LD_ADDR_VAR 0 1
115209: PUSH
115210: LD_INT 34
115212: PUSH
115213: LD_INT 81
115215: PUSH
115216: EMPTY
115217: LIST
115218: LIST
115219: PPUSH
115220: CALL_OW 69
115224: PUSH
115225: FOR_IN
115226: IFFALSE 115298
// begin if not i in minersList then
115228: LD_VAR 0 1
115232: PUSH
115233: LD_EXP 194
115237: IN
115238: NOT
115239: IFFALSE 115296
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
115241: LD_ADDR_EXP 194
115245: PUSH
115246: LD_EXP 194
115250: PPUSH
115251: LD_EXP 194
115255: PUSH
115256: LD_INT 1
115258: PLUS
115259: PPUSH
115260: LD_VAR 0 1
115264: PPUSH
115265: CALL_OW 1
115269: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
115270: LD_ADDR_EXP 195
115274: PUSH
115275: LD_EXP 195
115279: PPUSH
115280: LD_EXP 195
115284: PUSH
115285: LD_INT 1
115287: PLUS
115288: PPUSH
115289: EMPTY
115290: PPUSH
115291: CALL_OW 1
115295: ST_TO_ADDR
// end end ;
115296: GO 115225
115298: POP
115299: POP
// for i := minerMinesList downto 1 do
115300: LD_ADDR_VAR 0 1
115304: PUSH
115305: DOUBLE
115306: LD_EXP 195
115310: INC
115311: ST_TO_ADDR
115312: LD_INT 1
115314: PUSH
115315: FOR_DOWNTO
115316: IFFALSE 115652
// begin if IsLive ( minersList [ i ] ) then
115318: LD_EXP 194
115322: PUSH
115323: LD_VAR 0 1
115327: ARRAY
115328: PPUSH
115329: CALL_OW 300
115333: IFFALSE 115361
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
115335: LD_EXP 194
115339: PUSH
115340: LD_VAR 0 1
115344: ARRAY
115345: PPUSH
115346: LD_EXP 195
115350: PUSH
115351: LD_VAR 0 1
115355: ARRAY
115356: PPUSH
115357: CALL_OW 505
// if not minerMinesList [ i ] then
115361: LD_EXP 195
115365: PUSH
115366: LD_VAR 0 1
115370: ARRAY
115371: NOT
115372: IFFALSE 115376
// continue ;
115374: GO 115315
// for j := minerMinesList [ i ] downto 1 do
115376: LD_ADDR_VAR 0 2
115380: PUSH
115381: DOUBLE
115382: LD_EXP 195
115386: PUSH
115387: LD_VAR 0 1
115391: ARRAY
115392: INC
115393: ST_TO_ADDR
115394: LD_INT 1
115396: PUSH
115397: FOR_DOWNTO
115398: IFFALSE 115648
// begin side := GetSide ( minersList [ i ] ) ;
115400: LD_ADDR_VAR 0 3
115404: PUSH
115405: LD_EXP 194
115409: PUSH
115410: LD_VAR 0 1
115414: ARRAY
115415: PPUSH
115416: CALL_OW 255
115420: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
115421: LD_ADDR_VAR 0 4
115425: PUSH
115426: LD_EXP 195
115430: PUSH
115431: LD_VAR 0 1
115435: ARRAY
115436: PUSH
115437: LD_VAR 0 2
115441: ARRAY
115442: PUSH
115443: LD_INT 1
115445: ARRAY
115446: PPUSH
115447: LD_EXP 195
115451: PUSH
115452: LD_VAR 0 1
115456: ARRAY
115457: PUSH
115458: LD_VAR 0 2
115462: ARRAY
115463: PUSH
115464: LD_INT 2
115466: ARRAY
115467: PPUSH
115468: CALL_OW 428
115472: ST_TO_ADDR
// if not tmp then
115473: LD_VAR 0 4
115477: NOT
115478: IFFALSE 115482
// continue ;
115480: GO 115397
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
115482: LD_VAR 0 4
115486: PUSH
115487: LD_INT 81
115489: PUSH
115490: LD_VAR 0 3
115494: PUSH
115495: EMPTY
115496: LIST
115497: LIST
115498: PPUSH
115499: CALL_OW 69
115503: IN
115504: PUSH
115505: LD_EXP 195
115509: PUSH
115510: LD_VAR 0 1
115514: ARRAY
115515: PUSH
115516: LD_VAR 0 2
115520: ARRAY
115521: PUSH
115522: LD_INT 1
115524: ARRAY
115525: PPUSH
115526: LD_EXP 195
115530: PUSH
115531: LD_VAR 0 1
115535: ARRAY
115536: PUSH
115537: LD_VAR 0 2
115541: ARRAY
115542: PUSH
115543: LD_INT 2
115545: ARRAY
115546: PPUSH
115547: CALL_OW 458
115551: AND
115552: IFFALSE 115646
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
115554: LD_EXP 195
115558: PUSH
115559: LD_VAR 0 1
115563: ARRAY
115564: PUSH
115565: LD_VAR 0 2
115569: ARRAY
115570: PUSH
115571: LD_INT 1
115573: ARRAY
115574: PPUSH
115575: LD_EXP 195
115579: PUSH
115580: LD_VAR 0 1
115584: ARRAY
115585: PUSH
115586: LD_VAR 0 2
115590: ARRAY
115591: PUSH
115592: LD_INT 2
115594: ARRAY
115595: PPUSH
115596: LD_VAR 0 3
115600: PPUSH
115601: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
115605: LD_ADDR_EXP 195
115609: PUSH
115610: LD_EXP 195
115614: PPUSH
115615: LD_VAR 0 1
115619: PPUSH
115620: LD_EXP 195
115624: PUSH
115625: LD_VAR 0 1
115629: ARRAY
115630: PPUSH
115631: LD_VAR 0 2
115635: PPUSH
115636: CALL_OW 3
115640: PPUSH
115641: CALL_OW 1
115645: ST_TO_ADDR
// end ; end ;
115646: GO 115397
115648: POP
115649: POP
// end ;
115650: GO 115315
115652: POP
115653: POP
// end ;
115654: PPOPN 4
115656: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
115657: LD_INT 0
115659: PPUSH
115660: PPUSH
// result := false ;
115661: LD_ADDR_VAR 0 4
115665: PUSH
115666: LD_INT 0
115668: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
115669: LD_VAR 0 1
115673: PPUSH
115674: CALL_OW 264
115678: PUSH
115679: LD_INT 81
115681: EQUAL
115682: NOT
115683: IFFALSE 115687
// exit ;
115685: GO 115927
// index := GetElementIndex ( minersList , unit ) ;
115687: LD_ADDR_VAR 0 5
115691: PUSH
115692: LD_EXP 194
115696: PPUSH
115697: LD_VAR 0 1
115701: PPUSH
115702: CALL 58324 0 2
115706: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
115707: LD_EXP 195
115711: PUSH
115712: LD_VAR 0 5
115716: ARRAY
115717: PUSH
115718: LD_EXP 196
115722: GREATEREQUAL
115723: IFFALSE 115727
// exit ;
115725: GO 115927
// ComMoveXY ( unit , x , y ) ;
115727: LD_VAR 0 1
115731: PPUSH
115732: LD_VAR 0 2
115736: PPUSH
115737: LD_VAR 0 3
115741: PPUSH
115742: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115746: LD_INT 35
115748: PPUSH
115749: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
115753: LD_VAR 0 1
115757: PPUSH
115758: LD_VAR 0 2
115762: PPUSH
115763: LD_VAR 0 3
115767: PPUSH
115768: CALL 90065 0 3
115772: NOT
115773: PUSH
115774: LD_VAR 0 1
115778: PPUSH
115779: CALL_OW 314
115783: AND
115784: IFFALSE 115788
// exit ;
115786: GO 115927
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
115788: LD_VAR 0 2
115792: PPUSH
115793: LD_VAR 0 3
115797: PPUSH
115798: CALL_OW 428
115802: PUSH
115803: LD_VAR 0 1
115807: EQUAL
115808: PUSH
115809: LD_VAR 0 1
115813: PPUSH
115814: CALL_OW 314
115818: NOT
115819: AND
115820: IFFALSE 115746
// PlaySoundXY ( x , y , PlantMine ) ;
115822: LD_VAR 0 2
115826: PPUSH
115827: LD_VAR 0 3
115831: PPUSH
115832: LD_STRING PlantMine
115834: PPUSH
115835: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
115839: LD_VAR 0 2
115843: PPUSH
115844: LD_VAR 0 3
115848: PPUSH
115849: LD_VAR 0 1
115853: PPUSH
115854: CALL_OW 255
115858: PPUSH
115859: LD_INT 0
115861: PPUSH
115862: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
115866: LD_ADDR_EXP 195
115870: PUSH
115871: LD_EXP 195
115875: PPUSH
115876: LD_VAR 0 5
115880: PUSH
115881: LD_EXP 195
115885: PUSH
115886: LD_VAR 0 5
115890: ARRAY
115891: PUSH
115892: LD_INT 1
115894: PLUS
115895: PUSH
115896: EMPTY
115897: LIST
115898: LIST
115899: PPUSH
115900: LD_VAR 0 2
115904: PUSH
115905: LD_VAR 0 3
115909: PUSH
115910: EMPTY
115911: LIST
115912: LIST
115913: PPUSH
115914: CALL 58539 0 3
115918: ST_TO_ADDR
// result := true ;
115919: LD_ADDR_VAR 0 4
115923: PUSH
115924: LD_INT 1
115926: ST_TO_ADDR
// end ;
115927: LD_VAR 0 4
115931: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
115932: LD_INT 0
115934: PPUSH
115935: PPUSH
115936: PPUSH
// if not unit in minersList then
115937: LD_VAR 0 1
115941: PUSH
115942: LD_EXP 194
115946: IN
115947: NOT
115948: IFFALSE 115952
// exit ;
115950: GO 116344
// index := GetElementIndex ( minersList , unit ) ;
115952: LD_ADDR_VAR 0 6
115956: PUSH
115957: LD_EXP 194
115961: PPUSH
115962: LD_VAR 0 1
115966: PPUSH
115967: CALL 58324 0 2
115971: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
115972: LD_ADDR_VAR 0 5
115976: PUSH
115977: DOUBLE
115978: LD_EXP 195
115982: PUSH
115983: LD_VAR 0 6
115987: ARRAY
115988: INC
115989: ST_TO_ADDR
115990: LD_INT 1
115992: PUSH
115993: FOR_DOWNTO
115994: IFFALSE 116155
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
115996: LD_EXP 195
116000: PUSH
116001: LD_VAR 0 6
116005: ARRAY
116006: PUSH
116007: LD_VAR 0 5
116011: ARRAY
116012: PUSH
116013: LD_INT 1
116015: ARRAY
116016: PUSH
116017: LD_VAR 0 2
116021: EQUAL
116022: PUSH
116023: LD_EXP 195
116027: PUSH
116028: LD_VAR 0 6
116032: ARRAY
116033: PUSH
116034: LD_VAR 0 5
116038: ARRAY
116039: PUSH
116040: LD_INT 2
116042: ARRAY
116043: PUSH
116044: LD_VAR 0 3
116048: EQUAL
116049: AND
116050: IFFALSE 116153
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116052: LD_EXP 195
116056: PUSH
116057: LD_VAR 0 6
116061: ARRAY
116062: PUSH
116063: LD_VAR 0 5
116067: ARRAY
116068: PUSH
116069: LD_INT 1
116071: ARRAY
116072: PPUSH
116073: LD_EXP 195
116077: PUSH
116078: LD_VAR 0 6
116082: ARRAY
116083: PUSH
116084: LD_VAR 0 5
116088: ARRAY
116089: PUSH
116090: LD_INT 2
116092: ARRAY
116093: PPUSH
116094: LD_VAR 0 1
116098: PPUSH
116099: CALL_OW 255
116103: PPUSH
116104: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116108: LD_ADDR_EXP 195
116112: PUSH
116113: LD_EXP 195
116117: PPUSH
116118: LD_VAR 0 6
116122: PPUSH
116123: LD_EXP 195
116127: PUSH
116128: LD_VAR 0 6
116132: ARRAY
116133: PPUSH
116134: LD_VAR 0 5
116138: PPUSH
116139: CALL_OW 3
116143: PPUSH
116144: CALL_OW 1
116148: ST_TO_ADDR
// exit ;
116149: POP
116150: POP
116151: GO 116344
// end ; end ;
116153: GO 115993
116155: POP
116156: POP
// for i := minerMinesList [ index ] downto 1 do
116157: LD_ADDR_VAR 0 5
116161: PUSH
116162: DOUBLE
116163: LD_EXP 195
116167: PUSH
116168: LD_VAR 0 6
116172: ARRAY
116173: INC
116174: ST_TO_ADDR
116175: LD_INT 1
116177: PUSH
116178: FOR_DOWNTO
116179: IFFALSE 116342
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
116181: LD_EXP 195
116185: PUSH
116186: LD_VAR 0 6
116190: ARRAY
116191: PUSH
116192: LD_VAR 0 5
116196: ARRAY
116197: PUSH
116198: LD_INT 1
116200: ARRAY
116201: PPUSH
116202: LD_EXP 195
116206: PUSH
116207: LD_VAR 0 6
116211: ARRAY
116212: PUSH
116213: LD_VAR 0 5
116217: ARRAY
116218: PUSH
116219: LD_INT 2
116221: ARRAY
116222: PPUSH
116223: LD_VAR 0 2
116227: PPUSH
116228: LD_VAR 0 3
116232: PPUSH
116233: CALL_OW 298
116237: PUSH
116238: LD_INT 6
116240: LESS
116241: IFFALSE 116340
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116243: LD_EXP 195
116247: PUSH
116248: LD_VAR 0 6
116252: ARRAY
116253: PUSH
116254: LD_VAR 0 5
116258: ARRAY
116259: PUSH
116260: LD_INT 1
116262: ARRAY
116263: PPUSH
116264: LD_EXP 195
116268: PUSH
116269: LD_VAR 0 6
116273: ARRAY
116274: PUSH
116275: LD_VAR 0 5
116279: ARRAY
116280: PUSH
116281: LD_INT 2
116283: ARRAY
116284: PPUSH
116285: LD_VAR 0 1
116289: PPUSH
116290: CALL_OW 255
116294: PPUSH
116295: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116299: LD_ADDR_EXP 195
116303: PUSH
116304: LD_EXP 195
116308: PPUSH
116309: LD_VAR 0 6
116313: PPUSH
116314: LD_EXP 195
116318: PUSH
116319: LD_VAR 0 6
116323: ARRAY
116324: PPUSH
116325: LD_VAR 0 5
116329: PPUSH
116330: CALL_OW 3
116334: PPUSH
116335: CALL_OW 1
116339: ST_TO_ADDR
// end ; end ;
116340: GO 116178
116342: POP
116343: POP
// end ;
116344: LD_VAR 0 4
116348: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
116349: LD_INT 0
116351: PPUSH
116352: PPUSH
116353: PPUSH
116354: PPUSH
116355: PPUSH
116356: PPUSH
116357: PPUSH
116358: PPUSH
116359: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
116360: LD_VAR 0 1
116364: PPUSH
116365: CALL_OW 264
116369: PUSH
116370: LD_INT 81
116372: EQUAL
116373: NOT
116374: PUSH
116375: LD_VAR 0 1
116379: PUSH
116380: LD_EXP 194
116384: IN
116385: NOT
116386: OR
116387: IFFALSE 116391
// exit ;
116389: GO 116713
// index := GetElementIndex ( minersList , unit ) ;
116391: LD_ADDR_VAR 0 6
116395: PUSH
116396: LD_EXP 194
116400: PPUSH
116401: LD_VAR 0 1
116405: PPUSH
116406: CALL 58324 0 2
116410: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
116411: LD_ADDR_VAR 0 8
116415: PUSH
116416: LD_EXP 196
116420: PUSH
116421: LD_EXP 195
116425: PUSH
116426: LD_VAR 0 6
116430: ARRAY
116431: MINUS
116432: ST_TO_ADDR
// if not minesFreeAmount then
116433: LD_VAR 0 8
116437: NOT
116438: IFFALSE 116442
// exit ;
116440: GO 116713
// tmp := [ ] ;
116442: LD_ADDR_VAR 0 7
116446: PUSH
116447: EMPTY
116448: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
116449: LD_ADDR_VAR 0 5
116453: PUSH
116454: DOUBLE
116455: LD_INT 1
116457: DEC
116458: ST_TO_ADDR
116459: LD_VAR 0 8
116463: PUSH
116464: FOR_TO
116465: IFFALSE 116660
// begin _d := rand ( 0 , 5 ) ;
116467: LD_ADDR_VAR 0 11
116471: PUSH
116472: LD_INT 0
116474: PPUSH
116475: LD_INT 5
116477: PPUSH
116478: CALL_OW 12
116482: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
116483: LD_ADDR_VAR 0 12
116487: PUSH
116488: LD_INT 2
116490: PPUSH
116491: LD_INT 6
116493: PPUSH
116494: CALL_OW 12
116498: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
116499: LD_ADDR_VAR 0 9
116503: PUSH
116504: LD_VAR 0 2
116508: PPUSH
116509: LD_VAR 0 11
116513: PPUSH
116514: LD_VAR 0 12
116518: PPUSH
116519: CALL_OW 272
116523: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
116524: LD_ADDR_VAR 0 10
116528: PUSH
116529: LD_VAR 0 3
116533: PPUSH
116534: LD_VAR 0 11
116538: PPUSH
116539: LD_VAR 0 12
116543: PPUSH
116544: CALL_OW 273
116548: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
116549: LD_VAR 0 9
116553: PPUSH
116554: LD_VAR 0 10
116558: PPUSH
116559: CALL_OW 488
116563: PUSH
116564: LD_VAR 0 9
116568: PUSH
116569: LD_VAR 0 10
116573: PUSH
116574: EMPTY
116575: LIST
116576: LIST
116577: PUSH
116578: LD_VAR 0 7
116582: IN
116583: NOT
116584: AND
116585: PUSH
116586: LD_VAR 0 9
116590: PPUSH
116591: LD_VAR 0 10
116595: PPUSH
116596: CALL_OW 458
116600: NOT
116601: AND
116602: IFFALSE 116644
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
116604: LD_ADDR_VAR 0 7
116608: PUSH
116609: LD_VAR 0 7
116613: PPUSH
116614: LD_VAR 0 7
116618: PUSH
116619: LD_INT 1
116621: PLUS
116622: PPUSH
116623: LD_VAR 0 9
116627: PUSH
116628: LD_VAR 0 10
116632: PUSH
116633: EMPTY
116634: LIST
116635: LIST
116636: PPUSH
116637: CALL_OW 1
116641: ST_TO_ADDR
116642: GO 116658
// i := i - 1 ;
116644: LD_ADDR_VAR 0 5
116648: PUSH
116649: LD_VAR 0 5
116653: PUSH
116654: LD_INT 1
116656: MINUS
116657: ST_TO_ADDR
// end ;
116658: GO 116464
116660: POP
116661: POP
// for i in tmp do
116662: LD_ADDR_VAR 0 5
116666: PUSH
116667: LD_VAR 0 7
116671: PUSH
116672: FOR_IN
116673: IFFALSE 116711
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
116675: LD_VAR 0 1
116679: PPUSH
116680: LD_VAR 0 5
116684: PUSH
116685: LD_INT 1
116687: ARRAY
116688: PPUSH
116689: LD_VAR 0 5
116693: PUSH
116694: LD_INT 2
116696: ARRAY
116697: PPUSH
116698: CALL 115657 0 3
116702: NOT
116703: IFFALSE 116709
// exit ;
116705: POP
116706: POP
116707: GO 116713
116709: GO 116672
116711: POP
116712: POP
// end ;
116713: LD_VAR 0 4
116717: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
116718: LD_INT 0
116720: PPUSH
116721: PPUSH
116722: PPUSH
116723: PPUSH
116724: PPUSH
116725: PPUSH
116726: PPUSH
// if not GetClass ( unit ) = class_sniper then
116727: LD_VAR 0 1
116731: PPUSH
116732: CALL_OW 257
116736: PUSH
116737: LD_INT 5
116739: EQUAL
116740: NOT
116741: IFFALSE 116745
// exit ;
116743: GO 117133
// dist := 8 ;
116745: LD_ADDR_VAR 0 5
116749: PUSH
116750: LD_INT 8
116752: ST_TO_ADDR
// viewRange := 12 ;
116753: LD_ADDR_VAR 0 7
116757: PUSH
116758: LD_INT 12
116760: ST_TO_ADDR
// side := GetSide ( unit ) ;
116761: LD_ADDR_VAR 0 6
116765: PUSH
116766: LD_VAR 0 1
116770: PPUSH
116771: CALL_OW 255
116775: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
116776: LD_INT 61
116778: PPUSH
116779: LD_VAR 0 6
116783: PPUSH
116784: CALL_OW 321
116788: PUSH
116789: LD_INT 2
116791: EQUAL
116792: IFFALSE 116802
// viewRange := 16 ;
116794: LD_ADDR_VAR 0 7
116798: PUSH
116799: LD_INT 16
116801: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
116802: LD_VAR 0 1
116806: PPUSH
116807: LD_VAR 0 2
116811: PPUSH
116812: LD_VAR 0 3
116816: PPUSH
116817: CALL_OW 297
116821: PUSH
116822: LD_VAR 0 5
116826: GREATER
116827: IFFALSE 116906
// begin ComMoveXY ( unit , x , y ) ;
116829: LD_VAR 0 1
116833: PPUSH
116834: LD_VAR 0 2
116838: PPUSH
116839: LD_VAR 0 3
116843: PPUSH
116844: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
116848: LD_INT 35
116850: PPUSH
116851: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
116855: LD_VAR 0 1
116859: PPUSH
116860: LD_VAR 0 2
116864: PPUSH
116865: LD_VAR 0 3
116869: PPUSH
116870: CALL 90065 0 3
116874: NOT
116875: IFFALSE 116879
// exit ;
116877: GO 117133
// until GetDistUnitXY ( unit , x , y ) < dist ;
116879: LD_VAR 0 1
116883: PPUSH
116884: LD_VAR 0 2
116888: PPUSH
116889: LD_VAR 0 3
116893: PPUSH
116894: CALL_OW 297
116898: PUSH
116899: LD_VAR 0 5
116903: LESS
116904: IFFALSE 116848
// end ; ComTurnXY ( unit , x , y ) ;
116906: LD_VAR 0 1
116910: PPUSH
116911: LD_VAR 0 2
116915: PPUSH
116916: LD_VAR 0 3
116920: PPUSH
116921: CALL_OW 118
// wait ( 5 ) ;
116925: LD_INT 5
116927: PPUSH
116928: CALL_OW 67
// _d := GetDir ( unit ) ;
116932: LD_ADDR_VAR 0 10
116936: PUSH
116937: LD_VAR 0 1
116941: PPUSH
116942: CALL_OW 254
116946: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
116947: LD_ADDR_VAR 0 8
116951: PUSH
116952: LD_VAR 0 1
116956: PPUSH
116957: CALL_OW 250
116961: PPUSH
116962: LD_VAR 0 10
116966: PPUSH
116967: LD_VAR 0 5
116971: PPUSH
116972: CALL_OW 272
116976: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
116977: LD_ADDR_VAR 0 9
116981: PUSH
116982: LD_VAR 0 1
116986: PPUSH
116987: CALL_OW 251
116991: PPUSH
116992: LD_VAR 0 10
116996: PPUSH
116997: LD_VAR 0 5
117001: PPUSH
117002: CALL_OW 273
117006: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
117007: LD_VAR 0 8
117011: PPUSH
117012: LD_VAR 0 9
117016: PPUSH
117017: CALL_OW 488
117021: NOT
117022: IFFALSE 117026
// exit ;
117024: GO 117133
// ComAnimCustom ( unit , 1 ) ;
117026: LD_VAR 0 1
117030: PPUSH
117031: LD_INT 1
117033: PPUSH
117034: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
117038: LD_VAR 0 8
117042: PPUSH
117043: LD_VAR 0 9
117047: PPUSH
117048: LD_VAR 0 6
117052: PPUSH
117053: LD_VAR 0 7
117057: PPUSH
117058: CALL_OW 330
// repeat wait ( 1 ) ;
117062: LD_INT 1
117064: PPUSH
117065: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
117069: LD_VAR 0 1
117073: PPUSH
117074: CALL_OW 316
117078: PUSH
117079: LD_VAR 0 1
117083: PPUSH
117084: CALL_OW 314
117088: OR
117089: PUSH
117090: LD_VAR 0 1
117094: PPUSH
117095: CALL_OW 302
117099: NOT
117100: OR
117101: PUSH
117102: LD_VAR 0 1
117106: PPUSH
117107: CALL_OW 301
117111: OR
117112: IFFALSE 117062
// RemoveSeeing ( _x , _y , side ) ;
117114: LD_VAR 0 8
117118: PPUSH
117119: LD_VAR 0 9
117123: PPUSH
117124: LD_VAR 0 6
117128: PPUSH
117129: CALL_OW 331
// end ; end_of_file
117133: LD_VAR 0 4
117137: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
117138: LD_INT 0
117140: PPUSH
117141: PPUSH
117142: PPUSH
117143: PPUSH
117144: PPUSH
117145: PPUSH
117146: PPUSH
117147: PPUSH
117148: PPUSH
117149: PPUSH
117150: PPUSH
117151: PPUSH
117152: PPUSH
117153: PPUSH
117154: PPUSH
117155: PPUSH
117156: PPUSH
117157: PPUSH
117158: PPUSH
117159: PPUSH
117160: PPUSH
117161: PPUSH
117162: PPUSH
117163: PPUSH
117164: PPUSH
117165: PPUSH
117166: PPUSH
117167: PPUSH
117168: PPUSH
117169: PPUSH
117170: PPUSH
117171: PPUSH
117172: PPUSH
117173: PPUSH
// if not list then
117174: LD_VAR 0 1
117178: NOT
117179: IFFALSE 117183
// exit ;
117181: GO 121842
// base := list [ 1 ] ;
117183: LD_ADDR_VAR 0 3
117187: PUSH
117188: LD_VAR 0 1
117192: PUSH
117193: LD_INT 1
117195: ARRAY
117196: ST_TO_ADDR
// group := list [ 2 ] ;
117197: LD_ADDR_VAR 0 4
117201: PUSH
117202: LD_VAR 0 1
117206: PUSH
117207: LD_INT 2
117209: ARRAY
117210: ST_TO_ADDR
// path := list [ 3 ] ;
117211: LD_ADDR_VAR 0 5
117215: PUSH
117216: LD_VAR 0 1
117220: PUSH
117221: LD_INT 3
117223: ARRAY
117224: ST_TO_ADDR
// flags := list [ 4 ] ;
117225: LD_ADDR_VAR 0 6
117229: PUSH
117230: LD_VAR 0 1
117234: PUSH
117235: LD_INT 4
117237: ARRAY
117238: ST_TO_ADDR
// mined := [ ] ;
117239: LD_ADDR_VAR 0 27
117243: PUSH
117244: EMPTY
117245: ST_TO_ADDR
// bombed := [ ] ;
117246: LD_ADDR_VAR 0 28
117250: PUSH
117251: EMPTY
117252: ST_TO_ADDR
// healers := [ ] ;
117253: LD_ADDR_VAR 0 31
117257: PUSH
117258: EMPTY
117259: ST_TO_ADDR
// to_heal := [ ] ;
117260: LD_ADDR_VAR 0 30
117264: PUSH
117265: EMPTY
117266: ST_TO_ADDR
// repairs := [ ] ;
117267: LD_ADDR_VAR 0 33
117271: PUSH
117272: EMPTY
117273: ST_TO_ADDR
// to_repair := [ ] ;
117274: LD_ADDR_VAR 0 32
117278: PUSH
117279: EMPTY
117280: ST_TO_ADDR
// if not group or not path then
117281: LD_VAR 0 4
117285: NOT
117286: PUSH
117287: LD_VAR 0 5
117291: NOT
117292: OR
117293: IFFALSE 117297
// exit ;
117295: GO 121842
// side := GetSide ( group [ 1 ] ) ;
117297: LD_ADDR_VAR 0 35
117301: PUSH
117302: LD_VAR 0 4
117306: PUSH
117307: LD_INT 1
117309: ARRAY
117310: PPUSH
117311: CALL_OW 255
117315: ST_TO_ADDR
// if flags then
117316: LD_VAR 0 6
117320: IFFALSE 117464
// begin f_ignore_area := flags [ 1 ] ;
117322: LD_ADDR_VAR 0 17
117326: PUSH
117327: LD_VAR 0 6
117331: PUSH
117332: LD_INT 1
117334: ARRAY
117335: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117336: LD_ADDR_VAR 0 18
117340: PUSH
117341: LD_VAR 0 6
117345: PUSH
117346: LD_INT 2
117348: ARRAY
117349: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117350: LD_ADDR_VAR 0 19
117354: PUSH
117355: LD_VAR 0 6
117359: PUSH
117360: LD_INT 3
117362: ARRAY
117363: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117364: LD_ADDR_VAR 0 20
117368: PUSH
117369: LD_VAR 0 6
117373: PUSH
117374: LD_INT 4
117376: ARRAY
117377: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117378: LD_ADDR_VAR 0 21
117382: PUSH
117383: LD_VAR 0 6
117387: PUSH
117388: LD_INT 5
117390: ARRAY
117391: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117392: LD_ADDR_VAR 0 22
117396: PUSH
117397: LD_VAR 0 6
117401: PUSH
117402: LD_INT 6
117404: ARRAY
117405: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117406: LD_ADDR_VAR 0 23
117410: PUSH
117411: LD_VAR 0 6
117415: PUSH
117416: LD_INT 7
117418: ARRAY
117419: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117420: LD_ADDR_VAR 0 24
117424: PUSH
117425: LD_VAR 0 6
117429: PUSH
117430: LD_INT 8
117432: ARRAY
117433: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117434: LD_ADDR_VAR 0 25
117438: PUSH
117439: LD_VAR 0 6
117443: PUSH
117444: LD_INT 9
117446: ARRAY
117447: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117448: LD_ADDR_VAR 0 26
117452: PUSH
117453: LD_VAR 0 6
117457: PUSH
117458: LD_INT 10
117460: ARRAY
117461: ST_TO_ADDR
// end else
117462: GO 117544
// begin f_ignore_area := false ;
117464: LD_ADDR_VAR 0 17
117468: PUSH
117469: LD_INT 0
117471: ST_TO_ADDR
// f_capture := false ;
117472: LD_ADDR_VAR 0 18
117476: PUSH
117477: LD_INT 0
117479: ST_TO_ADDR
// f_ignore_civ := false ;
117480: LD_ADDR_VAR 0 19
117484: PUSH
117485: LD_INT 0
117487: ST_TO_ADDR
// f_murder := false ;
117488: LD_ADDR_VAR 0 20
117492: PUSH
117493: LD_INT 0
117495: ST_TO_ADDR
// f_mines := false ;
117496: LD_ADDR_VAR 0 21
117500: PUSH
117501: LD_INT 0
117503: ST_TO_ADDR
// f_repair := false ;
117504: LD_ADDR_VAR 0 22
117508: PUSH
117509: LD_INT 0
117511: ST_TO_ADDR
// f_heal := false ;
117512: LD_ADDR_VAR 0 23
117516: PUSH
117517: LD_INT 0
117519: ST_TO_ADDR
// f_spacetime := false ;
117520: LD_ADDR_VAR 0 24
117524: PUSH
117525: LD_INT 0
117527: ST_TO_ADDR
// f_attack_depot := false ;
117528: LD_ADDR_VAR 0 25
117532: PUSH
117533: LD_INT 0
117535: ST_TO_ADDR
// f_crawl := false ;
117536: LD_ADDR_VAR 0 26
117540: PUSH
117541: LD_INT 0
117543: ST_TO_ADDR
// end ; if f_heal then
117544: LD_VAR 0 23
117548: IFFALSE 117575
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
117550: LD_ADDR_VAR 0 31
117554: PUSH
117555: LD_VAR 0 4
117559: PPUSH
117560: LD_INT 25
117562: PUSH
117563: LD_INT 4
117565: PUSH
117566: EMPTY
117567: LIST
117568: LIST
117569: PPUSH
117570: CALL_OW 72
117574: ST_TO_ADDR
// if f_repair then
117575: LD_VAR 0 22
117579: IFFALSE 117606
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
117581: LD_ADDR_VAR 0 33
117585: PUSH
117586: LD_VAR 0 4
117590: PPUSH
117591: LD_INT 25
117593: PUSH
117594: LD_INT 3
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: PPUSH
117601: CALL_OW 72
117605: ST_TO_ADDR
// units_path := [ ] ;
117606: LD_ADDR_VAR 0 16
117610: PUSH
117611: EMPTY
117612: ST_TO_ADDR
// for i = 1 to group do
117613: LD_ADDR_VAR 0 7
117617: PUSH
117618: DOUBLE
117619: LD_INT 1
117621: DEC
117622: ST_TO_ADDR
117623: LD_VAR 0 4
117627: PUSH
117628: FOR_TO
117629: IFFALSE 117658
// units_path := Replace ( units_path , i , path ) ;
117631: LD_ADDR_VAR 0 16
117635: PUSH
117636: LD_VAR 0 16
117640: PPUSH
117641: LD_VAR 0 7
117645: PPUSH
117646: LD_VAR 0 5
117650: PPUSH
117651: CALL_OW 1
117655: ST_TO_ADDR
117656: GO 117628
117658: POP
117659: POP
// repeat for i = group downto 1 do
117660: LD_ADDR_VAR 0 7
117664: PUSH
117665: DOUBLE
117666: LD_VAR 0 4
117670: INC
117671: ST_TO_ADDR
117672: LD_INT 1
117674: PUSH
117675: FOR_DOWNTO
117676: IFFALSE 121798
// begin wait ( 5 ) ;
117678: LD_INT 5
117680: PPUSH
117681: CALL_OW 67
// tmp := [ ] ;
117685: LD_ADDR_VAR 0 14
117689: PUSH
117690: EMPTY
117691: ST_TO_ADDR
// attacking := false ;
117692: LD_ADDR_VAR 0 29
117696: PUSH
117697: LD_INT 0
117699: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
117700: LD_VAR 0 4
117704: PUSH
117705: LD_VAR 0 7
117709: ARRAY
117710: PPUSH
117711: CALL_OW 301
117715: PUSH
117716: LD_VAR 0 4
117720: PUSH
117721: LD_VAR 0 7
117725: ARRAY
117726: NOT
117727: OR
117728: IFFALSE 117837
// begin if GetType ( group [ i ] ) = unit_human then
117730: LD_VAR 0 4
117734: PUSH
117735: LD_VAR 0 7
117739: ARRAY
117740: PPUSH
117741: CALL_OW 247
117745: PUSH
117746: LD_INT 1
117748: EQUAL
117749: IFFALSE 117795
// begin to_heal := to_heal diff group [ i ] ;
117751: LD_ADDR_VAR 0 30
117755: PUSH
117756: LD_VAR 0 30
117760: PUSH
117761: LD_VAR 0 4
117765: PUSH
117766: LD_VAR 0 7
117770: ARRAY
117771: DIFF
117772: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117773: LD_ADDR_VAR 0 31
117777: PUSH
117778: LD_VAR 0 31
117782: PUSH
117783: LD_VAR 0 4
117787: PUSH
117788: LD_VAR 0 7
117792: ARRAY
117793: DIFF
117794: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117795: LD_ADDR_VAR 0 4
117799: PUSH
117800: LD_VAR 0 4
117804: PPUSH
117805: LD_VAR 0 7
117809: PPUSH
117810: CALL_OW 3
117814: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117815: LD_ADDR_VAR 0 16
117819: PUSH
117820: LD_VAR 0 16
117824: PPUSH
117825: LD_VAR 0 7
117829: PPUSH
117830: CALL_OW 3
117834: ST_TO_ADDR
// continue ;
117835: GO 117675
// end ; if f_repair then
117837: LD_VAR 0 22
117841: IFFALSE 118330
// begin if GetType ( group [ i ] ) = unit_vehicle then
117843: LD_VAR 0 4
117847: PUSH
117848: LD_VAR 0 7
117852: ARRAY
117853: PPUSH
117854: CALL_OW 247
117858: PUSH
117859: LD_INT 2
117861: EQUAL
117862: IFFALSE 118052
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117864: LD_VAR 0 4
117868: PUSH
117869: LD_VAR 0 7
117873: ARRAY
117874: PPUSH
117875: CALL_OW 256
117879: PUSH
117880: LD_INT 700
117882: LESS
117883: PUSH
117884: LD_VAR 0 4
117888: PUSH
117889: LD_VAR 0 7
117893: ARRAY
117894: PUSH
117895: LD_VAR 0 32
117899: IN
117900: NOT
117901: AND
117902: IFFALSE 117926
// to_repair := to_repair union group [ i ] ;
117904: LD_ADDR_VAR 0 32
117908: PUSH
117909: LD_VAR 0 32
117913: PUSH
117914: LD_VAR 0 4
117918: PUSH
117919: LD_VAR 0 7
117923: ARRAY
117924: UNION
117925: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117926: LD_VAR 0 4
117930: PUSH
117931: LD_VAR 0 7
117935: ARRAY
117936: PPUSH
117937: CALL_OW 256
117941: PUSH
117942: LD_INT 1000
117944: EQUAL
117945: PUSH
117946: LD_VAR 0 4
117950: PUSH
117951: LD_VAR 0 7
117955: ARRAY
117956: PUSH
117957: LD_VAR 0 32
117961: IN
117962: AND
117963: IFFALSE 117987
// to_repair := to_repair diff group [ i ] ;
117965: LD_ADDR_VAR 0 32
117969: PUSH
117970: LD_VAR 0 32
117974: PUSH
117975: LD_VAR 0 4
117979: PUSH
117980: LD_VAR 0 7
117984: ARRAY
117985: DIFF
117986: ST_TO_ADDR
// if group [ i ] in to_repair then
117987: LD_VAR 0 4
117991: PUSH
117992: LD_VAR 0 7
117996: ARRAY
117997: PUSH
117998: LD_VAR 0 32
118002: IN
118003: IFFALSE 118050
// begin if not IsInArea ( group [ i ] , f_repair ) then
118005: LD_VAR 0 4
118009: PUSH
118010: LD_VAR 0 7
118014: ARRAY
118015: PPUSH
118016: LD_VAR 0 22
118020: PPUSH
118021: CALL_OW 308
118025: NOT
118026: IFFALSE 118048
// ComMoveToArea ( group [ i ] , f_repair ) ;
118028: LD_VAR 0 4
118032: PUSH
118033: LD_VAR 0 7
118037: ARRAY
118038: PPUSH
118039: LD_VAR 0 22
118043: PPUSH
118044: CALL_OW 113
// continue ;
118048: GO 117675
// end ; end else
118050: GO 118330
// if group [ i ] in repairs then
118052: LD_VAR 0 4
118056: PUSH
118057: LD_VAR 0 7
118061: ARRAY
118062: PUSH
118063: LD_VAR 0 33
118067: IN
118068: IFFALSE 118330
// begin if IsInUnit ( group [ i ] ) then
118070: LD_VAR 0 4
118074: PUSH
118075: LD_VAR 0 7
118079: ARRAY
118080: PPUSH
118081: CALL_OW 310
118085: IFFALSE 118153
// begin z := IsInUnit ( group [ i ] ) ;
118087: LD_ADDR_VAR 0 13
118091: PUSH
118092: LD_VAR 0 4
118096: PUSH
118097: LD_VAR 0 7
118101: ARRAY
118102: PPUSH
118103: CALL_OW 310
118107: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
118108: LD_VAR 0 13
118112: PUSH
118113: LD_VAR 0 32
118117: IN
118118: PUSH
118119: LD_VAR 0 13
118123: PPUSH
118124: LD_VAR 0 22
118128: PPUSH
118129: CALL_OW 308
118133: AND
118134: IFFALSE 118151
// ComExitVehicle ( group [ i ] ) ;
118136: LD_VAR 0 4
118140: PUSH
118141: LD_VAR 0 7
118145: ARRAY
118146: PPUSH
118147: CALL_OW 121
// end else
118151: GO 118330
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
118153: LD_ADDR_VAR 0 13
118157: PUSH
118158: LD_VAR 0 4
118162: PPUSH
118163: LD_INT 95
118165: PUSH
118166: LD_VAR 0 22
118170: PUSH
118171: EMPTY
118172: LIST
118173: LIST
118174: PUSH
118175: LD_INT 58
118177: PUSH
118178: EMPTY
118179: LIST
118180: PUSH
118181: EMPTY
118182: LIST
118183: LIST
118184: PPUSH
118185: CALL_OW 72
118189: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
118190: LD_VAR 0 4
118194: PUSH
118195: LD_VAR 0 7
118199: ARRAY
118200: PPUSH
118201: CALL_OW 314
118205: NOT
118206: IFFALSE 118328
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
118208: LD_ADDR_VAR 0 10
118212: PUSH
118213: LD_VAR 0 13
118217: PPUSH
118218: LD_VAR 0 4
118222: PUSH
118223: LD_VAR 0 7
118227: ARRAY
118228: PPUSH
118229: CALL_OW 74
118233: ST_TO_ADDR
// if not x then
118234: LD_VAR 0 10
118238: NOT
118239: IFFALSE 118243
// continue ;
118241: GO 117675
// if GetLives ( x ) < 1000 then
118243: LD_VAR 0 10
118247: PPUSH
118248: CALL_OW 256
118252: PUSH
118253: LD_INT 1000
118255: LESS
118256: IFFALSE 118280
// ComRepairVehicle ( group [ i ] , x ) else
118258: LD_VAR 0 4
118262: PUSH
118263: LD_VAR 0 7
118267: ARRAY
118268: PPUSH
118269: LD_VAR 0 10
118273: PPUSH
118274: CALL_OW 129
118278: GO 118328
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
118280: LD_VAR 0 23
118284: PUSH
118285: LD_VAR 0 4
118289: PUSH
118290: LD_VAR 0 7
118294: ARRAY
118295: PPUSH
118296: CALL_OW 256
118300: PUSH
118301: LD_INT 1000
118303: LESS
118304: AND
118305: NOT
118306: IFFALSE 118328
// ComEnterUnit ( group [ i ] , x ) ;
118308: LD_VAR 0 4
118312: PUSH
118313: LD_VAR 0 7
118317: ARRAY
118318: PPUSH
118319: LD_VAR 0 10
118323: PPUSH
118324: CALL_OW 120
// end ; continue ;
118328: GO 117675
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118330: LD_VAR 0 23
118334: PUSH
118335: LD_VAR 0 4
118339: PUSH
118340: LD_VAR 0 7
118344: ARRAY
118345: PPUSH
118346: CALL_OW 247
118350: PUSH
118351: LD_INT 1
118353: EQUAL
118354: AND
118355: IFFALSE 118833
// begin if group [ i ] in healers then
118357: LD_VAR 0 4
118361: PUSH
118362: LD_VAR 0 7
118366: ARRAY
118367: PUSH
118368: LD_VAR 0 31
118372: IN
118373: IFFALSE 118646
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118375: LD_VAR 0 4
118379: PUSH
118380: LD_VAR 0 7
118384: ARRAY
118385: PPUSH
118386: LD_VAR 0 23
118390: PPUSH
118391: CALL_OW 308
118395: NOT
118396: PUSH
118397: LD_VAR 0 4
118401: PUSH
118402: LD_VAR 0 7
118406: ARRAY
118407: PPUSH
118408: CALL_OW 314
118412: NOT
118413: AND
118414: IFFALSE 118438
// ComMoveToArea ( group [ i ] , f_heal ) else
118416: LD_VAR 0 4
118420: PUSH
118421: LD_VAR 0 7
118425: ARRAY
118426: PPUSH
118427: LD_VAR 0 23
118431: PPUSH
118432: CALL_OW 113
118436: GO 118644
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118438: LD_VAR 0 4
118442: PUSH
118443: LD_VAR 0 7
118447: ARRAY
118448: PPUSH
118449: CALL 88648 0 1
118453: PPUSH
118454: CALL_OW 256
118458: PUSH
118459: LD_INT 1000
118461: EQUAL
118462: IFFALSE 118481
// ComStop ( group [ i ] ) else
118464: LD_VAR 0 4
118468: PUSH
118469: LD_VAR 0 7
118473: ARRAY
118474: PPUSH
118475: CALL_OW 141
118479: GO 118644
// if not HasTask ( group [ i ] ) and to_heal then
118481: LD_VAR 0 4
118485: PUSH
118486: LD_VAR 0 7
118490: ARRAY
118491: PPUSH
118492: CALL_OW 314
118496: NOT
118497: PUSH
118498: LD_VAR 0 30
118502: AND
118503: IFFALSE 118644
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118505: LD_ADDR_VAR 0 13
118509: PUSH
118510: LD_VAR 0 30
118514: PPUSH
118515: LD_INT 3
118517: PUSH
118518: LD_INT 54
118520: PUSH
118521: EMPTY
118522: LIST
118523: PUSH
118524: EMPTY
118525: LIST
118526: LIST
118527: PPUSH
118528: CALL_OW 72
118532: PPUSH
118533: LD_VAR 0 4
118537: PUSH
118538: LD_VAR 0 7
118542: ARRAY
118543: PPUSH
118544: CALL_OW 74
118548: ST_TO_ADDR
// if z then
118549: LD_VAR 0 13
118553: IFFALSE 118644
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
118555: LD_INT 91
118557: PUSH
118558: LD_VAR 0 13
118562: PUSH
118563: LD_INT 10
118565: PUSH
118566: EMPTY
118567: LIST
118568: LIST
118569: LIST
118570: PUSH
118571: LD_INT 81
118573: PUSH
118574: LD_VAR 0 13
118578: PPUSH
118579: CALL_OW 255
118583: PUSH
118584: EMPTY
118585: LIST
118586: LIST
118587: PUSH
118588: EMPTY
118589: LIST
118590: LIST
118591: PPUSH
118592: CALL_OW 69
118596: PUSH
118597: LD_INT 0
118599: EQUAL
118600: IFFALSE 118624
// ComHeal ( group [ i ] , z ) else
118602: LD_VAR 0 4
118606: PUSH
118607: LD_VAR 0 7
118611: ARRAY
118612: PPUSH
118613: LD_VAR 0 13
118617: PPUSH
118618: CALL_OW 128
118622: GO 118644
// ComMoveToArea ( group [ i ] , f_heal ) ;
118624: LD_VAR 0 4
118628: PUSH
118629: LD_VAR 0 7
118633: ARRAY
118634: PPUSH
118635: LD_VAR 0 23
118639: PPUSH
118640: CALL_OW 113
// end ; continue ;
118644: GO 117675
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
118646: LD_VAR 0 4
118650: PUSH
118651: LD_VAR 0 7
118655: ARRAY
118656: PPUSH
118657: CALL_OW 256
118661: PUSH
118662: LD_INT 700
118664: LESS
118665: PUSH
118666: LD_VAR 0 4
118670: PUSH
118671: LD_VAR 0 7
118675: ARRAY
118676: PUSH
118677: LD_VAR 0 30
118681: IN
118682: NOT
118683: AND
118684: IFFALSE 118708
// to_heal := to_heal union group [ i ] ;
118686: LD_ADDR_VAR 0 30
118690: PUSH
118691: LD_VAR 0 30
118695: PUSH
118696: LD_VAR 0 4
118700: PUSH
118701: LD_VAR 0 7
118705: ARRAY
118706: UNION
118707: ST_TO_ADDR
// if group [ i ] in to_heal then
118708: LD_VAR 0 4
118712: PUSH
118713: LD_VAR 0 7
118717: ARRAY
118718: PUSH
118719: LD_VAR 0 30
118723: IN
118724: IFFALSE 118833
// begin if GetLives ( group [ i ] ) = 1000 then
118726: LD_VAR 0 4
118730: PUSH
118731: LD_VAR 0 7
118735: ARRAY
118736: PPUSH
118737: CALL_OW 256
118741: PUSH
118742: LD_INT 1000
118744: EQUAL
118745: IFFALSE 118771
// to_heal := to_heal diff group [ i ] else
118747: LD_ADDR_VAR 0 30
118751: PUSH
118752: LD_VAR 0 30
118756: PUSH
118757: LD_VAR 0 4
118761: PUSH
118762: LD_VAR 0 7
118766: ARRAY
118767: DIFF
118768: ST_TO_ADDR
118769: GO 118833
// begin if not IsInArea ( group [ i ] , to_heal ) then
118771: LD_VAR 0 4
118775: PUSH
118776: LD_VAR 0 7
118780: ARRAY
118781: PPUSH
118782: LD_VAR 0 30
118786: PPUSH
118787: CALL_OW 308
118791: NOT
118792: IFFALSE 118816
// ComMoveToArea ( group [ i ] , f_heal ) else
118794: LD_VAR 0 4
118798: PUSH
118799: LD_VAR 0 7
118803: ARRAY
118804: PPUSH
118805: LD_VAR 0 23
118809: PPUSH
118810: CALL_OW 113
118814: GO 118831
// ComHold ( group [ i ] ) ;
118816: LD_VAR 0 4
118820: PUSH
118821: LD_VAR 0 7
118825: ARRAY
118826: PPUSH
118827: CALL_OW 140
// continue ;
118831: GO 117675
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118833: LD_VAR 0 4
118837: PUSH
118838: LD_VAR 0 7
118842: ARRAY
118843: PPUSH
118844: LD_INT 10
118846: PPUSH
118847: CALL 86430 0 2
118851: NOT
118852: PUSH
118853: LD_VAR 0 16
118857: PUSH
118858: LD_VAR 0 7
118862: ARRAY
118863: PUSH
118864: EMPTY
118865: EQUAL
118866: NOT
118867: AND
118868: IFFALSE 119134
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118870: LD_VAR 0 4
118874: PUSH
118875: LD_VAR 0 7
118879: ARRAY
118880: PPUSH
118881: CALL_OW 262
118885: PUSH
118886: LD_INT 1
118888: PUSH
118889: LD_INT 2
118891: PUSH
118892: EMPTY
118893: LIST
118894: LIST
118895: IN
118896: IFFALSE 118937
// if GetFuel ( group [ i ] ) < 10 then
118898: LD_VAR 0 4
118902: PUSH
118903: LD_VAR 0 7
118907: ARRAY
118908: PPUSH
118909: CALL_OW 261
118913: PUSH
118914: LD_INT 10
118916: LESS
118917: IFFALSE 118937
// SetFuel ( group [ i ] , 12 ) ;
118919: LD_VAR 0 4
118923: PUSH
118924: LD_VAR 0 7
118928: ARRAY
118929: PPUSH
118930: LD_INT 12
118932: PPUSH
118933: CALL_OW 240
// if units_path [ i ] then
118937: LD_VAR 0 16
118941: PUSH
118942: LD_VAR 0 7
118946: ARRAY
118947: IFFALSE 119132
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118949: LD_VAR 0 4
118953: PUSH
118954: LD_VAR 0 7
118958: ARRAY
118959: PPUSH
118960: LD_VAR 0 16
118964: PUSH
118965: LD_VAR 0 7
118969: ARRAY
118970: PUSH
118971: LD_INT 1
118973: ARRAY
118974: PUSH
118975: LD_INT 1
118977: ARRAY
118978: PPUSH
118979: LD_VAR 0 16
118983: PUSH
118984: LD_VAR 0 7
118988: ARRAY
118989: PUSH
118990: LD_INT 1
118992: ARRAY
118993: PUSH
118994: LD_INT 2
118996: ARRAY
118997: PPUSH
118998: CALL_OW 297
119002: PUSH
119003: LD_INT 6
119005: GREATER
119006: IFFALSE 119081
// begin if not HasTask ( group [ i ] ) then
119008: LD_VAR 0 4
119012: PUSH
119013: LD_VAR 0 7
119017: ARRAY
119018: PPUSH
119019: CALL_OW 314
119023: NOT
119024: IFFALSE 119079
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
119026: LD_VAR 0 4
119030: PUSH
119031: LD_VAR 0 7
119035: ARRAY
119036: PPUSH
119037: LD_VAR 0 16
119041: PUSH
119042: LD_VAR 0 7
119046: ARRAY
119047: PUSH
119048: LD_INT 1
119050: ARRAY
119051: PUSH
119052: LD_INT 1
119054: ARRAY
119055: PPUSH
119056: LD_VAR 0 16
119060: PUSH
119061: LD_VAR 0 7
119065: ARRAY
119066: PUSH
119067: LD_INT 1
119069: ARRAY
119070: PUSH
119071: LD_INT 2
119073: ARRAY
119074: PPUSH
119075: CALL_OW 114
// end else
119079: GO 119132
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
119081: LD_ADDR_VAR 0 15
119085: PUSH
119086: LD_VAR 0 16
119090: PUSH
119091: LD_VAR 0 7
119095: ARRAY
119096: PPUSH
119097: LD_INT 1
119099: PPUSH
119100: CALL_OW 3
119104: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
119105: LD_ADDR_VAR 0 16
119109: PUSH
119110: LD_VAR 0 16
119114: PPUSH
119115: LD_VAR 0 7
119119: PPUSH
119120: LD_VAR 0 15
119124: PPUSH
119125: CALL_OW 1
119129: ST_TO_ADDR
// continue ;
119130: GO 117675
// end ; end ; end else
119132: GO 121796
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
119134: LD_ADDR_VAR 0 14
119138: PUSH
119139: LD_INT 81
119141: PUSH
119142: LD_VAR 0 4
119146: PUSH
119147: LD_VAR 0 7
119151: ARRAY
119152: PPUSH
119153: CALL_OW 255
119157: PUSH
119158: EMPTY
119159: LIST
119160: LIST
119161: PPUSH
119162: CALL_OW 69
119166: ST_TO_ADDR
// if not tmp then
119167: LD_VAR 0 14
119171: NOT
119172: IFFALSE 119176
// continue ;
119174: GO 117675
// if f_ignore_area then
119176: LD_VAR 0 17
119180: IFFALSE 119268
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
119182: LD_ADDR_VAR 0 15
119186: PUSH
119187: LD_VAR 0 14
119191: PPUSH
119192: LD_INT 3
119194: PUSH
119195: LD_INT 92
119197: PUSH
119198: LD_VAR 0 17
119202: PUSH
119203: LD_INT 1
119205: ARRAY
119206: PUSH
119207: LD_VAR 0 17
119211: PUSH
119212: LD_INT 2
119214: ARRAY
119215: PUSH
119216: LD_VAR 0 17
119220: PUSH
119221: LD_INT 3
119223: ARRAY
119224: PUSH
119225: EMPTY
119226: LIST
119227: LIST
119228: LIST
119229: LIST
119230: PUSH
119231: EMPTY
119232: LIST
119233: LIST
119234: PPUSH
119235: CALL_OW 72
119239: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119240: LD_VAR 0 14
119244: PUSH
119245: LD_VAR 0 15
119249: DIFF
119250: IFFALSE 119268
// tmp := tmp diff tmp2 ;
119252: LD_ADDR_VAR 0 14
119256: PUSH
119257: LD_VAR 0 14
119261: PUSH
119262: LD_VAR 0 15
119266: DIFF
119267: ST_TO_ADDR
// end ; if not f_murder then
119268: LD_VAR 0 20
119272: NOT
119273: IFFALSE 119331
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
119275: LD_ADDR_VAR 0 15
119279: PUSH
119280: LD_VAR 0 14
119284: PPUSH
119285: LD_INT 3
119287: PUSH
119288: LD_INT 50
119290: PUSH
119291: EMPTY
119292: LIST
119293: PUSH
119294: EMPTY
119295: LIST
119296: LIST
119297: PPUSH
119298: CALL_OW 72
119302: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119303: LD_VAR 0 14
119307: PUSH
119308: LD_VAR 0 15
119312: DIFF
119313: IFFALSE 119331
// tmp := tmp diff tmp2 ;
119315: LD_ADDR_VAR 0 14
119319: PUSH
119320: LD_VAR 0 14
119324: PUSH
119325: LD_VAR 0 15
119329: DIFF
119330: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119331: LD_ADDR_VAR 0 14
119335: PUSH
119336: LD_VAR 0 4
119340: PUSH
119341: LD_VAR 0 7
119345: ARRAY
119346: PPUSH
119347: LD_VAR 0 14
119351: PPUSH
119352: LD_INT 1
119354: PPUSH
119355: LD_INT 1
119357: PPUSH
119358: CALL 58974 0 4
119362: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119363: LD_VAR 0 4
119367: PUSH
119368: LD_VAR 0 7
119372: ARRAY
119373: PPUSH
119374: CALL_OW 257
119378: PUSH
119379: LD_INT 1
119381: EQUAL
119382: IFFALSE 119830
// begin if WantPlant ( group [ i ] ) then
119384: LD_VAR 0 4
119388: PUSH
119389: LD_VAR 0 7
119393: ARRAY
119394: PPUSH
119395: CALL 58475 0 1
119399: IFFALSE 119403
// continue ;
119401: GO 117675
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119403: LD_VAR 0 18
119407: PUSH
119408: LD_VAR 0 4
119412: PUSH
119413: LD_VAR 0 7
119417: ARRAY
119418: PPUSH
119419: CALL_OW 310
119423: NOT
119424: AND
119425: PUSH
119426: LD_VAR 0 14
119430: PUSH
119431: LD_INT 1
119433: ARRAY
119434: PUSH
119435: LD_VAR 0 14
119439: PPUSH
119440: LD_INT 21
119442: PUSH
119443: LD_INT 2
119445: PUSH
119446: EMPTY
119447: LIST
119448: LIST
119449: PUSH
119450: LD_INT 58
119452: PUSH
119453: EMPTY
119454: LIST
119455: PUSH
119456: EMPTY
119457: LIST
119458: LIST
119459: PPUSH
119460: CALL_OW 72
119464: IN
119465: AND
119466: IFFALSE 119502
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119468: LD_VAR 0 4
119472: PUSH
119473: LD_VAR 0 7
119477: ARRAY
119478: PPUSH
119479: LD_VAR 0 14
119483: PUSH
119484: LD_INT 1
119486: ARRAY
119487: PPUSH
119488: CALL_OW 120
// attacking := true ;
119492: LD_ADDR_VAR 0 29
119496: PUSH
119497: LD_INT 1
119499: ST_TO_ADDR
// continue ;
119500: GO 117675
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119502: LD_VAR 0 26
119506: PUSH
119507: LD_VAR 0 4
119511: PUSH
119512: LD_VAR 0 7
119516: ARRAY
119517: PPUSH
119518: CALL_OW 257
119522: PUSH
119523: LD_INT 1
119525: EQUAL
119526: AND
119527: PUSH
119528: LD_VAR 0 4
119532: PUSH
119533: LD_VAR 0 7
119537: ARRAY
119538: PPUSH
119539: CALL_OW 256
119543: PUSH
119544: LD_INT 800
119546: LESS
119547: AND
119548: PUSH
119549: LD_VAR 0 4
119553: PUSH
119554: LD_VAR 0 7
119558: ARRAY
119559: PPUSH
119560: CALL_OW 318
119564: NOT
119565: AND
119566: IFFALSE 119583
// ComCrawl ( group [ i ] ) ;
119568: LD_VAR 0 4
119572: PUSH
119573: LD_VAR 0 7
119577: ARRAY
119578: PPUSH
119579: CALL_OW 137
// if f_mines then
119583: LD_VAR 0 21
119587: IFFALSE 119830
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
119589: LD_VAR 0 14
119593: PUSH
119594: LD_INT 1
119596: ARRAY
119597: PPUSH
119598: CALL_OW 247
119602: PUSH
119603: LD_INT 3
119605: EQUAL
119606: PUSH
119607: LD_VAR 0 14
119611: PUSH
119612: LD_INT 1
119614: ARRAY
119615: PUSH
119616: LD_VAR 0 27
119620: IN
119621: NOT
119622: AND
119623: IFFALSE 119830
// begin x := GetX ( tmp [ 1 ] ) ;
119625: LD_ADDR_VAR 0 10
119629: PUSH
119630: LD_VAR 0 14
119634: PUSH
119635: LD_INT 1
119637: ARRAY
119638: PPUSH
119639: CALL_OW 250
119643: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
119644: LD_ADDR_VAR 0 11
119648: PUSH
119649: LD_VAR 0 14
119653: PUSH
119654: LD_INT 1
119656: ARRAY
119657: PPUSH
119658: CALL_OW 251
119662: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
119663: LD_ADDR_VAR 0 12
119667: PUSH
119668: LD_VAR 0 4
119672: PUSH
119673: LD_VAR 0 7
119677: ARRAY
119678: PPUSH
119679: CALL 86515 0 1
119683: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
119684: LD_VAR 0 4
119688: PUSH
119689: LD_VAR 0 7
119693: ARRAY
119694: PPUSH
119695: LD_VAR 0 10
119699: PPUSH
119700: LD_VAR 0 11
119704: PPUSH
119705: LD_VAR 0 14
119709: PUSH
119710: LD_INT 1
119712: ARRAY
119713: PPUSH
119714: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119718: LD_VAR 0 4
119722: PUSH
119723: LD_VAR 0 7
119727: ARRAY
119728: PPUSH
119729: LD_VAR 0 10
119733: PPUSH
119734: LD_VAR 0 12
119738: PPUSH
119739: LD_INT 7
119741: PPUSH
119742: CALL_OW 272
119746: PPUSH
119747: LD_VAR 0 11
119751: PPUSH
119752: LD_VAR 0 12
119756: PPUSH
119757: LD_INT 7
119759: PPUSH
119760: CALL_OW 273
119764: PPUSH
119765: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119769: LD_VAR 0 4
119773: PUSH
119774: LD_VAR 0 7
119778: ARRAY
119779: PPUSH
119780: LD_INT 71
119782: PPUSH
119783: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119787: LD_ADDR_VAR 0 27
119791: PUSH
119792: LD_VAR 0 27
119796: PPUSH
119797: LD_VAR 0 27
119801: PUSH
119802: LD_INT 1
119804: PLUS
119805: PPUSH
119806: LD_VAR 0 14
119810: PUSH
119811: LD_INT 1
119813: ARRAY
119814: PPUSH
119815: CALL_OW 1
119819: ST_TO_ADDR
// attacking := true ;
119820: LD_ADDR_VAR 0 29
119824: PUSH
119825: LD_INT 1
119827: ST_TO_ADDR
// continue ;
119828: GO 117675
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119830: LD_VAR 0 4
119834: PUSH
119835: LD_VAR 0 7
119839: ARRAY
119840: PPUSH
119841: CALL_OW 257
119845: PUSH
119846: LD_INT 17
119848: EQUAL
119849: PUSH
119850: LD_VAR 0 4
119854: PUSH
119855: LD_VAR 0 7
119859: ARRAY
119860: PPUSH
119861: CALL_OW 110
119865: PUSH
119866: LD_INT 71
119868: EQUAL
119869: NOT
119870: AND
119871: IFFALSE 120017
// begin attacking := false ;
119873: LD_ADDR_VAR 0 29
119877: PUSH
119878: LD_INT 0
119880: ST_TO_ADDR
// k := 5 ;
119881: LD_ADDR_VAR 0 9
119885: PUSH
119886: LD_INT 5
119888: ST_TO_ADDR
// if tmp < k then
119889: LD_VAR 0 14
119893: PUSH
119894: LD_VAR 0 9
119898: LESS
119899: IFFALSE 119911
// k := tmp ;
119901: LD_ADDR_VAR 0 9
119905: PUSH
119906: LD_VAR 0 14
119910: ST_TO_ADDR
// for j = 1 to k do
119911: LD_ADDR_VAR 0 8
119915: PUSH
119916: DOUBLE
119917: LD_INT 1
119919: DEC
119920: ST_TO_ADDR
119921: LD_VAR 0 9
119925: PUSH
119926: FOR_TO
119927: IFFALSE 120015
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119929: LD_VAR 0 14
119933: PUSH
119934: LD_VAR 0 8
119938: ARRAY
119939: PUSH
119940: LD_VAR 0 14
119944: PPUSH
119945: LD_INT 58
119947: PUSH
119948: EMPTY
119949: LIST
119950: PPUSH
119951: CALL_OW 72
119955: IN
119956: NOT
119957: IFFALSE 120013
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119959: LD_VAR 0 4
119963: PUSH
119964: LD_VAR 0 7
119968: ARRAY
119969: PPUSH
119970: LD_VAR 0 14
119974: PUSH
119975: LD_VAR 0 8
119979: ARRAY
119980: PPUSH
119981: CALL_OW 115
// attacking := true ;
119985: LD_ADDR_VAR 0 29
119989: PUSH
119990: LD_INT 1
119992: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119993: LD_VAR 0 4
119997: PUSH
119998: LD_VAR 0 7
120002: ARRAY
120003: PPUSH
120004: LD_INT 71
120006: PPUSH
120007: CALL_OW 109
// continue ;
120011: GO 119926
// end ; end ;
120013: GO 119926
120015: POP
120016: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
120017: LD_VAR 0 4
120021: PUSH
120022: LD_VAR 0 7
120026: ARRAY
120027: PPUSH
120028: CALL_OW 257
120032: PUSH
120033: LD_INT 8
120035: EQUAL
120036: PUSH
120037: LD_VAR 0 4
120041: PUSH
120042: LD_VAR 0 7
120046: ARRAY
120047: PPUSH
120048: CALL_OW 264
120052: PUSH
120053: LD_INT 28
120055: PUSH
120056: LD_INT 45
120058: PUSH
120059: LD_INT 7
120061: PUSH
120062: LD_INT 47
120064: PUSH
120065: EMPTY
120066: LIST
120067: LIST
120068: LIST
120069: LIST
120070: IN
120071: OR
120072: IFFALSE 120328
// begin attacking := false ;
120074: LD_ADDR_VAR 0 29
120078: PUSH
120079: LD_INT 0
120081: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
120082: LD_VAR 0 14
120086: PUSH
120087: LD_INT 1
120089: ARRAY
120090: PPUSH
120091: CALL_OW 266
120095: PUSH
120096: LD_INT 32
120098: PUSH
120099: LD_INT 31
120101: PUSH
120102: LD_INT 33
120104: PUSH
120105: LD_INT 4
120107: PUSH
120108: LD_INT 5
120110: PUSH
120111: EMPTY
120112: LIST
120113: LIST
120114: LIST
120115: LIST
120116: LIST
120117: IN
120118: IFFALSE 120304
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
120120: LD_ADDR_VAR 0 9
120124: PUSH
120125: LD_VAR 0 14
120129: PUSH
120130: LD_INT 1
120132: ARRAY
120133: PPUSH
120134: CALL_OW 266
120138: PPUSH
120139: LD_VAR 0 14
120143: PUSH
120144: LD_INT 1
120146: ARRAY
120147: PPUSH
120148: CALL_OW 250
120152: PPUSH
120153: LD_VAR 0 14
120157: PUSH
120158: LD_INT 1
120160: ARRAY
120161: PPUSH
120162: CALL_OW 251
120166: PPUSH
120167: LD_VAR 0 14
120171: PUSH
120172: LD_INT 1
120174: ARRAY
120175: PPUSH
120176: CALL_OW 254
120180: PPUSH
120181: LD_VAR 0 14
120185: PUSH
120186: LD_INT 1
120188: ARRAY
120189: PPUSH
120190: CALL_OW 248
120194: PPUSH
120195: LD_INT 0
120197: PPUSH
120198: CALL 67885 0 6
120202: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
120203: LD_ADDR_VAR 0 8
120207: PUSH
120208: LD_VAR 0 4
120212: PUSH
120213: LD_VAR 0 7
120217: ARRAY
120218: PPUSH
120219: LD_VAR 0 9
120223: PPUSH
120224: CALL 86628 0 2
120228: ST_TO_ADDR
// if j then
120229: LD_VAR 0 8
120233: IFFALSE 120302
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
120235: LD_VAR 0 8
120239: PUSH
120240: LD_INT 1
120242: ARRAY
120243: PPUSH
120244: LD_VAR 0 8
120248: PUSH
120249: LD_INT 2
120251: ARRAY
120252: PPUSH
120253: CALL_OW 488
120257: IFFALSE 120302
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
120259: LD_VAR 0 4
120263: PUSH
120264: LD_VAR 0 7
120268: ARRAY
120269: PPUSH
120270: LD_VAR 0 8
120274: PUSH
120275: LD_INT 1
120277: ARRAY
120278: PPUSH
120279: LD_VAR 0 8
120283: PUSH
120284: LD_INT 2
120286: ARRAY
120287: PPUSH
120288: CALL_OW 116
// attacking := true ;
120292: LD_ADDR_VAR 0 29
120296: PUSH
120297: LD_INT 1
120299: ST_TO_ADDR
// continue ;
120300: GO 117675
// end ; end else
120302: GO 120328
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120304: LD_VAR 0 4
120308: PUSH
120309: LD_VAR 0 7
120313: ARRAY
120314: PPUSH
120315: LD_VAR 0 14
120319: PUSH
120320: LD_INT 1
120322: ARRAY
120323: PPUSH
120324: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
120328: LD_VAR 0 4
120332: PUSH
120333: LD_VAR 0 7
120337: ARRAY
120338: PPUSH
120339: CALL_OW 265
120343: PUSH
120344: LD_INT 11
120346: EQUAL
120347: IFFALSE 120625
// begin k := 10 ;
120349: LD_ADDR_VAR 0 9
120353: PUSH
120354: LD_INT 10
120356: ST_TO_ADDR
// x := 0 ;
120357: LD_ADDR_VAR 0 10
120361: PUSH
120362: LD_INT 0
120364: ST_TO_ADDR
// if tmp < k then
120365: LD_VAR 0 14
120369: PUSH
120370: LD_VAR 0 9
120374: LESS
120375: IFFALSE 120387
// k := tmp ;
120377: LD_ADDR_VAR 0 9
120381: PUSH
120382: LD_VAR 0 14
120386: ST_TO_ADDR
// for j = k downto 1 do
120387: LD_ADDR_VAR 0 8
120391: PUSH
120392: DOUBLE
120393: LD_VAR 0 9
120397: INC
120398: ST_TO_ADDR
120399: LD_INT 1
120401: PUSH
120402: FOR_DOWNTO
120403: IFFALSE 120478
// begin if GetType ( tmp [ j ] ) = unit_human then
120405: LD_VAR 0 14
120409: PUSH
120410: LD_VAR 0 8
120414: ARRAY
120415: PPUSH
120416: CALL_OW 247
120420: PUSH
120421: LD_INT 1
120423: EQUAL
120424: IFFALSE 120476
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120426: LD_VAR 0 4
120430: PUSH
120431: LD_VAR 0 7
120435: ARRAY
120436: PPUSH
120437: LD_VAR 0 14
120441: PUSH
120442: LD_VAR 0 8
120446: ARRAY
120447: PPUSH
120448: CALL 86882 0 2
// x := tmp [ j ] ;
120452: LD_ADDR_VAR 0 10
120456: PUSH
120457: LD_VAR 0 14
120461: PUSH
120462: LD_VAR 0 8
120466: ARRAY
120467: ST_TO_ADDR
// attacking := true ;
120468: LD_ADDR_VAR 0 29
120472: PUSH
120473: LD_INT 1
120475: ST_TO_ADDR
// end ; end ;
120476: GO 120402
120478: POP
120479: POP
// if not x then
120480: LD_VAR 0 10
120484: NOT
120485: IFFALSE 120625
// begin attacking := true ;
120487: LD_ADDR_VAR 0 29
120491: PUSH
120492: LD_INT 1
120494: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120495: LD_VAR 0 4
120499: PUSH
120500: LD_VAR 0 7
120504: ARRAY
120505: PPUSH
120506: CALL_OW 250
120510: PPUSH
120511: LD_VAR 0 4
120515: PUSH
120516: LD_VAR 0 7
120520: ARRAY
120521: PPUSH
120522: CALL_OW 251
120526: PPUSH
120527: CALL_OW 546
120531: PUSH
120532: LD_INT 2
120534: ARRAY
120535: PUSH
120536: LD_VAR 0 14
120540: PUSH
120541: LD_INT 1
120543: ARRAY
120544: PPUSH
120545: CALL_OW 250
120549: PPUSH
120550: LD_VAR 0 14
120554: PUSH
120555: LD_INT 1
120557: ARRAY
120558: PPUSH
120559: CALL_OW 251
120563: PPUSH
120564: CALL_OW 546
120568: PUSH
120569: LD_INT 2
120571: ARRAY
120572: EQUAL
120573: IFFALSE 120601
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
120575: LD_VAR 0 4
120579: PUSH
120580: LD_VAR 0 7
120584: ARRAY
120585: PPUSH
120586: LD_VAR 0 14
120590: PUSH
120591: LD_INT 1
120593: ARRAY
120594: PPUSH
120595: CALL 86882 0 2
120599: GO 120625
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120601: LD_VAR 0 4
120605: PUSH
120606: LD_VAR 0 7
120610: ARRAY
120611: PPUSH
120612: LD_VAR 0 14
120616: PUSH
120617: LD_INT 1
120619: ARRAY
120620: PPUSH
120621: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
120625: LD_VAR 0 4
120629: PUSH
120630: LD_VAR 0 7
120634: ARRAY
120635: PPUSH
120636: CALL_OW 264
120640: PUSH
120641: LD_INT 29
120643: EQUAL
120644: IFFALSE 121010
// begin if WantsToAttack ( group [ i ] ) in bombed then
120646: LD_VAR 0 4
120650: PUSH
120651: LD_VAR 0 7
120655: ARRAY
120656: PPUSH
120657: CALL_OW 319
120661: PUSH
120662: LD_VAR 0 28
120666: IN
120667: IFFALSE 120671
// continue ;
120669: GO 117675
// k := 8 ;
120671: LD_ADDR_VAR 0 9
120675: PUSH
120676: LD_INT 8
120678: ST_TO_ADDR
// x := 0 ;
120679: LD_ADDR_VAR 0 10
120683: PUSH
120684: LD_INT 0
120686: ST_TO_ADDR
// if tmp < k then
120687: LD_VAR 0 14
120691: PUSH
120692: LD_VAR 0 9
120696: LESS
120697: IFFALSE 120709
// k := tmp ;
120699: LD_ADDR_VAR 0 9
120703: PUSH
120704: LD_VAR 0 14
120708: ST_TO_ADDR
// for j = 1 to k do
120709: LD_ADDR_VAR 0 8
120713: PUSH
120714: DOUBLE
120715: LD_INT 1
120717: DEC
120718: ST_TO_ADDR
120719: LD_VAR 0 9
120723: PUSH
120724: FOR_TO
120725: IFFALSE 120857
// begin if GetType ( tmp [ j ] ) = unit_building then
120727: LD_VAR 0 14
120731: PUSH
120732: LD_VAR 0 8
120736: ARRAY
120737: PPUSH
120738: CALL_OW 247
120742: PUSH
120743: LD_INT 3
120745: EQUAL
120746: IFFALSE 120855
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120748: LD_VAR 0 14
120752: PUSH
120753: LD_VAR 0 8
120757: ARRAY
120758: PUSH
120759: LD_VAR 0 28
120763: IN
120764: NOT
120765: PUSH
120766: LD_VAR 0 14
120770: PUSH
120771: LD_VAR 0 8
120775: ARRAY
120776: PPUSH
120777: CALL_OW 313
120781: AND
120782: IFFALSE 120855
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120784: LD_VAR 0 4
120788: PUSH
120789: LD_VAR 0 7
120793: ARRAY
120794: PPUSH
120795: LD_VAR 0 14
120799: PUSH
120800: LD_VAR 0 8
120804: ARRAY
120805: PPUSH
120806: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120810: LD_ADDR_VAR 0 28
120814: PUSH
120815: LD_VAR 0 28
120819: PPUSH
120820: LD_VAR 0 28
120824: PUSH
120825: LD_INT 1
120827: PLUS
120828: PPUSH
120829: LD_VAR 0 14
120833: PUSH
120834: LD_VAR 0 8
120838: ARRAY
120839: PPUSH
120840: CALL_OW 1
120844: ST_TO_ADDR
// attacking := true ;
120845: LD_ADDR_VAR 0 29
120849: PUSH
120850: LD_INT 1
120852: ST_TO_ADDR
// break ;
120853: GO 120857
// end ; end ;
120855: GO 120724
120857: POP
120858: POP
// if not attacking and f_attack_depot then
120859: LD_VAR 0 29
120863: NOT
120864: PUSH
120865: LD_VAR 0 25
120869: AND
120870: IFFALSE 120965
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120872: LD_ADDR_VAR 0 13
120876: PUSH
120877: LD_VAR 0 14
120881: PPUSH
120882: LD_INT 2
120884: PUSH
120885: LD_INT 30
120887: PUSH
120888: LD_INT 0
120890: PUSH
120891: EMPTY
120892: LIST
120893: LIST
120894: PUSH
120895: LD_INT 30
120897: PUSH
120898: LD_INT 1
120900: PUSH
120901: EMPTY
120902: LIST
120903: LIST
120904: PUSH
120905: EMPTY
120906: LIST
120907: LIST
120908: LIST
120909: PPUSH
120910: CALL_OW 72
120914: ST_TO_ADDR
// if z then
120915: LD_VAR 0 13
120919: IFFALSE 120965
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120921: LD_VAR 0 4
120925: PUSH
120926: LD_VAR 0 7
120930: ARRAY
120931: PPUSH
120932: LD_VAR 0 13
120936: PPUSH
120937: LD_VAR 0 4
120941: PUSH
120942: LD_VAR 0 7
120946: ARRAY
120947: PPUSH
120948: CALL_OW 74
120952: PPUSH
120953: CALL_OW 115
// attacking := true ;
120957: LD_ADDR_VAR 0 29
120961: PUSH
120962: LD_INT 1
120964: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120965: LD_VAR 0 4
120969: PUSH
120970: LD_VAR 0 7
120974: ARRAY
120975: PPUSH
120976: CALL_OW 256
120980: PUSH
120981: LD_INT 500
120983: LESS
120984: IFFALSE 121010
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120986: LD_VAR 0 4
120990: PUSH
120991: LD_VAR 0 7
120995: ARRAY
120996: PPUSH
120997: LD_VAR 0 14
121001: PUSH
121002: LD_INT 1
121004: ARRAY
121005: PPUSH
121006: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
121010: LD_VAR 0 4
121014: PUSH
121015: LD_VAR 0 7
121019: ARRAY
121020: PPUSH
121021: CALL_OW 264
121025: PUSH
121026: LD_INT 49
121028: EQUAL
121029: IFFALSE 121150
// begin if not HasTask ( group [ i ] ) then
121031: LD_VAR 0 4
121035: PUSH
121036: LD_VAR 0 7
121040: ARRAY
121041: PPUSH
121042: CALL_OW 314
121046: NOT
121047: IFFALSE 121150
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
121049: LD_ADDR_VAR 0 9
121053: PUSH
121054: LD_INT 81
121056: PUSH
121057: LD_VAR 0 4
121061: PUSH
121062: LD_VAR 0 7
121066: ARRAY
121067: PPUSH
121068: CALL_OW 255
121072: PUSH
121073: EMPTY
121074: LIST
121075: LIST
121076: PPUSH
121077: CALL_OW 69
121081: PPUSH
121082: LD_VAR 0 4
121086: PUSH
121087: LD_VAR 0 7
121091: ARRAY
121092: PPUSH
121093: CALL_OW 74
121097: ST_TO_ADDR
// if k then
121098: LD_VAR 0 9
121102: IFFALSE 121150
// if GetDistUnits ( group [ i ] , k ) > 10 then
121104: LD_VAR 0 4
121108: PUSH
121109: LD_VAR 0 7
121113: ARRAY
121114: PPUSH
121115: LD_VAR 0 9
121119: PPUSH
121120: CALL_OW 296
121124: PUSH
121125: LD_INT 10
121127: GREATER
121128: IFFALSE 121150
// ComMoveUnit ( group [ i ] , k ) ;
121130: LD_VAR 0 4
121134: PUSH
121135: LD_VAR 0 7
121139: ARRAY
121140: PPUSH
121141: LD_VAR 0 9
121145: PPUSH
121146: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
121150: LD_VAR 0 4
121154: PUSH
121155: LD_VAR 0 7
121159: ARRAY
121160: PPUSH
121161: CALL_OW 256
121165: PUSH
121166: LD_INT 250
121168: LESS
121169: PUSH
121170: LD_VAR 0 4
121174: PUSH
121175: LD_VAR 0 7
121179: ARRAY
121180: PUSH
121181: LD_INT 21
121183: PUSH
121184: LD_INT 2
121186: PUSH
121187: EMPTY
121188: LIST
121189: LIST
121190: PUSH
121191: LD_INT 23
121193: PUSH
121194: LD_INT 2
121196: PUSH
121197: EMPTY
121198: LIST
121199: LIST
121200: PUSH
121201: EMPTY
121202: LIST
121203: LIST
121204: PPUSH
121205: CALL_OW 69
121209: IN
121210: AND
121211: IFFALSE 121336
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
121213: LD_ADDR_VAR 0 9
121217: PUSH
121218: LD_OWVAR 3
121222: PUSH
121223: LD_VAR 0 4
121227: PUSH
121228: LD_VAR 0 7
121232: ARRAY
121233: DIFF
121234: PPUSH
121235: LD_VAR 0 4
121239: PUSH
121240: LD_VAR 0 7
121244: ARRAY
121245: PPUSH
121246: CALL_OW 74
121250: ST_TO_ADDR
// if not k then
121251: LD_VAR 0 9
121255: NOT
121256: IFFALSE 121260
// continue ;
121258: GO 117675
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
121260: LD_VAR 0 9
121264: PUSH
121265: LD_INT 81
121267: PUSH
121268: LD_VAR 0 4
121272: PUSH
121273: LD_VAR 0 7
121277: ARRAY
121278: PPUSH
121279: CALL_OW 255
121283: PUSH
121284: EMPTY
121285: LIST
121286: LIST
121287: PPUSH
121288: CALL_OW 69
121292: IN
121293: PUSH
121294: LD_VAR 0 9
121298: PPUSH
121299: LD_VAR 0 4
121303: PUSH
121304: LD_VAR 0 7
121308: ARRAY
121309: PPUSH
121310: CALL_OW 296
121314: PUSH
121315: LD_INT 5
121317: LESS
121318: AND
121319: IFFALSE 121336
// ComAutodestruct ( group [ i ] ) ;
121321: LD_VAR 0 4
121325: PUSH
121326: LD_VAR 0 7
121330: ARRAY
121331: PPUSH
121332: CALL 86780 0 1
// end ; if f_attack_depot then
121336: LD_VAR 0 25
121340: IFFALSE 121452
// begin k := 6 ;
121342: LD_ADDR_VAR 0 9
121346: PUSH
121347: LD_INT 6
121349: ST_TO_ADDR
// if tmp < k then
121350: LD_VAR 0 14
121354: PUSH
121355: LD_VAR 0 9
121359: LESS
121360: IFFALSE 121372
// k := tmp ;
121362: LD_ADDR_VAR 0 9
121366: PUSH
121367: LD_VAR 0 14
121371: ST_TO_ADDR
// for j = 1 to k do
121372: LD_ADDR_VAR 0 8
121376: PUSH
121377: DOUBLE
121378: LD_INT 1
121380: DEC
121381: ST_TO_ADDR
121382: LD_VAR 0 9
121386: PUSH
121387: FOR_TO
121388: IFFALSE 121450
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121390: LD_VAR 0 8
121394: PPUSH
121395: CALL_OW 266
121399: PUSH
121400: LD_INT 0
121402: PUSH
121403: LD_INT 1
121405: PUSH
121406: EMPTY
121407: LIST
121408: LIST
121409: IN
121410: IFFALSE 121448
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121412: LD_VAR 0 4
121416: PUSH
121417: LD_VAR 0 7
121421: ARRAY
121422: PPUSH
121423: LD_VAR 0 14
121427: PUSH
121428: LD_VAR 0 8
121432: ARRAY
121433: PPUSH
121434: CALL_OW 115
// attacking := true ;
121438: LD_ADDR_VAR 0 29
121442: PUSH
121443: LD_INT 1
121445: ST_TO_ADDR
// break ;
121446: GO 121450
// end ;
121448: GO 121387
121450: POP
121451: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121452: LD_VAR 0 4
121456: PUSH
121457: LD_VAR 0 7
121461: ARRAY
121462: PPUSH
121463: CALL_OW 302
121467: PUSH
121468: LD_VAR 0 29
121472: NOT
121473: AND
121474: IFFALSE 121796
// begin if GetTag ( group [ i ] ) = 71 then
121476: LD_VAR 0 4
121480: PUSH
121481: LD_VAR 0 7
121485: ARRAY
121486: PPUSH
121487: CALL_OW 110
121491: PUSH
121492: LD_INT 71
121494: EQUAL
121495: IFFALSE 121536
// begin if HasTask ( group [ i ] ) then
121497: LD_VAR 0 4
121501: PUSH
121502: LD_VAR 0 7
121506: ARRAY
121507: PPUSH
121508: CALL_OW 314
121512: IFFALSE 121518
// continue else
121514: GO 117675
121516: GO 121536
// SetTag ( group [ i ] , 0 ) ;
121518: LD_VAR 0 4
121522: PUSH
121523: LD_VAR 0 7
121527: ARRAY
121528: PPUSH
121529: LD_INT 0
121531: PPUSH
121532: CALL_OW 109
// end ; k := 8 ;
121536: LD_ADDR_VAR 0 9
121540: PUSH
121541: LD_INT 8
121543: ST_TO_ADDR
// x := 0 ;
121544: LD_ADDR_VAR 0 10
121548: PUSH
121549: LD_INT 0
121551: ST_TO_ADDR
// if tmp < k then
121552: LD_VAR 0 14
121556: PUSH
121557: LD_VAR 0 9
121561: LESS
121562: IFFALSE 121574
// k := tmp ;
121564: LD_ADDR_VAR 0 9
121568: PUSH
121569: LD_VAR 0 14
121573: ST_TO_ADDR
// for j = 1 to k do
121574: LD_ADDR_VAR 0 8
121578: PUSH
121579: DOUBLE
121580: LD_INT 1
121582: DEC
121583: ST_TO_ADDR
121584: LD_VAR 0 9
121588: PUSH
121589: FOR_TO
121590: IFFALSE 121688
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
121592: LD_VAR 0 14
121596: PUSH
121597: LD_VAR 0 8
121601: ARRAY
121602: PPUSH
121603: CALL_OW 247
121607: PUSH
121608: LD_INT 1
121610: EQUAL
121611: PUSH
121612: LD_VAR 0 14
121616: PUSH
121617: LD_VAR 0 8
121621: ARRAY
121622: PPUSH
121623: CALL_OW 256
121627: PUSH
121628: LD_INT 250
121630: LESS
121631: PUSH
121632: LD_VAR 0 20
121636: AND
121637: PUSH
121638: LD_VAR 0 20
121642: NOT
121643: PUSH
121644: LD_VAR 0 14
121648: PUSH
121649: LD_VAR 0 8
121653: ARRAY
121654: PPUSH
121655: CALL_OW 256
121659: PUSH
121660: LD_INT 250
121662: GREATEREQUAL
121663: AND
121664: OR
121665: AND
121666: IFFALSE 121686
// begin x := tmp [ j ] ;
121668: LD_ADDR_VAR 0 10
121672: PUSH
121673: LD_VAR 0 14
121677: PUSH
121678: LD_VAR 0 8
121682: ARRAY
121683: ST_TO_ADDR
// break ;
121684: GO 121688
// end ;
121686: GO 121589
121688: POP
121689: POP
// if x then
121690: LD_VAR 0 10
121694: IFFALSE 121718
// ComAttackUnit ( group [ i ] , x ) else
121696: LD_VAR 0 4
121700: PUSH
121701: LD_VAR 0 7
121705: ARRAY
121706: PPUSH
121707: LD_VAR 0 10
121711: PPUSH
121712: CALL_OW 115
121716: GO 121742
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121718: LD_VAR 0 4
121722: PUSH
121723: LD_VAR 0 7
121727: ARRAY
121728: PPUSH
121729: LD_VAR 0 14
121733: PUSH
121734: LD_INT 1
121736: ARRAY
121737: PPUSH
121738: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121742: LD_VAR 0 4
121746: PUSH
121747: LD_VAR 0 7
121751: ARRAY
121752: PPUSH
121753: CALL_OW 314
121757: NOT
121758: IFFALSE 121796
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121760: LD_VAR 0 4
121764: PUSH
121765: LD_VAR 0 7
121769: ARRAY
121770: PPUSH
121771: LD_VAR 0 14
121775: PPUSH
121776: LD_VAR 0 4
121780: PUSH
121781: LD_VAR 0 7
121785: ARRAY
121786: PPUSH
121787: CALL_OW 74
121791: PPUSH
121792: CALL_OW 115
// end ; end ; end ;
121796: GO 117675
121798: POP
121799: POP
// wait ( 0 0$2 ) ;
121800: LD_INT 70
121802: PPUSH
121803: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121807: LD_VAR 0 4
121811: NOT
121812: PUSH
121813: LD_VAR 0 4
121817: PUSH
121818: EMPTY
121819: EQUAL
121820: OR
121821: PUSH
121822: LD_INT 81
121824: PUSH
121825: LD_VAR 0 35
121829: PUSH
121830: EMPTY
121831: LIST
121832: LIST
121833: PPUSH
121834: CALL_OW 69
121838: NOT
121839: OR
121840: IFFALSE 117660
// end ;
121842: LD_VAR 0 2
121846: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
121847: LD_INT 0
121849: PPUSH
121850: PPUSH
121851: PPUSH
121852: PPUSH
121853: PPUSH
121854: PPUSH
// if not base or not mc_bases [ base ] or not solds then
121855: LD_VAR 0 1
121859: NOT
121860: PUSH
121861: LD_EXP 80
121865: PUSH
121866: LD_VAR 0 1
121870: ARRAY
121871: NOT
121872: OR
121873: PUSH
121874: LD_VAR 0 2
121878: NOT
121879: OR
121880: IFFALSE 121884
// exit ;
121882: GO 122438
// side := mc_sides [ base ] ;
121884: LD_ADDR_VAR 0 6
121888: PUSH
121889: LD_EXP 106
121893: PUSH
121894: LD_VAR 0 1
121898: ARRAY
121899: ST_TO_ADDR
// if not side then
121900: LD_VAR 0 6
121904: NOT
121905: IFFALSE 121909
// exit ;
121907: GO 122438
// for i in solds do
121909: LD_ADDR_VAR 0 7
121913: PUSH
121914: LD_VAR 0 2
121918: PUSH
121919: FOR_IN
121920: IFFALSE 121981
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121922: LD_VAR 0 7
121926: PPUSH
121927: CALL_OW 310
121931: PPUSH
121932: CALL_OW 266
121936: PUSH
121937: LD_INT 32
121939: PUSH
121940: LD_INT 31
121942: PUSH
121943: EMPTY
121944: LIST
121945: LIST
121946: IN
121947: IFFALSE 121967
// solds := solds diff i else
121949: LD_ADDR_VAR 0 2
121953: PUSH
121954: LD_VAR 0 2
121958: PUSH
121959: LD_VAR 0 7
121963: DIFF
121964: ST_TO_ADDR
121965: GO 121979
// SetTag ( i , 18 ) ;
121967: LD_VAR 0 7
121971: PPUSH
121972: LD_INT 18
121974: PPUSH
121975: CALL_OW 109
121979: GO 121919
121981: POP
121982: POP
// if not solds then
121983: LD_VAR 0 2
121987: NOT
121988: IFFALSE 121992
// exit ;
121990: GO 122438
// repeat wait ( 0 0$2 ) ;
121992: LD_INT 70
121994: PPUSH
121995: CALL_OW 67
// enemy := mc_scan [ base ] ;
121999: LD_ADDR_VAR 0 4
122003: PUSH
122004: LD_EXP 103
122008: PUSH
122009: LD_VAR 0 1
122013: ARRAY
122014: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122015: LD_EXP 80
122019: PUSH
122020: LD_VAR 0 1
122024: ARRAY
122025: NOT
122026: PUSH
122027: LD_EXP 80
122031: PUSH
122032: LD_VAR 0 1
122036: ARRAY
122037: PUSH
122038: EMPTY
122039: EQUAL
122040: OR
122041: IFFALSE 122078
// begin for i in solds do
122043: LD_ADDR_VAR 0 7
122047: PUSH
122048: LD_VAR 0 2
122052: PUSH
122053: FOR_IN
122054: IFFALSE 122067
// ComStop ( i ) ;
122056: LD_VAR 0 7
122060: PPUSH
122061: CALL_OW 141
122065: GO 122053
122067: POP
122068: POP
// solds := [ ] ;
122069: LD_ADDR_VAR 0 2
122073: PUSH
122074: EMPTY
122075: ST_TO_ADDR
// exit ;
122076: GO 122438
// end ; for i in solds do
122078: LD_ADDR_VAR 0 7
122082: PUSH
122083: LD_VAR 0 2
122087: PUSH
122088: FOR_IN
122089: IFFALSE 122410
// begin if IsInUnit ( i ) then
122091: LD_VAR 0 7
122095: PPUSH
122096: CALL_OW 310
122100: IFFALSE 122111
// ComExitBuilding ( i ) ;
122102: LD_VAR 0 7
122106: PPUSH
122107: CALL_OW 122
// if GetLives ( i ) > 500 then
122111: LD_VAR 0 7
122115: PPUSH
122116: CALL_OW 256
122120: PUSH
122121: LD_INT 500
122123: GREATER
122124: IFFALSE 122177
// begin e := NearestUnitToUnit ( enemy , i ) ;
122126: LD_ADDR_VAR 0 5
122130: PUSH
122131: LD_VAR 0 4
122135: PPUSH
122136: LD_VAR 0 7
122140: PPUSH
122141: CALL_OW 74
122145: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
122146: LD_VAR 0 7
122150: PPUSH
122151: LD_VAR 0 5
122155: PPUSH
122156: CALL_OW 250
122160: PPUSH
122161: LD_VAR 0 5
122165: PPUSH
122166: CALL_OW 251
122170: PPUSH
122171: CALL_OW 114
// end else
122175: GO 122408
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
122177: LD_VAR 0 7
122181: PPUSH
122182: LD_EXP 80
122186: PUSH
122187: LD_VAR 0 1
122191: ARRAY
122192: PPUSH
122193: LD_INT 2
122195: PUSH
122196: LD_INT 30
122198: PUSH
122199: LD_INT 0
122201: PUSH
122202: EMPTY
122203: LIST
122204: LIST
122205: PUSH
122206: LD_INT 30
122208: PUSH
122209: LD_INT 1
122211: PUSH
122212: EMPTY
122213: LIST
122214: LIST
122215: PUSH
122216: LD_INT 30
122218: PUSH
122219: LD_INT 6
122221: PUSH
122222: EMPTY
122223: LIST
122224: LIST
122225: PUSH
122226: EMPTY
122227: LIST
122228: LIST
122229: LIST
122230: LIST
122231: PPUSH
122232: CALL_OW 72
122236: PPUSH
122237: LD_VAR 0 7
122241: PPUSH
122242: CALL_OW 74
122246: PPUSH
122247: CALL_OW 296
122251: PUSH
122252: LD_INT 10
122254: GREATER
122255: IFFALSE 122408
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
122257: LD_ADDR_VAR 0 8
122261: PUSH
122262: LD_EXP 80
122266: PUSH
122267: LD_VAR 0 1
122271: ARRAY
122272: PPUSH
122273: LD_INT 2
122275: PUSH
122276: LD_INT 30
122278: PUSH
122279: LD_INT 0
122281: PUSH
122282: EMPTY
122283: LIST
122284: LIST
122285: PUSH
122286: LD_INT 30
122288: PUSH
122289: LD_INT 1
122291: PUSH
122292: EMPTY
122293: LIST
122294: LIST
122295: PUSH
122296: LD_INT 30
122298: PUSH
122299: LD_INT 6
122301: PUSH
122302: EMPTY
122303: LIST
122304: LIST
122305: PUSH
122306: EMPTY
122307: LIST
122308: LIST
122309: LIST
122310: LIST
122311: PPUSH
122312: CALL_OW 72
122316: PPUSH
122317: LD_VAR 0 7
122321: PPUSH
122322: CALL_OW 74
122326: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
122327: LD_VAR 0 7
122331: PPUSH
122332: LD_VAR 0 8
122336: PPUSH
122337: CALL_OW 250
122341: PPUSH
122342: LD_INT 3
122344: PPUSH
122345: LD_INT 5
122347: PPUSH
122348: CALL_OW 272
122352: PPUSH
122353: LD_VAR 0 8
122357: PPUSH
122358: CALL_OW 251
122362: PPUSH
122363: LD_INT 3
122365: PPUSH
122366: LD_INT 5
122368: PPUSH
122369: CALL_OW 273
122373: PPUSH
122374: CALL_OW 111
// SetTag ( i , 0 ) ;
122378: LD_VAR 0 7
122382: PPUSH
122383: LD_INT 0
122385: PPUSH
122386: CALL_OW 109
// solds := solds diff i ;
122390: LD_ADDR_VAR 0 2
122394: PUSH
122395: LD_VAR 0 2
122399: PUSH
122400: LD_VAR 0 7
122404: DIFF
122405: ST_TO_ADDR
// continue ;
122406: GO 122088
// end ; end ;
122408: GO 122088
122410: POP
122411: POP
// until not solds or not enemy ;
122412: LD_VAR 0 2
122416: NOT
122417: PUSH
122418: LD_VAR 0 4
122422: NOT
122423: OR
122424: IFFALSE 121992
// MC_Reset ( base , 18 ) ;
122426: LD_VAR 0 1
122430: PPUSH
122431: LD_INT 18
122433: PPUSH
122434: CALL 27038 0 2
// end ;
122438: LD_VAR 0 3
122442: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122443: LD_INT 0
122445: PPUSH
122446: PPUSH
122447: PPUSH
122448: PPUSH
122449: PPUSH
122450: PPUSH
122451: PPUSH
122452: PPUSH
122453: PPUSH
122454: PPUSH
122455: PPUSH
122456: PPUSH
122457: PPUSH
122458: PPUSH
122459: PPUSH
122460: PPUSH
122461: PPUSH
122462: PPUSH
122463: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122464: LD_ADDR_VAR 0 12
122468: PUSH
122469: LD_EXP 80
122473: PUSH
122474: LD_VAR 0 1
122478: ARRAY
122479: PPUSH
122480: LD_INT 25
122482: PUSH
122483: LD_INT 3
122485: PUSH
122486: EMPTY
122487: LIST
122488: LIST
122489: PPUSH
122490: CALL_OW 72
122494: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122495: LD_EXP 120
122499: PUSH
122500: LD_VAR 0 1
122504: ARRAY
122505: IFFALSE 122529
// mechs := mechs diff mc_remote_driver [ base ] ;
122507: LD_ADDR_VAR 0 12
122511: PUSH
122512: LD_VAR 0 12
122516: PUSH
122517: LD_EXP 120
122521: PUSH
122522: LD_VAR 0 1
122526: ARRAY
122527: DIFF
122528: ST_TO_ADDR
// for i in mechs do
122529: LD_ADDR_VAR 0 4
122533: PUSH
122534: LD_VAR 0 12
122538: PUSH
122539: FOR_IN
122540: IFFALSE 122575
// if GetTag ( i ) > 0 then
122542: LD_VAR 0 4
122546: PPUSH
122547: CALL_OW 110
122551: PUSH
122552: LD_INT 0
122554: GREATER
122555: IFFALSE 122573
// mechs := mechs diff i ;
122557: LD_ADDR_VAR 0 12
122561: PUSH
122562: LD_VAR 0 12
122566: PUSH
122567: LD_VAR 0 4
122571: DIFF
122572: ST_TO_ADDR
122573: GO 122539
122575: POP
122576: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122577: LD_ADDR_VAR 0 8
122581: PUSH
122582: LD_EXP 80
122586: PUSH
122587: LD_VAR 0 1
122591: ARRAY
122592: PPUSH
122593: LD_INT 2
122595: PUSH
122596: LD_INT 25
122598: PUSH
122599: LD_INT 1
122601: PUSH
122602: EMPTY
122603: LIST
122604: LIST
122605: PUSH
122606: LD_INT 25
122608: PUSH
122609: LD_INT 5
122611: PUSH
122612: EMPTY
122613: LIST
122614: LIST
122615: PUSH
122616: LD_INT 25
122618: PUSH
122619: LD_INT 8
122621: PUSH
122622: EMPTY
122623: LIST
122624: LIST
122625: PUSH
122626: LD_INT 25
122628: PUSH
122629: LD_INT 9
122631: PUSH
122632: EMPTY
122633: LIST
122634: LIST
122635: PUSH
122636: EMPTY
122637: LIST
122638: LIST
122639: LIST
122640: LIST
122641: LIST
122642: PPUSH
122643: CALL_OW 72
122647: ST_TO_ADDR
// if not defenders and not solds then
122648: LD_VAR 0 2
122652: NOT
122653: PUSH
122654: LD_VAR 0 8
122658: NOT
122659: AND
122660: IFFALSE 122664
// exit ;
122662: GO 124434
// depot_under_attack := false ;
122664: LD_ADDR_VAR 0 16
122668: PUSH
122669: LD_INT 0
122671: ST_TO_ADDR
// sold_defenders := [ ] ;
122672: LD_ADDR_VAR 0 17
122676: PUSH
122677: EMPTY
122678: ST_TO_ADDR
// if mechs then
122679: LD_VAR 0 12
122683: IFFALSE 122836
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
122685: LD_ADDR_VAR 0 4
122689: PUSH
122690: LD_VAR 0 2
122694: PPUSH
122695: LD_INT 21
122697: PUSH
122698: LD_INT 2
122700: PUSH
122701: EMPTY
122702: LIST
122703: LIST
122704: PPUSH
122705: CALL_OW 72
122709: PUSH
122710: FOR_IN
122711: IFFALSE 122834
// begin if GetTag ( i ) <> 20 then
122713: LD_VAR 0 4
122717: PPUSH
122718: CALL_OW 110
122722: PUSH
122723: LD_INT 20
122725: NONEQUAL
122726: IFFALSE 122740
// SetTag ( i , 20 ) ;
122728: LD_VAR 0 4
122732: PPUSH
122733: LD_INT 20
122735: PPUSH
122736: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
122740: LD_VAR 0 4
122744: PPUSH
122745: CALL_OW 263
122749: PUSH
122750: LD_INT 1
122752: EQUAL
122753: PUSH
122754: LD_VAR 0 4
122758: PPUSH
122759: CALL_OW 311
122763: NOT
122764: AND
122765: IFFALSE 122832
// begin un := mechs [ 1 ] ;
122767: LD_ADDR_VAR 0 10
122771: PUSH
122772: LD_VAR 0 12
122776: PUSH
122777: LD_INT 1
122779: ARRAY
122780: ST_TO_ADDR
// ComExit ( un ) ;
122781: LD_VAR 0 10
122785: PPUSH
122786: CALL 91666 0 1
// AddComEnterUnit ( un , i ) ;
122790: LD_VAR 0 10
122794: PPUSH
122795: LD_VAR 0 4
122799: PPUSH
122800: CALL_OW 180
// SetTag ( un , 19 ) ;
122804: LD_VAR 0 10
122808: PPUSH
122809: LD_INT 19
122811: PPUSH
122812: CALL_OW 109
// mechs := mechs diff un ;
122816: LD_ADDR_VAR 0 12
122820: PUSH
122821: LD_VAR 0 12
122825: PUSH
122826: LD_VAR 0 10
122830: DIFF
122831: ST_TO_ADDR
// end ; end ;
122832: GO 122710
122834: POP
122835: POP
// if solds then
122836: LD_VAR 0 8
122840: IFFALSE 122899
// for i in solds do
122842: LD_ADDR_VAR 0 4
122846: PUSH
122847: LD_VAR 0 8
122851: PUSH
122852: FOR_IN
122853: IFFALSE 122897
// if not GetTag ( i ) then
122855: LD_VAR 0 4
122859: PPUSH
122860: CALL_OW 110
122864: NOT
122865: IFFALSE 122895
// begin defenders := defenders union i ;
122867: LD_ADDR_VAR 0 2
122871: PUSH
122872: LD_VAR 0 2
122876: PUSH
122877: LD_VAR 0 4
122881: UNION
122882: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122883: LD_VAR 0 4
122887: PPUSH
122888: LD_INT 18
122890: PPUSH
122891: CALL_OW 109
// end ;
122895: GO 122852
122897: POP
122898: POP
// repeat wait ( 0 0$2 ) ;
122899: LD_INT 70
122901: PPUSH
122902: CALL_OW 67
// enemy := mc_scan [ base ] ;
122906: LD_ADDR_VAR 0 21
122910: PUSH
122911: LD_EXP 103
122915: PUSH
122916: LD_VAR 0 1
122920: ARRAY
122921: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122922: LD_EXP 80
122926: PUSH
122927: LD_VAR 0 1
122931: ARRAY
122932: NOT
122933: PUSH
122934: LD_EXP 80
122938: PUSH
122939: LD_VAR 0 1
122943: ARRAY
122944: PUSH
122945: EMPTY
122946: EQUAL
122947: OR
122948: IFFALSE 122985
// begin for i in defenders do
122950: LD_ADDR_VAR 0 4
122954: PUSH
122955: LD_VAR 0 2
122959: PUSH
122960: FOR_IN
122961: IFFALSE 122974
// ComStop ( i ) ;
122963: LD_VAR 0 4
122967: PPUSH
122968: CALL_OW 141
122972: GO 122960
122974: POP
122975: POP
// defenders := [ ] ;
122976: LD_ADDR_VAR 0 2
122980: PUSH
122981: EMPTY
122982: ST_TO_ADDR
// exit ;
122983: GO 124434
// end ; for i in defenders do
122985: LD_ADDR_VAR 0 4
122989: PUSH
122990: LD_VAR 0 2
122994: PUSH
122995: FOR_IN
122996: IFFALSE 123894
// begin e := NearestUnitToUnit ( enemy , i ) ;
122998: LD_ADDR_VAR 0 13
123002: PUSH
123003: LD_VAR 0 21
123007: PPUSH
123008: LD_VAR 0 4
123012: PPUSH
123013: CALL_OW 74
123017: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123018: LD_ADDR_VAR 0 7
123022: PUSH
123023: LD_EXP 80
123027: PUSH
123028: LD_VAR 0 1
123032: ARRAY
123033: PPUSH
123034: LD_INT 2
123036: PUSH
123037: LD_INT 30
123039: PUSH
123040: LD_INT 0
123042: PUSH
123043: EMPTY
123044: LIST
123045: LIST
123046: PUSH
123047: LD_INT 30
123049: PUSH
123050: LD_INT 1
123052: PUSH
123053: EMPTY
123054: LIST
123055: LIST
123056: PUSH
123057: EMPTY
123058: LIST
123059: LIST
123060: LIST
123061: PPUSH
123062: CALL_OW 72
123066: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
123067: LD_ADDR_VAR 0 16
123071: PUSH
123072: LD_VAR 0 7
123076: NOT
123077: PUSH
123078: LD_VAR 0 7
123082: PPUSH
123083: LD_INT 3
123085: PUSH
123086: LD_INT 24
123088: PUSH
123089: LD_INT 600
123091: PUSH
123092: EMPTY
123093: LIST
123094: LIST
123095: PUSH
123096: EMPTY
123097: LIST
123098: LIST
123099: PPUSH
123100: CALL_OW 72
123104: OR
123105: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
123106: LD_VAR 0 4
123110: PPUSH
123111: CALL_OW 247
123115: PUSH
123116: LD_INT 2
123118: DOUBLE
123119: EQUAL
123120: IFTRUE 123124
123122: GO 123520
123124: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
123125: LD_VAR 0 4
123129: PPUSH
123130: CALL_OW 256
123134: PUSH
123135: LD_INT 1000
123137: EQUAL
123138: PUSH
123139: LD_VAR 0 4
123143: PPUSH
123144: LD_VAR 0 13
123148: PPUSH
123149: CALL_OW 296
123153: PUSH
123154: LD_INT 40
123156: LESS
123157: PUSH
123158: LD_VAR 0 13
123162: PPUSH
123163: LD_EXP 105
123167: PUSH
123168: LD_VAR 0 1
123172: ARRAY
123173: PPUSH
123174: CALL_OW 308
123178: OR
123179: AND
123180: IFFALSE 123302
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
123182: LD_VAR 0 4
123186: PPUSH
123187: CALL_OW 262
123191: PUSH
123192: LD_INT 1
123194: EQUAL
123195: PUSH
123196: LD_VAR 0 4
123200: PPUSH
123201: CALL_OW 261
123205: PUSH
123206: LD_INT 30
123208: LESS
123209: AND
123210: PUSH
123211: LD_VAR 0 7
123215: AND
123216: IFFALSE 123286
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
123218: LD_VAR 0 4
123222: PPUSH
123223: LD_VAR 0 7
123227: PPUSH
123228: LD_VAR 0 4
123232: PPUSH
123233: CALL_OW 74
123237: PPUSH
123238: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
123242: LD_VAR 0 4
123246: PPUSH
123247: LD_VAR 0 7
123251: PPUSH
123252: LD_VAR 0 4
123256: PPUSH
123257: CALL_OW 74
123261: PPUSH
123262: CALL_OW 296
123266: PUSH
123267: LD_INT 6
123269: LESS
123270: IFFALSE 123284
// SetFuel ( i , 100 ) ;
123272: LD_VAR 0 4
123276: PPUSH
123277: LD_INT 100
123279: PPUSH
123280: CALL_OW 240
// end else
123284: GO 123300
// ComAttackUnit ( i , e ) ;
123286: LD_VAR 0 4
123290: PPUSH
123291: LD_VAR 0 13
123295: PPUSH
123296: CALL_OW 115
// end else
123300: GO 123403
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
123302: LD_VAR 0 13
123306: PPUSH
123307: LD_EXP 105
123311: PUSH
123312: LD_VAR 0 1
123316: ARRAY
123317: PPUSH
123318: CALL_OW 308
123322: NOT
123323: PUSH
123324: LD_VAR 0 4
123328: PPUSH
123329: LD_VAR 0 13
123333: PPUSH
123334: CALL_OW 296
123338: PUSH
123339: LD_INT 40
123341: GREATEREQUAL
123342: AND
123343: PUSH
123344: LD_VAR 0 4
123348: PPUSH
123349: CALL_OW 256
123353: PUSH
123354: LD_INT 650
123356: LESSEQUAL
123357: OR
123358: PUSH
123359: LD_VAR 0 4
123363: PPUSH
123364: LD_EXP 104
123368: PUSH
123369: LD_VAR 0 1
123373: ARRAY
123374: PPUSH
123375: CALL_OW 308
123379: NOT
123380: AND
123381: IFFALSE 123403
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123383: LD_VAR 0 4
123387: PPUSH
123388: LD_EXP 104
123392: PUSH
123393: LD_VAR 0 1
123397: ARRAY
123398: PPUSH
123399: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123403: LD_VAR 0 4
123407: PPUSH
123408: CALL_OW 256
123412: PUSH
123413: LD_INT 1000
123415: LESS
123416: PUSH
123417: LD_VAR 0 4
123421: PPUSH
123422: CALL_OW 263
123426: PUSH
123427: LD_INT 1
123429: EQUAL
123430: AND
123431: PUSH
123432: LD_VAR 0 4
123436: PPUSH
123437: CALL_OW 311
123441: AND
123442: PUSH
123443: LD_VAR 0 4
123447: PPUSH
123448: LD_EXP 104
123452: PUSH
123453: LD_VAR 0 1
123457: ARRAY
123458: PPUSH
123459: CALL_OW 308
123463: AND
123464: IFFALSE 123518
// begin mech := IsDrivenBy ( i ) ;
123466: LD_ADDR_VAR 0 9
123470: PUSH
123471: LD_VAR 0 4
123475: PPUSH
123476: CALL_OW 311
123480: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123481: LD_VAR 0 9
123485: PPUSH
123486: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123490: LD_VAR 0 9
123494: PPUSH
123495: LD_VAR 0 4
123499: PPUSH
123500: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123504: LD_VAR 0 9
123508: PPUSH
123509: LD_VAR 0 4
123513: PPUSH
123514: CALL_OW 180
// end ; end ; unit_human :
123518: GO 123865
123520: LD_INT 1
123522: DOUBLE
123523: EQUAL
123524: IFTRUE 123528
123526: GO 123864
123528: POP
// begin b := IsInUnit ( i ) ;
123529: LD_ADDR_VAR 0 18
123533: PUSH
123534: LD_VAR 0 4
123538: PPUSH
123539: CALL_OW 310
123543: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
123544: LD_ADDR_VAR 0 19
123548: PUSH
123549: LD_VAR 0 18
123553: NOT
123554: PUSH
123555: LD_VAR 0 18
123559: PPUSH
123560: CALL_OW 266
123564: PUSH
123565: LD_INT 32
123567: PUSH
123568: LD_INT 31
123570: PUSH
123571: EMPTY
123572: LIST
123573: LIST
123574: IN
123575: OR
123576: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
123577: LD_VAR 0 18
123581: PPUSH
123582: CALL_OW 266
123586: PUSH
123587: LD_INT 5
123589: EQUAL
123590: PUSH
123591: LD_VAR 0 4
123595: PPUSH
123596: CALL_OW 257
123600: PUSH
123601: LD_INT 1
123603: PUSH
123604: LD_INT 2
123606: PUSH
123607: LD_INT 3
123609: PUSH
123610: LD_INT 4
123612: PUSH
123613: EMPTY
123614: LIST
123615: LIST
123616: LIST
123617: LIST
123618: IN
123619: AND
123620: IFFALSE 123657
// begin class := AllowSpecClass ( i ) ;
123622: LD_ADDR_VAR 0 20
123626: PUSH
123627: LD_VAR 0 4
123631: PPUSH
123632: CALL 55363 0 1
123636: ST_TO_ADDR
// if class then
123637: LD_VAR 0 20
123641: IFFALSE 123657
// ComChangeProfession ( i , class ) ;
123643: LD_VAR 0 4
123647: PPUSH
123648: LD_VAR 0 20
123652: PPUSH
123653: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
123657: LD_VAR 0 16
123661: PUSH
123662: LD_VAR 0 2
123666: PPUSH
123667: LD_INT 21
123669: PUSH
123670: LD_INT 2
123672: PUSH
123673: EMPTY
123674: LIST
123675: LIST
123676: PPUSH
123677: CALL_OW 72
123681: PUSH
123682: LD_INT 1
123684: LESSEQUAL
123685: OR
123686: PUSH
123687: LD_VAR 0 19
123691: AND
123692: PUSH
123693: LD_VAR 0 4
123697: PUSH
123698: LD_VAR 0 17
123702: IN
123703: NOT
123704: AND
123705: IFFALSE 123798
// begin if b then
123707: LD_VAR 0 18
123711: IFFALSE 123760
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
123713: LD_VAR 0 18
123717: PPUSH
123718: LD_VAR 0 21
123722: PPUSH
123723: LD_VAR 0 18
123727: PPUSH
123728: CALL_OW 74
123732: PPUSH
123733: CALL_OW 296
123737: PUSH
123738: LD_INT 10
123740: LESS
123741: PUSH
123742: LD_VAR 0 18
123746: PPUSH
123747: CALL_OW 461
123751: PUSH
123752: LD_INT 7
123754: NONEQUAL
123755: AND
123756: IFFALSE 123760
// continue ;
123758: GO 122995
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
123760: LD_ADDR_VAR 0 17
123764: PUSH
123765: LD_VAR 0 17
123769: PPUSH
123770: LD_VAR 0 17
123774: PUSH
123775: LD_INT 1
123777: PLUS
123778: PPUSH
123779: LD_VAR 0 4
123783: PPUSH
123784: CALL_OW 1
123788: ST_TO_ADDR
// ComExitBuilding ( i ) ;
123789: LD_VAR 0 4
123793: PPUSH
123794: CALL_OW 122
// end ; if sold_defenders then
123798: LD_VAR 0 17
123802: IFFALSE 123862
// if i in sold_defenders then
123804: LD_VAR 0 4
123808: PUSH
123809: LD_VAR 0 17
123813: IN
123814: IFFALSE 123862
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
123816: LD_VAR 0 4
123820: PPUSH
123821: CALL_OW 314
123825: NOT
123826: PUSH
123827: LD_VAR 0 4
123831: PPUSH
123832: LD_VAR 0 13
123836: PPUSH
123837: CALL_OW 296
123841: PUSH
123842: LD_INT 30
123844: LESS
123845: AND
123846: IFFALSE 123862
// ComAttackUnit ( i , e ) ;
123848: LD_VAR 0 4
123852: PPUSH
123853: LD_VAR 0 13
123857: PPUSH
123858: CALL_OW 115
// end ; end ; end ;
123862: GO 123865
123864: POP
// if IsDead ( i ) then
123865: LD_VAR 0 4
123869: PPUSH
123870: CALL_OW 301
123874: IFFALSE 123892
// defenders := defenders diff i ;
123876: LD_ADDR_VAR 0 2
123880: PUSH
123881: LD_VAR 0 2
123885: PUSH
123886: LD_VAR 0 4
123890: DIFF
123891: ST_TO_ADDR
// end ;
123892: GO 122995
123894: POP
123895: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123896: LD_VAR 0 21
123900: NOT
123901: PUSH
123902: LD_VAR 0 2
123906: NOT
123907: OR
123908: PUSH
123909: LD_EXP 80
123913: PUSH
123914: LD_VAR 0 1
123918: ARRAY
123919: NOT
123920: OR
123921: IFFALSE 122899
// MC_Reset ( base , 18 ) ;
123923: LD_VAR 0 1
123927: PPUSH
123928: LD_INT 18
123930: PPUSH
123931: CALL 27038 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123935: LD_ADDR_VAR 0 2
123939: PUSH
123940: LD_VAR 0 2
123944: PUSH
123945: LD_VAR 0 2
123949: PPUSH
123950: LD_INT 2
123952: PUSH
123953: LD_INT 25
123955: PUSH
123956: LD_INT 1
123958: PUSH
123959: EMPTY
123960: LIST
123961: LIST
123962: PUSH
123963: LD_INT 25
123965: PUSH
123966: LD_INT 5
123968: PUSH
123969: EMPTY
123970: LIST
123971: LIST
123972: PUSH
123973: LD_INT 25
123975: PUSH
123976: LD_INT 8
123978: PUSH
123979: EMPTY
123980: LIST
123981: LIST
123982: PUSH
123983: LD_INT 25
123985: PUSH
123986: LD_INT 9
123988: PUSH
123989: EMPTY
123990: LIST
123991: LIST
123992: PUSH
123993: EMPTY
123994: LIST
123995: LIST
123996: LIST
123997: LIST
123998: LIST
123999: PPUSH
124000: CALL_OW 72
124004: DIFF
124005: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
124006: LD_VAR 0 21
124010: NOT
124011: PUSH
124012: LD_VAR 0 2
124016: PPUSH
124017: LD_INT 21
124019: PUSH
124020: LD_INT 2
124022: PUSH
124023: EMPTY
124024: LIST
124025: LIST
124026: PPUSH
124027: CALL_OW 72
124031: AND
124032: IFFALSE 124370
// begin tmp := FilterByTag ( defenders , 19 ) ;
124034: LD_ADDR_VAR 0 11
124038: PUSH
124039: LD_VAR 0 2
124043: PPUSH
124044: LD_INT 19
124046: PPUSH
124047: CALL 88837 0 2
124051: ST_TO_ADDR
// if tmp then
124052: LD_VAR 0 11
124056: IFFALSE 124126
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
124058: LD_ADDR_VAR 0 11
124062: PUSH
124063: LD_VAR 0 11
124067: PPUSH
124068: LD_INT 25
124070: PUSH
124071: LD_INT 3
124073: PUSH
124074: EMPTY
124075: LIST
124076: LIST
124077: PPUSH
124078: CALL_OW 72
124082: ST_TO_ADDR
// if tmp then
124083: LD_VAR 0 11
124087: IFFALSE 124126
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
124089: LD_ADDR_EXP 92
124093: PUSH
124094: LD_EXP 92
124098: PPUSH
124099: LD_VAR 0 1
124103: PPUSH
124104: LD_EXP 92
124108: PUSH
124109: LD_VAR 0 1
124113: ARRAY
124114: PUSH
124115: LD_VAR 0 11
124119: UNION
124120: PPUSH
124121: CALL_OW 1
124125: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
124126: LD_VAR 0 1
124130: PPUSH
124131: LD_INT 19
124133: PPUSH
124134: CALL 27038 0 2
// repeat wait ( 0 0$1 ) ;
124138: LD_INT 35
124140: PPUSH
124141: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124145: LD_EXP 80
124149: PUSH
124150: LD_VAR 0 1
124154: ARRAY
124155: NOT
124156: PUSH
124157: LD_EXP 80
124161: PUSH
124162: LD_VAR 0 1
124166: ARRAY
124167: PUSH
124168: EMPTY
124169: EQUAL
124170: OR
124171: IFFALSE 124208
// begin for i in defenders do
124173: LD_ADDR_VAR 0 4
124177: PUSH
124178: LD_VAR 0 2
124182: PUSH
124183: FOR_IN
124184: IFFALSE 124197
// ComStop ( i ) ;
124186: LD_VAR 0 4
124190: PPUSH
124191: CALL_OW 141
124195: GO 124183
124197: POP
124198: POP
// defenders := [ ] ;
124199: LD_ADDR_VAR 0 2
124203: PUSH
124204: EMPTY
124205: ST_TO_ADDR
// exit ;
124206: GO 124434
// end ; for i in defenders do
124208: LD_ADDR_VAR 0 4
124212: PUSH
124213: LD_VAR 0 2
124217: PUSH
124218: FOR_IN
124219: IFFALSE 124308
// begin if not IsInArea ( i , mc_parking [ base ] ) then
124221: LD_VAR 0 4
124225: PPUSH
124226: LD_EXP 104
124230: PUSH
124231: LD_VAR 0 1
124235: ARRAY
124236: PPUSH
124237: CALL_OW 308
124241: NOT
124242: IFFALSE 124266
// ComMoveToArea ( i , mc_parking [ base ] ) else
124244: LD_VAR 0 4
124248: PPUSH
124249: LD_EXP 104
124253: PUSH
124254: LD_VAR 0 1
124258: ARRAY
124259: PPUSH
124260: CALL_OW 113
124264: GO 124306
// if GetControl ( i ) = control_manual then
124266: LD_VAR 0 4
124270: PPUSH
124271: CALL_OW 263
124275: PUSH
124276: LD_INT 1
124278: EQUAL
124279: IFFALSE 124306
// if IsDrivenBy ( i ) then
124281: LD_VAR 0 4
124285: PPUSH
124286: CALL_OW 311
124290: IFFALSE 124306
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
124292: LD_VAR 0 4
124296: PPUSH
124297: CALL_OW 311
124301: PPUSH
124302: CALL_OW 121
// end ;
124306: GO 124218
124308: POP
124309: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
124310: LD_VAR 0 2
124314: PPUSH
124315: LD_INT 95
124317: PUSH
124318: LD_EXP 104
124322: PUSH
124323: LD_VAR 0 1
124327: ARRAY
124328: PUSH
124329: EMPTY
124330: LIST
124331: LIST
124332: PPUSH
124333: CALL_OW 72
124337: PUSH
124338: LD_VAR 0 2
124342: EQUAL
124343: PUSH
124344: LD_EXP 103
124348: PUSH
124349: LD_VAR 0 1
124353: ARRAY
124354: OR
124355: PUSH
124356: LD_EXP 80
124360: PUSH
124361: LD_VAR 0 1
124365: ARRAY
124366: NOT
124367: OR
124368: IFFALSE 124138
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124370: LD_ADDR_EXP 102
124374: PUSH
124375: LD_EXP 102
124379: PPUSH
124380: LD_VAR 0 1
124384: PPUSH
124385: LD_VAR 0 2
124389: PPUSH
124390: LD_INT 21
124392: PUSH
124393: LD_INT 2
124395: PUSH
124396: EMPTY
124397: LIST
124398: LIST
124399: PPUSH
124400: CALL_OW 72
124404: PPUSH
124405: CALL_OW 1
124409: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124410: LD_VAR 0 1
124414: PPUSH
124415: LD_INT 19
124417: PPUSH
124418: CALL 27038 0 2
// MC_Reset ( base , 20 ) ;
124422: LD_VAR 0 1
124426: PPUSH
124427: LD_INT 20
124429: PPUSH
124430: CALL 27038 0 2
// end ; end_of_file
124434: LD_VAR 0 3
124438: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124439: LD_VAR 0 1
124443: PUSH
124444: LD_INT 200
124446: DOUBLE
124447: GREATEREQUAL
124448: IFFALSE 124456
124450: LD_INT 299
124452: DOUBLE
124453: LESSEQUAL
124454: IFTRUE 124458
124456: GO 124490
124458: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124459: LD_VAR 0 1
124463: PPUSH
124464: LD_VAR 0 2
124468: PPUSH
124469: LD_VAR 0 3
124473: PPUSH
124474: LD_VAR 0 4
124478: PPUSH
124479: LD_VAR 0 5
124483: PPUSH
124484: CALL 112620 0 5
124488: GO 124567
124490: LD_INT 300
124492: DOUBLE
124493: GREATEREQUAL
124494: IFFALSE 124502
124496: LD_INT 399
124498: DOUBLE
124499: LESSEQUAL
124500: IFTRUE 124504
124502: GO 124566
124504: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124505: LD_VAR 0 1
124509: PPUSH
124510: LD_VAR 0 2
124514: PPUSH
124515: LD_VAR 0 3
124519: PPUSH
124520: LD_VAR 0 4
124524: PPUSH
124525: LD_VAR 0 5
124529: PPUSH
124530: LD_VAR 0 6
124534: PPUSH
124535: LD_VAR 0 7
124539: PPUSH
124540: LD_VAR 0 8
124544: PPUSH
124545: LD_VAR 0 9
124549: PPUSH
124550: LD_VAR 0 10
124554: PPUSH
124555: LD_VAR 0 11
124559: PPUSH
124560: CALL 108872 0 11
124564: GO 124567
124566: POP
// end ;
124567: PPOPN 11
124569: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
124570: LD_VAR 0 1
124574: PPUSH
124575: LD_VAR 0 2
124579: PPUSH
124580: LD_VAR 0 3
124584: PPUSH
124585: LD_VAR 0 4
124589: PPUSH
124590: LD_VAR 0 5
124594: PPUSH
124595: CALL 112283 0 5
// end ; end_of_file
124599: PPOPN 5
124601: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
124602: LD_VAR 0 1
124606: PPUSH
124607: LD_VAR 0 2
124611: PPUSH
124612: LD_VAR 0 3
124616: PPUSH
124617: LD_VAR 0 4
124621: PPUSH
124622: LD_VAR 0 5
124626: PPUSH
124627: LD_VAR 0 6
124631: PPUSH
124632: CALL 96524 0 6
// end ;
124636: PPOPN 6
124638: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
124639: LD_INT 0
124641: PPUSH
// begin if not units then
124642: LD_VAR 0 1
124646: NOT
124647: IFFALSE 124651
// exit ;
124649: GO 124651
// end ;
124651: PPOPN 7
124653: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
124654: CALL 96411 0 0
// end ;
124658: PPOPN 1
124660: END
