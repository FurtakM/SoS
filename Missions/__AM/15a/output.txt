// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21232 0 0
// InitMacro ;
  19: CALL 21400 0 0
// InitNature ;
  23: CALL 17898 0 0
// InitArtifact ;
  27: CALL 18515 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11443 0 0
// MC_Start ( ) ;
  68: CALL 23565 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 119
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 120
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45254 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46314 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46407 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 124
 357: PUSH
 358: LD_EXP 124
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45572 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45757 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46314 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46407 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45572 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45757 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46187 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45254 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46314 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46407 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 124
 849: PUSH
 850: LD_EXP 124
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45572 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45757 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46314 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46407 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46725 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46519 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45572 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45757 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46138 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 52026 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 52026 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 52026 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 52026 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 52026 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 52026 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 52026 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 52026 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 52026 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 52026 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 52026 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 52026 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 52026 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 52026 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 52026 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 52026 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 52026 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 52026 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 52026 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 52026 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 52026 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 52026 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 52026 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 52026 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 52026 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 52026 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 52026 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 52026 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 52026 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 52026 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 52026 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 52026 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 52026 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 52026 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 56890 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 56890 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 56890 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 56890 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 56890 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56890 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 56890 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 56890 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 56890 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 56890 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 56890 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 56890 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 56890 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 56890 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 56890 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 56890 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 56890 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 56890 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 52026 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 52026 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 52026 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 52026 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 52026 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 52026 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 52026 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 52026 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 52026 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 52026 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 95
5868: PUSH
5869: LD_EXP 95
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47038 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45620 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45620 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47038 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47038 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 114
6351: PUSH
6352: LD_EXP 114
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 114
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45620 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60336 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 95
7133: PUSH
7134: LD_EXP 95
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 52026 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60336 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 95
7667: PUSH
7668: LD_EXP 95
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47038 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45620 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45620 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47038 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47038 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 114
8332: PUSH
8333: LD_EXP 114
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 114
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: CALL_OW 25
9038: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9039: LD_ADDR_EXP 60
9043: PUSH
9044: LD_STRING Gleb
9046: PPUSH
9047: CALL_OW 25
9051: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9052: LD_STRING 03_Cornel
9054: PPUSH
9055: CALL_OW 28
9059: IFFALSE 9107
// begin Bierezov := NewCharacter ( Mikhail ) ;
9061: LD_ADDR_EXP 61
9065: PUSH
9066: LD_STRING Mikhail
9068: PPUSH
9069: CALL_OW 25
9073: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9074: LD_EXP 61
9078: PPUSH
9079: LD_INT 197
9081: PPUSH
9082: LD_INT 111
9084: PPUSH
9085: LD_INT 9
9087: PPUSH
9088: LD_INT 0
9090: PPUSH
9091: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9095: LD_EXP 61
9099: PPUSH
9100: LD_INT 3
9102: PPUSH
9103: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9107: LD_EXP 58
9111: PPUSH
9112: LD_INT 126
9114: PPUSH
9115: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9119: LD_EXP 59
9123: PPUSH
9124: LD_INT 197
9126: PPUSH
9127: LD_INT 111
9129: PPUSH
9130: LD_INT 9
9132: PPUSH
9133: LD_INT 0
9135: PPUSH
9136: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9140: LD_EXP 60
9144: PPUSH
9145: LD_INT 197
9147: PPUSH
9148: LD_INT 111
9150: PPUSH
9151: LD_INT 9
9153: PPUSH
9154: LD_INT 0
9156: PPUSH
9157: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9161: LD_ADDR_VAR 0 5
9165: PUSH
9166: LD_INT 126
9168: PPUSH
9169: LD_INT 2
9171: PPUSH
9172: LD_STRING zhukov
9174: PPUSH
9175: LD_INT 9
9177: PUSH
9178: LD_INT 10
9180: PUSH
9181: LD_INT 10
9183: PUSH
9184: LD_INT 10
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: PUSH
9193: LD_OWVAR 67
9197: ARRAY
9198: PPUSH
9199: LD_INT 9000
9201: PUSH
9202: LD_INT 1000
9204: PUSH
9205: LD_INT 300
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: LIST
9212: PPUSH
9213: LD_INT 21
9215: PUSH
9216: LD_INT 8
9218: PUSH
9219: LD_INT 13
9221: PUSH
9222: LD_INT 8
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 60336 0 6
9235: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9236: LD_ADDR_VAR 0 4
9240: PUSH
9241: LD_INT 267
9243: PPUSH
9244: CALL_OW 274
9248: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9249: LD_VAR 0 4
9253: PPUSH
9254: LD_INT 1
9256: PPUSH
9257: LD_INT 5000
9259: PPUSH
9260: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: LD_INT 200
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9294: LD_ADDR_EXP 95
9298: PUSH
9299: LD_EXP 95
9303: PPUSH
9304: LD_INT 2
9306: PPUSH
9307: LD_VAR 0 5
9311: PUSH
9312: LD_INT 22
9314: PUSH
9315: LD_VAR 0 6
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 3
9326: PUSH
9327: LD_INT 21
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: UNION
9350: PUSH
9351: LD_EXP 58
9355: DIFF
9356: PPUSH
9357: CALL_OW 1
9361: ST_TO_ADDR
// behemoths := [ ] ;
9362: LD_ADDR_EXP 62
9366: PUSH
9367: EMPTY
9368: ST_TO_ADDR
// behemothBuilders := [ ] ;
9369: LD_ADDR_EXP 63
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// j := 3 ;
9376: LD_ADDR_VAR 0 3
9380: PUSH
9381: LD_INT 3
9383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9384: LD_ADDR_VAR 0 2
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 25
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: PUSH
9418: FOR_IN
9419: IFFALSE 9469
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9421: LD_ADDR_EXP 63
9425: PUSH
9426: LD_EXP 63
9430: PPUSH
9431: LD_VAR 0 2
9435: PPUSH
9436: CALL 88763 0 2
9440: ST_TO_ADDR
// j := j - 1 ;
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: LD_VAR 0 3
9450: PUSH
9451: LD_INT 1
9453: MINUS
9454: ST_TO_ADDR
// if j = 0 then
9455: LD_VAR 0 3
9459: PUSH
9460: LD_INT 0
9462: EQUAL
9463: IFFALSE 9467
// break ;
9465: GO 9469
// end ;
9467: GO 9418
9469: POP
9470: POP
// end ;
9471: LD_VAR 0 1
9475: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
9482: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9483: LD_ADDR_VAR 0 4
9487: PUSH
9488: LD_INT 209
9490: PUSH
9491: LD_INT 149
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 219
9500: PUSH
9501: LD_INT 154
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 223
9510: PUSH
9511: LD_INT 149
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: LD_INT 232
9520: PUSH
9521: LD_INT 155
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: ST_TO_ADDR
// if not behemothBuilders then
9534: LD_EXP 63
9538: NOT
9539: IFFALSE 9543
// exit ;
9541: GO 9647
// j := 1 ;
9543: LD_ADDR_VAR 0 3
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// for i in behemothBuilders do
9551: LD_ADDR_VAR 0 2
9555: PUSH
9556: LD_EXP 63
9560: PUSH
9561: FOR_IN
9562: IFFALSE 9645
// begin if IsInUnit ( i ) then
9564: LD_VAR 0 2
9568: PPUSH
9569: CALL_OW 310
9573: IFFALSE 9584
// ComExitBuilding ( i ) ;
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9584: LD_VAR 0 2
9588: PPUSH
9589: LD_INT 37
9591: PPUSH
9592: LD_VAR 0 4
9596: PUSH
9597: LD_VAR 0 3
9601: ARRAY
9602: PUSH
9603: LD_INT 1
9605: ARRAY
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 2
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 230
// j := j + 1 ;
9629: LD_ADDR_VAR 0 3
9633: PUSH
9634: LD_VAR 0 3
9638: PUSH
9639: LD_INT 1
9641: PLUS
9642: ST_TO_ADDR
// end ;
9643: GO 9561
9645: POP
9646: POP
// end ;
9647: LD_VAR 0 1
9651: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9652: LD_INT 3
9654: PPUSH
9655: CALL 88824 0 1
9659: PUSH
9660: LD_INT 22
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 30
9672: PUSH
9673: LD_INT 37
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PPUSH
9684: CALL_OW 69
9688: NOT
9689: AND
9690: IFFALSE 9876
9692: GO 9694
9694: DISABLE
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
// begin enable ;
9699: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_INT 3
9707: PPUSH
9708: CALL 88824 0 1
9712: ST_TO_ADDR
// for i in tmp do
9713: LD_ADDR_VAR 0 1
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: FOR_IN
9724: IFFALSE 9874
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 7
9733: PPUSH
9734: CALL_OW 308
9738: PUSH
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 110
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: NOT
9753: AND
9754: IFFALSE 9768
// SetTag ( i , 2 ) ;
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_INT 2
9763: PPUSH
9764: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9768: LD_INT 81
9770: PUSH
9771: LD_INT 3
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 91
9780: PUSH
9781: LD_VAR 0 1
9785: PUSH
9786: LD_INT 12
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: PPUSH
9798: CALL_OW 69
9802: NOT
9803: PUSH
9804: LD_VAR 0 1
9808: PPUSH
9809: CALL_OW 110
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: NOT
9818: AND
9819: IFFALSE 9838
// ComAgressiveMove ( i , 64 , 93 ) else
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_INT 64
9828: PPUSH
9829: LD_INT 93
9831: PPUSH
9832: CALL_OW 114
9836: GO 9872
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_INT 81
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: CALL_OW 69
9857: PPUSH
9858: LD_VAR 0 1
9862: PPUSH
9863: CALL_OW 74
9867: PPUSH
9868: CALL_OW 115
// end ;
9872: GO 9723
9874: POP
9875: POP
// end ;
9876: PPOPN 2
9878: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9879: LD_EXP 2
9883: NOT
9884: PUSH
9885: LD_INT 2
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: CALL 47038 0 2
9895: NOT
9896: AND
9897: IFFALSE 10821
9899: GO 9901
9901: DISABLE
9902: LD_INT 0
9904: PPUSH
9905: PPUSH
9906: PPUSH
9907: PPUSH
// begin enable ;
9908: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9909: LD_INT 22
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 30
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: NOT
9938: IFFALSE 9942
// exit ;
9940: GO 10821
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9942: LD_ADDR_VAR 0 4
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 34
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: ST_TO_ADDR
// if Prob ( 40 ) then
9976: LD_INT 40
9978: PPUSH
9979: CALL_OW 13
9983: IFFALSE 10110
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9985: LD_INT 2
9987: PPUSH
9988: LD_INT 22
9990: PUSH
9991: LD_INT 3
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 49
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 22
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 49
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: PUSH
10024: LD_INT 22
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 49
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: LIST
10040: LIST
10041: PUSH
10042: LD_INT 24
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 46
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 24
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 46
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 46
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: PPUSH
10104: CALL 45620 0 2
// end else
10108: GO 10233
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10110: LD_INT 2
10112: PPUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 47
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: LD_INT 24
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 47
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: PUSH
10149: LD_INT 24
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 47
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 24
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: LD_INT 46
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_INT 24
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: LD_INT 46
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 46
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: PPUSH
10229: CALL 45620 0 2
// end ; if Difficulty > 1 then
10233: LD_OWVAR 67
10237: PUSH
10238: LD_INT 1
10240: GREATER
10241: IFFALSE 10271
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10243: LD_INT 2
10245: PPUSH
10246: LD_INT 24
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 47
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: PPUSH
10267: CALL 45620 0 2
// repeat wait ( 0 0$1 ) ;
10271: LD_INT 35
10273: PPUSH
10274: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 1
10283: PPUSH
10284: CALL 47038 0 2
10288: PUSH
10289: LD_INT 6
10291: PUSH
10292: LD_INT 7
10294: PUSH
10295: LD_INT 7
10297: PUSH
10298: LD_INT 7
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_OWVAR 67
10311: ARRAY
10312: GREATEREQUAL
10313: IFFALSE 10271
// wait ( 0 0$30 ) ;
10315: LD_INT 1050
10317: PPUSH
10318: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 2
10329: PPUSH
10330: LD_INT 1
10332: PPUSH
10333: CALL 47038 0 2
10337: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10338: LD_ADDR_EXP 114
10342: PUSH
10343: LD_EXP 114
10347: PPUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_EXP 114
10355: PUSH
10356: LD_INT 2
10358: ARRAY
10359: PUSH
10360: LD_VAR 0 2
10364: DIFF
10365: PPUSH
10366: CALL_OW 1
10370: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10371: LD_ADDR_VAR 0 3
10375: PUSH
10376: LD_INT 0
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 12
10386: ST_TO_ADDR
// if target then
10387: LD_VAR 0 3
10391: IFFALSE 10519
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10393: LD_ADDR_VAR 0 2
10397: PUSH
10398: LD_VAR 0 2
10402: PPUSH
10403: LD_INT 24
10405: PUSH
10406: LD_INT 250
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 72
10417: ST_TO_ADDR
// for i in tmp do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: LD_VAR 0 2
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10469
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10431: LD_VAR 0 1
10435: PPUSH
10436: LD_INT 139
10438: PPUSH
10439: LD_INT 89
10441: PPUSH
10442: CALL_OW 297
10446: PUSH
10447: LD_INT 9
10449: GREATER
10450: IFFALSE 10467
// ComMoveXY ( i , 139 , 89 ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 111
10467: GO 10428
10469: POP
10470: POP
// wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10478: LD_VAR 0 2
10482: PPUSH
10483: LD_INT 92
10485: PUSH
10486: LD_INT 139
10488: PUSH
10489: LD_INT 89
10491: PUSH
10492: LD_INT 9
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 72
10505: PUSH
10506: LD_VAR 0 2
10510: PUSH
10511: LD_INT 1
10513: MINUS
10514: GREATEREQUAL
10515: IFFALSE 10393
// end else
10517: GO 10661
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10519: LD_VAR 0 2
10523: PPUSH
10524: LD_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ARRAY
10532: PPUSH
10533: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10537: LD_ADDR_VAR 0 2
10541: PUSH
10542: LD_VAR 0 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 250
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PPUSH
10557: CALL_OW 72
10561: ST_TO_ADDR
// for i in tmp do
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: LD_VAR 0 2
10571: PUSH
10572: FOR_IN
10573: IFFALSE 10613
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 124
10582: PPUSH
10583: LD_INT 139
10585: PPUSH
10586: CALL_OW 297
10590: PUSH
10591: LD_INT 9
10593: GREATER
10594: IFFALSE 10611
// ComMoveXY ( i , 124 , 139 ) ;
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 111
10611: GO 10572
10613: POP
10614: POP
// wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10622: LD_VAR 0 2
10626: PPUSH
10627: LD_INT 92
10629: PUSH
10630: LD_INT 124
10632: PUSH
10633: LD_INT 139
10635: PUSH
10636: LD_INT 9
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: PPUSH
10645: CALL_OW 72
10649: PUSH
10650: LD_VAR 0 2
10654: PUSH
10655: LD_INT 1
10657: MINUS
10658: GREATEREQUAL
10659: IFFALSE 10537
// end ; repeat wait ( 0 0$1 ) ;
10661: LD_INT 35
10663: PPUSH
10664: CALL_OW 67
// for i in tmp do
10668: LD_ADDR_VAR 0 1
10672: PUSH
10673: LD_VAR 0 2
10677: PUSH
10678: FOR_IN
10679: IFFALSE 10812
// begin if GetLives ( i ) > 251 then
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 256
10690: PUSH
10691: LD_INT 251
10693: GREATER
10694: IFFALSE 10783
// begin if GetWeapon ( i ) = ru_time_lapser then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 264
10705: PUSH
10706: LD_INT 49
10708: EQUAL
10709: IFFALSE 10747
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10711: LD_VAR 0 1
10715: PPUSH
10716: LD_INT 81
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 69
10730: PPUSH
10731: LD_VAR 0 1
10735: PPUSH
10736: CALL_OW 74
10740: PPUSH
10741: CALL_OW 112
10745: GO 10781
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 81
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PPUSH
10762: CALL_OW 69
10766: PPUSH
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 74
10776: PPUSH
10777: CALL_OW 115
// end else
10781: GO 10810
// if IsDead ( i ) then
10783: LD_VAR 0 1
10787: PPUSH
10788: CALL_OW 301
10792: IFFALSE 10810
// tmp := tmp diff i ;
10794: LD_ADDR_VAR 0 2
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_VAR 0 1
10808: DIFF
10809: ST_TO_ADDR
// end ;
10810: GO 10678
10812: POP
10813: POP
// until not tmp ;
10814: LD_VAR 0 2
10818: NOT
10819: IFFALSE 10661
// end ;
10821: PPOPN 4
10823: END
// every 30 30$00 trigger not russianDestroyed do
10824: LD_EXP 2
10828: NOT
10829: IFFALSE 10898
10831: GO 10833
10833: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10834: LD_INT 105000
10836: PUSH
10837: LD_INT 84000
10839: PUSH
10840: LD_INT 63000
10842: PUSH
10843: LD_INT 52500
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: PUSH
10852: LD_OWVAR 67
10856: ARRAY
10857: PPUSH
10858: CALL_OW 67
// if russianDestroyed then
10862: LD_EXP 2
10866: IFFALSE 10870
// exit ;
10868: GO 10898
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10870: LD_INT 2
10872: PPUSH
10873: LD_INT 23
10875: PUSH
10876: LD_INT 3
10878: PUSH
10879: LD_INT 1
10881: PUSH
10882: LD_INT 48
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL 45620 0 2
// end ; end_of_file
10898: END
// export function CustomEvent ( event ) ; begin
10899: LD_INT 0
10901: PPUSH
// end ;
10902: LD_VAR 0 2
10906: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_VAR 0 3
10916: PPUSH
10917: LD_INT 15
10919: PPUSH
10920: CALL_OW 309
10924: IFFALSE 10933
// YouLost ( MothContaminate ) ;
10926: LD_STRING MothContaminate
10928: PPUSH
10929: CALL_OW 104
// end ;
10933: PPOPN 3
10935: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_INT 15
10948: PPUSH
10949: CALL_OW 309
10953: IFFALSE 10969
// begin wait ( 0 0$6 ) ;
10955: LD_INT 210
10957: PPUSH
10958: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10962: LD_STRING MothContaminateBomb
10964: PPUSH
10965: CALL_OW 104
// end ; end ;
10969: PPOPN 3
10971: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10972: LD_VAR 0 1
10976: PUSH
10977: LD_EXP 19
10981: EQUAL
10982: IFFALSE 10993
// begin YouLost ( JMM ) ;
10984: LD_STRING JMM
10986: PPUSH
10987: CALL_OW 104
// exit ;
10991: GO 11122
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
10993: LD_VAR 0 1
10997: PPUSH
10998: CALL_OW 255
11002: PUSH
11003: LD_INT 2
11005: EQUAL
11006: PUSH
11007: LD_EXP 18
11011: NOT
11012: AND
11013: IFFALSE 11023
// arabianAttacked := true ;
11015: LD_ADDR_EXP 18
11019: PUSH
11020: LD_INT 1
11022: ST_TO_ADDR
// if un = Powell then
11023: LD_VAR 0 1
11027: PUSH
11028: LD_EXP 54
11032: EQUAL
11033: IFFALSE 11043
// americanDestroyed := true ;
11035: LD_ADDR_EXP 4
11039: PUSH
11040: LD_INT 1
11042: ST_TO_ADDR
// if un = Platonov then
11043: LD_VAR 0 1
11047: PUSH
11048: LD_EXP 58
11052: EQUAL
11053: IFFALSE 11063
// russianDestroyed := true ;
11055: LD_ADDR_EXP 2
11059: PUSH
11060: LD_INT 1
11062: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11063: LD_VAR 0 1
11067: PUSH
11068: LD_INT 22
11070: PUSH
11071: LD_INT 7
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: PUSH
11078: LD_INT 21
11080: PUSH
11081: LD_INT 2
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: IN
11097: IFFALSE 11113
// vehicleLostCounter := vehicleLostCounter + 1 ;
11099: LD_ADDR_EXP 15
11103: PUSH
11104: LD_EXP 15
11108: PUSH
11109: LD_INT 1
11111: PLUS
11112: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11113: LD_VAR 0 1
11117: PPUSH
11118: CALL 49040 0 1
// end ;
11122: PPOPN 1
11124: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11125: LD_VAR 0 1
11129: PPUSH
11130: LD_VAR 0 2
11134: PPUSH
11135: CALL 51374 0 2
// end ;
11139: PPOPN 2
11141: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11142: LD_VAR 0 1
11146: PPUSH
11147: CALL 50442 0 1
// end ;
11151: PPOPN 1
11153: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11154: LD_VAR 0 1
11158: PUSH
11159: LD_INT 22
11161: PUSH
11162: LD_INT 8
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: LD_INT 30
11171: PUSH
11172: LD_INT 2
11174: PUSH
11175: EMPTY
11176: LIST
11177: LIST
11178: PUSH
11179: LD_INT 23
11181: PUSH
11182: LD_INT 3
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL_OW 69
11198: IN
11199: IFFALSE 11226
// begin ComUpgrade ( building ) ;
11201: LD_VAR 0 1
11205: PPUSH
11206: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11210: LD_EXP 57
11214: PPUSH
11215: LD_VAR 0 1
11219: PPUSH
11220: CALL 59875 0 2
// exit ;
11224: GO 11235
// end ; MCE_BuildingComplete ( building ) ;
11226: LD_VAR 0 1
11230: PPUSH
11231: CALL 50683 0 1
// end ;
11235: PPOPN 1
11237: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11238: LD_VAR 0 1
11242: PPUSH
11243: LD_VAR 0 2
11247: PPUSH
11248: CALL 48736 0 2
// end ;
11252: PPOPN 2
11254: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11255: LD_VAR 0 1
11259: PPUSH
11260: LD_VAR 0 2
11264: PPUSH
11265: LD_VAR 0 3
11269: PPUSH
11270: LD_VAR 0 4
11274: PPUSH
11275: LD_VAR 0 5
11279: PPUSH
11280: CALL 48356 0 5
// end ;
11284: PPOPN 5
11286: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11287: LD_VAR 0 1
11291: PPUSH
11292: LD_VAR 0 2
11296: PPUSH
11297: CALL 47937 0 2
// end ;
11301: PPOPN 2
11303: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11304: LD_VAR 0 1
11308: PPUSH
11309: LD_VAR 0 2
11313: PPUSH
11314: LD_VAR 0 3
11318: PPUSH
11319: LD_VAR 0 4
11323: PPUSH
11324: CALL 47775 0 4
// end ;
11328: PPOPN 4
11330: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11331: LD_VAR 0 1
11335: PPUSH
11336: LD_VAR 0 2
11340: PPUSH
11341: LD_VAR 0 3
11345: PPUSH
11346: CALL 47550 0 3
// end ;
11350: PPOPN 3
11352: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11353: LD_VAR 0 1
11357: PPUSH
11358: LD_VAR 0 2
11362: PPUSH
11363: CALL 47435 0 2
// end ;
11367: PPOPN 2
11369: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11370: LD_VAR 0 1
11374: PPUSH
11375: LD_VAR 0 2
11379: PPUSH
11380: CALL 51669 0 2
// end ;
11384: PPOPN 2
11386: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11387: LD_VAR 0 1
11391: PPUSH
11392: LD_VAR 0 2
11396: PPUSH
11397: LD_VAR 0 3
11401: PPUSH
11402: LD_VAR 0 4
11406: PPUSH
11407: CALL 51885 0 4
// end ;
11411: PPOPN 4
11413: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11414: LD_VAR 0 1
11418: PPUSH
11419: LD_VAR 0 2
11423: PPUSH
11424: CALL 47244 0 2
// end ;
11428: PPOPN 2
11430: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11431: LD_VAR 0 1
11435: PPUSH
11436: CALL 105655 0 1
// end ; end_of_file
11440: PPOPN 1
11442: END
// export function Action ; begin
11443: LD_INT 0
11445: PPUSH
// InGameOn ;
11446: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11450: LD_INT 206
11452: PPUSH
11453: LD_INT 11
11455: PPUSH
11456: CALL_OW 86
// wait ( 0 0$1 ) ;
11460: LD_INT 35
11462: PPUSH
11463: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11467: LD_EXP 19
11471: PPUSH
11472: LD_STRING DStart-JMM-JMM-1
11474: PPUSH
11475: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11479: LD_EXP 51
11483: PPUSH
11484: LD_STRING DStart-JMM-Bur-1
11486: PPUSH
11487: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11491: LD_EXP 19
11495: PPUSH
11496: LD_STRING DStart-JMM-JMM-2
11498: PPUSH
11499: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11503: LD_EXP 51
11507: PPUSH
11508: LD_STRING DStart-JMM-Bur-2
11510: PPUSH
11511: CALL_OW 88
// InGameOff ;
11515: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11519: LD_STRING MStart
11521: PPUSH
11522: CALL_OW 337
// SaveForQuickRestart ;
11526: CALL_OW 22
// end ;
11530: LD_VAR 0 1
11534: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11535: LD_INT 7
11537: PPUSH
11538: LD_INT 255
11540: PPUSH
11541: LD_INT 219
11543: PPUSH
11544: CALL_OW 293
11548: IFFALSE 12157
11550: GO 11552
11552: DISABLE
11553: LD_INT 0
11555: PPUSH
// begin wait ( 0 0$3 ) ;
11556: LD_INT 105
11558: PPUSH
11559: CALL_OW 67
// alienSpotted := true ;
11563: LD_ADDR_EXP 10
11567: PUSH
11568: LD_INT 1
11570: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11571: LD_ADDR_VAR 0 1
11575: PUSH
11576: LD_INT 22
11578: PUSH
11579: LD_INT 7
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: PUSH
11586: LD_INT 23
11588: PUSH
11589: LD_INT 3
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: PUSH
11596: LD_INT 21
11598: PUSH
11599: LD_INT 1
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: PUSH
11606: LD_INT 26
11608: PUSH
11609: LD_INT 1
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: PPUSH
11622: CALL_OW 69
11626: PUSH
11627: LD_EXP 51
11631: PUSH
11632: LD_EXP 39
11636: PUSH
11637: LD_EXP 41
11641: PUSH
11642: LD_EXP 42
11646: PUSH
11647: LD_EXP 49
11651: PUSH
11652: LD_EXP 48
11656: PUSH
11657: LD_EXP 43
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: DIFF
11671: ST_TO_ADDR
// DialogueOn ;
11672: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11676: LD_INT 255
11678: PPUSH
11679: LD_INT 219
11681: PPUSH
11682: LD_INT 7
11684: PPUSH
11685: LD_INT 20
11687: NEG
11688: PPUSH
11689: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11693: LD_INT 255
11695: PPUSH
11696: LD_INT 219
11698: PPUSH
11699: CALL_OW 86
// if speaker then
11703: LD_VAR 0 1
11707: IFFALSE 11725
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11709: LD_VAR 0 1
11713: PUSH
11714: LD_INT 1
11716: ARRAY
11717: PPUSH
11718: LD_STRING DAlienBase-RSol1-1
11720: PPUSH
11721: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11725: LD_EXP 19
11729: PPUSH
11730: LD_STRING DAlienBase-JMM-1
11732: PPUSH
11733: CALL_OW 88
// if IsOk ( Burlak ) then
11737: LD_EXP 51
11741: PPUSH
11742: CALL_OW 302
11746: IFFALSE 11767
// begin dwait ( 0 0$1 ) ;
11748: LD_INT 35
11750: PPUSH
11751: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11755: LD_EXP 51
11759: PPUSH
11760: LD_STRING DAlienBase-Bur-1
11762: PPUSH
11763: CALL_OW 88
// end ; if IsOk ( Roth ) then
11767: LD_EXP 20
11771: PPUSH
11772: CALL_OW 302
11776: IFFALSE 11790
// Say ( Roth , DAlienBase-Roth-1 ) ;
11778: LD_EXP 20
11782: PPUSH
11783: LD_STRING DAlienBase-Roth-1
11785: PPUSH
11786: CALL_OW 88
// if IsOk ( Gossudarov ) then
11790: LD_EXP 37
11794: PPUSH
11795: CALL_OW 302
11799: IFFALSE 11815
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11801: LD_EXP 37
11805: PPUSH
11806: LD_STRING DAlienBase-Gos-1
11808: PPUSH
11809: CALL_OW 88
11813: GO 11932
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 25
11832: PUSH
11833: LD_INT 4
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 26
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: PUSH
11871: LD_EXP 20
11875: PUSH
11876: LD_EXP 19
11880: PUSH
11881: LD_EXP 51
11885: PUSH
11886: LD_EXP 39
11890: PUSH
11891: LD_EXP 49
11895: PUSH
11896: LD_EXP 48
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: DIFF
11909: ST_TO_ADDR
// if speaker then
11910: LD_VAR 0 1
11914: IFFALSE 11932
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11916: LD_VAR 0 1
11920: PUSH
11921: LD_INT 1
11923: ARRAY
11924: PPUSH
11925: LD_STRING DAlienBase-Sci1-1
11927: PPUSH
11928: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11932: LD_INT 255
11934: PPUSH
11935: LD_INT 219
11937: PPUSH
11938: LD_INT 7
11940: PPUSH
11941: CALL_OW 331
// DialogueOff ;
11945: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11949: LD_INT 35
11951: PPUSH
11952: CALL_OW 67
// until IsSelected ( alien ) ;
11956: LD_INT 1
11958: PPUSH
11959: CALL_OW 306
11963: IFFALSE 11949
// if not artifactIResearched or not artifactIIResearched then
11965: LD_EXP 12
11969: NOT
11970: PUSH
11971: LD_EXP 13
11975: NOT
11976: OR
11977: IFFALSE 12157
// begin if IsOk ( Roth ) then
11979: LD_EXP 20
11983: PPUSH
11984: CALL_OW 302
11988: IFFALSE 12004
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11990: LD_EXP 20
11994: PPUSH
11995: LD_STRING DAlieBaseNotReady-Roth-1
11997: PPUSH
11998: CALL_OW 88
12002: GO 12157
// if IsOk ( Gossudarov ) then
12004: LD_EXP 37
12008: PPUSH
12009: CALL_OW 302
12013: IFFALSE 12029
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12015: LD_EXP 37
12019: PPUSH
12020: LD_STRING DAlieBaseNotReady-Gos-1
12022: PPUSH
12023: CALL_OW 88
12027: GO 12157
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12029: LD_ADDR_VAR 0 1
12033: PUSH
12034: LD_INT 22
12036: PUSH
12037: LD_INT 7
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 23
12046: PUSH
12047: LD_INT 3
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 25
12056: PUSH
12057: LD_INT 4
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 21
12066: PUSH
12067: LD_INT 1
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 26
12076: PUSH
12077: LD_INT 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: PUSH
12096: LD_EXP 20
12100: PUSH
12101: LD_EXP 19
12105: PUSH
12106: LD_EXP 51
12110: PUSH
12111: LD_EXP 39
12115: PUSH
12116: LD_EXP 49
12120: PUSH
12121: LD_EXP 48
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: DIFF
12134: ST_TO_ADDR
// if speaker then
12135: LD_VAR 0 1
12139: IFFALSE 12157
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12141: LD_VAR 0 1
12145: PUSH
12146: LD_INT 1
12148: ARRAY
12149: PPUSH
12150: LD_STRING DAlieBaseNotReady-RSci1-1
12152: PPUSH
12153: CALL_OW 88
// end ; end ; end ;
12157: PPOPN 1
12159: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12160: LD_INT 24
12162: PPUSH
12163: LD_INT 7
12165: PPUSH
12166: CALL_OW 321
12170: PUSH
12171: LD_INT 2
12173: EQUAL
12174: IFFALSE 12865
12176: GO 12178
12178: DISABLE
12179: LD_INT 0
12181: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_INT 22
12189: PUSH
12190: LD_INT 7
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 23
12199: PUSH
12200: LD_INT 3
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 25
12209: PUSH
12210: LD_INT 4
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: PUSH
12217: LD_INT 21
12219: PUSH
12220: LD_INT 1
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 26
12229: PUSH
12230: LD_INT 1
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: PPUSH
12244: CALL_OW 69
12248: PUSH
12249: LD_EXP 20
12253: PUSH
12254: LD_EXP 19
12258: PUSH
12259: LD_EXP 51
12263: PUSH
12264: LD_EXP 39
12268: PUSH
12269: LD_EXP 49
12273: PUSH
12274: LD_EXP 48
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: DIFF
12287: ST_TO_ADDR
// if not speaker then
12288: LD_VAR 0 1
12292: NOT
12293: IFFALSE 12297
// exit ;
12295: GO 12865
// DialogueOn ;
12297: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12301: LD_VAR 0 1
12305: PUSH
12306: LD_INT 1
12308: ARRAY
12309: PPUSH
12310: LD_STRING DArtefTechnology-RSci1-1
12312: PPUSH
12313: CALL_OW 88
// if IsOk ( Burlak ) then
12317: LD_EXP 51
12321: PPUSH
12322: CALL_OW 302
12326: IFFALSE 12340
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12328: LD_EXP 51
12332: PPUSH
12333: LD_STRING DArtefTechnology-Bur-1
12335: PPUSH
12336: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12340: LD_VAR 0 1
12344: PUSH
12345: LD_INT 1
12347: ARRAY
12348: PPUSH
12349: LD_STRING DArtefTechnology-RSci1-2
12351: PPUSH
12352: CALL_OW 88
// if Denis then
12356: LD_EXP 25
12360: IFFALSE 12377
// speaker := [ Denis ] else
12362: LD_ADDR_VAR 0 1
12366: PUSH
12367: LD_EXP 25
12371: PUSH
12372: EMPTY
12373: LIST
12374: ST_TO_ADDR
12375: GO 12483
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12377: LD_ADDR_VAR 0 1
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_INT 7
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 23
12394: PUSH
12395: LD_INT 1
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PUSH
12402: LD_INT 25
12404: PUSH
12405: LD_INT 4
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PUSH
12412: LD_INT 21
12414: PUSH
12415: LD_INT 1
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: LD_INT 26
12424: PUSH
12425: LD_INT 1
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: PPUSH
12439: CALL_OW 69
12443: PUSH
12444: LD_EXP 20
12448: PUSH
12449: LD_EXP 19
12453: PUSH
12454: LD_EXP 51
12458: PUSH
12459: LD_EXP 39
12463: PUSH
12464: LD_EXP 49
12468: PUSH
12469: LD_EXP 48
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: LIST
12478: LIST
12479: LIST
12480: LIST
12481: DIFF
12482: ST_TO_ADDR
// if speaker then
12483: LD_VAR 0 1
12487: IFFALSE 12505
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12489: LD_VAR 0 1
12493: PUSH
12494: LD_INT 1
12496: ARRAY
12497: PPUSH
12498: LD_STRING DArtefTechnology-Sci1-2
12500: PPUSH
12501: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12505: LD_ADDR_VAR 0 1
12509: PUSH
12510: LD_INT 22
12512: PUSH
12513: LD_INT 7
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 23
12522: PUSH
12523: LD_INT 3
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: LD_INT 25
12532: PUSH
12533: LD_INT 4
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PUSH
12540: LD_INT 21
12542: PUSH
12543: LD_INT 1
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 26
12552: PUSH
12553: LD_INT 1
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: PUSH
12572: LD_EXP 20
12576: PUSH
12577: LD_EXP 19
12581: PUSH
12582: LD_EXP 51
12586: PUSH
12587: LD_EXP 39
12591: PUSH
12592: LD_EXP 49
12596: PUSH
12597: LD_EXP 48
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: DIFF
12610: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12611: LD_VAR 0 1
12615: PUSH
12616: LD_EXP 9
12620: PUSH
12621: LD_EXP 5
12625: OR
12626: AND
12627: IFFALSE 12861
// begin if arabianDestroyed and IsOk ( Burlak ) then
12629: LD_EXP 5
12633: PUSH
12634: LD_EXP 51
12638: PPUSH
12639: CALL_OW 302
12643: AND
12644: IFFALSE 12660
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12646: LD_EXP 51
12650: PPUSH
12651: LD_STRING DArtefTechnology-Bur-2
12653: PPUSH
12654: CALL_OW 88
12658: GO 12672
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12660: LD_EXP 19
12664: PPUSH
12665: LD_STRING DArtefTechnology-JMM-2
12667: PPUSH
12668: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 1
12679: ARRAY
12680: PPUSH
12681: LD_STRING DArtefTechnology-RSci1-3
12683: PPUSH
12684: CALL_OW 88
// if Denis then
12688: LD_EXP 25
12692: IFFALSE 12709
// speaker := [ Denis ] else
12694: LD_ADDR_VAR 0 1
12698: PUSH
12699: LD_EXP 25
12703: PUSH
12704: EMPTY
12705: LIST
12706: ST_TO_ADDR
12707: GO 12815
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12709: LD_ADDR_VAR 0 1
12713: PUSH
12714: LD_INT 22
12716: PUSH
12717: LD_INT 7
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: LD_INT 23
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 4
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 26
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: PPUSH
12771: CALL_OW 69
12775: PUSH
12776: LD_EXP 20
12780: PUSH
12781: LD_EXP 19
12785: PUSH
12786: LD_EXP 51
12790: PUSH
12791: LD_EXP 39
12795: PUSH
12796: LD_EXP 49
12800: PUSH
12801: LD_EXP 48
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: DIFF
12814: ST_TO_ADDR
// if speaker then
12815: LD_VAR 0 1
12819: IFFALSE 12861
// if alienSpotted then
12821: LD_EXP 10
12825: IFFALSE 12845
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12827: LD_VAR 0 1
12831: PUSH
12832: LD_INT 1
12834: ARRAY
12835: PPUSH
12836: LD_STRING DArtefTechnology-Sci1-3
12838: PPUSH
12839: CALL_OW 88
12843: GO 12861
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12845: LD_VAR 0 1
12849: PUSH
12850: LD_INT 1
12852: ARRAY
12853: PPUSH
12854: LD_STRING DArtefTechnology-Sci1-3a
12856: PPUSH
12857: CALL_OW 88
// end ; DialogueOff ;
12861: CALL_OW 7
// end ;
12865: PPOPN 1
12867: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12868: LD_EXP 12
12872: IFFALSE 13075
12874: GO 12876
12876: DISABLE
12877: LD_INT 0
12879: PPUSH
// begin if Denis then
12880: LD_EXP 25
12884: IFFALSE 12901
// speaker := [ Denis ] else
12886: LD_ADDR_VAR 0 1
12890: PUSH
12891: LD_EXP 25
12895: PUSH
12896: EMPTY
12897: LIST
12898: ST_TO_ADDR
12899: GO 13007
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12901: LD_ADDR_VAR 0 1
12905: PUSH
12906: LD_INT 22
12908: PUSH
12909: LD_INT 7
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 23
12918: PUSH
12919: LD_INT 1
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 25
12928: PUSH
12929: LD_INT 4
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 21
12938: PUSH
12939: LD_INT 1
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 26
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PPUSH
12963: CALL_OW 69
12967: PUSH
12968: LD_EXP 20
12972: PUSH
12973: LD_EXP 19
12977: PUSH
12978: LD_EXP 51
12982: PUSH
12983: LD_EXP 39
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 48
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: DIFF
13006: ST_TO_ADDR
// if not speaker then
13007: LD_VAR 0 1
13011: NOT
13012: IFFALSE 13016
// exit ;
13014: GO 13075
// DialogueOn ;
13016: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13020: LD_VAR 0 1
13024: PUSH
13025: LD_INT 1
13027: ARRAY
13028: PPUSH
13029: LD_STRING DArtefTechnologyAm-Sci1-1
13031: PPUSH
13032: CALL_OW 88
// if IsOk ( Burlak ) then
13036: LD_EXP 51
13040: PPUSH
13041: CALL_OW 302
13045: IFFALSE 13059
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13047: LD_EXP 51
13051: PPUSH
13052: LD_STRING DArtefTechnologyAm-Bur-1
13054: PPUSH
13055: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13059: LD_EXP 19
13063: PPUSH
13064: LD_STRING DArtefTechnologyAm-JMM-1
13066: PPUSH
13067: CALL_OW 88
// DialogueOff ;
13071: CALL_OW 7
// end ;
13075: PPOPN 1
13077: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13078: LD_EXP 13
13082: IFFALSE 13284
13084: GO 13086
13086: DISABLE
13087: LD_INT 0
13089: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13090: LD_ADDR_VAR 0 1
13094: PUSH
13095: LD_INT 22
13097: PUSH
13098: LD_INT 7
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: LD_INT 23
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: LD_INT 25
13117: PUSH
13118: LD_INT 4
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 21
13127: PUSH
13128: LD_INT 1
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 26
13137: PUSH
13138: LD_INT 1
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 69
13156: PUSH
13157: LD_EXP 20
13161: PUSH
13162: LD_EXP 19
13166: PUSH
13167: LD_EXP 51
13171: PUSH
13172: LD_EXP 39
13176: PUSH
13177: LD_EXP 49
13181: PUSH
13182: LD_EXP 48
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: DIFF
13195: ST_TO_ADDR
// if not speaker then
13196: LD_VAR 0 1
13200: NOT
13201: IFFALSE 13205
// exit ;
13203: GO 13284
// DialogueOn ;
13205: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13209: LD_VAR 0 1
13213: PUSH
13214: LD_VAR 0 1
13218: ARRAY
13219: PPUSH
13220: LD_STRING DArtefTechnologyRu-RSci1-1
13222: PPUSH
13223: CALL_OW 88
// if IsOk ( Burlak ) then
13227: LD_EXP 51
13231: PPUSH
13232: CALL_OW 302
13236: IFFALSE 13250
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13238: LD_EXP 51
13242: PPUSH
13243: LD_STRING DArtefTechnologyRu-Bur-1
13245: PPUSH
13246: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13250: LD_VAR 0 1
13254: PUSH
13255: LD_VAR 0 1
13259: ARRAY
13260: PPUSH
13261: LD_STRING DArtefTechnologyRu-RSci1-2
13263: PPUSH
13264: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13268: LD_EXP 19
13272: PPUSH
13273: LD_STRING DArtefTechnologyRu-JMM-1
13275: PPUSH
13276: CALL_OW 88
// DialogueOff ;
13280: CALL_OW 7
// end ;
13284: PPOPN 1
13286: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13287: LD_INT 24
13289: PPUSH
13290: LD_INT 7
13292: PPUSH
13293: CALL_OW 321
13297: PUSH
13298: LD_INT 2
13300: EQUAL
13301: PUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 255
13309: PUSH
13310: LD_INT 7
13312: EQUAL
13313: AND
13314: IFFALSE 13482
13316: GO 13318
13318: DISABLE
13319: LD_INT 0
13321: PPUSH
// begin if Denis then
13322: LD_EXP 25
13326: IFFALSE 13343
// speaker := [ Denis ] else
13328: LD_ADDR_VAR 0 1
13332: PUSH
13333: LD_EXP 25
13337: PUSH
13338: EMPTY
13339: LIST
13340: ST_TO_ADDR
13341: GO 13449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13343: LD_ADDR_VAR 0 1
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 7
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 23
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PUSH
13368: LD_INT 25
13370: PUSH
13371: LD_INT 4
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 21
13380: PUSH
13381: LD_INT 1
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 26
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 69
13409: PUSH
13410: LD_EXP 20
13414: PUSH
13415: LD_EXP 19
13419: PUSH
13420: LD_EXP 51
13424: PUSH
13425: LD_EXP 39
13429: PUSH
13430: LD_EXP 49
13434: PUSH
13435: LD_EXP 48
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: DIFF
13448: ST_TO_ADDR
// if not speaker then
13449: LD_VAR 0 1
13453: NOT
13454: IFFALSE 13458
// exit ;
13456: GO 13482
// DialogueOn ;
13458: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13462: LD_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: ARRAY
13470: PPUSH
13471: LD_STRING DArtefTechnologyArStart-Sci1-1
13473: PPUSH
13474: CALL_OW 88
// DialogueOff ;
13478: CALL_OW 7
// end ;
13482: PPOPN 1
13484: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13485: LD_EXP 14
13489: IFFALSE 13770
13491: GO 13493
13493: DISABLE
13494: LD_INT 0
13496: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_INT 22
13504: PUSH
13505: LD_INT 7
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 23
13514: PUSH
13515: LD_INT 3
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: PUSH
13522: LD_INT 25
13524: PUSH
13525: LD_INT 4
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: PUSH
13532: LD_INT 21
13534: PUSH
13535: LD_INT 1
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PUSH
13542: LD_INT 26
13544: PUSH
13545: LD_INT 1
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: PPUSH
13559: CALL_OW 69
13563: PUSH
13564: LD_EXP 20
13568: PUSH
13569: LD_EXP 19
13573: PUSH
13574: LD_EXP 51
13578: PUSH
13579: LD_EXP 39
13583: PUSH
13584: LD_EXP 49
13588: PUSH
13589: LD_EXP 48
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: DIFF
13602: ST_TO_ADDR
// if not speaker then
13603: LD_VAR 0 1
13607: NOT
13608: IFFALSE 13612
// exit ;
13610: GO 13770
// DialogueOn ;
13612: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13616: LD_VAR 0 1
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PPUSH
13625: LD_STRING DArtefTechnologyAr-RSci1-1
13627: PPUSH
13628: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13632: LD_EXP 19
13636: PPUSH
13637: LD_STRING DArtefTechnologyAr-JMM-1
13639: PPUSH
13640: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13644: LD_VAR 0 1
13648: PUSH
13649: LD_INT 1
13651: ARRAY
13652: PPUSH
13653: LD_STRING DArtefTechnologyAr-RSci1-2
13655: PPUSH
13656: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13660: LD_EXP 19
13664: PPUSH
13665: LD_STRING DArtefTechnologyAr-JMM-2
13667: PPUSH
13668: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13672: LD_VAR 0 1
13676: PUSH
13677: LD_INT 1
13679: ARRAY
13680: PPUSH
13681: LD_STRING DArtefTechnologyAr-RSci1-3
13683: PPUSH
13684: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13688: LD_EXP 19
13692: PPUSH
13693: LD_STRING DArtefTechnologyAr-JMM-3
13695: PPUSH
13696: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13700: LD_VAR 0 1
13704: PUSH
13705: LD_INT 1
13707: ARRAY
13708: PPUSH
13709: LD_STRING DArtefTechnologyAr-RSci1-4
13711: PPUSH
13712: CALL_OW 88
// if IsOk ( Burlak ) then
13716: LD_EXP 51
13720: PPUSH
13721: CALL_OW 302
13725: IFFALSE 13739
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13727: LD_EXP 51
13731: PPUSH
13732: LD_STRING DArtefTechnologyAr-Bur-4
13734: PPUSH
13735: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13739: LD_EXP 19
13743: PPUSH
13744: LD_STRING DArtefTechnologyAr-JMM-4
13746: PPUSH
13747: CALL_OW 88
// DialogueOff ;
13751: CALL_OW 7
// wait ( 0 0$45 ) ;
13755: LD_INT 1575
13757: PPUSH
13758: CALL_OW 67
// spawnOmar := true ;
13762: LD_ADDR_EXP 11
13766: PUSH
13767: LD_INT 1
13769: ST_TO_ADDR
// end ;
13770: PPOPN 1
13772: END
// every 0 0$1 trigger spawnOmar do
13773: LD_EXP 11
13777: IFFALSE 14157
13779: GO 13781
13781: DISABLE
// begin PrepareOmarAli ;
13782: CALL 7201 0 0
// if not HasTask ( Omar ) then
13786: LD_EXP 55
13790: PPUSH
13791: CALL_OW 314
13795: NOT
13796: IFFALSE 13813
// ComMoveXY ( Omar , 252 , 220 ) ;
13798: LD_EXP 55
13802: PPUSH
13803: LD_INT 252
13805: PPUSH
13806: LD_INT 220
13808: PPUSH
13809: CALL_OW 111
// if not Omar then
13813: LD_EXP 55
13817: NOT
13818: IFFALSE 13822
// exit ;
13820: GO 14157
// repeat wait ( 0 0$1 ) ;
13822: LD_INT 35
13824: PPUSH
13825: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13829: LD_EXP 55
13833: PPUSH
13834: CALL_OW 314
13838: NOT
13839: PUSH
13840: LD_EXP 55
13844: PPUSH
13845: LD_INT 252
13847: PPUSH
13848: LD_INT 220
13850: PPUSH
13851: CALL_OW 297
13855: PUSH
13856: LD_INT 6
13858: GREATER
13859: AND
13860: IFFALSE 13877
// ComMoveXY ( Omar , 252 , 220 ) ;
13862: LD_EXP 55
13866: PPUSH
13867: LD_INT 252
13869: PPUSH
13870: LD_INT 220
13872: PPUSH
13873: CALL_OW 111
// until See ( 7 , Omar ) ;
13877: LD_INT 7
13879: PPUSH
13880: LD_EXP 55
13884: PPUSH
13885: CALL_OW 292
13889: IFFALSE 13822
// CenterNowOnUnits ( Omar ) ;
13891: LD_EXP 55
13895: PPUSH
13896: CALL_OW 87
// DialogueOn ;
13900: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13904: LD_EXP 55
13908: PPUSH
13909: LD_STRING DOmar-Omar-1
13911: PPUSH
13912: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13916: LD_EXP 19
13920: PPUSH
13921: LD_STRING DOmar-JMM-1
13923: PPUSH
13924: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13928: LD_EXP 55
13932: PPUSH
13933: LD_STRING DOmar-Omar-2
13935: PPUSH
13936: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13940: LD_EXP 19
13944: PPUSH
13945: LD_STRING DOmar-JMM-2
13947: PPUSH
13948: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13952: LD_EXP 55
13956: PPUSH
13957: LD_STRING DOmar-Omar-3
13959: PPUSH
13960: CALL_OW 88
// if IsOk ( Burlak ) then
13964: LD_EXP 51
13968: PPUSH
13969: CALL_OW 302
13973: IFFALSE 13989
// Say ( Burlak , DOmar-Bur-3 ) else
13975: LD_EXP 51
13979: PPUSH
13980: LD_STRING DOmar-Bur-3
13982: PPUSH
13983: CALL_OW 88
13987: GO 14001
// Say ( JMM , DOmar-JMM-3 ) ;
13989: LD_EXP 19
13993: PPUSH
13994: LD_STRING DOmar-JMM-3
13996: PPUSH
13997: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14001: LD_EXP 55
14005: PPUSH
14006: LD_STRING DOmar-Omar-4
14008: PPUSH
14009: CALL_OW 88
// case Query ( QAccept ) of 1 :
14013: LD_STRING QAccept
14015: PPUSH
14016: CALL_OW 97
14020: PUSH
14021: LD_INT 1
14023: DOUBLE
14024: EQUAL
14025: IFTRUE 14029
14027: GO 14065
14029: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14030: LD_EXP 19
14034: PPUSH
14035: LD_STRING DQrAccept#1-JMM-1
14037: PPUSH
14038: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14042: LD_EXP 55
14046: PPUSH
14047: LD_INT 7
14049: PPUSH
14050: CALL_OW 235
// ComStop ( Omar ) ;
14054: LD_EXP 55
14058: PPUSH
14059: CALL_OW 141
// end ; 2 :
14063: GO 14114
14065: LD_INT 2
14067: DOUBLE
14068: EQUAL
14069: IFTRUE 14073
14071: GO 14113
14073: POP
// begin if IsOk ( Burlak ) then
14074: LD_EXP 51
14078: PPUSH
14079: CALL_OW 302
14083: IFFALSE 14099
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14085: LD_EXP 51
14089: PPUSH
14090: LD_STRING DQrAccept#2-Bur-1
14092: PPUSH
14093: CALL_OW 88
14097: GO 14111
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14099: LD_EXP 19
14103: PPUSH
14104: LD_STRING DQrAccept#2-JMM-1
14106: PPUSH
14107: CALL_OW 88
// end ; end ;
14111: GO 14114
14113: POP
// DialogueOff ;
14114: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14118: LD_EXP 55
14122: PPUSH
14123: CALL_OW 255
14127: PUSH
14128: LD_INT 7
14130: EQUAL
14131: IFFALSE 14142
// begin SetAchievement ( ACH_OMAR ) ;
14133: LD_STRING ACH_OMAR
14135: PPUSH
14136: CALL_OW 543
// exit ;
14140: GO 14157
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14142: LD_EXP 55
14146: PPUSH
14147: LD_INT 202
14149: PPUSH
14150: LD_INT 115
14152: PPUSH
14153: CALL_OW 111
// end ;
14157: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14158: LD_EXP 55
14162: PPUSH
14163: LD_INT 200
14165: PPUSH
14166: LD_INT 98
14168: PPUSH
14169: CALL_OW 297
14173: PUSH
14174: LD_INT 40
14176: LESS
14177: PUSH
14178: LD_EXP 2
14182: AND
14183: IFFALSE 14401
14185: GO 14187
14187: DISABLE
// begin SetSide ( Omar , 5 ) ;
14188: LD_EXP 55
14192: PPUSH
14193: LD_INT 5
14195: PPUSH
14196: CALL_OW 235
// if IsInUnit ( Omar ) then
14200: LD_EXP 55
14204: PPUSH
14205: CALL_OW 310
14209: IFFALSE 14220
// ComExitVehicle ( Omar ) ;
14211: LD_EXP 55
14215: PPUSH
14216: CALL_OW 121
// if IsInUnit ( Omar ) then
14220: LD_EXP 55
14224: PPUSH
14225: CALL_OW 310
14229: IFFALSE 14240
// ComExitBuilding ( Omar ) ;
14231: LD_EXP 55
14235: PPUSH
14236: CALL_OW 122
// wait ( 0 0$1 ) ;
14240: LD_INT 35
14242: PPUSH
14243: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14247: LD_EXP 55
14251: PPUSH
14252: LD_INT 203
14254: PPUSH
14255: LD_INT 120
14257: PPUSH
14258: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14262: LD_INT 35
14264: PPUSH
14265: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14269: LD_EXP 55
14273: PPUSH
14274: CALL_OW 306
14278: PUSH
14279: LD_EXP 55
14283: PPUSH
14284: LD_INT 203
14286: PPUSH
14287: LD_INT 120
14289: PPUSH
14290: CALL_OW 297
14294: PUSH
14295: LD_INT 6
14297: LESS
14298: OR
14299: IFFALSE 14262
// CenterNowOnUnits ( Omar ) ;
14301: LD_EXP 55
14305: PPUSH
14306: CALL_OW 87
// DialogueOn ;
14310: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14314: LD_EXP 19
14318: PPUSH
14319: LD_STRING DOmarContam-JMM-1
14321: PPUSH
14322: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14326: LD_EXP 55
14330: PPUSH
14331: LD_STRING DOmarContam-Omar-1
14333: PPUSH
14334: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14338: LD_EXP 19
14342: PPUSH
14343: LD_STRING DOmarContam-JMM-2
14345: PPUSH
14346: CALL_OW 88
// DialogueOff ;
14350: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14354: LD_INT 5
14356: PPUSH
14357: LD_INT 7
14359: PPUSH
14360: LD_INT 2
14362: PPUSH
14363: LD_INT 1
14365: PPUSH
14366: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14370: LD_INT 105
14372: PPUSH
14373: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14377: LD_EXP 55
14381: PPUSH
14382: LD_INT 203
14384: PPUSH
14385: LD_INT 120
14387: PPUSH
14388: CALL_OW 307
14392: IFFALSE 14370
// YouLost ( MothContaminate ) ;
14394: LD_STRING MothContaminate
14396: PPUSH
14397: CALL_OW 104
// end ;
14401: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14402: LD_EXP 4
14406: NOT
14407: PUSH
14408: LD_INT 22
14410: PUSH
14411: LD_INT 1
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: PUSH
14418: LD_INT 34
14420: PUSH
14421: LD_INT 8
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PPUSH
14432: CALL_OW 69
14436: AND
14437: IFFALSE 14556
14439: GO 14441
14441: DISABLE
// begin wait ( 0 0$5 ) ;
14442: LD_INT 175
14444: PPUSH
14445: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14449: LD_EXP 54
14453: PPUSH
14454: CALL_OW 302
14458: NOT
14459: PUSH
14460: LD_INT 22
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: LD_INT 34
14472: PUSH
14473: LD_INT 8
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PPUSH
14484: CALL_OW 69
14488: NOT
14489: OR
14490: IFFALSE 14494
// exit ;
14492: GO 14556
// DialogueOn ;
14494: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14498: LD_EXP 54
14502: PPUSH
14503: LD_STRING DWinAmericans-Pow-1
14505: PPUSH
14506: CALL_OW 94
// if IsOk ( Burlak ) then
14510: LD_EXP 51
14514: PPUSH
14515: CALL_OW 302
14519: IFFALSE 14533
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14521: LD_EXP 51
14525: PPUSH
14526: LD_STRING DWinAmericans-Bur-1
14528: PPUSH
14529: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14533: LD_EXP 19
14537: PPUSH
14538: LD_STRING DWinAmericans-JMM-1
14540: PPUSH
14541: CALL_OW 88
// DialogueOff ;
14545: CALL_OW 7
// YouLost ( AmBomb ) ;
14549: LD_STRING AmBomb
14551: PPUSH
14552: CALL_OW 104
// end ;
14556: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14557: LD_EXP 2
14561: NOT
14562: PUSH
14563: LD_INT 22
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: LD_INT 34
14575: PUSH
14576: LD_INT 48
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PPUSH
14587: CALL_OW 69
14591: AND
14592: IFFALSE 14711
14594: GO 14596
14596: DISABLE
// begin wait ( 0 0$5 ) ;
14597: LD_INT 175
14599: PPUSH
14600: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14604: LD_EXP 58
14608: PPUSH
14609: CALL_OW 302
14613: NOT
14614: PUSH
14615: LD_INT 22
14617: PUSH
14618: LD_INT 3
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 34
14627: PUSH
14628: LD_INT 48
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PPUSH
14639: CALL_OW 69
14643: NOT
14644: OR
14645: IFFALSE 14649
// exit ;
14647: GO 14711
// DialogueOn ;
14649: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14653: LD_EXP 58
14657: PPUSH
14658: LD_STRING DWinRussians-Pla-1
14660: PPUSH
14661: CALL_OW 94
// if IsOk ( Burlak ) then
14665: LD_EXP 51
14669: PPUSH
14670: CALL_OW 302
14674: IFFALSE 14688
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14676: LD_EXP 51
14680: PPUSH
14681: LD_STRING DWinRussians-Bur-1
14683: PPUSH
14684: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14688: LD_EXP 19
14692: PPUSH
14693: LD_STRING DWinRussians-JMM-1
14695: PPUSH
14696: CALL_OW 88
// DialogueOff ;
14700: CALL_OW 7
// YouLost ( RuBomb ) ;
14704: LD_STRING RuBomb
14706: PPUSH
14707: CALL_OW 104
// end ;
14711: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14712: LD_INT 7
14714: PPUSH
14715: LD_INT 22
14717: PUSH
14718: LD_INT 7
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 70
14729: PUSH
14730: LD_EXP 4
14734: NOT
14735: AND
14736: IFFALSE 14765
14738: GO 14740
14740: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14741: LD_EXP 54
14745: PPUSH
14746: LD_STRING DSurrenderAmericans-Pow-1
14748: PPUSH
14749: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14753: LD_EXP 19
14757: PPUSH
14758: LD_STRING DSurrenderAmericans-JMM-1
14760: PPUSH
14761: CALL_OW 88
// end ;
14765: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14766: LD_INT 2
14768: PPUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 7
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PPUSH
14779: CALL_OW 70
14783: PUSH
14784: LD_EXP 2
14788: NOT
14789: AND
14790: PUSH
14791: LD_EXP 51
14795: AND
14796: IFFALSE 14825
14798: GO 14800
14800: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14801: LD_EXP 58
14805: PPUSH
14806: LD_STRING DSurrenderRussians-Pla-1
14808: PPUSH
14809: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14813: LD_EXP 51
14817: PPUSH
14818: LD_STRING DSurrenderRussians-Bur-1
14820: PPUSH
14821: CALL_OW 88
// end ;
14825: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14826: LD_EXP 4
14830: IFFALSE 15213
14832: GO 14834
14834: DISABLE
14835: LD_INT 0
14837: PPUSH
14838: PPUSH
14839: PPUSH
// begin MC_Kill ( 4 ) ;
14840: LD_INT 4
14842: PPUSH
14843: CALL 21642 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14847: LD_INT 1
14849: PPUSH
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_INT 22
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 26
14880: PUSH
14881: LD_INT 1
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 23
14890: PUSH
14891: LD_INT 1
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: LIST
14902: PPUSH
14903: CALL_OW 69
14907: PUSH
14908: LD_EXP 54
14912: PUSH
14913: LD_EXP 27
14917: PUSH
14918: LD_EXP 24
14922: PUSH
14923: LD_EXP 23
14927: PUSH
14928: LD_EXP 30
14932: PUSH
14933: LD_EXP 28
14937: PUSH
14938: EMPTY
14939: LIST
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: DIFF
14946: ST_TO_ADDR
// if speaker then
14947: LD_VAR 0 3
14951: IFFALSE 14977
// begin DialogueOn ;
14953: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14957: LD_VAR 0 3
14961: PUSH
14962: LD_INT 1
14964: ARRAY
14965: PPUSH
14966: LD_STRING DSurrenderAmericans-Sol1-1a
14968: PPUSH
14969: CALL_OW 94
// DialogueOff ;
14973: CALL_OW 7
// end ; americanCapitulated := true ;
14977: LD_ADDR_EXP 6
14981: PUSH
14982: LD_INT 1
14984: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: LD_INT 22
14992: PUSH
14993: LD_INT 1
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: PUSH
15000: LD_INT 21
15002: PUSH
15003: LD_INT 1
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PUSH
15010: EMPTY
15011: LIST
15012: LIST
15013: PPUSH
15014: CALL_OW 69
15018: PUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 1
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PUSH
15029: LD_INT 21
15031: PUSH
15032: LD_INT 2
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 1
15041: PUSH
15042: EMPTY
15043: LIST
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: PPUSH
15050: CALL_OW 69
15054: ADD
15055: ST_TO_ADDR
// if tmp then
15056: LD_VAR 0 2
15060: IFFALSE 15213
// repeat wait ( 0 0$1 ) ;
15062: LD_INT 35
15064: PPUSH
15065: CALL_OW 67
// for i in tmp do
15069: LD_ADDR_VAR 0 1
15073: PUSH
15074: LD_VAR 0 2
15078: PUSH
15079: FOR_IN
15080: IFFALSE 15162
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15082: LD_VAR 0 1
15086: PPUSH
15087: CALL_OW 310
15091: PUSH
15092: LD_VAR 0 1
15096: PPUSH
15097: CALL_OW 310
15101: PPUSH
15102: CALL_OW 247
15106: PUSH
15107: LD_INT 3
15109: EQUAL
15110: AND
15111: IFFALSE 15122
// ComExitBuilding ( i ) ;
15113: LD_VAR 0 1
15117: PPUSH
15118: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15122: LD_VAR 0 1
15126: PPUSH
15127: LD_INT 122
15129: PPUSH
15130: LD_INT 242
15132: PPUSH
15133: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15137: LD_VAR 0 1
15141: PPUSH
15142: LD_INT 35
15144: PPUSH
15145: CALL_OW 308
15149: IFFALSE 15160
// RemoveUnit ( i ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 64
// end ;
15160: GO 15079
15162: POP
15163: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15164: LD_INT 22
15166: PUSH
15167: LD_INT 1
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PUSH
15174: LD_INT 2
15176: PUSH
15177: LD_INT 21
15179: PUSH
15180: LD_INT 1
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: PUSH
15187: LD_INT 33
15189: PUSH
15190: LD_INT 1
15192: PUSH
15193: EMPTY
15194: LIST
15195: LIST
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: NOT
15211: IFFALSE 15062
// end ;
15213: PPOPN 3
15215: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15216: LD_EXP 2
15220: IFFALSE 15621
15222: GO 15224
15224: DISABLE
15225: LD_INT 0
15227: PPUSH
15228: PPUSH
15229: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15230: LD_INT 35
15232: PPUSH
15233: CALL_OW 67
// until IsDead ( Yakotich ) ;
15237: LD_EXP 59
15241: PPUSH
15242: CALL_OW 301
15246: IFFALSE 15230
// MC_Kill ( 2 ) ;
15248: LD_INT 2
15250: PPUSH
15251: CALL 21642 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15255: LD_INT 3
15257: PPUSH
15258: LD_INT 7
15260: PPUSH
15261: LD_INT 1
15263: PPUSH
15264: LD_INT 1
15266: PPUSH
15267: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15271: LD_ADDR_VAR 0 3
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 3
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 26
15288: PUSH
15289: LD_INT 1
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 23
15298: PUSH
15299: LD_INT 3
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: LIST
15310: PPUSH
15311: CALL_OW 69
15315: PUSH
15316: LD_EXP 58
15320: PUSH
15321: LD_EXP 59
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: DIFF
15330: ST_TO_ADDR
// if speaker then
15331: LD_VAR 0 3
15335: IFFALSE 15385
// begin DialogueOn ;
15337: CALL_OW 6
// if Burlak then
15341: LD_EXP 51
15345: IFFALSE 15365
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15347: LD_VAR 0 3
15351: PUSH
15352: LD_INT 1
15354: ARRAY
15355: PPUSH
15356: LD_STRING DSurrenderRussians-RSol1-1
15358: PPUSH
15359: CALL_OW 94
15363: GO 15381
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15365: LD_VAR 0 3
15369: PUSH
15370: LD_INT 1
15372: ARRAY
15373: PPUSH
15374: LD_STRING DSurrenderRussians-RSol1-1a
15376: PPUSH
15377: CALL_OW 94
// DialogueOff ;
15381: CALL_OW 7
// end ; russianCapitulated := true ;
15385: LD_ADDR_EXP 7
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15393: LD_ADDR_VAR 0 2
15397: PUSH
15398: LD_INT 22
15400: PUSH
15401: LD_INT 3
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: EMPTY
15419: LIST
15420: LIST
15421: PPUSH
15422: CALL_OW 69
15426: PUSH
15427: LD_INT 22
15429: PUSH
15430: LD_INT 3
15432: PUSH
15433: EMPTY
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 21
15439: PUSH
15440: LD_INT 2
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: LIST
15457: PPUSH
15458: CALL_OW 69
15462: ADD
15463: ST_TO_ADDR
// if tmp then
15464: LD_VAR 0 2
15468: IFFALSE 15621
// repeat wait ( 0 0$1 ) ;
15470: LD_INT 35
15472: PPUSH
15473: CALL_OW 67
// for i in tmp do
15477: LD_ADDR_VAR 0 1
15481: PUSH
15482: LD_VAR 0 2
15486: PUSH
15487: FOR_IN
15488: IFFALSE 15570
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15490: LD_VAR 0 1
15494: PPUSH
15495: CALL_OW 310
15499: PUSH
15500: LD_VAR 0 1
15504: PPUSH
15505: CALL_OW 310
15509: PPUSH
15510: CALL_OW 247
15514: PUSH
15515: LD_INT 3
15517: EQUAL
15518: AND
15519: IFFALSE 15530
// ComExitBuilding ( i ) ;
15521: LD_VAR 0 1
15525: PPUSH
15526: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15530: LD_VAR 0 1
15534: PPUSH
15535: LD_INT 154
15537: PPUSH
15538: LD_INT 1
15540: PPUSH
15541: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_INT 36
15552: PPUSH
15553: CALL_OW 308
15557: IFFALSE 15568
// RemoveUnit ( i ) ;
15559: LD_VAR 0 1
15563: PPUSH
15564: CALL_OW 64
// end ;
15568: GO 15487
15570: POP
15571: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15572: LD_INT 22
15574: PUSH
15575: LD_INT 3
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: PUSH
15582: LD_INT 2
15584: PUSH
15585: LD_INT 21
15587: PUSH
15588: LD_INT 1
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PUSH
15595: LD_INT 33
15597: PUSH
15598: LD_INT 1
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: LIST
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PPUSH
15614: CALL_OW 69
15618: NOT
15619: IFFALSE 15470
// end ;
15621: PPOPN 3
15623: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15624: LD_INT 22
15626: PUSH
15627: LD_INT 8
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: PUSH
15634: LD_INT 21
15636: PUSH
15637: LD_INT 1
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PUSH
15644: LD_INT 23
15646: PUSH
15647: LD_INT 2
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 69
15663: PUSH
15664: LD_INT 18
15666: LESS
15667: PUSH
15668: LD_EXP 57
15672: PPUSH
15673: CALL_OW 301
15677: OR
15678: PUSH
15679: LD_INT 324
15681: PPUSH
15682: CALL_OW 255
15686: PUSH
15687: LD_INT 7
15689: EQUAL
15690: OR
15691: IFFALSE 15704
15693: GO 15695
15695: DISABLE
// legionDestroyed := true ;
15696: LD_ADDR_EXP 3
15700: PUSH
15701: LD_INT 1
15703: ST_TO_ADDR
15704: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15705: LD_INT 22
15707: PUSH
15708: LD_INT 2
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: LD_INT 21
15717: PUSH
15718: LD_INT 1
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 23
15727: PUSH
15728: LD_INT 2
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: LIST
15739: PPUSH
15740: CALL_OW 69
15744: PUSH
15745: LD_INT 9
15747: LESS
15748: IFFALSE 15761
15750: GO 15752
15752: DISABLE
// arabianDestroyed := true ;
15753: LD_ADDR_EXP 5
15757: PUSH
15758: LD_INT 1
15760: ST_TO_ADDR
15761: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15762: LD_EXP 5
15766: IFFALSE 16010
15768: GO 15770
15770: DISABLE
15771: LD_INT 0
15773: PPUSH
15774: PPUSH
// begin MC_Kill ( 1 ) ;
15775: LD_INT 1
15777: PPUSH
15778: CALL 21642 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15782: LD_ADDR_VAR 0 2
15786: PUSH
15787: LD_INT 22
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 21
15799: PUSH
15800: LD_INT 1
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PPUSH
15811: CALL_OW 69
15815: PUSH
15816: LD_INT 22
15818: PUSH
15819: LD_INT 8
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PUSH
15826: LD_INT 21
15828: PUSH
15829: LD_INT 2
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PUSH
15836: LD_INT 1
15838: PUSH
15839: EMPTY
15840: LIST
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: LIST
15846: PPUSH
15847: CALL_OW 69
15851: ADD
15852: ST_TO_ADDR
// if tmp then
15853: LD_VAR 0 2
15857: IFFALSE 16010
// repeat wait ( 0 0$1 ) ;
15859: LD_INT 35
15861: PPUSH
15862: CALL_OW 67
// for i in tmp do
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_VAR 0 2
15875: PUSH
15876: FOR_IN
15877: IFFALSE 15959
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15879: LD_VAR 0 1
15883: PPUSH
15884: CALL_OW 310
15888: PUSH
15889: LD_VAR 0 1
15893: PPUSH
15894: CALL_OW 310
15898: PPUSH
15899: CALL_OW 247
15903: PUSH
15904: LD_INT 3
15906: EQUAL
15907: AND
15908: IFFALSE 15919
// ComExitBuilding ( i ) ;
15910: LD_VAR 0 1
15914: PPUSH
15915: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15919: LD_VAR 0 1
15923: PPUSH
15924: LD_INT 254
15926: PPUSH
15927: LD_INT 268
15929: PPUSH
15930: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15934: LD_VAR 0 1
15938: PPUSH
15939: LD_INT 34
15941: PPUSH
15942: CALL_OW 308
15946: IFFALSE 15957
// RemoveUnit ( i ) ;
15948: LD_VAR 0 1
15952: PPUSH
15953: CALL_OW 64
// end ;
15957: GO 15876
15959: POP
15960: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15961: LD_INT 22
15963: PUSH
15964: LD_INT 2
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PUSH
15971: LD_INT 2
15973: PUSH
15974: LD_INT 21
15976: PUSH
15977: LD_INT 1
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: PUSH
15984: LD_INT 33
15986: PUSH
15987: LD_INT 1
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PUSH
15994: EMPTY
15995: LIST
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: NOT
16008: IFFALSE 15859
// end ;
16010: PPOPN 2
16012: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16013: LD_EXP 3
16017: IFFALSE 16369
16019: GO 16021
16021: DISABLE
16022: LD_INT 0
16024: PPUSH
16025: PPUSH
// begin MC_Kill ( 3 ) ;
16026: LD_INT 3
16028: PPUSH
16029: CALL 21642 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16033: LD_INT 8
16035: PPUSH
16036: LD_INT 7
16038: PPUSH
16039: LD_INT 1
16041: PPUSH
16042: LD_INT 1
16044: PPUSH
16045: CALL_OW 80
// DialogueOn ;
16049: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16053: LD_EXP 56
16057: PPUSH
16058: LD_STRING D15-Szulc-1
16060: PPUSH
16061: CALL_OW 94
// DialogueOff ;
16065: CALL_OW 7
// legionCapitulated := true ;
16069: LD_ADDR_EXP 8
16073: PUSH
16074: LD_INT 1
16076: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16077: LD_ADDR_VAR 0 1
16081: PUSH
16082: LD_INT 22
16084: PUSH
16085: LD_INT 8
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PUSH
16092: LD_INT 21
16094: PUSH
16095: LD_INT 3
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: PUSH
16102: LD_INT 23
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: EMPTY
16109: LIST
16110: LIST
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 69
16121: PUSH
16122: FOR_IN
16123: IFFALSE 16139
// SetLives ( i , 3 ) ;
16125: LD_VAR 0 1
16129: PPUSH
16130: LD_INT 3
16132: PPUSH
16133: CALL_OW 234
16137: GO 16122
16139: POP
16140: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16141: LD_ADDR_VAR 0 2
16145: PUSH
16146: LD_INT 22
16148: PUSH
16149: LD_INT 8
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PUSH
16156: LD_INT 21
16158: PUSH
16159: LD_INT 1
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL_OW 69
16174: PUSH
16175: LD_INT 22
16177: PUSH
16178: LD_INT 8
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: PUSH
16185: LD_INT 21
16187: PUSH
16188: LD_INT 2
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PUSH
16195: LD_INT 1
16197: PUSH
16198: EMPTY
16199: LIST
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: LIST
16205: PPUSH
16206: CALL_OW 69
16210: ADD
16211: ST_TO_ADDR
// if tmp then
16212: LD_VAR 0 2
16216: IFFALSE 16369
// repeat wait ( 0 0$1 ) ;
16218: LD_INT 35
16220: PPUSH
16221: CALL_OW 67
// for i in tmp do
16225: LD_ADDR_VAR 0 1
16229: PUSH
16230: LD_VAR 0 2
16234: PUSH
16235: FOR_IN
16236: IFFALSE 16318
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16238: LD_VAR 0 1
16242: PPUSH
16243: CALL_OW 310
16247: PUSH
16248: LD_VAR 0 1
16252: PPUSH
16253: CALL_OW 310
16257: PPUSH
16258: CALL_OW 247
16262: PUSH
16263: LD_INT 3
16265: EQUAL
16266: AND
16267: IFFALSE 16278
// ComExitBuilding ( i ) ;
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16278: LD_VAR 0 1
16282: PPUSH
16283: LD_INT 10
16285: PPUSH
16286: LD_INT 1
16288: PPUSH
16289: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16293: LD_VAR 0 1
16297: PPUSH
16298: LD_INT 32
16300: PPUSH
16301: CALL_OW 308
16305: IFFALSE 16316
// RemoveUnit ( i ) ;
16307: LD_VAR 0 1
16311: PPUSH
16312: CALL_OW 64
// end ;
16316: GO 16235
16318: POP
16319: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16320: LD_INT 22
16322: PUSH
16323: LD_INT 8
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PUSH
16330: LD_INT 2
16332: PUSH
16333: LD_INT 21
16335: PUSH
16336: LD_INT 1
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PUSH
16343: LD_INT 33
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: PUSH
16353: EMPTY
16354: LIST
16355: LIST
16356: LIST
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PPUSH
16362: CALL_OW 69
16366: NOT
16367: IFFALSE 16218
// end ;
16369: PPOPN 2
16371: END
// every 0 0$10 trigger legionDestroyed and americanDestroyed and arabianAttacked and not arabianDestroyed and tick >= 30 30$00 do
16372: LD_EXP 3
16376: PUSH
16377: LD_EXP 4
16381: AND
16382: PUSH
16383: LD_EXP 18
16387: AND
16388: PUSH
16389: LD_EXP 5
16393: NOT
16394: AND
16395: PUSH
16396: LD_OWVAR 1
16400: PUSH
16401: LD_INT 63000
16403: GREATEREQUAL
16404: AND
16405: IFFALSE 16414
16407: GO 16409
16409: DISABLE
// AllianceSupport ;
16410: CALL 4642 0 0
16414: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16415: LD_EXP 4
16419: PUSH
16420: LD_EXP 2
16424: AND
16425: PUSH
16426: LD_EXP 3
16430: AND
16431: PUSH
16432: LD_EXP 5
16436: AND
16437: PUSH
16438: LD_EXP 6
16442: AND
16443: PUSH
16444: LD_EXP 7
16448: AND
16449: PUSH
16450: LD_EXP 8
16454: AND
16455: PUSH
16456: LD_EXP 55
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 5
16468: NONEQUAL
16469: PUSH
16470: LD_EXP 55
16474: PPUSH
16475: CALL_OW 301
16479: OR
16480: PUSH
16481: LD_EXP 55
16485: PPUSH
16486: CALL_OW 305
16490: NOT
16491: OR
16492: AND
16493: IFFALSE 17895
16495: GO 16497
16497: DISABLE
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// begin wait ( 0 0$5 ) ;
16502: LD_INT 175
16504: PPUSH
16505: CALL_OW 67
// music_class := 5 ;
16509: LD_ADDR_OWVAR 72
16513: PUSH
16514: LD_INT 5
16516: ST_TO_ADDR
// music_nat := 5 ;
16517: LD_ADDR_OWVAR 71
16521: PUSH
16522: LD_INT 5
16524: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16525: LD_EXP 15
16529: PUSH
16530: LD_INT 3
16532: LESS
16533: IFFALSE 16542
// SetAchievement ( ACH_ECONOMY ) ;
16535: LD_STRING ACH_ECONOMY
16537: PPUSH
16538: CALL_OW 543
// if tick < 60 60$00 then
16542: LD_OWVAR 1
16546: PUSH
16547: LD_INT 126000
16549: LESS
16550: IFFALSE 16566
// begin wait ( 3 ) ;
16552: LD_INT 3
16554: PPUSH
16555: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16559: LD_STRING ACH_ASPEED_19
16561: PPUSH
16562: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16566: LD_EXP 19
16570: PPUSH
16571: CALL_OW 87
// InGameOn ;
16575: CALL_OW 8
// DialogueOn ;
16579: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16583: LD_EXP 19
16587: PPUSH
16588: LD_STRING DEnd-JMM-JMM-1
16590: PPUSH
16591: CALL_OW 88
// if Joan then
16595: LD_EXP 34
16599: IFFALSE 16615
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16601: LD_EXP 34
16605: PPUSH
16606: LD_STRING DEnd-JMM-Joan-1
16608: PPUSH
16609: CALL_OW 88
16613: GO 16659
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16615: LD_EXP 21
16619: PUSH
16620: LD_EXP 21
16624: PPUSH
16625: CALL_OW 255
16629: PUSH
16630: LD_INT 7
16632: EQUAL
16633: AND
16634: PUSH
16635: LD_EXP 21
16639: PPUSH
16640: CALL_OW 305
16644: AND
16645: IFFALSE 16659
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16647: LD_EXP 21
16651: PPUSH
16652: LD_STRING DEnd-JMM-Lisa-1
16654: PPUSH
16655: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16659: LD_EXP 31
16663: PUSH
16664: LD_EXP 31
16668: PPUSH
16669: CALL_OW 305
16673: AND
16674: IFFALSE 16688
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16676: LD_EXP 31
16680: PPUSH
16681: LD_STRING DEnd-JMM-Frank-1
16683: PPUSH
16684: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16688: LD_EXP 24
16692: PUSH
16693: LD_EXP 24
16697: PPUSH
16698: CALL_OW 255
16702: PUSH
16703: LD_INT 7
16705: EQUAL
16706: AND
16707: PUSH
16708: LD_EXP 24
16712: PPUSH
16713: CALL_OW 305
16717: AND
16718: IFFALSE 16732
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16720: LD_EXP 24
16724: PPUSH
16725: LD_STRING DEnd-JMM-Cyrus-1
16727: PPUSH
16728: CALL_OW 88
// if Burlak then
16732: LD_EXP 51
16736: IFFALSE 16750
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16738: LD_EXP 51
16742: PPUSH
16743: LD_STRING DEnd-JMM-Bur-1
16745: PPUSH
16746: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16750: LD_EXP 34
16754: PUSH
16755: LD_EXP 21
16759: AND
16760: PUSH
16761: LD_EXP 21
16765: PPUSH
16766: CALL_OW 255
16770: PUSH
16771: LD_INT 7
16773: EQUAL
16774: AND
16775: PUSH
16776: LD_EXP 21
16780: PPUSH
16781: CALL_OW 305
16785: AND
16786: PUSH
16787: LD_EXP 51
16791: PPUSH
16792: CALL_OW 302
16796: AND
16797: IFFALSE 16811
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16799: LD_EXP 21
16803: PPUSH
16804: LD_STRING DEnd-Burlak-Lisa-1
16806: PPUSH
16807: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16811: LD_EXP 52
16815: PUSH
16816: LD_EXP 52
16820: PPUSH
16821: CALL_OW 305
16825: AND
16826: IFFALSE 16840
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16828: LD_EXP 52
16832: PPUSH
16833: LD_STRING DEnd-JMM-Bel-1
16835: PPUSH
16836: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16840: LD_EXP 53
16844: PUSH
16845: LD_EXP 53
16849: PPUSH
16850: CALL_OW 305
16854: AND
16855: IFFALSE 16869
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16857: LD_EXP 53
16861: PPUSH
16862: LD_STRING DEnd-JMM-Gny-1
16864: PPUSH
16865: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16869: LD_EXP 29
16873: PUSH
16874: LD_EXP 29
16878: PPUSH
16879: CALL_OW 255
16883: PUSH
16884: LD_INT 7
16886: EQUAL
16887: AND
16888: PUSH
16889: LD_EXP 29
16893: PPUSH
16894: CALL_OW 305
16898: AND
16899: IFFALSE 16913
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16901: LD_EXP 29
16905: PPUSH
16906: LD_STRING DEnd-JMM-Corn-1
16908: PPUSH
16909: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16913: LD_EXP 22
16917: PUSH
16918: LD_EXP 22
16922: PPUSH
16923: CALL_OW 255
16927: PUSH
16928: LD_INT 7
16930: EQUAL
16931: AND
16932: PUSH
16933: LD_EXP 22
16937: PPUSH
16938: CALL_OW 305
16942: AND
16943: IFFALSE 16957
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16945: LD_EXP 22
16949: PPUSH
16950: LD_STRING DEnd-JMM-Don-1
16952: PPUSH
16953: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16957: LD_EXP 23
16961: PUSH
16962: LD_EXP 23
16966: PPUSH
16967: CALL_OW 255
16971: PUSH
16972: LD_INT 7
16974: EQUAL
16975: AND
16976: PUSH
16977: LD_EXP 23
16981: PPUSH
16982: CALL_OW 305
16986: AND
16987: IFFALSE 17001
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16989: LD_EXP 23
16993: PPUSH
16994: LD_STRING DEnd-JMM-Bobby-1
16996: PPUSH
16997: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17001: LD_EXP 25
17005: PUSH
17006: LD_EXP 25
17010: PPUSH
17011: CALL_OW 255
17015: PUSH
17016: LD_INT 7
17018: EQUAL
17019: AND
17020: PUSH
17021: LD_EXP 25
17025: PPUSH
17026: CALL_OW 305
17030: AND
17031: IFFALSE 17045
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17033: LD_EXP 25
17037: PPUSH
17038: LD_STRING DEnd-JMM-Den-1
17040: PPUSH
17041: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17045: LD_EXP 27
17049: PUSH
17050: LD_EXP 27
17054: PPUSH
17055: CALL_OW 255
17059: PUSH
17060: LD_INT 7
17062: EQUAL
17063: AND
17064: PUSH
17065: LD_EXP 27
17069: PPUSH
17070: CALL_OW 305
17074: AND
17075: IFFALSE 17089
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17077: LD_EXP 27
17081: PPUSH
17082: LD_STRING DEnd-JMM-Glad-1
17084: PPUSH
17085: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17089: LD_EXP 32
17093: PUSH
17094: LD_EXP 32
17098: PPUSH
17099: CALL_OW 255
17103: PUSH
17104: LD_INT 7
17106: EQUAL
17107: AND
17108: PUSH
17109: LD_EXP 32
17113: PPUSH
17114: CALL_OW 305
17118: AND
17119: IFFALSE 17133
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17121: LD_EXP 32
17125: PPUSH
17126: LD_STRING DEnd-JMM-Yam-1
17128: PPUSH
17129: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17133: LD_EXP 26
17137: PUSH
17138: LD_EXP 26
17142: PPUSH
17143: CALL_OW 255
17147: PUSH
17148: LD_INT 7
17150: EQUAL
17151: AND
17152: PUSH
17153: LD_EXP 26
17157: PPUSH
17158: CALL_OW 305
17162: AND
17163: IFFALSE 17177
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17165: LD_EXP 26
17169: PPUSH
17170: LD_STRING DEnd-JMM-Brown-1
17172: PPUSH
17173: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17177: LD_EXP 36
17181: PUSH
17182: LD_EXP 36
17186: PPUSH
17187: CALL_OW 255
17191: PUSH
17192: LD_INT 7
17194: EQUAL
17195: AND
17196: PUSH
17197: LD_EXP 36
17201: PPUSH
17202: CALL_OW 305
17206: AND
17207: IFFALSE 17221
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17209: LD_EXP 36
17213: PPUSH
17214: LD_STRING DEnd-JMM-Con-1
17216: PPUSH
17217: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17221: LD_EXP 30
17225: PUSH
17226: LD_EXP 30
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 7
17238: EQUAL
17239: AND
17240: PUSH
17241: LD_EXP 30
17245: PPUSH
17246: CALL_OW 305
17250: AND
17251: IFFALSE 17265
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17253: LD_EXP 30
17257: PPUSH
17258: LD_STRING DEnd-JMM-Gary-1
17260: PPUSH
17261: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17265: LD_EXP 33
17269: PUSH
17270: LD_EXP 20
17274: AND
17275: PUSH
17276: LD_EXP 33
17280: PPUSH
17281: CALL_OW 305
17285: AND
17286: IFFALSE 17300
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17288: LD_EXP 33
17292: PPUSH
17293: LD_STRING DEnd-JMM-Sim-1
17295: PPUSH
17296: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17300: LD_EXP 28
17304: PUSH
17305: LD_EXP 28
17309: PPUSH
17310: CALL_OW 255
17314: PUSH
17315: LD_INT 7
17317: EQUAL
17318: AND
17319: PUSH
17320: LD_EXP 28
17324: PPUSH
17325: CALL_OW 305
17329: AND
17330: IFFALSE 17344
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17332: LD_EXP 28
17336: PPUSH
17337: LD_STRING DEnd-JMM-VanH-1
17339: PPUSH
17340: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17344: LD_EXP 41
17348: PUSH
17349: LD_EXP 41
17353: PPUSH
17354: CALL_OW 305
17358: AND
17359: IFFALSE 17373
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17361: LD_EXP 41
17365: PPUSH
17366: LD_STRING DEnd-JMM-Dol-1
17368: PPUSH
17369: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17373: LD_EXP 45
17377: PUSH
17378: LD_EXP 45
17382: PPUSH
17383: CALL_OW 305
17387: AND
17388: IFFALSE 17402
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17390: LD_EXP 45
17394: PPUSH
17395: LD_STRING DEnd-JMM-Kap-1
17397: PPUSH
17398: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17402: LD_EXP 48
17406: PUSH
17407: LD_EXP 48
17411: PPUSH
17412: CALL_OW 305
17416: AND
17417: IFFALSE 17431
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17419: LD_EXP 48
17423: PPUSH
17424: LD_STRING DEnd-JMM-Kov-1
17426: PPUSH
17427: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17431: LD_EXP 43
17435: PUSH
17436: LD_EXP 43
17440: PPUSH
17441: CALL_OW 305
17445: AND
17446: IFFALSE 17460
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17448: LD_EXP 43
17452: PPUSH
17453: LD_STRING DEnd-JMM-Sch-1
17455: PPUSH
17456: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17460: LD_EXP 39
17464: PUSH
17465: LD_EXP 39
17469: PPUSH
17470: CALL_OW 305
17474: AND
17475: IFFALSE 17489
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17477: LD_EXP 39
17481: PPUSH
17482: LD_STRING DEnd-JMM-Tit-1
17484: PPUSH
17485: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17489: LD_EXP 44
17493: PUSH
17494: LD_EXP 44
17498: PPUSH
17499: CALL_OW 305
17503: AND
17504: IFFALSE 17518
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17506: LD_EXP 44
17510: PPUSH
17511: LD_STRING DEnd-JMM-Obl-1
17513: PPUSH
17514: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17518: LD_EXP 46
17522: PUSH
17523: LD_EXP 46
17527: PPUSH
17528: CALL_OW 305
17532: AND
17533: IFFALSE 17547
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17535: LD_EXP 46
17539: PPUSH
17540: LD_STRING DEnd-JMM-Lip-1
17542: PPUSH
17543: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17547: LD_EXP 40
17551: PUSH
17552: LD_EXP 40
17556: PPUSH
17557: CALL_OW 305
17561: AND
17562: PUSH
17563: LD_EXP 51
17567: AND
17568: IFFALSE 17582
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17570: LD_EXP 40
17574: PPUSH
17575: LD_STRING DEnd-Burlak-Fad-1
17577: PPUSH
17578: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17582: LD_EXP 47
17586: PUSH
17587: LD_EXP 47
17591: PPUSH
17592: CALL_OW 305
17596: AND
17597: IFFALSE 17611
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17599: LD_EXP 47
17603: PPUSH
17604: LD_STRING DEnd-Burlak-Ptr-1
17606: PPUSH
17607: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17611: LD_EXP 49
17615: PUSH
17616: LD_EXP 49
17620: PPUSH
17621: CALL_OW 305
17625: AND
17626: IFFALSE 17640
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17628: LD_EXP 49
17632: PPUSH
17633: LD_STRING DEnd-Burlak-Kuz-1
17635: PPUSH
17636: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17640: LD_EXP 38
17644: PUSH
17645: LD_EXP 38
17649: PPUSH
17650: CALL_OW 305
17654: AND
17655: PUSH
17656: LD_EXP 51
17660: AND
17661: IFFALSE 17675
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17663: LD_EXP 38
17667: PPUSH
17668: LD_STRING DEnd-Burlak-Kir-1
17670: PPUSH
17671: CALL_OW 88
// if Burlak then
17675: LD_EXP 51
17679: IFFALSE 17693
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17681: LD_EXP 19
17685: PPUSH
17686: LD_STRING DEnd-Burlak-JMM-1
17688: PPUSH
17689: CALL_OW 88
// dwait ( 0 0$2 ) ;
17693: LD_INT 70
17695: PPUSH
17696: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17700: LD_EXP 56
17704: PPUSH
17705: LD_STRING DEnd-Szulc
17707: PPUSH
17708: CALL_OW 94
// dwait ( 0 0$1 ) ;
17712: LD_INT 35
17714: PPUSH
17715: CALL_OW 68
// if IsLive ( Burlak ) then
17719: LD_EXP 51
17723: PPUSH
17724: CALL_OW 300
17728: IFFALSE 17740
// med1 := 1 else
17730: LD_ADDR_VAR 0 1
17734: PUSH
17735: LD_INT 1
17737: ST_TO_ADDR
17738: GO 17749
// med1 := - 1 ;
17740: LD_ADDR_VAR 0 1
17744: PUSH
17745: LD_INT 1
17747: NEG
17748: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17749: LD_EXP 12
17753: PUSH
17754: LD_EXP 13
17758: AND
17759: PUSH
17760: LD_EXP 14
17764: AND
17765: IFFALSE 17777
// med2 := 1 else
17767: LD_ADDR_VAR 0 2
17771: PUSH
17772: LD_INT 1
17774: ST_TO_ADDR
17775: GO 17786
// med2 := - 1 ;
17777: LD_ADDR_VAR 0 2
17781: PUSH
17782: LD_INT 1
17784: NEG
17785: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17786: LD_STRING Hero
17788: PPUSH
17789: LD_INT 1
17791: PPUSH
17792: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17796: LD_STRING Artefact
17798: PPUSH
17799: LD_VAR 0 2
17803: PPUSH
17804: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17808: LD_STRING ReconcileBurlak
17810: PPUSH
17811: LD_VAR 0 1
17815: PPUSH
17816: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17820: LD_OWVAR 67
17824: PUSH
17825: LD_INT 3
17827: GREATEREQUAL
17828: PUSH
17829: LD_VAR 0 1
17833: PUSH
17834: LD_INT 1
17836: EQUAL
17837: AND
17838: PUSH
17839: LD_VAR 0 2
17843: PUSH
17844: LD_INT 1
17846: EQUAL
17847: AND
17848: IFFALSE 17860
// SetAchievementEX ( ACH_AMER , 19 ) ;
17850: LD_STRING ACH_AMER
17852: PPUSH
17853: LD_INT 19
17855: PPUSH
17856: CALL_OW 564
// GiveMedals ( MAIN ) ;
17860: LD_STRING MAIN
17862: PPUSH
17863: CALL_OW 102
// InGameOff ;
17867: CALL_OW 9
// DialogueOff ;
17871: CALL_OW 7
// music_nat := 1 ;
17875: LD_ADDR_OWVAR 71
17879: PUSH
17880: LD_INT 1
17882: ST_TO_ADDR
// music_class := 4 ;
17883: LD_ADDR_OWVAR 72
17887: PUSH
17888: LD_INT 4
17890: ST_TO_ADDR
// YouWin ;
17891: CALL_OW 103
// end ; end_of_file
17895: PPOPN 2
17897: END
// export function InitNature ; begin
17898: LD_INT 0
17900: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17901: LD_INT 3
17903: PPUSH
17904: LD_INT 3
17906: PPUSH
17907: LD_INT 2
17909: PPUSH
17910: LD_INT 1
17912: PPUSH
17913: LD_INT 1
17915: PPUSH
17916: LD_INT 0
17918: PPUSH
17919: LD_INT 0
17921: PPUSH
17922: LD_INT 17
17924: PPUSH
17925: LD_INT 0
17927: PPUSH
17928: CALL 85389 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17932: LD_INT 2
17934: PPUSH
17935: LD_INT 1
17937: PPUSH
17938: LD_INT 1
17940: PPUSH
17941: LD_INT 1
17943: PPUSH
17944: LD_INT 1
17946: PPUSH
17947: LD_INT 0
17949: PPUSH
17950: LD_INT 0
17952: PPUSH
17953: LD_INT 18
17955: PPUSH
17956: LD_INT 0
17958: PPUSH
17959: CALL 85389 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17963: LD_INT 4
17965: PPUSH
17966: LD_INT 1
17968: PPUSH
17969: LD_INT 2
17971: PPUSH
17972: LD_INT 4
17974: PPUSH
17975: LD_INT 2
17977: PPUSH
17978: LD_INT 1
17980: PPUSH
17981: LD_INT 0
17983: PPUSH
17984: LD_INT 19
17986: PPUSH
17987: LD_INT 0
17989: PPUSH
17990: CALL 85389 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17994: LD_INT 0
17996: PPUSH
17997: LD_INT 0
17999: PPUSH
18000: LD_INT 0
18002: PPUSH
18003: LD_INT 0
18005: PPUSH
18006: LD_INT 0
18008: PPUSH
18009: LD_INT 0
18011: PPUSH
18012: LD_INT 9
18014: PPUSH
18015: LD_INT 0
18017: PPUSH
18018: LD_INT 20
18020: PPUSH
18021: CALL 85389 0 9
// end ; end_of_file
18025: LD_VAR 0 1
18029: RET
// every 0 0$30 do var time ;
18030: GO 18032
18032: DISABLE
18033: LD_INT 0
18035: PPUSH
// begin time := 0 0$30 ;
18036: LD_ADDR_VAR 0 1
18040: PUSH
18041: LD_INT 1050
18043: ST_TO_ADDR
// repeat wait ( time ) ;
18044: LD_VAR 0 1
18048: PPUSH
18049: CALL_OW 67
// if Prob ( 50 ) then
18053: LD_INT 50
18055: PPUSH
18056: CALL_OW 13
18060: IFFALSE 18089
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18062: LD_INT 1
18064: PPUSH
18065: LD_INT 5
18067: PPUSH
18068: CALL_OW 12
18072: PPUSH
18073: LD_INT 106
18075: PPUSH
18076: LD_INT 89
18078: PPUSH
18079: LD_INT 45
18081: PPUSH
18082: LD_INT 1
18084: PPUSH
18085: CALL_OW 56
// time := time + 0 0$3 ;
18089: LD_ADDR_VAR 0 1
18093: PUSH
18094: LD_VAR 0 1
18098: PUSH
18099: LD_INT 105
18101: PLUS
18102: ST_TO_ADDR
// if Prob ( 30 ) then
18103: LD_INT 30
18105: PPUSH
18106: CALL_OW 13
18110: IFFALSE 18156
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18112: LD_INT 525
18114: PPUSH
18115: LD_INT 735
18117: PPUSH
18118: CALL_OW 12
18122: PPUSH
18123: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18127: LD_INT 1
18129: PPUSH
18130: LD_INT 5
18132: PPUSH
18133: CALL_OW 12
18137: PPUSH
18138: LD_INT 21
18140: PPUSH
18141: LD_INT 26
18143: PPUSH
18144: LD_INT 12
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL_OW 56
// end else
18154: GO 18192
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18156: LD_INT 700
18158: PPUSH
18159: LD_INT 1225
18161: PPUSH
18162: CALL_OW 12
18166: PPUSH
18167: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18171: LD_INT 1
18173: PPUSH
18174: LD_INT 5
18176: PPUSH
18177: CALL_OW 12
18181: PPUSH
18182: LD_INT 14
18184: PPUSH
18185: LD_INT 1
18187: PPUSH
18188: CALL_OW 55
// end ; if Prob ( 50 ) then
18192: LD_INT 50
18194: PPUSH
18195: CALL_OW 13
18199: IFFALSE 18245
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18201: LD_INT 700
18203: PPUSH
18204: LD_INT 1050
18206: PPUSH
18207: CALL_OW 12
18211: PPUSH
18212: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18216: LD_INT 1
18218: PPUSH
18219: LD_INT 5
18221: PPUSH
18222: CALL_OW 12
18226: PPUSH
18227: LD_INT 181
18229: PPUSH
18230: LD_INT 218
18232: PPUSH
18233: LD_INT 16
18235: PPUSH
18236: LD_INT 1
18238: PPUSH
18239: CALL_OW 56
// end else
18243: GO 18317
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18245: LD_INT 350
18247: PPUSH
18248: LD_INT 525
18250: PPUSH
18251: CALL_OW 12
18255: PPUSH
18256: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18260: LD_INT 1
18262: PPUSH
18263: LD_INT 5
18265: PPUSH
18266: CALL_OW 12
18270: PPUSH
18271: LD_INT 13
18273: PPUSH
18274: LD_INT 1
18276: PPUSH
18277: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18281: LD_INT 350
18283: PPUSH
18284: LD_INT 700
18286: PPUSH
18287: CALL_OW 12
18291: PPUSH
18292: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18296: LD_INT 1
18298: PPUSH
18299: LD_INT 5
18301: PPUSH
18302: CALL_OW 12
18306: PPUSH
18307: LD_INT 33
18309: PPUSH
18310: LD_INT 1
18312: PPUSH
18313: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18317: LD_INT 65
18319: PUSH
18320: LD_INT 62
18322: PUSH
18323: LD_INT 55
18325: PUSH
18326: LD_INT 50
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: LIST
18333: LIST
18334: PUSH
18335: LD_OWVAR 67
18339: ARRAY
18340: PPUSH
18341: CALL_OW 13
18345: IFFALSE 18391
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18347: LD_INT 525
18349: PPUSH
18350: LD_INT 875
18352: PPUSH
18353: CALL_OW 12
18357: PPUSH
18358: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18362: LD_INT 1
18364: PPUSH
18365: LD_INT 5
18367: PPUSH
18368: CALL_OW 12
18372: PPUSH
18373: LD_INT 294
18375: PPUSH
18376: LD_INT 211
18378: PPUSH
18379: LD_INT 30
18381: PPUSH
18382: LD_INT 1
18384: PPUSH
18385: CALL_OW 56
// end else
18389: GO 18433
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18391: LD_INT 420
18393: PPUSH
18394: LD_INT 770
18396: PPUSH
18397: CALL_OW 12
18401: PPUSH
18402: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18406: LD_INT 1
18408: PPUSH
18409: LD_INT 5
18411: PPUSH
18412: CALL_OW 12
18416: PPUSH
18417: LD_INT 294
18419: PPUSH
18420: LD_INT 211
18422: PPUSH
18423: LD_INT 30
18425: PPUSH
18426: LD_INT 1
18428: PPUSH
18429: CALL_OW 56
// end ; if time > 2 2$20 then
18433: LD_VAR 0 1
18437: PUSH
18438: LD_INT 4900
18440: GREATER
18441: IFFALSE 18451
// time := 0 0$50 ;
18443: LD_ADDR_VAR 0 1
18447: PUSH
18448: LD_INT 1750
18450: ST_TO_ADDR
// until false ;
18451: LD_INT 0
18453: IFFALSE 18044
// end ;
18455: PPOPN 1
18457: END
// every 0 0$45 trigger tick < 10 10$00 do
18458: LD_OWVAR 1
18462: PUSH
18463: LD_INT 21000
18465: LESS
18466: IFFALSE 18514
18468: GO 18470
18470: DISABLE
// begin enable ;
18471: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18472: LD_INT 350
18474: PPUSH
18475: LD_INT 700
18477: PPUSH
18478: CALL_OW 12
18482: PPUSH
18483: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18487: LD_INT 3
18489: PPUSH
18490: LD_INT 5
18492: PPUSH
18493: CALL_OW 12
18497: PPUSH
18498: LD_INT 181
18500: PPUSH
18501: LD_INT 13
18503: PPUSH
18504: LD_INT 20
18506: PPUSH
18507: LD_INT 1
18509: PPUSH
18510: CALL_OW 56
// end ; end_of_file
18514: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18515: LD_INT 0
18517: PPUSH
// SetArtifactRes ( 7 , true ) ;
18518: LD_INT 7
18520: PPUSH
18521: LD_INT 1
18523: PPUSH
18524: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18528: LD_ADDR_EXP 64
18532: PUSH
18533: EMPTY
18534: PUSH
18535: EMPTY
18536: PUSH
18537: EMPTY
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18544: LD_ADDR_EXP 65
18548: PUSH
18549: LD_INT 1050
18551: PUSH
18552: LD_OWVAR 67
18556: MUL
18557: PUSH
18558: LD_INT 2800
18560: PUSH
18561: LD_OWVAR 67
18565: MUL
18566: PUSH
18567: LD_INT 1
18569: NEG
18570: PUSH
18571: EMPTY
18572: LIST
18573: LIST
18574: LIST
18575: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18576: LD_ADDR_EXP 66
18580: PUSH
18581: LD_INT 10
18583: PUSH
18584: LD_INT 35
18586: PUSH
18587: LD_INT 100
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: LIST
18594: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18595: LD_ADDR_EXP 67
18599: PUSH
18600: LD_INT 0
18602: PUSH
18603: LD_INT 0
18605: PUSH
18606: LD_INT 0
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18614: LD_ADDR_EXP 69
18618: PUSH
18619: LD_INT 300
18621: PUSH
18622: LD_INT 500
18624: PUSH
18625: LD_INT 800
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: LIST
18632: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18633: LD_ADDR_EXP 70
18637: PUSH
18638: LD_INT 0
18640: PUSH
18641: LD_INT 0
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18652: LD_ADDR_EXP 71
18656: PUSH
18657: LD_INT 0
18659: PUSH
18660: LD_INT 0
18662: PUSH
18663: LD_INT 0
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: LIST
18670: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18671: LD_ADDR_EXP 68
18675: PUSH
18676: LD_INT 0
18678: PUSH
18679: LD_INT 0
18681: PUSH
18682: LD_INT 0
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: LIST
18689: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18690: LD_ADDR_EXP 72
18694: PUSH
18695: LD_INT 4
18697: PUSH
18698: LD_INT 3
18700: PUSH
18701: LD_INT 1
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 5
18711: PUSH
18712: LD_INT 4
18714: PUSH
18715: LD_INT 2
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 6
18725: PUSH
18726: LD_INT 3
18728: PUSH
18729: LD_INT 3
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: LIST
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: LIST
18741: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18742: LD_ADDR_EXP 73
18746: PUSH
18747: LD_INT 0
18749: PUSH
18750: LD_INT 0
18752: PUSH
18753: LD_INT 0
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// end ;
18761: LD_VAR 0 1
18765: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18766: LD_INT 24
18768: PPUSH
18769: LD_INT 7
18771: PPUSH
18772: CALL_OW 321
18776: PUSH
18777: LD_INT 2
18779: EQUAL
18780: IFFALSE 19706
18782: GO 18784
18784: DISABLE
18785: LD_INT 0
18787: PPUSH
18788: PPUSH
18789: PPUSH
18790: PPUSH
18791: PPUSH
// begin enable ;
18792: ENABLE
// for i = 1 to 3 do
18793: LD_ADDR_VAR 0 1
18797: PUSH
18798: DOUBLE
18799: LD_INT 1
18801: DEC
18802: ST_TO_ADDR
18803: LD_INT 3
18805: PUSH
18806: FOR_TO
18807: IFFALSE 19704
// begin pos := FindArtifact ( i + 2 ) ;
18809: LD_ADDR_VAR 0 2
18813: PUSH
18814: LD_VAR 0 1
18818: PUSH
18819: LD_INT 2
18821: PLUS
18822: PPUSH
18823: CALL_OW 469
18827: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18828: LD_ADDR_EXP 64
18832: PUSH
18833: LD_EXP 64
18837: PPUSH
18838: LD_VAR 0 1
18842: PPUSH
18843: LD_VAR 0 2
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// if pos then
18853: LD_VAR 0 2
18857: IFFALSE 19565
// begin case i of 1 :
18859: LD_VAR 0 1
18863: PUSH
18864: LD_INT 1
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18949
18872: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18873: LD_ADDR_VAR 0 4
18877: PUSH
18878: LD_INT 22
18880: PUSH
18881: LD_INT 7
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PUSH
18888: LD_INT 23
18890: PUSH
18891: LD_INT 1
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: PUSH
18898: LD_INT 2
18900: PUSH
18901: LD_INT 30
18903: PUSH
18904: LD_INT 8
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: PUSH
18911: LD_INT 30
18913: PUSH
18914: LD_INT 7
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 11
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: LIST
18941: PPUSH
18942: CALL_OW 69
18946: ST_TO_ADDR
18947: GO 19057
18949: LD_INT 2
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 19034
18957: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18958: LD_ADDR_VAR 0 4
18962: PUSH
18963: LD_INT 22
18965: PUSH
18966: LD_INT 7
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: PUSH
18973: LD_INT 23
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: EMPTY
18980: LIST
18981: LIST
18982: PUSH
18983: LD_INT 2
18985: PUSH
18986: LD_INT 30
18988: PUSH
18989: LD_INT 8
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: PUSH
18996: LD_INT 30
18998: PUSH
18999: LD_INT 7
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PUSH
19006: LD_INT 30
19008: PUSH
19009: LD_INT 11
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PUSH
19016: EMPTY
19017: LIST
19018: LIST
19019: LIST
19020: LIST
19021: PUSH
19022: EMPTY
19023: LIST
19024: LIST
19025: LIST
19026: PPUSH
19027: CALL_OW 69
19031: ST_TO_ADDR
19032: GO 19057
19034: LD_INT 3
19036: DOUBLE
19037: EQUAL
19038: IFTRUE 19042
19040: GO 19056
19042: POP
// labs := [ alien ] ; end ;
19043: LD_ADDR_VAR 0 4
19047: PUSH
19048: LD_INT 1
19050: PUSH
19051: EMPTY
19052: LIST
19053: ST_TO_ADDR
19054: GO 19057
19056: POP
// if not labs then
19057: LD_VAR 0 4
19061: NOT
19062: IFFALSE 19066
// continue ;
19064: GO 18806
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19066: LD_ADDR_VAR 0 5
19070: PUSH
19071: LD_VAR 0 4
19075: PPUSH
19076: LD_EXP 64
19080: PUSH
19081: LD_VAR 0 1
19085: ARRAY
19086: PUSH
19087: LD_INT 1
19089: ARRAY
19090: PPUSH
19091: LD_EXP 64
19095: PUSH
19096: LD_VAR 0 1
19100: ARRAY
19101: PUSH
19102: LD_INT 2
19104: ARRAY
19105: PPUSH
19106: CALL_OW 73
19110: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19111: LD_VAR 0 5
19115: NOT
19116: PUSH
19117: LD_VAR 0 5
19121: PUSH
19122: LD_EXP 71
19126: PUSH
19127: LD_VAR 0 1
19131: ARRAY
19132: NONEQUAL
19133: OR
19134: IFFALSE 19239
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19136: LD_INT 7
19138: PPUSH
19139: LD_EXP 72
19143: PUSH
19144: LD_VAR 0 1
19148: ARRAY
19149: PUSH
19150: LD_INT 3
19152: ARRAY
19153: PPUSH
19154: LD_INT 0
19156: PPUSH
19157: LD_EXP 71
19161: PUSH
19162: LD_VAR 0 1
19166: ARRAY
19167: PPUSH
19168: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19172: LD_INT 7
19174: PPUSH
19175: LD_EXP 72
19179: PUSH
19180: LD_VAR 0 1
19184: ARRAY
19185: PUSH
19186: LD_INT 1
19188: ARRAY
19189: PPUSH
19190: LD_INT 0
19192: PPUSH
19193: LD_EXP 71
19197: PUSH
19198: LD_VAR 0 1
19202: ARRAY
19203: PPUSH
19204: CALL_OW 468
// if nearestLab then
19208: LD_VAR 0 5
19212: IFFALSE 19239
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19214: LD_ADDR_EXP 71
19218: PUSH
19219: LD_EXP 71
19223: PPUSH
19224: LD_VAR 0 1
19228: PPUSH
19229: LD_VAR 0 5
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// end ; if not nearestLab then
19239: LD_VAR 0 5
19243: NOT
19244: IFFALSE 19248
// continue ;
19246: GO 18806
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19248: LD_VAR 0 5
19252: PPUSH
19253: LD_EXP 64
19257: PUSH
19258: LD_VAR 0 1
19262: ARRAY
19263: PUSH
19264: LD_INT 1
19266: ARRAY
19267: PPUSH
19268: LD_EXP 64
19272: PUSH
19273: LD_VAR 0 1
19277: ARRAY
19278: PUSH
19279: LD_INT 2
19281: ARRAY
19282: PPUSH
19283: CALL_OW 297
19287: PUSH
19288: LD_INT 8
19290: LESS
19291: IFFALSE 19488
// begin if not artifactsResearched [ i ] then
19293: LD_EXP 67
19297: PUSH
19298: LD_VAR 0 1
19302: ARRAY
19303: NOT
19304: IFFALSE 19385
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19306: LD_VAR 0 5
19310: PPUSH
19311: CALL_OW 461
19315: PUSH
19316: LD_INT 2
19318: EQUAL
19319: IFFALSE 19353
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19321: LD_INT 7
19323: PPUSH
19324: LD_EXP 72
19328: PUSH
19329: LD_VAR 0 1
19333: ARRAY
19334: PUSH
19335: LD_INT 3
19337: ARRAY
19338: PPUSH
19339: LD_INT 2
19341: PPUSH
19342: LD_VAR 0 5
19346: PPUSH
19347: CALL_OW 468
19351: GO 19383
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19353: LD_INT 7
19355: PPUSH
19356: LD_EXP 72
19360: PUSH
19361: LD_VAR 0 1
19365: ARRAY
19366: PUSH
19367: LD_INT 3
19369: ARRAY
19370: PPUSH
19371: LD_INT 1
19373: PPUSH
19374: LD_VAR 0 5
19378: PPUSH
19379: CALL_OW 468
// end else
19383: GO 19486
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19385: LD_VAR 0 5
19389: PPUSH
19390: CALL_OW 461
19394: PUSH
19395: LD_INT 2
19397: EQUAL
19398: PUSH
19399: LD_EXP 73
19403: PUSH
19404: LD_VAR 0 1
19408: ARRAY
19409: AND
19410: IFFALSE 19456
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19412: LD_INT 7
19414: PPUSH
19415: LD_EXP 72
19419: PUSH
19420: LD_VAR 0 1
19424: ARRAY
19425: PUSH
19426: LD_INT 1
19428: ARRAY
19429: PPUSH
19430: LD_EXP 72
19434: PUSH
19435: LD_VAR 0 1
19439: ARRAY
19440: PUSH
19441: LD_INT 2
19443: ARRAY
19444: PPUSH
19445: LD_VAR 0 5
19449: PPUSH
19450: CALL_OW 468
19454: GO 19486
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19456: LD_INT 7
19458: PPUSH
19459: LD_EXP 72
19463: PUSH
19464: LD_VAR 0 1
19468: ARRAY
19469: PUSH
19470: LD_INT 1
19472: ARRAY
19473: PPUSH
19474: LD_INT 1
19476: PPUSH
19477: LD_VAR 0 5
19481: PPUSH
19482: CALL_OW 468
// end else
19486: GO 19563
// begin if not artifactsResearched [ i ] then
19488: LD_EXP 67
19492: PUSH
19493: LD_VAR 0 1
19497: ARRAY
19498: NOT
19499: IFFALSE 19533
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19501: LD_INT 7
19503: PPUSH
19504: LD_EXP 72
19508: PUSH
19509: LD_VAR 0 1
19513: ARRAY
19514: PUSH
19515: LD_INT 3
19517: ARRAY
19518: PPUSH
19519: LD_INT 0
19521: PPUSH
19522: LD_VAR 0 5
19526: PPUSH
19527: CALL_OW 468
19531: GO 19563
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19533: LD_INT 7
19535: PPUSH
19536: LD_EXP 72
19540: PUSH
19541: LD_VAR 0 1
19545: ARRAY
19546: PUSH
19547: LD_INT 1
19549: ARRAY
19550: PPUSH
19551: LD_INT 0
19553: PPUSH
19554: LD_VAR 0 5
19558: PPUSH
19559: CALL_OW 468
// end ; end else
19563: GO 19702
// begin if not artifactsLabs [ i ] then
19565: LD_EXP 71
19569: PUSH
19570: LD_VAR 0 1
19574: ARRAY
19575: NOT
19576: IFFALSE 19580
// continue ;
19578: GO 18806
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19580: LD_INT 7
19582: PPUSH
19583: LD_EXP 72
19587: PUSH
19588: LD_VAR 0 1
19592: ARRAY
19593: PUSH
19594: LD_INT 3
19596: ARRAY
19597: PPUSH
19598: LD_INT 0
19600: PPUSH
19601: LD_EXP 71
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19616: LD_INT 7
19618: PPUSH
19619: LD_EXP 72
19623: PUSH
19624: LD_VAR 0 1
19628: ARRAY
19629: PUSH
19630: LD_INT 1
19632: ARRAY
19633: PPUSH
19634: LD_INT 0
19636: PPUSH
19637: LD_EXP 71
19641: PUSH
19642: LD_VAR 0 1
19646: ARRAY
19647: PPUSH
19648: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19652: LD_EXP 68
19656: PUSH
19657: LD_VAR 0 1
19661: ARRAY
19662: IFFALSE 19702
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19664: LD_ADDR_EXP 68
19668: PUSH
19669: LD_EXP 68
19673: PPUSH
19674: LD_VAR 0 1
19678: PPUSH
19679: LD_INT 0
19681: PPUSH
19682: CALL_OW 1
19686: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19687: LD_EXP 71
19691: PUSH
19692: LD_VAR 0 1
19696: ARRAY
19697: PPUSH
19698: CALL_OW 127
// end ; end ; end ;
19702: GO 18806
19704: POP
19705: POP
// end ;
19706: PPOPN 5
19708: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19709: LD_INT 0
19711: PPUSH
19712: PPUSH
19713: PPUSH
19714: PPUSH
19715: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19716: LD_VAR 0 2
19720: PUSH
19721: LD_EXP 72
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: LD_INT 3
19732: ARRAY
19733: EQUAL
19734: IFFALSE 19857
// begin lab := artifactsLabs [ 1 ] ;
19736: LD_ADDR_VAR 0 6
19740: PUSH
19741: LD_EXP 71
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: ST_TO_ADDR
// if not lab then
19750: LD_VAR 0 6
19754: NOT
19755: IFFALSE 19759
// exit ;
19757: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19759: LD_VAR 0 6
19763: PPUSH
19764: LD_EXP 69
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_INT 1
19775: PPUSH
19776: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19780: LD_EXP 70
19784: PUSH
19785: LD_INT 1
19787: ARRAY
19788: IFFALSE 19808
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19790: LD_VAR 0 6
19794: PPUSH
19795: LD_EXP 70
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PPUSH
19804: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19808: LD_ADDR_EXP 68
19812: PUSH
19813: LD_EXP 68
19817: PPUSH
19818: LD_INT 1
19820: PPUSH
19821: LD_INT 1
19823: PPUSH
19824: CALL_OW 1
19828: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19829: LD_INT 7
19831: PPUSH
19832: LD_EXP 72
19836: PUSH
19837: LD_INT 1
19839: ARRAY
19840: PUSH
19841: LD_INT 3
19843: ARRAY
19844: PPUSH
19845: LD_INT 0
19847: PPUSH
19848: LD_VAR 0 6
19852: PPUSH
19853: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19857: LD_VAR 0 2
19861: PUSH
19862: LD_EXP 72
19866: PUSH
19867: LD_INT 2
19869: ARRAY
19870: PUSH
19871: LD_INT 3
19873: ARRAY
19874: EQUAL
19875: IFFALSE 19998
// begin lab := artifactsLabs [ 2 ] ;
19877: LD_ADDR_VAR 0 6
19881: PUSH
19882: LD_EXP 71
19886: PUSH
19887: LD_INT 2
19889: ARRAY
19890: ST_TO_ADDR
// if not lab then
19891: LD_VAR 0 6
19895: NOT
19896: IFFALSE 19900
// exit ;
19898: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19900: LD_VAR 0 6
19904: PPUSH
19905: LD_EXP 69
19909: PUSH
19910: LD_INT 2
19912: ARRAY
19913: PPUSH
19914: LD_INT 1
19916: PPUSH
19917: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19921: LD_EXP 70
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: IFFALSE 19949
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19931: LD_VAR 0 6
19935: PPUSH
19936: LD_EXP 70
19940: PUSH
19941: LD_INT 2
19943: ARRAY
19944: PPUSH
19945: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19949: LD_ADDR_EXP 68
19953: PUSH
19954: LD_EXP 68
19958: PPUSH
19959: LD_INT 2
19961: PPUSH
19962: LD_INT 1
19964: PPUSH
19965: CALL_OW 1
19969: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19970: LD_INT 7
19972: PPUSH
19973: LD_EXP 72
19977: PUSH
19978: LD_INT 2
19980: ARRAY
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PPUSH
19986: LD_INT 0
19988: PPUSH
19989: LD_VAR 0 6
19993: PPUSH
19994: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19998: LD_VAR 0 2
20002: PUSH
20003: LD_EXP 72
20007: PUSH
20008: LD_INT 3
20010: ARRAY
20011: PUSH
20012: LD_INT 3
20014: ARRAY
20015: EQUAL
20016: IFFALSE 20139
// begin lab := artifactsLabs [ 3 ] ;
20018: LD_ADDR_VAR 0 6
20022: PUSH
20023: LD_EXP 71
20027: PUSH
20028: LD_INT 3
20030: ARRAY
20031: ST_TO_ADDR
// if not lab then
20032: LD_VAR 0 6
20036: NOT
20037: IFFALSE 20041
// exit ;
20039: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20041: LD_VAR 0 6
20045: PPUSH
20046: LD_EXP 69
20050: PUSH
20051: LD_INT 3
20053: ARRAY
20054: PPUSH
20055: LD_INT 1
20057: PPUSH
20058: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20062: LD_EXP 70
20066: PUSH
20067: LD_INT 3
20069: ARRAY
20070: IFFALSE 20090
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20072: LD_VAR 0 6
20076: PPUSH
20077: LD_EXP 70
20081: PUSH
20082: LD_INT 3
20084: ARRAY
20085: PPUSH
20086: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20090: LD_ADDR_EXP 68
20094: PUSH
20095: LD_EXP 68
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: LD_INT 1
20105: PPUSH
20106: CALL_OW 1
20110: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20111: LD_INT 7
20113: PPUSH
20114: LD_EXP 72
20118: PUSH
20119: LD_INT 3
20121: ARRAY
20122: PUSH
20123: LD_INT 3
20125: ARRAY
20126: PPUSH
20127: LD_INT 0
20129: PPUSH
20130: LD_VAR 0 6
20134: PPUSH
20135: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20139: LD_VAR 0 2
20143: PUSH
20144: LD_EXP 72
20148: PUSH
20149: LD_INT 1
20151: ARRAY
20152: PUSH
20153: LD_INT 1
20155: ARRAY
20156: EQUAL
20157: IFFALSE 20315
// begin lab := artifactsLabs [ 1 ] ;
20159: LD_ADDR_VAR 0 6
20163: PUSH
20164: LD_EXP 71
20168: PUSH
20169: LD_INT 1
20171: ARRAY
20172: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20173: LD_VAR 0 6
20177: PPUSH
20178: CALL_OW 274
20182: PPUSH
20183: CALL 88993 0 1
20187: PUSH
20188: LD_INT 3
20190: ARRAY
20191: PUSH
20192: LD_EXP 66
20196: PUSH
20197: LD_INT 1
20199: ARRAY
20200: LESS
20201: IFFALSE 20215
// begin HintSpec ( ArtifactCost , 2 ) ;
20203: LD_STRING ArtifactCost
20205: PPUSH
20206: LD_INT 2
20208: PPUSH
20209: CALL_OW 338
// exit ;
20213: GO 20837
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20215: LD_ADDR_EXP 73
20219: PUSH
20220: LD_EXP 73
20224: PPUSH
20225: LD_INT 1
20227: PPUSH
20228: LD_INT 0
20230: PPUSH
20231: CALL_OW 1
20235: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20236: LD_VAR 0 3
20240: PPUSH
20241: LD_VAR 0 4
20245: PPUSH
20246: LD_INT 7
20248: PPUSH
20249: LD_INT 12
20251: NEG
20252: PPUSH
20253: CALL_OW 330
// wait ( 0 0$30 ) ;
20257: LD_INT 1050
20259: PPUSH
20260: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20264: LD_VAR 0 3
20268: PPUSH
20269: LD_VAR 0 4
20273: PPUSH
20274: LD_INT 7
20276: PPUSH
20277: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20281: LD_EXP 65
20285: PUSH
20286: LD_INT 1
20288: ARRAY
20289: PPUSH
20290: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20294: LD_ADDR_EXP 73
20298: PUSH
20299: LD_EXP 73
20303: PPUSH
20304: LD_INT 1
20306: PPUSH
20307: LD_INT 1
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20315: LD_VAR 0 2
20319: PUSH
20320: LD_EXP 72
20324: PUSH
20325: LD_INT 2
20327: ARRAY
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: EQUAL
20333: IFFALSE 20570
// begin lab := artifactsLabs [ 2 ] ;
20335: LD_ADDR_VAR 0 6
20339: PUSH
20340: LD_EXP 71
20344: PUSH
20345: LD_INT 2
20347: ARRAY
20348: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20349: LD_VAR 0 3
20353: PUSH
20354: LD_INT 81
20356: PUSH
20357: LD_INT 7
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: LD_INT 2
20366: PUSH
20367: LD_INT 32
20369: PUSH
20370: LD_INT 3
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 30
20379: PUSH
20380: LD_INT 28
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 30
20389: PUSH
20390: LD_INT 30
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 35
20399: PUSH
20400: LD_INT 49
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 34
20409: PUSH
20410: LD_INT 49
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 30
20419: PUSH
20420: LD_INT 21
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL_OW 69
20444: IN
20445: NOT
20446: IFFALSE 20450
// exit ;
20448: GO 20837
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20450: LD_VAR 0 6
20454: PPUSH
20455: CALL_OW 274
20459: PPUSH
20460: CALL 88993 0 1
20464: PUSH
20465: LD_INT 3
20467: ARRAY
20468: PUSH
20469: LD_EXP 66
20473: PUSH
20474: LD_INT 2
20476: ARRAY
20477: LESS
20478: IFFALSE 20492
// begin HintSpec ( ArtifactCost , 2 ) ;
20480: LD_STRING ArtifactCost
20482: PPUSH
20483: LD_INT 2
20485: PPUSH
20486: CALL_OW 338
// exit ;
20490: GO 20837
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20492: LD_ADDR_EXP 73
20496: PUSH
20497: LD_EXP 73
20501: PPUSH
20502: LD_INT 2
20504: PPUSH
20505: LD_INT 0
20507: PPUSH
20508: CALL_OW 1
20512: ST_TO_ADDR
// KillUnit ( x ) ;
20513: LD_VAR 0 3
20517: PPUSH
20518: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20522: LD_ADDR_EXP 16
20526: PUSH
20527: LD_EXP 16
20531: PUSH
20532: LD_INT 1
20534: PLUS
20535: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20536: LD_EXP 65
20540: PUSH
20541: LD_INT 2
20543: ARRAY
20544: PPUSH
20545: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20549: LD_ADDR_EXP 73
20553: PUSH
20554: LD_EXP 73
20558: PPUSH
20559: LD_INT 2
20561: PPUSH
20562: LD_INT 1
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20570: LD_VAR 0 2
20574: PUSH
20575: LD_EXP 72
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PUSH
20584: LD_INT 1
20586: ARRAY
20587: EQUAL
20588: IFFALSE 20837
// begin lab := artifactsLabs [ 3 ] ;
20590: LD_ADDR_VAR 0 6
20594: PUSH
20595: LD_EXP 71
20599: PUSH
20600: LD_INT 3
20602: ARRAY
20603: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20604: LD_VAR 0 6
20608: PPUSH
20609: CALL_OW 274
20613: PPUSH
20614: CALL 88993 0 1
20618: PUSH
20619: LD_INT 3
20621: ARRAY
20622: PUSH
20623: LD_EXP 66
20627: PUSH
20628: LD_INT 3
20630: ARRAY
20631: LESS
20632: IFFALSE 20646
// begin HintSpec ( ArtifactCost , 2 ) ;
20634: LD_STRING ArtifactCost
20636: PPUSH
20637: LD_INT 2
20639: PPUSH
20640: CALL_OW 338
// exit ;
20644: GO 20837
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20646: LD_INT 37
20648: PPUSH
20649: LD_INT 1
20651: PPUSH
20652: CALL_OW 424
// time := 0 0$30 ;
20656: LD_ADDR_VAR 0 7
20660: PUSH
20661: LD_INT 1050
20663: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20664: LD_ADDR_EXP 73
20668: PUSH
20669: LD_EXP 73
20673: PPUSH
20674: LD_INT 3
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 1
20684: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20685: LD_ADDR_OWVAR 47
20689: PUSH
20690: LD_STRING #Am15a-1
20692: PUSH
20693: LD_VAR 0 7
20697: PUSH
20698: EMPTY
20699: LIST
20700: LIST
20701: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20702: LD_INT 35
20704: PPUSH
20705: CALL_OW 67
// time := time - 0 0$1 ;
20709: LD_ADDR_VAR 0 7
20713: PUSH
20714: LD_VAR 0 7
20718: PUSH
20719: LD_INT 35
20721: MINUS
20722: ST_TO_ADDR
// until time = 0 0$00 ;
20723: LD_VAR 0 7
20727: PUSH
20728: LD_INT 0
20730: EQUAL
20731: IFFALSE 20685
// display_strings :=  ;
20733: LD_ADDR_OWVAR 47
20737: PUSH
20738: LD_STRING 
20740: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20741: LD_INT 37
20743: PPUSH
20744: LD_INT 0
20746: PPUSH
20747: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20751: LD_ADDR_VAR 0 8
20755: PUSH
20756: LD_INT 37
20758: PPUSH
20759: LD_INT 3
20761: PUSH
20762: LD_INT 21
20764: PUSH
20765: LD_INT 3
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: PUSH
20772: EMPTY
20773: LIST
20774: LIST
20775: PPUSH
20776: CALL_OW 70
20780: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20781: LD_VAR 0 3
20785: PPUSH
20786: LD_VAR 0 4
20790: PPUSH
20791: CALL_OW 84
// for un in list do
20795: LD_ADDR_VAR 0 9
20799: PUSH
20800: LD_VAR 0 8
20804: PUSH
20805: FOR_IN
20806: IFFALSE 20835
// TeleportUnit ( un , x , y , 12 , true ) ;
20808: LD_VAR 0 9
20812: PPUSH
20813: LD_VAR 0 3
20817: PPUSH
20818: LD_VAR 0 4
20822: PPUSH
20823: LD_INT 12
20825: PPUSH
20826: LD_INT 1
20828: PPUSH
20829: CALL_OW 483
20833: GO 20805
20835: POP
20836: POP
// end ; end ;
20837: PPOPN 9
20839: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20840: LD_INT 0
20842: PPUSH
20843: PPUSH
// begin labNum := 0 ;
20844: LD_ADDR_VAR 0 4
20848: PUSH
20849: LD_INT 0
20851: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20852: LD_ADDR_VAR 0 3
20856: PUSH
20857: DOUBLE
20858: LD_INT 1
20860: DEC
20861: ST_TO_ADDR
20862: LD_EXP 71
20866: PUSH
20867: FOR_TO
20868: IFFALSE 20902
// if artifactsLabs [ i ] = lab then
20870: LD_EXP 71
20874: PUSH
20875: LD_VAR 0 3
20879: ARRAY
20880: PUSH
20881: LD_VAR 0 1
20885: EQUAL
20886: IFFALSE 20900
// begin labNum := i ;
20888: LD_ADDR_VAR 0 4
20892: PUSH
20893: LD_VAR 0 3
20897: ST_TO_ADDR
// break ;
20898: GO 20902
// end ;
20900: GO 20867
20902: POP
20903: POP
// if not labNum then
20904: LD_VAR 0 4
20908: NOT
20909: IFFALSE 20913
// exit ;
20911: GO 20991
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20913: LD_INT 7
20915: PPUSH
20916: LD_EXP 72
20920: PUSH
20921: LD_VAR 0 4
20925: ARRAY
20926: PUSH
20927: LD_INT 3
20929: ARRAY
20930: PPUSH
20931: LD_INT 2
20933: PPUSH
20934: LD_VAR 0 1
20938: PPUSH
20939: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20943: LD_ADDR_EXP 70
20947: PUSH
20948: LD_EXP 70
20952: PPUSH
20953: LD_VAR 0 4
20957: PPUSH
20958: LD_VAR 0 2
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20968: LD_ADDR_EXP 68
20972: PUSH
20973: LD_EXP 68
20977: PPUSH
20978: LD_VAR 0 4
20982: PPUSH
20983: LD_INT 0
20985: PPUSH
20986: CALL_OW 1
20990: ST_TO_ADDR
// end ;
20991: PPOPN 4
20993: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20994: LD_INT 0
20996: PPUSH
20997: PPUSH
// begin labNum := 0 ;
20998: LD_ADDR_VAR 0 3
21002: PUSH
21003: LD_INT 0
21005: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21006: LD_ADDR_VAR 0 2
21010: PUSH
21011: DOUBLE
21012: LD_INT 1
21014: DEC
21015: ST_TO_ADDR
21016: LD_EXP 71
21020: PUSH
21021: FOR_TO
21022: IFFALSE 21056
// if artifactsLabs [ i ] = lab then
21024: LD_EXP 71
21028: PUSH
21029: LD_VAR 0 2
21033: ARRAY
21034: PUSH
21035: LD_VAR 0 1
21039: EQUAL
21040: IFFALSE 21054
// begin labNum := i ;
21042: LD_ADDR_VAR 0 3
21046: PUSH
21047: LD_VAR 0 2
21051: ST_TO_ADDR
// break ;
21052: GO 21056
// end ;
21054: GO 21021
21056: POP
21057: POP
// if not labNum then
21058: LD_VAR 0 3
21062: NOT
21063: IFFALSE 21067
// exit ;
21065: GO 21229
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21067: LD_INT 7
21069: PPUSH
21070: LD_EXP 72
21074: PUSH
21075: LD_VAR 0 3
21079: ARRAY
21080: PUSH
21081: LD_INT 3
21083: ARRAY
21084: PPUSH
21085: LD_INT 0
21087: PPUSH
21088: LD_VAR 0 1
21092: PPUSH
21093: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21097: LD_ADDR_EXP 67
21101: PUSH
21102: LD_EXP 67
21106: PPUSH
21107: LD_VAR 0 3
21111: PPUSH
21112: LD_INT 1
21114: PPUSH
21115: CALL_OW 1
21119: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21120: LD_ADDR_EXP 73
21124: PUSH
21125: LD_EXP 73
21129: PPUSH
21130: LD_VAR 0 3
21134: PPUSH
21135: LD_INT 1
21137: PPUSH
21138: CALL_OW 1
21142: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21143: LD_ADDR_EXP 68
21147: PUSH
21148: LD_EXP 68
21152: PPUSH
21153: LD_VAR 0 3
21157: PPUSH
21158: LD_INT 0
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// case labNum of 1 :
21166: LD_VAR 0 3
21170: PUSH
21171: LD_INT 1
21173: DOUBLE
21174: EQUAL
21175: IFTRUE 21179
21177: GO 21190
21179: POP
// artifactIResearched := true ; 2 :
21180: LD_ADDR_EXP 12
21184: PUSH
21185: LD_INT 1
21187: ST_TO_ADDR
21188: GO 21229
21190: LD_INT 2
21192: DOUBLE
21193: EQUAL
21194: IFTRUE 21198
21196: GO 21209
21198: POP
// artifactIIResearched := true ; 3 :
21199: LD_ADDR_EXP 13
21203: PUSH
21204: LD_INT 1
21206: ST_TO_ADDR
21207: GO 21229
21209: LD_INT 3
21211: DOUBLE
21212: EQUAL
21213: IFTRUE 21217
21215: GO 21228
21217: POP
// artifactIIIResearched := true ; end ;
21218: LD_ADDR_EXP 14
21222: PUSH
21223: LD_INT 1
21225: ST_TO_ADDR
21226: GO 21229
21228: POP
// end ; end_of_file
21229: PPOPN 3
21231: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
21232: LD_INT 0
21234: PPUSH
// ar_miner := 81 ;
21235: LD_ADDR_EXP 81
21239: PUSH
21240: LD_INT 81
21242: ST_TO_ADDR
// ar_crane := 88 ;
21243: LD_ADDR_EXP 80
21247: PUSH
21248: LD_INT 88
21250: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21251: LD_ADDR_EXP 75
21255: PUSH
21256: LD_INT 89
21258: ST_TO_ADDR
// us_hack := 99 ;
21259: LD_ADDR_EXP 76
21263: PUSH
21264: LD_INT 99
21266: ST_TO_ADDR
// us_artillery := 97 ;
21267: LD_ADDR_EXP 77
21271: PUSH
21272: LD_INT 97
21274: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21275: LD_ADDR_EXP 78
21279: PUSH
21280: LD_INT 91
21282: ST_TO_ADDR
// ar_mortar := 92 ;
21283: LD_ADDR_EXP 79
21287: PUSH
21288: LD_INT 92
21290: ST_TO_ADDR
// ru_radar := 98 ;
21291: LD_ADDR_EXP 74
21295: PUSH
21296: LD_INT 98
21298: ST_TO_ADDR
// tech_Artillery := 80 ;
21299: LD_ADDR_EXP 82
21303: PUSH
21304: LD_INT 80
21306: ST_TO_ADDR
// tech_RadMat := 81 ;
21307: LD_ADDR_EXP 83
21311: PUSH
21312: LD_INT 81
21314: ST_TO_ADDR
// tech_BasicTools := 82 ;
21315: LD_ADDR_EXP 84
21319: PUSH
21320: LD_INT 82
21322: ST_TO_ADDR
// tech_Cargo := 83 ;
21323: LD_ADDR_EXP 85
21327: PUSH
21328: LD_INT 83
21330: ST_TO_ADDR
// tech_Track := 84 ;
21331: LD_ADDR_EXP 86
21335: PUSH
21336: LD_INT 84
21338: ST_TO_ADDR
// tech_Crane := 85 ;
21339: LD_ADDR_EXP 87
21343: PUSH
21344: LD_INT 85
21346: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21347: LD_ADDR_EXP 88
21351: PUSH
21352: LD_INT 86
21354: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21355: LD_ADDR_EXP 89
21359: PUSH
21360: LD_INT 87
21362: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21363: LD_ADDR_EXP 90
21367: PUSH
21368: LD_INT 88
21370: ST_TO_ADDR
// class_mastodont := 31 ;
21371: LD_ADDR_EXP 91
21375: PUSH
21376: LD_INT 31
21378: ST_TO_ADDR
// class_horse := 21 ;
21379: LD_ADDR_EXP 92
21383: PUSH
21384: LD_INT 21
21386: ST_TO_ADDR
// end ;
21387: LD_VAR 0 1
21391: RET
// every 1 do
21392: GO 21394
21394: DISABLE
// InitGlobalVariables ; end_of_file
21395: CALL 21232 0 0
21399: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21400: LD_INT 0
21402: PPUSH
21403: PPUSH
// skirmish := false ;
21404: LD_ADDR_EXP 93
21408: PUSH
21409: LD_INT 0
21411: ST_TO_ADDR
// debug_mc := false ;
21412: LD_ADDR_EXP 94
21416: PUSH
21417: LD_INT 0
21419: ST_TO_ADDR
// mc_bases := [ ] ;
21420: LD_ADDR_EXP 95
21424: PUSH
21425: EMPTY
21426: ST_TO_ADDR
// mc_sides := [ ] ;
21427: LD_ADDR_EXP 121
21431: PUSH
21432: EMPTY
21433: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21434: LD_ADDR_EXP 96
21438: PUSH
21439: EMPTY
21440: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21441: LD_ADDR_EXP 97
21445: PUSH
21446: EMPTY
21447: ST_TO_ADDR
// mc_need_heal := [ ] ;
21448: LD_ADDR_EXP 98
21452: PUSH
21453: EMPTY
21454: ST_TO_ADDR
// mc_healers := [ ] ;
21455: LD_ADDR_EXP 99
21459: PUSH
21460: EMPTY
21461: ST_TO_ADDR
// mc_build_list := [ ] ;
21462: LD_ADDR_EXP 100
21466: PUSH
21467: EMPTY
21468: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21469: LD_ADDR_EXP 127
21473: PUSH
21474: EMPTY
21475: ST_TO_ADDR
// mc_builders := [ ] ;
21476: LD_ADDR_EXP 101
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// mc_construct_list := [ ] ;
21483: LD_ADDR_EXP 102
21487: PUSH
21488: EMPTY
21489: ST_TO_ADDR
// mc_turret_list := [ ] ;
21490: LD_ADDR_EXP 103
21494: PUSH
21495: EMPTY
21496: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21497: LD_ADDR_EXP 104
21501: PUSH
21502: EMPTY
21503: ST_TO_ADDR
// mc_miners := [ ] ;
21504: LD_ADDR_EXP 109
21508: PUSH
21509: EMPTY
21510: ST_TO_ADDR
// mc_mines := [ ] ;
21511: LD_ADDR_EXP 108
21515: PUSH
21516: EMPTY
21517: ST_TO_ADDR
// mc_minefields := [ ] ;
21518: LD_ADDR_EXP 110
21522: PUSH
21523: EMPTY
21524: ST_TO_ADDR
// mc_crates := [ ] ;
21525: LD_ADDR_EXP 111
21529: PUSH
21530: EMPTY
21531: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21532: LD_ADDR_EXP 112
21536: PUSH
21537: EMPTY
21538: ST_TO_ADDR
// mc_crates_area := [ ] ;
21539: LD_ADDR_EXP 113
21543: PUSH
21544: EMPTY
21545: ST_TO_ADDR
// mc_vehicles := [ ] ;
21546: LD_ADDR_EXP 114
21550: PUSH
21551: EMPTY
21552: ST_TO_ADDR
// mc_attack := [ ] ;
21553: LD_ADDR_EXP 115
21557: PUSH
21558: EMPTY
21559: ST_TO_ADDR
// mc_produce := [ ] ;
21560: LD_ADDR_EXP 116
21564: PUSH
21565: EMPTY
21566: ST_TO_ADDR
// mc_defender := [ ] ;
21567: LD_ADDR_EXP 117
21571: PUSH
21572: EMPTY
21573: ST_TO_ADDR
// mc_parking := [ ] ;
21574: LD_ADDR_EXP 119
21578: PUSH
21579: EMPTY
21580: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21581: LD_ADDR_EXP 105
21585: PUSH
21586: EMPTY
21587: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21588: LD_ADDR_EXP 107
21592: PUSH
21593: EMPTY
21594: ST_TO_ADDR
// mc_scan := [ ] ;
21595: LD_ADDR_EXP 118
21599: PUSH
21600: EMPTY
21601: ST_TO_ADDR
// mc_scan_area := [ ] ;
21602: LD_ADDR_EXP 120
21606: PUSH
21607: EMPTY
21608: ST_TO_ADDR
// mc_tech := [ ] ;
21609: LD_ADDR_EXP 122
21613: PUSH
21614: EMPTY
21615: ST_TO_ADDR
// mc_class := [ ] ;
21616: LD_ADDR_EXP 136
21620: PUSH
21621: EMPTY
21622: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21623: LD_ADDR_EXP 137
21627: PUSH
21628: EMPTY
21629: ST_TO_ADDR
// mc_is_defending := [ ] ;
21630: LD_ADDR_EXP 138
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// end ;
21637: LD_VAR 0 1
21641: RET
// export function MC_Kill ( base ) ; begin
21642: LD_INT 0
21644: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21645: LD_ADDR_EXP 95
21649: PUSH
21650: LD_EXP 95
21654: PPUSH
21655: LD_VAR 0 1
21659: PPUSH
21660: EMPTY
21661: PPUSH
21662: CALL_OW 1
21666: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21667: LD_ADDR_EXP 96
21671: PUSH
21672: LD_EXP 96
21676: PPUSH
21677: LD_VAR 0 1
21681: PPUSH
21682: EMPTY
21683: PPUSH
21684: CALL_OW 1
21688: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21689: LD_ADDR_EXP 97
21693: PUSH
21694: LD_EXP 97
21698: PPUSH
21699: LD_VAR 0 1
21703: PPUSH
21704: EMPTY
21705: PPUSH
21706: CALL_OW 1
21710: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21711: LD_ADDR_EXP 98
21715: PUSH
21716: LD_EXP 98
21720: PPUSH
21721: LD_VAR 0 1
21725: PPUSH
21726: EMPTY
21727: PPUSH
21728: CALL_OW 1
21732: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21733: LD_ADDR_EXP 99
21737: PUSH
21738: LD_EXP 99
21742: PPUSH
21743: LD_VAR 0 1
21747: PPUSH
21748: EMPTY
21749: PPUSH
21750: CALL_OW 1
21754: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21755: LD_ADDR_EXP 100
21759: PUSH
21760: LD_EXP 100
21764: PPUSH
21765: LD_VAR 0 1
21769: PPUSH
21770: EMPTY
21771: PPUSH
21772: CALL_OW 1
21776: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21777: LD_ADDR_EXP 101
21781: PUSH
21782: LD_EXP 101
21786: PPUSH
21787: LD_VAR 0 1
21791: PPUSH
21792: EMPTY
21793: PPUSH
21794: CALL_OW 1
21798: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21799: LD_ADDR_EXP 102
21803: PUSH
21804: LD_EXP 102
21808: PPUSH
21809: LD_VAR 0 1
21813: PPUSH
21814: EMPTY
21815: PPUSH
21816: CALL_OW 1
21820: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21821: LD_ADDR_EXP 103
21825: PUSH
21826: LD_EXP 103
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: EMPTY
21837: PPUSH
21838: CALL_OW 1
21842: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21843: LD_ADDR_EXP 104
21847: PUSH
21848: LD_EXP 104
21852: PPUSH
21853: LD_VAR 0 1
21857: PPUSH
21858: EMPTY
21859: PPUSH
21860: CALL_OW 1
21864: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21865: LD_ADDR_EXP 105
21869: PUSH
21870: LD_EXP 105
21874: PPUSH
21875: LD_VAR 0 1
21879: PPUSH
21880: EMPTY
21881: PPUSH
21882: CALL_OW 1
21886: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21887: LD_ADDR_EXP 106
21891: PUSH
21892: LD_EXP 106
21896: PPUSH
21897: LD_VAR 0 1
21901: PPUSH
21902: LD_INT 0
21904: PPUSH
21905: CALL_OW 1
21909: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21910: LD_ADDR_EXP 107
21914: PUSH
21915: LD_EXP 107
21919: PPUSH
21920: LD_VAR 0 1
21924: PPUSH
21925: EMPTY
21926: PPUSH
21927: CALL_OW 1
21931: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21932: LD_ADDR_EXP 108
21936: PUSH
21937: LD_EXP 108
21941: PPUSH
21942: LD_VAR 0 1
21946: PPUSH
21947: EMPTY
21948: PPUSH
21949: CALL_OW 1
21953: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21954: LD_ADDR_EXP 109
21958: PUSH
21959: LD_EXP 109
21963: PPUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: EMPTY
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21976: LD_ADDR_EXP 110
21980: PUSH
21981: LD_EXP 110
21985: PPUSH
21986: LD_VAR 0 1
21990: PPUSH
21991: EMPTY
21992: PPUSH
21993: CALL_OW 1
21997: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21998: LD_ADDR_EXP 111
22002: PUSH
22003: LD_EXP 111
22007: PPUSH
22008: LD_VAR 0 1
22012: PPUSH
22013: EMPTY
22014: PPUSH
22015: CALL_OW 1
22019: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22020: LD_ADDR_EXP 112
22024: PUSH
22025: LD_EXP 112
22029: PPUSH
22030: LD_VAR 0 1
22034: PPUSH
22035: EMPTY
22036: PPUSH
22037: CALL_OW 1
22041: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22042: LD_ADDR_EXP 113
22046: PUSH
22047: LD_EXP 113
22051: PPUSH
22052: LD_VAR 0 1
22056: PPUSH
22057: EMPTY
22058: PPUSH
22059: CALL_OW 1
22063: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22064: LD_ADDR_EXP 114
22068: PUSH
22069: LD_EXP 114
22073: PPUSH
22074: LD_VAR 0 1
22078: PPUSH
22079: EMPTY
22080: PPUSH
22081: CALL_OW 1
22085: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22086: LD_ADDR_EXP 115
22090: PUSH
22091: LD_EXP 115
22095: PPUSH
22096: LD_VAR 0 1
22100: PPUSH
22101: EMPTY
22102: PPUSH
22103: CALL_OW 1
22107: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22108: LD_ADDR_EXP 116
22112: PUSH
22113: LD_EXP 116
22117: PPUSH
22118: LD_VAR 0 1
22122: PPUSH
22123: EMPTY
22124: PPUSH
22125: CALL_OW 1
22129: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22130: LD_ADDR_EXP 117
22134: PUSH
22135: LD_EXP 117
22139: PPUSH
22140: LD_VAR 0 1
22144: PPUSH
22145: EMPTY
22146: PPUSH
22147: CALL_OW 1
22151: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22152: LD_ADDR_EXP 118
22156: PUSH
22157: LD_EXP 118
22161: PPUSH
22162: LD_VAR 0 1
22166: PPUSH
22167: EMPTY
22168: PPUSH
22169: CALL_OW 1
22173: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22174: LD_ADDR_EXP 119
22178: PUSH
22179: LD_EXP 119
22183: PPUSH
22184: LD_VAR 0 1
22188: PPUSH
22189: EMPTY
22190: PPUSH
22191: CALL_OW 1
22195: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22196: LD_ADDR_EXP 120
22200: PUSH
22201: LD_EXP 120
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: EMPTY
22212: PPUSH
22213: CALL_OW 1
22217: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22218: LD_ADDR_EXP 122
22222: PUSH
22223: LD_EXP 122
22227: PPUSH
22228: LD_VAR 0 1
22232: PPUSH
22233: EMPTY
22234: PPUSH
22235: CALL_OW 1
22239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22240: LD_ADDR_EXP 124
22244: PUSH
22245: LD_EXP 124
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: EMPTY
22256: PPUSH
22257: CALL_OW 1
22261: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22262: LD_ADDR_EXP 125
22266: PUSH
22267: LD_EXP 125
22271: PPUSH
22272: LD_VAR 0 1
22276: PPUSH
22277: EMPTY
22278: PPUSH
22279: CALL_OW 1
22283: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22284: LD_ADDR_EXP 126
22288: PUSH
22289: LD_EXP 126
22293: PPUSH
22294: LD_VAR 0 1
22298: PPUSH
22299: EMPTY
22300: PPUSH
22301: CALL_OW 1
22305: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22306: LD_ADDR_EXP 127
22310: PUSH
22311: LD_EXP 127
22315: PPUSH
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL_OW 1
22327: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22328: LD_ADDR_EXP 128
22332: PUSH
22333: LD_EXP 128
22337: PPUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: EMPTY
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22350: LD_ADDR_EXP 129
22354: PUSH
22355: LD_EXP 129
22359: PPUSH
22360: LD_VAR 0 1
22364: PPUSH
22365: EMPTY
22366: PPUSH
22367: CALL_OW 1
22371: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22372: LD_ADDR_EXP 130
22376: PUSH
22377: LD_EXP 130
22381: PPUSH
22382: LD_VAR 0 1
22386: PPUSH
22387: EMPTY
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22394: LD_ADDR_EXP 131
22398: PUSH
22399: LD_EXP 131
22403: PPUSH
22404: LD_VAR 0 1
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22416: LD_ADDR_EXP 132
22420: PUSH
22421: LD_EXP 132
22425: PPUSH
22426: LD_VAR 0 1
22430: PPUSH
22431: EMPTY
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22438: LD_ADDR_EXP 133
22442: PUSH
22443: LD_EXP 133
22447: PPUSH
22448: LD_VAR 0 1
22452: PPUSH
22453: EMPTY
22454: PPUSH
22455: CALL_OW 1
22459: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22460: LD_ADDR_EXP 134
22464: PUSH
22465: LD_EXP 134
22469: PPUSH
22470: LD_VAR 0 1
22474: PPUSH
22475: EMPTY
22476: PPUSH
22477: CALL_OW 1
22481: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22482: LD_ADDR_EXP 135
22486: PUSH
22487: LD_EXP 135
22491: PPUSH
22492: LD_VAR 0 1
22496: PPUSH
22497: EMPTY
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22504: LD_ADDR_EXP 136
22508: PUSH
22509: LD_EXP 136
22513: PPUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: EMPTY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22526: LD_ADDR_EXP 137
22530: PUSH
22531: LD_EXP 137
22535: PPUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: LD_INT 0
22543: PPUSH
22544: CALL_OW 1
22548: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22549: LD_ADDR_EXP 138
22553: PUSH
22554: LD_EXP 138
22558: PPUSH
22559: LD_VAR 0 1
22563: PPUSH
22564: LD_INT 0
22566: PPUSH
22567: CALL_OW 1
22571: ST_TO_ADDR
// end ;
22572: LD_VAR 0 2
22576: RET
// export function MC_Add ( side , units ) ; var base ; begin
22577: LD_INT 0
22579: PPUSH
22580: PPUSH
// base := mc_bases + 1 ;
22581: LD_ADDR_VAR 0 4
22585: PUSH
22586: LD_EXP 95
22590: PUSH
22591: LD_INT 1
22593: PLUS
22594: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22595: LD_ADDR_EXP 121
22599: PUSH
22600: LD_EXP 121
22604: PPUSH
22605: LD_VAR 0 4
22609: PPUSH
22610: LD_VAR 0 1
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22620: LD_ADDR_EXP 95
22624: PUSH
22625: LD_EXP 95
22629: PPUSH
22630: LD_VAR 0 4
22634: PPUSH
22635: LD_VAR 0 2
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22645: LD_ADDR_EXP 96
22649: PUSH
22650: LD_EXP 96
22654: PPUSH
22655: LD_VAR 0 4
22659: PPUSH
22660: EMPTY
22661: PPUSH
22662: CALL_OW 1
22666: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22667: LD_ADDR_EXP 97
22671: PUSH
22672: LD_EXP 97
22676: PPUSH
22677: LD_VAR 0 4
22681: PPUSH
22682: EMPTY
22683: PPUSH
22684: CALL_OW 1
22688: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22689: LD_ADDR_EXP 98
22693: PUSH
22694: LD_EXP 98
22698: PPUSH
22699: LD_VAR 0 4
22703: PPUSH
22704: EMPTY
22705: PPUSH
22706: CALL_OW 1
22710: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22711: LD_ADDR_EXP 99
22715: PUSH
22716: LD_EXP 99
22720: PPUSH
22721: LD_VAR 0 4
22725: PPUSH
22726: EMPTY
22727: PPUSH
22728: CALL_OW 1
22732: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22733: LD_ADDR_EXP 100
22737: PUSH
22738: LD_EXP 100
22742: PPUSH
22743: LD_VAR 0 4
22747: PPUSH
22748: EMPTY
22749: PPUSH
22750: CALL_OW 1
22754: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22755: LD_ADDR_EXP 101
22759: PUSH
22760: LD_EXP 101
22764: PPUSH
22765: LD_VAR 0 4
22769: PPUSH
22770: EMPTY
22771: PPUSH
22772: CALL_OW 1
22776: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22777: LD_ADDR_EXP 102
22781: PUSH
22782: LD_EXP 102
22786: PPUSH
22787: LD_VAR 0 4
22791: PPUSH
22792: EMPTY
22793: PPUSH
22794: CALL_OW 1
22798: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22799: LD_ADDR_EXP 103
22803: PUSH
22804: LD_EXP 103
22808: PPUSH
22809: LD_VAR 0 4
22813: PPUSH
22814: EMPTY
22815: PPUSH
22816: CALL_OW 1
22820: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22821: LD_ADDR_EXP 104
22825: PUSH
22826: LD_EXP 104
22830: PPUSH
22831: LD_VAR 0 4
22835: PPUSH
22836: EMPTY
22837: PPUSH
22838: CALL_OW 1
22842: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22843: LD_ADDR_EXP 105
22847: PUSH
22848: LD_EXP 105
22852: PPUSH
22853: LD_VAR 0 4
22857: PPUSH
22858: EMPTY
22859: PPUSH
22860: CALL_OW 1
22864: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22865: LD_ADDR_EXP 106
22869: PUSH
22870: LD_EXP 106
22874: PPUSH
22875: LD_VAR 0 4
22879: PPUSH
22880: LD_INT 0
22882: PPUSH
22883: CALL_OW 1
22887: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22888: LD_ADDR_EXP 107
22892: PUSH
22893: LD_EXP 107
22897: PPUSH
22898: LD_VAR 0 4
22902: PPUSH
22903: EMPTY
22904: PPUSH
22905: CALL_OW 1
22909: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22910: LD_ADDR_EXP 108
22914: PUSH
22915: LD_EXP 108
22919: PPUSH
22920: LD_VAR 0 4
22924: PPUSH
22925: EMPTY
22926: PPUSH
22927: CALL_OW 1
22931: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22932: LD_ADDR_EXP 109
22936: PUSH
22937: LD_EXP 109
22941: PPUSH
22942: LD_VAR 0 4
22946: PPUSH
22947: EMPTY
22948: PPUSH
22949: CALL_OW 1
22953: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22954: LD_ADDR_EXP 110
22958: PUSH
22959: LD_EXP 110
22963: PPUSH
22964: LD_VAR 0 4
22968: PPUSH
22969: EMPTY
22970: PPUSH
22971: CALL_OW 1
22975: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22976: LD_ADDR_EXP 111
22980: PUSH
22981: LD_EXP 111
22985: PPUSH
22986: LD_VAR 0 4
22990: PPUSH
22991: EMPTY
22992: PPUSH
22993: CALL_OW 1
22997: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22998: LD_ADDR_EXP 112
23002: PUSH
23003: LD_EXP 112
23007: PPUSH
23008: LD_VAR 0 4
23012: PPUSH
23013: EMPTY
23014: PPUSH
23015: CALL_OW 1
23019: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23020: LD_ADDR_EXP 113
23024: PUSH
23025: LD_EXP 113
23029: PPUSH
23030: LD_VAR 0 4
23034: PPUSH
23035: EMPTY
23036: PPUSH
23037: CALL_OW 1
23041: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23042: LD_ADDR_EXP 114
23046: PUSH
23047: LD_EXP 114
23051: PPUSH
23052: LD_VAR 0 4
23056: PPUSH
23057: EMPTY
23058: PPUSH
23059: CALL_OW 1
23063: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23064: LD_ADDR_EXP 115
23068: PUSH
23069: LD_EXP 115
23073: PPUSH
23074: LD_VAR 0 4
23078: PPUSH
23079: EMPTY
23080: PPUSH
23081: CALL_OW 1
23085: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23086: LD_ADDR_EXP 116
23090: PUSH
23091: LD_EXP 116
23095: PPUSH
23096: LD_VAR 0 4
23100: PPUSH
23101: EMPTY
23102: PPUSH
23103: CALL_OW 1
23107: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23108: LD_ADDR_EXP 117
23112: PUSH
23113: LD_EXP 117
23117: PPUSH
23118: LD_VAR 0 4
23122: PPUSH
23123: EMPTY
23124: PPUSH
23125: CALL_OW 1
23129: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23130: LD_ADDR_EXP 118
23134: PUSH
23135: LD_EXP 118
23139: PPUSH
23140: LD_VAR 0 4
23144: PPUSH
23145: EMPTY
23146: PPUSH
23147: CALL_OW 1
23151: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23152: LD_ADDR_EXP 119
23156: PUSH
23157: LD_EXP 119
23161: PPUSH
23162: LD_VAR 0 4
23166: PPUSH
23167: EMPTY
23168: PPUSH
23169: CALL_OW 1
23173: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23174: LD_ADDR_EXP 120
23178: PUSH
23179: LD_EXP 120
23183: PPUSH
23184: LD_VAR 0 4
23188: PPUSH
23189: EMPTY
23190: PPUSH
23191: CALL_OW 1
23195: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23196: LD_ADDR_EXP 122
23200: PUSH
23201: LD_EXP 122
23205: PPUSH
23206: LD_VAR 0 4
23210: PPUSH
23211: EMPTY
23212: PPUSH
23213: CALL_OW 1
23217: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23218: LD_ADDR_EXP 124
23222: PUSH
23223: LD_EXP 124
23227: PPUSH
23228: LD_VAR 0 4
23232: PPUSH
23233: EMPTY
23234: PPUSH
23235: CALL_OW 1
23239: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23240: LD_ADDR_EXP 125
23244: PUSH
23245: LD_EXP 125
23249: PPUSH
23250: LD_VAR 0 4
23254: PPUSH
23255: EMPTY
23256: PPUSH
23257: CALL_OW 1
23261: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23262: LD_ADDR_EXP 126
23266: PUSH
23267: LD_EXP 126
23271: PPUSH
23272: LD_VAR 0 4
23276: PPUSH
23277: EMPTY
23278: PPUSH
23279: CALL_OW 1
23283: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23284: LD_ADDR_EXP 127
23288: PUSH
23289: LD_EXP 127
23293: PPUSH
23294: LD_VAR 0 4
23298: PPUSH
23299: EMPTY
23300: PPUSH
23301: CALL_OW 1
23305: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23306: LD_ADDR_EXP 128
23310: PUSH
23311: LD_EXP 128
23315: PPUSH
23316: LD_VAR 0 4
23320: PPUSH
23321: EMPTY
23322: PPUSH
23323: CALL_OW 1
23327: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23328: LD_ADDR_EXP 129
23332: PUSH
23333: LD_EXP 129
23337: PPUSH
23338: LD_VAR 0 4
23342: PPUSH
23343: EMPTY
23344: PPUSH
23345: CALL_OW 1
23349: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23350: LD_ADDR_EXP 130
23354: PUSH
23355: LD_EXP 130
23359: PPUSH
23360: LD_VAR 0 4
23364: PPUSH
23365: EMPTY
23366: PPUSH
23367: CALL_OW 1
23371: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23372: LD_ADDR_EXP 131
23376: PUSH
23377: LD_EXP 131
23381: PPUSH
23382: LD_VAR 0 4
23386: PPUSH
23387: EMPTY
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23394: LD_ADDR_EXP 132
23398: PUSH
23399: LD_EXP 132
23403: PPUSH
23404: LD_VAR 0 4
23408: PPUSH
23409: EMPTY
23410: PPUSH
23411: CALL_OW 1
23415: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23416: LD_ADDR_EXP 133
23420: PUSH
23421: LD_EXP 133
23425: PPUSH
23426: LD_VAR 0 4
23430: PPUSH
23431: EMPTY
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23438: LD_ADDR_EXP 134
23442: PUSH
23443: LD_EXP 134
23447: PPUSH
23448: LD_VAR 0 4
23452: PPUSH
23453: EMPTY
23454: PPUSH
23455: CALL_OW 1
23459: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23460: LD_ADDR_EXP 135
23464: PUSH
23465: LD_EXP 135
23469: PPUSH
23470: LD_VAR 0 4
23474: PPUSH
23475: EMPTY
23476: PPUSH
23477: CALL_OW 1
23481: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23482: LD_ADDR_EXP 136
23486: PUSH
23487: LD_EXP 136
23491: PPUSH
23492: LD_VAR 0 4
23496: PPUSH
23497: EMPTY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23504: LD_ADDR_EXP 137
23508: PUSH
23509: LD_EXP 137
23513: PPUSH
23514: LD_VAR 0 4
23518: PPUSH
23519: LD_INT 0
23521: PPUSH
23522: CALL_OW 1
23526: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23527: LD_ADDR_EXP 138
23531: PUSH
23532: LD_EXP 138
23536: PPUSH
23537: LD_VAR 0 4
23541: PPUSH
23542: LD_INT 0
23544: PPUSH
23545: CALL_OW 1
23549: ST_TO_ADDR
// result := base ;
23550: LD_ADDR_VAR 0 3
23554: PUSH
23555: LD_VAR 0 4
23559: ST_TO_ADDR
// end ;
23560: LD_VAR 0 3
23564: RET
// export function MC_Start ( ) ; var i ; begin
23565: LD_INT 0
23567: PPUSH
23568: PPUSH
// for i = 1 to mc_bases do
23569: LD_ADDR_VAR 0 2
23573: PUSH
23574: DOUBLE
23575: LD_INT 1
23577: DEC
23578: ST_TO_ADDR
23579: LD_EXP 95
23583: PUSH
23584: FOR_TO
23585: IFFALSE 24685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23587: LD_ADDR_EXP 95
23591: PUSH
23592: LD_EXP 95
23596: PPUSH
23597: LD_VAR 0 2
23601: PPUSH
23602: LD_EXP 95
23606: PUSH
23607: LD_VAR 0 2
23611: ARRAY
23612: PUSH
23613: LD_INT 0
23615: DIFF
23616: PPUSH
23617: CALL_OW 1
23621: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23622: LD_ADDR_EXP 96
23626: PUSH
23627: LD_EXP 96
23631: PPUSH
23632: LD_VAR 0 2
23636: PPUSH
23637: EMPTY
23638: PPUSH
23639: CALL_OW 1
23643: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23644: LD_ADDR_EXP 97
23648: PUSH
23649: LD_EXP 97
23653: PPUSH
23654: LD_VAR 0 2
23658: PPUSH
23659: EMPTY
23660: PPUSH
23661: CALL_OW 1
23665: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23666: LD_ADDR_EXP 98
23670: PUSH
23671: LD_EXP 98
23675: PPUSH
23676: LD_VAR 0 2
23680: PPUSH
23681: EMPTY
23682: PPUSH
23683: CALL_OW 1
23687: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23688: LD_ADDR_EXP 99
23692: PUSH
23693: LD_EXP 99
23697: PPUSH
23698: LD_VAR 0 2
23702: PPUSH
23703: EMPTY
23704: PUSH
23705: EMPTY
23706: PUSH
23707: EMPTY
23708: LIST
23709: LIST
23710: PPUSH
23711: CALL_OW 1
23715: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23716: LD_ADDR_EXP 100
23720: PUSH
23721: LD_EXP 100
23725: PPUSH
23726: LD_VAR 0 2
23730: PPUSH
23731: EMPTY
23732: PPUSH
23733: CALL_OW 1
23737: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23738: LD_ADDR_EXP 127
23742: PUSH
23743: LD_EXP 127
23747: PPUSH
23748: LD_VAR 0 2
23752: PPUSH
23753: EMPTY
23754: PPUSH
23755: CALL_OW 1
23759: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23760: LD_ADDR_EXP 101
23764: PUSH
23765: LD_EXP 101
23769: PPUSH
23770: LD_VAR 0 2
23774: PPUSH
23775: EMPTY
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23782: LD_ADDR_EXP 102
23786: PUSH
23787: LD_EXP 102
23791: PPUSH
23792: LD_VAR 0 2
23796: PPUSH
23797: EMPTY
23798: PPUSH
23799: CALL_OW 1
23803: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23804: LD_ADDR_EXP 103
23808: PUSH
23809: LD_EXP 103
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: LD_EXP 95
23823: PUSH
23824: LD_VAR 0 2
23828: ARRAY
23829: PPUSH
23830: LD_INT 2
23832: PUSH
23833: LD_INT 30
23835: PUSH
23836: LD_INT 32
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PUSH
23843: LD_INT 30
23845: PUSH
23846: LD_INT 33
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: LIST
23857: PPUSH
23858: CALL_OW 72
23862: PPUSH
23863: CALL_OW 1
23867: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23868: LD_ADDR_EXP 104
23872: PUSH
23873: LD_EXP 104
23877: PPUSH
23878: LD_VAR 0 2
23882: PPUSH
23883: LD_EXP 95
23887: PUSH
23888: LD_VAR 0 2
23892: ARRAY
23893: PPUSH
23894: LD_INT 2
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 32
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: LD_INT 30
23909: PUSH
23910: LD_INT 31
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PUSH
23922: LD_INT 58
23924: PUSH
23925: EMPTY
23926: LIST
23927: PUSH
23928: EMPTY
23929: LIST
23930: LIST
23931: PPUSH
23932: CALL_OW 72
23936: PPUSH
23937: CALL_OW 1
23941: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23942: LD_ADDR_EXP 105
23946: PUSH
23947: LD_EXP 105
23951: PPUSH
23952: LD_VAR 0 2
23956: PPUSH
23957: EMPTY
23958: PPUSH
23959: CALL_OW 1
23963: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23964: LD_ADDR_EXP 109
23968: PUSH
23969: LD_EXP 109
23973: PPUSH
23974: LD_VAR 0 2
23978: PPUSH
23979: EMPTY
23980: PPUSH
23981: CALL_OW 1
23985: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23986: LD_ADDR_EXP 108
23990: PUSH
23991: LD_EXP 108
23995: PPUSH
23996: LD_VAR 0 2
24000: PPUSH
24001: EMPTY
24002: PPUSH
24003: CALL_OW 1
24007: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24008: LD_ADDR_EXP 110
24012: PUSH
24013: LD_EXP 110
24017: PPUSH
24018: LD_VAR 0 2
24022: PPUSH
24023: EMPTY
24024: PPUSH
24025: CALL_OW 1
24029: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24030: LD_ADDR_EXP 111
24034: PUSH
24035: LD_EXP 111
24039: PPUSH
24040: LD_VAR 0 2
24044: PPUSH
24045: EMPTY
24046: PPUSH
24047: CALL_OW 1
24051: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24052: LD_ADDR_EXP 112
24056: PUSH
24057: LD_EXP 112
24061: PPUSH
24062: LD_VAR 0 2
24066: PPUSH
24067: EMPTY
24068: PPUSH
24069: CALL_OW 1
24073: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24074: LD_ADDR_EXP 113
24078: PUSH
24079: LD_EXP 113
24083: PPUSH
24084: LD_VAR 0 2
24088: PPUSH
24089: EMPTY
24090: PPUSH
24091: CALL_OW 1
24095: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24096: LD_ADDR_EXP 114
24100: PUSH
24101: LD_EXP 114
24105: PPUSH
24106: LD_VAR 0 2
24110: PPUSH
24111: EMPTY
24112: PPUSH
24113: CALL_OW 1
24117: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24118: LD_ADDR_EXP 115
24122: PUSH
24123: LD_EXP 115
24127: PPUSH
24128: LD_VAR 0 2
24132: PPUSH
24133: EMPTY
24134: PPUSH
24135: CALL_OW 1
24139: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24140: LD_ADDR_EXP 116
24144: PUSH
24145: LD_EXP 116
24149: PPUSH
24150: LD_VAR 0 2
24154: PPUSH
24155: EMPTY
24156: PPUSH
24157: CALL_OW 1
24161: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24162: LD_ADDR_EXP 117
24166: PUSH
24167: LD_EXP 117
24171: PPUSH
24172: LD_VAR 0 2
24176: PPUSH
24177: EMPTY
24178: PPUSH
24179: CALL_OW 1
24183: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24184: LD_ADDR_EXP 106
24188: PUSH
24189: LD_EXP 106
24193: PPUSH
24194: LD_VAR 0 2
24198: PPUSH
24199: LD_INT 0
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24207: LD_ADDR_EXP 119
24211: PUSH
24212: LD_EXP 119
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: LD_INT 0
24224: PPUSH
24225: CALL_OW 1
24229: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24230: LD_ADDR_EXP 107
24234: PUSH
24235: LD_EXP 107
24239: PPUSH
24240: LD_VAR 0 2
24244: PPUSH
24245: EMPTY
24246: PPUSH
24247: CALL_OW 1
24251: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24252: LD_ADDR_EXP 118
24256: PUSH
24257: LD_EXP 118
24261: PPUSH
24262: LD_VAR 0 2
24266: PPUSH
24267: LD_INT 0
24269: PPUSH
24270: CALL_OW 1
24274: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24275: LD_ADDR_EXP 120
24279: PUSH
24280: LD_EXP 120
24284: PPUSH
24285: LD_VAR 0 2
24289: PPUSH
24290: EMPTY
24291: PPUSH
24292: CALL_OW 1
24296: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24297: LD_ADDR_EXP 123
24301: PUSH
24302: LD_EXP 123
24306: PPUSH
24307: LD_VAR 0 2
24311: PPUSH
24312: LD_INT 0
24314: PPUSH
24315: CALL_OW 1
24319: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24320: LD_ADDR_EXP 124
24324: PUSH
24325: LD_EXP 124
24329: PPUSH
24330: LD_VAR 0 2
24334: PPUSH
24335: EMPTY
24336: PPUSH
24337: CALL_OW 1
24341: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24342: LD_ADDR_EXP 125
24346: PUSH
24347: LD_EXP 125
24351: PPUSH
24352: LD_VAR 0 2
24356: PPUSH
24357: EMPTY
24358: PPUSH
24359: CALL_OW 1
24363: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24364: LD_ADDR_EXP 126
24368: PUSH
24369: LD_EXP 126
24373: PPUSH
24374: LD_VAR 0 2
24378: PPUSH
24379: EMPTY
24380: PPUSH
24381: CALL_OW 1
24385: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24386: LD_ADDR_EXP 128
24390: PUSH
24391: LD_EXP 128
24395: PPUSH
24396: LD_VAR 0 2
24400: PPUSH
24401: LD_EXP 95
24405: PUSH
24406: LD_VAR 0 2
24410: ARRAY
24411: PPUSH
24412: LD_INT 2
24414: PUSH
24415: LD_INT 30
24417: PUSH
24418: LD_INT 6
24420: PUSH
24421: EMPTY
24422: LIST
24423: LIST
24424: PUSH
24425: LD_INT 30
24427: PUSH
24428: LD_INT 7
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: PUSH
24435: LD_INT 30
24437: PUSH
24438: LD_INT 8
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: LIST
24449: LIST
24450: PPUSH
24451: CALL_OW 72
24455: PPUSH
24456: CALL_OW 1
24460: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24461: LD_ADDR_EXP 129
24465: PUSH
24466: LD_EXP 129
24470: PPUSH
24471: LD_VAR 0 2
24475: PPUSH
24476: EMPTY
24477: PPUSH
24478: CALL_OW 1
24482: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24483: LD_ADDR_EXP 130
24487: PUSH
24488: LD_EXP 130
24492: PPUSH
24493: LD_VAR 0 2
24497: PPUSH
24498: EMPTY
24499: PPUSH
24500: CALL_OW 1
24504: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24505: LD_ADDR_EXP 131
24509: PUSH
24510: LD_EXP 131
24514: PPUSH
24515: LD_VAR 0 2
24519: PPUSH
24520: EMPTY
24521: PPUSH
24522: CALL_OW 1
24526: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24527: LD_ADDR_EXP 132
24531: PUSH
24532: LD_EXP 132
24536: PPUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: EMPTY
24543: PPUSH
24544: CALL_OW 1
24548: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24549: LD_ADDR_EXP 133
24553: PUSH
24554: LD_EXP 133
24558: PPUSH
24559: LD_VAR 0 2
24563: PPUSH
24564: EMPTY
24565: PPUSH
24566: CALL_OW 1
24570: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24571: LD_ADDR_EXP 134
24575: PUSH
24576: LD_EXP 134
24580: PPUSH
24581: LD_VAR 0 2
24585: PPUSH
24586: EMPTY
24587: PPUSH
24588: CALL_OW 1
24592: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24593: LD_ADDR_EXP 135
24597: PUSH
24598: LD_EXP 135
24602: PPUSH
24603: LD_VAR 0 2
24607: PPUSH
24608: EMPTY
24609: PPUSH
24610: CALL_OW 1
24614: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24615: LD_ADDR_EXP 136
24619: PUSH
24620: LD_EXP 136
24624: PPUSH
24625: LD_VAR 0 2
24629: PPUSH
24630: EMPTY
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24637: LD_ADDR_EXP 137
24641: PUSH
24642: LD_EXP 137
24646: PPUSH
24647: LD_VAR 0 2
24651: PPUSH
24652: LD_INT 0
24654: PPUSH
24655: CALL_OW 1
24659: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24660: LD_ADDR_EXP 138
24664: PUSH
24665: LD_EXP 138
24669: PPUSH
24670: LD_VAR 0 2
24674: PPUSH
24675: LD_INT 0
24677: PPUSH
24678: CALL_OW 1
24682: ST_TO_ADDR
// end ;
24683: GO 23584
24685: POP
24686: POP
// MC_InitSides ( ) ;
24687: CALL 24973 0 0
// MC_InitResearch ( ) ;
24691: CALL 24712 0 0
// CustomInitMacro ( ) ;
24695: CALL 232 0 0
// skirmish := true ;
24699: LD_ADDR_EXP 93
24703: PUSH
24704: LD_INT 1
24706: ST_TO_ADDR
// end ;
24707: LD_VAR 0 1
24711: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24712: LD_INT 0
24714: PPUSH
24715: PPUSH
24716: PPUSH
24717: PPUSH
24718: PPUSH
24719: PPUSH
// if not mc_bases then
24720: LD_EXP 95
24724: NOT
24725: IFFALSE 24729
// exit ;
24727: GO 24968
// for i = 1 to 8 do
24729: LD_ADDR_VAR 0 2
24733: PUSH
24734: DOUBLE
24735: LD_INT 1
24737: DEC
24738: ST_TO_ADDR
24739: LD_INT 8
24741: PUSH
24742: FOR_TO
24743: IFFALSE 24769
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24745: LD_ADDR_EXP 122
24749: PUSH
24750: LD_EXP 122
24754: PPUSH
24755: LD_VAR 0 2
24759: PPUSH
24760: EMPTY
24761: PPUSH
24762: CALL_OW 1
24766: ST_TO_ADDR
24767: GO 24742
24769: POP
24770: POP
// tmp := [ ] ;
24771: LD_ADDR_VAR 0 5
24775: PUSH
24776: EMPTY
24777: ST_TO_ADDR
// for i = 1 to mc_sides do
24778: LD_ADDR_VAR 0 2
24782: PUSH
24783: DOUBLE
24784: LD_INT 1
24786: DEC
24787: ST_TO_ADDR
24788: LD_EXP 121
24792: PUSH
24793: FOR_TO
24794: IFFALSE 24852
// if not mc_sides [ i ] in tmp then
24796: LD_EXP 121
24800: PUSH
24801: LD_VAR 0 2
24805: ARRAY
24806: PUSH
24807: LD_VAR 0 5
24811: IN
24812: NOT
24813: IFFALSE 24850
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24815: LD_ADDR_VAR 0 5
24819: PUSH
24820: LD_VAR 0 5
24824: PPUSH
24825: LD_VAR 0 5
24829: PUSH
24830: LD_INT 1
24832: PLUS
24833: PPUSH
24834: LD_EXP 121
24838: PUSH
24839: LD_VAR 0 2
24843: ARRAY
24844: PPUSH
24845: CALL_OW 2
24849: ST_TO_ADDR
24850: GO 24793
24852: POP
24853: POP
// if not tmp then
24854: LD_VAR 0 5
24858: NOT
24859: IFFALSE 24863
// exit ;
24861: GO 24968
// for j in tmp do
24863: LD_ADDR_VAR 0 3
24867: PUSH
24868: LD_VAR 0 5
24872: PUSH
24873: FOR_IN
24874: IFFALSE 24966
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24876: LD_ADDR_VAR 0 6
24880: PUSH
24881: LD_INT 22
24883: PUSH
24884: LD_VAR 0 3
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PPUSH
24893: CALL_OW 69
24897: ST_TO_ADDR
// if not un then
24898: LD_VAR 0 6
24902: NOT
24903: IFFALSE 24907
// continue ;
24905: GO 24873
// nation := GetNation ( un [ 1 ] ) ;
24907: LD_ADDR_VAR 0 4
24911: PUSH
24912: LD_VAR 0 6
24916: PUSH
24917: LD_INT 1
24919: ARRAY
24920: PPUSH
24921: CALL_OW 248
24925: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24926: LD_ADDR_EXP 122
24930: PUSH
24931: LD_EXP 122
24935: PPUSH
24936: LD_VAR 0 3
24940: PPUSH
24941: LD_VAR 0 3
24945: PPUSH
24946: LD_VAR 0 4
24950: PPUSH
24951: LD_INT 1
24953: PPUSH
24954: CALL 52089 0 3
24958: PPUSH
24959: CALL_OW 1
24963: ST_TO_ADDR
// end ;
24964: GO 24873
24966: POP
24967: POP
// end ;
24968: LD_VAR 0 1
24972: RET
// export function MC_InitSides ( ) ; var i ; begin
24973: LD_INT 0
24975: PPUSH
24976: PPUSH
// if not mc_bases then
24977: LD_EXP 95
24981: NOT
24982: IFFALSE 24986
// exit ;
24984: GO 25060
// for i = 1 to mc_bases do
24986: LD_ADDR_VAR 0 2
24990: PUSH
24991: DOUBLE
24992: LD_INT 1
24994: DEC
24995: ST_TO_ADDR
24996: LD_EXP 95
25000: PUSH
25001: FOR_TO
25002: IFFALSE 25058
// if mc_bases [ i ] then
25004: LD_EXP 95
25008: PUSH
25009: LD_VAR 0 2
25013: ARRAY
25014: IFFALSE 25056
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25016: LD_ADDR_EXP 121
25020: PUSH
25021: LD_EXP 121
25025: PPUSH
25026: LD_VAR 0 2
25030: PPUSH
25031: LD_EXP 95
25035: PUSH
25036: LD_VAR 0 2
25040: ARRAY
25041: PUSH
25042: LD_INT 1
25044: ARRAY
25045: PPUSH
25046: CALL_OW 255
25050: PPUSH
25051: CALL_OW 1
25055: ST_TO_ADDR
25056: GO 25001
25058: POP
25059: POP
// end ;
25060: LD_VAR 0 1
25064: RET
// every 0 0$03 trigger skirmish do
25065: LD_EXP 93
25069: IFFALSE 25223
25071: GO 25073
25073: DISABLE
// begin enable ;
25074: ENABLE
// MC_CheckBuildings ( ) ;
25075: CALL 29721 0 0
// MC_CheckPeopleLife ( ) ;
25079: CALL 29882 0 0
// RaiseSailEvent ( 100 ) ;
25083: LD_INT 100
25085: PPUSH
25086: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25090: LD_INT 103
25092: PPUSH
25093: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25097: LD_INT 104
25099: PPUSH
25100: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25104: LD_INT 105
25106: PPUSH
25107: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25111: LD_INT 106
25113: PPUSH
25114: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25118: LD_INT 107
25120: PPUSH
25121: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25125: LD_INT 108
25127: PPUSH
25128: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25132: LD_INT 109
25134: PPUSH
25135: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25139: LD_INT 110
25141: PPUSH
25142: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25146: LD_INT 111
25148: PPUSH
25149: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25153: LD_INT 112
25155: PPUSH
25156: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25160: LD_INT 113
25162: PPUSH
25163: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25167: LD_INT 120
25169: PPUSH
25170: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25174: LD_INT 121
25176: PPUSH
25177: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25181: LD_INT 122
25183: PPUSH
25184: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25188: LD_INT 123
25190: PPUSH
25191: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25195: LD_INT 124
25197: PPUSH
25198: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25202: LD_INT 125
25204: PPUSH
25205: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25209: LD_INT 126
25211: PPUSH
25212: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25216: LD_INT 200
25218: PPUSH
25219: CALL_OW 427
// end ;
25223: END
// on SailEvent ( event ) do begin if event < 100 then
25224: LD_VAR 0 1
25228: PUSH
25229: LD_INT 100
25231: LESS
25232: IFFALSE 25243
// CustomEvent ( event ) ;
25234: LD_VAR 0 1
25238: PPUSH
25239: CALL 10899 0 1
// if event = 100 then
25243: LD_VAR 0 1
25247: PUSH
25248: LD_INT 100
25250: EQUAL
25251: IFFALSE 25257
// MC_ClassManager ( ) ;
25253: CALL 25649 0 0
// if event = 101 then
25257: LD_VAR 0 1
25261: PUSH
25262: LD_INT 101
25264: EQUAL
25265: IFFALSE 25271
// MC_RepairBuildings ( ) ;
25267: CALL 30467 0 0
// if event = 102 then
25271: LD_VAR 0 1
25275: PUSH
25276: LD_INT 102
25278: EQUAL
25279: IFFALSE 25285
// MC_Heal ( ) ;
25281: CALL 31374 0 0
// if event = 103 then
25285: LD_VAR 0 1
25289: PUSH
25290: LD_INT 103
25292: EQUAL
25293: IFFALSE 25299
// MC_Build ( ) ;
25295: CALL 31796 0 0
// if event = 104 then
25299: LD_VAR 0 1
25303: PUSH
25304: LD_INT 104
25306: EQUAL
25307: IFFALSE 25313
// MC_TurretWeapon ( ) ;
25309: CALL 33437 0 0
// if event = 105 then
25313: LD_VAR 0 1
25317: PUSH
25318: LD_INT 105
25320: EQUAL
25321: IFFALSE 25327
// MC_BuildUpgrade ( ) ;
25323: CALL 32988 0 0
// if event = 106 then
25327: LD_VAR 0 1
25331: PUSH
25332: LD_INT 106
25334: EQUAL
25335: IFFALSE 25341
// MC_PlantMines ( ) ;
25337: CALL 33867 0 0
// if event = 107 then
25341: LD_VAR 0 1
25345: PUSH
25346: LD_INT 107
25348: EQUAL
25349: IFFALSE 25355
// MC_CollectCrates ( ) ;
25351: CALL 34658 0 0
// if event = 108 then
25355: LD_VAR 0 1
25359: PUSH
25360: LD_INT 108
25362: EQUAL
25363: IFFALSE 25369
// MC_LinkRemoteControl ( ) ;
25365: CALL 36508 0 0
// if event = 109 then
25369: LD_VAR 0 1
25373: PUSH
25374: LD_INT 109
25376: EQUAL
25377: IFFALSE 25383
// MC_ProduceVehicle ( ) ;
25379: CALL 36689 0 0
// if event = 110 then
25383: LD_VAR 0 1
25387: PUSH
25388: LD_INT 110
25390: EQUAL
25391: IFFALSE 25397
// MC_SendAttack ( ) ;
25393: CALL 37155 0 0
// if event = 111 then
25397: LD_VAR 0 1
25401: PUSH
25402: LD_INT 111
25404: EQUAL
25405: IFFALSE 25411
// MC_Defend ( ) ;
25407: CALL 37263 0 0
// if event = 112 then
25411: LD_VAR 0 1
25415: PUSH
25416: LD_INT 112
25418: EQUAL
25419: IFFALSE 25425
// MC_Research ( ) ;
25421: CALL 38143 0 0
// if event = 113 then
25425: LD_VAR 0 1
25429: PUSH
25430: LD_INT 113
25432: EQUAL
25433: IFFALSE 25439
// MC_MinesTrigger ( ) ;
25435: CALL 39257 0 0
// if event = 120 then
25439: LD_VAR 0 1
25443: PUSH
25444: LD_INT 120
25446: EQUAL
25447: IFFALSE 25453
// MC_RepairVehicle ( ) ;
25449: CALL 39356 0 0
// if event = 121 then
25453: LD_VAR 0 1
25457: PUSH
25458: LD_INT 121
25460: EQUAL
25461: IFFALSE 25467
// MC_TameApe ( ) ;
25463: CALL 40097 0 0
// if event = 122 then
25467: LD_VAR 0 1
25471: PUSH
25472: LD_INT 122
25474: EQUAL
25475: IFFALSE 25481
// MC_ChangeApeClass ( ) ;
25477: CALL 40926 0 0
// if event = 123 then
25481: LD_VAR 0 1
25485: PUSH
25486: LD_INT 123
25488: EQUAL
25489: IFFALSE 25495
// MC_Bazooka ( ) ;
25491: CALL 41576 0 0
// if event = 124 then
25495: LD_VAR 0 1
25499: PUSH
25500: LD_INT 124
25502: EQUAL
25503: IFFALSE 25509
// MC_TeleportExit ( ) ;
25505: CALL 41774 0 0
// if event = 125 then
25509: LD_VAR 0 1
25513: PUSH
25514: LD_INT 125
25516: EQUAL
25517: IFFALSE 25523
// MC_Deposits ( ) ;
25519: CALL 42421 0 0
// if event = 126 then
25523: LD_VAR 0 1
25527: PUSH
25528: LD_INT 126
25530: EQUAL
25531: IFFALSE 25537
// MC_RemoteDriver ( ) ;
25533: CALL 43046 0 0
// if event = 200 then
25537: LD_VAR 0 1
25541: PUSH
25542: LD_INT 200
25544: EQUAL
25545: IFFALSE 25551
// MC_Idle ( ) ;
25547: CALL 44995 0 0
// end ;
25551: PPOPN 1
25553: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25554: LD_INT 0
25556: PPUSH
25557: PPUSH
// if not mc_bases [ base ] or not tag then
25558: LD_EXP 95
25562: PUSH
25563: LD_VAR 0 1
25567: ARRAY
25568: NOT
25569: PUSH
25570: LD_VAR 0 2
25574: NOT
25575: OR
25576: IFFALSE 25580
// exit ;
25578: GO 25644
// for i in mc_bases [ base ] union mc_ape [ base ] do
25580: LD_ADDR_VAR 0 4
25584: PUSH
25585: LD_EXP 95
25589: PUSH
25590: LD_VAR 0 1
25594: ARRAY
25595: PUSH
25596: LD_EXP 124
25600: PUSH
25601: LD_VAR 0 1
25605: ARRAY
25606: UNION
25607: PUSH
25608: FOR_IN
25609: IFFALSE 25642
// if GetTag ( i ) = tag then
25611: LD_VAR 0 4
25615: PPUSH
25616: CALL_OW 110
25620: PUSH
25621: LD_VAR 0 2
25625: EQUAL
25626: IFFALSE 25640
// SetTag ( i , 0 ) ;
25628: LD_VAR 0 4
25632: PPUSH
25633: LD_INT 0
25635: PPUSH
25636: CALL_OW 109
25640: GO 25608
25642: POP
25643: POP
// end ;
25644: LD_VAR 0 3
25648: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
25655: PPUSH
25656: PPUSH
25657: PPUSH
25658: PPUSH
// if not mc_bases then
25659: LD_EXP 95
25663: NOT
25664: IFFALSE 25668
// exit ;
25666: GO 26126
// for i = 1 to mc_bases do
25668: LD_ADDR_VAR 0 2
25672: PUSH
25673: DOUBLE
25674: LD_INT 1
25676: DEC
25677: ST_TO_ADDR
25678: LD_EXP 95
25682: PUSH
25683: FOR_TO
25684: IFFALSE 26124
// begin tmp := MC_ClassCheckReq ( i ) ;
25686: LD_ADDR_VAR 0 4
25690: PUSH
25691: LD_VAR 0 2
25695: PPUSH
25696: CALL 26131 0 1
25700: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25701: LD_ADDR_EXP 136
25705: PUSH
25706: LD_EXP 136
25710: PPUSH
25711: LD_VAR 0 2
25715: PPUSH
25716: LD_VAR 0 4
25720: PPUSH
25721: CALL_OW 1
25725: ST_TO_ADDR
// if not tmp then
25726: LD_VAR 0 4
25730: NOT
25731: IFFALSE 25735
// continue ;
25733: GO 25683
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25735: LD_ADDR_VAR 0 6
25739: PUSH
25740: LD_EXP 95
25744: PUSH
25745: LD_VAR 0 2
25749: ARRAY
25750: PPUSH
25751: LD_INT 2
25753: PUSH
25754: LD_INT 30
25756: PUSH
25757: LD_INT 4
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 30
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: LIST
25778: PPUSH
25779: CALL_OW 72
25783: PUSH
25784: LD_EXP 95
25788: PUSH
25789: LD_VAR 0 2
25793: ARRAY
25794: PPUSH
25795: LD_INT 2
25797: PUSH
25798: LD_INT 30
25800: PUSH
25801: LD_INT 0
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 30
25810: PUSH
25811: LD_INT 1
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: LIST
25822: PPUSH
25823: CALL_OW 72
25827: PUSH
25828: LD_EXP 95
25832: PUSH
25833: LD_VAR 0 2
25837: ARRAY
25838: PPUSH
25839: LD_INT 30
25841: PUSH
25842: LD_INT 3
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PPUSH
25849: CALL_OW 72
25853: PUSH
25854: LD_EXP 95
25858: PUSH
25859: LD_VAR 0 2
25863: ARRAY
25864: PPUSH
25865: LD_INT 2
25867: PUSH
25868: LD_INT 30
25870: PUSH
25871: LD_INT 6
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PUSH
25878: LD_INT 30
25880: PUSH
25881: LD_INT 7
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 30
25890: PUSH
25891: LD_INT 8
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: PPUSH
25904: CALL_OW 72
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: LIST
25913: LIST
25914: ST_TO_ADDR
// for j = 1 to 4 do
25915: LD_ADDR_VAR 0 3
25919: PUSH
25920: DOUBLE
25921: LD_INT 1
25923: DEC
25924: ST_TO_ADDR
25925: LD_INT 4
25927: PUSH
25928: FOR_TO
25929: IFFALSE 26120
// begin if not tmp [ j ] then
25931: LD_VAR 0 4
25935: PUSH
25936: LD_VAR 0 3
25940: ARRAY
25941: NOT
25942: IFFALSE 25946
// continue ;
25944: GO 25928
// for p in tmp [ j ] do
25946: LD_ADDR_VAR 0 5
25950: PUSH
25951: LD_VAR 0 4
25955: PUSH
25956: LD_VAR 0 3
25960: ARRAY
25961: PUSH
25962: FOR_IN
25963: IFFALSE 26116
// begin if not b [ j ] then
25965: LD_VAR 0 6
25969: PUSH
25970: LD_VAR 0 3
25974: ARRAY
25975: NOT
25976: IFFALSE 25980
// break ;
25978: GO 26116
// e := 0 ;
25980: LD_ADDR_VAR 0 7
25984: PUSH
25985: LD_INT 0
25987: ST_TO_ADDR
// for k in b [ j ] do
25988: LD_ADDR_VAR 0 8
25992: PUSH
25993: LD_VAR 0 6
25997: PUSH
25998: LD_VAR 0 3
26002: ARRAY
26003: PUSH
26004: FOR_IN
26005: IFFALSE 26032
// if IsNotFull ( k ) then
26007: LD_VAR 0 8
26011: PPUSH
26012: CALL 54242 0 1
26016: IFFALSE 26030
// begin e := k ;
26018: LD_ADDR_VAR 0 7
26022: PUSH
26023: LD_VAR 0 8
26027: ST_TO_ADDR
// break ;
26028: GO 26032
// end ;
26030: GO 26004
26032: POP
26033: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26034: LD_VAR 0 7
26038: PUSH
26039: LD_VAR 0 5
26043: PPUSH
26044: LD_VAR 0 7
26048: PPUSH
26049: CALL 87406 0 2
26053: NOT
26054: AND
26055: IFFALSE 26114
// begin if IsInUnit ( p ) then
26057: LD_VAR 0 5
26061: PPUSH
26062: CALL_OW 310
26066: IFFALSE 26077
// ComExitBuilding ( p ) ;
26068: LD_VAR 0 5
26072: PPUSH
26073: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26077: LD_VAR 0 5
26081: PPUSH
26082: LD_VAR 0 7
26086: PPUSH
26087: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26091: LD_VAR 0 5
26095: PPUSH
26096: LD_VAR 0 3
26100: PPUSH
26101: CALL_OW 183
// AddComExitBuilding ( p ) ;
26105: LD_VAR 0 5
26109: PPUSH
26110: CALL_OW 182
// end ; end ;
26114: GO 25962
26116: POP
26117: POP
// end ;
26118: GO 25928
26120: POP
26121: POP
// end ;
26122: GO 25683
26124: POP
26125: POP
// end ;
26126: LD_VAR 0 1
26130: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26131: LD_INT 0
26133: PPUSH
26134: PPUSH
26135: PPUSH
26136: PPUSH
26137: PPUSH
26138: PPUSH
26139: PPUSH
26140: PPUSH
26141: PPUSH
26142: PPUSH
26143: PPUSH
26144: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26145: LD_VAR 0 1
26149: NOT
26150: PUSH
26151: LD_EXP 95
26155: PUSH
26156: LD_VAR 0 1
26160: ARRAY
26161: NOT
26162: OR
26163: PUSH
26164: LD_EXP 95
26168: PUSH
26169: LD_VAR 0 1
26173: ARRAY
26174: PPUSH
26175: LD_INT 2
26177: PUSH
26178: LD_INT 30
26180: PUSH
26181: LD_INT 0
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 1
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: LIST
26202: PPUSH
26203: CALL_OW 72
26207: NOT
26208: OR
26209: IFFALSE 26213
// exit ;
26211: GO 29716
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_EXP 95
26222: PUSH
26223: LD_VAR 0 1
26227: ARRAY
26228: PPUSH
26229: LD_INT 2
26231: PUSH
26232: LD_INT 25
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: LD_INT 25
26244: PUSH
26245: LD_INT 2
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 25
26254: PUSH
26255: LD_INT 3
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 25
26264: PUSH
26265: LD_INT 4
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 25
26274: PUSH
26275: LD_INT 5
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 25
26284: PUSH
26285: LD_INT 8
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: LD_INT 25
26294: PUSH
26295: LD_INT 9
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: LIST
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: PPUSH
26312: CALL_OW 72
26316: ST_TO_ADDR
// if not tmp then
26317: LD_VAR 0 4
26321: NOT
26322: IFFALSE 26326
// exit ;
26324: GO 29716
// for i in tmp do
26326: LD_ADDR_VAR 0 3
26330: PUSH
26331: LD_VAR 0 4
26335: PUSH
26336: FOR_IN
26337: IFFALSE 26368
// if GetTag ( i ) then
26339: LD_VAR 0 3
26343: PPUSH
26344: CALL_OW 110
26348: IFFALSE 26366
// tmp := tmp diff i ;
26350: LD_ADDR_VAR 0 4
26354: PUSH
26355: LD_VAR 0 4
26359: PUSH
26360: LD_VAR 0 3
26364: DIFF
26365: ST_TO_ADDR
26366: GO 26336
26368: POP
26369: POP
// if not tmp then
26370: LD_VAR 0 4
26374: NOT
26375: IFFALSE 26379
// exit ;
26377: GO 29716
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26379: LD_ADDR_VAR 0 5
26383: PUSH
26384: LD_EXP 95
26388: PUSH
26389: LD_VAR 0 1
26393: ARRAY
26394: PPUSH
26395: LD_INT 2
26397: PUSH
26398: LD_INT 25
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: LD_INT 25
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 25
26420: PUSH
26421: LD_INT 8
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 25
26430: PUSH
26431: LD_INT 9
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: PPUSH
26445: CALL_OW 72
26449: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26450: LD_ADDR_VAR 0 6
26454: PUSH
26455: LD_EXP 95
26459: PUSH
26460: LD_VAR 0 1
26464: ARRAY
26465: PPUSH
26466: LD_INT 25
26468: PUSH
26469: LD_INT 2
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PPUSH
26476: CALL_OW 72
26480: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26481: LD_ADDR_VAR 0 7
26485: PUSH
26486: LD_EXP 95
26490: PUSH
26491: LD_VAR 0 1
26495: ARRAY
26496: PPUSH
26497: LD_INT 25
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL_OW 72
26511: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: LD_EXP 95
26521: PUSH
26522: LD_VAR 0 1
26526: ARRAY
26527: PPUSH
26528: LD_INT 25
26530: PUSH
26531: LD_INT 4
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: LD_INT 24
26540: PUSH
26541: LD_INT 251
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL_OW 72
26556: ST_TO_ADDR
// if mc_is_defending [ base ] then
26557: LD_EXP 138
26561: PUSH
26562: LD_VAR 0 1
26566: ARRAY
26567: IFFALSE 27028
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26569: LD_ADDR_EXP 137
26573: PUSH
26574: LD_EXP 137
26578: PPUSH
26579: LD_VAR 0 1
26583: PPUSH
26584: LD_INT 4
26586: PPUSH
26587: CALL_OW 1
26591: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26592: LD_ADDR_VAR 0 12
26596: PUSH
26597: LD_EXP 95
26601: PUSH
26602: LD_VAR 0 1
26606: ARRAY
26607: PPUSH
26608: LD_INT 2
26610: PUSH
26611: LD_INT 30
26613: PUSH
26614: LD_INT 4
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 30
26623: PUSH
26624: LD_INT 5
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: LIST
26635: PPUSH
26636: CALL_OW 72
26640: ST_TO_ADDR
// if not b then
26641: LD_VAR 0 12
26645: NOT
26646: IFFALSE 26650
// exit ;
26648: GO 29716
// p := [ ] ;
26650: LD_ADDR_VAR 0 11
26654: PUSH
26655: EMPTY
26656: ST_TO_ADDR
// if sci >= 2 then
26657: LD_VAR 0 8
26661: PUSH
26662: LD_INT 2
26664: GREATEREQUAL
26665: IFFALSE 26696
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26667: LD_ADDR_VAR 0 8
26671: PUSH
26672: LD_VAR 0 8
26676: PUSH
26677: LD_INT 1
26679: ARRAY
26680: PUSH
26681: LD_VAR 0 8
26685: PUSH
26686: LD_INT 2
26688: ARRAY
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: ST_TO_ADDR
26694: GO 26757
// if sci = 1 then
26696: LD_VAR 0 8
26700: PUSH
26701: LD_INT 1
26703: EQUAL
26704: IFFALSE 26725
// sci := [ sci [ 1 ] ] else
26706: LD_ADDR_VAR 0 8
26710: PUSH
26711: LD_VAR 0 8
26715: PUSH
26716: LD_INT 1
26718: ARRAY
26719: PUSH
26720: EMPTY
26721: LIST
26722: ST_TO_ADDR
26723: GO 26757
// if sci = 0 then
26725: LD_VAR 0 8
26729: PUSH
26730: LD_INT 0
26732: EQUAL
26733: IFFALSE 26757
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26735: LD_ADDR_VAR 0 11
26739: PUSH
26740: LD_VAR 0 4
26744: PPUSH
26745: LD_INT 4
26747: PPUSH
26748: CALL 87269 0 2
26752: PUSH
26753: LD_INT 1
26755: ARRAY
26756: ST_TO_ADDR
// if eng > 4 then
26757: LD_VAR 0 6
26761: PUSH
26762: LD_INT 4
26764: GREATER
26765: IFFALSE 26811
// for i = eng downto 4 do
26767: LD_ADDR_VAR 0 3
26771: PUSH
26772: DOUBLE
26773: LD_VAR 0 6
26777: INC
26778: ST_TO_ADDR
26779: LD_INT 4
26781: PUSH
26782: FOR_DOWNTO
26783: IFFALSE 26809
// eng := eng diff eng [ i ] ;
26785: LD_ADDR_VAR 0 6
26789: PUSH
26790: LD_VAR 0 6
26794: PUSH
26795: LD_VAR 0 6
26799: PUSH
26800: LD_VAR 0 3
26804: ARRAY
26805: DIFF
26806: ST_TO_ADDR
26807: GO 26782
26809: POP
26810: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26811: LD_ADDR_VAR 0 4
26815: PUSH
26816: LD_VAR 0 4
26820: PUSH
26821: LD_VAR 0 5
26825: PUSH
26826: LD_VAR 0 6
26830: UNION
26831: PUSH
26832: LD_VAR 0 7
26836: UNION
26837: PUSH
26838: LD_VAR 0 8
26842: UNION
26843: DIFF
26844: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26845: LD_ADDR_VAR 0 13
26849: PUSH
26850: LD_EXP 95
26854: PUSH
26855: LD_VAR 0 1
26859: ARRAY
26860: PPUSH
26861: LD_INT 2
26863: PUSH
26864: LD_INT 30
26866: PUSH
26867: LD_INT 32
26869: PUSH
26870: EMPTY
26871: LIST
26872: LIST
26873: PUSH
26874: LD_INT 30
26876: PUSH
26877: LD_INT 31
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: LIST
26888: PPUSH
26889: CALL_OW 72
26893: PUSH
26894: LD_EXP 95
26898: PUSH
26899: LD_VAR 0 1
26903: ARRAY
26904: PPUSH
26905: LD_INT 2
26907: PUSH
26908: LD_INT 30
26910: PUSH
26911: LD_INT 4
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 30
26920: PUSH
26921: LD_INT 5
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: LIST
26932: PPUSH
26933: CALL_OW 72
26937: PUSH
26938: LD_INT 6
26940: MUL
26941: PLUS
26942: ST_TO_ADDR
// if bcount < tmp then
26943: LD_VAR 0 13
26947: PUSH
26948: LD_VAR 0 4
26952: LESS
26953: IFFALSE 26999
// for i = tmp downto bcount do
26955: LD_ADDR_VAR 0 3
26959: PUSH
26960: DOUBLE
26961: LD_VAR 0 4
26965: INC
26966: ST_TO_ADDR
26967: LD_VAR 0 13
26971: PUSH
26972: FOR_DOWNTO
26973: IFFALSE 26997
// tmp := Delete ( tmp , tmp ) ;
26975: LD_ADDR_VAR 0 4
26979: PUSH
26980: LD_VAR 0 4
26984: PPUSH
26985: LD_VAR 0 4
26989: PPUSH
26990: CALL_OW 3
26994: ST_TO_ADDR
26995: GO 26972
26997: POP
26998: POP
// result := [ tmp , 0 , 0 , p ] ;
26999: LD_ADDR_VAR 0 2
27003: PUSH
27004: LD_VAR 0 4
27008: PUSH
27009: LD_INT 0
27011: PUSH
27012: LD_INT 0
27014: PUSH
27015: LD_VAR 0 11
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: ST_TO_ADDR
// exit ;
27026: GO 29716
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27028: LD_EXP 95
27032: PUSH
27033: LD_VAR 0 1
27037: ARRAY
27038: PPUSH
27039: LD_INT 2
27041: PUSH
27042: LD_INT 30
27044: PUSH
27045: LD_INT 6
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 30
27054: PUSH
27055: LD_INT 7
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 30
27064: PUSH
27065: LD_INT 8
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: PPUSH
27078: CALL_OW 72
27082: NOT
27083: PUSH
27084: LD_EXP 95
27088: PUSH
27089: LD_VAR 0 1
27093: ARRAY
27094: PPUSH
27095: LD_INT 30
27097: PUSH
27098: LD_INT 3
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PPUSH
27105: CALL_OW 72
27109: NOT
27110: AND
27111: IFFALSE 27183
// begin if eng = tmp then
27113: LD_VAR 0 6
27117: PUSH
27118: LD_VAR 0 4
27122: EQUAL
27123: IFFALSE 27127
// exit ;
27125: GO 29716
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27127: LD_ADDR_EXP 137
27131: PUSH
27132: LD_EXP 137
27136: PPUSH
27137: LD_VAR 0 1
27141: PPUSH
27142: LD_INT 1
27144: PPUSH
27145: CALL_OW 1
27149: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27150: LD_ADDR_VAR 0 2
27154: PUSH
27155: LD_INT 0
27157: PUSH
27158: LD_VAR 0 4
27162: PUSH
27163: LD_VAR 0 6
27167: DIFF
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: LIST
27180: ST_TO_ADDR
// exit ;
27181: GO 29716
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27183: LD_EXP 122
27187: PUSH
27188: LD_EXP 121
27192: PUSH
27193: LD_VAR 0 1
27197: ARRAY
27198: ARRAY
27199: PUSH
27200: LD_EXP 95
27204: PUSH
27205: LD_VAR 0 1
27209: ARRAY
27210: PPUSH
27211: LD_INT 2
27213: PUSH
27214: LD_INT 30
27216: PUSH
27217: LD_INT 6
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 30
27226: PUSH
27227: LD_INT 7
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 30
27236: PUSH
27237: LD_INT 8
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: PPUSH
27250: CALL_OW 72
27254: AND
27255: PUSH
27256: LD_EXP 95
27260: PUSH
27261: LD_VAR 0 1
27265: ARRAY
27266: PPUSH
27267: LD_INT 30
27269: PUSH
27270: LD_INT 3
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PPUSH
27277: CALL_OW 72
27281: NOT
27282: AND
27283: IFFALSE 27497
// begin if sci >= 6 then
27285: LD_VAR 0 8
27289: PUSH
27290: LD_INT 6
27292: GREATEREQUAL
27293: IFFALSE 27297
// exit ;
27295: GO 29716
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27297: LD_ADDR_EXP 137
27301: PUSH
27302: LD_EXP 137
27306: PPUSH
27307: LD_VAR 0 1
27311: PPUSH
27312: LD_INT 2
27314: PPUSH
27315: CALL_OW 1
27319: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27320: LD_ADDR_VAR 0 9
27324: PUSH
27325: LD_VAR 0 4
27329: PUSH
27330: LD_VAR 0 8
27334: DIFF
27335: PPUSH
27336: LD_INT 4
27338: PPUSH
27339: CALL 87269 0 2
27343: ST_TO_ADDR
// p := [ ] ;
27344: LD_ADDR_VAR 0 11
27348: PUSH
27349: EMPTY
27350: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27351: LD_VAR 0 8
27355: PUSH
27356: LD_INT 6
27358: LESS
27359: PUSH
27360: LD_VAR 0 9
27364: PUSH
27365: LD_INT 6
27367: GREATER
27368: AND
27369: IFFALSE 27450
// begin for i = 1 to 6 - sci do
27371: LD_ADDR_VAR 0 3
27375: PUSH
27376: DOUBLE
27377: LD_INT 1
27379: DEC
27380: ST_TO_ADDR
27381: LD_INT 6
27383: PUSH
27384: LD_VAR 0 8
27388: MINUS
27389: PUSH
27390: FOR_TO
27391: IFFALSE 27446
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27393: LD_ADDR_VAR 0 11
27397: PUSH
27398: LD_VAR 0 11
27402: PPUSH
27403: LD_VAR 0 11
27407: PUSH
27408: LD_INT 1
27410: PLUS
27411: PPUSH
27412: LD_VAR 0 9
27416: PUSH
27417: LD_INT 1
27419: ARRAY
27420: PPUSH
27421: CALL_OW 2
27425: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27426: LD_ADDR_VAR 0 9
27430: PUSH
27431: LD_VAR 0 9
27435: PPUSH
27436: LD_INT 1
27438: PPUSH
27439: CALL_OW 3
27443: ST_TO_ADDR
// end ;
27444: GO 27390
27446: POP
27447: POP
// end else
27448: GO 27470
// if sort then
27450: LD_VAR 0 9
27454: IFFALSE 27470
// p := sort [ 1 ] ;
27456: LD_ADDR_VAR 0 11
27460: PUSH
27461: LD_VAR 0 9
27465: PUSH
27466: LD_INT 1
27468: ARRAY
27469: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27470: LD_ADDR_VAR 0 2
27474: PUSH
27475: LD_INT 0
27477: PUSH
27478: LD_INT 0
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: LD_VAR 0 11
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: ST_TO_ADDR
// exit ;
27495: GO 29716
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27497: LD_EXP 122
27501: PUSH
27502: LD_EXP 121
27506: PUSH
27507: LD_VAR 0 1
27511: ARRAY
27512: ARRAY
27513: PUSH
27514: LD_EXP 95
27518: PUSH
27519: LD_VAR 0 1
27523: ARRAY
27524: PPUSH
27525: LD_INT 2
27527: PUSH
27528: LD_INT 30
27530: PUSH
27531: LD_INT 6
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 30
27540: PUSH
27541: LD_INT 7
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 30
27550: PUSH
27551: LD_INT 8
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: PPUSH
27564: CALL_OW 72
27568: AND
27569: PUSH
27570: LD_EXP 95
27574: PUSH
27575: LD_VAR 0 1
27579: ARRAY
27580: PPUSH
27581: LD_INT 30
27583: PUSH
27584: LD_INT 3
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PPUSH
27591: CALL_OW 72
27595: AND
27596: IFFALSE 28330
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27598: LD_ADDR_EXP 137
27602: PUSH
27603: LD_EXP 137
27607: PPUSH
27608: LD_VAR 0 1
27612: PPUSH
27613: LD_INT 3
27615: PPUSH
27616: CALL_OW 1
27620: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27621: LD_ADDR_VAR 0 2
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: LD_INT 0
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: LD_INT 0
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: ST_TO_ADDR
// if not eng then
27644: LD_VAR 0 6
27648: NOT
27649: IFFALSE 27712
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27651: LD_ADDR_VAR 0 11
27655: PUSH
27656: LD_VAR 0 4
27660: PPUSH
27661: LD_INT 2
27663: PPUSH
27664: CALL 87269 0 2
27668: PUSH
27669: LD_INT 1
27671: ARRAY
27672: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27673: LD_ADDR_VAR 0 2
27677: PUSH
27678: LD_VAR 0 2
27682: PPUSH
27683: LD_INT 2
27685: PPUSH
27686: LD_VAR 0 11
27690: PPUSH
27691: CALL_OW 1
27695: ST_TO_ADDR
// tmp := tmp diff p ;
27696: LD_ADDR_VAR 0 4
27700: PUSH
27701: LD_VAR 0 4
27705: PUSH
27706: LD_VAR 0 11
27710: DIFF
27711: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27712: LD_VAR 0 4
27716: PUSH
27717: LD_VAR 0 8
27721: PUSH
27722: LD_INT 6
27724: LESS
27725: AND
27726: IFFALSE 27914
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27728: LD_ADDR_VAR 0 9
27732: PUSH
27733: LD_VAR 0 4
27737: PUSH
27738: LD_VAR 0 8
27742: PUSH
27743: LD_VAR 0 7
27747: UNION
27748: DIFF
27749: PPUSH
27750: LD_INT 4
27752: PPUSH
27753: CALL 87269 0 2
27757: ST_TO_ADDR
// p := [ ] ;
27758: LD_ADDR_VAR 0 11
27762: PUSH
27763: EMPTY
27764: ST_TO_ADDR
// if sort then
27765: LD_VAR 0 9
27769: IFFALSE 27885
// for i = 1 to 6 - sci do
27771: LD_ADDR_VAR 0 3
27775: PUSH
27776: DOUBLE
27777: LD_INT 1
27779: DEC
27780: ST_TO_ADDR
27781: LD_INT 6
27783: PUSH
27784: LD_VAR 0 8
27788: MINUS
27789: PUSH
27790: FOR_TO
27791: IFFALSE 27883
// begin if i = sort then
27793: LD_VAR 0 3
27797: PUSH
27798: LD_VAR 0 9
27802: EQUAL
27803: IFFALSE 27807
// break ;
27805: GO 27883
// if GetClass ( i ) = 4 then
27807: LD_VAR 0 3
27811: PPUSH
27812: CALL_OW 257
27816: PUSH
27817: LD_INT 4
27819: EQUAL
27820: IFFALSE 27824
// continue ;
27822: GO 27790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27824: LD_ADDR_VAR 0 11
27828: PUSH
27829: LD_VAR 0 11
27833: PPUSH
27834: LD_VAR 0 11
27838: PUSH
27839: LD_INT 1
27841: PLUS
27842: PPUSH
27843: LD_VAR 0 9
27847: PUSH
27848: LD_VAR 0 3
27852: ARRAY
27853: PPUSH
27854: CALL_OW 2
27858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27859: LD_ADDR_VAR 0 4
27863: PUSH
27864: LD_VAR 0 4
27868: PUSH
27869: LD_VAR 0 9
27873: PUSH
27874: LD_VAR 0 3
27878: ARRAY
27879: DIFF
27880: ST_TO_ADDR
// end ;
27881: GO 27790
27883: POP
27884: POP
// if p then
27885: LD_VAR 0 11
27889: IFFALSE 27914
// result := Replace ( result , 4 , p ) ;
27891: LD_ADDR_VAR 0 2
27895: PUSH
27896: LD_VAR 0 2
27900: PPUSH
27901: LD_INT 4
27903: PPUSH
27904: LD_VAR 0 11
27908: PPUSH
27909: CALL_OW 1
27913: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27914: LD_VAR 0 4
27918: PUSH
27919: LD_VAR 0 7
27923: PUSH
27924: LD_INT 6
27926: LESS
27927: AND
27928: IFFALSE 28116
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27930: LD_ADDR_VAR 0 9
27934: PUSH
27935: LD_VAR 0 4
27939: PUSH
27940: LD_VAR 0 8
27944: PUSH
27945: LD_VAR 0 7
27949: UNION
27950: DIFF
27951: PPUSH
27952: LD_INT 3
27954: PPUSH
27955: CALL 87269 0 2
27959: ST_TO_ADDR
// p := [ ] ;
27960: LD_ADDR_VAR 0 11
27964: PUSH
27965: EMPTY
27966: ST_TO_ADDR
// if sort then
27967: LD_VAR 0 9
27971: IFFALSE 28087
// for i = 1 to 6 - mech do
27973: LD_ADDR_VAR 0 3
27977: PUSH
27978: DOUBLE
27979: LD_INT 1
27981: DEC
27982: ST_TO_ADDR
27983: LD_INT 6
27985: PUSH
27986: LD_VAR 0 7
27990: MINUS
27991: PUSH
27992: FOR_TO
27993: IFFALSE 28085
// begin if i = sort then
27995: LD_VAR 0 3
27999: PUSH
28000: LD_VAR 0 9
28004: EQUAL
28005: IFFALSE 28009
// break ;
28007: GO 28085
// if GetClass ( i ) = 3 then
28009: LD_VAR 0 3
28013: PPUSH
28014: CALL_OW 257
28018: PUSH
28019: LD_INT 3
28021: EQUAL
28022: IFFALSE 28026
// continue ;
28024: GO 27992
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28026: LD_ADDR_VAR 0 11
28030: PUSH
28031: LD_VAR 0 11
28035: PPUSH
28036: LD_VAR 0 11
28040: PUSH
28041: LD_INT 1
28043: PLUS
28044: PPUSH
28045: LD_VAR 0 9
28049: PUSH
28050: LD_VAR 0 3
28054: ARRAY
28055: PPUSH
28056: CALL_OW 2
28060: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28061: LD_ADDR_VAR 0 4
28065: PUSH
28066: LD_VAR 0 4
28070: PUSH
28071: LD_VAR 0 9
28075: PUSH
28076: LD_VAR 0 3
28080: ARRAY
28081: DIFF
28082: ST_TO_ADDR
// end ;
28083: GO 27992
28085: POP
28086: POP
// if p then
28087: LD_VAR 0 11
28091: IFFALSE 28116
// result := Replace ( result , 3 , p ) ;
28093: LD_ADDR_VAR 0 2
28097: PUSH
28098: LD_VAR 0 2
28102: PPUSH
28103: LD_INT 3
28105: PPUSH
28106: LD_VAR 0 11
28110: PPUSH
28111: CALL_OW 1
28115: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28116: LD_VAR 0 4
28120: PUSH
28121: LD_INT 6
28123: GREATER
28124: PUSH
28125: LD_VAR 0 6
28129: PUSH
28130: LD_INT 6
28132: LESS
28133: AND
28134: IFFALSE 28328
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28136: LD_ADDR_VAR 0 9
28140: PUSH
28141: LD_VAR 0 4
28145: PUSH
28146: LD_VAR 0 8
28150: PUSH
28151: LD_VAR 0 7
28155: UNION
28156: PUSH
28157: LD_VAR 0 6
28161: UNION
28162: DIFF
28163: PPUSH
28164: LD_INT 2
28166: PPUSH
28167: CALL 87269 0 2
28171: ST_TO_ADDR
// p := [ ] ;
28172: LD_ADDR_VAR 0 11
28176: PUSH
28177: EMPTY
28178: ST_TO_ADDR
// if sort then
28179: LD_VAR 0 9
28183: IFFALSE 28299
// for i = 1 to 6 - eng do
28185: LD_ADDR_VAR 0 3
28189: PUSH
28190: DOUBLE
28191: LD_INT 1
28193: DEC
28194: ST_TO_ADDR
28195: LD_INT 6
28197: PUSH
28198: LD_VAR 0 6
28202: MINUS
28203: PUSH
28204: FOR_TO
28205: IFFALSE 28297
// begin if i = sort then
28207: LD_VAR 0 3
28211: PUSH
28212: LD_VAR 0 9
28216: EQUAL
28217: IFFALSE 28221
// break ;
28219: GO 28297
// if GetClass ( i ) = 2 then
28221: LD_VAR 0 3
28225: PPUSH
28226: CALL_OW 257
28230: PUSH
28231: LD_INT 2
28233: EQUAL
28234: IFFALSE 28238
// continue ;
28236: GO 28204
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28238: LD_ADDR_VAR 0 11
28242: PUSH
28243: LD_VAR 0 11
28247: PPUSH
28248: LD_VAR 0 11
28252: PUSH
28253: LD_INT 1
28255: PLUS
28256: PPUSH
28257: LD_VAR 0 9
28261: PUSH
28262: LD_VAR 0 3
28266: ARRAY
28267: PPUSH
28268: CALL_OW 2
28272: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28273: LD_ADDR_VAR 0 4
28277: PUSH
28278: LD_VAR 0 4
28282: PUSH
28283: LD_VAR 0 9
28287: PUSH
28288: LD_VAR 0 3
28292: ARRAY
28293: DIFF
28294: ST_TO_ADDR
// end ;
28295: GO 28204
28297: POP
28298: POP
// if p then
28299: LD_VAR 0 11
28303: IFFALSE 28328
// result := Replace ( result , 2 , p ) ;
28305: LD_ADDR_VAR 0 2
28309: PUSH
28310: LD_VAR 0 2
28314: PPUSH
28315: LD_INT 2
28317: PPUSH
28318: LD_VAR 0 11
28322: PPUSH
28323: CALL_OW 1
28327: ST_TO_ADDR
// end ; exit ;
28328: GO 29716
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28330: LD_EXP 122
28334: PUSH
28335: LD_EXP 121
28339: PUSH
28340: LD_VAR 0 1
28344: ARRAY
28345: ARRAY
28346: NOT
28347: PUSH
28348: LD_EXP 95
28352: PUSH
28353: LD_VAR 0 1
28357: ARRAY
28358: PPUSH
28359: LD_INT 30
28361: PUSH
28362: LD_INT 3
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PPUSH
28369: CALL_OW 72
28373: AND
28374: PUSH
28375: LD_EXP 100
28379: PUSH
28380: LD_VAR 0 1
28384: ARRAY
28385: AND
28386: IFFALSE 28994
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28388: LD_ADDR_EXP 137
28392: PUSH
28393: LD_EXP 137
28397: PPUSH
28398: LD_VAR 0 1
28402: PPUSH
28403: LD_INT 5
28405: PPUSH
28406: CALL_OW 1
28410: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28411: LD_ADDR_VAR 0 2
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: LD_INT 0
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: ST_TO_ADDR
// if sci > 1 then
28434: LD_VAR 0 8
28438: PUSH
28439: LD_INT 1
28441: GREATER
28442: IFFALSE 28470
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28444: LD_ADDR_VAR 0 4
28448: PUSH
28449: LD_VAR 0 4
28453: PUSH
28454: LD_VAR 0 8
28458: PUSH
28459: LD_VAR 0 8
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: DIFF
28468: DIFF
28469: ST_TO_ADDR
// if tmp and not sci then
28470: LD_VAR 0 4
28474: PUSH
28475: LD_VAR 0 8
28479: NOT
28480: AND
28481: IFFALSE 28550
// begin sort := SortBySkill ( tmp , 4 ) ;
28483: LD_ADDR_VAR 0 9
28487: PUSH
28488: LD_VAR 0 4
28492: PPUSH
28493: LD_INT 4
28495: PPUSH
28496: CALL 87269 0 2
28500: ST_TO_ADDR
// if sort then
28501: LD_VAR 0 9
28505: IFFALSE 28521
// p := sort [ 1 ] ;
28507: LD_ADDR_VAR 0 11
28511: PUSH
28512: LD_VAR 0 9
28516: PUSH
28517: LD_INT 1
28519: ARRAY
28520: ST_TO_ADDR
// if p then
28521: LD_VAR 0 11
28525: IFFALSE 28550
// result := Replace ( result , 4 , p ) ;
28527: LD_ADDR_VAR 0 2
28531: PUSH
28532: LD_VAR 0 2
28536: PPUSH
28537: LD_INT 4
28539: PPUSH
28540: LD_VAR 0 11
28544: PPUSH
28545: CALL_OW 1
28549: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28550: LD_ADDR_VAR 0 4
28554: PUSH
28555: LD_VAR 0 4
28559: PUSH
28560: LD_VAR 0 7
28564: DIFF
28565: ST_TO_ADDR
// if tmp and mech < 6 then
28566: LD_VAR 0 4
28570: PUSH
28571: LD_VAR 0 7
28575: PUSH
28576: LD_INT 6
28578: LESS
28579: AND
28580: IFFALSE 28768
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28582: LD_ADDR_VAR 0 9
28586: PUSH
28587: LD_VAR 0 4
28591: PUSH
28592: LD_VAR 0 8
28596: PUSH
28597: LD_VAR 0 7
28601: UNION
28602: DIFF
28603: PPUSH
28604: LD_INT 3
28606: PPUSH
28607: CALL 87269 0 2
28611: ST_TO_ADDR
// p := [ ] ;
28612: LD_ADDR_VAR 0 11
28616: PUSH
28617: EMPTY
28618: ST_TO_ADDR
// if sort then
28619: LD_VAR 0 9
28623: IFFALSE 28739
// for i = 1 to 6 - mech do
28625: LD_ADDR_VAR 0 3
28629: PUSH
28630: DOUBLE
28631: LD_INT 1
28633: DEC
28634: ST_TO_ADDR
28635: LD_INT 6
28637: PUSH
28638: LD_VAR 0 7
28642: MINUS
28643: PUSH
28644: FOR_TO
28645: IFFALSE 28737
// begin if i = sort then
28647: LD_VAR 0 3
28651: PUSH
28652: LD_VAR 0 9
28656: EQUAL
28657: IFFALSE 28661
// break ;
28659: GO 28737
// if GetClass ( i ) = 3 then
28661: LD_VAR 0 3
28665: PPUSH
28666: CALL_OW 257
28670: PUSH
28671: LD_INT 3
28673: EQUAL
28674: IFFALSE 28678
// continue ;
28676: GO 28644
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28678: LD_ADDR_VAR 0 11
28682: PUSH
28683: LD_VAR 0 11
28687: PPUSH
28688: LD_VAR 0 11
28692: PUSH
28693: LD_INT 1
28695: PLUS
28696: PPUSH
28697: LD_VAR 0 9
28701: PUSH
28702: LD_VAR 0 3
28706: ARRAY
28707: PPUSH
28708: CALL_OW 2
28712: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28713: LD_ADDR_VAR 0 4
28717: PUSH
28718: LD_VAR 0 4
28722: PUSH
28723: LD_VAR 0 9
28727: PUSH
28728: LD_VAR 0 3
28732: ARRAY
28733: DIFF
28734: ST_TO_ADDR
// end ;
28735: GO 28644
28737: POP
28738: POP
// if p then
28739: LD_VAR 0 11
28743: IFFALSE 28768
// result := Replace ( result , 3 , p ) ;
28745: LD_ADDR_VAR 0 2
28749: PUSH
28750: LD_VAR 0 2
28754: PPUSH
28755: LD_INT 3
28757: PPUSH
28758: LD_VAR 0 11
28762: PPUSH
28763: CALL_OW 1
28767: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28768: LD_ADDR_VAR 0 4
28772: PUSH
28773: LD_VAR 0 4
28777: PUSH
28778: LD_VAR 0 6
28782: DIFF
28783: ST_TO_ADDR
// if tmp and eng < 6 then
28784: LD_VAR 0 4
28788: PUSH
28789: LD_VAR 0 6
28793: PUSH
28794: LD_INT 6
28796: LESS
28797: AND
28798: IFFALSE 28992
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28800: LD_ADDR_VAR 0 9
28804: PUSH
28805: LD_VAR 0 4
28809: PUSH
28810: LD_VAR 0 8
28814: PUSH
28815: LD_VAR 0 7
28819: UNION
28820: PUSH
28821: LD_VAR 0 6
28825: UNION
28826: DIFF
28827: PPUSH
28828: LD_INT 2
28830: PPUSH
28831: CALL 87269 0 2
28835: ST_TO_ADDR
// p := [ ] ;
28836: LD_ADDR_VAR 0 11
28840: PUSH
28841: EMPTY
28842: ST_TO_ADDR
// if sort then
28843: LD_VAR 0 9
28847: IFFALSE 28963
// for i = 1 to 6 - eng do
28849: LD_ADDR_VAR 0 3
28853: PUSH
28854: DOUBLE
28855: LD_INT 1
28857: DEC
28858: ST_TO_ADDR
28859: LD_INT 6
28861: PUSH
28862: LD_VAR 0 6
28866: MINUS
28867: PUSH
28868: FOR_TO
28869: IFFALSE 28961
// begin if i = sort then
28871: LD_VAR 0 3
28875: PUSH
28876: LD_VAR 0 9
28880: EQUAL
28881: IFFALSE 28885
// break ;
28883: GO 28961
// if GetClass ( i ) = 2 then
28885: LD_VAR 0 3
28889: PPUSH
28890: CALL_OW 257
28894: PUSH
28895: LD_INT 2
28897: EQUAL
28898: IFFALSE 28902
// continue ;
28900: GO 28868
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28902: LD_ADDR_VAR 0 11
28906: PUSH
28907: LD_VAR 0 11
28911: PPUSH
28912: LD_VAR 0 11
28916: PUSH
28917: LD_INT 1
28919: PLUS
28920: PPUSH
28921: LD_VAR 0 9
28925: PUSH
28926: LD_VAR 0 3
28930: ARRAY
28931: PPUSH
28932: CALL_OW 2
28936: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28937: LD_ADDR_VAR 0 4
28941: PUSH
28942: LD_VAR 0 4
28946: PUSH
28947: LD_VAR 0 9
28951: PUSH
28952: LD_VAR 0 3
28956: ARRAY
28957: DIFF
28958: ST_TO_ADDR
// end ;
28959: GO 28868
28961: POP
28962: POP
// if p then
28963: LD_VAR 0 11
28967: IFFALSE 28992
// result := Replace ( result , 2 , p ) ;
28969: LD_ADDR_VAR 0 2
28973: PUSH
28974: LD_VAR 0 2
28978: PPUSH
28979: LD_INT 2
28981: PPUSH
28982: LD_VAR 0 11
28986: PPUSH
28987: CALL_OW 1
28991: ST_TO_ADDR
// end ; exit ;
28992: GO 29716
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28994: LD_EXP 122
28998: PUSH
28999: LD_EXP 121
29003: PUSH
29004: LD_VAR 0 1
29008: ARRAY
29009: ARRAY
29010: NOT
29011: PUSH
29012: LD_EXP 95
29016: PUSH
29017: LD_VAR 0 1
29021: ARRAY
29022: PPUSH
29023: LD_INT 30
29025: PUSH
29026: LD_INT 3
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PPUSH
29033: CALL_OW 72
29037: AND
29038: PUSH
29039: LD_EXP 100
29043: PUSH
29044: LD_VAR 0 1
29048: ARRAY
29049: NOT
29050: AND
29051: IFFALSE 29716
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29053: LD_ADDR_EXP 137
29057: PUSH
29058: LD_EXP 137
29062: PPUSH
29063: LD_VAR 0 1
29067: PPUSH
29068: LD_INT 6
29070: PPUSH
29071: CALL_OW 1
29075: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29076: LD_ADDR_VAR 0 2
29080: PUSH
29081: LD_INT 0
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: LIST
29097: LIST
29098: ST_TO_ADDR
// if sci >= 1 then
29099: LD_VAR 0 8
29103: PUSH
29104: LD_INT 1
29106: GREATEREQUAL
29107: IFFALSE 29129
// tmp := tmp diff sci [ 1 ] ;
29109: LD_ADDR_VAR 0 4
29113: PUSH
29114: LD_VAR 0 4
29118: PUSH
29119: LD_VAR 0 8
29123: PUSH
29124: LD_INT 1
29126: ARRAY
29127: DIFF
29128: ST_TO_ADDR
// if tmp and not sci then
29129: LD_VAR 0 4
29133: PUSH
29134: LD_VAR 0 8
29138: NOT
29139: AND
29140: IFFALSE 29209
// begin sort := SortBySkill ( tmp , 4 ) ;
29142: LD_ADDR_VAR 0 9
29146: PUSH
29147: LD_VAR 0 4
29151: PPUSH
29152: LD_INT 4
29154: PPUSH
29155: CALL 87269 0 2
29159: ST_TO_ADDR
// if sort then
29160: LD_VAR 0 9
29164: IFFALSE 29180
// p := sort [ 1 ] ;
29166: LD_ADDR_VAR 0 11
29170: PUSH
29171: LD_VAR 0 9
29175: PUSH
29176: LD_INT 1
29178: ARRAY
29179: ST_TO_ADDR
// if p then
29180: LD_VAR 0 11
29184: IFFALSE 29209
// result := Replace ( result , 4 , p ) ;
29186: LD_ADDR_VAR 0 2
29190: PUSH
29191: LD_VAR 0 2
29195: PPUSH
29196: LD_INT 4
29198: PPUSH
29199: LD_VAR 0 11
29203: PPUSH
29204: CALL_OW 1
29208: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29209: LD_ADDR_VAR 0 4
29213: PUSH
29214: LD_VAR 0 4
29218: PUSH
29219: LD_VAR 0 7
29223: DIFF
29224: ST_TO_ADDR
// if tmp and mech < 6 then
29225: LD_VAR 0 4
29229: PUSH
29230: LD_VAR 0 7
29234: PUSH
29235: LD_INT 6
29237: LESS
29238: AND
29239: IFFALSE 29421
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29241: LD_ADDR_VAR 0 9
29245: PUSH
29246: LD_VAR 0 4
29250: PUSH
29251: LD_VAR 0 7
29255: DIFF
29256: PPUSH
29257: LD_INT 3
29259: PPUSH
29260: CALL 87269 0 2
29264: ST_TO_ADDR
// p := [ ] ;
29265: LD_ADDR_VAR 0 11
29269: PUSH
29270: EMPTY
29271: ST_TO_ADDR
// if sort then
29272: LD_VAR 0 9
29276: IFFALSE 29392
// for i = 1 to 6 - mech do
29278: LD_ADDR_VAR 0 3
29282: PUSH
29283: DOUBLE
29284: LD_INT 1
29286: DEC
29287: ST_TO_ADDR
29288: LD_INT 6
29290: PUSH
29291: LD_VAR 0 7
29295: MINUS
29296: PUSH
29297: FOR_TO
29298: IFFALSE 29390
// begin if i = sort then
29300: LD_VAR 0 3
29304: PUSH
29305: LD_VAR 0 9
29309: EQUAL
29310: IFFALSE 29314
// break ;
29312: GO 29390
// if GetClass ( i ) = 3 then
29314: LD_VAR 0 3
29318: PPUSH
29319: CALL_OW 257
29323: PUSH
29324: LD_INT 3
29326: EQUAL
29327: IFFALSE 29331
// continue ;
29329: GO 29297
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29331: LD_ADDR_VAR 0 11
29335: PUSH
29336: LD_VAR 0 11
29340: PPUSH
29341: LD_VAR 0 11
29345: PUSH
29346: LD_INT 1
29348: PLUS
29349: PPUSH
29350: LD_VAR 0 9
29354: PUSH
29355: LD_VAR 0 3
29359: ARRAY
29360: PPUSH
29361: CALL_OW 2
29365: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29366: LD_ADDR_VAR 0 4
29370: PUSH
29371: LD_VAR 0 4
29375: PUSH
29376: LD_VAR 0 9
29380: PUSH
29381: LD_VAR 0 3
29385: ARRAY
29386: DIFF
29387: ST_TO_ADDR
// end ;
29388: GO 29297
29390: POP
29391: POP
// if p then
29392: LD_VAR 0 11
29396: IFFALSE 29421
// result := Replace ( result , 3 , p ) ;
29398: LD_ADDR_VAR 0 2
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: LD_INT 3
29410: PPUSH
29411: LD_VAR 0 11
29415: PPUSH
29416: CALL_OW 1
29420: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29421: LD_ADDR_VAR 0 4
29425: PUSH
29426: LD_VAR 0 4
29430: PUSH
29431: LD_VAR 0 6
29435: DIFF
29436: ST_TO_ADDR
// if tmp and eng < 4 then
29437: LD_VAR 0 4
29441: PUSH
29442: LD_VAR 0 6
29446: PUSH
29447: LD_INT 4
29449: LESS
29450: AND
29451: IFFALSE 29641
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29453: LD_ADDR_VAR 0 9
29457: PUSH
29458: LD_VAR 0 4
29462: PUSH
29463: LD_VAR 0 7
29467: PUSH
29468: LD_VAR 0 6
29472: UNION
29473: DIFF
29474: PPUSH
29475: LD_INT 2
29477: PPUSH
29478: CALL 87269 0 2
29482: ST_TO_ADDR
// p := [ ] ;
29483: LD_ADDR_VAR 0 11
29487: PUSH
29488: EMPTY
29489: ST_TO_ADDR
// if sort then
29490: LD_VAR 0 9
29494: IFFALSE 29610
// for i = 1 to 4 - eng do
29496: LD_ADDR_VAR 0 3
29500: PUSH
29501: DOUBLE
29502: LD_INT 1
29504: DEC
29505: ST_TO_ADDR
29506: LD_INT 4
29508: PUSH
29509: LD_VAR 0 6
29513: MINUS
29514: PUSH
29515: FOR_TO
29516: IFFALSE 29608
// begin if i = sort then
29518: LD_VAR 0 3
29522: PUSH
29523: LD_VAR 0 9
29527: EQUAL
29528: IFFALSE 29532
// break ;
29530: GO 29608
// if GetClass ( i ) = 2 then
29532: LD_VAR 0 3
29536: PPUSH
29537: CALL_OW 257
29541: PUSH
29542: LD_INT 2
29544: EQUAL
29545: IFFALSE 29549
// continue ;
29547: GO 29515
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29549: LD_ADDR_VAR 0 11
29553: PUSH
29554: LD_VAR 0 11
29558: PPUSH
29559: LD_VAR 0 11
29563: PUSH
29564: LD_INT 1
29566: PLUS
29567: PPUSH
29568: LD_VAR 0 9
29572: PUSH
29573: LD_VAR 0 3
29577: ARRAY
29578: PPUSH
29579: CALL_OW 2
29583: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29584: LD_ADDR_VAR 0 4
29588: PUSH
29589: LD_VAR 0 4
29593: PUSH
29594: LD_VAR 0 9
29598: PUSH
29599: LD_VAR 0 3
29603: ARRAY
29604: DIFF
29605: ST_TO_ADDR
// end ;
29606: GO 29515
29608: POP
29609: POP
// if p then
29610: LD_VAR 0 11
29614: IFFALSE 29639
// result := Replace ( result , 2 , p ) ;
29616: LD_ADDR_VAR 0 2
29620: PUSH
29621: LD_VAR 0 2
29625: PPUSH
29626: LD_INT 2
29628: PPUSH
29629: LD_VAR 0 11
29633: PPUSH
29634: CALL_OW 1
29638: ST_TO_ADDR
// end else
29639: GO 29685
// for i = eng downto 5 do
29641: LD_ADDR_VAR 0 3
29645: PUSH
29646: DOUBLE
29647: LD_VAR 0 6
29651: INC
29652: ST_TO_ADDR
29653: LD_INT 5
29655: PUSH
29656: FOR_DOWNTO
29657: IFFALSE 29683
// tmp := tmp union eng [ i ] ;
29659: LD_ADDR_VAR 0 4
29663: PUSH
29664: LD_VAR 0 4
29668: PUSH
29669: LD_VAR 0 6
29673: PUSH
29674: LD_VAR 0 3
29678: ARRAY
29679: UNION
29680: ST_TO_ADDR
29681: GO 29656
29683: POP
29684: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29685: LD_ADDR_VAR 0 2
29689: PUSH
29690: LD_VAR 0 2
29694: PPUSH
29695: LD_INT 1
29697: PPUSH
29698: LD_VAR 0 4
29702: PUSH
29703: LD_VAR 0 5
29707: DIFF
29708: PPUSH
29709: CALL_OW 1
29713: ST_TO_ADDR
// exit ;
29714: GO 29716
// end ; end ;
29716: LD_VAR 0 2
29720: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29721: LD_INT 0
29723: PPUSH
29724: PPUSH
29725: PPUSH
// if not mc_bases then
29726: LD_EXP 95
29730: NOT
29731: IFFALSE 29735
// exit ;
29733: GO 29877
// for i = 1 to mc_bases do
29735: LD_ADDR_VAR 0 2
29739: PUSH
29740: DOUBLE
29741: LD_INT 1
29743: DEC
29744: ST_TO_ADDR
29745: LD_EXP 95
29749: PUSH
29750: FOR_TO
29751: IFFALSE 29868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29753: LD_ADDR_VAR 0 3
29757: PUSH
29758: LD_EXP 95
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PPUSH
29769: LD_INT 21
29771: PUSH
29772: LD_INT 3
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 3
29781: PUSH
29782: LD_INT 2
29784: PUSH
29785: LD_INT 30
29787: PUSH
29788: LD_INT 29
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 30
29797: PUSH
29798: LD_INT 30
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: LIST
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: LD_INT 3
29816: PUSH
29817: LD_INT 24
29819: PUSH
29820: LD_INT 1000
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: LIST
29835: PPUSH
29836: CALL_OW 72
29840: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29841: LD_ADDR_EXP 96
29845: PUSH
29846: LD_EXP 96
29850: PPUSH
29851: LD_VAR 0 2
29855: PPUSH
29856: LD_VAR 0 3
29860: PPUSH
29861: CALL_OW 1
29865: ST_TO_ADDR
// end ;
29866: GO 29750
29868: POP
29869: POP
// RaiseSailEvent ( 101 ) ;
29870: LD_INT 101
29872: PPUSH
29873: CALL_OW 427
// end ;
29877: LD_VAR 0 1
29881: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29882: LD_INT 0
29884: PPUSH
29885: PPUSH
29886: PPUSH
29887: PPUSH
29888: PPUSH
29889: PPUSH
29890: PPUSH
// if not mc_bases then
29891: LD_EXP 95
29895: NOT
29896: IFFALSE 29900
// exit ;
29898: GO 30462
// for i = 1 to mc_bases do
29900: LD_ADDR_VAR 0 2
29904: PUSH
29905: DOUBLE
29906: LD_INT 1
29908: DEC
29909: ST_TO_ADDR
29910: LD_EXP 95
29914: PUSH
29915: FOR_TO
29916: IFFALSE 30453
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29918: LD_ADDR_VAR 0 5
29922: PUSH
29923: LD_EXP 95
29927: PUSH
29928: LD_VAR 0 2
29932: ARRAY
29933: PUSH
29934: LD_EXP 124
29938: PUSH
29939: LD_VAR 0 2
29943: ARRAY
29944: UNION
29945: PPUSH
29946: LD_INT 21
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 54
29964: PUSH
29965: EMPTY
29966: LIST
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: LD_INT 24
29977: PUSH
29978: LD_INT 1000
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PPUSH
29998: CALL_OW 72
30002: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30003: LD_ADDR_VAR 0 6
30007: PUSH
30008: LD_EXP 95
30012: PUSH
30013: LD_VAR 0 2
30017: ARRAY
30018: PPUSH
30019: LD_INT 21
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: LD_INT 3
30034: PUSH
30035: LD_INT 54
30037: PUSH
30038: EMPTY
30039: LIST
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 3
30047: PUSH
30048: LD_INT 24
30050: PUSH
30051: LD_INT 250
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: LIST
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PPUSH
30071: CALL_OW 72
30075: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30076: LD_ADDR_VAR 0 7
30080: PUSH
30081: LD_VAR 0 5
30085: PUSH
30086: LD_VAR 0 6
30090: DIFF
30091: ST_TO_ADDR
// if not need_heal_1 then
30092: LD_VAR 0 6
30096: NOT
30097: IFFALSE 30130
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30099: LD_ADDR_EXP 98
30103: PUSH
30104: LD_EXP 98
30108: PPUSH
30109: LD_VAR 0 2
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PPUSH
30121: EMPTY
30122: PPUSH
30123: CALL 57012 0 3
30127: ST_TO_ADDR
30128: GO 30200
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30130: LD_ADDR_EXP 98
30134: PUSH
30135: LD_EXP 98
30139: PPUSH
30140: LD_VAR 0 2
30144: PUSH
30145: LD_INT 1
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PPUSH
30152: LD_EXP 98
30156: PUSH
30157: LD_VAR 0 2
30161: ARRAY
30162: PUSH
30163: LD_INT 1
30165: ARRAY
30166: PPUSH
30167: LD_INT 3
30169: PUSH
30170: LD_INT 24
30172: PUSH
30173: LD_INT 1000
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PPUSH
30184: CALL_OW 72
30188: PUSH
30189: LD_VAR 0 6
30193: UNION
30194: PPUSH
30195: CALL 57012 0 3
30199: ST_TO_ADDR
// if not need_heal_2 then
30200: LD_VAR 0 7
30204: NOT
30205: IFFALSE 30238
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30207: LD_ADDR_EXP 98
30211: PUSH
30212: LD_EXP 98
30216: PPUSH
30217: LD_VAR 0 2
30221: PUSH
30222: LD_INT 2
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PPUSH
30229: EMPTY
30230: PPUSH
30231: CALL 57012 0 3
30235: ST_TO_ADDR
30236: GO 30270
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30238: LD_ADDR_EXP 98
30242: PUSH
30243: LD_EXP 98
30247: PPUSH
30248: LD_VAR 0 2
30252: PUSH
30253: LD_INT 2
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PPUSH
30260: LD_VAR 0 7
30264: PPUSH
30265: CALL 57012 0 3
30269: ST_TO_ADDR
// if need_heal_2 then
30270: LD_VAR 0 7
30274: IFFALSE 30435
// for j in need_heal_2 do
30276: LD_ADDR_VAR 0 3
30280: PUSH
30281: LD_VAR 0 7
30285: PUSH
30286: FOR_IN
30287: IFFALSE 30433
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30289: LD_ADDR_VAR 0 5
30293: PUSH
30294: LD_EXP 95
30298: PUSH
30299: LD_VAR 0 2
30303: ARRAY
30304: PPUSH
30305: LD_INT 2
30307: PUSH
30308: LD_INT 30
30310: PUSH
30311: LD_INT 6
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 30
30320: PUSH
30321: LD_INT 7
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 30
30330: PUSH
30331: LD_INT 8
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 30
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: PUSH
30348: LD_INT 30
30350: PUSH
30351: LD_INT 1
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: PPUSH
30366: CALL_OW 72
30370: ST_TO_ADDR
// if tmp then
30371: LD_VAR 0 5
30375: IFFALSE 30431
// begin k := NearestUnitToUnit ( tmp , j ) ;
30377: LD_ADDR_VAR 0 4
30381: PUSH
30382: LD_VAR 0 5
30386: PPUSH
30387: LD_VAR 0 3
30391: PPUSH
30392: CALL_OW 74
30396: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30397: LD_VAR 0 3
30401: PPUSH
30402: LD_VAR 0 4
30406: PPUSH
30407: CALL_OW 296
30411: PUSH
30412: LD_INT 5
30414: GREATER
30415: IFFALSE 30431
// ComMoveToNearbyEntrance ( j , k ) ;
30417: LD_VAR 0 3
30421: PPUSH
30422: LD_VAR 0 4
30426: PPUSH
30427: CALL 89630 0 2
// end ; end ;
30431: GO 30286
30433: POP
30434: POP
// if not need_heal_1 and not need_heal_2 then
30435: LD_VAR 0 6
30439: NOT
30440: PUSH
30441: LD_VAR 0 7
30445: NOT
30446: AND
30447: IFFALSE 30451
// continue ;
30449: GO 29915
// end ;
30451: GO 29915
30453: POP
30454: POP
// RaiseSailEvent ( 102 ) ;
30455: LD_INT 102
30457: PPUSH
30458: CALL_OW 427
// end ;
30462: LD_VAR 0 1
30466: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30467: LD_INT 0
30469: PPUSH
30470: PPUSH
30471: PPUSH
30472: PPUSH
30473: PPUSH
30474: PPUSH
30475: PPUSH
30476: PPUSH
// if not mc_bases then
30477: LD_EXP 95
30481: NOT
30482: IFFALSE 30486
// exit ;
30484: GO 31369
// for i = 1 to mc_bases do
30486: LD_ADDR_VAR 0 2
30490: PUSH
30491: DOUBLE
30492: LD_INT 1
30494: DEC
30495: ST_TO_ADDR
30496: LD_EXP 95
30500: PUSH
30501: FOR_TO
30502: IFFALSE 31367
// begin if not mc_building_need_repair [ i ] then
30504: LD_EXP 96
30508: PUSH
30509: LD_VAR 0 2
30513: ARRAY
30514: NOT
30515: IFFALSE 30702
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30517: LD_ADDR_VAR 0 6
30521: PUSH
30522: LD_EXP 114
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: PPUSH
30533: LD_INT 3
30535: PUSH
30536: LD_INT 24
30538: PUSH
30539: LD_INT 1000
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 2
30552: PUSH
30553: LD_INT 34
30555: PUSH
30556: LD_INT 13
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 34
30565: PUSH
30566: LD_INT 52
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 34
30575: PUSH
30576: LD_EXP 80
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 72
30599: ST_TO_ADDR
// if cranes then
30600: LD_VAR 0 6
30604: IFFALSE 30666
// for j in cranes do
30606: LD_ADDR_VAR 0 3
30610: PUSH
30611: LD_VAR 0 6
30615: PUSH
30616: FOR_IN
30617: IFFALSE 30664
// if not IsInArea ( j , mc_parking [ i ] ) then
30619: LD_VAR 0 3
30623: PPUSH
30624: LD_EXP 119
30628: PUSH
30629: LD_VAR 0 2
30633: ARRAY
30634: PPUSH
30635: CALL_OW 308
30639: NOT
30640: IFFALSE 30662
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30642: LD_VAR 0 3
30646: PPUSH
30647: LD_EXP 119
30651: PUSH
30652: LD_VAR 0 2
30656: ARRAY
30657: PPUSH
30658: CALL_OW 113
30662: GO 30616
30664: POP
30665: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30666: LD_ADDR_EXP 97
30670: PUSH
30671: LD_EXP 97
30675: PPUSH
30676: LD_VAR 0 2
30680: PPUSH
30681: EMPTY
30682: PPUSH
30683: CALL_OW 1
30687: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30688: LD_VAR 0 2
30692: PPUSH
30693: LD_INT 101
30695: PPUSH
30696: CALL 25554 0 2
// continue ;
30700: GO 30501
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30702: LD_ADDR_EXP 101
30706: PUSH
30707: LD_EXP 101
30711: PPUSH
30712: LD_VAR 0 2
30716: PPUSH
30717: EMPTY
30718: PPUSH
30719: CALL_OW 1
30723: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30724: LD_VAR 0 2
30728: PPUSH
30729: LD_INT 103
30731: PPUSH
30732: CALL 25554 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30736: LD_ADDR_VAR 0 5
30740: PUSH
30741: LD_EXP 95
30745: PUSH
30746: LD_VAR 0 2
30750: ARRAY
30751: PUSH
30752: LD_EXP 124
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: UNION
30763: PPUSH
30764: LD_INT 2
30766: PUSH
30767: LD_INT 25
30769: PUSH
30770: LD_INT 2
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 25
30779: PUSH
30780: LD_INT 16
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: LIST
30791: PUSH
30792: EMPTY
30793: LIST
30794: PPUSH
30795: CALL_OW 72
30799: ST_TO_ADDR
// if mc_need_heal [ i ] then
30800: LD_EXP 98
30804: PUSH
30805: LD_VAR 0 2
30809: ARRAY
30810: IFFALSE 30854
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30812: LD_ADDR_VAR 0 5
30816: PUSH
30817: LD_VAR 0 5
30821: PUSH
30822: LD_EXP 98
30826: PUSH
30827: LD_VAR 0 2
30831: ARRAY
30832: PUSH
30833: LD_INT 1
30835: ARRAY
30836: PUSH
30837: LD_EXP 98
30841: PUSH
30842: LD_VAR 0 2
30846: ARRAY
30847: PUSH
30848: LD_INT 2
30850: ARRAY
30851: UNION
30852: DIFF
30853: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30854: LD_ADDR_VAR 0 6
30858: PUSH
30859: LD_EXP 114
30863: PUSH
30864: LD_VAR 0 2
30868: ARRAY
30869: PPUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 34
30875: PUSH
30876: LD_INT 13
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 34
30885: PUSH
30886: LD_INT 52
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 34
30895: PUSH
30896: LD_EXP 80
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: PPUSH
30911: CALL_OW 72
30915: ST_TO_ADDR
// if cranes then
30916: LD_VAR 0 6
30920: IFFALSE 31056
// begin for j in cranes do
30922: LD_ADDR_VAR 0 3
30926: PUSH
30927: LD_VAR 0 6
30931: PUSH
30932: FOR_IN
30933: IFFALSE 31054
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30935: LD_VAR 0 3
30939: PPUSH
30940: CALL_OW 256
30944: PUSH
30945: LD_INT 1000
30947: EQUAL
30948: PUSH
30949: LD_VAR 0 3
30953: PPUSH
30954: CALL_OW 314
30958: NOT
30959: AND
30960: IFFALSE 30994
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30962: LD_VAR 0 3
30966: PPUSH
30967: LD_EXP 96
30971: PUSH
30972: LD_VAR 0 2
30976: ARRAY
30977: PPUSH
30978: LD_VAR 0 3
30982: PPUSH
30983: CALL_OW 74
30987: PPUSH
30988: CALL_OW 130
30992: GO 31052
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30994: LD_VAR 0 3
30998: PPUSH
30999: CALL_OW 256
31003: PUSH
31004: LD_INT 500
31006: LESS
31007: PUSH
31008: LD_VAR 0 3
31012: PPUSH
31013: LD_EXP 119
31017: PUSH
31018: LD_VAR 0 2
31022: ARRAY
31023: PPUSH
31024: CALL_OW 308
31028: NOT
31029: AND
31030: IFFALSE 31052
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31032: LD_VAR 0 3
31036: PPUSH
31037: LD_EXP 119
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PPUSH
31048: CALL_OW 113
// end ;
31052: GO 30932
31054: POP
31055: POP
// end ; if tmp > 3 then
31056: LD_VAR 0 5
31060: PUSH
31061: LD_INT 3
31063: GREATER
31064: IFFALSE 31084
// tmp := ShrinkArray ( tmp , 4 ) ;
31066: LD_ADDR_VAR 0 5
31070: PUSH
31071: LD_VAR 0 5
31075: PPUSH
31076: LD_INT 4
31078: PPUSH
31079: CALL 89078 0 2
31083: ST_TO_ADDR
// if not tmp then
31084: LD_VAR 0 5
31088: NOT
31089: IFFALSE 31093
// continue ;
31091: GO 30501
// for j in tmp do
31093: LD_ADDR_VAR 0 3
31097: PUSH
31098: LD_VAR 0 5
31102: PUSH
31103: FOR_IN
31104: IFFALSE 31363
// begin if IsInUnit ( j ) then
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL_OW 310
31115: IFFALSE 31126
// ComExitBuilding ( j ) ;
31117: LD_VAR 0 3
31121: PPUSH
31122: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31126: LD_VAR 0 3
31130: PUSH
31131: LD_EXP 97
31135: PUSH
31136: LD_VAR 0 2
31140: ARRAY
31141: IN
31142: NOT
31143: IFFALSE 31201
// begin SetTag ( j , 101 ) ;
31145: LD_VAR 0 3
31149: PPUSH
31150: LD_INT 101
31152: PPUSH
31153: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31157: LD_ADDR_EXP 97
31161: PUSH
31162: LD_EXP 97
31166: PPUSH
31167: LD_VAR 0 2
31171: PUSH
31172: LD_EXP 97
31176: PUSH
31177: LD_VAR 0 2
31181: ARRAY
31182: PUSH
31183: LD_INT 1
31185: PLUS
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PPUSH
31191: LD_VAR 0 3
31195: PPUSH
31196: CALL 57012 0 3
31200: ST_TO_ADDR
// end ; wait ( 1 ) ;
31201: LD_INT 1
31203: PPUSH
31204: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31208: LD_ADDR_VAR 0 7
31212: PUSH
31213: LD_EXP 96
31217: PUSH
31218: LD_VAR 0 2
31222: ARRAY
31223: ST_TO_ADDR
// if mc_scan [ i ] then
31224: LD_EXP 118
31228: PUSH
31229: LD_VAR 0 2
31233: ARRAY
31234: IFFALSE 31296
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31236: LD_ADDR_VAR 0 7
31240: PUSH
31241: LD_EXP 96
31245: PUSH
31246: LD_VAR 0 2
31250: ARRAY
31251: PPUSH
31252: LD_INT 3
31254: PUSH
31255: LD_INT 30
31257: PUSH
31258: LD_INT 32
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 30
31267: PUSH
31268: LD_INT 33
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 30
31277: PUSH
31278: LD_INT 31
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: PPUSH
31291: CALL_OW 72
31295: ST_TO_ADDR
// if not to_repair_tmp then
31296: LD_VAR 0 7
31300: NOT
31301: IFFALSE 31305
// continue ;
31303: GO 31103
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31305: LD_ADDR_VAR 0 8
31309: PUSH
31310: LD_VAR 0 7
31314: PPUSH
31315: LD_VAR 0 3
31319: PPUSH
31320: CALL_OW 74
31324: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31325: LD_VAR 0 8
31329: PPUSH
31330: LD_INT 16
31332: PPUSH
31333: CALL 59611 0 2
31337: PUSH
31338: LD_INT 4
31340: ARRAY
31341: PUSH
31342: LD_INT 10
31344: LESS
31345: IFFALSE 31361
// ComRepairBuilding ( j , to_repair ) ;
31347: LD_VAR 0 3
31351: PPUSH
31352: LD_VAR 0 8
31356: PPUSH
31357: CALL_OW 130
// end ;
31361: GO 31103
31363: POP
31364: POP
// end ;
31365: GO 30501
31367: POP
31368: POP
// end ;
31369: LD_VAR 0 1
31373: RET
// export function MC_Heal ; var i , j , tmp ; begin
31374: LD_INT 0
31376: PPUSH
31377: PPUSH
31378: PPUSH
31379: PPUSH
// if not mc_bases then
31380: LD_EXP 95
31384: NOT
31385: IFFALSE 31389
// exit ;
31387: GO 31791
// for i = 1 to mc_bases do
31389: LD_ADDR_VAR 0 2
31393: PUSH
31394: DOUBLE
31395: LD_INT 1
31397: DEC
31398: ST_TO_ADDR
31399: LD_EXP 95
31403: PUSH
31404: FOR_TO
31405: IFFALSE 31789
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31407: LD_EXP 98
31411: PUSH
31412: LD_VAR 0 2
31416: ARRAY
31417: PUSH
31418: LD_INT 1
31420: ARRAY
31421: NOT
31422: PUSH
31423: LD_EXP 98
31427: PUSH
31428: LD_VAR 0 2
31432: ARRAY
31433: PUSH
31434: LD_INT 2
31436: ARRAY
31437: NOT
31438: AND
31439: IFFALSE 31477
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31441: LD_ADDR_EXP 99
31445: PUSH
31446: LD_EXP 99
31450: PPUSH
31451: LD_VAR 0 2
31455: PPUSH
31456: EMPTY
31457: PPUSH
31458: CALL_OW 1
31462: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31463: LD_VAR 0 2
31467: PPUSH
31468: LD_INT 102
31470: PPUSH
31471: CALL 25554 0 2
// continue ;
31475: GO 31404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31477: LD_ADDR_VAR 0 4
31481: PUSH
31482: LD_EXP 95
31486: PUSH
31487: LD_VAR 0 2
31491: ARRAY
31492: PPUSH
31493: LD_INT 25
31495: PUSH
31496: LD_INT 4
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PPUSH
31503: CALL_OW 72
31507: ST_TO_ADDR
// if not tmp then
31508: LD_VAR 0 4
31512: NOT
31513: IFFALSE 31517
// continue ;
31515: GO 31404
// if mc_taming [ i ] then
31517: LD_EXP 126
31521: PUSH
31522: LD_VAR 0 2
31526: ARRAY
31527: IFFALSE 31551
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31529: LD_ADDR_EXP 126
31533: PUSH
31534: LD_EXP 126
31538: PPUSH
31539: LD_VAR 0 2
31543: PPUSH
31544: EMPTY
31545: PPUSH
31546: CALL_OW 1
31550: ST_TO_ADDR
// for j in tmp do
31551: LD_ADDR_VAR 0 3
31555: PUSH
31556: LD_VAR 0 4
31560: PUSH
31561: FOR_IN
31562: IFFALSE 31785
// begin if IsInUnit ( j ) then
31564: LD_VAR 0 3
31568: PPUSH
31569: CALL_OW 310
31573: IFFALSE 31584
// ComExitBuilding ( j ) ;
31575: LD_VAR 0 3
31579: PPUSH
31580: CALL_OW 122
// if not j in mc_healers [ i ] then
31584: LD_VAR 0 3
31588: PUSH
31589: LD_EXP 99
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: IN
31600: NOT
31601: IFFALSE 31647
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31603: LD_ADDR_EXP 99
31607: PUSH
31608: LD_EXP 99
31612: PPUSH
31613: LD_VAR 0 2
31617: PUSH
31618: LD_EXP 99
31622: PUSH
31623: LD_VAR 0 2
31627: ARRAY
31628: PUSH
31629: LD_INT 1
31631: PLUS
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PPUSH
31637: LD_VAR 0 3
31641: PPUSH
31642: CALL 57012 0 3
31646: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31647: LD_VAR 0 3
31651: PPUSH
31652: CALL_OW 110
31656: PUSH
31657: LD_INT 102
31659: NONEQUAL
31660: IFFALSE 31674
// SetTag ( j , 102 ) ;
31662: LD_VAR 0 3
31666: PPUSH
31667: LD_INT 102
31669: PPUSH
31670: CALL_OW 109
// Wait ( 3 ) ;
31674: LD_INT 3
31676: PPUSH
31677: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31681: LD_EXP 98
31685: PUSH
31686: LD_VAR 0 2
31690: ARRAY
31691: PUSH
31692: LD_INT 1
31694: ARRAY
31695: IFFALSE 31727
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31697: LD_VAR 0 3
31701: PPUSH
31702: LD_EXP 98
31706: PUSH
31707: LD_VAR 0 2
31711: ARRAY
31712: PUSH
31713: LD_INT 1
31715: ARRAY
31716: PUSH
31717: LD_INT 1
31719: ARRAY
31720: PPUSH
31721: CALL_OW 128
31725: GO 31783
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31727: LD_VAR 0 3
31731: PPUSH
31732: CALL_OW 314
31736: NOT
31737: PUSH
31738: LD_EXP 98
31742: PUSH
31743: LD_VAR 0 2
31747: ARRAY
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: AND
31753: IFFALSE 31783
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31755: LD_VAR 0 3
31759: PPUSH
31760: LD_EXP 98
31764: PUSH
31765: LD_VAR 0 2
31769: ARRAY
31770: PUSH
31771: LD_INT 2
31773: ARRAY
31774: PUSH
31775: LD_INT 1
31777: ARRAY
31778: PPUSH
31779: CALL_OW 128
// end ;
31783: GO 31561
31785: POP
31786: POP
// end ;
31787: GO 31404
31789: POP
31790: POP
// end ;
31791: LD_VAR 0 1
31795: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31796: LD_INT 0
31798: PPUSH
31799: PPUSH
31800: PPUSH
31801: PPUSH
31802: PPUSH
// if not mc_bases then
31803: LD_EXP 95
31807: NOT
31808: IFFALSE 31812
// exit ;
31810: GO 32983
// for i = 1 to mc_bases do
31812: LD_ADDR_VAR 0 2
31816: PUSH
31817: DOUBLE
31818: LD_INT 1
31820: DEC
31821: ST_TO_ADDR
31822: LD_EXP 95
31826: PUSH
31827: FOR_TO
31828: IFFALSE 32981
// begin if mc_scan [ i ] then
31830: LD_EXP 118
31834: PUSH
31835: LD_VAR 0 2
31839: ARRAY
31840: IFFALSE 31844
// continue ;
31842: GO 31827
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31844: LD_EXP 100
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: NOT
31855: PUSH
31856: LD_EXP 102
31860: PUSH
31861: LD_VAR 0 2
31865: ARRAY
31866: NOT
31867: AND
31868: PUSH
31869: LD_EXP 101
31873: PUSH
31874: LD_VAR 0 2
31878: ARRAY
31879: AND
31880: IFFALSE 31918
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31882: LD_ADDR_EXP 101
31886: PUSH
31887: LD_EXP 101
31891: PPUSH
31892: LD_VAR 0 2
31896: PPUSH
31897: EMPTY
31898: PPUSH
31899: CALL_OW 1
31903: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31904: LD_VAR 0 2
31908: PPUSH
31909: LD_INT 103
31911: PPUSH
31912: CALL 25554 0 2
// continue ;
31916: GO 31827
// end ; if mc_construct_list [ i ] then
31918: LD_EXP 102
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: IFFALSE 32148
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31930: LD_ADDR_VAR 0 4
31934: PUSH
31935: LD_EXP 95
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: PPUSH
31946: LD_INT 25
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PPUSH
31956: CALL_OW 72
31960: PUSH
31961: LD_EXP 97
31965: PUSH
31966: LD_VAR 0 2
31970: ARRAY
31971: DIFF
31972: ST_TO_ADDR
// if not tmp then
31973: LD_VAR 0 4
31977: NOT
31978: IFFALSE 31982
// continue ;
31980: GO 31827
// for j in tmp do
31982: LD_ADDR_VAR 0 3
31986: PUSH
31987: LD_VAR 0 4
31991: PUSH
31992: FOR_IN
31993: IFFALSE 32144
// begin if not mc_builders [ i ] then
31995: LD_EXP 101
31999: PUSH
32000: LD_VAR 0 2
32004: ARRAY
32005: NOT
32006: IFFALSE 32064
// begin SetTag ( j , 103 ) ;
32008: LD_VAR 0 3
32012: PPUSH
32013: LD_INT 103
32015: PPUSH
32016: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32020: LD_ADDR_EXP 101
32024: PUSH
32025: LD_EXP 101
32029: PPUSH
32030: LD_VAR 0 2
32034: PUSH
32035: LD_EXP 101
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: PUSH
32046: LD_INT 1
32048: PLUS
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PPUSH
32054: LD_VAR 0 3
32058: PPUSH
32059: CALL 57012 0 3
32063: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32064: LD_VAR 0 3
32068: PPUSH
32069: CALL_OW 310
32073: IFFALSE 32084
// ComExitBuilding ( j ) ;
32075: LD_VAR 0 3
32079: PPUSH
32080: CALL_OW 122
// wait ( 3 ) ;
32084: LD_INT 3
32086: PPUSH
32087: CALL_OW 67
// if not mc_construct_list [ i ] then
32091: LD_EXP 102
32095: PUSH
32096: LD_VAR 0 2
32100: ARRAY
32101: NOT
32102: IFFALSE 32106
// break ;
32104: GO 32144
// if not HasTask ( j ) then
32106: LD_VAR 0 3
32110: PPUSH
32111: CALL_OW 314
32115: NOT
32116: IFFALSE 32142
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32118: LD_VAR 0 3
32122: PPUSH
32123: LD_EXP 102
32127: PUSH
32128: LD_VAR 0 2
32132: ARRAY
32133: PUSH
32134: LD_INT 1
32136: ARRAY
32137: PPUSH
32138: CALL 59875 0 2
// end ;
32142: GO 31992
32144: POP
32145: POP
// end else
32146: GO 32979
// if mc_build_list [ i ] then
32148: LD_EXP 100
32152: PUSH
32153: LD_VAR 0 2
32157: ARRAY
32158: IFFALSE 32979
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32160: LD_ADDR_VAR 0 5
32164: PUSH
32165: LD_EXP 95
32169: PUSH
32170: LD_VAR 0 2
32174: ARRAY
32175: PPUSH
32176: LD_INT 2
32178: PUSH
32179: LD_INT 30
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 30
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: LIST
32203: PPUSH
32204: CALL_OW 72
32208: ST_TO_ADDR
// if depot then
32209: LD_VAR 0 5
32213: IFFALSE 32231
// depot := depot [ 1 ] else
32215: LD_ADDR_VAR 0 5
32219: PUSH
32220: LD_VAR 0 5
32224: PUSH
32225: LD_INT 1
32227: ARRAY
32228: ST_TO_ADDR
32229: GO 32239
// depot := 0 ;
32231: LD_ADDR_VAR 0 5
32235: PUSH
32236: LD_INT 0
32238: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32239: LD_EXP 100
32243: PUSH
32244: LD_VAR 0 2
32248: ARRAY
32249: PUSH
32250: LD_INT 1
32252: ARRAY
32253: PUSH
32254: LD_INT 1
32256: ARRAY
32257: PPUSH
32258: CALL 59699 0 1
32262: PUSH
32263: LD_EXP 95
32267: PUSH
32268: LD_VAR 0 2
32272: ARRAY
32273: PPUSH
32274: LD_INT 2
32276: PUSH
32277: LD_INT 30
32279: PUSH
32280: LD_INT 2
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 30
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: PPUSH
32302: CALL_OW 72
32306: NOT
32307: AND
32308: IFFALSE 32413
// begin for j = 1 to mc_build_list [ i ] do
32310: LD_ADDR_VAR 0 3
32314: PUSH
32315: DOUBLE
32316: LD_INT 1
32318: DEC
32319: ST_TO_ADDR
32320: LD_EXP 100
32324: PUSH
32325: LD_VAR 0 2
32329: ARRAY
32330: PUSH
32331: FOR_TO
32332: IFFALSE 32411
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32334: LD_EXP 100
32338: PUSH
32339: LD_VAR 0 2
32343: ARRAY
32344: PUSH
32345: LD_VAR 0 3
32349: ARRAY
32350: PUSH
32351: LD_INT 1
32353: ARRAY
32354: PUSH
32355: LD_INT 2
32357: EQUAL
32358: IFFALSE 32409
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32360: LD_ADDR_EXP 100
32364: PUSH
32365: LD_EXP 100
32369: PPUSH
32370: LD_VAR 0 2
32374: PPUSH
32375: LD_EXP 100
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: PPUSH
32386: LD_VAR 0 3
32390: PPUSH
32391: LD_INT 1
32393: PPUSH
32394: LD_INT 0
32396: PPUSH
32397: CALL 56430 0 4
32401: PPUSH
32402: CALL_OW 1
32406: ST_TO_ADDR
// break ;
32407: GO 32411
// end ;
32409: GO 32331
32411: POP
32412: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32413: LD_EXP 100
32417: PUSH
32418: LD_VAR 0 2
32422: ARRAY
32423: PUSH
32424: LD_INT 1
32426: ARRAY
32427: PUSH
32428: LD_INT 1
32430: ARRAY
32431: PUSH
32432: LD_INT 0
32434: EQUAL
32435: PUSH
32436: LD_VAR 0 5
32440: PUSH
32441: LD_VAR 0 5
32445: PPUSH
32446: LD_EXP 100
32450: PUSH
32451: LD_VAR 0 2
32455: ARRAY
32456: PUSH
32457: LD_INT 1
32459: ARRAY
32460: PUSH
32461: LD_INT 1
32463: ARRAY
32464: PPUSH
32465: LD_EXP 100
32469: PUSH
32470: LD_VAR 0 2
32474: ARRAY
32475: PUSH
32476: LD_INT 1
32478: ARRAY
32479: PUSH
32480: LD_INT 2
32482: ARRAY
32483: PPUSH
32484: LD_EXP 100
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PUSH
32495: LD_INT 1
32497: ARRAY
32498: PUSH
32499: LD_INT 3
32501: ARRAY
32502: PPUSH
32503: LD_EXP 100
32507: PUSH
32508: LD_VAR 0 2
32512: ARRAY
32513: PUSH
32514: LD_INT 1
32516: ARRAY
32517: PUSH
32518: LD_INT 4
32520: ARRAY
32521: PPUSH
32522: CALL 65115 0 5
32526: AND
32527: OR
32528: IFFALSE 32809
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32530: LD_ADDR_VAR 0 4
32534: PUSH
32535: LD_EXP 95
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PPUSH
32546: LD_INT 25
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PPUSH
32556: CALL_OW 72
32560: PUSH
32561: LD_EXP 97
32565: PUSH
32566: LD_VAR 0 2
32570: ARRAY
32571: DIFF
32572: ST_TO_ADDR
// if not tmp then
32573: LD_VAR 0 4
32577: NOT
32578: IFFALSE 32582
// continue ;
32580: GO 31827
// for j in tmp do
32582: LD_ADDR_VAR 0 3
32586: PUSH
32587: LD_VAR 0 4
32591: PUSH
32592: FOR_IN
32593: IFFALSE 32805
// begin if not mc_builders [ i ] then
32595: LD_EXP 101
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: NOT
32606: IFFALSE 32664
// begin SetTag ( j , 103 ) ;
32608: LD_VAR 0 3
32612: PPUSH
32613: LD_INT 103
32615: PPUSH
32616: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32620: LD_ADDR_EXP 101
32624: PUSH
32625: LD_EXP 101
32629: PPUSH
32630: LD_VAR 0 2
32634: PUSH
32635: LD_EXP 101
32639: PUSH
32640: LD_VAR 0 2
32644: ARRAY
32645: PUSH
32646: LD_INT 1
32648: PLUS
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PPUSH
32654: LD_VAR 0 3
32658: PPUSH
32659: CALL 57012 0 3
32663: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32664: LD_VAR 0 3
32668: PPUSH
32669: CALL_OW 310
32673: IFFALSE 32684
// ComExitBuilding ( j ) ;
32675: LD_VAR 0 3
32679: PPUSH
32680: CALL_OW 122
// wait ( 3 ) ;
32684: LD_INT 3
32686: PPUSH
32687: CALL_OW 67
// if not mc_build_list [ i ] then
32691: LD_EXP 100
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: NOT
32702: IFFALSE 32706
// break ;
32704: GO 32805
// if not HasTask ( j ) then
32706: LD_VAR 0 3
32710: PPUSH
32711: CALL_OW 314
32715: NOT
32716: IFFALSE 32803
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32718: LD_VAR 0 3
32722: PPUSH
32723: LD_EXP 100
32727: PUSH
32728: LD_VAR 0 2
32732: ARRAY
32733: PUSH
32734: LD_INT 1
32736: ARRAY
32737: PUSH
32738: LD_INT 1
32740: ARRAY
32741: PPUSH
32742: LD_EXP 100
32746: PUSH
32747: LD_VAR 0 2
32751: ARRAY
32752: PUSH
32753: LD_INT 1
32755: ARRAY
32756: PUSH
32757: LD_INT 2
32759: ARRAY
32760: PPUSH
32761: LD_EXP 100
32765: PUSH
32766: LD_VAR 0 2
32770: ARRAY
32771: PUSH
32772: LD_INT 1
32774: ARRAY
32775: PUSH
32776: LD_INT 3
32778: ARRAY
32779: PPUSH
32780: LD_EXP 100
32784: PUSH
32785: LD_VAR 0 2
32789: ARRAY
32790: PUSH
32791: LD_INT 1
32793: ARRAY
32794: PUSH
32795: LD_INT 4
32797: ARRAY
32798: PPUSH
32799: CALL_OW 145
// end ;
32803: GO 32592
32805: POP
32806: POP
// end else
32807: GO 32979
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32809: LD_EXP 95
32813: PUSH
32814: LD_VAR 0 2
32818: ARRAY
32819: PPUSH
32820: LD_EXP 100
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: PUSH
32831: LD_INT 1
32833: ARRAY
32834: PUSH
32835: LD_INT 1
32837: ARRAY
32838: PPUSH
32839: LD_EXP 100
32843: PUSH
32844: LD_VAR 0 2
32848: ARRAY
32849: PUSH
32850: LD_INT 1
32852: ARRAY
32853: PUSH
32854: LD_INT 2
32856: ARRAY
32857: PPUSH
32858: LD_EXP 100
32862: PUSH
32863: LD_VAR 0 2
32867: ARRAY
32868: PUSH
32869: LD_INT 1
32871: ARRAY
32872: PUSH
32873: LD_INT 3
32875: ARRAY
32876: PPUSH
32877: LD_EXP 100
32881: PUSH
32882: LD_VAR 0 2
32886: ARRAY
32887: PUSH
32888: LD_INT 1
32890: ARRAY
32891: PUSH
32892: LD_INT 4
32894: ARRAY
32895: PPUSH
32896: LD_EXP 95
32900: PUSH
32901: LD_VAR 0 2
32905: ARRAY
32906: PPUSH
32907: LD_INT 21
32909: PUSH
32910: LD_INT 3
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PPUSH
32917: CALL_OW 72
32921: PPUSH
32922: EMPTY
32923: PPUSH
32924: CALL 63865 0 7
32928: NOT
32929: IFFALSE 32979
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32931: LD_ADDR_EXP 100
32935: PUSH
32936: LD_EXP 100
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_EXP 100
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: PPUSH
32957: LD_INT 1
32959: PPUSH
32960: LD_INT 1
32962: NEG
32963: PPUSH
32964: LD_INT 0
32966: PPUSH
32967: CALL 56430 0 4
32971: PPUSH
32972: CALL_OW 1
32976: ST_TO_ADDR
// continue ;
32977: GO 31827
// end ; end ; end ;
32979: GO 31827
32981: POP
32982: POP
// end ;
32983: LD_VAR 0 1
32987: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32988: LD_INT 0
32990: PPUSH
32991: PPUSH
32992: PPUSH
32993: PPUSH
32994: PPUSH
32995: PPUSH
// if not mc_bases then
32996: LD_EXP 95
33000: NOT
33001: IFFALSE 33005
// exit ;
33003: GO 33432
// for i = 1 to mc_bases do
33005: LD_ADDR_VAR 0 2
33009: PUSH
33010: DOUBLE
33011: LD_INT 1
33013: DEC
33014: ST_TO_ADDR
33015: LD_EXP 95
33019: PUSH
33020: FOR_TO
33021: IFFALSE 33430
// begin tmp := mc_build_upgrade [ i ] ;
33023: LD_ADDR_VAR 0 4
33027: PUSH
33028: LD_EXP 127
33032: PUSH
33033: LD_VAR 0 2
33037: ARRAY
33038: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33039: LD_ADDR_VAR 0 6
33043: PUSH
33044: LD_EXP 128
33048: PUSH
33049: LD_VAR 0 2
33053: ARRAY
33054: PPUSH
33055: LD_INT 2
33057: PUSH
33058: LD_INT 30
33060: PUSH
33061: LD_INT 6
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 30
33070: PUSH
33071: LD_INT 7
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: PPUSH
33083: CALL_OW 72
33087: ST_TO_ADDR
// if not tmp and not lab then
33088: LD_VAR 0 4
33092: NOT
33093: PUSH
33094: LD_VAR 0 6
33098: NOT
33099: AND
33100: IFFALSE 33104
// continue ;
33102: GO 33020
// if tmp then
33104: LD_VAR 0 4
33108: IFFALSE 33228
// for j in tmp do
33110: LD_ADDR_VAR 0 3
33114: PUSH
33115: LD_VAR 0 4
33119: PUSH
33120: FOR_IN
33121: IFFALSE 33226
// begin if UpgradeCost ( j ) then
33123: LD_VAR 0 3
33127: PPUSH
33128: CALL 63525 0 1
33132: IFFALSE 33224
// begin ComUpgrade ( j ) ;
33134: LD_VAR 0 3
33138: PPUSH
33139: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33143: LD_ADDR_EXP 127
33147: PUSH
33148: LD_EXP 127
33152: PPUSH
33153: LD_VAR 0 2
33157: PPUSH
33158: LD_EXP 127
33162: PUSH
33163: LD_VAR 0 2
33167: ARRAY
33168: PUSH
33169: LD_VAR 0 3
33173: DIFF
33174: PPUSH
33175: CALL_OW 1
33179: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33180: LD_ADDR_EXP 102
33184: PUSH
33185: LD_EXP 102
33189: PPUSH
33190: LD_VAR 0 2
33194: PUSH
33195: LD_EXP 102
33199: PUSH
33200: LD_VAR 0 2
33204: ARRAY
33205: PUSH
33206: LD_INT 1
33208: PLUS
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PPUSH
33214: LD_VAR 0 3
33218: PPUSH
33219: CALL 57012 0 3
33223: ST_TO_ADDR
// end ; end ;
33224: GO 33120
33226: POP
33227: POP
// if not lab or not mc_lab_upgrade [ i ] then
33228: LD_VAR 0 6
33232: NOT
33233: PUSH
33234: LD_EXP 129
33238: PUSH
33239: LD_VAR 0 2
33243: ARRAY
33244: NOT
33245: OR
33246: IFFALSE 33250
// continue ;
33248: GO 33020
// for j in lab do
33250: LD_ADDR_VAR 0 3
33254: PUSH
33255: LD_VAR 0 6
33259: PUSH
33260: FOR_IN
33261: IFFALSE 33426
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33263: LD_VAR 0 3
33267: PPUSH
33268: CALL_OW 266
33272: PUSH
33273: LD_INT 6
33275: PUSH
33276: LD_INT 7
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: IN
33283: PUSH
33284: LD_VAR 0 3
33288: PPUSH
33289: CALL_OW 461
33293: PUSH
33294: LD_INT 1
33296: NONEQUAL
33297: AND
33298: IFFALSE 33424
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33300: LD_VAR 0 3
33304: PPUSH
33305: LD_EXP 129
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: PUSH
33316: LD_INT 1
33318: ARRAY
33319: PPUSH
33320: CALL 63730 0 2
33324: IFFALSE 33424
// begin ComCancel ( j ) ;
33326: LD_VAR 0 3
33330: PPUSH
33331: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33335: LD_VAR 0 3
33339: PPUSH
33340: LD_EXP 129
33344: PUSH
33345: LD_VAR 0 2
33349: ARRAY
33350: PUSH
33351: LD_INT 1
33353: ARRAY
33354: PPUSH
33355: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33359: LD_VAR 0 3
33363: PUSH
33364: LD_EXP 102
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: IN
33375: NOT
33376: IFFALSE 33422
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33378: LD_ADDR_EXP 102
33382: PUSH
33383: LD_EXP 102
33387: PPUSH
33388: LD_VAR 0 2
33392: PUSH
33393: LD_EXP 102
33397: PUSH
33398: LD_VAR 0 2
33402: ARRAY
33403: PUSH
33404: LD_INT 1
33406: PLUS
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PPUSH
33412: LD_VAR 0 3
33416: PPUSH
33417: CALL 57012 0 3
33421: ST_TO_ADDR
// break ;
33422: GO 33426
// end ; end ; end ;
33424: GO 33260
33426: POP
33427: POP
// end ;
33428: GO 33020
33430: POP
33431: POP
// end ;
33432: LD_VAR 0 1
33436: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33437: LD_INT 0
33439: PPUSH
33440: PPUSH
33441: PPUSH
33442: PPUSH
33443: PPUSH
33444: PPUSH
33445: PPUSH
33446: PPUSH
33447: PPUSH
// if not mc_bases then
33448: LD_EXP 95
33452: NOT
33453: IFFALSE 33457
// exit ;
33455: GO 33862
// for i = 1 to mc_bases do
33457: LD_ADDR_VAR 0 2
33461: PUSH
33462: DOUBLE
33463: LD_INT 1
33465: DEC
33466: ST_TO_ADDR
33467: LD_EXP 95
33471: PUSH
33472: FOR_TO
33473: IFFALSE 33860
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33475: LD_EXP 103
33479: PUSH
33480: LD_VAR 0 2
33484: ARRAY
33485: NOT
33486: PUSH
33487: LD_EXP 95
33491: PUSH
33492: LD_VAR 0 2
33496: ARRAY
33497: PPUSH
33498: LD_INT 30
33500: PUSH
33501: LD_INT 3
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PPUSH
33508: CALL_OW 72
33512: NOT
33513: OR
33514: IFFALSE 33518
// continue ;
33516: GO 33472
// busy := false ;
33518: LD_ADDR_VAR 0 8
33522: PUSH
33523: LD_INT 0
33525: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33526: LD_ADDR_VAR 0 4
33530: PUSH
33531: LD_EXP 95
33535: PUSH
33536: LD_VAR 0 2
33540: ARRAY
33541: PPUSH
33542: LD_INT 30
33544: PUSH
33545: LD_INT 3
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PPUSH
33552: CALL_OW 72
33556: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33557: LD_ADDR_VAR 0 6
33561: PUSH
33562: LD_EXP 103
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: PPUSH
33573: LD_INT 2
33575: PUSH
33576: LD_INT 30
33578: PUSH
33579: LD_INT 32
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 30
33588: PUSH
33589: LD_INT 33
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: LIST
33600: PPUSH
33601: CALL_OW 72
33605: ST_TO_ADDR
// if not t then
33606: LD_VAR 0 6
33610: NOT
33611: IFFALSE 33615
// continue ;
33613: GO 33472
// for j in tmp do
33615: LD_ADDR_VAR 0 3
33619: PUSH
33620: LD_VAR 0 4
33624: PUSH
33625: FOR_IN
33626: IFFALSE 33656
// if not BuildingStatus ( j ) = bs_idle then
33628: LD_VAR 0 3
33632: PPUSH
33633: CALL_OW 461
33637: PUSH
33638: LD_INT 2
33640: EQUAL
33641: NOT
33642: IFFALSE 33654
// begin busy := true ;
33644: LD_ADDR_VAR 0 8
33648: PUSH
33649: LD_INT 1
33651: ST_TO_ADDR
// break ;
33652: GO 33656
// end ;
33654: GO 33625
33656: POP
33657: POP
// if busy then
33658: LD_VAR 0 8
33662: IFFALSE 33666
// continue ;
33664: GO 33472
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33666: LD_ADDR_VAR 0 7
33670: PUSH
33671: LD_VAR 0 6
33675: PPUSH
33676: LD_INT 35
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PPUSH
33686: CALL_OW 72
33690: ST_TO_ADDR
// if tw then
33691: LD_VAR 0 7
33695: IFFALSE 33772
// begin tw := tw [ 1 ] ;
33697: LD_ADDR_VAR 0 7
33701: PUSH
33702: LD_VAR 0 7
33706: PUSH
33707: LD_INT 1
33709: ARRAY
33710: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33711: LD_ADDR_VAR 0 9
33715: PUSH
33716: LD_VAR 0 7
33720: PPUSH
33721: LD_EXP 120
33725: PUSH
33726: LD_VAR 0 2
33730: ARRAY
33731: PPUSH
33732: CALL 62022 0 2
33736: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33737: LD_EXP 134
33741: PUSH
33742: LD_VAR 0 2
33746: ARRAY
33747: IFFALSE 33770
// if not weapon in mc_allowed_tower_weapons [ i ] then
33749: LD_VAR 0 9
33753: PUSH
33754: LD_EXP 134
33758: PUSH
33759: LD_VAR 0 2
33763: ARRAY
33764: IN
33765: NOT
33766: IFFALSE 33770
// continue ;
33768: GO 33472
// end else
33770: GO 33835
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33772: LD_ADDR_VAR 0 5
33776: PUSH
33777: LD_EXP 103
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: PPUSH
33788: LD_VAR 0 4
33792: PPUSH
33793: CALL 88311 0 2
33797: ST_TO_ADDR
// if not tmp2 then
33798: LD_VAR 0 5
33802: NOT
33803: IFFALSE 33807
// continue ;
33805: GO 33472
// tw := tmp2 [ 1 ] ;
33807: LD_ADDR_VAR 0 7
33811: PUSH
33812: LD_VAR 0 5
33816: PUSH
33817: LD_INT 1
33819: ARRAY
33820: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33821: LD_ADDR_VAR 0 9
33825: PUSH
33826: LD_VAR 0 5
33830: PUSH
33831: LD_INT 2
33833: ARRAY
33834: ST_TO_ADDR
// end ; if not weapon then
33835: LD_VAR 0 9
33839: NOT
33840: IFFALSE 33844
// continue ;
33842: GO 33472
// ComPlaceWeapon ( tw , weapon ) ;
33844: LD_VAR 0 7
33848: PPUSH
33849: LD_VAR 0 9
33853: PPUSH
33854: CALL_OW 148
// end ;
33858: GO 33472
33860: POP
33861: POP
// end ;
33862: LD_VAR 0 1
33866: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33867: LD_INT 0
33869: PPUSH
33870: PPUSH
33871: PPUSH
33872: PPUSH
33873: PPUSH
33874: PPUSH
33875: PPUSH
// if not mc_bases then
33876: LD_EXP 95
33880: NOT
33881: IFFALSE 33885
// exit ;
33883: GO 34653
// for i = 1 to mc_bases do
33885: LD_ADDR_VAR 0 2
33889: PUSH
33890: DOUBLE
33891: LD_INT 1
33893: DEC
33894: ST_TO_ADDR
33895: LD_EXP 95
33899: PUSH
33900: FOR_TO
33901: IFFALSE 34651
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33903: LD_EXP 108
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: NOT
33914: PUSH
33915: LD_EXP 108
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: PUSH
33926: LD_EXP 109
33930: PUSH
33931: LD_VAR 0 2
33935: ARRAY
33936: EQUAL
33937: OR
33938: PUSH
33939: LD_EXP 118
33943: PUSH
33944: LD_VAR 0 2
33948: ARRAY
33949: OR
33950: IFFALSE 33954
// continue ;
33952: GO 33900
// if mc_miners [ i ] then
33954: LD_EXP 109
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: IFFALSE 34338
// begin for j = mc_miners [ i ] downto 1 do
33966: LD_ADDR_VAR 0 3
33970: PUSH
33971: DOUBLE
33972: LD_EXP 109
33976: PUSH
33977: LD_VAR 0 2
33981: ARRAY
33982: INC
33983: ST_TO_ADDR
33984: LD_INT 1
33986: PUSH
33987: FOR_DOWNTO
33988: IFFALSE 34336
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33990: LD_EXP 109
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_VAR 0 3
34005: ARRAY
34006: PPUSH
34007: CALL_OW 301
34011: PUSH
34012: LD_EXP 109
34016: PUSH
34017: LD_VAR 0 2
34021: ARRAY
34022: PUSH
34023: LD_VAR 0 3
34027: ARRAY
34028: PPUSH
34029: CALL_OW 257
34033: PUSH
34034: LD_INT 1
34036: NONEQUAL
34037: OR
34038: IFFALSE 34101
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34040: LD_ADDR_VAR 0 5
34044: PUSH
34045: LD_EXP 109
34049: PUSH
34050: LD_VAR 0 2
34054: ARRAY
34055: PUSH
34056: LD_EXP 109
34060: PUSH
34061: LD_VAR 0 2
34065: ARRAY
34066: PUSH
34067: LD_VAR 0 3
34071: ARRAY
34072: DIFF
34073: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34074: LD_ADDR_EXP 109
34078: PUSH
34079: LD_EXP 109
34083: PPUSH
34084: LD_VAR 0 2
34088: PPUSH
34089: LD_VAR 0 5
34093: PPUSH
34094: CALL_OW 1
34098: ST_TO_ADDR
// continue ;
34099: GO 33987
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34101: LD_EXP 109
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: PUSH
34112: LD_VAR 0 3
34116: ARRAY
34117: PPUSH
34118: CALL_OW 257
34122: PUSH
34123: LD_INT 1
34125: EQUAL
34126: PUSH
34127: LD_EXP 109
34131: PUSH
34132: LD_VAR 0 2
34136: ARRAY
34137: PUSH
34138: LD_VAR 0 3
34142: ARRAY
34143: PPUSH
34144: CALL_OW 459
34148: NOT
34149: AND
34150: PUSH
34151: LD_EXP 109
34155: PUSH
34156: LD_VAR 0 2
34160: ARRAY
34161: PUSH
34162: LD_VAR 0 3
34166: ARRAY
34167: PPUSH
34168: CALL_OW 314
34172: NOT
34173: AND
34174: IFFALSE 34334
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34176: LD_EXP 109
34180: PUSH
34181: LD_VAR 0 2
34185: ARRAY
34186: PUSH
34187: LD_VAR 0 3
34191: ARRAY
34192: PPUSH
34193: CALL_OW 310
34197: IFFALSE 34220
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34199: LD_EXP 109
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: PUSH
34210: LD_VAR 0 3
34214: ARRAY
34215: PPUSH
34216: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34220: LD_EXP 109
34224: PUSH
34225: LD_VAR 0 2
34229: ARRAY
34230: PUSH
34231: LD_VAR 0 3
34235: ARRAY
34236: PPUSH
34237: CALL_OW 314
34241: NOT
34242: IFFALSE 34334
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34244: LD_ADDR_VAR 0 7
34248: PUSH
34249: LD_INT 1
34251: PPUSH
34252: LD_EXP 108
34256: PUSH
34257: LD_VAR 0 2
34261: ARRAY
34262: PPUSH
34263: CALL_OW 12
34267: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34268: LD_EXP 109
34272: PUSH
34273: LD_VAR 0 2
34277: ARRAY
34278: PUSH
34279: LD_VAR 0 3
34283: ARRAY
34284: PPUSH
34285: LD_EXP 108
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PUSH
34296: LD_VAR 0 7
34300: ARRAY
34301: PUSH
34302: LD_INT 1
34304: ARRAY
34305: PPUSH
34306: LD_EXP 108
34310: PUSH
34311: LD_VAR 0 2
34315: ARRAY
34316: PUSH
34317: LD_VAR 0 7
34321: ARRAY
34322: PUSH
34323: LD_INT 2
34325: ARRAY
34326: PPUSH
34327: LD_INT 0
34329: PPUSH
34330: CALL_OW 193
// end ; end ; end ;
34334: GO 33987
34336: POP
34337: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34338: LD_ADDR_VAR 0 5
34342: PUSH
34343: LD_EXP 95
34347: PUSH
34348: LD_VAR 0 2
34352: ARRAY
34353: PPUSH
34354: LD_INT 2
34356: PUSH
34357: LD_INT 30
34359: PUSH
34360: LD_INT 4
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 30
34369: PUSH
34370: LD_INT 5
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 30
34379: PUSH
34380: LD_INT 32
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: PPUSH
34393: CALL_OW 72
34397: ST_TO_ADDR
// if not tmp then
34398: LD_VAR 0 5
34402: NOT
34403: IFFALSE 34407
// continue ;
34405: GO 33900
// list := [ ] ;
34407: LD_ADDR_VAR 0 6
34411: PUSH
34412: EMPTY
34413: ST_TO_ADDR
// for j in tmp do
34414: LD_ADDR_VAR 0 3
34418: PUSH
34419: LD_VAR 0 5
34423: PUSH
34424: FOR_IN
34425: IFFALSE 34494
// begin for k in UnitsInside ( j ) do
34427: LD_ADDR_VAR 0 4
34431: PUSH
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 313
34441: PUSH
34442: FOR_IN
34443: IFFALSE 34490
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34445: LD_VAR 0 4
34449: PPUSH
34450: CALL_OW 257
34454: PUSH
34455: LD_INT 1
34457: EQUAL
34458: PUSH
34459: LD_VAR 0 4
34463: PPUSH
34464: CALL_OW 459
34468: NOT
34469: AND
34470: IFFALSE 34488
// list := list ^ k ;
34472: LD_ADDR_VAR 0 6
34476: PUSH
34477: LD_VAR 0 6
34481: PUSH
34482: LD_VAR 0 4
34486: ADD
34487: ST_TO_ADDR
34488: GO 34442
34490: POP
34491: POP
// end ;
34492: GO 34424
34494: POP
34495: POP
// list := list diff mc_miners [ i ] ;
34496: LD_ADDR_VAR 0 6
34500: PUSH
34501: LD_VAR 0 6
34505: PUSH
34506: LD_EXP 109
34510: PUSH
34511: LD_VAR 0 2
34515: ARRAY
34516: DIFF
34517: ST_TO_ADDR
// if not list then
34518: LD_VAR 0 6
34522: NOT
34523: IFFALSE 34527
// continue ;
34525: GO 33900
// k := mc_mines [ i ] - mc_miners [ i ] ;
34527: LD_ADDR_VAR 0 4
34531: PUSH
34532: LD_EXP 108
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_EXP 109
34547: PUSH
34548: LD_VAR 0 2
34552: ARRAY
34553: MINUS
34554: ST_TO_ADDR
// if k > list then
34555: LD_VAR 0 4
34559: PUSH
34560: LD_VAR 0 6
34564: GREATER
34565: IFFALSE 34577
// k := list ;
34567: LD_ADDR_VAR 0 4
34571: PUSH
34572: LD_VAR 0 6
34576: ST_TO_ADDR
// for j = 1 to k do
34577: LD_ADDR_VAR 0 3
34581: PUSH
34582: DOUBLE
34583: LD_INT 1
34585: DEC
34586: ST_TO_ADDR
34587: LD_VAR 0 4
34591: PUSH
34592: FOR_TO
34593: IFFALSE 34647
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34595: LD_ADDR_EXP 109
34599: PUSH
34600: LD_EXP 109
34604: PPUSH
34605: LD_VAR 0 2
34609: PUSH
34610: LD_EXP 109
34614: PUSH
34615: LD_VAR 0 2
34619: ARRAY
34620: PUSH
34621: LD_INT 1
34623: PLUS
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PPUSH
34629: LD_VAR 0 6
34633: PUSH
34634: LD_VAR 0 3
34638: ARRAY
34639: PPUSH
34640: CALL 57012 0 3
34644: ST_TO_ADDR
34645: GO 34592
34647: POP
34648: POP
// end ;
34649: GO 33900
34651: POP
34652: POP
// end ;
34653: LD_VAR 0 1
34657: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34658: LD_INT 0
34660: PPUSH
34661: PPUSH
34662: PPUSH
34663: PPUSH
34664: PPUSH
34665: PPUSH
34666: PPUSH
34667: PPUSH
34668: PPUSH
34669: PPUSH
34670: PPUSH
// if not mc_bases then
34671: LD_EXP 95
34675: NOT
34676: IFFALSE 34680
// exit ;
34678: GO 36503
// for i = 1 to mc_bases do
34680: LD_ADDR_VAR 0 2
34684: PUSH
34685: DOUBLE
34686: LD_INT 1
34688: DEC
34689: ST_TO_ADDR
34690: LD_EXP 95
34694: PUSH
34695: FOR_TO
34696: IFFALSE 36501
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34698: LD_EXP 95
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: NOT
34709: PUSH
34710: LD_EXP 102
34714: PUSH
34715: LD_VAR 0 2
34719: ARRAY
34720: OR
34721: IFFALSE 34725
// continue ;
34723: GO 34695
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34725: LD_EXP 111
34729: PUSH
34730: LD_VAR 0 2
34734: ARRAY
34735: NOT
34736: PUSH
34737: LD_EXP 112
34741: PUSH
34742: LD_VAR 0 2
34746: ARRAY
34747: AND
34748: IFFALSE 34786
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34750: LD_ADDR_EXP 112
34754: PUSH
34755: LD_EXP 112
34759: PPUSH
34760: LD_VAR 0 2
34764: PPUSH
34765: EMPTY
34766: PPUSH
34767: CALL_OW 1
34771: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34772: LD_VAR 0 2
34776: PPUSH
34777: LD_INT 107
34779: PPUSH
34780: CALL 25554 0 2
// continue ;
34784: GO 34695
// end ; target := [ ] ;
34786: LD_ADDR_VAR 0 7
34790: PUSH
34791: EMPTY
34792: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34793: LD_ADDR_VAR 0 6
34797: PUSH
34798: LD_EXP 95
34802: PUSH
34803: LD_VAR 0 2
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PPUSH
34813: CALL_OW 255
34817: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34818: LD_ADDR_VAR 0 9
34822: PUSH
34823: LD_EXP 95
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PPUSH
34834: LD_INT 2
34836: PUSH
34837: LD_INT 30
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 30
34849: PUSH
34850: LD_INT 1
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: LIST
34861: PPUSH
34862: CALL_OW 72
34866: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34867: LD_ADDR_VAR 0 3
34871: PUSH
34872: DOUBLE
34873: LD_EXP 111
34877: PUSH
34878: LD_VAR 0 2
34882: ARRAY
34883: INC
34884: ST_TO_ADDR
34885: LD_INT 1
34887: PUSH
34888: FOR_DOWNTO
34889: IFFALSE 35134
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34891: LD_EXP 111
34895: PUSH
34896: LD_VAR 0 2
34900: ARRAY
34901: PUSH
34902: LD_VAR 0 3
34906: ARRAY
34907: PUSH
34908: LD_INT 2
34910: ARRAY
34911: PPUSH
34912: LD_EXP 111
34916: PUSH
34917: LD_VAR 0 2
34921: ARRAY
34922: PUSH
34923: LD_VAR 0 3
34927: ARRAY
34928: PUSH
34929: LD_INT 3
34931: ARRAY
34932: PPUSH
34933: CALL_OW 488
34937: PUSH
34938: LD_EXP 111
34942: PUSH
34943: LD_VAR 0 2
34947: ARRAY
34948: PUSH
34949: LD_VAR 0 3
34953: ARRAY
34954: PUSH
34955: LD_INT 2
34957: ARRAY
34958: PPUSH
34959: LD_EXP 111
34963: PUSH
34964: LD_VAR 0 2
34968: ARRAY
34969: PUSH
34970: LD_VAR 0 3
34974: ARRAY
34975: PUSH
34976: LD_INT 3
34978: ARRAY
34979: PPUSH
34980: CALL_OW 284
34984: PUSH
34985: LD_INT 0
34987: EQUAL
34988: AND
34989: IFFALSE 35044
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34991: LD_ADDR_VAR 0 5
34995: PUSH
34996: LD_EXP 111
35000: PUSH
35001: LD_VAR 0 2
35005: ARRAY
35006: PPUSH
35007: LD_VAR 0 3
35011: PPUSH
35012: CALL_OW 3
35016: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35017: LD_ADDR_EXP 111
35021: PUSH
35022: LD_EXP 111
35026: PPUSH
35027: LD_VAR 0 2
35031: PPUSH
35032: LD_VAR 0 5
35036: PPUSH
35037: CALL_OW 1
35041: ST_TO_ADDR
// continue ;
35042: GO 34888
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35044: LD_VAR 0 6
35048: PPUSH
35049: LD_EXP 111
35053: PUSH
35054: LD_VAR 0 2
35058: ARRAY
35059: PUSH
35060: LD_VAR 0 3
35064: ARRAY
35065: PUSH
35066: LD_INT 2
35068: ARRAY
35069: PPUSH
35070: LD_EXP 111
35074: PUSH
35075: LD_VAR 0 2
35079: ARRAY
35080: PUSH
35081: LD_VAR 0 3
35085: ARRAY
35086: PUSH
35087: LD_INT 3
35089: ARRAY
35090: PPUSH
35091: LD_INT 30
35093: PPUSH
35094: CALL 57908 0 4
35098: PUSH
35099: LD_INT 4
35101: ARRAY
35102: PUSH
35103: LD_INT 0
35105: EQUAL
35106: IFFALSE 35132
// begin target := mc_crates [ i ] [ j ] ;
35108: LD_ADDR_VAR 0 7
35112: PUSH
35113: LD_EXP 111
35117: PUSH
35118: LD_VAR 0 2
35122: ARRAY
35123: PUSH
35124: LD_VAR 0 3
35128: ARRAY
35129: ST_TO_ADDR
// break ;
35130: GO 35134
// end ; end ;
35132: GO 34888
35134: POP
35135: POP
// if not target then
35136: LD_VAR 0 7
35140: NOT
35141: IFFALSE 35145
// continue ;
35143: GO 34695
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35145: LD_ADDR_VAR 0 8
35149: PUSH
35150: LD_EXP 114
35154: PUSH
35155: LD_VAR 0 2
35159: ARRAY
35160: PPUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 3
35166: PUSH
35167: LD_INT 58
35169: PUSH
35170: EMPTY
35171: LIST
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 61
35179: PUSH
35180: EMPTY
35181: LIST
35182: PUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 5
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 33
35195: PUSH
35196: LD_INT 3
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 2
35212: PUSH
35213: LD_INT 34
35215: PUSH
35216: LD_INT 32
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 34
35225: PUSH
35226: LD_INT 51
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 34
35235: PUSH
35236: LD_INT 12
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PPUSH
35253: CALL_OW 72
35257: ST_TO_ADDR
// if not cargo then
35258: LD_VAR 0 8
35262: NOT
35263: IFFALSE 35969
// begin if mc_crates_collector [ i ] < 5 then
35265: LD_EXP 112
35269: PUSH
35270: LD_VAR 0 2
35274: ARRAY
35275: PUSH
35276: LD_INT 5
35278: LESS
35279: IFFALSE 35645
// begin if mc_ape [ i ] then
35281: LD_EXP 124
35285: PUSH
35286: LD_VAR 0 2
35290: ARRAY
35291: IFFALSE 35338
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35293: LD_ADDR_VAR 0 5
35297: PUSH
35298: LD_EXP 124
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PPUSH
35309: LD_INT 25
35311: PUSH
35312: LD_INT 16
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 24
35321: PUSH
35322: LD_INT 750
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PPUSH
35333: CALL_OW 72
35337: ST_TO_ADDR
// if not tmp then
35338: LD_VAR 0 5
35342: NOT
35343: IFFALSE 35390
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35345: LD_ADDR_VAR 0 5
35349: PUSH
35350: LD_EXP 95
35354: PUSH
35355: LD_VAR 0 2
35359: ARRAY
35360: PPUSH
35361: LD_INT 25
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 24
35373: PUSH
35374: LD_INT 750
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PPUSH
35385: CALL_OW 72
35389: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35390: LD_EXP 124
35394: PUSH
35395: LD_VAR 0 2
35399: ARRAY
35400: PUSH
35401: LD_EXP 95
35405: PUSH
35406: LD_VAR 0 2
35410: ARRAY
35411: PPUSH
35412: LD_INT 25
35414: PUSH
35415: LD_INT 2
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 24
35424: PUSH
35425: LD_INT 750
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PPUSH
35436: CALL_OW 72
35440: AND
35441: PUSH
35442: LD_VAR 0 5
35446: PUSH
35447: LD_INT 5
35449: LESS
35450: AND
35451: IFFALSE 35533
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35453: LD_ADDR_VAR 0 3
35457: PUSH
35458: LD_EXP 95
35462: PUSH
35463: LD_VAR 0 2
35467: ARRAY
35468: PPUSH
35469: LD_INT 25
35471: PUSH
35472: LD_INT 2
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 24
35481: PUSH
35482: LD_INT 750
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PPUSH
35493: CALL_OW 72
35497: PUSH
35498: FOR_IN
35499: IFFALSE 35531
// begin tmp := tmp union j ;
35501: LD_ADDR_VAR 0 5
35505: PUSH
35506: LD_VAR 0 5
35510: PUSH
35511: LD_VAR 0 3
35515: UNION
35516: ST_TO_ADDR
// if tmp >= 5 then
35517: LD_VAR 0 5
35521: PUSH
35522: LD_INT 5
35524: GREATEREQUAL
35525: IFFALSE 35529
// break ;
35527: GO 35531
// end ;
35529: GO 35498
35531: POP
35532: POP
// end ; if not tmp then
35533: LD_VAR 0 5
35537: NOT
35538: IFFALSE 35542
// continue ;
35540: GO 34695
// for j in tmp do
35542: LD_ADDR_VAR 0 3
35546: PUSH
35547: LD_VAR 0 5
35551: PUSH
35552: FOR_IN
35553: IFFALSE 35643
// if not GetTag ( j ) then
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL_OW 110
35564: NOT
35565: IFFALSE 35641
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35567: LD_ADDR_EXP 112
35571: PUSH
35572: LD_EXP 112
35576: PPUSH
35577: LD_VAR 0 2
35581: PUSH
35582: LD_EXP 112
35586: PUSH
35587: LD_VAR 0 2
35591: ARRAY
35592: PUSH
35593: LD_INT 1
35595: PLUS
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PPUSH
35601: LD_VAR 0 3
35605: PPUSH
35606: CALL 57012 0 3
35610: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35611: LD_VAR 0 3
35615: PPUSH
35616: LD_INT 107
35618: PPUSH
35619: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35623: LD_EXP 112
35627: PUSH
35628: LD_VAR 0 2
35632: ARRAY
35633: PUSH
35634: LD_INT 5
35636: GREATEREQUAL
35637: IFFALSE 35641
// break ;
35639: GO 35643
// end ;
35641: GO 35552
35643: POP
35644: POP
// end ; if mc_crates_collector [ i ] and target then
35645: LD_EXP 112
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: LD_VAR 0 7
35660: AND
35661: IFFALSE 35967
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35663: LD_EXP 112
35667: PUSH
35668: LD_VAR 0 2
35672: ARRAY
35673: PUSH
35674: LD_VAR 0 7
35678: PUSH
35679: LD_INT 1
35681: ARRAY
35682: LESS
35683: IFFALSE 35703
// tmp := mc_crates_collector [ i ] else
35685: LD_ADDR_VAR 0 5
35689: PUSH
35690: LD_EXP 112
35694: PUSH
35695: LD_VAR 0 2
35699: ARRAY
35700: ST_TO_ADDR
35701: GO 35717
// tmp := target [ 1 ] ;
35703: LD_ADDR_VAR 0 5
35707: PUSH
35708: LD_VAR 0 7
35712: PUSH
35713: LD_INT 1
35715: ARRAY
35716: ST_TO_ADDR
// k := 0 ;
35717: LD_ADDR_VAR 0 4
35721: PUSH
35722: LD_INT 0
35724: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35725: LD_ADDR_VAR 0 3
35729: PUSH
35730: LD_EXP 112
35734: PUSH
35735: LD_VAR 0 2
35739: ARRAY
35740: PUSH
35741: FOR_IN
35742: IFFALSE 35965
// begin k := k + 1 ;
35744: LD_ADDR_VAR 0 4
35748: PUSH
35749: LD_VAR 0 4
35753: PUSH
35754: LD_INT 1
35756: PLUS
35757: ST_TO_ADDR
// if k > tmp then
35758: LD_VAR 0 4
35762: PUSH
35763: LD_VAR 0 5
35767: GREATER
35768: IFFALSE 35772
// break ;
35770: GO 35965
// if not GetClass ( j ) in [ 2 , 16 ] then
35772: LD_VAR 0 3
35776: PPUSH
35777: CALL_OW 257
35781: PUSH
35782: LD_INT 2
35784: PUSH
35785: LD_INT 16
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: IN
35792: NOT
35793: IFFALSE 35846
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35795: LD_ADDR_EXP 112
35799: PUSH
35800: LD_EXP 112
35804: PPUSH
35805: LD_VAR 0 2
35809: PPUSH
35810: LD_EXP 112
35814: PUSH
35815: LD_VAR 0 2
35819: ARRAY
35820: PUSH
35821: LD_VAR 0 3
35825: DIFF
35826: PPUSH
35827: CALL_OW 1
35831: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35832: LD_VAR 0 3
35836: PPUSH
35837: LD_INT 0
35839: PPUSH
35840: CALL_OW 109
// continue ;
35844: GO 35741
// end ; if IsInUnit ( j ) then
35846: LD_VAR 0 3
35850: PPUSH
35851: CALL_OW 310
35855: IFFALSE 35866
// ComExitBuilding ( j ) ;
35857: LD_VAR 0 3
35861: PPUSH
35862: CALL_OW 122
// wait ( 3 ) ;
35866: LD_INT 3
35868: PPUSH
35869: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35873: LD_VAR 0 3
35877: PPUSH
35878: CALL_OW 314
35882: PUSH
35883: LD_VAR 0 6
35887: PPUSH
35888: LD_VAR 0 7
35892: PUSH
35893: LD_INT 2
35895: ARRAY
35896: PPUSH
35897: LD_VAR 0 7
35901: PUSH
35902: LD_INT 3
35904: ARRAY
35905: PPUSH
35906: LD_INT 30
35908: PPUSH
35909: CALL 57908 0 4
35913: PUSH
35914: LD_INT 4
35916: ARRAY
35917: AND
35918: IFFALSE 35936
// ComStandNearbyBuilding ( j , depot ) else
35920: LD_VAR 0 3
35924: PPUSH
35925: LD_VAR 0 9
35929: PPUSH
35930: CALL 53590 0 2
35934: GO 35963
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35936: LD_VAR 0 3
35940: PPUSH
35941: LD_VAR 0 7
35945: PUSH
35946: LD_INT 2
35948: ARRAY
35949: PPUSH
35950: LD_VAR 0 7
35954: PUSH
35955: LD_INT 3
35957: ARRAY
35958: PPUSH
35959: CALL_OW 117
// end ;
35963: GO 35741
35965: POP
35966: POP
// end ; end else
35967: GO 36499
// begin for j in cargo do
35969: LD_ADDR_VAR 0 3
35973: PUSH
35974: LD_VAR 0 8
35978: PUSH
35979: FOR_IN
35980: IFFALSE 36497
// begin if GetTag ( j ) <> 0 then
35982: LD_VAR 0 3
35986: PPUSH
35987: CALL_OW 110
35991: PUSH
35992: LD_INT 0
35994: NONEQUAL
35995: IFFALSE 35999
// continue ;
35997: GO 35979
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35999: LD_VAR 0 3
36003: PPUSH
36004: CALL_OW 256
36008: PUSH
36009: LD_INT 1000
36011: LESS
36012: PUSH
36013: LD_VAR 0 3
36017: PPUSH
36018: LD_EXP 119
36022: PUSH
36023: LD_VAR 0 2
36027: ARRAY
36028: PPUSH
36029: CALL_OW 308
36033: NOT
36034: AND
36035: IFFALSE 36057
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36037: LD_VAR 0 3
36041: PPUSH
36042: LD_EXP 119
36046: PUSH
36047: LD_VAR 0 2
36051: ARRAY
36052: PPUSH
36053: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36057: LD_VAR 0 3
36061: PPUSH
36062: CALL_OW 256
36066: PUSH
36067: LD_INT 1000
36069: LESS
36070: PUSH
36071: LD_VAR 0 3
36075: PPUSH
36076: LD_EXP 119
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: PPUSH
36087: CALL_OW 308
36091: AND
36092: IFFALSE 36096
// continue ;
36094: GO 35979
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36096: LD_VAR 0 3
36100: PPUSH
36101: CALL_OW 262
36105: PUSH
36106: LD_INT 2
36108: EQUAL
36109: PUSH
36110: LD_VAR 0 3
36114: PPUSH
36115: CALL_OW 261
36119: PUSH
36120: LD_INT 15
36122: LESS
36123: AND
36124: IFFALSE 36128
// continue ;
36126: GO 35979
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36128: LD_VAR 0 3
36132: PPUSH
36133: CALL_OW 262
36137: PUSH
36138: LD_INT 1
36140: EQUAL
36141: PUSH
36142: LD_VAR 0 3
36146: PPUSH
36147: CALL_OW 261
36151: PUSH
36152: LD_INT 10
36154: LESS
36155: AND
36156: IFFALSE 36436
// begin if not depot then
36158: LD_VAR 0 9
36162: NOT
36163: IFFALSE 36167
// continue ;
36165: GO 35979
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36167: LD_VAR 0 3
36171: PPUSH
36172: LD_VAR 0 9
36176: PPUSH
36177: LD_VAR 0 3
36181: PPUSH
36182: CALL_OW 74
36186: PPUSH
36187: CALL_OW 296
36191: PUSH
36192: LD_INT 6
36194: LESS
36195: IFFALSE 36211
// SetFuel ( j , 100 ) else
36197: LD_VAR 0 3
36201: PPUSH
36202: LD_INT 100
36204: PPUSH
36205: CALL_OW 240
36209: GO 36436
// if GetFuel ( j ) = 0 then
36211: LD_VAR 0 3
36215: PPUSH
36216: CALL_OW 261
36220: PUSH
36221: LD_INT 0
36223: EQUAL
36224: IFFALSE 36436
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36226: LD_ADDR_EXP 114
36230: PUSH
36231: LD_EXP 114
36235: PPUSH
36236: LD_VAR 0 2
36240: PPUSH
36241: LD_EXP 114
36245: PUSH
36246: LD_VAR 0 2
36250: ARRAY
36251: PUSH
36252: LD_VAR 0 3
36256: DIFF
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36263: LD_VAR 0 3
36267: PPUSH
36268: CALL_OW 263
36272: PUSH
36273: LD_INT 1
36275: EQUAL
36276: IFFALSE 36292
// ComExitVehicle ( IsInUnit ( j ) ) ;
36278: LD_VAR 0 3
36282: PPUSH
36283: CALL_OW 310
36287: PPUSH
36288: CALL_OW 121
// if GetControl ( j ) = control_remote then
36292: LD_VAR 0 3
36296: PPUSH
36297: CALL_OW 263
36301: PUSH
36302: LD_INT 2
36304: EQUAL
36305: IFFALSE 36316
// ComUnlink ( j ) ;
36307: LD_VAR 0 3
36311: PPUSH
36312: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36316: LD_ADDR_VAR 0 10
36320: PUSH
36321: LD_VAR 0 2
36325: PPUSH
36326: LD_INT 3
36328: PPUSH
36329: CALL 46075 0 2
36333: ST_TO_ADDR
// if fac then
36334: LD_VAR 0 10
36338: IFFALSE 36434
// begin for k in fac do
36340: LD_ADDR_VAR 0 4
36344: PUSH
36345: LD_VAR 0 10
36349: PUSH
36350: FOR_IN
36351: IFFALSE 36432
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36353: LD_ADDR_VAR 0 11
36357: PUSH
36358: LD_VAR 0 10
36362: PPUSH
36363: LD_VAR 0 3
36367: PPUSH
36368: CALL_OW 265
36372: PPUSH
36373: LD_VAR 0 3
36377: PPUSH
36378: CALL_OW 262
36382: PPUSH
36383: LD_VAR 0 3
36387: PPUSH
36388: CALL_OW 263
36392: PPUSH
36393: LD_VAR 0 3
36397: PPUSH
36398: CALL_OW 264
36402: PPUSH
36403: CALL 54508 0 5
36407: ST_TO_ADDR
// if components then
36408: LD_VAR 0 11
36412: IFFALSE 36430
// begin MC_InsertProduceList ( i , components ) ;
36414: LD_VAR 0 2
36418: PPUSH
36419: LD_VAR 0 11
36423: PPUSH
36424: CALL 45620 0 2
// break ;
36428: GO 36432
// end ; end ;
36430: GO 36350
36432: POP
36433: POP
// end ; continue ;
36434: GO 35979
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36436: LD_VAR 0 3
36440: PPUSH
36441: LD_INT 1
36443: PPUSH
36444: CALL_OW 289
36448: PUSH
36449: LD_INT 100
36451: LESS
36452: PUSH
36453: LD_VAR 0 3
36457: PPUSH
36458: CALL_OW 314
36462: NOT
36463: AND
36464: IFFALSE 36493
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36466: LD_VAR 0 3
36470: PPUSH
36471: LD_VAR 0 7
36475: PUSH
36476: LD_INT 2
36478: ARRAY
36479: PPUSH
36480: LD_VAR 0 7
36484: PUSH
36485: LD_INT 3
36487: ARRAY
36488: PPUSH
36489: CALL_OW 117
// break ;
36493: GO 36497
// end ;
36495: GO 35979
36497: POP
36498: POP
// end ; end ;
36499: GO 34695
36501: POP
36502: POP
// end ;
36503: LD_VAR 0 1
36507: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36508: LD_INT 0
36510: PPUSH
36511: PPUSH
36512: PPUSH
36513: PPUSH
// if not mc_bases then
36514: LD_EXP 95
36518: NOT
36519: IFFALSE 36523
// exit ;
36521: GO 36684
// for i = 1 to mc_bases do
36523: LD_ADDR_VAR 0 2
36527: PUSH
36528: DOUBLE
36529: LD_INT 1
36531: DEC
36532: ST_TO_ADDR
36533: LD_EXP 95
36537: PUSH
36538: FOR_TO
36539: IFFALSE 36682
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36541: LD_ADDR_VAR 0 4
36545: PUSH
36546: LD_EXP 114
36550: PUSH
36551: LD_VAR 0 2
36555: ARRAY
36556: PUSH
36557: LD_EXP 117
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: UNION
36568: PPUSH
36569: LD_INT 33
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PPUSH
36579: CALL_OW 72
36583: ST_TO_ADDR
// if tmp then
36584: LD_VAR 0 4
36588: IFFALSE 36680
// for j in tmp do
36590: LD_ADDR_VAR 0 3
36594: PUSH
36595: LD_VAR 0 4
36599: PUSH
36600: FOR_IN
36601: IFFALSE 36678
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36603: LD_VAR 0 3
36607: PPUSH
36608: CALL_OW 312
36612: NOT
36613: PUSH
36614: LD_VAR 0 3
36618: PPUSH
36619: CALL_OW 256
36623: PUSH
36624: LD_INT 250
36626: GREATEREQUAL
36627: AND
36628: IFFALSE 36641
// Connect ( j ) else
36630: LD_VAR 0 3
36634: PPUSH
36635: CALL 59983 0 1
36639: GO 36676
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36641: LD_VAR 0 3
36645: PPUSH
36646: CALL_OW 256
36650: PUSH
36651: LD_INT 250
36653: LESS
36654: PUSH
36655: LD_VAR 0 3
36659: PPUSH
36660: CALL_OW 312
36664: AND
36665: IFFALSE 36676
// ComUnlink ( j ) ;
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 136
36676: GO 36600
36678: POP
36679: POP
// end ;
36680: GO 36538
36682: POP
36683: POP
// end ;
36684: LD_VAR 0 1
36688: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36689: LD_INT 0
36691: PPUSH
36692: PPUSH
36693: PPUSH
36694: PPUSH
36695: PPUSH
// if not mc_bases then
36696: LD_EXP 95
36700: NOT
36701: IFFALSE 36705
// exit ;
36703: GO 37150
// for i = 1 to mc_bases do
36705: LD_ADDR_VAR 0 2
36709: PUSH
36710: DOUBLE
36711: LD_INT 1
36713: DEC
36714: ST_TO_ADDR
36715: LD_EXP 95
36719: PUSH
36720: FOR_TO
36721: IFFALSE 37148
// begin if not mc_produce [ i ] then
36723: LD_EXP 116
36727: PUSH
36728: LD_VAR 0 2
36732: ARRAY
36733: NOT
36734: IFFALSE 36738
// continue ;
36736: GO 36720
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36738: LD_ADDR_VAR 0 5
36742: PUSH
36743: LD_EXP 95
36747: PUSH
36748: LD_VAR 0 2
36752: ARRAY
36753: PPUSH
36754: LD_INT 30
36756: PUSH
36757: LD_INT 3
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PPUSH
36764: CALL_OW 72
36768: ST_TO_ADDR
// if not fac then
36769: LD_VAR 0 5
36773: NOT
36774: IFFALSE 36778
// continue ;
36776: GO 36720
// for j in fac do
36778: LD_ADDR_VAR 0 3
36782: PUSH
36783: LD_VAR 0 5
36787: PUSH
36788: FOR_IN
36789: IFFALSE 37144
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36791: LD_VAR 0 3
36795: PPUSH
36796: CALL_OW 461
36800: PUSH
36801: LD_INT 2
36803: NONEQUAL
36804: PUSH
36805: LD_VAR 0 3
36809: PPUSH
36810: LD_INT 15
36812: PPUSH
36813: CALL 59611 0 2
36817: PUSH
36818: LD_INT 4
36820: ARRAY
36821: OR
36822: IFFALSE 36826
// continue ;
36824: GO 36788
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36826: LD_VAR 0 3
36830: PPUSH
36831: LD_EXP 116
36835: PUSH
36836: LD_VAR 0 2
36840: ARRAY
36841: PUSH
36842: LD_INT 1
36844: ARRAY
36845: PUSH
36846: LD_INT 1
36848: ARRAY
36849: PPUSH
36850: LD_EXP 116
36854: PUSH
36855: LD_VAR 0 2
36859: ARRAY
36860: PUSH
36861: LD_INT 1
36863: ARRAY
36864: PUSH
36865: LD_INT 2
36867: ARRAY
36868: PPUSH
36869: LD_EXP 116
36873: PUSH
36874: LD_VAR 0 2
36878: ARRAY
36879: PUSH
36880: LD_INT 1
36882: ARRAY
36883: PUSH
36884: LD_INT 3
36886: ARRAY
36887: PPUSH
36888: LD_EXP 116
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: PUSH
36899: LD_INT 1
36901: ARRAY
36902: PUSH
36903: LD_INT 4
36905: ARRAY
36906: PPUSH
36907: CALL_OW 448
36911: PUSH
36912: LD_VAR 0 3
36916: PPUSH
36917: LD_EXP 116
36921: PUSH
36922: LD_VAR 0 2
36926: ARRAY
36927: PUSH
36928: LD_INT 1
36930: ARRAY
36931: PUSH
36932: LD_INT 1
36934: ARRAY
36935: PUSH
36936: LD_EXP 116
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PUSH
36947: LD_INT 1
36949: ARRAY
36950: PUSH
36951: LD_INT 2
36953: ARRAY
36954: PUSH
36955: LD_EXP 116
36959: PUSH
36960: LD_VAR 0 2
36964: ARRAY
36965: PUSH
36966: LD_INT 1
36968: ARRAY
36969: PUSH
36970: LD_INT 3
36972: ARRAY
36973: PUSH
36974: LD_EXP 116
36978: PUSH
36979: LD_VAR 0 2
36983: ARRAY
36984: PUSH
36985: LD_INT 1
36987: ARRAY
36988: PUSH
36989: LD_INT 4
36991: ARRAY
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: PPUSH
36999: CALL 63378 0 2
37003: AND
37004: IFFALSE 37142
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37006: LD_VAR 0 3
37010: PPUSH
37011: LD_EXP 116
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: PPUSH
37030: LD_EXP 116
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PUSH
37045: LD_INT 2
37047: ARRAY
37048: PPUSH
37049: LD_EXP 116
37053: PUSH
37054: LD_VAR 0 2
37058: ARRAY
37059: PUSH
37060: LD_INT 1
37062: ARRAY
37063: PUSH
37064: LD_INT 3
37066: ARRAY
37067: PPUSH
37068: LD_EXP 116
37072: PUSH
37073: LD_VAR 0 2
37077: ARRAY
37078: PUSH
37079: LD_INT 1
37081: ARRAY
37082: PUSH
37083: LD_INT 4
37085: ARRAY
37086: PPUSH
37087: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37091: LD_ADDR_VAR 0 4
37095: PUSH
37096: LD_EXP 116
37100: PUSH
37101: LD_VAR 0 2
37105: ARRAY
37106: PPUSH
37107: LD_INT 1
37109: PPUSH
37110: CALL_OW 3
37114: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37115: LD_ADDR_EXP 116
37119: PUSH
37120: LD_EXP 116
37124: PPUSH
37125: LD_VAR 0 2
37129: PPUSH
37130: LD_VAR 0 4
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// break ;
37140: GO 37144
// end ; end ;
37142: GO 36788
37144: POP
37145: POP
// end ;
37146: GO 36720
37148: POP
37149: POP
// end ;
37150: LD_VAR 0 1
37154: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37155: LD_INT 0
37157: PPUSH
37158: PPUSH
37159: PPUSH
// if not mc_bases then
37160: LD_EXP 95
37164: NOT
37165: IFFALSE 37169
// exit ;
37167: GO 37258
// for i = 1 to mc_bases do
37169: LD_ADDR_VAR 0 2
37173: PUSH
37174: DOUBLE
37175: LD_INT 1
37177: DEC
37178: ST_TO_ADDR
37179: LD_EXP 95
37183: PUSH
37184: FOR_TO
37185: IFFALSE 37256
// begin if mc_attack [ i ] then
37187: LD_EXP 115
37191: PUSH
37192: LD_VAR 0 2
37196: ARRAY
37197: IFFALSE 37254
// begin tmp := mc_attack [ i ] [ 1 ] ;
37199: LD_ADDR_VAR 0 3
37203: PUSH
37204: LD_EXP 115
37208: PUSH
37209: LD_VAR 0 2
37213: ARRAY
37214: PUSH
37215: LD_INT 1
37217: ARRAY
37218: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37219: LD_ADDR_EXP 115
37223: PUSH
37224: LD_EXP 115
37228: PPUSH
37229: LD_VAR 0 2
37233: PPUSH
37234: EMPTY
37235: PPUSH
37236: CALL_OW 1
37240: ST_TO_ADDR
// Attack ( tmp ) ;
37241: LD_VAR 0 3
37245: PPUSH
37246: CALL 109554 0 1
// exit ;
37250: POP
37251: POP
37252: GO 37258
// end ; end ;
37254: GO 37184
37256: POP
37257: POP
// end ;
37258: LD_VAR 0 1
37262: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37263: LD_INT 0
37265: PPUSH
37266: PPUSH
37267: PPUSH
37268: PPUSH
37269: PPUSH
37270: PPUSH
37271: PPUSH
// if not mc_bases then
37272: LD_EXP 95
37276: NOT
37277: IFFALSE 37281
// exit ;
37279: GO 38138
// for i = 1 to mc_bases do
37281: LD_ADDR_VAR 0 2
37285: PUSH
37286: DOUBLE
37287: LD_INT 1
37289: DEC
37290: ST_TO_ADDR
37291: LD_EXP 95
37295: PUSH
37296: FOR_TO
37297: IFFALSE 38136
// begin if not mc_bases [ i ] then
37299: LD_EXP 95
37303: PUSH
37304: LD_VAR 0 2
37308: ARRAY
37309: NOT
37310: IFFALSE 37314
// continue ;
37312: GO 37296
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37314: LD_ADDR_VAR 0 7
37318: PUSH
37319: LD_EXP 95
37323: PUSH
37324: LD_VAR 0 2
37328: ARRAY
37329: PUSH
37330: LD_INT 1
37332: ARRAY
37333: PPUSH
37334: CALL 53812 0 1
37338: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37339: LD_ADDR_EXP 118
37343: PUSH
37344: LD_EXP 118
37348: PPUSH
37349: LD_VAR 0 2
37353: PPUSH
37354: LD_EXP 95
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: PUSH
37365: LD_INT 1
37367: ARRAY
37368: PPUSH
37369: CALL_OW 255
37373: PPUSH
37374: LD_EXP 120
37378: PUSH
37379: LD_VAR 0 2
37383: ARRAY
37384: PPUSH
37385: CALL 53777 0 2
37389: PPUSH
37390: CALL_OW 1
37394: ST_TO_ADDR
// if not mc_scan [ i ] then
37395: LD_EXP 118
37399: PUSH
37400: LD_VAR 0 2
37404: ARRAY
37405: NOT
37406: IFFALSE 37584
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37408: LD_ADDR_EXP 138
37412: PUSH
37413: LD_EXP 138
37417: PPUSH
37418: LD_VAR 0 2
37422: PPUSH
37423: LD_INT 0
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37431: LD_ADDR_VAR 0 4
37435: PUSH
37436: LD_EXP 95
37440: PUSH
37441: LD_VAR 0 2
37445: ARRAY
37446: PPUSH
37447: LD_INT 2
37449: PUSH
37450: LD_INT 25
37452: PUSH
37453: LD_INT 5
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 25
37462: PUSH
37463: LD_INT 8
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 25
37472: PUSH
37473: LD_INT 9
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: PPUSH
37486: CALL_OW 72
37490: ST_TO_ADDR
// if not tmp then
37491: LD_VAR 0 4
37495: NOT
37496: IFFALSE 37500
// continue ;
37498: GO 37296
// for j in tmp do
37500: LD_ADDR_VAR 0 3
37504: PUSH
37505: LD_VAR 0 4
37509: PUSH
37510: FOR_IN
37511: IFFALSE 37582
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37513: LD_VAR 0 3
37517: PPUSH
37518: CALL_OW 310
37522: PPUSH
37523: CALL_OW 266
37527: PUSH
37528: LD_INT 5
37530: EQUAL
37531: PUSH
37532: LD_VAR 0 3
37536: PPUSH
37537: CALL_OW 257
37541: PUSH
37542: LD_INT 1
37544: EQUAL
37545: AND
37546: PUSH
37547: LD_VAR 0 3
37551: PPUSH
37552: CALL_OW 459
37556: NOT
37557: AND
37558: PUSH
37559: LD_VAR 0 7
37563: AND
37564: IFFALSE 37580
// ComChangeProfession ( j , class ) ;
37566: LD_VAR 0 3
37570: PPUSH
37571: LD_VAR 0 7
37575: PPUSH
37576: CALL_OW 123
37580: GO 37510
37582: POP
37583: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37584: LD_EXP 118
37588: PUSH
37589: LD_VAR 0 2
37593: ARRAY
37594: PUSH
37595: LD_EXP 138
37599: PUSH
37600: LD_VAR 0 2
37604: ARRAY
37605: NOT
37606: AND
37607: PUSH
37608: LD_EXP 117
37612: PUSH
37613: LD_VAR 0 2
37617: ARRAY
37618: NOT
37619: AND
37620: PUSH
37621: LD_EXP 95
37625: PUSH
37626: LD_VAR 0 2
37630: ARRAY
37631: PPUSH
37632: LD_INT 50
37634: PUSH
37635: EMPTY
37636: LIST
37637: PUSH
37638: LD_INT 2
37640: PUSH
37641: LD_INT 30
37643: PUSH
37644: LD_INT 32
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 30
37653: PUSH
37654: LD_INT 33
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 30
37663: PUSH
37664: LD_INT 4
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 30
37673: PUSH
37674: LD_INT 5
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PPUSH
37692: CALL_OW 72
37696: PUSH
37697: LD_INT 4
37699: LESS
37700: PUSH
37701: LD_EXP 95
37705: PUSH
37706: LD_VAR 0 2
37710: ARRAY
37711: PPUSH
37712: LD_INT 3
37714: PUSH
37715: LD_INT 24
37717: PUSH
37718: LD_INT 1000
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 30
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: LIST
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PPUSH
37761: CALL_OW 72
37765: OR
37766: AND
37767: IFFALSE 38018
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37769: LD_ADDR_EXP 138
37773: PUSH
37774: LD_EXP 138
37778: PPUSH
37779: LD_VAR 0 2
37783: PPUSH
37784: LD_INT 1
37786: PPUSH
37787: CALL_OW 1
37791: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37792: LD_ADDR_VAR 0 4
37796: PUSH
37797: LD_EXP 95
37801: PUSH
37802: LD_VAR 0 2
37806: ARRAY
37807: PPUSH
37808: LD_INT 2
37810: PUSH
37811: LD_INT 25
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 25
37823: PUSH
37824: LD_INT 5
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 25
37833: PUSH
37834: LD_INT 8
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 25
37843: PUSH
37844: LD_INT 9
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: PPUSH
37858: CALL_OW 72
37862: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37863: LD_ADDR_VAR 0 4
37867: PUSH
37868: LD_VAR 0 4
37872: PUSH
37873: LD_VAR 0 4
37877: PPUSH
37878: LD_INT 18
37880: PPUSH
37881: CALL 86281 0 2
37885: DIFF
37886: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37887: LD_VAR 0 4
37891: NOT
37892: PUSH
37893: LD_EXP 95
37897: PUSH
37898: LD_VAR 0 2
37902: ARRAY
37903: PPUSH
37904: LD_INT 2
37906: PUSH
37907: LD_INT 30
37909: PUSH
37910: LD_INT 4
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 30
37919: PUSH
37920: LD_INT 5
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: LIST
37931: PPUSH
37932: CALL_OW 72
37936: NOT
37937: AND
37938: IFFALSE 38000
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37940: LD_ADDR_VAR 0 4
37944: PUSH
37945: LD_EXP 95
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: PPUSH
37956: LD_INT 2
37958: PUSH
37959: LD_INT 25
37961: PUSH
37962: LD_INT 2
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 25
37971: PUSH
37972: LD_INT 3
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 25
37981: PUSH
37982: LD_INT 4
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: PPUSH
37995: CALL_OW 72
37999: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38000: LD_VAR 0 2
38004: PPUSH
38005: LD_VAR 0 4
38009: PPUSH
38010: CALL 114263 0 2
// exit ;
38014: POP
38015: POP
38016: GO 38138
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38018: LD_EXP 118
38022: PUSH
38023: LD_VAR 0 2
38027: ARRAY
38028: PUSH
38029: LD_EXP 138
38033: PUSH
38034: LD_VAR 0 2
38038: ARRAY
38039: NOT
38040: AND
38041: PUSH
38042: LD_EXP 117
38046: PUSH
38047: LD_VAR 0 2
38051: ARRAY
38052: AND
38053: IFFALSE 38134
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38055: LD_ADDR_EXP 138
38059: PUSH
38060: LD_EXP 138
38064: PPUSH
38065: LD_VAR 0 2
38069: PPUSH
38070: LD_INT 1
38072: PPUSH
38073: CALL_OW 1
38077: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38078: LD_ADDR_VAR 0 4
38082: PUSH
38083: LD_EXP 117
38087: PUSH
38088: LD_VAR 0 2
38092: ARRAY
38093: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38094: LD_ADDR_EXP 117
38098: PUSH
38099: LD_EXP 117
38103: PPUSH
38104: LD_VAR 0 2
38108: PPUSH
38109: EMPTY
38110: PPUSH
38111: CALL_OW 1
38115: ST_TO_ADDR
// Defend ( i , tmp ) ;
38116: LD_VAR 0 2
38120: PPUSH
38121: LD_VAR 0 4
38125: PPUSH
38126: CALL 114859 0 2
// exit ;
38130: POP
38131: POP
38132: GO 38138
// end ; end ;
38134: GO 37296
38136: POP
38137: POP
// end ;
38138: LD_VAR 0 1
38142: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38143: LD_INT 0
38145: PPUSH
38146: PPUSH
38147: PPUSH
38148: PPUSH
38149: PPUSH
38150: PPUSH
38151: PPUSH
38152: PPUSH
38153: PPUSH
38154: PPUSH
38155: PPUSH
// if not mc_bases then
38156: LD_EXP 95
38160: NOT
38161: IFFALSE 38165
// exit ;
38163: GO 39252
// for i = 1 to mc_bases do
38165: LD_ADDR_VAR 0 2
38169: PUSH
38170: DOUBLE
38171: LD_INT 1
38173: DEC
38174: ST_TO_ADDR
38175: LD_EXP 95
38179: PUSH
38180: FOR_TO
38181: IFFALSE 39250
// begin tmp := mc_lab [ i ] ;
38183: LD_ADDR_VAR 0 6
38187: PUSH
38188: LD_EXP 128
38192: PUSH
38193: LD_VAR 0 2
38197: ARRAY
38198: ST_TO_ADDR
// if not tmp then
38199: LD_VAR 0 6
38203: NOT
38204: IFFALSE 38208
// continue ;
38206: GO 38180
// idle_lab := 0 ;
38208: LD_ADDR_VAR 0 11
38212: PUSH
38213: LD_INT 0
38215: ST_TO_ADDR
// for j in tmp do
38216: LD_ADDR_VAR 0 3
38220: PUSH
38221: LD_VAR 0 6
38225: PUSH
38226: FOR_IN
38227: IFFALSE 39246
// begin researching := false ;
38229: LD_ADDR_VAR 0 10
38233: PUSH
38234: LD_INT 0
38236: ST_TO_ADDR
// side := GetSide ( j ) ;
38237: LD_ADDR_VAR 0 4
38241: PUSH
38242: LD_VAR 0 3
38246: PPUSH
38247: CALL_OW 255
38251: ST_TO_ADDR
// if not mc_tech [ side ] then
38252: LD_EXP 122
38256: PUSH
38257: LD_VAR 0 4
38261: ARRAY
38262: NOT
38263: IFFALSE 38267
// continue ;
38265: GO 38226
// if BuildingStatus ( j ) = bs_idle then
38267: LD_VAR 0 3
38271: PPUSH
38272: CALL_OW 461
38276: PUSH
38277: LD_INT 2
38279: EQUAL
38280: IFFALSE 38468
// begin if idle_lab and UnitsInside ( j ) < 6 then
38282: LD_VAR 0 11
38286: PUSH
38287: LD_VAR 0 3
38291: PPUSH
38292: CALL_OW 313
38296: PUSH
38297: LD_INT 6
38299: LESS
38300: AND
38301: IFFALSE 38372
// begin tmp2 := UnitsInside ( idle_lab ) ;
38303: LD_ADDR_VAR 0 9
38307: PUSH
38308: LD_VAR 0 11
38312: PPUSH
38313: CALL_OW 313
38317: ST_TO_ADDR
// if tmp2 then
38318: LD_VAR 0 9
38322: IFFALSE 38364
// for x in tmp2 do
38324: LD_ADDR_VAR 0 7
38328: PUSH
38329: LD_VAR 0 9
38333: PUSH
38334: FOR_IN
38335: IFFALSE 38362
// begin ComExitBuilding ( x ) ;
38337: LD_VAR 0 7
38341: PPUSH
38342: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38346: LD_VAR 0 7
38350: PPUSH
38351: LD_VAR 0 3
38355: PPUSH
38356: CALL_OW 180
// end ;
38360: GO 38334
38362: POP
38363: POP
// idle_lab := 0 ;
38364: LD_ADDR_VAR 0 11
38368: PUSH
38369: LD_INT 0
38371: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38372: LD_ADDR_VAR 0 5
38376: PUSH
38377: LD_EXP 122
38381: PUSH
38382: LD_VAR 0 4
38386: ARRAY
38387: PUSH
38388: FOR_IN
38389: IFFALSE 38449
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38391: LD_VAR 0 3
38395: PPUSH
38396: LD_VAR 0 5
38400: PPUSH
38401: CALL_OW 430
38405: PUSH
38406: LD_VAR 0 4
38410: PPUSH
38411: LD_VAR 0 5
38415: PPUSH
38416: CALL 52882 0 2
38420: AND
38421: IFFALSE 38447
// begin researching := true ;
38423: LD_ADDR_VAR 0 10
38427: PUSH
38428: LD_INT 1
38430: ST_TO_ADDR
// ComResearch ( j , t ) ;
38431: LD_VAR 0 3
38435: PPUSH
38436: LD_VAR 0 5
38440: PPUSH
38441: CALL_OW 124
// break ;
38445: GO 38449
// end ;
38447: GO 38388
38449: POP
38450: POP
// if not researching then
38451: LD_VAR 0 10
38455: NOT
38456: IFFALSE 38468
// idle_lab := j ;
38458: LD_ADDR_VAR 0 11
38462: PUSH
38463: LD_VAR 0 3
38467: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38468: LD_VAR 0 3
38472: PPUSH
38473: CALL_OW 461
38477: PUSH
38478: LD_INT 10
38480: EQUAL
38481: IFFALSE 39069
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38483: LD_EXP 124
38487: PUSH
38488: LD_VAR 0 2
38492: ARRAY
38493: NOT
38494: PUSH
38495: LD_EXP 125
38499: PUSH
38500: LD_VAR 0 2
38504: ARRAY
38505: NOT
38506: AND
38507: PUSH
38508: LD_EXP 122
38512: PUSH
38513: LD_VAR 0 4
38517: ARRAY
38518: PUSH
38519: LD_INT 1
38521: GREATER
38522: AND
38523: IFFALSE 38654
// begin ComCancel ( j ) ;
38525: LD_VAR 0 3
38529: PPUSH
38530: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38534: LD_ADDR_EXP 122
38538: PUSH
38539: LD_EXP 122
38543: PPUSH
38544: LD_VAR 0 4
38548: PPUSH
38549: LD_EXP 122
38553: PUSH
38554: LD_VAR 0 4
38558: ARRAY
38559: PPUSH
38560: LD_EXP 122
38564: PUSH
38565: LD_VAR 0 4
38569: ARRAY
38570: PUSH
38571: LD_INT 1
38573: MINUS
38574: PPUSH
38575: LD_EXP 122
38579: PUSH
38580: LD_VAR 0 4
38584: ARRAY
38585: PPUSH
38586: LD_INT 0
38588: PPUSH
38589: CALL 56430 0 4
38593: PPUSH
38594: CALL_OW 1
38598: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38599: LD_ADDR_EXP 122
38603: PUSH
38604: LD_EXP 122
38608: PPUSH
38609: LD_VAR 0 4
38613: PPUSH
38614: LD_EXP 122
38618: PUSH
38619: LD_VAR 0 4
38623: ARRAY
38624: PPUSH
38625: LD_EXP 122
38629: PUSH
38630: LD_VAR 0 4
38634: ARRAY
38635: PPUSH
38636: LD_INT 1
38638: PPUSH
38639: LD_INT 0
38641: PPUSH
38642: CALL 56430 0 4
38646: PPUSH
38647: CALL_OW 1
38651: ST_TO_ADDR
// continue ;
38652: GO 38226
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38654: LD_EXP 124
38658: PUSH
38659: LD_VAR 0 2
38663: ARRAY
38664: PUSH
38665: LD_EXP 125
38669: PUSH
38670: LD_VAR 0 2
38674: ARRAY
38675: NOT
38676: AND
38677: IFFALSE 38804
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38679: LD_ADDR_EXP 125
38683: PUSH
38684: LD_EXP 125
38688: PPUSH
38689: LD_VAR 0 2
38693: PUSH
38694: LD_EXP 125
38698: PUSH
38699: LD_VAR 0 2
38703: ARRAY
38704: PUSH
38705: LD_INT 1
38707: PLUS
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PPUSH
38713: LD_EXP 124
38717: PUSH
38718: LD_VAR 0 2
38722: ARRAY
38723: PUSH
38724: LD_INT 1
38726: ARRAY
38727: PPUSH
38728: CALL 57012 0 3
38732: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38733: LD_EXP 124
38737: PUSH
38738: LD_VAR 0 2
38742: ARRAY
38743: PUSH
38744: LD_INT 1
38746: ARRAY
38747: PPUSH
38748: LD_INT 112
38750: PPUSH
38751: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38755: LD_ADDR_VAR 0 9
38759: PUSH
38760: LD_EXP 124
38764: PUSH
38765: LD_VAR 0 2
38769: ARRAY
38770: PPUSH
38771: LD_INT 1
38773: PPUSH
38774: CALL_OW 3
38778: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38779: LD_ADDR_EXP 124
38783: PUSH
38784: LD_EXP 124
38788: PPUSH
38789: LD_VAR 0 2
38793: PPUSH
38794: LD_VAR 0 9
38798: PPUSH
38799: CALL_OW 1
38803: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38804: LD_EXP 124
38808: PUSH
38809: LD_VAR 0 2
38813: ARRAY
38814: PUSH
38815: LD_EXP 125
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: AND
38826: PUSH
38827: LD_EXP 125
38831: PUSH
38832: LD_VAR 0 2
38836: ARRAY
38837: PUSH
38838: LD_INT 1
38840: ARRAY
38841: PPUSH
38842: CALL_OW 310
38846: NOT
38847: AND
38848: PUSH
38849: LD_VAR 0 3
38853: PPUSH
38854: CALL_OW 313
38858: PUSH
38859: LD_INT 6
38861: EQUAL
38862: AND
38863: IFFALSE 38919
// begin tmp2 := UnitsInside ( j ) ;
38865: LD_ADDR_VAR 0 9
38869: PUSH
38870: LD_VAR 0 3
38874: PPUSH
38875: CALL_OW 313
38879: ST_TO_ADDR
// if tmp2 = 6 then
38880: LD_VAR 0 9
38884: PUSH
38885: LD_INT 6
38887: EQUAL
38888: IFFALSE 38919
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38890: LD_VAR 0 9
38894: PUSH
38895: LD_INT 1
38897: ARRAY
38898: PPUSH
38899: LD_INT 112
38901: PPUSH
38902: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38906: LD_VAR 0 9
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38919: LD_EXP 125
38923: PUSH
38924: LD_VAR 0 2
38928: ARRAY
38929: PUSH
38930: LD_EXP 125
38934: PUSH
38935: LD_VAR 0 2
38939: ARRAY
38940: PUSH
38941: LD_INT 1
38943: ARRAY
38944: PPUSH
38945: CALL_OW 314
38949: NOT
38950: AND
38951: PUSH
38952: LD_EXP 125
38956: PUSH
38957: LD_VAR 0 2
38961: ARRAY
38962: PUSH
38963: LD_INT 1
38965: ARRAY
38966: PPUSH
38967: CALL_OW 310
38971: NOT
38972: AND
38973: IFFALSE 38999
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38975: LD_EXP 125
38979: PUSH
38980: LD_VAR 0 2
38984: ARRAY
38985: PUSH
38986: LD_INT 1
38988: ARRAY
38989: PPUSH
38990: LD_VAR 0 3
38994: PPUSH
38995: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38999: LD_EXP 125
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: PUSH
39010: LD_INT 1
39012: ARRAY
39013: PPUSH
39014: CALL_OW 310
39018: PUSH
39019: LD_EXP 125
39023: PUSH
39024: LD_VAR 0 2
39028: ARRAY
39029: PUSH
39030: LD_INT 1
39032: ARRAY
39033: PPUSH
39034: CALL_OW 310
39038: PPUSH
39039: CALL_OW 461
39043: PUSH
39044: LD_INT 3
39046: NONEQUAL
39047: AND
39048: IFFALSE 39069
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39050: LD_EXP 125
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: PUSH
39061: LD_INT 1
39063: ARRAY
39064: PPUSH
39065: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39069: LD_VAR 0 3
39073: PPUSH
39074: CALL_OW 461
39078: PUSH
39079: LD_INT 6
39081: EQUAL
39082: PUSH
39083: LD_VAR 0 6
39087: PUSH
39088: LD_INT 1
39090: GREATER
39091: AND
39092: IFFALSE 39244
// begin sci := [ ] ;
39094: LD_ADDR_VAR 0 8
39098: PUSH
39099: EMPTY
39100: ST_TO_ADDR
// for x in ( tmp diff j ) do
39101: LD_ADDR_VAR 0 7
39105: PUSH
39106: LD_VAR 0 6
39110: PUSH
39111: LD_VAR 0 3
39115: DIFF
39116: PUSH
39117: FOR_IN
39118: IFFALSE 39170
// begin if sci = 6 then
39120: LD_VAR 0 8
39124: PUSH
39125: LD_INT 6
39127: EQUAL
39128: IFFALSE 39132
// break ;
39130: GO 39170
// if BuildingStatus ( x ) = bs_idle then
39132: LD_VAR 0 7
39136: PPUSH
39137: CALL_OW 461
39141: PUSH
39142: LD_INT 2
39144: EQUAL
39145: IFFALSE 39168
// sci := sci ^ UnitsInside ( x ) ;
39147: LD_ADDR_VAR 0 8
39151: PUSH
39152: LD_VAR 0 8
39156: PUSH
39157: LD_VAR 0 7
39161: PPUSH
39162: CALL_OW 313
39166: ADD
39167: ST_TO_ADDR
// end ;
39168: GO 39117
39170: POP
39171: POP
// if not sci then
39172: LD_VAR 0 8
39176: NOT
39177: IFFALSE 39181
// continue ;
39179: GO 38226
// for x in sci do
39181: LD_ADDR_VAR 0 7
39185: PUSH
39186: LD_VAR 0 8
39190: PUSH
39191: FOR_IN
39192: IFFALSE 39242
// if IsInUnit ( x ) and not HasTask ( x ) then
39194: LD_VAR 0 7
39198: PPUSH
39199: CALL_OW 310
39203: PUSH
39204: LD_VAR 0 7
39208: PPUSH
39209: CALL_OW 314
39213: NOT
39214: AND
39215: IFFALSE 39240
// begin ComExitBuilding ( x ) ;
39217: LD_VAR 0 7
39221: PPUSH
39222: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39226: LD_VAR 0 7
39230: PPUSH
39231: LD_VAR 0 3
39235: PPUSH
39236: CALL_OW 180
// end ;
39240: GO 39191
39242: POP
39243: POP
// end ; end ;
39244: GO 38226
39246: POP
39247: POP
// end ;
39248: GO 38180
39250: POP
39251: POP
// end ;
39252: LD_VAR 0 1
39256: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39257: LD_INT 0
39259: PPUSH
39260: PPUSH
// if not mc_bases then
39261: LD_EXP 95
39265: NOT
39266: IFFALSE 39270
// exit ;
39268: GO 39351
// for i = 1 to mc_bases do
39270: LD_ADDR_VAR 0 2
39274: PUSH
39275: DOUBLE
39276: LD_INT 1
39278: DEC
39279: ST_TO_ADDR
39280: LD_EXP 95
39284: PUSH
39285: FOR_TO
39286: IFFALSE 39349
// if mc_mines [ i ] and mc_miners [ i ] then
39288: LD_EXP 108
39292: PUSH
39293: LD_VAR 0 2
39297: ARRAY
39298: PUSH
39299: LD_EXP 109
39303: PUSH
39304: LD_VAR 0 2
39308: ARRAY
39309: AND
39310: IFFALSE 39347
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39312: LD_EXP 109
39316: PUSH
39317: LD_VAR 0 2
39321: ARRAY
39322: PUSH
39323: LD_INT 1
39325: ARRAY
39326: PPUSH
39327: CALL_OW 255
39331: PPUSH
39332: LD_EXP 108
39336: PUSH
39337: LD_VAR 0 2
39341: ARRAY
39342: PPUSH
39343: CALL 53965 0 2
39347: GO 39285
39349: POP
39350: POP
// end ;
39351: LD_VAR 0 1
39355: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39356: LD_INT 0
39358: PPUSH
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
39363: PPUSH
39364: PPUSH
39365: PPUSH
// if not mc_bases or not mc_parking then
39366: LD_EXP 95
39370: NOT
39371: PUSH
39372: LD_EXP 119
39376: NOT
39377: OR
39378: IFFALSE 39382
// exit ;
39380: GO 40092
// for i = 1 to mc_bases do
39382: LD_ADDR_VAR 0 2
39386: PUSH
39387: DOUBLE
39388: LD_INT 1
39390: DEC
39391: ST_TO_ADDR
39392: LD_EXP 95
39396: PUSH
39397: FOR_TO
39398: IFFALSE 40090
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39400: LD_EXP 95
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: NOT
39411: PUSH
39412: LD_EXP 119
39416: PUSH
39417: LD_VAR 0 2
39421: ARRAY
39422: NOT
39423: OR
39424: IFFALSE 39428
// continue ;
39426: GO 39397
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39428: LD_ADDR_VAR 0 5
39432: PUSH
39433: LD_EXP 95
39437: PUSH
39438: LD_VAR 0 2
39442: ARRAY
39443: PUSH
39444: LD_INT 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 255
39452: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39453: LD_ADDR_VAR 0 6
39457: PUSH
39458: LD_EXP 95
39462: PUSH
39463: LD_VAR 0 2
39467: ARRAY
39468: PPUSH
39469: LD_INT 30
39471: PUSH
39472: LD_INT 3
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PPUSH
39479: CALL_OW 72
39483: ST_TO_ADDR
// if not fac then
39484: LD_VAR 0 6
39488: NOT
39489: IFFALSE 39540
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39491: LD_ADDR_VAR 0 6
39495: PUSH
39496: LD_EXP 95
39500: PUSH
39501: LD_VAR 0 2
39505: ARRAY
39506: PPUSH
39507: LD_INT 2
39509: PUSH
39510: LD_INT 30
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 30
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: LIST
39534: PPUSH
39535: CALL_OW 72
39539: ST_TO_ADDR
// if not fac then
39540: LD_VAR 0 6
39544: NOT
39545: IFFALSE 39549
// continue ;
39547: GO 39397
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39549: LD_ADDR_VAR 0 7
39553: PUSH
39554: LD_EXP 119
39558: PUSH
39559: LD_VAR 0 2
39563: ARRAY
39564: PPUSH
39565: LD_INT 22
39567: PUSH
39568: LD_VAR 0 5
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 21
39579: PUSH
39580: LD_INT 2
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 24
39592: PUSH
39593: LD_INT 1000
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: PPUSH
39609: CALL_OW 70
39613: ST_TO_ADDR
// for j in fac do
39614: LD_ADDR_VAR 0 3
39618: PUSH
39619: LD_VAR 0 6
39623: PUSH
39624: FOR_IN
39625: IFFALSE 39706
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39627: LD_ADDR_VAR 0 7
39631: PUSH
39632: LD_VAR 0 7
39636: PUSH
39637: LD_INT 22
39639: PUSH
39640: LD_VAR 0 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 91
39651: PUSH
39652: LD_VAR 0 3
39656: PUSH
39657: LD_INT 15
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 21
39667: PUSH
39668: LD_INT 2
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: LD_INT 24
39680: PUSH
39681: LD_INT 1000
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: PPUSH
39698: CALL_OW 69
39702: UNION
39703: ST_TO_ADDR
39704: GO 39624
39706: POP
39707: POP
// if not vehs then
39708: LD_VAR 0 7
39712: NOT
39713: IFFALSE 39739
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39715: LD_ADDR_EXP 107
39719: PUSH
39720: LD_EXP 107
39724: PPUSH
39725: LD_VAR 0 2
39729: PPUSH
39730: EMPTY
39731: PPUSH
39732: CALL_OW 1
39736: ST_TO_ADDR
// continue ;
39737: GO 39397
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39739: LD_ADDR_VAR 0 8
39743: PUSH
39744: LD_EXP 95
39748: PUSH
39749: LD_VAR 0 2
39753: ARRAY
39754: PPUSH
39755: LD_INT 30
39757: PUSH
39758: LD_INT 3
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PPUSH
39765: CALL_OW 72
39769: ST_TO_ADDR
// if tmp then
39770: LD_VAR 0 8
39774: IFFALSE 39877
// begin for j in tmp do
39776: LD_ADDR_VAR 0 3
39780: PUSH
39781: LD_VAR 0 8
39785: PUSH
39786: FOR_IN
39787: IFFALSE 39875
// for k in UnitsInside ( j ) do
39789: LD_ADDR_VAR 0 4
39793: PUSH
39794: LD_VAR 0 3
39798: PPUSH
39799: CALL_OW 313
39803: PUSH
39804: FOR_IN
39805: IFFALSE 39871
// if k then
39807: LD_VAR 0 4
39811: IFFALSE 39869
// if not k in mc_repair_vehicle [ i ] then
39813: LD_VAR 0 4
39817: PUSH
39818: LD_EXP 107
39822: PUSH
39823: LD_VAR 0 2
39827: ARRAY
39828: IN
39829: NOT
39830: IFFALSE 39869
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39832: LD_ADDR_EXP 107
39836: PUSH
39837: LD_EXP 107
39841: PPUSH
39842: LD_VAR 0 2
39846: PPUSH
39847: LD_EXP 107
39851: PUSH
39852: LD_VAR 0 2
39856: ARRAY
39857: PUSH
39858: LD_VAR 0 4
39862: UNION
39863: PPUSH
39864: CALL_OW 1
39868: ST_TO_ADDR
39869: GO 39804
39871: POP
39872: POP
39873: GO 39786
39875: POP
39876: POP
// end ; if not mc_repair_vehicle [ i ] then
39877: LD_EXP 107
39881: PUSH
39882: LD_VAR 0 2
39886: ARRAY
39887: NOT
39888: IFFALSE 39892
// continue ;
39890: GO 39397
// for j in mc_repair_vehicle [ i ] do
39892: LD_ADDR_VAR 0 3
39896: PUSH
39897: LD_EXP 107
39901: PUSH
39902: LD_VAR 0 2
39906: ARRAY
39907: PUSH
39908: FOR_IN
39909: IFFALSE 40086
// begin if GetClass ( j ) <> 3 then
39911: LD_VAR 0 3
39915: PPUSH
39916: CALL_OW 257
39920: PUSH
39921: LD_INT 3
39923: NONEQUAL
39924: IFFALSE 39965
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39926: LD_ADDR_EXP 107
39930: PUSH
39931: LD_EXP 107
39935: PPUSH
39936: LD_VAR 0 2
39940: PPUSH
39941: LD_EXP 107
39945: PUSH
39946: LD_VAR 0 2
39950: ARRAY
39951: PUSH
39952: LD_VAR 0 3
39956: DIFF
39957: PPUSH
39958: CALL_OW 1
39962: ST_TO_ADDR
// continue ;
39963: GO 39908
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39965: LD_VAR 0 3
39969: PPUSH
39970: CALL_OW 311
39974: NOT
39975: PUSH
39976: LD_VAR 0 3
39980: PUSH
39981: LD_EXP 98
39985: PUSH
39986: LD_VAR 0 2
39990: ARRAY
39991: PUSH
39992: LD_INT 1
39994: ARRAY
39995: IN
39996: NOT
39997: AND
39998: PUSH
39999: LD_VAR 0 3
40003: PUSH
40004: LD_EXP 98
40008: PUSH
40009: LD_VAR 0 2
40013: ARRAY
40014: PUSH
40015: LD_INT 2
40017: ARRAY
40018: IN
40019: NOT
40020: AND
40021: IFFALSE 40084
// begin if IsInUnit ( j ) then
40023: LD_VAR 0 3
40027: PPUSH
40028: CALL_OW 310
40032: IFFALSE 40045
// ComExitBuilding ( j ) else
40034: LD_VAR 0 3
40038: PPUSH
40039: CALL_OW 122
40043: GO 40084
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40045: LD_VAR 0 3
40049: PPUSH
40050: LD_VAR 0 7
40054: PUSH
40055: LD_INT 1
40057: ARRAY
40058: PPUSH
40059: CALL 90776 0 2
40063: NOT
40064: IFFALSE 40084
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40066: LD_VAR 0 3
40070: PPUSH
40071: LD_VAR 0 7
40075: PUSH
40076: LD_INT 1
40078: ARRAY
40079: PPUSH
40080: CALL_OW 129
// end ; end ;
40084: GO 39908
40086: POP
40087: POP
// end ;
40088: GO 39397
40090: POP
40091: POP
// end ;
40092: LD_VAR 0 1
40096: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40097: LD_INT 0
40099: PPUSH
40100: PPUSH
40101: PPUSH
40102: PPUSH
40103: PPUSH
40104: PPUSH
40105: PPUSH
40106: PPUSH
40107: PPUSH
40108: PPUSH
40109: PPUSH
// if not mc_bases then
40110: LD_EXP 95
40114: NOT
40115: IFFALSE 40119
// exit ;
40117: GO 40921
// for i = 1 to mc_bases do
40119: LD_ADDR_VAR 0 2
40123: PUSH
40124: DOUBLE
40125: LD_INT 1
40127: DEC
40128: ST_TO_ADDR
40129: LD_EXP 95
40133: PUSH
40134: FOR_TO
40135: IFFALSE 40919
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40137: LD_EXP 123
40141: PUSH
40142: LD_VAR 0 2
40146: ARRAY
40147: NOT
40148: PUSH
40149: LD_EXP 98
40153: PUSH
40154: LD_VAR 0 2
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: OR
40164: PUSH
40165: LD_EXP 98
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: PUSH
40176: LD_INT 2
40178: ARRAY
40179: OR
40180: PUSH
40181: LD_EXP 121
40185: PUSH
40186: LD_VAR 0 2
40190: ARRAY
40191: PPUSH
40192: LD_INT 1
40194: PPUSH
40195: CALL_OW 325
40199: NOT
40200: OR
40201: PUSH
40202: LD_EXP 118
40206: PUSH
40207: LD_VAR 0 2
40211: ARRAY
40212: OR
40213: IFFALSE 40217
// continue ;
40215: GO 40134
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40217: LD_ADDR_VAR 0 8
40221: PUSH
40222: LD_EXP 95
40226: PUSH
40227: LD_VAR 0 2
40231: ARRAY
40232: PPUSH
40233: LD_INT 25
40235: PUSH
40236: LD_INT 4
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 50
40245: PUSH
40246: EMPTY
40247: LIST
40248: PUSH
40249: LD_INT 3
40251: PUSH
40252: LD_INT 60
40254: PUSH
40255: EMPTY
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: LIST
40266: PPUSH
40267: CALL_OW 72
40271: PUSH
40272: LD_EXP 99
40276: PUSH
40277: LD_VAR 0 2
40281: ARRAY
40282: DIFF
40283: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40284: LD_ADDR_VAR 0 9
40288: PUSH
40289: LD_EXP 95
40293: PUSH
40294: LD_VAR 0 2
40298: ARRAY
40299: PPUSH
40300: LD_INT 2
40302: PUSH
40303: LD_INT 30
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 30
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: LIST
40327: PPUSH
40328: CALL_OW 72
40332: ST_TO_ADDR
// if not tmp or not dep then
40333: LD_VAR 0 8
40337: NOT
40338: PUSH
40339: LD_VAR 0 9
40343: NOT
40344: OR
40345: IFFALSE 40349
// continue ;
40347: GO 40134
// side := GetSide ( tmp [ 1 ] ) ;
40349: LD_ADDR_VAR 0 11
40353: PUSH
40354: LD_VAR 0 8
40358: PUSH
40359: LD_INT 1
40361: ARRAY
40362: PPUSH
40363: CALL_OW 255
40367: ST_TO_ADDR
// dep := dep [ 1 ] ;
40368: LD_ADDR_VAR 0 9
40372: PUSH
40373: LD_VAR 0 9
40377: PUSH
40378: LD_INT 1
40380: ARRAY
40381: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40382: LD_ADDR_VAR 0 7
40386: PUSH
40387: LD_EXP 123
40391: PUSH
40392: LD_VAR 0 2
40396: ARRAY
40397: PPUSH
40398: LD_INT 22
40400: PUSH
40401: LD_INT 0
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 25
40410: PUSH
40411: LD_INT 12
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PPUSH
40422: CALL_OW 70
40426: PUSH
40427: LD_INT 22
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 25
40439: PUSH
40440: LD_INT 12
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 91
40449: PUSH
40450: LD_VAR 0 9
40454: PUSH
40455: LD_INT 20
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: LIST
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: LIST
40467: PPUSH
40468: CALL_OW 69
40472: UNION
40473: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40474: LD_ADDR_VAR 0 10
40478: PUSH
40479: LD_EXP 123
40483: PUSH
40484: LD_VAR 0 2
40488: ARRAY
40489: PPUSH
40490: LD_INT 81
40492: PUSH
40493: LD_VAR 0 11
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PPUSH
40502: CALL_OW 70
40506: ST_TO_ADDR
// if not apes or danger_at_area then
40507: LD_VAR 0 7
40511: NOT
40512: PUSH
40513: LD_VAR 0 10
40517: OR
40518: IFFALSE 40568
// begin if mc_taming [ i ] then
40520: LD_EXP 126
40524: PUSH
40525: LD_VAR 0 2
40529: ARRAY
40530: IFFALSE 40566
// begin MC_Reset ( i , 121 ) ;
40532: LD_VAR 0 2
40536: PPUSH
40537: LD_INT 121
40539: PPUSH
40540: CALL 25554 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40544: LD_ADDR_EXP 126
40548: PUSH
40549: LD_EXP 126
40553: PPUSH
40554: LD_VAR 0 2
40558: PPUSH
40559: EMPTY
40560: PPUSH
40561: CALL_OW 1
40565: ST_TO_ADDR
// end ; continue ;
40566: GO 40134
// end ; for j in tmp do
40568: LD_ADDR_VAR 0 3
40572: PUSH
40573: LD_VAR 0 8
40577: PUSH
40578: FOR_IN
40579: IFFALSE 40915
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40581: LD_VAR 0 3
40585: PUSH
40586: LD_EXP 126
40590: PUSH
40591: LD_VAR 0 2
40595: ARRAY
40596: IN
40597: NOT
40598: PUSH
40599: LD_EXP 126
40603: PUSH
40604: LD_VAR 0 2
40608: ARRAY
40609: PUSH
40610: LD_INT 3
40612: LESS
40613: AND
40614: IFFALSE 40672
// begin SetTag ( j , 121 ) ;
40616: LD_VAR 0 3
40620: PPUSH
40621: LD_INT 121
40623: PPUSH
40624: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40628: LD_ADDR_EXP 126
40632: PUSH
40633: LD_EXP 126
40637: PPUSH
40638: LD_VAR 0 2
40642: PUSH
40643: LD_EXP 126
40647: PUSH
40648: LD_VAR 0 2
40652: ARRAY
40653: PUSH
40654: LD_INT 1
40656: PLUS
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PPUSH
40662: LD_VAR 0 3
40666: PPUSH
40667: CALL 57012 0 3
40671: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40672: LD_VAR 0 3
40676: PUSH
40677: LD_EXP 126
40681: PUSH
40682: LD_VAR 0 2
40686: ARRAY
40687: IN
40688: IFFALSE 40913
// begin if GetClass ( j ) <> 4 then
40690: LD_VAR 0 3
40694: PPUSH
40695: CALL_OW 257
40699: PUSH
40700: LD_INT 4
40702: NONEQUAL
40703: IFFALSE 40756
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40705: LD_ADDR_EXP 126
40709: PUSH
40710: LD_EXP 126
40714: PPUSH
40715: LD_VAR 0 2
40719: PPUSH
40720: LD_EXP 126
40724: PUSH
40725: LD_VAR 0 2
40729: ARRAY
40730: PUSH
40731: LD_VAR 0 3
40735: DIFF
40736: PPUSH
40737: CALL_OW 1
40741: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40742: LD_VAR 0 3
40746: PPUSH
40747: LD_INT 0
40749: PPUSH
40750: CALL_OW 109
// continue ;
40754: GO 40578
// end ; if IsInUnit ( j ) then
40756: LD_VAR 0 3
40760: PPUSH
40761: CALL_OW 310
40765: IFFALSE 40776
// ComExitBuilding ( j ) ;
40767: LD_VAR 0 3
40771: PPUSH
40772: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40776: LD_ADDR_VAR 0 6
40780: PUSH
40781: LD_VAR 0 7
40785: PPUSH
40786: LD_VAR 0 3
40790: PPUSH
40791: CALL_OW 74
40795: ST_TO_ADDR
// if not ape then
40796: LD_VAR 0 6
40800: NOT
40801: IFFALSE 40805
// break ;
40803: GO 40915
// x := GetX ( ape ) ;
40805: LD_ADDR_VAR 0 4
40809: PUSH
40810: LD_VAR 0 6
40814: PPUSH
40815: CALL_OW 250
40819: ST_TO_ADDR
// y := GetY ( ape ) ;
40820: LD_ADDR_VAR 0 5
40824: PUSH
40825: LD_VAR 0 6
40829: PPUSH
40830: CALL_OW 251
40834: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40835: LD_VAR 0 4
40839: PPUSH
40840: LD_VAR 0 5
40844: PPUSH
40845: CALL_OW 488
40849: NOT
40850: PUSH
40851: LD_VAR 0 11
40855: PPUSH
40856: LD_VAR 0 4
40860: PPUSH
40861: LD_VAR 0 5
40865: PPUSH
40866: LD_INT 20
40868: PPUSH
40869: CALL 57908 0 4
40873: PUSH
40874: LD_INT 4
40876: ARRAY
40877: OR
40878: IFFALSE 40882
// break ;
40880: GO 40915
// if not HasTask ( j ) then
40882: LD_VAR 0 3
40886: PPUSH
40887: CALL_OW 314
40891: NOT
40892: IFFALSE 40913
// ComTameXY ( j , x , y ) ;
40894: LD_VAR 0 3
40898: PPUSH
40899: LD_VAR 0 4
40903: PPUSH
40904: LD_VAR 0 5
40908: PPUSH
40909: CALL_OW 131
// end ; end ;
40913: GO 40578
40915: POP
40916: POP
// end ;
40917: GO 40134
40919: POP
40920: POP
// end ;
40921: LD_VAR 0 1
40925: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40926: LD_INT 0
40928: PPUSH
40929: PPUSH
40930: PPUSH
40931: PPUSH
40932: PPUSH
40933: PPUSH
40934: PPUSH
40935: PPUSH
// if not mc_bases then
40936: LD_EXP 95
40940: NOT
40941: IFFALSE 40945
// exit ;
40943: GO 41571
// for i = 1 to mc_bases do
40945: LD_ADDR_VAR 0 2
40949: PUSH
40950: DOUBLE
40951: LD_INT 1
40953: DEC
40954: ST_TO_ADDR
40955: LD_EXP 95
40959: PUSH
40960: FOR_TO
40961: IFFALSE 41569
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40963: LD_EXP 124
40967: PUSH
40968: LD_VAR 0 2
40972: ARRAY
40973: NOT
40974: PUSH
40975: LD_EXP 124
40979: PUSH
40980: LD_VAR 0 2
40984: ARRAY
40985: PPUSH
40986: LD_INT 25
40988: PUSH
40989: LD_INT 12
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PPUSH
40996: CALL_OW 72
41000: NOT
41001: OR
41002: IFFALSE 41006
// continue ;
41004: GO 40960
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41006: LD_ADDR_VAR 0 5
41010: PUSH
41011: LD_EXP 124
41015: PUSH
41016: LD_VAR 0 2
41020: ARRAY
41021: PUSH
41022: LD_INT 1
41024: ARRAY
41025: PPUSH
41026: CALL_OW 255
41030: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41031: LD_VAR 0 5
41035: PPUSH
41036: LD_INT 2
41038: PPUSH
41039: CALL_OW 325
41043: IFFALSE 41296
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41045: LD_ADDR_VAR 0 4
41049: PUSH
41050: LD_EXP 124
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PPUSH
41061: LD_INT 25
41063: PUSH
41064: LD_INT 16
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PPUSH
41071: CALL_OW 72
41075: ST_TO_ADDR
// if tmp < 6 then
41076: LD_VAR 0 4
41080: PUSH
41081: LD_INT 6
41083: LESS
41084: IFFALSE 41296
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41086: LD_ADDR_VAR 0 6
41090: PUSH
41091: LD_EXP 95
41095: PUSH
41096: LD_VAR 0 2
41100: ARRAY
41101: PPUSH
41102: LD_INT 2
41104: PUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 30
41117: PUSH
41118: LD_INT 1
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: LIST
41129: PPUSH
41130: CALL_OW 72
41134: ST_TO_ADDR
// if depot then
41135: LD_VAR 0 6
41139: IFFALSE 41296
// begin selected := 0 ;
41141: LD_ADDR_VAR 0 7
41145: PUSH
41146: LD_INT 0
41148: ST_TO_ADDR
// for j in depot do
41149: LD_ADDR_VAR 0 3
41153: PUSH
41154: LD_VAR 0 6
41158: PUSH
41159: FOR_IN
41160: IFFALSE 41191
// begin if UnitsInside ( j ) < 6 then
41162: LD_VAR 0 3
41166: PPUSH
41167: CALL_OW 313
41171: PUSH
41172: LD_INT 6
41174: LESS
41175: IFFALSE 41189
// begin selected := j ;
41177: LD_ADDR_VAR 0 7
41181: PUSH
41182: LD_VAR 0 3
41186: ST_TO_ADDR
// break ;
41187: GO 41191
// end ; end ;
41189: GO 41159
41191: POP
41192: POP
// if selected then
41193: LD_VAR 0 7
41197: IFFALSE 41296
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41199: LD_ADDR_VAR 0 3
41203: PUSH
41204: LD_EXP 124
41208: PUSH
41209: LD_VAR 0 2
41213: ARRAY
41214: PPUSH
41215: LD_INT 25
41217: PUSH
41218: LD_INT 12
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PPUSH
41225: CALL_OW 72
41229: PUSH
41230: FOR_IN
41231: IFFALSE 41294
// if not HasTask ( j ) then
41233: LD_VAR 0 3
41237: PPUSH
41238: CALL_OW 314
41242: NOT
41243: IFFALSE 41292
// begin if not IsInUnit ( j ) then
41245: LD_VAR 0 3
41249: PPUSH
41250: CALL_OW 310
41254: NOT
41255: IFFALSE 41271
// ComEnterUnit ( j , selected ) ;
41257: LD_VAR 0 3
41261: PPUSH
41262: LD_VAR 0 7
41266: PPUSH
41267: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41271: LD_VAR 0 3
41275: PPUSH
41276: LD_INT 16
41278: PPUSH
41279: CALL_OW 183
// AddComExitBuilding ( j ) ;
41283: LD_VAR 0 3
41287: PPUSH
41288: CALL_OW 182
// end ;
41292: GO 41230
41294: POP
41295: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41296: LD_VAR 0 5
41300: PPUSH
41301: LD_INT 11
41303: PPUSH
41304: CALL_OW 325
41308: IFFALSE 41567
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41310: LD_ADDR_VAR 0 4
41314: PUSH
41315: LD_EXP 124
41319: PUSH
41320: LD_VAR 0 2
41324: ARRAY
41325: PPUSH
41326: LD_INT 25
41328: PUSH
41329: LD_INT 16
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PPUSH
41336: CALL_OW 72
41340: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41341: LD_VAR 0 4
41345: PUSH
41346: LD_INT 6
41348: GREATEREQUAL
41349: PUSH
41350: LD_VAR 0 5
41354: PPUSH
41355: LD_INT 2
41357: PPUSH
41358: CALL_OW 325
41362: NOT
41363: OR
41364: IFFALSE 41567
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41366: LD_ADDR_VAR 0 8
41370: PUSH
41371: LD_EXP 95
41375: PUSH
41376: LD_VAR 0 2
41380: ARRAY
41381: PPUSH
41382: LD_INT 2
41384: PUSH
41385: LD_INT 30
41387: PUSH
41388: LD_INT 4
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 30
41397: PUSH
41398: LD_INT 5
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: LIST
41409: PPUSH
41410: CALL_OW 72
41414: ST_TO_ADDR
// if barracks then
41415: LD_VAR 0 8
41419: IFFALSE 41567
// begin selected := 0 ;
41421: LD_ADDR_VAR 0 7
41425: PUSH
41426: LD_INT 0
41428: ST_TO_ADDR
// for j in barracks do
41429: LD_ADDR_VAR 0 3
41433: PUSH
41434: LD_VAR 0 8
41438: PUSH
41439: FOR_IN
41440: IFFALSE 41471
// begin if UnitsInside ( j ) < 6 then
41442: LD_VAR 0 3
41446: PPUSH
41447: CALL_OW 313
41451: PUSH
41452: LD_INT 6
41454: LESS
41455: IFFALSE 41469
// begin selected := j ;
41457: LD_ADDR_VAR 0 7
41461: PUSH
41462: LD_VAR 0 3
41466: ST_TO_ADDR
// break ;
41467: GO 41471
// end ; end ;
41469: GO 41439
41471: POP
41472: POP
// if selected then
41473: LD_VAR 0 7
41477: IFFALSE 41567
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41479: LD_ADDR_VAR 0 3
41483: PUSH
41484: LD_EXP 124
41488: PUSH
41489: LD_VAR 0 2
41493: ARRAY
41494: PPUSH
41495: LD_INT 25
41497: PUSH
41498: LD_INT 12
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PPUSH
41505: CALL_OW 72
41509: PUSH
41510: FOR_IN
41511: IFFALSE 41565
// if not IsInUnit ( j ) and not HasTask ( j ) then
41513: LD_VAR 0 3
41517: PPUSH
41518: CALL_OW 310
41522: NOT
41523: PUSH
41524: LD_VAR 0 3
41528: PPUSH
41529: CALL_OW 314
41533: NOT
41534: AND
41535: IFFALSE 41563
// begin ComEnterUnit ( j , selected ) ;
41537: LD_VAR 0 3
41541: PPUSH
41542: LD_VAR 0 7
41546: PPUSH
41547: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41551: LD_VAR 0 3
41555: PPUSH
41556: LD_INT 15
41558: PPUSH
41559: CALL_OW 183
// end ;
41563: GO 41510
41565: POP
41566: POP
// end ; end ; end ; end ; end ;
41567: GO 40960
41569: POP
41570: POP
// end ;
41571: LD_VAR 0 1
41575: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41576: LD_INT 0
41578: PPUSH
41579: PPUSH
41580: PPUSH
41581: PPUSH
// if not mc_bases then
41582: LD_EXP 95
41586: NOT
41587: IFFALSE 41591
// exit ;
41589: GO 41769
// for i = 1 to mc_bases do
41591: LD_ADDR_VAR 0 2
41595: PUSH
41596: DOUBLE
41597: LD_INT 1
41599: DEC
41600: ST_TO_ADDR
41601: LD_EXP 95
41605: PUSH
41606: FOR_TO
41607: IFFALSE 41767
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41609: LD_ADDR_VAR 0 4
41613: PUSH
41614: LD_EXP 95
41618: PUSH
41619: LD_VAR 0 2
41623: ARRAY
41624: PPUSH
41625: LD_INT 25
41627: PUSH
41628: LD_INT 9
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PPUSH
41635: CALL_OW 72
41639: ST_TO_ADDR
// if not tmp then
41640: LD_VAR 0 4
41644: NOT
41645: IFFALSE 41649
// continue ;
41647: GO 41606
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41649: LD_EXP 121
41653: PUSH
41654: LD_VAR 0 2
41658: ARRAY
41659: PPUSH
41660: LD_INT 29
41662: PPUSH
41663: CALL_OW 325
41667: NOT
41668: PUSH
41669: LD_EXP 121
41673: PUSH
41674: LD_VAR 0 2
41678: ARRAY
41679: PPUSH
41680: LD_INT 28
41682: PPUSH
41683: CALL_OW 325
41687: NOT
41688: AND
41689: IFFALSE 41693
// continue ;
41691: GO 41606
// for j in tmp do
41693: LD_ADDR_VAR 0 3
41697: PUSH
41698: LD_VAR 0 4
41702: PUSH
41703: FOR_IN
41704: IFFALSE 41763
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41706: LD_VAR 0 3
41710: PUSH
41711: LD_EXP 98
41715: PUSH
41716: LD_VAR 0 2
41720: ARRAY
41721: PUSH
41722: LD_INT 1
41724: ARRAY
41725: IN
41726: NOT
41727: PUSH
41728: LD_VAR 0 3
41732: PUSH
41733: LD_EXP 98
41737: PUSH
41738: LD_VAR 0 2
41742: ARRAY
41743: PUSH
41744: LD_INT 2
41746: ARRAY
41747: IN
41748: NOT
41749: AND
41750: IFFALSE 41761
// ComSpaceTimeShoot ( j ) ;
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL 52973 0 1
41761: GO 41703
41763: POP
41764: POP
// end ;
41765: GO 41606
41767: POP
41768: POP
// end ;
41769: LD_VAR 0 1
41773: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41774: LD_INT 0
41776: PPUSH
41777: PPUSH
41778: PPUSH
41779: PPUSH
41780: PPUSH
41781: PPUSH
41782: PPUSH
41783: PPUSH
41784: PPUSH
// if not mc_bases then
41785: LD_EXP 95
41789: NOT
41790: IFFALSE 41794
// exit ;
41792: GO 42416
// for i = 1 to mc_bases do
41794: LD_ADDR_VAR 0 2
41798: PUSH
41799: DOUBLE
41800: LD_INT 1
41802: DEC
41803: ST_TO_ADDR
41804: LD_EXP 95
41808: PUSH
41809: FOR_TO
41810: IFFALSE 42414
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41812: LD_EXP 130
41816: PUSH
41817: LD_VAR 0 2
41821: ARRAY
41822: NOT
41823: PUSH
41824: LD_INT 38
41826: PPUSH
41827: LD_EXP 121
41831: PUSH
41832: LD_VAR 0 2
41836: ARRAY
41837: PPUSH
41838: CALL_OW 321
41842: PUSH
41843: LD_INT 2
41845: NONEQUAL
41846: OR
41847: IFFALSE 41851
// continue ;
41849: GO 41809
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41851: LD_ADDR_VAR 0 8
41855: PUSH
41856: LD_EXP 95
41860: PUSH
41861: LD_VAR 0 2
41865: ARRAY
41866: PPUSH
41867: LD_INT 30
41869: PUSH
41870: LD_INT 34
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PPUSH
41877: CALL_OW 72
41881: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41882: LD_ADDR_VAR 0 9
41886: PUSH
41887: LD_EXP 95
41891: PUSH
41892: LD_VAR 0 2
41896: ARRAY
41897: PPUSH
41898: LD_INT 25
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PPUSH
41908: CALL_OW 72
41912: PPUSH
41913: LD_INT 0
41915: PPUSH
41916: CALL 86281 0 2
41920: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41921: LD_VAR 0 9
41925: NOT
41926: PUSH
41927: LD_VAR 0 8
41931: NOT
41932: OR
41933: PUSH
41934: LD_EXP 95
41938: PUSH
41939: LD_VAR 0 2
41943: ARRAY
41944: PPUSH
41945: LD_INT 124
41947: PPUSH
41948: CALL 86281 0 2
41952: OR
41953: IFFALSE 41957
// continue ;
41955: GO 41809
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41957: LD_EXP 131
41961: PUSH
41962: LD_VAR 0 2
41966: ARRAY
41967: PUSH
41968: LD_EXP 130
41972: PUSH
41973: LD_VAR 0 2
41977: ARRAY
41978: LESS
41979: PUSH
41980: LD_EXP 131
41984: PUSH
41985: LD_VAR 0 2
41989: ARRAY
41990: PUSH
41991: LD_VAR 0 8
41995: LESS
41996: AND
41997: IFFALSE 42412
// begin tmp := sci [ 1 ] ;
41999: LD_ADDR_VAR 0 7
42003: PUSH
42004: LD_VAR 0 9
42008: PUSH
42009: LD_INT 1
42011: ARRAY
42012: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42013: LD_VAR 0 7
42017: PPUSH
42018: LD_INT 124
42020: PPUSH
42021: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42025: LD_ADDR_VAR 0 3
42029: PUSH
42030: DOUBLE
42031: LD_EXP 130
42035: PUSH
42036: LD_VAR 0 2
42040: ARRAY
42041: INC
42042: ST_TO_ADDR
42043: LD_EXP 130
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: PUSH
42054: FOR_DOWNTO
42055: IFFALSE 42398
// begin if IsInUnit ( tmp ) then
42057: LD_VAR 0 7
42061: PPUSH
42062: CALL_OW 310
42066: IFFALSE 42077
// ComExitBuilding ( tmp ) ;
42068: LD_VAR 0 7
42072: PPUSH
42073: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42077: LD_INT 35
42079: PPUSH
42080: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42084: LD_VAR 0 7
42088: PPUSH
42089: CALL_OW 310
42093: NOT
42094: PUSH
42095: LD_VAR 0 7
42099: PPUSH
42100: CALL_OW 314
42104: NOT
42105: AND
42106: IFFALSE 42077
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42108: LD_ADDR_VAR 0 6
42112: PUSH
42113: LD_VAR 0 7
42117: PPUSH
42118: CALL_OW 250
42122: PUSH
42123: LD_VAR 0 7
42127: PPUSH
42128: CALL_OW 251
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42137: LD_INT 35
42139: PPUSH
42140: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42144: LD_ADDR_VAR 0 4
42148: PUSH
42149: LD_EXP 130
42153: PUSH
42154: LD_VAR 0 2
42158: ARRAY
42159: PUSH
42160: LD_VAR 0 3
42164: ARRAY
42165: PUSH
42166: LD_INT 1
42168: ARRAY
42169: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42170: LD_ADDR_VAR 0 5
42174: PUSH
42175: LD_EXP 130
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_VAR 0 3
42190: ARRAY
42191: PUSH
42192: LD_INT 2
42194: ARRAY
42195: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42196: LD_VAR 0 7
42200: PPUSH
42201: LD_INT 10
42203: PPUSH
42204: CALL 59611 0 2
42208: PUSH
42209: LD_INT 4
42211: ARRAY
42212: IFFALSE 42250
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42214: LD_VAR 0 7
42218: PPUSH
42219: LD_VAR 0 6
42223: PUSH
42224: LD_INT 1
42226: ARRAY
42227: PPUSH
42228: LD_VAR 0 6
42232: PUSH
42233: LD_INT 2
42235: ARRAY
42236: PPUSH
42237: CALL_OW 111
// wait ( 0 0$10 ) ;
42241: LD_INT 350
42243: PPUSH
42244: CALL_OW 67
// end else
42248: GO 42276
// begin ComMoveXY ( tmp , x , y ) ;
42250: LD_VAR 0 7
42254: PPUSH
42255: LD_VAR 0 4
42259: PPUSH
42260: LD_VAR 0 5
42264: PPUSH
42265: CALL_OW 111
// wait ( 0 0$3 ) ;
42269: LD_INT 105
42271: PPUSH
42272: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42276: LD_VAR 0 7
42280: PPUSH
42281: LD_VAR 0 4
42285: PPUSH
42286: LD_VAR 0 5
42290: PPUSH
42291: CALL_OW 307
42295: IFFALSE 42137
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42297: LD_VAR 0 7
42301: PPUSH
42302: LD_VAR 0 4
42306: PPUSH
42307: LD_VAR 0 5
42311: PPUSH
42312: LD_VAR 0 8
42316: PUSH
42317: LD_VAR 0 3
42321: ARRAY
42322: PPUSH
42323: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42327: LD_INT 35
42329: PPUSH
42330: CALL_OW 67
// until not HasTask ( tmp ) ;
42334: LD_VAR 0 7
42338: PPUSH
42339: CALL_OW 314
42343: NOT
42344: IFFALSE 42327
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42346: LD_ADDR_EXP 131
42350: PUSH
42351: LD_EXP 131
42355: PPUSH
42356: LD_VAR 0 2
42360: PUSH
42361: LD_EXP 131
42365: PUSH
42366: LD_VAR 0 2
42370: ARRAY
42371: PUSH
42372: LD_INT 1
42374: PLUS
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PPUSH
42380: LD_VAR 0 8
42384: PUSH
42385: LD_VAR 0 3
42389: ARRAY
42390: PPUSH
42391: CALL 57012 0 3
42395: ST_TO_ADDR
// end ;
42396: GO 42054
42398: POP
42399: POP
// MC_Reset ( i , 124 ) ;
42400: LD_VAR 0 2
42404: PPUSH
42405: LD_INT 124
42407: PPUSH
42408: CALL 25554 0 2
// end ; end ;
42412: GO 41809
42414: POP
42415: POP
// end ;
42416: LD_VAR 0 1
42420: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42421: LD_INT 0
42423: PPUSH
42424: PPUSH
42425: PPUSH
// if not mc_bases then
42426: LD_EXP 95
42430: NOT
42431: IFFALSE 42435
// exit ;
42433: GO 43041
// for i = 1 to mc_bases do
42435: LD_ADDR_VAR 0 2
42439: PUSH
42440: DOUBLE
42441: LD_INT 1
42443: DEC
42444: ST_TO_ADDR
42445: LD_EXP 95
42449: PUSH
42450: FOR_TO
42451: IFFALSE 43039
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42453: LD_ADDR_VAR 0 3
42457: PUSH
42458: LD_EXP 95
42462: PUSH
42463: LD_VAR 0 2
42467: ARRAY
42468: PPUSH
42469: LD_INT 25
42471: PUSH
42472: LD_INT 4
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PPUSH
42479: CALL_OW 72
42483: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42484: LD_VAR 0 3
42488: NOT
42489: PUSH
42490: LD_EXP 132
42494: PUSH
42495: LD_VAR 0 2
42499: ARRAY
42500: NOT
42501: OR
42502: PUSH
42503: LD_EXP 95
42507: PUSH
42508: LD_VAR 0 2
42512: ARRAY
42513: PPUSH
42514: LD_INT 2
42516: PUSH
42517: LD_INT 30
42519: PUSH
42520: LD_INT 0
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 30
42529: PUSH
42530: LD_INT 1
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: LIST
42541: PPUSH
42542: CALL_OW 72
42546: NOT
42547: OR
42548: IFFALSE 42598
// begin if mc_deposits_finder [ i ] then
42550: LD_EXP 133
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: IFFALSE 42596
// begin MC_Reset ( i , 125 ) ;
42562: LD_VAR 0 2
42566: PPUSH
42567: LD_INT 125
42569: PPUSH
42570: CALL 25554 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42574: LD_ADDR_EXP 133
42578: PUSH
42579: LD_EXP 133
42583: PPUSH
42584: LD_VAR 0 2
42588: PPUSH
42589: EMPTY
42590: PPUSH
42591: CALL_OW 1
42595: ST_TO_ADDR
// end ; continue ;
42596: GO 42450
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42598: LD_EXP 132
42602: PUSH
42603: LD_VAR 0 2
42607: ARRAY
42608: PUSH
42609: LD_INT 1
42611: ARRAY
42612: PUSH
42613: LD_INT 3
42615: ARRAY
42616: PUSH
42617: LD_INT 1
42619: EQUAL
42620: PUSH
42621: LD_INT 20
42623: PPUSH
42624: LD_EXP 121
42628: PUSH
42629: LD_VAR 0 2
42633: ARRAY
42634: PPUSH
42635: CALL_OW 321
42639: PUSH
42640: LD_INT 2
42642: NONEQUAL
42643: AND
42644: IFFALSE 42694
// begin if mc_deposits_finder [ i ] then
42646: LD_EXP 133
42650: PUSH
42651: LD_VAR 0 2
42655: ARRAY
42656: IFFALSE 42692
// begin MC_Reset ( i , 125 ) ;
42658: LD_VAR 0 2
42662: PPUSH
42663: LD_INT 125
42665: PPUSH
42666: CALL 25554 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42670: LD_ADDR_EXP 133
42674: PUSH
42675: LD_EXP 133
42679: PPUSH
42680: LD_VAR 0 2
42684: PPUSH
42685: EMPTY
42686: PPUSH
42687: CALL_OW 1
42691: ST_TO_ADDR
// end ; continue ;
42692: GO 42450
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42694: LD_EXP 132
42698: PUSH
42699: LD_VAR 0 2
42703: ARRAY
42704: PUSH
42705: LD_INT 1
42707: ARRAY
42708: PUSH
42709: LD_INT 1
42711: ARRAY
42712: PPUSH
42713: LD_EXP 132
42717: PUSH
42718: LD_VAR 0 2
42722: ARRAY
42723: PUSH
42724: LD_INT 1
42726: ARRAY
42727: PUSH
42728: LD_INT 2
42730: ARRAY
42731: PPUSH
42732: LD_EXP 121
42736: PUSH
42737: LD_VAR 0 2
42741: ARRAY
42742: PPUSH
42743: CALL_OW 440
42747: IFFALSE 42790
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42749: LD_ADDR_EXP 132
42753: PUSH
42754: LD_EXP 132
42758: PPUSH
42759: LD_VAR 0 2
42763: PPUSH
42764: LD_EXP 132
42768: PUSH
42769: LD_VAR 0 2
42773: ARRAY
42774: PPUSH
42775: LD_INT 1
42777: PPUSH
42778: CALL_OW 3
42782: PPUSH
42783: CALL_OW 1
42787: ST_TO_ADDR
42788: GO 43037
// begin if not mc_deposits_finder [ i ] then
42790: LD_EXP 133
42794: PUSH
42795: LD_VAR 0 2
42799: ARRAY
42800: NOT
42801: IFFALSE 42853
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42803: LD_ADDR_EXP 133
42807: PUSH
42808: LD_EXP 133
42812: PPUSH
42813: LD_VAR 0 2
42817: PPUSH
42818: LD_VAR 0 3
42822: PUSH
42823: LD_INT 1
42825: ARRAY
42826: PUSH
42827: EMPTY
42828: LIST
42829: PPUSH
42830: CALL_OW 1
42834: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42835: LD_VAR 0 3
42839: PUSH
42840: LD_INT 1
42842: ARRAY
42843: PPUSH
42844: LD_INT 125
42846: PPUSH
42847: CALL_OW 109
// end else
42851: GO 43037
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42853: LD_EXP 133
42857: PUSH
42858: LD_VAR 0 2
42862: ARRAY
42863: PUSH
42864: LD_INT 1
42866: ARRAY
42867: PPUSH
42868: CALL_OW 310
42872: IFFALSE 42895
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42874: LD_EXP 133
42878: PUSH
42879: LD_VAR 0 2
42883: ARRAY
42884: PUSH
42885: LD_INT 1
42887: ARRAY
42888: PPUSH
42889: CALL_OW 122
42893: GO 43037
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42895: LD_EXP 133
42899: PUSH
42900: LD_VAR 0 2
42904: ARRAY
42905: PUSH
42906: LD_INT 1
42908: ARRAY
42909: PPUSH
42910: CALL_OW 314
42914: NOT
42915: PUSH
42916: LD_EXP 133
42920: PUSH
42921: LD_VAR 0 2
42925: ARRAY
42926: PUSH
42927: LD_INT 1
42929: ARRAY
42930: PPUSH
42931: LD_EXP 132
42935: PUSH
42936: LD_VAR 0 2
42940: ARRAY
42941: PUSH
42942: LD_INT 1
42944: ARRAY
42945: PUSH
42946: LD_INT 1
42948: ARRAY
42949: PPUSH
42950: LD_EXP 132
42954: PUSH
42955: LD_VAR 0 2
42959: ARRAY
42960: PUSH
42961: LD_INT 1
42963: ARRAY
42964: PUSH
42965: LD_INT 2
42967: ARRAY
42968: PPUSH
42969: CALL_OW 297
42973: PUSH
42974: LD_INT 6
42976: GREATER
42977: AND
42978: IFFALSE 43037
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42980: LD_EXP 133
42984: PUSH
42985: LD_VAR 0 2
42989: ARRAY
42990: PUSH
42991: LD_INT 1
42993: ARRAY
42994: PPUSH
42995: LD_EXP 132
42999: PUSH
43000: LD_VAR 0 2
43004: ARRAY
43005: PUSH
43006: LD_INT 1
43008: ARRAY
43009: PUSH
43010: LD_INT 1
43012: ARRAY
43013: PPUSH
43014: LD_EXP 132
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PUSH
43025: LD_INT 1
43027: ARRAY
43028: PUSH
43029: LD_INT 2
43031: ARRAY
43032: PPUSH
43033: CALL_OW 111
// end ; end ; end ;
43037: GO 42450
43039: POP
43040: POP
// end ;
43041: LD_VAR 0 1
43045: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43046: LD_INT 0
43048: PPUSH
43049: PPUSH
43050: PPUSH
43051: PPUSH
43052: PPUSH
43053: PPUSH
43054: PPUSH
43055: PPUSH
43056: PPUSH
43057: PPUSH
43058: PPUSH
// if not mc_bases then
43059: LD_EXP 95
43063: NOT
43064: IFFALSE 43068
// exit ;
43066: GO 44008
// for i = 1 to mc_bases do
43068: LD_ADDR_VAR 0 2
43072: PUSH
43073: DOUBLE
43074: LD_INT 1
43076: DEC
43077: ST_TO_ADDR
43078: LD_EXP 95
43082: PUSH
43083: FOR_TO
43084: IFFALSE 44006
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43086: LD_EXP 95
43090: PUSH
43091: LD_VAR 0 2
43095: ARRAY
43096: NOT
43097: PUSH
43098: LD_EXP 118
43102: PUSH
43103: LD_VAR 0 2
43107: ARRAY
43108: OR
43109: IFFALSE 43113
// continue ;
43111: GO 43083
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43113: LD_ADDR_VAR 0 7
43117: PUSH
43118: LD_EXP 95
43122: PUSH
43123: LD_VAR 0 2
43127: ARRAY
43128: PUSH
43129: LD_INT 1
43131: ARRAY
43132: PPUSH
43133: CALL_OW 248
43137: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43138: LD_VAR 0 7
43142: PUSH
43143: LD_INT 3
43145: EQUAL
43146: PUSH
43147: LD_EXP 114
43151: PUSH
43152: LD_VAR 0 2
43156: ARRAY
43157: PUSH
43158: LD_EXP 117
43162: PUSH
43163: LD_VAR 0 2
43167: ARRAY
43168: UNION
43169: PPUSH
43170: LD_INT 33
43172: PUSH
43173: LD_INT 2
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PPUSH
43180: CALL_OW 72
43184: NOT
43185: OR
43186: IFFALSE 43190
// continue ;
43188: GO 43083
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43190: LD_ADDR_VAR 0 9
43194: PUSH
43195: LD_EXP 95
43199: PUSH
43200: LD_VAR 0 2
43204: ARRAY
43205: PPUSH
43206: LD_INT 30
43208: PUSH
43209: LD_INT 36
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PPUSH
43216: CALL_OW 72
43220: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43221: LD_ADDR_VAR 0 10
43225: PUSH
43226: LD_EXP 114
43230: PUSH
43231: LD_VAR 0 2
43235: ARRAY
43236: PPUSH
43237: LD_INT 34
43239: PUSH
43240: LD_INT 31
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PPUSH
43247: CALL_OW 72
43251: ST_TO_ADDR
// if not cts and not mcts then
43252: LD_VAR 0 9
43256: NOT
43257: PUSH
43258: LD_VAR 0 10
43262: NOT
43263: AND
43264: IFFALSE 43268
// continue ;
43266: GO 43083
// x := cts ;
43268: LD_ADDR_VAR 0 11
43272: PUSH
43273: LD_VAR 0 9
43277: ST_TO_ADDR
// if not x then
43278: LD_VAR 0 11
43282: NOT
43283: IFFALSE 43295
// x := mcts ;
43285: LD_ADDR_VAR 0 11
43289: PUSH
43290: LD_VAR 0 10
43294: ST_TO_ADDR
// if not x then
43295: LD_VAR 0 11
43299: NOT
43300: IFFALSE 43304
// continue ;
43302: GO 43083
// if mc_remote_driver [ i ] then
43304: LD_EXP 135
43308: PUSH
43309: LD_VAR 0 2
43313: ARRAY
43314: IFFALSE 43701
// for j in mc_remote_driver [ i ] do
43316: LD_ADDR_VAR 0 3
43320: PUSH
43321: LD_EXP 135
43325: PUSH
43326: LD_VAR 0 2
43330: ARRAY
43331: PUSH
43332: FOR_IN
43333: IFFALSE 43699
// begin if GetClass ( j ) <> 3 then
43335: LD_VAR 0 3
43339: PPUSH
43340: CALL_OW 257
43344: PUSH
43345: LD_INT 3
43347: NONEQUAL
43348: IFFALSE 43401
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43350: LD_ADDR_EXP 135
43354: PUSH
43355: LD_EXP 135
43359: PPUSH
43360: LD_VAR 0 2
43364: PPUSH
43365: LD_EXP 135
43369: PUSH
43370: LD_VAR 0 2
43374: ARRAY
43375: PUSH
43376: LD_VAR 0 3
43380: DIFF
43381: PPUSH
43382: CALL_OW 1
43386: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43387: LD_VAR 0 3
43391: PPUSH
43392: LD_INT 0
43394: PPUSH
43395: CALL_OW 109
// continue ;
43399: GO 43332
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43401: LD_EXP 114
43405: PUSH
43406: LD_VAR 0 2
43410: ARRAY
43411: PPUSH
43412: LD_INT 34
43414: PUSH
43415: LD_INT 31
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 58
43424: PUSH
43425: EMPTY
43426: LIST
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PPUSH
43432: CALL_OW 72
43436: PUSH
43437: LD_VAR 0 3
43441: PPUSH
43442: CALL 86369 0 1
43446: NOT
43447: AND
43448: IFFALSE 43519
// begin if IsInUnit ( j ) then
43450: LD_VAR 0 3
43454: PPUSH
43455: CALL_OW 310
43459: IFFALSE 43470
// ComExitBuilding ( j ) ;
43461: LD_VAR 0 3
43465: PPUSH
43466: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43470: LD_VAR 0 3
43474: PPUSH
43475: LD_EXP 114
43479: PUSH
43480: LD_VAR 0 2
43484: ARRAY
43485: PPUSH
43486: LD_INT 34
43488: PUSH
43489: LD_INT 31
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 58
43498: PUSH
43499: EMPTY
43500: LIST
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PPUSH
43506: CALL_OW 72
43510: PUSH
43511: LD_INT 1
43513: ARRAY
43514: PPUSH
43515: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43519: LD_VAR 0 3
43523: PPUSH
43524: CALL_OW 310
43528: NOT
43529: PUSH
43530: LD_VAR 0 3
43534: PPUSH
43535: CALL_OW 310
43539: PPUSH
43540: CALL_OW 266
43544: PUSH
43545: LD_INT 36
43547: NONEQUAL
43548: PUSH
43549: LD_VAR 0 3
43553: PPUSH
43554: CALL 86369 0 1
43558: NOT
43559: AND
43560: OR
43561: IFFALSE 43697
// begin if IsInUnit ( j ) then
43563: LD_VAR 0 3
43567: PPUSH
43568: CALL_OW 310
43572: IFFALSE 43583
// ComExitBuilding ( j ) ;
43574: LD_VAR 0 3
43578: PPUSH
43579: CALL_OW 122
// ct := 0 ;
43583: LD_ADDR_VAR 0 8
43587: PUSH
43588: LD_INT 0
43590: ST_TO_ADDR
// for k in x do
43591: LD_ADDR_VAR 0 4
43595: PUSH
43596: LD_VAR 0 11
43600: PUSH
43601: FOR_IN
43602: IFFALSE 43675
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43604: LD_VAR 0 4
43608: PPUSH
43609: CALL_OW 264
43613: PUSH
43614: LD_INT 31
43616: EQUAL
43617: PUSH
43618: LD_VAR 0 4
43622: PPUSH
43623: CALL_OW 311
43627: NOT
43628: AND
43629: PUSH
43630: LD_VAR 0 4
43634: PPUSH
43635: CALL_OW 266
43639: PUSH
43640: LD_INT 36
43642: EQUAL
43643: PUSH
43644: LD_VAR 0 4
43648: PPUSH
43649: CALL_OW 313
43653: PUSH
43654: LD_INT 3
43656: LESS
43657: AND
43658: OR
43659: IFFALSE 43673
// begin ct := k ;
43661: LD_ADDR_VAR 0 8
43665: PUSH
43666: LD_VAR 0 4
43670: ST_TO_ADDR
// break ;
43671: GO 43675
// end ;
43673: GO 43601
43675: POP
43676: POP
// if ct then
43677: LD_VAR 0 8
43681: IFFALSE 43697
// ComEnterUnit ( j , ct ) ;
43683: LD_VAR 0 3
43687: PPUSH
43688: LD_VAR 0 8
43692: PPUSH
43693: CALL_OW 120
// end ; end ;
43697: GO 43332
43699: POP
43700: POP
// places := 0 ;
43701: LD_ADDR_VAR 0 5
43705: PUSH
43706: LD_INT 0
43708: ST_TO_ADDR
// for j = 1 to x do
43709: LD_ADDR_VAR 0 3
43713: PUSH
43714: DOUBLE
43715: LD_INT 1
43717: DEC
43718: ST_TO_ADDR
43719: LD_VAR 0 11
43723: PUSH
43724: FOR_TO
43725: IFFALSE 43801
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43727: LD_VAR 0 11
43731: PUSH
43732: LD_VAR 0 3
43736: ARRAY
43737: PPUSH
43738: CALL_OW 264
43742: PUSH
43743: LD_INT 31
43745: EQUAL
43746: IFFALSE 43764
// places := places + 1 else
43748: LD_ADDR_VAR 0 5
43752: PUSH
43753: LD_VAR 0 5
43757: PUSH
43758: LD_INT 1
43760: PLUS
43761: ST_TO_ADDR
43762: GO 43799
// if GetBType ( x [ j ] ) = b_control_tower then
43764: LD_VAR 0 11
43768: PUSH
43769: LD_VAR 0 3
43773: ARRAY
43774: PPUSH
43775: CALL_OW 266
43779: PUSH
43780: LD_INT 36
43782: EQUAL
43783: IFFALSE 43799
// places := places + 3 ;
43785: LD_ADDR_VAR 0 5
43789: PUSH
43790: LD_VAR 0 5
43794: PUSH
43795: LD_INT 3
43797: PLUS
43798: ST_TO_ADDR
43799: GO 43724
43801: POP
43802: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43803: LD_VAR 0 5
43807: PUSH
43808: LD_INT 0
43810: EQUAL
43811: PUSH
43812: LD_VAR 0 5
43816: PUSH
43817: LD_EXP 135
43821: PUSH
43822: LD_VAR 0 2
43826: ARRAY
43827: LESSEQUAL
43828: OR
43829: IFFALSE 43833
// continue ;
43831: GO 43083
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43833: LD_ADDR_VAR 0 6
43837: PUSH
43838: LD_EXP 95
43842: PUSH
43843: LD_VAR 0 2
43847: ARRAY
43848: PPUSH
43849: LD_INT 25
43851: PUSH
43852: LD_INT 3
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PPUSH
43859: CALL_OW 72
43863: PUSH
43864: LD_EXP 135
43868: PUSH
43869: LD_VAR 0 2
43873: ARRAY
43874: DIFF
43875: PPUSH
43876: LD_INT 3
43878: PPUSH
43879: CALL 87269 0 2
43883: ST_TO_ADDR
// for j in tmp do
43884: LD_ADDR_VAR 0 3
43888: PUSH
43889: LD_VAR 0 6
43893: PUSH
43894: FOR_IN
43895: IFFALSE 43930
// if GetTag ( j ) > 0 then
43897: LD_VAR 0 3
43901: PPUSH
43902: CALL_OW 110
43906: PUSH
43907: LD_INT 0
43909: GREATER
43910: IFFALSE 43928
// tmp := tmp diff j ;
43912: LD_ADDR_VAR 0 6
43916: PUSH
43917: LD_VAR 0 6
43921: PUSH
43922: LD_VAR 0 3
43926: DIFF
43927: ST_TO_ADDR
43928: GO 43894
43930: POP
43931: POP
// if not tmp then
43932: LD_VAR 0 6
43936: NOT
43937: IFFALSE 43941
// continue ;
43939: GO 43083
// if places then
43941: LD_VAR 0 5
43945: IFFALSE 44004
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43947: LD_ADDR_EXP 135
43951: PUSH
43952: LD_EXP 135
43956: PPUSH
43957: LD_VAR 0 2
43961: PPUSH
43962: LD_EXP 135
43966: PUSH
43967: LD_VAR 0 2
43971: ARRAY
43972: PUSH
43973: LD_VAR 0 6
43977: PUSH
43978: LD_INT 1
43980: ARRAY
43981: UNION
43982: PPUSH
43983: CALL_OW 1
43987: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43988: LD_VAR 0 6
43992: PUSH
43993: LD_INT 1
43995: ARRAY
43996: PPUSH
43997: LD_INT 126
43999: PPUSH
44000: CALL_OW 109
// end ; end ;
44004: GO 43083
44006: POP
44007: POP
// end ;
44008: LD_VAR 0 1
44012: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44013: LD_INT 0
44015: PPUSH
44016: PPUSH
44017: PPUSH
44018: PPUSH
44019: PPUSH
44020: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44021: LD_VAR 0 1
44025: NOT
44026: PUSH
44027: LD_VAR 0 2
44031: NOT
44032: OR
44033: PUSH
44034: LD_VAR 0 3
44038: NOT
44039: OR
44040: PUSH
44041: LD_VAR 0 4
44045: PUSH
44046: LD_INT 1
44048: PUSH
44049: LD_INT 2
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 4
44057: PUSH
44058: LD_INT 5
44060: PUSH
44061: LD_INT 8
44063: PUSH
44064: LD_INT 9
44066: PUSH
44067: LD_INT 15
44069: PUSH
44070: LD_INT 16
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: IN
44084: NOT
44085: OR
44086: IFFALSE 44090
// exit ;
44088: GO 44990
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44090: LD_ADDR_VAR 0 2
44094: PUSH
44095: LD_VAR 0 2
44099: PPUSH
44100: LD_INT 21
44102: PUSH
44103: LD_INT 3
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 24
44112: PUSH
44113: LD_INT 250
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PPUSH
44124: CALL_OW 72
44128: ST_TO_ADDR
// case class of 1 , 15 :
44129: LD_VAR 0 4
44133: PUSH
44134: LD_INT 1
44136: DOUBLE
44137: EQUAL
44138: IFTRUE 44148
44140: LD_INT 15
44142: DOUBLE
44143: EQUAL
44144: IFTRUE 44148
44146: GO 44233
44148: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44149: LD_ADDR_VAR 0 8
44153: PUSH
44154: LD_VAR 0 2
44158: PPUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 30
44164: PUSH
44165: LD_INT 32
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 30
44174: PUSH
44175: LD_INT 31
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: PPUSH
44187: CALL_OW 72
44191: PUSH
44192: LD_VAR 0 2
44196: PPUSH
44197: LD_INT 2
44199: PUSH
44200: LD_INT 30
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 30
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: LIST
44224: PPUSH
44225: CALL_OW 72
44229: ADD
44230: ST_TO_ADDR
44231: GO 44479
44233: LD_INT 2
44235: DOUBLE
44236: EQUAL
44237: IFTRUE 44247
44239: LD_INT 16
44241: DOUBLE
44242: EQUAL
44243: IFTRUE 44247
44245: GO 44293
44247: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44248: LD_ADDR_VAR 0 8
44252: PUSH
44253: LD_VAR 0 2
44257: PPUSH
44258: LD_INT 2
44260: PUSH
44261: LD_INT 30
44263: PUSH
44264: LD_INT 0
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 30
44273: PUSH
44274: LD_INT 1
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: ST_TO_ADDR
44291: GO 44479
44293: LD_INT 3
44295: DOUBLE
44296: EQUAL
44297: IFTRUE 44301
44299: GO 44347
44301: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44302: LD_ADDR_VAR 0 8
44306: PUSH
44307: LD_VAR 0 2
44311: PPUSH
44312: LD_INT 2
44314: PUSH
44315: LD_INT 30
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 30
44327: PUSH
44328: LD_INT 3
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: LIST
44339: PPUSH
44340: CALL_OW 72
44344: ST_TO_ADDR
44345: GO 44479
44347: LD_INT 4
44349: DOUBLE
44350: EQUAL
44351: IFTRUE 44355
44353: GO 44412
44355: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44356: LD_ADDR_VAR 0 8
44360: PUSH
44361: LD_VAR 0 2
44365: PPUSH
44366: LD_INT 2
44368: PUSH
44369: LD_INT 30
44371: PUSH
44372: LD_INT 6
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 30
44381: PUSH
44382: LD_INT 7
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 30
44391: PUSH
44392: LD_INT 8
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: PPUSH
44405: CALL_OW 72
44409: ST_TO_ADDR
44410: GO 44479
44412: LD_INT 5
44414: DOUBLE
44415: EQUAL
44416: IFTRUE 44432
44418: LD_INT 8
44420: DOUBLE
44421: EQUAL
44422: IFTRUE 44432
44424: LD_INT 9
44426: DOUBLE
44427: EQUAL
44428: IFTRUE 44432
44430: GO 44478
44432: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44433: LD_ADDR_VAR 0 8
44437: PUSH
44438: LD_VAR 0 2
44442: PPUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 30
44448: PUSH
44449: LD_INT 4
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 30
44458: PUSH
44459: LD_INT 5
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: PPUSH
44471: CALL_OW 72
44475: ST_TO_ADDR
44476: GO 44479
44478: POP
// if not tmp then
44479: LD_VAR 0 8
44483: NOT
44484: IFFALSE 44488
// exit ;
44486: GO 44990
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44488: LD_VAR 0 4
44492: PUSH
44493: LD_INT 1
44495: PUSH
44496: LD_INT 15
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: IN
44503: PUSH
44504: LD_EXP 104
44508: PUSH
44509: LD_VAR 0 1
44513: ARRAY
44514: AND
44515: IFFALSE 44671
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44517: LD_ADDR_VAR 0 9
44521: PUSH
44522: LD_EXP 104
44526: PUSH
44527: LD_VAR 0 1
44531: ARRAY
44532: PUSH
44533: LD_INT 1
44535: ARRAY
44536: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44537: LD_VAR 0 9
44541: PUSH
44542: LD_EXP 105
44546: PUSH
44547: LD_VAR 0 1
44551: ARRAY
44552: IN
44553: NOT
44554: IFFALSE 44669
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44556: LD_ADDR_EXP 105
44560: PUSH
44561: LD_EXP 105
44565: PPUSH
44566: LD_VAR 0 1
44570: PUSH
44571: LD_EXP 105
44575: PUSH
44576: LD_VAR 0 1
44580: ARRAY
44581: PUSH
44582: LD_INT 1
44584: PLUS
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PPUSH
44590: LD_VAR 0 9
44594: PPUSH
44595: CALL 57012 0 3
44599: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44600: LD_ADDR_EXP 104
44604: PUSH
44605: LD_EXP 104
44609: PPUSH
44610: LD_VAR 0 1
44614: PPUSH
44615: LD_EXP 104
44619: PUSH
44620: LD_VAR 0 1
44624: ARRAY
44625: PUSH
44626: LD_VAR 0 9
44630: DIFF
44631: PPUSH
44632: CALL_OW 1
44636: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44637: LD_VAR 0 3
44641: PPUSH
44642: LD_EXP 105
44646: PUSH
44647: LD_VAR 0 1
44651: ARRAY
44652: PUSH
44653: LD_EXP 105
44657: PUSH
44658: LD_VAR 0 1
44662: ARRAY
44663: ARRAY
44664: PPUSH
44665: CALL_OW 120
// end ; exit ;
44669: GO 44990
// end ; if tmp > 1 then
44671: LD_VAR 0 8
44675: PUSH
44676: LD_INT 1
44678: GREATER
44679: IFFALSE 44783
// for i = 2 to tmp do
44681: LD_ADDR_VAR 0 6
44685: PUSH
44686: DOUBLE
44687: LD_INT 2
44689: DEC
44690: ST_TO_ADDR
44691: LD_VAR 0 8
44695: PUSH
44696: FOR_TO
44697: IFFALSE 44781
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44699: LD_VAR 0 8
44703: PUSH
44704: LD_VAR 0 6
44708: ARRAY
44709: PPUSH
44710: CALL_OW 461
44714: PUSH
44715: LD_INT 6
44717: EQUAL
44718: IFFALSE 44779
// begin x := tmp [ i ] ;
44720: LD_ADDR_VAR 0 9
44724: PUSH
44725: LD_VAR 0 8
44729: PUSH
44730: LD_VAR 0 6
44734: ARRAY
44735: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44736: LD_ADDR_VAR 0 8
44740: PUSH
44741: LD_VAR 0 8
44745: PPUSH
44746: LD_VAR 0 6
44750: PPUSH
44751: CALL_OW 3
44755: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44756: LD_ADDR_VAR 0 8
44760: PUSH
44761: LD_VAR 0 8
44765: PPUSH
44766: LD_INT 1
44768: PPUSH
44769: LD_VAR 0 9
44773: PPUSH
44774: CALL_OW 2
44778: ST_TO_ADDR
// end ;
44779: GO 44696
44781: POP
44782: POP
// for i in tmp do
44783: LD_ADDR_VAR 0 6
44787: PUSH
44788: LD_VAR 0 8
44792: PUSH
44793: FOR_IN
44794: IFFALSE 44863
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44796: LD_VAR 0 6
44800: PPUSH
44801: CALL_OW 313
44805: PUSH
44806: LD_INT 6
44808: LESS
44809: PUSH
44810: LD_VAR 0 6
44814: PPUSH
44815: CALL_OW 266
44819: PUSH
44820: LD_INT 31
44822: PUSH
44823: LD_INT 32
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: IN
44830: NOT
44831: AND
44832: PUSH
44833: LD_VAR 0 6
44837: PPUSH
44838: CALL_OW 313
44842: PUSH
44843: LD_INT 0
44845: EQUAL
44846: OR
44847: IFFALSE 44861
// begin j := i ;
44849: LD_ADDR_VAR 0 7
44853: PUSH
44854: LD_VAR 0 6
44858: ST_TO_ADDR
// break ;
44859: GO 44863
// end ; end ;
44861: GO 44793
44863: POP
44864: POP
// if j then
44865: LD_VAR 0 7
44869: IFFALSE 44887
// ComEnterUnit ( unit , j ) else
44871: LD_VAR 0 3
44875: PPUSH
44876: LD_VAR 0 7
44880: PPUSH
44881: CALL_OW 120
44885: GO 44990
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44887: LD_ADDR_VAR 0 10
44891: PUSH
44892: LD_VAR 0 2
44896: PPUSH
44897: LD_INT 2
44899: PUSH
44900: LD_INT 30
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 30
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: LIST
44924: PPUSH
44925: CALL_OW 72
44929: ST_TO_ADDR
// if depot then
44930: LD_VAR 0 10
44934: IFFALSE 44990
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44936: LD_ADDR_VAR 0 10
44940: PUSH
44941: LD_VAR 0 10
44945: PPUSH
44946: LD_VAR 0 3
44950: PPUSH
44951: CALL_OW 74
44955: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44956: LD_VAR 0 3
44960: PPUSH
44961: LD_VAR 0 10
44965: PPUSH
44966: CALL_OW 296
44970: PUSH
44971: LD_INT 10
44973: GREATER
44974: IFFALSE 44990
// ComStandNearbyBuilding ( unit , depot ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: LD_VAR 0 10
44985: PPUSH
44986: CALL 53590 0 2
// end ; end ; end ;
44990: LD_VAR 0 5
44994: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44995: LD_INT 0
44997: PPUSH
44998: PPUSH
44999: PPUSH
45000: PPUSH
// if not mc_bases then
45001: LD_EXP 95
45005: NOT
45006: IFFALSE 45010
// exit ;
45008: GO 45249
// for i = 1 to mc_bases do
45010: LD_ADDR_VAR 0 2
45014: PUSH
45015: DOUBLE
45016: LD_INT 1
45018: DEC
45019: ST_TO_ADDR
45020: LD_EXP 95
45024: PUSH
45025: FOR_TO
45026: IFFALSE 45247
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45028: LD_ADDR_VAR 0 4
45032: PUSH
45033: LD_EXP 95
45037: PUSH
45038: LD_VAR 0 2
45042: ARRAY
45043: PPUSH
45044: LD_INT 21
45046: PUSH
45047: LD_INT 1
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PPUSH
45054: CALL_OW 72
45058: PUSH
45059: LD_EXP 124
45063: PUSH
45064: LD_VAR 0 2
45068: ARRAY
45069: UNION
45070: ST_TO_ADDR
// if not tmp then
45071: LD_VAR 0 4
45075: NOT
45076: IFFALSE 45080
// continue ;
45078: GO 45025
// for j in tmp do
45080: LD_ADDR_VAR 0 3
45084: PUSH
45085: LD_VAR 0 4
45089: PUSH
45090: FOR_IN
45091: IFFALSE 45243
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45093: LD_VAR 0 3
45097: PPUSH
45098: CALL_OW 110
45102: NOT
45103: PUSH
45104: LD_VAR 0 3
45108: PPUSH
45109: CALL_OW 314
45113: NOT
45114: AND
45115: PUSH
45116: LD_VAR 0 3
45120: PPUSH
45121: CALL_OW 311
45125: NOT
45126: AND
45127: PUSH
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 310
45137: NOT
45138: AND
45139: PUSH
45140: LD_VAR 0 3
45144: PUSH
45145: LD_EXP 98
45149: PUSH
45150: LD_VAR 0 2
45154: ARRAY
45155: PUSH
45156: LD_INT 1
45158: ARRAY
45159: IN
45160: NOT
45161: AND
45162: PUSH
45163: LD_VAR 0 3
45167: PUSH
45168: LD_EXP 98
45172: PUSH
45173: LD_VAR 0 2
45177: ARRAY
45178: PUSH
45179: LD_INT 2
45181: ARRAY
45182: IN
45183: NOT
45184: AND
45185: PUSH
45186: LD_VAR 0 3
45190: PUSH
45191: LD_EXP 107
45195: PUSH
45196: LD_VAR 0 2
45200: ARRAY
45201: IN
45202: NOT
45203: AND
45204: IFFALSE 45241
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45206: LD_VAR 0 2
45210: PPUSH
45211: LD_EXP 95
45215: PUSH
45216: LD_VAR 0 2
45220: ARRAY
45221: PPUSH
45222: LD_VAR 0 3
45226: PPUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: CALL_OW 257
45236: PPUSH
45237: CALL 44013 0 4
// end ;
45241: GO 45090
45243: POP
45244: POP
// end ;
45245: GO 45025
45247: POP
45248: POP
// end ;
45249: LD_VAR 0 1
45253: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45254: LD_INT 0
45256: PPUSH
45257: PPUSH
45258: PPUSH
45259: PPUSH
45260: PPUSH
45261: PPUSH
// if not mc_bases [ base ] then
45262: LD_EXP 95
45266: PUSH
45267: LD_VAR 0 1
45271: ARRAY
45272: NOT
45273: IFFALSE 45277
// exit ;
45275: GO 45459
// tmp := [ ] ;
45277: LD_ADDR_VAR 0 6
45281: PUSH
45282: EMPTY
45283: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45284: LD_ADDR_VAR 0 7
45288: PUSH
45289: LD_VAR 0 3
45293: PPUSH
45294: LD_INT 0
45296: PPUSH
45297: CALL_OW 517
45301: ST_TO_ADDR
// if not list then
45302: LD_VAR 0 7
45306: NOT
45307: IFFALSE 45311
// exit ;
45309: GO 45459
// for i = 1 to amount do
45311: LD_ADDR_VAR 0 5
45315: PUSH
45316: DOUBLE
45317: LD_INT 1
45319: DEC
45320: ST_TO_ADDR
45321: LD_VAR 0 2
45325: PUSH
45326: FOR_TO
45327: IFFALSE 45407
// begin x := rand ( 1 , list [ 1 ] ) ;
45329: LD_ADDR_VAR 0 8
45333: PUSH
45334: LD_INT 1
45336: PPUSH
45337: LD_VAR 0 7
45341: PUSH
45342: LD_INT 1
45344: ARRAY
45345: PPUSH
45346: CALL_OW 12
45350: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45351: LD_ADDR_VAR 0 6
45355: PUSH
45356: LD_VAR 0 6
45360: PPUSH
45361: LD_VAR 0 5
45365: PPUSH
45366: LD_VAR 0 7
45370: PUSH
45371: LD_INT 1
45373: ARRAY
45374: PUSH
45375: LD_VAR 0 8
45379: ARRAY
45380: PUSH
45381: LD_VAR 0 7
45385: PUSH
45386: LD_INT 2
45388: ARRAY
45389: PUSH
45390: LD_VAR 0 8
45394: ARRAY
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PPUSH
45400: CALL_OW 1
45404: ST_TO_ADDR
// end ;
45405: GO 45326
45407: POP
45408: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45409: LD_ADDR_EXP 108
45413: PUSH
45414: LD_EXP 108
45418: PPUSH
45419: LD_VAR 0 1
45423: PPUSH
45424: LD_VAR 0 6
45428: PPUSH
45429: CALL_OW 1
45433: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45434: LD_ADDR_EXP 110
45438: PUSH
45439: LD_EXP 110
45443: PPUSH
45444: LD_VAR 0 1
45448: PPUSH
45449: LD_VAR 0 3
45453: PPUSH
45454: CALL_OW 1
45458: ST_TO_ADDR
// end ;
45459: LD_VAR 0 4
45463: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45464: LD_INT 0
45466: PPUSH
// if not mc_bases [ base ] then
45467: LD_EXP 95
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: NOT
45478: IFFALSE 45482
// exit ;
45480: GO 45507
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45482: LD_ADDR_EXP 100
45486: PUSH
45487: LD_EXP 100
45491: PPUSH
45492: LD_VAR 0 1
45496: PPUSH
45497: LD_VAR 0 2
45501: PPUSH
45502: CALL_OW 1
45506: ST_TO_ADDR
// end ;
45507: LD_VAR 0 3
45511: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45512: LD_INT 0
45514: PPUSH
// if not mc_bases [ base ] then
45515: LD_EXP 95
45519: PUSH
45520: LD_VAR 0 1
45524: ARRAY
45525: NOT
45526: IFFALSE 45530
// exit ;
45528: GO 45567
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45530: LD_ADDR_EXP 100
45534: PUSH
45535: LD_EXP 100
45539: PPUSH
45540: LD_VAR 0 1
45544: PPUSH
45545: LD_EXP 100
45549: PUSH
45550: LD_VAR 0 1
45554: ARRAY
45555: PUSH
45556: LD_VAR 0 2
45560: UNION
45561: PPUSH
45562: CALL_OW 1
45566: ST_TO_ADDR
// end ;
45567: LD_VAR 0 3
45571: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45572: LD_INT 0
45574: PPUSH
// if not mc_bases [ base ] then
45575: LD_EXP 95
45579: PUSH
45580: LD_VAR 0 1
45584: ARRAY
45585: NOT
45586: IFFALSE 45590
// exit ;
45588: GO 45615
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45590: LD_ADDR_EXP 116
45594: PUSH
45595: LD_EXP 116
45599: PPUSH
45600: LD_VAR 0 1
45604: PPUSH
45605: LD_VAR 0 2
45609: PPUSH
45610: CALL_OW 1
45614: ST_TO_ADDR
// end ;
45615: LD_VAR 0 3
45619: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45620: LD_INT 0
45622: PPUSH
// if not mc_bases [ base ] then
45623: LD_EXP 95
45627: PUSH
45628: LD_VAR 0 1
45632: ARRAY
45633: NOT
45634: IFFALSE 45638
// exit ;
45636: GO 45675
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45638: LD_ADDR_EXP 116
45642: PUSH
45643: LD_EXP 116
45647: PPUSH
45648: LD_VAR 0 1
45652: PPUSH
45653: LD_EXP 116
45657: PUSH
45658: LD_VAR 0 1
45662: ARRAY
45663: PUSH
45664: LD_VAR 0 2
45668: ADD
45669: PPUSH
45670: CALL_OW 1
45674: ST_TO_ADDR
// end ;
45675: LD_VAR 0 3
45679: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45680: LD_INT 0
45682: PPUSH
// if not mc_bases [ base ] then
45683: LD_EXP 95
45687: PUSH
45688: LD_VAR 0 1
45692: ARRAY
45693: NOT
45694: IFFALSE 45698
// exit ;
45696: GO 45752
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45698: LD_ADDR_EXP 117
45702: PUSH
45703: LD_EXP 117
45707: PPUSH
45708: LD_VAR 0 1
45712: PPUSH
45713: LD_VAR 0 2
45717: PPUSH
45718: CALL_OW 1
45722: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45723: LD_ADDR_EXP 106
45727: PUSH
45728: LD_EXP 106
45732: PPUSH
45733: LD_VAR 0 1
45737: PPUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 0
45745: PLUS
45746: PPUSH
45747: CALL_OW 1
45751: ST_TO_ADDR
// end ;
45752: LD_VAR 0 3
45756: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45757: LD_INT 0
45759: PPUSH
// if not mc_bases [ base ] then
45760: LD_EXP 95
45764: PUSH
45765: LD_VAR 0 1
45769: ARRAY
45770: NOT
45771: IFFALSE 45775
// exit ;
45773: GO 45800
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45775: LD_ADDR_EXP 106
45779: PUSH
45780: LD_EXP 106
45784: PPUSH
45785: LD_VAR 0 1
45789: PPUSH
45790: LD_VAR 0 2
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// end ;
45800: LD_VAR 0 3
45804: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45805: LD_INT 0
45807: PPUSH
45808: PPUSH
45809: PPUSH
45810: PPUSH
// if not mc_bases [ base ] then
45811: LD_EXP 95
45815: PUSH
45816: LD_VAR 0 1
45820: ARRAY
45821: NOT
45822: IFFALSE 45826
// exit ;
45824: GO 45891
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45826: LD_ADDR_EXP 115
45830: PUSH
45831: LD_EXP 115
45835: PPUSH
45836: LD_VAR 0 1
45840: PUSH
45841: LD_EXP 115
45845: PUSH
45846: LD_VAR 0 1
45850: ARRAY
45851: PUSH
45852: LD_INT 1
45854: PLUS
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PPUSH
45860: LD_VAR 0 1
45864: PUSH
45865: LD_VAR 0 2
45869: PUSH
45870: LD_VAR 0 3
45874: PUSH
45875: LD_VAR 0 4
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: PPUSH
45886: CALL 57012 0 3
45890: ST_TO_ADDR
// end ;
45891: LD_VAR 0 5
45895: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45896: LD_INT 0
45898: PPUSH
// if not mc_bases [ base ] then
45899: LD_EXP 95
45903: PUSH
45904: LD_VAR 0 1
45908: ARRAY
45909: NOT
45910: IFFALSE 45914
// exit ;
45912: GO 45939
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45914: LD_ADDR_EXP 132
45918: PUSH
45919: LD_EXP 132
45923: PPUSH
45924: LD_VAR 0 1
45928: PPUSH
45929: LD_VAR 0 2
45933: PPUSH
45934: CALL_OW 1
45938: ST_TO_ADDR
// end ;
45939: LD_VAR 0 3
45943: RET
// export function MC_GetMinesField ( base ) ; begin
45944: LD_INT 0
45946: PPUSH
// result := mc_mines [ base ] ;
45947: LD_ADDR_VAR 0 2
45951: PUSH
45952: LD_EXP 108
45956: PUSH
45957: LD_VAR 0 1
45961: ARRAY
45962: ST_TO_ADDR
// end ;
45963: LD_VAR 0 2
45967: RET
// export function MC_GetProduceList ( base ) ; begin
45968: LD_INT 0
45970: PPUSH
// result := mc_produce [ base ] ;
45971: LD_ADDR_VAR 0 2
45975: PUSH
45976: LD_EXP 116
45980: PUSH
45981: LD_VAR 0 1
45985: ARRAY
45986: ST_TO_ADDR
// end ;
45987: LD_VAR 0 2
45991: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45992: LD_INT 0
45994: PPUSH
45995: PPUSH
// if not mc_bases then
45996: LD_EXP 95
46000: NOT
46001: IFFALSE 46005
// exit ;
46003: GO 46070
// if mc_bases [ base ] then
46005: LD_EXP 95
46009: PUSH
46010: LD_VAR 0 1
46014: ARRAY
46015: IFFALSE 46070
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46017: LD_ADDR_VAR 0 3
46021: PUSH
46022: LD_EXP 95
46026: PUSH
46027: LD_VAR 0 1
46031: ARRAY
46032: PPUSH
46033: LD_INT 30
46035: PUSH
46036: LD_VAR 0 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL_OW 72
46049: ST_TO_ADDR
// if result then
46050: LD_VAR 0 3
46054: IFFALSE 46070
// result := result [ 1 ] ;
46056: LD_ADDR_VAR 0 3
46060: PUSH
46061: LD_VAR 0 3
46065: PUSH
46066: LD_INT 1
46068: ARRAY
46069: ST_TO_ADDR
// end ; end ;
46070: LD_VAR 0 3
46074: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46075: LD_INT 0
46077: PPUSH
46078: PPUSH
// if not mc_bases then
46079: LD_EXP 95
46083: NOT
46084: IFFALSE 46088
// exit ;
46086: GO 46133
// if mc_bases [ base ] then
46088: LD_EXP 95
46092: PUSH
46093: LD_VAR 0 1
46097: ARRAY
46098: IFFALSE 46133
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46100: LD_ADDR_VAR 0 3
46104: PUSH
46105: LD_EXP 95
46109: PUSH
46110: LD_VAR 0 1
46114: ARRAY
46115: PPUSH
46116: LD_INT 30
46118: PUSH
46119: LD_VAR 0 2
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PPUSH
46128: CALL_OW 72
46132: ST_TO_ADDR
// end ;
46133: LD_VAR 0 3
46137: RET
// export function MC_SetTame ( base , area ) ; begin
46138: LD_INT 0
46140: PPUSH
// if not mc_bases or not base then
46141: LD_EXP 95
46145: NOT
46146: PUSH
46147: LD_VAR 0 1
46151: NOT
46152: OR
46153: IFFALSE 46157
// exit ;
46155: GO 46182
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46157: LD_ADDR_EXP 123
46161: PUSH
46162: LD_EXP 123
46166: PPUSH
46167: LD_VAR 0 1
46171: PPUSH
46172: LD_VAR 0 2
46176: PPUSH
46177: CALL_OW 1
46181: ST_TO_ADDR
// end ;
46182: LD_VAR 0 3
46186: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46187: LD_INT 0
46189: PPUSH
46190: PPUSH
// if not mc_bases or not base then
46191: LD_EXP 95
46195: NOT
46196: PUSH
46197: LD_VAR 0 1
46201: NOT
46202: OR
46203: IFFALSE 46207
// exit ;
46205: GO 46309
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46207: LD_ADDR_VAR 0 4
46211: PUSH
46212: LD_EXP 95
46216: PUSH
46217: LD_VAR 0 1
46221: ARRAY
46222: PPUSH
46223: LD_INT 30
46225: PUSH
46226: LD_VAR 0 2
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PPUSH
46235: CALL_OW 72
46239: ST_TO_ADDR
// if not tmp then
46240: LD_VAR 0 4
46244: NOT
46245: IFFALSE 46249
// exit ;
46247: GO 46309
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46249: LD_ADDR_EXP 127
46253: PUSH
46254: LD_EXP 127
46258: PPUSH
46259: LD_VAR 0 1
46263: PPUSH
46264: LD_EXP 127
46268: PUSH
46269: LD_VAR 0 1
46273: ARRAY
46274: PPUSH
46275: LD_EXP 127
46279: PUSH
46280: LD_VAR 0 1
46284: ARRAY
46285: PUSH
46286: LD_INT 1
46288: PLUS
46289: PPUSH
46290: LD_VAR 0 4
46294: PUSH
46295: LD_INT 1
46297: ARRAY
46298: PPUSH
46299: CALL_OW 2
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// end ;
46309: LD_VAR 0 3
46313: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46314: LD_INT 0
46316: PPUSH
46317: PPUSH
// if not mc_bases or not base or not kinds then
46318: LD_EXP 95
46322: NOT
46323: PUSH
46324: LD_VAR 0 1
46328: NOT
46329: OR
46330: PUSH
46331: LD_VAR 0 2
46335: NOT
46336: OR
46337: IFFALSE 46341
// exit ;
46339: GO 46402
// for i in kinds do
46341: LD_ADDR_VAR 0 4
46345: PUSH
46346: LD_VAR 0 2
46350: PUSH
46351: FOR_IN
46352: IFFALSE 46400
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46354: LD_ADDR_EXP 129
46358: PUSH
46359: LD_EXP 129
46363: PPUSH
46364: LD_VAR 0 1
46368: PUSH
46369: LD_EXP 129
46373: PUSH
46374: LD_VAR 0 1
46378: ARRAY
46379: PUSH
46380: LD_INT 1
46382: PLUS
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PPUSH
46388: LD_VAR 0 4
46392: PPUSH
46393: CALL 57012 0 3
46397: ST_TO_ADDR
46398: GO 46351
46400: POP
46401: POP
// end ;
46402: LD_VAR 0 3
46406: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46407: LD_INT 0
46409: PPUSH
// if not mc_bases or not base or not areas then
46410: LD_EXP 95
46414: NOT
46415: PUSH
46416: LD_VAR 0 1
46420: NOT
46421: OR
46422: PUSH
46423: LD_VAR 0 2
46427: NOT
46428: OR
46429: IFFALSE 46433
// exit ;
46431: GO 46458
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46433: LD_ADDR_EXP 113
46437: PUSH
46438: LD_EXP 113
46442: PPUSH
46443: LD_VAR 0 1
46447: PPUSH
46448: LD_VAR 0 2
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// end ;
46458: LD_VAR 0 3
46462: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46463: LD_INT 0
46465: PPUSH
// if not mc_bases or not base or not teleports_exit then
46466: LD_EXP 95
46470: NOT
46471: PUSH
46472: LD_VAR 0 1
46476: NOT
46477: OR
46478: PUSH
46479: LD_VAR 0 2
46483: NOT
46484: OR
46485: IFFALSE 46489
// exit ;
46487: GO 46514
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46489: LD_ADDR_EXP 130
46493: PUSH
46494: LD_EXP 130
46498: PPUSH
46499: LD_VAR 0 1
46503: PPUSH
46504: LD_VAR 0 2
46508: PPUSH
46509: CALL_OW 1
46513: ST_TO_ADDR
// end ;
46514: LD_VAR 0 3
46518: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46519: LD_INT 0
46521: PPUSH
46522: PPUSH
46523: PPUSH
// if not mc_bases or not base or not ext_list then
46524: LD_EXP 95
46528: NOT
46529: PUSH
46530: LD_VAR 0 1
46534: NOT
46535: OR
46536: PUSH
46537: LD_VAR 0 5
46541: NOT
46542: OR
46543: IFFALSE 46547
// exit ;
46545: GO 46720
// tmp := GetFacExtXYD ( x , y , d ) ;
46547: LD_ADDR_VAR 0 8
46551: PUSH
46552: LD_VAR 0 2
46556: PPUSH
46557: LD_VAR 0 3
46561: PPUSH
46562: LD_VAR 0 4
46566: PPUSH
46567: CALL 86399 0 3
46571: ST_TO_ADDR
// if not tmp then
46572: LD_VAR 0 8
46576: NOT
46577: IFFALSE 46581
// exit ;
46579: GO 46720
// for i in tmp do
46581: LD_ADDR_VAR 0 7
46585: PUSH
46586: LD_VAR 0 8
46590: PUSH
46591: FOR_IN
46592: IFFALSE 46718
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46594: LD_ADDR_EXP 100
46598: PUSH
46599: LD_EXP 100
46603: PPUSH
46604: LD_VAR 0 1
46608: PPUSH
46609: LD_EXP 100
46613: PUSH
46614: LD_VAR 0 1
46618: ARRAY
46619: PPUSH
46620: LD_EXP 100
46624: PUSH
46625: LD_VAR 0 1
46629: ARRAY
46630: PUSH
46631: LD_INT 1
46633: PLUS
46634: PPUSH
46635: LD_VAR 0 5
46639: PUSH
46640: LD_INT 1
46642: ARRAY
46643: PUSH
46644: LD_VAR 0 7
46648: PUSH
46649: LD_INT 1
46651: ARRAY
46652: PUSH
46653: LD_VAR 0 7
46657: PUSH
46658: LD_INT 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 7
46666: PUSH
46667: LD_INT 3
46669: ARRAY
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: PPUSH
46677: CALL_OW 2
46681: PPUSH
46682: CALL_OW 1
46686: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46687: LD_ADDR_VAR 0 5
46691: PUSH
46692: LD_VAR 0 5
46696: PPUSH
46697: LD_INT 1
46699: PPUSH
46700: CALL_OW 3
46704: ST_TO_ADDR
// if not ext_list then
46705: LD_VAR 0 5
46709: NOT
46710: IFFALSE 46716
// exit ;
46712: POP
46713: POP
46714: GO 46720
// end ;
46716: GO 46591
46718: POP
46719: POP
// end ;
46720: LD_VAR 0 6
46724: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46725: LD_INT 0
46727: PPUSH
// if not mc_bases or not base or not weapon_list then
46728: LD_EXP 95
46732: NOT
46733: PUSH
46734: LD_VAR 0 1
46738: NOT
46739: OR
46740: PUSH
46741: LD_VAR 0 2
46745: NOT
46746: OR
46747: IFFALSE 46751
// exit ;
46749: GO 46776
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46751: LD_ADDR_EXP 134
46755: PUSH
46756: LD_EXP 134
46760: PPUSH
46761: LD_VAR 0 1
46765: PPUSH
46766: LD_VAR 0 2
46770: PPUSH
46771: CALL_OW 1
46775: ST_TO_ADDR
// end ;
46776: LD_VAR 0 3
46780: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46781: LD_INT 0
46783: PPUSH
// if not mc_bases or not base or not tech_list then
46784: LD_EXP 95
46788: NOT
46789: PUSH
46790: LD_VAR 0 1
46794: NOT
46795: OR
46796: PUSH
46797: LD_VAR 0 2
46801: NOT
46802: OR
46803: IFFALSE 46807
// exit ;
46805: GO 46832
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46807: LD_ADDR_EXP 122
46811: PUSH
46812: LD_EXP 122
46816: PPUSH
46817: LD_VAR 0 1
46821: PPUSH
46822: LD_VAR 0 2
46826: PPUSH
46827: CALL_OW 1
46831: ST_TO_ADDR
// end ;
46832: LD_VAR 0 3
46836: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46837: LD_INT 0
46839: PPUSH
// if not mc_bases or not parking_area or not base then
46840: LD_EXP 95
46844: NOT
46845: PUSH
46846: LD_VAR 0 2
46850: NOT
46851: OR
46852: PUSH
46853: LD_VAR 0 1
46857: NOT
46858: OR
46859: IFFALSE 46863
// exit ;
46861: GO 46888
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46863: LD_ADDR_EXP 119
46867: PUSH
46868: LD_EXP 119
46872: PPUSH
46873: LD_VAR 0 1
46877: PPUSH
46878: LD_VAR 0 2
46882: PPUSH
46883: CALL_OW 1
46887: ST_TO_ADDR
// end ;
46888: LD_VAR 0 3
46892: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46893: LD_INT 0
46895: PPUSH
// if not mc_bases or not base or not scan_area then
46896: LD_EXP 95
46900: NOT
46901: PUSH
46902: LD_VAR 0 1
46906: NOT
46907: OR
46908: PUSH
46909: LD_VAR 0 2
46913: NOT
46914: OR
46915: IFFALSE 46919
// exit ;
46917: GO 46944
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46919: LD_ADDR_EXP 120
46923: PUSH
46924: LD_EXP 120
46928: PPUSH
46929: LD_VAR 0 1
46933: PPUSH
46934: LD_VAR 0 2
46938: PPUSH
46939: CALL_OW 1
46943: ST_TO_ADDR
// end ;
46944: LD_VAR 0 3
46948: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46949: LD_INT 0
46951: PPUSH
46952: PPUSH
// if not mc_bases or not base then
46953: LD_EXP 95
46957: NOT
46958: PUSH
46959: LD_VAR 0 1
46963: NOT
46964: OR
46965: IFFALSE 46969
// exit ;
46967: GO 47033
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46969: LD_ADDR_VAR 0 3
46973: PUSH
46974: LD_INT 1
46976: PUSH
46977: LD_INT 2
46979: PUSH
46980: LD_INT 3
46982: PUSH
46983: LD_INT 4
46985: PUSH
46986: LD_INT 11
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46996: LD_ADDR_EXP 122
47000: PUSH
47001: LD_EXP 122
47005: PPUSH
47006: LD_VAR 0 1
47010: PPUSH
47011: LD_EXP 122
47015: PUSH
47016: LD_VAR 0 1
47020: ARRAY
47021: PUSH
47022: LD_VAR 0 3
47026: DIFF
47027: PPUSH
47028: CALL_OW 1
47032: ST_TO_ADDR
// end ;
47033: LD_VAR 0 2
47037: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47038: LD_INT 0
47040: PPUSH
// result := mc_vehicles [ base ] ;
47041: LD_ADDR_VAR 0 3
47045: PUSH
47046: LD_EXP 114
47050: PUSH
47051: LD_VAR 0 1
47055: ARRAY
47056: ST_TO_ADDR
// if onlyCombat then
47057: LD_VAR 0 2
47061: IFFALSE 47239
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47063: LD_ADDR_VAR 0 3
47067: PUSH
47068: LD_VAR 0 3
47072: PUSH
47073: LD_VAR 0 3
47077: PPUSH
47078: LD_INT 2
47080: PUSH
47081: LD_INT 34
47083: PUSH
47084: LD_INT 12
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: LD_INT 34
47093: PUSH
47094: LD_INT 51
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 34
47103: PUSH
47104: LD_EXP 75
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 34
47115: PUSH
47116: LD_INT 32
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: LD_INT 34
47125: PUSH
47126: LD_INT 13
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 34
47135: PUSH
47136: LD_INT 52
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: PUSH
47143: LD_INT 34
47145: PUSH
47146: LD_EXP 80
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 34
47157: PUSH
47158: LD_INT 14
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 34
47167: PUSH
47168: LD_INT 53
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 34
47177: PUSH
47178: LD_EXP 74
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PUSH
47187: LD_INT 34
47189: PUSH
47190: LD_INT 31
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 34
47199: PUSH
47200: LD_INT 48
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 34
47209: PUSH
47210: LD_INT 8
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: PPUSH
47233: CALL_OW 72
47237: DIFF
47238: ST_TO_ADDR
// end ; end_of_file
47239: LD_VAR 0 3
47243: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47244: LD_INT 0
47246: PPUSH
47247: PPUSH
47248: PPUSH
// if not mc_bases or not skirmish then
47249: LD_EXP 95
47253: NOT
47254: PUSH
47255: LD_EXP 93
47259: NOT
47260: OR
47261: IFFALSE 47265
// exit ;
47263: GO 47430
// for i = 1 to mc_bases do
47265: LD_ADDR_VAR 0 4
47269: PUSH
47270: DOUBLE
47271: LD_INT 1
47273: DEC
47274: ST_TO_ADDR
47275: LD_EXP 95
47279: PUSH
47280: FOR_TO
47281: IFFALSE 47428
// begin if sci in mc_bases [ i ] then
47283: LD_VAR 0 2
47287: PUSH
47288: LD_EXP 95
47292: PUSH
47293: LD_VAR 0 4
47297: ARRAY
47298: IN
47299: IFFALSE 47426
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47301: LD_ADDR_EXP 124
47305: PUSH
47306: LD_EXP 124
47310: PPUSH
47311: LD_VAR 0 4
47315: PUSH
47316: LD_EXP 124
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: PUSH
47327: LD_INT 1
47329: PLUS
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PPUSH
47335: LD_VAR 0 1
47339: PPUSH
47340: CALL 57012 0 3
47344: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47345: LD_ADDR_VAR 0 5
47349: PUSH
47350: LD_EXP 95
47354: PUSH
47355: LD_VAR 0 4
47359: ARRAY
47360: PPUSH
47361: LD_INT 2
47363: PUSH
47364: LD_INT 30
47366: PUSH
47367: LD_INT 0
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: PUSH
47374: LD_INT 30
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: LIST
47388: PPUSH
47389: CALL_OW 72
47393: PPUSH
47394: LD_VAR 0 1
47398: PPUSH
47399: CALL_OW 74
47403: ST_TO_ADDR
// if tmp then
47404: LD_VAR 0 5
47408: IFFALSE 47424
// ComStandNearbyBuilding ( ape , tmp ) ;
47410: LD_VAR 0 1
47414: PPUSH
47415: LD_VAR 0 5
47419: PPUSH
47420: CALL 53590 0 2
// break ;
47424: GO 47428
// end ; end ;
47426: GO 47280
47428: POP
47429: POP
// end ;
47430: LD_VAR 0 3
47434: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47435: LD_INT 0
47437: PPUSH
47438: PPUSH
47439: PPUSH
// if not mc_bases or not skirmish then
47440: LD_EXP 95
47444: NOT
47445: PUSH
47446: LD_EXP 93
47450: NOT
47451: OR
47452: IFFALSE 47456
// exit ;
47454: GO 47545
// for i = 1 to mc_bases do
47456: LD_ADDR_VAR 0 4
47460: PUSH
47461: DOUBLE
47462: LD_INT 1
47464: DEC
47465: ST_TO_ADDR
47466: LD_EXP 95
47470: PUSH
47471: FOR_TO
47472: IFFALSE 47543
// begin if building in mc_busy_turret_list [ i ] then
47474: LD_VAR 0 1
47478: PUSH
47479: LD_EXP 105
47483: PUSH
47484: LD_VAR 0 4
47488: ARRAY
47489: IN
47490: IFFALSE 47541
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47492: LD_ADDR_VAR 0 5
47496: PUSH
47497: LD_EXP 105
47501: PUSH
47502: LD_VAR 0 4
47506: ARRAY
47507: PUSH
47508: LD_VAR 0 1
47512: DIFF
47513: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47514: LD_ADDR_EXP 105
47518: PUSH
47519: LD_EXP 105
47523: PPUSH
47524: LD_VAR 0 4
47528: PPUSH
47529: LD_VAR 0 5
47533: PPUSH
47534: CALL_OW 1
47538: ST_TO_ADDR
// break ;
47539: GO 47543
// end ; end ;
47541: GO 47471
47543: POP
47544: POP
// end ;
47545: LD_VAR 0 3
47549: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47550: LD_INT 0
47552: PPUSH
47553: PPUSH
47554: PPUSH
// if not mc_bases or not skirmish then
47555: LD_EXP 95
47559: NOT
47560: PUSH
47561: LD_EXP 93
47565: NOT
47566: OR
47567: IFFALSE 47571
// exit ;
47569: GO 47770
// for i = 1 to mc_bases do
47571: LD_ADDR_VAR 0 5
47575: PUSH
47576: DOUBLE
47577: LD_INT 1
47579: DEC
47580: ST_TO_ADDR
47581: LD_EXP 95
47585: PUSH
47586: FOR_TO
47587: IFFALSE 47768
// if building in mc_bases [ i ] then
47589: LD_VAR 0 1
47593: PUSH
47594: LD_EXP 95
47598: PUSH
47599: LD_VAR 0 5
47603: ARRAY
47604: IN
47605: IFFALSE 47766
// begin tmp := mc_bases [ i ] diff building ;
47607: LD_ADDR_VAR 0 6
47611: PUSH
47612: LD_EXP 95
47616: PUSH
47617: LD_VAR 0 5
47621: ARRAY
47622: PUSH
47623: LD_VAR 0 1
47627: DIFF
47628: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47629: LD_ADDR_EXP 95
47633: PUSH
47634: LD_EXP 95
47638: PPUSH
47639: LD_VAR 0 5
47643: PPUSH
47644: LD_VAR 0 6
47648: PPUSH
47649: CALL_OW 1
47653: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47654: LD_VAR 0 1
47658: PUSH
47659: LD_EXP 103
47663: PUSH
47664: LD_VAR 0 5
47668: ARRAY
47669: IN
47670: IFFALSE 47709
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47672: LD_ADDR_EXP 103
47676: PUSH
47677: LD_EXP 103
47681: PPUSH
47682: LD_VAR 0 5
47686: PPUSH
47687: LD_EXP 103
47691: PUSH
47692: LD_VAR 0 5
47696: ARRAY
47697: PUSH
47698: LD_VAR 0 1
47702: DIFF
47703: PPUSH
47704: CALL_OW 1
47708: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47709: LD_VAR 0 1
47713: PUSH
47714: LD_EXP 104
47718: PUSH
47719: LD_VAR 0 5
47723: ARRAY
47724: IN
47725: IFFALSE 47764
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47727: LD_ADDR_EXP 104
47731: PUSH
47732: LD_EXP 104
47736: PPUSH
47737: LD_VAR 0 5
47741: PPUSH
47742: LD_EXP 104
47746: PUSH
47747: LD_VAR 0 5
47751: ARRAY
47752: PUSH
47753: LD_VAR 0 1
47757: DIFF
47758: PPUSH
47759: CALL_OW 1
47763: ST_TO_ADDR
// break ;
47764: GO 47768
// end ;
47766: GO 47586
47768: POP
47769: POP
// end ;
47770: LD_VAR 0 4
47774: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47775: LD_INT 0
47777: PPUSH
47778: PPUSH
47779: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47780: LD_EXP 95
47784: NOT
47785: PUSH
47786: LD_EXP 93
47790: NOT
47791: OR
47792: PUSH
47793: LD_VAR 0 3
47797: PUSH
47798: LD_EXP 121
47802: IN
47803: NOT
47804: OR
47805: IFFALSE 47809
// exit ;
47807: GO 47932
// for i = 1 to mc_vehicles do
47809: LD_ADDR_VAR 0 6
47813: PUSH
47814: DOUBLE
47815: LD_INT 1
47817: DEC
47818: ST_TO_ADDR
47819: LD_EXP 114
47823: PUSH
47824: FOR_TO
47825: IFFALSE 47930
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47827: LD_VAR 0 2
47831: PUSH
47832: LD_EXP 114
47836: PUSH
47837: LD_VAR 0 6
47841: ARRAY
47842: IN
47843: PUSH
47844: LD_VAR 0 1
47848: PUSH
47849: LD_EXP 114
47853: PUSH
47854: LD_VAR 0 6
47858: ARRAY
47859: IN
47860: OR
47861: IFFALSE 47928
// begin tmp := mc_vehicles [ i ] diff old ;
47863: LD_ADDR_VAR 0 7
47867: PUSH
47868: LD_EXP 114
47872: PUSH
47873: LD_VAR 0 6
47877: ARRAY
47878: PUSH
47879: LD_VAR 0 2
47883: DIFF
47884: ST_TO_ADDR
// tmp := tmp diff new ;
47885: LD_ADDR_VAR 0 7
47889: PUSH
47890: LD_VAR 0 7
47894: PUSH
47895: LD_VAR 0 1
47899: DIFF
47900: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47901: LD_ADDR_EXP 114
47905: PUSH
47906: LD_EXP 114
47910: PPUSH
47911: LD_VAR 0 6
47915: PPUSH
47916: LD_VAR 0 7
47920: PPUSH
47921: CALL_OW 1
47925: ST_TO_ADDR
// break ;
47926: GO 47930
// end ;
47928: GO 47824
47930: POP
47931: POP
// end ;
47932: LD_VAR 0 5
47936: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47937: LD_INT 0
47939: PPUSH
47940: PPUSH
47941: PPUSH
47942: PPUSH
// if not mc_bases or not skirmish then
47943: LD_EXP 95
47947: NOT
47948: PUSH
47949: LD_EXP 93
47953: NOT
47954: OR
47955: IFFALSE 47959
// exit ;
47957: GO 48351
// side := GetSide ( vehicle ) ;
47959: LD_ADDR_VAR 0 5
47963: PUSH
47964: LD_VAR 0 1
47968: PPUSH
47969: CALL_OW 255
47973: ST_TO_ADDR
// for i = 1 to mc_bases do
47974: LD_ADDR_VAR 0 4
47978: PUSH
47979: DOUBLE
47980: LD_INT 1
47982: DEC
47983: ST_TO_ADDR
47984: LD_EXP 95
47988: PUSH
47989: FOR_TO
47990: IFFALSE 48349
// begin if factory in mc_bases [ i ] then
47992: LD_VAR 0 2
47996: PUSH
47997: LD_EXP 95
48001: PUSH
48002: LD_VAR 0 4
48006: ARRAY
48007: IN
48008: IFFALSE 48347
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48010: LD_EXP 117
48014: PUSH
48015: LD_VAR 0 4
48019: ARRAY
48020: PUSH
48021: LD_EXP 106
48025: PUSH
48026: LD_VAR 0 4
48030: ARRAY
48031: LESS
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: CALL_OW 264
48042: PUSH
48043: LD_INT 31
48045: PUSH
48046: LD_INT 32
48048: PUSH
48049: LD_INT 51
48051: PUSH
48052: LD_EXP 75
48056: PUSH
48057: LD_INT 12
48059: PUSH
48060: LD_INT 30
48062: PUSH
48063: LD_EXP 74
48067: PUSH
48068: LD_INT 11
48070: PUSH
48071: LD_INT 53
48073: PUSH
48074: LD_INT 14
48076: PUSH
48077: LD_EXP 78
48081: PUSH
48082: LD_INT 29
48084: PUSH
48085: LD_EXP 76
48089: PUSH
48090: LD_INT 13
48092: PUSH
48093: LD_INT 52
48095: PUSH
48096: LD_EXP 80
48100: PUSH
48101: LD_INT 48
48103: PUSH
48104: LD_INT 8
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: IN
48127: NOT
48128: AND
48129: IFFALSE 48177
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48131: LD_ADDR_EXP 117
48135: PUSH
48136: LD_EXP 117
48140: PPUSH
48141: LD_VAR 0 4
48145: PUSH
48146: LD_EXP 117
48150: PUSH
48151: LD_VAR 0 4
48155: ARRAY
48156: PUSH
48157: LD_INT 1
48159: PLUS
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PPUSH
48165: LD_VAR 0 1
48169: PPUSH
48170: CALL 57012 0 3
48174: ST_TO_ADDR
48175: GO 48221
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48177: LD_ADDR_EXP 114
48181: PUSH
48182: LD_EXP 114
48186: PPUSH
48187: LD_VAR 0 4
48191: PUSH
48192: LD_EXP 114
48196: PUSH
48197: LD_VAR 0 4
48201: ARRAY
48202: PUSH
48203: LD_INT 1
48205: PLUS
48206: PUSH
48207: EMPTY
48208: LIST
48209: LIST
48210: PPUSH
48211: LD_VAR 0 1
48215: PPUSH
48216: CALL 57012 0 3
48220: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48221: LD_VAR 0 1
48225: PPUSH
48226: CALL_OW 263
48230: PUSH
48231: LD_INT 2
48233: EQUAL
48234: IFFALSE 48263
// begin repeat wait ( 0 0$3 ) ;
48236: LD_INT 105
48238: PPUSH
48239: CALL_OW 67
// Connect ( vehicle ) ;
48243: LD_VAR 0 1
48247: PPUSH
48248: CALL 59983 0 1
// until IsControledBy ( vehicle ) ;
48252: LD_VAR 0 1
48256: PPUSH
48257: CALL_OW 312
48261: IFFALSE 48236
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48263: LD_VAR 0 1
48267: PPUSH
48268: LD_EXP 119
48272: PUSH
48273: LD_VAR 0 4
48277: ARRAY
48278: PPUSH
48279: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48283: LD_VAR 0 1
48287: PPUSH
48288: CALL_OW 263
48292: PUSH
48293: LD_INT 1
48295: NONEQUAL
48296: IFFALSE 48300
// break ;
48298: GO 48349
// repeat wait ( 0 0$1 ) ;
48300: LD_INT 35
48302: PPUSH
48303: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48307: LD_VAR 0 1
48311: PPUSH
48312: LD_EXP 119
48316: PUSH
48317: LD_VAR 0 4
48321: ARRAY
48322: PPUSH
48323: CALL_OW 308
48327: IFFALSE 48300
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48329: LD_VAR 0 1
48333: PPUSH
48334: CALL_OW 311
48338: PPUSH
48339: CALL_OW 121
// exit ;
48343: POP
48344: POP
48345: GO 48351
// end ; end ;
48347: GO 47989
48349: POP
48350: POP
// end ;
48351: LD_VAR 0 3
48355: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48356: LD_INT 0
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
// if not mc_bases or not skirmish then
48362: LD_EXP 95
48366: NOT
48367: PUSH
48368: LD_EXP 93
48372: NOT
48373: OR
48374: IFFALSE 48378
// exit ;
48376: GO 48731
// repeat wait ( 0 0$1 ) ;
48378: LD_INT 35
48380: PPUSH
48381: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48385: LD_VAR 0 2
48389: PPUSH
48390: LD_VAR 0 3
48394: PPUSH
48395: CALL_OW 284
48399: IFFALSE 48378
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48401: LD_VAR 0 2
48405: PPUSH
48406: LD_VAR 0 3
48410: PPUSH
48411: CALL_OW 283
48415: PUSH
48416: LD_INT 4
48418: EQUAL
48419: IFFALSE 48423
// exit ;
48421: GO 48731
// for i = 1 to mc_bases do
48423: LD_ADDR_VAR 0 7
48427: PUSH
48428: DOUBLE
48429: LD_INT 1
48431: DEC
48432: ST_TO_ADDR
48433: LD_EXP 95
48437: PUSH
48438: FOR_TO
48439: IFFALSE 48729
// begin if mc_crates_area [ i ] then
48441: LD_EXP 113
48445: PUSH
48446: LD_VAR 0 7
48450: ARRAY
48451: IFFALSE 48562
// for j in mc_crates_area [ i ] do
48453: LD_ADDR_VAR 0 8
48457: PUSH
48458: LD_EXP 113
48462: PUSH
48463: LD_VAR 0 7
48467: ARRAY
48468: PUSH
48469: FOR_IN
48470: IFFALSE 48560
// if InArea ( x , y , j ) then
48472: LD_VAR 0 2
48476: PPUSH
48477: LD_VAR 0 3
48481: PPUSH
48482: LD_VAR 0 8
48486: PPUSH
48487: CALL_OW 309
48491: IFFALSE 48558
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48493: LD_ADDR_EXP 111
48497: PUSH
48498: LD_EXP 111
48502: PPUSH
48503: LD_VAR 0 7
48507: PUSH
48508: LD_EXP 111
48512: PUSH
48513: LD_VAR 0 7
48517: ARRAY
48518: PUSH
48519: LD_INT 1
48521: PLUS
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PPUSH
48527: LD_VAR 0 4
48531: PUSH
48532: LD_VAR 0 2
48536: PUSH
48537: LD_VAR 0 3
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: PPUSH
48547: CALL 57012 0 3
48551: ST_TO_ADDR
// exit ;
48552: POP
48553: POP
48554: POP
48555: POP
48556: GO 48731
// end ;
48558: GO 48469
48560: POP
48561: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48562: LD_ADDR_VAR 0 9
48566: PUSH
48567: LD_EXP 95
48571: PUSH
48572: LD_VAR 0 7
48576: ARRAY
48577: PPUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 30
48583: PUSH
48584: LD_INT 0
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 30
48593: PUSH
48594: LD_INT 1
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: LIST
48605: PPUSH
48606: CALL_OW 72
48610: ST_TO_ADDR
// if not depot then
48611: LD_VAR 0 9
48615: NOT
48616: IFFALSE 48620
// continue ;
48618: GO 48438
// for j in depot do
48620: LD_ADDR_VAR 0 8
48624: PUSH
48625: LD_VAR 0 9
48629: PUSH
48630: FOR_IN
48631: IFFALSE 48725
// if GetDistUnitXY ( j , x , y ) < 30 then
48633: LD_VAR 0 8
48637: PPUSH
48638: LD_VAR 0 2
48642: PPUSH
48643: LD_VAR 0 3
48647: PPUSH
48648: CALL_OW 297
48652: PUSH
48653: LD_INT 30
48655: LESS
48656: IFFALSE 48723
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48658: LD_ADDR_EXP 111
48662: PUSH
48663: LD_EXP 111
48667: PPUSH
48668: LD_VAR 0 7
48672: PUSH
48673: LD_EXP 111
48677: PUSH
48678: LD_VAR 0 7
48682: ARRAY
48683: PUSH
48684: LD_INT 1
48686: PLUS
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PPUSH
48692: LD_VAR 0 4
48696: PUSH
48697: LD_VAR 0 2
48701: PUSH
48702: LD_VAR 0 3
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: LIST
48711: PPUSH
48712: CALL 57012 0 3
48716: ST_TO_ADDR
// exit ;
48717: POP
48718: POP
48719: POP
48720: POP
48721: GO 48731
// end ;
48723: GO 48630
48725: POP
48726: POP
// end ;
48727: GO 48438
48729: POP
48730: POP
// end ;
48731: LD_VAR 0 6
48735: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48736: LD_INT 0
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
// if not mc_bases or not skirmish then
48742: LD_EXP 95
48746: NOT
48747: PUSH
48748: LD_EXP 93
48752: NOT
48753: OR
48754: IFFALSE 48758
// exit ;
48756: GO 49035
// side := GetSide ( lab ) ;
48758: LD_ADDR_VAR 0 4
48762: PUSH
48763: LD_VAR 0 2
48767: PPUSH
48768: CALL_OW 255
48772: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48773: LD_VAR 0 4
48777: PUSH
48778: LD_EXP 121
48782: IN
48783: NOT
48784: PUSH
48785: LD_EXP 122
48789: NOT
48790: OR
48791: PUSH
48792: LD_EXP 95
48796: NOT
48797: OR
48798: IFFALSE 48802
// exit ;
48800: GO 49035
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48802: LD_ADDR_EXP 122
48806: PUSH
48807: LD_EXP 122
48811: PPUSH
48812: LD_VAR 0 4
48816: PPUSH
48817: LD_EXP 122
48821: PUSH
48822: LD_VAR 0 4
48826: ARRAY
48827: PUSH
48828: LD_VAR 0 1
48832: DIFF
48833: PPUSH
48834: CALL_OW 1
48838: ST_TO_ADDR
// for i = 1 to mc_bases do
48839: LD_ADDR_VAR 0 5
48843: PUSH
48844: DOUBLE
48845: LD_INT 1
48847: DEC
48848: ST_TO_ADDR
48849: LD_EXP 95
48853: PUSH
48854: FOR_TO
48855: IFFALSE 49033
// begin if lab in mc_bases [ i ] then
48857: LD_VAR 0 2
48861: PUSH
48862: LD_EXP 95
48866: PUSH
48867: LD_VAR 0 5
48871: ARRAY
48872: IN
48873: IFFALSE 49031
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48875: LD_VAR 0 1
48879: PUSH
48880: LD_INT 11
48882: PUSH
48883: LD_INT 4
48885: PUSH
48886: LD_INT 3
48888: PUSH
48889: LD_INT 2
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: IN
48898: PUSH
48899: LD_EXP 125
48903: PUSH
48904: LD_VAR 0 5
48908: ARRAY
48909: AND
48910: IFFALSE 49031
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48912: LD_ADDR_VAR 0 6
48916: PUSH
48917: LD_EXP 125
48921: PUSH
48922: LD_VAR 0 5
48926: ARRAY
48927: PUSH
48928: LD_INT 1
48930: ARRAY
48931: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48932: LD_ADDR_EXP 125
48936: PUSH
48937: LD_EXP 125
48941: PPUSH
48942: LD_VAR 0 5
48946: PPUSH
48947: EMPTY
48948: PPUSH
48949: CALL_OW 1
48953: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48954: LD_VAR 0 6
48958: PPUSH
48959: LD_INT 0
48961: PPUSH
48962: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48966: LD_VAR 0 6
48970: PPUSH
48971: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48975: LD_ADDR_EXP 124
48979: PUSH
48980: LD_EXP 124
48984: PPUSH
48985: LD_VAR 0 5
48989: PPUSH
48990: LD_EXP 124
48994: PUSH
48995: LD_VAR 0 5
48999: ARRAY
49000: PPUSH
49001: LD_INT 1
49003: PPUSH
49004: LD_VAR 0 6
49008: PPUSH
49009: CALL_OW 2
49013: PPUSH
49014: CALL_OW 1
49018: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49019: LD_VAR 0 5
49023: PPUSH
49024: LD_INT 112
49026: PPUSH
49027: CALL 25554 0 2
// end ; end ; end ;
49031: GO 48854
49033: POP
49034: POP
// end ;
49035: LD_VAR 0 3
49039: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49040: LD_INT 0
49042: PPUSH
49043: PPUSH
49044: PPUSH
49045: PPUSH
49046: PPUSH
49047: PPUSH
49048: PPUSH
49049: PPUSH
// if not mc_bases or not skirmish then
49050: LD_EXP 95
49054: NOT
49055: PUSH
49056: LD_EXP 93
49060: NOT
49061: OR
49062: IFFALSE 49066
// exit ;
49064: GO 50437
// for i = 1 to mc_bases do
49066: LD_ADDR_VAR 0 3
49070: PUSH
49071: DOUBLE
49072: LD_INT 1
49074: DEC
49075: ST_TO_ADDR
49076: LD_EXP 95
49080: PUSH
49081: FOR_TO
49082: IFFALSE 50435
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49084: LD_VAR 0 1
49088: PUSH
49089: LD_EXP 95
49093: PUSH
49094: LD_VAR 0 3
49098: ARRAY
49099: IN
49100: PUSH
49101: LD_VAR 0 1
49105: PUSH
49106: LD_EXP 102
49110: PUSH
49111: LD_VAR 0 3
49115: ARRAY
49116: IN
49117: OR
49118: PUSH
49119: LD_VAR 0 1
49123: PUSH
49124: LD_EXP 117
49128: PUSH
49129: LD_VAR 0 3
49133: ARRAY
49134: IN
49135: OR
49136: PUSH
49137: LD_VAR 0 1
49141: PUSH
49142: LD_EXP 114
49146: PUSH
49147: LD_VAR 0 3
49151: ARRAY
49152: IN
49153: OR
49154: PUSH
49155: LD_VAR 0 1
49159: PUSH
49160: LD_EXP 124
49164: PUSH
49165: LD_VAR 0 3
49169: ARRAY
49170: IN
49171: OR
49172: PUSH
49173: LD_VAR 0 1
49177: PUSH
49178: LD_EXP 125
49182: PUSH
49183: LD_VAR 0 3
49187: ARRAY
49188: IN
49189: OR
49190: IFFALSE 50433
// begin if un in mc_ape [ i ] then
49192: LD_VAR 0 1
49196: PUSH
49197: LD_EXP 124
49201: PUSH
49202: LD_VAR 0 3
49206: ARRAY
49207: IN
49208: IFFALSE 49247
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49210: LD_ADDR_EXP 124
49214: PUSH
49215: LD_EXP 124
49219: PPUSH
49220: LD_VAR 0 3
49224: PPUSH
49225: LD_EXP 124
49229: PUSH
49230: LD_VAR 0 3
49234: ARRAY
49235: PUSH
49236: LD_VAR 0 1
49240: DIFF
49241: PPUSH
49242: CALL_OW 1
49246: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49247: LD_VAR 0 1
49251: PUSH
49252: LD_EXP 125
49256: PUSH
49257: LD_VAR 0 3
49261: ARRAY
49262: IN
49263: IFFALSE 49287
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49265: LD_ADDR_EXP 125
49269: PUSH
49270: LD_EXP 125
49274: PPUSH
49275: LD_VAR 0 3
49279: PPUSH
49280: EMPTY
49281: PPUSH
49282: CALL_OW 1
49286: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49287: LD_VAR 0 1
49291: PPUSH
49292: CALL_OW 247
49296: PUSH
49297: LD_INT 2
49299: EQUAL
49300: PUSH
49301: LD_VAR 0 1
49305: PPUSH
49306: CALL_OW 110
49310: PUSH
49311: LD_INT 20
49313: EQUAL
49314: PUSH
49315: LD_VAR 0 1
49319: PUSH
49320: LD_EXP 117
49324: PUSH
49325: LD_VAR 0 3
49329: ARRAY
49330: IN
49331: OR
49332: PUSH
49333: LD_VAR 0 1
49337: PPUSH
49338: CALL_OW 264
49342: PUSH
49343: LD_INT 12
49345: PUSH
49346: LD_INT 51
49348: PUSH
49349: LD_EXP 75
49353: PUSH
49354: LD_INT 32
49356: PUSH
49357: LD_INT 13
49359: PUSH
49360: LD_INT 52
49362: PUSH
49363: LD_INT 31
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: IN
49375: OR
49376: AND
49377: IFFALSE 49685
// begin if un in mc_defender [ i ] then
49379: LD_VAR 0 1
49383: PUSH
49384: LD_EXP 117
49388: PUSH
49389: LD_VAR 0 3
49393: ARRAY
49394: IN
49395: IFFALSE 49434
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49397: LD_ADDR_EXP 117
49401: PUSH
49402: LD_EXP 117
49406: PPUSH
49407: LD_VAR 0 3
49411: PPUSH
49412: LD_EXP 117
49416: PUSH
49417: LD_VAR 0 3
49421: ARRAY
49422: PUSH
49423: LD_VAR 0 1
49427: DIFF
49428: PPUSH
49429: CALL_OW 1
49433: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49434: LD_ADDR_VAR 0 8
49438: PUSH
49439: LD_VAR 0 3
49443: PPUSH
49444: LD_INT 3
49446: PPUSH
49447: CALL 46075 0 2
49451: ST_TO_ADDR
// if fac then
49452: LD_VAR 0 8
49456: IFFALSE 49685
// begin for j in fac do
49458: LD_ADDR_VAR 0 4
49462: PUSH
49463: LD_VAR 0 8
49467: PUSH
49468: FOR_IN
49469: IFFALSE 49683
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49471: LD_ADDR_VAR 0 9
49475: PUSH
49476: LD_VAR 0 8
49480: PPUSH
49481: LD_VAR 0 1
49485: PPUSH
49486: CALL_OW 265
49490: PPUSH
49491: LD_VAR 0 1
49495: PPUSH
49496: CALL_OW 262
49500: PPUSH
49501: LD_VAR 0 1
49505: PPUSH
49506: CALL_OW 263
49510: PPUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: CALL_OW 264
49520: PPUSH
49521: CALL 54508 0 5
49525: ST_TO_ADDR
// if components then
49526: LD_VAR 0 9
49530: IFFALSE 49681
// begin if GetWeapon ( un ) = ar_control_tower then
49532: LD_VAR 0 1
49536: PPUSH
49537: CALL_OW 264
49541: PUSH
49542: LD_INT 31
49544: EQUAL
49545: IFFALSE 49662
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 311
49556: PPUSH
49557: LD_INT 0
49559: PPUSH
49560: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49564: LD_ADDR_EXP 135
49568: PUSH
49569: LD_EXP 135
49573: PPUSH
49574: LD_VAR 0 3
49578: PPUSH
49579: LD_EXP 135
49583: PUSH
49584: LD_VAR 0 3
49588: ARRAY
49589: PUSH
49590: LD_VAR 0 1
49594: PPUSH
49595: CALL_OW 311
49599: DIFF
49600: PPUSH
49601: CALL_OW 1
49605: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49606: LD_ADDR_VAR 0 7
49610: PUSH
49611: LD_EXP 116
49615: PUSH
49616: LD_VAR 0 3
49620: ARRAY
49621: PPUSH
49622: LD_INT 1
49624: PPUSH
49625: LD_VAR 0 9
49629: PPUSH
49630: CALL_OW 2
49634: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49635: LD_ADDR_EXP 116
49639: PUSH
49640: LD_EXP 116
49644: PPUSH
49645: LD_VAR 0 3
49649: PPUSH
49650: LD_VAR 0 7
49654: PPUSH
49655: CALL_OW 1
49659: ST_TO_ADDR
// end else
49660: GO 49679
// MC_InsertProduceList ( i , [ components ] ) ;
49662: LD_VAR 0 3
49666: PPUSH
49667: LD_VAR 0 9
49671: PUSH
49672: EMPTY
49673: LIST
49674: PPUSH
49675: CALL 45620 0 2
// break ;
49679: GO 49683
// end ; end ;
49681: GO 49468
49683: POP
49684: POP
// end ; end ; if GetType ( un ) = unit_building then
49685: LD_VAR 0 1
49689: PPUSH
49690: CALL_OW 247
49694: PUSH
49695: LD_INT 3
49697: EQUAL
49698: IFFALSE 50101
// begin btype := GetBType ( un ) ;
49700: LD_ADDR_VAR 0 5
49704: PUSH
49705: LD_VAR 0 1
49709: PPUSH
49710: CALL_OW 266
49714: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49715: LD_VAR 0 5
49719: PUSH
49720: LD_INT 29
49722: PUSH
49723: LD_INT 30
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: IN
49730: IFFALSE 49803
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49732: LD_VAR 0 1
49736: PPUSH
49737: CALL_OW 250
49741: PPUSH
49742: LD_VAR 0 1
49746: PPUSH
49747: CALL_OW 251
49751: PPUSH
49752: LD_VAR 0 1
49756: PPUSH
49757: CALL_OW 255
49761: PPUSH
49762: CALL_OW 440
49766: NOT
49767: IFFALSE 49803
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49769: LD_VAR 0 1
49773: PPUSH
49774: CALL_OW 250
49778: PPUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL_OW 251
49788: PPUSH
49789: LD_VAR 0 1
49793: PPUSH
49794: CALL_OW 255
49798: PPUSH
49799: CALL_OW 441
// end ; if btype = b_warehouse then
49803: LD_VAR 0 5
49807: PUSH
49808: LD_INT 1
49810: EQUAL
49811: IFFALSE 49829
// begin btype := b_depot ;
49813: LD_ADDR_VAR 0 5
49817: PUSH
49818: LD_INT 0
49820: ST_TO_ADDR
// pos := 1 ;
49821: LD_ADDR_VAR 0 6
49825: PUSH
49826: LD_INT 1
49828: ST_TO_ADDR
// end ; if btype = b_factory then
49829: LD_VAR 0 5
49833: PUSH
49834: LD_INT 3
49836: EQUAL
49837: IFFALSE 49855
// begin btype := b_workshop ;
49839: LD_ADDR_VAR 0 5
49843: PUSH
49844: LD_INT 2
49846: ST_TO_ADDR
// pos := 1 ;
49847: LD_ADDR_VAR 0 6
49851: PUSH
49852: LD_INT 1
49854: ST_TO_ADDR
// end ; if btype = b_barracks then
49855: LD_VAR 0 5
49859: PUSH
49860: LD_INT 5
49862: EQUAL
49863: IFFALSE 49873
// btype := b_armoury ;
49865: LD_ADDR_VAR 0 5
49869: PUSH
49870: LD_INT 4
49872: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49873: LD_VAR 0 5
49877: PUSH
49878: LD_INT 7
49880: PUSH
49881: LD_INT 8
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: IN
49888: IFFALSE 49898
// btype := b_lab ;
49890: LD_ADDR_VAR 0 5
49894: PUSH
49895: LD_INT 6
49897: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49898: LD_ADDR_EXP 100
49902: PUSH
49903: LD_EXP 100
49907: PPUSH
49908: LD_VAR 0 3
49912: PUSH
49913: LD_EXP 100
49917: PUSH
49918: LD_VAR 0 3
49922: ARRAY
49923: PUSH
49924: LD_INT 1
49926: PLUS
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: PPUSH
49932: LD_VAR 0 5
49936: PUSH
49937: LD_VAR 0 1
49941: PPUSH
49942: CALL_OW 250
49946: PUSH
49947: LD_VAR 0 1
49951: PPUSH
49952: CALL_OW 251
49956: PUSH
49957: LD_VAR 0 1
49961: PPUSH
49962: CALL_OW 254
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: PPUSH
49973: CALL 57012 0 3
49977: ST_TO_ADDR
// if pos = 1 then
49978: LD_VAR 0 6
49982: PUSH
49983: LD_INT 1
49985: EQUAL
49986: IFFALSE 50101
// begin tmp := mc_build_list [ i ] ;
49988: LD_ADDR_VAR 0 7
49992: PUSH
49993: LD_EXP 100
49997: PUSH
49998: LD_VAR 0 3
50002: ARRAY
50003: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50004: LD_VAR 0 7
50008: PPUSH
50009: LD_INT 2
50011: PUSH
50012: LD_INT 30
50014: PUSH
50015: LD_INT 0
50017: PUSH
50018: EMPTY
50019: LIST
50020: LIST
50021: PUSH
50022: LD_INT 30
50024: PUSH
50025: LD_INT 1
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: LIST
50036: PPUSH
50037: CALL_OW 72
50041: IFFALSE 50051
// pos := 2 ;
50043: LD_ADDR_VAR 0 6
50047: PUSH
50048: LD_INT 2
50050: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50051: LD_ADDR_VAR 0 7
50055: PUSH
50056: LD_VAR 0 7
50060: PPUSH
50061: LD_VAR 0 6
50065: PPUSH
50066: LD_VAR 0 7
50070: PPUSH
50071: CALL 57338 0 3
50075: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50076: LD_ADDR_EXP 100
50080: PUSH
50081: LD_EXP 100
50085: PPUSH
50086: LD_VAR 0 3
50090: PPUSH
50091: LD_VAR 0 7
50095: PPUSH
50096: CALL_OW 1
50100: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50101: LD_VAR 0 1
50105: PUSH
50106: LD_EXP 95
50110: PUSH
50111: LD_VAR 0 3
50115: ARRAY
50116: IN
50117: IFFALSE 50156
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50119: LD_ADDR_EXP 95
50123: PUSH
50124: LD_EXP 95
50128: PPUSH
50129: LD_VAR 0 3
50133: PPUSH
50134: LD_EXP 95
50138: PUSH
50139: LD_VAR 0 3
50143: ARRAY
50144: PUSH
50145: LD_VAR 0 1
50149: DIFF
50150: PPUSH
50151: CALL_OW 1
50155: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50156: LD_VAR 0 1
50160: PUSH
50161: LD_EXP 102
50165: PUSH
50166: LD_VAR 0 3
50170: ARRAY
50171: IN
50172: IFFALSE 50211
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50174: LD_ADDR_EXP 102
50178: PUSH
50179: LD_EXP 102
50183: PPUSH
50184: LD_VAR 0 3
50188: PPUSH
50189: LD_EXP 102
50193: PUSH
50194: LD_VAR 0 3
50198: ARRAY
50199: PUSH
50200: LD_VAR 0 1
50204: DIFF
50205: PPUSH
50206: CALL_OW 1
50210: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50211: LD_VAR 0 1
50215: PUSH
50216: LD_EXP 114
50220: PUSH
50221: LD_VAR 0 3
50225: ARRAY
50226: IN
50227: IFFALSE 50266
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50229: LD_ADDR_EXP 114
50233: PUSH
50234: LD_EXP 114
50238: PPUSH
50239: LD_VAR 0 3
50243: PPUSH
50244: LD_EXP 114
50248: PUSH
50249: LD_VAR 0 3
50253: ARRAY
50254: PUSH
50255: LD_VAR 0 1
50259: DIFF
50260: PPUSH
50261: CALL_OW 1
50265: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50266: LD_VAR 0 1
50270: PUSH
50271: LD_EXP 117
50275: PUSH
50276: LD_VAR 0 3
50280: ARRAY
50281: IN
50282: IFFALSE 50321
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50284: LD_ADDR_EXP 117
50288: PUSH
50289: LD_EXP 117
50293: PPUSH
50294: LD_VAR 0 3
50298: PPUSH
50299: LD_EXP 117
50303: PUSH
50304: LD_VAR 0 3
50308: ARRAY
50309: PUSH
50310: LD_VAR 0 1
50314: DIFF
50315: PPUSH
50316: CALL_OW 1
50320: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50321: LD_VAR 0 1
50325: PUSH
50326: LD_EXP 104
50330: PUSH
50331: LD_VAR 0 3
50335: ARRAY
50336: IN
50337: IFFALSE 50376
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50339: LD_ADDR_EXP 104
50343: PUSH
50344: LD_EXP 104
50348: PPUSH
50349: LD_VAR 0 3
50353: PPUSH
50354: LD_EXP 104
50358: PUSH
50359: LD_VAR 0 3
50363: ARRAY
50364: PUSH
50365: LD_VAR 0 1
50369: DIFF
50370: PPUSH
50371: CALL_OW 1
50375: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50376: LD_VAR 0 1
50380: PUSH
50381: LD_EXP 103
50385: PUSH
50386: LD_VAR 0 3
50390: ARRAY
50391: IN
50392: IFFALSE 50431
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50394: LD_ADDR_EXP 103
50398: PUSH
50399: LD_EXP 103
50403: PPUSH
50404: LD_VAR 0 3
50408: PPUSH
50409: LD_EXP 103
50413: PUSH
50414: LD_VAR 0 3
50418: ARRAY
50419: PUSH
50420: LD_VAR 0 1
50424: DIFF
50425: PPUSH
50426: CALL_OW 1
50430: ST_TO_ADDR
// end ; break ;
50431: GO 50435
// end ;
50433: GO 49081
50435: POP
50436: POP
// end ;
50437: LD_VAR 0 2
50441: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50442: LD_INT 0
50444: PPUSH
50445: PPUSH
50446: PPUSH
// if not mc_bases or not skirmish then
50447: LD_EXP 95
50451: NOT
50452: PUSH
50453: LD_EXP 93
50457: NOT
50458: OR
50459: IFFALSE 50463
// exit ;
50461: GO 50678
// for i = 1 to mc_bases do
50463: LD_ADDR_VAR 0 3
50467: PUSH
50468: DOUBLE
50469: LD_INT 1
50471: DEC
50472: ST_TO_ADDR
50473: LD_EXP 95
50477: PUSH
50478: FOR_TO
50479: IFFALSE 50676
// begin if building in mc_construct_list [ i ] then
50481: LD_VAR 0 1
50485: PUSH
50486: LD_EXP 102
50490: PUSH
50491: LD_VAR 0 3
50495: ARRAY
50496: IN
50497: IFFALSE 50674
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50499: LD_ADDR_EXP 102
50503: PUSH
50504: LD_EXP 102
50508: PPUSH
50509: LD_VAR 0 3
50513: PPUSH
50514: LD_EXP 102
50518: PUSH
50519: LD_VAR 0 3
50523: ARRAY
50524: PUSH
50525: LD_VAR 0 1
50529: DIFF
50530: PPUSH
50531: CALL_OW 1
50535: ST_TO_ADDR
// if building in mc_lab [ i ] then
50536: LD_VAR 0 1
50540: PUSH
50541: LD_EXP 128
50545: PUSH
50546: LD_VAR 0 3
50550: ARRAY
50551: IN
50552: IFFALSE 50607
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50554: LD_ADDR_EXP 129
50558: PUSH
50559: LD_EXP 129
50563: PPUSH
50564: LD_VAR 0 3
50568: PPUSH
50569: LD_EXP 129
50573: PUSH
50574: LD_VAR 0 3
50578: ARRAY
50579: PPUSH
50580: LD_INT 1
50582: PPUSH
50583: LD_EXP 129
50587: PUSH
50588: LD_VAR 0 3
50592: ARRAY
50593: PPUSH
50594: LD_INT 0
50596: PPUSH
50597: CALL 56430 0 4
50601: PPUSH
50602: CALL_OW 1
50606: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50607: LD_VAR 0 1
50611: PUSH
50612: LD_EXP 95
50616: PUSH
50617: LD_VAR 0 3
50621: ARRAY
50622: IN
50623: NOT
50624: IFFALSE 50670
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50626: LD_ADDR_EXP 95
50630: PUSH
50631: LD_EXP 95
50635: PPUSH
50636: LD_VAR 0 3
50640: PUSH
50641: LD_EXP 95
50645: PUSH
50646: LD_VAR 0 3
50650: ARRAY
50651: PUSH
50652: LD_INT 1
50654: PLUS
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PPUSH
50660: LD_VAR 0 1
50664: PPUSH
50665: CALL 57012 0 3
50669: ST_TO_ADDR
// exit ;
50670: POP
50671: POP
50672: GO 50678
// end ; end ;
50674: GO 50478
50676: POP
50677: POP
// end ;
50678: LD_VAR 0 2
50682: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50683: LD_INT 0
50685: PPUSH
50686: PPUSH
50687: PPUSH
50688: PPUSH
50689: PPUSH
50690: PPUSH
50691: PPUSH
// if not mc_bases or not skirmish then
50692: LD_EXP 95
50696: NOT
50697: PUSH
50698: LD_EXP 93
50702: NOT
50703: OR
50704: IFFALSE 50708
// exit ;
50706: GO 51369
// for i = 1 to mc_bases do
50708: LD_ADDR_VAR 0 3
50712: PUSH
50713: DOUBLE
50714: LD_INT 1
50716: DEC
50717: ST_TO_ADDR
50718: LD_EXP 95
50722: PUSH
50723: FOR_TO
50724: IFFALSE 51367
// begin if building in mc_construct_list [ i ] then
50726: LD_VAR 0 1
50730: PUSH
50731: LD_EXP 102
50735: PUSH
50736: LD_VAR 0 3
50740: ARRAY
50741: IN
50742: IFFALSE 51365
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50744: LD_ADDR_EXP 102
50748: PUSH
50749: LD_EXP 102
50753: PPUSH
50754: LD_VAR 0 3
50758: PPUSH
50759: LD_EXP 102
50763: PUSH
50764: LD_VAR 0 3
50768: ARRAY
50769: PUSH
50770: LD_VAR 0 1
50774: DIFF
50775: PPUSH
50776: CALL_OW 1
50780: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50781: LD_ADDR_EXP 95
50785: PUSH
50786: LD_EXP 95
50790: PPUSH
50791: LD_VAR 0 3
50795: PUSH
50796: LD_EXP 95
50800: PUSH
50801: LD_VAR 0 3
50805: ARRAY
50806: PUSH
50807: LD_INT 1
50809: PLUS
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PPUSH
50815: LD_VAR 0 1
50819: PPUSH
50820: CALL 57012 0 3
50824: ST_TO_ADDR
// btype := GetBType ( building ) ;
50825: LD_ADDR_VAR 0 5
50829: PUSH
50830: LD_VAR 0 1
50834: PPUSH
50835: CALL_OW 266
50839: ST_TO_ADDR
// side := GetSide ( building ) ;
50840: LD_ADDR_VAR 0 8
50844: PUSH
50845: LD_VAR 0 1
50849: PPUSH
50850: CALL_OW 255
50854: ST_TO_ADDR
// if btype = b_lab then
50855: LD_VAR 0 5
50859: PUSH
50860: LD_INT 6
50862: EQUAL
50863: IFFALSE 50913
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50865: LD_ADDR_EXP 128
50869: PUSH
50870: LD_EXP 128
50874: PPUSH
50875: LD_VAR 0 3
50879: PUSH
50880: LD_EXP 128
50884: PUSH
50885: LD_VAR 0 3
50889: ARRAY
50890: PUSH
50891: LD_INT 1
50893: PLUS
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PPUSH
50899: LD_VAR 0 1
50903: PPUSH
50904: CALL 57012 0 3
50908: ST_TO_ADDR
// exit ;
50909: POP
50910: POP
50911: GO 51369
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50913: LD_VAR 0 5
50917: PUSH
50918: LD_INT 0
50920: PUSH
50921: LD_INT 2
50923: PUSH
50924: LD_INT 4
50926: PUSH
50927: EMPTY
50928: LIST
50929: LIST
50930: LIST
50931: IN
50932: IFFALSE 51056
// begin if btype = b_armoury then
50934: LD_VAR 0 5
50938: PUSH
50939: LD_INT 4
50941: EQUAL
50942: IFFALSE 50952
// btype := b_barracks ;
50944: LD_ADDR_VAR 0 5
50948: PUSH
50949: LD_INT 5
50951: ST_TO_ADDR
// if btype = b_depot then
50952: LD_VAR 0 5
50956: PUSH
50957: LD_INT 0
50959: EQUAL
50960: IFFALSE 50970
// btype := b_warehouse ;
50962: LD_ADDR_VAR 0 5
50966: PUSH
50967: LD_INT 1
50969: ST_TO_ADDR
// if btype = b_workshop then
50970: LD_VAR 0 5
50974: PUSH
50975: LD_INT 2
50977: EQUAL
50978: IFFALSE 50988
// btype := b_factory ;
50980: LD_ADDR_VAR 0 5
50984: PUSH
50985: LD_INT 3
50987: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50988: LD_VAR 0 5
50992: PPUSH
50993: LD_VAR 0 8
50997: PPUSH
50998: CALL_OW 323
51002: PUSH
51003: LD_INT 1
51005: EQUAL
51006: IFFALSE 51052
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51008: LD_ADDR_EXP 127
51012: PUSH
51013: LD_EXP 127
51017: PPUSH
51018: LD_VAR 0 3
51022: PUSH
51023: LD_EXP 127
51027: PUSH
51028: LD_VAR 0 3
51032: ARRAY
51033: PUSH
51034: LD_INT 1
51036: PLUS
51037: PUSH
51038: EMPTY
51039: LIST
51040: LIST
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL 57012 0 3
51051: ST_TO_ADDR
// exit ;
51052: POP
51053: POP
51054: GO 51369
// end ; if btype in [ b_bunker , b_turret ] then
51056: LD_VAR 0 5
51060: PUSH
51061: LD_INT 32
51063: PUSH
51064: LD_INT 33
51066: PUSH
51067: EMPTY
51068: LIST
51069: LIST
51070: IN
51071: IFFALSE 51361
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51073: LD_ADDR_EXP 103
51077: PUSH
51078: LD_EXP 103
51082: PPUSH
51083: LD_VAR 0 3
51087: PUSH
51088: LD_EXP 103
51092: PUSH
51093: LD_VAR 0 3
51097: ARRAY
51098: PUSH
51099: LD_INT 1
51101: PLUS
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: PPUSH
51107: LD_VAR 0 1
51111: PPUSH
51112: CALL 57012 0 3
51116: ST_TO_ADDR
// if btype = b_bunker then
51117: LD_VAR 0 5
51121: PUSH
51122: LD_INT 32
51124: EQUAL
51125: IFFALSE 51361
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51127: LD_ADDR_EXP 104
51131: PUSH
51132: LD_EXP 104
51136: PPUSH
51137: LD_VAR 0 3
51141: PUSH
51142: LD_EXP 104
51146: PUSH
51147: LD_VAR 0 3
51151: ARRAY
51152: PUSH
51153: LD_INT 1
51155: PLUS
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PPUSH
51161: LD_VAR 0 1
51165: PPUSH
51166: CALL 57012 0 3
51170: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51171: LD_ADDR_VAR 0 6
51175: PUSH
51176: LD_EXP 95
51180: PUSH
51181: LD_VAR 0 3
51185: ARRAY
51186: PPUSH
51187: LD_INT 25
51189: PUSH
51190: LD_INT 1
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PUSH
51197: LD_INT 3
51199: PUSH
51200: LD_INT 54
51202: PUSH
51203: EMPTY
51204: LIST
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PPUSH
51214: CALL_OW 72
51218: ST_TO_ADDR
// if tmp then
51219: LD_VAR 0 6
51223: IFFALSE 51229
// exit ;
51225: POP
51226: POP
51227: GO 51369
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51229: LD_ADDR_VAR 0 6
51233: PUSH
51234: LD_EXP 95
51238: PUSH
51239: LD_VAR 0 3
51243: ARRAY
51244: PPUSH
51245: LD_INT 2
51247: PUSH
51248: LD_INT 30
51250: PUSH
51251: LD_INT 4
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 30
51260: PUSH
51261: LD_INT 5
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: LIST
51272: PPUSH
51273: CALL_OW 72
51277: ST_TO_ADDR
// if not tmp then
51278: LD_VAR 0 6
51282: NOT
51283: IFFALSE 51289
// exit ;
51285: POP
51286: POP
51287: GO 51369
// for j in tmp do
51289: LD_ADDR_VAR 0 4
51293: PUSH
51294: LD_VAR 0 6
51298: PUSH
51299: FOR_IN
51300: IFFALSE 51359
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51302: LD_ADDR_VAR 0 7
51306: PUSH
51307: LD_VAR 0 4
51311: PPUSH
51312: CALL_OW 313
51316: PPUSH
51317: LD_INT 25
51319: PUSH
51320: LD_INT 1
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: PPUSH
51327: CALL_OW 72
51331: ST_TO_ADDR
// if units then
51332: LD_VAR 0 7
51336: IFFALSE 51357
// begin ComExitBuilding ( units [ 1 ] ) ;
51338: LD_VAR 0 7
51342: PUSH
51343: LD_INT 1
51345: ARRAY
51346: PPUSH
51347: CALL_OW 122
// exit ;
51351: POP
51352: POP
51353: POP
51354: POP
51355: GO 51369
// end ; end ;
51357: GO 51299
51359: POP
51360: POP
// end ; end ; exit ;
51361: POP
51362: POP
51363: GO 51369
// end ; end ;
51365: GO 50723
51367: POP
51368: POP
// end ;
51369: LD_VAR 0 2
51373: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51374: LD_INT 0
51376: PPUSH
51377: PPUSH
51378: PPUSH
51379: PPUSH
51380: PPUSH
51381: PPUSH
51382: PPUSH
// if not mc_bases or not skirmish then
51383: LD_EXP 95
51387: NOT
51388: PUSH
51389: LD_EXP 93
51393: NOT
51394: OR
51395: IFFALSE 51399
// exit ;
51397: GO 51664
// btype := GetBType ( building ) ;
51399: LD_ADDR_VAR 0 6
51403: PUSH
51404: LD_VAR 0 1
51408: PPUSH
51409: CALL_OW 266
51413: ST_TO_ADDR
// x := GetX ( building ) ;
51414: LD_ADDR_VAR 0 7
51418: PUSH
51419: LD_VAR 0 1
51423: PPUSH
51424: CALL_OW 250
51428: ST_TO_ADDR
// y := GetY ( building ) ;
51429: LD_ADDR_VAR 0 8
51433: PUSH
51434: LD_VAR 0 1
51438: PPUSH
51439: CALL_OW 251
51443: ST_TO_ADDR
// d := GetDir ( building ) ;
51444: LD_ADDR_VAR 0 9
51448: PUSH
51449: LD_VAR 0 1
51453: PPUSH
51454: CALL_OW 254
51458: ST_TO_ADDR
// for i = 1 to mc_bases do
51459: LD_ADDR_VAR 0 4
51463: PUSH
51464: DOUBLE
51465: LD_INT 1
51467: DEC
51468: ST_TO_ADDR
51469: LD_EXP 95
51473: PUSH
51474: FOR_TO
51475: IFFALSE 51662
// begin if not mc_build_list [ i ] then
51477: LD_EXP 100
51481: PUSH
51482: LD_VAR 0 4
51486: ARRAY
51487: NOT
51488: IFFALSE 51492
// continue ;
51490: GO 51474
// for j := 1 to mc_build_list [ i ] do
51492: LD_ADDR_VAR 0 5
51496: PUSH
51497: DOUBLE
51498: LD_INT 1
51500: DEC
51501: ST_TO_ADDR
51502: LD_EXP 100
51506: PUSH
51507: LD_VAR 0 4
51511: ARRAY
51512: PUSH
51513: FOR_TO
51514: IFFALSE 51658
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51516: LD_VAR 0 6
51520: PUSH
51521: LD_VAR 0 7
51525: PUSH
51526: LD_VAR 0 8
51530: PUSH
51531: LD_VAR 0 9
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PPUSH
51542: LD_EXP 100
51546: PUSH
51547: LD_VAR 0 4
51551: ARRAY
51552: PUSH
51553: LD_VAR 0 5
51557: ARRAY
51558: PPUSH
51559: CALL 63194 0 2
51563: IFFALSE 51656
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51565: LD_ADDR_EXP 100
51569: PUSH
51570: LD_EXP 100
51574: PPUSH
51575: LD_VAR 0 4
51579: PPUSH
51580: LD_EXP 100
51584: PUSH
51585: LD_VAR 0 4
51589: ARRAY
51590: PPUSH
51591: LD_VAR 0 5
51595: PPUSH
51596: CALL_OW 3
51600: PPUSH
51601: CALL_OW 1
51605: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51606: LD_ADDR_EXP 102
51610: PUSH
51611: LD_EXP 102
51615: PPUSH
51616: LD_VAR 0 4
51620: PUSH
51621: LD_EXP 102
51625: PUSH
51626: LD_VAR 0 4
51630: ARRAY
51631: PUSH
51632: LD_INT 1
51634: PLUS
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PPUSH
51640: LD_VAR 0 1
51644: PPUSH
51645: CALL 57012 0 3
51649: ST_TO_ADDR
// exit ;
51650: POP
51651: POP
51652: POP
51653: POP
51654: GO 51664
// end ;
51656: GO 51513
51658: POP
51659: POP
// end ;
51660: GO 51474
51662: POP
51663: POP
// end ;
51664: LD_VAR 0 3
51668: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51669: LD_INT 0
51671: PPUSH
51672: PPUSH
51673: PPUSH
// if not mc_bases or not skirmish then
51674: LD_EXP 95
51678: NOT
51679: PUSH
51680: LD_EXP 93
51684: NOT
51685: OR
51686: IFFALSE 51690
// exit ;
51688: GO 51880
// for i = 1 to mc_bases do
51690: LD_ADDR_VAR 0 4
51694: PUSH
51695: DOUBLE
51696: LD_INT 1
51698: DEC
51699: ST_TO_ADDR
51700: LD_EXP 95
51704: PUSH
51705: FOR_TO
51706: IFFALSE 51793
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51708: LD_VAR 0 1
51712: PUSH
51713: LD_EXP 103
51717: PUSH
51718: LD_VAR 0 4
51722: ARRAY
51723: IN
51724: PUSH
51725: LD_VAR 0 1
51729: PUSH
51730: LD_EXP 104
51734: PUSH
51735: LD_VAR 0 4
51739: ARRAY
51740: IN
51741: NOT
51742: AND
51743: IFFALSE 51791
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51745: LD_ADDR_EXP 104
51749: PUSH
51750: LD_EXP 104
51754: PPUSH
51755: LD_VAR 0 4
51759: PUSH
51760: LD_EXP 104
51764: PUSH
51765: LD_VAR 0 4
51769: ARRAY
51770: PUSH
51771: LD_INT 1
51773: PLUS
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PPUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: CALL 57012 0 3
51788: ST_TO_ADDR
// break ;
51789: GO 51793
// end ; end ;
51791: GO 51705
51793: POP
51794: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51795: LD_VAR 0 1
51799: PPUSH
51800: CALL_OW 257
51804: PUSH
51805: LD_EXP 121
51809: IN
51810: PUSH
51811: LD_VAR 0 1
51815: PPUSH
51816: CALL_OW 266
51820: PUSH
51821: LD_INT 5
51823: EQUAL
51824: AND
51825: PUSH
51826: LD_VAR 0 2
51830: PPUSH
51831: CALL_OW 110
51835: PUSH
51836: LD_INT 18
51838: NONEQUAL
51839: AND
51840: IFFALSE 51880
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51842: LD_VAR 0 2
51846: PPUSH
51847: CALL_OW 257
51851: PUSH
51852: LD_INT 5
51854: PUSH
51855: LD_INT 8
51857: PUSH
51858: LD_INT 9
51860: PUSH
51861: EMPTY
51862: LIST
51863: LIST
51864: LIST
51865: IN
51866: IFFALSE 51880
// SetClass ( unit , 1 ) ;
51868: LD_VAR 0 2
51872: PPUSH
51873: LD_INT 1
51875: PPUSH
51876: CALL_OW 336
// end ;
51880: LD_VAR 0 3
51884: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51885: LD_INT 0
51887: PPUSH
51888: PPUSH
// if not mc_bases or not skirmish then
51889: LD_EXP 95
51893: NOT
51894: PUSH
51895: LD_EXP 93
51899: NOT
51900: OR
51901: IFFALSE 51905
// exit ;
51903: GO 52021
// if GetLives ( abandoned_vehicle ) > 250 then
51905: LD_VAR 0 2
51909: PPUSH
51910: CALL_OW 256
51914: PUSH
51915: LD_INT 250
51917: GREATER
51918: IFFALSE 51922
// exit ;
51920: GO 52021
// for i = 1 to mc_bases do
51922: LD_ADDR_VAR 0 6
51926: PUSH
51927: DOUBLE
51928: LD_INT 1
51930: DEC
51931: ST_TO_ADDR
51932: LD_EXP 95
51936: PUSH
51937: FOR_TO
51938: IFFALSE 52019
// begin if driver in mc_bases [ i ] then
51940: LD_VAR 0 1
51944: PUSH
51945: LD_EXP 95
51949: PUSH
51950: LD_VAR 0 6
51954: ARRAY
51955: IN
51956: IFFALSE 52017
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51958: LD_VAR 0 1
51962: PPUSH
51963: LD_EXP 95
51967: PUSH
51968: LD_VAR 0 6
51972: ARRAY
51973: PPUSH
51974: LD_INT 2
51976: PUSH
51977: LD_INT 30
51979: PUSH
51980: LD_INT 0
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: LD_INT 30
51989: PUSH
51990: LD_INT 1
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: LIST
52001: PPUSH
52002: CALL_OW 72
52006: PUSH
52007: LD_INT 1
52009: ARRAY
52010: PPUSH
52011: CALL 89630 0 2
// break ;
52015: GO 52019
// end ; end ;
52017: GO 51937
52019: POP
52020: POP
// end ; end_of_file
52021: LD_VAR 0 5
52025: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52026: LD_INT 0
52028: PPUSH
52029: PPUSH
// if exist_mode then
52030: LD_VAR 0 2
52034: IFFALSE 52059
// unit := CreateCharacter ( prefix & ident ) else
52036: LD_ADDR_VAR 0 5
52040: PUSH
52041: LD_VAR 0 3
52045: PUSH
52046: LD_VAR 0 1
52050: STR
52051: PPUSH
52052: CALL_OW 34
52056: ST_TO_ADDR
52057: GO 52074
// unit := NewCharacter ( ident ) ;
52059: LD_ADDR_VAR 0 5
52063: PUSH
52064: LD_VAR 0 1
52068: PPUSH
52069: CALL_OW 25
52073: ST_TO_ADDR
// result := unit ;
52074: LD_ADDR_VAR 0 4
52078: PUSH
52079: LD_VAR 0 5
52083: ST_TO_ADDR
// end ;
52084: LD_VAR 0 4
52088: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52089: LD_INT 0
52091: PPUSH
52092: PPUSH
// if not side or not nation then
52093: LD_VAR 0 1
52097: NOT
52098: PUSH
52099: LD_VAR 0 2
52103: NOT
52104: OR
52105: IFFALSE 52109
// exit ;
52107: GO 52877
// case nation of nation_american :
52109: LD_VAR 0 2
52113: PUSH
52114: LD_INT 1
52116: DOUBLE
52117: EQUAL
52118: IFTRUE 52122
52120: GO 52336
52122: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52123: LD_ADDR_VAR 0 4
52127: PUSH
52128: LD_INT 35
52130: PUSH
52131: LD_INT 45
52133: PUSH
52134: LD_INT 46
52136: PUSH
52137: LD_INT 47
52139: PUSH
52140: LD_INT 82
52142: PUSH
52143: LD_INT 83
52145: PUSH
52146: LD_INT 84
52148: PUSH
52149: LD_INT 85
52151: PUSH
52152: LD_INT 86
52154: PUSH
52155: LD_INT 1
52157: PUSH
52158: LD_INT 2
52160: PUSH
52161: LD_INT 6
52163: PUSH
52164: LD_INT 15
52166: PUSH
52167: LD_INT 16
52169: PUSH
52170: LD_INT 7
52172: PUSH
52173: LD_INT 12
52175: PUSH
52176: LD_INT 13
52178: PUSH
52179: LD_INT 10
52181: PUSH
52182: LD_INT 14
52184: PUSH
52185: LD_INT 20
52187: PUSH
52188: LD_INT 21
52190: PUSH
52191: LD_INT 22
52193: PUSH
52194: LD_INT 25
52196: PUSH
52197: LD_INT 32
52199: PUSH
52200: LD_INT 27
52202: PUSH
52203: LD_INT 36
52205: PUSH
52206: LD_INT 69
52208: PUSH
52209: LD_INT 39
52211: PUSH
52212: LD_INT 34
52214: PUSH
52215: LD_INT 40
52217: PUSH
52218: LD_INT 48
52220: PUSH
52221: LD_INT 49
52223: PUSH
52224: LD_INT 50
52226: PUSH
52227: LD_INT 51
52229: PUSH
52230: LD_INT 52
52232: PUSH
52233: LD_INT 53
52235: PUSH
52236: LD_INT 54
52238: PUSH
52239: LD_INT 55
52241: PUSH
52242: LD_INT 56
52244: PUSH
52245: LD_INT 57
52247: PUSH
52248: LD_INT 58
52250: PUSH
52251: LD_INT 59
52253: PUSH
52254: LD_INT 60
52256: PUSH
52257: LD_INT 61
52259: PUSH
52260: LD_INT 62
52262: PUSH
52263: LD_INT 80
52265: PUSH
52266: LD_INT 82
52268: PUSH
52269: LD_INT 83
52271: PUSH
52272: LD_INT 84
52274: PUSH
52275: LD_INT 85
52277: PUSH
52278: LD_INT 86
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: LIST
52296: LIST
52297: LIST
52298: LIST
52299: LIST
52300: LIST
52301: LIST
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: ST_TO_ADDR
52334: GO 52801
52336: LD_INT 2
52338: DOUBLE
52339: EQUAL
52340: IFTRUE 52344
52342: GO 52570
52344: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52345: LD_ADDR_VAR 0 4
52349: PUSH
52350: LD_INT 35
52352: PUSH
52353: LD_INT 45
52355: PUSH
52356: LD_INT 46
52358: PUSH
52359: LD_INT 47
52361: PUSH
52362: LD_INT 82
52364: PUSH
52365: LD_INT 83
52367: PUSH
52368: LD_INT 84
52370: PUSH
52371: LD_INT 85
52373: PUSH
52374: LD_INT 87
52376: PUSH
52377: LD_INT 70
52379: PUSH
52380: LD_INT 1
52382: PUSH
52383: LD_INT 11
52385: PUSH
52386: LD_INT 3
52388: PUSH
52389: LD_INT 4
52391: PUSH
52392: LD_INT 5
52394: PUSH
52395: LD_INT 6
52397: PUSH
52398: LD_INT 15
52400: PUSH
52401: LD_INT 18
52403: PUSH
52404: LD_INT 7
52406: PUSH
52407: LD_INT 17
52409: PUSH
52410: LD_INT 8
52412: PUSH
52413: LD_INT 20
52415: PUSH
52416: LD_INT 21
52418: PUSH
52419: LD_INT 22
52421: PUSH
52422: LD_INT 72
52424: PUSH
52425: LD_INT 26
52427: PUSH
52428: LD_INT 69
52430: PUSH
52431: LD_INT 39
52433: PUSH
52434: LD_INT 40
52436: PUSH
52437: LD_INT 41
52439: PUSH
52440: LD_INT 42
52442: PUSH
52443: LD_INT 43
52445: PUSH
52446: LD_INT 48
52448: PUSH
52449: LD_INT 49
52451: PUSH
52452: LD_INT 50
52454: PUSH
52455: LD_INT 51
52457: PUSH
52458: LD_INT 52
52460: PUSH
52461: LD_INT 53
52463: PUSH
52464: LD_INT 54
52466: PUSH
52467: LD_INT 55
52469: PUSH
52470: LD_INT 56
52472: PUSH
52473: LD_INT 60
52475: PUSH
52476: LD_INT 61
52478: PUSH
52479: LD_INT 62
52481: PUSH
52482: LD_INT 66
52484: PUSH
52485: LD_INT 67
52487: PUSH
52488: LD_INT 68
52490: PUSH
52491: LD_INT 81
52493: PUSH
52494: LD_INT 82
52496: PUSH
52497: LD_INT 83
52499: PUSH
52500: LD_INT 84
52502: PUSH
52503: LD_INT 85
52505: PUSH
52506: LD_INT 87
52508: PUSH
52509: LD_INT 88
52511: PUSH
52512: EMPTY
52513: LIST
52514: LIST
52515: LIST
52516: LIST
52517: LIST
52518: LIST
52519: LIST
52520: LIST
52521: LIST
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: LIST
52540: LIST
52541: LIST
52542: LIST
52543: LIST
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: ST_TO_ADDR
52568: GO 52801
52570: LD_INT 3
52572: DOUBLE
52573: EQUAL
52574: IFTRUE 52578
52576: GO 52800
52578: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52579: LD_ADDR_VAR 0 4
52583: PUSH
52584: LD_INT 46
52586: PUSH
52587: LD_INT 47
52589: PUSH
52590: LD_INT 1
52592: PUSH
52593: LD_INT 2
52595: PUSH
52596: LD_INT 82
52598: PUSH
52599: LD_INT 83
52601: PUSH
52602: LD_INT 84
52604: PUSH
52605: LD_INT 85
52607: PUSH
52608: LD_INT 86
52610: PUSH
52611: LD_INT 11
52613: PUSH
52614: LD_INT 9
52616: PUSH
52617: LD_INT 20
52619: PUSH
52620: LD_INT 19
52622: PUSH
52623: LD_INT 21
52625: PUSH
52626: LD_INT 24
52628: PUSH
52629: LD_INT 22
52631: PUSH
52632: LD_INT 25
52634: PUSH
52635: LD_INT 28
52637: PUSH
52638: LD_INT 29
52640: PUSH
52641: LD_INT 30
52643: PUSH
52644: LD_INT 31
52646: PUSH
52647: LD_INT 37
52649: PUSH
52650: LD_INT 38
52652: PUSH
52653: LD_INT 32
52655: PUSH
52656: LD_INT 27
52658: PUSH
52659: LD_INT 33
52661: PUSH
52662: LD_INT 69
52664: PUSH
52665: LD_INT 39
52667: PUSH
52668: LD_INT 34
52670: PUSH
52671: LD_INT 40
52673: PUSH
52674: LD_INT 71
52676: PUSH
52677: LD_INT 23
52679: PUSH
52680: LD_INT 44
52682: PUSH
52683: LD_INT 48
52685: PUSH
52686: LD_INT 49
52688: PUSH
52689: LD_INT 50
52691: PUSH
52692: LD_INT 51
52694: PUSH
52695: LD_INT 52
52697: PUSH
52698: LD_INT 53
52700: PUSH
52701: LD_INT 54
52703: PUSH
52704: LD_INT 55
52706: PUSH
52707: LD_INT 56
52709: PUSH
52710: LD_INT 57
52712: PUSH
52713: LD_INT 58
52715: PUSH
52716: LD_INT 59
52718: PUSH
52719: LD_INT 63
52721: PUSH
52722: LD_INT 64
52724: PUSH
52725: LD_INT 65
52727: PUSH
52728: LD_INT 82
52730: PUSH
52731: LD_INT 83
52733: PUSH
52734: LD_INT 84
52736: PUSH
52737: LD_INT 85
52739: PUSH
52740: LD_INT 86
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: LIST
52747: LIST
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: LIST
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: ST_TO_ADDR
52798: GO 52801
52800: POP
// if state > - 1 and state < 3 then
52801: LD_VAR 0 3
52805: PUSH
52806: LD_INT 1
52808: NEG
52809: GREATER
52810: PUSH
52811: LD_VAR 0 3
52815: PUSH
52816: LD_INT 3
52818: LESS
52819: AND
52820: IFFALSE 52877
// for i in result do
52822: LD_ADDR_VAR 0 5
52826: PUSH
52827: LD_VAR 0 4
52831: PUSH
52832: FOR_IN
52833: IFFALSE 52875
// if GetTech ( i , side ) <> state then
52835: LD_VAR 0 5
52839: PPUSH
52840: LD_VAR 0 1
52844: PPUSH
52845: CALL_OW 321
52849: PUSH
52850: LD_VAR 0 3
52854: NONEQUAL
52855: IFFALSE 52873
// result := result diff i ;
52857: LD_ADDR_VAR 0 4
52861: PUSH
52862: LD_VAR 0 4
52866: PUSH
52867: LD_VAR 0 5
52871: DIFF
52872: ST_TO_ADDR
52873: GO 52832
52875: POP
52876: POP
// end ;
52877: LD_VAR 0 4
52881: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52882: LD_INT 0
52884: PPUSH
52885: PPUSH
52886: PPUSH
// result := true ;
52887: LD_ADDR_VAR 0 3
52891: PUSH
52892: LD_INT 1
52894: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52895: LD_ADDR_VAR 0 5
52899: PUSH
52900: LD_VAR 0 2
52904: PPUSH
52905: CALL_OW 480
52909: ST_TO_ADDR
// if not tmp then
52910: LD_VAR 0 5
52914: NOT
52915: IFFALSE 52919
// exit ;
52917: GO 52968
// for i in tmp do
52919: LD_ADDR_VAR 0 4
52923: PUSH
52924: LD_VAR 0 5
52928: PUSH
52929: FOR_IN
52930: IFFALSE 52966
// if GetTech ( i , side ) <> state_researched then
52932: LD_VAR 0 4
52936: PPUSH
52937: LD_VAR 0 1
52941: PPUSH
52942: CALL_OW 321
52946: PUSH
52947: LD_INT 2
52949: NONEQUAL
52950: IFFALSE 52964
// begin result := false ;
52952: LD_ADDR_VAR 0 3
52956: PUSH
52957: LD_INT 0
52959: ST_TO_ADDR
// exit ;
52960: POP
52961: POP
52962: GO 52968
// end ;
52964: GO 52929
52966: POP
52967: POP
// end ;
52968: LD_VAR 0 3
52972: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52973: LD_INT 0
52975: PPUSH
52976: PPUSH
52977: PPUSH
52978: PPUSH
52979: PPUSH
52980: PPUSH
52981: PPUSH
52982: PPUSH
52983: PPUSH
52984: PPUSH
52985: PPUSH
52986: PPUSH
52987: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52988: LD_VAR 0 1
52992: NOT
52993: PUSH
52994: LD_VAR 0 1
52998: PPUSH
52999: CALL_OW 257
53003: PUSH
53004: LD_INT 9
53006: NONEQUAL
53007: OR
53008: IFFALSE 53012
// exit ;
53010: GO 53585
// side := GetSide ( unit ) ;
53012: LD_ADDR_VAR 0 9
53016: PUSH
53017: LD_VAR 0 1
53021: PPUSH
53022: CALL_OW 255
53026: ST_TO_ADDR
// tech_space := tech_spacanom ;
53027: LD_ADDR_VAR 0 12
53031: PUSH
53032: LD_INT 29
53034: ST_TO_ADDR
// tech_time := tech_taurad ;
53035: LD_ADDR_VAR 0 13
53039: PUSH
53040: LD_INT 28
53042: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53043: LD_ADDR_VAR 0 11
53047: PUSH
53048: LD_VAR 0 1
53052: PPUSH
53053: CALL_OW 310
53057: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53058: LD_VAR 0 11
53062: PPUSH
53063: CALL_OW 247
53067: PUSH
53068: LD_INT 2
53070: EQUAL
53071: IFFALSE 53075
// exit ;
53073: GO 53585
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53075: LD_ADDR_VAR 0 8
53079: PUSH
53080: LD_INT 81
53082: PUSH
53083: LD_VAR 0 9
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: PUSH
53092: LD_INT 3
53094: PUSH
53095: LD_INT 21
53097: PUSH
53098: LD_INT 3
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PPUSH
53113: CALL_OW 69
53117: ST_TO_ADDR
// if not tmp then
53118: LD_VAR 0 8
53122: NOT
53123: IFFALSE 53127
// exit ;
53125: GO 53585
// if in_unit then
53127: LD_VAR 0 11
53131: IFFALSE 53155
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53133: LD_ADDR_VAR 0 10
53137: PUSH
53138: LD_VAR 0 8
53142: PPUSH
53143: LD_VAR 0 11
53147: PPUSH
53148: CALL_OW 74
53152: ST_TO_ADDR
53153: GO 53175
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53155: LD_ADDR_VAR 0 10
53159: PUSH
53160: LD_VAR 0 8
53164: PPUSH
53165: LD_VAR 0 1
53169: PPUSH
53170: CALL_OW 74
53174: ST_TO_ADDR
// if not enemy then
53175: LD_VAR 0 10
53179: NOT
53180: IFFALSE 53184
// exit ;
53182: GO 53585
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53184: LD_VAR 0 11
53188: PUSH
53189: LD_VAR 0 11
53193: PPUSH
53194: LD_VAR 0 10
53198: PPUSH
53199: CALL_OW 296
53203: PUSH
53204: LD_INT 13
53206: GREATER
53207: AND
53208: PUSH
53209: LD_VAR 0 1
53213: PPUSH
53214: LD_VAR 0 10
53218: PPUSH
53219: CALL_OW 296
53223: PUSH
53224: LD_INT 12
53226: GREATER
53227: OR
53228: IFFALSE 53232
// exit ;
53230: GO 53585
// missile := [ 1 ] ;
53232: LD_ADDR_VAR 0 14
53236: PUSH
53237: LD_INT 1
53239: PUSH
53240: EMPTY
53241: LIST
53242: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53243: LD_VAR 0 9
53247: PPUSH
53248: LD_VAR 0 12
53252: PPUSH
53253: CALL_OW 325
53257: IFFALSE 53286
// missile := Insert ( missile , missile + 1 , 2 ) ;
53259: LD_ADDR_VAR 0 14
53263: PUSH
53264: LD_VAR 0 14
53268: PPUSH
53269: LD_VAR 0 14
53273: PUSH
53274: LD_INT 1
53276: PLUS
53277: PPUSH
53278: LD_INT 2
53280: PPUSH
53281: CALL_OW 2
53285: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53286: LD_VAR 0 9
53290: PPUSH
53291: LD_VAR 0 13
53295: PPUSH
53296: CALL_OW 325
53300: PUSH
53301: LD_VAR 0 10
53305: PPUSH
53306: CALL_OW 255
53310: PPUSH
53311: LD_VAR 0 13
53315: PPUSH
53316: CALL_OW 325
53320: NOT
53321: AND
53322: IFFALSE 53351
// missile := Insert ( missile , missile + 1 , 3 ) ;
53324: LD_ADDR_VAR 0 14
53328: PUSH
53329: LD_VAR 0 14
53333: PPUSH
53334: LD_VAR 0 14
53338: PUSH
53339: LD_INT 1
53341: PLUS
53342: PPUSH
53343: LD_INT 3
53345: PPUSH
53346: CALL_OW 2
53350: ST_TO_ADDR
// if missile < 2 then
53351: LD_VAR 0 14
53355: PUSH
53356: LD_INT 2
53358: LESS
53359: IFFALSE 53363
// exit ;
53361: GO 53585
// x := GetX ( enemy ) ;
53363: LD_ADDR_VAR 0 4
53367: PUSH
53368: LD_VAR 0 10
53372: PPUSH
53373: CALL_OW 250
53377: ST_TO_ADDR
// y := GetY ( enemy ) ;
53378: LD_ADDR_VAR 0 5
53382: PUSH
53383: LD_VAR 0 10
53387: PPUSH
53388: CALL_OW 251
53392: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53393: LD_ADDR_VAR 0 6
53397: PUSH
53398: LD_VAR 0 4
53402: PUSH
53403: LD_INT 1
53405: NEG
53406: PPUSH
53407: LD_INT 1
53409: PPUSH
53410: CALL_OW 12
53414: PLUS
53415: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53416: LD_ADDR_VAR 0 7
53420: PUSH
53421: LD_VAR 0 5
53425: PUSH
53426: LD_INT 1
53428: NEG
53429: PPUSH
53430: LD_INT 1
53432: PPUSH
53433: CALL_OW 12
53437: PLUS
53438: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53439: LD_VAR 0 6
53443: PPUSH
53444: LD_VAR 0 7
53448: PPUSH
53449: CALL_OW 488
53453: NOT
53454: IFFALSE 53476
// begin _x := x ;
53456: LD_ADDR_VAR 0 6
53460: PUSH
53461: LD_VAR 0 4
53465: ST_TO_ADDR
// _y := y ;
53466: LD_ADDR_VAR 0 7
53470: PUSH
53471: LD_VAR 0 5
53475: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53476: LD_ADDR_VAR 0 3
53480: PUSH
53481: LD_INT 1
53483: PPUSH
53484: LD_VAR 0 14
53488: PPUSH
53489: CALL_OW 12
53493: ST_TO_ADDR
// case i of 1 :
53494: LD_VAR 0 3
53498: PUSH
53499: LD_INT 1
53501: DOUBLE
53502: EQUAL
53503: IFTRUE 53507
53505: GO 53524
53507: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53508: LD_VAR 0 1
53512: PPUSH
53513: LD_VAR 0 10
53517: PPUSH
53518: CALL_OW 115
53522: GO 53585
53524: LD_INT 2
53526: DOUBLE
53527: EQUAL
53528: IFTRUE 53532
53530: GO 53554
53532: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53533: LD_VAR 0 1
53537: PPUSH
53538: LD_VAR 0 6
53542: PPUSH
53543: LD_VAR 0 7
53547: PPUSH
53548: CALL_OW 153
53552: GO 53585
53554: LD_INT 3
53556: DOUBLE
53557: EQUAL
53558: IFTRUE 53562
53560: GO 53584
53562: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53563: LD_VAR 0 1
53567: PPUSH
53568: LD_VAR 0 6
53572: PPUSH
53573: LD_VAR 0 7
53577: PPUSH
53578: CALL_OW 154
53582: GO 53585
53584: POP
// end ;
53585: LD_VAR 0 2
53589: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
53594: PPUSH
53595: PPUSH
53596: PPUSH
53597: PPUSH
// if not unit or not building then
53598: LD_VAR 0 1
53602: NOT
53603: PUSH
53604: LD_VAR 0 2
53608: NOT
53609: OR
53610: IFFALSE 53614
// exit ;
53612: GO 53772
// x := GetX ( building ) ;
53614: LD_ADDR_VAR 0 5
53618: PUSH
53619: LD_VAR 0 2
53623: PPUSH
53624: CALL_OW 250
53628: ST_TO_ADDR
// y := GetY ( building ) ;
53629: LD_ADDR_VAR 0 6
53633: PUSH
53634: LD_VAR 0 2
53638: PPUSH
53639: CALL_OW 251
53643: ST_TO_ADDR
// for i = 0 to 5 do
53644: LD_ADDR_VAR 0 4
53648: PUSH
53649: DOUBLE
53650: LD_INT 0
53652: DEC
53653: ST_TO_ADDR
53654: LD_INT 5
53656: PUSH
53657: FOR_TO
53658: IFFALSE 53770
// begin _x := ShiftX ( x , i , 3 ) ;
53660: LD_ADDR_VAR 0 7
53664: PUSH
53665: LD_VAR 0 5
53669: PPUSH
53670: LD_VAR 0 4
53674: PPUSH
53675: LD_INT 3
53677: PPUSH
53678: CALL_OW 272
53682: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53683: LD_ADDR_VAR 0 8
53687: PUSH
53688: LD_VAR 0 6
53692: PPUSH
53693: LD_VAR 0 4
53697: PPUSH
53698: LD_INT 3
53700: PPUSH
53701: CALL_OW 273
53705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53706: LD_VAR 0 7
53710: PPUSH
53711: LD_VAR 0 8
53715: PPUSH
53716: CALL_OW 488
53720: NOT
53721: IFFALSE 53725
// continue ;
53723: GO 53657
// if HexInfo ( _x , _y ) = 0 then
53725: LD_VAR 0 7
53729: PPUSH
53730: LD_VAR 0 8
53734: PPUSH
53735: CALL_OW 428
53739: PUSH
53740: LD_INT 0
53742: EQUAL
53743: IFFALSE 53768
// begin ComMoveXY ( unit , _x , _y ) ;
53745: LD_VAR 0 1
53749: PPUSH
53750: LD_VAR 0 7
53754: PPUSH
53755: LD_VAR 0 8
53759: PPUSH
53760: CALL_OW 111
// exit ;
53764: POP
53765: POP
53766: GO 53772
// end ; end ;
53768: GO 53657
53770: POP
53771: POP
// end ;
53772: LD_VAR 0 3
53776: RET
// export function ScanBase ( side , base_area ) ; begin
53777: LD_INT 0
53779: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_VAR 0 2
53789: PPUSH
53790: LD_INT 81
53792: PUSH
53793: LD_VAR 0 1
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PPUSH
53802: CALL_OW 70
53806: ST_TO_ADDR
// end ;
53807: LD_VAR 0 3
53811: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53812: LD_INT 0
53814: PPUSH
53815: PPUSH
53816: PPUSH
53817: PPUSH
// result := false ;
53818: LD_ADDR_VAR 0 2
53822: PUSH
53823: LD_INT 0
53825: ST_TO_ADDR
// side := GetSide ( unit ) ;
53826: LD_ADDR_VAR 0 3
53830: PUSH
53831: LD_VAR 0 1
53835: PPUSH
53836: CALL_OW 255
53840: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53841: LD_ADDR_VAR 0 4
53845: PUSH
53846: LD_VAR 0 1
53850: PPUSH
53851: CALL_OW 248
53855: ST_TO_ADDR
// case nat of 1 :
53856: LD_VAR 0 4
53860: PUSH
53861: LD_INT 1
53863: DOUBLE
53864: EQUAL
53865: IFTRUE 53869
53867: GO 53880
53869: POP
// tech := tech_lassight ; 2 :
53870: LD_ADDR_VAR 0 5
53874: PUSH
53875: LD_INT 12
53877: ST_TO_ADDR
53878: GO 53919
53880: LD_INT 2
53882: DOUBLE
53883: EQUAL
53884: IFTRUE 53888
53886: GO 53899
53888: POP
// tech := tech_mortar ; 3 :
53889: LD_ADDR_VAR 0 5
53893: PUSH
53894: LD_INT 41
53896: ST_TO_ADDR
53897: GO 53919
53899: LD_INT 3
53901: DOUBLE
53902: EQUAL
53903: IFTRUE 53907
53905: GO 53918
53907: POP
// tech := tech_bazooka ; end ;
53908: LD_ADDR_VAR 0 5
53912: PUSH
53913: LD_INT 44
53915: ST_TO_ADDR
53916: GO 53919
53918: POP
// if Researched ( side , tech ) then
53919: LD_VAR 0 3
53923: PPUSH
53924: LD_VAR 0 5
53928: PPUSH
53929: CALL_OW 325
53933: IFFALSE 53960
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53935: LD_ADDR_VAR 0 2
53939: PUSH
53940: LD_INT 5
53942: PUSH
53943: LD_INT 8
53945: PUSH
53946: LD_INT 9
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: LIST
53953: PUSH
53954: LD_VAR 0 4
53958: ARRAY
53959: ST_TO_ADDR
// end ;
53960: LD_VAR 0 2
53964: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53965: LD_INT 0
53967: PPUSH
53968: PPUSH
53969: PPUSH
// if not mines then
53970: LD_VAR 0 2
53974: NOT
53975: IFFALSE 53979
// exit ;
53977: GO 54123
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53979: LD_ADDR_VAR 0 5
53983: PUSH
53984: LD_INT 81
53986: PUSH
53987: LD_VAR 0 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: PUSH
53996: LD_INT 3
53998: PUSH
53999: LD_INT 21
54001: PUSH
54002: LD_INT 3
54004: PUSH
54005: EMPTY
54006: LIST
54007: LIST
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: PUSH
54013: EMPTY
54014: LIST
54015: LIST
54016: PPUSH
54017: CALL_OW 69
54021: ST_TO_ADDR
// for i in mines do
54022: LD_ADDR_VAR 0 4
54026: PUSH
54027: LD_VAR 0 2
54031: PUSH
54032: FOR_IN
54033: IFFALSE 54121
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54035: LD_VAR 0 4
54039: PUSH
54040: LD_INT 1
54042: ARRAY
54043: PPUSH
54044: LD_VAR 0 4
54048: PUSH
54049: LD_INT 2
54051: ARRAY
54052: PPUSH
54053: CALL_OW 458
54057: NOT
54058: IFFALSE 54062
// continue ;
54060: GO 54032
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54062: LD_VAR 0 4
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PPUSH
54071: LD_VAR 0 4
54075: PUSH
54076: LD_INT 2
54078: ARRAY
54079: PPUSH
54080: CALL_OW 428
54084: PUSH
54085: LD_VAR 0 5
54089: IN
54090: IFFALSE 54119
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54092: LD_VAR 0 4
54096: PUSH
54097: LD_INT 1
54099: ARRAY
54100: PPUSH
54101: LD_VAR 0 4
54105: PUSH
54106: LD_INT 2
54108: ARRAY
54109: PPUSH
54110: LD_VAR 0 1
54114: PPUSH
54115: CALL_OW 456
// end ;
54119: GO 54032
54121: POP
54122: POP
// end ;
54123: LD_VAR 0 3
54127: RET
// export function Count ( array ) ; var i ; begin
54128: LD_INT 0
54130: PPUSH
54131: PPUSH
// result := 0 ;
54132: LD_ADDR_VAR 0 2
54136: PUSH
54137: LD_INT 0
54139: ST_TO_ADDR
// for i in array do
54140: LD_ADDR_VAR 0 3
54144: PUSH
54145: LD_VAR 0 1
54149: PUSH
54150: FOR_IN
54151: IFFALSE 54175
// if i then
54153: LD_VAR 0 3
54157: IFFALSE 54173
// result := result + 1 ;
54159: LD_ADDR_VAR 0 2
54163: PUSH
54164: LD_VAR 0 2
54168: PUSH
54169: LD_INT 1
54171: PLUS
54172: ST_TO_ADDR
54173: GO 54150
54175: POP
54176: POP
// end ;
54177: LD_VAR 0 2
54181: RET
// export function IsEmpty ( building ) ; begin
54182: LD_INT 0
54184: PPUSH
// if not building then
54185: LD_VAR 0 1
54189: NOT
54190: IFFALSE 54194
// exit ;
54192: GO 54237
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54194: LD_ADDR_VAR 0 2
54198: PUSH
54199: LD_VAR 0 1
54203: PUSH
54204: LD_INT 22
54206: PUSH
54207: LD_VAR 0 1
54211: PPUSH
54212: CALL_OW 255
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PUSH
54221: LD_INT 58
54223: PUSH
54224: EMPTY
54225: LIST
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PPUSH
54231: CALL_OW 69
54235: IN
54236: ST_TO_ADDR
// end ;
54237: LD_VAR 0 2
54241: RET
// export function IsNotFull ( building ) ; begin
54242: LD_INT 0
54244: PPUSH
// if not building then
54245: LD_VAR 0 1
54249: NOT
54250: IFFALSE 54254
// exit ;
54252: GO 54273
// result := UnitsInside ( building ) < 6 ;
54254: LD_ADDR_VAR 0 2
54258: PUSH
54259: LD_VAR 0 1
54263: PPUSH
54264: CALL_OW 313
54268: PUSH
54269: LD_INT 6
54271: LESS
54272: ST_TO_ADDR
// end ;
54273: LD_VAR 0 2
54277: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54278: LD_INT 0
54280: PPUSH
54281: PPUSH
54282: PPUSH
54283: PPUSH
// tmp := [ ] ;
54284: LD_ADDR_VAR 0 3
54288: PUSH
54289: EMPTY
54290: ST_TO_ADDR
// list := [ ] ;
54291: LD_ADDR_VAR 0 5
54295: PUSH
54296: EMPTY
54297: ST_TO_ADDR
// for i = 16 to 25 do
54298: LD_ADDR_VAR 0 4
54302: PUSH
54303: DOUBLE
54304: LD_INT 16
54306: DEC
54307: ST_TO_ADDR
54308: LD_INT 25
54310: PUSH
54311: FOR_TO
54312: IFFALSE 54385
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54314: LD_ADDR_VAR 0 3
54318: PUSH
54319: LD_VAR 0 3
54323: PUSH
54324: LD_INT 22
54326: PUSH
54327: LD_VAR 0 1
54331: PPUSH
54332: CALL_OW 255
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PUSH
54341: LD_INT 91
54343: PUSH
54344: LD_VAR 0 1
54348: PUSH
54349: LD_INT 6
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: LIST
54356: PUSH
54357: LD_INT 30
54359: PUSH
54360: LD_VAR 0 4
54364: PUSH
54365: EMPTY
54366: LIST
54367: LIST
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: PUSH
54374: EMPTY
54375: LIST
54376: PPUSH
54377: CALL_OW 69
54381: ADD
54382: ST_TO_ADDR
54383: GO 54311
54385: POP
54386: POP
// for i = 1 to tmp do
54387: LD_ADDR_VAR 0 4
54391: PUSH
54392: DOUBLE
54393: LD_INT 1
54395: DEC
54396: ST_TO_ADDR
54397: LD_VAR 0 3
54401: PUSH
54402: FOR_TO
54403: IFFALSE 54491
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54405: LD_ADDR_VAR 0 5
54409: PUSH
54410: LD_VAR 0 5
54414: PUSH
54415: LD_VAR 0 3
54419: PUSH
54420: LD_VAR 0 4
54424: ARRAY
54425: PPUSH
54426: CALL_OW 266
54430: PUSH
54431: LD_VAR 0 3
54435: PUSH
54436: LD_VAR 0 4
54440: ARRAY
54441: PPUSH
54442: CALL_OW 250
54446: PUSH
54447: LD_VAR 0 3
54451: PUSH
54452: LD_VAR 0 4
54456: ARRAY
54457: PPUSH
54458: CALL_OW 251
54462: PUSH
54463: LD_VAR 0 3
54467: PUSH
54468: LD_VAR 0 4
54472: ARRAY
54473: PPUSH
54474: CALL_OW 254
54478: PUSH
54479: EMPTY
54480: LIST
54481: LIST
54482: LIST
54483: LIST
54484: PUSH
54485: EMPTY
54486: LIST
54487: ADD
54488: ST_TO_ADDR
54489: GO 54402
54491: POP
54492: POP
// result := list ;
54493: LD_ADDR_VAR 0 2
54497: PUSH
54498: LD_VAR 0 5
54502: ST_TO_ADDR
// end ;
54503: LD_VAR 0 2
54507: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54508: LD_INT 0
54510: PPUSH
54511: PPUSH
54512: PPUSH
54513: PPUSH
54514: PPUSH
54515: PPUSH
54516: PPUSH
// if not factory then
54517: LD_VAR 0 1
54521: NOT
54522: IFFALSE 54526
// exit ;
54524: GO 55119
// if control = control_apeman then
54526: LD_VAR 0 4
54530: PUSH
54531: LD_INT 5
54533: EQUAL
54534: IFFALSE 54643
// begin tmp := UnitsInside ( factory ) ;
54536: LD_ADDR_VAR 0 8
54540: PUSH
54541: LD_VAR 0 1
54545: PPUSH
54546: CALL_OW 313
54550: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54551: LD_VAR 0 8
54555: PPUSH
54556: LD_INT 25
54558: PUSH
54559: LD_INT 12
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PPUSH
54566: CALL_OW 72
54570: NOT
54571: IFFALSE 54581
// control := control_manual ;
54573: LD_ADDR_VAR 0 4
54577: PUSH
54578: LD_INT 1
54580: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54581: LD_ADDR_VAR 0 8
54585: PUSH
54586: LD_VAR 0 1
54590: PPUSH
54591: CALL 54278 0 1
54595: ST_TO_ADDR
// if tmp then
54596: LD_VAR 0 8
54600: IFFALSE 54643
// begin for i in tmp do
54602: LD_ADDR_VAR 0 7
54606: PUSH
54607: LD_VAR 0 8
54611: PUSH
54612: FOR_IN
54613: IFFALSE 54641
// if i [ 1 ] = b_ext_radio then
54615: LD_VAR 0 7
54619: PUSH
54620: LD_INT 1
54622: ARRAY
54623: PUSH
54624: LD_INT 22
54626: EQUAL
54627: IFFALSE 54639
// begin control := control_remote ;
54629: LD_ADDR_VAR 0 4
54633: PUSH
54634: LD_INT 2
54636: ST_TO_ADDR
// break ;
54637: GO 54641
// end ;
54639: GO 54612
54641: POP
54642: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54643: LD_VAR 0 1
54647: PPUSH
54648: LD_VAR 0 2
54652: PPUSH
54653: LD_VAR 0 3
54657: PPUSH
54658: LD_VAR 0 4
54662: PPUSH
54663: LD_VAR 0 5
54667: PPUSH
54668: CALL_OW 448
54672: IFFALSE 54707
// begin result := [ chassis , engine , control , weapon ] ;
54674: LD_ADDR_VAR 0 6
54678: PUSH
54679: LD_VAR 0 2
54683: PUSH
54684: LD_VAR 0 3
54688: PUSH
54689: LD_VAR 0 4
54693: PUSH
54694: LD_VAR 0 5
54698: PUSH
54699: EMPTY
54700: LIST
54701: LIST
54702: LIST
54703: LIST
54704: ST_TO_ADDR
// exit ;
54705: GO 55119
// end ; _chassis := AvailableChassisList ( factory ) ;
54707: LD_ADDR_VAR 0 9
54711: PUSH
54712: LD_VAR 0 1
54716: PPUSH
54717: CALL_OW 475
54721: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54722: LD_ADDR_VAR 0 11
54726: PUSH
54727: LD_VAR 0 1
54731: PPUSH
54732: CALL_OW 476
54736: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54737: LD_ADDR_VAR 0 12
54741: PUSH
54742: LD_VAR 0 1
54746: PPUSH
54747: CALL_OW 477
54751: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54752: LD_ADDR_VAR 0 10
54756: PUSH
54757: LD_VAR 0 1
54761: PPUSH
54762: CALL_OW 478
54766: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54767: LD_VAR 0 9
54771: NOT
54772: PUSH
54773: LD_VAR 0 11
54777: NOT
54778: OR
54779: PUSH
54780: LD_VAR 0 12
54784: NOT
54785: OR
54786: PUSH
54787: LD_VAR 0 10
54791: NOT
54792: OR
54793: IFFALSE 54828
// begin result := [ chassis , engine , control , weapon ] ;
54795: LD_ADDR_VAR 0 6
54799: PUSH
54800: LD_VAR 0 2
54804: PUSH
54805: LD_VAR 0 3
54809: PUSH
54810: LD_VAR 0 4
54814: PUSH
54815: LD_VAR 0 5
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: LIST
54825: ST_TO_ADDR
// exit ;
54826: GO 55119
// end ; if not chassis in _chassis then
54828: LD_VAR 0 2
54832: PUSH
54833: LD_VAR 0 9
54837: IN
54838: NOT
54839: IFFALSE 54865
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54841: LD_ADDR_VAR 0 2
54845: PUSH
54846: LD_VAR 0 9
54850: PUSH
54851: LD_INT 1
54853: PPUSH
54854: LD_VAR 0 9
54858: PPUSH
54859: CALL_OW 12
54863: ARRAY
54864: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54865: LD_VAR 0 2
54869: PPUSH
54870: LD_VAR 0 3
54874: PPUSH
54875: CALL 55124 0 2
54879: NOT
54880: IFFALSE 54939
// repeat engine := _engine [ 1 ] ;
54882: LD_ADDR_VAR 0 3
54886: PUSH
54887: LD_VAR 0 11
54891: PUSH
54892: LD_INT 1
54894: ARRAY
54895: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54896: LD_ADDR_VAR 0 11
54900: PUSH
54901: LD_VAR 0 11
54905: PPUSH
54906: LD_INT 1
54908: PPUSH
54909: CALL_OW 3
54913: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54914: LD_VAR 0 2
54918: PPUSH
54919: LD_VAR 0 3
54923: PPUSH
54924: CALL 55124 0 2
54928: PUSH
54929: LD_VAR 0 11
54933: PUSH
54934: EMPTY
54935: EQUAL
54936: OR
54937: IFFALSE 54882
// if not control in _control then
54939: LD_VAR 0 4
54943: PUSH
54944: LD_VAR 0 12
54948: IN
54949: NOT
54950: IFFALSE 54976
// control := _control [ rand ( 1 , _control ) ] ;
54952: LD_ADDR_VAR 0 4
54956: PUSH
54957: LD_VAR 0 12
54961: PUSH
54962: LD_INT 1
54964: PPUSH
54965: LD_VAR 0 12
54969: PPUSH
54970: CALL_OW 12
54974: ARRAY
54975: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54976: LD_VAR 0 2
54980: PPUSH
54981: LD_VAR 0 5
54985: PPUSH
54986: CALL 55344 0 2
54990: NOT
54991: IFFALSE 55050
// repeat weapon := _weapon [ 1 ] ;
54993: LD_ADDR_VAR 0 5
54997: PUSH
54998: LD_VAR 0 10
55002: PUSH
55003: LD_INT 1
55005: ARRAY
55006: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55007: LD_ADDR_VAR 0 10
55011: PUSH
55012: LD_VAR 0 10
55016: PPUSH
55017: LD_INT 1
55019: PPUSH
55020: CALL_OW 3
55024: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55025: LD_VAR 0 2
55029: PPUSH
55030: LD_VAR 0 5
55034: PPUSH
55035: CALL 55344 0 2
55039: PUSH
55040: LD_VAR 0 10
55044: PUSH
55045: EMPTY
55046: EQUAL
55047: OR
55048: IFFALSE 54993
// result := [ ] ;
55050: LD_ADDR_VAR 0 6
55054: PUSH
55055: EMPTY
55056: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55057: LD_VAR 0 1
55061: PPUSH
55062: LD_VAR 0 2
55066: PPUSH
55067: LD_VAR 0 3
55071: PPUSH
55072: LD_VAR 0 4
55076: PPUSH
55077: LD_VAR 0 5
55081: PPUSH
55082: CALL_OW 448
55086: IFFALSE 55119
// result := [ chassis , engine , control , weapon ] ;
55088: LD_ADDR_VAR 0 6
55092: PUSH
55093: LD_VAR 0 2
55097: PUSH
55098: LD_VAR 0 3
55102: PUSH
55103: LD_VAR 0 4
55107: PUSH
55108: LD_VAR 0 5
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: LIST
55118: ST_TO_ADDR
// end ;
55119: LD_VAR 0 6
55123: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55124: LD_INT 0
55126: PPUSH
// if not chassis or not engine then
55127: LD_VAR 0 1
55131: NOT
55132: PUSH
55133: LD_VAR 0 2
55137: NOT
55138: OR
55139: IFFALSE 55143
// exit ;
55141: GO 55339
// case engine of engine_solar :
55143: LD_VAR 0 2
55147: PUSH
55148: LD_INT 2
55150: DOUBLE
55151: EQUAL
55152: IFTRUE 55156
55154: GO 55194
55156: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55157: LD_ADDR_VAR 0 3
55161: PUSH
55162: LD_INT 11
55164: PUSH
55165: LD_INT 12
55167: PUSH
55168: LD_INT 13
55170: PUSH
55171: LD_INT 14
55173: PUSH
55174: LD_INT 1
55176: PUSH
55177: LD_INT 2
55179: PUSH
55180: LD_INT 3
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: LIST
55190: LIST
55191: ST_TO_ADDR
55192: GO 55323
55194: LD_INT 1
55196: DOUBLE
55197: EQUAL
55198: IFTRUE 55202
55200: GO 55264
55202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55203: LD_ADDR_VAR 0 3
55207: PUSH
55208: LD_INT 11
55210: PUSH
55211: LD_INT 12
55213: PUSH
55214: LD_INT 13
55216: PUSH
55217: LD_INT 14
55219: PUSH
55220: LD_INT 1
55222: PUSH
55223: LD_INT 2
55225: PUSH
55226: LD_INT 3
55228: PUSH
55229: LD_INT 4
55231: PUSH
55232: LD_INT 5
55234: PUSH
55235: LD_INT 21
55237: PUSH
55238: LD_INT 23
55240: PUSH
55241: LD_INT 22
55243: PUSH
55244: LD_INT 24
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: LIST
55258: LIST
55259: LIST
55260: LIST
55261: ST_TO_ADDR
55262: GO 55323
55264: LD_INT 3
55266: DOUBLE
55267: EQUAL
55268: IFTRUE 55272
55270: GO 55322
55272: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55273: LD_ADDR_VAR 0 3
55277: PUSH
55278: LD_INT 13
55280: PUSH
55281: LD_INT 14
55283: PUSH
55284: LD_INT 2
55286: PUSH
55287: LD_INT 3
55289: PUSH
55290: LD_INT 4
55292: PUSH
55293: LD_INT 5
55295: PUSH
55296: LD_INT 21
55298: PUSH
55299: LD_INT 22
55301: PUSH
55302: LD_INT 23
55304: PUSH
55305: LD_INT 24
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: LIST
55312: LIST
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: ST_TO_ADDR
55320: GO 55323
55322: POP
// result := ( chassis in result ) ;
55323: LD_ADDR_VAR 0 3
55327: PUSH
55328: LD_VAR 0 1
55332: PUSH
55333: LD_VAR 0 3
55337: IN
55338: ST_TO_ADDR
// end ;
55339: LD_VAR 0 3
55343: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55344: LD_INT 0
55346: PPUSH
// if not chassis or not weapon then
55347: LD_VAR 0 1
55351: NOT
55352: PUSH
55353: LD_VAR 0 2
55357: NOT
55358: OR
55359: IFFALSE 55363
// exit ;
55361: GO 56425
// case weapon of us_machine_gun :
55363: LD_VAR 0 2
55367: PUSH
55368: LD_INT 2
55370: DOUBLE
55371: EQUAL
55372: IFTRUE 55376
55374: GO 55406
55376: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_INT 1
55384: PUSH
55385: LD_INT 2
55387: PUSH
55388: LD_INT 3
55390: PUSH
55391: LD_INT 4
55393: PUSH
55394: LD_INT 5
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: LIST
55402: LIST
55403: ST_TO_ADDR
55404: GO 56409
55406: LD_INT 3
55408: DOUBLE
55409: EQUAL
55410: IFTRUE 55414
55412: GO 55444
55414: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55415: LD_ADDR_VAR 0 3
55419: PUSH
55420: LD_INT 1
55422: PUSH
55423: LD_INT 2
55425: PUSH
55426: LD_INT 3
55428: PUSH
55429: LD_INT 4
55431: PUSH
55432: LD_INT 5
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: ST_TO_ADDR
55442: GO 56409
55444: LD_INT 11
55446: DOUBLE
55447: EQUAL
55448: IFTRUE 55452
55450: GO 55482
55452: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55453: LD_ADDR_VAR 0 3
55457: PUSH
55458: LD_INT 1
55460: PUSH
55461: LD_INT 2
55463: PUSH
55464: LD_INT 3
55466: PUSH
55467: LD_INT 4
55469: PUSH
55470: LD_INT 5
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: ST_TO_ADDR
55480: GO 56409
55482: LD_INT 4
55484: DOUBLE
55485: EQUAL
55486: IFTRUE 55490
55488: GO 55516
55490: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55491: LD_ADDR_VAR 0 3
55495: PUSH
55496: LD_INT 2
55498: PUSH
55499: LD_INT 3
55501: PUSH
55502: LD_INT 4
55504: PUSH
55505: LD_INT 5
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: LIST
55513: ST_TO_ADDR
55514: GO 56409
55516: LD_INT 5
55518: DOUBLE
55519: EQUAL
55520: IFTRUE 55524
55522: GO 55550
55524: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55525: LD_ADDR_VAR 0 3
55529: PUSH
55530: LD_INT 2
55532: PUSH
55533: LD_INT 3
55535: PUSH
55536: LD_INT 4
55538: PUSH
55539: LD_INT 5
55541: PUSH
55542: EMPTY
55543: LIST
55544: LIST
55545: LIST
55546: LIST
55547: ST_TO_ADDR
55548: GO 56409
55550: LD_INT 9
55552: DOUBLE
55553: EQUAL
55554: IFTRUE 55558
55556: GO 55584
55558: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55559: LD_ADDR_VAR 0 3
55563: PUSH
55564: LD_INT 2
55566: PUSH
55567: LD_INT 3
55569: PUSH
55570: LD_INT 4
55572: PUSH
55573: LD_INT 5
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: LIST
55580: LIST
55581: ST_TO_ADDR
55582: GO 56409
55584: LD_INT 7
55586: DOUBLE
55587: EQUAL
55588: IFTRUE 55592
55590: GO 55618
55592: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55593: LD_ADDR_VAR 0 3
55597: PUSH
55598: LD_INT 2
55600: PUSH
55601: LD_INT 3
55603: PUSH
55604: LD_INT 4
55606: PUSH
55607: LD_INT 5
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: ST_TO_ADDR
55616: GO 56409
55618: LD_INT 12
55620: DOUBLE
55621: EQUAL
55622: IFTRUE 55626
55624: GO 55652
55626: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55627: LD_ADDR_VAR 0 3
55631: PUSH
55632: LD_INT 2
55634: PUSH
55635: LD_INT 3
55637: PUSH
55638: LD_INT 4
55640: PUSH
55641: LD_INT 5
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: LIST
55648: LIST
55649: ST_TO_ADDR
55650: GO 56409
55652: LD_INT 13
55654: DOUBLE
55655: EQUAL
55656: IFTRUE 55660
55658: GO 55686
55660: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55661: LD_ADDR_VAR 0 3
55665: PUSH
55666: LD_INT 2
55668: PUSH
55669: LD_INT 3
55671: PUSH
55672: LD_INT 4
55674: PUSH
55675: LD_INT 5
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: LIST
55682: LIST
55683: ST_TO_ADDR
55684: GO 56409
55686: LD_INT 14
55688: DOUBLE
55689: EQUAL
55690: IFTRUE 55694
55692: GO 55712
55694: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55695: LD_ADDR_VAR 0 3
55699: PUSH
55700: LD_INT 4
55702: PUSH
55703: LD_INT 5
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: ST_TO_ADDR
55710: GO 56409
55712: LD_INT 6
55714: DOUBLE
55715: EQUAL
55716: IFTRUE 55720
55718: GO 55738
55720: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55721: LD_ADDR_VAR 0 3
55725: PUSH
55726: LD_INT 4
55728: PUSH
55729: LD_INT 5
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: ST_TO_ADDR
55736: GO 56409
55738: LD_INT 10
55740: DOUBLE
55741: EQUAL
55742: IFTRUE 55746
55744: GO 55764
55746: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55747: LD_ADDR_VAR 0 3
55751: PUSH
55752: LD_INT 4
55754: PUSH
55755: LD_INT 5
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: ST_TO_ADDR
55762: GO 56409
55764: LD_INT 22
55766: DOUBLE
55767: EQUAL
55768: IFTRUE 55772
55770: GO 55798
55772: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55773: LD_ADDR_VAR 0 3
55777: PUSH
55778: LD_INT 11
55780: PUSH
55781: LD_INT 12
55783: PUSH
55784: LD_INT 13
55786: PUSH
55787: LD_INT 14
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: LIST
55795: ST_TO_ADDR
55796: GO 56409
55798: LD_INT 23
55800: DOUBLE
55801: EQUAL
55802: IFTRUE 55806
55804: GO 55832
55806: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55807: LD_ADDR_VAR 0 3
55811: PUSH
55812: LD_INT 11
55814: PUSH
55815: LD_INT 12
55817: PUSH
55818: LD_INT 13
55820: PUSH
55821: LD_INT 14
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: ST_TO_ADDR
55830: GO 56409
55832: LD_INT 24
55834: DOUBLE
55835: EQUAL
55836: IFTRUE 55840
55838: GO 55866
55840: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55841: LD_ADDR_VAR 0 3
55845: PUSH
55846: LD_INT 11
55848: PUSH
55849: LD_INT 12
55851: PUSH
55852: LD_INT 13
55854: PUSH
55855: LD_INT 14
55857: PUSH
55858: EMPTY
55859: LIST
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
55864: GO 56409
55866: LD_INT 30
55868: DOUBLE
55869: EQUAL
55870: IFTRUE 55874
55872: GO 55900
55874: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55875: LD_ADDR_VAR 0 3
55879: PUSH
55880: LD_INT 11
55882: PUSH
55883: LD_INT 12
55885: PUSH
55886: LD_INT 13
55888: PUSH
55889: LD_INT 14
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: ST_TO_ADDR
55898: GO 56409
55900: LD_INT 25
55902: DOUBLE
55903: EQUAL
55904: IFTRUE 55908
55906: GO 55926
55908: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55909: LD_ADDR_VAR 0 3
55913: PUSH
55914: LD_INT 13
55916: PUSH
55917: LD_INT 14
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: ST_TO_ADDR
55924: GO 56409
55926: LD_INT 27
55928: DOUBLE
55929: EQUAL
55930: IFTRUE 55934
55932: GO 55952
55934: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55935: LD_ADDR_VAR 0 3
55939: PUSH
55940: LD_INT 13
55942: PUSH
55943: LD_INT 14
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: ST_TO_ADDR
55950: GO 56409
55952: LD_EXP 79
55956: DOUBLE
55957: EQUAL
55958: IFTRUE 55962
55960: GO 55988
55962: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55963: LD_ADDR_VAR 0 3
55967: PUSH
55968: LD_INT 11
55970: PUSH
55971: LD_INT 12
55973: PUSH
55974: LD_INT 13
55976: PUSH
55977: LD_INT 14
55979: PUSH
55980: EMPTY
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: ST_TO_ADDR
55986: GO 56409
55988: LD_INT 28
55990: DOUBLE
55991: EQUAL
55992: IFTRUE 55996
55994: GO 56014
55996: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55997: LD_ADDR_VAR 0 3
56001: PUSH
56002: LD_INT 13
56004: PUSH
56005: LD_INT 14
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: ST_TO_ADDR
56012: GO 56409
56014: LD_INT 29
56016: DOUBLE
56017: EQUAL
56018: IFTRUE 56022
56020: GO 56040
56022: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56023: LD_ADDR_VAR 0 3
56027: PUSH
56028: LD_INT 13
56030: PUSH
56031: LD_INT 14
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: ST_TO_ADDR
56038: GO 56409
56040: LD_INT 31
56042: DOUBLE
56043: EQUAL
56044: IFTRUE 56048
56046: GO 56066
56048: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_INT 13
56056: PUSH
56057: LD_INT 14
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: ST_TO_ADDR
56064: GO 56409
56066: LD_INT 26
56068: DOUBLE
56069: EQUAL
56070: IFTRUE 56074
56072: GO 56092
56074: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56075: LD_ADDR_VAR 0 3
56079: PUSH
56080: LD_INT 13
56082: PUSH
56083: LD_INT 14
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: ST_TO_ADDR
56090: GO 56409
56092: LD_INT 42
56094: DOUBLE
56095: EQUAL
56096: IFTRUE 56100
56098: GO 56126
56100: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56101: LD_ADDR_VAR 0 3
56105: PUSH
56106: LD_INT 21
56108: PUSH
56109: LD_INT 22
56111: PUSH
56112: LD_INT 23
56114: PUSH
56115: LD_INT 24
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: ST_TO_ADDR
56124: GO 56409
56126: LD_INT 43
56128: DOUBLE
56129: EQUAL
56130: IFTRUE 56134
56132: GO 56160
56134: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56135: LD_ADDR_VAR 0 3
56139: PUSH
56140: LD_INT 21
56142: PUSH
56143: LD_INT 22
56145: PUSH
56146: LD_INT 23
56148: PUSH
56149: LD_INT 24
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: ST_TO_ADDR
56158: GO 56409
56160: LD_INT 44
56162: DOUBLE
56163: EQUAL
56164: IFTRUE 56168
56166: GO 56194
56168: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56169: LD_ADDR_VAR 0 3
56173: PUSH
56174: LD_INT 21
56176: PUSH
56177: LD_INT 22
56179: PUSH
56180: LD_INT 23
56182: PUSH
56183: LD_INT 24
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: ST_TO_ADDR
56192: GO 56409
56194: LD_INT 45
56196: DOUBLE
56197: EQUAL
56198: IFTRUE 56202
56200: GO 56228
56202: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56203: LD_ADDR_VAR 0 3
56207: PUSH
56208: LD_INT 21
56210: PUSH
56211: LD_INT 22
56213: PUSH
56214: LD_INT 23
56216: PUSH
56217: LD_INT 24
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: LIST
56224: LIST
56225: ST_TO_ADDR
56226: GO 56409
56228: LD_INT 49
56230: DOUBLE
56231: EQUAL
56232: IFTRUE 56236
56234: GO 56262
56236: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56237: LD_ADDR_VAR 0 3
56241: PUSH
56242: LD_INT 21
56244: PUSH
56245: LD_INT 22
56247: PUSH
56248: LD_INT 23
56250: PUSH
56251: LD_INT 24
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: LIST
56258: LIST
56259: ST_TO_ADDR
56260: GO 56409
56262: LD_INT 51
56264: DOUBLE
56265: EQUAL
56266: IFTRUE 56270
56268: GO 56296
56270: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56271: LD_ADDR_VAR 0 3
56275: PUSH
56276: LD_INT 21
56278: PUSH
56279: LD_INT 22
56281: PUSH
56282: LD_INT 23
56284: PUSH
56285: LD_INT 24
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: ST_TO_ADDR
56294: GO 56409
56296: LD_INT 52
56298: DOUBLE
56299: EQUAL
56300: IFTRUE 56304
56302: GO 56330
56304: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56305: LD_ADDR_VAR 0 3
56309: PUSH
56310: LD_INT 21
56312: PUSH
56313: LD_INT 22
56315: PUSH
56316: LD_INT 23
56318: PUSH
56319: LD_INT 24
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: LIST
56326: LIST
56327: ST_TO_ADDR
56328: GO 56409
56330: LD_INT 53
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56338
56336: GO 56356
56338: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56339: LD_ADDR_VAR 0 3
56343: PUSH
56344: LD_INT 23
56346: PUSH
56347: LD_INT 24
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: ST_TO_ADDR
56354: GO 56409
56356: LD_INT 46
56358: DOUBLE
56359: EQUAL
56360: IFTRUE 56364
56362: GO 56382
56364: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56365: LD_ADDR_VAR 0 3
56369: PUSH
56370: LD_INT 23
56372: PUSH
56373: LD_INT 24
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: ST_TO_ADDR
56380: GO 56409
56382: LD_INT 47
56384: DOUBLE
56385: EQUAL
56386: IFTRUE 56390
56388: GO 56408
56390: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56391: LD_ADDR_VAR 0 3
56395: PUSH
56396: LD_INT 23
56398: PUSH
56399: LD_INT 24
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: ST_TO_ADDR
56406: GO 56409
56408: POP
// result := ( chassis in result ) ;
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_VAR 0 1
56418: PUSH
56419: LD_VAR 0 3
56423: IN
56424: ST_TO_ADDR
// end ;
56425: LD_VAR 0 3
56429: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56430: LD_INT 0
56432: PPUSH
56433: PPUSH
56434: PPUSH
56435: PPUSH
56436: PPUSH
56437: PPUSH
56438: PPUSH
// result := array ;
56439: LD_ADDR_VAR 0 5
56443: PUSH
56444: LD_VAR 0 1
56448: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56449: LD_VAR 0 1
56453: NOT
56454: PUSH
56455: LD_VAR 0 2
56459: NOT
56460: OR
56461: PUSH
56462: LD_VAR 0 3
56466: NOT
56467: OR
56468: PUSH
56469: LD_VAR 0 2
56473: PUSH
56474: LD_VAR 0 1
56478: GREATER
56479: OR
56480: PUSH
56481: LD_VAR 0 3
56485: PUSH
56486: LD_VAR 0 1
56490: GREATER
56491: OR
56492: IFFALSE 56496
// exit ;
56494: GO 56792
// if direction then
56496: LD_VAR 0 4
56500: IFFALSE 56564
// begin d := 1 ;
56502: LD_ADDR_VAR 0 9
56506: PUSH
56507: LD_INT 1
56509: ST_TO_ADDR
// if i_from > i_to then
56510: LD_VAR 0 2
56514: PUSH
56515: LD_VAR 0 3
56519: GREATER
56520: IFFALSE 56546
// length := ( array - i_from ) + i_to else
56522: LD_ADDR_VAR 0 11
56526: PUSH
56527: LD_VAR 0 1
56531: PUSH
56532: LD_VAR 0 2
56536: MINUS
56537: PUSH
56538: LD_VAR 0 3
56542: PLUS
56543: ST_TO_ADDR
56544: GO 56562
// length := i_to - i_from ;
56546: LD_ADDR_VAR 0 11
56550: PUSH
56551: LD_VAR 0 3
56555: PUSH
56556: LD_VAR 0 2
56560: MINUS
56561: ST_TO_ADDR
// end else
56562: GO 56625
// begin d := - 1 ;
56564: LD_ADDR_VAR 0 9
56568: PUSH
56569: LD_INT 1
56571: NEG
56572: ST_TO_ADDR
// if i_from > i_to then
56573: LD_VAR 0 2
56577: PUSH
56578: LD_VAR 0 3
56582: GREATER
56583: IFFALSE 56603
// length := i_from - i_to else
56585: LD_ADDR_VAR 0 11
56589: PUSH
56590: LD_VAR 0 2
56594: PUSH
56595: LD_VAR 0 3
56599: MINUS
56600: ST_TO_ADDR
56601: GO 56625
// length := ( array - i_to ) + i_from ;
56603: LD_ADDR_VAR 0 11
56607: PUSH
56608: LD_VAR 0 1
56612: PUSH
56613: LD_VAR 0 3
56617: MINUS
56618: PUSH
56619: LD_VAR 0 2
56623: PLUS
56624: ST_TO_ADDR
// end ; if not length then
56625: LD_VAR 0 11
56629: NOT
56630: IFFALSE 56634
// exit ;
56632: GO 56792
// tmp := array ;
56634: LD_ADDR_VAR 0 10
56638: PUSH
56639: LD_VAR 0 1
56643: ST_TO_ADDR
// for i = 1 to length do
56644: LD_ADDR_VAR 0 6
56648: PUSH
56649: DOUBLE
56650: LD_INT 1
56652: DEC
56653: ST_TO_ADDR
56654: LD_VAR 0 11
56658: PUSH
56659: FOR_TO
56660: IFFALSE 56780
// begin for j = 1 to array do
56662: LD_ADDR_VAR 0 7
56666: PUSH
56667: DOUBLE
56668: LD_INT 1
56670: DEC
56671: ST_TO_ADDR
56672: LD_VAR 0 1
56676: PUSH
56677: FOR_TO
56678: IFFALSE 56766
// begin k := j + d ;
56680: LD_ADDR_VAR 0 8
56684: PUSH
56685: LD_VAR 0 7
56689: PUSH
56690: LD_VAR 0 9
56694: PLUS
56695: ST_TO_ADDR
// if k > array then
56696: LD_VAR 0 8
56700: PUSH
56701: LD_VAR 0 1
56705: GREATER
56706: IFFALSE 56716
// k := 1 ;
56708: LD_ADDR_VAR 0 8
56712: PUSH
56713: LD_INT 1
56715: ST_TO_ADDR
// if not k then
56716: LD_VAR 0 8
56720: NOT
56721: IFFALSE 56733
// k := array ;
56723: LD_ADDR_VAR 0 8
56727: PUSH
56728: LD_VAR 0 1
56732: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56733: LD_ADDR_VAR 0 10
56737: PUSH
56738: LD_VAR 0 10
56742: PPUSH
56743: LD_VAR 0 8
56747: PPUSH
56748: LD_VAR 0 1
56752: PUSH
56753: LD_VAR 0 7
56757: ARRAY
56758: PPUSH
56759: CALL_OW 1
56763: ST_TO_ADDR
// end ;
56764: GO 56677
56766: POP
56767: POP
// array := tmp ;
56768: LD_ADDR_VAR 0 1
56772: PUSH
56773: LD_VAR 0 10
56777: ST_TO_ADDR
// end ;
56778: GO 56659
56780: POP
56781: POP
// result := array ;
56782: LD_ADDR_VAR 0 5
56786: PUSH
56787: LD_VAR 0 1
56791: ST_TO_ADDR
// end ;
56792: LD_VAR 0 5
56796: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
// result := 0 ;
56801: LD_ADDR_VAR 0 3
56805: PUSH
56806: LD_INT 0
56808: ST_TO_ADDR
// if not array or not value in array then
56809: LD_VAR 0 1
56813: NOT
56814: PUSH
56815: LD_VAR 0 2
56819: PUSH
56820: LD_VAR 0 1
56824: IN
56825: NOT
56826: OR
56827: IFFALSE 56831
// exit ;
56829: GO 56885
// for i = 1 to array do
56831: LD_ADDR_VAR 0 4
56835: PUSH
56836: DOUBLE
56837: LD_INT 1
56839: DEC
56840: ST_TO_ADDR
56841: LD_VAR 0 1
56845: PUSH
56846: FOR_TO
56847: IFFALSE 56883
// if value = array [ i ] then
56849: LD_VAR 0 2
56853: PUSH
56854: LD_VAR 0 1
56858: PUSH
56859: LD_VAR 0 4
56863: ARRAY
56864: EQUAL
56865: IFFALSE 56881
// begin result := i ;
56867: LD_ADDR_VAR 0 3
56871: PUSH
56872: LD_VAR 0 4
56876: ST_TO_ADDR
// exit ;
56877: POP
56878: POP
56879: GO 56885
// end ;
56881: GO 56846
56883: POP
56884: POP
// end ;
56885: LD_VAR 0 3
56889: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56890: LD_INT 0
56892: PPUSH
// vc_chassis := chassis ;
56893: LD_ADDR_OWVAR 37
56897: PUSH
56898: LD_VAR 0 1
56902: ST_TO_ADDR
// vc_engine := engine ;
56903: LD_ADDR_OWVAR 39
56907: PUSH
56908: LD_VAR 0 2
56912: ST_TO_ADDR
// vc_control := control ;
56913: LD_ADDR_OWVAR 38
56917: PUSH
56918: LD_VAR 0 3
56922: ST_TO_ADDR
// vc_weapon := weapon ;
56923: LD_ADDR_OWVAR 40
56927: PUSH
56928: LD_VAR 0 4
56932: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56933: LD_ADDR_OWVAR 41
56937: PUSH
56938: LD_VAR 0 5
56942: ST_TO_ADDR
// end ;
56943: LD_VAR 0 6
56947: RET
// export function WantPlant ( unit ) ; var task ; begin
56948: LD_INT 0
56950: PPUSH
56951: PPUSH
// result := false ;
56952: LD_ADDR_VAR 0 2
56956: PUSH
56957: LD_INT 0
56959: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56960: LD_ADDR_VAR 0 3
56964: PUSH
56965: LD_VAR 0 1
56969: PPUSH
56970: CALL_OW 437
56974: ST_TO_ADDR
// if task then
56975: LD_VAR 0 3
56979: IFFALSE 57007
// if task [ 1 ] [ 1 ] = p then
56981: LD_VAR 0 3
56985: PUSH
56986: LD_INT 1
56988: ARRAY
56989: PUSH
56990: LD_INT 1
56992: ARRAY
56993: PUSH
56994: LD_STRING p
56996: EQUAL
56997: IFFALSE 57007
// result := true ;
56999: LD_ADDR_VAR 0 2
57003: PUSH
57004: LD_INT 1
57006: ST_TO_ADDR
// end ;
57007: LD_VAR 0 2
57011: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57012: LD_INT 0
57014: PPUSH
57015: PPUSH
57016: PPUSH
57017: PPUSH
// if pos < 1 then
57018: LD_VAR 0 2
57022: PUSH
57023: LD_INT 1
57025: LESS
57026: IFFALSE 57030
// exit ;
57028: GO 57333
// if pos = 1 then
57030: LD_VAR 0 2
57034: PUSH
57035: LD_INT 1
57037: EQUAL
57038: IFFALSE 57071
// result := Replace ( arr , pos [ 1 ] , value ) else
57040: LD_ADDR_VAR 0 4
57044: PUSH
57045: LD_VAR 0 1
57049: PPUSH
57050: LD_VAR 0 2
57054: PUSH
57055: LD_INT 1
57057: ARRAY
57058: PPUSH
57059: LD_VAR 0 3
57063: PPUSH
57064: CALL_OW 1
57068: ST_TO_ADDR
57069: GO 57333
// begin tmp := arr ;
57071: LD_ADDR_VAR 0 6
57075: PUSH
57076: LD_VAR 0 1
57080: ST_TO_ADDR
// s_arr := [ tmp ] ;
57081: LD_ADDR_VAR 0 7
57085: PUSH
57086: LD_VAR 0 6
57090: PUSH
57091: EMPTY
57092: LIST
57093: ST_TO_ADDR
// for i = 1 to pos - 1 do
57094: LD_ADDR_VAR 0 5
57098: PUSH
57099: DOUBLE
57100: LD_INT 1
57102: DEC
57103: ST_TO_ADDR
57104: LD_VAR 0 2
57108: PUSH
57109: LD_INT 1
57111: MINUS
57112: PUSH
57113: FOR_TO
57114: IFFALSE 57159
// begin tmp := tmp [ pos [ i ] ] ;
57116: LD_ADDR_VAR 0 6
57120: PUSH
57121: LD_VAR 0 6
57125: PUSH
57126: LD_VAR 0 2
57130: PUSH
57131: LD_VAR 0 5
57135: ARRAY
57136: ARRAY
57137: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57138: LD_ADDR_VAR 0 7
57142: PUSH
57143: LD_VAR 0 7
57147: PUSH
57148: LD_VAR 0 6
57152: PUSH
57153: EMPTY
57154: LIST
57155: ADD
57156: ST_TO_ADDR
// end ;
57157: GO 57113
57159: POP
57160: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57161: LD_ADDR_VAR 0 6
57165: PUSH
57166: LD_VAR 0 6
57170: PPUSH
57171: LD_VAR 0 2
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: PPUSH
57182: LD_VAR 0 3
57186: PPUSH
57187: CALL_OW 1
57191: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57192: LD_ADDR_VAR 0 7
57196: PUSH
57197: LD_VAR 0 7
57201: PPUSH
57202: LD_VAR 0 7
57206: PPUSH
57207: LD_VAR 0 6
57211: PPUSH
57212: CALL_OW 1
57216: ST_TO_ADDR
// for i = s_arr downto 2 do
57217: LD_ADDR_VAR 0 5
57221: PUSH
57222: DOUBLE
57223: LD_VAR 0 7
57227: INC
57228: ST_TO_ADDR
57229: LD_INT 2
57231: PUSH
57232: FOR_DOWNTO
57233: IFFALSE 57317
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57235: LD_ADDR_VAR 0 6
57239: PUSH
57240: LD_VAR 0 7
57244: PUSH
57245: LD_VAR 0 5
57249: PUSH
57250: LD_INT 1
57252: MINUS
57253: ARRAY
57254: PPUSH
57255: LD_VAR 0 2
57259: PUSH
57260: LD_VAR 0 5
57264: PUSH
57265: LD_INT 1
57267: MINUS
57268: ARRAY
57269: PPUSH
57270: LD_VAR 0 7
57274: PUSH
57275: LD_VAR 0 5
57279: ARRAY
57280: PPUSH
57281: CALL_OW 1
57285: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57286: LD_ADDR_VAR 0 7
57290: PUSH
57291: LD_VAR 0 7
57295: PPUSH
57296: LD_VAR 0 5
57300: PUSH
57301: LD_INT 1
57303: MINUS
57304: PPUSH
57305: LD_VAR 0 6
57309: PPUSH
57310: CALL_OW 1
57314: ST_TO_ADDR
// end ;
57315: GO 57232
57317: POP
57318: POP
// result := s_arr [ 1 ] ;
57319: LD_ADDR_VAR 0 4
57323: PUSH
57324: LD_VAR 0 7
57328: PUSH
57329: LD_INT 1
57331: ARRAY
57332: ST_TO_ADDR
// end ; end ;
57333: LD_VAR 0 4
57337: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57338: LD_INT 0
57340: PPUSH
57341: PPUSH
// if not list then
57342: LD_VAR 0 1
57346: NOT
57347: IFFALSE 57351
// exit ;
57349: GO 57442
// i := list [ pos1 ] ;
57351: LD_ADDR_VAR 0 5
57355: PUSH
57356: LD_VAR 0 1
57360: PUSH
57361: LD_VAR 0 2
57365: ARRAY
57366: ST_TO_ADDR
// if not i then
57367: LD_VAR 0 5
57371: NOT
57372: IFFALSE 57376
// exit ;
57374: GO 57442
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57376: LD_ADDR_VAR 0 1
57380: PUSH
57381: LD_VAR 0 1
57385: PPUSH
57386: LD_VAR 0 2
57390: PPUSH
57391: LD_VAR 0 1
57395: PUSH
57396: LD_VAR 0 3
57400: ARRAY
57401: PPUSH
57402: CALL_OW 1
57406: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57407: LD_ADDR_VAR 0 1
57411: PUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: LD_VAR 0 3
57421: PPUSH
57422: LD_VAR 0 5
57426: PPUSH
57427: CALL_OW 1
57431: ST_TO_ADDR
// result := list ;
57432: LD_ADDR_VAR 0 4
57436: PUSH
57437: LD_VAR 0 1
57441: ST_TO_ADDR
// end ;
57442: LD_VAR 0 4
57446: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57447: LD_INT 0
57449: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57450: LD_ADDR_VAR 0 5
57454: PUSH
57455: LD_VAR 0 1
57459: PPUSH
57460: CALL_OW 250
57464: PPUSH
57465: LD_VAR 0 1
57469: PPUSH
57470: CALL_OW 251
57474: PPUSH
57475: LD_VAR 0 2
57479: PPUSH
57480: LD_VAR 0 3
57484: PPUSH
57485: LD_VAR 0 4
57489: PPUSH
57490: CALL 57500 0 5
57494: ST_TO_ADDR
// end ;
57495: LD_VAR 0 5
57499: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57500: LD_INT 0
57502: PPUSH
57503: PPUSH
57504: PPUSH
57505: PPUSH
// if not list then
57506: LD_VAR 0 3
57510: NOT
57511: IFFALSE 57515
// exit ;
57513: GO 57903
// result := [ ] ;
57515: LD_ADDR_VAR 0 6
57519: PUSH
57520: EMPTY
57521: ST_TO_ADDR
// for i in list do
57522: LD_ADDR_VAR 0 7
57526: PUSH
57527: LD_VAR 0 3
57531: PUSH
57532: FOR_IN
57533: IFFALSE 57735
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57535: LD_ADDR_VAR 0 9
57539: PUSH
57540: LD_VAR 0 7
57544: PPUSH
57545: LD_VAR 0 1
57549: PPUSH
57550: LD_VAR 0 2
57554: PPUSH
57555: CALL_OW 297
57559: ST_TO_ADDR
// if not result then
57560: LD_VAR 0 6
57564: NOT
57565: IFFALSE 57591
// result := [ [ i , tmp ] ] else
57567: LD_ADDR_VAR 0 6
57571: PUSH
57572: LD_VAR 0 7
57576: PUSH
57577: LD_VAR 0 9
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: PUSH
57586: EMPTY
57587: LIST
57588: ST_TO_ADDR
57589: GO 57733
// begin if result [ result ] [ 2 ] < tmp then
57591: LD_VAR 0 6
57595: PUSH
57596: LD_VAR 0 6
57600: ARRAY
57601: PUSH
57602: LD_INT 2
57604: ARRAY
57605: PUSH
57606: LD_VAR 0 9
57610: LESS
57611: IFFALSE 57653
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57613: LD_ADDR_VAR 0 6
57617: PUSH
57618: LD_VAR 0 6
57622: PPUSH
57623: LD_VAR 0 6
57627: PUSH
57628: LD_INT 1
57630: PLUS
57631: PPUSH
57632: LD_VAR 0 7
57636: PUSH
57637: LD_VAR 0 9
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PPUSH
57646: CALL_OW 2
57650: ST_TO_ADDR
57651: GO 57733
// for j = 1 to result do
57653: LD_ADDR_VAR 0 8
57657: PUSH
57658: DOUBLE
57659: LD_INT 1
57661: DEC
57662: ST_TO_ADDR
57663: LD_VAR 0 6
57667: PUSH
57668: FOR_TO
57669: IFFALSE 57731
// begin if tmp < result [ j ] [ 2 ] then
57671: LD_VAR 0 9
57675: PUSH
57676: LD_VAR 0 6
57680: PUSH
57681: LD_VAR 0 8
57685: ARRAY
57686: PUSH
57687: LD_INT 2
57689: ARRAY
57690: LESS
57691: IFFALSE 57729
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57693: LD_ADDR_VAR 0 6
57697: PUSH
57698: LD_VAR 0 6
57702: PPUSH
57703: LD_VAR 0 8
57707: PPUSH
57708: LD_VAR 0 7
57712: PUSH
57713: LD_VAR 0 9
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PPUSH
57722: CALL_OW 2
57726: ST_TO_ADDR
// break ;
57727: GO 57731
// end ; end ;
57729: GO 57668
57731: POP
57732: POP
// end ; end ;
57733: GO 57532
57735: POP
57736: POP
// if result and not asc then
57737: LD_VAR 0 6
57741: PUSH
57742: LD_VAR 0 4
57746: NOT
57747: AND
57748: IFFALSE 57823
// begin tmp := result ;
57750: LD_ADDR_VAR 0 9
57754: PUSH
57755: LD_VAR 0 6
57759: ST_TO_ADDR
// for i = tmp downto 1 do
57760: LD_ADDR_VAR 0 7
57764: PUSH
57765: DOUBLE
57766: LD_VAR 0 9
57770: INC
57771: ST_TO_ADDR
57772: LD_INT 1
57774: PUSH
57775: FOR_DOWNTO
57776: IFFALSE 57821
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57778: LD_ADDR_VAR 0 6
57782: PUSH
57783: LD_VAR 0 6
57787: PPUSH
57788: LD_VAR 0 9
57792: PUSH
57793: LD_VAR 0 7
57797: MINUS
57798: PUSH
57799: LD_INT 1
57801: PLUS
57802: PPUSH
57803: LD_VAR 0 9
57807: PUSH
57808: LD_VAR 0 7
57812: ARRAY
57813: PPUSH
57814: CALL_OW 1
57818: ST_TO_ADDR
57819: GO 57775
57821: POP
57822: POP
// end ; tmp := [ ] ;
57823: LD_ADDR_VAR 0 9
57827: PUSH
57828: EMPTY
57829: ST_TO_ADDR
// if mode then
57830: LD_VAR 0 5
57834: IFFALSE 57903
// begin for i = 1 to result do
57836: LD_ADDR_VAR 0 7
57840: PUSH
57841: DOUBLE
57842: LD_INT 1
57844: DEC
57845: ST_TO_ADDR
57846: LD_VAR 0 6
57850: PUSH
57851: FOR_TO
57852: IFFALSE 57891
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57854: LD_ADDR_VAR 0 9
57858: PUSH
57859: LD_VAR 0 9
57863: PPUSH
57864: LD_VAR 0 7
57868: PPUSH
57869: LD_VAR 0 6
57873: PUSH
57874: LD_VAR 0 7
57878: ARRAY
57879: PUSH
57880: LD_INT 1
57882: ARRAY
57883: PPUSH
57884: CALL_OW 1
57888: ST_TO_ADDR
57889: GO 57851
57891: POP
57892: POP
// result := tmp ;
57893: LD_ADDR_VAR 0 6
57897: PUSH
57898: LD_VAR 0 9
57902: ST_TO_ADDR
// end ; end ;
57903: LD_VAR 0 6
57907: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57908: LD_INT 0
57910: PPUSH
57911: PPUSH
57912: PPUSH
57913: PPUSH
57914: PPUSH
57915: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57916: LD_ADDR_VAR 0 5
57920: PUSH
57921: LD_INT 0
57923: PUSH
57924: LD_INT 0
57926: PUSH
57927: LD_INT 0
57929: PUSH
57930: EMPTY
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: LIST
57936: LIST
57937: ST_TO_ADDR
// if not x or not y then
57938: LD_VAR 0 2
57942: NOT
57943: PUSH
57944: LD_VAR 0 3
57948: NOT
57949: OR
57950: IFFALSE 57954
// exit ;
57952: GO 59606
// if not range then
57954: LD_VAR 0 4
57958: NOT
57959: IFFALSE 57969
// range := 10 ;
57961: LD_ADDR_VAR 0 4
57965: PUSH
57966: LD_INT 10
57968: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57969: LD_ADDR_VAR 0 8
57973: PUSH
57974: LD_INT 81
57976: PUSH
57977: LD_VAR 0 1
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PUSH
57986: LD_INT 92
57988: PUSH
57989: LD_VAR 0 2
57993: PUSH
57994: LD_VAR 0 3
57998: PUSH
57999: LD_VAR 0 4
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: LIST
58008: LIST
58009: PUSH
58010: LD_INT 3
58012: PUSH
58013: LD_INT 21
58015: PUSH
58016: LD_INT 3
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: LIST
58031: PPUSH
58032: CALL_OW 69
58036: ST_TO_ADDR
// if not tmp then
58037: LD_VAR 0 8
58041: NOT
58042: IFFALSE 58046
// exit ;
58044: GO 59606
// for i in tmp do
58046: LD_ADDR_VAR 0 6
58050: PUSH
58051: LD_VAR 0 8
58055: PUSH
58056: FOR_IN
58057: IFFALSE 59581
// begin points := [ 0 , 0 , 0 ] ;
58059: LD_ADDR_VAR 0 9
58063: PUSH
58064: LD_INT 0
58066: PUSH
58067: LD_INT 0
58069: PUSH
58070: LD_INT 0
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: ST_TO_ADDR
// bpoints := 1 ;
58078: LD_ADDR_VAR 0 10
58082: PUSH
58083: LD_INT 1
58085: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58086: LD_VAR 0 6
58090: PPUSH
58091: CALL_OW 247
58095: PUSH
58096: LD_INT 1
58098: DOUBLE
58099: EQUAL
58100: IFTRUE 58104
58102: GO 58682
58104: POP
// begin if GetClass ( i ) = 1 then
58105: LD_VAR 0 6
58109: PPUSH
58110: CALL_OW 257
58114: PUSH
58115: LD_INT 1
58117: EQUAL
58118: IFFALSE 58139
// points := [ 10 , 5 , 3 ] ;
58120: LD_ADDR_VAR 0 9
58124: PUSH
58125: LD_INT 10
58127: PUSH
58128: LD_INT 5
58130: PUSH
58131: LD_INT 3
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: LIST
58138: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58139: LD_VAR 0 6
58143: PPUSH
58144: CALL_OW 257
58148: PUSH
58149: LD_INT 2
58151: PUSH
58152: LD_INT 3
58154: PUSH
58155: LD_INT 4
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: LIST
58162: IN
58163: IFFALSE 58184
// points := [ 3 , 2 , 1 ] ;
58165: LD_ADDR_VAR 0 9
58169: PUSH
58170: LD_INT 3
58172: PUSH
58173: LD_INT 2
58175: PUSH
58176: LD_INT 1
58178: PUSH
58179: EMPTY
58180: LIST
58181: LIST
58182: LIST
58183: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58184: LD_VAR 0 6
58188: PPUSH
58189: CALL_OW 257
58193: PUSH
58194: LD_INT 5
58196: EQUAL
58197: IFFALSE 58218
// points := [ 130 , 5 , 2 ] ;
58199: LD_ADDR_VAR 0 9
58203: PUSH
58204: LD_INT 130
58206: PUSH
58207: LD_INT 5
58209: PUSH
58210: LD_INT 2
58212: PUSH
58213: EMPTY
58214: LIST
58215: LIST
58216: LIST
58217: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58218: LD_VAR 0 6
58222: PPUSH
58223: CALL_OW 257
58227: PUSH
58228: LD_INT 8
58230: EQUAL
58231: IFFALSE 58252
// points := [ 35 , 35 , 30 ] ;
58233: LD_ADDR_VAR 0 9
58237: PUSH
58238: LD_INT 35
58240: PUSH
58241: LD_INT 35
58243: PUSH
58244: LD_INT 30
58246: PUSH
58247: EMPTY
58248: LIST
58249: LIST
58250: LIST
58251: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58252: LD_VAR 0 6
58256: PPUSH
58257: CALL_OW 257
58261: PUSH
58262: LD_INT 9
58264: EQUAL
58265: IFFALSE 58286
// points := [ 20 , 55 , 40 ] ;
58267: LD_ADDR_VAR 0 9
58271: PUSH
58272: LD_INT 20
58274: PUSH
58275: LD_INT 55
58277: PUSH
58278: LD_INT 40
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: LIST
58285: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58286: LD_VAR 0 6
58290: PPUSH
58291: CALL_OW 257
58295: PUSH
58296: LD_INT 12
58298: PUSH
58299: LD_INT 16
58301: PUSH
58302: EMPTY
58303: LIST
58304: LIST
58305: IN
58306: IFFALSE 58327
// points := [ 5 , 3 , 2 ] ;
58308: LD_ADDR_VAR 0 9
58312: PUSH
58313: LD_INT 5
58315: PUSH
58316: LD_INT 3
58318: PUSH
58319: LD_INT 2
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: LIST
58326: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58327: LD_VAR 0 6
58331: PPUSH
58332: CALL_OW 257
58336: PUSH
58337: LD_INT 17
58339: EQUAL
58340: IFFALSE 58361
// points := [ 100 , 50 , 75 ] ;
58342: LD_ADDR_VAR 0 9
58346: PUSH
58347: LD_INT 100
58349: PUSH
58350: LD_INT 50
58352: PUSH
58353: LD_INT 75
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: LIST
58360: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58361: LD_VAR 0 6
58365: PPUSH
58366: CALL_OW 257
58370: PUSH
58371: LD_INT 15
58373: EQUAL
58374: IFFALSE 58395
// points := [ 10 , 5 , 3 ] ;
58376: LD_ADDR_VAR 0 9
58380: PUSH
58381: LD_INT 10
58383: PUSH
58384: LD_INT 5
58386: PUSH
58387: LD_INT 3
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58395: LD_VAR 0 6
58399: PPUSH
58400: CALL_OW 257
58404: PUSH
58405: LD_INT 14
58407: EQUAL
58408: IFFALSE 58429
// points := [ 10 , 0 , 0 ] ;
58410: LD_ADDR_VAR 0 9
58414: PUSH
58415: LD_INT 10
58417: PUSH
58418: LD_INT 0
58420: PUSH
58421: LD_INT 0
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: LIST
58428: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58429: LD_VAR 0 6
58433: PPUSH
58434: CALL_OW 257
58438: PUSH
58439: LD_INT 11
58441: EQUAL
58442: IFFALSE 58463
// points := [ 30 , 10 , 5 ] ;
58444: LD_ADDR_VAR 0 9
58448: PUSH
58449: LD_INT 30
58451: PUSH
58452: LD_INT 10
58454: PUSH
58455: LD_INT 5
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: LIST
58462: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58463: LD_VAR 0 1
58467: PPUSH
58468: LD_INT 5
58470: PPUSH
58471: CALL_OW 321
58475: PUSH
58476: LD_INT 2
58478: EQUAL
58479: IFFALSE 58496
// bpoints := bpoints * 1.8 ;
58481: LD_ADDR_VAR 0 10
58485: PUSH
58486: LD_VAR 0 10
58490: PUSH
58491: LD_REAL  1.80000000000000E+0000
58494: MUL
58495: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58496: LD_VAR 0 6
58500: PPUSH
58501: CALL_OW 257
58505: PUSH
58506: LD_INT 1
58508: PUSH
58509: LD_INT 2
58511: PUSH
58512: LD_INT 3
58514: PUSH
58515: LD_INT 4
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: IN
58524: PUSH
58525: LD_VAR 0 1
58529: PPUSH
58530: LD_INT 51
58532: PPUSH
58533: CALL_OW 321
58537: PUSH
58538: LD_INT 2
58540: EQUAL
58541: AND
58542: IFFALSE 58559
// bpoints := bpoints * 1.2 ;
58544: LD_ADDR_VAR 0 10
58548: PUSH
58549: LD_VAR 0 10
58553: PUSH
58554: LD_REAL  1.20000000000000E+0000
58557: MUL
58558: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58559: LD_VAR 0 6
58563: PPUSH
58564: CALL_OW 257
58568: PUSH
58569: LD_INT 5
58571: PUSH
58572: LD_INT 7
58574: PUSH
58575: LD_INT 9
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: IN
58583: PUSH
58584: LD_VAR 0 1
58588: PPUSH
58589: LD_INT 52
58591: PPUSH
58592: CALL_OW 321
58596: PUSH
58597: LD_INT 2
58599: EQUAL
58600: AND
58601: IFFALSE 58618
// bpoints := bpoints * 1.5 ;
58603: LD_ADDR_VAR 0 10
58607: PUSH
58608: LD_VAR 0 10
58612: PUSH
58613: LD_REAL  1.50000000000000E+0000
58616: MUL
58617: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58618: LD_VAR 0 1
58622: PPUSH
58623: LD_INT 66
58625: PPUSH
58626: CALL_OW 321
58630: PUSH
58631: LD_INT 2
58633: EQUAL
58634: IFFALSE 58651
// bpoints := bpoints * 1.1 ;
58636: LD_ADDR_VAR 0 10
58640: PUSH
58641: LD_VAR 0 10
58645: PUSH
58646: LD_REAL  1.10000000000000E+0000
58649: MUL
58650: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58651: LD_ADDR_VAR 0 10
58655: PUSH
58656: LD_VAR 0 10
58660: PUSH
58661: LD_VAR 0 6
58665: PPUSH
58666: LD_INT 1
58668: PPUSH
58669: CALL_OW 259
58673: PUSH
58674: LD_REAL  1.15000000000000E+0000
58677: MUL
58678: MUL
58679: ST_TO_ADDR
// end ; unit_vehicle :
58680: GO 59510
58682: LD_INT 2
58684: DOUBLE
58685: EQUAL
58686: IFTRUE 58690
58688: GO 59498
58690: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58691: LD_VAR 0 6
58695: PPUSH
58696: CALL_OW 264
58700: PUSH
58701: LD_INT 2
58703: PUSH
58704: LD_INT 42
58706: PUSH
58707: LD_INT 24
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: LIST
58714: IN
58715: IFFALSE 58736
// points := [ 25 , 5 , 3 ] ;
58717: LD_ADDR_VAR 0 9
58721: PUSH
58722: LD_INT 25
58724: PUSH
58725: LD_INT 5
58727: PUSH
58728: LD_INT 3
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: LIST
58735: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58736: LD_VAR 0 6
58740: PPUSH
58741: CALL_OW 264
58745: PUSH
58746: LD_INT 4
58748: PUSH
58749: LD_INT 43
58751: PUSH
58752: LD_INT 25
58754: PUSH
58755: EMPTY
58756: LIST
58757: LIST
58758: LIST
58759: IN
58760: IFFALSE 58781
// points := [ 40 , 15 , 5 ] ;
58762: LD_ADDR_VAR 0 9
58766: PUSH
58767: LD_INT 40
58769: PUSH
58770: LD_INT 15
58772: PUSH
58773: LD_INT 5
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: LIST
58780: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58781: LD_VAR 0 6
58785: PPUSH
58786: CALL_OW 264
58790: PUSH
58791: LD_INT 3
58793: PUSH
58794: LD_INT 23
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: IN
58801: IFFALSE 58822
// points := [ 7 , 25 , 8 ] ;
58803: LD_ADDR_VAR 0 9
58807: PUSH
58808: LD_INT 7
58810: PUSH
58811: LD_INT 25
58813: PUSH
58814: LD_INT 8
58816: PUSH
58817: EMPTY
58818: LIST
58819: LIST
58820: LIST
58821: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58822: LD_VAR 0 6
58826: PPUSH
58827: CALL_OW 264
58831: PUSH
58832: LD_INT 5
58834: PUSH
58835: LD_INT 27
58837: PUSH
58838: LD_INT 44
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: LIST
58845: IN
58846: IFFALSE 58867
// points := [ 14 , 50 , 16 ] ;
58848: LD_ADDR_VAR 0 9
58852: PUSH
58853: LD_INT 14
58855: PUSH
58856: LD_INT 50
58858: PUSH
58859: LD_INT 16
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: LIST
58866: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58867: LD_VAR 0 6
58871: PPUSH
58872: CALL_OW 264
58876: PUSH
58877: LD_INT 6
58879: PUSH
58880: LD_INT 46
58882: PUSH
58883: EMPTY
58884: LIST
58885: LIST
58886: IN
58887: IFFALSE 58908
// points := [ 32 , 120 , 70 ] ;
58889: LD_ADDR_VAR 0 9
58893: PUSH
58894: LD_INT 32
58896: PUSH
58897: LD_INT 120
58899: PUSH
58900: LD_INT 70
58902: PUSH
58903: EMPTY
58904: LIST
58905: LIST
58906: LIST
58907: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58908: LD_VAR 0 6
58912: PPUSH
58913: CALL_OW 264
58917: PUSH
58918: LD_INT 7
58920: PUSH
58921: LD_INT 28
58923: PUSH
58924: LD_INT 45
58926: PUSH
58927: LD_EXP 79
58931: PUSH
58932: EMPTY
58933: LIST
58934: LIST
58935: LIST
58936: LIST
58937: IN
58938: IFFALSE 58959
// points := [ 35 , 20 , 45 ] ;
58940: LD_ADDR_VAR 0 9
58944: PUSH
58945: LD_INT 35
58947: PUSH
58948: LD_INT 20
58950: PUSH
58951: LD_INT 45
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: LIST
58958: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58959: LD_VAR 0 6
58963: PPUSH
58964: CALL_OW 264
58968: PUSH
58969: LD_INT 47
58971: PUSH
58972: EMPTY
58973: LIST
58974: IN
58975: IFFALSE 58996
// points := [ 67 , 45 , 75 ] ;
58977: LD_ADDR_VAR 0 9
58981: PUSH
58982: LD_INT 67
58984: PUSH
58985: LD_INT 45
58987: PUSH
58988: LD_INT 75
58990: PUSH
58991: EMPTY
58992: LIST
58993: LIST
58994: LIST
58995: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58996: LD_VAR 0 6
59000: PPUSH
59001: CALL_OW 264
59005: PUSH
59006: LD_INT 26
59008: PUSH
59009: EMPTY
59010: LIST
59011: IN
59012: IFFALSE 59033
// points := [ 120 , 30 , 80 ] ;
59014: LD_ADDR_VAR 0 9
59018: PUSH
59019: LD_INT 120
59021: PUSH
59022: LD_INT 30
59024: PUSH
59025: LD_INT 80
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59033: LD_VAR 0 6
59037: PPUSH
59038: CALL_OW 264
59042: PUSH
59043: LD_INT 22
59045: PUSH
59046: EMPTY
59047: LIST
59048: IN
59049: IFFALSE 59070
// points := [ 40 , 1 , 1 ] ;
59051: LD_ADDR_VAR 0 9
59055: PUSH
59056: LD_INT 40
59058: PUSH
59059: LD_INT 1
59061: PUSH
59062: LD_INT 1
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59070: LD_VAR 0 6
59074: PPUSH
59075: CALL_OW 264
59079: PUSH
59080: LD_INT 29
59082: PUSH
59083: EMPTY
59084: LIST
59085: IN
59086: IFFALSE 59107
// points := [ 70 , 200 , 400 ] ;
59088: LD_ADDR_VAR 0 9
59092: PUSH
59093: LD_INT 70
59095: PUSH
59096: LD_INT 200
59098: PUSH
59099: LD_INT 400
59101: PUSH
59102: EMPTY
59103: LIST
59104: LIST
59105: LIST
59106: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59107: LD_VAR 0 6
59111: PPUSH
59112: CALL_OW 264
59116: PUSH
59117: LD_INT 14
59119: PUSH
59120: LD_INT 53
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: IN
59127: IFFALSE 59148
// points := [ 40 , 10 , 20 ] ;
59129: LD_ADDR_VAR 0 9
59133: PUSH
59134: LD_INT 40
59136: PUSH
59137: LD_INT 10
59139: PUSH
59140: LD_INT 20
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: LIST
59147: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59148: LD_VAR 0 6
59152: PPUSH
59153: CALL_OW 264
59157: PUSH
59158: LD_INT 9
59160: PUSH
59161: EMPTY
59162: LIST
59163: IN
59164: IFFALSE 59185
// points := [ 5 , 70 , 20 ] ;
59166: LD_ADDR_VAR 0 9
59170: PUSH
59171: LD_INT 5
59173: PUSH
59174: LD_INT 70
59176: PUSH
59177: LD_INT 20
59179: PUSH
59180: EMPTY
59181: LIST
59182: LIST
59183: LIST
59184: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59185: LD_VAR 0 6
59189: PPUSH
59190: CALL_OW 264
59194: PUSH
59195: LD_INT 10
59197: PUSH
59198: EMPTY
59199: LIST
59200: IN
59201: IFFALSE 59222
// points := [ 35 , 110 , 70 ] ;
59203: LD_ADDR_VAR 0 9
59207: PUSH
59208: LD_INT 35
59210: PUSH
59211: LD_INT 110
59213: PUSH
59214: LD_INT 70
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: LIST
59221: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59222: LD_VAR 0 6
59226: PPUSH
59227: CALL_OW 265
59231: PUSH
59232: LD_INT 25
59234: EQUAL
59235: IFFALSE 59256
// points := [ 80 , 65 , 100 ] ;
59237: LD_ADDR_VAR 0 9
59241: PUSH
59242: LD_INT 80
59244: PUSH
59245: LD_INT 65
59247: PUSH
59248: LD_INT 100
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59256: LD_VAR 0 6
59260: PPUSH
59261: CALL_OW 263
59265: PUSH
59266: LD_INT 1
59268: EQUAL
59269: IFFALSE 59304
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59271: LD_ADDR_VAR 0 10
59275: PUSH
59276: LD_VAR 0 10
59280: PUSH
59281: LD_VAR 0 6
59285: PPUSH
59286: CALL_OW 311
59290: PPUSH
59291: LD_INT 3
59293: PPUSH
59294: CALL_OW 259
59298: PUSH
59299: LD_INT 4
59301: MUL
59302: MUL
59303: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59304: LD_VAR 0 6
59308: PPUSH
59309: CALL_OW 263
59313: PUSH
59314: LD_INT 2
59316: EQUAL
59317: IFFALSE 59368
// begin j := IsControledBy ( i ) ;
59319: LD_ADDR_VAR 0 7
59323: PUSH
59324: LD_VAR 0 6
59328: PPUSH
59329: CALL_OW 312
59333: ST_TO_ADDR
// if j then
59334: LD_VAR 0 7
59338: IFFALSE 59368
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59340: LD_ADDR_VAR 0 10
59344: PUSH
59345: LD_VAR 0 10
59349: PUSH
59350: LD_VAR 0 7
59354: PPUSH
59355: LD_INT 3
59357: PPUSH
59358: CALL_OW 259
59362: PUSH
59363: LD_INT 3
59365: MUL
59366: MUL
59367: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59368: LD_VAR 0 6
59372: PPUSH
59373: CALL_OW 264
59377: PUSH
59378: LD_INT 5
59380: PUSH
59381: LD_INT 6
59383: PUSH
59384: LD_INT 46
59386: PUSH
59387: LD_INT 44
59389: PUSH
59390: LD_INT 47
59392: PUSH
59393: LD_INT 45
59395: PUSH
59396: LD_INT 28
59398: PUSH
59399: LD_INT 7
59401: PUSH
59402: LD_INT 27
59404: PUSH
59405: LD_INT 29
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: LIST
59413: LIST
59414: LIST
59415: LIST
59416: LIST
59417: LIST
59418: LIST
59419: IN
59420: PUSH
59421: LD_VAR 0 1
59425: PPUSH
59426: LD_INT 52
59428: PPUSH
59429: CALL_OW 321
59433: PUSH
59434: LD_INT 2
59436: EQUAL
59437: AND
59438: IFFALSE 59455
// bpoints := bpoints * 1.2 ;
59440: LD_ADDR_VAR 0 10
59444: PUSH
59445: LD_VAR 0 10
59449: PUSH
59450: LD_REAL  1.20000000000000E+0000
59453: MUL
59454: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59455: LD_VAR 0 6
59459: PPUSH
59460: CALL_OW 264
59464: PUSH
59465: LD_INT 6
59467: PUSH
59468: LD_INT 46
59470: PUSH
59471: LD_INT 47
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: LIST
59478: IN
59479: IFFALSE 59496
// bpoints := bpoints * 1.2 ;
59481: LD_ADDR_VAR 0 10
59485: PUSH
59486: LD_VAR 0 10
59490: PUSH
59491: LD_REAL  1.20000000000000E+0000
59494: MUL
59495: ST_TO_ADDR
// end ; unit_building :
59496: GO 59510
59498: LD_INT 3
59500: DOUBLE
59501: EQUAL
59502: IFTRUE 59506
59504: GO 59509
59506: POP
// ; end ;
59507: GO 59510
59509: POP
// for j = 1 to 3 do
59510: LD_ADDR_VAR 0 7
59514: PUSH
59515: DOUBLE
59516: LD_INT 1
59518: DEC
59519: ST_TO_ADDR
59520: LD_INT 3
59522: PUSH
59523: FOR_TO
59524: IFFALSE 59577
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59526: LD_ADDR_VAR 0 5
59530: PUSH
59531: LD_VAR 0 5
59535: PPUSH
59536: LD_VAR 0 7
59540: PPUSH
59541: LD_VAR 0 5
59545: PUSH
59546: LD_VAR 0 7
59550: ARRAY
59551: PUSH
59552: LD_VAR 0 9
59556: PUSH
59557: LD_VAR 0 7
59561: ARRAY
59562: PUSH
59563: LD_VAR 0 10
59567: MUL
59568: PLUS
59569: PPUSH
59570: CALL_OW 1
59574: ST_TO_ADDR
59575: GO 59523
59577: POP
59578: POP
// end ;
59579: GO 58056
59581: POP
59582: POP
// result := Replace ( result , 4 , tmp ) ;
59583: LD_ADDR_VAR 0 5
59587: PUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: LD_INT 4
59595: PPUSH
59596: LD_VAR 0 8
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
// end ;
59606: LD_VAR 0 5
59610: RET
// export function DangerAtRange ( unit , range ) ; begin
59611: LD_INT 0
59613: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59614: LD_ADDR_VAR 0 3
59618: PUSH
59619: LD_VAR 0 1
59623: PPUSH
59624: CALL_OW 255
59628: PPUSH
59629: LD_VAR 0 1
59633: PPUSH
59634: CALL_OW 250
59638: PPUSH
59639: LD_VAR 0 1
59643: PPUSH
59644: CALL_OW 251
59648: PPUSH
59649: LD_VAR 0 2
59653: PPUSH
59654: CALL 57908 0 4
59658: ST_TO_ADDR
// end ;
59659: LD_VAR 0 3
59663: RET
// export function DangerInArea ( side , area ) ; begin
59664: LD_INT 0
59666: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59667: LD_ADDR_VAR 0 3
59671: PUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: LD_INT 81
59679: PUSH
59680: LD_VAR 0 1
59684: PUSH
59685: EMPTY
59686: LIST
59687: LIST
59688: PPUSH
59689: CALL_OW 70
59693: ST_TO_ADDR
// end ;
59694: LD_VAR 0 3
59698: RET
// export function IsExtension ( b ) ; begin
59699: LD_INT 0
59701: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59702: LD_ADDR_VAR 0 2
59706: PUSH
59707: LD_VAR 0 1
59711: PUSH
59712: LD_INT 23
59714: PUSH
59715: LD_INT 20
59717: PUSH
59718: LD_INT 22
59720: PUSH
59721: LD_INT 17
59723: PUSH
59724: LD_INT 24
59726: PUSH
59727: LD_INT 21
59729: PUSH
59730: LD_INT 19
59732: PUSH
59733: LD_INT 16
59735: PUSH
59736: LD_INT 25
59738: PUSH
59739: LD_INT 18
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: LIST
59753: IN
59754: ST_TO_ADDR
// end ;
59755: LD_VAR 0 2
59759: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59760: LD_INT 0
59762: PPUSH
59763: PPUSH
59764: PPUSH
// result := [ ] ;
59765: LD_ADDR_VAR 0 4
59769: PUSH
59770: EMPTY
59771: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59772: LD_ADDR_VAR 0 5
59776: PUSH
59777: LD_VAR 0 2
59781: PPUSH
59782: LD_INT 21
59784: PUSH
59785: LD_INT 3
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: PPUSH
59792: CALL_OW 70
59796: ST_TO_ADDR
// if not tmp then
59797: LD_VAR 0 5
59801: NOT
59802: IFFALSE 59806
// exit ;
59804: GO 59870
// if checkLink then
59806: LD_VAR 0 3
59810: IFFALSE 59860
// begin for i in tmp do
59812: LD_ADDR_VAR 0 6
59816: PUSH
59817: LD_VAR 0 5
59821: PUSH
59822: FOR_IN
59823: IFFALSE 59858
// if GetBase ( i ) <> base then
59825: LD_VAR 0 6
59829: PPUSH
59830: CALL_OW 274
59834: PUSH
59835: LD_VAR 0 1
59839: NONEQUAL
59840: IFFALSE 59856
// ComLinkToBase ( base , i ) ;
59842: LD_VAR 0 1
59846: PPUSH
59847: LD_VAR 0 6
59851: PPUSH
59852: CALL_OW 169
59856: GO 59822
59858: POP
59859: POP
// end ; result := tmp ;
59860: LD_ADDR_VAR 0 4
59864: PUSH
59865: LD_VAR 0 5
59869: ST_TO_ADDR
// end ;
59870: LD_VAR 0 4
59874: RET
// export function ComComplete ( units , b ) ; var i ; begin
59875: LD_INT 0
59877: PPUSH
59878: PPUSH
// if not units then
59879: LD_VAR 0 1
59883: NOT
59884: IFFALSE 59888
// exit ;
59886: GO 59978
// for i in units do
59888: LD_ADDR_VAR 0 4
59892: PUSH
59893: LD_VAR 0 1
59897: PUSH
59898: FOR_IN
59899: IFFALSE 59976
// if BuildingStatus ( b ) = bs_build then
59901: LD_VAR 0 2
59905: PPUSH
59906: CALL_OW 461
59910: PUSH
59911: LD_INT 1
59913: EQUAL
59914: IFFALSE 59974
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59916: LD_VAR 0 4
59920: PPUSH
59921: LD_STRING h
59923: PUSH
59924: LD_VAR 0 2
59928: PPUSH
59929: CALL_OW 250
59933: PUSH
59934: LD_VAR 0 2
59938: PPUSH
59939: CALL_OW 251
59943: PUSH
59944: LD_VAR 0 2
59948: PUSH
59949: LD_INT 0
59951: PUSH
59952: LD_INT 0
59954: PUSH
59955: LD_INT 0
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: LIST
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: PUSH
59967: EMPTY
59968: LIST
59969: PPUSH
59970: CALL_OW 446
59974: GO 59898
59976: POP
59977: POP
// end ;
59978: LD_VAR 0 3
59982: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59983: LD_INT 0
59985: PPUSH
59986: PPUSH
59987: PPUSH
59988: PPUSH
59989: PPUSH
59990: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59991: LD_VAR 0 1
59995: NOT
59996: PUSH
59997: LD_VAR 0 1
60001: PPUSH
60002: CALL_OW 263
60006: PUSH
60007: LD_INT 2
60009: NONEQUAL
60010: OR
60011: IFFALSE 60015
// exit ;
60013: GO 60331
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60015: LD_ADDR_VAR 0 6
60019: PUSH
60020: LD_INT 22
60022: PUSH
60023: LD_VAR 0 1
60027: PPUSH
60028: CALL_OW 255
60032: PUSH
60033: EMPTY
60034: LIST
60035: LIST
60036: PUSH
60037: LD_INT 2
60039: PUSH
60040: LD_INT 30
60042: PUSH
60043: LD_INT 36
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: PUSH
60050: LD_INT 34
60052: PUSH
60053: LD_INT 31
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: LIST
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: PPUSH
60069: CALL_OW 69
60073: ST_TO_ADDR
// if not tmp then
60074: LD_VAR 0 6
60078: NOT
60079: IFFALSE 60083
// exit ;
60081: GO 60331
// result := [ ] ;
60083: LD_ADDR_VAR 0 2
60087: PUSH
60088: EMPTY
60089: ST_TO_ADDR
// for i in tmp do
60090: LD_ADDR_VAR 0 3
60094: PUSH
60095: LD_VAR 0 6
60099: PUSH
60100: FOR_IN
60101: IFFALSE 60172
// begin t := UnitsInside ( i ) ;
60103: LD_ADDR_VAR 0 4
60107: PUSH
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 313
60117: ST_TO_ADDR
// if t then
60118: LD_VAR 0 4
60122: IFFALSE 60170
// for j in t do
60124: LD_ADDR_VAR 0 7
60128: PUSH
60129: LD_VAR 0 4
60133: PUSH
60134: FOR_IN
60135: IFFALSE 60168
// result := Replace ( result , result + 1 , j ) ;
60137: LD_ADDR_VAR 0 2
60141: PUSH
60142: LD_VAR 0 2
60146: PPUSH
60147: LD_VAR 0 2
60151: PUSH
60152: LD_INT 1
60154: PLUS
60155: PPUSH
60156: LD_VAR 0 7
60160: PPUSH
60161: CALL_OW 1
60165: ST_TO_ADDR
60166: GO 60134
60168: POP
60169: POP
// end ;
60170: GO 60100
60172: POP
60173: POP
// if not result then
60174: LD_VAR 0 2
60178: NOT
60179: IFFALSE 60183
// exit ;
60181: GO 60331
// mech := result [ 1 ] ;
60183: LD_ADDR_VAR 0 5
60187: PUSH
60188: LD_VAR 0 2
60192: PUSH
60193: LD_INT 1
60195: ARRAY
60196: ST_TO_ADDR
// if result > 1 then
60197: LD_VAR 0 2
60201: PUSH
60202: LD_INT 1
60204: GREATER
60205: IFFALSE 60317
// begin for i = 2 to result do
60207: LD_ADDR_VAR 0 3
60211: PUSH
60212: DOUBLE
60213: LD_INT 2
60215: DEC
60216: ST_TO_ADDR
60217: LD_VAR 0 2
60221: PUSH
60222: FOR_TO
60223: IFFALSE 60315
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60225: LD_ADDR_VAR 0 4
60229: PUSH
60230: LD_VAR 0 2
60234: PUSH
60235: LD_VAR 0 3
60239: ARRAY
60240: PPUSH
60241: LD_INT 3
60243: PPUSH
60244: CALL_OW 259
60248: PUSH
60249: LD_VAR 0 2
60253: PUSH
60254: LD_VAR 0 3
60258: ARRAY
60259: PPUSH
60260: CALL_OW 432
60264: MINUS
60265: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60266: LD_VAR 0 4
60270: PUSH
60271: LD_VAR 0 5
60275: PPUSH
60276: LD_INT 3
60278: PPUSH
60279: CALL_OW 259
60283: PUSH
60284: LD_VAR 0 5
60288: PPUSH
60289: CALL_OW 432
60293: MINUS
60294: GREATEREQUAL
60295: IFFALSE 60313
// mech := result [ i ] ;
60297: LD_ADDR_VAR 0 5
60301: PUSH
60302: LD_VAR 0 2
60306: PUSH
60307: LD_VAR 0 3
60311: ARRAY
60312: ST_TO_ADDR
// end ;
60313: GO 60222
60315: POP
60316: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60317: LD_VAR 0 1
60321: PPUSH
60322: LD_VAR 0 5
60326: PPUSH
60327: CALL_OW 135
// end ;
60331: LD_VAR 0 2
60335: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60336: LD_INT 0
60338: PPUSH
60339: PPUSH
60340: PPUSH
60341: PPUSH
60342: PPUSH
60343: PPUSH
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
// result := [ ] ;
60351: LD_ADDR_VAR 0 7
60355: PUSH
60356: EMPTY
60357: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60358: LD_VAR 0 1
60362: PPUSH
60363: CALL_OW 266
60367: PUSH
60368: LD_INT 0
60370: PUSH
60371: LD_INT 1
60373: PUSH
60374: EMPTY
60375: LIST
60376: LIST
60377: IN
60378: NOT
60379: IFFALSE 60383
// exit ;
60381: GO 62017
// if name then
60383: LD_VAR 0 3
60387: IFFALSE 60403
// SetBName ( base_dep , name ) ;
60389: LD_VAR 0 1
60393: PPUSH
60394: LD_VAR 0 3
60398: PPUSH
60399: CALL_OW 500
// base := GetBase ( base_dep ) ;
60403: LD_ADDR_VAR 0 15
60407: PUSH
60408: LD_VAR 0 1
60412: PPUSH
60413: CALL_OW 274
60417: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60418: LD_ADDR_VAR 0 16
60422: PUSH
60423: LD_VAR 0 1
60427: PPUSH
60428: CALL_OW 255
60432: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60433: LD_ADDR_VAR 0 17
60437: PUSH
60438: LD_VAR 0 1
60442: PPUSH
60443: CALL_OW 248
60447: ST_TO_ADDR
// if sources then
60448: LD_VAR 0 5
60452: IFFALSE 60499
// for i = 1 to 3 do
60454: LD_ADDR_VAR 0 8
60458: PUSH
60459: DOUBLE
60460: LD_INT 1
60462: DEC
60463: ST_TO_ADDR
60464: LD_INT 3
60466: PUSH
60467: FOR_TO
60468: IFFALSE 60497
// AddResourceType ( base , i , sources [ i ] ) ;
60470: LD_VAR 0 15
60474: PPUSH
60475: LD_VAR 0 8
60479: PPUSH
60480: LD_VAR 0 5
60484: PUSH
60485: LD_VAR 0 8
60489: ARRAY
60490: PPUSH
60491: CALL_OW 276
60495: GO 60467
60497: POP
60498: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60499: LD_ADDR_VAR 0 18
60503: PUSH
60504: LD_VAR 0 15
60508: PPUSH
60509: LD_VAR 0 2
60513: PPUSH
60514: LD_INT 1
60516: PPUSH
60517: CALL 59760 0 3
60521: ST_TO_ADDR
// InitHc ;
60522: CALL_OW 19
// InitUc ;
60526: CALL_OW 18
// uc_side := side ;
60530: LD_ADDR_OWVAR 20
60534: PUSH
60535: LD_VAR 0 16
60539: ST_TO_ADDR
// uc_nation := nation ;
60540: LD_ADDR_OWVAR 21
60544: PUSH
60545: LD_VAR 0 17
60549: ST_TO_ADDR
// if buildings then
60550: LD_VAR 0 18
60554: IFFALSE 61876
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60556: LD_ADDR_VAR 0 19
60560: PUSH
60561: LD_VAR 0 18
60565: PPUSH
60566: LD_INT 2
60568: PUSH
60569: LD_INT 30
60571: PUSH
60572: LD_INT 29
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: PUSH
60579: LD_INT 30
60581: PUSH
60582: LD_INT 30
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: EMPTY
60590: LIST
60591: LIST
60592: LIST
60593: PPUSH
60594: CALL_OW 72
60598: ST_TO_ADDR
// if tmp then
60599: LD_VAR 0 19
60603: IFFALSE 60651
// for i in tmp do
60605: LD_ADDR_VAR 0 8
60609: PUSH
60610: LD_VAR 0 19
60614: PUSH
60615: FOR_IN
60616: IFFALSE 60649
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60618: LD_VAR 0 8
60622: PPUSH
60623: CALL_OW 250
60627: PPUSH
60628: LD_VAR 0 8
60632: PPUSH
60633: CALL_OW 251
60637: PPUSH
60638: LD_VAR 0 16
60642: PPUSH
60643: CALL_OW 441
60647: GO 60615
60649: POP
60650: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60651: LD_VAR 0 18
60655: PPUSH
60656: LD_INT 2
60658: PUSH
60659: LD_INT 30
60661: PUSH
60662: LD_INT 32
60664: PUSH
60665: EMPTY
60666: LIST
60667: LIST
60668: PUSH
60669: LD_INT 30
60671: PUSH
60672: LD_INT 33
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: LIST
60683: PPUSH
60684: CALL_OW 72
60688: IFFALSE 60776
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60690: LD_ADDR_VAR 0 8
60694: PUSH
60695: LD_VAR 0 18
60699: PPUSH
60700: LD_INT 2
60702: PUSH
60703: LD_INT 30
60705: PUSH
60706: LD_INT 32
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 30
60715: PUSH
60716: LD_INT 33
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: PPUSH
60728: CALL_OW 72
60732: PUSH
60733: FOR_IN
60734: IFFALSE 60774
// begin if not GetBWeapon ( i ) then
60736: LD_VAR 0 8
60740: PPUSH
60741: CALL_OW 269
60745: NOT
60746: IFFALSE 60772
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60748: LD_VAR 0 8
60752: PPUSH
60753: LD_VAR 0 8
60757: PPUSH
60758: LD_VAR 0 2
60762: PPUSH
60763: CALL 62022 0 2
60767: PPUSH
60768: CALL_OW 431
// end ;
60772: GO 60733
60774: POP
60775: POP
// end ; for i = 1 to personel do
60776: LD_ADDR_VAR 0 8
60780: PUSH
60781: DOUBLE
60782: LD_INT 1
60784: DEC
60785: ST_TO_ADDR
60786: LD_VAR 0 6
60790: PUSH
60791: FOR_TO
60792: IFFALSE 61856
// begin if i > 4 then
60794: LD_VAR 0 8
60798: PUSH
60799: LD_INT 4
60801: GREATER
60802: IFFALSE 60806
// break ;
60804: GO 61856
// case i of 1 :
60806: LD_VAR 0 8
60810: PUSH
60811: LD_INT 1
60813: DOUBLE
60814: EQUAL
60815: IFTRUE 60819
60817: GO 60899
60819: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60820: LD_ADDR_VAR 0 12
60824: PUSH
60825: LD_VAR 0 18
60829: PPUSH
60830: LD_INT 22
60832: PUSH
60833: LD_VAR 0 16
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 58
60844: PUSH
60845: EMPTY
60846: LIST
60847: PUSH
60848: LD_INT 2
60850: PUSH
60851: LD_INT 30
60853: PUSH
60854: LD_INT 32
60856: PUSH
60857: EMPTY
60858: LIST
60859: LIST
60860: PUSH
60861: LD_INT 30
60863: PUSH
60864: LD_INT 4
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: PUSH
60871: LD_INT 30
60873: PUSH
60874: LD_INT 5
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: LIST
60891: PPUSH
60892: CALL_OW 72
60896: ST_TO_ADDR
60897: GO 61121
60899: LD_INT 2
60901: DOUBLE
60902: EQUAL
60903: IFTRUE 60907
60905: GO 60969
60907: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60908: LD_ADDR_VAR 0 12
60912: PUSH
60913: LD_VAR 0 18
60917: PPUSH
60918: LD_INT 22
60920: PUSH
60921: LD_VAR 0 16
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 2
60932: PUSH
60933: LD_INT 30
60935: PUSH
60936: LD_INT 0
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 30
60945: PUSH
60946: LD_INT 1
60948: PUSH
60949: EMPTY
60950: LIST
60951: LIST
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: LIST
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PPUSH
60962: CALL_OW 72
60966: ST_TO_ADDR
60967: GO 61121
60969: LD_INT 3
60971: DOUBLE
60972: EQUAL
60973: IFTRUE 60977
60975: GO 61039
60977: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60978: LD_ADDR_VAR 0 12
60982: PUSH
60983: LD_VAR 0 18
60987: PPUSH
60988: LD_INT 22
60990: PUSH
60991: LD_VAR 0 16
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PUSH
61000: LD_INT 2
61002: PUSH
61003: LD_INT 30
61005: PUSH
61006: LD_INT 2
61008: PUSH
61009: EMPTY
61010: LIST
61011: LIST
61012: PUSH
61013: LD_INT 30
61015: PUSH
61016: LD_INT 3
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: LIST
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PPUSH
61032: CALL_OW 72
61036: ST_TO_ADDR
61037: GO 61121
61039: LD_INT 4
61041: DOUBLE
61042: EQUAL
61043: IFTRUE 61047
61045: GO 61120
61047: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61048: LD_ADDR_VAR 0 12
61052: PUSH
61053: LD_VAR 0 18
61057: PPUSH
61058: LD_INT 22
61060: PUSH
61061: LD_VAR 0 16
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: PUSH
61070: LD_INT 2
61072: PUSH
61073: LD_INT 30
61075: PUSH
61076: LD_INT 6
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PUSH
61083: LD_INT 30
61085: PUSH
61086: LD_INT 7
61088: PUSH
61089: EMPTY
61090: LIST
61091: LIST
61092: PUSH
61093: LD_INT 30
61095: PUSH
61096: LD_INT 8
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: LIST
61107: LIST
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: PPUSH
61113: CALL_OW 72
61117: ST_TO_ADDR
61118: GO 61121
61120: POP
// if i = 1 then
61121: LD_VAR 0 8
61125: PUSH
61126: LD_INT 1
61128: EQUAL
61129: IFFALSE 61240
// begin tmp := [ ] ;
61131: LD_ADDR_VAR 0 19
61135: PUSH
61136: EMPTY
61137: ST_TO_ADDR
// for j in f do
61138: LD_ADDR_VAR 0 9
61142: PUSH
61143: LD_VAR 0 12
61147: PUSH
61148: FOR_IN
61149: IFFALSE 61222
// if GetBType ( j ) = b_bunker then
61151: LD_VAR 0 9
61155: PPUSH
61156: CALL_OW 266
61160: PUSH
61161: LD_INT 32
61163: EQUAL
61164: IFFALSE 61191
// tmp := Insert ( tmp , 1 , j ) else
61166: LD_ADDR_VAR 0 19
61170: PUSH
61171: LD_VAR 0 19
61175: PPUSH
61176: LD_INT 1
61178: PPUSH
61179: LD_VAR 0 9
61183: PPUSH
61184: CALL_OW 2
61188: ST_TO_ADDR
61189: GO 61220
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61191: LD_ADDR_VAR 0 19
61195: PUSH
61196: LD_VAR 0 19
61200: PPUSH
61201: LD_VAR 0 19
61205: PUSH
61206: LD_INT 1
61208: PLUS
61209: PPUSH
61210: LD_VAR 0 9
61214: PPUSH
61215: CALL_OW 2
61219: ST_TO_ADDR
61220: GO 61148
61222: POP
61223: POP
// if tmp then
61224: LD_VAR 0 19
61228: IFFALSE 61240
// f := tmp ;
61230: LD_ADDR_VAR 0 12
61234: PUSH
61235: LD_VAR 0 19
61239: ST_TO_ADDR
// end ; x := personel [ i ] ;
61240: LD_ADDR_VAR 0 13
61244: PUSH
61245: LD_VAR 0 6
61249: PUSH
61250: LD_VAR 0 8
61254: ARRAY
61255: ST_TO_ADDR
// if x = - 1 then
61256: LD_VAR 0 13
61260: PUSH
61261: LD_INT 1
61263: NEG
61264: EQUAL
61265: IFFALSE 61474
// begin for j in f do
61267: LD_ADDR_VAR 0 9
61271: PUSH
61272: LD_VAR 0 12
61276: PUSH
61277: FOR_IN
61278: IFFALSE 61470
// repeat InitHc ;
61280: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61284: LD_VAR 0 9
61288: PPUSH
61289: CALL_OW 266
61293: PUSH
61294: LD_INT 5
61296: EQUAL
61297: IFFALSE 61367
// begin if UnitsInside ( j ) < 3 then
61299: LD_VAR 0 9
61303: PPUSH
61304: CALL_OW 313
61308: PUSH
61309: LD_INT 3
61311: LESS
61312: IFFALSE 61348
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61314: LD_INT 0
61316: PPUSH
61317: LD_INT 5
61319: PUSH
61320: LD_INT 8
61322: PUSH
61323: LD_INT 9
61325: PUSH
61326: EMPTY
61327: LIST
61328: LIST
61329: LIST
61330: PUSH
61331: LD_VAR 0 17
61335: ARRAY
61336: PPUSH
61337: LD_VAR 0 4
61341: PPUSH
61342: CALL_OW 380
61346: GO 61365
// PrepareHuman ( false , i , skill ) ;
61348: LD_INT 0
61350: PPUSH
61351: LD_VAR 0 8
61355: PPUSH
61356: LD_VAR 0 4
61360: PPUSH
61361: CALL_OW 380
// end else
61365: GO 61384
// PrepareHuman ( false , i , skill ) ;
61367: LD_INT 0
61369: PPUSH
61370: LD_VAR 0 8
61374: PPUSH
61375: LD_VAR 0 4
61379: PPUSH
61380: CALL_OW 380
// un := CreateHuman ;
61384: LD_ADDR_VAR 0 14
61388: PUSH
61389: CALL_OW 44
61393: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61394: LD_ADDR_VAR 0 7
61398: PUSH
61399: LD_VAR 0 7
61403: PPUSH
61404: LD_INT 1
61406: PPUSH
61407: LD_VAR 0 14
61411: PPUSH
61412: CALL_OW 2
61416: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61417: LD_VAR 0 14
61421: PPUSH
61422: LD_VAR 0 9
61426: PPUSH
61427: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61431: LD_VAR 0 9
61435: PPUSH
61436: CALL_OW 313
61440: PUSH
61441: LD_INT 6
61443: EQUAL
61444: PUSH
61445: LD_VAR 0 9
61449: PPUSH
61450: CALL_OW 266
61454: PUSH
61455: LD_INT 32
61457: PUSH
61458: LD_INT 31
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: IN
61465: OR
61466: IFFALSE 61280
61468: GO 61277
61470: POP
61471: POP
// end else
61472: GO 61854
// for j = 1 to x do
61474: LD_ADDR_VAR 0 9
61478: PUSH
61479: DOUBLE
61480: LD_INT 1
61482: DEC
61483: ST_TO_ADDR
61484: LD_VAR 0 13
61488: PUSH
61489: FOR_TO
61490: IFFALSE 61852
// begin InitHc ;
61492: CALL_OW 19
// if not f then
61496: LD_VAR 0 12
61500: NOT
61501: IFFALSE 61590
// begin PrepareHuman ( false , i , skill ) ;
61503: LD_INT 0
61505: PPUSH
61506: LD_VAR 0 8
61510: PPUSH
61511: LD_VAR 0 4
61515: PPUSH
61516: CALL_OW 380
// un := CreateHuman ;
61520: LD_ADDR_VAR 0 14
61524: PUSH
61525: CALL_OW 44
61529: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61530: LD_ADDR_VAR 0 7
61534: PUSH
61535: LD_VAR 0 7
61539: PPUSH
61540: LD_INT 1
61542: PPUSH
61543: LD_VAR 0 14
61547: PPUSH
61548: CALL_OW 2
61552: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61553: LD_VAR 0 14
61557: PPUSH
61558: LD_VAR 0 1
61562: PPUSH
61563: CALL_OW 250
61567: PPUSH
61568: LD_VAR 0 1
61572: PPUSH
61573: CALL_OW 251
61577: PPUSH
61578: LD_INT 10
61580: PPUSH
61581: LD_INT 0
61583: PPUSH
61584: CALL_OW 50
// continue ;
61588: GO 61489
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61590: LD_VAR 0 12
61594: PUSH
61595: LD_INT 1
61597: ARRAY
61598: PPUSH
61599: CALL_OW 313
61603: PUSH
61604: LD_VAR 0 12
61608: PUSH
61609: LD_INT 1
61611: ARRAY
61612: PPUSH
61613: CALL_OW 266
61617: PUSH
61618: LD_INT 32
61620: PUSH
61621: LD_INT 31
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: IN
61628: AND
61629: PUSH
61630: LD_VAR 0 12
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PPUSH
61639: CALL_OW 313
61643: PUSH
61644: LD_INT 6
61646: EQUAL
61647: OR
61648: IFFALSE 61668
// f := Delete ( f , 1 ) ;
61650: LD_ADDR_VAR 0 12
61654: PUSH
61655: LD_VAR 0 12
61659: PPUSH
61660: LD_INT 1
61662: PPUSH
61663: CALL_OW 3
61667: ST_TO_ADDR
// if not f then
61668: LD_VAR 0 12
61672: NOT
61673: IFFALSE 61691
// begin x := x + 2 ;
61675: LD_ADDR_VAR 0 13
61679: PUSH
61680: LD_VAR 0 13
61684: PUSH
61685: LD_INT 2
61687: PLUS
61688: ST_TO_ADDR
// continue ;
61689: GO 61489
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61691: LD_VAR 0 12
61695: PUSH
61696: LD_INT 1
61698: ARRAY
61699: PPUSH
61700: CALL_OW 266
61704: PUSH
61705: LD_INT 5
61707: EQUAL
61708: IFFALSE 61782
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61710: LD_VAR 0 12
61714: PUSH
61715: LD_INT 1
61717: ARRAY
61718: PPUSH
61719: CALL_OW 313
61723: PUSH
61724: LD_INT 3
61726: LESS
61727: IFFALSE 61763
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61729: LD_INT 0
61731: PPUSH
61732: LD_INT 5
61734: PUSH
61735: LD_INT 8
61737: PUSH
61738: LD_INT 9
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: LIST
61745: PUSH
61746: LD_VAR 0 17
61750: ARRAY
61751: PPUSH
61752: LD_VAR 0 4
61756: PPUSH
61757: CALL_OW 380
61761: GO 61780
// PrepareHuman ( false , i , skill ) ;
61763: LD_INT 0
61765: PPUSH
61766: LD_VAR 0 8
61770: PPUSH
61771: LD_VAR 0 4
61775: PPUSH
61776: CALL_OW 380
// end else
61780: GO 61799
// PrepareHuman ( false , i , skill ) ;
61782: LD_INT 0
61784: PPUSH
61785: LD_VAR 0 8
61789: PPUSH
61790: LD_VAR 0 4
61794: PPUSH
61795: CALL_OW 380
// un := CreateHuman ;
61799: LD_ADDR_VAR 0 14
61803: PUSH
61804: CALL_OW 44
61808: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61809: LD_ADDR_VAR 0 7
61813: PUSH
61814: LD_VAR 0 7
61818: PPUSH
61819: LD_INT 1
61821: PPUSH
61822: LD_VAR 0 14
61826: PPUSH
61827: CALL_OW 2
61831: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61832: LD_VAR 0 14
61836: PPUSH
61837: LD_VAR 0 12
61841: PUSH
61842: LD_INT 1
61844: ARRAY
61845: PPUSH
61846: CALL_OW 52
// end ;
61850: GO 61489
61852: POP
61853: POP
// end ;
61854: GO 60791
61856: POP
61857: POP
// result := result ^ buildings ;
61858: LD_ADDR_VAR 0 7
61862: PUSH
61863: LD_VAR 0 7
61867: PUSH
61868: LD_VAR 0 18
61872: ADD
61873: ST_TO_ADDR
// end else
61874: GO 62017
// begin for i = 1 to personel do
61876: LD_ADDR_VAR 0 8
61880: PUSH
61881: DOUBLE
61882: LD_INT 1
61884: DEC
61885: ST_TO_ADDR
61886: LD_VAR 0 6
61890: PUSH
61891: FOR_TO
61892: IFFALSE 62015
// begin if i > 4 then
61894: LD_VAR 0 8
61898: PUSH
61899: LD_INT 4
61901: GREATER
61902: IFFALSE 61906
// break ;
61904: GO 62015
// x := personel [ i ] ;
61906: LD_ADDR_VAR 0 13
61910: PUSH
61911: LD_VAR 0 6
61915: PUSH
61916: LD_VAR 0 8
61920: ARRAY
61921: ST_TO_ADDR
// if x = - 1 then
61922: LD_VAR 0 13
61926: PUSH
61927: LD_INT 1
61929: NEG
61930: EQUAL
61931: IFFALSE 61935
// continue ;
61933: GO 61891
// PrepareHuman ( false , i , skill ) ;
61935: LD_INT 0
61937: PPUSH
61938: LD_VAR 0 8
61942: PPUSH
61943: LD_VAR 0 4
61947: PPUSH
61948: CALL_OW 380
// un := CreateHuman ;
61952: LD_ADDR_VAR 0 14
61956: PUSH
61957: CALL_OW 44
61961: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61962: LD_VAR 0 14
61966: PPUSH
61967: LD_VAR 0 1
61971: PPUSH
61972: CALL_OW 250
61976: PPUSH
61977: LD_VAR 0 1
61981: PPUSH
61982: CALL_OW 251
61986: PPUSH
61987: LD_INT 10
61989: PPUSH
61990: LD_INT 0
61992: PPUSH
61993: CALL_OW 50
// result := result ^ un ;
61997: LD_ADDR_VAR 0 7
62001: PUSH
62002: LD_VAR 0 7
62006: PUSH
62007: LD_VAR 0 14
62011: ADD
62012: ST_TO_ADDR
// end ;
62013: GO 61891
62015: POP
62016: POP
// end ; end ;
62017: LD_VAR 0 7
62021: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62022: LD_INT 0
62024: PPUSH
62025: PPUSH
62026: PPUSH
62027: PPUSH
62028: PPUSH
62029: PPUSH
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
62038: PPUSH
62039: PPUSH
// result := false ;
62040: LD_ADDR_VAR 0 3
62044: PUSH
62045: LD_INT 0
62047: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62048: LD_VAR 0 1
62052: NOT
62053: PUSH
62054: LD_VAR 0 1
62058: PPUSH
62059: CALL_OW 266
62063: PUSH
62064: LD_INT 32
62066: PUSH
62067: LD_INT 33
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: IN
62074: NOT
62075: OR
62076: IFFALSE 62080
// exit ;
62078: GO 63189
// nat := GetNation ( tower ) ;
62080: LD_ADDR_VAR 0 12
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 248
62094: ST_TO_ADDR
// side := GetSide ( tower ) ;
62095: LD_ADDR_VAR 0 16
62099: PUSH
62100: LD_VAR 0 1
62104: PPUSH
62105: CALL_OW 255
62109: ST_TO_ADDR
// x := GetX ( tower ) ;
62110: LD_ADDR_VAR 0 10
62114: PUSH
62115: LD_VAR 0 1
62119: PPUSH
62120: CALL_OW 250
62124: ST_TO_ADDR
// y := GetY ( tower ) ;
62125: LD_ADDR_VAR 0 11
62129: PUSH
62130: LD_VAR 0 1
62134: PPUSH
62135: CALL_OW 251
62139: ST_TO_ADDR
// if not x or not y then
62140: LD_VAR 0 10
62144: NOT
62145: PUSH
62146: LD_VAR 0 11
62150: NOT
62151: OR
62152: IFFALSE 62156
// exit ;
62154: GO 63189
// weapon := 0 ;
62156: LD_ADDR_VAR 0 18
62160: PUSH
62161: LD_INT 0
62163: ST_TO_ADDR
// fac_list := [ ] ;
62164: LD_ADDR_VAR 0 17
62168: PUSH
62169: EMPTY
62170: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62171: LD_ADDR_VAR 0 6
62175: PUSH
62176: LD_VAR 0 1
62180: PPUSH
62181: CALL_OW 274
62185: PPUSH
62186: LD_VAR 0 2
62190: PPUSH
62191: LD_INT 0
62193: PPUSH
62194: CALL 59760 0 3
62198: PPUSH
62199: LD_INT 30
62201: PUSH
62202: LD_INT 3
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: PPUSH
62209: CALL_OW 72
62213: ST_TO_ADDR
// if not factories then
62214: LD_VAR 0 6
62218: NOT
62219: IFFALSE 62223
// exit ;
62221: GO 63189
// for i in factories do
62223: LD_ADDR_VAR 0 8
62227: PUSH
62228: LD_VAR 0 6
62232: PUSH
62233: FOR_IN
62234: IFFALSE 62259
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62236: LD_ADDR_VAR 0 17
62240: PUSH
62241: LD_VAR 0 17
62245: PUSH
62246: LD_VAR 0 8
62250: PPUSH
62251: CALL_OW 478
62255: UNION
62256: ST_TO_ADDR
62257: GO 62233
62259: POP
62260: POP
// if not fac_list then
62261: LD_VAR 0 17
62265: NOT
62266: IFFALSE 62270
// exit ;
62268: GO 63189
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62270: LD_ADDR_VAR 0 5
62274: PUSH
62275: LD_INT 4
62277: PUSH
62278: LD_INT 5
62280: PUSH
62281: LD_INT 9
62283: PUSH
62284: LD_INT 10
62286: PUSH
62287: LD_INT 6
62289: PUSH
62290: LD_INT 7
62292: PUSH
62293: LD_INT 11
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: PUSH
62305: LD_INT 27
62307: PUSH
62308: LD_INT 28
62310: PUSH
62311: LD_INT 26
62313: PUSH
62314: LD_INT 30
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: LIST
62321: LIST
62322: PUSH
62323: LD_INT 43
62325: PUSH
62326: LD_INT 44
62328: PUSH
62329: LD_INT 46
62331: PUSH
62332: LD_INT 45
62334: PUSH
62335: LD_INT 47
62337: PUSH
62338: LD_INT 49
62340: PUSH
62341: EMPTY
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: LIST
62353: PUSH
62354: LD_VAR 0 12
62358: ARRAY
62359: ST_TO_ADDR
// list := list isect fac_list ;
62360: LD_ADDR_VAR 0 5
62364: PUSH
62365: LD_VAR 0 5
62369: PUSH
62370: LD_VAR 0 17
62374: ISECT
62375: ST_TO_ADDR
// if not list then
62376: LD_VAR 0 5
62380: NOT
62381: IFFALSE 62385
// exit ;
62383: GO 63189
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62385: LD_VAR 0 12
62389: PUSH
62390: LD_INT 3
62392: EQUAL
62393: PUSH
62394: LD_INT 49
62396: PUSH
62397: LD_VAR 0 5
62401: IN
62402: AND
62403: PUSH
62404: LD_INT 31
62406: PPUSH
62407: LD_VAR 0 16
62411: PPUSH
62412: CALL_OW 321
62416: PUSH
62417: LD_INT 2
62419: EQUAL
62420: AND
62421: IFFALSE 62481
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62423: LD_INT 22
62425: PUSH
62426: LD_VAR 0 16
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: PUSH
62435: LD_INT 35
62437: PUSH
62438: LD_INT 49
62440: PUSH
62441: EMPTY
62442: LIST
62443: LIST
62444: PUSH
62445: LD_INT 91
62447: PUSH
62448: LD_VAR 0 1
62452: PUSH
62453: LD_INT 10
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: LIST
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: LIST
62465: PPUSH
62466: CALL_OW 69
62470: NOT
62471: IFFALSE 62481
// weapon := ru_time_lapser ;
62473: LD_ADDR_VAR 0 18
62477: PUSH
62478: LD_INT 49
62480: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62481: LD_VAR 0 12
62485: PUSH
62486: LD_INT 1
62488: PUSH
62489: LD_INT 2
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: IN
62496: PUSH
62497: LD_INT 11
62499: PUSH
62500: LD_VAR 0 5
62504: IN
62505: PUSH
62506: LD_INT 30
62508: PUSH
62509: LD_VAR 0 5
62513: IN
62514: OR
62515: AND
62516: PUSH
62517: LD_INT 6
62519: PPUSH
62520: LD_VAR 0 16
62524: PPUSH
62525: CALL_OW 321
62529: PUSH
62530: LD_INT 2
62532: EQUAL
62533: AND
62534: IFFALSE 62699
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62536: LD_INT 22
62538: PUSH
62539: LD_VAR 0 16
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: PUSH
62548: LD_INT 2
62550: PUSH
62551: LD_INT 35
62553: PUSH
62554: LD_INT 11
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: LD_INT 35
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: LIST
62575: PUSH
62576: LD_INT 91
62578: PUSH
62579: LD_VAR 0 1
62583: PUSH
62584: LD_INT 18
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: LIST
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: LIST
62596: PPUSH
62597: CALL_OW 69
62601: NOT
62602: PUSH
62603: LD_INT 22
62605: PUSH
62606: LD_VAR 0 16
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PUSH
62615: LD_INT 2
62617: PUSH
62618: LD_INT 30
62620: PUSH
62621: LD_INT 32
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 33
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: LIST
62642: PUSH
62643: LD_INT 91
62645: PUSH
62646: LD_VAR 0 1
62650: PUSH
62651: LD_INT 12
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: LIST
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: LIST
62663: PUSH
62664: EMPTY
62665: LIST
62666: PPUSH
62667: CALL_OW 69
62671: PUSH
62672: LD_INT 2
62674: GREATER
62675: AND
62676: IFFALSE 62699
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62678: LD_ADDR_VAR 0 18
62682: PUSH
62683: LD_INT 11
62685: PUSH
62686: LD_INT 30
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_VAR 0 12
62697: ARRAY
62698: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62699: LD_VAR 0 18
62703: NOT
62704: PUSH
62705: LD_INT 40
62707: PPUSH
62708: LD_VAR 0 16
62712: PPUSH
62713: CALL_OW 321
62717: PUSH
62718: LD_INT 2
62720: EQUAL
62721: AND
62722: PUSH
62723: LD_INT 7
62725: PUSH
62726: LD_VAR 0 5
62730: IN
62731: PUSH
62732: LD_INT 28
62734: PUSH
62735: LD_VAR 0 5
62739: IN
62740: OR
62741: PUSH
62742: LD_INT 45
62744: PUSH
62745: LD_VAR 0 5
62749: IN
62750: OR
62751: AND
62752: IFFALSE 63006
// begin hex := GetHexInfo ( x , y ) ;
62754: LD_ADDR_VAR 0 4
62758: PUSH
62759: LD_VAR 0 10
62763: PPUSH
62764: LD_VAR 0 11
62768: PPUSH
62769: CALL_OW 546
62773: ST_TO_ADDR
// if hex [ 1 ] then
62774: LD_VAR 0 4
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: IFFALSE 62786
// exit ;
62784: GO 63189
// height := hex [ 2 ] ;
62786: LD_ADDR_VAR 0 15
62790: PUSH
62791: LD_VAR 0 4
62795: PUSH
62796: LD_INT 2
62798: ARRAY
62799: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62800: LD_ADDR_VAR 0 14
62804: PUSH
62805: LD_INT 0
62807: PUSH
62808: LD_INT 2
62810: PUSH
62811: LD_INT 3
62813: PUSH
62814: LD_INT 5
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: LIST
62821: LIST
62822: ST_TO_ADDR
// for i in tmp do
62823: LD_ADDR_VAR 0 8
62827: PUSH
62828: LD_VAR 0 14
62832: PUSH
62833: FOR_IN
62834: IFFALSE 63004
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62836: LD_ADDR_VAR 0 9
62840: PUSH
62841: LD_VAR 0 10
62845: PPUSH
62846: LD_VAR 0 8
62850: PPUSH
62851: LD_INT 5
62853: PPUSH
62854: CALL_OW 272
62858: PUSH
62859: LD_VAR 0 11
62863: PPUSH
62864: LD_VAR 0 8
62868: PPUSH
62869: LD_INT 5
62871: PPUSH
62872: CALL_OW 273
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62881: LD_VAR 0 9
62885: PUSH
62886: LD_INT 1
62888: ARRAY
62889: PPUSH
62890: LD_VAR 0 9
62894: PUSH
62895: LD_INT 2
62897: ARRAY
62898: PPUSH
62899: CALL_OW 488
62903: IFFALSE 63002
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62905: LD_ADDR_VAR 0 4
62909: PUSH
62910: LD_VAR 0 9
62914: PUSH
62915: LD_INT 1
62917: ARRAY
62918: PPUSH
62919: LD_VAR 0 9
62923: PUSH
62924: LD_INT 2
62926: ARRAY
62927: PPUSH
62928: CALL_OW 546
62932: ST_TO_ADDR
// if hex [ 1 ] then
62933: LD_VAR 0 4
62937: PUSH
62938: LD_INT 1
62940: ARRAY
62941: IFFALSE 62945
// continue ;
62943: GO 62833
// h := hex [ 2 ] ;
62945: LD_ADDR_VAR 0 13
62949: PUSH
62950: LD_VAR 0 4
62954: PUSH
62955: LD_INT 2
62957: ARRAY
62958: ST_TO_ADDR
// if h + 7 < height then
62959: LD_VAR 0 13
62963: PUSH
62964: LD_INT 7
62966: PLUS
62967: PUSH
62968: LD_VAR 0 15
62972: LESS
62973: IFFALSE 63002
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62975: LD_ADDR_VAR 0 18
62979: PUSH
62980: LD_INT 7
62982: PUSH
62983: LD_INT 28
62985: PUSH
62986: LD_INT 45
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: LIST
62993: PUSH
62994: LD_VAR 0 12
62998: ARRAY
62999: ST_TO_ADDR
// break ;
63000: GO 63004
// end ; end ; end ;
63002: GO 62833
63004: POP
63005: POP
// end ; if not weapon then
63006: LD_VAR 0 18
63010: NOT
63011: IFFALSE 63071
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63013: LD_ADDR_VAR 0 5
63017: PUSH
63018: LD_VAR 0 5
63022: PUSH
63023: LD_INT 11
63025: PUSH
63026: LD_INT 30
63028: PUSH
63029: LD_INT 49
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: DIFF
63037: ST_TO_ADDR
// if not list then
63038: LD_VAR 0 5
63042: NOT
63043: IFFALSE 63047
// exit ;
63045: GO 63189
// weapon := list [ rand ( 1 , list ) ] ;
63047: LD_ADDR_VAR 0 18
63051: PUSH
63052: LD_VAR 0 5
63056: PUSH
63057: LD_INT 1
63059: PPUSH
63060: LD_VAR 0 5
63064: PPUSH
63065: CALL_OW 12
63069: ARRAY
63070: ST_TO_ADDR
// end ; if weapon then
63071: LD_VAR 0 18
63075: IFFALSE 63189
// begin tmp := CostOfWeapon ( weapon ) ;
63077: LD_ADDR_VAR 0 14
63081: PUSH
63082: LD_VAR 0 18
63086: PPUSH
63087: CALL_OW 451
63091: ST_TO_ADDR
// j := GetBase ( tower ) ;
63092: LD_ADDR_VAR 0 9
63096: PUSH
63097: LD_VAR 0 1
63101: PPUSH
63102: CALL_OW 274
63106: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63107: LD_VAR 0 9
63111: PPUSH
63112: LD_INT 1
63114: PPUSH
63115: CALL_OW 275
63119: PUSH
63120: LD_VAR 0 14
63124: PUSH
63125: LD_INT 1
63127: ARRAY
63128: GREATEREQUAL
63129: PUSH
63130: LD_VAR 0 9
63134: PPUSH
63135: LD_INT 2
63137: PPUSH
63138: CALL_OW 275
63142: PUSH
63143: LD_VAR 0 14
63147: PUSH
63148: LD_INT 2
63150: ARRAY
63151: GREATEREQUAL
63152: AND
63153: PUSH
63154: LD_VAR 0 9
63158: PPUSH
63159: LD_INT 3
63161: PPUSH
63162: CALL_OW 275
63166: PUSH
63167: LD_VAR 0 14
63171: PUSH
63172: LD_INT 3
63174: ARRAY
63175: GREATEREQUAL
63176: AND
63177: IFFALSE 63189
// result := weapon ;
63179: LD_ADDR_VAR 0 3
63183: PUSH
63184: LD_VAR 0 18
63188: ST_TO_ADDR
// end ; end ;
63189: LD_VAR 0 3
63193: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63194: LD_INT 0
63196: PPUSH
63197: PPUSH
// result := true ;
63198: LD_ADDR_VAR 0 3
63202: PUSH
63203: LD_INT 1
63205: ST_TO_ADDR
// if array1 = array2 then
63206: LD_VAR 0 1
63210: PUSH
63211: LD_VAR 0 2
63215: EQUAL
63216: IFFALSE 63276
// begin for i = 1 to array1 do
63218: LD_ADDR_VAR 0 4
63222: PUSH
63223: DOUBLE
63224: LD_INT 1
63226: DEC
63227: ST_TO_ADDR
63228: LD_VAR 0 1
63232: PUSH
63233: FOR_TO
63234: IFFALSE 63272
// if array1 [ i ] <> array2 [ i ] then
63236: LD_VAR 0 1
63240: PUSH
63241: LD_VAR 0 4
63245: ARRAY
63246: PUSH
63247: LD_VAR 0 2
63251: PUSH
63252: LD_VAR 0 4
63256: ARRAY
63257: NONEQUAL
63258: IFFALSE 63270
// begin result := false ;
63260: LD_ADDR_VAR 0 3
63264: PUSH
63265: LD_INT 0
63267: ST_TO_ADDR
// break ;
63268: GO 63272
// end ;
63270: GO 63233
63272: POP
63273: POP
// end else
63274: GO 63284
// result := false ;
63276: LD_ADDR_VAR 0 3
63280: PUSH
63281: LD_INT 0
63283: ST_TO_ADDR
// end ;
63284: LD_VAR 0 3
63288: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63289: LD_INT 0
63291: PPUSH
63292: PPUSH
// if not array1 or not array2 then
63293: LD_VAR 0 1
63297: NOT
63298: PUSH
63299: LD_VAR 0 2
63303: NOT
63304: OR
63305: IFFALSE 63309
// exit ;
63307: GO 63373
// result := true ;
63309: LD_ADDR_VAR 0 3
63313: PUSH
63314: LD_INT 1
63316: ST_TO_ADDR
// for i = 1 to array1 do
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: DOUBLE
63323: LD_INT 1
63325: DEC
63326: ST_TO_ADDR
63327: LD_VAR 0 1
63331: PUSH
63332: FOR_TO
63333: IFFALSE 63371
// if array1 [ i ] <> array2 [ i ] then
63335: LD_VAR 0 1
63339: PUSH
63340: LD_VAR 0 4
63344: ARRAY
63345: PUSH
63346: LD_VAR 0 2
63350: PUSH
63351: LD_VAR 0 4
63355: ARRAY
63356: NONEQUAL
63357: IFFALSE 63369
// begin result := false ;
63359: LD_ADDR_VAR 0 3
63363: PUSH
63364: LD_INT 0
63366: ST_TO_ADDR
// break ;
63367: GO 63371
// end ;
63369: GO 63332
63371: POP
63372: POP
// end ;
63373: LD_VAR 0 3
63377: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63378: LD_INT 0
63380: PPUSH
63381: PPUSH
63382: PPUSH
// pom := GetBase ( fac ) ;
63383: LD_ADDR_VAR 0 5
63387: PUSH
63388: LD_VAR 0 1
63392: PPUSH
63393: CALL_OW 274
63397: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63398: LD_ADDR_VAR 0 4
63402: PUSH
63403: LD_VAR 0 2
63407: PUSH
63408: LD_INT 1
63410: ARRAY
63411: PPUSH
63412: LD_VAR 0 2
63416: PUSH
63417: LD_INT 2
63419: ARRAY
63420: PPUSH
63421: LD_VAR 0 2
63425: PUSH
63426: LD_INT 3
63428: ARRAY
63429: PPUSH
63430: LD_VAR 0 2
63434: PUSH
63435: LD_INT 4
63437: ARRAY
63438: PPUSH
63439: CALL_OW 449
63443: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63444: LD_ADDR_VAR 0 3
63448: PUSH
63449: LD_VAR 0 5
63453: PPUSH
63454: LD_INT 1
63456: PPUSH
63457: CALL_OW 275
63461: PUSH
63462: LD_VAR 0 4
63466: PUSH
63467: LD_INT 1
63469: ARRAY
63470: GREATEREQUAL
63471: PUSH
63472: LD_VAR 0 5
63476: PPUSH
63477: LD_INT 2
63479: PPUSH
63480: CALL_OW 275
63484: PUSH
63485: LD_VAR 0 4
63489: PUSH
63490: LD_INT 2
63492: ARRAY
63493: GREATEREQUAL
63494: AND
63495: PUSH
63496: LD_VAR 0 5
63500: PPUSH
63501: LD_INT 3
63503: PPUSH
63504: CALL_OW 275
63508: PUSH
63509: LD_VAR 0 4
63513: PUSH
63514: LD_INT 3
63516: ARRAY
63517: GREATEREQUAL
63518: AND
63519: ST_TO_ADDR
// end ;
63520: LD_VAR 0 3
63524: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63525: LD_INT 0
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
// pom := GetBase ( building ) ;
63531: LD_ADDR_VAR 0 3
63535: PUSH
63536: LD_VAR 0 1
63540: PPUSH
63541: CALL_OW 274
63545: ST_TO_ADDR
// if not pom then
63546: LD_VAR 0 3
63550: NOT
63551: IFFALSE 63555
// exit ;
63553: GO 63725
// btype := GetBType ( building ) ;
63555: LD_ADDR_VAR 0 5
63559: PUSH
63560: LD_VAR 0 1
63564: PPUSH
63565: CALL_OW 266
63569: ST_TO_ADDR
// if btype = b_armoury then
63570: LD_VAR 0 5
63574: PUSH
63575: LD_INT 4
63577: EQUAL
63578: IFFALSE 63588
// btype := b_barracks ;
63580: LD_ADDR_VAR 0 5
63584: PUSH
63585: LD_INT 5
63587: ST_TO_ADDR
// if btype = b_depot then
63588: LD_VAR 0 5
63592: PUSH
63593: LD_INT 0
63595: EQUAL
63596: IFFALSE 63606
// btype := b_warehouse ;
63598: LD_ADDR_VAR 0 5
63602: PUSH
63603: LD_INT 1
63605: ST_TO_ADDR
// if btype = b_workshop then
63606: LD_VAR 0 5
63610: PUSH
63611: LD_INT 2
63613: EQUAL
63614: IFFALSE 63624
// btype := b_factory ;
63616: LD_ADDR_VAR 0 5
63620: PUSH
63621: LD_INT 3
63623: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63624: LD_ADDR_VAR 0 4
63628: PUSH
63629: LD_VAR 0 5
63633: PPUSH
63634: LD_VAR 0 1
63638: PPUSH
63639: CALL_OW 248
63643: PPUSH
63644: CALL_OW 450
63648: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63649: LD_ADDR_VAR 0 2
63653: PUSH
63654: LD_VAR 0 3
63658: PPUSH
63659: LD_INT 1
63661: PPUSH
63662: CALL_OW 275
63666: PUSH
63667: LD_VAR 0 4
63671: PUSH
63672: LD_INT 1
63674: ARRAY
63675: GREATEREQUAL
63676: PUSH
63677: LD_VAR 0 3
63681: PPUSH
63682: LD_INT 2
63684: PPUSH
63685: CALL_OW 275
63689: PUSH
63690: LD_VAR 0 4
63694: PUSH
63695: LD_INT 2
63697: ARRAY
63698: GREATEREQUAL
63699: AND
63700: PUSH
63701: LD_VAR 0 3
63705: PPUSH
63706: LD_INT 3
63708: PPUSH
63709: CALL_OW 275
63713: PUSH
63714: LD_VAR 0 4
63718: PUSH
63719: LD_INT 3
63721: ARRAY
63722: GREATEREQUAL
63723: AND
63724: ST_TO_ADDR
// end ;
63725: LD_VAR 0 2
63729: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63730: LD_INT 0
63732: PPUSH
63733: PPUSH
63734: PPUSH
// pom := GetBase ( building ) ;
63735: LD_ADDR_VAR 0 4
63739: PUSH
63740: LD_VAR 0 1
63744: PPUSH
63745: CALL_OW 274
63749: ST_TO_ADDR
// if not pom then
63750: LD_VAR 0 4
63754: NOT
63755: IFFALSE 63759
// exit ;
63757: GO 63860
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63759: LD_ADDR_VAR 0 5
63763: PUSH
63764: LD_VAR 0 2
63768: PPUSH
63769: LD_VAR 0 1
63773: PPUSH
63774: CALL_OW 248
63778: PPUSH
63779: CALL_OW 450
63783: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63784: LD_ADDR_VAR 0 3
63788: PUSH
63789: LD_VAR 0 4
63793: PPUSH
63794: LD_INT 1
63796: PPUSH
63797: CALL_OW 275
63801: PUSH
63802: LD_VAR 0 5
63806: PUSH
63807: LD_INT 1
63809: ARRAY
63810: GREATEREQUAL
63811: PUSH
63812: LD_VAR 0 4
63816: PPUSH
63817: LD_INT 2
63819: PPUSH
63820: CALL_OW 275
63824: PUSH
63825: LD_VAR 0 5
63829: PUSH
63830: LD_INT 2
63832: ARRAY
63833: GREATEREQUAL
63834: AND
63835: PUSH
63836: LD_VAR 0 4
63840: PPUSH
63841: LD_INT 3
63843: PPUSH
63844: CALL_OW 275
63848: PUSH
63849: LD_VAR 0 5
63853: PUSH
63854: LD_INT 3
63856: ARRAY
63857: GREATEREQUAL
63858: AND
63859: ST_TO_ADDR
// end ;
63860: LD_VAR 0 3
63864: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63865: LD_INT 0
63867: PPUSH
63868: PPUSH
63869: PPUSH
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
// result := false ;
63878: LD_ADDR_VAR 0 8
63882: PUSH
63883: LD_INT 0
63885: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63886: LD_VAR 0 5
63890: NOT
63891: PUSH
63892: LD_VAR 0 1
63896: NOT
63897: OR
63898: PUSH
63899: LD_VAR 0 2
63903: NOT
63904: OR
63905: PUSH
63906: LD_VAR 0 3
63910: NOT
63911: OR
63912: IFFALSE 63916
// exit ;
63914: GO 64730
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63916: LD_ADDR_VAR 0 14
63920: PUSH
63921: LD_VAR 0 1
63925: PPUSH
63926: LD_VAR 0 2
63930: PPUSH
63931: LD_VAR 0 3
63935: PPUSH
63936: LD_VAR 0 4
63940: PPUSH
63941: LD_VAR 0 5
63945: PUSH
63946: LD_INT 1
63948: ARRAY
63949: PPUSH
63950: CALL_OW 248
63954: PPUSH
63955: LD_INT 0
63957: PPUSH
63958: CALL 65967 0 6
63962: ST_TO_ADDR
// if not hexes then
63963: LD_VAR 0 14
63967: NOT
63968: IFFALSE 63972
// exit ;
63970: GO 64730
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63972: LD_ADDR_VAR 0 17
63976: PUSH
63977: LD_VAR 0 5
63981: PPUSH
63982: LD_INT 22
63984: PUSH
63985: LD_VAR 0 13
63989: PPUSH
63990: CALL_OW 255
63994: PUSH
63995: EMPTY
63996: LIST
63997: LIST
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 30
64014: PUSH
64015: LD_INT 1
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: LIST
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PPUSH
64031: CALL_OW 72
64035: ST_TO_ADDR
// for i = 1 to hexes do
64036: LD_ADDR_VAR 0 9
64040: PUSH
64041: DOUBLE
64042: LD_INT 1
64044: DEC
64045: ST_TO_ADDR
64046: LD_VAR 0 14
64050: PUSH
64051: FOR_TO
64052: IFFALSE 64728
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64054: LD_ADDR_VAR 0 13
64058: PUSH
64059: LD_VAR 0 14
64063: PUSH
64064: LD_VAR 0 9
64068: ARRAY
64069: PUSH
64070: LD_INT 1
64072: ARRAY
64073: PPUSH
64074: LD_VAR 0 14
64078: PUSH
64079: LD_VAR 0 9
64083: ARRAY
64084: PUSH
64085: LD_INT 2
64087: ARRAY
64088: PPUSH
64089: CALL_OW 428
64093: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64094: LD_VAR 0 14
64098: PUSH
64099: LD_VAR 0 9
64103: ARRAY
64104: PUSH
64105: LD_INT 1
64107: ARRAY
64108: PPUSH
64109: LD_VAR 0 14
64113: PUSH
64114: LD_VAR 0 9
64118: ARRAY
64119: PUSH
64120: LD_INT 2
64122: ARRAY
64123: PPUSH
64124: CALL_OW 351
64128: PUSH
64129: LD_VAR 0 14
64133: PUSH
64134: LD_VAR 0 9
64138: ARRAY
64139: PUSH
64140: LD_INT 1
64142: ARRAY
64143: PPUSH
64144: LD_VAR 0 14
64148: PUSH
64149: LD_VAR 0 9
64153: ARRAY
64154: PUSH
64155: LD_INT 2
64157: ARRAY
64158: PPUSH
64159: CALL_OW 488
64163: NOT
64164: OR
64165: PUSH
64166: LD_VAR 0 13
64170: PPUSH
64171: CALL_OW 247
64175: PUSH
64176: LD_INT 3
64178: EQUAL
64179: OR
64180: IFFALSE 64186
// exit ;
64182: POP
64183: POP
64184: GO 64730
// if not tmp then
64186: LD_VAR 0 13
64190: NOT
64191: IFFALSE 64195
// continue ;
64193: GO 64051
// result := true ;
64195: LD_ADDR_VAR 0 8
64199: PUSH
64200: LD_INT 1
64202: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64203: LD_VAR 0 6
64207: PUSH
64208: LD_VAR 0 13
64212: PPUSH
64213: CALL_OW 247
64217: PUSH
64218: LD_INT 2
64220: EQUAL
64221: AND
64222: PUSH
64223: LD_VAR 0 13
64227: PPUSH
64228: CALL_OW 263
64232: PUSH
64233: LD_INT 1
64235: EQUAL
64236: AND
64237: IFFALSE 64401
// begin if IsDrivenBy ( tmp ) then
64239: LD_VAR 0 13
64243: PPUSH
64244: CALL_OW 311
64248: IFFALSE 64252
// continue ;
64250: GO 64051
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64252: LD_VAR 0 6
64256: PPUSH
64257: LD_INT 3
64259: PUSH
64260: LD_INT 60
64262: PUSH
64263: EMPTY
64264: LIST
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 3
64272: PUSH
64273: LD_INT 55
64275: PUSH
64276: EMPTY
64277: LIST
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PPUSH
64287: CALL_OW 72
64291: IFFALSE 64399
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64293: LD_ADDR_VAR 0 18
64297: PUSH
64298: LD_VAR 0 6
64302: PPUSH
64303: LD_INT 3
64305: PUSH
64306: LD_INT 60
64308: PUSH
64309: EMPTY
64310: LIST
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 3
64318: PUSH
64319: LD_INT 55
64321: PUSH
64322: EMPTY
64323: LIST
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PPUSH
64333: CALL_OW 72
64337: PUSH
64338: LD_INT 1
64340: ARRAY
64341: ST_TO_ADDR
// if IsInUnit ( driver ) then
64342: LD_VAR 0 18
64346: PPUSH
64347: CALL_OW 310
64351: IFFALSE 64362
// ComExit ( driver ) ;
64353: LD_VAR 0 18
64357: PPUSH
64358: CALL 89151 0 1
// AddComEnterUnit ( driver , tmp ) ;
64362: LD_VAR 0 18
64366: PPUSH
64367: LD_VAR 0 13
64371: PPUSH
64372: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64376: LD_VAR 0 18
64380: PPUSH
64381: LD_VAR 0 7
64385: PPUSH
64386: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64390: LD_VAR 0 18
64394: PPUSH
64395: CALL_OW 181
// end ; continue ;
64399: GO 64051
// end ; if not cleaners or not tmp in cleaners then
64401: LD_VAR 0 6
64405: NOT
64406: PUSH
64407: LD_VAR 0 13
64411: PUSH
64412: LD_VAR 0 6
64416: IN
64417: NOT
64418: OR
64419: IFFALSE 64726
// begin if dep then
64421: LD_VAR 0 17
64425: IFFALSE 64561
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64427: LD_ADDR_VAR 0 16
64431: PUSH
64432: LD_VAR 0 17
64436: PUSH
64437: LD_INT 1
64439: ARRAY
64440: PPUSH
64441: CALL_OW 250
64445: PPUSH
64446: LD_VAR 0 17
64450: PUSH
64451: LD_INT 1
64453: ARRAY
64454: PPUSH
64455: CALL_OW 254
64459: PPUSH
64460: LD_INT 5
64462: PPUSH
64463: CALL_OW 272
64467: PUSH
64468: LD_VAR 0 17
64472: PUSH
64473: LD_INT 1
64475: ARRAY
64476: PPUSH
64477: CALL_OW 251
64481: PPUSH
64482: LD_VAR 0 17
64486: PUSH
64487: LD_INT 1
64489: ARRAY
64490: PPUSH
64491: CALL_OW 254
64495: PPUSH
64496: LD_INT 5
64498: PPUSH
64499: CALL_OW 273
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64508: LD_VAR 0 16
64512: PUSH
64513: LD_INT 1
64515: ARRAY
64516: PPUSH
64517: LD_VAR 0 16
64521: PUSH
64522: LD_INT 2
64524: ARRAY
64525: PPUSH
64526: CALL_OW 488
64530: IFFALSE 64561
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64532: LD_VAR 0 13
64536: PPUSH
64537: LD_VAR 0 16
64541: PUSH
64542: LD_INT 1
64544: ARRAY
64545: PPUSH
64546: LD_VAR 0 16
64550: PUSH
64551: LD_INT 2
64553: ARRAY
64554: PPUSH
64555: CALL_OW 111
// continue ;
64559: GO 64051
// end ; end ; r := GetDir ( tmp ) ;
64561: LD_ADDR_VAR 0 15
64565: PUSH
64566: LD_VAR 0 13
64570: PPUSH
64571: CALL_OW 254
64575: ST_TO_ADDR
// if r = 5 then
64576: LD_VAR 0 15
64580: PUSH
64581: LD_INT 5
64583: EQUAL
64584: IFFALSE 64594
// r := 0 ;
64586: LD_ADDR_VAR 0 15
64590: PUSH
64591: LD_INT 0
64593: ST_TO_ADDR
// for j = r to 5 do
64594: LD_ADDR_VAR 0 10
64598: PUSH
64599: DOUBLE
64600: LD_VAR 0 15
64604: DEC
64605: ST_TO_ADDR
64606: LD_INT 5
64608: PUSH
64609: FOR_TO
64610: IFFALSE 64724
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64612: LD_ADDR_VAR 0 11
64616: PUSH
64617: LD_VAR 0 13
64621: PPUSH
64622: CALL_OW 250
64626: PPUSH
64627: LD_VAR 0 10
64631: PPUSH
64632: LD_INT 2
64634: PPUSH
64635: CALL_OW 272
64639: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64640: LD_ADDR_VAR 0 12
64644: PUSH
64645: LD_VAR 0 13
64649: PPUSH
64650: CALL_OW 251
64654: PPUSH
64655: LD_VAR 0 10
64659: PPUSH
64660: LD_INT 2
64662: PPUSH
64663: CALL_OW 273
64667: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64668: LD_VAR 0 11
64672: PPUSH
64673: LD_VAR 0 12
64677: PPUSH
64678: CALL_OW 488
64682: PUSH
64683: LD_VAR 0 11
64687: PPUSH
64688: LD_VAR 0 12
64692: PPUSH
64693: CALL_OW 428
64697: NOT
64698: AND
64699: IFFALSE 64722
// begin ComMoveXY ( tmp , _x , _y ) ;
64701: LD_VAR 0 13
64705: PPUSH
64706: LD_VAR 0 11
64710: PPUSH
64711: LD_VAR 0 12
64715: PPUSH
64716: CALL_OW 111
// break ;
64720: GO 64724
// end ; end ;
64722: GO 64609
64724: POP
64725: POP
// end ; end ;
64726: GO 64051
64728: POP
64729: POP
// end ;
64730: LD_VAR 0 8
64734: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64735: LD_INT 0
64737: PPUSH
// result := true ;
64738: LD_ADDR_VAR 0 3
64742: PUSH
64743: LD_INT 1
64745: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64746: LD_VAR 0 2
64750: PUSH
64751: LD_INT 24
64753: DOUBLE
64754: EQUAL
64755: IFTRUE 64765
64757: LD_INT 33
64759: DOUBLE
64760: EQUAL
64761: IFTRUE 64765
64763: GO 64790
64765: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64766: LD_ADDR_VAR 0 3
64770: PUSH
64771: LD_INT 32
64773: PPUSH
64774: LD_VAR 0 1
64778: PPUSH
64779: CALL_OW 321
64783: PUSH
64784: LD_INT 2
64786: EQUAL
64787: ST_TO_ADDR
64788: GO 65110
64790: LD_INT 20
64792: DOUBLE
64793: EQUAL
64794: IFTRUE 64798
64796: GO 64823
64798: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64799: LD_ADDR_VAR 0 3
64803: PUSH
64804: LD_INT 6
64806: PPUSH
64807: LD_VAR 0 1
64811: PPUSH
64812: CALL_OW 321
64816: PUSH
64817: LD_INT 2
64819: EQUAL
64820: ST_TO_ADDR
64821: GO 65110
64823: LD_INT 22
64825: DOUBLE
64826: EQUAL
64827: IFTRUE 64837
64829: LD_INT 36
64831: DOUBLE
64832: EQUAL
64833: IFTRUE 64837
64835: GO 64862
64837: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64838: LD_ADDR_VAR 0 3
64842: PUSH
64843: LD_INT 15
64845: PPUSH
64846: LD_VAR 0 1
64850: PPUSH
64851: CALL_OW 321
64855: PUSH
64856: LD_INT 2
64858: EQUAL
64859: ST_TO_ADDR
64860: GO 65110
64862: LD_INT 30
64864: DOUBLE
64865: EQUAL
64866: IFTRUE 64870
64868: GO 64895
64870: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64871: LD_ADDR_VAR 0 3
64875: PUSH
64876: LD_INT 20
64878: PPUSH
64879: LD_VAR 0 1
64883: PPUSH
64884: CALL_OW 321
64888: PUSH
64889: LD_INT 2
64891: EQUAL
64892: ST_TO_ADDR
64893: GO 65110
64895: LD_INT 28
64897: DOUBLE
64898: EQUAL
64899: IFTRUE 64909
64901: LD_INT 21
64903: DOUBLE
64904: EQUAL
64905: IFTRUE 64909
64907: GO 64934
64909: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64910: LD_ADDR_VAR 0 3
64914: PUSH
64915: LD_INT 21
64917: PPUSH
64918: LD_VAR 0 1
64922: PPUSH
64923: CALL_OW 321
64927: PUSH
64928: LD_INT 2
64930: EQUAL
64931: ST_TO_ADDR
64932: GO 65110
64934: LD_INT 16
64936: DOUBLE
64937: EQUAL
64938: IFTRUE 64942
64940: GO 64969
64942: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64943: LD_ADDR_VAR 0 3
64947: PUSH
64948: LD_EXP 86
64952: PPUSH
64953: LD_VAR 0 1
64957: PPUSH
64958: CALL_OW 321
64962: PUSH
64963: LD_INT 2
64965: EQUAL
64966: ST_TO_ADDR
64967: GO 65110
64969: LD_INT 19
64971: DOUBLE
64972: EQUAL
64973: IFTRUE 64983
64975: LD_INT 23
64977: DOUBLE
64978: EQUAL
64979: IFTRUE 64983
64981: GO 65010
64983: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64984: LD_ADDR_VAR 0 3
64988: PUSH
64989: LD_EXP 85
64993: PPUSH
64994: LD_VAR 0 1
64998: PPUSH
64999: CALL_OW 321
65003: PUSH
65004: LD_INT 2
65006: EQUAL
65007: ST_TO_ADDR
65008: GO 65110
65010: LD_INT 17
65012: DOUBLE
65013: EQUAL
65014: IFTRUE 65018
65016: GO 65043
65018: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65019: LD_ADDR_VAR 0 3
65023: PUSH
65024: LD_INT 39
65026: PPUSH
65027: LD_VAR 0 1
65031: PPUSH
65032: CALL_OW 321
65036: PUSH
65037: LD_INT 2
65039: EQUAL
65040: ST_TO_ADDR
65041: GO 65110
65043: LD_INT 18
65045: DOUBLE
65046: EQUAL
65047: IFTRUE 65051
65049: GO 65076
65051: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65052: LD_ADDR_VAR 0 3
65056: PUSH
65057: LD_INT 40
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 321
65069: PUSH
65070: LD_INT 2
65072: EQUAL
65073: ST_TO_ADDR
65074: GO 65110
65076: LD_INT 27
65078: DOUBLE
65079: EQUAL
65080: IFTRUE 65084
65082: GO 65109
65084: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65085: LD_ADDR_VAR 0 3
65089: PUSH
65090: LD_INT 35
65092: PPUSH
65093: LD_VAR 0 1
65097: PPUSH
65098: CALL_OW 321
65102: PUSH
65103: LD_INT 2
65105: EQUAL
65106: ST_TO_ADDR
65107: GO 65110
65109: POP
// end ;
65110: LD_VAR 0 3
65114: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65115: LD_INT 0
65117: PPUSH
65118: PPUSH
65119: PPUSH
65120: PPUSH
65121: PPUSH
65122: PPUSH
65123: PPUSH
65124: PPUSH
65125: PPUSH
65126: PPUSH
65127: PPUSH
// result := false ;
65128: LD_ADDR_VAR 0 6
65132: PUSH
65133: LD_INT 0
65135: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65136: LD_VAR 0 1
65140: NOT
65141: PUSH
65142: LD_VAR 0 1
65146: PPUSH
65147: CALL_OW 266
65151: PUSH
65152: LD_INT 0
65154: PUSH
65155: LD_INT 1
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: IN
65162: NOT
65163: OR
65164: PUSH
65165: LD_VAR 0 2
65169: NOT
65170: OR
65171: PUSH
65172: LD_VAR 0 5
65176: PUSH
65177: LD_INT 0
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 2
65185: PUSH
65186: LD_INT 3
65188: PUSH
65189: LD_INT 4
65191: PUSH
65192: LD_INT 5
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: IN
65203: NOT
65204: OR
65205: PUSH
65206: LD_VAR 0 3
65210: PPUSH
65211: LD_VAR 0 4
65215: PPUSH
65216: CALL_OW 488
65220: NOT
65221: OR
65222: IFFALSE 65226
// exit ;
65224: GO 65962
// side := GetSide ( depot ) ;
65226: LD_ADDR_VAR 0 9
65230: PUSH
65231: LD_VAR 0 1
65235: PPUSH
65236: CALL_OW 255
65240: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65241: LD_VAR 0 9
65245: PPUSH
65246: LD_VAR 0 2
65250: PPUSH
65251: CALL 64735 0 2
65255: NOT
65256: IFFALSE 65260
// exit ;
65258: GO 65962
// pom := GetBase ( depot ) ;
65260: LD_ADDR_VAR 0 10
65264: PUSH
65265: LD_VAR 0 1
65269: PPUSH
65270: CALL_OW 274
65274: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65275: LD_ADDR_VAR 0 11
65279: PUSH
65280: LD_VAR 0 2
65284: PPUSH
65285: LD_VAR 0 1
65289: PPUSH
65290: CALL_OW 248
65294: PPUSH
65295: CALL_OW 450
65299: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65300: LD_VAR 0 10
65304: PPUSH
65305: LD_INT 1
65307: PPUSH
65308: CALL_OW 275
65312: PUSH
65313: LD_VAR 0 11
65317: PUSH
65318: LD_INT 1
65320: ARRAY
65321: GREATEREQUAL
65322: PUSH
65323: LD_VAR 0 10
65327: PPUSH
65328: LD_INT 2
65330: PPUSH
65331: CALL_OW 275
65335: PUSH
65336: LD_VAR 0 11
65340: PUSH
65341: LD_INT 2
65343: ARRAY
65344: GREATEREQUAL
65345: AND
65346: PUSH
65347: LD_VAR 0 10
65351: PPUSH
65352: LD_INT 3
65354: PPUSH
65355: CALL_OW 275
65359: PUSH
65360: LD_VAR 0 11
65364: PUSH
65365: LD_INT 3
65367: ARRAY
65368: GREATEREQUAL
65369: AND
65370: NOT
65371: IFFALSE 65375
// exit ;
65373: GO 65962
// if GetBType ( depot ) = b_depot then
65375: LD_VAR 0 1
65379: PPUSH
65380: CALL_OW 266
65384: PUSH
65385: LD_INT 0
65387: EQUAL
65388: IFFALSE 65400
// dist := 28 else
65390: LD_ADDR_VAR 0 14
65394: PUSH
65395: LD_INT 28
65397: ST_TO_ADDR
65398: GO 65408
// dist := 36 ;
65400: LD_ADDR_VAR 0 14
65404: PUSH
65405: LD_INT 36
65407: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65408: LD_VAR 0 1
65412: PPUSH
65413: LD_VAR 0 3
65417: PPUSH
65418: LD_VAR 0 4
65422: PPUSH
65423: CALL_OW 297
65427: PUSH
65428: LD_VAR 0 14
65432: GREATER
65433: IFFALSE 65437
// exit ;
65435: GO 65962
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65437: LD_ADDR_VAR 0 12
65441: PUSH
65442: LD_VAR 0 2
65446: PPUSH
65447: LD_VAR 0 3
65451: PPUSH
65452: LD_VAR 0 4
65456: PPUSH
65457: LD_VAR 0 5
65461: PPUSH
65462: LD_VAR 0 1
65466: PPUSH
65467: CALL_OW 248
65471: PPUSH
65472: LD_INT 0
65474: PPUSH
65475: CALL 65967 0 6
65479: ST_TO_ADDR
// if not hexes then
65480: LD_VAR 0 12
65484: NOT
65485: IFFALSE 65489
// exit ;
65487: GO 65962
// hex := GetHexInfo ( x , y ) ;
65489: LD_ADDR_VAR 0 15
65493: PUSH
65494: LD_VAR 0 3
65498: PPUSH
65499: LD_VAR 0 4
65503: PPUSH
65504: CALL_OW 546
65508: ST_TO_ADDR
// if hex [ 1 ] then
65509: LD_VAR 0 15
65513: PUSH
65514: LD_INT 1
65516: ARRAY
65517: IFFALSE 65521
// exit ;
65519: GO 65962
// height := hex [ 2 ] ;
65521: LD_ADDR_VAR 0 13
65525: PUSH
65526: LD_VAR 0 15
65530: PUSH
65531: LD_INT 2
65533: ARRAY
65534: ST_TO_ADDR
// for i = 1 to hexes do
65535: LD_ADDR_VAR 0 7
65539: PUSH
65540: DOUBLE
65541: LD_INT 1
65543: DEC
65544: ST_TO_ADDR
65545: LD_VAR 0 12
65549: PUSH
65550: FOR_TO
65551: IFFALSE 65881
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65553: LD_VAR 0 12
65557: PUSH
65558: LD_VAR 0 7
65562: ARRAY
65563: PUSH
65564: LD_INT 1
65566: ARRAY
65567: PPUSH
65568: LD_VAR 0 12
65572: PUSH
65573: LD_VAR 0 7
65577: ARRAY
65578: PUSH
65579: LD_INT 2
65581: ARRAY
65582: PPUSH
65583: CALL_OW 488
65587: NOT
65588: PUSH
65589: LD_VAR 0 12
65593: PUSH
65594: LD_VAR 0 7
65598: ARRAY
65599: PUSH
65600: LD_INT 1
65602: ARRAY
65603: PPUSH
65604: LD_VAR 0 12
65608: PUSH
65609: LD_VAR 0 7
65613: ARRAY
65614: PUSH
65615: LD_INT 2
65617: ARRAY
65618: PPUSH
65619: CALL_OW 428
65623: PUSH
65624: LD_INT 0
65626: GREATER
65627: OR
65628: PUSH
65629: LD_VAR 0 12
65633: PUSH
65634: LD_VAR 0 7
65638: ARRAY
65639: PUSH
65640: LD_INT 1
65642: ARRAY
65643: PPUSH
65644: LD_VAR 0 12
65648: PUSH
65649: LD_VAR 0 7
65653: ARRAY
65654: PUSH
65655: LD_INT 2
65657: ARRAY
65658: PPUSH
65659: CALL_OW 351
65663: OR
65664: IFFALSE 65670
// exit ;
65666: POP
65667: POP
65668: GO 65962
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65670: LD_ADDR_VAR 0 8
65674: PUSH
65675: LD_VAR 0 12
65679: PUSH
65680: LD_VAR 0 7
65684: ARRAY
65685: PUSH
65686: LD_INT 1
65688: ARRAY
65689: PPUSH
65690: LD_VAR 0 12
65694: PUSH
65695: LD_VAR 0 7
65699: ARRAY
65700: PUSH
65701: LD_INT 2
65703: ARRAY
65704: PPUSH
65705: CALL_OW 546
65709: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65710: LD_VAR 0 8
65714: PUSH
65715: LD_INT 1
65717: ARRAY
65718: PUSH
65719: LD_VAR 0 8
65723: PUSH
65724: LD_INT 2
65726: ARRAY
65727: PUSH
65728: LD_VAR 0 13
65732: PUSH
65733: LD_INT 2
65735: PLUS
65736: GREATER
65737: OR
65738: PUSH
65739: LD_VAR 0 8
65743: PUSH
65744: LD_INT 2
65746: ARRAY
65747: PUSH
65748: LD_VAR 0 13
65752: PUSH
65753: LD_INT 2
65755: MINUS
65756: LESS
65757: OR
65758: PUSH
65759: LD_VAR 0 8
65763: PUSH
65764: LD_INT 3
65766: ARRAY
65767: PUSH
65768: LD_INT 0
65770: PUSH
65771: LD_INT 8
65773: PUSH
65774: LD_INT 9
65776: PUSH
65777: LD_INT 10
65779: PUSH
65780: LD_INT 11
65782: PUSH
65783: LD_INT 12
65785: PUSH
65786: LD_INT 13
65788: PUSH
65789: LD_INT 16
65791: PUSH
65792: LD_INT 17
65794: PUSH
65795: LD_INT 18
65797: PUSH
65798: LD_INT 19
65800: PUSH
65801: LD_INT 20
65803: PUSH
65804: LD_INT 21
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: IN
65822: NOT
65823: OR
65824: PUSH
65825: LD_VAR 0 8
65829: PUSH
65830: LD_INT 5
65832: ARRAY
65833: NOT
65834: OR
65835: PUSH
65836: LD_VAR 0 8
65840: PUSH
65841: LD_INT 6
65843: ARRAY
65844: PUSH
65845: LD_INT 1
65847: PUSH
65848: LD_INT 2
65850: PUSH
65851: LD_INT 7
65853: PUSH
65854: LD_INT 9
65856: PUSH
65857: LD_INT 10
65859: PUSH
65860: LD_INT 11
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: IN
65871: NOT
65872: OR
65873: IFFALSE 65879
// exit ;
65875: POP
65876: POP
65877: GO 65962
// end ;
65879: GO 65550
65881: POP
65882: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65883: LD_VAR 0 9
65887: PPUSH
65888: LD_VAR 0 3
65892: PPUSH
65893: LD_VAR 0 4
65897: PPUSH
65898: LD_INT 20
65900: PPUSH
65901: CALL 57908 0 4
65905: PUSH
65906: LD_INT 4
65908: ARRAY
65909: IFFALSE 65913
// exit ;
65911: GO 65962
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65913: LD_VAR 0 2
65917: PUSH
65918: LD_INT 29
65920: PUSH
65921: LD_INT 30
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: IN
65928: PUSH
65929: LD_VAR 0 3
65933: PPUSH
65934: LD_VAR 0 4
65938: PPUSH
65939: LD_VAR 0 9
65943: PPUSH
65944: CALL_OW 440
65948: NOT
65949: AND
65950: IFFALSE 65954
// exit ;
65952: GO 65962
// result := true ;
65954: LD_ADDR_VAR 0 6
65958: PUSH
65959: LD_INT 1
65961: ST_TO_ADDR
// end ;
65962: LD_VAR 0 6
65966: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65967: LD_INT 0
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
65973: PPUSH
65974: PPUSH
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
// result = [ ] ;
66027: LD_ADDR_VAR 0 7
66031: PUSH
66032: EMPTY
66033: ST_TO_ADDR
// temp_list = [ ] ;
66034: LD_ADDR_VAR 0 9
66038: PUSH
66039: EMPTY
66040: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66041: LD_VAR 0 4
66045: PUSH
66046: LD_INT 0
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: LD_INT 3
66057: PUSH
66058: LD_INT 4
66060: PUSH
66061: LD_INT 5
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: IN
66072: NOT
66073: PUSH
66074: LD_VAR 0 1
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: IN
66089: PUSH
66090: LD_VAR 0 5
66094: PUSH
66095: LD_INT 1
66097: PUSH
66098: LD_INT 2
66100: PUSH
66101: LD_INT 3
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: LIST
66108: IN
66109: NOT
66110: AND
66111: OR
66112: IFFALSE 66116
// exit ;
66114: GO 84507
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66116: LD_VAR 0 1
66120: PUSH
66121: LD_INT 6
66123: PUSH
66124: LD_INT 7
66126: PUSH
66127: LD_INT 8
66129: PUSH
66130: LD_INT 13
66132: PUSH
66133: LD_INT 12
66135: PUSH
66136: LD_INT 15
66138: PUSH
66139: LD_INT 11
66141: PUSH
66142: LD_INT 14
66144: PUSH
66145: LD_INT 10
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: IN
66159: IFFALSE 66169
// btype = b_lab ;
66161: LD_ADDR_VAR 0 1
66165: PUSH
66166: LD_INT 6
66168: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66169: LD_VAR 0 6
66173: PUSH
66174: LD_INT 0
66176: PUSH
66177: LD_INT 1
66179: PUSH
66180: LD_INT 2
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: LIST
66187: IN
66188: NOT
66189: PUSH
66190: LD_VAR 0 1
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 1
66200: PUSH
66201: LD_INT 2
66203: PUSH
66204: LD_INT 3
66206: PUSH
66207: LD_INT 6
66209: PUSH
66210: LD_INT 36
66212: PUSH
66213: LD_INT 4
66215: PUSH
66216: LD_INT 5
66218: PUSH
66219: LD_INT 31
66221: PUSH
66222: LD_INT 32
66224: PUSH
66225: LD_INT 33
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: IN
66241: NOT
66242: PUSH
66243: LD_VAR 0 6
66247: PUSH
66248: LD_INT 1
66250: EQUAL
66251: AND
66252: OR
66253: PUSH
66254: LD_VAR 0 1
66258: PUSH
66259: LD_INT 2
66261: PUSH
66262: LD_INT 3
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: IN
66269: NOT
66270: PUSH
66271: LD_VAR 0 6
66275: PUSH
66276: LD_INT 2
66278: EQUAL
66279: AND
66280: OR
66281: IFFALSE 66291
// mode = 0 ;
66283: LD_ADDR_VAR 0 6
66287: PUSH
66288: LD_INT 0
66290: ST_TO_ADDR
// case mode of 0 :
66291: LD_VAR 0 6
66295: PUSH
66296: LD_INT 0
66298: DOUBLE
66299: EQUAL
66300: IFTRUE 66304
66302: GO 77757
66304: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66305: LD_ADDR_VAR 0 11
66309: PUSH
66310: LD_INT 0
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 1
66325: NEG
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 1
66333: PUSH
66334: LD_INT 0
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: PUSH
66344: LD_INT 1
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: LD_INT 1
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 1
66363: NEG
66364: PUSH
66365: LD_INT 0
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 1
66374: NEG
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: LD_INT 2
66390: NEG
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 2
66401: NEG
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: LD_INT 1
66412: NEG
66413: PUSH
66414: EMPTY
66415: LIST
66416: LIST
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: LD_INT 2
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: LD_INT 2
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: LD_INT 1
66440: NEG
66441: PUSH
66442: LD_INT 1
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: LD_INT 3
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: LD_INT 3
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 1
66471: NEG
66472: PUSH
66473: LD_INT 2
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66498: LD_ADDR_VAR 0 12
66502: PUSH
66503: LD_INT 0
66505: PUSH
66506: LD_INT 0
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: LD_INT 1
66518: NEG
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 1
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: LD_INT 1
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: NEG
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 2
66590: PUSH
66591: LD_INT 0
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: LD_INT 2
66600: PUSH
66601: LD_INT 1
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 2
66621: NEG
66622: PUSH
66623: LD_INT 0
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 2
66644: NEG
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 3
66655: NEG
66656: PUSH
66657: LD_INT 0
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 3
66666: NEG
66667: PUSH
66668: LD_INT 1
66670: NEG
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66694: LD_ADDR_VAR 0 13
66698: PUSH
66699: LD_INT 0
66701: PUSH
66702: LD_INT 0
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: LD_INT 1
66714: NEG
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 1
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 0
66742: PUSH
66743: LD_INT 1
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: LD_INT 0
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 1
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: LD_INT 2
66779: NEG
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 2
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: LD_INT 2
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 1
66807: PUSH
66808: LD_INT 2
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 2
66817: NEG
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: LD_INT 2
66833: NEG
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 2
66841: NEG
66842: PUSH
66843: LD_INT 3
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 3
66853: NEG
66854: PUSH
66855: LD_INT 2
66857: NEG
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 3
66865: NEG
66866: PUSH
66867: LD_INT 3
66869: NEG
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66893: LD_ADDR_VAR 0 14
66897: PUSH
66898: LD_INT 0
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: LD_INT 0
66910: PUSH
66911: LD_INT 1
66913: NEG
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: LD_INT 0
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 1
66931: PUSH
66932: LD_INT 1
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 0
66941: PUSH
66942: LD_INT 1
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 1
66951: NEG
66952: PUSH
66953: LD_INT 0
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 1
66962: NEG
66963: PUSH
66964: LD_INT 1
66966: NEG
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: LD_INT 2
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 0
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 1
66997: PUSH
66998: LD_INT 1
67000: NEG
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 1
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: LD_INT 2
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 1
67028: NEG
67029: PUSH
67030: LD_INT 1
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: LD_INT 3
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: LD_INT 3
67054: NEG
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: PUSH
67063: LD_INT 2
67065: NEG
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: LIST
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67089: LD_ADDR_VAR 0 15
67093: PUSH
67094: LD_INT 0
67096: PUSH
67097: LD_INT 0
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: LD_INT 1
67109: NEG
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: LD_INT 0
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: LD_INT 1
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 0
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 1
67147: NEG
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 1
67158: NEG
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 1
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 2
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: PUSH
67192: LD_INT 1
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 1
67201: NEG
67202: PUSH
67203: LD_INT 1
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 2
67212: NEG
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 2
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 3
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 3
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67282: LD_ADDR_VAR 0 16
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: LD_INT 0
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 0
67299: PUSH
67300: LD_INT 1
67302: NEG
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 1
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 1
67320: PUSH
67321: LD_INT 1
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 0
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 1
67340: NEG
67341: PUSH
67342: LD_INT 0
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: LD_INT 1
67355: NEG
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: LD_INT 2
67367: NEG
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 2
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: LD_INT 2
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: LD_INT 2
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 2
67405: NEG
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 2
67417: NEG
67418: PUSH
67419: LD_INT 2
67421: NEG
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 3
67429: PUSH
67430: LD_INT 2
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 3
67439: PUSH
67440: LD_INT 3
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 2
67449: PUSH
67450: LD_INT 3
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67475: LD_ADDR_VAR 0 17
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: LD_INT 1
67495: NEG
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: LD_INT 0
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 0
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 1
67533: NEG
67534: PUSH
67535: LD_INT 0
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 1
67548: NEG
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 2
67560: NEG
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: LD_INT 0
67568: PUSH
67569: LD_INT 2
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: PUSH
67580: LD_INT 1
67582: NEG
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 2
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: LD_INT 1
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: LD_INT 1
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 2
67651: NEG
67652: PUSH
67653: LD_INT 0
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 2
67662: NEG
67663: PUSH
67664: LD_INT 1
67666: NEG
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: NEG
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67705: LD_ADDR_VAR 0 18
67709: PUSH
67710: LD_INT 0
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 0
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 1
67733: PUSH
67734: LD_INT 0
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: LD_INT 1
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: LD_INT 0
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: LD_INT 1
67778: NEG
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 2
67790: NEG
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: LD_INT 2
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: LD_INT 1
67812: NEG
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 2
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 2
67830: PUSH
67831: LD_INT 1
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 2
67840: PUSH
67841: LD_INT 2
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: LD_INT 2
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 2
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: LD_INT 1
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 2
67881: NEG
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 2
67892: NEG
67893: PUSH
67894: LD_INT 1
67896: NEG
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 2
67904: NEG
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67935: LD_ADDR_VAR 0 19
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 0
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: LD_INT 0
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: NEG
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: PUSH
68018: LD_INT 2
68020: NEG
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 0
68028: PUSH
68029: LD_INT 2
68031: NEG
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 2
68050: PUSH
68051: LD_INT 0
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 2
68060: PUSH
68061: LD_INT 1
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 2
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 1
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 2
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 1
68100: NEG
68101: PUSH
68102: LD_INT 1
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 2
68111: NEG
68112: PUSH
68113: LD_INT 0
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 2
68122: NEG
68123: PUSH
68124: LD_INT 1
68126: NEG
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 2
68134: NEG
68135: PUSH
68136: LD_INT 2
68138: NEG
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68165: LD_ADDR_VAR 0 20
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 0
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: LD_INT 1
68238: NEG
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 2
68250: NEG
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: LD_INT 2
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 2
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 2
68290: PUSH
68291: LD_INT 1
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 2
68300: PUSH
68301: LD_INT 2
68303: PUSH
68304: EMPTY
68305: LIST
68306: LIST
68307: PUSH
68308: LD_INT 1
68310: PUSH
68311: LD_INT 2
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 2
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: LD_INT 1
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 2
68341: NEG
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 2
68352: NEG
68353: PUSH
68354: LD_INT 1
68356: NEG
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 2
68364: NEG
68365: PUSH
68366: LD_INT 2
68368: NEG
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68395: LD_ADDR_VAR 0 21
68399: PUSH
68400: LD_INT 0
68402: PUSH
68403: LD_INT 0
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 1
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 1
68433: PUSH
68434: LD_INT 1
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 1
68464: NEG
68465: PUSH
68466: LD_INT 1
68468: NEG
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 2
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: LD_INT 2
68491: NEG
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 2
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 2
68520: PUSH
68521: LD_INT 1
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: LD_INT 2
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 2
68571: NEG
68572: PUSH
68573: LD_INT 0
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 2
68582: NEG
68583: PUSH
68584: LD_INT 1
68586: NEG
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 2
68594: NEG
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68625: LD_ADDR_VAR 0 22
68629: PUSH
68630: LD_INT 0
68632: PUSH
68633: LD_INT 0
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 0
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 1
68653: PUSH
68654: LD_INT 0
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 0
68673: PUSH
68674: LD_INT 1
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: LD_INT 0
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: LD_INT 2
68710: NEG
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 0
68718: PUSH
68719: LD_INT 2
68721: NEG
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: LD_INT 1
68732: NEG
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 2
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 2
68750: PUSH
68751: LD_INT 1
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 2
68760: PUSH
68761: LD_INT 2
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: LD_INT 2
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 0
68780: PUSH
68781: LD_INT 2
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: LD_INT 1
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 2
68801: NEG
68802: PUSH
68803: LD_INT 0
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 2
68812: NEG
68813: PUSH
68814: LD_INT 1
68816: NEG
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 2
68824: NEG
68825: PUSH
68826: LD_INT 2
68828: NEG
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68855: LD_ADDR_VAR 0 23
68859: PUSH
68860: LD_INT 0
68862: PUSH
68863: LD_INT 0
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 0
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 1
68893: PUSH
68894: LD_INT 1
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: NEG
68937: PUSH
68938: LD_INT 2
68940: NEG
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: LD_INT 0
68948: PUSH
68949: LD_INT 2
68951: NEG
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: LD_INT 1
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 2
68980: PUSH
68981: LD_INT 1
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 2
68990: PUSH
68991: LD_INT 2
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 2
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 2
69031: NEG
69032: PUSH
69033: LD_INT 0
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 2
69042: NEG
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: LD_INT 2
69058: NEG
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 2
69066: NEG
69067: PUSH
69068: LD_INT 3
69070: NEG
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: LD_INT 3
69082: NEG
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 1
69090: PUSH
69091: LD_INT 2
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 2
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69135: LD_ADDR_VAR 0 24
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 1
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 0
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: NEG
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 1
69208: NEG
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 2
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 2
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: LD_INT 1
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 2
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 1
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: NEG
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 2
69311: NEG
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 2
69322: NEG
69323: PUSH
69324: LD_INT 1
69326: NEG
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: LD_INT 2
69349: NEG
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 2
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 3
69368: PUSH
69369: LD_INT 1
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 3
69378: PUSH
69379: LD_INT 2
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69411: LD_ADDR_VAR 0 25
69415: PUSH
69416: LD_INT 0
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: LD_INT 0
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 1
69469: NEG
69470: PUSH
69471: LD_INT 0
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: LD_INT 1
69484: NEG
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 2
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 2
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 2
69536: PUSH
69537: LD_INT 1
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 2
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 2
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: LD_INT 2
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: NEG
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 2
69587: NEG
69588: PUSH
69589: LD_INT 0
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: NEG
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 2
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 3
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 3
69632: PUSH
69633: LD_INT 2
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 2
69642: PUSH
69643: LD_INT 3
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: LD_INT 3
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: LIST
69666: LIST
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69685: LD_ADDR_VAR 0 26
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 0
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 0
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: PUSH
69714: LD_INT 0
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 1
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: NEG
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 1
69754: NEG
69755: PUSH
69756: LD_INT 1
69758: NEG
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 2
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 2
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: LD_INT 1
69792: NEG
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 2
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 2
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: PUSH
69831: LD_INT 2
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: LD_INT 2
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: LD_INT 1
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: NEG
69862: PUSH
69863: LD_INT 0
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: LD_INT 2
69872: NEG
69873: PUSH
69874: LD_INT 1
69876: NEG
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: LD_INT 2
69888: NEG
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: LD_INT 3
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: LD_INT 3
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: LD_INT 2
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 2
69927: NEG
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69961: LD_ADDR_VAR 0 27
69965: PUSH
69966: LD_INT 0
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 0
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: PUSH
69990: LD_INT 0
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 1
69999: PUSH
70000: LD_INT 1
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 0
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: NEG
70020: PUSH
70021: LD_INT 0
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: NEG
70031: PUSH
70032: LD_INT 1
70034: NEG
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 2
70046: NEG
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 0
70054: PUSH
70055: LD_INT 2
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: PUSH
70066: LD_INT 1
70068: NEG
70069: PUSH
70070: EMPTY
70071: LIST
70072: LIST
70073: PUSH
70074: LD_INT 2
70076: PUSH
70077: LD_INT 0
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PUSH
70084: LD_INT 2
70086: PUSH
70087: LD_INT 1
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 2
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 0
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 2
70137: NEG
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 2
70148: NEG
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: LD_INT 2
70164: NEG
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: NEG
70173: PUSH
70174: LD_INT 2
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 1
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: PUSH
70192: LD_INT 3
70194: NEG
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 3
70206: NEG
70207: PUSH
70208: LD_INT 2
70210: NEG
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70241: LD_ADDR_VAR 0 28
70245: PUSH
70246: LD_INT 0
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 1
70279: PUSH
70280: LD_INT 1
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 1
70299: NEG
70300: PUSH
70301: LD_INT 0
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: LD_INT 1
70314: NEG
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 2
70326: NEG
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: LD_INT 2
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 2
70356: PUSH
70357: LD_INT 0
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 2
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 2
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 1
70406: NEG
70407: PUSH
70408: LD_INT 1
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: NEG
70418: PUSH
70419: LD_INT 0
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 2
70428: NEG
70429: PUSH
70430: LD_INT 1
70432: NEG
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 2
70440: NEG
70441: PUSH
70442: LD_INT 2
70444: NEG
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 2
70452: NEG
70453: PUSH
70454: LD_INT 3
70456: NEG
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: LD_INT 3
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 3
70476: NEG
70477: PUSH
70478: LD_INT 1
70480: NEG
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 3
70488: NEG
70489: PUSH
70490: LD_INT 2
70492: NEG
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70523: LD_ADDR_VAR 0 29
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: LD_INT 0
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: LD_INT 0
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: LD_INT 1
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: NEG
70582: PUSH
70583: LD_INT 0
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: NEG
70593: PUSH
70594: LD_INT 1
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 1
70604: NEG
70605: PUSH
70606: LD_INT 2
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 0
70616: PUSH
70617: LD_INT 2
70619: NEG
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: LD_INT 1
70630: NEG
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 2
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 2
70648: PUSH
70649: LD_INT 1
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 1
70658: PUSH
70659: LD_INT 2
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 0
70668: PUSH
70669: LD_INT 2
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 1
70678: NEG
70679: PUSH
70680: LD_INT 1
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 2
70689: NEG
70690: PUSH
70691: LD_INT 1
70693: NEG
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 2
70701: NEG
70702: PUSH
70703: LD_INT 2
70705: NEG
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 2
70713: NEG
70714: PUSH
70715: LD_INT 3
70717: NEG
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 2
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 3
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: LD_INT 3
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: LD_INT 2
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 3
70767: NEG
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70802: LD_ADDR_VAR 0 30
70806: PUSH
70807: LD_INT 0
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 0
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: LD_INT 0
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: LD_INT 1
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 0
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: LD_INT 0
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 1
70883: NEG
70884: PUSH
70885: LD_INT 2
70887: NEG
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: LD_INT 2
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 1
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 2
70917: PUSH
70918: LD_INT 0
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 1
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 2
70937: PUSH
70938: LD_INT 2
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: LD_INT 2
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: NEG
70958: PUSH
70959: LD_INT 1
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 2
70968: NEG
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 2
70979: NEG
70980: PUSH
70981: LD_INT 1
70983: NEG
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 1
70991: NEG
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 1
71003: PUSH
71004: LD_INT 2
71006: NEG
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 3
71014: PUSH
71015: LD_INT 2
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 2
71024: PUSH
71025: LD_INT 3
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 2
71034: NEG
71035: PUSH
71036: LD_INT 1
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 3
71045: NEG
71046: PUSH
71047: LD_INT 1
71049: NEG
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71080: LD_ADDR_VAR 0 31
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 0
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 1
71108: PUSH
71109: LD_INT 0
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 1
71118: PUSH
71119: LD_INT 1
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 0
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: LD_INT 0
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: LD_INT 1
71153: NEG
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: PUSH
71163: LD_INT 2
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: PUSH
71174: LD_INT 1
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: LD_INT 0
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 2
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 2
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 1
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 0
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 1
71234: NEG
71235: PUSH
71236: LD_INT 1
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 2
71245: NEG
71246: PUSH
71247: LD_INT 1
71249: NEG
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 2
71257: NEG
71258: PUSH
71259: LD_INT 2
71261: NEG
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: NEG
71270: PUSH
71271: LD_INT 3
71273: NEG
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 2
71281: PUSH
71282: LD_INT 1
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 3
71292: PUSH
71293: LD_INT 1
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 3
71323: NEG
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71358: LD_ADDR_VAR 0 32
71362: PUSH
71363: LD_INT 0
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 1
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 1
71427: NEG
71428: PUSH
71429: LD_INT 1
71431: NEG
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: NEG
71440: PUSH
71441: LD_INT 2
71443: NEG
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: LD_INT 2
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 1
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 2
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 2
71483: PUSH
71484: LD_INT 2
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: LD_INT 2
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: LD_INT 0
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 2
71535: NEG
71536: PUSH
71537: LD_INT 1
71539: NEG
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: LD_INT 3
71551: NEG
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: LD_INT 2
71562: NEG
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 3
71570: PUSH
71571: LD_INT 2
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 2
71580: PUSH
71581: LD_INT 3
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 2
71590: NEG
71591: PUSH
71592: LD_INT 1
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 3
71601: NEG
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71636: LD_ADDR_VAR 0 33
71640: PUSH
71641: LD_INT 0
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: LD_INT 0
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: LD_INT 1
71709: NEG
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 1
71717: NEG
71718: PUSH
71719: LD_INT 2
71721: NEG
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 1
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 2
71740: PUSH
71741: LD_INT 0
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 2
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 1
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 0
71770: PUSH
71771: LD_INT 2
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: LD_INT 1
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 2
71791: NEG
71792: PUSH
71793: LD_INT 0
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 2
71802: NEG
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: NEG
71815: PUSH
71816: LD_INT 2
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: LD_INT 3
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 2
71838: PUSH
71839: LD_INT 1
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 3
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: PUSH
71860: LD_INT 3
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 1
71869: NEG
71870: PUSH
71871: LD_INT 2
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 3
71880: NEG
71881: PUSH
71882: LD_INT 2
71884: NEG
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71915: LD_ADDR_VAR 0 34
71919: PUSH
71920: LD_INT 0
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 0
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: PUSH
71944: LD_INT 0
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: LD_INT 1
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 0
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 1
71988: NEG
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: NEG
71997: PUSH
71998: LD_INT 2
72000: NEG
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 0
72008: PUSH
72009: LD_INT 2
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 1
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 2
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 1
72050: PUSH
72051: LD_INT 2
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: LD_INT 1
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 2
72071: NEG
72072: PUSH
72073: LD_INT 0
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 2
72082: NEG
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 2
72094: NEG
72095: PUSH
72096: LD_INT 2
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: NEG
72107: PUSH
72108: LD_INT 3
72110: NEG
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: PUSH
72119: LD_INT 2
72121: NEG
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 3
72129: PUSH
72130: LD_INT 2
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 2
72139: PUSH
72140: LD_INT 3
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 2
72149: NEG
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 3
72160: NEG
72161: PUSH
72162: LD_INT 1
72164: NEG
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72195: LD_ADDR_VAR 0 35
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 0
72212: PUSH
72213: LD_INT 1
72215: NEG
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 1
72223: PUSH
72224: LD_INT 0
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: LD_INT 1
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 0
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: NEG
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 1
72264: NEG
72265: PUSH
72266: LD_INT 1
72268: NEG
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 2
72276: PUSH
72277: LD_INT 1
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 2
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72307: LD_ADDR_VAR 0 36
72311: PUSH
72312: LD_INT 0
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 0
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 1
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 1
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 0
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 1
72365: NEG
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 1
72376: NEG
72377: PUSH
72378: LD_INT 1
72380: NEG
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: LD_INT 2
72392: NEG
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: LD_INT 2
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72419: LD_ADDR_VAR 0 37
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 0
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: LD_INT 1
72439: NEG
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 1
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 1
72477: NEG
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 1
72488: NEG
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: LD_INT 1
72503: NEG
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: LD_INT 1
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72531: LD_ADDR_VAR 0 38
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 2
72612: PUSH
72613: LD_INT 1
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 2
72622: NEG
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72643: LD_ADDR_VAR 0 39
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: LD_INT 0
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 0
72660: PUSH
72661: LD_INT 1
72663: NEG
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: LD_INT 0
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: LD_INT 1
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: LD_INT 1
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 1
72701: NEG
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 1
72712: NEG
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: NEG
72725: PUSH
72726: LD_INT 2
72728: NEG
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 1
72736: PUSH
72737: LD_INT 2
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72755: LD_ADDR_VAR 0 40
72759: PUSH
72760: LD_INT 0
72762: PUSH
72763: LD_INT 0
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 1
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 0
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: NEG
72814: PUSH
72815: LD_INT 0
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 1
72824: NEG
72825: PUSH
72826: LD_INT 1
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: LD_INT 1
72839: NEG
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72867: LD_ADDR_VAR 0 41
72871: PUSH
72872: LD_INT 0
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 1
72895: PUSH
72896: LD_INT 0
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: PUSH
72906: LD_INT 1
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 0
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 1
72936: NEG
72937: PUSH
72938: LD_INT 1
72940: NEG
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 2
72952: NEG
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 2
72981: PUSH
72982: LD_INT 1
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 2
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: PUSH
73002: LD_INT 2
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: NEG
73012: PUSH
73013: LD_INT 1
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 2
73022: NEG
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 2
73033: NEG
73034: PUSH
73035: LD_INT 1
73037: NEG
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 2
73045: NEG
73046: PUSH
73047: LD_INT 2
73049: NEG
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 2
73057: NEG
73058: PUSH
73059: LD_INT 3
73061: NEG
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 2
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 3
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 3
73090: PUSH
73091: LD_INT 1
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 3
73100: PUSH
73101: LD_INT 2
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 3
73110: PUSH
73111: LD_INT 3
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 2
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 2
73130: NEG
73131: PUSH
73132: LD_INT 1
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 3
73141: NEG
73142: PUSH
73143: LD_INT 0
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 3
73152: NEG
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 3
73164: NEG
73165: PUSH
73166: LD_INT 2
73168: NEG
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 3
73176: NEG
73177: PUSH
73178: LD_INT 3
73180: NEG
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73217: LD_ADDR_VAR 0 42
73221: PUSH
73222: LD_INT 0
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 0
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 1
73275: NEG
73276: PUSH
73277: LD_INT 0
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 1
73286: NEG
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 1
73298: NEG
73299: PUSH
73300: LD_INT 2
73302: NEG
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 2
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 2
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: PUSH
73343: LD_INT 2
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: LD_INT 2
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 0
73362: PUSH
73363: LD_INT 2
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 1
73372: NEG
73373: PUSH
73374: LD_INT 1
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 2
73383: NEG
73384: PUSH
73385: LD_INT 1
73387: NEG
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 2
73395: NEG
73396: PUSH
73397: LD_INT 2
73399: NEG
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: LD_INT 3
73411: NEG
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: LD_INT 3
73423: NEG
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 0
73431: PUSH
73432: LD_INT 3
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: PUSH
73443: LD_INT 2
73445: NEG
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: LD_INT 2
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: LD_INT 3
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 2
73473: PUSH
73474: LD_INT 3
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 3
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 0
73493: PUSH
73494: LD_INT 3
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 1
73503: NEG
73504: PUSH
73505: LD_INT 2
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 3
73514: NEG
73515: PUSH
73516: LD_INT 2
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 3
73526: NEG
73527: PUSH
73528: LD_INT 3
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73567: LD_ADDR_VAR 0 43
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 1
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 0
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: EMPTY
73620: LIST
73621: LIST
73622: PUSH
73623: LD_INT 1
73625: NEG
73626: PUSH
73627: LD_INT 0
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 1
73636: NEG
73637: PUSH
73638: LD_INT 1
73640: NEG
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: LD_INT 2
73652: NEG
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: LD_INT 2
73663: NEG
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 2
73682: PUSH
73683: LD_INT 0
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 2
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 1
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: LD_INT 1
73748: NEG
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 1
73756: NEG
73757: PUSH
73758: LD_INT 3
73760: NEG
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 0
73768: PUSH
73769: LD_INT 3
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 1
73779: PUSH
73780: LD_INT 2
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 2
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 3
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 3
73811: PUSH
73812: LD_INT 1
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: LD_INT 3
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: LD_INT 2
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 2
73852: NEG
73853: PUSH
73854: LD_INT 1
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 3
73863: NEG
73864: PUSH
73865: LD_INT 0
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 3
73874: NEG
73875: PUSH
73876: LD_INT 1
73878: NEG
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73915: LD_ADDR_VAR 0 44
73919: PUSH
73920: LD_INT 0
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 0
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 1
73943: PUSH
73944: LD_INT 0
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 1
73953: PUSH
73954: LD_INT 1
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: LD_INT 1
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: NEG
73974: PUSH
73975: LD_INT 0
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 1
73984: NEG
73985: PUSH
73986: LD_INT 1
73988: NEG
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: LD_INT 2
74000: NEG
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 1
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: PUSH
74020: LD_INT 0
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 2
74029: PUSH
74030: LD_INT 1
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 2
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: LD_INT 2
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: LD_INT 1
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 2
74070: NEG
74071: PUSH
74072: LD_INT 0
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 2
74081: NEG
74082: PUSH
74083: LD_INT 1
74085: NEG
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 2
74093: NEG
74094: PUSH
74095: LD_INT 2
74097: NEG
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 2
74105: NEG
74106: PUSH
74107: LD_INT 3
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 2
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 3
74128: PUSH
74129: LD_INT 0
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 3
74138: PUSH
74139: LD_INT 1
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 3
74148: PUSH
74149: LD_INT 2
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 3
74158: PUSH
74159: LD_INT 3
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 2
74168: PUSH
74169: LD_INT 3
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 2
74178: NEG
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 3
74189: NEG
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 3
74200: NEG
74201: PUSH
74202: LD_INT 1
74204: NEG
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 3
74212: NEG
74213: PUSH
74214: LD_INT 2
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 3
74224: NEG
74225: PUSH
74226: LD_INT 3
74228: NEG
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74265: LD_ADDR_VAR 0 45
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 1
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 0
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: NEG
74324: PUSH
74325: LD_INT 0
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: LD_INT 2
74350: NEG
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 0
74358: PUSH
74359: LD_INT 2
74361: NEG
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: PUSH
74370: LD_INT 1
74372: NEG
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 2
74380: PUSH
74381: LD_INT 1
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 2
74390: PUSH
74391: LD_INT 2
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 1
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: NEG
74421: PUSH
74422: LD_INT 1
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 2
74431: NEG
74432: PUSH
74433: LD_INT 1
74435: NEG
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 2
74443: NEG
74444: PUSH
74445: LD_INT 2
74447: NEG
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 2
74455: NEG
74456: PUSH
74457: LD_INT 3
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: NEG
74468: PUSH
74469: LD_INT 3
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 0
74479: PUSH
74480: LD_INT 3
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: LD_INT 2
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 3
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 3
74511: PUSH
74512: LD_INT 3
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: LD_INT 3
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 1
74531: PUSH
74532: LD_INT 3
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 0
74541: PUSH
74542: LD_INT 3
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 1
74551: NEG
74552: PUSH
74553: LD_INT 2
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 3
74562: NEG
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: NEG
74575: PUSH
74576: LD_INT 3
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74615: LD_ADDR_VAR 0 46
74619: PUSH
74620: LD_INT 0
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 0
74632: PUSH
74633: LD_INT 1
74635: NEG
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 1
74643: PUSH
74644: LD_INT 0
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 1
74653: PUSH
74654: LD_INT 1
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 0
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 1
74673: NEG
74674: PUSH
74675: LD_INT 0
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: LD_INT 1
74688: NEG
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 2
74700: NEG
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 0
74708: PUSH
74709: LD_INT 2
74711: NEG
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: LD_INT 1
74722: NEG
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 2
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 1
74750: PUSH
74751: LD_INT 2
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: LD_INT 2
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 1
74770: NEG
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 2
74781: NEG
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 2
74792: NEG
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 1
74804: NEG
74805: PUSH
74806: LD_INT 3
74808: NEG
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: LD_INT 3
74819: NEG
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 1
74827: PUSH
74828: LD_INT 2
74830: NEG
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: LD_INT 2
74838: PUSH
74839: LD_INT 1
74841: NEG
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 3
74849: PUSH
74850: LD_INT 0
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 3
74859: PUSH
74860: LD_INT 1
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: PUSH
74870: LD_INT 3
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 3
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: LD_INT 2
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 2
74900: NEG
74901: PUSH
74902: LD_INT 1
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 3
74911: NEG
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 3
74922: NEG
74923: PUSH
74924: LD_INT 1
74926: NEG
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74963: LD_ADDR_VAR 0 47
74967: PUSH
74968: LD_INT 0
74970: PUSH
74971: LD_INT 0
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: LD_INT 1
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 1
74991: PUSH
74992: LD_INT 0
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 1
75001: PUSH
75002: LD_INT 1
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 0
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PUSH
75019: LD_INT 1
75021: NEG
75022: PUSH
75023: LD_INT 0
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 1
75032: NEG
75033: PUSH
75034: LD_INT 1
75036: NEG
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: LD_INT 2
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 2
75078: NEG
75079: PUSH
75080: LD_INT 1
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 2
75090: NEG
75091: PUSH
75092: LD_INT 2
75094: NEG
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75114: LD_ADDR_VAR 0 48
75118: PUSH
75119: LD_INT 0
75121: PUSH
75122: LD_INT 0
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: LD_INT 1
75134: NEG
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 1
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: PUSH
75153: LD_INT 1
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 1
75183: NEG
75184: PUSH
75185: LD_INT 1
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: NEG
75196: PUSH
75197: LD_INT 2
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: LD_INT 1
75221: NEG
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 2
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 2
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: LIST
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75261: LD_ADDR_VAR 0 49
75265: PUSH
75266: LD_INT 0
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 0
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: LD_INT 1
75289: PUSH
75290: LD_INT 0
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 1
75299: PUSH
75300: LD_INT 1
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 0
75309: PUSH
75310: LD_INT 1
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 1
75319: NEG
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 1
75330: NEG
75331: PUSH
75332: LD_INT 1
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 2
75353: PUSH
75354: LD_INT 0
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 2
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: LD_INT 2
75373: PUSH
75374: LD_INT 2
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: LD_INT 2
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75405: LD_ADDR_VAR 0 50
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 1
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 1
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 0
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 1
75463: NEG
75464: PUSH
75465: LD_INT 0
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 1
75474: NEG
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 1
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 2
75496: PUSH
75497: LD_INT 2
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75549: LD_ADDR_VAR 0 51
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 0
75566: PUSH
75567: LD_INT 1
75569: NEG
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: PUSH
75578: LD_INT 0
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 1
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 1
75607: NEG
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: NEG
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 1
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 0
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: NEG
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 2
75661: NEG
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: NEG
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: LIST
75686: LIST
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75696: LD_ADDR_VAR 0 52
75700: PUSH
75701: LD_INT 0
75703: PUSH
75704: LD_INT 0
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 0
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 1
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 1
75765: NEG
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: LD_INT 2
75781: NEG
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: LD_INT 1
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 2
75800: NEG
75801: PUSH
75802: LD_INT 0
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 2
75811: NEG
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 2
75823: NEG
75824: PUSH
75825: LD_INT 2
75827: NEG
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75847: LD_ADDR_VAR 0 53
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: LD_INT 0
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 1
75885: PUSH
75886: LD_INT 1
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: NEG
75906: PUSH
75907: LD_INT 0
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 1
75916: NEG
75917: PUSH
75918: LD_INT 1
75920: NEG
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 2
75932: NEG
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: LD_INT 2
75943: NEG
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 1
75951: PUSH
75952: LD_INT 1
75954: NEG
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 2
75962: PUSH
75963: LD_INT 0
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 2
75972: PUSH
75973: LD_INT 1
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 2
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 1
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: LD_INT 2
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 2
76023: NEG
76024: PUSH
76025: LD_INT 0
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 2
76034: NEG
76035: PUSH
76036: LD_INT 1
76038: NEG
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 2
76046: NEG
76047: PUSH
76048: LD_INT 2
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76077: LD_ADDR_VAR 0 54
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: LD_INT 0
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 0
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: LD_INT 0
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: NEG
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: NEG
76159: PUSH
76160: LD_INT 2
76162: NEG
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 0
76170: PUSH
76171: LD_INT 2
76173: NEG
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 1
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 2
76202: PUSH
76203: LD_INT 1
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 2
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 1
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 0
76232: PUSH
76233: LD_INT 2
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 1
76242: NEG
76243: PUSH
76244: LD_INT 1
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 2
76253: NEG
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 2
76264: NEG
76265: PUSH
76266: LD_INT 1
76268: NEG
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: LD_INT 2
76280: NEG
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76307: LD_ADDR_VAR 0 55
76311: PUSH
76312: LD_INT 0
76314: PUSH
76315: LD_INT 0
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 1
76335: PUSH
76336: LD_INT 0
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 0
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 1
76365: NEG
76366: PUSH
76367: LD_INT 0
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: LD_INT 1
76376: NEG
76377: PUSH
76378: LD_INT 1
76380: NEG
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 1
76388: NEG
76389: PUSH
76390: LD_INT 2
76392: NEG
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: PUSH
76398: LD_INT 0
76400: PUSH
76401: LD_INT 2
76403: NEG
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 1
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 2
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 1
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 2
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: NEG
76473: PUSH
76474: LD_INT 1
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 2
76483: NEG
76484: PUSH
76485: LD_INT 0
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 2
76494: NEG
76495: PUSH
76496: LD_INT 1
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 2
76506: NEG
76507: PUSH
76508: LD_INT 2
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76537: LD_ADDR_VAR 0 56
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 0
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: LD_INT 1
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 0
76585: PUSH
76586: LD_INT 1
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: NEG
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 1
76606: NEG
76607: PUSH
76608: LD_INT 1
76610: NEG
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: NEG
76619: PUSH
76620: LD_INT 2
76622: NEG
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: LD_INT 2
76633: NEG
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: LD_INT 1
76644: NEG
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 2
76652: PUSH
76653: LD_INT 0
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 2
76662: PUSH
76663: LD_INT 1
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 2
76672: PUSH
76673: LD_INT 2
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: LD_INT 2
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: LD_INT 2
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: LD_INT 1
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: LD_INT 0
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 2
76724: NEG
76725: PUSH
76726: LD_INT 1
76728: NEG
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 2
76736: NEG
76737: PUSH
76738: LD_INT 2
76740: NEG
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76767: LD_ADDR_VAR 0 57
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 1
76795: PUSH
76796: LD_INT 0
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 1
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 0
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 1
76836: NEG
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 2
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: LD_INT 2
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: LD_INT 1
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 2
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 2
76902: PUSH
76903: LD_INT 2
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: LD_INT 1
76912: PUSH
76913: LD_INT 2
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 0
76922: PUSH
76923: LD_INT 2
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 1
76932: NEG
76933: PUSH
76934: LD_INT 1
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 2
76943: NEG
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 2
76954: NEG
76955: PUSH
76956: LD_INT 1
76958: NEG
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: LD_INT 2
76970: NEG
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76997: LD_ADDR_VAR 0 58
77001: PUSH
77002: LD_INT 0
77004: PUSH
77005: LD_INT 0
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 0
77014: PUSH
77015: LD_INT 1
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: LD_INT 0
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 1
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 0
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: LD_INT 0
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 1
77066: NEG
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 1
77078: NEG
77079: PUSH
77080: LD_INT 2
77082: NEG
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: LD_INT 2
77093: NEG
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 2
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 2
77122: PUSH
77123: LD_INT 1
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 2
77132: PUSH
77133: LD_INT 2
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: LD_INT 2
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 0
77152: PUSH
77153: LD_INT 2
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: LD_INT 1
77162: NEG
77163: PUSH
77164: LD_INT 1
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 2
77173: NEG
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 2
77184: NEG
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 2
77196: NEG
77197: PUSH
77198: LD_INT 2
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77227: LD_ADDR_VAR 0 59
77231: PUSH
77232: LD_INT 0
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 0
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 1
77255: PUSH
77256: LD_INT 0
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 1
77285: NEG
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 1
77296: NEG
77297: PUSH
77298: LD_INT 1
77300: NEG
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77315: LD_ADDR_VAR 0 60
77319: PUSH
77320: LD_INT 0
77322: PUSH
77323: LD_INT 0
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: LD_INT 1
77335: NEG
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 1
77343: PUSH
77344: LD_INT 0
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 1
77353: PUSH
77354: LD_INT 1
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 0
77363: PUSH
77364: LD_INT 1
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 1
77373: NEG
77374: PUSH
77375: LD_INT 0
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: NEG
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77403: LD_ADDR_VAR 0 61
77407: PUSH
77408: LD_INT 0
77410: PUSH
77411: LD_INT 0
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 0
77420: PUSH
77421: LD_INT 1
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 1
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: LD_INT 1
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 0
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 1
77461: NEG
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 1
77476: NEG
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: LIST
77488: LIST
77489: LIST
77490: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77491: LD_ADDR_VAR 0 62
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: LD_INT 1
77511: NEG
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 1
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 1
77529: PUSH
77530: LD_INT 1
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 0
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 1
77549: NEG
77550: PUSH
77551: LD_INT 0
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 1
77560: NEG
77561: PUSH
77562: LD_INT 1
77564: NEG
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77579: LD_ADDR_VAR 0 63
77583: PUSH
77584: LD_INT 0
77586: PUSH
77587: LD_INT 0
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 0
77596: PUSH
77597: LD_INT 1
77599: NEG
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 1
77617: PUSH
77618: LD_INT 1
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 0
77627: PUSH
77628: LD_INT 1
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 1
77637: NEG
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 1
77648: NEG
77649: PUSH
77650: LD_INT 1
77652: NEG
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77667: LD_ADDR_VAR 0 64
77671: PUSH
77672: LD_INT 0
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 0
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: PUSH
77696: LD_INT 0
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 1
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 0
77715: PUSH
77716: LD_INT 1
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: LD_INT 0
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 1
77736: NEG
77737: PUSH
77738: LD_INT 1
77740: NEG
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: ST_TO_ADDR
// end ; 1 :
77755: GO 83652
77757: LD_INT 1
77759: DOUBLE
77760: EQUAL
77761: IFTRUE 77765
77763: GO 80388
77765: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77766: LD_ADDR_VAR 0 11
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: LD_INT 3
77777: NEG
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 0
77785: PUSH
77786: LD_INT 3
77788: NEG
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 1
77796: PUSH
77797: LD_INT 2
77799: NEG
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: LIST
77809: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77810: LD_ADDR_VAR 0 12
77814: PUSH
77815: LD_INT 2
77817: PUSH
77818: LD_INT 1
77820: NEG
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 3
77828: PUSH
77829: LD_INT 0
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 3
77838: PUSH
77839: LD_INT 1
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: LIST
77850: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77851: LD_ADDR_VAR 0 13
77855: PUSH
77856: LD_INT 3
77858: PUSH
77859: LD_INT 2
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: LD_INT 3
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: LD_INT 3
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: LIST
77890: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77891: LD_ADDR_VAR 0 14
77895: PUSH
77896: LD_INT 1
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: LD_INT 2
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77932: LD_ADDR_VAR 0 15
77936: PUSH
77937: LD_INT 2
77939: NEG
77940: PUSH
77941: LD_INT 1
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 3
77950: NEG
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: LD_INT 1
77965: NEG
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: LIST
77975: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77976: LD_ADDR_VAR 0 16
77980: PUSH
77981: LD_INT 2
77983: NEG
77984: PUSH
77985: LD_INT 3
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 3
77995: NEG
77996: PUSH
77997: LD_INT 2
77999: NEG
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 3
78007: NEG
78008: PUSH
78009: LD_INT 3
78011: NEG
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: LIST
78021: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78022: LD_ADDR_VAR 0 17
78026: PUSH
78027: LD_INT 1
78029: NEG
78030: PUSH
78031: LD_INT 3
78033: NEG
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 3
78044: NEG
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: LD_INT 2
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: LIST
78065: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78066: LD_ADDR_VAR 0 18
78070: PUSH
78071: LD_INT 2
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 3
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: LD_INT 1
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: LIST
78106: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78107: LD_ADDR_VAR 0 19
78111: PUSH
78112: LD_INT 3
78114: PUSH
78115: LD_INT 2
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: LD_INT 3
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: LIST
78146: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78147: LD_ADDR_VAR 0 20
78151: PUSH
78152: LD_INT 1
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 3
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 1
78174: NEG
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: LIST
78187: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78188: LD_ADDR_VAR 0 21
78192: PUSH
78193: LD_INT 2
78195: NEG
78196: PUSH
78197: LD_INT 1
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: LD_INT 0
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: LD_INT 1
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: LIST
78231: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78232: LD_ADDR_VAR 0 22
78236: PUSH
78237: LD_INT 2
78239: NEG
78240: PUSH
78241: LD_INT 3
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 3
78251: NEG
78252: PUSH
78253: LD_INT 2
78255: NEG
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 3
78263: NEG
78264: PUSH
78265: LD_INT 3
78267: NEG
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: LIST
78277: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78278: LD_ADDR_VAR 0 23
78282: PUSH
78283: LD_INT 0
78285: PUSH
78286: LD_INT 3
78288: NEG
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: LD_INT 4
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 1
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: LIST
78321: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78322: LD_ADDR_VAR 0 24
78326: PUSH
78327: LD_INT 3
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 3
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 4
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: LIST
78362: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78363: LD_ADDR_VAR 0 25
78367: PUSH
78368: LD_INT 3
78370: PUSH
78371: LD_INT 3
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 4
78380: PUSH
78381: LD_INT 3
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 3
78390: PUSH
78391: LD_INT 4
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: LIST
78402: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78403: LD_ADDR_VAR 0 26
78407: PUSH
78408: LD_INT 0
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 1
78420: PUSH
78421: LD_INT 4
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: LD_INT 1
78430: NEG
78431: PUSH
78432: LD_INT 3
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: LIST
78443: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78444: LD_ADDR_VAR 0 27
78448: PUSH
78449: LD_INT 3
78451: NEG
78452: PUSH
78453: LD_INT 0
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: LIST
78487: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78488: LD_ADDR_VAR 0 28
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: LD_INT 3
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: LD_INT 4
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: LD_INT 3
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: LIST
78533: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78534: LD_ADDR_VAR 0 29
78538: PUSH
78539: LD_INT 1
78541: NEG
78542: PUSH
78543: LD_INT 3
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: LD_INT 3
78556: NEG
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 1
78564: PUSH
78565: LD_INT 2
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: LD_INT 4
78579: NEG
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 0
78587: PUSH
78588: LD_INT 4
78590: NEG
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: LD_INT 3
78601: NEG
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 1
78609: NEG
78610: PUSH
78611: LD_INT 5
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 0
78621: PUSH
78622: LD_INT 5
78624: NEG
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 1
78632: PUSH
78633: LD_INT 4
78635: NEG
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: LD_INT 6
78647: NEG
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 0
78655: PUSH
78656: LD_INT 6
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 1
78666: PUSH
78667: LD_INT 5
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78689: LD_ADDR_VAR 0 30
78693: PUSH
78694: LD_INT 2
78696: PUSH
78697: LD_INT 1
78699: NEG
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 3
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 3
78717: PUSH
78718: LD_INT 1
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 3
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 4
78738: PUSH
78739: LD_INT 0
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 4
78748: PUSH
78749: LD_INT 1
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 4
78758: PUSH
78759: LD_INT 1
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 5
78769: PUSH
78770: LD_INT 0
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 5
78779: PUSH
78780: LD_INT 1
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 5
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 6
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 6
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78832: LD_ADDR_VAR 0 31
78836: PUSH
78837: LD_INT 3
78839: PUSH
78840: LD_INT 2
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 3
78849: PUSH
78850: LD_INT 3
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 2
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 4
78869: PUSH
78870: LD_INT 3
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 4
78879: PUSH
78880: LD_INT 4
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: LD_INT 4
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 5
78899: PUSH
78900: LD_INT 4
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 5
78909: PUSH
78910: LD_INT 5
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: PUSH
78920: LD_INT 5
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 6
78929: PUSH
78930: LD_INT 5
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 6
78939: PUSH
78940: LD_INT 6
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 5
78949: PUSH
78950: LD_INT 6
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78971: LD_ADDR_VAR 0 32
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: LD_INT 3
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: LD_INT 3
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 1
78998: NEG
78999: PUSH
79000: LD_INT 2
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: PUSH
79010: LD_INT 4
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: LD_INT 4
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 1
79029: NEG
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 5
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: LD_INT 5
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: NEG
79061: PUSH
79062: LD_INT 4
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: PUSH
79072: LD_INT 6
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: LD_INT 6
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 1
79091: NEG
79092: PUSH
79093: LD_INT 5
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79114: LD_ADDR_VAR 0 33
79118: PUSH
79119: LD_INT 2
79121: NEG
79122: PUSH
79123: LD_INT 1
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 3
79132: NEG
79133: PUSH
79134: LD_INT 0
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 3
79143: NEG
79144: PUSH
79145: LD_INT 1
79147: NEG
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 4
79166: NEG
79167: PUSH
79168: LD_INT 0
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 4
79177: NEG
79178: PUSH
79179: LD_INT 1
79181: NEG
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 4
79189: NEG
79190: PUSH
79191: LD_INT 1
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 5
79200: NEG
79201: PUSH
79202: LD_INT 0
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 5
79211: NEG
79212: PUSH
79213: LD_INT 1
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 5
79223: NEG
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 6
79234: NEG
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 6
79245: NEG
79246: PUSH
79247: LD_INT 1
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79269: LD_ADDR_VAR 0 34
79273: PUSH
79274: LD_INT 2
79276: NEG
79277: PUSH
79278: LD_INT 3
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 3
79288: NEG
79289: PUSH
79290: LD_INT 2
79292: NEG
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 3
79300: NEG
79301: PUSH
79302: LD_INT 3
79304: NEG
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 3
79312: NEG
79313: PUSH
79314: LD_INT 4
79316: NEG
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 4
79324: NEG
79325: PUSH
79326: LD_INT 3
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 4
79336: NEG
79337: PUSH
79338: LD_INT 4
79340: NEG
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 4
79348: NEG
79349: PUSH
79350: LD_INT 5
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 5
79360: NEG
79361: PUSH
79362: LD_INT 4
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 5
79372: NEG
79373: PUSH
79374: LD_INT 5
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 5
79384: NEG
79385: PUSH
79386: LD_INT 6
79388: NEG
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 6
79396: NEG
79397: PUSH
79398: LD_INT 5
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 6
79408: NEG
79409: PUSH
79410: LD_INT 6
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79432: LD_ADDR_VAR 0 41
79436: PUSH
79437: LD_INT 0
79439: PUSH
79440: LD_INT 2
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 1
79450: NEG
79451: PUSH
79452: LD_INT 3
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: LD_INT 2
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: LIST
79475: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79476: LD_ADDR_VAR 0 42
79480: PUSH
79481: LD_INT 2
79483: PUSH
79484: LD_INT 0
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 2
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 3
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: LIST
79516: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79517: LD_ADDR_VAR 0 43
79521: PUSH
79522: LD_INT 2
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 3
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: LD_INT 3
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: LIST
79556: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79557: LD_ADDR_VAR 0 44
79561: PUSH
79562: LD_INT 0
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 1
79574: PUSH
79575: LD_INT 3
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: LIST
79597: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79598: LD_ADDR_VAR 0 45
79602: PUSH
79603: LD_INT 2
79605: NEG
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: LD_INT 1
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 3
79627: NEG
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: LIST
79641: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79642: LD_ADDR_VAR 0 46
79646: PUSH
79647: LD_INT 2
79649: NEG
79650: PUSH
79651: LD_INT 2
79653: NEG
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 2
79661: NEG
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 3
79673: NEG
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: LIST
79687: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79688: LD_ADDR_VAR 0 47
79692: PUSH
79693: LD_INT 2
79695: NEG
79696: PUSH
79697: LD_INT 3
79699: NEG
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 1
79707: NEG
79708: PUSH
79709: LD_INT 3
79711: NEG
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79721: LD_ADDR_VAR 0 48
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 2
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 2
79739: PUSH
79740: LD_INT 1
79742: NEG
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79752: LD_ADDR_VAR 0 49
79756: PUSH
79757: LD_INT 3
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 3
79769: PUSH
79770: LD_INT 2
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79781: LD_ADDR_VAR 0 50
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 3
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 3
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79810: LD_ADDR_VAR 0 51
79814: PUSH
79815: LD_INT 1
79817: NEG
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 2
79828: NEG
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79841: LD_ADDR_VAR 0 52
79845: PUSH
79846: LD_INT 3
79848: NEG
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 3
79860: NEG
79861: PUSH
79862: LD_INT 2
79864: NEG
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79874: LD_ADDR_VAR 0 53
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 3
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: LD_INT 3
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: LD_INT 2
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: LIST
79917: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79918: LD_ADDR_VAR 0 54
79922: PUSH
79923: LD_INT 2
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 3
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: LIST
79958: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79959: LD_ADDR_VAR 0 55
79963: PUSH
79964: LD_INT 3
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 3
79976: PUSH
79977: LD_INT 3
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 3
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: LIST
79998: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79999: LD_ADDR_VAR 0 56
80003: PUSH
80004: LD_INT 1
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: LIST
80039: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80040: LD_ADDR_VAR 0 57
80044: PUSH
80045: LD_INT 2
80047: NEG
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 3
80058: NEG
80059: PUSH
80060: LD_INT 0
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 3
80069: NEG
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80084: LD_ADDR_VAR 0 58
80088: PUSH
80089: LD_INT 2
80091: NEG
80092: PUSH
80093: LD_INT 3
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 3
80103: NEG
80104: PUSH
80105: LD_INT 2
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 3
80115: NEG
80116: PUSH
80117: LD_INT 3
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: LIST
80129: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80130: LD_ADDR_VAR 0 59
80134: PUSH
80135: LD_INT 1
80137: NEG
80138: PUSH
80139: LD_INT 2
80141: NEG
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: LD_INT 2
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: LIST
80173: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80174: LD_ADDR_VAR 0 60
80178: PUSH
80179: LD_INT 1
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 2
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 2
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: LIST
80214: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80215: LD_ADDR_VAR 0 61
80219: PUSH
80220: LD_INT 2
80222: PUSH
80223: LD_INT 1
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 2
80232: PUSH
80233: LD_INT 2
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: PUSH
80243: LD_INT 2
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: LIST
80254: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80255: LD_ADDR_VAR 0 62
80259: PUSH
80260: LD_INT 1
80262: PUSH
80263: LD_INT 2
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: LD_INT 2
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: LD_INT 1
80282: NEG
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80296: LD_ADDR_VAR 0 63
80300: PUSH
80301: LD_INT 1
80303: NEG
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 2
80314: NEG
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 2
80325: NEG
80326: PUSH
80327: LD_INT 1
80329: NEG
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: LIST
80339: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80340: LD_ADDR_VAR 0 64
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: LD_INT 2
80351: NEG
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: NEG
80360: PUSH
80361: LD_INT 1
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 2
80371: NEG
80372: PUSH
80373: LD_INT 2
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: LIST
80385: ST_TO_ADDR
// end ; 2 :
80386: GO 83652
80388: LD_INT 2
80390: DOUBLE
80391: EQUAL
80392: IFTRUE 80396
80394: GO 83651
80396: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80397: LD_ADDR_VAR 0 29
80401: PUSH
80402: LD_INT 4
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 4
80414: PUSH
80415: LD_INT 1
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 5
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 5
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 4
80445: PUSH
80446: LD_INT 1
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 3
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 3
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 5
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 3
80497: PUSH
80498: LD_INT 3
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 3
80507: PUSH
80508: LD_INT 2
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 4
80517: PUSH
80518: LD_INT 3
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 4
80527: PUSH
80528: LD_INT 4
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 3
80537: PUSH
80538: LD_INT 4
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 2
80547: PUSH
80548: LD_INT 3
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 2
80557: PUSH
80558: LD_INT 2
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 4
80567: PUSH
80568: LD_INT 2
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: LD_INT 4
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: LD_INT 4
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 0
80597: PUSH
80598: LD_INT 3
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: LD_INT 4
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 5
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 5
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 4
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 3
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: LD_INT 5
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: NEG
80670: PUSH
80671: LD_INT 3
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 3
80680: NEG
80681: PUSH
80682: LD_INT 0
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 3
80691: NEG
80692: PUSH
80693: LD_INT 1
80695: NEG
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 2
80703: NEG
80704: PUSH
80705: LD_INT 0
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 2
80714: NEG
80715: PUSH
80716: LD_INT 1
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 3
80725: NEG
80726: PUSH
80727: LD_INT 1
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 4
80736: NEG
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 4
80747: NEG
80748: PUSH
80749: LD_INT 1
80751: NEG
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 4
80759: NEG
80760: PUSH
80761: LD_INT 2
80763: NEG
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 2
80771: NEG
80772: PUSH
80773: LD_INT 2
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 4
80782: NEG
80783: PUSH
80784: LD_INT 4
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 4
80794: NEG
80795: PUSH
80796: LD_INT 5
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 3
80806: NEG
80807: PUSH
80808: LD_INT 4
80810: NEG
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 3
80818: NEG
80819: PUSH
80820: LD_INT 3
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 4
80830: NEG
80831: PUSH
80832: LD_INT 3
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 5
80842: NEG
80843: PUSH
80844: LD_INT 4
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 5
80854: NEG
80855: PUSH
80856: LD_INT 5
80858: NEG
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 3
80866: NEG
80867: PUSH
80868: LD_INT 5
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 5
80878: NEG
80879: PUSH
80880: LD_INT 3
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80935: LD_ADDR_VAR 0 30
80939: PUSH
80940: LD_INT 4
80942: PUSH
80943: LD_INT 4
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 4
80952: PUSH
80953: LD_INT 3
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 5
80962: PUSH
80963: LD_INT 4
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 5
80972: PUSH
80973: LD_INT 5
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 4
80982: PUSH
80983: LD_INT 5
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 3
80992: PUSH
80993: LD_INT 4
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 3
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 5
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 3
81022: PUSH
81023: LD_INT 5
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 3
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 0
81042: PUSH
81043: LD_INT 2
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: PUSH
81053: LD_INT 3
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 1
81062: PUSH
81063: LD_INT 4
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: LD_INT 4
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 1
81082: NEG
81083: PUSH
81084: LD_INT 3
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: NEG
81094: PUSH
81095: LD_INT 2
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: PUSH
81105: LD_INT 4
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: NEG
81115: PUSH
81116: LD_INT 2
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 4
81125: NEG
81126: PUSH
81127: LD_INT 0
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 4
81136: NEG
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: NEG
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 3
81159: NEG
81160: PUSH
81161: LD_INT 1
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 4
81170: NEG
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 5
81181: NEG
81182: PUSH
81183: LD_INT 0
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 5
81192: NEG
81193: PUSH
81194: LD_INT 1
81196: NEG
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 5
81204: NEG
81205: PUSH
81206: LD_INT 2
81208: NEG
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 3
81216: NEG
81217: PUSH
81218: LD_INT 2
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 3
81227: NEG
81228: PUSH
81229: LD_INT 3
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: NEG
81240: PUSH
81241: LD_INT 4
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: LD_INT 3
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 2
81263: NEG
81264: PUSH
81265: LD_INT 2
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 3
81275: NEG
81276: PUSH
81277: LD_INT 2
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 4
81287: NEG
81288: PUSH
81289: LD_INT 3
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 4
81299: NEG
81300: PUSH
81301: LD_INT 4
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 2
81311: NEG
81312: PUSH
81313: LD_INT 4
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 4
81323: NEG
81324: PUSH
81325: LD_INT 2
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 0
81335: PUSH
81336: LD_INT 4
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 5
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: LD_INT 4
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: PUSH
81369: LD_INT 3
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 0
81379: PUSH
81380: LD_INT 3
81382: NEG
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 1
81390: NEG
81391: PUSH
81392: LD_INT 4
81394: NEG
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: NEG
81403: PUSH
81404: LD_INT 5
81406: NEG
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 3
81417: NEG
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 2
81425: NEG
81426: PUSH
81427: LD_INT 5
81429: NEG
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81482: LD_ADDR_VAR 0 31
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: LD_INT 4
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 0
81499: PUSH
81500: LD_INT 3
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: LD_INT 4
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 1
81519: PUSH
81520: LD_INT 5
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 5
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 1
81539: NEG
81540: PUSH
81541: LD_INT 4
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 1
81550: NEG
81551: PUSH
81552: LD_INT 3
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 5
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 2
81571: NEG
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 3
81582: NEG
81583: PUSH
81584: LD_INT 0
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 3
81593: NEG
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 2
81605: NEG
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 2
81616: NEG
81617: PUSH
81618: LD_INT 1
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 3
81627: NEG
81628: PUSH
81629: LD_INT 1
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 4
81638: NEG
81639: PUSH
81640: LD_INT 0
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 4
81649: NEG
81650: PUSH
81651: LD_INT 1
81653: NEG
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 4
81661: NEG
81662: PUSH
81663: LD_INT 2
81665: NEG
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 2
81673: NEG
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 4
81684: NEG
81685: PUSH
81686: LD_INT 4
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 4
81696: NEG
81697: PUSH
81698: LD_INT 5
81700: NEG
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 3
81708: NEG
81709: PUSH
81710: LD_INT 4
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 3
81720: NEG
81721: PUSH
81722: LD_INT 3
81724: NEG
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 4
81732: NEG
81733: PUSH
81734: LD_INT 3
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 5
81744: NEG
81745: PUSH
81746: LD_INT 4
81748: NEG
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 5
81756: NEG
81757: PUSH
81758: LD_INT 5
81760: NEG
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 3
81768: NEG
81769: PUSH
81770: LD_INT 5
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 5
81780: NEG
81781: PUSH
81782: LD_INT 3
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 0
81792: PUSH
81793: LD_INT 3
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: LD_INT 4
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: PUSH
81815: LD_INT 3
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: LD_INT 2
81828: NEG
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 0
81836: PUSH
81837: LD_INT 2
81839: NEG
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: NEG
81848: PUSH
81849: LD_INT 3
81851: NEG
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: LD_INT 4
81863: NEG
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: LD_INT 2
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 2
81882: NEG
81883: PUSH
81884: LD_INT 4
81886: NEG
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 4
81894: PUSH
81895: LD_INT 0
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 4
81904: PUSH
81905: LD_INT 1
81907: NEG
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 5
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 5
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 4
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 3
81945: PUSH
81946: LD_INT 0
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 3
81955: PUSH
81956: LD_INT 1
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: PUSH
81967: LD_INT 2
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 5
81977: PUSH
81978: LD_INT 2
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82032: LD_ADDR_VAR 0 32
82036: PUSH
82037: LD_INT 4
82039: NEG
82040: PUSH
82041: LD_INT 0
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 4
82050: NEG
82051: PUSH
82052: LD_INT 1
82054: NEG
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 3
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 4
82084: NEG
82085: PUSH
82086: LD_INT 1
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 5
82095: NEG
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 5
82106: NEG
82107: PUSH
82108: LD_INT 1
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 5
82118: NEG
82119: PUSH
82120: LD_INT 2
82122: NEG
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 3
82130: NEG
82131: PUSH
82132: LD_INT 2
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 3
82141: NEG
82142: PUSH
82143: LD_INT 3
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 3
82153: NEG
82154: PUSH
82155: LD_INT 4
82157: NEG
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 2
82165: NEG
82166: PUSH
82167: LD_INT 3
82169: NEG
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 2
82177: NEG
82178: PUSH
82179: LD_INT 2
82181: NEG
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 3
82189: NEG
82190: PUSH
82191: LD_INT 2
82193: NEG
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 4
82201: NEG
82202: PUSH
82203: LD_INT 3
82205: NEG
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 4
82213: NEG
82214: PUSH
82215: LD_INT 4
82217: NEG
82218: PUSH
82219: EMPTY
82220: LIST
82221: LIST
82222: PUSH
82223: LD_INT 2
82225: NEG
82226: PUSH
82227: LD_INT 4
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 4
82237: NEG
82238: PUSH
82239: LD_INT 2
82241: NEG
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 0
82249: PUSH
82250: LD_INT 4
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 5
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 1
82271: PUSH
82272: LD_INT 4
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 3
82285: NEG
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 0
82293: PUSH
82294: LD_INT 3
82296: NEG
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 4
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 1
82316: NEG
82317: PUSH
82318: LD_INT 5
82320: NEG
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: LD_INT 3
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 2
82339: NEG
82340: PUSH
82341: LD_INT 5
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 4
82372: PUSH
82373: LD_INT 0
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 4
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 3
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 2
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 2
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 2
82423: PUSH
82424: LD_INT 2
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 4
82444: PUSH
82445: LD_INT 4
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 4
82454: PUSH
82455: LD_INT 3
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 5
82464: PUSH
82465: LD_INT 4
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 5
82474: PUSH
82475: LD_INT 5
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 4
82484: PUSH
82485: LD_INT 5
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 3
82494: PUSH
82495: LD_INT 4
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 3
82504: PUSH
82505: LD_INT 3
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 5
82514: PUSH
82515: LD_INT 3
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 3
82524: PUSH
82525: LD_INT 5
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82579: LD_ADDR_VAR 0 33
82583: PUSH
82584: LD_INT 4
82586: NEG
82587: PUSH
82588: LD_INT 4
82590: NEG
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 4
82598: NEG
82599: PUSH
82600: LD_INT 5
82602: NEG
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 3
82610: NEG
82611: PUSH
82612: LD_INT 4
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 3
82622: NEG
82623: PUSH
82624: LD_INT 3
82626: NEG
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 4
82634: NEG
82635: PUSH
82636: LD_INT 3
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 5
82646: NEG
82647: PUSH
82648: LD_INT 4
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 5
82658: NEG
82659: PUSH
82660: LD_INT 5
82662: NEG
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 3
82670: NEG
82671: PUSH
82672: LD_INT 5
82674: NEG
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 5
82682: NEG
82683: PUSH
82684: LD_INT 3
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: LD_INT 3
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 0
82705: PUSH
82706: LD_INT 4
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: LD_INT 3
82719: NEG
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 2
82741: NEG
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 1
82749: NEG
82750: PUSH
82751: LD_INT 3
82753: NEG
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 1
82761: NEG
82762: PUSH
82763: LD_INT 4
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 2
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 2
82784: NEG
82785: PUSH
82786: LD_INT 4
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 4
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 4
82806: PUSH
82807: LD_INT 1
82809: NEG
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 5
82817: PUSH
82818: LD_INT 0
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 5
82827: PUSH
82828: LD_INT 1
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 4
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 3
82847: PUSH
82848: LD_INT 0
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 3
82857: PUSH
82858: LD_INT 1
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 3
82868: PUSH
82869: LD_INT 2
82871: NEG
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 5
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 3
82889: PUSH
82890: LD_INT 3
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 3
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 4
82909: PUSH
82910: LD_INT 3
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 4
82919: PUSH
82920: LD_INT 4
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 3
82929: PUSH
82930: LD_INT 4
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: LD_INT 3
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 2
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 4
82959: PUSH
82960: LD_INT 2
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: PUSH
82970: LD_INT 4
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 0
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 0
82989: PUSH
82990: LD_INT 3
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 1
82999: PUSH
83000: LD_INT 4
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 1
83009: PUSH
83010: LD_INT 5
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 0
83019: PUSH
83020: LD_INT 5
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 1
83029: NEG
83030: PUSH
83031: LD_INT 4
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 1
83040: NEG
83041: PUSH
83042: LD_INT 3
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: LD_INT 5
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 2
83061: NEG
83062: PUSH
83063: LD_INT 3
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83117: LD_ADDR_VAR 0 34
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: LD_INT 4
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 5
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: LD_INT 4
83149: NEG
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 1
83157: PUSH
83158: LD_INT 3
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 3
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 1
83179: NEG
83180: PUSH
83181: LD_INT 4
83183: NEG
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 1
83191: NEG
83192: PUSH
83193: LD_INT 5
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 2
83203: PUSH
83204: LD_INT 3
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 2
83214: NEG
83215: PUSH
83216: LD_INT 5
83218: NEG
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 3
83226: PUSH
83227: LD_INT 0
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 3
83236: PUSH
83237: LD_INT 1
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 4
83247: PUSH
83248: LD_INT 0
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 4
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 3
83267: PUSH
83268: LD_INT 1
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 2
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 2
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: PUSH
83299: LD_INT 2
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 4
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 4
83319: PUSH
83320: LD_INT 4
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 4
83329: PUSH
83330: LD_INT 3
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 5
83339: PUSH
83340: LD_INT 4
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 5
83349: PUSH
83350: LD_INT 5
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 4
83359: PUSH
83360: LD_INT 5
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 3
83369: PUSH
83370: LD_INT 4
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 3
83379: PUSH
83380: LD_INT 3
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 5
83389: PUSH
83390: LD_INT 3
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 3
83399: PUSH
83400: LD_INT 5
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 0
83409: PUSH
83410: LD_INT 3
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 2
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: PUSH
83430: LD_INT 3
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: LD_INT 4
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 0
83449: PUSH
83450: LD_INT 4
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 1
83459: NEG
83460: PUSH
83461: LD_INT 3
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 1
83470: NEG
83471: PUSH
83472: LD_INT 2
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 2
83481: PUSH
83482: LD_INT 4
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 4
83502: NEG
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 4
83513: NEG
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 3
83525: NEG
83526: PUSH
83527: LD_INT 0
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 3
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 4
83547: NEG
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 5
83558: NEG
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 5
83569: NEG
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 5
83581: NEG
83582: PUSH
83583: LD_INT 2
83585: NEG
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 3
83593: NEG
83594: PUSH
83595: LD_INT 2
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: ST_TO_ADDR
// end ; end ;
83649: GO 83652
83651: POP
// case btype of b_depot , b_warehouse :
83652: LD_VAR 0 1
83656: PUSH
83657: LD_INT 0
83659: DOUBLE
83660: EQUAL
83661: IFTRUE 83671
83663: LD_INT 1
83665: DOUBLE
83666: EQUAL
83667: IFTRUE 83671
83669: GO 83872
83671: POP
// case nation of nation_american :
83672: LD_VAR 0 5
83676: PUSH
83677: LD_INT 1
83679: DOUBLE
83680: EQUAL
83681: IFTRUE 83685
83683: GO 83741
83685: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83686: LD_ADDR_VAR 0 9
83690: PUSH
83691: LD_VAR 0 11
83695: PUSH
83696: LD_VAR 0 12
83700: PUSH
83701: LD_VAR 0 13
83705: PUSH
83706: LD_VAR 0 14
83710: PUSH
83711: LD_VAR 0 15
83715: PUSH
83716: LD_VAR 0 16
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: PUSH
83729: LD_VAR 0 4
83733: PUSH
83734: LD_INT 1
83736: PLUS
83737: ARRAY
83738: ST_TO_ADDR
83739: GO 83870
83741: LD_INT 2
83743: DOUBLE
83744: EQUAL
83745: IFTRUE 83749
83747: GO 83805
83749: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83750: LD_ADDR_VAR 0 9
83754: PUSH
83755: LD_VAR 0 17
83759: PUSH
83760: LD_VAR 0 18
83764: PUSH
83765: LD_VAR 0 19
83769: PUSH
83770: LD_VAR 0 20
83774: PUSH
83775: LD_VAR 0 21
83779: PUSH
83780: LD_VAR 0 22
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: PUSH
83793: LD_VAR 0 4
83797: PUSH
83798: LD_INT 1
83800: PLUS
83801: ARRAY
83802: ST_TO_ADDR
83803: GO 83870
83805: LD_INT 3
83807: DOUBLE
83808: EQUAL
83809: IFTRUE 83813
83811: GO 83869
83813: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83814: LD_ADDR_VAR 0 9
83818: PUSH
83819: LD_VAR 0 23
83823: PUSH
83824: LD_VAR 0 24
83828: PUSH
83829: LD_VAR 0 25
83833: PUSH
83834: LD_VAR 0 26
83838: PUSH
83839: LD_VAR 0 27
83843: PUSH
83844: LD_VAR 0 28
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: PUSH
83857: LD_VAR 0 4
83861: PUSH
83862: LD_INT 1
83864: PLUS
83865: ARRAY
83866: ST_TO_ADDR
83867: GO 83870
83869: POP
83870: GO 84425
83872: LD_INT 2
83874: DOUBLE
83875: EQUAL
83876: IFTRUE 83886
83878: LD_INT 3
83880: DOUBLE
83881: EQUAL
83882: IFTRUE 83886
83884: GO 83942
83886: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83887: LD_ADDR_VAR 0 9
83891: PUSH
83892: LD_VAR 0 29
83896: PUSH
83897: LD_VAR 0 30
83901: PUSH
83902: LD_VAR 0 31
83906: PUSH
83907: LD_VAR 0 32
83911: PUSH
83912: LD_VAR 0 33
83916: PUSH
83917: LD_VAR 0 34
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: PUSH
83930: LD_VAR 0 4
83934: PUSH
83935: LD_INT 1
83937: PLUS
83938: ARRAY
83939: ST_TO_ADDR
83940: GO 84425
83942: LD_INT 16
83944: DOUBLE
83945: EQUAL
83946: IFTRUE 84004
83948: LD_INT 17
83950: DOUBLE
83951: EQUAL
83952: IFTRUE 84004
83954: LD_INT 18
83956: DOUBLE
83957: EQUAL
83958: IFTRUE 84004
83960: LD_INT 19
83962: DOUBLE
83963: EQUAL
83964: IFTRUE 84004
83966: LD_INT 22
83968: DOUBLE
83969: EQUAL
83970: IFTRUE 84004
83972: LD_INT 20
83974: DOUBLE
83975: EQUAL
83976: IFTRUE 84004
83978: LD_INT 21
83980: DOUBLE
83981: EQUAL
83982: IFTRUE 84004
83984: LD_INT 23
83986: DOUBLE
83987: EQUAL
83988: IFTRUE 84004
83990: LD_INT 24
83992: DOUBLE
83993: EQUAL
83994: IFTRUE 84004
83996: LD_INT 25
83998: DOUBLE
83999: EQUAL
84000: IFTRUE 84004
84002: GO 84060
84004: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84005: LD_ADDR_VAR 0 9
84009: PUSH
84010: LD_VAR 0 35
84014: PUSH
84015: LD_VAR 0 36
84019: PUSH
84020: LD_VAR 0 37
84024: PUSH
84025: LD_VAR 0 38
84029: PUSH
84030: LD_VAR 0 39
84034: PUSH
84035: LD_VAR 0 40
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: PUSH
84048: LD_VAR 0 4
84052: PUSH
84053: LD_INT 1
84055: PLUS
84056: ARRAY
84057: ST_TO_ADDR
84058: GO 84425
84060: LD_INT 6
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84116
84066: LD_INT 7
84068: DOUBLE
84069: EQUAL
84070: IFTRUE 84116
84072: LD_INT 8
84074: DOUBLE
84075: EQUAL
84076: IFTRUE 84116
84078: LD_INT 13
84080: DOUBLE
84081: EQUAL
84082: IFTRUE 84116
84084: LD_INT 12
84086: DOUBLE
84087: EQUAL
84088: IFTRUE 84116
84090: LD_INT 15
84092: DOUBLE
84093: EQUAL
84094: IFTRUE 84116
84096: LD_INT 11
84098: DOUBLE
84099: EQUAL
84100: IFTRUE 84116
84102: LD_INT 14
84104: DOUBLE
84105: EQUAL
84106: IFTRUE 84116
84108: LD_INT 10
84110: DOUBLE
84111: EQUAL
84112: IFTRUE 84116
84114: GO 84172
84116: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84117: LD_ADDR_VAR 0 9
84121: PUSH
84122: LD_VAR 0 41
84126: PUSH
84127: LD_VAR 0 42
84131: PUSH
84132: LD_VAR 0 43
84136: PUSH
84137: LD_VAR 0 44
84141: PUSH
84142: LD_VAR 0 45
84146: PUSH
84147: LD_VAR 0 46
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: PUSH
84160: LD_VAR 0 4
84164: PUSH
84165: LD_INT 1
84167: PLUS
84168: ARRAY
84169: ST_TO_ADDR
84170: GO 84425
84172: LD_INT 36
84174: DOUBLE
84175: EQUAL
84176: IFTRUE 84180
84178: GO 84236
84180: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84181: LD_ADDR_VAR 0 9
84185: PUSH
84186: LD_VAR 0 47
84190: PUSH
84191: LD_VAR 0 48
84195: PUSH
84196: LD_VAR 0 49
84200: PUSH
84201: LD_VAR 0 50
84205: PUSH
84206: LD_VAR 0 51
84210: PUSH
84211: LD_VAR 0 52
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: PUSH
84224: LD_VAR 0 4
84228: PUSH
84229: LD_INT 1
84231: PLUS
84232: ARRAY
84233: ST_TO_ADDR
84234: GO 84425
84236: LD_INT 4
84238: DOUBLE
84239: EQUAL
84240: IFTRUE 84262
84242: LD_INT 5
84244: DOUBLE
84245: EQUAL
84246: IFTRUE 84262
84248: LD_INT 34
84250: DOUBLE
84251: EQUAL
84252: IFTRUE 84262
84254: LD_INT 37
84256: DOUBLE
84257: EQUAL
84258: IFTRUE 84262
84260: GO 84318
84262: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84263: LD_ADDR_VAR 0 9
84267: PUSH
84268: LD_VAR 0 53
84272: PUSH
84273: LD_VAR 0 54
84277: PUSH
84278: LD_VAR 0 55
84282: PUSH
84283: LD_VAR 0 56
84287: PUSH
84288: LD_VAR 0 57
84292: PUSH
84293: LD_VAR 0 58
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: PUSH
84306: LD_VAR 0 4
84310: PUSH
84311: LD_INT 1
84313: PLUS
84314: ARRAY
84315: ST_TO_ADDR
84316: GO 84425
84318: LD_INT 31
84320: DOUBLE
84321: EQUAL
84322: IFTRUE 84368
84324: LD_INT 32
84326: DOUBLE
84327: EQUAL
84328: IFTRUE 84368
84330: LD_INT 33
84332: DOUBLE
84333: EQUAL
84334: IFTRUE 84368
84336: LD_INT 27
84338: DOUBLE
84339: EQUAL
84340: IFTRUE 84368
84342: LD_INT 26
84344: DOUBLE
84345: EQUAL
84346: IFTRUE 84368
84348: LD_INT 28
84350: DOUBLE
84351: EQUAL
84352: IFTRUE 84368
84354: LD_INT 29
84356: DOUBLE
84357: EQUAL
84358: IFTRUE 84368
84360: LD_INT 30
84362: DOUBLE
84363: EQUAL
84364: IFTRUE 84368
84366: GO 84424
84368: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84369: LD_ADDR_VAR 0 9
84373: PUSH
84374: LD_VAR 0 59
84378: PUSH
84379: LD_VAR 0 60
84383: PUSH
84384: LD_VAR 0 61
84388: PUSH
84389: LD_VAR 0 62
84393: PUSH
84394: LD_VAR 0 63
84398: PUSH
84399: LD_VAR 0 64
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: PUSH
84412: LD_VAR 0 4
84416: PUSH
84417: LD_INT 1
84419: PLUS
84420: ARRAY
84421: ST_TO_ADDR
84422: GO 84425
84424: POP
// temp_list2 = [ ] ;
84425: LD_ADDR_VAR 0 10
84429: PUSH
84430: EMPTY
84431: ST_TO_ADDR
// for i in temp_list do
84432: LD_ADDR_VAR 0 8
84436: PUSH
84437: LD_VAR 0 9
84441: PUSH
84442: FOR_IN
84443: IFFALSE 84495
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84445: LD_ADDR_VAR 0 10
84449: PUSH
84450: LD_VAR 0 10
84454: PUSH
84455: LD_VAR 0 8
84459: PUSH
84460: LD_INT 1
84462: ARRAY
84463: PUSH
84464: LD_VAR 0 2
84468: PLUS
84469: PUSH
84470: LD_VAR 0 8
84474: PUSH
84475: LD_INT 2
84477: ARRAY
84478: PUSH
84479: LD_VAR 0 3
84483: PLUS
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: EMPTY
84490: LIST
84491: ADD
84492: ST_TO_ADDR
84493: GO 84442
84495: POP
84496: POP
// result = temp_list2 ;
84497: LD_ADDR_VAR 0 7
84501: PUSH
84502: LD_VAR 0 10
84506: ST_TO_ADDR
// end ;
84507: LD_VAR 0 7
84511: RET
// export function EnemyInRange ( unit , dist ) ; begin
84512: LD_INT 0
84514: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84515: LD_ADDR_VAR 0 3
84519: PUSH
84520: LD_VAR 0 1
84524: PPUSH
84525: CALL_OW 255
84529: PPUSH
84530: LD_VAR 0 1
84534: PPUSH
84535: CALL_OW 250
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: CALL_OW 251
84549: PPUSH
84550: LD_VAR 0 2
84554: PPUSH
84555: CALL 57908 0 4
84559: PUSH
84560: LD_INT 4
84562: ARRAY
84563: ST_TO_ADDR
// end ;
84564: LD_VAR 0 3
84568: RET
// export function PlayerSeeMe ( unit ) ; begin
84569: LD_INT 0
84571: PPUSH
// result := See ( your_side , unit ) ;
84572: LD_ADDR_VAR 0 2
84576: PUSH
84577: LD_OWVAR 2
84581: PPUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: CALL_OW 292
84591: ST_TO_ADDR
// end ;
84592: LD_VAR 0 2
84596: RET
// export function ReverseDir ( unit ) ; begin
84597: LD_INT 0
84599: PPUSH
// if not unit then
84600: LD_VAR 0 1
84604: NOT
84605: IFFALSE 84609
// exit ;
84607: GO 84632
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84609: LD_ADDR_VAR 0 2
84613: PUSH
84614: LD_VAR 0 1
84618: PPUSH
84619: CALL_OW 254
84623: PUSH
84624: LD_INT 3
84626: PLUS
84627: PUSH
84628: LD_INT 6
84630: MOD
84631: ST_TO_ADDR
// end ;
84632: LD_VAR 0 2
84636: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84637: LD_INT 0
84639: PPUSH
84640: PPUSH
84641: PPUSH
84642: PPUSH
84643: PPUSH
// if not hexes then
84644: LD_VAR 0 2
84648: NOT
84649: IFFALSE 84653
// exit ;
84651: GO 84801
// dist := 9999 ;
84653: LD_ADDR_VAR 0 5
84657: PUSH
84658: LD_INT 9999
84660: ST_TO_ADDR
// for i = 1 to hexes do
84661: LD_ADDR_VAR 0 4
84665: PUSH
84666: DOUBLE
84667: LD_INT 1
84669: DEC
84670: ST_TO_ADDR
84671: LD_VAR 0 2
84675: PUSH
84676: FOR_TO
84677: IFFALSE 84789
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84679: LD_VAR 0 1
84683: PPUSH
84684: LD_VAR 0 2
84688: PUSH
84689: LD_VAR 0 4
84693: ARRAY
84694: PUSH
84695: LD_INT 1
84697: ARRAY
84698: PPUSH
84699: LD_VAR 0 2
84703: PUSH
84704: LD_VAR 0 4
84708: ARRAY
84709: PUSH
84710: LD_INT 2
84712: ARRAY
84713: PPUSH
84714: CALL_OW 297
84718: PUSH
84719: LD_VAR 0 5
84723: LESS
84724: IFFALSE 84787
// begin hex := hexes [ i ] ;
84726: LD_ADDR_VAR 0 7
84730: PUSH
84731: LD_VAR 0 2
84735: PUSH
84736: LD_VAR 0 4
84740: ARRAY
84741: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84742: LD_ADDR_VAR 0 5
84746: PUSH
84747: LD_VAR 0 1
84751: PPUSH
84752: LD_VAR 0 2
84756: PUSH
84757: LD_VAR 0 4
84761: ARRAY
84762: PUSH
84763: LD_INT 1
84765: ARRAY
84766: PPUSH
84767: LD_VAR 0 2
84771: PUSH
84772: LD_VAR 0 4
84776: ARRAY
84777: PUSH
84778: LD_INT 2
84780: ARRAY
84781: PPUSH
84782: CALL_OW 297
84786: ST_TO_ADDR
// end ; end ;
84787: GO 84676
84789: POP
84790: POP
// result := hex ;
84791: LD_ADDR_VAR 0 3
84795: PUSH
84796: LD_VAR 0 7
84800: ST_TO_ADDR
// end ;
84801: LD_VAR 0 3
84805: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84806: LD_INT 0
84808: PPUSH
84809: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84810: LD_VAR 0 1
84814: NOT
84815: PUSH
84816: LD_VAR 0 1
84820: PUSH
84821: LD_INT 21
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 23
84833: PUSH
84834: LD_INT 2
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PPUSH
84845: CALL_OW 69
84849: IN
84850: NOT
84851: OR
84852: IFFALSE 84856
// exit ;
84854: GO 84903
// for i = 1 to 3 do
84856: LD_ADDR_VAR 0 3
84860: PUSH
84861: DOUBLE
84862: LD_INT 1
84864: DEC
84865: ST_TO_ADDR
84866: LD_INT 3
84868: PUSH
84869: FOR_TO
84870: IFFALSE 84901
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84872: LD_VAR 0 1
84876: PPUSH
84877: CALL_OW 250
84881: PPUSH
84882: LD_VAR 0 1
84886: PPUSH
84887: CALL_OW 251
84891: PPUSH
84892: LD_INT 1
84894: PPUSH
84895: CALL_OW 453
84899: GO 84869
84901: POP
84902: POP
// end ;
84903: LD_VAR 0 2
84907: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84908: LD_INT 0
84910: PPUSH
84911: PPUSH
84912: PPUSH
84913: PPUSH
84914: PPUSH
84915: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84916: LD_VAR 0 1
84920: NOT
84921: PUSH
84922: LD_VAR 0 2
84926: NOT
84927: OR
84928: PUSH
84929: LD_VAR 0 1
84933: PPUSH
84934: CALL_OW 314
84938: OR
84939: IFFALSE 84943
// exit ;
84941: GO 85384
// x := GetX ( enemy_unit ) ;
84943: LD_ADDR_VAR 0 7
84947: PUSH
84948: LD_VAR 0 2
84952: PPUSH
84953: CALL_OW 250
84957: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84958: LD_ADDR_VAR 0 8
84962: PUSH
84963: LD_VAR 0 2
84967: PPUSH
84968: CALL_OW 251
84972: ST_TO_ADDR
// if not x or not y then
84973: LD_VAR 0 7
84977: NOT
84978: PUSH
84979: LD_VAR 0 8
84983: NOT
84984: OR
84985: IFFALSE 84989
// exit ;
84987: GO 85384
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84989: LD_ADDR_VAR 0 6
84993: PUSH
84994: LD_VAR 0 7
84998: PPUSH
84999: LD_INT 0
85001: PPUSH
85002: LD_INT 4
85004: PPUSH
85005: CALL_OW 272
85009: PUSH
85010: LD_VAR 0 8
85014: PPUSH
85015: LD_INT 0
85017: PPUSH
85018: LD_INT 4
85020: PPUSH
85021: CALL_OW 273
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_VAR 0 7
85034: PPUSH
85035: LD_INT 1
85037: PPUSH
85038: LD_INT 4
85040: PPUSH
85041: CALL_OW 272
85045: PUSH
85046: LD_VAR 0 8
85050: PPUSH
85051: LD_INT 1
85053: PPUSH
85054: LD_INT 4
85056: PPUSH
85057: CALL_OW 273
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_VAR 0 7
85070: PPUSH
85071: LD_INT 2
85073: PPUSH
85074: LD_INT 4
85076: PPUSH
85077: CALL_OW 272
85081: PUSH
85082: LD_VAR 0 8
85086: PPUSH
85087: LD_INT 2
85089: PPUSH
85090: LD_INT 4
85092: PPUSH
85093: CALL_OW 273
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_VAR 0 7
85106: PPUSH
85107: LD_INT 3
85109: PPUSH
85110: LD_INT 4
85112: PPUSH
85113: CALL_OW 272
85117: PUSH
85118: LD_VAR 0 8
85122: PPUSH
85123: LD_INT 3
85125: PPUSH
85126: LD_INT 4
85128: PPUSH
85129: CALL_OW 273
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_VAR 0 7
85142: PPUSH
85143: LD_INT 4
85145: PPUSH
85146: LD_INT 4
85148: PPUSH
85149: CALL_OW 272
85153: PUSH
85154: LD_VAR 0 8
85158: PPUSH
85159: LD_INT 4
85161: PPUSH
85162: LD_INT 4
85164: PPUSH
85165: CALL_OW 273
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_VAR 0 7
85178: PPUSH
85179: LD_INT 5
85181: PPUSH
85182: LD_INT 4
85184: PPUSH
85185: CALL_OW 272
85189: PUSH
85190: LD_VAR 0 8
85194: PPUSH
85195: LD_INT 5
85197: PPUSH
85198: LD_INT 4
85200: PPUSH
85201: CALL_OW 273
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: ST_TO_ADDR
// for i = tmp downto 1 do
85218: LD_ADDR_VAR 0 4
85222: PUSH
85223: DOUBLE
85224: LD_VAR 0 6
85228: INC
85229: ST_TO_ADDR
85230: LD_INT 1
85232: PUSH
85233: FOR_DOWNTO
85234: IFFALSE 85335
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85236: LD_VAR 0 6
85240: PUSH
85241: LD_VAR 0 4
85245: ARRAY
85246: PUSH
85247: LD_INT 1
85249: ARRAY
85250: PPUSH
85251: LD_VAR 0 6
85255: PUSH
85256: LD_VAR 0 4
85260: ARRAY
85261: PUSH
85262: LD_INT 2
85264: ARRAY
85265: PPUSH
85266: CALL_OW 488
85270: NOT
85271: PUSH
85272: LD_VAR 0 6
85276: PUSH
85277: LD_VAR 0 4
85281: ARRAY
85282: PUSH
85283: LD_INT 1
85285: ARRAY
85286: PPUSH
85287: LD_VAR 0 6
85291: PUSH
85292: LD_VAR 0 4
85296: ARRAY
85297: PUSH
85298: LD_INT 2
85300: ARRAY
85301: PPUSH
85302: CALL_OW 428
85306: PUSH
85307: LD_INT 0
85309: NONEQUAL
85310: OR
85311: IFFALSE 85333
// tmp := Delete ( tmp , i ) ;
85313: LD_ADDR_VAR 0 6
85317: PUSH
85318: LD_VAR 0 6
85322: PPUSH
85323: LD_VAR 0 4
85327: PPUSH
85328: CALL_OW 3
85332: ST_TO_ADDR
85333: GO 85233
85335: POP
85336: POP
// j := GetClosestHex ( unit , tmp ) ;
85337: LD_ADDR_VAR 0 5
85341: PUSH
85342: LD_VAR 0 1
85346: PPUSH
85347: LD_VAR 0 6
85351: PPUSH
85352: CALL 84637 0 2
85356: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85357: LD_VAR 0 1
85361: PPUSH
85362: LD_VAR 0 5
85366: PUSH
85367: LD_INT 1
85369: ARRAY
85370: PPUSH
85371: LD_VAR 0 5
85375: PUSH
85376: LD_INT 2
85378: ARRAY
85379: PPUSH
85380: CALL_OW 111
// end ;
85384: LD_VAR 0 3
85388: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85389: LD_INT 0
85391: PPUSH
85392: PPUSH
85393: PPUSH
// uc_side = 0 ;
85394: LD_ADDR_OWVAR 20
85398: PUSH
85399: LD_INT 0
85401: ST_TO_ADDR
// uc_nation = 0 ;
85402: LD_ADDR_OWVAR 21
85406: PUSH
85407: LD_INT 0
85409: ST_TO_ADDR
// InitHc_All ( ) ;
85410: CALL_OW 584
// InitVc ;
85414: CALL_OW 20
// if mastodonts then
85418: LD_VAR 0 6
85422: IFFALSE 85489
// for i = 1 to mastodonts do
85424: LD_ADDR_VAR 0 11
85428: PUSH
85429: DOUBLE
85430: LD_INT 1
85432: DEC
85433: ST_TO_ADDR
85434: LD_VAR 0 6
85438: PUSH
85439: FOR_TO
85440: IFFALSE 85487
// begin vc_chassis := 31 ;
85442: LD_ADDR_OWVAR 37
85446: PUSH
85447: LD_INT 31
85449: ST_TO_ADDR
// vc_control := control_rider ;
85450: LD_ADDR_OWVAR 38
85454: PUSH
85455: LD_INT 4
85457: ST_TO_ADDR
// animal := CreateVehicle ;
85458: LD_ADDR_VAR 0 12
85462: PUSH
85463: CALL_OW 45
85467: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85468: LD_VAR 0 12
85472: PPUSH
85473: LD_VAR 0 8
85477: PPUSH
85478: LD_INT 0
85480: PPUSH
85481: CALL 87677 0 3
// end ;
85485: GO 85439
85487: POP
85488: POP
// if horses then
85489: LD_VAR 0 5
85493: IFFALSE 85560
// for i = 1 to horses do
85495: LD_ADDR_VAR 0 11
85499: PUSH
85500: DOUBLE
85501: LD_INT 1
85503: DEC
85504: ST_TO_ADDR
85505: LD_VAR 0 5
85509: PUSH
85510: FOR_TO
85511: IFFALSE 85558
// begin hc_class := 21 ;
85513: LD_ADDR_OWVAR 28
85517: PUSH
85518: LD_INT 21
85520: ST_TO_ADDR
// hc_gallery :=  ;
85521: LD_ADDR_OWVAR 33
85525: PUSH
85526: LD_STRING 
85528: ST_TO_ADDR
// animal := CreateHuman ;
85529: LD_ADDR_VAR 0 12
85533: PUSH
85534: CALL_OW 44
85538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85539: LD_VAR 0 12
85543: PPUSH
85544: LD_VAR 0 8
85548: PPUSH
85549: LD_INT 0
85551: PPUSH
85552: CALL 87677 0 3
// end ;
85556: GO 85510
85558: POP
85559: POP
// if birds then
85560: LD_VAR 0 1
85564: IFFALSE 85631
// for i = 1 to birds do
85566: LD_ADDR_VAR 0 11
85570: PUSH
85571: DOUBLE
85572: LD_INT 1
85574: DEC
85575: ST_TO_ADDR
85576: LD_VAR 0 1
85580: PUSH
85581: FOR_TO
85582: IFFALSE 85629
// begin hc_class = 18 ;
85584: LD_ADDR_OWVAR 28
85588: PUSH
85589: LD_INT 18
85591: ST_TO_ADDR
// hc_gallery =  ;
85592: LD_ADDR_OWVAR 33
85596: PUSH
85597: LD_STRING 
85599: ST_TO_ADDR
// animal := CreateHuman ;
85600: LD_ADDR_VAR 0 12
85604: PUSH
85605: CALL_OW 44
85609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85610: LD_VAR 0 12
85614: PPUSH
85615: LD_VAR 0 8
85619: PPUSH
85620: LD_INT 0
85622: PPUSH
85623: CALL 87677 0 3
// end ;
85627: GO 85581
85629: POP
85630: POP
// if tigers then
85631: LD_VAR 0 2
85635: IFFALSE 85719
// for i = 1 to tigers do
85637: LD_ADDR_VAR 0 11
85641: PUSH
85642: DOUBLE
85643: LD_INT 1
85645: DEC
85646: ST_TO_ADDR
85647: LD_VAR 0 2
85651: PUSH
85652: FOR_TO
85653: IFFALSE 85717
// begin hc_class = class_tiger ;
85655: LD_ADDR_OWVAR 28
85659: PUSH
85660: LD_INT 14
85662: ST_TO_ADDR
// hc_gallery =  ;
85663: LD_ADDR_OWVAR 33
85667: PUSH
85668: LD_STRING 
85670: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85671: LD_ADDR_OWVAR 35
85675: PUSH
85676: LD_INT 7
85678: NEG
85679: PPUSH
85680: LD_INT 7
85682: PPUSH
85683: CALL_OW 12
85687: ST_TO_ADDR
// animal := CreateHuman ;
85688: LD_ADDR_VAR 0 12
85692: PUSH
85693: CALL_OW 44
85697: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85698: LD_VAR 0 12
85702: PPUSH
85703: LD_VAR 0 8
85707: PPUSH
85708: LD_INT 0
85710: PPUSH
85711: CALL 87677 0 3
// end ;
85715: GO 85652
85717: POP
85718: POP
// if apemans then
85719: LD_VAR 0 3
85723: IFFALSE 85846
// for i = 1 to apemans do
85725: LD_ADDR_VAR 0 11
85729: PUSH
85730: DOUBLE
85731: LD_INT 1
85733: DEC
85734: ST_TO_ADDR
85735: LD_VAR 0 3
85739: PUSH
85740: FOR_TO
85741: IFFALSE 85844
// begin hc_class = class_apeman ;
85743: LD_ADDR_OWVAR 28
85747: PUSH
85748: LD_INT 12
85750: ST_TO_ADDR
// hc_gallery =  ;
85751: LD_ADDR_OWVAR 33
85755: PUSH
85756: LD_STRING 
85758: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85759: LD_ADDR_OWVAR 35
85763: PUSH
85764: LD_INT 2
85766: NEG
85767: PPUSH
85768: LD_INT 2
85770: PPUSH
85771: CALL_OW 12
85775: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85776: LD_ADDR_OWVAR 31
85780: PUSH
85781: LD_INT 1
85783: PPUSH
85784: LD_INT 3
85786: PPUSH
85787: CALL_OW 12
85791: PUSH
85792: LD_INT 1
85794: PPUSH
85795: LD_INT 3
85797: PPUSH
85798: CALL_OW 12
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: LD_INT 0
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: ST_TO_ADDR
// animal := CreateHuman ;
85815: LD_ADDR_VAR 0 12
85819: PUSH
85820: CALL_OW 44
85824: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85825: LD_VAR 0 12
85829: PPUSH
85830: LD_VAR 0 8
85834: PPUSH
85835: LD_INT 0
85837: PPUSH
85838: CALL 87677 0 3
// end ;
85842: GO 85740
85844: POP
85845: POP
// if enchidnas then
85846: LD_VAR 0 4
85850: IFFALSE 85917
// for i = 1 to enchidnas do
85852: LD_ADDR_VAR 0 11
85856: PUSH
85857: DOUBLE
85858: LD_INT 1
85860: DEC
85861: ST_TO_ADDR
85862: LD_VAR 0 4
85866: PUSH
85867: FOR_TO
85868: IFFALSE 85915
// begin hc_class = 13 ;
85870: LD_ADDR_OWVAR 28
85874: PUSH
85875: LD_INT 13
85877: ST_TO_ADDR
// hc_gallery =  ;
85878: LD_ADDR_OWVAR 33
85882: PUSH
85883: LD_STRING 
85885: ST_TO_ADDR
// animal := CreateHuman ;
85886: LD_ADDR_VAR 0 12
85890: PUSH
85891: CALL_OW 44
85895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85896: LD_VAR 0 12
85900: PPUSH
85901: LD_VAR 0 8
85905: PPUSH
85906: LD_INT 0
85908: PPUSH
85909: CALL 87677 0 3
// end ;
85913: GO 85867
85915: POP
85916: POP
// if fishes then
85917: LD_VAR 0 7
85921: IFFALSE 85988
// for i = 1 to fishes do
85923: LD_ADDR_VAR 0 11
85927: PUSH
85928: DOUBLE
85929: LD_INT 1
85931: DEC
85932: ST_TO_ADDR
85933: LD_VAR 0 7
85937: PUSH
85938: FOR_TO
85939: IFFALSE 85986
// begin hc_class = 20 ;
85941: LD_ADDR_OWVAR 28
85945: PUSH
85946: LD_INT 20
85948: ST_TO_ADDR
// hc_gallery =  ;
85949: LD_ADDR_OWVAR 33
85953: PUSH
85954: LD_STRING 
85956: ST_TO_ADDR
// animal := CreateHuman ;
85957: LD_ADDR_VAR 0 12
85961: PUSH
85962: CALL_OW 44
85966: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85967: LD_VAR 0 12
85971: PPUSH
85972: LD_VAR 0 9
85976: PPUSH
85977: LD_INT 0
85979: PPUSH
85980: CALL 87677 0 3
// end ;
85984: GO 85938
85986: POP
85987: POP
// end ;
85988: LD_VAR 0 10
85992: RET
// export function WantHeal ( sci , unit ) ; begin
85993: LD_INT 0
85995: PPUSH
// if GetTaskList ( sci ) > 0 then
85996: LD_VAR 0 1
86000: PPUSH
86001: CALL_OW 437
86005: PUSH
86006: LD_INT 0
86008: GREATER
86009: IFFALSE 86079
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86011: LD_VAR 0 1
86015: PPUSH
86016: CALL_OW 437
86020: PUSH
86021: LD_INT 1
86023: ARRAY
86024: PUSH
86025: LD_INT 1
86027: ARRAY
86028: PUSH
86029: LD_STRING l
86031: EQUAL
86032: PUSH
86033: LD_VAR 0 1
86037: PPUSH
86038: CALL_OW 437
86042: PUSH
86043: LD_INT 1
86045: ARRAY
86046: PUSH
86047: LD_INT 4
86049: ARRAY
86050: PUSH
86051: LD_VAR 0 2
86055: EQUAL
86056: AND
86057: IFFALSE 86069
// result := true else
86059: LD_ADDR_VAR 0 3
86063: PUSH
86064: LD_INT 1
86066: ST_TO_ADDR
86067: GO 86077
// result := false ;
86069: LD_ADDR_VAR 0 3
86073: PUSH
86074: LD_INT 0
86076: ST_TO_ADDR
// end else
86077: GO 86087
// result := false ;
86079: LD_ADDR_VAR 0 3
86083: PUSH
86084: LD_INT 0
86086: ST_TO_ADDR
// end ;
86087: LD_VAR 0 3
86091: RET
// export function HealTarget ( sci ) ; begin
86092: LD_INT 0
86094: PPUSH
// if not sci then
86095: LD_VAR 0 1
86099: NOT
86100: IFFALSE 86104
// exit ;
86102: GO 86169
// result := 0 ;
86104: LD_ADDR_VAR 0 2
86108: PUSH
86109: LD_INT 0
86111: ST_TO_ADDR
// if GetTaskList ( sci ) then
86112: LD_VAR 0 1
86116: PPUSH
86117: CALL_OW 437
86121: IFFALSE 86169
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86123: LD_VAR 0 1
86127: PPUSH
86128: CALL_OW 437
86132: PUSH
86133: LD_INT 1
86135: ARRAY
86136: PUSH
86137: LD_INT 1
86139: ARRAY
86140: PUSH
86141: LD_STRING l
86143: EQUAL
86144: IFFALSE 86169
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86146: LD_ADDR_VAR 0 2
86150: PUSH
86151: LD_VAR 0 1
86155: PPUSH
86156: CALL_OW 437
86160: PUSH
86161: LD_INT 1
86163: ARRAY
86164: PUSH
86165: LD_INT 4
86167: ARRAY
86168: ST_TO_ADDR
// end ;
86169: LD_VAR 0 2
86173: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86174: LD_INT 0
86176: PPUSH
86177: PPUSH
86178: PPUSH
86179: PPUSH
// if not base_units then
86180: LD_VAR 0 1
86184: NOT
86185: IFFALSE 86189
// exit ;
86187: GO 86276
// result := false ;
86189: LD_ADDR_VAR 0 2
86193: PUSH
86194: LD_INT 0
86196: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86197: LD_ADDR_VAR 0 5
86201: PUSH
86202: LD_VAR 0 1
86206: PPUSH
86207: LD_INT 21
86209: PUSH
86210: LD_INT 3
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PPUSH
86217: CALL_OW 72
86221: ST_TO_ADDR
// if not tmp then
86222: LD_VAR 0 5
86226: NOT
86227: IFFALSE 86231
// exit ;
86229: GO 86276
// for i in tmp do
86231: LD_ADDR_VAR 0 3
86235: PUSH
86236: LD_VAR 0 5
86240: PUSH
86241: FOR_IN
86242: IFFALSE 86274
// begin result := EnemyInRange ( i , 22 ) ;
86244: LD_ADDR_VAR 0 2
86248: PUSH
86249: LD_VAR 0 3
86253: PPUSH
86254: LD_INT 22
86256: PPUSH
86257: CALL 84512 0 2
86261: ST_TO_ADDR
// if result then
86262: LD_VAR 0 2
86266: IFFALSE 86272
// exit ;
86268: POP
86269: POP
86270: GO 86276
// end ;
86272: GO 86241
86274: POP
86275: POP
// end ;
86276: LD_VAR 0 2
86280: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
86281: LD_INT 0
86283: PPUSH
86284: PPUSH
// if not units then
86285: LD_VAR 0 1
86289: NOT
86290: IFFALSE 86294
// exit ;
86292: GO 86364
// result := [ ] ;
86294: LD_ADDR_VAR 0 3
86298: PUSH
86299: EMPTY
86300: ST_TO_ADDR
// for i in units do
86301: LD_ADDR_VAR 0 4
86305: PUSH
86306: LD_VAR 0 1
86310: PUSH
86311: FOR_IN
86312: IFFALSE 86362
// if GetTag ( i ) = tag then
86314: LD_VAR 0 4
86318: PPUSH
86319: CALL_OW 110
86323: PUSH
86324: LD_VAR 0 2
86328: EQUAL
86329: IFFALSE 86360
// result := Replace ( result , result + 1 , i ) ;
86331: LD_ADDR_VAR 0 3
86335: PUSH
86336: LD_VAR 0 3
86340: PPUSH
86341: LD_VAR 0 3
86345: PUSH
86346: LD_INT 1
86348: PLUS
86349: PPUSH
86350: LD_VAR 0 4
86354: PPUSH
86355: CALL_OW 1
86359: ST_TO_ADDR
86360: GO 86311
86362: POP
86363: POP
// end ;
86364: LD_VAR 0 3
86368: RET
// export function IsDriver ( un ) ; begin
86369: LD_INT 0
86371: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86372: LD_ADDR_VAR 0 2
86376: PUSH
86377: LD_VAR 0 1
86381: PUSH
86382: LD_INT 55
86384: PUSH
86385: EMPTY
86386: LIST
86387: PPUSH
86388: CALL_OW 69
86392: IN
86393: ST_TO_ADDR
// end ;
86394: LD_VAR 0 2
86398: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86399: LD_INT 0
86401: PPUSH
86402: PPUSH
// list := [ ] ;
86403: LD_ADDR_VAR 0 5
86407: PUSH
86408: EMPTY
86409: ST_TO_ADDR
// case d of 0 :
86410: LD_VAR 0 3
86414: PUSH
86415: LD_INT 0
86417: DOUBLE
86418: EQUAL
86419: IFTRUE 86423
86421: GO 86556
86423: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86424: LD_ADDR_VAR 0 5
86428: PUSH
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 4
86436: MINUS
86437: PUSH
86438: LD_VAR 0 2
86442: PUSH
86443: LD_INT 4
86445: MINUS
86446: PUSH
86447: LD_INT 2
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: PUSH
86455: LD_VAR 0 1
86459: PUSH
86460: LD_INT 3
86462: MINUS
86463: PUSH
86464: LD_VAR 0 2
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: LIST
86476: PUSH
86477: LD_VAR 0 1
86481: PUSH
86482: LD_INT 4
86484: PLUS
86485: PUSH
86486: LD_VAR 0 2
86490: PUSH
86491: LD_INT 4
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 3
86506: PLUS
86507: PUSH
86508: LD_VAR 0 2
86512: PUSH
86513: LD_INT 3
86515: PLUS
86516: PUSH
86517: LD_INT 5
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: LIST
86524: PUSH
86525: LD_VAR 0 1
86529: PUSH
86530: LD_VAR 0 2
86534: PUSH
86535: LD_INT 4
86537: PLUS
86538: PUSH
86539: LD_INT 0
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: LIST
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: ST_TO_ADDR
// end ; 1 :
86554: GO 87254
86556: LD_INT 1
86558: DOUBLE
86559: EQUAL
86560: IFTRUE 86564
86562: GO 86697
86564: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86565: LD_ADDR_VAR 0 5
86569: PUSH
86570: LD_VAR 0 1
86574: PUSH
86575: LD_VAR 0 2
86579: PUSH
86580: LD_INT 4
86582: MINUS
86583: PUSH
86584: LD_INT 3
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: LIST
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_INT 3
86599: MINUS
86600: PUSH
86601: LD_VAR 0 2
86605: PUSH
86606: LD_INT 3
86608: MINUS
86609: PUSH
86610: LD_INT 2
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: LIST
86617: PUSH
86618: LD_VAR 0 1
86622: PUSH
86623: LD_INT 4
86625: MINUS
86626: PUSH
86627: LD_VAR 0 2
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: LIST
86639: PUSH
86640: LD_VAR 0 1
86644: PUSH
86645: LD_VAR 0 2
86649: PUSH
86650: LD_INT 3
86652: PLUS
86653: PUSH
86654: LD_INT 0
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: LIST
86661: PUSH
86662: LD_VAR 0 1
86666: PUSH
86667: LD_INT 4
86669: PLUS
86670: PUSH
86671: LD_VAR 0 2
86675: PUSH
86676: LD_INT 4
86678: PLUS
86679: PUSH
86680: LD_INT 5
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: LIST
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: ST_TO_ADDR
// end ; 2 :
86695: GO 87254
86697: LD_INT 2
86699: DOUBLE
86700: EQUAL
86701: IFTRUE 86705
86703: GO 86834
86705: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86706: LD_ADDR_VAR 0 5
86710: PUSH
86711: LD_VAR 0 1
86715: PUSH
86716: LD_VAR 0 2
86720: PUSH
86721: LD_INT 3
86723: MINUS
86724: PUSH
86725: LD_INT 3
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: LIST
86732: PUSH
86733: LD_VAR 0 1
86737: PUSH
86738: LD_INT 4
86740: PLUS
86741: PUSH
86742: LD_VAR 0 2
86746: PUSH
86747: LD_INT 4
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: LIST
86754: PUSH
86755: LD_VAR 0 1
86759: PUSH
86760: LD_VAR 0 2
86764: PUSH
86765: LD_INT 4
86767: PLUS
86768: PUSH
86769: LD_INT 0
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: LIST
86776: PUSH
86777: LD_VAR 0 1
86781: PUSH
86782: LD_INT 3
86784: MINUS
86785: PUSH
86786: LD_VAR 0 2
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: LIST
86798: PUSH
86799: LD_VAR 0 1
86803: PUSH
86804: LD_INT 4
86806: MINUS
86807: PUSH
86808: LD_VAR 0 2
86812: PUSH
86813: LD_INT 4
86815: MINUS
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: LIST
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: ST_TO_ADDR
// end ; 3 :
86832: GO 87254
86834: LD_INT 3
86836: DOUBLE
86837: EQUAL
86838: IFTRUE 86842
86840: GO 86975
86842: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86843: LD_ADDR_VAR 0 5
86847: PUSH
86848: LD_VAR 0 1
86852: PUSH
86853: LD_INT 3
86855: PLUS
86856: PUSH
86857: LD_VAR 0 2
86861: PUSH
86862: LD_INT 4
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: LIST
86869: PUSH
86870: LD_VAR 0 1
86874: PUSH
86875: LD_INT 4
86877: PLUS
86878: PUSH
86879: LD_VAR 0 2
86883: PUSH
86884: LD_INT 4
86886: PLUS
86887: PUSH
86888: LD_INT 5
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: LIST
86895: PUSH
86896: LD_VAR 0 1
86900: PUSH
86901: LD_INT 4
86903: MINUS
86904: PUSH
86905: LD_VAR 0 2
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: PUSH
86918: LD_VAR 0 1
86922: PUSH
86923: LD_VAR 0 2
86927: PUSH
86928: LD_INT 4
86930: MINUS
86931: PUSH
86932: LD_INT 3
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: LIST
86939: PUSH
86940: LD_VAR 0 1
86944: PUSH
86945: LD_INT 3
86947: MINUS
86948: PUSH
86949: LD_VAR 0 2
86953: PUSH
86954: LD_INT 3
86956: MINUS
86957: PUSH
86958: LD_INT 2
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: LIST
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: ST_TO_ADDR
// end ; 4 :
86973: GO 87254
86975: LD_INT 4
86977: DOUBLE
86978: EQUAL
86979: IFTRUE 86983
86981: GO 87116
86983: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86984: LD_ADDR_VAR 0 5
86988: PUSH
86989: LD_VAR 0 1
86993: PUSH
86994: LD_VAR 0 2
86998: PUSH
86999: LD_INT 4
87001: PLUS
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: PUSH
87011: LD_VAR 0 1
87015: PUSH
87016: LD_INT 3
87018: PLUS
87019: PUSH
87020: LD_VAR 0 2
87024: PUSH
87025: LD_INT 3
87027: PLUS
87028: PUSH
87029: LD_INT 5
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: LIST
87036: PUSH
87037: LD_VAR 0 1
87041: PUSH
87042: LD_INT 4
87044: PLUS
87045: PUSH
87046: LD_VAR 0 2
87050: PUSH
87051: LD_INT 4
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: LIST
87058: PUSH
87059: LD_VAR 0 1
87063: PUSH
87064: LD_VAR 0 2
87068: PUSH
87069: LD_INT 3
87071: MINUS
87072: PUSH
87073: LD_INT 3
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: LIST
87080: PUSH
87081: LD_VAR 0 1
87085: PUSH
87086: LD_INT 4
87088: MINUS
87089: PUSH
87090: LD_VAR 0 2
87094: PUSH
87095: LD_INT 4
87097: MINUS
87098: PUSH
87099: LD_INT 2
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: LIST
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: ST_TO_ADDR
// end ; 5 :
87114: GO 87254
87116: LD_INT 5
87118: DOUBLE
87119: EQUAL
87120: IFTRUE 87124
87122: GO 87253
87124: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87125: LD_ADDR_VAR 0 5
87129: PUSH
87130: LD_VAR 0 1
87134: PUSH
87135: LD_INT 4
87137: MINUS
87138: PUSH
87139: LD_VAR 0 2
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: LIST
87151: PUSH
87152: LD_VAR 0 1
87156: PUSH
87157: LD_VAR 0 2
87161: PUSH
87162: LD_INT 4
87164: MINUS
87165: PUSH
87166: LD_INT 3
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: PUSH
87174: LD_VAR 0 1
87178: PUSH
87179: LD_INT 4
87181: PLUS
87182: PUSH
87183: LD_VAR 0 2
87187: PUSH
87188: LD_INT 4
87190: PLUS
87191: PUSH
87192: LD_INT 5
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: LIST
87199: PUSH
87200: LD_VAR 0 1
87204: PUSH
87205: LD_INT 3
87207: PLUS
87208: PUSH
87209: LD_VAR 0 2
87213: PUSH
87214: LD_INT 4
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: LIST
87221: PUSH
87222: LD_VAR 0 1
87226: PUSH
87227: LD_VAR 0 2
87231: PUSH
87232: LD_INT 3
87234: PLUS
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: LIST
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: ST_TO_ADDR
// end ; end ;
87251: GO 87254
87253: POP
// result := list ;
87254: LD_ADDR_VAR 0 4
87258: PUSH
87259: LD_VAR 0 5
87263: ST_TO_ADDR
// end ;
87264: LD_VAR 0 4
87268: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87269: LD_INT 0
87271: PPUSH
87272: PPUSH
87273: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87274: LD_VAR 0 1
87278: NOT
87279: PUSH
87280: LD_VAR 0 2
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 3
87293: PUSH
87294: LD_INT 4
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: IN
87303: NOT
87304: OR
87305: IFFALSE 87309
// exit ;
87307: GO 87401
// tmp := [ ] ;
87309: LD_ADDR_VAR 0 5
87313: PUSH
87314: EMPTY
87315: ST_TO_ADDR
// for i in units do
87316: LD_ADDR_VAR 0 4
87320: PUSH
87321: LD_VAR 0 1
87325: PUSH
87326: FOR_IN
87327: IFFALSE 87370
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87329: LD_ADDR_VAR 0 5
87333: PUSH
87334: LD_VAR 0 5
87338: PPUSH
87339: LD_VAR 0 5
87343: PUSH
87344: LD_INT 1
87346: PLUS
87347: PPUSH
87348: LD_VAR 0 4
87352: PPUSH
87353: LD_VAR 0 2
87357: PPUSH
87358: CALL_OW 259
87362: PPUSH
87363: CALL_OW 2
87367: ST_TO_ADDR
87368: GO 87326
87370: POP
87371: POP
// if not tmp then
87372: LD_VAR 0 5
87376: NOT
87377: IFFALSE 87381
// exit ;
87379: GO 87401
// result := SortListByListDesc ( units , tmp ) ;
87381: LD_ADDR_VAR 0 3
87385: PUSH
87386: LD_VAR 0 1
87390: PPUSH
87391: LD_VAR 0 5
87395: PPUSH
87396: CALL_OW 77
87400: ST_TO_ADDR
// end ;
87401: LD_VAR 0 3
87405: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87406: LD_INT 0
87408: PPUSH
87409: PPUSH
87410: PPUSH
// result := false ;
87411: LD_ADDR_VAR 0 3
87415: PUSH
87416: LD_INT 0
87418: ST_TO_ADDR
// x := GetX ( building ) ;
87419: LD_ADDR_VAR 0 4
87423: PUSH
87424: LD_VAR 0 2
87428: PPUSH
87429: CALL_OW 250
87433: ST_TO_ADDR
// y := GetY ( building ) ;
87434: LD_ADDR_VAR 0 5
87438: PUSH
87439: LD_VAR 0 2
87443: PPUSH
87444: CALL_OW 251
87448: ST_TO_ADDR
// if not building or not x or not y then
87449: LD_VAR 0 2
87453: NOT
87454: PUSH
87455: LD_VAR 0 4
87459: NOT
87460: OR
87461: PUSH
87462: LD_VAR 0 5
87466: NOT
87467: OR
87468: IFFALSE 87472
// exit ;
87470: GO 87564
// if GetTaskList ( unit ) then
87472: LD_VAR 0 1
87476: PPUSH
87477: CALL_OW 437
87481: IFFALSE 87564
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87483: LD_STRING e
87485: PUSH
87486: LD_VAR 0 1
87490: PPUSH
87491: CALL_OW 437
87495: PUSH
87496: LD_INT 1
87498: ARRAY
87499: PUSH
87500: LD_INT 1
87502: ARRAY
87503: EQUAL
87504: PUSH
87505: LD_VAR 0 4
87509: PUSH
87510: LD_VAR 0 1
87514: PPUSH
87515: CALL_OW 437
87519: PUSH
87520: LD_INT 1
87522: ARRAY
87523: PUSH
87524: LD_INT 2
87526: ARRAY
87527: EQUAL
87528: AND
87529: PUSH
87530: LD_VAR 0 5
87534: PUSH
87535: LD_VAR 0 1
87539: PPUSH
87540: CALL_OW 437
87544: PUSH
87545: LD_INT 1
87547: ARRAY
87548: PUSH
87549: LD_INT 3
87551: ARRAY
87552: EQUAL
87553: AND
87554: IFFALSE 87564
// result := true end ;
87556: LD_ADDR_VAR 0 3
87560: PUSH
87561: LD_INT 1
87563: ST_TO_ADDR
// end ;
87564: LD_VAR 0 3
87568: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87569: LD_INT 0
87571: PPUSH
// result := false ;
87572: LD_ADDR_VAR 0 4
87576: PUSH
87577: LD_INT 0
87579: ST_TO_ADDR
// if GetTaskList ( unit ) then
87580: LD_VAR 0 1
87584: PPUSH
87585: CALL_OW 437
87589: IFFALSE 87672
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87591: LD_STRING M
87593: PUSH
87594: LD_VAR 0 1
87598: PPUSH
87599: CALL_OW 437
87603: PUSH
87604: LD_INT 1
87606: ARRAY
87607: PUSH
87608: LD_INT 1
87610: ARRAY
87611: EQUAL
87612: PUSH
87613: LD_VAR 0 2
87617: PUSH
87618: LD_VAR 0 1
87622: PPUSH
87623: CALL_OW 437
87627: PUSH
87628: LD_INT 1
87630: ARRAY
87631: PUSH
87632: LD_INT 2
87634: ARRAY
87635: EQUAL
87636: AND
87637: PUSH
87638: LD_VAR 0 3
87642: PUSH
87643: LD_VAR 0 1
87647: PPUSH
87648: CALL_OW 437
87652: PUSH
87653: LD_INT 1
87655: ARRAY
87656: PUSH
87657: LD_INT 3
87659: ARRAY
87660: EQUAL
87661: AND
87662: IFFALSE 87672
// result := true ;
87664: LD_ADDR_VAR 0 4
87668: PUSH
87669: LD_INT 1
87671: ST_TO_ADDR
// end ; end ;
87672: LD_VAR 0 4
87676: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87677: LD_INT 0
87679: PPUSH
87680: PPUSH
87681: PPUSH
87682: PPUSH
// if not unit or not area then
87683: LD_VAR 0 1
87687: NOT
87688: PUSH
87689: LD_VAR 0 2
87693: NOT
87694: OR
87695: IFFALSE 87699
// exit ;
87697: GO 87863
// tmp := AreaToList ( area , i ) ;
87699: LD_ADDR_VAR 0 6
87703: PUSH
87704: LD_VAR 0 2
87708: PPUSH
87709: LD_VAR 0 5
87713: PPUSH
87714: CALL_OW 517
87718: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87719: LD_ADDR_VAR 0 5
87723: PUSH
87724: DOUBLE
87725: LD_INT 1
87727: DEC
87728: ST_TO_ADDR
87729: LD_VAR 0 6
87733: PUSH
87734: LD_INT 1
87736: ARRAY
87737: PUSH
87738: FOR_TO
87739: IFFALSE 87861
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87741: LD_ADDR_VAR 0 7
87745: PUSH
87746: LD_VAR 0 6
87750: PUSH
87751: LD_INT 1
87753: ARRAY
87754: PUSH
87755: LD_VAR 0 5
87759: ARRAY
87760: PUSH
87761: LD_VAR 0 6
87765: PUSH
87766: LD_INT 2
87768: ARRAY
87769: PUSH
87770: LD_VAR 0 5
87774: ARRAY
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87780: LD_VAR 0 7
87784: PUSH
87785: LD_INT 1
87787: ARRAY
87788: PPUSH
87789: LD_VAR 0 7
87793: PUSH
87794: LD_INT 2
87796: ARRAY
87797: PPUSH
87798: CALL_OW 428
87802: PUSH
87803: LD_INT 0
87805: EQUAL
87806: IFFALSE 87859
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87808: LD_VAR 0 1
87812: PPUSH
87813: LD_VAR 0 7
87817: PUSH
87818: LD_INT 1
87820: ARRAY
87821: PPUSH
87822: LD_VAR 0 7
87826: PUSH
87827: LD_INT 2
87829: ARRAY
87830: PPUSH
87831: LD_VAR 0 3
87835: PPUSH
87836: CALL_OW 48
// result := IsPlaced ( unit ) ;
87840: LD_ADDR_VAR 0 4
87844: PUSH
87845: LD_VAR 0 1
87849: PPUSH
87850: CALL_OW 305
87854: ST_TO_ADDR
// exit ;
87855: POP
87856: POP
87857: GO 87863
// end ; end ;
87859: GO 87738
87861: POP
87862: POP
// end ;
87863: LD_VAR 0 4
87867: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87868: LD_INT 0
87870: PPUSH
87871: PPUSH
87872: PPUSH
// if not side or side > 8 then
87873: LD_VAR 0 1
87877: NOT
87878: PUSH
87879: LD_VAR 0 1
87883: PUSH
87884: LD_INT 8
87886: GREATER
87887: OR
87888: IFFALSE 87892
// exit ;
87890: GO 88079
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87892: LD_ADDR_VAR 0 4
87896: PUSH
87897: LD_INT 22
87899: PUSH
87900: LD_VAR 0 1
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 21
87911: PUSH
87912: LD_INT 3
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PPUSH
87923: CALL_OW 69
87927: ST_TO_ADDR
// if not tmp then
87928: LD_VAR 0 4
87932: NOT
87933: IFFALSE 87937
// exit ;
87935: GO 88079
// enable_addtolog := true ;
87937: LD_ADDR_OWVAR 81
87941: PUSH
87942: LD_INT 1
87944: ST_TO_ADDR
// AddToLog ( [ ) ;
87945: LD_STRING [
87947: PPUSH
87948: CALL_OW 561
// for i in tmp do
87952: LD_ADDR_VAR 0 3
87956: PUSH
87957: LD_VAR 0 4
87961: PUSH
87962: FOR_IN
87963: IFFALSE 88070
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87965: LD_STRING [
87967: PUSH
87968: LD_VAR 0 3
87972: PPUSH
87973: CALL_OW 266
87977: STR
87978: PUSH
87979: LD_STRING , 
87981: STR
87982: PUSH
87983: LD_VAR 0 3
87987: PPUSH
87988: CALL_OW 250
87992: STR
87993: PUSH
87994: LD_STRING , 
87996: STR
87997: PUSH
87998: LD_VAR 0 3
88002: PPUSH
88003: CALL_OW 251
88007: STR
88008: PUSH
88009: LD_STRING , 
88011: STR
88012: PUSH
88013: LD_VAR 0 3
88017: PPUSH
88018: CALL_OW 254
88022: STR
88023: PUSH
88024: LD_STRING , 
88026: STR
88027: PUSH
88028: LD_VAR 0 3
88032: PPUSH
88033: LD_INT 1
88035: PPUSH
88036: CALL_OW 268
88040: STR
88041: PUSH
88042: LD_STRING , 
88044: STR
88045: PUSH
88046: LD_VAR 0 3
88050: PPUSH
88051: LD_INT 2
88053: PPUSH
88054: CALL_OW 268
88058: STR
88059: PUSH
88060: LD_STRING ],
88062: STR
88063: PPUSH
88064: CALL_OW 561
// end ;
88068: GO 87962
88070: POP
88071: POP
// AddToLog ( ]; ) ;
88072: LD_STRING ];
88074: PPUSH
88075: CALL_OW 561
// end ;
88079: LD_VAR 0 2
88083: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88084: LD_INT 0
88086: PPUSH
88087: PPUSH
88088: PPUSH
88089: PPUSH
88090: PPUSH
// if not area or not rate or not max then
88091: LD_VAR 0 1
88095: NOT
88096: PUSH
88097: LD_VAR 0 2
88101: NOT
88102: OR
88103: PUSH
88104: LD_VAR 0 4
88108: NOT
88109: OR
88110: IFFALSE 88114
// exit ;
88112: GO 88306
// while 1 do
88114: LD_INT 1
88116: IFFALSE 88306
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88118: LD_ADDR_VAR 0 9
88122: PUSH
88123: LD_VAR 0 1
88127: PPUSH
88128: LD_INT 1
88130: PPUSH
88131: CALL_OW 287
88135: PUSH
88136: LD_INT 10
88138: MUL
88139: ST_TO_ADDR
// r := rate / 10 ;
88140: LD_ADDR_VAR 0 7
88144: PUSH
88145: LD_VAR 0 2
88149: PUSH
88150: LD_INT 10
88152: DIVREAL
88153: ST_TO_ADDR
// time := 1 1$00 ;
88154: LD_ADDR_VAR 0 8
88158: PUSH
88159: LD_INT 2100
88161: ST_TO_ADDR
// if amount < min then
88162: LD_VAR 0 9
88166: PUSH
88167: LD_VAR 0 3
88171: LESS
88172: IFFALSE 88190
// r := r * 2 else
88174: LD_ADDR_VAR 0 7
88178: PUSH
88179: LD_VAR 0 7
88183: PUSH
88184: LD_INT 2
88186: MUL
88187: ST_TO_ADDR
88188: GO 88216
// if amount > max then
88190: LD_VAR 0 9
88194: PUSH
88195: LD_VAR 0 4
88199: GREATER
88200: IFFALSE 88216
// r := r / 2 ;
88202: LD_ADDR_VAR 0 7
88206: PUSH
88207: LD_VAR 0 7
88211: PUSH
88212: LD_INT 2
88214: DIVREAL
88215: ST_TO_ADDR
// time := time / r ;
88216: LD_ADDR_VAR 0 8
88220: PUSH
88221: LD_VAR 0 8
88225: PUSH
88226: LD_VAR 0 7
88230: DIVREAL
88231: ST_TO_ADDR
// if time < 0 then
88232: LD_VAR 0 8
88236: PUSH
88237: LD_INT 0
88239: LESS
88240: IFFALSE 88257
// time := time * - 1 ;
88242: LD_ADDR_VAR 0 8
88246: PUSH
88247: LD_VAR 0 8
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: MUL
88256: ST_TO_ADDR
// wait ( time ) ;
88257: LD_VAR 0 8
88261: PPUSH
88262: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
88266: LD_INT 35
88268: PPUSH
88269: LD_INT 875
88271: PPUSH
88272: CALL_OW 12
88276: PPUSH
88277: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88281: LD_INT 1
88283: PPUSH
88284: LD_INT 5
88286: PPUSH
88287: CALL_OW 12
88291: PPUSH
88292: LD_VAR 0 1
88296: PPUSH
88297: LD_INT 1
88299: PPUSH
88300: CALL_OW 55
// end ;
88304: GO 88114
// end ;
88306: LD_VAR 0 5
88310: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88311: LD_INT 0
88313: PPUSH
88314: PPUSH
88315: PPUSH
88316: PPUSH
88317: PPUSH
88318: PPUSH
88319: PPUSH
88320: PPUSH
// if not turrets or not factories then
88321: LD_VAR 0 1
88325: NOT
88326: PUSH
88327: LD_VAR 0 2
88331: NOT
88332: OR
88333: IFFALSE 88337
// exit ;
88335: GO 88644
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88337: LD_ADDR_VAR 0 10
88341: PUSH
88342: LD_INT 5
88344: PUSH
88345: LD_INT 6
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 2
88354: PUSH
88355: LD_INT 4
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 3
88364: PUSH
88365: LD_INT 5
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 24
88379: PUSH
88380: LD_INT 25
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 23
88389: PUSH
88390: LD_INT 27
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 42
88403: PUSH
88404: LD_INT 43
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 44
88413: PUSH
88414: LD_INT 46
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 45
88423: PUSH
88424: LD_INT 47
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: LIST
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: LIST
88440: ST_TO_ADDR
// result := [ ] ;
88441: LD_ADDR_VAR 0 3
88445: PUSH
88446: EMPTY
88447: ST_TO_ADDR
// for i in turrets do
88448: LD_ADDR_VAR 0 4
88452: PUSH
88453: LD_VAR 0 1
88457: PUSH
88458: FOR_IN
88459: IFFALSE 88642
// begin nat := GetNation ( i ) ;
88461: LD_ADDR_VAR 0 7
88465: PUSH
88466: LD_VAR 0 4
88470: PPUSH
88471: CALL_OW 248
88475: ST_TO_ADDR
// weapon := 0 ;
88476: LD_ADDR_VAR 0 8
88480: PUSH
88481: LD_INT 0
88483: ST_TO_ADDR
// if not nat then
88484: LD_VAR 0 7
88488: NOT
88489: IFFALSE 88493
// continue ;
88491: GO 88458
// for j in list [ nat ] do
88493: LD_ADDR_VAR 0 5
88497: PUSH
88498: LD_VAR 0 10
88502: PUSH
88503: LD_VAR 0 7
88507: ARRAY
88508: PUSH
88509: FOR_IN
88510: IFFALSE 88551
// if GetBWeapon ( i ) = j [ 1 ] then
88512: LD_VAR 0 4
88516: PPUSH
88517: CALL_OW 269
88521: PUSH
88522: LD_VAR 0 5
88526: PUSH
88527: LD_INT 1
88529: ARRAY
88530: EQUAL
88531: IFFALSE 88549
// begin weapon := j [ 2 ] ;
88533: LD_ADDR_VAR 0 8
88537: PUSH
88538: LD_VAR 0 5
88542: PUSH
88543: LD_INT 2
88545: ARRAY
88546: ST_TO_ADDR
// break ;
88547: GO 88551
// end ;
88549: GO 88509
88551: POP
88552: POP
// if not weapon then
88553: LD_VAR 0 8
88557: NOT
88558: IFFALSE 88562
// continue ;
88560: GO 88458
// for k in factories do
88562: LD_ADDR_VAR 0 6
88566: PUSH
88567: LD_VAR 0 2
88571: PUSH
88572: FOR_IN
88573: IFFALSE 88638
// begin weapons := AvailableWeaponList ( k ) ;
88575: LD_ADDR_VAR 0 9
88579: PUSH
88580: LD_VAR 0 6
88584: PPUSH
88585: CALL_OW 478
88589: ST_TO_ADDR
// if not weapons then
88590: LD_VAR 0 9
88594: NOT
88595: IFFALSE 88599
// continue ;
88597: GO 88572
// if weapon in weapons then
88599: LD_VAR 0 8
88603: PUSH
88604: LD_VAR 0 9
88608: IN
88609: IFFALSE 88636
// begin result := [ i , weapon ] ;
88611: LD_ADDR_VAR 0 3
88615: PUSH
88616: LD_VAR 0 4
88620: PUSH
88621: LD_VAR 0 8
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: ST_TO_ADDR
// exit ;
88630: POP
88631: POP
88632: POP
88633: POP
88634: GO 88644
// end ; end ;
88636: GO 88572
88638: POP
88639: POP
// end ;
88640: GO 88458
88642: POP
88643: POP
// end ;
88644: LD_VAR 0 3
88648: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88649: LD_INT 0
88651: PPUSH
// if not side or side > 8 then
88652: LD_VAR 0 3
88656: NOT
88657: PUSH
88658: LD_VAR 0 3
88662: PUSH
88663: LD_INT 8
88665: GREATER
88666: OR
88667: IFFALSE 88671
// exit ;
88669: GO 88730
// if not range then
88671: LD_VAR 0 4
88675: NOT
88676: IFFALSE 88687
// range := - 12 ;
88678: LD_ADDR_VAR 0 4
88682: PUSH
88683: LD_INT 12
88685: NEG
88686: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88687: LD_VAR 0 1
88691: PPUSH
88692: LD_VAR 0 2
88696: PPUSH
88697: LD_VAR 0 3
88701: PPUSH
88702: LD_VAR 0 4
88706: PPUSH
88707: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88711: LD_VAR 0 1
88715: PPUSH
88716: LD_VAR 0 2
88720: PPUSH
88721: LD_VAR 0 3
88725: PPUSH
88726: CALL_OW 331
// end ;
88730: LD_VAR 0 5
88734: RET
// export function Video ( mode ) ; begin
88735: LD_INT 0
88737: PPUSH
// ingame_video = mode ;
88738: LD_ADDR_OWVAR 52
88742: PUSH
88743: LD_VAR 0 1
88747: ST_TO_ADDR
// interface_hidden = mode ;
88748: LD_ADDR_OWVAR 54
88752: PUSH
88753: LD_VAR 0 1
88757: ST_TO_ADDR
// end ;
88758: LD_VAR 0 2
88762: RET
// export function Join ( array , element ) ; begin
88763: LD_INT 0
88765: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88766: LD_ADDR_VAR 0 3
88770: PUSH
88771: LD_VAR 0 1
88775: PPUSH
88776: LD_VAR 0 1
88780: PUSH
88781: LD_INT 1
88783: PLUS
88784: PPUSH
88785: LD_VAR 0 2
88789: PPUSH
88790: CALL_OW 1
88794: ST_TO_ADDR
// end ;
88795: LD_VAR 0 3
88799: RET
// export function JoinUnion ( array , element ) ; begin
88800: LD_INT 0
88802: PPUSH
// result := array union element ;
88803: LD_ADDR_VAR 0 3
88807: PUSH
88808: LD_VAR 0 1
88812: PUSH
88813: LD_VAR 0 2
88817: UNION
88818: ST_TO_ADDR
// end ;
88819: LD_VAR 0 3
88823: RET
// export function GetBehemoths ( side ) ; begin
88824: LD_INT 0
88826: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88827: LD_ADDR_VAR 0 2
88831: PUSH
88832: LD_INT 22
88834: PUSH
88835: LD_VAR 0 1
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 31
88846: PUSH
88847: LD_INT 25
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PPUSH
88858: CALL_OW 69
88862: ST_TO_ADDR
// end ;
88863: LD_VAR 0 2
88867: RET
// export function Shuffle ( array ) ; var i , index ; begin
88868: LD_INT 0
88870: PPUSH
88871: PPUSH
88872: PPUSH
// result := [ ] ;
88873: LD_ADDR_VAR 0 2
88877: PUSH
88878: EMPTY
88879: ST_TO_ADDR
// if not array then
88880: LD_VAR 0 1
88884: NOT
88885: IFFALSE 88889
// exit ;
88887: GO 88988
// Randomize ;
88889: CALL_OW 10
// for i = array downto 1 do
88893: LD_ADDR_VAR 0 3
88897: PUSH
88898: DOUBLE
88899: LD_VAR 0 1
88903: INC
88904: ST_TO_ADDR
88905: LD_INT 1
88907: PUSH
88908: FOR_DOWNTO
88909: IFFALSE 88986
// begin index := rand ( 1 , array ) ;
88911: LD_ADDR_VAR 0 4
88915: PUSH
88916: LD_INT 1
88918: PPUSH
88919: LD_VAR 0 1
88923: PPUSH
88924: CALL_OW 12
88928: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88929: LD_ADDR_VAR 0 2
88933: PUSH
88934: LD_VAR 0 2
88938: PPUSH
88939: LD_VAR 0 2
88943: PUSH
88944: LD_INT 1
88946: PLUS
88947: PPUSH
88948: LD_VAR 0 1
88952: PUSH
88953: LD_VAR 0 4
88957: ARRAY
88958: PPUSH
88959: CALL_OW 2
88963: ST_TO_ADDR
// array := Delete ( array , index ) ;
88964: LD_ADDR_VAR 0 1
88968: PUSH
88969: LD_VAR 0 1
88973: PPUSH
88974: LD_VAR 0 4
88978: PPUSH
88979: CALL_OW 3
88983: ST_TO_ADDR
// end ;
88984: GO 88908
88986: POP
88987: POP
// end ;
88988: LD_VAR 0 2
88992: RET
// export function GetBaseMaterials ( base ) ; begin
88993: LD_INT 0
88995: PPUSH
// result := [ 0 , 0 , 0 ] ;
88996: LD_ADDR_VAR 0 2
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: LIST
89014: ST_TO_ADDR
// if not base then
89015: LD_VAR 0 1
89019: NOT
89020: IFFALSE 89024
// exit ;
89022: GO 89073
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89024: LD_ADDR_VAR 0 2
89028: PUSH
89029: LD_VAR 0 1
89033: PPUSH
89034: LD_INT 1
89036: PPUSH
89037: CALL_OW 275
89041: PUSH
89042: LD_VAR 0 1
89046: PPUSH
89047: LD_INT 2
89049: PPUSH
89050: CALL_OW 275
89054: PUSH
89055: LD_VAR 0 1
89059: PPUSH
89060: LD_INT 3
89062: PPUSH
89063: CALL_OW 275
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: LIST
89072: ST_TO_ADDR
// end ;
89073: LD_VAR 0 2
89077: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89078: LD_INT 0
89080: PPUSH
89081: PPUSH
// result := array ;
89082: LD_ADDR_VAR 0 3
89086: PUSH
89087: LD_VAR 0 1
89091: ST_TO_ADDR
// if size > 0 then
89092: LD_VAR 0 2
89096: PUSH
89097: LD_INT 0
89099: GREATER
89100: IFFALSE 89146
// for i := array downto size do
89102: LD_ADDR_VAR 0 4
89106: PUSH
89107: DOUBLE
89108: LD_VAR 0 1
89112: INC
89113: ST_TO_ADDR
89114: LD_VAR 0 2
89118: PUSH
89119: FOR_DOWNTO
89120: IFFALSE 89144
// result := Delete ( result , result ) ;
89122: LD_ADDR_VAR 0 3
89126: PUSH
89127: LD_VAR 0 3
89131: PPUSH
89132: LD_VAR 0 3
89136: PPUSH
89137: CALL_OW 3
89141: ST_TO_ADDR
89142: GO 89119
89144: POP
89145: POP
// end ;
89146: LD_VAR 0 3
89150: RET
// export function ComExit ( unit ) ; var tmp ; begin
89151: LD_INT 0
89153: PPUSH
89154: PPUSH
// if not IsInUnit ( unit ) then
89155: LD_VAR 0 1
89159: PPUSH
89160: CALL_OW 310
89164: NOT
89165: IFFALSE 89169
// exit ;
89167: GO 89229
// tmp := IsInUnit ( unit ) ;
89169: LD_ADDR_VAR 0 3
89173: PUSH
89174: LD_VAR 0 1
89178: PPUSH
89179: CALL_OW 310
89183: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89184: LD_VAR 0 3
89188: PPUSH
89189: CALL_OW 247
89193: PUSH
89194: LD_INT 2
89196: EQUAL
89197: IFFALSE 89210
// ComExitVehicle ( unit ) else
89199: LD_VAR 0 1
89203: PPUSH
89204: CALL_OW 121
89208: GO 89219
// ComExitBuilding ( unit ) ;
89210: LD_VAR 0 1
89214: PPUSH
89215: CALL_OW 122
// result := tmp ;
89219: LD_ADDR_VAR 0 2
89223: PUSH
89224: LD_VAR 0 3
89228: ST_TO_ADDR
// end ;
89229: LD_VAR 0 2
89233: RET
// export function ComExitAll ( units ) ; var i ; begin
89234: LD_INT 0
89236: PPUSH
89237: PPUSH
// if not units then
89238: LD_VAR 0 1
89242: NOT
89243: IFFALSE 89247
// exit ;
89245: GO 89273
// for i in units do
89247: LD_ADDR_VAR 0 3
89251: PUSH
89252: LD_VAR 0 1
89256: PUSH
89257: FOR_IN
89258: IFFALSE 89271
// ComExit ( i ) ;
89260: LD_VAR 0 3
89264: PPUSH
89265: CALL 89151 0 1
89269: GO 89257
89271: POP
89272: POP
// end ;
89273: LD_VAR 0 2
89277: RET
// export function ResetHc ; begin
89278: LD_INT 0
89280: PPUSH
// InitHc ;
89281: CALL_OW 19
// hc_importance := 0 ;
89285: LD_ADDR_OWVAR 32
89289: PUSH
89290: LD_INT 0
89292: ST_TO_ADDR
// end ;
89293: LD_VAR 0 1
89297: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89298: LD_INT 0
89300: PPUSH
89301: PPUSH
89302: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89303: LD_ADDR_VAR 0 6
89307: PUSH
89308: LD_VAR 0 1
89312: PUSH
89313: LD_VAR 0 3
89317: PLUS
89318: PUSH
89319: LD_INT 2
89321: DIV
89322: ST_TO_ADDR
// if _x < 0 then
89323: LD_VAR 0 6
89327: PUSH
89328: LD_INT 0
89330: LESS
89331: IFFALSE 89348
// _x := _x * - 1 ;
89333: LD_ADDR_VAR 0 6
89337: PUSH
89338: LD_VAR 0 6
89342: PUSH
89343: LD_INT 1
89345: NEG
89346: MUL
89347: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89348: LD_ADDR_VAR 0 7
89352: PUSH
89353: LD_VAR 0 2
89357: PUSH
89358: LD_VAR 0 4
89362: PLUS
89363: PUSH
89364: LD_INT 2
89366: DIV
89367: ST_TO_ADDR
// if _y < 0 then
89368: LD_VAR 0 7
89372: PUSH
89373: LD_INT 0
89375: LESS
89376: IFFALSE 89393
// _y := _y * - 1 ;
89378: LD_ADDR_VAR 0 7
89382: PUSH
89383: LD_VAR 0 7
89387: PUSH
89388: LD_INT 1
89390: NEG
89391: MUL
89392: ST_TO_ADDR
// result := [ _x , _y ] ;
89393: LD_ADDR_VAR 0 5
89397: PUSH
89398: LD_VAR 0 6
89402: PUSH
89403: LD_VAR 0 7
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: ST_TO_ADDR
// end ;
89412: LD_VAR 0 5
89416: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89417: LD_INT 0
89419: PPUSH
89420: PPUSH
89421: PPUSH
89422: PPUSH
// task := GetTaskList ( unit ) ;
89423: LD_ADDR_VAR 0 7
89427: PUSH
89428: LD_VAR 0 1
89432: PPUSH
89433: CALL_OW 437
89437: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89438: LD_VAR 0 7
89442: NOT
89443: PUSH
89444: LD_VAR 0 1
89448: PPUSH
89449: LD_VAR 0 2
89453: PPUSH
89454: CALL_OW 308
89458: NOT
89459: AND
89460: IFFALSE 89464
// exit ;
89462: GO 89582
// if IsInArea ( unit , area ) then
89464: LD_VAR 0 1
89468: PPUSH
89469: LD_VAR 0 2
89473: PPUSH
89474: CALL_OW 308
89478: IFFALSE 89496
// begin ComMoveToArea ( unit , goAway ) ;
89480: LD_VAR 0 1
89484: PPUSH
89485: LD_VAR 0 3
89489: PPUSH
89490: CALL_OW 113
// exit ;
89494: GO 89582
// end ; if task [ 1 ] [ 1 ] <> M then
89496: LD_VAR 0 7
89500: PUSH
89501: LD_INT 1
89503: ARRAY
89504: PUSH
89505: LD_INT 1
89507: ARRAY
89508: PUSH
89509: LD_STRING M
89511: NONEQUAL
89512: IFFALSE 89516
// exit ;
89514: GO 89582
// x := task [ 1 ] [ 2 ] ;
89516: LD_ADDR_VAR 0 5
89520: PUSH
89521: LD_VAR 0 7
89525: PUSH
89526: LD_INT 1
89528: ARRAY
89529: PUSH
89530: LD_INT 2
89532: ARRAY
89533: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
89534: LD_ADDR_VAR 0 6
89538: PUSH
89539: LD_VAR 0 7
89543: PUSH
89544: LD_INT 1
89546: ARRAY
89547: PUSH
89548: LD_INT 3
89550: ARRAY
89551: ST_TO_ADDR
// if InArea ( x , y , area ) then
89552: LD_VAR 0 5
89556: PPUSH
89557: LD_VAR 0 6
89561: PPUSH
89562: LD_VAR 0 2
89566: PPUSH
89567: CALL_OW 309
89571: IFFALSE 89582
// ComStop ( unit ) ;
89573: LD_VAR 0 1
89577: PPUSH
89578: CALL_OW 141
// end ;
89582: LD_VAR 0 4
89586: RET
// export function Abs ( value ) ; begin
89587: LD_INT 0
89589: PPUSH
// result := value ;
89590: LD_ADDR_VAR 0 2
89594: PUSH
89595: LD_VAR 0 1
89599: ST_TO_ADDR
// if value < 0 then
89600: LD_VAR 0 1
89604: PUSH
89605: LD_INT 0
89607: LESS
89608: IFFALSE 89625
// result := value * - 1 ;
89610: LD_ADDR_VAR 0 2
89614: PUSH
89615: LD_VAR 0 1
89619: PUSH
89620: LD_INT 1
89622: NEG
89623: MUL
89624: ST_TO_ADDR
// end ;
89625: LD_VAR 0 2
89629: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89630: LD_INT 0
89632: PPUSH
89633: PPUSH
89634: PPUSH
89635: PPUSH
89636: PPUSH
89637: PPUSH
89638: PPUSH
89639: PPUSH
// if not unit or not building then
89640: LD_VAR 0 1
89644: NOT
89645: PUSH
89646: LD_VAR 0 2
89650: NOT
89651: OR
89652: IFFALSE 89656
// exit ;
89654: GO 89882
// x := GetX ( building ) ;
89656: LD_ADDR_VAR 0 4
89660: PUSH
89661: LD_VAR 0 2
89665: PPUSH
89666: CALL_OW 250
89670: ST_TO_ADDR
// y := GetY ( building ) ;
89671: LD_ADDR_VAR 0 6
89675: PUSH
89676: LD_VAR 0 2
89680: PPUSH
89681: CALL_OW 251
89685: ST_TO_ADDR
// d := GetDir ( building ) ;
89686: LD_ADDR_VAR 0 8
89690: PUSH
89691: LD_VAR 0 2
89695: PPUSH
89696: CALL_OW 254
89700: ST_TO_ADDR
// r := 4 ;
89701: LD_ADDR_VAR 0 9
89705: PUSH
89706: LD_INT 4
89708: ST_TO_ADDR
// for i := 1 to 5 do
89709: LD_ADDR_VAR 0 10
89713: PUSH
89714: DOUBLE
89715: LD_INT 1
89717: DEC
89718: ST_TO_ADDR
89719: LD_INT 5
89721: PUSH
89722: FOR_TO
89723: IFFALSE 89880
// begin _x := ShiftX ( x , d , r + i ) ;
89725: LD_ADDR_VAR 0 5
89729: PUSH
89730: LD_VAR 0 4
89734: PPUSH
89735: LD_VAR 0 8
89739: PPUSH
89740: LD_VAR 0 9
89744: PUSH
89745: LD_VAR 0 10
89749: PLUS
89750: PPUSH
89751: CALL_OW 272
89755: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89756: LD_ADDR_VAR 0 7
89760: PUSH
89761: LD_VAR 0 6
89765: PPUSH
89766: LD_VAR 0 8
89770: PPUSH
89771: LD_VAR 0 9
89775: PUSH
89776: LD_VAR 0 10
89780: PLUS
89781: PPUSH
89782: CALL_OW 273
89786: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89787: LD_VAR 0 5
89791: PPUSH
89792: LD_VAR 0 7
89796: PPUSH
89797: CALL_OW 488
89801: PUSH
89802: LD_VAR 0 5
89806: PPUSH
89807: LD_VAR 0 7
89811: PPUSH
89812: CALL_OW 428
89816: PPUSH
89817: CALL_OW 247
89821: PUSH
89822: LD_INT 3
89824: PUSH
89825: LD_INT 2
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: IN
89832: NOT
89833: AND
89834: IFFALSE 89878
// begin ComMoveXY ( unit , _x , _y ) ;
89836: LD_VAR 0 1
89840: PPUSH
89841: LD_VAR 0 5
89845: PPUSH
89846: LD_VAR 0 7
89850: PPUSH
89851: CALL_OW 111
// result := [ _x , _y ] ;
89855: LD_ADDR_VAR 0 3
89859: PUSH
89860: LD_VAR 0 5
89864: PUSH
89865: LD_VAR 0 7
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: ST_TO_ADDR
// exit ;
89874: POP
89875: POP
89876: GO 89882
// end ; end ;
89878: GO 89722
89880: POP
89881: POP
// end ;
89882: LD_VAR 0 3
89886: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89887: LD_INT 0
89889: PPUSH
89890: PPUSH
89891: PPUSH
// result := 0 ;
89892: LD_ADDR_VAR 0 3
89896: PUSH
89897: LD_INT 0
89899: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89900: LD_VAR 0 1
89904: PUSH
89905: LD_INT 0
89907: LESS
89908: PUSH
89909: LD_VAR 0 1
89913: PUSH
89914: LD_INT 8
89916: GREATER
89917: OR
89918: PUSH
89919: LD_VAR 0 2
89923: PUSH
89924: LD_INT 0
89926: LESS
89927: OR
89928: PUSH
89929: LD_VAR 0 2
89933: PUSH
89934: LD_INT 8
89936: GREATER
89937: OR
89938: IFFALSE 89942
// exit ;
89940: GO 90017
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89942: LD_ADDR_VAR 0 4
89946: PUSH
89947: LD_INT 22
89949: PUSH
89950: LD_VAR 0 2
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PPUSH
89959: CALL_OW 69
89963: PUSH
89964: FOR_IN
89965: IFFALSE 90015
// begin un := UnitShoot ( i ) ;
89967: LD_ADDR_VAR 0 5
89971: PUSH
89972: LD_VAR 0 4
89976: PPUSH
89977: CALL_OW 504
89981: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89982: LD_VAR 0 5
89986: PPUSH
89987: CALL_OW 255
89991: PUSH
89992: LD_VAR 0 1
89996: EQUAL
89997: IFFALSE 90013
// begin result := un ;
89999: LD_ADDR_VAR 0 3
90003: PUSH
90004: LD_VAR 0 5
90008: ST_TO_ADDR
// exit ;
90009: POP
90010: POP
90011: GO 90017
// end ; end ;
90013: GO 89964
90015: POP
90016: POP
// end ;
90017: LD_VAR 0 3
90021: RET
// export function GetCargoBay ( units ) ; begin
90022: LD_INT 0
90024: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90025: LD_ADDR_VAR 0 2
90029: PUSH
90030: LD_VAR 0 1
90034: PPUSH
90035: LD_INT 2
90037: PUSH
90038: LD_INT 34
90040: PUSH
90041: LD_INT 12
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 34
90050: PUSH
90051: LD_INT 51
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 34
90060: PUSH
90061: LD_INT 32
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 34
90070: PUSH
90071: LD_EXP 75
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: PPUSH
90087: CALL_OW 72
90091: ST_TO_ADDR
// end ;
90092: LD_VAR 0 2
90096: RET
// export function Negate ( value ) ; begin
90097: LD_INT 0
90099: PPUSH
// result := not value ;
90100: LD_ADDR_VAR 0 2
90104: PUSH
90105: LD_VAR 0 1
90109: NOT
90110: ST_TO_ADDR
// end ;
90111: LD_VAR 0 2
90115: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90116: LD_INT 0
90118: PPUSH
90119: PPUSH
90120: PPUSH
90121: PPUSH
90122: PPUSH
90123: PPUSH
90124: PPUSH
90125: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90126: LD_VAR 0 1
90130: PPUSH
90131: LD_VAR 0 2
90135: PPUSH
90136: CALL_OW 488
90140: NOT
90141: PUSH
90142: LD_VAR 0 3
90146: PPUSH
90147: LD_VAR 0 4
90151: PPUSH
90152: CALL_OW 488
90156: NOT
90157: OR
90158: IFFALSE 90171
// begin result := - 1 ;
90160: LD_ADDR_VAR 0 5
90164: PUSH
90165: LD_INT 1
90167: NEG
90168: ST_TO_ADDR
// exit ;
90169: GO 90406
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90171: LD_ADDR_VAR 0 12
90175: PUSH
90176: LD_VAR 0 1
90180: PPUSH
90181: LD_VAR 0 2
90185: PPUSH
90186: LD_VAR 0 3
90190: PPUSH
90191: LD_VAR 0 4
90195: PPUSH
90196: CALL 89298 0 4
90200: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90201: LD_ADDR_VAR 0 11
90205: PUSH
90206: LD_VAR 0 1
90210: PPUSH
90211: LD_VAR 0 2
90215: PPUSH
90216: LD_VAR 0 12
90220: PUSH
90221: LD_INT 1
90223: ARRAY
90224: PPUSH
90225: LD_VAR 0 12
90229: PUSH
90230: LD_INT 2
90232: ARRAY
90233: PPUSH
90234: CALL_OW 298
90238: ST_TO_ADDR
// distance := 9999 ;
90239: LD_ADDR_VAR 0 10
90243: PUSH
90244: LD_INT 9999
90246: ST_TO_ADDR
// for i := 0 to 5 do
90247: LD_ADDR_VAR 0 6
90251: PUSH
90252: DOUBLE
90253: LD_INT 0
90255: DEC
90256: ST_TO_ADDR
90257: LD_INT 5
90259: PUSH
90260: FOR_TO
90261: IFFALSE 90404
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90263: LD_ADDR_VAR 0 7
90267: PUSH
90268: LD_VAR 0 1
90272: PPUSH
90273: LD_VAR 0 6
90277: PPUSH
90278: LD_VAR 0 11
90282: PPUSH
90283: CALL_OW 272
90287: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90288: LD_ADDR_VAR 0 8
90292: PUSH
90293: LD_VAR 0 2
90297: PPUSH
90298: LD_VAR 0 6
90302: PPUSH
90303: LD_VAR 0 11
90307: PPUSH
90308: CALL_OW 273
90312: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90313: LD_VAR 0 7
90317: PPUSH
90318: LD_VAR 0 8
90322: PPUSH
90323: CALL_OW 488
90327: NOT
90328: IFFALSE 90332
// continue ;
90330: GO 90260
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90332: LD_ADDR_VAR 0 9
90336: PUSH
90337: LD_VAR 0 12
90341: PUSH
90342: LD_INT 1
90344: ARRAY
90345: PPUSH
90346: LD_VAR 0 12
90350: PUSH
90351: LD_INT 2
90353: ARRAY
90354: PPUSH
90355: LD_VAR 0 7
90359: PPUSH
90360: LD_VAR 0 8
90364: PPUSH
90365: CALL_OW 298
90369: ST_TO_ADDR
// if tmp < distance then
90370: LD_VAR 0 9
90374: PUSH
90375: LD_VAR 0 10
90379: LESS
90380: IFFALSE 90402
// begin result := i ;
90382: LD_ADDR_VAR 0 5
90386: PUSH
90387: LD_VAR 0 6
90391: ST_TO_ADDR
// distance := tmp ;
90392: LD_ADDR_VAR 0 10
90396: PUSH
90397: LD_VAR 0 9
90401: ST_TO_ADDR
// end ; end ;
90402: GO 90260
90404: POP
90405: POP
// end ;
90406: LD_VAR 0 5
90410: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90411: LD_INT 0
90413: PPUSH
90414: PPUSH
// if not driver or not IsInUnit ( driver ) then
90415: LD_VAR 0 1
90419: NOT
90420: PUSH
90421: LD_VAR 0 1
90425: PPUSH
90426: CALL_OW 310
90430: NOT
90431: OR
90432: IFFALSE 90436
// exit ;
90434: GO 90526
// vehicle := IsInUnit ( driver ) ;
90436: LD_ADDR_VAR 0 3
90440: PUSH
90441: LD_VAR 0 1
90445: PPUSH
90446: CALL_OW 310
90450: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90451: LD_VAR 0 1
90455: PPUSH
90456: LD_STRING \
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: LD_INT 0
90467: PUSH
90468: LD_INT 0
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: LD_INT 0
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: PUSH
90486: LD_STRING E
90488: PUSH
90489: LD_INT 0
90491: PUSH
90492: LD_INT 0
90494: PUSH
90495: LD_VAR 0 3
90499: PUSH
90500: LD_INT 0
90502: PUSH
90503: LD_INT 0
90505: PUSH
90506: LD_INT 0
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PPUSH
90522: CALL_OW 446
// end ;
90526: LD_VAR 0 2
90530: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90531: LD_INT 0
90533: PPUSH
90534: PPUSH
// if not driver or not IsInUnit ( driver ) then
90535: LD_VAR 0 1
90539: NOT
90540: PUSH
90541: LD_VAR 0 1
90545: PPUSH
90546: CALL_OW 310
90550: NOT
90551: OR
90552: IFFALSE 90556
// exit ;
90554: GO 90646
// vehicle := IsInUnit ( driver ) ;
90556: LD_ADDR_VAR 0 3
90560: PUSH
90561: LD_VAR 0 1
90565: PPUSH
90566: CALL_OW 310
90570: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90571: LD_VAR 0 1
90575: PPUSH
90576: LD_STRING \
90578: PUSH
90579: LD_INT 0
90581: PUSH
90582: LD_INT 0
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: LD_INT 0
90590: PUSH
90591: LD_INT 0
90593: PUSH
90594: LD_INT 0
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: PUSH
90606: LD_STRING E
90608: PUSH
90609: LD_INT 0
90611: PUSH
90612: LD_INT 0
90614: PUSH
90615: LD_VAR 0 3
90619: PUSH
90620: LD_INT 0
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PPUSH
90642: CALL_OW 447
// end ;
90646: LD_VAR 0 2
90650: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
90651: LD_INT 0
90653: PPUSH
90654: PPUSH
90655: PPUSH
// tmp := [ ] ;
90656: LD_ADDR_VAR 0 5
90660: PUSH
90661: EMPTY
90662: ST_TO_ADDR
// for i in units do
90663: LD_ADDR_VAR 0 4
90667: PUSH
90668: LD_VAR 0 1
90672: PUSH
90673: FOR_IN
90674: IFFALSE 90712
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
90676: LD_ADDR_VAR 0 5
90680: PUSH
90681: LD_VAR 0 5
90685: PPUSH
90686: LD_VAR 0 5
90690: PUSH
90691: LD_INT 1
90693: PLUS
90694: PPUSH
90695: LD_VAR 0 4
90699: PPUSH
90700: CALL_OW 256
90704: PPUSH
90705: CALL_OW 2
90709: ST_TO_ADDR
90710: GO 90673
90712: POP
90713: POP
// if not tmp then
90714: LD_VAR 0 5
90718: NOT
90719: IFFALSE 90723
// exit ;
90721: GO 90771
// if asc then
90723: LD_VAR 0 2
90727: IFFALSE 90751
// result := SortListByListAsc ( units , tmp ) else
90729: LD_ADDR_VAR 0 3
90733: PUSH
90734: LD_VAR 0 1
90738: PPUSH
90739: LD_VAR 0 5
90743: PPUSH
90744: CALL_OW 76
90748: ST_TO_ADDR
90749: GO 90771
// result := SortListByListDesc ( units , tmp ) ;
90751: LD_ADDR_VAR 0 3
90755: PUSH
90756: LD_VAR 0 1
90760: PPUSH
90761: LD_VAR 0 5
90765: PPUSH
90766: CALL_OW 77
90770: ST_TO_ADDR
// end ;
90771: LD_VAR 0 3
90775: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90776: LD_INT 0
90778: PPUSH
90779: PPUSH
// task := GetTaskList ( mech ) ;
90780: LD_ADDR_VAR 0 4
90784: PUSH
90785: LD_VAR 0 1
90789: PPUSH
90790: CALL_OW 437
90794: ST_TO_ADDR
// if not task then
90795: LD_VAR 0 4
90799: NOT
90800: IFFALSE 90804
// exit ;
90802: GO 90846
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90804: LD_ADDR_VAR 0 3
90808: PUSH
90809: LD_VAR 0 4
90813: PUSH
90814: LD_INT 1
90816: ARRAY
90817: PUSH
90818: LD_INT 1
90820: ARRAY
90821: PUSH
90822: LD_STRING r
90824: EQUAL
90825: PUSH
90826: LD_VAR 0 4
90830: PUSH
90831: LD_INT 1
90833: ARRAY
90834: PUSH
90835: LD_INT 4
90837: ARRAY
90838: PUSH
90839: LD_VAR 0 2
90843: EQUAL
90844: AND
90845: ST_TO_ADDR
// end ;
90846: LD_VAR 0 3
90850: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90851: LD_INT 0
90853: PPUSH
// SetDir ( unit , d ) ;
90854: LD_VAR 0 1
90858: PPUSH
90859: LD_VAR 0 4
90863: PPUSH
90864: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90868: LD_VAR 0 1
90872: PPUSH
90873: LD_VAR 0 2
90877: PPUSH
90878: LD_VAR 0 3
90882: PPUSH
90883: LD_VAR 0 5
90887: PPUSH
90888: CALL_OW 48
// end ;
90892: LD_VAR 0 6
90896: RET
// export function ToNaturalNumber ( number ) ; begin
90897: LD_INT 0
90899: PPUSH
// result := number div 1 ;
90900: LD_ADDR_VAR 0 2
90904: PUSH
90905: LD_VAR 0 1
90909: PUSH
90910: LD_INT 1
90912: DIV
90913: ST_TO_ADDR
// if number < 0 then
90914: LD_VAR 0 1
90918: PUSH
90919: LD_INT 0
90921: LESS
90922: IFFALSE 90932
// result := 0 ;
90924: LD_ADDR_VAR 0 2
90928: PUSH
90929: LD_INT 0
90931: ST_TO_ADDR
// end ;
90932: LD_VAR 0 2
90936: RET
// export function SortByClass ( units , class ) ; var un ; begin
90937: LD_INT 0
90939: PPUSH
90940: PPUSH
// if not units or not class then
90941: LD_VAR 0 1
90945: NOT
90946: PUSH
90947: LD_VAR 0 2
90951: NOT
90952: OR
90953: IFFALSE 90957
// exit ;
90955: GO 91052
// result := [ ] ;
90957: LD_ADDR_VAR 0 3
90961: PUSH
90962: EMPTY
90963: ST_TO_ADDR
// for un in units do
90964: LD_ADDR_VAR 0 4
90968: PUSH
90969: LD_VAR 0 1
90973: PUSH
90974: FOR_IN
90975: IFFALSE 91050
// if GetClass ( un ) = class then
90977: LD_VAR 0 4
90981: PPUSH
90982: CALL_OW 257
90986: PUSH
90987: LD_VAR 0 2
90991: EQUAL
90992: IFFALSE 91019
// result := Insert ( result , 1 , un ) else
90994: LD_ADDR_VAR 0 3
90998: PUSH
90999: LD_VAR 0 3
91003: PPUSH
91004: LD_INT 1
91006: PPUSH
91007: LD_VAR 0 4
91011: PPUSH
91012: CALL_OW 2
91016: ST_TO_ADDR
91017: GO 91048
// result := Replace ( result , result + 1 , un ) ;
91019: LD_ADDR_VAR 0 3
91023: PUSH
91024: LD_VAR 0 3
91028: PPUSH
91029: LD_VAR 0 3
91033: PUSH
91034: LD_INT 1
91036: PLUS
91037: PPUSH
91038: LD_VAR 0 4
91042: PPUSH
91043: CALL_OW 1
91047: ST_TO_ADDR
91048: GO 90974
91050: POP
91051: POP
// end ;
91052: LD_VAR 0 3
91056: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91057: LD_INT 0
91059: PPUSH
91060: PPUSH
91061: PPUSH
91062: PPUSH
91063: PPUSH
91064: PPUSH
91065: PPUSH
// result := [ ] ;
91066: LD_ADDR_VAR 0 4
91070: PUSH
91071: EMPTY
91072: ST_TO_ADDR
// if x - r < 0 then
91073: LD_VAR 0 1
91077: PUSH
91078: LD_VAR 0 3
91082: MINUS
91083: PUSH
91084: LD_INT 0
91086: LESS
91087: IFFALSE 91099
// min_x := 0 else
91089: LD_ADDR_VAR 0 8
91093: PUSH
91094: LD_INT 0
91096: ST_TO_ADDR
91097: GO 91115
// min_x := x - r ;
91099: LD_ADDR_VAR 0 8
91103: PUSH
91104: LD_VAR 0 1
91108: PUSH
91109: LD_VAR 0 3
91113: MINUS
91114: ST_TO_ADDR
// if y - r < 0 then
91115: LD_VAR 0 2
91119: PUSH
91120: LD_VAR 0 3
91124: MINUS
91125: PUSH
91126: LD_INT 0
91128: LESS
91129: IFFALSE 91141
// min_y := 0 else
91131: LD_ADDR_VAR 0 7
91135: PUSH
91136: LD_INT 0
91138: ST_TO_ADDR
91139: GO 91157
// min_y := y - r ;
91141: LD_ADDR_VAR 0 7
91145: PUSH
91146: LD_VAR 0 2
91150: PUSH
91151: LD_VAR 0 3
91155: MINUS
91156: ST_TO_ADDR
// max_x := x + r ;
91157: LD_ADDR_VAR 0 9
91161: PUSH
91162: LD_VAR 0 1
91166: PUSH
91167: LD_VAR 0 3
91171: PLUS
91172: ST_TO_ADDR
// max_y := y + r ;
91173: LD_ADDR_VAR 0 10
91177: PUSH
91178: LD_VAR 0 2
91182: PUSH
91183: LD_VAR 0 3
91187: PLUS
91188: ST_TO_ADDR
// for _x = min_x to max_x do
91189: LD_ADDR_VAR 0 5
91193: PUSH
91194: DOUBLE
91195: LD_VAR 0 8
91199: DEC
91200: ST_TO_ADDR
91201: LD_VAR 0 9
91205: PUSH
91206: FOR_TO
91207: IFFALSE 91308
// for _y = min_y to max_y do
91209: LD_ADDR_VAR 0 6
91213: PUSH
91214: DOUBLE
91215: LD_VAR 0 7
91219: DEC
91220: ST_TO_ADDR
91221: LD_VAR 0 10
91225: PUSH
91226: FOR_TO
91227: IFFALSE 91304
// begin if not ValidHex ( _x , _y ) then
91229: LD_VAR 0 5
91233: PPUSH
91234: LD_VAR 0 6
91238: PPUSH
91239: CALL_OW 488
91243: NOT
91244: IFFALSE 91248
// continue ;
91246: GO 91226
// if GetResourceTypeXY ( _x , _y ) then
91248: LD_VAR 0 5
91252: PPUSH
91253: LD_VAR 0 6
91257: PPUSH
91258: CALL_OW 283
91262: IFFALSE 91302
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91264: LD_ADDR_VAR 0 4
91268: PUSH
91269: LD_VAR 0 4
91273: PPUSH
91274: LD_VAR 0 4
91278: PUSH
91279: LD_INT 1
91281: PLUS
91282: PPUSH
91283: LD_VAR 0 5
91287: PUSH
91288: LD_VAR 0 6
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PPUSH
91297: CALL_OW 1
91301: ST_TO_ADDR
// end ;
91302: GO 91226
91304: POP
91305: POP
91306: GO 91206
91308: POP
91309: POP
// end ;
91310: LD_VAR 0 4
91314: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91315: LD_INT 0
91317: PPUSH
91318: PPUSH
91319: PPUSH
91320: PPUSH
91321: PPUSH
91322: PPUSH
91323: PPUSH
91324: PPUSH
// if not units then
91325: LD_VAR 0 1
91329: NOT
91330: IFFALSE 91334
// exit ;
91332: GO 91759
// result := UnitFilter ( units , [ f_ok ] ) ;
91334: LD_ADDR_VAR 0 3
91338: PUSH
91339: LD_VAR 0 1
91343: PPUSH
91344: LD_INT 50
91346: PUSH
91347: EMPTY
91348: LIST
91349: PPUSH
91350: CALL_OW 72
91354: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91355: LD_ADDR_VAR 0 8
91359: PUSH
91360: LD_VAR 0 1
91364: PUSH
91365: LD_INT 1
91367: ARRAY
91368: PPUSH
91369: CALL_OW 255
91373: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
91374: LD_ADDR_VAR 0 10
91378: PUSH
91379: LD_INT 29
91381: PUSH
91382: LD_EXP 78
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: ST_TO_ADDR
// if not result then
91391: LD_VAR 0 3
91395: NOT
91396: IFFALSE 91400
// exit ;
91398: GO 91759
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91400: LD_ADDR_VAR 0 5
91404: PUSH
91405: LD_INT 81
91407: PUSH
91408: LD_VAR 0 8
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PPUSH
91417: CALL_OW 69
91421: ST_TO_ADDR
// for i in result do
91422: LD_ADDR_VAR 0 4
91426: PUSH
91427: LD_VAR 0 3
91431: PUSH
91432: FOR_IN
91433: IFFALSE 91757
// begin tag := GetTag ( i ) + 1 ;
91435: LD_ADDR_VAR 0 9
91439: PUSH
91440: LD_VAR 0 4
91444: PPUSH
91445: CALL_OW 110
91449: PUSH
91450: LD_INT 1
91452: PLUS
91453: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91454: LD_ADDR_VAR 0 7
91458: PUSH
91459: LD_VAR 0 4
91463: PPUSH
91464: CALL_OW 250
91468: PPUSH
91469: LD_VAR 0 4
91473: PPUSH
91474: CALL_OW 251
91478: PPUSH
91479: LD_INT 6
91481: PPUSH
91482: CALL 91057 0 3
91486: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
91487: LD_VAR 0 7
91491: PUSH
91492: LD_VAR 0 4
91496: PPUSH
91497: CALL_OW 264
91501: PUSH
91502: LD_VAR 0 10
91506: IN
91507: NOT
91508: AND
91509: IFFALSE 91548
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
91511: LD_VAR 0 4
91515: PPUSH
91516: LD_VAR 0 7
91520: PUSH
91521: LD_INT 1
91523: ARRAY
91524: PUSH
91525: LD_INT 1
91527: ARRAY
91528: PPUSH
91529: LD_VAR 0 7
91533: PUSH
91534: LD_INT 1
91536: ARRAY
91537: PUSH
91538: LD_INT 2
91540: ARRAY
91541: PPUSH
91542: CALL_OW 116
91546: GO 91755
// if path > tag then
91548: LD_VAR 0 2
91552: PUSH
91553: LD_VAR 0 9
91557: GREATER
91558: IFFALSE 91725
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
91560: LD_ADDR_VAR 0 6
91564: PUSH
91565: LD_VAR 0 5
91569: PPUSH
91570: LD_INT 91
91572: PUSH
91573: LD_VAR 0 4
91577: PUSH
91578: LD_INT 12
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: LIST
91585: PPUSH
91586: CALL_OW 72
91590: ST_TO_ADDR
// if nearEnemy then
91591: LD_VAR 0 6
91595: IFFALSE 91623
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
91597: LD_VAR 0 4
91601: PPUSH
91602: LD_VAR 0 6
91606: PPUSH
91607: LD_VAR 0 4
91611: PPUSH
91612: CALL_OW 74
91616: PPUSH
91617: CALL_OW 115
91621: GO 91723
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91623: LD_VAR 0 4
91627: PPUSH
91628: LD_VAR 0 2
91632: PUSH
91633: LD_VAR 0 9
91637: ARRAY
91638: PUSH
91639: LD_INT 1
91641: ARRAY
91642: PPUSH
91643: LD_VAR 0 2
91647: PUSH
91648: LD_VAR 0 9
91652: ARRAY
91653: PUSH
91654: LD_INT 2
91656: ARRAY
91657: PPUSH
91658: CALL_OW 297
91662: PUSH
91663: LD_INT 6
91665: GREATER
91666: IFFALSE 91709
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91668: LD_VAR 0 4
91672: PPUSH
91673: LD_VAR 0 2
91677: PUSH
91678: LD_VAR 0 9
91682: ARRAY
91683: PUSH
91684: LD_INT 1
91686: ARRAY
91687: PPUSH
91688: LD_VAR 0 2
91692: PUSH
91693: LD_VAR 0 9
91697: ARRAY
91698: PUSH
91699: LD_INT 2
91701: ARRAY
91702: PPUSH
91703: CALL_OW 114
91707: GO 91723
// SetTag ( i , tag ) ;
91709: LD_VAR 0 4
91713: PPUSH
91714: LD_VAR 0 9
91718: PPUSH
91719: CALL_OW 109
// end else
91723: GO 91755
// if enemy then
91725: LD_VAR 0 5
91729: IFFALSE 91755
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91731: LD_VAR 0 4
91735: PPUSH
91736: LD_VAR 0 5
91740: PPUSH
91741: LD_VAR 0 4
91745: PPUSH
91746: CALL_OW 74
91750: PPUSH
91751: CALL_OW 115
// end ;
91755: GO 91432
91757: POP
91758: POP
// end ; end_of_file end_of_file
91759: LD_VAR 0 3
91763: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91764: LD_INT 0
91766: PPUSH
// if p2 = 100 then
91767: LD_VAR 0 2
91771: PUSH
91772: LD_INT 100
91774: EQUAL
91775: IFFALSE 92778
// begin if not StreamModeActive then
91777: LD_EXP 139
91781: NOT
91782: IFFALSE 91792
// StreamModeActive := true ;
91784: LD_ADDR_EXP 139
91788: PUSH
91789: LD_INT 1
91791: ST_TO_ADDR
// if p3 = 0 then
91792: LD_VAR 0 3
91796: PUSH
91797: LD_INT 0
91799: EQUAL
91800: IFFALSE 91806
// InitStreamMode ;
91802: CALL 92938 0 0
// if p3 = 1 then
91806: LD_VAR 0 3
91810: PUSH
91811: LD_INT 1
91813: EQUAL
91814: IFFALSE 91824
// sRocket := true ;
91816: LD_ADDR_EXP 144
91820: PUSH
91821: LD_INT 1
91823: ST_TO_ADDR
// if p3 = 2 then
91824: LD_VAR 0 3
91828: PUSH
91829: LD_INT 2
91831: EQUAL
91832: IFFALSE 91842
// sSpeed := true ;
91834: LD_ADDR_EXP 143
91838: PUSH
91839: LD_INT 1
91841: ST_TO_ADDR
// if p3 = 3 then
91842: LD_VAR 0 3
91846: PUSH
91847: LD_INT 3
91849: EQUAL
91850: IFFALSE 91860
// sEngine := true ;
91852: LD_ADDR_EXP 145
91856: PUSH
91857: LD_INT 1
91859: ST_TO_ADDR
// if p3 = 4 then
91860: LD_VAR 0 3
91864: PUSH
91865: LD_INT 4
91867: EQUAL
91868: IFFALSE 91878
// sSpec := true ;
91870: LD_ADDR_EXP 142
91874: PUSH
91875: LD_INT 1
91877: ST_TO_ADDR
// if p3 = 5 then
91878: LD_VAR 0 3
91882: PUSH
91883: LD_INT 5
91885: EQUAL
91886: IFFALSE 91896
// sLevel := true ;
91888: LD_ADDR_EXP 146
91892: PUSH
91893: LD_INT 1
91895: ST_TO_ADDR
// if p3 = 6 then
91896: LD_VAR 0 3
91900: PUSH
91901: LD_INT 6
91903: EQUAL
91904: IFFALSE 91914
// sArmoury := true ;
91906: LD_ADDR_EXP 147
91910: PUSH
91911: LD_INT 1
91913: ST_TO_ADDR
// if p3 = 7 then
91914: LD_VAR 0 3
91918: PUSH
91919: LD_INT 7
91921: EQUAL
91922: IFFALSE 91932
// sRadar := true ;
91924: LD_ADDR_EXP 148
91928: PUSH
91929: LD_INT 1
91931: ST_TO_ADDR
// if p3 = 8 then
91932: LD_VAR 0 3
91936: PUSH
91937: LD_INT 8
91939: EQUAL
91940: IFFALSE 91950
// sBunker := true ;
91942: LD_ADDR_EXP 149
91946: PUSH
91947: LD_INT 1
91949: ST_TO_ADDR
// if p3 = 9 then
91950: LD_VAR 0 3
91954: PUSH
91955: LD_INT 9
91957: EQUAL
91958: IFFALSE 91968
// sHack := true ;
91960: LD_ADDR_EXP 150
91964: PUSH
91965: LD_INT 1
91967: ST_TO_ADDR
// if p3 = 10 then
91968: LD_VAR 0 3
91972: PUSH
91973: LD_INT 10
91975: EQUAL
91976: IFFALSE 91986
// sFire := true ;
91978: LD_ADDR_EXP 151
91982: PUSH
91983: LD_INT 1
91985: ST_TO_ADDR
// if p3 = 11 then
91986: LD_VAR 0 3
91990: PUSH
91991: LD_INT 11
91993: EQUAL
91994: IFFALSE 92004
// sRefresh := true ;
91996: LD_ADDR_EXP 152
92000: PUSH
92001: LD_INT 1
92003: ST_TO_ADDR
// if p3 = 12 then
92004: LD_VAR 0 3
92008: PUSH
92009: LD_INT 12
92011: EQUAL
92012: IFFALSE 92022
// sExp := true ;
92014: LD_ADDR_EXP 153
92018: PUSH
92019: LD_INT 1
92021: ST_TO_ADDR
// if p3 = 13 then
92022: LD_VAR 0 3
92026: PUSH
92027: LD_INT 13
92029: EQUAL
92030: IFFALSE 92040
// sDepot := true ;
92032: LD_ADDR_EXP 154
92036: PUSH
92037: LD_INT 1
92039: ST_TO_ADDR
// if p3 = 14 then
92040: LD_VAR 0 3
92044: PUSH
92045: LD_INT 14
92047: EQUAL
92048: IFFALSE 92058
// sFlag := true ;
92050: LD_ADDR_EXP 155
92054: PUSH
92055: LD_INT 1
92057: ST_TO_ADDR
// if p3 = 15 then
92058: LD_VAR 0 3
92062: PUSH
92063: LD_INT 15
92065: EQUAL
92066: IFFALSE 92076
// sKamikadze := true ;
92068: LD_ADDR_EXP 163
92072: PUSH
92073: LD_INT 1
92075: ST_TO_ADDR
// if p3 = 16 then
92076: LD_VAR 0 3
92080: PUSH
92081: LD_INT 16
92083: EQUAL
92084: IFFALSE 92094
// sTroll := true ;
92086: LD_ADDR_EXP 164
92090: PUSH
92091: LD_INT 1
92093: ST_TO_ADDR
// if p3 = 17 then
92094: LD_VAR 0 3
92098: PUSH
92099: LD_INT 17
92101: EQUAL
92102: IFFALSE 92112
// sSlow := true ;
92104: LD_ADDR_EXP 165
92108: PUSH
92109: LD_INT 1
92111: ST_TO_ADDR
// if p3 = 18 then
92112: LD_VAR 0 3
92116: PUSH
92117: LD_INT 18
92119: EQUAL
92120: IFFALSE 92130
// sLack := true ;
92122: LD_ADDR_EXP 166
92126: PUSH
92127: LD_INT 1
92129: ST_TO_ADDR
// if p3 = 19 then
92130: LD_VAR 0 3
92134: PUSH
92135: LD_INT 19
92137: EQUAL
92138: IFFALSE 92148
// sTank := true ;
92140: LD_ADDR_EXP 168
92144: PUSH
92145: LD_INT 1
92147: ST_TO_ADDR
// if p3 = 20 then
92148: LD_VAR 0 3
92152: PUSH
92153: LD_INT 20
92155: EQUAL
92156: IFFALSE 92166
// sRemote := true ;
92158: LD_ADDR_EXP 169
92162: PUSH
92163: LD_INT 1
92165: ST_TO_ADDR
// if p3 = 21 then
92166: LD_VAR 0 3
92170: PUSH
92171: LD_INT 21
92173: EQUAL
92174: IFFALSE 92184
// sPowell := true ;
92176: LD_ADDR_EXP 170
92180: PUSH
92181: LD_INT 1
92183: ST_TO_ADDR
// if p3 = 22 then
92184: LD_VAR 0 3
92188: PUSH
92189: LD_INT 22
92191: EQUAL
92192: IFFALSE 92202
// sTeleport := true ;
92194: LD_ADDR_EXP 173
92198: PUSH
92199: LD_INT 1
92201: ST_TO_ADDR
// if p3 = 23 then
92202: LD_VAR 0 3
92206: PUSH
92207: LD_INT 23
92209: EQUAL
92210: IFFALSE 92220
// sOilTower := true ;
92212: LD_ADDR_EXP 175
92216: PUSH
92217: LD_INT 1
92219: ST_TO_ADDR
// if p3 = 24 then
92220: LD_VAR 0 3
92224: PUSH
92225: LD_INT 24
92227: EQUAL
92228: IFFALSE 92238
// sShovel := true ;
92230: LD_ADDR_EXP 176
92234: PUSH
92235: LD_INT 1
92237: ST_TO_ADDR
// if p3 = 25 then
92238: LD_VAR 0 3
92242: PUSH
92243: LD_INT 25
92245: EQUAL
92246: IFFALSE 92256
// sSheik := true ;
92248: LD_ADDR_EXP 177
92252: PUSH
92253: LD_INT 1
92255: ST_TO_ADDR
// if p3 = 26 then
92256: LD_VAR 0 3
92260: PUSH
92261: LD_INT 26
92263: EQUAL
92264: IFFALSE 92274
// sEarthquake := true ;
92266: LD_ADDR_EXP 179
92270: PUSH
92271: LD_INT 1
92273: ST_TO_ADDR
// if p3 = 27 then
92274: LD_VAR 0 3
92278: PUSH
92279: LD_INT 27
92281: EQUAL
92282: IFFALSE 92292
// sAI := true ;
92284: LD_ADDR_EXP 180
92288: PUSH
92289: LD_INT 1
92291: ST_TO_ADDR
// if p3 = 28 then
92292: LD_VAR 0 3
92296: PUSH
92297: LD_INT 28
92299: EQUAL
92300: IFFALSE 92310
// sCargo := true ;
92302: LD_ADDR_EXP 183
92306: PUSH
92307: LD_INT 1
92309: ST_TO_ADDR
// if p3 = 29 then
92310: LD_VAR 0 3
92314: PUSH
92315: LD_INT 29
92317: EQUAL
92318: IFFALSE 92328
// sDLaser := true ;
92320: LD_ADDR_EXP 184
92324: PUSH
92325: LD_INT 1
92327: ST_TO_ADDR
// if p3 = 30 then
92328: LD_VAR 0 3
92332: PUSH
92333: LD_INT 30
92335: EQUAL
92336: IFFALSE 92346
// sExchange := true ;
92338: LD_ADDR_EXP 185
92342: PUSH
92343: LD_INT 1
92345: ST_TO_ADDR
// if p3 = 31 then
92346: LD_VAR 0 3
92350: PUSH
92351: LD_INT 31
92353: EQUAL
92354: IFFALSE 92364
// sFac := true ;
92356: LD_ADDR_EXP 186
92360: PUSH
92361: LD_INT 1
92363: ST_TO_ADDR
// if p3 = 32 then
92364: LD_VAR 0 3
92368: PUSH
92369: LD_INT 32
92371: EQUAL
92372: IFFALSE 92382
// sPower := true ;
92374: LD_ADDR_EXP 187
92378: PUSH
92379: LD_INT 1
92381: ST_TO_ADDR
// if p3 = 33 then
92382: LD_VAR 0 3
92386: PUSH
92387: LD_INT 33
92389: EQUAL
92390: IFFALSE 92400
// sRandom := true ;
92392: LD_ADDR_EXP 188
92396: PUSH
92397: LD_INT 1
92399: ST_TO_ADDR
// if p3 = 34 then
92400: LD_VAR 0 3
92404: PUSH
92405: LD_INT 34
92407: EQUAL
92408: IFFALSE 92418
// sShield := true ;
92410: LD_ADDR_EXP 189
92414: PUSH
92415: LD_INT 1
92417: ST_TO_ADDR
// if p3 = 35 then
92418: LD_VAR 0 3
92422: PUSH
92423: LD_INT 35
92425: EQUAL
92426: IFFALSE 92436
// sTime := true ;
92428: LD_ADDR_EXP 190
92432: PUSH
92433: LD_INT 1
92435: ST_TO_ADDR
// if p3 = 36 then
92436: LD_VAR 0 3
92440: PUSH
92441: LD_INT 36
92443: EQUAL
92444: IFFALSE 92454
// sTools := true ;
92446: LD_ADDR_EXP 191
92450: PUSH
92451: LD_INT 1
92453: ST_TO_ADDR
// if p3 = 101 then
92454: LD_VAR 0 3
92458: PUSH
92459: LD_INT 101
92461: EQUAL
92462: IFFALSE 92472
// sSold := true ;
92464: LD_ADDR_EXP 156
92468: PUSH
92469: LD_INT 1
92471: ST_TO_ADDR
// if p3 = 102 then
92472: LD_VAR 0 3
92476: PUSH
92477: LD_INT 102
92479: EQUAL
92480: IFFALSE 92490
// sDiff := true ;
92482: LD_ADDR_EXP 157
92486: PUSH
92487: LD_INT 1
92489: ST_TO_ADDR
// if p3 = 103 then
92490: LD_VAR 0 3
92494: PUSH
92495: LD_INT 103
92497: EQUAL
92498: IFFALSE 92508
// sFog := true ;
92500: LD_ADDR_EXP 160
92504: PUSH
92505: LD_INT 1
92507: ST_TO_ADDR
// if p3 = 104 then
92508: LD_VAR 0 3
92512: PUSH
92513: LD_INT 104
92515: EQUAL
92516: IFFALSE 92526
// sReset := true ;
92518: LD_ADDR_EXP 161
92522: PUSH
92523: LD_INT 1
92525: ST_TO_ADDR
// if p3 = 105 then
92526: LD_VAR 0 3
92530: PUSH
92531: LD_INT 105
92533: EQUAL
92534: IFFALSE 92544
// sSun := true ;
92536: LD_ADDR_EXP 162
92540: PUSH
92541: LD_INT 1
92543: ST_TO_ADDR
// if p3 = 106 then
92544: LD_VAR 0 3
92548: PUSH
92549: LD_INT 106
92551: EQUAL
92552: IFFALSE 92562
// sTiger := true ;
92554: LD_ADDR_EXP 158
92558: PUSH
92559: LD_INT 1
92561: ST_TO_ADDR
// if p3 = 107 then
92562: LD_VAR 0 3
92566: PUSH
92567: LD_INT 107
92569: EQUAL
92570: IFFALSE 92580
// sBomb := true ;
92572: LD_ADDR_EXP 159
92576: PUSH
92577: LD_INT 1
92579: ST_TO_ADDR
// if p3 = 108 then
92580: LD_VAR 0 3
92584: PUSH
92585: LD_INT 108
92587: EQUAL
92588: IFFALSE 92598
// sWound := true ;
92590: LD_ADDR_EXP 167
92594: PUSH
92595: LD_INT 1
92597: ST_TO_ADDR
// if p3 = 109 then
92598: LD_VAR 0 3
92602: PUSH
92603: LD_INT 109
92605: EQUAL
92606: IFFALSE 92616
// sBetray := true ;
92608: LD_ADDR_EXP 171
92612: PUSH
92613: LD_INT 1
92615: ST_TO_ADDR
// if p3 = 110 then
92616: LD_VAR 0 3
92620: PUSH
92621: LD_INT 110
92623: EQUAL
92624: IFFALSE 92634
// sContamin := true ;
92626: LD_ADDR_EXP 172
92630: PUSH
92631: LD_INT 1
92633: ST_TO_ADDR
// if p3 = 111 then
92634: LD_VAR 0 3
92638: PUSH
92639: LD_INT 111
92641: EQUAL
92642: IFFALSE 92652
// sOil := true ;
92644: LD_ADDR_EXP 174
92648: PUSH
92649: LD_INT 1
92651: ST_TO_ADDR
// if p3 = 112 then
92652: LD_VAR 0 3
92656: PUSH
92657: LD_INT 112
92659: EQUAL
92660: IFFALSE 92670
// sStu := true ;
92662: LD_ADDR_EXP 178
92666: PUSH
92667: LD_INT 1
92669: ST_TO_ADDR
// if p3 = 113 then
92670: LD_VAR 0 3
92674: PUSH
92675: LD_INT 113
92677: EQUAL
92678: IFFALSE 92688
// sBazooka := true ;
92680: LD_ADDR_EXP 181
92684: PUSH
92685: LD_INT 1
92687: ST_TO_ADDR
// if p3 = 114 then
92688: LD_VAR 0 3
92692: PUSH
92693: LD_INT 114
92695: EQUAL
92696: IFFALSE 92706
// sMortar := true ;
92698: LD_ADDR_EXP 182
92702: PUSH
92703: LD_INT 1
92705: ST_TO_ADDR
// if p3 = 115 then
92706: LD_VAR 0 3
92710: PUSH
92711: LD_INT 115
92713: EQUAL
92714: IFFALSE 92724
// sRanger := true ;
92716: LD_ADDR_EXP 192
92720: PUSH
92721: LD_INT 1
92723: ST_TO_ADDR
// if p3 = 116 then
92724: LD_VAR 0 3
92728: PUSH
92729: LD_INT 116
92731: EQUAL
92732: IFFALSE 92742
// sComputer := true ;
92734: LD_ADDR_EXP 193
92738: PUSH
92739: LD_INT 1
92741: ST_TO_ADDR
// if p3 = 117 then
92742: LD_VAR 0 3
92746: PUSH
92747: LD_INT 117
92749: EQUAL
92750: IFFALSE 92760
// s30 := true ;
92752: LD_ADDR_EXP 194
92756: PUSH
92757: LD_INT 1
92759: ST_TO_ADDR
// if p3 = 118 then
92760: LD_VAR 0 3
92764: PUSH
92765: LD_INT 118
92767: EQUAL
92768: IFFALSE 92778
// s60 := true ;
92770: LD_ADDR_EXP 195
92774: PUSH
92775: LD_INT 1
92777: ST_TO_ADDR
// end ; if p2 = 101 then
92778: LD_VAR 0 2
92782: PUSH
92783: LD_INT 101
92785: EQUAL
92786: IFFALSE 92914
// begin case p3 of 1 :
92788: LD_VAR 0 3
92792: PUSH
92793: LD_INT 1
92795: DOUBLE
92796: EQUAL
92797: IFTRUE 92801
92799: GO 92808
92801: POP
// hHackUnlimitedResources ; 2 :
92802: CALL 104510 0 0
92806: GO 92914
92808: LD_INT 2
92810: DOUBLE
92811: EQUAL
92812: IFTRUE 92816
92814: GO 92823
92816: POP
// hHackSetLevel10 ; 3 :
92817: CALL 104643 0 0
92821: GO 92914
92823: LD_INT 3
92825: DOUBLE
92826: EQUAL
92827: IFTRUE 92831
92829: GO 92838
92831: POP
// hHackSetLevel10YourUnits ; 4 :
92832: CALL 104728 0 0
92836: GO 92914
92838: LD_INT 4
92840: DOUBLE
92841: EQUAL
92842: IFTRUE 92846
92844: GO 92853
92846: POP
// hHackInvincible ; 5 :
92847: CALL 105176 0 0
92851: GO 92914
92853: LD_INT 5
92855: DOUBLE
92856: EQUAL
92857: IFTRUE 92861
92859: GO 92868
92861: POP
// hHackInvisible ; 6 :
92862: CALL 105287 0 0
92866: GO 92914
92868: LD_INT 6
92870: DOUBLE
92871: EQUAL
92872: IFTRUE 92876
92874: GO 92883
92876: POP
// hHackChangeYourSide ; 7 :
92877: CALL 105344 0 0
92881: GO 92914
92883: LD_INT 7
92885: DOUBLE
92886: EQUAL
92887: IFTRUE 92891
92889: GO 92898
92891: POP
// hHackChangeUnitSide ; 8 :
92892: CALL 105386 0 0
92896: GO 92914
92898: LD_INT 8
92900: DOUBLE
92901: EQUAL
92902: IFTRUE 92906
92904: GO 92913
92906: POP
// hHackFog ; end ;
92907: CALL 105487 0 0
92911: GO 92914
92913: POP
// end ; end ;
92914: LD_VAR 0 7
92918: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
92919: GO 92921
92921: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92922: LD_STRING initStreamRollete();
92924: PPUSH
92925: CALL_OW 559
// InitStreamMode ;
92929: CALL 92938 0 0
// DefineStreamItems ( ) ;
92933: CALL 93402 0 0
// end ;
92937: END
// function InitStreamMode ; begin
92938: LD_INT 0
92940: PPUSH
// streamModeActive := false ;
92941: LD_ADDR_EXP 139
92945: PUSH
92946: LD_INT 0
92948: ST_TO_ADDR
// normalCounter := 36 ;
92949: LD_ADDR_EXP 140
92953: PUSH
92954: LD_INT 36
92956: ST_TO_ADDR
// hardcoreCounter := 16 ;
92957: LD_ADDR_EXP 141
92961: PUSH
92962: LD_INT 16
92964: ST_TO_ADDR
// sRocket := false ;
92965: LD_ADDR_EXP 144
92969: PUSH
92970: LD_INT 0
92972: ST_TO_ADDR
// sSpeed := false ;
92973: LD_ADDR_EXP 143
92977: PUSH
92978: LD_INT 0
92980: ST_TO_ADDR
// sEngine := false ;
92981: LD_ADDR_EXP 145
92985: PUSH
92986: LD_INT 0
92988: ST_TO_ADDR
// sSpec := false ;
92989: LD_ADDR_EXP 142
92993: PUSH
92994: LD_INT 0
92996: ST_TO_ADDR
// sLevel := false ;
92997: LD_ADDR_EXP 146
93001: PUSH
93002: LD_INT 0
93004: ST_TO_ADDR
// sArmoury := false ;
93005: LD_ADDR_EXP 147
93009: PUSH
93010: LD_INT 0
93012: ST_TO_ADDR
// sRadar := false ;
93013: LD_ADDR_EXP 148
93017: PUSH
93018: LD_INT 0
93020: ST_TO_ADDR
// sBunker := false ;
93021: LD_ADDR_EXP 149
93025: PUSH
93026: LD_INT 0
93028: ST_TO_ADDR
// sHack := false ;
93029: LD_ADDR_EXP 150
93033: PUSH
93034: LD_INT 0
93036: ST_TO_ADDR
// sFire := false ;
93037: LD_ADDR_EXP 151
93041: PUSH
93042: LD_INT 0
93044: ST_TO_ADDR
// sRefresh := false ;
93045: LD_ADDR_EXP 152
93049: PUSH
93050: LD_INT 0
93052: ST_TO_ADDR
// sExp := false ;
93053: LD_ADDR_EXP 153
93057: PUSH
93058: LD_INT 0
93060: ST_TO_ADDR
// sDepot := false ;
93061: LD_ADDR_EXP 154
93065: PUSH
93066: LD_INT 0
93068: ST_TO_ADDR
// sFlag := false ;
93069: LD_ADDR_EXP 155
93073: PUSH
93074: LD_INT 0
93076: ST_TO_ADDR
// sKamikadze := false ;
93077: LD_ADDR_EXP 163
93081: PUSH
93082: LD_INT 0
93084: ST_TO_ADDR
// sTroll := false ;
93085: LD_ADDR_EXP 164
93089: PUSH
93090: LD_INT 0
93092: ST_TO_ADDR
// sSlow := false ;
93093: LD_ADDR_EXP 165
93097: PUSH
93098: LD_INT 0
93100: ST_TO_ADDR
// sLack := false ;
93101: LD_ADDR_EXP 166
93105: PUSH
93106: LD_INT 0
93108: ST_TO_ADDR
// sTank := false ;
93109: LD_ADDR_EXP 168
93113: PUSH
93114: LD_INT 0
93116: ST_TO_ADDR
// sRemote := false ;
93117: LD_ADDR_EXP 169
93121: PUSH
93122: LD_INT 0
93124: ST_TO_ADDR
// sPowell := false ;
93125: LD_ADDR_EXP 170
93129: PUSH
93130: LD_INT 0
93132: ST_TO_ADDR
// sTeleport := false ;
93133: LD_ADDR_EXP 173
93137: PUSH
93138: LD_INT 0
93140: ST_TO_ADDR
// sOilTower := false ;
93141: LD_ADDR_EXP 175
93145: PUSH
93146: LD_INT 0
93148: ST_TO_ADDR
// sShovel := false ;
93149: LD_ADDR_EXP 176
93153: PUSH
93154: LD_INT 0
93156: ST_TO_ADDR
// sSheik := false ;
93157: LD_ADDR_EXP 177
93161: PUSH
93162: LD_INT 0
93164: ST_TO_ADDR
// sEarthquake := false ;
93165: LD_ADDR_EXP 179
93169: PUSH
93170: LD_INT 0
93172: ST_TO_ADDR
// sAI := false ;
93173: LD_ADDR_EXP 180
93177: PUSH
93178: LD_INT 0
93180: ST_TO_ADDR
// sCargo := false ;
93181: LD_ADDR_EXP 183
93185: PUSH
93186: LD_INT 0
93188: ST_TO_ADDR
// sDLaser := false ;
93189: LD_ADDR_EXP 184
93193: PUSH
93194: LD_INT 0
93196: ST_TO_ADDR
// sExchange := false ;
93197: LD_ADDR_EXP 185
93201: PUSH
93202: LD_INT 0
93204: ST_TO_ADDR
// sFac := false ;
93205: LD_ADDR_EXP 186
93209: PUSH
93210: LD_INT 0
93212: ST_TO_ADDR
// sPower := false ;
93213: LD_ADDR_EXP 187
93217: PUSH
93218: LD_INT 0
93220: ST_TO_ADDR
// sRandom := false ;
93221: LD_ADDR_EXP 188
93225: PUSH
93226: LD_INT 0
93228: ST_TO_ADDR
// sShield := false ;
93229: LD_ADDR_EXP 189
93233: PUSH
93234: LD_INT 0
93236: ST_TO_ADDR
// sTime := false ;
93237: LD_ADDR_EXP 190
93241: PUSH
93242: LD_INT 0
93244: ST_TO_ADDR
// sTools := false ;
93245: LD_ADDR_EXP 191
93249: PUSH
93250: LD_INT 0
93252: ST_TO_ADDR
// sSold := false ;
93253: LD_ADDR_EXP 156
93257: PUSH
93258: LD_INT 0
93260: ST_TO_ADDR
// sDiff := false ;
93261: LD_ADDR_EXP 157
93265: PUSH
93266: LD_INT 0
93268: ST_TO_ADDR
// sFog := false ;
93269: LD_ADDR_EXP 160
93273: PUSH
93274: LD_INT 0
93276: ST_TO_ADDR
// sReset := false ;
93277: LD_ADDR_EXP 161
93281: PUSH
93282: LD_INT 0
93284: ST_TO_ADDR
// sSun := false ;
93285: LD_ADDR_EXP 162
93289: PUSH
93290: LD_INT 0
93292: ST_TO_ADDR
// sTiger := false ;
93293: LD_ADDR_EXP 158
93297: PUSH
93298: LD_INT 0
93300: ST_TO_ADDR
// sBomb := false ;
93301: LD_ADDR_EXP 159
93305: PUSH
93306: LD_INT 0
93308: ST_TO_ADDR
// sWound := false ;
93309: LD_ADDR_EXP 167
93313: PUSH
93314: LD_INT 0
93316: ST_TO_ADDR
// sBetray := false ;
93317: LD_ADDR_EXP 171
93321: PUSH
93322: LD_INT 0
93324: ST_TO_ADDR
// sContamin := false ;
93325: LD_ADDR_EXP 172
93329: PUSH
93330: LD_INT 0
93332: ST_TO_ADDR
// sOil := false ;
93333: LD_ADDR_EXP 174
93337: PUSH
93338: LD_INT 0
93340: ST_TO_ADDR
// sStu := false ;
93341: LD_ADDR_EXP 178
93345: PUSH
93346: LD_INT 0
93348: ST_TO_ADDR
// sBazooka := false ;
93349: LD_ADDR_EXP 181
93353: PUSH
93354: LD_INT 0
93356: ST_TO_ADDR
// sMortar := false ;
93357: LD_ADDR_EXP 182
93361: PUSH
93362: LD_INT 0
93364: ST_TO_ADDR
// sRanger := false ;
93365: LD_ADDR_EXP 192
93369: PUSH
93370: LD_INT 0
93372: ST_TO_ADDR
// sComputer := false ;
93373: LD_ADDR_EXP 193
93377: PUSH
93378: LD_INT 0
93380: ST_TO_ADDR
// s30 := false ;
93381: LD_ADDR_EXP 194
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// s60 := false ;
93389: LD_ADDR_EXP 195
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// end ;
93397: LD_VAR 0 1
93401: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
93402: LD_INT 0
93404: PPUSH
93405: PPUSH
93406: PPUSH
93407: PPUSH
93408: PPUSH
// result := [ ] ;
93409: LD_ADDR_VAR 0 1
93413: PUSH
93414: EMPTY
93415: ST_TO_ADDR
// if campaign_id = 1 then
93416: LD_OWVAR 69
93420: PUSH
93421: LD_INT 1
93423: EQUAL
93424: IFFALSE 96590
// begin case mission_number of 1 :
93426: LD_OWVAR 70
93430: PUSH
93431: LD_INT 1
93433: DOUBLE
93434: EQUAL
93435: IFTRUE 93439
93437: GO 93515
93439: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93440: LD_ADDR_VAR 0 1
93444: PUSH
93445: LD_INT 2
93447: PUSH
93448: LD_INT 4
93450: PUSH
93451: LD_INT 11
93453: PUSH
93454: LD_INT 12
93456: PUSH
93457: LD_INT 15
93459: PUSH
93460: LD_INT 16
93462: PUSH
93463: LD_INT 22
93465: PUSH
93466: LD_INT 23
93468: PUSH
93469: LD_INT 26
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: PUSH
93483: LD_INT 101
93485: PUSH
93486: LD_INT 102
93488: PUSH
93489: LD_INT 106
93491: PUSH
93492: LD_INT 116
93494: PUSH
93495: LD_INT 117
93497: PUSH
93498: LD_INT 118
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: ST_TO_ADDR
93513: GO 96588
93515: LD_INT 2
93517: DOUBLE
93518: EQUAL
93519: IFTRUE 93523
93521: GO 93607
93523: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93524: LD_ADDR_VAR 0 1
93528: PUSH
93529: LD_INT 2
93531: PUSH
93532: LD_INT 4
93534: PUSH
93535: LD_INT 11
93537: PUSH
93538: LD_INT 12
93540: PUSH
93541: LD_INT 15
93543: PUSH
93544: LD_INT 16
93546: PUSH
93547: LD_INT 22
93549: PUSH
93550: LD_INT 23
93552: PUSH
93553: LD_INT 26
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 101
93569: PUSH
93570: LD_INT 102
93572: PUSH
93573: LD_INT 105
93575: PUSH
93576: LD_INT 106
93578: PUSH
93579: LD_INT 108
93581: PUSH
93582: LD_INT 116
93584: PUSH
93585: LD_INT 117
93587: PUSH
93588: LD_INT 118
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: ST_TO_ADDR
93605: GO 96588
93607: LD_INT 3
93609: DOUBLE
93610: EQUAL
93611: IFTRUE 93615
93613: GO 93703
93615: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93616: LD_ADDR_VAR 0 1
93620: PUSH
93621: LD_INT 2
93623: PUSH
93624: LD_INT 4
93626: PUSH
93627: LD_INT 5
93629: PUSH
93630: LD_INT 11
93632: PUSH
93633: LD_INT 12
93635: PUSH
93636: LD_INT 15
93638: PUSH
93639: LD_INT 16
93641: PUSH
93642: LD_INT 22
93644: PUSH
93645: LD_INT 26
93647: PUSH
93648: LD_INT 36
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 101
93665: PUSH
93666: LD_INT 102
93668: PUSH
93669: LD_INT 105
93671: PUSH
93672: LD_INT 106
93674: PUSH
93675: LD_INT 108
93677: PUSH
93678: LD_INT 116
93680: PUSH
93681: LD_INT 117
93683: PUSH
93684: LD_INT 118
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: ST_TO_ADDR
93701: GO 96588
93703: LD_INT 4
93705: DOUBLE
93706: EQUAL
93707: IFTRUE 93711
93709: GO 93807
93711: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93712: LD_ADDR_VAR 0 1
93716: PUSH
93717: LD_INT 2
93719: PUSH
93720: LD_INT 4
93722: PUSH
93723: LD_INT 5
93725: PUSH
93726: LD_INT 8
93728: PUSH
93729: LD_INT 11
93731: PUSH
93732: LD_INT 12
93734: PUSH
93735: LD_INT 15
93737: PUSH
93738: LD_INT 16
93740: PUSH
93741: LD_INT 22
93743: PUSH
93744: LD_INT 23
93746: PUSH
93747: LD_INT 26
93749: PUSH
93750: LD_INT 36
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: PUSH
93767: LD_INT 101
93769: PUSH
93770: LD_INT 102
93772: PUSH
93773: LD_INT 105
93775: PUSH
93776: LD_INT 106
93778: PUSH
93779: LD_INT 108
93781: PUSH
93782: LD_INT 116
93784: PUSH
93785: LD_INT 117
93787: PUSH
93788: LD_INT 118
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: ST_TO_ADDR
93805: GO 96588
93807: LD_INT 5
93809: DOUBLE
93810: EQUAL
93811: IFTRUE 93815
93813: GO 93927
93815: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93816: LD_ADDR_VAR 0 1
93820: PUSH
93821: LD_INT 2
93823: PUSH
93824: LD_INT 4
93826: PUSH
93827: LD_INT 5
93829: PUSH
93830: LD_INT 6
93832: PUSH
93833: LD_INT 8
93835: PUSH
93836: LD_INT 11
93838: PUSH
93839: LD_INT 12
93841: PUSH
93842: LD_INT 15
93844: PUSH
93845: LD_INT 16
93847: PUSH
93848: LD_INT 22
93850: PUSH
93851: LD_INT 23
93853: PUSH
93854: LD_INT 25
93856: PUSH
93857: LD_INT 26
93859: PUSH
93860: LD_INT 36
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 101
93881: PUSH
93882: LD_INT 102
93884: PUSH
93885: LD_INT 105
93887: PUSH
93888: LD_INT 106
93890: PUSH
93891: LD_INT 108
93893: PUSH
93894: LD_INT 109
93896: PUSH
93897: LD_INT 112
93899: PUSH
93900: LD_INT 116
93902: PUSH
93903: LD_INT 117
93905: PUSH
93906: LD_INT 118
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: ST_TO_ADDR
93925: GO 96588
93927: LD_INT 6
93929: DOUBLE
93930: EQUAL
93931: IFTRUE 93935
93933: GO 94067
93935: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93936: LD_ADDR_VAR 0 1
93940: PUSH
93941: LD_INT 2
93943: PUSH
93944: LD_INT 4
93946: PUSH
93947: LD_INT 5
93949: PUSH
93950: LD_INT 6
93952: PUSH
93953: LD_INT 8
93955: PUSH
93956: LD_INT 11
93958: PUSH
93959: LD_INT 12
93961: PUSH
93962: LD_INT 15
93964: PUSH
93965: LD_INT 16
93967: PUSH
93968: LD_INT 20
93970: PUSH
93971: LD_INT 21
93973: PUSH
93974: LD_INT 22
93976: PUSH
93977: LD_INT 23
93979: PUSH
93980: LD_INT 25
93982: PUSH
93983: LD_INT 26
93985: PUSH
93986: LD_INT 30
93988: PUSH
93989: LD_INT 31
93991: PUSH
93992: LD_INT 32
93994: PUSH
93995: LD_INT 36
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 101
94021: PUSH
94022: LD_INT 102
94024: PUSH
94025: LD_INT 105
94027: PUSH
94028: LD_INT 106
94030: PUSH
94031: LD_INT 108
94033: PUSH
94034: LD_INT 109
94036: PUSH
94037: LD_INT 112
94039: PUSH
94040: LD_INT 116
94042: PUSH
94043: LD_INT 117
94045: PUSH
94046: LD_INT 118
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: ST_TO_ADDR
94065: GO 96588
94067: LD_INT 7
94069: DOUBLE
94070: EQUAL
94071: IFTRUE 94075
94073: GO 94187
94075: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94076: LD_ADDR_VAR 0 1
94080: PUSH
94081: LD_INT 2
94083: PUSH
94084: LD_INT 4
94086: PUSH
94087: LD_INT 5
94089: PUSH
94090: LD_INT 7
94092: PUSH
94093: LD_INT 11
94095: PUSH
94096: LD_INT 12
94098: PUSH
94099: LD_INT 15
94101: PUSH
94102: LD_INT 16
94104: PUSH
94105: LD_INT 20
94107: PUSH
94108: LD_INT 21
94110: PUSH
94111: LD_INT 22
94113: PUSH
94114: LD_INT 23
94116: PUSH
94117: LD_INT 25
94119: PUSH
94120: LD_INT 26
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 101
94141: PUSH
94142: LD_INT 102
94144: PUSH
94145: LD_INT 103
94147: PUSH
94148: LD_INT 105
94150: PUSH
94151: LD_INT 106
94153: PUSH
94154: LD_INT 108
94156: PUSH
94157: LD_INT 112
94159: PUSH
94160: LD_INT 116
94162: PUSH
94163: LD_INT 117
94165: PUSH
94166: LD_INT 118
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: ST_TO_ADDR
94185: GO 96588
94187: LD_INT 8
94189: DOUBLE
94190: EQUAL
94191: IFTRUE 94195
94193: GO 94335
94195: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94196: LD_ADDR_VAR 0 1
94200: PUSH
94201: LD_INT 2
94203: PUSH
94204: LD_INT 4
94206: PUSH
94207: LD_INT 5
94209: PUSH
94210: LD_INT 6
94212: PUSH
94213: LD_INT 7
94215: PUSH
94216: LD_INT 8
94218: PUSH
94219: LD_INT 11
94221: PUSH
94222: LD_INT 12
94224: PUSH
94225: LD_INT 15
94227: PUSH
94228: LD_INT 16
94230: PUSH
94231: LD_INT 20
94233: PUSH
94234: LD_INT 21
94236: PUSH
94237: LD_INT 22
94239: PUSH
94240: LD_INT 23
94242: PUSH
94243: LD_INT 25
94245: PUSH
94246: LD_INT 26
94248: PUSH
94249: LD_INT 30
94251: PUSH
94252: LD_INT 31
94254: PUSH
94255: LD_INT 32
94257: PUSH
94258: LD_INT 36
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 101
94285: PUSH
94286: LD_INT 102
94288: PUSH
94289: LD_INT 103
94291: PUSH
94292: LD_INT 105
94294: PUSH
94295: LD_INT 106
94297: PUSH
94298: LD_INT 108
94300: PUSH
94301: LD_INT 109
94303: PUSH
94304: LD_INT 112
94306: PUSH
94307: LD_INT 116
94309: PUSH
94310: LD_INT 117
94312: PUSH
94313: LD_INT 118
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: ST_TO_ADDR
94333: GO 96588
94335: LD_INT 9
94337: DOUBLE
94338: EQUAL
94339: IFTRUE 94343
94341: GO 94491
94343: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94344: LD_ADDR_VAR 0 1
94348: PUSH
94349: LD_INT 2
94351: PUSH
94352: LD_INT 4
94354: PUSH
94355: LD_INT 5
94357: PUSH
94358: LD_INT 6
94360: PUSH
94361: LD_INT 7
94363: PUSH
94364: LD_INT 8
94366: PUSH
94367: LD_INT 11
94369: PUSH
94370: LD_INT 12
94372: PUSH
94373: LD_INT 15
94375: PUSH
94376: LD_INT 16
94378: PUSH
94379: LD_INT 20
94381: PUSH
94382: LD_INT 21
94384: PUSH
94385: LD_INT 22
94387: PUSH
94388: LD_INT 23
94390: PUSH
94391: LD_INT 25
94393: PUSH
94394: LD_INT 26
94396: PUSH
94397: LD_INT 28
94399: PUSH
94400: LD_INT 30
94402: PUSH
94403: LD_INT 31
94405: PUSH
94406: LD_INT 32
94408: PUSH
94409: LD_INT 36
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 101
94437: PUSH
94438: LD_INT 102
94440: PUSH
94441: LD_INT 103
94443: PUSH
94444: LD_INT 105
94446: PUSH
94447: LD_INT 106
94449: PUSH
94450: LD_INT 108
94452: PUSH
94453: LD_INT 109
94455: PUSH
94456: LD_INT 112
94458: PUSH
94459: LD_INT 114
94461: PUSH
94462: LD_INT 116
94464: PUSH
94465: LD_INT 117
94467: PUSH
94468: LD_INT 118
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: ST_TO_ADDR
94489: GO 96588
94491: LD_INT 10
94493: DOUBLE
94494: EQUAL
94495: IFTRUE 94499
94497: GO 94695
94499: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94500: LD_ADDR_VAR 0 1
94504: PUSH
94505: LD_INT 2
94507: PUSH
94508: LD_INT 4
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: LD_INT 6
94516: PUSH
94517: LD_INT 7
94519: PUSH
94520: LD_INT 8
94522: PUSH
94523: LD_INT 9
94525: PUSH
94526: LD_INT 10
94528: PUSH
94529: LD_INT 11
94531: PUSH
94532: LD_INT 12
94534: PUSH
94535: LD_INT 13
94537: PUSH
94538: LD_INT 14
94540: PUSH
94541: LD_INT 15
94543: PUSH
94544: LD_INT 16
94546: PUSH
94547: LD_INT 17
94549: PUSH
94550: LD_INT 18
94552: PUSH
94553: LD_INT 19
94555: PUSH
94556: LD_INT 20
94558: PUSH
94559: LD_INT 21
94561: PUSH
94562: LD_INT 22
94564: PUSH
94565: LD_INT 23
94567: PUSH
94568: LD_INT 24
94570: PUSH
94571: LD_INT 25
94573: PUSH
94574: LD_INT 26
94576: PUSH
94577: LD_INT 28
94579: PUSH
94580: LD_INT 30
94582: PUSH
94583: LD_INT 31
94585: PUSH
94586: LD_INT 32
94588: PUSH
94589: LD_INT 36
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 101
94625: PUSH
94626: LD_INT 102
94628: PUSH
94629: LD_INT 103
94631: PUSH
94632: LD_INT 104
94634: PUSH
94635: LD_INT 105
94637: PUSH
94638: LD_INT 106
94640: PUSH
94641: LD_INT 107
94643: PUSH
94644: LD_INT 108
94646: PUSH
94647: LD_INT 109
94649: PUSH
94650: LD_INT 110
94652: PUSH
94653: LD_INT 111
94655: PUSH
94656: LD_INT 112
94658: PUSH
94659: LD_INT 114
94661: PUSH
94662: LD_INT 116
94664: PUSH
94665: LD_INT 117
94667: PUSH
94668: LD_INT 118
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: ST_TO_ADDR
94693: GO 96588
94695: LD_INT 11
94697: DOUBLE
94698: EQUAL
94699: IFTRUE 94703
94701: GO 94907
94703: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94704: LD_ADDR_VAR 0 1
94708: PUSH
94709: LD_INT 2
94711: PUSH
94712: LD_INT 3
94714: PUSH
94715: LD_INT 4
94717: PUSH
94718: LD_INT 5
94720: PUSH
94721: LD_INT 6
94723: PUSH
94724: LD_INT 7
94726: PUSH
94727: LD_INT 8
94729: PUSH
94730: LD_INT 9
94732: PUSH
94733: LD_INT 10
94735: PUSH
94736: LD_INT 11
94738: PUSH
94739: LD_INT 12
94741: PUSH
94742: LD_INT 13
94744: PUSH
94745: LD_INT 14
94747: PUSH
94748: LD_INT 15
94750: PUSH
94751: LD_INT 16
94753: PUSH
94754: LD_INT 17
94756: PUSH
94757: LD_INT 18
94759: PUSH
94760: LD_INT 19
94762: PUSH
94763: LD_INT 20
94765: PUSH
94766: LD_INT 21
94768: PUSH
94769: LD_INT 22
94771: PUSH
94772: LD_INT 23
94774: PUSH
94775: LD_INT 24
94777: PUSH
94778: LD_INT 25
94780: PUSH
94781: LD_INT 26
94783: PUSH
94784: LD_INT 28
94786: PUSH
94787: LD_INT 30
94789: PUSH
94790: LD_INT 31
94792: PUSH
94793: LD_INT 32
94795: PUSH
94796: LD_INT 34
94798: PUSH
94799: LD_INT 36
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 101
94837: PUSH
94838: LD_INT 102
94840: PUSH
94841: LD_INT 103
94843: PUSH
94844: LD_INT 104
94846: PUSH
94847: LD_INT 105
94849: PUSH
94850: LD_INT 106
94852: PUSH
94853: LD_INT 107
94855: PUSH
94856: LD_INT 108
94858: PUSH
94859: LD_INT 109
94861: PUSH
94862: LD_INT 110
94864: PUSH
94865: LD_INT 111
94867: PUSH
94868: LD_INT 112
94870: PUSH
94871: LD_INT 114
94873: PUSH
94874: LD_INT 116
94876: PUSH
94877: LD_INT 117
94879: PUSH
94880: LD_INT 118
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: ST_TO_ADDR
94905: GO 96588
94907: LD_INT 12
94909: DOUBLE
94910: EQUAL
94911: IFTRUE 94915
94913: GO 95135
94915: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94916: LD_ADDR_VAR 0 1
94920: PUSH
94921: LD_INT 1
94923: PUSH
94924: LD_INT 2
94926: PUSH
94927: LD_INT 3
94929: PUSH
94930: LD_INT 4
94932: PUSH
94933: LD_INT 5
94935: PUSH
94936: LD_INT 6
94938: PUSH
94939: LD_INT 7
94941: PUSH
94942: LD_INT 8
94944: PUSH
94945: LD_INT 9
94947: PUSH
94948: LD_INT 10
94950: PUSH
94951: LD_INT 11
94953: PUSH
94954: LD_INT 12
94956: PUSH
94957: LD_INT 13
94959: PUSH
94960: LD_INT 14
94962: PUSH
94963: LD_INT 15
94965: PUSH
94966: LD_INT 16
94968: PUSH
94969: LD_INT 17
94971: PUSH
94972: LD_INT 18
94974: PUSH
94975: LD_INT 19
94977: PUSH
94978: LD_INT 20
94980: PUSH
94981: LD_INT 21
94983: PUSH
94984: LD_INT 22
94986: PUSH
94987: LD_INT 23
94989: PUSH
94990: LD_INT 24
94992: PUSH
94993: LD_INT 25
94995: PUSH
94996: LD_INT 26
94998: PUSH
94999: LD_INT 27
95001: PUSH
95002: LD_INT 28
95004: PUSH
95005: LD_INT 30
95007: PUSH
95008: LD_INT 31
95010: PUSH
95011: LD_INT 32
95013: PUSH
95014: LD_INT 33
95016: PUSH
95017: LD_INT 34
95019: PUSH
95020: LD_INT 36
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 101
95061: PUSH
95062: LD_INT 102
95064: PUSH
95065: LD_INT 103
95067: PUSH
95068: LD_INT 104
95070: PUSH
95071: LD_INT 105
95073: PUSH
95074: LD_INT 106
95076: PUSH
95077: LD_INT 107
95079: PUSH
95080: LD_INT 108
95082: PUSH
95083: LD_INT 109
95085: PUSH
95086: LD_INT 110
95088: PUSH
95089: LD_INT 111
95091: PUSH
95092: LD_INT 112
95094: PUSH
95095: LD_INT 113
95097: PUSH
95098: LD_INT 114
95100: PUSH
95101: LD_INT 116
95103: PUSH
95104: LD_INT 117
95106: PUSH
95107: LD_INT 118
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: ST_TO_ADDR
95133: GO 96588
95135: LD_INT 13
95137: DOUBLE
95138: EQUAL
95139: IFTRUE 95143
95141: GO 95351
95143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95144: LD_ADDR_VAR 0 1
95148: PUSH
95149: LD_INT 1
95151: PUSH
95152: LD_INT 2
95154: PUSH
95155: LD_INT 3
95157: PUSH
95158: LD_INT 4
95160: PUSH
95161: LD_INT 5
95163: PUSH
95164: LD_INT 8
95166: PUSH
95167: LD_INT 9
95169: PUSH
95170: LD_INT 10
95172: PUSH
95173: LD_INT 11
95175: PUSH
95176: LD_INT 12
95178: PUSH
95179: LD_INT 14
95181: PUSH
95182: LD_INT 15
95184: PUSH
95185: LD_INT 16
95187: PUSH
95188: LD_INT 17
95190: PUSH
95191: LD_INT 18
95193: PUSH
95194: LD_INT 19
95196: PUSH
95197: LD_INT 20
95199: PUSH
95200: LD_INT 21
95202: PUSH
95203: LD_INT 22
95205: PUSH
95206: LD_INT 23
95208: PUSH
95209: LD_INT 24
95211: PUSH
95212: LD_INT 25
95214: PUSH
95215: LD_INT 26
95217: PUSH
95218: LD_INT 27
95220: PUSH
95221: LD_INT 28
95223: PUSH
95224: LD_INT 30
95226: PUSH
95227: LD_INT 31
95229: PUSH
95230: LD_INT 32
95232: PUSH
95233: LD_INT 33
95235: PUSH
95236: LD_INT 34
95238: PUSH
95239: LD_INT 36
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 101
95277: PUSH
95278: LD_INT 102
95280: PUSH
95281: LD_INT 103
95283: PUSH
95284: LD_INT 104
95286: PUSH
95287: LD_INT 105
95289: PUSH
95290: LD_INT 106
95292: PUSH
95293: LD_INT 107
95295: PUSH
95296: LD_INT 108
95298: PUSH
95299: LD_INT 109
95301: PUSH
95302: LD_INT 110
95304: PUSH
95305: LD_INT 111
95307: PUSH
95308: LD_INT 112
95310: PUSH
95311: LD_INT 113
95313: PUSH
95314: LD_INT 114
95316: PUSH
95317: LD_INT 116
95319: PUSH
95320: LD_INT 117
95322: PUSH
95323: LD_INT 118
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: ST_TO_ADDR
95349: GO 96588
95351: LD_INT 14
95353: DOUBLE
95354: EQUAL
95355: IFTRUE 95359
95357: GO 95583
95359: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95360: LD_ADDR_VAR 0 1
95364: PUSH
95365: LD_INT 1
95367: PUSH
95368: LD_INT 2
95370: PUSH
95371: LD_INT 3
95373: PUSH
95374: LD_INT 4
95376: PUSH
95377: LD_INT 5
95379: PUSH
95380: LD_INT 6
95382: PUSH
95383: LD_INT 7
95385: PUSH
95386: LD_INT 8
95388: PUSH
95389: LD_INT 9
95391: PUSH
95392: LD_INT 10
95394: PUSH
95395: LD_INT 11
95397: PUSH
95398: LD_INT 12
95400: PUSH
95401: LD_INT 13
95403: PUSH
95404: LD_INT 14
95406: PUSH
95407: LD_INT 15
95409: PUSH
95410: LD_INT 16
95412: PUSH
95413: LD_INT 17
95415: PUSH
95416: LD_INT 18
95418: PUSH
95419: LD_INT 19
95421: PUSH
95422: LD_INT 20
95424: PUSH
95425: LD_INT 21
95427: PUSH
95428: LD_INT 22
95430: PUSH
95431: LD_INT 23
95433: PUSH
95434: LD_INT 24
95436: PUSH
95437: LD_INT 25
95439: PUSH
95440: LD_INT 26
95442: PUSH
95443: LD_INT 27
95445: PUSH
95446: LD_INT 28
95448: PUSH
95449: LD_INT 29
95451: PUSH
95452: LD_INT 30
95454: PUSH
95455: LD_INT 31
95457: PUSH
95458: LD_INT 32
95460: PUSH
95461: LD_INT 33
95463: PUSH
95464: LD_INT 34
95466: PUSH
95467: LD_INT 36
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 101
95509: PUSH
95510: LD_INT 102
95512: PUSH
95513: LD_INT 103
95515: PUSH
95516: LD_INT 104
95518: PUSH
95519: LD_INT 105
95521: PUSH
95522: LD_INT 106
95524: PUSH
95525: LD_INT 107
95527: PUSH
95528: LD_INT 108
95530: PUSH
95531: LD_INT 109
95533: PUSH
95534: LD_INT 110
95536: PUSH
95537: LD_INT 111
95539: PUSH
95540: LD_INT 112
95542: PUSH
95543: LD_INT 113
95545: PUSH
95546: LD_INT 114
95548: PUSH
95549: LD_INT 116
95551: PUSH
95552: LD_INT 117
95554: PUSH
95555: LD_INT 118
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: ST_TO_ADDR
95581: GO 96588
95583: LD_INT 15
95585: DOUBLE
95586: EQUAL
95587: IFTRUE 95591
95589: GO 95815
95591: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95592: LD_ADDR_VAR 0 1
95596: PUSH
95597: LD_INT 1
95599: PUSH
95600: LD_INT 2
95602: PUSH
95603: LD_INT 3
95605: PUSH
95606: LD_INT 4
95608: PUSH
95609: LD_INT 5
95611: PUSH
95612: LD_INT 6
95614: PUSH
95615: LD_INT 7
95617: PUSH
95618: LD_INT 8
95620: PUSH
95621: LD_INT 9
95623: PUSH
95624: LD_INT 10
95626: PUSH
95627: LD_INT 11
95629: PUSH
95630: LD_INT 12
95632: PUSH
95633: LD_INT 13
95635: PUSH
95636: LD_INT 14
95638: PUSH
95639: LD_INT 15
95641: PUSH
95642: LD_INT 16
95644: PUSH
95645: LD_INT 17
95647: PUSH
95648: LD_INT 18
95650: PUSH
95651: LD_INT 19
95653: PUSH
95654: LD_INT 20
95656: PUSH
95657: LD_INT 21
95659: PUSH
95660: LD_INT 22
95662: PUSH
95663: LD_INT 23
95665: PUSH
95666: LD_INT 24
95668: PUSH
95669: LD_INT 25
95671: PUSH
95672: LD_INT 26
95674: PUSH
95675: LD_INT 27
95677: PUSH
95678: LD_INT 28
95680: PUSH
95681: LD_INT 29
95683: PUSH
95684: LD_INT 30
95686: PUSH
95687: LD_INT 31
95689: PUSH
95690: LD_INT 32
95692: PUSH
95693: LD_INT 33
95695: PUSH
95696: LD_INT 34
95698: PUSH
95699: LD_INT 36
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 101
95741: PUSH
95742: LD_INT 102
95744: PUSH
95745: LD_INT 103
95747: PUSH
95748: LD_INT 104
95750: PUSH
95751: LD_INT 105
95753: PUSH
95754: LD_INT 106
95756: PUSH
95757: LD_INT 107
95759: PUSH
95760: LD_INT 108
95762: PUSH
95763: LD_INT 109
95765: PUSH
95766: LD_INT 110
95768: PUSH
95769: LD_INT 111
95771: PUSH
95772: LD_INT 112
95774: PUSH
95775: LD_INT 113
95777: PUSH
95778: LD_INT 114
95780: PUSH
95781: LD_INT 116
95783: PUSH
95784: LD_INT 117
95786: PUSH
95787: LD_INT 118
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: ST_TO_ADDR
95813: GO 96588
95815: LD_INT 16
95817: DOUBLE
95818: EQUAL
95819: IFTRUE 95823
95821: GO 95959
95823: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95824: LD_ADDR_VAR 0 1
95828: PUSH
95829: LD_INT 2
95831: PUSH
95832: LD_INT 4
95834: PUSH
95835: LD_INT 5
95837: PUSH
95838: LD_INT 7
95840: PUSH
95841: LD_INT 11
95843: PUSH
95844: LD_INT 12
95846: PUSH
95847: LD_INT 15
95849: PUSH
95850: LD_INT 16
95852: PUSH
95853: LD_INT 20
95855: PUSH
95856: LD_INT 21
95858: PUSH
95859: LD_INT 22
95861: PUSH
95862: LD_INT 23
95864: PUSH
95865: LD_INT 25
95867: PUSH
95868: LD_INT 26
95870: PUSH
95871: LD_INT 30
95873: PUSH
95874: LD_INT 31
95876: PUSH
95877: LD_INT 32
95879: PUSH
95880: LD_INT 33
95882: PUSH
95883: LD_INT 34
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 101
95909: PUSH
95910: LD_INT 102
95912: PUSH
95913: LD_INT 103
95915: PUSH
95916: LD_INT 106
95918: PUSH
95919: LD_INT 108
95921: PUSH
95922: LD_INT 112
95924: PUSH
95925: LD_INT 113
95927: PUSH
95928: LD_INT 114
95930: PUSH
95931: LD_INT 116
95933: PUSH
95934: LD_INT 117
95936: PUSH
95937: LD_INT 118
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: ST_TO_ADDR
95957: GO 96588
95959: LD_INT 17
95961: DOUBLE
95962: EQUAL
95963: IFTRUE 95967
95965: GO 96191
95967: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95968: LD_ADDR_VAR 0 1
95972: PUSH
95973: LD_INT 1
95975: PUSH
95976: LD_INT 2
95978: PUSH
95979: LD_INT 3
95981: PUSH
95982: LD_INT 4
95984: PUSH
95985: LD_INT 5
95987: PUSH
95988: LD_INT 6
95990: PUSH
95991: LD_INT 7
95993: PUSH
95994: LD_INT 8
95996: PUSH
95997: LD_INT 9
95999: PUSH
96000: LD_INT 10
96002: PUSH
96003: LD_INT 11
96005: PUSH
96006: LD_INT 12
96008: PUSH
96009: LD_INT 13
96011: PUSH
96012: LD_INT 14
96014: PUSH
96015: LD_INT 15
96017: PUSH
96018: LD_INT 16
96020: PUSH
96021: LD_INT 17
96023: PUSH
96024: LD_INT 18
96026: PUSH
96027: LD_INT 19
96029: PUSH
96030: LD_INT 20
96032: PUSH
96033: LD_INT 21
96035: PUSH
96036: LD_INT 22
96038: PUSH
96039: LD_INT 23
96041: PUSH
96042: LD_INT 24
96044: PUSH
96045: LD_INT 25
96047: PUSH
96048: LD_INT 26
96050: PUSH
96051: LD_INT 27
96053: PUSH
96054: LD_INT 28
96056: PUSH
96057: LD_INT 29
96059: PUSH
96060: LD_INT 30
96062: PUSH
96063: LD_INT 31
96065: PUSH
96066: LD_INT 32
96068: PUSH
96069: LD_INT 33
96071: PUSH
96072: LD_INT 34
96074: PUSH
96075: LD_INT 36
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 101
96117: PUSH
96118: LD_INT 102
96120: PUSH
96121: LD_INT 103
96123: PUSH
96124: LD_INT 104
96126: PUSH
96127: LD_INT 105
96129: PUSH
96130: LD_INT 106
96132: PUSH
96133: LD_INT 107
96135: PUSH
96136: LD_INT 108
96138: PUSH
96139: LD_INT 109
96141: PUSH
96142: LD_INT 110
96144: PUSH
96145: LD_INT 111
96147: PUSH
96148: LD_INT 112
96150: PUSH
96151: LD_INT 113
96153: PUSH
96154: LD_INT 114
96156: PUSH
96157: LD_INT 116
96159: PUSH
96160: LD_INT 117
96162: PUSH
96163: LD_INT 118
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: PUSH
96185: EMPTY
96186: LIST
96187: LIST
96188: ST_TO_ADDR
96189: GO 96588
96191: LD_INT 18
96193: DOUBLE
96194: EQUAL
96195: IFTRUE 96199
96197: GO 96347
96199: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96200: LD_ADDR_VAR 0 1
96204: PUSH
96205: LD_INT 2
96207: PUSH
96208: LD_INT 4
96210: PUSH
96211: LD_INT 5
96213: PUSH
96214: LD_INT 7
96216: PUSH
96217: LD_INT 11
96219: PUSH
96220: LD_INT 12
96222: PUSH
96223: LD_INT 15
96225: PUSH
96226: LD_INT 16
96228: PUSH
96229: LD_INT 20
96231: PUSH
96232: LD_INT 21
96234: PUSH
96235: LD_INT 22
96237: PUSH
96238: LD_INT 23
96240: PUSH
96241: LD_INT 25
96243: PUSH
96244: LD_INT 26
96246: PUSH
96247: LD_INT 30
96249: PUSH
96250: LD_INT 31
96252: PUSH
96253: LD_INT 32
96255: PUSH
96256: LD_INT 33
96258: PUSH
96259: LD_INT 34
96261: PUSH
96262: LD_INT 35
96264: PUSH
96265: LD_INT 36
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: PUSH
96291: LD_INT 101
96293: PUSH
96294: LD_INT 102
96296: PUSH
96297: LD_INT 103
96299: PUSH
96300: LD_INT 106
96302: PUSH
96303: LD_INT 108
96305: PUSH
96306: LD_INT 112
96308: PUSH
96309: LD_INT 113
96311: PUSH
96312: LD_INT 114
96314: PUSH
96315: LD_INT 115
96317: PUSH
96318: LD_INT 116
96320: PUSH
96321: LD_INT 117
96323: PUSH
96324: LD_INT 118
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: ST_TO_ADDR
96345: GO 96588
96347: LD_INT 19
96349: DOUBLE
96350: EQUAL
96351: IFTRUE 96355
96353: GO 96587
96355: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96356: LD_ADDR_VAR 0 1
96360: PUSH
96361: LD_INT 1
96363: PUSH
96364: LD_INT 2
96366: PUSH
96367: LD_INT 3
96369: PUSH
96370: LD_INT 4
96372: PUSH
96373: LD_INT 5
96375: PUSH
96376: LD_INT 6
96378: PUSH
96379: LD_INT 7
96381: PUSH
96382: LD_INT 8
96384: PUSH
96385: LD_INT 9
96387: PUSH
96388: LD_INT 10
96390: PUSH
96391: LD_INT 11
96393: PUSH
96394: LD_INT 12
96396: PUSH
96397: LD_INT 13
96399: PUSH
96400: LD_INT 14
96402: PUSH
96403: LD_INT 15
96405: PUSH
96406: LD_INT 16
96408: PUSH
96409: LD_INT 17
96411: PUSH
96412: LD_INT 18
96414: PUSH
96415: LD_INT 19
96417: PUSH
96418: LD_INT 20
96420: PUSH
96421: LD_INT 21
96423: PUSH
96424: LD_INT 22
96426: PUSH
96427: LD_INT 23
96429: PUSH
96430: LD_INT 24
96432: PUSH
96433: LD_INT 25
96435: PUSH
96436: LD_INT 26
96438: PUSH
96439: LD_INT 27
96441: PUSH
96442: LD_INT 28
96444: PUSH
96445: LD_INT 29
96447: PUSH
96448: LD_INT 30
96450: PUSH
96451: LD_INT 31
96453: PUSH
96454: LD_INT 32
96456: PUSH
96457: LD_INT 33
96459: PUSH
96460: LD_INT 34
96462: PUSH
96463: LD_INT 35
96465: PUSH
96466: LD_INT 36
96468: PUSH
96469: EMPTY
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 101
96509: PUSH
96510: LD_INT 102
96512: PUSH
96513: LD_INT 103
96515: PUSH
96516: LD_INT 104
96518: PUSH
96519: LD_INT 105
96521: PUSH
96522: LD_INT 106
96524: PUSH
96525: LD_INT 107
96527: PUSH
96528: LD_INT 108
96530: PUSH
96531: LD_INT 109
96533: PUSH
96534: LD_INT 110
96536: PUSH
96537: LD_INT 111
96539: PUSH
96540: LD_INT 112
96542: PUSH
96543: LD_INT 113
96545: PUSH
96546: LD_INT 114
96548: PUSH
96549: LD_INT 115
96551: PUSH
96552: LD_INT 116
96554: PUSH
96555: LD_INT 117
96557: PUSH
96558: LD_INT 118
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: ST_TO_ADDR
96585: GO 96588
96587: POP
// end else
96588: GO 96819
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96590: LD_ADDR_VAR 0 1
96594: PUSH
96595: LD_INT 1
96597: PUSH
96598: LD_INT 2
96600: PUSH
96601: LD_INT 3
96603: PUSH
96604: LD_INT 4
96606: PUSH
96607: LD_INT 5
96609: PUSH
96610: LD_INT 6
96612: PUSH
96613: LD_INT 7
96615: PUSH
96616: LD_INT 8
96618: PUSH
96619: LD_INT 9
96621: PUSH
96622: LD_INT 10
96624: PUSH
96625: LD_INT 11
96627: PUSH
96628: LD_INT 12
96630: PUSH
96631: LD_INT 13
96633: PUSH
96634: LD_INT 14
96636: PUSH
96637: LD_INT 15
96639: PUSH
96640: LD_INT 16
96642: PUSH
96643: LD_INT 17
96645: PUSH
96646: LD_INT 18
96648: PUSH
96649: LD_INT 19
96651: PUSH
96652: LD_INT 20
96654: PUSH
96655: LD_INT 21
96657: PUSH
96658: LD_INT 22
96660: PUSH
96661: LD_INT 23
96663: PUSH
96664: LD_INT 24
96666: PUSH
96667: LD_INT 25
96669: PUSH
96670: LD_INT 26
96672: PUSH
96673: LD_INT 27
96675: PUSH
96676: LD_INT 28
96678: PUSH
96679: LD_INT 29
96681: PUSH
96682: LD_INT 30
96684: PUSH
96685: LD_INT 31
96687: PUSH
96688: LD_INT 32
96690: PUSH
96691: LD_INT 33
96693: PUSH
96694: LD_INT 34
96696: PUSH
96697: LD_INT 35
96699: PUSH
96700: LD_INT 36
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: LIST
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 101
96743: PUSH
96744: LD_INT 102
96746: PUSH
96747: LD_INT 103
96749: PUSH
96750: LD_INT 104
96752: PUSH
96753: LD_INT 105
96755: PUSH
96756: LD_INT 106
96758: PUSH
96759: LD_INT 107
96761: PUSH
96762: LD_INT 108
96764: PUSH
96765: LD_INT 109
96767: PUSH
96768: LD_INT 110
96770: PUSH
96771: LD_INT 111
96773: PUSH
96774: LD_INT 112
96776: PUSH
96777: LD_INT 113
96779: PUSH
96780: LD_INT 114
96782: PUSH
96783: LD_INT 115
96785: PUSH
96786: LD_INT 116
96788: PUSH
96789: LD_INT 117
96791: PUSH
96792: LD_INT 118
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: ST_TO_ADDR
// if result then
96819: LD_VAR 0 1
96823: IFFALSE 97112
// begin normal :=  ;
96825: LD_ADDR_VAR 0 3
96829: PUSH
96830: LD_STRING 
96832: ST_TO_ADDR
// hardcore :=  ;
96833: LD_ADDR_VAR 0 4
96837: PUSH
96838: LD_STRING 
96840: ST_TO_ADDR
// for i = 1 to normalCounter do
96841: LD_ADDR_VAR 0 5
96845: PUSH
96846: DOUBLE
96847: LD_INT 1
96849: DEC
96850: ST_TO_ADDR
96851: LD_EXP 140
96855: PUSH
96856: FOR_TO
96857: IFFALSE 96958
// begin tmp := 0 ;
96859: LD_ADDR_VAR 0 2
96863: PUSH
96864: LD_STRING 0
96866: ST_TO_ADDR
// if result [ 1 ] then
96867: LD_VAR 0 1
96871: PUSH
96872: LD_INT 1
96874: ARRAY
96875: IFFALSE 96940
// if result [ 1 ] [ 1 ] = i then
96877: LD_VAR 0 1
96881: PUSH
96882: LD_INT 1
96884: ARRAY
96885: PUSH
96886: LD_INT 1
96888: ARRAY
96889: PUSH
96890: LD_VAR 0 5
96894: EQUAL
96895: IFFALSE 96940
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96897: LD_ADDR_VAR 0 1
96901: PUSH
96902: LD_VAR 0 1
96906: PPUSH
96907: LD_INT 1
96909: PPUSH
96910: LD_VAR 0 1
96914: PUSH
96915: LD_INT 1
96917: ARRAY
96918: PPUSH
96919: LD_INT 1
96921: PPUSH
96922: CALL_OW 3
96926: PPUSH
96927: CALL_OW 1
96931: ST_TO_ADDR
// tmp := 1 ;
96932: LD_ADDR_VAR 0 2
96936: PUSH
96937: LD_STRING 1
96939: ST_TO_ADDR
// end ; normal := normal & tmp ;
96940: LD_ADDR_VAR 0 3
96944: PUSH
96945: LD_VAR 0 3
96949: PUSH
96950: LD_VAR 0 2
96954: STR
96955: ST_TO_ADDR
// end ;
96956: GO 96856
96958: POP
96959: POP
// for i = 1 to hardcoreCounter do
96960: LD_ADDR_VAR 0 5
96964: PUSH
96965: DOUBLE
96966: LD_INT 1
96968: DEC
96969: ST_TO_ADDR
96970: LD_EXP 141
96974: PUSH
96975: FOR_TO
96976: IFFALSE 97081
// begin tmp := 0 ;
96978: LD_ADDR_VAR 0 2
96982: PUSH
96983: LD_STRING 0
96985: ST_TO_ADDR
// if result [ 2 ] then
96986: LD_VAR 0 1
96990: PUSH
96991: LD_INT 2
96993: ARRAY
96994: IFFALSE 97063
// if result [ 2 ] [ 1 ] = 100 + i then
96996: LD_VAR 0 1
97000: PUSH
97001: LD_INT 2
97003: ARRAY
97004: PUSH
97005: LD_INT 1
97007: ARRAY
97008: PUSH
97009: LD_INT 100
97011: PUSH
97012: LD_VAR 0 5
97016: PLUS
97017: EQUAL
97018: IFFALSE 97063
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97020: LD_ADDR_VAR 0 1
97024: PUSH
97025: LD_VAR 0 1
97029: PPUSH
97030: LD_INT 2
97032: PPUSH
97033: LD_VAR 0 1
97037: PUSH
97038: LD_INT 2
97040: ARRAY
97041: PPUSH
97042: LD_INT 1
97044: PPUSH
97045: CALL_OW 3
97049: PPUSH
97050: CALL_OW 1
97054: ST_TO_ADDR
// tmp := 1 ;
97055: LD_ADDR_VAR 0 2
97059: PUSH
97060: LD_STRING 1
97062: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97063: LD_ADDR_VAR 0 4
97067: PUSH
97068: LD_VAR 0 4
97072: PUSH
97073: LD_VAR 0 2
97077: STR
97078: ST_TO_ADDR
// end ;
97079: GO 96975
97081: POP
97082: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
97083: LD_STRING getStreamItemsFromMission("
97085: PUSH
97086: LD_VAR 0 3
97090: STR
97091: PUSH
97092: LD_STRING ","
97094: STR
97095: PUSH
97096: LD_VAR 0 4
97100: STR
97101: PUSH
97102: LD_STRING ")
97104: STR
97105: PPUSH
97106: CALL_OW 559
// end else
97110: GO 97119
// ToLua ( getStreamItemsFromMission("","") ) ;
97112: LD_STRING getStreamItemsFromMission("","")
97114: PPUSH
97115: CALL_OW 559
// end ;
97119: LD_VAR 0 1
97123: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97124: LD_EXP 139
97128: PUSH
97129: LD_EXP 144
97133: AND
97134: IFFALSE 97258
97136: GO 97138
97138: DISABLE
97139: LD_INT 0
97141: PPUSH
97142: PPUSH
// begin enable ;
97143: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97144: LD_ADDR_VAR 0 2
97148: PUSH
97149: LD_INT 22
97151: PUSH
97152: LD_OWVAR 2
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: PUSH
97161: LD_INT 2
97163: PUSH
97164: LD_INT 34
97166: PUSH
97167: LD_INT 7
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: PUSH
97174: LD_INT 34
97176: PUSH
97177: LD_INT 45
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: LD_INT 34
97186: PUSH
97187: LD_INT 28
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: LD_INT 34
97196: PUSH
97197: LD_INT 47
97199: PUSH
97200: EMPTY
97201: LIST
97202: LIST
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PPUSH
97215: CALL_OW 69
97219: ST_TO_ADDR
// if not tmp then
97220: LD_VAR 0 2
97224: NOT
97225: IFFALSE 97229
// exit ;
97227: GO 97258
// for i in tmp do
97229: LD_ADDR_VAR 0 1
97233: PUSH
97234: LD_VAR 0 2
97238: PUSH
97239: FOR_IN
97240: IFFALSE 97256
// begin SetLives ( i , 0 ) ;
97242: LD_VAR 0 1
97246: PPUSH
97247: LD_INT 0
97249: PPUSH
97250: CALL_OW 234
// end ;
97254: GO 97239
97256: POP
97257: POP
// end ;
97258: PPOPN 2
97260: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97261: LD_EXP 139
97265: PUSH
97266: LD_EXP 145
97270: AND
97271: IFFALSE 97355
97273: GO 97275
97275: DISABLE
97276: LD_INT 0
97278: PPUSH
97279: PPUSH
// begin enable ;
97280: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97281: LD_ADDR_VAR 0 2
97285: PUSH
97286: LD_INT 22
97288: PUSH
97289: LD_OWVAR 2
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 32
97300: PUSH
97301: LD_INT 3
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PPUSH
97312: CALL_OW 69
97316: ST_TO_ADDR
// if not tmp then
97317: LD_VAR 0 2
97321: NOT
97322: IFFALSE 97326
// exit ;
97324: GO 97355
// for i in tmp do
97326: LD_ADDR_VAR 0 1
97330: PUSH
97331: LD_VAR 0 2
97335: PUSH
97336: FOR_IN
97337: IFFALSE 97353
// begin SetLives ( i , 0 ) ;
97339: LD_VAR 0 1
97343: PPUSH
97344: LD_INT 0
97346: PPUSH
97347: CALL_OW 234
// end ;
97351: GO 97336
97353: POP
97354: POP
// end ;
97355: PPOPN 2
97357: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97358: LD_EXP 139
97362: PUSH
97363: LD_EXP 142
97367: AND
97368: IFFALSE 97461
97370: GO 97372
97372: DISABLE
97373: LD_INT 0
97375: PPUSH
// begin enable ;
97376: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97377: LD_ADDR_VAR 0 1
97381: PUSH
97382: LD_INT 22
97384: PUSH
97385: LD_OWVAR 2
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: PUSH
97394: LD_INT 2
97396: PUSH
97397: LD_INT 25
97399: PUSH
97400: LD_INT 5
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 25
97409: PUSH
97410: LD_INT 9
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 25
97419: PUSH
97420: LD_INT 8
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: PUSH
97433: EMPTY
97434: LIST
97435: LIST
97436: PPUSH
97437: CALL_OW 69
97441: PUSH
97442: FOR_IN
97443: IFFALSE 97459
// begin SetClass ( i , 1 ) ;
97445: LD_VAR 0 1
97449: PPUSH
97450: LD_INT 1
97452: PPUSH
97453: CALL_OW 336
// end ;
97457: GO 97442
97459: POP
97460: POP
// end ;
97461: PPOPN 1
97463: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97464: LD_EXP 139
97468: PUSH
97469: LD_EXP 143
97473: AND
97474: PUSH
97475: LD_OWVAR 65
97479: PUSH
97480: LD_INT 7
97482: LESS
97483: AND
97484: IFFALSE 97498
97486: GO 97488
97488: DISABLE
// begin enable ;
97489: ENABLE
// game_speed := 7 ;
97490: LD_ADDR_OWVAR 65
97494: PUSH
97495: LD_INT 7
97497: ST_TO_ADDR
// end ;
97498: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97499: LD_EXP 139
97503: PUSH
97504: LD_EXP 146
97508: AND
97509: IFFALSE 97711
97511: GO 97513
97513: DISABLE
97514: LD_INT 0
97516: PPUSH
97517: PPUSH
97518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97519: LD_ADDR_VAR 0 3
97523: PUSH
97524: LD_INT 81
97526: PUSH
97527: LD_OWVAR 2
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: LD_INT 21
97538: PUSH
97539: LD_INT 1
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PPUSH
97550: CALL_OW 69
97554: ST_TO_ADDR
// if not tmp then
97555: LD_VAR 0 3
97559: NOT
97560: IFFALSE 97564
// exit ;
97562: GO 97711
// if tmp > 5 then
97564: LD_VAR 0 3
97568: PUSH
97569: LD_INT 5
97571: GREATER
97572: IFFALSE 97584
// k := 5 else
97574: LD_ADDR_VAR 0 2
97578: PUSH
97579: LD_INT 5
97581: ST_TO_ADDR
97582: GO 97594
// k := tmp ;
97584: LD_ADDR_VAR 0 2
97588: PUSH
97589: LD_VAR 0 3
97593: ST_TO_ADDR
// for i := 1 to k do
97594: LD_ADDR_VAR 0 1
97598: PUSH
97599: DOUBLE
97600: LD_INT 1
97602: DEC
97603: ST_TO_ADDR
97604: LD_VAR 0 2
97608: PUSH
97609: FOR_TO
97610: IFFALSE 97709
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97612: LD_VAR 0 3
97616: PUSH
97617: LD_VAR 0 1
97621: ARRAY
97622: PPUSH
97623: LD_VAR 0 1
97627: PUSH
97628: LD_INT 4
97630: MOD
97631: PUSH
97632: LD_INT 1
97634: PLUS
97635: PPUSH
97636: CALL_OW 259
97640: PUSH
97641: LD_INT 10
97643: LESS
97644: IFFALSE 97707
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97646: LD_VAR 0 3
97650: PUSH
97651: LD_VAR 0 1
97655: ARRAY
97656: PPUSH
97657: LD_VAR 0 1
97661: PUSH
97662: LD_INT 4
97664: MOD
97665: PUSH
97666: LD_INT 1
97668: PLUS
97669: PPUSH
97670: LD_VAR 0 3
97674: PUSH
97675: LD_VAR 0 1
97679: ARRAY
97680: PPUSH
97681: LD_VAR 0 1
97685: PUSH
97686: LD_INT 4
97688: MOD
97689: PUSH
97690: LD_INT 1
97692: PLUS
97693: PPUSH
97694: CALL_OW 259
97698: PUSH
97699: LD_INT 1
97701: PLUS
97702: PPUSH
97703: CALL_OW 237
97707: GO 97609
97709: POP
97710: POP
// end ;
97711: PPOPN 3
97713: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97714: LD_EXP 139
97718: PUSH
97719: LD_EXP 147
97723: AND
97724: IFFALSE 97744
97726: GO 97728
97728: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97729: LD_INT 4
97731: PPUSH
97732: LD_OWVAR 2
97736: PPUSH
97737: LD_INT 0
97739: PPUSH
97740: CALL_OW 324
97744: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97745: LD_EXP 139
97749: PUSH
97750: LD_EXP 176
97754: AND
97755: IFFALSE 97775
97757: GO 97759
97759: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97760: LD_INT 19
97762: PPUSH
97763: LD_OWVAR 2
97767: PPUSH
97768: LD_INT 0
97770: PPUSH
97771: CALL_OW 324
97775: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97776: LD_EXP 139
97780: PUSH
97781: LD_EXP 148
97785: AND
97786: IFFALSE 97888
97788: GO 97790
97790: DISABLE
97791: LD_INT 0
97793: PPUSH
97794: PPUSH
// begin enable ;
97795: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97796: LD_ADDR_VAR 0 2
97800: PUSH
97801: LD_INT 22
97803: PUSH
97804: LD_OWVAR 2
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: PUSH
97813: LD_INT 2
97815: PUSH
97816: LD_INT 34
97818: PUSH
97819: LD_INT 11
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: PUSH
97826: LD_INT 34
97828: PUSH
97829: LD_INT 30
97831: PUSH
97832: EMPTY
97833: LIST
97834: LIST
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: LIST
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: PPUSH
97845: CALL_OW 69
97849: ST_TO_ADDR
// if not tmp then
97850: LD_VAR 0 2
97854: NOT
97855: IFFALSE 97859
// exit ;
97857: GO 97888
// for i in tmp do
97859: LD_ADDR_VAR 0 1
97863: PUSH
97864: LD_VAR 0 2
97868: PUSH
97869: FOR_IN
97870: IFFALSE 97886
// begin SetLives ( i , 0 ) ;
97872: LD_VAR 0 1
97876: PPUSH
97877: LD_INT 0
97879: PPUSH
97880: CALL_OW 234
// end ;
97884: GO 97869
97886: POP
97887: POP
// end ;
97888: PPOPN 2
97890: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97891: LD_EXP 139
97895: PUSH
97896: LD_EXP 149
97900: AND
97901: IFFALSE 97921
97903: GO 97905
97905: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97906: LD_INT 32
97908: PPUSH
97909: LD_OWVAR 2
97913: PPUSH
97914: LD_INT 0
97916: PPUSH
97917: CALL_OW 324
97921: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97922: LD_EXP 139
97926: PUSH
97927: LD_EXP 150
97931: AND
97932: IFFALSE 98113
97934: GO 97936
97936: DISABLE
97937: LD_INT 0
97939: PPUSH
97940: PPUSH
97941: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97942: LD_ADDR_VAR 0 2
97946: PUSH
97947: LD_INT 22
97949: PUSH
97950: LD_OWVAR 2
97954: PUSH
97955: EMPTY
97956: LIST
97957: LIST
97958: PUSH
97959: LD_INT 33
97961: PUSH
97962: LD_INT 3
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PUSH
97969: EMPTY
97970: LIST
97971: LIST
97972: PPUSH
97973: CALL_OW 69
97977: ST_TO_ADDR
// if not tmp then
97978: LD_VAR 0 2
97982: NOT
97983: IFFALSE 97987
// exit ;
97985: GO 98113
// side := 0 ;
97987: LD_ADDR_VAR 0 3
97991: PUSH
97992: LD_INT 0
97994: ST_TO_ADDR
// for i := 1 to 8 do
97995: LD_ADDR_VAR 0 1
97999: PUSH
98000: DOUBLE
98001: LD_INT 1
98003: DEC
98004: ST_TO_ADDR
98005: LD_INT 8
98007: PUSH
98008: FOR_TO
98009: IFFALSE 98057
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98011: LD_OWVAR 2
98015: PUSH
98016: LD_VAR 0 1
98020: NONEQUAL
98021: PUSH
98022: LD_OWVAR 2
98026: PPUSH
98027: LD_VAR 0 1
98031: PPUSH
98032: CALL_OW 81
98036: PUSH
98037: LD_INT 2
98039: EQUAL
98040: AND
98041: IFFALSE 98055
// begin side := i ;
98043: LD_ADDR_VAR 0 3
98047: PUSH
98048: LD_VAR 0 1
98052: ST_TO_ADDR
// break ;
98053: GO 98057
// end ;
98055: GO 98008
98057: POP
98058: POP
// if not side then
98059: LD_VAR 0 3
98063: NOT
98064: IFFALSE 98068
// exit ;
98066: GO 98113
// for i := 1 to tmp do
98068: LD_ADDR_VAR 0 1
98072: PUSH
98073: DOUBLE
98074: LD_INT 1
98076: DEC
98077: ST_TO_ADDR
98078: LD_VAR 0 2
98082: PUSH
98083: FOR_TO
98084: IFFALSE 98111
// if Prob ( 60 ) then
98086: LD_INT 60
98088: PPUSH
98089: CALL_OW 13
98093: IFFALSE 98109
// SetSide ( i , side ) ;
98095: LD_VAR 0 1
98099: PPUSH
98100: LD_VAR 0 3
98104: PPUSH
98105: CALL_OW 235
98109: GO 98083
98111: POP
98112: POP
// end ;
98113: PPOPN 3
98115: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98116: LD_EXP 139
98120: PUSH
98121: LD_EXP 152
98125: AND
98126: IFFALSE 98245
98128: GO 98130
98130: DISABLE
98131: LD_INT 0
98133: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98134: LD_ADDR_VAR 0 1
98138: PUSH
98139: LD_INT 22
98141: PUSH
98142: LD_OWVAR 2
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 21
98153: PUSH
98154: LD_INT 1
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: PUSH
98161: LD_INT 3
98163: PUSH
98164: LD_INT 23
98166: PUSH
98167: LD_INT 0
98169: PUSH
98170: EMPTY
98171: LIST
98172: LIST
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: LIST
98182: PPUSH
98183: CALL_OW 69
98187: PUSH
98188: FOR_IN
98189: IFFALSE 98243
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98191: LD_VAR 0 1
98195: PPUSH
98196: CALL_OW 257
98200: PUSH
98201: LD_INT 1
98203: PUSH
98204: LD_INT 2
98206: PUSH
98207: LD_INT 3
98209: PUSH
98210: LD_INT 4
98212: PUSH
98213: EMPTY
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: IN
98219: IFFALSE 98241
// SetClass ( un , rand ( 1 , 4 ) ) ;
98221: LD_VAR 0 1
98225: PPUSH
98226: LD_INT 1
98228: PPUSH
98229: LD_INT 4
98231: PPUSH
98232: CALL_OW 12
98236: PPUSH
98237: CALL_OW 336
98241: GO 98188
98243: POP
98244: POP
// end ;
98245: PPOPN 1
98247: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98248: LD_EXP 139
98252: PUSH
98253: LD_EXP 151
98257: AND
98258: IFFALSE 98337
98260: GO 98262
98262: DISABLE
98263: LD_INT 0
98265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98266: LD_ADDR_VAR 0 1
98270: PUSH
98271: LD_INT 22
98273: PUSH
98274: LD_OWVAR 2
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PUSH
98283: LD_INT 21
98285: PUSH
98286: LD_INT 3
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PPUSH
98297: CALL_OW 69
98301: ST_TO_ADDR
// if not tmp then
98302: LD_VAR 0 1
98306: NOT
98307: IFFALSE 98311
// exit ;
98309: GO 98337
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98311: LD_VAR 0 1
98315: PUSH
98316: LD_INT 1
98318: PPUSH
98319: LD_VAR 0 1
98323: PPUSH
98324: CALL_OW 12
98328: ARRAY
98329: PPUSH
98330: LD_INT 100
98332: PPUSH
98333: CALL_OW 234
// end ;
98337: PPOPN 1
98339: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98340: LD_EXP 139
98344: PUSH
98345: LD_EXP 153
98349: AND
98350: IFFALSE 98448
98352: GO 98354
98354: DISABLE
98355: LD_INT 0
98357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98358: LD_ADDR_VAR 0 1
98362: PUSH
98363: LD_INT 22
98365: PUSH
98366: LD_OWVAR 2
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: LD_INT 21
98377: PUSH
98378: LD_INT 1
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: PPUSH
98389: CALL_OW 69
98393: ST_TO_ADDR
// if not tmp then
98394: LD_VAR 0 1
98398: NOT
98399: IFFALSE 98403
// exit ;
98401: GO 98448
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98403: LD_VAR 0 1
98407: PUSH
98408: LD_INT 1
98410: PPUSH
98411: LD_VAR 0 1
98415: PPUSH
98416: CALL_OW 12
98420: ARRAY
98421: PPUSH
98422: LD_INT 1
98424: PPUSH
98425: LD_INT 4
98427: PPUSH
98428: CALL_OW 12
98432: PPUSH
98433: LD_INT 3000
98435: PPUSH
98436: LD_INT 9000
98438: PPUSH
98439: CALL_OW 12
98443: PPUSH
98444: CALL_OW 492
// end ;
98448: PPOPN 1
98450: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98451: LD_EXP 139
98455: PUSH
98456: LD_EXP 154
98460: AND
98461: IFFALSE 98481
98463: GO 98465
98465: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98466: LD_INT 1
98468: PPUSH
98469: LD_OWVAR 2
98473: PPUSH
98474: LD_INT 0
98476: PPUSH
98477: CALL_OW 324
98481: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98482: LD_EXP 139
98486: PUSH
98487: LD_EXP 155
98491: AND
98492: IFFALSE 98575
98494: GO 98496
98496: DISABLE
98497: LD_INT 0
98499: PPUSH
98500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98501: LD_ADDR_VAR 0 2
98505: PUSH
98506: LD_INT 22
98508: PUSH
98509: LD_OWVAR 2
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: PUSH
98518: LD_INT 21
98520: PUSH
98521: LD_INT 3
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: PPUSH
98532: CALL_OW 69
98536: ST_TO_ADDR
// if not tmp then
98537: LD_VAR 0 2
98541: NOT
98542: IFFALSE 98546
// exit ;
98544: GO 98575
// for i in tmp do
98546: LD_ADDR_VAR 0 1
98550: PUSH
98551: LD_VAR 0 2
98555: PUSH
98556: FOR_IN
98557: IFFALSE 98573
// SetBLevel ( i , 10 ) ;
98559: LD_VAR 0 1
98563: PPUSH
98564: LD_INT 10
98566: PPUSH
98567: CALL_OW 241
98571: GO 98556
98573: POP
98574: POP
// end ;
98575: PPOPN 2
98577: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98578: LD_EXP 139
98582: PUSH
98583: LD_EXP 156
98587: AND
98588: IFFALSE 98699
98590: GO 98592
98592: DISABLE
98593: LD_INT 0
98595: PPUSH
98596: PPUSH
98597: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98598: LD_ADDR_VAR 0 3
98602: PUSH
98603: LD_INT 22
98605: PUSH
98606: LD_OWVAR 2
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: PUSH
98615: LD_INT 25
98617: PUSH
98618: LD_INT 1
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PUSH
98625: EMPTY
98626: LIST
98627: LIST
98628: PPUSH
98629: CALL_OW 69
98633: ST_TO_ADDR
// if not tmp then
98634: LD_VAR 0 3
98638: NOT
98639: IFFALSE 98643
// exit ;
98641: GO 98699
// un := tmp [ rand ( 1 , tmp ) ] ;
98643: LD_ADDR_VAR 0 2
98647: PUSH
98648: LD_VAR 0 3
98652: PUSH
98653: LD_INT 1
98655: PPUSH
98656: LD_VAR 0 3
98660: PPUSH
98661: CALL_OW 12
98665: ARRAY
98666: ST_TO_ADDR
// if Crawls ( un ) then
98667: LD_VAR 0 2
98671: PPUSH
98672: CALL_OW 318
98676: IFFALSE 98687
// ComWalk ( un ) ;
98678: LD_VAR 0 2
98682: PPUSH
98683: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98687: LD_VAR 0 2
98691: PPUSH
98692: LD_INT 5
98694: PPUSH
98695: CALL_OW 336
// end ;
98699: PPOPN 3
98701: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98702: LD_EXP 139
98706: PUSH
98707: LD_EXP 157
98711: AND
98712: PUSH
98713: LD_OWVAR 67
98717: PUSH
98718: LD_INT 4
98720: LESS
98721: AND
98722: IFFALSE 98741
98724: GO 98726
98726: DISABLE
// begin Difficulty := Difficulty + 1 ;
98727: LD_ADDR_OWVAR 67
98731: PUSH
98732: LD_OWVAR 67
98736: PUSH
98737: LD_INT 1
98739: PLUS
98740: ST_TO_ADDR
// end ;
98741: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98742: LD_EXP 139
98746: PUSH
98747: LD_EXP 158
98751: AND
98752: IFFALSE 98855
98754: GO 98756
98756: DISABLE
98757: LD_INT 0
98759: PPUSH
// begin for i := 1 to 5 do
98760: LD_ADDR_VAR 0 1
98764: PUSH
98765: DOUBLE
98766: LD_INT 1
98768: DEC
98769: ST_TO_ADDR
98770: LD_INT 5
98772: PUSH
98773: FOR_TO
98774: IFFALSE 98853
// begin uc_nation := nation_nature ;
98776: LD_ADDR_OWVAR 21
98780: PUSH
98781: LD_INT 0
98783: ST_TO_ADDR
// uc_side := 0 ;
98784: LD_ADDR_OWVAR 20
98788: PUSH
98789: LD_INT 0
98791: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98792: LD_ADDR_OWVAR 29
98796: PUSH
98797: LD_INT 12
98799: PUSH
98800: LD_INT 12
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: ST_TO_ADDR
// hc_agressivity := 20 ;
98807: LD_ADDR_OWVAR 35
98811: PUSH
98812: LD_INT 20
98814: ST_TO_ADDR
// hc_class := class_tiger ;
98815: LD_ADDR_OWVAR 28
98819: PUSH
98820: LD_INT 14
98822: ST_TO_ADDR
// hc_gallery :=  ;
98823: LD_ADDR_OWVAR 33
98827: PUSH
98828: LD_STRING 
98830: ST_TO_ADDR
// hc_name :=  ;
98831: LD_ADDR_OWVAR 26
98835: PUSH
98836: LD_STRING 
98838: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98839: CALL_OW 44
98843: PPUSH
98844: LD_INT 0
98846: PPUSH
98847: CALL_OW 51
// end ;
98851: GO 98773
98853: POP
98854: POP
// end ;
98855: PPOPN 1
98857: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98858: LD_EXP 139
98862: PUSH
98863: LD_EXP 159
98867: AND
98868: IFFALSE 98877
98870: GO 98872
98872: DISABLE
// StreamSibBomb ;
98873: CALL 98878 0 0
98877: END
// export function StreamSibBomb ; var i , x , y ; begin
98878: LD_INT 0
98880: PPUSH
98881: PPUSH
98882: PPUSH
98883: PPUSH
// result := false ;
98884: LD_ADDR_VAR 0 1
98888: PUSH
98889: LD_INT 0
98891: ST_TO_ADDR
// for i := 1 to 16 do
98892: LD_ADDR_VAR 0 2
98896: PUSH
98897: DOUBLE
98898: LD_INT 1
98900: DEC
98901: ST_TO_ADDR
98902: LD_INT 16
98904: PUSH
98905: FOR_TO
98906: IFFALSE 99105
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98908: LD_ADDR_VAR 0 3
98912: PUSH
98913: LD_INT 10
98915: PUSH
98916: LD_INT 20
98918: PUSH
98919: LD_INT 30
98921: PUSH
98922: LD_INT 40
98924: PUSH
98925: LD_INT 50
98927: PUSH
98928: LD_INT 60
98930: PUSH
98931: LD_INT 70
98933: PUSH
98934: LD_INT 80
98936: PUSH
98937: LD_INT 90
98939: PUSH
98940: LD_INT 100
98942: PUSH
98943: LD_INT 110
98945: PUSH
98946: LD_INT 120
98948: PUSH
98949: LD_INT 130
98951: PUSH
98952: LD_INT 140
98954: PUSH
98955: LD_INT 150
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: PUSH
98975: LD_INT 1
98977: PPUSH
98978: LD_INT 15
98980: PPUSH
98981: CALL_OW 12
98985: ARRAY
98986: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98987: LD_ADDR_VAR 0 4
98991: PUSH
98992: LD_INT 10
98994: PUSH
98995: LD_INT 20
98997: PUSH
98998: LD_INT 30
99000: PUSH
99001: LD_INT 40
99003: PUSH
99004: LD_INT 50
99006: PUSH
99007: LD_INT 60
99009: PUSH
99010: LD_INT 70
99012: PUSH
99013: LD_INT 80
99015: PUSH
99016: LD_INT 90
99018: PUSH
99019: LD_INT 100
99021: PUSH
99022: LD_INT 110
99024: PUSH
99025: LD_INT 120
99027: PUSH
99028: LD_INT 130
99030: PUSH
99031: LD_INT 140
99033: PUSH
99034: LD_INT 150
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: PUSH
99054: LD_INT 1
99056: PPUSH
99057: LD_INT 15
99059: PPUSH
99060: CALL_OW 12
99064: ARRAY
99065: ST_TO_ADDR
// if ValidHex ( x , y ) then
99066: LD_VAR 0 3
99070: PPUSH
99071: LD_VAR 0 4
99075: PPUSH
99076: CALL_OW 488
99080: IFFALSE 99103
// begin result := [ x , y ] ;
99082: LD_ADDR_VAR 0 1
99086: PUSH
99087: LD_VAR 0 3
99091: PUSH
99092: LD_VAR 0 4
99096: PUSH
99097: EMPTY
99098: LIST
99099: LIST
99100: ST_TO_ADDR
// break ;
99101: GO 99105
// end ; end ;
99103: GO 98905
99105: POP
99106: POP
// if result then
99107: LD_VAR 0 1
99111: IFFALSE 99171
// begin ToLua ( playSibBomb() ) ;
99113: LD_STRING playSibBomb()
99115: PPUSH
99116: CALL_OW 559
// wait ( 0 0$14 ) ;
99120: LD_INT 490
99122: PPUSH
99123: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99127: LD_VAR 0 1
99131: PUSH
99132: LD_INT 1
99134: ARRAY
99135: PPUSH
99136: LD_VAR 0 1
99140: PUSH
99141: LD_INT 2
99143: ARRAY
99144: PPUSH
99145: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99149: LD_VAR 0 1
99153: PUSH
99154: LD_INT 1
99156: ARRAY
99157: PPUSH
99158: LD_VAR 0 1
99162: PUSH
99163: LD_INT 2
99165: ARRAY
99166: PPUSH
99167: CALL_OW 429
// end ; end ;
99171: LD_VAR 0 1
99175: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99176: LD_EXP 139
99180: PUSH
99181: LD_EXP 161
99185: AND
99186: IFFALSE 99198
99188: GO 99190
99190: DISABLE
// YouLost (  ) ;
99191: LD_STRING 
99193: PPUSH
99194: CALL_OW 104
99198: END
// every 0 0$1 trigger StreamModeActive and sFog do
99199: LD_EXP 139
99203: PUSH
99204: LD_EXP 160
99208: AND
99209: IFFALSE 99223
99211: GO 99213
99213: DISABLE
// FogOff ( your_side ) ;
99214: LD_OWVAR 2
99218: PPUSH
99219: CALL_OW 344
99223: END
// every 0 0$1 trigger StreamModeActive and sSun do
99224: LD_EXP 139
99228: PUSH
99229: LD_EXP 162
99233: AND
99234: IFFALSE 99262
99236: GO 99238
99238: DISABLE
// begin solar_recharge_percent := 0 ;
99239: LD_ADDR_OWVAR 79
99243: PUSH
99244: LD_INT 0
99246: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99247: LD_INT 10500
99249: PPUSH
99250: CALL_OW 67
// solar_recharge_percent := 100 ;
99254: LD_ADDR_OWVAR 79
99258: PUSH
99259: LD_INT 100
99261: ST_TO_ADDR
// end ;
99262: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99263: LD_EXP 139
99267: PUSH
99268: LD_EXP 163
99272: AND
99273: IFFALSE 99512
99275: GO 99277
99277: DISABLE
99278: LD_INT 0
99280: PPUSH
99281: PPUSH
99282: PPUSH
// begin tmp := [ ] ;
99283: LD_ADDR_VAR 0 3
99287: PUSH
99288: EMPTY
99289: ST_TO_ADDR
// for i := 1 to 6 do
99290: LD_ADDR_VAR 0 1
99294: PUSH
99295: DOUBLE
99296: LD_INT 1
99298: DEC
99299: ST_TO_ADDR
99300: LD_INT 6
99302: PUSH
99303: FOR_TO
99304: IFFALSE 99409
// begin uc_nation := nation_nature ;
99306: LD_ADDR_OWVAR 21
99310: PUSH
99311: LD_INT 0
99313: ST_TO_ADDR
// uc_side := 0 ;
99314: LD_ADDR_OWVAR 20
99318: PUSH
99319: LD_INT 0
99321: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99322: LD_ADDR_OWVAR 29
99326: PUSH
99327: LD_INT 12
99329: PUSH
99330: LD_INT 12
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: ST_TO_ADDR
// hc_agressivity := 20 ;
99337: LD_ADDR_OWVAR 35
99341: PUSH
99342: LD_INT 20
99344: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99345: LD_ADDR_OWVAR 28
99349: PUSH
99350: LD_INT 17
99352: ST_TO_ADDR
// hc_gallery :=  ;
99353: LD_ADDR_OWVAR 33
99357: PUSH
99358: LD_STRING 
99360: ST_TO_ADDR
// hc_name :=  ;
99361: LD_ADDR_OWVAR 26
99365: PUSH
99366: LD_STRING 
99368: ST_TO_ADDR
// un := CreateHuman ;
99369: LD_ADDR_VAR 0 2
99373: PUSH
99374: CALL_OW 44
99378: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99379: LD_VAR 0 2
99383: PPUSH
99384: LD_INT 1
99386: PPUSH
99387: CALL_OW 51
// tmp := tmp ^ un ;
99391: LD_ADDR_VAR 0 3
99395: PUSH
99396: LD_VAR 0 3
99400: PUSH
99401: LD_VAR 0 2
99405: ADD
99406: ST_TO_ADDR
// end ;
99407: GO 99303
99409: POP
99410: POP
// repeat wait ( 0 0$1 ) ;
99411: LD_INT 35
99413: PPUSH
99414: CALL_OW 67
// for un in tmp do
99418: LD_ADDR_VAR 0 2
99422: PUSH
99423: LD_VAR 0 3
99427: PUSH
99428: FOR_IN
99429: IFFALSE 99503
// begin if IsDead ( un ) then
99431: LD_VAR 0 2
99435: PPUSH
99436: CALL_OW 301
99440: IFFALSE 99460
// begin tmp := tmp diff un ;
99442: LD_ADDR_VAR 0 3
99446: PUSH
99447: LD_VAR 0 3
99451: PUSH
99452: LD_VAR 0 2
99456: DIFF
99457: ST_TO_ADDR
// continue ;
99458: GO 99428
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99460: LD_VAR 0 2
99464: PPUSH
99465: LD_INT 3
99467: PUSH
99468: LD_INT 22
99470: PUSH
99471: LD_INT 0
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: PPUSH
99482: CALL_OW 69
99486: PPUSH
99487: LD_VAR 0 2
99491: PPUSH
99492: CALL_OW 74
99496: PPUSH
99497: CALL_OW 115
// end ;
99501: GO 99428
99503: POP
99504: POP
// until not tmp ;
99505: LD_VAR 0 3
99509: NOT
99510: IFFALSE 99411
// end ;
99512: PPOPN 3
99514: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99515: LD_EXP 139
99519: PUSH
99520: LD_EXP 164
99524: AND
99525: IFFALSE 99579
99527: GO 99529
99529: DISABLE
// begin ToLua ( displayTroll(); ) ;
99530: LD_STRING displayTroll();
99532: PPUSH
99533: CALL_OW 559
// wait ( 3 3$00 ) ;
99537: LD_INT 6300
99539: PPUSH
99540: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99544: LD_STRING hideTroll();
99546: PPUSH
99547: CALL_OW 559
// wait ( 1 1$00 ) ;
99551: LD_INT 2100
99553: PPUSH
99554: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99558: LD_STRING displayTroll();
99560: PPUSH
99561: CALL_OW 559
// wait ( 1 1$00 ) ;
99565: LD_INT 2100
99567: PPUSH
99568: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99572: LD_STRING hideTroll();
99574: PPUSH
99575: CALL_OW 559
// end ;
99579: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99580: LD_EXP 139
99584: PUSH
99585: LD_EXP 165
99589: AND
99590: IFFALSE 99653
99592: GO 99594
99594: DISABLE
99595: LD_INT 0
99597: PPUSH
// begin p := 0 ;
99598: LD_ADDR_VAR 0 1
99602: PUSH
99603: LD_INT 0
99605: ST_TO_ADDR
// repeat game_speed := 1 ;
99606: LD_ADDR_OWVAR 65
99610: PUSH
99611: LD_INT 1
99613: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99614: LD_INT 35
99616: PPUSH
99617: CALL_OW 67
// p := p + 1 ;
99621: LD_ADDR_VAR 0 1
99625: PUSH
99626: LD_VAR 0 1
99630: PUSH
99631: LD_INT 1
99633: PLUS
99634: ST_TO_ADDR
// until p >= 60 ;
99635: LD_VAR 0 1
99639: PUSH
99640: LD_INT 60
99642: GREATEREQUAL
99643: IFFALSE 99606
// game_speed := 4 ;
99645: LD_ADDR_OWVAR 65
99649: PUSH
99650: LD_INT 4
99652: ST_TO_ADDR
// end ;
99653: PPOPN 1
99655: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99656: LD_EXP 139
99660: PUSH
99661: LD_EXP 166
99665: AND
99666: IFFALSE 99812
99668: GO 99670
99670: DISABLE
99671: LD_INT 0
99673: PPUSH
99674: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99675: LD_ADDR_VAR 0 1
99679: PUSH
99680: LD_INT 22
99682: PUSH
99683: LD_OWVAR 2
99687: PUSH
99688: EMPTY
99689: LIST
99690: LIST
99691: PUSH
99692: LD_INT 2
99694: PUSH
99695: LD_INT 30
99697: PUSH
99698: LD_INT 0
99700: PUSH
99701: EMPTY
99702: LIST
99703: LIST
99704: PUSH
99705: LD_INT 30
99707: PUSH
99708: LD_INT 1
99710: PUSH
99711: EMPTY
99712: LIST
99713: LIST
99714: PUSH
99715: EMPTY
99716: LIST
99717: LIST
99718: LIST
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PPUSH
99724: CALL_OW 69
99728: ST_TO_ADDR
// if not depot then
99729: LD_VAR 0 1
99733: NOT
99734: IFFALSE 99738
// exit ;
99736: GO 99812
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99738: LD_ADDR_VAR 0 2
99742: PUSH
99743: LD_VAR 0 1
99747: PUSH
99748: LD_INT 1
99750: PPUSH
99751: LD_VAR 0 1
99755: PPUSH
99756: CALL_OW 12
99760: ARRAY
99761: PPUSH
99762: CALL_OW 274
99766: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99767: LD_VAR 0 2
99771: PPUSH
99772: LD_INT 1
99774: PPUSH
99775: LD_INT 0
99777: PPUSH
99778: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99782: LD_VAR 0 2
99786: PPUSH
99787: LD_INT 2
99789: PPUSH
99790: LD_INT 0
99792: PPUSH
99793: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99797: LD_VAR 0 2
99801: PPUSH
99802: LD_INT 3
99804: PPUSH
99805: LD_INT 0
99807: PPUSH
99808: CALL_OW 277
// end ;
99812: PPOPN 2
99814: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99815: LD_EXP 139
99819: PUSH
99820: LD_EXP 167
99824: AND
99825: IFFALSE 99922
99827: GO 99829
99829: DISABLE
99830: LD_INT 0
99832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99833: LD_ADDR_VAR 0 1
99837: PUSH
99838: LD_INT 22
99840: PUSH
99841: LD_OWVAR 2
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: LD_INT 21
99852: PUSH
99853: LD_INT 1
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 3
99862: PUSH
99863: LD_INT 23
99865: PUSH
99866: LD_INT 0
99868: PUSH
99869: EMPTY
99870: LIST
99871: LIST
99872: PUSH
99873: EMPTY
99874: LIST
99875: LIST
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: LIST
99881: PPUSH
99882: CALL_OW 69
99886: ST_TO_ADDR
// if not tmp then
99887: LD_VAR 0 1
99891: NOT
99892: IFFALSE 99896
// exit ;
99894: GO 99922
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99896: LD_VAR 0 1
99900: PUSH
99901: LD_INT 1
99903: PPUSH
99904: LD_VAR 0 1
99908: PPUSH
99909: CALL_OW 12
99913: ARRAY
99914: PPUSH
99915: LD_INT 200
99917: PPUSH
99918: CALL_OW 234
// end ;
99922: PPOPN 1
99924: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99925: LD_EXP 139
99929: PUSH
99930: LD_EXP 168
99934: AND
99935: IFFALSE 100014
99937: GO 99939
99939: DISABLE
99940: LD_INT 0
99942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99943: LD_ADDR_VAR 0 1
99947: PUSH
99948: LD_INT 22
99950: PUSH
99951: LD_OWVAR 2
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: PUSH
99960: LD_INT 21
99962: PUSH
99963: LD_INT 2
99965: PUSH
99966: EMPTY
99967: LIST
99968: LIST
99969: PUSH
99970: EMPTY
99971: LIST
99972: LIST
99973: PPUSH
99974: CALL_OW 69
99978: ST_TO_ADDR
// if not tmp then
99979: LD_VAR 0 1
99983: NOT
99984: IFFALSE 99988
// exit ;
99986: GO 100014
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99988: LD_VAR 0 1
99992: PUSH
99993: LD_INT 1
99995: PPUSH
99996: LD_VAR 0 1
100000: PPUSH
100001: CALL_OW 12
100005: ARRAY
100006: PPUSH
100007: LD_INT 60
100009: PPUSH
100010: CALL_OW 234
// end ;
100014: PPOPN 1
100016: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100017: LD_EXP 139
100021: PUSH
100022: LD_EXP 169
100026: AND
100027: IFFALSE 100126
100029: GO 100031
100031: DISABLE
100032: LD_INT 0
100034: PPUSH
100035: PPUSH
// begin enable ;
100036: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100037: LD_ADDR_VAR 0 1
100041: PUSH
100042: LD_INT 22
100044: PUSH
100045: LD_OWVAR 2
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: PUSH
100054: LD_INT 61
100056: PUSH
100057: EMPTY
100058: LIST
100059: PUSH
100060: LD_INT 33
100062: PUSH
100063: LD_INT 2
100065: PUSH
100066: EMPTY
100067: LIST
100068: LIST
100069: PUSH
100070: EMPTY
100071: LIST
100072: LIST
100073: LIST
100074: PPUSH
100075: CALL_OW 69
100079: ST_TO_ADDR
// if not tmp then
100080: LD_VAR 0 1
100084: NOT
100085: IFFALSE 100089
// exit ;
100087: GO 100126
// for i in tmp do
100089: LD_ADDR_VAR 0 2
100093: PUSH
100094: LD_VAR 0 1
100098: PUSH
100099: FOR_IN
100100: IFFALSE 100124
// if IsControledBy ( i ) then
100102: LD_VAR 0 2
100106: PPUSH
100107: CALL_OW 312
100111: IFFALSE 100122
// ComUnlink ( i ) ;
100113: LD_VAR 0 2
100117: PPUSH
100118: CALL_OW 136
100122: GO 100099
100124: POP
100125: POP
// end ;
100126: PPOPN 2
100128: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100129: LD_EXP 139
100133: PUSH
100134: LD_EXP 170
100138: AND
100139: IFFALSE 100279
100141: GO 100143
100143: DISABLE
100144: LD_INT 0
100146: PPUSH
100147: PPUSH
// begin ToLua ( displayPowell(); ) ;
100148: LD_STRING displayPowell();
100150: PPUSH
100151: CALL_OW 559
// uc_side := 0 ;
100155: LD_ADDR_OWVAR 20
100159: PUSH
100160: LD_INT 0
100162: ST_TO_ADDR
// uc_nation := 2 ;
100163: LD_ADDR_OWVAR 21
100167: PUSH
100168: LD_INT 2
100170: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100171: LD_ADDR_OWVAR 37
100175: PUSH
100176: LD_INT 14
100178: ST_TO_ADDR
// vc_engine := engine_siberite ;
100179: LD_ADDR_OWVAR 39
100183: PUSH
100184: LD_INT 3
100186: ST_TO_ADDR
// vc_control := control_apeman ;
100187: LD_ADDR_OWVAR 38
100191: PUSH
100192: LD_INT 5
100194: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100195: LD_ADDR_OWVAR 40
100199: PUSH
100200: LD_INT 29
100202: ST_TO_ADDR
// un := CreateVehicle ;
100203: LD_ADDR_VAR 0 2
100207: PUSH
100208: CALL_OW 45
100212: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100213: LD_VAR 0 2
100217: PPUSH
100218: LD_INT 1
100220: PPUSH
100221: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100225: LD_INT 35
100227: PPUSH
100228: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100232: LD_VAR 0 2
100236: PPUSH
100237: LD_INT 22
100239: PUSH
100240: LD_OWVAR 2
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PPUSH
100249: CALL_OW 69
100253: PPUSH
100254: LD_VAR 0 2
100258: PPUSH
100259: CALL_OW 74
100263: PPUSH
100264: CALL_OW 115
// until IsDead ( un ) ;
100268: LD_VAR 0 2
100272: PPUSH
100273: CALL_OW 301
100277: IFFALSE 100225
// end ;
100279: PPOPN 2
100281: END
// every 0 0$1 trigger StreamModeActive and sStu do
100282: LD_EXP 139
100286: PUSH
100287: LD_EXP 178
100291: AND
100292: IFFALSE 100308
100294: GO 100296
100296: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100297: LD_STRING displayStucuk();
100299: PPUSH
100300: CALL_OW 559
// ResetFog ;
100304: CALL_OW 335
// end ;
100308: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100309: LD_EXP 139
100313: PUSH
100314: LD_EXP 171
100318: AND
100319: IFFALSE 100460
100321: GO 100323
100323: DISABLE
100324: LD_INT 0
100326: PPUSH
100327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100328: LD_ADDR_VAR 0 2
100332: PUSH
100333: LD_INT 22
100335: PUSH
100336: LD_OWVAR 2
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: PUSH
100345: LD_INT 21
100347: PUSH
100348: LD_INT 1
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: PPUSH
100359: CALL_OW 69
100363: ST_TO_ADDR
// if not tmp then
100364: LD_VAR 0 2
100368: NOT
100369: IFFALSE 100373
// exit ;
100371: GO 100460
// un := tmp [ rand ( 1 , tmp ) ] ;
100373: LD_ADDR_VAR 0 1
100377: PUSH
100378: LD_VAR 0 2
100382: PUSH
100383: LD_INT 1
100385: PPUSH
100386: LD_VAR 0 2
100390: PPUSH
100391: CALL_OW 12
100395: ARRAY
100396: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100397: LD_VAR 0 1
100401: PPUSH
100402: LD_INT 0
100404: PPUSH
100405: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100409: LD_VAR 0 1
100413: PPUSH
100414: LD_OWVAR 3
100418: PUSH
100419: LD_VAR 0 1
100423: DIFF
100424: PPUSH
100425: LD_VAR 0 1
100429: PPUSH
100430: CALL_OW 74
100434: PPUSH
100435: CALL_OW 115
// wait ( 0 0$20 ) ;
100439: LD_INT 700
100441: PPUSH
100442: CALL_OW 67
// SetSide ( un , your_side ) ;
100446: LD_VAR 0 1
100450: PPUSH
100451: LD_OWVAR 2
100455: PPUSH
100456: CALL_OW 235
// end ;
100460: PPOPN 2
100462: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100463: LD_EXP 139
100467: PUSH
100468: LD_EXP 172
100472: AND
100473: IFFALSE 100579
100475: GO 100477
100477: DISABLE
100478: LD_INT 0
100480: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100481: LD_ADDR_VAR 0 1
100485: PUSH
100486: LD_INT 22
100488: PUSH
100489: LD_OWVAR 2
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: PUSH
100498: LD_INT 2
100500: PUSH
100501: LD_INT 30
100503: PUSH
100504: LD_INT 0
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: LD_INT 30
100513: PUSH
100514: LD_INT 1
100516: PUSH
100517: EMPTY
100518: LIST
100519: LIST
100520: PUSH
100521: EMPTY
100522: LIST
100523: LIST
100524: LIST
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PPUSH
100530: CALL_OW 69
100534: ST_TO_ADDR
// if not depot then
100535: LD_VAR 0 1
100539: NOT
100540: IFFALSE 100544
// exit ;
100542: GO 100579
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100544: LD_VAR 0 1
100548: PUSH
100549: LD_INT 1
100551: ARRAY
100552: PPUSH
100553: CALL_OW 250
100557: PPUSH
100558: LD_VAR 0 1
100562: PUSH
100563: LD_INT 1
100565: ARRAY
100566: PPUSH
100567: CALL_OW 251
100571: PPUSH
100572: LD_INT 70
100574: PPUSH
100575: CALL_OW 495
// end ;
100579: PPOPN 1
100581: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100582: LD_EXP 139
100586: PUSH
100587: LD_EXP 173
100591: AND
100592: IFFALSE 100803
100594: GO 100596
100596: DISABLE
100597: LD_INT 0
100599: PPUSH
100600: PPUSH
100601: PPUSH
100602: PPUSH
100603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100604: LD_ADDR_VAR 0 5
100608: PUSH
100609: LD_INT 22
100611: PUSH
100612: LD_OWVAR 2
100616: PUSH
100617: EMPTY
100618: LIST
100619: LIST
100620: PUSH
100621: LD_INT 21
100623: PUSH
100624: LD_INT 1
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: PPUSH
100635: CALL_OW 69
100639: ST_TO_ADDR
// if not tmp then
100640: LD_VAR 0 5
100644: NOT
100645: IFFALSE 100649
// exit ;
100647: GO 100803
// for i in tmp do
100649: LD_ADDR_VAR 0 1
100653: PUSH
100654: LD_VAR 0 5
100658: PUSH
100659: FOR_IN
100660: IFFALSE 100801
// begin d := rand ( 0 , 5 ) ;
100662: LD_ADDR_VAR 0 4
100666: PUSH
100667: LD_INT 0
100669: PPUSH
100670: LD_INT 5
100672: PPUSH
100673: CALL_OW 12
100677: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100678: LD_ADDR_VAR 0 2
100682: PUSH
100683: LD_VAR 0 1
100687: PPUSH
100688: CALL_OW 250
100692: PPUSH
100693: LD_VAR 0 4
100697: PPUSH
100698: LD_INT 3
100700: PPUSH
100701: LD_INT 12
100703: PPUSH
100704: CALL_OW 12
100708: PPUSH
100709: CALL_OW 272
100713: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100714: LD_ADDR_VAR 0 3
100718: PUSH
100719: LD_VAR 0 1
100723: PPUSH
100724: CALL_OW 251
100728: PPUSH
100729: LD_VAR 0 4
100733: PPUSH
100734: LD_INT 3
100736: PPUSH
100737: LD_INT 12
100739: PPUSH
100740: CALL_OW 12
100744: PPUSH
100745: CALL_OW 273
100749: ST_TO_ADDR
// if ValidHex ( x , y ) then
100750: LD_VAR 0 2
100754: PPUSH
100755: LD_VAR 0 3
100759: PPUSH
100760: CALL_OW 488
100764: IFFALSE 100799
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100766: LD_VAR 0 1
100770: PPUSH
100771: LD_VAR 0 2
100775: PPUSH
100776: LD_VAR 0 3
100780: PPUSH
100781: LD_INT 3
100783: PPUSH
100784: LD_INT 6
100786: PPUSH
100787: CALL_OW 12
100791: PPUSH
100792: LD_INT 1
100794: PPUSH
100795: CALL_OW 483
// end ;
100799: GO 100659
100801: POP
100802: POP
// end ;
100803: PPOPN 5
100805: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100806: LD_EXP 139
100810: PUSH
100811: LD_EXP 174
100815: AND
100816: IFFALSE 100910
100818: GO 100820
100820: DISABLE
100821: LD_INT 0
100823: PPUSH
100824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100825: LD_ADDR_VAR 0 2
100829: PUSH
100830: LD_INT 22
100832: PUSH
100833: LD_OWVAR 2
100837: PUSH
100838: EMPTY
100839: LIST
100840: LIST
100841: PUSH
100842: LD_INT 32
100844: PUSH
100845: LD_INT 1
100847: PUSH
100848: EMPTY
100849: LIST
100850: LIST
100851: PUSH
100852: LD_INT 21
100854: PUSH
100855: LD_INT 2
100857: PUSH
100858: EMPTY
100859: LIST
100860: LIST
100861: PUSH
100862: EMPTY
100863: LIST
100864: LIST
100865: LIST
100866: PPUSH
100867: CALL_OW 69
100871: ST_TO_ADDR
// if not tmp then
100872: LD_VAR 0 2
100876: NOT
100877: IFFALSE 100881
// exit ;
100879: GO 100910
// for i in tmp do
100881: LD_ADDR_VAR 0 1
100885: PUSH
100886: LD_VAR 0 2
100890: PUSH
100891: FOR_IN
100892: IFFALSE 100908
// SetFuel ( i , 0 ) ;
100894: LD_VAR 0 1
100898: PPUSH
100899: LD_INT 0
100901: PPUSH
100902: CALL_OW 240
100906: GO 100891
100908: POP
100909: POP
// end ;
100910: PPOPN 2
100912: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100913: LD_EXP 139
100917: PUSH
100918: LD_EXP 175
100922: AND
100923: IFFALSE 100989
100925: GO 100927
100927: DISABLE
100928: LD_INT 0
100930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100931: LD_ADDR_VAR 0 1
100935: PUSH
100936: LD_INT 22
100938: PUSH
100939: LD_OWVAR 2
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: PUSH
100948: LD_INT 30
100950: PUSH
100951: LD_INT 29
100953: PUSH
100954: EMPTY
100955: LIST
100956: LIST
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PPUSH
100962: CALL_OW 69
100966: ST_TO_ADDR
// if not tmp then
100967: LD_VAR 0 1
100971: NOT
100972: IFFALSE 100976
// exit ;
100974: GO 100989
// DestroyUnit ( tmp [ 1 ] ) ;
100976: LD_VAR 0 1
100980: PUSH
100981: LD_INT 1
100983: ARRAY
100984: PPUSH
100985: CALL_OW 65
// end ;
100989: PPOPN 1
100991: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100992: LD_EXP 139
100996: PUSH
100997: LD_EXP 177
101001: AND
101002: IFFALSE 101131
101004: GO 101006
101006: DISABLE
101007: LD_INT 0
101009: PPUSH
// begin uc_side := 0 ;
101010: LD_ADDR_OWVAR 20
101014: PUSH
101015: LD_INT 0
101017: ST_TO_ADDR
// uc_nation := nation_arabian ;
101018: LD_ADDR_OWVAR 21
101022: PUSH
101023: LD_INT 2
101025: ST_TO_ADDR
// hc_gallery :=  ;
101026: LD_ADDR_OWVAR 33
101030: PUSH
101031: LD_STRING 
101033: ST_TO_ADDR
// hc_name :=  ;
101034: LD_ADDR_OWVAR 26
101038: PUSH
101039: LD_STRING 
101041: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101042: LD_INT 1
101044: PPUSH
101045: LD_INT 11
101047: PPUSH
101048: LD_INT 10
101050: PPUSH
101051: CALL_OW 380
// un := CreateHuman ;
101055: LD_ADDR_VAR 0 1
101059: PUSH
101060: CALL_OW 44
101064: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101065: LD_VAR 0 1
101069: PPUSH
101070: LD_INT 1
101072: PPUSH
101073: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101077: LD_INT 35
101079: PPUSH
101080: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101084: LD_VAR 0 1
101088: PPUSH
101089: LD_INT 22
101091: PUSH
101092: LD_OWVAR 2
101096: PUSH
101097: EMPTY
101098: LIST
101099: LIST
101100: PPUSH
101101: CALL_OW 69
101105: PPUSH
101106: LD_VAR 0 1
101110: PPUSH
101111: CALL_OW 74
101115: PPUSH
101116: CALL_OW 115
// until IsDead ( un ) ;
101120: LD_VAR 0 1
101124: PPUSH
101125: CALL_OW 301
101129: IFFALSE 101077
// end ;
101131: PPOPN 1
101133: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101134: LD_EXP 139
101138: PUSH
101139: LD_EXP 179
101143: AND
101144: IFFALSE 101156
101146: GO 101148
101148: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101149: LD_STRING earthquake(getX(game), 0, 32)
101151: PPUSH
101152: CALL_OW 559
101156: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101157: LD_EXP 139
101161: PUSH
101162: LD_EXP 180
101166: AND
101167: IFFALSE 101258
101169: GO 101171
101171: DISABLE
101172: LD_INT 0
101174: PPUSH
// begin enable ;
101175: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101176: LD_ADDR_VAR 0 1
101180: PUSH
101181: LD_INT 22
101183: PUSH
101184: LD_OWVAR 2
101188: PUSH
101189: EMPTY
101190: LIST
101191: LIST
101192: PUSH
101193: LD_INT 21
101195: PUSH
101196: LD_INT 2
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 33
101205: PUSH
101206: LD_INT 3
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: LIST
101217: PPUSH
101218: CALL_OW 69
101222: ST_TO_ADDR
// if not tmp then
101223: LD_VAR 0 1
101227: NOT
101228: IFFALSE 101232
// exit ;
101230: GO 101258
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101232: LD_VAR 0 1
101236: PUSH
101237: LD_INT 1
101239: PPUSH
101240: LD_VAR 0 1
101244: PPUSH
101245: CALL_OW 12
101249: ARRAY
101250: PPUSH
101251: LD_INT 1
101253: PPUSH
101254: CALL_OW 234
// end ;
101258: PPOPN 1
101260: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101261: LD_EXP 139
101265: PUSH
101266: LD_EXP 181
101270: AND
101271: IFFALSE 101412
101273: GO 101275
101275: DISABLE
101276: LD_INT 0
101278: PPUSH
101279: PPUSH
101280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101281: LD_ADDR_VAR 0 3
101285: PUSH
101286: LD_INT 22
101288: PUSH
101289: LD_OWVAR 2
101293: PUSH
101294: EMPTY
101295: LIST
101296: LIST
101297: PUSH
101298: LD_INT 25
101300: PUSH
101301: LD_INT 1
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PPUSH
101312: CALL_OW 69
101316: ST_TO_ADDR
// if not tmp then
101317: LD_VAR 0 3
101321: NOT
101322: IFFALSE 101326
// exit ;
101324: GO 101412
// un := tmp [ rand ( 1 , tmp ) ] ;
101326: LD_ADDR_VAR 0 2
101330: PUSH
101331: LD_VAR 0 3
101335: PUSH
101336: LD_INT 1
101338: PPUSH
101339: LD_VAR 0 3
101343: PPUSH
101344: CALL_OW 12
101348: ARRAY
101349: ST_TO_ADDR
// if Crawls ( un ) then
101350: LD_VAR 0 2
101354: PPUSH
101355: CALL_OW 318
101359: IFFALSE 101370
// ComWalk ( un ) ;
101361: LD_VAR 0 2
101365: PPUSH
101366: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101370: LD_VAR 0 2
101374: PPUSH
101375: LD_INT 9
101377: PPUSH
101378: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101382: LD_INT 28
101384: PPUSH
101385: LD_OWVAR 2
101389: PPUSH
101390: LD_INT 2
101392: PPUSH
101393: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101397: LD_INT 29
101399: PPUSH
101400: LD_OWVAR 2
101404: PPUSH
101405: LD_INT 2
101407: PPUSH
101408: CALL_OW 322
// end ;
101412: PPOPN 3
101414: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101415: LD_EXP 139
101419: PUSH
101420: LD_EXP 182
101424: AND
101425: IFFALSE 101536
101427: GO 101429
101429: DISABLE
101430: LD_INT 0
101432: PPUSH
101433: PPUSH
101434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101435: LD_ADDR_VAR 0 3
101439: PUSH
101440: LD_INT 22
101442: PUSH
101443: LD_OWVAR 2
101447: PUSH
101448: EMPTY
101449: LIST
101450: LIST
101451: PUSH
101452: LD_INT 25
101454: PUSH
101455: LD_INT 1
101457: PUSH
101458: EMPTY
101459: LIST
101460: LIST
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: PPUSH
101466: CALL_OW 69
101470: ST_TO_ADDR
// if not tmp then
101471: LD_VAR 0 3
101475: NOT
101476: IFFALSE 101480
// exit ;
101478: GO 101536
// un := tmp [ rand ( 1 , tmp ) ] ;
101480: LD_ADDR_VAR 0 2
101484: PUSH
101485: LD_VAR 0 3
101489: PUSH
101490: LD_INT 1
101492: PPUSH
101493: LD_VAR 0 3
101497: PPUSH
101498: CALL_OW 12
101502: ARRAY
101503: ST_TO_ADDR
// if Crawls ( un ) then
101504: LD_VAR 0 2
101508: PPUSH
101509: CALL_OW 318
101513: IFFALSE 101524
// ComWalk ( un ) ;
101515: LD_VAR 0 2
101519: PPUSH
101520: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101524: LD_VAR 0 2
101528: PPUSH
101529: LD_INT 8
101531: PPUSH
101532: CALL_OW 336
// end ;
101536: PPOPN 3
101538: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101539: LD_EXP 139
101543: PUSH
101544: LD_EXP 183
101548: AND
101549: IFFALSE 101693
101551: GO 101553
101553: DISABLE
101554: LD_INT 0
101556: PPUSH
101557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101558: LD_ADDR_VAR 0 2
101562: PUSH
101563: LD_INT 22
101565: PUSH
101566: LD_OWVAR 2
101570: PUSH
101571: EMPTY
101572: LIST
101573: LIST
101574: PUSH
101575: LD_INT 21
101577: PUSH
101578: LD_INT 2
101580: PUSH
101581: EMPTY
101582: LIST
101583: LIST
101584: PUSH
101585: LD_INT 2
101587: PUSH
101588: LD_INT 34
101590: PUSH
101591: LD_INT 12
101593: PUSH
101594: EMPTY
101595: LIST
101596: LIST
101597: PUSH
101598: LD_INT 34
101600: PUSH
101601: LD_INT 51
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 34
101610: PUSH
101611: LD_INT 32
101613: PUSH
101614: EMPTY
101615: LIST
101616: LIST
101617: PUSH
101618: EMPTY
101619: LIST
101620: LIST
101621: LIST
101622: LIST
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: LIST
101628: PPUSH
101629: CALL_OW 69
101633: ST_TO_ADDR
// if not tmp then
101634: LD_VAR 0 2
101638: NOT
101639: IFFALSE 101643
// exit ;
101641: GO 101693
// for i in tmp do
101643: LD_ADDR_VAR 0 1
101647: PUSH
101648: LD_VAR 0 2
101652: PUSH
101653: FOR_IN
101654: IFFALSE 101691
// if GetCargo ( i , mat_artifact ) = 0 then
101656: LD_VAR 0 1
101660: PPUSH
101661: LD_INT 4
101663: PPUSH
101664: CALL_OW 289
101668: PUSH
101669: LD_INT 0
101671: EQUAL
101672: IFFALSE 101689
// SetCargo ( i , mat_siberit , 100 ) ;
101674: LD_VAR 0 1
101678: PPUSH
101679: LD_INT 3
101681: PPUSH
101682: LD_INT 100
101684: PPUSH
101685: CALL_OW 290
101689: GO 101653
101691: POP
101692: POP
// end ;
101693: PPOPN 2
101695: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101696: LD_EXP 139
101700: PUSH
101701: LD_EXP 184
101705: AND
101706: IFFALSE 101889
101708: GO 101710
101710: DISABLE
101711: LD_INT 0
101713: PPUSH
101714: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101715: LD_ADDR_VAR 0 2
101719: PUSH
101720: LD_INT 22
101722: PUSH
101723: LD_OWVAR 2
101727: PUSH
101728: EMPTY
101729: LIST
101730: LIST
101731: PPUSH
101732: CALL_OW 69
101736: ST_TO_ADDR
// if not tmp then
101737: LD_VAR 0 2
101741: NOT
101742: IFFALSE 101746
// exit ;
101744: GO 101889
// for i := 1 to 2 do
101746: LD_ADDR_VAR 0 1
101750: PUSH
101751: DOUBLE
101752: LD_INT 1
101754: DEC
101755: ST_TO_ADDR
101756: LD_INT 2
101758: PUSH
101759: FOR_TO
101760: IFFALSE 101887
// begin uc_side := your_side ;
101762: LD_ADDR_OWVAR 20
101766: PUSH
101767: LD_OWVAR 2
101771: ST_TO_ADDR
// uc_nation := nation_american ;
101772: LD_ADDR_OWVAR 21
101776: PUSH
101777: LD_INT 1
101779: ST_TO_ADDR
// vc_chassis := us_morphling ;
101780: LD_ADDR_OWVAR 37
101784: PUSH
101785: LD_INT 5
101787: ST_TO_ADDR
// vc_engine := engine_siberite ;
101788: LD_ADDR_OWVAR 39
101792: PUSH
101793: LD_INT 3
101795: ST_TO_ADDR
// vc_control := control_computer ;
101796: LD_ADDR_OWVAR 38
101800: PUSH
101801: LD_INT 3
101803: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101804: LD_ADDR_OWVAR 40
101808: PUSH
101809: LD_INT 10
101811: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101812: LD_VAR 0 2
101816: PUSH
101817: LD_INT 1
101819: ARRAY
101820: PPUSH
101821: CALL_OW 310
101825: NOT
101826: IFFALSE 101873
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101828: CALL_OW 45
101832: PPUSH
101833: LD_VAR 0 2
101837: PUSH
101838: LD_INT 1
101840: ARRAY
101841: PPUSH
101842: CALL_OW 250
101846: PPUSH
101847: LD_VAR 0 2
101851: PUSH
101852: LD_INT 1
101854: ARRAY
101855: PPUSH
101856: CALL_OW 251
101860: PPUSH
101861: LD_INT 12
101863: PPUSH
101864: LD_INT 1
101866: PPUSH
101867: CALL_OW 50
101871: GO 101885
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101873: CALL_OW 45
101877: PPUSH
101878: LD_INT 1
101880: PPUSH
101881: CALL_OW 51
// end ;
101885: GO 101759
101887: POP
101888: POP
// end ;
101889: PPOPN 2
101891: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101892: LD_EXP 139
101896: PUSH
101897: LD_EXP 185
101901: AND
101902: IFFALSE 102124
101904: GO 101906
101906: DISABLE
101907: LD_INT 0
101909: PPUSH
101910: PPUSH
101911: PPUSH
101912: PPUSH
101913: PPUSH
101914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101915: LD_ADDR_VAR 0 6
101919: PUSH
101920: LD_INT 22
101922: PUSH
101923: LD_OWVAR 2
101927: PUSH
101928: EMPTY
101929: LIST
101930: LIST
101931: PUSH
101932: LD_INT 21
101934: PUSH
101935: LD_INT 1
101937: PUSH
101938: EMPTY
101939: LIST
101940: LIST
101941: PUSH
101942: LD_INT 3
101944: PUSH
101945: LD_INT 23
101947: PUSH
101948: LD_INT 0
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PUSH
101959: EMPTY
101960: LIST
101961: LIST
101962: LIST
101963: PPUSH
101964: CALL_OW 69
101968: ST_TO_ADDR
// if not tmp then
101969: LD_VAR 0 6
101973: NOT
101974: IFFALSE 101978
// exit ;
101976: GO 102124
// s1 := rand ( 1 , 4 ) ;
101978: LD_ADDR_VAR 0 2
101982: PUSH
101983: LD_INT 1
101985: PPUSH
101986: LD_INT 4
101988: PPUSH
101989: CALL_OW 12
101993: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101994: LD_ADDR_VAR 0 4
101998: PUSH
101999: LD_VAR 0 6
102003: PUSH
102004: LD_INT 1
102006: ARRAY
102007: PPUSH
102008: LD_VAR 0 2
102012: PPUSH
102013: CALL_OW 259
102017: ST_TO_ADDR
// if s1 = 1 then
102018: LD_VAR 0 2
102022: PUSH
102023: LD_INT 1
102025: EQUAL
102026: IFFALSE 102046
// s2 := rand ( 2 , 4 ) else
102028: LD_ADDR_VAR 0 3
102032: PUSH
102033: LD_INT 2
102035: PPUSH
102036: LD_INT 4
102038: PPUSH
102039: CALL_OW 12
102043: ST_TO_ADDR
102044: GO 102054
// s2 := 1 ;
102046: LD_ADDR_VAR 0 3
102050: PUSH
102051: LD_INT 1
102053: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102054: LD_ADDR_VAR 0 5
102058: PUSH
102059: LD_VAR 0 6
102063: PUSH
102064: LD_INT 1
102066: ARRAY
102067: PPUSH
102068: LD_VAR 0 3
102072: PPUSH
102073: CALL_OW 259
102077: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102078: LD_VAR 0 6
102082: PUSH
102083: LD_INT 1
102085: ARRAY
102086: PPUSH
102087: LD_VAR 0 2
102091: PPUSH
102092: LD_VAR 0 5
102096: PPUSH
102097: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102101: LD_VAR 0 6
102105: PUSH
102106: LD_INT 1
102108: ARRAY
102109: PPUSH
102110: LD_VAR 0 3
102114: PPUSH
102115: LD_VAR 0 4
102119: PPUSH
102120: CALL_OW 237
// end ;
102124: PPOPN 6
102126: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102127: LD_EXP 139
102131: PUSH
102132: LD_EXP 186
102136: AND
102137: IFFALSE 102216
102139: GO 102141
102141: DISABLE
102142: LD_INT 0
102144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102145: LD_ADDR_VAR 0 1
102149: PUSH
102150: LD_INT 22
102152: PUSH
102153: LD_OWVAR 2
102157: PUSH
102158: EMPTY
102159: LIST
102160: LIST
102161: PUSH
102162: LD_INT 30
102164: PUSH
102165: LD_INT 3
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: PUSH
102172: EMPTY
102173: LIST
102174: LIST
102175: PPUSH
102176: CALL_OW 69
102180: ST_TO_ADDR
// if not tmp then
102181: LD_VAR 0 1
102185: NOT
102186: IFFALSE 102190
// exit ;
102188: GO 102216
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102190: LD_VAR 0 1
102194: PUSH
102195: LD_INT 1
102197: PPUSH
102198: LD_VAR 0 1
102202: PPUSH
102203: CALL_OW 12
102207: ARRAY
102208: PPUSH
102209: LD_INT 1
102211: PPUSH
102212: CALL_OW 234
// end ;
102216: PPOPN 1
102218: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102219: LD_EXP 139
102223: PUSH
102224: LD_EXP 187
102228: AND
102229: IFFALSE 102341
102231: GO 102233
102233: DISABLE
102234: LD_INT 0
102236: PPUSH
102237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102238: LD_ADDR_VAR 0 2
102242: PUSH
102243: LD_INT 22
102245: PUSH
102246: LD_OWVAR 2
102250: PUSH
102251: EMPTY
102252: LIST
102253: LIST
102254: PUSH
102255: LD_INT 2
102257: PUSH
102258: LD_INT 30
102260: PUSH
102261: LD_INT 27
102263: PUSH
102264: EMPTY
102265: LIST
102266: LIST
102267: PUSH
102268: LD_INT 30
102270: PUSH
102271: LD_INT 26
102273: PUSH
102274: EMPTY
102275: LIST
102276: LIST
102277: PUSH
102278: LD_INT 30
102280: PUSH
102281: LD_INT 28
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: PUSH
102288: EMPTY
102289: LIST
102290: LIST
102291: LIST
102292: LIST
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: PPUSH
102298: CALL_OW 69
102302: ST_TO_ADDR
// if not tmp then
102303: LD_VAR 0 2
102307: NOT
102308: IFFALSE 102312
// exit ;
102310: GO 102341
// for i in tmp do
102312: LD_ADDR_VAR 0 1
102316: PUSH
102317: LD_VAR 0 2
102321: PUSH
102322: FOR_IN
102323: IFFALSE 102339
// SetLives ( i , 1 ) ;
102325: LD_VAR 0 1
102329: PPUSH
102330: LD_INT 1
102332: PPUSH
102333: CALL_OW 234
102337: GO 102322
102339: POP
102340: POP
// end ;
102341: PPOPN 2
102343: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102344: LD_EXP 139
102348: PUSH
102349: LD_EXP 188
102353: AND
102354: IFFALSE 102641
102356: GO 102358
102358: DISABLE
102359: LD_INT 0
102361: PPUSH
102362: PPUSH
102363: PPUSH
// begin i := rand ( 1 , 7 ) ;
102364: LD_ADDR_VAR 0 1
102368: PUSH
102369: LD_INT 1
102371: PPUSH
102372: LD_INT 7
102374: PPUSH
102375: CALL_OW 12
102379: ST_TO_ADDR
// case i of 1 :
102380: LD_VAR 0 1
102384: PUSH
102385: LD_INT 1
102387: DOUBLE
102388: EQUAL
102389: IFTRUE 102393
102391: GO 102403
102393: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102394: LD_STRING earthquake(getX(game), 0, 32)
102396: PPUSH
102397: CALL_OW 559
102401: GO 102641
102403: LD_INT 2
102405: DOUBLE
102406: EQUAL
102407: IFTRUE 102411
102409: GO 102425
102411: POP
// begin ToLua ( displayStucuk(); ) ;
102412: LD_STRING displayStucuk();
102414: PPUSH
102415: CALL_OW 559
// ResetFog ;
102419: CALL_OW 335
// end ; 3 :
102423: GO 102641
102425: LD_INT 3
102427: DOUBLE
102428: EQUAL
102429: IFTRUE 102433
102431: GO 102537
102433: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102434: LD_ADDR_VAR 0 2
102438: PUSH
102439: LD_INT 22
102441: PUSH
102442: LD_OWVAR 2
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: PUSH
102451: LD_INT 25
102453: PUSH
102454: LD_INT 1
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PPUSH
102465: CALL_OW 69
102469: ST_TO_ADDR
// if not tmp then
102470: LD_VAR 0 2
102474: NOT
102475: IFFALSE 102479
// exit ;
102477: GO 102641
// un := tmp [ rand ( 1 , tmp ) ] ;
102479: LD_ADDR_VAR 0 3
102483: PUSH
102484: LD_VAR 0 2
102488: PUSH
102489: LD_INT 1
102491: PPUSH
102492: LD_VAR 0 2
102496: PPUSH
102497: CALL_OW 12
102501: ARRAY
102502: ST_TO_ADDR
// if Crawls ( un ) then
102503: LD_VAR 0 3
102507: PPUSH
102508: CALL_OW 318
102512: IFFALSE 102523
// ComWalk ( un ) ;
102514: LD_VAR 0 3
102518: PPUSH
102519: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102523: LD_VAR 0 3
102527: PPUSH
102528: LD_INT 8
102530: PPUSH
102531: CALL_OW 336
// end ; 4 :
102535: GO 102641
102537: LD_INT 4
102539: DOUBLE
102540: EQUAL
102541: IFTRUE 102545
102543: GO 102619
102545: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102546: LD_ADDR_VAR 0 2
102550: PUSH
102551: LD_INT 22
102553: PUSH
102554: LD_OWVAR 2
102558: PUSH
102559: EMPTY
102560: LIST
102561: LIST
102562: PUSH
102563: LD_INT 30
102565: PUSH
102566: LD_INT 29
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: PPUSH
102577: CALL_OW 69
102581: ST_TO_ADDR
// if not tmp then
102582: LD_VAR 0 2
102586: NOT
102587: IFFALSE 102591
// exit ;
102589: GO 102641
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102591: LD_VAR 0 2
102595: PUSH
102596: LD_INT 1
102598: ARRAY
102599: PPUSH
102600: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102604: LD_VAR 0 2
102608: PUSH
102609: LD_INT 1
102611: ARRAY
102612: PPUSH
102613: CALL_OW 65
// end ; 5 .. 7 :
102617: GO 102641
102619: LD_INT 5
102621: DOUBLE
102622: GREATEREQUAL
102623: IFFALSE 102631
102625: LD_INT 7
102627: DOUBLE
102628: LESSEQUAL
102629: IFTRUE 102633
102631: GO 102640
102633: POP
// StreamSibBomb ; end ;
102634: CALL 98878 0 0
102638: GO 102641
102640: POP
// end ;
102641: PPOPN 3
102643: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102644: LD_EXP 139
102648: PUSH
102649: LD_EXP 189
102653: AND
102654: IFFALSE 102810
102656: GO 102658
102658: DISABLE
102659: LD_INT 0
102661: PPUSH
102662: PPUSH
102663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102664: LD_ADDR_VAR 0 2
102668: PUSH
102669: LD_INT 81
102671: PUSH
102672: LD_OWVAR 2
102676: PUSH
102677: EMPTY
102678: LIST
102679: LIST
102680: PUSH
102681: LD_INT 2
102683: PUSH
102684: LD_INT 21
102686: PUSH
102687: LD_INT 1
102689: PUSH
102690: EMPTY
102691: LIST
102692: LIST
102693: PUSH
102694: LD_INT 21
102696: PUSH
102697: LD_INT 2
102699: PUSH
102700: EMPTY
102701: LIST
102702: LIST
102703: PUSH
102704: EMPTY
102705: LIST
102706: LIST
102707: LIST
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: PPUSH
102713: CALL_OW 69
102717: ST_TO_ADDR
// if not tmp then
102718: LD_VAR 0 2
102722: NOT
102723: IFFALSE 102727
// exit ;
102725: GO 102810
// p := 0 ;
102727: LD_ADDR_VAR 0 3
102731: PUSH
102732: LD_INT 0
102734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102735: LD_INT 35
102737: PPUSH
102738: CALL_OW 67
// p := p + 1 ;
102742: LD_ADDR_VAR 0 3
102746: PUSH
102747: LD_VAR 0 3
102751: PUSH
102752: LD_INT 1
102754: PLUS
102755: ST_TO_ADDR
// for i in tmp do
102756: LD_ADDR_VAR 0 1
102760: PUSH
102761: LD_VAR 0 2
102765: PUSH
102766: FOR_IN
102767: IFFALSE 102798
// if GetLives ( i ) < 1000 then
102769: LD_VAR 0 1
102773: PPUSH
102774: CALL_OW 256
102778: PUSH
102779: LD_INT 1000
102781: LESS
102782: IFFALSE 102796
// SetLives ( i , 1000 ) ;
102784: LD_VAR 0 1
102788: PPUSH
102789: LD_INT 1000
102791: PPUSH
102792: CALL_OW 234
102796: GO 102766
102798: POP
102799: POP
// until p > 20 ;
102800: LD_VAR 0 3
102804: PUSH
102805: LD_INT 20
102807: GREATER
102808: IFFALSE 102735
// end ;
102810: PPOPN 3
102812: END
// every 0 0$1 trigger StreamModeActive and sTime do
102813: LD_EXP 139
102817: PUSH
102818: LD_EXP 190
102822: AND
102823: IFFALSE 102858
102825: GO 102827
102827: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102828: LD_INT 28
102830: PPUSH
102831: LD_OWVAR 2
102835: PPUSH
102836: LD_INT 2
102838: PPUSH
102839: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102843: LD_INT 30
102845: PPUSH
102846: LD_OWVAR 2
102850: PPUSH
102851: LD_INT 2
102853: PPUSH
102854: CALL_OW 322
// end ;
102858: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102859: LD_EXP 139
102863: PUSH
102864: LD_EXP 191
102868: AND
102869: IFFALSE 102990
102871: GO 102873
102873: DISABLE
102874: LD_INT 0
102876: PPUSH
102877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102878: LD_ADDR_VAR 0 2
102882: PUSH
102883: LD_INT 22
102885: PUSH
102886: LD_OWVAR 2
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: PUSH
102895: LD_INT 21
102897: PUSH
102898: LD_INT 1
102900: PUSH
102901: EMPTY
102902: LIST
102903: LIST
102904: PUSH
102905: LD_INT 3
102907: PUSH
102908: LD_INT 23
102910: PUSH
102911: LD_INT 0
102913: PUSH
102914: EMPTY
102915: LIST
102916: LIST
102917: PUSH
102918: EMPTY
102919: LIST
102920: LIST
102921: PUSH
102922: EMPTY
102923: LIST
102924: LIST
102925: LIST
102926: PPUSH
102927: CALL_OW 69
102931: ST_TO_ADDR
// if not tmp then
102932: LD_VAR 0 2
102936: NOT
102937: IFFALSE 102941
// exit ;
102939: GO 102990
// for i in tmp do
102941: LD_ADDR_VAR 0 1
102945: PUSH
102946: LD_VAR 0 2
102950: PUSH
102951: FOR_IN
102952: IFFALSE 102988
// begin if Crawls ( i ) then
102954: LD_VAR 0 1
102958: PPUSH
102959: CALL_OW 318
102963: IFFALSE 102974
// ComWalk ( i ) ;
102965: LD_VAR 0 1
102969: PPUSH
102970: CALL_OW 138
// SetClass ( i , 2 ) ;
102974: LD_VAR 0 1
102978: PPUSH
102979: LD_INT 2
102981: PPUSH
102982: CALL_OW 336
// end ;
102986: GO 102951
102988: POP
102989: POP
// end ;
102990: PPOPN 2
102992: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102993: LD_EXP 139
102997: PUSH
102998: LD_EXP 192
103002: AND
103003: IFFALSE 103291
103005: GO 103007
103007: DISABLE
103008: LD_INT 0
103010: PPUSH
103011: PPUSH
103012: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103013: LD_OWVAR 2
103017: PPUSH
103018: LD_INT 9
103020: PPUSH
103021: LD_INT 1
103023: PPUSH
103024: LD_INT 1
103026: PPUSH
103027: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103031: LD_INT 9
103033: PPUSH
103034: LD_OWVAR 2
103038: PPUSH
103039: CALL_OW 343
// uc_side := 9 ;
103043: LD_ADDR_OWVAR 20
103047: PUSH
103048: LD_INT 9
103050: ST_TO_ADDR
// uc_nation := 2 ;
103051: LD_ADDR_OWVAR 21
103055: PUSH
103056: LD_INT 2
103058: ST_TO_ADDR
// hc_name := Dark Warrior ;
103059: LD_ADDR_OWVAR 26
103063: PUSH
103064: LD_STRING Dark Warrior
103066: ST_TO_ADDR
// hc_gallery :=  ;
103067: LD_ADDR_OWVAR 33
103071: PUSH
103072: LD_STRING 
103074: ST_TO_ADDR
// hc_noskilllimit := true ;
103075: LD_ADDR_OWVAR 76
103079: PUSH
103080: LD_INT 1
103082: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103083: LD_ADDR_OWVAR 31
103087: PUSH
103088: LD_INT 30
103090: PUSH
103091: LD_INT 30
103093: PUSH
103094: LD_INT 30
103096: PUSH
103097: LD_INT 30
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: LIST
103104: LIST
103105: ST_TO_ADDR
// un := CreateHuman ;
103106: LD_ADDR_VAR 0 3
103110: PUSH
103111: CALL_OW 44
103115: ST_TO_ADDR
// hc_noskilllimit := false ;
103116: LD_ADDR_OWVAR 76
103120: PUSH
103121: LD_INT 0
103123: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103124: LD_VAR 0 3
103128: PPUSH
103129: LD_INT 1
103131: PPUSH
103132: CALL_OW 51
// ToLua ( playRanger() ) ;
103136: LD_STRING playRanger()
103138: PPUSH
103139: CALL_OW 559
// p := 0 ;
103143: LD_ADDR_VAR 0 2
103147: PUSH
103148: LD_INT 0
103150: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103151: LD_INT 35
103153: PPUSH
103154: CALL_OW 67
// p := p + 1 ;
103158: LD_ADDR_VAR 0 2
103162: PUSH
103163: LD_VAR 0 2
103167: PUSH
103168: LD_INT 1
103170: PLUS
103171: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103172: LD_VAR 0 3
103176: PPUSH
103177: CALL_OW 256
103181: PUSH
103182: LD_INT 1000
103184: LESS
103185: IFFALSE 103199
// SetLives ( un , 1000 ) ;
103187: LD_VAR 0 3
103191: PPUSH
103192: LD_INT 1000
103194: PPUSH
103195: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103199: LD_VAR 0 3
103203: PPUSH
103204: LD_INT 81
103206: PUSH
103207: LD_OWVAR 2
103211: PUSH
103212: EMPTY
103213: LIST
103214: LIST
103215: PUSH
103216: LD_INT 91
103218: PUSH
103219: LD_VAR 0 3
103223: PUSH
103224: LD_INT 30
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: LIST
103231: PUSH
103232: EMPTY
103233: LIST
103234: LIST
103235: PPUSH
103236: CALL_OW 69
103240: PPUSH
103241: LD_VAR 0 3
103245: PPUSH
103246: CALL_OW 74
103250: PPUSH
103251: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103255: LD_VAR 0 2
103259: PUSH
103260: LD_INT 80
103262: GREATER
103263: PUSH
103264: LD_VAR 0 3
103268: PPUSH
103269: CALL_OW 301
103273: OR
103274: IFFALSE 103151
// if un then
103276: LD_VAR 0 3
103280: IFFALSE 103291
// RemoveUnit ( un ) ;
103282: LD_VAR 0 3
103286: PPUSH
103287: CALL_OW 64
// end ;
103291: PPOPN 3
103293: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103294: LD_EXP 193
103298: IFFALSE 103414
103300: GO 103302
103302: DISABLE
103303: LD_INT 0
103305: PPUSH
103306: PPUSH
103307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103308: LD_ADDR_VAR 0 2
103312: PUSH
103313: LD_INT 81
103315: PUSH
103316: LD_OWVAR 2
103320: PUSH
103321: EMPTY
103322: LIST
103323: LIST
103324: PUSH
103325: LD_INT 21
103327: PUSH
103328: LD_INT 1
103330: PUSH
103331: EMPTY
103332: LIST
103333: LIST
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: PPUSH
103339: CALL_OW 69
103343: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103344: LD_STRING playComputer()
103346: PPUSH
103347: CALL_OW 559
// if not tmp then
103351: LD_VAR 0 2
103355: NOT
103356: IFFALSE 103360
// exit ;
103358: GO 103414
// for i in tmp do
103360: LD_ADDR_VAR 0 1
103364: PUSH
103365: LD_VAR 0 2
103369: PUSH
103370: FOR_IN
103371: IFFALSE 103412
// for j := 1 to 4 do
103373: LD_ADDR_VAR 0 3
103377: PUSH
103378: DOUBLE
103379: LD_INT 1
103381: DEC
103382: ST_TO_ADDR
103383: LD_INT 4
103385: PUSH
103386: FOR_TO
103387: IFFALSE 103408
// SetSkill ( i , j , 10 ) ;
103389: LD_VAR 0 1
103393: PPUSH
103394: LD_VAR 0 3
103398: PPUSH
103399: LD_INT 10
103401: PPUSH
103402: CALL_OW 237
103406: GO 103386
103408: POP
103409: POP
103410: GO 103370
103412: POP
103413: POP
// end ;
103414: PPOPN 3
103416: END
// every 0 0$1 trigger s30 do var i , tmp ;
103417: LD_EXP 194
103421: IFFALSE 103490
103423: GO 103425
103425: DISABLE
103426: LD_INT 0
103428: PPUSH
103429: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103430: LD_ADDR_VAR 0 2
103434: PUSH
103435: LD_INT 22
103437: PUSH
103438: LD_OWVAR 2
103442: PUSH
103443: EMPTY
103444: LIST
103445: LIST
103446: PPUSH
103447: CALL_OW 69
103451: ST_TO_ADDR
// if not tmp then
103452: LD_VAR 0 2
103456: NOT
103457: IFFALSE 103461
// exit ;
103459: GO 103490
// for i in tmp do
103461: LD_ADDR_VAR 0 1
103465: PUSH
103466: LD_VAR 0 2
103470: PUSH
103471: FOR_IN
103472: IFFALSE 103488
// SetLives ( i , 300 ) ;
103474: LD_VAR 0 1
103478: PPUSH
103479: LD_INT 300
103481: PPUSH
103482: CALL_OW 234
103486: GO 103471
103488: POP
103489: POP
// end ;
103490: PPOPN 2
103492: END
// every 0 0$1 trigger s60 do var i , tmp ;
103493: LD_EXP 195
103497: IFFALSE 103566
103499: GO 103501
103501: DISABLE
103502: LD_INT 0
103504: PPUSH
103505: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103506: LD_ADDR_VAR 0 2
103510: PUSH
103511: LD_INT 22
103513: PUSH
103514: LD_OWVAR 2
103518: PUSH
103519: EMPTY
103520: LIST
103521: LIST
103522: PPUSH
103523: CALL_OW 69
103527: ST_TO_ADDR
// if not tmp then
103528: LD_VAR 0 2
103532: NOT
103533: IFFALSE 103537
// exit ;
103535: GO 103566
// for i in tmp do
103537: LD_ADDR_VAR 0 1
103541: PUSH
103542: LD_VAR 0 2
103546: PUSH
103547: FOR_IN
103548: IFFALSE 103564
// SetLives ( i , 600 ) ;
103550: LD_VAR 0 1
103554: PPUSH
103555: LD_INT 600
103557: PPUSH
103558: CALL_OW 234
103562: GO 103547
103564: POP
103565: POP
// end ;
103566: PPOPN 2
103568: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103569: LD_INT 0
103571: PPUSH
// case cmd of 301 :
103572: LD_VAR 0 1
103576: PUSH
103577: LD_INT 301
103579: DOUBLE
103580: EQUAL
103581: IFTRUE 103585
103583: GO 103617
103585: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103586: LD_VAR 0 6
103590: PPUSH
103591: LD_VAR 0 7
103595: PPUSH
103596: LD_VAR 0 8
103600: PPUSH
103601: LD_VAR 0 4
103605: PPUSH
103606: LD_VAR 0 5
103610: PPUSH
103611: CALL 104818 0 5
103615: GO 103738
103617: LD_INT 302
103619: DOUBLE
103620: EQUAL
103621: IFTRUE 103625
103623: GO 103662
103625: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103626: LD_VAR 0 6
103630: PPUSH
103631: LD_VAR 0 7
103635: PPUSH
103636: LD_VAR 0 8
103640: PPUSH
103641: LD_VAR 0 9
103645: PPUSH
103646: LD_VAR 0 4
103650: PPUSH
103651: LD_VAR 0 5
103655: PPUSH
103656: CALL 104909 0 6
103660: GO 103738
103662: LD_INT 303
103664: DOUBLE
103665: EQUAL
103666: IFTRUE 103670
103668: GO 103707
103670: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103671: LD_VAR 0 6
103675: PPUSH
103676: LD_VAR 0 7
103680: PPUSH
103681: LD_VAR 0 8
103685: PPUSH
103686: LD_VAR 0 9
103690: PPUSH
103691: LD_VAR 0 4
103695: PPUSH
103696: LD_VAR 0 5
103700: PPUSH
103701: CALL 103743 0 6
103705: GO 103738
103707: LD_INT 304
103709: DOUBLE
103710: EQUAL
103711: IFTRUE 103715
103713: GO 103737
103715: POP
// hHackTeleport ( unit , x , y ) ; end ;
103716: LD_VAR 0 2
103720: PPUSH
103721: LD_VAR 0 4
103725: PPUSH
103726: LD_VAR 0 5
103730: PPUSH
103731: CALL 105502 0 3
103735: GO 103738
103737: POP
// end ;
103738: LD_VAR 0 12
103742: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103743: LD_INT 0
103745: PPUSH
103746: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103747: LD_VAR 0 1
103751: PUSH
103752: LD_INT 1
103754: LESS
103755: PUSH
103756: LD_VAR 0 1
103760: PUSH
103761: LD_INT 3
103763: GREATER
103764: OR
103765: PUSH
103766: LD_VAR 0 5
103770: PPUSH
103771: LD_VAR 0 6
103775: PPUSH
103776: CALL_OW 428
103780: OR
103781: IFFALSE 103785
// exit ;
103783: GO 104505
// uc_side := your_side ;
103785: LD_ADDR_OWVAR 20
103789: PUSH
103790: LD_OWVAR 2
103794: ST_TO_ADDR
// uc_nation := nation ;
103795: LD_ADDR_OWVAR 21
103799: PUSH
103800: LD_VAR 0 1
103804: ST_TO_ADDR
// bc_level = 1 ;
103805: LD_ADDR_OWVAR 43
103809: PUSH
103810: LD_INT 1
103812: ST_TO_ADDR
// case btype of 1 :
103813: LD_VAR 0 2
103817: PUSH
103818: LD_INT 1
103820: DOUBLE
103821: EQUAL
103822: IFTRUE 103826
103824: GO 103837
103826: POP
// bc_type := b_depot ; 2 :
103827: LD_ADDR_OWVAR 42
103831: PUSH
103832: LD_INT 0
103834: ST_TO_ADDR
103835: GO 104449
103837: LD_INT 2
103839: DOUBLE
103840: EQUAL
103841: IFTRUE 103845
103843: GO 103856
103845: POP
// bc_type := b_warehouse ; 3 :
103846: LD_ADDR_OWVAR 42
103850: PUSH
103851: LD_INT 1
103853: ST_TO_ADDR
103854: GO 104449
103856: LD_INT 3
103858: DOUBLE
103859: EQUAL
103860: IFTRUE 103864
103862: GO 103875
103864: POP
// bc_type := b_lab ; 4 .. 9 :
103865: LD_ADDR_OWVAR 42
103869: PUSH
103870: LD_INT 6
103872: ST_TO_ADDR
103873: GO 104449
103875: LD_INT 4
103877: DOUBLE
103878: GREATEREQUAL
103879: IFFALSE 103887
103881: LD_INT 9
103883: DOUBLE
103884: LESSEQUAL
103885: IFTRUE 103889
103887: GO 103941
103889: POP
// begin bc_type := b_lab_half ;
103890: LD_ADDR_OWVAR 42
103894: PUSH
103895: LD_INT 7
103897: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103898: LD_ADDR_OWVAR 44
103902: PUSH
103903: LD_INT 10
103905: PUSH
103906: LD_INT 11
103908: PUSH
103909: LD_INT 12
103911: PUSH
103912: LD_INT 15
103914: PUSH
103915: LD_INT 14
103917: PUSH
103918: LD_INT 13
103920: PUSH
103921: EMPTY
103922: LIST
103923: LIST
103924: LIST
103925: LIST
103926: LIST
103927: LIST
103928: PUSH
103929: LD_VAR 0 2
103933: PUSH
103934: LD_INT 3
103936: MINUS
103937: ARRAY
103938: ST_TO_ADDR
// end ; 10 .. 13 :
103939: GO 104449
103941: LD_INT 10
103943: DOUBLE
103944: GREATEREQUAL
103945: IFFALSE 103953
103947: LD_INT 13
103949: DOUBLE
103950: LESSEQUAL
103951: IFTRUE 103955
103953: GO 104032
103955: POP
// begin bc_type := b_lab_full ;
103956: LD_ADDR_OWVAR 42
103960: PUSH
103961: LD_INT 8
103963: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103964: LD_ADDR_OWVAR 44
103968: PUSH
103969: LD_INT 10
103971: PUSH
103972: LD_INT 12
103974: PUSH
103975: LD_INT 14
103977: PUSH
103978: LD_INT 13
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: LIST
103985: LIST
103986: PUSH
103987: LD_VAR 0 2
103991: PUSH
103992: LD_INT 9
103994: MINUS
103995: ARRAY
103996: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103997: LD_ADDR_OWVAR 45
104001: PUSH
104002: LD_INT 11
104004: PUSH
104005: LD_INT 15
104007: PUSH
104008: LD_INT 12
104010: PUSH
104011: LD_INT 15
104013: PUSH
104014: EMPTY
104015: LIST
104016: LIST
104017: LIST
104018: LIST
104019: PUSH
104020: LD_VAR 0 2
104024: PUSH
104025: LD_INT 9
104027: MINUS
104028: ARRAY
104029: ST_TO_ADDR
// end ; 14 :
104030: GO 104449
104032: LD_INT 14
104034: DOUBLE
104035: EQUAL
104036: IFTRUE 104040
104038: GO 104051
104040: POP
// bc_type := b_workshop ; 15 :
104041: LD_ADDR_OWVAR 42
104045: PUSH
104046: LD_INT 2
104048: ST_TO_ADDR
104049: GO 104449
104051: LD_INT 15
104053: DOUBLE
104054: EQUAL
104055: IFTRUE 104059
104057: GO 104070
104059: POP
// bc_type := b_factory ; 16 :
104060: LD_ADDR_OWVAR 42
104064: PUSH
104065: LD_INT 3
104067: ST_TO_ADDR
104068: GO 104449
104070: LD_INT 16
104072: DOUBLE
104073: EQUAL
104074: IFTRUE 104078
104076: GO 104089
104078: POP
// bc_type := b_ext_gun ; 17 :
104079: LD_ADDR_OWVAR 42
104083: PUSH
104084: LD_INT 17
104086: ST_TO_ADDR
104087: GO 104449
104089: LD_INT 17
104091: DOUBLE
104092: EQUAL
104093: IFTRUE 104097
104095: GO 104125
104097: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104098: LD_ADDR_OWVAR 42
104102: PUSH
104103: LD_INT 19
104105: PUSH
104106: LD_INT 23
104108: PUSH
104109: LD_INT 19
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: LIST
104116: PUSH
104117: LD_VAR 0 1
104121: ARRAY
104122: ST_TO_ADDR
104123: GO 104449
104125: LD_INT 18
104127: DOUBLE
104128: EQUAL
104129: IFTRUE 104133
104131: GO 104144
104133: POP
// bc_type := b_ext_radar ; 19 :
104134: LD_ADDR_OWVAR 42
104138: PUSH
104139: LD_INT 20
104141: ST_TO_ADDR
104142: GO 104449
104144: LD_INT 19
104146: DOUBLE
104147: EQUAL
104148: IFTRUE 104152
104150: GO 104163
104152: POP
// bc_type := b_ext_radio ; 20 :
104153: LD_ADDR_OWVAR 42
104157: PUSH
104158: LD_INT 22
104160: ST_TO_ADDR
104161: GO 104449
104163: LD_INT 20
104165: DOUBLE
104166: EQUAL
104167: IFTRUE 104171
104169: GO 104182
104171: POP
// bc_type := b_ext_siberium ; 21 :
104172: LD_ADDR_OWVAR 42
104176: PUSH
104177: LD_INT 21
104179: ST_TO_ADDR
104180: GO 104449
104182: LD_INT 21
104184: DOUBLE
104185: EQUAL
104186: IFTRUE 104190
104188: GO 104201
104190: POP
// bc_type := b_ext_computer ; 22 :
104191: LD_ADDR_OWVAR 42
104195: PUSH
104196: LD_INT 24
104198: ST_TO_ADDR
104199: GO 104449
104201: LD_INT 22
104203: DOUBLE
104204: EQUAL
104205: IFTRUE 104209
104207: GO 104220
104209: POP
// bc_type := b_ext_track ; 23 :
104210: LD_ADDR_OWVAR 42
104214: PUSH
104215: LD_INT 16
104217: ST_TO_ADDR
104218: GO 104449
104220: LD_INT 23
104222: DOUBLE
104223: EQUAL
104224: IFTRUE 104228
104226: GO 104239
104228: POP
// bc_type := b_ext_laser ; 24 :
104229: LD_ADDR_OWVAR 42
104233: PUSH
104234: LD_INT 25
104236: ST_TO_ADDR
104237: GO 104449
104239: LD_INT 24
104241: DOUBLE
104242: EQUAL
104243: IFTRUE 104247
104245: GO 104258
104247: POP
// bc_type := b_control_tower ; 25 :
104248: LD_ADDR_OWVAR 42
104252: PUSH
104253: LD_INT 36
104255: ST_TO_ADDR
104256: GO 104449
104258: LD_INT 25
104260: DOUBLE
104261: EQUAL
104262: IFTRUE 104266
104264: GO 104277
104266: POP
// bc_type := b_breastwork ; 26 :
104267: LD_ADDR_OWVAR 42
104271: PUSH
104272: LD_INT 31
104274: ST_TO_ADDR
104275: GO 104449
104277: LD_INT 26
104279: DOUBLE
104280: EQUAL
104281: IFTRUE 104285
104283: GO 104296
104285: POP
// bc_type := b_bunker ; 27 :
104286: LD_ADDR_OWVAR 42
104290: PUSH
104291: LD_INT 32
104293: ST_TO_ADDR
104294: GO 104449
104296: LD_INT 27
104298: DOUBLE
104299: EQUAL
104300: IFTRUE 104304
104302: GO 104315
104304: POP
// bc_type := b_turret ; 28 :
104305: LD_ADDR_OWVAR 42
104309: PUSH
104310: LD_INT 33
104312: ST_TO_ADDR
104313: GO 104449
104315: LD_INT 28
104317: DOUBLE
104318: EQUAL
104319: IFTRUE 104323
104321: GO 104334
104323: POP
// bc_type := b_armoury ; 29 :
104324: LD_ADDR_OWVAR 42
104328: PUSH
104329: LD_INT 4
104331: ST_TO_ADDR
104332: GO 104449
104334: LD_INT 29
104336: DOUBLE
104337: EQUAL
104338: IFTRUE 104342
104340: GO 104353
104342: POP
// bc_type := b_barracks ; 30 :
104343: LD_ADDR_OWVAR 42
104347: PUSH
104348: LD_INT 5
104350: ST_TO_ADDR
104351: GO 104449
104353: LD_INT 30
104355: DOUBLE
104356: EQUAL
104357: IFTRUE 104361
104359: GO 104372
104361: POP
// bc_type := b_solar_power ; 31 :
104362: LD_ADDR_OWVAR 42
104366: PUSH
104367: LD_INT 27
104369: ST_TO_ADDR
104370: GO 104449
104372: LD_INT 31
104374: DOUBLE
104375: EQUAL
104376: IFTRUE 104380
104378: GO 104391
104380: POP
// bc_type := b_oil_power ; 32 :
104381: LD_ADDR_OWVAR 42
104385: PUSH
104386: LD_INT 26
104388: ST_TO_ADDR
104389: GO 104449
104391: LD_INT 32
104393: DOUBLE
104394: EQUAL
104395: IFTRUE 104399
104397: GO 104410
104399: POP
// bc_type := b_siberite_power ; 33 :
104400: LD_ADDR_OWVAR 42
104404: PUSH
104405: LD_INT 28
104407: ST_TO_ADDR
104408: GO 104449
104410: LD_INT 33
104412: DOUBLE
104413: EQUAL
104414: IFTRUE 104418
104416: GO 104429
104418: POP
// bc_type := b_oil_mine ; 34 :
104419: LD_ADDR_OWVAR 42
104423: PUSH
104424: LD_INT 29
104426: ST_TO_ADDR
104427: GO 104449
104429: LD_INT 34
104431: DOUBLE
104432: EQUAL
104433: IFTRUE 104437
104435: GO 104448
104437: POP
// bc_type := b_siberite_mine ; end ;
104438: LD_ADDR_OWVAR 42
104442: PUSH
104443: LD_INT 30
104445: ST_TO_ADDR
104446: GO 104449
104448: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104449: LD_ADDR_VAR 0 8
104453: PUSH
104454: LD_VAR 0 5
104458: PPUSH
104459: LD_VAR 0 6
104463: PPUSH
104464: LD_VAR 0 3
104468: PPUSH
104469: CALL_OW 47
104473: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104474: LD_OWVAR 42
104478: PUSH
104479: LD_INT 32
104481: PUSH
104482: LD_INT 33
104484: PUSH
104485: EMPTY
104486: LIST
104487: LIST
104488: IN
104489: IFFALSE 104505
// PlaceWeaponTurret ( b , weapon ) ;
104491: LD_VAR 0 8
104495: PPUSH
104496: LD_VAR 0 4
104500: PPUSH
104501: CALL_OW 431
// end ;
104505: LD_VAR 0 7
104509: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104510: LD_INT 0
104512: PPUSH
104513: PPUSH
104514: PPUSH
104515: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104516: LD_ADDR_VAR 0 4
104520: PUSH
104521: LD_INT 22
104523: PUSH
104524: LD_OWVAR 2
104528: PUSH
104529: EMPTY
104530: LIST
104531: LIST
104532: PUSH
104533: LD_INT 2
104535: PUSH
104536: LD_INT 30
104538: PUSH
104539: LD_INT 0
104541: PUSH
104542: EMPTY
104543: LIST
104544: LIST
104545: PUSH
104546: LD_INT 30
104548: PUSH
104549: LD_INT 1
104551: PUSH
104552: EMPTY
104553: LIST
104554: LIST
104555: PUSH
104556: EMPTY
104557: LIST
104558: LIST
104559: LIST
104560: PUSH
104561: EMPTY
104562: LIST
104563: LIST
104564: PPUSH
104565: CALL_OW 69
104569: ST_TO_ADDR
// if not tmp then
104570: LD_VAR 0 4
104574: NOT
104575: IFFALSE 104579
// exit ;
104577: GO 104638
// for i in tmp do
104579: LD_ADDR_VAR 0 2
104583: PUSH
104584: LD_VAR 0 4
104588: PUSH
104589: FOR_IN
104590: IFFALSE 104636
// for j = 1 to 3 do
104592: LD_ADDR_VAR 0 3
104596: PUSH
104597: DOUBLE
104598: LD_INT 1
104600: DEC
104601: ST_TO_ADDR
104602: LD_INT 3
104604: PUSH
104605: FOR_TO
104606: IFFALSE 104632
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104608: LD_VAR 0 2
104612: PPUSH
104613: CALL_OW 274
104617: PPUSH
104618: LD_VAR 0 3
104622: PPUSH
104623: LD_INT 99999
104625: PPUSH
104626: CALL_OW 277
104630: GO 104605
104632: POP
104633: POP
104634: GO 104589
104636: POP
104637: POP
// end ;
104638: LD_VAR 0 1
104642: RET
// export function hHackSetLevel10 ; var i , j ; begin
104643: LD_INT 0
104645: PPUSH
104646: PPUSH
104647: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104648: LD_ADDR_VAR 0 2
104652: PUSH
104653: LD_INT 21
104655: PUSH
104656: LD_INT 1
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: PPUSH
104663: CALL_OW 69
104667: PUSH
104668: FOR_IN
104669: IFFALSE 104721
// if IsSelected ( i ) then
104671: LD_VAR 0 2
104675: PPUSH
104676: CALL_OW 306
104680: IFFALSE 104719
// begin for j := 1 to 4 do
104682: LD_ADDR_VAR 0 3
104686: PUSH
104687: DOUBLE
104688: LD_INT 1
104690: DEC
104691: ST_TO_ADDR
104692: LD_INT 4
104694: PUSH
104695: FOR_TO
104696: IFFALSE 104717
// SetSkill ( i , j , 10 ) ;
104698: LD_VAR 0 2
104702: PPUSH
104703: LD_VAR 0 3
104707: PPUSH
104708: LD_INT 10
104710: PPUSH
104711: CALL_OW 237
104715: GO 104695
104717: POP
104718: POP
// end ;
104719: GO 104668
104721: POP
104722: POP
// end ;
104723: LD_VAR 0 1
104727: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104728: LD_INT 0
104730: PPUSH
104731: PPUSH
104732: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104733: LD_ADDR_VAR 0 2
104737: PUSH
104738: LD_INT 22
104740: PUSH
104741: LD_OWVAR 2
104745: PUSH
104746: EMPTY
104747: LIST
104748: LIST
104749: PUSH
104750: LD_INT 21
104752: PUSH
104753: LD_INT 1
104755: PUSH
104756: EMPTY
104757: LIST
104758: LIST
104759: PUSH
104760: EMPTY
104761: LIST
104762: LIST
104763: PPUSH
104764: CALL_OW 69
104768: PUSH
104769: FOR_IN
104770: IFFALSE 104811
// begin for j := 1 to 4 do
104772: LD_ADDR_VAR 0 3
104776: PUSH
104777: DOUBLE
104778: LD_INT 1
104780: DEC
104781: ST_TO_ADDR
104782: LD_INT 4
104784: PUSH
104785: FOR_TO
104786: IFFALSE 104807
// SetSkill ( i , j , 10 ) ;
104788: LD_VAR 0 2
104792: PPUSH
104793: LD_VAR 0 3
104797: PPUSH
104798: LD_INT 10
104800: PPUSH
104801: CALL_OW 237
104805: GO 104785
104807: POP
104808: POP
// end ;
104809: GO 104769
104811: POP
104812: POP
// end ;
104813: LD_VAR 0 1
104817: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104818: LD_INT 0
104820: PPUSH
// uc_side := your_side ;
104821: LD_ADDR_OWVAR 20
104825: PUSH
104826: LD_OWVAR 2
104830: ST_TO_ADDR
// uc_nation := nation ;
104831: LD_ADDR_OWVAR 21
104835: PUSH
104836: LD_VAR 0 1
104840: ST_TO_ADDR
// InitHc ;
104841: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104845: LD_INT 0
104847: PPUSH
104848: LD_VAR 0 2
104852: PPUSH
104853: LD_VAR 0 3
104857: PPUSH
104858: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104862: LD_VAR 0 4
104866: PPUSH
104867: LD_VAR 0 5
104871: PPUSH
104872: CALL_OW 428
104876: PUSH
104877: LD_INT 0
104879: EQUAL
104880: IFFALSE 104904
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104882: CALL_OW 44
104886: PPUSH
104887: LD_VAR 0 4
104891: PPUSH
104892: LD_VAR 0 5
104896: PPUSH
104897: LD_INT 1
104899: PPUSH
104900: CALL_OW 48
// end ;
104904: LD_VAR 0 6
104908: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104909: LD_INT 0
104911: PPUSH
104912: PPUSH
// uc_side := your_side ;
104913: LD_ADDR_OWVAR 20
104917: PUSH
104918: LD_OWVAR 2
104922: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104923: LD_VAR 0 1
104927: PUSH
104928: LD_INT 1
104930: PUSH
104931: LD_INT 2
104933: PUSH
104934: LD_INT 3
104936: PUSH
104937: LD_INT 4
104939: PUSH
104940: LD_INT 5
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: LIST
104947: LIST
104948: LIST
104949: IN
104950: IFFALSE 104962
// uc_nation := nation_american else
104952: LD_ADDR_OWVAR 21
104956: PUSH
104957: LD_INT 1
104959: ST_TO_ADDR
104960: GO 105005
// if chassis in [ 11 , 12 , 13 , 14 ] then
104962: LD_VAR 0 1
104966: PUSH
104967: LD_INT 11
104969: PUSH
104970: LD_INT 12
104972: PUSH
104973: LD_INT 13
104975: PUSH
104976: LD_INT 14
104978: PUSH
104979: EMPTY
104980: LIST
104981: LIST
104982: LIST
104983: LIST
104984: IN
104985: IFFALSE 104997
// uc_nation := nation_arabian else
104987: LD_ADDR_OWVAR 21
104991: PUSH
104992: LD_INT 2
104994: ST_TO_ADDR
104995: GO 105005
// uc_nation := nation_russian ;
104997: LD_ADDR_OWVAR 21
105001: PUSH
105002: LD_INT 3
105004: ST_TO_ADDR
// vc_chassis := chassis ;
105005: LD_ADDR_OWVAR 37
105009: PUSH
105010: LD_VAR 0 1
105014: ST_TO_ADDR
// vc_engine := engine ;
105015: LD_ADDR_OWVAR 39
105019: PUSH
105020: LD_VAR 0 2
105024: ST_TO_ADDR
// vc_control := control ;
105025: LD_ADDR_OWVAR 38
105029: PUSH
105030: LD_VAR 0 3
105034: ST_TO_ADDR
// vc_weapon := weapon ;
105035: LD_ADDR_OWVAR 40
105039: PUSH
105040: LD_VAR 0 4
105044: ST_TO_ADDR
// un := CreateVehicle ;
105045: LD_ADDR_VAR 0 8
105049: PUSH
105050: CALL_OW 45
105054: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105055: LD_VAR 0 8
105059: PPUSH
105060: LD_INT 0
105062: PPUSH
105063: LD_INT 5
105065: PPUSH
105066: CALL_OW 12
105070: PPUSH
105071: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105075: LD_VAR 0 8
105079: PPUSH
105080: LD_VAR 0 5
105084: PPUSH
105085: LD_VAR 0 6
105089: PPUSH
105090: LD_INT 1
105092: PPUSH
105093: CALL_OW 48
// end ;
105097: LD_VAR 0 7
105101: RET
// export hInvincible ; every 1 do
105102: GO 105104
105104: DISABLE
// hInvincible := [ ] ;
105105: LD_ADDR_EXP 196
105109: PUSH
105110: EMPTY
105111: ST_TO_ADDR
105112: END
// every 10 do var i ;
105113: GO 105115
105115: DISABLE
105116: LD_INT 0
105118: PPUSH
// begin enable ;
105119: ENABLE
// if not hInvincible then
105120: LD_EXP 196
105124: NOT
105125: IFFALSE 105129
// exit ;
105127: GO 105173
// for i in hInvincible do
105129: LD_ADDR_VAR 0 1
105133: PUSH
105134: LD_EXP 196
105138: PUSH
105139: FOR_IN
105140: IFFALSE 105171
// if GetLives ( i ) < 1000 then
105142: LD_VAR 0 1
105146: PPUSH
105147: CALL_OW 256
105151: PUSH
105152: LD_INT 1000
105154: LESS
105155: IFFALSE 105169
// SetLives ( i , 1000 ) ;
105157: LD_VAR 0 1
105161: PPUSH
105162: LD_INT 1000
105164: PPUSH
105165: CALL_OW 234
105169: GO 105139
105171: POP
105172: POP
// end ;
105173: PPOPN 1
105175: END
// export function hHackInvincible ; var i ; begin
105176: LD_INT 0
105178: PPUSH
105179: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105180: LD_ADDR_VAR 0 2
105184: PUSH
105185: LD_INT 2
105187: PUSH
105188: LD_INT 21
105190: PUSH
105191: LD_INT 1
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: PUSH
105198: LD_INT 21
105200: PUSH
105201: LD_INT 2
105203: PUSH
105204: EMPTY
105205: LIST
105206: LIST
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: LIST
105212: PPUSH
105213: CALL_OW 69
105217: PUSH
105218: FOR_IN
105219: IFFALSE 105280
// if IsSelected ( i ) then
105221: LD_VAR 0 2
105225: PPUSH
105226: CALL_OW 306
105230: IFFALSE 105278
// begin if i in hInvincible then
105232: LD_VAR 0 2
105236: PUSH
105237: LD_EXP 196
105241: IN
105242: IFFALSE 105262
// hInvincible := hInvincible diff i else
105244: LD_ADDR_EXP 196
105248: PUSH
105249: LD_EXP 196
105253: PUSH
105254: LD_VAR 0 2
105258: DIFF
105259: ST_TO_ADDR
105260: GO 105278
// hInvincible := hInvincible union i ;
105262: LD_ADDR_EXP 196
105266: PUSH
105267: LD_EXP 196
105271: PUSH
105272: LD_VAR 0 2
105276: UNION
105277: ST_TO_ADDR
// end ;
105278: GO 105218
105280: POP
105281: POP
// end ;
105282: LD_VAR 0 1
105286: RET
// export function hHackInvisible ; var i , j ; begin
105287: LD_INT 0
105289: PPUSH
105290: PPUSH
105291: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105292: LD_ADDR_VAR 0 2
105296: PUSH
105297: LD_INT 21
105299: PUSH
105300: LD_INT 1
105302: PUSH
105303: EMPTY
105304: LIST
105305: LIST
105306: PPUSH
105307: CALL_OW 69
105311: PUSH
105312: FOR_IN
105313: IFFALSE 105337
// if IsSelected ( i ) then
105315: LD_VAR 0 2
105319: PPUSH
105320: CALL_OW 306
105324: IFFALSE 105335
// ComForceInvisible ( i ) ;
105326: LD_VAR 0 2
105330: PPUSH
105331: CALL_OW 496
105335: GO 105312
105337: POP
105338: POP
// end ;
105339: LD_VAR 0 1
105343: RET
// export function hHackChangeYourSide ; begin
105344: LD_INT 0
105346: PPUSH
// if your_side = 8 then
105347: LD_OWVAR 2
105351: PUSH
105352: LD_INT 8
105354: EQUAL
105355: IFFALSE 105367
// your_side := 0 else
105357: LD_ADDR_OWVAR 2
105361: PUSH
105362: LD_INT 0
105364: ST_TO_ADDR
105365: GO 105381
// your_side := your_side + 1 ;
105367: LD_ADDR_OWVAR 2
105371: PUSH
105372: LD_OWVAR 2
105376: PUSH
105377: LD_INT 1
105379: PLUS
105380: ST_TO_ADDR
// end ;
105381: LD_VAR 0 1
105385: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105386: LD_INT 0
105388: PPUSH
105389: PPUSH
105390: PPUSH
// for i in all_units do
105391: LD_ADDR_VAR 0 2
105395: PUSH
105396: LD_OWVAR 3
105400: PUSH
105401: FOR_IN
105402: IFFALSE 105480
// if IsSelected ( i ) then
105404: LD_VAR 0 2
105408: PPUSH
105409: CALL_OW 306
105413: IFFALSE 105478
// begin j := GetSide ( i ) ;
105415: LD_ADDR_VAR 0 3
105419: PUSH
105420: LD_VAR 0 2
105424: PPUSH
105425: CALL_OW 255
105429: ST_TO_ADDR
// if j = 8 then
105430: LD_VAR 0 3
105434: PUSH
105435: LD_INT 8
105437: EQUAL
105438: IFFALSE 105450
// j := 0 else
105440: LD_ADDR_VAR 0 3
105444: PUSH
105445: LD_INT 0
105447: ST_TO_ADDR
105448: GO 105464
// j := j + 1 ;
105450: LD_ADDR_VAR 0 3
105454: PUSH
105455: LD_VAR 0 3
105459: PUSH
105460: LD_INT 1
105462: PLUS
105463: ST_TO_ADDR
// SetSide ( i , j ) ;
105464: LD_VAR 0 2
105468: PPUSH
105469: LD_VAR 0 3
105473: PPUSH
105474: CALL_OW 235
// end ;
105478: GO 105401
105480: POP
105481: POP
// end ;
105482: LD_VAR 0 1
105486: RET
// export function hHackFog ; begin
105487: LD_INT 0
105489: PPUSH
// FogOff ( true ) ;
105490: LD_INT 1
105492: PPUSH
105493: CALL_OW 344
// end ;
105497: LD_VAR 0 1
105501: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105502: LD_INT 0
105504: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105505: LD_VAR 0 1
105509: PPUSH
105510: LD_VAR 0 2
105514: PPUSH
105515: LD_VAR 0 3
105519: PPUSH
105520: LD_INT 1
105522: PPUSH
105523: LD_INT 1
105525: PPUSH
105526: CALL_OW 483
// CenterOnXY ( x , y ) ;
105530: LD_VAR 0 2
105534: PPUSH
105535: LD_VAR 0 3
105539: PPUSH
105540: CALL_OW 84
// end ; end_of_file
105544: LD_VAR 0 4
105548: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105549: LD_INT 0
105551: PPUSH
105552: PPUSH
105553: PPUSH
105554: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105555: LD_VAR 0 1
105559: PPUSH
105560: CALL_OW 264
105564: PUSH
105565: LD_EXP 78
105569: EQUAL
105570: IFFALSE 105642
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105572: LD_INT 68
105574: PPUSH
105575: LD_VAR 0 1
105579: PPUSH
105580: CALL_OW 255
105584: PPUSH
105585: CALL_OW 321
105589: PUSH
105590: LD_INT 2
105592: EQUAL
105593: IFFALSE 105605
// eff := 70 else
105595: LD_ADDR_VAR 0 4
105599: PUSH
105600: LD_INT 70
105602: ST_TO_ADDR
105603: GO 105613
// eff := 30 ;
105605: LD_ADDR_VAR 0 4
105609: PUSH
105610: LD_INT 30
105612: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105613: LD_VAR 0 1
105617: PPUSH
105618: CALL_OW 250
105622: PPUSH
105623: LD_VAR 0 1
105627: PPUSH
105628: CALL_OW 251
105632: PPUSH
105633: LD_VAR 0 4
105637: PPUSH
105638: CALL_OW 495
// end ; end ;
105642: LD_VAR 0 2
105646: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105647: LD_INT 0
105649: PPUSH
// end ;
105650: LD_VAR 0 4
105654: RET
// export function SOS_Command ( cmd ) ; begin
105655: LD_INT 0
105657: PPUSH
// end ;
105658: LD_VAR 0 2
105662: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105663: LD_INT 0
105665: PPUSH
// end ;
105666: LD_VAR 0 6
105670: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105671: LD_INT 0
105673: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105674: LD_VAR 0 1
105678: PUSH
105679: LD_INT 250
105681: EQUAL
105682: PUSH
105683: LD_VAR 0 2
105687: PPUSH
105688: CALL_OW 264
105692: PUSH
105693: LD_EXP 81
105697: EQUAL
105698: AND
105699: IFFALSE 105720
// MinerPlaceMine ( unit , x , y ) ;
105701: LD_VAR 0 2
105705: PPUSH
105706: LD_VAR 0 4
105710: PPUSH
105711: LD_VAR 0 5
105715: PPUSH
105716: CALL 108069 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105720: LD_VAR 0 1
105724: PUSH
105725: LD_INT 251
105727: EQUAL
105728: PUSH
105729: LD_VAR 0 2
105733: PPUSH
105734: CALL_OW 264
105738: PUSH
105739: LD_EXP 81
105743: EQUAL
105744: AND
105745: IFFALSE 105766
// MinerDetonateMine ( unit , x , y ) ;
105747: LD_VAR 0 2
105751: PPUSH
105752: LD_VAR 0 4
105756: PPUSH
105757: LD_VAR 0 5
105761: PPUSH
105762: CALL 108346 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105766: LD_VAR 0 1
105770: PUSH
105771: LD_INT 252
105773: EQUAL
105774: PUSH
105775: LD_VAR 0 2
105779: PPUSH
105780: CALL_OW 264
105784: PUSH
105785: LD_EXP 81
105789: EQUAL
105790: AND
105791: IFFALSE 105812
// MinerCreateMinefield ( unit , x , y ) ;
105793: LD_VAR 0 2
105797: PPUSH
105798: LD_VAR 0 4
105802: PPUSH
105803: LD_VAR 0 5
105807: PPUSH
105808: CALL 108763 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105812: LD_VAR 0 1
105816: PUSH
105817: LD_INT 253
105819: EQUAL
105820: PUSH
105821: LD_VAR 0 2
105825: PPUSH
105826: CALL_OW 257
105830: PUSH
105831: LD_INT 5
105833: EQUAL
105834: AND
105835: IFFALSE 105856
// ComBinocular ( unit , x , y ) ;
105837: LD_VAR 0 2
105841: PPUSH
105842: LD_VAR 0 4
105846: PPUSH
105847: LD_VAR 0 5
105851: PPUSH
105852: CALL 109134 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105856: LD_VAR 0 1
105860: PUSH
105861: LD_INT 254
105863: EQUAL
105864: PUSH
105865: LD_VAR 0 2
105869: PPUSH
105870: CALL_OW 264
105874: PUSH
105875: LD_EXP 76
105879: EQUAL
105880: AND
105881: PUSH
105882: LD_VAR 0 3
105886: PPUSH
105887: CALL_OW 263
105891: PUSH
105892: LD_INT 3
105894: EQUAL
105895: AND
105896: IFFALSE 105912
// HackDestroyVehicle ( unit , selectedUnit ) ;
105898: LD_VAR 0 2
105902: PPUSH
105903: LD_VAR 0 3
105907: PPUSH
105908: CALL 107429 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105912: LD_VAR 0 1
105916: PUSH
105917: LD_INT 255
105919: EQUAL
105920: PUSH
105921: LD_VAR 0 2
105925: PPUSH
105926: CALL_OW 264
105930: PUSH
105931: LD_INT 14
105933: PUSH
105934: LD_INT 53
105936: PUSH
105937: EMPTY
105938: LIST
105939: LIST
105940: IN
105941: AND
105942: PUSH
105943: LD_VAR 0 4
105947: PPUSH
105948: LD_VAR 0 5
105952: PPUSH
105953: CALL_OW 488
105957: AND
105958: IFFALSE 105982
// CutTreeXYR ( unit , x , y , 12 ) ;
105960: LD_VAR 0 2
105964: PPUSH
105965: LD_VAR 0 4
105969: PPUSH
105970: LD_VAR 0 5
105974: PPUSH
105975: LD_INT 12
105977: PPUSH
105978: CALL 105995 0 4
// end ;
105982: LD_VAR 0 6
105986: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
105987: LD_INT 0
105989: PPUSH
// end ;
105990: LD_VAR 0 4
105994: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105995: LD_INT 0
105997: PPUSH
105998: PPUSH
105999: PPUSH
106000: PPUSH
106001: PPUSH
106002: PPUSH
106003: PPUSH
106004: PPUSH
106005: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106006: LD_VAR 0 1
106010: NOT
106011: PUSH
106012: LD_VAR 0 2
106016: PPUSH
106017: LD_VAR 0 3
106021: PPUSH
106022: CALL_OW 488
106026: NOT
106027: OR
106028: PUSH
106029: LD_VAR 0 4
106033: NOT
106034: OR
106035: IFFALSE 106039
// exit ;
106037: GO 106379
// list := [ ] ;
106039: LD_ADDR_VAR 0 13
106043: PUSH
106044: EMPTY
106045: ST_TO_ADDR
// if x - r < 0 then
106046: LD_VAR 0 2
106050: PUSH
106051: LD_VAR 0 4
106055: MINUS
106056: PUSH
106057: LD_INT 0
106059: LESS
106060: IFFALSE 106072
// min_x := 0 else
106062: LD_ADDR_VAR 0 7
106066: PUSH
106067: LD_INT 0
106069: ST_TO_ADDR
106070: GO 106088
// min_x := x - r ;
106072: LD_ADDR_VAR 0 7
106076: PUSH
106077: LD_VAR 0 2
106081: PUSH
106082: LD_VAR 0 4
106086: MINUS
106087: ST_TO_ADDR
// if y - r < 0 then
106088: LD_VAR 0 3
106092: PUSH
106093: LD_VAR 0 4
106097: MINUS
106098: PUSH
106099: LD_INT 0
106101: LESS
106102: IFFALSE 106114
// min_y := 0 else
106104: LD_ADDR_VAR 0 8
106108: PUSH
106109: LD_INT 0
106111: ST_TO_ADDR
106112: GO 106130
// min_y := y - r ;
106114: LD_ADDR_VAR 0 8
106118: PUSH
106119: LD_VAR 0 3
106123: PUSH
106124: LD_VAR 0 4
106128: MINUS
106129: ST_TO_ADDR
// max_x := x + r ;
106130: LD_ADDR_VAR 0 9
106134: PUSH
106135: LD_VAR 0 2
106139: PUSH
106140: LD_VAR 0 4
106144: PLUS
106145: ST_TO_ADDR
// max_y := y + r ;
106146: LD_ADDR_VAR 0 10
106150: PUSH
106151: LD_VAR 0 3
106155: PUSH
106156: LD_VAR 0 4
106160: PLUS
106161: ST_TO_ADDR
// for _x = min_x to max_x do
106162: LD_ADDR_VAR 0 11
106166: PUSH
106167: DOUBLE
106168: LD_VAR 0 7
106172: DEC
106173: ST_TO_ADDR
106174: LD_VAR 0 9
106178: PUSH
106179: FOR_TO
106180: IFFALSE 106297
// for _y = min_y to max_y do
106182: LD_ADDR_VAR 0 12
106186: PUSH
106187: DOUBLE
106188: LD_VAR 0 8
106192: DEC
106193: ST_TO_ADDR
106194: LD_VAR 0 10
106198: PUSH
106199: FOR_TO
106200: IFFALSE 106293
// begin if not ValidHex ( _x , _y ) then
106202: LD_VAR 0 11
106206: PPUSH
106207: LD_VAR 0 12
106211: PPUSH
106212: CALL_OW 488
106216: NOT
106217: IFFALSE 106221
// continue ;
106219: GO 106199
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106221: LD_VAR 0 11
106225: PPUSH
106226: LD_VAR 0 12
106230: PPUSH
106231: CALL_OW 351
106235: PUSH
106236: LD_VAR 0 11
106240: PPUSH
106241: LD_VAR 0 12
106245: PPUSH
106246: CALL_OW 554
106250: AND
106251: IFFALSE 106291
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106253: LD_ADDR_VAR 0 13
106257: PUSH
106258: LD_VAR 0 13
106262: PPUSH
106263: LD_VAR 0 13
106267: PUSH
106268: LD_INT 1
106270: PLUS
106271: PPUSH
106272: LD_VAR 0 11
106276: PUSH
106277: LD_VAR 0 12
106281: PUSH
106282: EMPTY
106283: LIST
106284: LIST
106285: PPUSH
106286: CALL_OW 2
106290: ST_TO_ADDR
// end ;
106291: GO 106199
106293: POP
106294: POP
106295: GO 106179
106297: POP
106298: POP
// if not list then
106299: LD_VAR 0 13
106303: NOT
106304: IFFALSE 106308
// exit ;
106306: GO 106379
// for i in list do
106308: LD_ADDR_VAR 0 6
106312: PUSH
106313: LD_VAR 0 13
106317: PUSH
106318: FOR_IN
106319: IFFALSE 106377
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106321: LD_VAR 0 1
106325: PPUSH
106326: LD_STRING M
106328: PUSH
106329: LD_VAR 0 6
106333: PUSH
106334: LD_INT 1
106336: ARRAY
106337: PUSH
106338: LD_VAR 0 6
106342: PUSH
106343: LD_INT 2
106345: ARRAY
106346: PUSH
106347: LD_INT 0
106349: PUSH
106350: LD_INT 0
106352: PUSH
106353: LD_INT 0
106355: PUSH
106356: LD_INT 0
106358: PUSH
106359: EMPTY
106360: LIST
106361: LIST
106362: LIST
106363: LIST
106364: LIST
106365: LIST
106366: LIST
106367: PUSH
106368: EMPTY
106369: LIST
106370: PPUSH
106371: CALL_OW 447
106375: GO 106318
106377: POP
106378: POP
// end ;
106379: LD_VAR 0 5
106383: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106384: LD_EXP 199
106388: NOT
106389: IFFALSE 106439
106391: GO 106393
106393: DISABLE
// begin initHack := true ;
106394: LD_ADDR_EXP 199
106398: PUSH
106399: LD_INT 1
106401: ST_TO_ADDR
// hackTanks := [ ] ;
106402: LD_ADDR_EXP 200
106406: PUSH
106407: EMPTY
106408: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106409: LD_ADDR_EXP 201
106413: PUSH
106414: EMPTY
106415: ST_TO_ADDR
// hackLimit := 3 ;
106416: LD_ADDR_EXP 202
106420: PUSH
106421: LD_INT 3
106423: ST_TO_ADDR
// hackDist := 12 ;
106424: LD_ADDR_EXP 203
106428: PUSH
106429: LD_INT 12
106431: ST_TO_ADDR
// hackCounter := [ ] ;
106432: LD_ADDR_EXP 204
106436: PUSH
106437: EMPTY
106438: ST_TO_ADDR
// end ;
106439: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106440: LD_EXP 199
106444: PUSH
106445: LD_INT 34
106447: PUSH
106448: LD_EXP 76
106452: PUSH
106453: EMPTY
106454: LIST
106455: LIST
106456: PPUSH
106457: CALL_OW 69
106461: AND
106462: IFFALSE 106717
106464: GO 106466
106466: DISABLE
106467: LD_INT 0
106469: PPUSH
106470: PPUSH
// begin enable ;
106471: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106472: LD_ADDR_VAR 0 1
106476: PUSH
106477: LD_INT 34
106479: PUSH
106480: LD_EXP 76
106484: PUSH
106485: EMPTY
106486: LIST
106487: LIST
106488: PPUSH
106489: CALL_OW 69
106493: PUSH
106494: FOR_IN
106495: IFFALSE 106715
// begin if not i in hackTanks then
106497: LD_VAR 0 1
106501: PUSH
106502: LD_EXP 200
106506: IN
106507: NOT
106508: IFFALSE 106591
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106510: LD_ADDR_EXP 200
106514: PUSH
106515: LD_EXP 200
106519: PPUSH
106520: LD_EXP 200
106524: PUSH
106525: LD_INT 1
106527: PLUS
106528: PPUSH
106529: LD_VAR 0 1
106533: PPUSH
106534: CALL_OW 1
106538: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106539: LD_ADDR_EXP 201
106543: PUSH
106544: LD_EXP 201
106548: PPUSH
106549: LD_EXP 201
106553: PUSH
106554: LD_INT 1
106556: PLUS
106557: PPUSH
106558: EMPTY
106559: PPUSH
106560: CALL_OW 1
106564: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106565: LD_ADDR_EXP 204
106569: PUSH
106570: LD_EXP 204
106574: PPUSH
106575: LD_EXP 204
106579: PUSH
106580: LD_INT 1
106582: PLUS
106583: PPUSH
106584: EMPTY
106585: PPUSH
106586: CALL_OW 1
106590: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106591: LD_VAR 0 1
106595: PPUSH
106596: CALL_OW 302
106600: NOT
106601: IFFALSE 106614
// begin HackUnlinkAll ( i ) ;
106603: LD_VAR 0 1
106607: PPUSH
106608: CALL 106720 0 1
// continue ;
106612: GO 106494
// end ; HackCheckCapturedStatus ( i ) ;
106614: LD_VAR 0 1
106618: PPUSH
106619: CALL 107163 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106623: LD_ADDR_VAR 0 2
106627: PUSH
106628: LD_INT 81
106630: PUSH
106631: LD_VAR 0 1
106635: PPUSH
106636: CALL_OW 255
106640: PUSH
106641: EMPTY
106642: LIST
106643: LIST
106644: PUSH
106645: LD_INT 33
106647: PUSH
106648: LD_INT 3
106650: PUSH
106651: EMPTY
106652: LIST
106653: LIST
106654: PUSH
106655: LD_INT 91
106657: PUSH
106658: LD_VAR 0 1
106662: PUSH
106663: LD_EXP 203
106667: PUSH
106668: EMPTY
106669: LIST
106670: LIST
106671: LIST
106672: PUSH
106673: LD_INT 50
106675: PUSH
106676: EMPTY
106677: LIST
106678: PUSH
106679: EMPTY
106680: LIST
106681: LIST
106682: LIST
106683: LIST
106684: PPUSH
106685: CALL_OW 69
106689: ST_TO_ADDR
// if not tmp then
106690: LD_VAR 0 2
106694: NOT
106695: IFFALSE 106699
// continue ;
106697: GO 106494
// HackLink ( i , tmp ) ;
106699: LD_VAR 0 1
106703: PPUSH
106704: LD_VAR 0 2
106708: PPUSH
106709: CALL 106856 0 2
// end ;
106713: GO 106494
106715: POP
106716: POP
// end ;
106717: PPOPN 2
106719: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
106720: LD_INT 0
106722: PPUSH
106723: PPUSH
106724: PPUSH
// if not hack in hackTanks then
106725: LD_VAR 0 1
106729: PUSH
106730: LD_EXP 200
106734: IN
106735: NOT
106736: IFFALSE 106740
// exit ;
106738: GO 106851
// index := GetElementIndex ( hackTanks , hack ) ;
106740: LD_ADDR_VAR 0 4
106744: PUSH
106745: LD_EXP 200
106749: PPUSH
106750: LD_VAR 0 1
106754: PPUSH
106755: CALL 56797 0 2
106759: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106760: LD_EXP 201
106764: PUSH
106765: LD_VAR 0 4
106769: ARRAY
106770: IFFALSE 106851
// begin for i in hackTanksCaptured [ index ] do
106772: LD_ADDR_VAR 0 3
106776: PUSH
106777: LD_EXP 201
106781: PUSH
106782: LD_VAR 0 4
106786: ARRAY
106787: PUSH
106788: FOR_IN
106789: IFFALSE 106815
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106791: LD_VAR 0 3
106795: PUSH
106796: LD_INT 1
106798: ARRAY
106799: PPUSH
106800: LD_VAR 0 3
106804: PUSH
106805: LD_INT 2
106807: ARRAY
106808: PPUSH
106809: CALL_OW 235
106813: GO 106788
106815: POP
106816: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106817: LD_ADDR_EXP 201
106821: PUSH
106822: LD_EXP 201
106826: PPUSH
106827: LD_VAR 0 4
106831: PPUSH
106832: EMPTY
106833: PPUSH
106834: CALL_OW 1
106838: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
106839: LD_VAR 0 1
106843: PPUSH
106844: LD_INT 0
106846: PPUSH
106847: CALL_OW 505
// end ; end ;
106851: LD_VAR 0 2
106855: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
106856: LD_INT 0
106858: PPUSH
106859: PPUSH
106860: PPUSH
// if not hack in hackTanks or not vehicles then
106861: LD_VAR 0 1
106865: PUSH
106866: LD_EXP 200
106870: IN
106871: NOT
106872: PUSH
106873: LD_VAR 0 2
106877: NOT
106878: OR
106879: IFFALSE 106883
// exit ;
106881: GO 107158
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
106883: LD_ADDR_VAR 0 2
106887: PUSH
106888: LD_VAR 0 1
106892: PPUSH
106893: LD_VAR 0 2
106897: PPUSH
106898: LD_INT 1
106900: PPUSH
106901: LD_INT 1
106903: PPUSH
106904: CALL 57447 0 4
106908: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
106909: LD_ADDR_VAR 0 5
106913: PUSH
106914: LD_EXP 200
106918: PPUSH
106919: LD_VAR 0 1
106923: PPUSH
106924: CALL 56797 0 2
106928: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
106929: LD_EXP 201
106933: PUSH
106934: LD_VAR 0 5
106938: ARRAY
106939: PUSH
106940: LD_EXP 202
106944: LESS
106945: IFFALSE 107134
// begin for i := 1 to vehicles do
106947: LD_ADDR_VAR 0 4
106951: PUSH
106952: DOUBLE
106953: LD_INT 1
106955: DEC
106956: ST_TO_ADDR
106957: LD_VAR 0 2
106961: PUSH
106962: FOR_TO
106963: IFFALSE 107132
// begin if hackTanksCaptured [ index ] = hackLimit then
106965: LD_EXP 201
106969: PUSH
106970: LD_VAR 0 5
106974: ARRAY
106975: PUSH
106976: LD_EXP 202
106980: EQUAL
106981: IFFALSE 106985
// break ;
106983: GO 107132
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
106985: LD_ADDR_EXP 204
106989: PUSH
106990: LD_EXP 204
106994: PPUSH
106995: LD_VAR 0 5
106999: PPUSH
107000: LD_EXP 204
107004: PUSH
107005: LD_VAR 0 5
107009: ARRAY
107010: PUSH
107011: LD_INT 1
107013: PLUS
107014: PPUSH
107015: CALL_OW 1
107019: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107020: LD_ADDR_EXP 201
107024: PUSH
107025: LD_EXP 201
107029: PPUSH
107030: LD_VAR 0 5
107034: PUSH
107035: LD_EXP 201
107039: PUSH
107040: LD_VAR 0 5
107044: ARRAY
107045: PUSH
107046: LD_INT 1
107048: PLUS
107049: PUSH
107050: EMPTY
107051: LIST
107052: LIST
107053: PPUSH
107054: LD_VAR 0 2
107058: PUSH
107059: LD_VAR 0 4
107063: ARRAY
107064: PUSH
107065: LD_VAR 0 2
107069: PUSH
107070: LD_VAR 0 4
107074: ARRAY
107075: PPUSH
107076: CALL_OW 255
107080: PUSH
107081: EMPTY
107082: LIST
107083: LIST
107084: PPUSH
107085: CALL 57012 0 3
107089: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107090: LD_VAR 0 2
107094: PUSH
107095: LD_VAR 0 4
107099: ARRAY
107100: PPUSH
107101: LD_VAR 0 1
107105: PPUSH
107106: CALL_OW 255
107110: PPUSH
107111: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107115: LD_VAR 0 2
107119: PUSH
107120: LD_VAR 0 4
107124: ARRAY
107125: PPUSH
107126: CALL_OW 141
// end ;
107130: GO 106962
107132: POP
107133: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107134: LD_VAR 0 1
107138: PPUSH
107139: LD_EXP 201
107143: PUSH
107144: LD_VAR 0 5
107148: ARRAY
107149: PUSH
107150: LD_INT 0
107152: PLUS
107153: PPUSH
107154: CALL_OW 505
// end ;
107158: LD_VAR 0 3
107162: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107163: LD_INT 0
107165: PPUSH
107166: PPUSH
107167: PPUSH
107168: PPUSH
// if not hack in hackTanks then
107169: LD_VAR 0 1
107173: PUSH
107174: LD_EXP 200
107178: IN
107179: NOT
107180: IFFALSE 107184
// exit ;
107182: GO 107424
// index := GetElementIndex ( hackTanks , hack ) ;
107184: LD_ADDR_VAR 0 4
107188: PUSH
107189: LD_EXP 200
107193: PPUSH
107194: LD_VAR 0 1
107198: PPUSH
107199: CALL 56797 0 2
107203: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107204: LD_ADDR_VAR 0 3
107208: PUSH
107209: DOUBLE
107210: LD_EXP 201
107214: PUSH
107215: LD_VAR 0 4
107219: ARRAY
107220: INC
107221: ST_TO_ADDR
107222: LD_INT 1
107224: PUSH
107225: FOR_DOWNTO
107226: IFFALSE 107398
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107228: LD_ADDR_VAR 0 5
107232: PUSH
107233: LD_EXP 201
107237: PUSH
107238: LD_VAR 0 4
107242: ARRAY
107243: PUSH
107244: LD_VAR 0 3
107248: ARRAY
107249: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107250: LD_VAR 0 5
107254: PUSH
107255: LD_INT 1
107257: ARRAY
107258: PPUSH
107259: CALL_OW 302
107263: NOT
107264: PUSH
107265: LD_VAR 0 5
107269: PUSH
107270: LD_INT 1
107272: ARRAY
107273: PPUSH
107274: CALL_OW 255
107278: PUSH
107279: LD_VAR 0 1
107283: PPUSH
107284: CALL_OW 255
107288: NONEQUAL
107289: OR
107290: IFFALSE 107396
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107292: LD_VAR 0 5
107296: PUSH
107297: LD_INT 1
107299: ARRAY
107300: PPUSH
107301: CALL_OW 305
107305: PUSH
107306: LD_VAR 0 5
107310: PUSH
107311: LD_INT 1
107313: ARRAY
107314: PPUSH
107315: CALL_OW 255
107319: PUSH
107320: LD_VAR 0 1
107324: PPUSH
107325: CALL_OW 255
107329: EQUAL
107330: AND
107331: IFFALSE 107355
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107333: LD_VAR 0 5
107337: PUSH
107338: LD_INT 1
107340: ARRAY
107341: PPUSH
107342: LD_VAR 0 5
107346: PUSH
107347: LD_INT 2
107349: ARRAY
107350: PPUSH
107351: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107355: LD_ADDR_EXP 201
107359: PUSH
107360: LD_EXP 201
107364: PPUSH
107365: LD_VAR 0 4
107369: PPUSH
107370: LD_EXP 201
107374: PUSH
107375: LD_VAR 0 4
107379: ARRAY
107380: PPUSH
107381: LD_VAR 0 3
107385: PPUSH
107386: CALL_OW 3
107390: PPUSH
107391: CALL_OW 1
107395: ST_TO_ADDR
// end ; end ;
107396: GO 107225
107398: POP
107399: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107400: LD_VAR 0 1
107404: PPUSH
107405: LD_EXP 201
107409: PUSH
107410: LD_VAR 0 4
107414: ARRAY
107415: PUSH
107416: LD_INT 0
107418: PLUS
107419: PPUSH
107420: CALL_OW 505
// end ;
107424: LD_VAR 0 2
107428: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107429: LD_INT 0
107431: PPUSH
107432: PPUSH
107433: PPUSH
107434: PPUSH
// if not hack in hackTanks then
107435: LD_VAR 0 1
107439: PUSH
107440: LD_EXP 200
107444: IN
107445: NOT
107446: IFFALSE 107450
// exit ;
107448: GO 107535
// index := GetElementIndex ( hackTanks , hack ) ;
107450: LD_ADDR_VAR 0 5
107454: PUSH
107455: LD_EXP 200
107459: PPUSH
107460: LD_VAR 0 1
107464: PPUSH
107465: CALL 56797 0 2
107469: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107470: LD_ADDR_VAR 0 4
107474: PUSH
107475: DOUBLE
107476: LD_INT 1
107478: DEC
107479: ST_TO_ADDR
107480: LD_EXP 201
107484: PUSH
107485: LD_VAR 0 5
107489: ARRAY
107490: PUSH
107491: FOR_TO
107492: IFFALSE 107533
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107494: LD_EXP 201
107498: PUSH
107499: LD_VAR 0 5
107503: ARRAY
107504: PUSH
107505: LD_VAR 0 4
107509: ARRAY
107510: PUSH
107511: LD_INT 1
107513: ARRAY
107514: PUSH
107515: LD_VAR 0 2
107519: EQUAL
107520: IFFALSE 107531
// KillUnit ( vehicle ) ;
107522: LD_VAR 0 2
107526: PPUSH
107527: CALL_OW 66
107531: GO 107491
107533: POP
107534: POP
// end ;
107535: LD_VAR 0 3
107539: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107540: LD_EXP 205
107544: NOT
107545: IFFALSE 107580
107547: GO 107549
107549: DISABLE
// begin initMiner := true ;
107550: LD_ADDR_EXP 205
107554: PUSH
107555: LD_INT 1
107557: ST_TO_ADDR
// minersList := [ ] ;
107558: LD_ADDR_EXP 206
107562: PUSH
107563: EMPTY
107564: ST_TO_ADDR
// minerMinesList := [ ] ;
107565: LD_ADDR_EXP 207
107569: PUSH
107570: EMPTY
107571: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107572: LD_ADDR_EXP 208
107576: PUSH
107577: LD_INT 5
107579: ST_TO_ADDR
// end ;
107580: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107581: LD_EXP 205
107585: PUSH
107586: LD_INT 34
107588: PUSH
107589: LD_EXP 81
107593: PUSH
107594: EMPTY
107595: LIST
107596: LIST
107597: PPUSH
107598: CALL_OW 69
107602: AND
107603: IFFALSE 108066
107605: GO 107607
107607: DISABLE
107608: LD_INT 0
107610: PPUSH
107611: PPUSH
107612: PPUSH
107613: PPUSH
// begin enable ;
107614: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107615: LD_ADDR_VAR 0 1
107619: PUSH
107620: LD_INT 34
107622: PUSH
107623: LD_EXP 81
107627: PUSH
107628: EMPTY
107629: LIST
107630: LIST
107631: PPUSH
107632: CALL_OW 69
107636: PUSH
107637: FOR_IN
107638: IFFALSE 107710
// begin if not i in minersList then
107640: LD_VAR 0 1
107644: PUSH
107645: LD_EXP 206
107649: IN
107650: NOT
107651: IFFALSE 107708
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
107653: LD_ADDR_EXP 206
107657: PUSH
107658: LD_EXP 206
107662: PPUSH
107663: LD_EXP 206
107667: PUSH
107668: LD_INT 1
107670: PLUS
107671: PPUSH
107672: LD_VAR 0 1
107676: PPUSH
107677: CALL_OW 1
107681: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
107682: LD_ADDR_EXP 207
107686: PUSH
107687: LD_EXP 207
107691: PPUSH
107692: LD_EXP 207
107696: PUSH
107697: LD_INT 1
107699: PLUS
107700: PPUSH
107701: EMPTY
107702: PPUSH
107703: CALL_OW 1
107707: ST_TO_ADDR
// end end ;
107708: GO 107637
107710: POP
107711: POP
// for i := minerMinesList downto 1 do
107712: LD_ADDR_VAR 0 1
107716: PUSH
107717: DOUBLE
107718: LD_EXP 207
107722: INC
107723: ST_TO_ADDR
107724: LD_INT 1
107726: PUSH
107727: FOR_DOWNTO
107728: IFFALSE 108064
// begin if IsLive ( minersList [ i ] ) then
107730: LD_EXP 206
107734: PUSH
107735: LD_VAR 0 1
107739: ARRAY
107740: PPUSH
107741: CALL_OW 300
107745: IFFALSE 107773
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107747: LD_EXP 206
107751: PUSH
107752: LD_VAR 0 1
107756: ARRAY
107757: PPUSH
107758: LD_EXP 207
107762: PUSH
107763: LD_VAR 0 1
107767: ARRAY
107768: PPUSH
107769: CALL_OW 505
// if not minerMinesList [ i ] then
107773: LD_EXP 207
107777: PUSH
107778: LD_VAR 0 1
107782: ARRAY
107783: NOT
107784: IFFALSE 107788
// continue ;
107786: GO 107727
// for j := minerMinesList [ i ] downto 1 do
107788: LD_ADDR_VAR 0 2
107792: PUSH
107793: DOUBLE
107794: LD_EXP 207
107798: PUSH
107799: LD_VAR 0 1
107803: ARRAY
107804: INC
107805: ST_TO_ADDR
107806: LD_INT 1
107808: PUSH
107809: FOR_DOWNTO
107810: IFFALSE 108060
// begin side := GetSide ( minersList [ i ] ) ;
107812: LD_ADDR_VAR 0 3
107816: PUSH
107817: LD_EXP 206
107821: PUSH
107822: LD_VAR 0 1
107826: ARRAY
107827: PPUSH
107828: CALL_OW 255
107832: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
107833: LD_ADDR_VAR 0 4
107837: PUSH
107838: LD_EXP 207
107842: PUSH
107843: LD_VAR 0 1
107847: ARRAY
107848: PUSH
107849: LD_VAR 0 2
107853: ARRAY
107854: PUSH
107855: LD_INT 1
107857: ARRAY
107858: PPUSH
107859: LD_EXP 207
107863: PUSH
107864: LD_VAR 0 1
107868: ARRAY
107869: PUSH
107870: LD_VAR 0 2
107874: ARRAY
107875: PUSH
107876: LD_INT 2
107878: ARRAY
107879: PPUSH
107880: CALL_OW 428
107884: ST_TO_ADDR
// if not tmp then
107885: LD_VAR 0 4
107889: NOT
107890: IFFALSE 107894
// continue ;
107892: GO 107809
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
107894: LD_VAR 0 4
107898: PUSH
107899: LD_INT 81
107901: PUSH
107902: LD_VAR 0 3
107906: PUSH
107907: EMPTY
107908: LIST
107909: LIST
107910: PPUSH
107911: CALL_OW 69
107915: IN
107916: PUSH
107917: LD_EXP 207
107921: PUSH
107922: LD_VAR 0 1
107926: ARRAY
107927: PUSH
107928: LD_VAR 0 2
107932: ARRAY
107933: PUSH
107934: LD_INT 1
107936: ARRAY
107937: PPUSH
107938: LD_EXP 207
107942: PUSH
107943: LD_VAR 0 1
107947: ARRAY
107948: PUSH
107949: LD_VAR 0 2
107953: ARRAY
107954: PUSH
107955: LD_INT 2
107957: ARRAY
107958: PPUSH
107959: CALL_OW 458
107963: AND
107964: IFFALSE 108058
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
107966: LD_EXP 207
107970: PUSH
107971: LD_VAR 0 1
107975: ARRAY
107976: PUSH
107977: LD_VAR 0 2
107981: ARRAY
107982: PUSH
107983: LD_INT 1
107985: ARRAY
107986: PPUSH
107987: LD_EXP 207
107991: PUSH
107992: LD_VAR 0 1
107996: ARRAY
107997: PUSH
107998: LD_VAR 0 2
108002: ARRAY
108003: PUSH
108004: LD_INT 2
108006: ARRAY
108007: PPUSH
108008: LD_VAR 0 3
108012: PPUSH
108013: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108017: LD_ADDR_EXP 207
108021: PUSH
108022: LD_EXP 207
108026: PPUSH
108027: LD_VAR 0 1
108031: PPUSH
108032: LD_EXP 207
108036: PUSH
108037: LD_VAR 0 1
108041: ARRAY
108042: PPUSH
108043: LD_VAR 0 2
108047: PPUSH
108048: CALL_OW 3
108052: PPUSH
108053: CALL_OW 1
108057: ST_TO_ADDR
// end ; end ;
108058: GO 107809
108060: POP
108061: POP
// end ;
108062: GO 107727
108064: POP
108065: POP
// end ;
108066: PPOPN 4
108068: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108069: LD_INT 0
108071: PPUSH
108072: PPUSH
// result := false ;
108073: LD_ADDR_VAR 0 4
108077: PUSH
108078: LD_INT 0
108080: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108081: LD_VAR 0 1
108085: PPUSH
108086: CALL_OW 264
108090: PUSH
108091: LD_EXP 81
108095: EQUAL
108096: NOT
108097: IFFALSE 108101
// exit ;
108099: GO 108341
// index := GetElementIndex ( minersList , unit ) ;
108101: LD_ADDR_VAR 0 5
108105: PUSH
108106: LD_EXP 206
108110: PPUSH
108111: LD_VAR 0 1
108115: PPUSH
108116: CALL 56797 0 2
108120: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108121: LD_EXP 207
108125: PUSH
108126: LD_VAR 0 5
108130: ARRAY
108131: PUSH
108132: LD_EXP 208
108136: GREATEREQUAL
108137: IFFALSE 108141
// exit ;
108139: GO 108341
// ComMoveXY ( unit , x , y ) ;
108141: LD_VAR 0 1
108145: PPUSH
108146: LD_VAR 0 2
108150: PPUSH
108151: LD_VAR 0 3
108155: PPUSH
108156: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108160: LD_INT 35
108162: PPUSH
108163: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108167: LD_VAR 0 1
108171: PPUSH
108172: LD_VAR 0 2
108176: PPUSH
108177: LD_VAR 0 3
108181: PPUSH
108182: CALL 87569 0 3
108186: NOT
108187: PUSH
108188: LD_VAR 0 1
108192: PPUSH
108193: CALL_OW 314
108197: AND
108198: IFFALSE 108202
// exit ;
108200: GO 108341
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108202: LD_VAR 0 2
108206: PPUSH
108207: LD_VAR 0 3
108211: PPUSH
108212: CALL_OW 428
108216: PUSH
108217: LD_VAR 0 1
108221: EQUAL
108222: PUSH
108223: LD_VAR 0 1
108227: PPUSH
108228: CALL_OW 314
108232: NOT
108233: AND
108234: IFFALSE 108160
// PlaySoundXY ( x , y , PlantMine ) ;
108236: LD_VAR 0 2
108240: PPUSH
108241: LD_VAR 0 3
108245: PPUSH
108246: LD_STRING PlantMine
108248: PPUSH
108249: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108253: LD_VAR 0 2
108257: PPUSH
108258: LD_VAR 0 3
108262: PPUSH
108263: LD_VAR 0 1
108267: PPUSH
108268: CALL_OW 255
108272: PPUSH
108273: LD_INT 0
108275: PPUSH
108276: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108280: LD_ADDR_EXP 207
108284: PUSH
108285: LD_EXP 207
108289: PPUSH
108290: LD_VAR 0 5
108294: PUSH
108295: LD_EXP 207
108299: PUSH
108300: LD_VAR 0 5
108304: ARRAY
108305: PUSH
108306: LD_INT 1
108308: PLUS
108309: PUSH
108310: EMPTY
108311: LIST
108312: LIST
108313: PPUSH
108314: LD_VAR 0 2
108318: PUSH
108319: LD_VAR 0 3
108323: PUSH
108324: EMPTY
108325: LIST
108326: LIST
108327: PPUSH
108328: CALL 57012 0 3
108332: ST_TO_ADDR
// result := true ;
108333: LD_ADDR_VAR 0 4
108337: PUSH
108338: LD_INT 1
108340: ST_TO_ADDR
// end ;
108341: LD_VAR 0 4
108345: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108346: LD_INT 0
108348: PPUSH
108349: PPUSH
108350: PPUSH
// if not unit in minersList then
108351: LD_VAR 0 1
108355: PUSH
108356: LD_EXP 206
108360: IN
108361: NOT
108362: IFFALSE 108366
// exit ;
108364: GO 108758
// index := GetElementIndex ( minersList , unit ) ;
108366: LD_ADDR_VAR 0 6
108370: PUSH
108371: LD_EXP 206
108375: PPUSH
108376: LD_VAR 0 1
108380: PPUSH
108381: CALL 56797 0 2
108385: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108386: LD_ADDR_VAR 0 5
108390: PUSH
108391: DOUBLE
108392: LD_EXP 207
108396: PUSH
108397: LD_VAR 0 6
108401: ARRAY
108402: INC
108403: ST_TO_ADDR
108404: LD_INT 1
108406: PUSH
108407: FOR_DOWNTO
108408: IFFALSE 108569
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108410: LD_EXP 207
108414: PUSH
108415: LD_VAR 0 6
108419: ARRAY
108420: PUSH
108421: LD_VAR 0 5
108425: ARRAY
108426: PUSH
108427: LD_INT 1
108429: ARRAY
108430: PUSH
108431: LD_VAR 0 2
108435: EQUAL
108436: PUSH
108437: LD_EXP 207
108441: PUSH
108442: LD_VAR 0 6
108446: ARRAY
108447: PUSH
108448: LD_VAR 0 5
108452: ARRAY
108453: PUSH
108454: LD_INT 2
108456: ARRAY
108457: PUSH
108458: LD_VAR 0 3
108462: EQUAL
108463: AND
108464: IFFALSE 108567
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108466: LD_EXP 207
108470: PUSH
108471: LD_VAR 0 6
108475: ARRAY
108476: PUSH
108477: LD_VAR 0 5
108481: ARRAY
108482: PUSH
108483: LD_INT 1
108485: ARRAY
108486: PPUSH
108487: LD_EXP 207
108491: PUSH
108492: LD_VAR 0 6
108496: ARRAY
108497: PUSH
108498: LD_VAR 0 5
108502: ARRAY
108503: PUSH
108504: LD_INT 2
108506: ARRAY
108507: PPUSH
108508: LD_VAR 0 1
108512: PPUSH
108513: CALL_OW 255
108517: PPUSH
108518: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108522: LD_ADDR_EXP 207
108526: PUSH
108527: LD_EXP 207
108531: PPUSH
108532: LD_VAR 0 6
108536: PPUSH
108537: LD_EXP 207
108541: PUSH
108542: LD_VAR 0 6
108546: ARRAY
108547: PPUSH
108548: LD_VAR 0 5
108552: PPUSH
108553: CALL_OW 3
108557: PPUSH
108558: CALL_OW 1
108562: ST_TO_ADDR
// exit ;
108563: POP
108564: POP
108565: GO 108758
// end ; end ;
108567: GO 108407
108569: POP
108570: POP
// for i := minerMinesList [ index ] downto 1 do
108571: LD_ADDR_VAR 0 5
108575: PUSH
108576: DOUBLE
108577: LD_EXP 207
108581: PUSH
108582: LD_VAR 0 6
108586: ARRAY
108587: INC
108588: ST_TO_ADDR
108589: LD_INT 1
108591: PUSH
108592: FOR_DOWNTO
108593: IFFALSE 108756
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108595: LD_EXP 207
108599: PUSH
108600: LD_VAR 0 6
108604: ARRAY
108605: PUSH
108606: LD_VAR 0 5
108610: ARRAY
108611: PUSH
108612: LD_INT 1
108614: ARRAY
108615: PPUSH
108616: LD_EXP 207
108620: PUSH
108621: LD_VAR 0 6
108625: ARRAY
108626: PUSH
108627: LD_VAR 0 5
108631: ARRAY
108632: PUSH
108633: LD_INT 2
108635: ARRAY
108636: PPUSH
108637: LD_VAR 0 2
108641: PPUSH
108642: LD_VAR 0 3
108646: PPUSH
108647: CALL_OW 298
108651: PUSH
108652: LD_INT 6
108654: LESS
108655: IFFALSE 108754
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108657: LD_EXP 207
108661: PUSH
108662: LD_VAR 0 6
108666: ARRAY
108667: PUSH
108668: LD_VAR 0 5
108672: ARRAY
108673: PUSH
108674: LD_INT 1
108676: ARRAY
108677: PPUSH
108678: LD_EXP 207
108682: PUSH
108683: LD_VAR 0 6
108687: ARRAY
108688: PUSH
108689: LD_VAR 0 5
108693: ARRAY
108694: PUSH
108695: LD_INT 2
108697: ARRAY
108698: PPUSH
108699: LD_VAR 0 1
108703: PPUSH
108704: CALL_OW 255
108708: PPUSH
108709: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108713: LD_ADDR_EXP 207
108717: PUSH
108718: LD_EXP 207
108722: PPUSH
108723: LD_VAR 0 6
108727: PPUSH
108728: LD_EXP 207
108732: PUSH
108733: LD_VAR 0 6
108737: ARRAY
108738: PPUSH
108739: LD_VAR 0 5
108743: PPUSH
108744: CALL_OW 3
108748: PPUSH
108749: CALL_OW 1
108753: ST_TO_ADDR
// end ; end ;
108754: GO 108592
108756: POP
108757: POP
// end ;
108758: LD_VAR 0 4
108762: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108763: LD_INT 0
108765: PPUSH
108766: PPUSH
108767: PPUSH
108768: PPUSH
108769: PPUSH
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108774: LD_VAR 0 1
108778: PPUSH
108779: CALL_OW 264
108783: PUSH
108784: LD_EXP 81
108788: EQUAL
108789: NOT
108790: PUSH
108791: LD_VAR 0 1
108795: PUSH
108796: LD_EXP 206
108800: IN
108801: NOT
108802: OR
108803: IFFALSE 108807
// exit ;
108805: GO 109129
// index := GetElementIndex ( minersList , unit ) ;
108807: LD_ADDR_VAR 0 6
108811: PUSH
108812: LD_EXP 206
108816: PPUSH
108817: LD_VAR 0 1
108821: PPUSH
108822: CALL 56797 0 2
108826: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108827: LD_ADDR_VAR 0 8
108831: PUSH
108832: LD_EXP 208
108836: PUSH
108837: LD_EXP 207
108841: PUSH
108842: LD_VAR 0 6
108846: ARRAY
108847: MINUS
108848: ST_TO_ADDR
// if not minesFreeAmount then
108849: LD_VAR 0 8
108853: NOT
108854: IFFALSE 108858
// exit ;
108856: GO 109129
// tmp := [ ] ;
108858: LD_ADDR_VAR 0 7
108862: PUSH
108863: EMPTY
108864: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
108865: LD_ADDR_VAR 0 5
108869: PUSH
108870: DOUBLE
108871: LD_INT 1
108873: DEC
108874: ST_TO_ADDR
108875: LD_VAR 0 8
108879: PUSH
108880: FOR_TO
108881: IFFALSE 109076
// begin _d := rand ( 0 , 5 ) ;
108883: LD_ADDR_VAR 0 11
108887: PUSH
108888: LD_INT 0
108890: PPUSH
108891: LD_INT 5
108893: PPUSH
108894: CALL_OW 12
108898: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
108899: LD_ADDR_VAR 0 12
108903: PUSH
108904: LD_INT 2
108906: PPUSH
108907: LD_INT 6
108909: PPUSH
108910: CALL_OW 12
108914: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
108915: LD_ADDR_VAR 0 9
108919: PUSH
108920: LD_VAR 0 2
108924: PPUSH
108925: LD_VAR 0 11
108929: PPUSH
108930: LD_VAR 0 12
108934: PPUSH
108935: CALL_OW 272
108939: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
108940: LD_ADDR_VAR 0 10
108944: PUSH
108945: LD_VAR 0 3
108949: PPUSH
108950: LD_VAR 0 11
108954: PPUSH
108955: LD_VAR 0 12
108959: PPUSH
108960: CALL_OW 273
108964: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
108965: LD_VAR 0 9
108969: PPUSH
108970: LD_VAR 0 10
108974: PPUSH
108975: CALL_OW 488
108979: PUSH
108980: LD_VAR 0 9
108984: PUSH
108985: LD_VAR 0 10
108989: PUSH
108990: EMPTY
108991: LIST
108992: LIST
108993: PUSH
108994: LD_VAR 0 7
108998: IN
108999: NOT
109000: AND
109001: PUSH
109002: LD_VAR 0 9
109006: PPUSH
109007: LD_VAR 0 10
109011: PPUSH
109012: CALL_OW 458
109016: NOT
109017: AND
109018: IFFALSE 109060
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109020: LD_ADDR_VAR 0 7
109024: PUSH
109025: LD_VAR 0 7
109029: PPUSH
109030: LD_VAR 0 7
109034: PUSH
109035: LD_INT 1
109037: PLUS
109038: PPUSH
109039: LD_VAR 0 9
109043: PUSH
109044: LD_VAR 0 10
109048: PUSH
109049: EMPTY
109050: LIST
109051: LIST
109052: PPUSH
109053: CALL_OW 1
109057: ST_TO_ADDR
109058: GO 109074
// i := i - 1 ;
109060: LD_ADDR_VAR 0 5
109064: PUSH
109065: LD_VAR 0 5
109069: PUSH
109070: LD_INT 1
109072: MINUS
109073: ST_TO_ADDR
// end ;
109074: GO 108880
109076: POP
109077: POP
// for i in tmp do
109078: LD_ADDR_VAR 0 5
109082: PUSH
109083: LD_VAR 0 7
109087: PUSH
109088: FOR_IN
109089: IFFALSE 109127
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109091: LD_VAR 0 1
109095: PPUSH
109096: LD_VAR 0 5
109100: PUSH
109101: LD_INT 1
109103: ARRAY
109104: PPUSH
109105: LD_VAR 0 5
109109: PUSH
109110: LD_INT 2
109112: ARRAY
109113: PPUSH
109114: CALL 108069 0 3
109118: NOT
109119: IFFALSE 109125
// exit ;
109121: POP
109122: POP
109123: GO 109129
109125: GO 109088
109127: POP
109128: POP
// end ;
109129: LD_VAR 0 4
109133: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109134: LD_INT 0
109136: PPUSH
109137: PPUSH
109138: PPUSH
109139: PPUSH
109140: PPUSH
109141: PPUSH
109142: PPUSH
// if not GetClass ( unit ) = class_sniper then
109143: LD_VAR 0 1
109147: PPUSH
109148: CALL_OW 257
109152: PUSH
109153: LD_INT 5
109155: EQUAL
109156: NOT
109157: IFFALSE 109161
// exit ;
109159: GO 109549
// dist := 8 ;
109161: LD_ADDR_VAR 0 5
109165: PUSH
109166: LD_INT 8
109168: ST_TO_ADDR
// viewRange := 12 ;
109169: LD_ADDR_VAR 0 7
109173: PUSH
109174: LD_INT 12
109176: ST_TO_ADDR
// side := GetSide ( unit ) ;
109177: LD_ADDR_VAR 0 6
109181: PUSH
109182: LD_VAR 0 1
109186: PPUSH
109187: CALL_OW 255
109191: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109192: LD_INT 61
109194: PPUSH
109195: LD_VAR 0 6
109199: PPUSH
109200: CALL_OW 321
109204: PUSH
109205: LD_INT 2
109207: EQUAL
109208: IFFALSE 109218
// viewRange := 16 ;
109210: LD_ADDR_VAR 0 7
109214: PUSH
109215: LD_INT 16
109217: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109218: LD_VAR 0 1
109222: PPUSH
109223: LD_VAR 0 2
109227: PPUSH
109228: LD_VAR 0 3
109232: PPUSH
109233: CALL_OW 297
109237: PUSH
109238: LD_VAR 0 5
109242: GREATER
109243: IFFALSE 109322
// begin ComMoveXY ( unit , x , y ) ;
109245: LD_VAR 0 1
109249: PPUSH
109250: LD_VAR 0 2
109254: PPUSH
109255: LD_VAR 0 3
109259: PPUSH
109260: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109264: LD_INT 35
109266: PPUSH
109267: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109271: LD_VAR 0 1
109275: PPUSH
109276: LD_VAR 0 2
109280: PPUSH
109281: LD_VAR 0 3
109285: PPUSH
109286: CALL 87569 0 3
109290: NOT
109291: IFFALSE 109295
// exit ;
109293: GO 109549
// until GetDistUnitXY ( unit , x , y ) < dist ;
109295: LD_VAR 0 1
109299: PPUSH
109300: LD_VAR 0 2
109304: PPUSH
109305: LD_VAR 0 3
109309: PPUSH
109310: CALL_OW 297
109314: PUSH
109315: LD_VAR 0 5
109319: LESS
109320: IFFALSE 109264
// end ; ComTurnXY ( unit , x , y ) ;
109322: LD_VAR 0 1
109326: PPUSH
109327: LD_VAR 0 2
109331: PPUSH
109332: LD_VAR 0 3
109336: PPUSH
109337: CALL_OW 118
// wait ( 5 ) ;
109341: LD_INT 5
109343: PPUSH
109344: CALL_OW 67
// _d := GetDir ( unit ) ;
109348: LD_ADDR_VAR 0 10
109352: PUSH
109353: LD_VAR 0 1
109357: PPUSH
109358: CALL_OW 254
109362: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109363: LD_ADDR_VAR 0 8
109367: PUSH
109368: LD_VAR 0 1
109372: PPUSH
109373: CALL_OW 250
109377: PPUSH
109378: LD_VAR 0 10
109382: PPUSH
109383: LD_VAR 0 5
109387: PPUSH
109388: CALL_OW 272
109392: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109393: LD_ADDR_VAR 0 9
109397: PUSH
109398: LD_VAR 0 1
109402: PPUSH
109403: CALL_OW 251
109407: PPUSH
109408: LD_VAR 0 10
109412: PPUSH
109413: LD_VAR 0 5
109417: PPUSH
109418: CALL_OW 273
109422: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109423: LD_VAR 0 8
109427: PPUSH
109428: LD_VAR 0 9
109432: PPUSH
109433: CALL_OW 488
109437: NOT
109438: IFFALSE 109442
// exit ;
109440: GO 109549
// ComAnimCustom ( unit , 1 ) ;
109442: LD_VAR 0 1
109446: PPUSH
109447: LD_INT 1
109449: PPUSH
109450: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109454: LD_VAR 0 8
109458: PPUSH
109459: LD_VAR 0 9
109463: PPUSH
109464: LD_VAR 0 6
109468: PPUSH
109469: LD_VAR 0 7
109473: PPUSH
109474: CALL_OW 330
// repeat wait ( 1 ) ;
109478: LD_INT 1
109480: PPUSH
109481: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109485: LD_VAR 0 1
109489: PPUSH
109490: CALL_OW 316
109494: PUSH
109495: LD_VAR 0 1
109499: PPUSH
109500: CALL_OW 314
109504: OR
109505: PUSH
109506: LD_VAR 0 1
109510: PPUSH
109511: CALL_OW 302
109515: NOT
109516: OR
109517: PUSH
109518: LD_VAR 0 1
109522: PPUSH
109523: CALL_OW 301
109527: OR
109528: IFFALSE 109478
// RemoveSeeing ( _x , _y , side ) ;
109530: LD_VAR 0 8
109534: PPUSH
109535: LD_VAR 0 9
109539: PPUSH
109540: LD_VAR 0 6
109544: PPUSH
109545: CALL_OW 331
// end ; end_of_file
109549: LD_VAR 0 4
109553: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109554: LD_INT 0
109556: PPUSH
109557: PPUSH
109558: PPUSH
109559: PPUSH
109560: PPUSH
109561: PPUSH
109562: PPUSH
109563: PPUSH
109564: PPUSH
109565: PPUSH
109566: PPUSH
109567: PPUSH
109568: PPUSH
109569: PPUSH
109570: PPUSH
109571: PPUSH
109572: PPUSH
109573: PPUSH
109574: PPUSH
109575: PPUSH
109576: PPUSH
109577: PPUSH
109578: PPUSH
109579: PPUSH
109580: PPUSH
109581: PPUSH
109582: PPUSH
109583: PPUSH
109584: PPUSH
109585: PPUSH
109586: PPUSH
109587: PPUSH
109588: PPUSH
109589: PPUSH
// if not list then
109590: LD_VAR 0 1
109594: NOT
109595: IFFALSE 109599
// exit ;
109597: GO 114258
// base := list [ 1 ] ;
109599: LD_ADDR_VAR 0 3
109603: PUSH
109604: LD_VAR 0 1
109608: PUSH
109609: LD_INT 1
109611: ARRAY
109612: ST_TO_ADDR
// group := list [ 2 ] ;
109613: LD_ADDR_VAR 0 4
109617: PUSH
109618: LD_VAR 0 1
109622: PUSH
109623: LD_INT 2
109625: ARRAY
109626: ST_TO_ADDR
// path := list [ 3 ] ;
109627: LD_ADDR_VAR 0 5
109631: PUSH
109632: LD_VAR 0 1
109636: PUSH
109637: LD_INT 3
109639: ARRAY
109640: ST_TO_ADDR
// flags := list [ 4 ] ;
109641: LD_ADDR_VAR 0 6
109645: PUSH
109646: LD_VAR 0 1
109650: PUSH
109651: LD_INT 4
109653: ARRAY
109654: ST_TO_ADDR
// mined := [ ] ;
109655: LD_ADDR_VAR 0 27
109659: PUSH
109660: EMPTY
109661: ST_TO_ADDR
// bombed := [ ] ;
109662: LD_ADDR_VAR 0 28
109666: PUSH
109667: EMPTY
109668: ST_TO_ADDR
// healers := [ ] ;
109669: LD_ADDR_VAR 0 31
109673: PUSH
109674: EMPTY
109675: ST_TO_ADDR
// to_heal := [ ] ;
109676: LD_ADDR_VAR 0 30
109680: PUSH
109681: EMPTY
109682: ST_TO_ADDR
// repairs := [ ] ;
109683: LD_ADDR_VAR 0 33
109687: PUSH
109688: EMPTY
109689: ST_TO_ADDR
// to_repair := [ ] ;
109690: LD_ADDR_VAR 0 32
109694: PUSH
109695: EMPTY
109696: ST_TO_ADDR
// if not group or not path then
109697: LD_VAR 0 4
109701: NOT
109702: PUSH
109703: LD_VAR 0 5
109707: NOT
109708: OR
109709: IFFALSE 109713
// exit ;
109711: GO 114258
// side := GetSide ( group [ 1 ] ) ;
109713: LD_ADDR_VAR 0 35
109717: PUSH
109718: LD_VAR 0 4
109722: PUSH
109723: LD_INT 1
109725: ARRAY
109726: PPUSH
109727: CALL_OW 255
109731: ST_TO_ADDR
// if flags then
109732: LD_VAR 0 6
109736: IFFALSE 109880
// begin f_ignore_area := flags [ 1 ] ;
109738: LD_ADDR_VAR 0 17
109742: PUSH
109743: LD_VAR 0 6
109747: PUSH
109748: LD_INT 1
109750: ARRAY
109751: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109752: LD_ADDR_VAR 0 18
109756: PUSH
109757: LD_VAR 0 6
109761: PUSH
109762: LD_INT 2
109764: ARRAY
109765: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109766: LD_ADDR_VAR 0 19
109770: PUSH
109771: LD_VAR 0 6
109775: PUSH
109776: LD_INT 3
109778: ARRAY
109779: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109780: LD_ADDR_VAR 0 20
109784: PUSH
109785: LD_VAR 0 6
109789: PUSH
109790: LD_INT 4
109792: ARRAY
109793: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109794: LD_ADDR_VAR 0 21
109798: PUSH
109799: LD_VAR 0 6
109803: PUSH
109804: LD_INT 5
109806: ARRAY
109807: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109808: LD_ADDR_VAR 0 22
109812: PUSH
109813: LD_VAR 0 6
109817: PUSH
109818: LD_INT 6
109820: ARRAY
109821: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109822: LD_ADDR_VAR 0 23
109826: PUSH
109827: LD_VAR 0 6
109831: PUSH
109832: LD_INT 7
109834: ARRAY
109835: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
109836: LD_ADDR_VAR 0 24
109840: PUSH
109841: LD_VAR 0 6
109845: PUSH
109846: LD_INT 8
109848: ARRAY
109849: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
109850: LD_ADDR_VAR 0 25
109854: PUSH
109855: LD_VAR 0 6
109859: PUSH
109860: LD_INT 9
109862: ARRAY
109863: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
109864: LD_ADDR_VAR 0 26
109868: PUSH
109869: LD_VAR 0 6
109873: PUSH
109874: LD_INT 10
109876: ARRAY
109877: ST_TO_ADDR
// end else
109878: GO 109960
// begin f_ignore_area := false ;
109880: LD_ADDR_VAR 0 17
109884: PUSH
109885: LD_INT 0
109887: ST_TO_ADDR
// f_capture := false ;
109888: LD_ADDR_VAR 0 18
109892: PUSH
109893: LD_INT 0
109895: ST_TO_ADDR
// f_ignore_civ := false ;
109896: LD_ADDR_VAR 0 19
109900: PUSH
109901: LD_INT 0
109903: ST_TO_ADDR
// f_murder := false ;
109904: LD_ADDR_VAR 0 20
109908: PUSH
109909: LD_INT 0
109911: ST_TO_ADDR
// f_mines := false ;
109912: LD_ADDR_VAR 0 21
109916: PUSH
109917: LD_INT 0
109919: ST_TO_ADDR
// f_repair := false ;
109920: LD_ADDR_VAR 0 22
109924: PUSH
109925: LD_INT 0
109927: ST_TO_ADDR
// f_heal := false ;
109928: LD_ADDR_VAR 0 23
109932: PUSH
109933: LD_INT 0
109935: ST_TO_ADDR
// f_spacetime := false ;
109936: LD_ADDR_VAR 0 24
109940: PUSH
109941: LD_INT 0
109943: ST_TO_ADDR
// f_attack_depot := false ;
109944: LD_ADDR_VAR 0 25
109948: PUSH
109949: LD_INT 0
109951: ST_TO_ADDR
// f_crawl := false ;
109952: LD_ADDR_VAR 0 26
109956: PUSH
109957: LD_INT 0
109959: ST_TO_ADDR
// end ; if f_heal then
109960: LD_VAR 0 23
109964: IFFALSE 109991
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
109966: LD_ADDR_VAR 0 31
109970: PUSH
109971: LD_VAR 0 4
109975: PPUSH
109976: LD_INT 25
109978: PUSH
109979: LD_INT 4
109981: PUSH
109982: EMPTY
109983: LIST
109984: LIST
109985: PPUSH
109986: CALL_OW 72
109990: ST_TO_ADDR
// if f_repair then
109991: LD_VAR 0 22
109995: IFFALSE 110022
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
109997: LD_ADDR_VAR 0 33
110001: PUSH
110002: LD_VAR 0 4
110006: PPUSH
110007: LD_INT 25
110009: PUSH
110010: LD_INT 3
110012: PUSH
110013: EMPTY
110014: LIST
110015: LIST
110016: PPUSH
110017: CALL_OW 72
110021: ST_TO_ADDR
// units_path := [ ] ;
110022: LD_ADDR_VAR 0 16
110026: PUSH
110027: EMPTY
110028: ST_TO_ADDR
// for i = 1 to group do
110029: LD_ADDR_VAR 0 7
110033: PUSH
110034: DOUBLE
110035: LD_INT 1
110037: DEC
110038: ST_TO_ADDR
110039: LD_VAR 0 4
110043: PUSH
110044: FOR_TO
110045: IFFALSE 110074
// units_path := Replace ( units_path , i , path ) ;
110047: LD_ADDR_VAR 0 16
110051: PUSH
110052: LD_VAR 0 16
110056: PPUSH
110057: LD_VAR 0 7
110061: PPUSH
110062: LD_VAR 0 5
110066: PPUSH
110067: CALL_OW 1
110071: ST_TO_ADDR
110072: GO 110044
110074: POP
110075: POP
// repeat for i = group downto 1 do
110076: LD_ADDR_VAR 0 7
110080: PUSH
110081: DOUBLE
110082: LD_VAR 0 4
110086: INC
110087: ST_TO_ADDR
110088: LD_INT 1
110090: PUSH
110091: FOR_DOWNTO
110092: IFFALSE 114214
// begin wait ( 5 ) ;
110094: LD_INT 5
110096: PPUSH
110097: CALL_OW 67
// tmp := [ ] ;
110101: LD_ADDR_VAR 0 14
110105: PUSH
110106: EMPTY
110107: ST_TO_ADDR
// attacking := false ;
110108: LD_ADDR_VAR 0 29
110112: PUSH
110113: LD_INT 0
110115: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110116: LD_VAR 0 4
110120: PUSH
110121: LD_VAR 0 7
110125: ARRAY
110126: PPUSH
110127: CALL_OW 301
110131: PUSH
110132: LD_VAR 0 4
110136: PUSH
110137: LD_VAR 0 7
110141: ARRAY
110142: NOT
110143: OR
110144: IFFALSE 110253
// begin if GetType ( group [ i ] ) = unit_human then
110146: LD_VAR 0 4
110150: PUSH
110151: LD_VAR 0 7
110155: ARRAY
110156: PPUSH
110157: CALL_OW 247
110161: PUSH
110162: LD_INT 1
110164: EQUAL
110165: IFFALSE 110211
// begin to_heal := to_heal diff group [ i ] ;
110167: LD_ADDR_VAR 0 30
110171: PUSH
110172: LD_VAR 0 30
110176: PUSH
110177: LD_VAR 0 4
110181: PUSH
110182: LD_VAR 0 7
110186: ARRAY
110187: DIFF
110188: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110189: LD_ADDR_VAR 0 31
110193: PUSH
110194: LD_VAR 0 31
110198: PUSH
110199: LD_VAR 0 4
110203: PUSH
110204: LD_VAR 0 7
110208: ARRAY
110209: DIFF
110210: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110211: LD_ADDR_VAR 0 4
110215: PUSH
110216: LD_VAR 0 4
110220: PPUSH
110221: LD_VAR 0 7
110225: PPUSH
110226: CALL_OW 3
110230: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110231: LD_ADDR_VAR 0 16
110235: PUSH
110236: LD_VAR 0 16
110240: PPUSH
110241: LD_VAR 0 7
110245: PPUSH
110246: CALL_OW 3
110250: ST_TO_ADDR
// continue ;
110251: GO 110091
// end ; if f_repair then
110253: LD_VAR 0 22
110257: IFFALSE 110746
// begin if GetType ( group [ i ] ) = unit_vehicle then
110259: LD_VAR 0 4
110263: PUSH
110264: LD_VAR 0 7
110268: ARRAY
110269: PPUSH
110270: CALL_OW 247
110274: PUSH
110275: LD_INT 2
110277: EQUAL
110278: IFFALSE 110468
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110280: LD_VAR 0 4
110284: PUSH
110285: LD_VAR 0 7
110289: ARRAY
110290: PPUSH
110291: CALL_OW 256
110295: PUSH
110296: LD_INT 700
110298: LESS
110299: PUSH
110300: LD_VAR 0 4
110304: PUSH
110305: LD_VAR 0 7
110309: ARRAY
110310: PUSH
110311: LD_VAR 0 32
110315: IN
110316: NOT
110317: AND
110318: IFFALSE 110342
// to_repair := to_repair union group [ i ] ;
110320: LD_ADDR_VAR 0 32
110324: PUSH
110325: LD_VAR 0 32
110329: PUSH
110330: LD_VAR 0 4
110334: PUSH
110335: LD_VAR 0 7
110339: ARRAY
110340: UNION
110341: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110342: LD_VAR 0 4
110346: PUSH
110347: LD_VAR 0 7
110351: ARRAY
110352: PPUSH
110353: CALL_OW 256
110357: PUSH
110358: LD_INT 1000
110360: EQUAL
110361: PUSH
110362: LD_VAR 0 4
110366: PUSH
110367: LD_VAR 0 7
110371: ARRAY
110372: PUSH
110373: LD_VAR 0 32
110377: IN
110378: AND
110379: IFFALSE 110403
// to_repair := to_repair diff group [ i ] ;
110381: LD_ADDR_VAR 0 32
110385: PUSH
110386: LD_VAR 0 32
110390: PUSH
110391: LD_VAR 0 4
110395: PUSH
110396: LD_VAR 0 7
110400: ARRAY
110401: DIFF
110402: ST_TO_ADDR
// if group [ i ] in to_repair then
110403: LD_VAR 0 4
110407: PUSH
110408: LD_VAR 0 7
110412: ARRAY
110413: PUSH
110414: LD_VAR 0 32
110418: IN
110419: IFFALSE 110466
// begin if not IsInArea ( group [ i ] , f_repair ) then
110421: LD_VAR 0 4
110425: PUSH
110426: LD_VAR 0 7
110430: ARRAY
110431: PPUSH
110432: LD_VAR 0 22
110436: PPUSH
110437: CALL_OW 308
110441: NOT
110442: IFFALSE 110464
// ComMoveToArea ( group [ i ] , f_repair ) ;
110444: LD_VAR 0 4
110448: PUSH
110449: LD_VAR 0 7
110453: ARRAY
110454: PPUSH
110455: LD_VAR 0 22
110459: PPUSH
110460: CALL_OW 113
// continue ;
110464: GO 110091
// end ; end else
110466: GO 110746
// if group [ i ] in repairs then
110468: LD_VAR 0 4
110472: PUSH
110473: LD_VAR 0 7
110477: ARRAY
110478: PUSH
110479: LD_VAR 0 33
110483: IN
110484: IFFALSE 110746
// begin if IsInUnit ( group [ i ] ) then
110486: LD_VAR 0 4
110490: PUSH
110491: LD_VAR 0 7
110495: ARRAY
110496: PPUSH
110497: CALL_OW 310
110501: IFFALSE 110569
// begin z := IsInUnit ( group [ i ] ) ;
110503: LD_ADDR_VAR 0 13
110507: PUSH
110508: LD_VAR 0 4
110512: PUSH
110513: LD_VAR 0 7
110517: ARRAY
110518: PPUSH
110519: CALL_OW 310
110523: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110524: LD_VAR 0 13
110528: PUSH
110529: LD_VAR 0 32
110533: IN
110534: PUSH
110535: LD_VAR 0 13
110539: PPUSH
110540: LD_VAR 0 22
110544: PPUSH
110545: CALL_OW 308
110549: AND
110550: IFFALSE 110567
// ComExitVehicle ( group [ i ] ) ;
110552: LD_VAR 0 4
110556: PUSH
110557: LD_VAR 0 7
110561: ARRAY
110562: PPUSH
110563: CALL_OW 121
// end else
110567: GO 110746
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110569: LD_ADDR_VAR 0 13
110573: PUSH
110574: LD_VAR 0 4
110578: PPUSH
110579: LD_INT 95
110581: PUSH
110582: LD_VAR 0 22
110586: PUSH
110587: EMPTY
110588: LIST
110589: LIST
110590: PUSH
110591: LD_INT 58
110593: PUSH
110594: EMPTY
110595: LIST
110596: PUSH
110597: EMPTY
110598: LIST
110599: LIST
110600: PPUSH
110601: CALL_OW 72
110605: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110606: LD_VAR 0 4
110610: PUSH
110611: LD_VAR 0 7
110615: ARRAY
110616: PPUSH
110617: CALL_OW 314
110621: NOT
110622: IFFALSE 110744
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110624: LD_ADDR_VAR 0 10
110628: PUSH
110629: LD_VAR 0 13
110633: PPUSH
110634: LD_VAR 0 4
110638: PUSH
110639: LD_VAR 0 7
110643: ARRAY
110644: PPUSH
110645: CALL_OW 74
110649: ST_TO_ADDR
// if not x then
110650: LD_VAR 0 10
110654: NOT
110655: IFFALSE 110659
// continue ;
110657: GO 110091
// if GetLives ( x ) < 1000 then
110659: LD_VAR 0 10
110663: PPUSH
110664: CALL_OW 256
110668: PUSH
110669: LD_INT 1000
110671: LESS
110672: IFFALSE 110696
// ComRepairVehicle ( group [ i ] , x ) else
110674: LD_VAR 0 4
110678: PUSH
110679: LD_VAR 0 7
110683: ARRAY
110684: PPUSH
110685: LD_VAR 0 10
110689: PPUSH
110690: CALL_OW 129
110694: GO 110744
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
110696: LD_VAR 0 23
110700: PUSH
110701: LD_VAR 0 4
110705: PUSH
110706: LD_VAR 0 7
110710: ARRAY
110711: PPUSH
110712: CALL_OW 256
110716: PUSH
110717: LD_INT 1000
110719: LESS
110720: AND
110721: NOT
110722: IFFALSE 110744
// ComEnterUnit ( group [ i ] , x ) ;
110724: LD_VAR 0 4
110728: PUSH
110729: LD_VAR 0 7
110733: ARRAY
110734: PPUSH
110735: LD_VAR 0 10
110739: PPUSH
110740: CALL_OW 120
// end ; continue ;
110744: GO 110091
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110746: LD_VAR 0 23
110750: PUSH
110751: LD_VAR 0 4
110755: PUSH
110756: LD_VAR 0 7
110760: ARRAY
110761: PPUSH
110762: CALL_OW 247
110766: PUSH
110767: LD_INT 1
110769: EQUAL
110770: AND
110771: IFFALSE 111249
// begin if group [ i ] in healers then
110773: LD_VAR 0 4
110777: PUSH
110778: LD_VAR 0 7
110782: ARRAY
110783: PUSH
110784: LD_VAR 0 31
110788: IN
110789: IFFALSE 111062
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110791: LD_VAR 0 4
110795: PUSH
110796: LD_VAR 0 7
110800: ARRAY
110801: PPUSH
110802: LD_VAR 0 23
110806: PPUSH
110807: CALL_OW 308
110811: NOT
110812: PUSH
110813: LD_VAR 0 4
110817: PUSH
110818: LD_VAR 0 7
110822: ARRAY
110823: PPUSH
110824: CALL_OW 314
110828: NOT
110829: AND
110830: IFFALSE 110854
// ComMoveToArea ( group [ i ] , f_heal ) else
110832: LD_VAR 0 4
110836: PUSH
110837: LD_VAR 0 7
110841: ARRAY
110842: PPUSH
110843: LD_VAR 0 23
110847: PPUSH
110848: CALL_OW 113
110852: GO 111060
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
110854: LD_VAR 0 4
110858: PUSH
110859: LD_VAR 0 7
110863: ARRAY
110864: PPUSH
110865: CALL 86092 0 1
110869: PPUSH
110870: CALL_OW 256
110874: PUSH
110875: LD_INT 1000
110877: EQUAL
110878: IFFALSE 110897
// ComStop ( group [ i ] ) else
110880: LD_VAR 0 4
110884: PUSH
110885: LD_VAR 0 7
110889: ARRAY
110890: PPUSH
110891: CALL_OW 141
110895: GO 111060
// if not HasTask ( group [ i ] ) and to_heal then
110897: LD_VAR 0 4
110901: PUSH
110902: LD_VAR 0 7
110906: ARRAY
110907: PPUSH
110908: CALL_OW 314
110912: NOT
110913: PUSH
110914: LD_VAR 0 30
110918: AND
110919: IFFALSE 111060
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
110921: LD_ADDR_VAR 0 13
110925: PUSH
110926: LD_VAR 0 30
110930: PPUSH
110931: LD_INT 3
110933: PUSH
110934: LD_INT 54
110936: PUSH
110937: EMPTY
110938: LIST
110939: PUSH
110940: EMPTY
110941: LIST
110942: LIST
110943: PPUSH
110944: CALL_OW 72
110948: PPUSH
110949: LD_VAR 0 4
110953: PUSH
110954: LD_VAR 0 7
110958: ARRAY
110959: PPUSH
110960: CALL_OW 74
110964: ST_TO_ADDR
// if z then
110965: LD_VAR 0 13
110969: IFFALSE 111060
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
110971: LD_INT 91
110973: PUSH
110974: LD_VAR 0 13
110978: PUSH
110979: LD_INT 10
110981: PUSH
110982: EMPTY
110983: LIST
110984: LIST
110985: LIST
110986: PUSH
110987: LD_INT 81
110989: PUSH
110990: LD_VAR 0 13
110994: PPUSH
110995: CALL_OW 255
110999: PUSH
111000: EMPTY
111001: LIST
111002: LIST
111003: PUSH
111004: EMPTY
111005: LIST
111006: LIST
111007: PPUSH
111008: CALL_OW 69
111012: PUSH
111013: LD_INT 0
111015: EQUAL
111016: IFFALSE 111040
// ComHeal ( group [ i ] , z ) else
111018: LD_VAR 0 4
111022: PUSH
111023: LD_VAR 0 7
111027: ARRAY
111028: PPUSH
111029: LD_VAR 0 13
111033: PPUSH
111034: CALL_OW 128
111038: GO 111060
// ComMoveToArea ( group [ i ] , f_heal ) ;
111040: LD_VAR 0 4
111044: PUSH
111045: LD_VAR 0 7
111049: ARRAY
111050: PPUSH
111051: LD_VAR 0 23
111055: PPUSH
111056: CALL_OW 113
// end ; continue ;
111060: GO 110091
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111062: LD_VAR 0 4
111066: PUSH
111067: LD_VAR 0 7
111071: ARRAY
111072: PPUSH
111073: CALL_OW 256
111077: PUSH
111078: LD_INT 700
111080: LESS
111081: PUSH
111082: LD_VAR 0 4
111086: PUSH
111087: LD_VAR 0 7
111091: ARRAY
111092: PUSH
111093: LD_VAR 0 30
111097: IN
111098: NOT
111099: AND
111100: IFFALSE 111124
// to_heal := to_heal union group [ i ] ;
111102: LD_ADDR_VAR 0 30
111106: PUSH
111107: LD_VAR 0 30
111111: PUSH
111112: LD_VAR 0 4
111116: PUSH
111117: LD_VAR 0 7
111121: ARRAY
111122: UNION
111123: ST_TO_ADDR
// if group [ i ] in to_heal then
111124: LD_VAR 0 4
111128: PUSH
111129: LD_VAR 0 7
111133: ARRAY
111134: PUSH
111135: LD_VAR 0 30
111139: IN
111140: IFFALSE 111249
// begin if GetLives ( group [ i ] ) = 1000 then
111142: LD_VAR 0 4
111146: PUSH
111147: LD_VAR 0 7
111151: ARRAY
111152: PPUSH
111153: CALL_OW 256
111157: PUSH
111158: LD_INT 1000
111160: EQUAL
111161: IFFALSE 111187
// to_heal := to_heal diff group [ i ] else
111163: LD_ADDR_VAR 0 30
111167: PUSH
111168: LD_VAR 0 30
111172: PUSH
111173: LD_VAR 0 4
111177: PUSH
111178: LD_VAR 0 7
111182: ARRAY
111183: DIFF
111184: ST_TO_ADDR
111185: GO 111249
// begin if not IsInArea ( group [ i ] , to_heal ) then
111187: LD_VAR 0 4
111191: PUSH
111192: LD_VAR 0 7
111196: ARRAY
111197: PPUSH
111198: LD_VAR 0 30
111202: PPUSH
111203: CALL_OW 308
111207: NOT
111208: IFFALSE 111232
// ComMoveToArea ( group [ i ] , f_heal ) else
111210: LD_VAR 0 4
111214: PUSH
111215: LD_VAR 0 7
111219: ARRAY
111220: PPUSH
111221: LD_VAR 0 23
111225: PPUSH
111226: CALL_OW 113
111230: GO 111247
// ComHold ( group [ i ] ) ;
111232: LD_VAR 0 4
111236: PUSH
111237: LD_VAR 0 7
111241: ARRAY
111242: PPUSH
111243: CALL_OW 140
// continue ;
111247: GO 110091
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111249: LD_VAR 0 4
111253: PUSH
111254: LD_VAR 0 7
111258: ARRAY
111259: PPUSH
111260: LD_INT 10
111262: PPUSH
111263: CALL 84512 0 2
111267: NOT
111268: PUSH
111269: LD_VAR 0 16
111273: PUSH
111274: LD_VAR 0 7
111278: ARRAY
111279: PUSH
111280: EMPTY
111281: EQUAL
111282: NOT
111283: AND
111284: IFFALSE 111550
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111286: LD_VAR 0 4
111290: PUSH
111291: LD_VAR 0 7
111295: ARRAY
111296: PPUSH
111297: CALL_OW 262
111301: PUSH
111302: LD_INT 1
111304: PUSH
111305: LD_INT 2
111307: PUSH
111308: EMPTY
111309: LIST
111310: LIST
111311: IN
111312: IFFALSE 111353
// if GetFuel ( group [ i ] ) < 10 then
111314: LD_VAR 0 4
111318: PUSH
111319: LD_VAR 0 7
111323: ARRAY
111324: PPUSH
111325: CALL_OW 261
111329: PUSH
111330: LD_INT 10
111332: LESS
111333: IFFALSE 111353
// SetFuel ( group [ i ] , 12 ) ;
111335: LD_VAR 0 4
111339: PUSH
111340: LD_VAR 0 7
111344: ARRAY
111345: PPUSH
111346: LD_INT 12
111348: PPUSH
111349: CALL_OW 240
// if units_path [ i ] then
111353: LD_VAR 0 16
111357: PUSH
111358: LD_VAR 0 7
111362: ARRAY
111363: IFFALSE 111548
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111365: LD_VAR 0 4
111369: PUSH
111370: LD_VAR 0 7
111374: ARRAY
111375: PPUSH
111376: LD_VAR 0 16
111380: PUSH
111381: LD_VAR 0 7
111385: ARRAY
111386: PUSH
111387: LD_INT 1
111389: ARRAY
111390: PUSH
111391: LD_INT 1
111393: ARRAY
111394: PPUSH
111395: LD_VAR 0 16
111399: PUSH
111400: LD_VAR 0 7
111404: ARRAY
111405: PUSH
111406: LD_INT 1
111408: ARRAY
111409: PUSH
111410: LD_INT 2
111412: ARRAY
111413: PPUSH
111414: CALL_OW 297
111418: PUSH
111419: LD_INT 6
111421: GREATER
111422: IFFALSE 111497
// begin if not HasTask ( group [ i ] ) then
111424: LD_VAR 0 4
111428: PUSH
111429: LD_VAR 0 7
111433: ARRAY
111434: PPUSH
111435: CALL_OW 314
111439: NOT
111440: IFFALSE 111495
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111442: LD_VAR 0 4
111446: PUSH
111447: LD_VAR 0 7
111451: ARRAY
111452: PPUSH
111453: LD_VAR 0 16
111457: PUSH
111458: LD_VAR 0 7
111462: ARRAY
111463: PUSH
111464: LD_INT 1
111466: ARRAY
111467: PUSH
111468: LD_INT 1
111470: ARRAY
111471: PPUSH
111472: LD_VAR 0 16
111476: PUSH
111477: LD_VAR 0 7
111481: ARRAY
111482: PUSH
111483: LD_INT 1
111485: ARRAY
111486: PUSH
111487: LD_INT 2
111489: ARRAY
111490: PPUSH
111491: CALL_OW 114
// end else
111495: GO 111548
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111497: LD_ADDR_VAR 0 15
111501: PUSH
111502: LD_VAR 0 16
111506: PUSH
111507: LD_VAR 0 7
111511: ARRAY
111512: PPUSH
111513: LD_INT 1
111515: PPUSH
111516: CALL_OW 3
111520: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111521: LD_ADDR_VAR 0 16
111525: PUSH
111526: LD_VAR 0 16
111530: PPUSH
111531: LD_VAR 0 7
111535: PPUSH
111536: LD_VAR 0 15
111540: PPUSH
111541: CALL_OW 1
111545: ST_TO_ADDR
// continue ;
111546: GO 110091
// end ; end ; end else
111548: GO 114212
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111550: LD_ADDR_VAR 0 14
111554: PUSH
111555: LD_INT 81
111557: PUSH
111558: LD_VAR 0 4
111562: PUSH
111563: LD_VAR 0 7
111567: ARRAY
111568: PPUSH
111569: CALL_OW 255
111573: PUSH
111574: EMPTY
111575: LIST
111576: LIST
111577: PPUSH
111578: CALL_OW 69
111582: ST_TO_ADDR
// if not tmp then
111583: LD_VAR 0 14
111587: NOT
111588: IFFALSE 111592
// continue ;
111590: GO 110091
// if f_ignore_area then
111592: LD_VAR 0 17
111596: IFFALSE 111684
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111598: LD_ADDR_VAR 0 15
111602: PUSH
111603: LD_VAR 0 14
111607: PPUSH
111608: LD_INT 3
111610: PUSH
111611: LD_INT 92
111613: PUSH
111614: LD_VAR 0 17
111618: PUSH
111619: LD_INT 1
111621: ARRAY
111622: PUSH
111623: LD_VAR 0 17
111627: PUSH
111628: LD_INT 2
111630: ARRAY
111631: PUSH
111632: LD_VAR 0 17
111636: PUSH
111637: LD_INT 3
111639: ARRAY
111640: PUSH
111641: EMPTY
111642: LIST
111643: LIST
111644: LIST
111645: LIST
111646: PUSH
111647: EMPTY
111648: LIST
111649: LIST
111650: PPUSH
111651: CALL_OW 72
111655: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111656: LD_VAR 0 14
111660: PUSH
111661: LD_VAR 0 15
111665: DIFF
111666: IFFALSE 111684
// tmp := tmp diff tmp2 ;
111668: LD_ADDR_VAR 0 14
111672: PUSH
111673: LD_VAR 0 14
111677: PUSH
111678: LD_VAR 0 15
111682: DIFF
111683: ST_TO_ADDR
// end ; if not f_murder then
111684: LD_VAR 0 20
111688: NOT
111689: IFFALSE 111747
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
111691: LD_ADDR_VAR 0 15
111695: PUSH
111696: LD_VAR 0 14
111700: PPUSH
111701: LD_INT 3
111703: PUSH
111704: LD_INT 50
111706: PUSH
111707: EMPTY
111708: LIST
111709: PUSH
111710: EMPTY
111711: LIST
111712: LIST
111713: PPUSH
111714: CALL_OW 72
111718: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111719: LD_VAR 0 14
111723: PUSH
111724: LD_VAR 0 15
111728: DIFF
111729: IFFALSE 111747
// tmp := tmp diff tmp2 ;
111731: LD_ADDR_VAR 0 14
111735: PUSH
111736: LD_VAR 0 14
111740: PUSH
111741: LD_VAR 0 15
111745: DIFF
111746: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111747: LD_ADDR_VAR 0 14
111751: PUSH
111752: LD_VAR 0 4
111756: PUSH
111757: LD_VAR 0 7
111761: ARRAY
111762: PPUSH
111763: LD_VAR 0 14
111767: PPUSH
111768: LD_INT 1
111770: PPUSH
111771: LD_INT 1
111773: PPUSH
111774: CALL 57447 0 4
111778: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111779: LD_VAR 0 4
111783: PUSH
111784: LD_VAR 0 7
111788: ARRAY
111789: PPUSH
111790: CALL_OW 257
111794: PUSH
111795: LD_INT 1
111797: EQUAL
111798: IFFALSE 112246
// begin if WantPlant ( group [ i ] ) then
111800: LD_VAR 0 4
111804: PUSH
111805: LD_VAR 0 7
111809: ARRAY
111810: PPUSH
111811: CALL 56948 0 1
111815: IFFALSE 111819
// continue ;
111817: GO 110091
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111819: LD_VAR 0 18
111823: PUSH
111824: LD_VAR 0 4
111828: PUSH
111829: LD_VAR 0 7
111833: ARRAY
111834: PPUSH
111835: CALL_OW 310
111839: NOT
111840: AND
111841: PUSH
111842: LD_VAR 0 14
111846: PUSH
111847: LD_INT 1
111849: ARRAY
111850: PUSH
111851: LD_VAR 0 14
111855: PPUSH
111856: LD_INT 21
111858: PUSH
111859: LD_INT 2
111861: PUSH
111862: EMPTY
111863: LIST
111864: LIST
111865: PUSH
111866: LD_INT 58
111868: PUSH
111869: EMPTY
111870: LIST
111871: PUSH
111872: EMPTY
111873: LIST
111874: LIST
111875: PPUSH
111876: CALL_OW 72
111880: IN
111881: AND
111882: IFFALSE 111918
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
111884: LD_VAR 0 4
111888: PUSH
111889: LD_VAR 0 7
111893: ARRAY
111894: PPUSH
111895: LD_VAR 0 14
111899: PUSH
111900: LD_INT 1
111902: ARRAY
111903: PPUSH
111904: CALL_OW 120
// attacking := true ;
111908: LD_ADDR_VAR 0 29
111912: PUSH
111913: LD_INT 1
111915: ST_TO_ADDR
// continue ;
111916: GO 110091
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
111918: LD_VAR 0 26
111922: PUSH
111923: LD_VAR 0 4
111927: PUSH
111928: LD_VAR 0 7
111932: ARRAY
111933: PPUSH
111934: CALL_OW 257
111938: PUSH
111939: LD_INT 1
111941: EQUAL
111942: AND
111943: PUSH
111944: LD_VAR 0 4
111948: PUSH
111949: LD_VAR 0 7
111953: ARRAY
111954: PPUSH
111955: CALL_OW 256
111959: PUSH
111960: LD_INT 800
111962: LESS
111963: AND
111964: PUSH
111965: LD_VAR 0 4
111969: PUSH
111970: LD_VAR 0 7
111974: ARRAY
111975: PPUSH
111976: CALL_OW 318
111980: NOT
111981: AND
111982: IFFALSE 111999
// ComCrawl ( group [ i ] ) ;
111984: LD_VAR 0 4
111988: PUSH
111989: LD_VAR 0 7
111993: ARRAY
111994: PPUSH
111995: CALL_OW 137
// if f_mines then
111999: LD_VAR 0 21
112003: IFFALSE 112246
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112005: LD_VAR 0 14
112009: PUSH
112010: LD_INT 1
112012: ARRAY
112013: PPUSH
112014: CALL_OW 247
112018: PUSH
112019: LD_INT 3
112021: EQUAL
112022: PUSH
112023: LD_VAR 0 14
112027: PUSH
112028: LD_INT 1
112030: ARRAY
112031: PUSH
112032: LD_VAR 0 27
112036: IN
112037: NOT
112038: AND
112039: IFFALSE 112246
// begin x := GetX ( tmp [ 1 ] ) ;
112041: LD_ADDR_VAR 0 10
112045: PUSH
112046: LD_VAR 0 14
112050: PUSH
112051: LD_INT 1
112053: ARRAY
112054: PPUSH
112055: CALL_OW 250
112059: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112060: LD_ADDR_VAR 0 11
112064: PUSH
112065: LD_VAR 0 14
112069: PUSH
112070: LD_INT 1
112072: ARRAY
112073: PPUSH
112074: CALL_OW 251
112078: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112079: LD_ADDR_VAR 0 12
112083: PUSH
112084: LD_VAR 0 4
112088: PUSH
112089: LD_VAR 0 7
112093: ARRAY
112094: PPUSH
112095: CALL 84597 0 1
112099: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112100: LD_VAR 0 4
112104: PUSH
112105: LD_VAR 0 7
112109: ARRAY
112110: PPUSH
112111: LD_VAR 0 10
112115: PPUSH
112116: LD_VAR 0 11
112120: PPUSH
112121: LD_VAR 0 14
112125: PUSH
112126: LD_INT 1
112128: ARRAY
112129: PPUSH
112130: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112134: LD_VAR 0 4
112138: PUSH
112139: LD_VAR 0 7
112143: ARRAY
112144: PPUSH
112145: LD_VAR 0 10
112149: PPUSH
112150: LD_VAR 0 12
112154: PPUSH
112155: LD_INT 7
112157: PPUSH
112158: CALL_OW 272
112162: PPUSH
112163: LD_VAR 0 11
112167: PPUSH
112168: LD_VAR 0 12
112172: PPUSH
112173: LD_INT 7
112175: PPUSH
112176: CALL_OW 273
112180: PPUSH
112181: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112185: LD_VAR 0 4
112189: PUSH
112190: LD_VAR 0 7
112194: ARRAY
112195: PPUSH
112196: LD_INT 71
112198: PPUSH
112199: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112203: LD_ADDR_VAR 0 27
112207: PUSH
112208: LD_VAR 0 27
112212: PPUSH
112213: LD_VAR 0 27
112217: PUSH
112218: LD_INT 1
112220: PLUS
112221: PPUSH
112222: LD_VAR 0 14
112226: PUSH
112227: LD_INT 1
112229: ARRAY
112230: PPUSH
112231: CALL_OW 1
112235: ST_TO_ADDR
// attacking := true ;
112236: LD_ADDR_VAR 0 29
112240: PUSH
112241: LD_INT 1
112243: ST_TO_ADDR
// continue ;
112244: GO 110091
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112246: LD_VAR 0 4
112250: PUSH
112251: LD_VAR 0 7
112255: ARRAY
112256: PPUSH
112257: CALL_OW 257
112261: PUSH
112262: LD_INT 17
112264: EQUAL
112265: PUSH
112266: LD_VAR 0 4
112270: PUSH
112271: LD_VAR 0 7
112275: ARRAY
112276: PPUSH
112277: CALL_OW 110
112281: PUSH
112282: LD_INT 71
112284: EQUAL
112285: NOT
112286: AND
112287: IFFALSE 112433
// begin attacking := false ;
112289: LD_ADDR_VAR 0 29
112293: PUSH
112294: LD_INT 0
112296: ST_TO_ADDR
// k := 5 ;
112297: LD_ADDR_VAR 0 9
112301: PUSH
112302: LD_INT 5
112304: ST_TO_ADDR
// if tmp < k then
112305: LD_VAR 0 14
112309: PUSH
112310: LD_VAR 0 9
112314: LESS
112315: IFFALSE 112327
// k := tmp ;
112317: LD_ADDR_VAR 0 9
112321: PUSH
112322: LD_VAR 0 14
112326: ST_TO_ADDR
// for j = 1 to k do
112327: LD_ADDR_VAR 0 8
112331: PUSH
112332: DOUBLE
112333: LD_INT 1
112335: DEC
112336: ST_TO_ADDR
112337: LD_VAR 0 9
112341: PUSH
112342: FOR_TO
112343: IFFALSE 112431
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112345: LD_VAR 0 14
112349: PUSH
112350: LD_VAR 0 8
112354: ARRAY
112355: PUSH
112356: LD_VAR 0 14
112360: PPUSH
112361: LD_INT 58
112363: PUSH
112364: EMPTY
112365: LIST
112366: PPUSH
112367: CALL_OW 72
112371: IN
112372: NOT
112373: IFFALSE 112429
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112375: LD_VAR 0 4
112379: PUSH
112380: LD_VAR 0 7
112384: ARRAY
112385: PPUSH
112386: LD_VAR 0 14
112390: PUSH
112391: LD_VAR 0 8
112395: ARRAY
112396: PPUSH
112397: CALL_OW 115
// attacking := true ;
112401: LD_ADDR_VAR 0 29
112405: PUSH
112406: LD_INT 1
112408: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112409: LD_VAR 0 4
112413: PUSH
112414: LD_VAR 0 7
112418: ARRAY
112419: PPUSH
112420: LD_INT 71
112422: PPUSH
112423: CALL_OW 109
// continue ;
112427: GO 112342
// end ; end ;
112429: GO 112342
112431: POP
112432: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112433: LD_VAR 0 4
112437: PUSH
112438: LD_VAR 0 7
112442: ARRAY
112443: PPUSH
112444: CALL_OW 257
112448: PUSH
112449: LD_INT 8
112451: EQUAL
112452: PUSH
112453: LD_VAR 0 4
112457: PUSH
112458: LD_VAR 0 7
112462: ARRAY
112463: PPUSH
112464: CALL_OW 264
112468: PUSH
112469: LD_INT 28
112471: PUSH
112472: LD_INT 45
112474: PUSH
112475: LD_INT 7
112477: PUSH
112478: LD_INT 47
112480: PUSH
112481: EMPTY
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: IN
112487: OR
112488: IFFALSE 112744
// begin attacking := false ;
112490: LD_ADDR_VAR 0 29
112494: PUSH
112495: LD_INT 0
112497: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112498: LD_VAR 0 14
112502: PUSH
112503: LD_INT 1
112505: ARRAY
112506: PPUSH
112507: CALL_OW 266
112511: PUSH
112512: LD_INT 32
112514: PUSH
112515: LD_INT 31
112517: PUSH
112518: LD_INT 33
112520: PUSH
112521: LD_INT 4
112523: PUSH
112524: LD_INT 5
112526: PUSH
112527: EMPTY
112528: LIST
112529: LIST
112530: LIST
112531: LIST
112532: LIST
112533: IN
112534: IFFALSE 112720
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112536: LD_ADDR_VAR 0 9
112540: PUSH
112541: LD_VAR 0 14
112545: PUSH
112546: LD_INT 1
112548: ARRAY
112549: PPUSH
112550: CALL_OW 266
112554: PPUSH
112555: LD_VAR 0 14
112559: PUSH
112560: LD_INT 1
112562: ARRAY
112563: PPUSH
112564: CALL_OW 250
112568: PPUSH
112569: LD_VAR 0 14
112573: PUSH
112574: LD_INT 1
112576: ARRAY
112577: PPUSH
112578: CALL_OW 251
112582: PPUSH
112583: LD_VAR 0 14
112587: PUSH
112588: LD_INT 1
112590: ARRAY
112591: PPUSH
112592: CALL_OW 254
112596: PPUSH
112597: LD_VAR 0 14
112601: PUSH
112602: LD_INT 1
112604: ARRAY
112605: PPUSH
112606: CALL_OW 248
112610: PPUSH
112611: LD_INT 0
112613: PPUSH
112614: CALL 65967 0 6
112618: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112619: LD_ADDR_VAR 0 8
112623: PUSH
112624: LD_VAR 0 4
112628: PUSH
112629: LD_VAR 0 7
112633: ARRAY
112634: PPUSH
112635: LD_VAR 0 9
112639: PPUSH
112640: CALL 84637 0 2
112644: ST_TO_ADDR
// if j then
112645: LD_VAR 0 8
112649: IFFALSE 112718
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
112651: LD_VAR 0 8
112655: PUSH
112656: LD_INT 1
112658: ARRAY
112659: PPUSH
112660: LD_VAR 0 8
112664: PUSH
112665: LD_INT 2
112667: ARRAY
112668: PPUSH
112669: CALL_OW 488
112673: IFFALSE 112718
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
112675: LD_VAR 0 4
112679: PUSH
112680: LD_VAR 0 7
112684: ARRAY
112685: PPUSH
112686: LD_VAR 0 8
112690: PUSH
112691: LD_INT 1
112693: ARRAY
112694: PPUSH
112695: LD_VAR 0 8
112699: PUSH
112700: LD_INT 2
112702: ARRAY
112703: PPUSH
112704: CALL_OW 116
// attacking := true ;
112708: LD_ADDR_VAR 0 29
112712: PUSH
112713: LD_INT 1
112715: ST_TO_ADDR
// continue ;
112716: GO 110091
// end ; end else
112718: GO 112744
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112720: LD_VAR 0 4
112724: PUSH
112725: LD_VAR 0 7
112729: ARRAY
112730: PPUSH
112731: LD_VAR 0 14
112735: PUSH
112736: LD_INT 1
112738: ARRAY
112739: PPUSH
112740: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112744: LD_VAR 0 4
112748: PUSH
112749: LD_VAR 0 7
112753: ARRAY
112754: PPUSH
112755: CALL_OW 265
112759: PUSH
112760: LD_INT 11
112762: EQUAL
112763: IFFALSE 113041
// begin k := 10 ;
112765: LD_ADDR_VAR 0 9
112769: PUSH
112770: LD_INT 10
112772: ST_TO_ADDR
// x := 0 ;
112773: LD_ADDR_VAR 0 10
112777: PUSH
112778: LD_INT 0
112780: ST_TO_ADDR
// if tmp < k then
112781: LD_VAR 0 14
112785: PUSH
112786: LD_VAR 0 9
112790: LESS
112791: IFFALSE 112803
// k := tmp ;
112793: LD_ADDR_VAR 0 9
112797: PUSH
112798: LD_VAR 0 14
112802: ST_TO_ADDR
// for j = k downto 1 do
112803: LD_ADDR_VAR 0 8
112807: PUSH
112808: DOUBLE
112809: LD_VAR 0 9
112813: INC
112814: ST_TO_ADDR
112815: LD_INT 1
112817: PUSH
112818: FOR_DOWNTO
112819: IFFALSE 112894
// begin if GetType ( tmp [ j ] ) = unit_human then
112821: LD_VAR 0 14
112825: PUSH
112826: LD_VAR 0 8
112830: ARRAY
112831: PPUSH
112832: CALL_OW 247
112836: PUSH
112837: LD_INT 1
112839: EQUAL
112840: IFFALSE 112892
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
112842: LD_VAR 0 4
112846: PUSH
112847: LD_VAR 0 7
112851: ARRAY
112852: PPUSH
112853: LD_VAR 0 14
112857: PUSH
112858: LD_VAR 0 8
112862: ARRAY
112863: PPUSH
112864: CALL 84908 0 2
// x := tmp [ j ] ;
112868: LD_ADDR_VAR 0 10
112872: PUSH
112873: LD_VAR 0 14
112877: PUSH
112878: LD_VAR 0 8
112882: ARRAY
112883: ST_TO_ADDR
// attacking := true ;
112884: LD_ADDR_VAR 0 29
112888: PUSH
112889: LD_INT 1
112891: ST_TO_ADDR
// end ; end ;
112892: GO 112818
112894: POP
112895: POP
// if not x then
112896: LD_VAR 0 10
112900: NOT
112901: IFFALSE 113041
// begin attacking := true ;
112903: LD_ADDR_VAR 0 29
112907: PUSH
112908: LD_INT 1
112910: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
112911: LD_VAR 0 4
112915: PUSH
112916: LD_VAR 0 7
112920: ARRAY
112921: PPUSH
112922: CALL_OW 250
112926: PPUSH
112927: LD_VAR 0 4
112931: PUSH
112932: LD_VAR 0 7
112936: ARRAY
112937: PPUSH
112938: CALL_OW 251
112942: PPUSH
112943: CALL_OW 546
112947: PUSH
112948: LD_INT 2
112950: ARRAY
112951: PUSH
112952: LD_VAR 0 14
112956: PUSH
112957: LD_INT 1
112959: ARRAY
112960: PPUSH
112961: CALL_OW 250
112965: PPUSH
112966: LD_VAR 0 14
112970: PUSH
112971: LD_INT 1
112973: ARRAY
112974: PPUSH
112975: CALL_OW 251
112979: PPUSH
112980: CALL_OW 546
112984: PUSH
112985: LD_INT 2
112987: ARRAY
112988: EQUAL
112989: IFFALSE 113017
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
112991: LD_VAR 0 4
112995: PUSH
112996: LD_VAR 0 7
113000: ARRAY
113001: PPUSH
113002: LD_VAR 0 14
113006: PUSH
113007: LD_INT 1
113009: ARRAY
113010: PPUSH
113011: CALL 84908 0 2
113015: GO 113041
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113017: LD_VAR 0 4
113021: PUSH
113022: LD_VAR 0 7
113026: ARRAY
113027: PPUSH
113028: LD_VAR 0 14
113032: PUSH
113033: LD_INT 1
113035: ARRAY
113036: PPUSH
113037: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113041: LD_VAR 0 4
113045: PUSH
113046: LD_VAR 0 7
113050: ARRAY
113051: PPUSH
113052: CALL_OW 264
113056: PUSH
113057: LD_INT 29
113059: EQUAL
113060: IFFALSE 113426
// begin if WantsToAttack ( group [ i ] ) in bombed then
113062: LD_VAR 0 4
113066: PUSH
113067: LD_VAR 0 7
113071: ARRAY
113072: PPUSH
113073: CALL_OW 319
113077: PUSH
113078: LD_VAR 0 28
113082: IN
113083: IFFALSE 113087
// continue ;
113085: GO 110091
// k := 8 ;
113087: LD_ADDR_VAR 0 9
113091: PUSH
113092: LD_INT 8
113094: ST_TO_ADDR
// x := 0 ;
113095: LD_ADDR_VAR 0 10
113099: PUSH
113100: LD_INT 0
113102: ST_TO_ADDR
// if tmp < k then
113103: LD_VAR 0 14
113107: PUSH
113108: LD_VAR 0 9
113112: LESS
113113: IFFALSE 113125
// k := tmp ;
113115: LD_ADDR_VAR 0 9
113119: PUSH
113120: LD_VAR 0 14
113124: ST_TO_ADDR
// for j = 1 to k do
113125: LD_ADDR_VAR 0 8
113129: PUSH
113130: DOUBLE
113131: LD_INT 1
113133: DEC
113134: ST_TO_ADDR
113135: LD_VAR 0 9
113139: PUSH
113140: FOR_TO
113141: IFFALSE 113273
// begin if GetType ( tmp [ j ] ) = unit_building then
113143: LD_VAR 0 14
113147: PUSH
113148: LD_VAR 0 8
113152: ARRAY
113153: PPUSH
113154: CALL_OW 247
113158: PUSH
113159: LD_INT 3
113161: EQUAL
113162: IFFALSE 113271
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113164: LD_VAR 0 14
113168: PUSH
113169: LD_VAR 0 8
113173: ARRAY
113174: PUSH
113175: LD_VAR 0 28
113179: IN
113180: NOT
113181: PUSH
113182: LD_VAR 0 14
113186: PUSH
113187: LD_VAR 0 8
113191: ARRAY
113192: PPUSH
113193: CALL_OW 313
113197: AND
113198: IFFALSE 113271
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113200: LD_VAR 0 4
113204: PUSH
113205: LD_VAR 0 7
113209: ARRAY
113210: PPUSH
113211: LD_VAR 0 14
113215: PUSH
113216: LD_VAR 0 8
113220: ARRAY
113221: PPUSH
113222: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113226: LD_ADDR_VAR 0 28
113230: PUSH
113231: LD_VAR 0 28
113235: PPUSH
113236: LD_VAR 0 28
113240: PUSH
113241: LD_INT 1
113243: PLUS
113244: PPUSH
113245: LD_VAR 0 14
113249: PUSH
113250: LD_VAR 0 8
113254: ARRAY
113255: PPUSH
113256: CALL_OW 1
113260: ST_TO_ADDR
// attacking := true ;
113261: LD_ADDR_VAR 0 29
113265: PUSH
113266: LD_INT 1
113268: ST_TO_ADDR
// break ;
113269: GO 113273
// end ; end ;
113271: GO 113140
113273: POP
113274: POP
// if not attacking and f_attack_depot then
113275: LD_VAR 0 29
113279: NOT
113280: PUSH
113281: LD_VAR 0 25
113285: AND
113286: IFFALSE 113381
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113288: LD_ADDR_VAR 0 13
113292: PUSH
113293: LD_VAR 0 14
113297: PPUSH
113298: LD_INT 2
113300: PUSH
113301: LD_INT 30
113303: PUSH
113304: LD_INT 0
113306: PUSH
113307: EMPTY
113308: LIST
113309: LIST
113310: PUSH
113311: LD_INT 30
113313: PUSH
113314: LD_INT 1
113316: PUSH
113317: EMPTY
113318: LIST
113319: LIST
113320: PUSH
113321: EMPTY
113322: LIST
113323: LIST
113324: LIST
113325: PPUSH
113326: CALL_OW 72
113330: ST_TO_ADDR
// if z then
113331: LD_VAR 0 13
113335: IFFALSE 113381
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113337: LD_VAR 0 4
113341: PUSH
113342: LD_VAR 0 7
113346: ARRAY
113347: PPUSH
113348: LD_VAR 0 13
113352: PPUSH
113353: LD_VAR 0 4
113357: PUSH
113358: LD_VAR 0 7
113362: ARRAY
113363: PPUSH
113364: CALL_OW 74
113368: PPUSH
113369: CALL_OW 115
// attacking := true ;
113373: LD_ADDR_VAR 0 29
113377: PUSH
113378: LD_INT 1
113380: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113381: LD_VAR 0 4
113385: PUSH
113386: LD_VAR 0 7
113390: ARRAY
113391: PPUSH
113392: CALL_OW 256
113396: PUSH
113397: LD_INT 500
113399: LESS
113400: IFFALSE 113426
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113402: LD_VAR 0 4
113406: PUSH
113407: LD_VAR 0 7
113411: ARRAY
113412: PPUSH
113413: LD_VAR 0 14
113417: PUSH
113418: LD_INT 1
113420: ARRAY
113421: PPUSH
113422: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113426: LD_VAR 0 4
113430: PUSH
113431: LD_VAR 0 7
113435: ARRAY
113436: PPUSH
113437: CALL_OW 264
113441: PUSH
113442: LD_INT 49
113444: EQUAL
113445: IFFALSE 113566
// begin if not HasTask ( group [ i ] ) then
113447: LD_VAR 0 4
113451: PUSH
113452: LD_VAR 0 7
113456: ARRAY
113457: PPUSH
113458: CALL_OW 314
113462: NOT
113463: IFFALSE 113566
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113465: LD_ADDR_VAR 0 9
113469: PUSH
113470: LD_INT 81
113472: PUSH
113473: LD_VAR 0 4
113477: PUSH
113478: LD_VAR 0 7
113482: ARRAY
113483: PPUSH
113484: CALL_OW 255
113488: PUSH
113489: EMPTY
113490: LIST
113491: LIST
113492: PPUSH
113493: CALL_OW 69
113497: PPUSH
113498: LD_VAR 0 4
113502: PUSH
113503: LD_VAR 0 7
113507: ARRAY
113508: PPUSH
113509: CALL_OW 74
113513: ST_TO_ADDR
// if k then
113514: LD_VAR 0 9
113518: IFFALSE 113566
// if GetDistUnits ( group [ i ] , k ) > 10 then
113520: LD_VAR 0 4
113524: PUSH
113525: LD_VAR 0 7
113529: ARRAY
113530: PPUSH
113531: LD_VAR 0 9
113535: PPUSH
113536: CALL_OW 296
113540: PUSH
113541: LD_INT 10
113543: GREATER
113544: IFFALSE 113566
// ComMoveUnit ( group [ i ] , k ) ;
113546: LD_VAR 0 4
113550: PUSH
113551: LD_VAR 0 7
113555: ARRAY
113556: PPUSH
113557: LD_VAR 0 9
113561: PPUSH
113562: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113566: LD_VAR 0 4
113570: PUSH
113571: LD_VAR 0 7
113575: ARRAY
113576: PPUSH
113577: CALL_OW 256
113581: PUSH
113582: LD_INT 250
113584: LESS
113585: PUSH
113586: LD_VAR 0 4
113590: PUSH
113591: LD_VAR 0 7
113595: ARRAY
113596: PUSH
113597: LD_INT 21
113599: PUSH
113600: LD_INT 2
113602: PUSH
113603: EMPTY
113604: LIST
113605: LIST
113606: PUSH
113607: LD_INT 23
113609: PUSH
113610: LD_INT 2
113612: PUSH
113613: EMPTY
113614: LIST
113615: LIST
113616: PUSH
113617: EMPTY
113618: LIST
113619: LIST
113620: PPUSH
113621: CALL_OW 69
113625: IN
113626: AND
113627: IFFALSE 113752
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113629: LD_ADDR_VAR 0 9
113633: PUSH
113634: LD_OWVAR 3
113638: PUSH
113639: LD_VAR 0 4
113643: PUSH
113644: LD_VAR 0 7
113648: ARRAY
113649: DIFF
113650: PPUSH
113651: LD_VAR 0 4
113655: PUSH
113656: LD_VAR 0 7
113660: ARRAY
113661: PPUSH
113662: CALL_OW 74
113666: ST_TO_ADDR
// if not k then
113667: LD_VAR 0 9
113671: NOT
113672: IFFALSE 113676
// continue ;
113674: GO 110091
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
113676: LD_VAR 0 9
113680: PUSH
113681: LD_INT 81
113683: PUSH
113684: LD_VAR 0 4
113688: PUSH
113689: LD_VAR 0 7
113693: ARRAY
113694: PPUSH
113695: CALL_OW 255
113699: PUSH
113700: EMPTY
113701: LIST
113702: LIST
113703: PPUSH
113704: CALL_OW 69
113708: IN
113709: PUSH
113710: LD_VAR 0 9
113714: PPUSH
113715: LD_VAR 0 4
113719: PUSH
113720: LD_VAR 0 7
113724: ARRAY
113725: PPUSH
113726: CALL_OW 296
113730: PUSH
113731: LD_INT 5
113733: LESS
113734: AND
113735: IFFALSE 113752
// ComAutodestruct ( group [ i ] ) ;
113737: LD_VAR 0 4
113741: PUSH
113742: LD_VAR 0 7
113746: ARRAY
113747: PPUSH
113748: CALL 84806 0 1
// end ; if f_attack_depot then
113752: LD_VAR 0 25
113756: IFFALSE 113868
// begin k := 6 ;
113758: LD_ADDR_VAR 0 9
113762: PUSH
113763: LD_INT 6
113765: ST_TO_ADDR
// if tmp < k then
113766: LD_VAR 0 14
113770: PUSH
113771: LD_VAR 0 9
113775: LESS
113776: IFFALSE 113788
// k := tmp ;
113778: LD_ADDR_VAR 0 9
113782: PUSH
113783: LD_VAR 0 14
113787: ST_TO_ADDR
// for j = 1 to k do
113788: LD_ADDR_VAR 0 8
113792: PUSH
113793: DOUBLE
113794: LD_INT 1
113796: DEC
113797: ST_TO_ADDR
113798: LD_VAR 0 9
113802: PUSH
113803: FOR_TO
113804: IFFALSE 113866
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113806: LD_VAR 0 8
113810: PPUSH
113811: CALL_OW 266
113815: PUSH
113816: LD_INT 0
113818: PUSH
113819: LD_INT 1
113821: PUSH
113822: EMPTY
113823: LIST
113824: LIST
113825: IN
113826: IFFALSE 113864
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113828: LD_VAR 0 4
113832: PUSH
113833: LD_VAR 0 7
113837: ARRAY
113838: PPUSH
113839: LD_VAR 0 14
113843: PUSH
113844: LD_VAR 0 8
113848: ARRAY
113849: PPUSH
113850: CALL_OW 115
// attacking := true ;
113854: LD_ADDR_VAR 0 29
113858: PUSH
113859: LD_INT 1
113861: ST_TO_ADDR
// break ;
113862: GO 113866
// end ;
113864: GO 113803
113866: POP
113867: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
113868: LD_VAR 0 4
113872: PUSH
113873: LD_VAR 0 7
113877: ARRAY
113878: PPUSH
113879: CALL_OW 302
113883: PUSH
113884: LD_VAR 0 29
113888: NOT
113889: AND
113890: IFFALSE 114212
// begin if GetTag ( group [ i ] ) = 71 then
113892: LD_VAR 0 4
113896: PUSH
113897: LD_VAR 0 7
113901: ARRAY
113902: PPUSH
113903: CALL_OW 110
113907: PUSH
113908: LD_INT 71
113910: EQUAL
113911: IFFALSE 113952
// begin if HasTask ( group [ i ] ) then
113913: LD_VAR 0 4
113917: PUSH
113918: LD_VAR 0 7
113922: ARRAY
113923: PPUSH
113924: CALL_OW 314
113928: IFFALSE 113934
// continue else
113930: GO 110091
113932: GO 113952
// SetTag ( group [ i ] , 0 ) ;
113934: LD_VAR 0 4
113938: PUSH
113939: LD_VAR 0 7
113943: ARRAY
113944: PPUSH
113945: LD_INT 0
113947: PPUSH
113948: CALL_OW 109
// end ; k := 8 ;
113952: LD_ADDR_VAR 0 9
113956: PUSH
113957: LD_INT 8
113959: ST_TO_ADDR
// x := 0 ;
113960: LD_ADDR_VAR 0 10
113964: PUSH
113965: LD_INT 0
113967: ST_TO_ADDR
// if tmp < k then
113968: LD_VAR 0 14
113972: PUSH
113973: LD_VAR 0 9
113977: LESS
113978: IFFALSE 113990
// k := tmp ;
113980: LD_ADDR_VAR 0 9
113984: PUSH
113985: LD_VAR 0 14
113989: ST_TO_ADDR
// for j = 1 to k do
113990: LD_ADDR_VAR 0 8
113994: PUSH
113995: DOUBLE
113996: LD_INT 1
113998: DEC
113999: ST_TO_ADDR
114000: LD_VAR 0 9
114004: PUSH
114005: FOR_TO
114006: IFFALSE 114104
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114008: LD_VAR 0 14
114012: PUSH
114013: LD_VAR 0 8
114017: ARRAY
114018: PPUSH
114019: CALL_OW 247
114023: PUSH
114024: LD_INT 1
114026: EQUAL
114027: PUSH
114028: LD_VAR 0 14
114032: PUSH
114033: LD_VAR 0 8
114037: ARRAY
114038: PPUSH
114039: CALL_OW 256
114043: PUSH
114044: LD_INT 250
114046: LESS
114047: PUSH
114048: LD_VAR 0 20
114052: AND
114053: PUSH
114054: LD_VAR 0 20
114058: NOT
114059: PUSH
114060: LD_VAR 0 14
114064: PUSH
114065: LD_VAR 0 8
114069: ARRAY
114070: PPUSH
114071: CALL_OW 256
114075: PUSH
114076: LD_INT 250
114078: GREATEREQUAL
114079: AND
114080: OR
114081: AND
114082: IFFALSE 114102
// begin x := tmp [ j ] ;
114084: LD_ADDR_VAR 0 10
114088: PUSH
114089: LD_VAR 0 14
114093: PUSH
114094: LD_VAR 0 8
114098: ARRAY
114099: ST_TO_ADDR
// break ;
114100: GO 114104
// end ;
114102: GO 114005
114104: POP
114105: POP
// if x then
114106: LD_VAR 0 10
114110: IFFALSE 114134
// ComAttackUnit ( group [ i ] , x ) else
114112: LD_VAR 0 4
114116: PUSH
114117: LD_VAR 0 7
114121: ARRAY
114122: PPUSH
114123: LD_VAR 0 10
114127: PPUSH
114128: CALL_OW 115
114132: GO 114158
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114134: LD_VAR 0 4
114138: PUSH
114139: LD_VAR 0 7
114143: ARRAY
114144: PPUSH
114145: LD_VAR 0 14
114149: PUSH
114150: LD_INT 1
114152: ARRAY
114153: PPUSH
114154: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114158: LD_VAR 0 4
114162: PUSH
114163: LD_VAR 0 7
114167: ARRAY
114168: PPUSH
114169: CALL_OW 314
114173: NOT
114174: IFFALSE 114212
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114176: LD_VAR 0 4
114180: PUSH
114181: LD_VAR 0 7
114185: ARRAY
114186: PPUSH
114187: LD_VAR 0 14
114191: PPUSH
114192: LD_VAR 0 4
114196: PUSH
114197: LD_VAR 0 7
114201: ARRAY
114202: PPUSH
114203: CALL_OW 74
114207: PPUSH
114208: CALL_OW 115
// end ; end ; end ;
114212: GO 110091
114214: POP
114215: POP
// wait ( 0 0$2 ) ;
114216: LD_INT 70
114218: PPUSH
114219: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114223: LD_VAR 0 4
114227: NOT
114228: PUSH
114229: LD_VAR 0 4
114233: PUSH
114234: EMPTY
114235: EQUAL
114236: OR
114237: PUSH
114238: LD_INT 81
114240: PUSH
114241: LD_VAR 0 35
114245: PUSH
114246: EMPTY
114247: LIST
114248: LIST
114249: PPUSH
114250: CALL_OW 69
114254: NOT
114255: OR
114256: IFFALSE 110076
// end ;
114258: LD_VAR 0 2
114262: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114263: LD_INT 0
114265: PPUSH
114266: PPUSH
114267: PPUSH
114268: PPUSH
114269: PPUSH
114270: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114271: LD_VAR 0 1
114275: NOT
114276: PUSH
114277: LD_EXP 95
114281: PUSH
114282: LD_VAR 0 1
114286: ARRAY
114287: NOT
114288: OR
114289: PUSH
114290: LD_VAR 0 2
114294: NOT
114295: OR
114296: IFFALSE 114300
// exit ;
114298: GO 114854
// side := mc_sides [ base ] ;
114300: LD_ADDR_VAR 0 6
114304: PUSH
114305: LD_EXP 121
114309: PUSH
114310: LD_VAR 0 1
114314: ARRAY
114315: ST_TO_ADDR
// if not side then
114316: LD_VAR 0 6
114320: NOT
114321: IFFALSE 114325
// exit ;
114323: GO 114854
// for i in solds do
114325: LD_ADDR_VAR 0 7
114329: PUSH
114330: LD_VAR 0 2
114334: PUSH
114335: FOR_IN
114336: IFFALSE 114397
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114338: LD_VAR 0 7
114342: PPUSH
114343: CALL_OW 310
114347: PPUSH
114348: CALL_OW 266
114352: PUSH
114353: LD_INT 32
114355: PUSH
114356: LD_INT 31
114358: PUSH
114359: EMPTY
114360: LIST
114361: LIST
114362: IN
114363: IFFALSE 114383
// solds := solds diff i else
114365: LD_ADDR_VAR 0 2
114369: PUSH
114370: LD_VAR 0 2
114374: PUSH
114375: LD_VAR 0 7
114379: DIFF
114380: ST_TO_ADDR
114381: GO 114395
// SetTag ( i , 18 ) ;
114383: LD_VAR 0 7
114387: PPUSH
114388: LD_INT 18
114390: PPUSH
114391: CALL_OW 109
114395: GO 114335
114397: POP
114398: POP
// if not solds then
114399: LD_VAR 0 2
114403: NOT
114404: IFFALSE 114408
// exit ;
114406: GO 114854
// repeat wait ( 0 0$2 ) ;
114408: LD_INT 70
114410: PPUSH
114411: CALL_OW 67
// enemy := mc_scan [ base ] ;
114415: LD_ADDR_VAR 0 4
114419: PUSH
114420: LD_EXP 118
114424: PUSH
114425: LD_VAR 0 1
114429: ARRAY
114430: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114431: LD_EXP 95
114435: PUSH
114436: LD_VAR 0 1
114440: ARRAY
114441: NOT
114442: PUSH
114443: LD_EXP 95
114447: PUSH
114448: LD_VAR 0 1
114452: ARRAY
114453: PUSH
114454: EMPTY
114455: EQUAL
114456: OR
114457: IFFALSE 114494
// begin for i in solds do
114459: LD_ADDR_VAR 0 7
114463: PUSH
114464: LD_VAR 0 2
114468: PUSH
114469: FOR_IN
114470: IFFALSE 114483
// ComStop ( i ) ;
114472: LD_VAR 0 7
114476: PPUSH
114477: CALL_OW 141
114481: GO 114469
114483: POP
114484: POP
// solds := [ ] ;
114485: LD_ADDR_VAR 0 2
114489: PUSH
114490: EMPTY
114491: ST_TO_ADDR
// exit ;
114492: GO 114854
// end ; for i in solds do
114494: LD_ADDR_VAR 0 7
114498: PUSH
114499: LD_VAR 0 2
114503: PUSH
114504: FOR_IN
114505: IFFALSE 114826
// begin if IsInUnit ( i ) then
114507: LD_VAR 0 7
114511: PPUSH
114512: CALL_OW 310
114516: IFFALSE 114527
// ComExitBuilding ( i ) ;
114518: LD_VAR 0 7
114522: PPUSH
114523: CALL_OW 122
// if GetLives ( i ) > 500 then
114527: LD_VAR 0 7
114531: PPUSH
114532: CALL_OW 256
114536: PUSH
114537: LD_INT 500
114539: GREATER
114540: IFFALSE 114593
// begin e := NearestUnitToUnit ( enemy , i ) ;
114542: LD_ADDR_VAR 0 5
114546: PUSH
114547: LD_VAR 0 4
114551: PPUSH
114552: LD_VAR 0 7
114556: PPUSH
114557: CALL_OW 74
114561: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114562: LD_VAR 0 7
114566: PPUSH
114567: LD_VAR 0 5
114571: PPUSH
114572: CALL_OW 250
114576: PPUSH
114577: LD_VAR 0 5
114581: PPUSH
114582: CALL_OW 251
114586: PPUSH
114587: CALL_OW 114
// end else
114591: GO 114824
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114593: LD_VAR 0 7
114597: PPUSH
114598: LD_EXP 95
114602: PUSH
114603: LD_VAR 0 1
114607: ARRAY
114608: PPUSH
114609: LD_INT 2
114611: PUSH
114612: LD_INT 30
114614: PUSH
114615: LD_INT 0
114617: PUSH
114618: EMPTY
114619: LIST
114620: LIST
114621: PUSH
114622: LD_INT 30
114624: PUSH
114625: LD_INT 1
114627: PUSH
114628: EMPTY
114629: LIST
114630: LIST
114631: PUSH
114632: LD_INT 30
114634: PUSH
114635: LD_INT 6
114637: PUSH
114638: EMPTY
114639: LIST
114640: LIST
114641: PUSH
114642: EMPTY
114643: LIST
114644: LIST
114645: LIST
114646: LIST
114647: PPUSH
114648: CALL_OW 72
114652: PPUSH
114653: LD_VAR 0 7
114657: PPUSH
114658: CALL_OW 74
114662: PPUSH
114663: CALL_OW 296
114667: PUSH
114668: LD_INT 10
114670: GREATER
114671: IFFALSE 114824
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
114673: LD_ADDR_VAR 0 8
114677: PUSH
114678: LD_EXP 95
114682: PUSH
114683: LD_VAR 0 1
114687: ARRAY
114688: PPUSH
114689: LD_INT 2
114691: PUSH
114692: LD_INT 30
114694: PUSH
114695: LD_INT 0
114697: PUSH
114698: EMPTY
114699: LIST
114700: LIST
114701: PUSH
114702: LD_INT 30
114704: PUSH
114705: LD_INT 1
114707: PUSH
114708: EMPTY
114709: LIST
114710: LIST
114711: PUSH
114712: LD_INT 30
114714: PUSH
114715: LD_INT 6
114717: PUSH
114718: EMPTY
114719: LIST
114720: LIST
114721: PUSH
114722: EMPTY
114723: LIST
114724: LIST
114725: LIST
114726: LIST
114727: PPUSH
114728: CALL_OW 72
114732: PPUSH
114733: LD_VAR 0 7
114737: PPUSH
114738: CALL_OW 74
114742: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114743: LD_VAR 0 7
114747: PPUSH
114748: LD_VAR 0 8
114752: PPUSH
114753: CALL_OW 250
114757: PPUSH
114758: LD_INT 3
114760: PPUSH
114761: LD_INT 5
114763: PPUSH
114764: CALL_OW 272
114768: PPUSH
114769: LD_VAR 0 8
114773: PPUSH
114774: CALL_OW 251
114778: PPUSH
114779: LD_INT 3
114781: PPUSH
114782: LD_INT 5
114784: PPUSH
114785: CALL_OW 273
114789: PPUSH
114790: CALL_OW 111
// SetTag ( i , 0 ) ;
114794: LD_VAR 0 7
114798: PPUSH
114799: LD_INT 0
114801: PPUSH
114802: CALL_OW 109
// solds := solds diff i ;
114806: LD_ADDR_VAR 0 2
114810: PUSH
114811: LD_VAR 0 2
114815: PUSH
114816: LD_VAR 0 7
114820: DIFF
114821: ST_TO_ADDR
// continue ;
114822: GO 114504
// end ; end ;
114824: GO 114504
114826: POP
114827: POP
// until not solds or not enemy ;
114828: LD_VAR 0 2
114832: NOT
114833: PUSH
114834: LD_VAR 0 4
114838: NOT
114839: OR
114840: IFFALSE 114408
// MC_Reset ( base , 18 ) ;
114842: LD_VAR 0 1
114846: PPUSH
114847: LD_INT 18
114849: PPUSH
114850: CALL 25554 0 2
// end ;
114854: LD_VAR 0 3
114858: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
114859: LD_INT 0
114861: PPUSH
114862: PPUSH
114863: PPUSH
114864: PPUSH
114865: PPUSH
114866: PPUSH
114867: PPUSH
114868: PPUSH
114869: PPUSH
114870: PPUSH
114871: PPUSH
114872: PPUSH
114873: PPUSH
114874: PPUSH
114875: PPUSH
114876: PPUSH
114877: PPUSH
114878: PPUSH
114879: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
114880: LD_ADDR_VAR 0 12
114884: PUSH
114885: LD_EXP 95
114889: PUSH
114890: LD_VAR 0 1
114894: ARRAY
114895: PPUSH
114896: LD_INT 25
114898: PUSH
114899: LD_INT 3
114901: PUSH
114902: EMPTY
114903: LIST
114904: LIST
114905: PPUSH
114906: CALL_OW 72
114910: ST_TO_ADDR
// if mc_remote_driver [ base ] then
114911: LD_EXP 135
114915: PUSH
114916: LD_VAR 0 1
114920: ARRAY
114921: IFFALSE 114945
// mechs := mechs diff mc_remote_driver [ base ] ;
114923: LD_ADDR_VAR 0 12
114927: PUSH
114928: LD_VAR 0 12
114932: PUSH
114933: LD_EXP 135
114937: PUSH
114938: LD_VAR 0 1
114942: ARRAY
114943: DIFF
114944: ST_TO_ADDR
// for i in mechs do
114945: LD_ADDR_VAR 0 4
114949: PUSH
114950: LD_VAR 0 12
114954: PUSH
114955: FOR_IN
114956: IFFALSE 114991
// if GetTag ( i ) > 0 then
114958: LD_VAR 0 4
114962: PPUSH
114963: CALL_OW 110
114967: PUSH
114968: LD_INT 0
114970: GREATER
114971: IFFALSE 114989
// mechs := mechs diff i ;
114973: LD_ADDR_VAR 0 12
114977: PUSH
114978: LD_VAR 0 12
114982: PUSH
114983: LD_VAR 0 4
114987: DIFF
114988: ST_TO_ADDR
114989: GO 114955
114991: POP
114992: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114993: LD_ADDR_VAR 0 8
114997: PUSH
114998: LD_EXP 95
115002: PUSH
115003: LD_VAR 0 1
115007: ARRAY
115008: PPUSH
115009: LD_INT 2
115011: PUSH
115012: LD_INT 25
115014: PUSH
115015: LD_INT 1
115017: PUSH
115018: EMPTY
115019: LIST
115020: LIST
115021: PUSH
115022: LD_INT 25
115024: PUSH
115025: LD_INT 5
115027: PUSH
115028: EMPTY
115029: LIST
115030: LIST
115031: PUSH
115032: LD_INT 25
115034: PUSH
115035: LD_INT 8
115037: PUSH
115038: EMPTY
115039: LIST
115040: LIST
115041: PUSH
115042: LD_INT 25
115044: PUSH
115045: LD_INT 9
115047: PUSH
115048: EMPTY
115049: LIST
115050: LIST
115051: PUSH
115052: EMPTY
115053: LIST
115054: LIST
115055: LIST
115056: LIST
115057: LIST
115058: PPUSH
115059: CALL_OW 72
115063: ST_TO_ADDR
// if not defenders and not solds then
115064: LD_VAR 0 2
115068: NOT
115069: PUSH
115070: LD_VAR 0 8
115074: NOT
115075: AND
115076: IFFALSE 115080
// exit ;
115078: GO 116850
// depot_under_attack := false ;
115080: LD_ADDR_VAR 0 16
115084: PUSH
115085: LD_INT 0
115087: ST_TO_ADDR
// sold_defenders := [ ] ;
115088: LD_ADDR_VAR 0 17
115092: PUSH
115093: EMPTY
115094: ST_TO_ADDR
// if mechs then
115095: LD_VAR 0 12
115099: IFFALSE 115252
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115101: LD_ADDR_VAR 0 4
115105: PUSH
115106: LD_VAR 0 2
115110: PPUSH
115111: LD_INT 21
115113: PUSH
115114: LD_INT 2
115116: PUSH
115117: EMPTY
115118: LIST
115119: LIST
115120: PPUSH
115121: CALL_OW 72
115125: PUSH
115126: FOR_IN
115127: IFFALSE 115250
// begin if GetTag ( i ) <> 20 then
115129: LD_VAR 0 4
115133: PPUSH
115134: CALL_OW 110
115138: PUSH
115139: LD_INT 20
115141: NONEQUAL
115142: IFFALSE 115156
// SetTag ( i , 20 ) ;
115144: LD_VAR 0 4
115148: PPUSH
115149: LD_INT 20
115151: PPUSH
115152: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115156: LD_VAR 0 4
115160: PPUSH
115161: CALL_OW 263
115165: PUSH
115166: LD_INT 1
115168: EQUAL
115169: PUSH
115170: LD_VAR 0 4
115174: PPUSH
115175: CALL_OW 311
115179: NOT
115180: AND
115181: IFFALSE 115248
// begin un := mechs [ 1 ] ;
115183: LD_ADDR_VAR 0 10
115187: PUSH
115188: LD_VAR 0 12
115192: PUSH
115193: LD_INT 1
115195: ARRAY
115196: ST_TO_ADDR
// ComExit ( un ) ;
115197: LD_VAR 0 10
115201: PPUSH
115202: CALL 89151 0 1
// AddComEnterUnit ( un , i ) ;
115206: LD_VAR 0 10
115210: PPUSH
115211: LD_VAR 0 4
115215: PPUSH
115216: CALL_OW 180
// SetTag ( un , 19 ) ;
115220: LD_VAR 0 10
115224: PPUSH
115225: LD_INT 19
115227: PPUSH
115228: CALL_OW 109
// mechs := mechs diff un ;
115232: LD_ADDR_VAR 0 12
115236: PUSH
115237: LD_VAR 0 12
115241: PUSH
115242: LD_VAR 0 10
115246: DIFF
115247: ST_TO_ADDR
// end ; end ;
115248: GO 115126
115250: POP
115251: POP
// if solds then
115252: LD_VAR 0 8
115256: IFFALSE 115315
// for i in solds do
115258: LD_ADDR_VAR 0 4
115262: PUSH
115263: LD_VAR 0 8
115267: PUSH
115268: FOR_IN
115269: IFFALSE 115313
// if not GetTag ( i ) then
115271: LD_VAR 0 4
115275: PPUSH
115276: CALL_OW 110
115280: NOT
115281: IFFALSE 115311
// begin defenders := defenders union i ;
115283: LD_ADDR_VAR 0 2
115287: PUSH
115288: LD_VAR 0 2
115292: PUSH
115293: LD_VAR 0 4
115297: UNION
115298: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115299: LD_VAR 0 4
115303: PPUSH
115304: LD_INT 18
115306: PPUSH
115307: CALL_OW 109
// end ;
115311: GO 115268
115313: POP
115314: POP
// repeat wait ( 0 0$2 ) ;
115315: LD_INT 70
115317: PPUSH
115318: CALL_OW 67
// enemy := mc_scan [ base ] ;
115322: LD_ADDR_VAR 0 21
115326: PUSH
115327: LD_EXP 118
115331: PUSH
115332: LD_VAR 0 1
115336: ARRAY
115337: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115338: LD_EXP 95
115342: PUSH
115343: LD_VAR 0 1
115347: ARRAY
115348: NOT
115349: PUSH
115350: LD_EXP 95
115354: PUSH
115355: LD_VAR 0 1
115359: ARRAY
115360: PUSH
115361: EMPTY
115362: EQUAL
115363: OR
115364: IFFALSE 115401
// begin for i in defenders do
115366: LD_ADDR_VAR 0 4
115370: PUSH
115371: LD_VAR 0 2
115375: PUSH
115376: FOR_IN
115377: IFFALSE 115390
// ComStop ( i ) ;
115379: LD_VAR 0 4
115383: PPUSH
115384: CALL_OW 141
115388: GO 115376
115390: POP
115391: POP
// defenders := [ ] ;
115392: LD_ADDR_VAR 0 2
115396: PUSH
115397: EMPTY
115398: ST_TO_ADDR
// exit ;
115399: GO 116850
// end ; for i in defenders do
115401: LD_ADDR_VAR 0 4
115405: PUSH
115406: LD_VAR 0 2
115410: PUSH
115411: FOR_IN
115412: IFFALSE 116310
// begin e := NearestUnitToUnit ( enemy , i ) ;
115414: LD_ADDR_VAR 0 13
115418: PUSH
115419: LD_VAR 0 21
115423: PPUSH
115424: LD_VAR 0 4
115428: PPUSH
115429: CALL_OW 74
115433: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115434: LD_ADDR_VAR 0 7
115438: PUSH
115439: LD_EXP 95
115443: PUSH
115444: LD_VAR 0 1
115448: ARRAY
115449: PPUSH
115450: LD_INT 2
115452: PUSH
115453: LD_INT 30
115455: PUSH
115456: LD_INT 0
115458: PUSH
115459: EMPTY
115460: LIST
115461: LIST
115462: PUSH
115463: LD_INT 30
115465: PUSH
115466: LD_INT 1
115468: PUSH
115469: EMPTY
115470: LIST
115471: LIST
115472: PUSH
115473: EMPTY
115474: LIST
115475: LIST
115476: LIST
115477: PPUSH
115478: CALL_OW 72
115482: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115483: LD_ADDR_VAR 0 16
115487: PUSH
115488: LD_VAR 0 7
115492: NOT
115493: PUSH
115494: LD_VAR 0 7
115498: PPUSH
115499: LD_INT 3
115501: PUSH
115502: LD_INT 24
115504: PUSH
115505: LD_INT 600
115507: PUSH
115508: EMPTY
115509: LIST
115510: LIST
115511: PUSH
115512: EMPTY
115513: LIST
115514: LIST
115515: PPUSH
115516: CALL_OW 72
115520: OR
115521: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115522: LD_VAR 0 4
115526: PPUSH
115527: CALL_OW 247
115531: PUSH
115532: LD_INT 2
115534: DOUBLE
115535: EQUAL
115536: IFTRUE 115540
115538: GO 115936
115540: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115541: LD_VAR 0 4
115545: PPUSH
115546: CALL_OW 256
115550: PUSH
115551: LD_INT 1000
115553: EQUAL
115554: PUSH
115555: LD_VAR 0 4
115559: PPUSH
115560: LD_VAR 0 13
115564: PPUSH
115565: CALL_OW 296
115569: PUSH
115570: LD_INT 40
115572: LESS
115573: PUSH
115574: LD_VAR 0 13
115578: PPUSH
115579: LD_EXP 120
115583: PUSH
115584: LD_VAR 0 1
115588: ARRAY
115589: PPUSH
115590: CALL_OW 308
115594: OR
115595: AND
115596: IFFALSE 115718
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115598: LD_VAR 0 4
115602: PPUSH
115603: CALL_OW 262
115607: PUSH
115608: LD_INT 1
115610: EQUAL
115611: PUSH
115612: LD_VAR 0 4
115616: PPUSH
115617: CALL_OW 261
115621: PUSH
115622: LD_INT 30
115624: LESS
115625: AND
115626: PUSH
115627: LD_VAR 0 7
115631: AND
115632: IFFALSE 115702
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115634: LD_VAR 0 4
115638: PPUSH
115639: LD_VAR 0 7
115643: PPUSH
115644: LD_VAR 0 4
115648: PPUSH
115649: CALL_OW 74
115653: PPUSH
115654: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
115658: LD_VAR 0 4
115662: PPUSH
115663: LD_VAR 0 7
115667: PPUSH
115668: LD_VAR 0 4
115672: PPUSH
115673: CALL_OW 74
115677: PPUSH
115678: CALL_OW 296
115682: PUSH
115683: LD_INT 6
115685: LESS
115686: IFFALSE 115700
// SetFuel ( i , 100 ) ;
115688: LD_VAR 0 4
115692: PPUSH
115693: LD_INT 100
115695: PPUSH
115696: CALL_OW 240
// end else
115700: GO 115716
// ComAttackUnit ( i , e ) ;
115702: LD_VAR 0 4
115706: PPUSH
115707: LD_VAR 0 13
115711: PPUSH
115712: CALL_OW 115
// end else
115716: GO 115819
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
115718: LD_VAR 0 13
115722: PPUSH
115723: LD_EXP 120
115727: PUSH
115728: LD_VAR 0 1
115732: ARRAY
115733: PPUSH
115734: CALL_OW 308
115738: NOT
115739: PUSH
115740: LD_VAR 0 4
115744: PPUSH
115745: LD_VAR 0 13
115749: PPUSH
115750: CALL_OW 296
115754: PUSH
115755: LD_INT 40
115757: GREATEREQUAL
115758: AND
115759: PUSH
115760: LD_VAR 0 4
115764: PPUSH
115765: CALL_OW 256
115769: PUSH
115770: LD_INT 650
115772: LESSEQUAL
115773: OR
115774: PUSH
115775: LD_VAR 0 4
115779: PPUSH
115780: LD_EXP 119
115784: PUSH
115785: LD_VAR 0 1
115789: ARRAY
115790: PPUSH
115791: CALL_OW 308
115795: NOT
115796: AND
115797: IFFALSE 115819
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115799: LD_VAR 0 4
115803: PPUSH
115804: LD_EXP 119
115808: PUSH
115809: LD_VAR 0 1
115813: ARRAY
115814: PPUSH
115815: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115819: LD_VAR 0 4
115823: PPUSH
115824: CALL_OW 256
115828: PUSH
115829: LD_INT 1000
115831: LESS
115832: PUSH
115833: LD_VAR 0 4
115837: PPUSH
115838: CALL_OW 263
115842: PUSH
115843: LD_INT 1
115845: EQUAL
115846: AND
115847: PUSH
115848: LD_VAR 0 4
115852: PPUSH
115853: CALL_OW 311
115857: AND
115858: PUSH
115859: LD_VAR 0 4
115863: PPUSH
115864: LD_EXP 119
115868: PUSH
115869: LD_VAR 0 1
115873: ARRAY
115874: PPUSH
115875: CALL_OW 308
115879: AND
115880: IFFALSE 115934
// begin mech := IsDrivenBy ( i ) ;
115882: LD_ADDR_VAR 0 9
115886: PUSH
115887: LD_VAR 0 4
115891: PPUSH
115892: CALL_OW 311
115896: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
115897: LD_VAR 0 9
115901: PPUSH
115902: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
115906: LD_VAR 0 9
115910: PPUSH
115911: LD_VAR 0 4
115915: PPUSH
115916: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
115920: LD_VAR 0 9
115924: PPUSH
115925: LD_VAR 0 4
115929: PPUSH
115930: CALL_OW 180
// end ; end ; unit_human :
115934: GO 116281
115936: LD_INT 1
115938: DOUBLE
115939: EQUAL
115940: IFTRUE 115944
115942: GO 116280
115944: POP
// begin b := IsInUnit ( i ) ;
115945: LD_ADDR_VAR 0 18
115949: PUSH
115950: LD_VAR 0 4
115954: PPUSH
115955: CALL_OW 310
115959: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
115960: LD_ADDR_VAR 0 19
115964: PUSH
115965: LD_VAR 0 18
115969: NOT
115970: PUSH
115971: LD_VAR 0 18
115975: PPUSH
115976: CALL_OW 266
115980: PUSH
115981: LD_INT 32
115983: PUSH
115984: LD_INT 31
115986: PUSH
115987: EMPTY
115988: LIST
115989: LIST
115990: IN
115991: OR
115992: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
115993: LD_VAR 0 18
115997: PPUSH
115998: CALL_OW 266
116002: PUSH
116003: LD_INT 5
116005: EQUAL
116006: PUSH
116007: LD_VAR 0 4
116011: PPUSH
116012: CALL_OW 257
116016: PUSH
116017: LD_INT 1
116019: PUSH
116020: LD_INT 2
116022: PUSH
116023: LD_INT 3
116025: PUSH
116026: LD_INT 4
116028: PUSH
116029: EMPTY
116030: LIST
116031: LIST
116032: LIST
116033: LIST
116034: IN
116035: AND
116036: IFFALSE 116073
// begin class := AllowSpecClass ( i ) ;
116038: LD_ADDR_VAR 0 20
116042: PUSH
116043: LD_VAR 0 4
116047: PPUSH
116048: CALL 53812 0 1
116052: ST_TO_ADDR
// if class then
116053: LD_VAR 0 20
116057: IFFALSE 116073
// ComChangeProfession ( i , class ) ;
116059: LD_VAR 0 4
116063: PPUSH
116064: LD_VAR 0 20
116068: PPUSH
116069: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116073: LD_VAR 0 16
116077: PUSH
116078: LD_VAR 0 2
116082: PPUSH
116083: LD_INT 21
116085: PUSH
116086: LD_INT 2
116088: PUSH
116089: EMPTY
116090: LIST
116091: LIST
116092: PPUSH
116093: CALL_OW 72
116097: PUSH
116098: LD_INT 1
116100: LESSEQUAL
116101: OR
116102: PUSH
116103: LD_VAR 0 19
116107: AND
116108: PUSH
116109: LD_VAR 0 4
116113: PUSH
116114: LD_VAR 0 17
116118: IN
116119: NOT
116120: AND
116121: IFFALSE 116214
// begin if b then
116123: LD_VAR 0 18
116127: IFFALSE 116176
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116129: LD_VAR 0 18
116133: PPUSH
116134: LD_VAR 0 21
116138: PPUSH
116139: LD_VAR 0 18
116143: PPUSH
116144: CALL_OW 74
116148: PPUSH
116149: CALL_OW 296
116153: PUSH
116154: LD_INT 10
116156: LESS
116157: PUSH
116158: LD_VAR 0 18
116162: PPUSH
116163: CALL_OW 461
116167: PUSH
116168: LD_INT 7
116170: NONEQUAL
116171: AND
116172: IFFALSE 116176
// continue ;
116174: GO 115411
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116176: LD_ADDR_VAR 0 17
116180: PUSH
116181: LD_VAR 0 17
116185: PPUSH
116186: LD_VAR 0 17
116190: PUSH
116191: LD_INT 1
116193: PLUS
116194: PPUSH
116195: LD_VAR 0 4
116199: PPUSH
116200: CALL_OW 1
116204: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116205: LD_VAR 0 4
116209: PPUSH
116210: CALL_OW 122
// end ; if sold_defenders then
116214: LD_VAR 0 17
116218: IFFALSE 116278
// if i in sold_defenders then
116220: LD_VAR 0 4
116224: PUSH
116225: LD_VAR 0 17
116229: IN
116230: IFFALSE 116278
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116232: LD_VAR 0 4
116236: PPUSH
116237: CALL_OW 314
116241: NOT
116242: PUSH
116243: LD_VAR 0 4
116247: PPUSH
116248: LD_VAR 0 13
116252: PPUSH
116253: CALL_OW 296
116257: PUSH
116258: LD_INT 30
116260: LESS
116261: AND
116262: IFFALSE 116278
// ComAttackUnit ( i , e ) ;
116264: LD_VAR 0 4
116268: PPUSH
116269: LD_VAR 0 13
116273: PPUSH
116274: CALL_OW 115
// end ; end ; end ;
116278: GO 116281
116280: POP
// if IsDead ( i ) then
116281: LD_VAR 0 4
116285: PPUSH
116286: CALL_OW 301
116290: IFFALSE 116308
// defenders := defenders diff i ;
116292: LD_ADDR_VAR 0 2
116296: PUSH
116297: LD_VAR 0 2
116301: PUSH
116302: LD_VAR 0 4
116306: DIFF
116307: ST_TO_ADDR
// end ;
116308: GO 115411
116310: POP
116311: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116312: LD_VAR 0 21
116316: NOT
116317: PUSH
116318: LD_VAR 0 2
116322: NOT
116323: OR
116324: PUSH
116325: LD_EXP 95
116329: PUSH
116330: LD_VAR 0 1
116334: ARRAY
116335: NOT
116336: OR
116337: IFFALSE 115315
// MC_Reset ( base , 18 ) ;
116339: LD_VAR 0 1
116343: PPUSH
116344: LD_INT 18
116346: PPUSH
116347: CALL 25554 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116351: LD_ADDR_VAR 0 2
116355: PUSH
116356: LD_VAR 0 2
116360: PUSH
116361: LD_VAR 0 2
116365: PPUSH
116366: LD_INT 2
116368: PUSH
116369: LD_INT 25
116371: PUSH
116372: LD_INT 1
116374: PUSH
116375: EMPTY
116376: LIST
116377: LIST
116378: PUSH
116379: LD_INT 25
116381: PUSH
116382: LD_INT 5
116384: PUSH
116385: EMPTY
116386: LIST
116387: LIST
116388: PUSH
116389: LD_INT 25
116391: PUSH
116392: LD_INT 8
116394: PUSH
116395: EMPTY
116396: LIST
116397: LIST
116398: PUSH
116399: LD_INT 25
116401: PUSH
116402: LD_INT 9
116404: PUSH
116405: EMPTY
116406: LIST
116407: LIST
116408: PUSH
116409: EMPTY
116410: LIST
116411: LIST
116412: LIST
116413: LIST
116414: LIST
116415: PPUSH
116416: CALL_OW 72
116420: DIFF
116421: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116422: LD_VAR 0 21
116426: NOT
116427: PUSH
116428: LD_VAR 0 2
116432: PPUSH
116433: LD_INT 21
116435: PUSH
116436: LD_INT 2
116438: PUSH
116439: EMPTY
116440: LIST
116441: LIST
116442: PPUSH
116443: CALL_OW 72
116447: AND
116448: IFFALSE 116786
// begin tmp := FilterByTag ( defenders , 19 ) ;
116450: LD_ADDR_VAR 0 11
116454: PUSH
116455: LD_VAR 0 2
116459: PPUSH
116460: LD_INT 19
116462: PPUSH
116463: CALL 86281 0 2
116467: ST_TO_ADDR
// if tmp then
116468: LD_VAR 0 11
116472: IFFALSE 116542
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116474: LD_ADDR_VAR 0 11
116478: PUSH
116479: LD_VAR 0 11
116483: PPUSH
116484: LD_INT 25
116486: PUSH
116487: LD_INT 3
116489: PUSH
116490: EMPTY
116491: LIST
116492: LIST
116493: PPUSH
116494: CALL_OW 72
116498: ST_TO_ADDR
// if tmp then
116499: LD_VAR 0 11
116503: IFFALSE 116542
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116505: LD_ADDR_EXP 107
116509: PUSH
116510: LD_EXP 107
116514: PPUSH
116515: LD_VAR 0 1
116519: PPUSH
116520: LD_EXP 107
116524: PUSH
116525: LD_VAR 0 1
116529: ARRAY
116530: PUSH
116531: LD_VAR 0 11
116535: UNION
116536: PPUSH
116537: CALL_OW 1
116541: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116542: LD_VAR 0 1
116546: PPUSH
116547: LD_INT 19
116549: PPUSH
116550: CALL 25554 0 2
// repeat wait ( 0 0$1 ) ;
116554: LD_INT 35
116556: PPUSH
116557: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116561: LD_EXP 95
116565: PUSH
116566: LD_VAR 0 1
116570: ARRAY
116571: NOT
116572: PUSH
116573: LD_EXP 95
116577: PUSH
116578: LD_VAR 0 1
116582: ARRAY
116583: PUSH
116584: EMPTY
116585: EQUAL
116586: OR
116587: IFFALSE 116624
// begin for i in defenders do
116589: LD_ADDR_VAR 0 4
116593: PUSH
116594: LD_VAR 0 2
116598: PUSH
116599: FOR_IN
116600: IFFALSE 116613
// ComStop ( i ) ;
116602: LD_VAR 0 4
116606: PPUSH
116607: CALL_OW 141
116611: GO 116599
116613: POP
116614: POP
// defenders := [ ] ;
116615: LD_ADDR_VAR 0 2
116619: PUSH
116620: EMPTY
116621: ST_TO_ADDR
// exit ;
116622: GO 116850
// end ; for i in defenders do
116624: LD_ADDR_VAR 0 4
116628: PUSH
116629: LD_VAR 0 2
116633: PUSH
116634: FOR_IN
116635: IFFALSE 116724
// begin if not IsInArea ( i , mc_parking [ base ] ) then
116637: LD_VAR 0 4
116641: PPUSH
116642: LD_EXP 119
116646: PUSH
116647: LD_VAR 0 1
116651: ARRAY
116652: PPUSH
116653: CALL_OW 308
116657: NOT
116658: IFFALSE 116682
// ComMoveToArea ( i , mc_parking [ base ] ) else
116660: LD_VAR 0 4
116664: PPUSH
116665: LD_EXP 119
116669: PUSH
116670: LD_VAR 0 1
116674: ARRAY
116675: PPUSH
116676: CALL_OW 113
116680: GO 116722
// if GetControl ( i ) = control_manual then
116682: LD_VAR 0 4
116686: PPUSH
116687: CALL_OW 263
116691: PUSH
116692: LD_INT 1
116694: EQUAL
116695: IFFALSE 116722
// if IsDrivenBy ( i ) then
116697: LD_VAR 0 4
116701: PPUSH
116702: CALL_OW 311
116706: IFFALSE 116722
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
116708: LD_VAR 0 4
116712: PPUSH
116713: CALL_OW 311
116717: PPUSH
116718: CALL_OW 121
// end ;
116722: GO 116634
116724: POP
116725: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116726: LD_VAR 0 2
116730: PPUSH
116731: LD_INT 95
116733: PUSH
116734: LD_EXP 119
116738: PUSH
116739: LD_VAR 0 1
116743: ARRAY
116744: PUSH
116745: EMPTY
116746: LIST
116747: LIST
116748: PPUSH
116749: CALL_OW 72
116753: PUSH
116754: LD_VAR 0 2
116758: EQUAL
116759: PUSH
116760: LD_EXP 118
116764: PUSH
116765: LD_VAR 0 1
116769: ARRAY
116770: OR
116771: PUSH
116772: LD_EXP 95
116776: PUSH
116777: LD_VAR 0 1
116781: ARRAY
116782: NOT
116783: OR
116784: IFFALSE 116554
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116786: LD_ADDR_EXP 117
116790: PUSH
116791: LD_EXP 117
116795: PPUSH
116796: LD_VAR 0 1
116800: PPUSH
116801: LD_VAR 0 2
116805: PPUSH
116806: LD_INT 21
116808: PUSH
116809: LD_INT 2
116811: PUSH
116812: EMPTY
116813: LIST
116814: LIST
116815: PPUSH
116816: CALL_OW 72
116820: PPUSH
116821: CALL_OW 1
116825: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116826: LD_VAR 0 1
116830: PPUSH
116831: LD_INT 19
116833: PPUSH
116834: CALL 25554 0 2
// MC_Reset ( base , 20 ) ;
116838: LD_VAR 0 1
116842: PPUSH
116843: LD_INT 20
116845: PPUSH
116846: CALL 25554 0 2
// end ; end_of_file
116850: LD_VAR 0 3
116854: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
116855: LD_VAR 0 1
116859: PUSH
116860: LD_INT 200
116862: DOUBLE
116863: GREATEREQUAL
116864: IFFALSE 116872
116866: LD_INT 299
116868: DOUBLE
116869: LESSEQUAL
116870: IFTRUE 116874
116872: GO 116906
116874: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
116875: LD_VAR 0 1
116879: PPUSH
116880: LD_VAR 0 2
116884: PPUSH
116885: LD_VAR 0 3
116889: PPUSH
116890: LD_VAR 0 4
116894: PPUSH
116895: LD_VAR 0 5
116899: PPUSH
116900: CALL 105671 0 5
116904: GO 116983
116906: LD_INT 300
116908: DOUBLE
116909: GREATEREQUAL
116910: IFFALSE 116918
116912: LD_INT 399
116914: DOUBLE
116915: LESSEQUAL
116916: IFTRUE 116920
116918: GO 116982
116920: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
116921: LD_VAR 0 1
116925: PPUSH
116926: LD_VAR 0 2
116930: PPUSH
116931: LD_VAR 0 3
116935: PPUSH
116936: LD_VAR 0 4
116940: PPUSH
116941: LD_VAR 0 5
116945: PPUSH
116946: LD_VAR 0 6
116950: PPUSH
116951: LD_VAR 0 7
116955: PPUSH
116956: LD_VAR 0 8
116960: PPUSH
116961: LD_VAR 0 9
116965: PPUSH
116966: LD_VAR 0 10
116970: PPUSH
116971: LD_VAR 0 11
116975: PPUSH
116976: CALL 103569 0 11
116980: GO 116983
116982: POP
// end ;
116983: PPOPN 11
116985: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
116986: LD_VAR 0 1
116990: PPUSH
116991: LD_VAR 0 2
116995: PPUSH
116996: LD_VAR 0 3
117000: PPUSH
117001: LD_VAR 0 4
117005: PPUSH
117006: LD_VAR 0 5
117010: PPUSH
117011: CALL 105663 0 5
// end ; end_of_file
117015: PPOPN 5
117017: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117018: LD_VAR 0 1
117022: PPUSH
117023: LD_VAR 0 2
117027: PPUSH
117028: LD_VAR 0 3
117032: PPUSH
117033: LD_VAR 0 4
117037: PPUSH
117038: LD_VAR 0 5
117042: PPUSH
117043: LD_VAR 0 6
117047: PPUSH
117048: CALL 91764 0 6
// end ;
117052: PPOPN 6
117054: END
