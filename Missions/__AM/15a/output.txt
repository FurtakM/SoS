// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20517 0 0
// InitNature ;
  19: CALL 17154 0 0
// InitArtifact ;
  23: CALL 17767 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22629 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := 0 ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 103
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 104
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43846 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 44906 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 44999 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 108
 334: PUSH
 335: LD_EXP 108
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44164 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44349 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 44906 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 44999 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44164 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44349 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44779 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43846 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 44906 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 44999 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 108
 801: PUSH
 802: LD_EXP 108
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44164 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44349 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 44906 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 44999 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45317 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45111 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44164 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44349 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44730 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50556 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50556 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50556 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50556 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50556 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50556 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50556 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50556 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50556 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50556 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50556 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50556 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50556 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50556 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50556 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50556 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50556 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50556 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50556 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50556 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50556 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50556 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50556 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50556 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50556 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50556 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50556 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50556 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50556 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50556 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50556 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50556 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50556 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50556 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 57671 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 57671 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 57671 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 57671 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 57671 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 57671 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 57671 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 57671 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 57671 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 57671 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 57671 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 57671 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 57671 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 57671 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 57671 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 25500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 7500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50556 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50556 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50556 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50556 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50556 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50556 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50556 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50556 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50556 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50556 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 79
5380: PUSH
5381: LD_EXP 79
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45630 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44212 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44212 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45630 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45630 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 98
5863: PUSH
5864: LD_EXP 98
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 98
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44212 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 61080 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 79
6637: PUSH
6638: LD_EXP 79
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50556 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 61080 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 79
7167: PUSH
7168: LD_EXP 79
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45630 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44212 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44212 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45630 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45630 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 98
7816: PUSH
7817: LD_EXP 98
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 98
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 90000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 61080 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 79
8778: PUSH
8779: LD_EXP 79
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 93426 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 93474 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 93474 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45630 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44212 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44212 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44212 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45630 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45630 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 98
9818: PUSH
9819: LD_EXP 98
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 98
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44212 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47604 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 49938 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49006 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 60644 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49247 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47300 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 46920 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46516 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46354 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46129 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46014 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50199 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50415 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45823 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 96090 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// end ;
10968: LD_VAR 0 1
10972: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10973: LD_INT 7
10975: PPUSH
10976: LD_INT 255
10978: PPUSH
10979: LD_INT 219
10981: PPUSH
10982: CALL_OW 293
10986: IFFALSE 11595
10988: GO 10990
10990: DISABLE
10991: LD_INT 0
10993: PPUSH
// begin wait ( 0 0$3 ) ;
10994: LD_INT 105
10996: PPUSH
10997: CALL_OW 67
// alienSpotted := true ;
11001: LD_ADDR_EXP 10
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 22
11016: PUSH
11017: LD_INT 7
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 23
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 26
11046: PUSH
11047: LD_INT 1
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: PPUSH
11060: CALL_OW 69
11064: PUSH
11065: LD_EXP 49
11069: PUSH
11070: LD_EXP 37
11074: PUSH
11075: LD_EXP 39
11079: PUSH
11080: LD_EXP 40
11084: PUSH
11085: LD_EXP 47
11089: PUSH
11090: LD_EXP 46
11094: PUSH
11095: LD_EXP 41
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: DIFF
11109: ST_TO_ADDR
// DialogueOn ;
11110: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11114: LD_INT 255
11116: PPUSH
11117: LD_INT 219
11119: PPUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 20
11125: NEG
11126: PPUSH
11127: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11131: LD_INT 255
11133: PPUSH
11134: LD_INT 219
11136: PPUSH
11137: CALL_OW 86
// if speaker then
11141: LD_VAR 0 1
11145: IFFALSE 11163
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11147: LD_VAR 0 1
11151: PUSH
11152: LD_INT 1
11154: ARRAY
11155: PPUSH
11156: LD_STRING DAlienBase-RSol1-1
11158: PPUSH
11159: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11163: LD_EXP 17
11167: PPUSH
11168: LD_STRING DAlienBase-JMM-1
11170: PPUSH
11171: CALL_OW 88
// if IsOk ( Burlak ) then
11175: LD_EXP 49
11179: PPUSH
11180: CALL_OW 302
11184: IFFALSE 11205
// begin dwait ( 0 0$1 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11193: LD_EXP 49
11197: PPUSH
11198: LD_STRING DAlienBase-Bur-1
11200: PPUSH
11201: CALL_OW 88
// end ; if IsOk ( Roth ) then
11205: LD_EXP 18
11209: PPUSH
11210: CALL_OW 302
11214: IFFALSE 11228
// Say ( Roth , DAlienBase-Roth-1 ) ;
11216: LD_EXP 18
11220: PPUSH
11221: LD_STRING DAlienBase-Roth-1
11223: PPUSH
11224: CALL_OW 88
// if IsOk ( Gossudarov ) then
11228: LD_EXP 35
11232: PPUSH
11233: CALL_OW 302
11237: IFFALSE 11253
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11239: LD_EXP 35
11243: PPUSH
11244: LD_STRING DAlienBase-Gos-1
11246: PPUSH
11247: CALL_OW 88
11251: GO 11370
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11253: LD_ADDR_VAR 0 1
11257: PUSH
11258: LD_INT 22
11260: PUSH
11261: LD_INT 7
11263: PUSH
11264: EMPTY
11265: LIST
11266: LIST
11267: PUSH
11268: LD_INT 25
11270: PUSH
11271: LD_INT 4
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 26
11290: PUSH
11291: LD_INT 1
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PPUSH
11304: CALL_OW 69
11308: PUSH
11309: LD_EXP 18
11313: PUSH
11314: LD_EXP 17
11318: PUSH
11319: LD_EXP 49
11323: PUSH
11324: LD_EXP 37
11328: PUSH
11329: LD_EXP 47
11333: PUSH
11334: LD_EXP 46
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: DIFF
11347: ST_TO_ADDR
// if speaker then
11348: LD_VAR 0 1
11352: IFFALSE 11370
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11354: LD_VAR 0 1
11358: PUSH
11359: LD_INT 1
11361: ARRAY
11362: PPUSH
11363: LD_STRING DAlienBase-Sci1-1
11365: PPUSH
11366: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11370: LD_INT 255
11372: PPUSH
11373: LD_INT 219
11375: PPUSH
11376: LD_INT 7
11378: PPUSH
11379: CALL_OW 331
// DialogueOff ;
11383: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11387: LD_INT 35
11389: PPUSH
11390: CALL_OW 67
// until IsSelected ( alien ) ;
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 306
11401: IFFALSE 11387
// if not artifactIResearched or not artifactIIResearched then
11403: LD_EXP 12
11407: NOT
11408: PUSH
11409: LD_EXP 13
11413: NOT
11414: OR
11415: IFFALSE 11595
// begin if IsOk ( Roth ) then
11417: LD_EXP 18
11421: PPUSH
11422: CALL_OW 302
11426: IFFALSE 11442
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11428: LD_EXP 18
11432: PPUSH
11433: LD_STRING DAlieBaseNotReady-Roth-1
11435: PPUSH
11436: CALL_OW 88
11440: GO 11595
// if IsOk ( Gossudarov ) then
11442: LD_EXP 35
11446: PPUSH
11447: CALL_OW 302
11451: IFFALSE 11467
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11453: LD_EXP 35
11457: PPUSH
11458: LD_STRING DAlieBaseNotReady-Gos-1
11460: PPUSH
11461: CALL_OW 88
11465: GO 11595
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11467: LD_ADDR_VAR 0 1
11471: PUSH
11472: LD_INT 22
11474: PUSH
11475: LD_INT 7
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: PUSH
11482: LD_INT 23
11484: PUSH
11485: LD_INT 3
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: PUSH
11492: LD_INT 25
11494: PUSH
11495: LD_INT 4
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PUSH
11502: LD_INT 21
11504: PUSH
11505: LD_INT 1
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 26
11514: PUSH
11515: LD_INT 1
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: PPUSH
11529: CALL_OW 69
11533: PUSH
11534: LD_EXP 18
11538: PUSH
11539: LD_EXP 17
11543: PUSH
11544: LD_EXP 49
11548: PUSH
11549: LD_EXP 37
11553: PUSH
11554: LD_EXP 47
11558: PUSH
11559: LD_EXP 46
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: DIFF
11572: ST_TO_ADDR
// if speaker then
11573: LD_VAR 0 1
11577: IFFALSE 11595
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11579: LD_VAR 0 1
11583: PUSH
11584: LD_INT 1
11586: ARRAY
11587: PPUSH
11588: LD_STRING DAlieBaseNotReady-RSci1-1
11590: PPUSH
11591: CALL_OW 88
// end ; end ; end ;
11595: PPOPN 1
11597: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11598: LD_INT 24
11600: PPUSH
11601: LD_INT 7
11603: PPUSH
11604: CALL_OW 321
11608: PUSH
11609: LD_INT 2
11611: EQUAL
11612: IFFALSE 12303
11614: GO 11616
11616: DISABLE
11617: LD_INT 0
11619: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11620: LD_ADDR_VAR 0 1
11624: PUSH
11625: LD_INT 22
11627: PUSH
11628: LD_INT 7
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 23
11637: PUSH
11638: LD_INT 3
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 25
11647: PUSH
11648: LD_INT 4
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 21
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: LD_INT 26
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: PPUSH
11682: CALL_OW 69
11686: PUSH
11687: LD_EXP 18
11691: PUSH
11692: LD_EXP 17
11696: PUSH
11697: LD_EXP 49
11701: PUSH
11702: LD_EXP 37
11706: PUSH
11707: LD_EXP 47
11711: PUSH
11712: LD_EXP 46
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: DIFF
11725: ST_TO_ADDR
// if not speaker then
11726: LD_VAR 0 1
11730: NOT
11731: IFFALSE 11735
// exit ;
11733: GO 12303
// DialogueOn ;
11735: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DArtefTechnology-RSci1-1
11750: PPUSH
11751: CALL_OW 88
// if IsOk ( Burlak ) then
11755: LD_EXP 49
11759: PPUSH
11760: CALL_OW 302
11764: IFFALSE 11778
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11766: LD_EXP 49
11770: PPUSH
11771: LD_STRING DArtefTechnology-Bur-1
11773: PPUSH
11774: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11778: LD_VAR 0 1
11782: PUSH
11783: LD_INT 1
11785: ARRAY
11786: PPUSH
11787: LD_STRING DArtefTechnology-RSci1-2
11789: PPUSH
11790: CALL_OW 88
// if Denis then
11794: LD_EXP 23
11798: IFFALSE 11815
// speaker := [ Denis ] else
11800: LD_ADDR_VAR 0 1
11804: PUSH
11805: LD_EXP 23
11809: PUSH
11810: EMPTY
11811: LIST
11812: ST_TO_ADDR
11813: GO 11921
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 25
11842: PUSH
11843: LD_INT 4
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 26
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_EXP 18
11886: PUSH
11887: LD_EXP 17
11891: PUSH
11892: LD_EXP 49
11896: PUSH
11897: LD_EXP 37
11901: PUSH
11902: LD_EXP 47
11906: PUSH
11907: LD_EXP 46
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: LIST
11919: DIFF
11920: ST_TO_ADDR
// if speaker then
11921: LD_VAR 0 1
11925: IFFALSE 11943
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11927: LD_VAR 0 1
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PPUSH
11936: LD_STRING DArtefTechnology-Sci1-2
11938: PPUSH
11939: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11943: LD_ADDR_VAR 0 1
11947: PUSH
11948: LD_INT 22
11950: PUSH
11951: LD_INT 7
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 23
11960: PUSH
11961: LD_INT 3
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 25
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: LD_INT 21
11980: PUSH
11981: LD_INT 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 1
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: PUSH
12010: LD_EXP 18
12014: PUSH
12015: LD_EXP 17
12019: PUSH
12020: LD_EXP 49
12024: PUSH
12025: LD_EXP 37
12029: PUSH
12030: LD_EXP 47
12034: PUSH
12035: LD_EXP 46
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: DIFF
12048: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12049: LD_VAR 0 1
12053: PUSH
12054: LD_EXP 9
12058: PUSH
12059: LD_EXP 5
12063: OR
12064: AND
12065: IFFALSE 12299
// begin if arabianDestroyed and IsOk ( Burlak ) then
12067: LD_EXP 5
12071: PUSH
12072: LD_EXP 49
12076: PPUSH
12077: CALL_OW 302
12081: AND
12082: IFFALSE 12098
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12084: LD_EXP 49
12088: PPUSH
12089: LD_STRING DArtefTechnology-Bur-2
12091: PPUSH
12092: CALL_OW 88
12096: GO 12110
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12098: LD_EXP 17
12102: PPUSH
12103: LD_STRING DArtefTechnology-JMM-2
12105: PPUSH
12106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12110: LD_VAR 0 1
12114: PUSH
12115: LD_INT 1
12117: ARRAY
12118: PPUSH
12119: LD_STRING DArtefTechnology-RSci1-3
12121: PPUSH
12122: CALL_OW 88
// if Denis then
12126: LD_EXP 23
12130: IFFALSE 12147
// speaker := [ Denis ] else
12132: LD_ADDR_VAR 0 1
12136: PUSH
12137: LD_EXP 23
12141: PUSH
12142: EMPTY
12143: LIST
12144: ST_TO_ADDR
12145: GO 12253
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12147: LD_ADDR_VAR 0 1
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_INT 7
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 23
12164: PUSH
12165: LD_INT 1
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: LD_INT 25
12174: PUSH
12175: LD_INT 4
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 21
12184: PUSH
12185: LD_INT 1
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 26
12194: PUSH
12195: LD_INT 1
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 17
12223: PUSH
12224: LD_EXP 49
12228: PUSH
12229: LD_EXP 37
12233: PUSH
12234: LD_EXP 47
12238: PUSH
12239: LD_EXP 46
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: DIFF
12252: ST_TO_ADDR
// if speaker then
12253: LD_VAR 0 1
12257: IFFALSE 12299
// if alienSpotted then
12259: LD_EXP 10
12263: IFFALSE 12283
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING DArtefTechnology-Sci1-3
12276: PPUSH
12277: CALL_OW 88
12281: GO 12299
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12283: LD_VAR 0 1
12287: PUSH
12288: LD_INT 1
12290: ARRAY
12291: PPUSH
12292: LD_STRING DArtefTechnology-Sci1-3a
12294: PPUSH
12295: CALL_OW 88
// end ; DialogueOff ;
12299: CALL_OW 7
// end ;
12303: PPOPN 1
12305: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12306: LD_EXP 12
12310: IFFALSE 12505
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin if Denis then
12318: LD_EXP 23
12322: IFFALSE 12339
// speaker := [ Denis ] else
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_EXP 23
12333: PUSH
12334: EMPTY
12335: LIST
12336: ST_TO_ADDR
12337: GO 12445
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12339: LD_ADDR_VAR 0 1
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 7
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 23
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 25
12366: PUSH
12367: LD_INT 4
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 21
12376: PUSH
12377: LD_INT 1
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 26
12386: PUSH
12387: LD_INT 1
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: PPUSH
12401: CALL_OW 69
12405: PUSH
12406: LD_EXP 18
12410: PUSH
12411: LD_EXP 17
12415: PUSH
12416: LD_EXP 49
12420: PUSH
12421: LD_EXP 37
12425: PUSH
12426: LD_EXP 47
12430: PUSH
12431: LD_EXP 46
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: DIFF
12444: ST_TO_ADDR
// if not speaker then
12445: LD_VAR 0 1
12449: NOT
12450: IFFALSE 12454
// exit ;
12452: GO 12505
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12454: LD_VAR 0 1
12458: PUSH
12459: LD_INT 1
12461: ARRAY
12462: PPUSH
12463: LD_STRING DArtefTechnologyAm-Sci1-1
12465: PPUSH
12466: CALL_OW 88
// if IsOk ( Burlak ) then
12470: LD_EXP 49
12474: PPUSH
12475: CALL_OW 302
12479: IFFALSE 12493
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12481: LD_EXP 49
12485: PPUSH
12486: LD_STRING DArtefTechnologyAm-Bur-1
12488: PPUSH
12489: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12493: LD_EXP 17
12497: PPUSH
12498: LD_STRING DArtefTechnologyAm-JMM-1
12500: PPUSH
12501: CALL_OW 88
// end ;
12505: PPOPN 1
12507: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12508: LD_EXP 13
12512: IFFALSE 12723
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
// begin if Denis then
12520: LD_EXP 23
12524: IFFALSE 12541
// speaker := [ Denis ] else
12526: LD_ADDR_VAR 0 1
12530: PUSH
12531: LD_EXP 23
12535: PUSH
12536: EMPTY
12537: LIST
12538: ST_TO_ADDR
12539: GO 12647
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12541: LD_ADDR_VAR 0 1
12545: PUSH
12546: LD_INT 22
12548: PUSH
12549: LD_INT 7
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 23
12558: PUSH
12559: LD_INT 3
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 4
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: LD_INT 21
12578: PUSH
12579: LD_INT 1
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: LD_INT 26
12588: PUSH
12589: LD_INT 1
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: EMPTY
12597: LIST
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: PPUSH
12603: CALL_OW 69
12607: PUSH
12608: LD_EXP 18
12612: PUSH
12613: LD_EXP 17
12617: PUSH
12618: LD_EXP 49
12622: PUSH
12623: LD_EXP 37
12627: PUSH
12628: LD_EXP 47
12632: PUSH
12633: LD_EXP 46
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: DIFF
12646: ST_TO_ADDR
// if not speaker then
12647: LD_VAR 0 1
12651: NOT
12652: IFFALSE 12656
// exit ;
12654: GO 12723
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12656: LD_VAR 0 1
12660: PUSH
12661: LD_INT 1
12663: ARRAY
12664: PPUSH
12665: LD_STRING DArtefTechnologyRu-RSci1-1
12667: PPUSH
12668: CALL_OW 88
// if IsOk ( Burlak ) then
12672: LD_EXP 49
12676: PPUSH
12677: CALL_OW 302
12681: IFFALSE 12695
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12683: LD_EXP 49
12687: PPUSH
12688: LD_STRING DArtefTechnologyRu-Bur-1
12690: PPUSH
12691: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12695: LD_VAR 0 1
12699: PUSH
12700: LD_INT 1
12702: ARRAY
12703: PPUSH
12704: LD_STRING DArtefTechnologyRu-RSci1-2
12706: PPUSH
12707: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12711: LD_EXP 17
12715: PPUSH
12716: LD_STRING DArtefTechnologyRu-JMM-1
12718: PPUSH
12719: CALL_OW 88
// end ;
12723: PPOPN 1
12725: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12726: LD_INT 24
12728: PPUSH
12729: LD_INT 7
12731: PPUSH
12732: CALL_OW 321
12736: PUSH
12737: LD_INT 2
12739: EQUAL
12740: PUSH
12741: LD_INT 1
12743: PPUSH
12744: CALL_OW 255
12748: PUSH
12749: LD_INT 7
12751: EQUAL
12752: AND
12753: IFFALSE 12913
12755: GO 12757
12757: DISABLE
12758: LD_INT 0
12760: PPUSH
// begin if Denis then
12761: LD_EXP 23
12765: IFFALSE 12782
// speaker := [ Denis ] else
12767: LD_ADDR_VAR 0 1
12771: PUSH
12772: LD_EXP 23
12776: PUSH
12777: EMPTY
12778: LIST
12779: ST_TO_ADDR
12780: GO 12888
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12782: LD_ADDR_VAR 0 1
12786: PUSH
12787: LD_INT 22
12789: PUSH
12790: LD_INT 7
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: PUSH
12797: LD_INT 23
12799: PUSH
12800: LD_INT 1
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 4
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 21
12819: PUSH
12820: LD_INT 1
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: LD_INT 26
12829: PUSH
12830: LD_INT 1
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: PPUSH
12844: CALL_OW 69
12848: PUSH
12849: LD_EXP 18
12853: PUSH
12854: LD_EXP 17
12858: PUSH
12859: LD_EXP 49
12863: PUSH
12864: LD_EXP 37
12868: PUSH
12869: LD_EXP 47
12873: PUSH
12874: LD_EXP 46
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: DIFF
12887: ST_TO_ADDR
// if not speaker then
12888: LD_VAR 0 1
12892: NOT
12893: IFFALSE 12897
// exit ;
12895: GO 12913
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12897: LD_VAR 0 1
12901: PUSH
12902: LD_INT 1
12904: ARRAY
12905: PPUSH
12906: LD_STRING DArtefTechnologyArStart-Sci1-1
12908: PPUSH
12909: CALL_OW 88
// end ;
12913: PPOPN 1
12915: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12916: LD_EXP 14
12920: IFFALSE 13201
12922: GO 12924
12924: DISABLE
12925: LD_INT 0
12927: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12928: LD_ADDR_VAR 0 1
12932: PUSH
12933: LD_INT 22
12935: PUSH
12936: LD_INT 7
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 23
12945: PUSH
12946: LD_INT 3
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 25
12955: PUSH
12956: LD_INT 4
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: LD_INT 21
12965: PUSH
12966: LD_INT 1
12968: PUSH
12969: EMPTY
12970: LIST
12971: LIST
12972: PUSH
12973: LD_INT 26
12975: PUSH
12976: LD_INT 1
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: PPUSH
12990: CALL_OW 69
12994: PUSH
12995: LD_EXP 18
12999: PUSH
13000: LD_EXP 17
13004: PUSH
13005: LD_EXP 49
13009: PUSH
13010: LD_EXP 37
13014: PUSH
13015: LD_EXP 47
13019: PUSH
13020: LD_EXP 46
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: DIFF
13033: ST_TO_ADDR
// if not speaker then
13034: LD_VAR 0 1
13038: NOT
13039: IFFALSE 13043
// exit ;
13041: GO 13201
// DialogueOn ;
13043: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 1
13054: ARRAY
13055: PPUSH
13056: LD_STRING DArtefTechnologyAr-RSci1-1
13058: PPUSH
13059: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13063: LD_EXP 17
13067: PPUSH
13068: LD_STRING DArtefTechnologyAr-JMM-1
13070: PPUSH
13071: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13075: LD_VAR 0 1
13079: PUSH
13080: LD_INT 1
13082: ARRAY
13083: PPUSH
13084: LD_STRING DArtefTechnologyAr-RSci1-2
13086: PPUSH
13087: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13091: LD_EXP 17
13095: PPUSH
13096: LD_STRING DArtefTechnologyAr-JMM-2
13098: PPUSH
13099: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13103: LD_VAR 0 1
13107: PUSH
13108: LD_INT 1
13110: ARRAY
13111: PPUSH
13112: LD_STRING DArtefTechnologyAr-RSci1-3
13114: PPUSH
13115: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13119: LD_EXP 17
13123: PPUSH
13124: LD_STRING DArtefTechnologyAr-JMM-3
13126: PPUSH
13127: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13131: LD_VAR 0 1
13135: PUSH
13136: LD_INT 1
13138: ARRAY
13139: PPUSH
13140: LD_STRING DArtefTechnologyAr-RSci1-4
13142: PPUSH
13143: CALL_OW 88
// if IsOk ( Burlak ) then
13147: LD_EXP 49
13151: PPUSH
13152: CALL_OW 302
13156: IFFALSE 13170
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13158: LD_EXP 49
13162: PPUSH
13163: LD_STRING DArtefTechnologyAr-Bur-4
13165: PPUSH
13166: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13170: LD_EXP 17
13174: PPUSH
13175: LD_STRING DArtefTechnologyAr-JMM-4
13177: PPUSH
13178: CALL_OW 88
// DialogueOff ;
13182: CALL_OW 7
// wait ( 0 0$45 ) ;
13186: LD_INT 1575
13188: PPUSH
13189: CALL_OW 67
// spawnOmar := true ;
13193: LD_ADDR_EXP 11
13197: PUSH
13198: LD_INT 1
13200: ST_TO_ADDR
// end ;
13201: PPOPN 1
13203: END
// every 0 0$1 trigger spawnOmar do
13204: LD_EXP 11
13208: IFFALSE 13588
13210: GO 13212
13212: DISABLE
// begin PrepareOmarAli ;
13213: CALL 6705 0 0
// if not HasTask ( Omar ) then
13217: LD_EXP 53
13221: PPUSH
13222: CALL_OW 314
13226: NOT
13227: IFFALSE 13244
// ComMoveXY ( Omar , 252 , 220 ) ;
13229: LD_EXP 53
13233: PPUSH
13234: LD_INT 252
13236: PPUSH
13237: LD_INT 220
13239: PPUSH
13240: CALL_OW 111
// if not Omar then
13244: LD_EXP 53
13248: NOT
13249: IFFALSE 13253
// exit ;
13251: GO 13588
// repeat wait ( 0 0$1 ) ;
13253: LD_INT 35
13255: PPUSH
13256: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13260: LD_EXP 53
13264: PPUSH
13265: CALL_OW 314
13269: NOT
13270: PUSH
13271: LD_EXP 53
13275: PPUSH
13276: LD_INT 252
13278: PPUSH
13279: LD_INT 220
13281: PPUSH
13282: CALL_OW 297
13286: PUSH
13287: LD_INT 6
13289: GREATER
13290: AND
13291: IFFALSE 13308
// ComMoveXY ( Omar , 252 , 220 ) ;
13293: LD_EXP 53
13297: PPUSH
13298: LD_INT 252
13300: PPUSH
13301: LD_INT 220
13303: PPUSH
13304: CALL_OW 111
// until See ( 7 , Omar ) ;
13308: LD_INT 7
13310: PPUSH
13311: LD_EXP 53
13315: PPUSH
13316: CALL_OW 292
13320: IFFALSE 13253
// CenterNowOnUnits ( Omar ) ;
13322: LD_EXP 53
13326: PPUSH
13327: CALL_OW 87
// DialogueOn ;
13331: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13335: LD_EXP 53
13339: PPUSH
13340: LD_STRING DOmar-Omar-1
13342: PPUSH
13343: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13347: LD_EXP 17
13351: PPUSH
13352: LD_STRING DOmar-JMM-1
13354: PPUSH
13355: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13359: LD_EXP 53
13363: PPUSH
13364: LD_STRING DOmar-Omar-2
13366: PPUSH
13367: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13371: LD_EXP 17
13375: PPUSH
13376: LD_STRING DOmar-JMM-2
13378: PPUSH
13379: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13383: LD_EXP 53
13387: PPUSH
13388: LD_STRING DOmar-Omar-3
13390: PPUSH
13391: CALL_OW 88
// if IsOk ( Burlak ) then
13395: LD_EXP 49
13399: PPUSH
13400: CALL_OW 302
13404: IFFALSE 13420
// Say ( Burlak , DOmar-Bur-3 ) else
13406: LD_EXP 49
13410: PPUSH
13411: LD_STRING DOmar-Bur-3
13413: PPUSH
13414: CALL_OW 88
13418: GO 13432
// Say ( JMM , DOmar-JMM-3 ) ;
13420: LD_EXP 17
13424: PPUSH
13425: LD_STRING DOmar-JMM-3
13427: PPUSH
13428: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13432: LD_EXP 53
13436: PPUSH
13437: LD_STRING DOmar-Omar-4
13439: PPUSH
13440: CALL_OW 88
// case Query ( QAccept ) of 1 :
13444: LD_STRING QAccept
13446: PPUSH
13447: CALL_OW 97
13451: PUSH
13452: LD_INT 1
13454: DOUBLE
13455: EQUAL
13456: IFTRUE 13460
13458: GO 13496
13460: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13461: LD_EXP 17
13465: PPUSH
13466: LD_STRING DQrAccept#1-JMM-1
13468: PPUSH
13469: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13473: LD_EXP 53
13477: PPUSH
13478: LD_INT 7
13480: PPUSH
13481: CALL_OW 235
// ComStop ( Omar ) ;
13485: LD_EXP 53
13489: PPUSH
13490: CALL_OW 141
// end ; 2 :
13494: GO 13545
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13544
13504: POP
// begin if IsOk ( Burlak ) then
13505: LD_EXP 49
13509: PPUSH
13510: CALL_OW 302
13514: IFFALSE 13530
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13516: LD_EXP 49
13520: PPUSH
13521: LD_STRING DQrAccept#2-Bur-1
13523: PPUSH
13524: CALL_OW 88
13528: GO 13542
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13530: LD_EXP 17
13534: PPUSH
13535: LD_STRING DQrAccept#2-JMM-1
13537: PPUSH
13538: CALL_OW 88
// end ; end ;
13542: GO 13545
13544: POP
// DialogueOff ;
13545: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13549: LD_EXP 53
13553: PPUSH
13554: CALL_OW 255
13558: PUSH
13559: LD_INT 7
13561: EQUAL
13562: IFFALSE 13573
// begin SetAchievement ( ACH_OMAR ) ;
13564: LD_STRING ACH_OMAR
13566: PPUSH
13567: CALL_OW 543
// exit ;
13571: GO 13588
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13573: LD_EXP 53
13577: PPUSH
13578: LD_INT 202
13580: PPUSH
13581: LD_INT 115
13583: PPUSH
13584: CALL_OW 111
// end ;
13588: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13589: LD_EXP 53
13593: PPUSH
13594: LD_INT 200
13596: PPUSH
13597: LD_INT 98
13599: PPUSH
13600: CALL_OW 297
13604: PUSH
13605: LD_INT 40
13607: LESS
13608: PUSH
13609: LD_EXP 2
13613: AND
13614: IFFALSE 13832
13616: GO 13618
13618: DISABLE
// begin SetSide ( Omar , 5 ) ;
13619: LD_EXP 53
13623: PPUSH
13624: LD_INT 5
13626: PPUSH
13627: CALL_OW 235
// if IsInUnit ( Omar ) then
13631: LD_EXP 53
13635: PPUSH
13636: CALL_OW 310
13640: IFFALSE 13651
// ComExitVehicle ( Omar ) ;
13642: LD_EXP 53
13646: PPUSH
13647: CALL_OW 121
// if IsInUnit ( Omar ) then
13651: LD_EXP 53
13655: PPUSH
13656: CALL_OW 310
13660: IFFALSE 13671
// ComExitBuilding ( Omar ) ;
13662: LD_EXP 53
13666: PPUSH
13667: CALL_OW 122
// wait ( 0 0$1 ) ;
13671: LD_INT 35
13673: PPUSH
13674: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13678: LD_EXP 53
13682: PPUSH
13683: LD_INT 203
13685: PPUSH
13686: LD_INT 120
13688: PPUSH
13689: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13693: LD_INT 35
13695: PPUSH
13696: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13700: LD_EXP 53
13704: PPUSH
13705: CALL_OW 306
13709: PUSH
13710: LD_EXP 53
13714: PPUSH
13715: LD_INT 203
13717: PPUSH
13718: LD_INT 120
13720: PPUSH
13721: CALL_OW 297
13725: PUSH
13726: LD_INT 6
13728: LESS
13729: OR
13730: IFFALSE 13693
// CenterNowOnUnits ( Omar ) ;
13732: LD_EXP 53
13736: PPUSH
13737: CALL_OW 87
// DialogueOn ;
13741: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13745: LD_EXP 17
13749: PPUSH
13750: LD_STRING DOmarContam-JMM-1
13752: PPUSH
13753: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13757: LD_EXP 53
13761: PPUSH
13762: LD_STRING DOmarContam-Omar-1
13764: PPUSH
13765: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13769: LD_EXP 17
13773: PPUSH
13774: LD_STRING DOmarContam-JMM-2
13776: PPUSH
13777: CALL_OW 88
// DialogueOff ;
13781: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13785: LD_INT 5
13787: PPUSH
13788: LD_INT 7
13790: PPUSH
13791: LD_INT 2
13793: PPUSH
13794: LD_INT 1
13796: PPUSH
13797: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13801: LD_INT 105
13803: PPUSH
13804: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13808: LD_EXP 53
13812: PPUSH
13813: LD_INT 203
13815: PPUSH
13816: LD_INT 120
13818: PPUSH
13819: CALL_OW 307
13823: IFFALSE 13801
// YouLost ( MothContaminate ) ;
13825: LD_STRING MothContaminate
13827: PPUSH
13828: CALL_OW 104
// end ;
13832: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13833: LD_EXP 4
13837: NOT
13838: PUSH
13839: LD_INT 22
13841: PUSH
13842: LD_INT 1
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: PUSH
13849: LD_INT 34
13851: PUSH
13852: LD_INT 8
13854: PUSH
13855: EMPTY
13856: LIST
13857: LIST
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: PPUSH
13863: CALL_OW 69
13867: AND
13868: IFFALSE 13949
13870: GO 13872
13872: DISABLE
// begin if not IsOk ( Powell ) then
13873: LD_EXP 52
13877: PPUSH
13878: CALL_OW 302
13882: NOT
13883: IFFALSE 13887
// exit ;
13885: GO 13949
// DialogueOn ;
13887: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13891: LD_EXP 52
13895: PPUSH
13896: LD_STRING DWinAmericans-Pow-1
13898: PPUSH
13899: CALL_OW 94
// if IsOk ( Burlak ) then
13903: LD_EXP 49
13907: PPUSH
13908: CALL_OW 302
13912: IFFALSE 13926
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13914: LD_EXP 49
13918: PPUSH
13919: LD_STRING DWinAmericans-Bur-1
13921: PPUSH
13922: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13926: LD_EXP 17
13930: PPUSH
13931: LD_STRING DWinAmericans-JMM-1
13933: PPUSH
13934: CALL_OW 88
// DialogueOff ;
13938: CALL_OW 7
// YouLost ( AmBomb ) ;
13942: LD_STRING AmBomb
13944: PPUSH
13945: CALL_OW 104
// end ;
13949: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13950: LD_EXP 2
13954: NOT
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 34
13968: PUSH
13969: LD_INT 48
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: AND
13985: IFFALSE 14066
13987: GO 13989
13989: DISABLE
// begin if not IsOk ( Platonov ) then
13990: LD_EXP 56
13994: PPUSH
13995: CALL_OW 302
13999: NOT
14000: IFFALSE 14004
// exit ;
14002: GO 14066
// DialogueOn ;
14004: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14008: LD_EXP 56
14012: PPUSH
14013: LD_STRING DWinRussians-Pla-1
14015: PPUSH
14016: CALL_OW 94
// if IsOk ( Burlak ) then
14020: LD_EXP 49
14024: PPUSH
14025: CALL_OW 302
14029: IFFALSE 14043
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14031: LD_EXP 49
14035: PPUSH
14036: LD_STRING DWinRussians-Bur-1
14038: PPUSH
14039: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14043: LD_EXP 17
14047: PPUSH
14048: LD_STRING DWinRussians-JMM-1
14050: PPUSH
14051: CALL_OW 88
// DialogueOff ;
14055: CALL_OW 7
// YouLost ( RuBomb ) ;
14059: LD_STRING RuBomb
14061: PPUSH
14062: CALL_OW 104
// end ;
14066: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14067: LD_INT 7
14069: PPUSH
14070: LD_INT 22
14072: PUSH
14073: LD_INT 7
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: PPUSH
14080: CALL_OW 70
14084: PUSH
14085: LD_EXP 4
14089: NOT
14090: AND
14091: IFFALSE 14120
14093: GO 14095
14095: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14096: LD_EXP 52
14100: PPUSH
14101: LD_STRING DSurrenderAmericans-Pow-1
14103: PPUSH
14104: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14108: LD_EXP 17
14112: PPUSH
14113: LD_STRING DSurrenderAmericans-JMM-1
14115: PPUSH
14116: CALL_OW 88
// end ;
14120: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14121: LD_INT 2
14123: PPUSH
14124: LD_INT 22
14126: PUSH
14127: LD_INT 7
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: PPUSH
14134: CALL_OW 70
14138: PUSH
14139: LD_EXP 2
14143: NOT
14144: AND
14145: PUSH
14146: LD_EXP 49
14150: AND
14151: IFFALSE 14180
14153: GO 14155
14155: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14156: LD_EXP 56
14160: PPUSH
14161: LD_STRING DSurrenderRussians-Pla-1
14163: PPUSH
14164: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14168: LD_EXP 49
14172: PPUSH
14173: LD_STRING DSurrenderRussians-Bur-1
14175: PPUSH
14176: CALL_OW 88
// end ;
14180: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14181: LD_EXP 4
14185: IFFALSE 14568
14187: GO 14189
14189: DISABLE
14190: LD_INT 0
14192: PPUSH
14193: PPUSH
14194: PPUSH
// begin MC_Kill ( 4 ) ;
14195: LD_INT 4
14197: PPUSH
14198: CALL 20752 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14202: LD_INT 1
14204: PPUSH
14205: LD_INT 7
14207: PPUSH
14208: LD_INT 1
14210: PPUSH
14211: LD_INT 1
14213: PPUSH
14214: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14218: LD_ADDR_VAR 0 3
14222: PUSH
14223: LD_INT 22
14225: PUSH
14226: LD_INT 1
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: PUSH
14233: LD_INT 26
14235: PUSH
14236: LD_INT 1
14238: PUSH
14239: EMPTY
14240: LIST
14241: LIST
14242: PUSH
14243: LD_INT 23
14245: PUSH
14246: LD_INT 1
14248: PUSH
14249: EMPTY
14250: LIST
14251: LIST
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: LIST
14257: PPUSH
14258: CALL_OW 69
14262: PUSH
14263: LD_EXP 52
14267: PUSH
14268: LD_EXP 25
14272: PUSH
14273: LD_EXP 22
14277: PUSH
14278: LD_EXP 21
14282: PUSH
14283: LD_EXP 28
14287: PUSH
14288: LD_EXP 26
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: DIFF
14301: ST_TO_ADDR
// if speaker then
14302: LD_VAR 0 3
14306: IFFALSE 14332
// begin DialogueOn ;
14308: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14312: LD_VAR 0 3
14316: PUSH
14317: LD_INT 1
14319: ARRAY
14320: PPUSH
14321: LD_STRING DSurrenderAmericans-Sol1-1a
14323: PPUSH
14324: CALL_OW 94
// DialogueOff ;
14328: CALL_OW 7
// end ; americanCapitulated := true ;
14332: LD_ADDR_EXP 6
14336: PUSH
14337: LD_INT 1
14339: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14340: LD_ADDR_VAR 0 2
14344: PUSH
14345: LD_INT 22
14347: PUSH
14348: LD_INT 1
14350: PUSH
14351: EMPTY
14352: LIST
14353: LIST
14354: PUSH
14355: LD_INT 21
14357: PUSH
14358: LD_INT 1
14360: PUSH
14361: EMPTY
14362: LIST
14363: LIST
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: PPUSH
14369: CALL_OW 69
14373: PUSH
14374: LD_INT 22
14376: PUSH
14377: LD_INT 1
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 21
14386: PUSH
14387: LD_INT 2
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 1
14396: PUSH
14397: EMPTY
14398: LIST
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: LIST
14404: PPUSH
14405: CALL_OW 69
14409: ADD
14410: ST_TO_ADDR
// if tmp then
14411: LD_VAR 0 2
14415: IFFALSE 14568
// repeat wait ( 0 0$1 ) ;
14417: LD_INT 35
14419: PPUSH
14420: CALL_OW 67
// for i in tmp do
14424: LD_ADDR_VAR 0 1
14428: PUSH
14429: LD_VAR 0 2
14433: PUSH
14434: FOR_IN
14435: IFFALSE 14517
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14437: LD_VAR 0 1
14441: PPUSH
14442: CALL_OW 310
14446: PUSH
14447: LD_VAR 0 1
14451: PPUSH
14452: CALL_OW 310
14456: PPUSH
14457: CALL_OW 247
14461: PUSH
14462: LD_INT 3
14464: EQUAL
14465: AND
14466: IFFALSE 14477
// ComExitBuilding ( i ) ;
14468: LD_VAR 0 1
14472: PPUSH
14473: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14477: LD_VAR 0 1
14481: PPUSH
14482: LD_INT 122
14484: PPUSH
14485: LD_INT 242
14487: PPUSH
14488: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14492: LD_VAR 0 1
14496: PPUSH
14497: LD_INT 35
14499: PPUSH
14500: CALL_OW 308
14504: IFFALSE 14515
// RemoveUnit ( i ) ;
14506: LD_VAR 0 1
14510: PPUSH
14511: CALL_OW 64
// end ;
14515: GO 14434
14517: POP
14518: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14519: LD_INT 22
14521: PUSH
14522: LD_INT 1
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: PUSH
14529: LD_INT 2
14531: PUSH
14532: LD_INT 21
14534: PUSH
14535: LD_INT 1
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 33
14544: PUSH
14545: LD_INT 1
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: LIST
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PPUSH
14561: CALL_OW 69
14565: NOT
14566: IFFALSE 14417
// end ;
14568: PPOPN 3
14570: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14571: LD_EXP 2
14575: IFFALSE 14976
14577: GO 14579
14579: DISABLE
14580: LD_INT 0
14582: PPUSH
14583: PPUSH
14584: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14585: LD_INT 35
14587: PPUSH
14588: CALL_OW 67
// until IsDead ( Yakotich ) ;
14592: LD_EXP 57
14596: PPUSH
14597: CALL_OW 301
14601: IFFALSE 14585
// MC_Kill ( 2 ) ;
14603: LD_INT 2
14605: PPUSH
14606: CALL 20752 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14610: LD_INT 3
14612: PPUSH
14613: LD_INT 7
14615: PPUSH
14616: LD_INT 1
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: LD_INT 22
14633: PUSH
14634: LD_INT 3
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PUSH
14641: LD_INT 26
14643: PUSH
14644: LD_INT 1
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: LD_INT 23
14653: PUSH
14654: LD_INT 3
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: PUSH
14671: LD_EXP 56
14675: PUSH
14676: LD_EXP 57
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: DIFF
14685: ST_TO_ADDR
// if speaker then
14686: LD_VAR 0 3
14690: IFFALSE 14740
// begin DialogueOn ;
14692: CALL_OW 6
// if Burlak then
14696: LD_EXP 49
14700: IFFALSE 14720
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14702: LD_VAR 0 3
14706: PUSH
14707: LD_INT 1
14709: ARRAY
14710: PPUSH
14711: LD_STRING DSurrenderRussians-RSol1-1
14713: PPUSH
14714: CALL_OW 94
14718: GO 14736
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14720: LD_VAR 0 3
14724: PUSH
14725: LD_INT 1
14727: ARRAY
14728: PPUSH
14729: LD_STRING DSurrenderRussians-RSol1-1a
14731: PPUSH
14732: CALL_OW 94
// DialogueOff ;
14736: CALL_OW 7
// end ; russianCapitulated := true ;
14740: LD_ADDR_EXP 7
14744: PUSH
14745: LD_INT 1
14747: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14748: LD_ADDR_VAR 0 2
14752: PUSH
14753: LD_INT 22
14755: PUSH
14756: LD_INT 3
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PUSH
14763: LD_INT 21
14765: PUSH
14766: LD_INT 1
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PPUSH
14777: CALL_OW 69
14781: PUSH
14782: LD_INT 22
14784: PUSH
14785: LD_INT 3
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 21
14794: PUSH
14795: LD_INT 2
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 1
14804: PUSH
14805: EMPTY
14806: LIST
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: LIST
14812: PPUSH
14813: CALL_OW 69
14817: ADD
14818: ST_TO_ADDR
// if tmp then
14819: LD_VAR 0 2
14823: IFFALSE 14976
// repeat wait ( 0 0$1 ) ;
14825: LD_INT 35
14827: PPUSH
14828: CALL_OW 67
// for i in tmp do
14832: LD_ADDR_VAR 0 1
14836: PUSH
14837: LD_VAR 0 2
14841: PUSH
14842: FOR_IN
14843: IFFALSE 14925
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14845: LD_VAR 0 1
14849: PPUSH
14850: CALL_OW 310
14854: PUSH
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 310
14864: PPUSH
14865: CALL_OW 247
14869: PUSH
14870: LD_INT 3
14872: EQUAL
14873: AND
14874: IFFALSE 14885
// ComExitBuilding ( i ) ;
14876: LD_VAR 0 1
14880: PPUSH
14881: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14885: LD_VAR 0 1
14889: PPUSH
14890: LD_INT 154
14892: PPUSH
14893: LD_INT 1
14895: PPUSH
14896: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14900: LD_VAR 0 1
14904: PPUSH
14905: LD_INT 36
14907: PPUSH
14908: CALL_OW 308
14912: IFFALSE 14923
// RemoveUnit ( i ) ;
14914: LD_VAR 0 1
14918: PPUSH
14919: CALL_OW 64
// end ;
14923: GO 14842
14925: POP
14926: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14927: LD_INT 22
14929: PUSH
14930: LD_INT 3
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 33
14952: PUSH
14953: LD_INT 1
14955: PUSH
14956: EMPTY
14957: LIST
14958: LIST
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: LIST
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PPUSH
14969: CALL_OW 69
14973: NOT
14974: IFFALSE 14825
// end ;
14976: PPOPN 3
14978: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14979: LD_INT 22
14981: PUSH
14982: LD_INT 8
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PUSH
14989: LD_INT 21
14991: PUSH
14992: LD_INT 1
14994: PUSH
14995: EMPTY
14996: LIST
14997: LIST
14998: PUSH
14999: LD_INT 23
15001: PUSH
15002: LD_INT 2
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: LIST
15013: PPUSH
15014: CALL_OW 69
15018: PUSH
15019: LD_INT 18
15021: LESS
15022: PUSH
15023: LD_EXP 55
15027: PPUSH
15028: CALL_OW 301
15032: OR
15033: PUSH
15034: LD_INT 324
15036: PPUSH
15037: CALL_OW 255
15041: PUSH
15042: LD_INT 7
15044: EQUAL
15045: OR
15046: IFFALSE 15059
15048: GO 15050
15050: DISABLE
// legionDestroyed := true ;
15051: LD_ADDR_EXP 3
15055: PUSH
15056: LD_INT 1
15058: ST_TO_ADDR
15059: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15060: LD_INT 22
15062: PUSH
15063: LD_INT 2
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: PUSH
15070: LD_INT 21
15072: PUSH
15073: LD_INT 1
15075: PUSH
15076: EMPTY
15077: LIST
15078: LIST
15079: PUSH
15080: LD_INT 23
15082: PUSH
15083: LD_INT 2
15085: PUSH
15086: EMPTY
15087: LIST
15088: LIST
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: LIST
15094: PPUSH
15095: CALL_OW 69
15099: PUSH
15100: LD_INT 9
15102: LESS
15103: IFFALSE 15116
15105: GO 15107
15107: DISABLE
// arabianDestroyed := true ;
15108: LD_ADDR_EXP 5
15112: PUSH
15113: LD_INT 1
15115: ST_TO_ADDR
15116: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15117: LD_EXP 5
15121: IFFALSE 15365
15123: GO 15125
15125: DISABLE
15126: LD_INT 0
15128: PPUSH
15129: PPUSH
// begin MC_Kill ( 1 ) ;
15130: LD_INT 1
15132: PPUSH
15133: CALL 20752 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15137: LD_ADDR_VAR 0 2
15141: PUSH
15142: LD_INT 22
15144: PUSH
15145: LD_INT 2
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: LD_INT 21
15154: PUSH
15155: LD_INT 1
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: PPUSH
15166: CALL_OW 69
15170: PUSH
15171: LD_INT 22
15173: PUSH
15174: LD_INT 8
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: LD_INT 21
15183: PUSH
15184: LD_INT 2
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: PUSH
15191: LD_INT 1
15193: PUSH
15194: EMPTY
15195: LIST
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: ADD
15207: ST_TO_ADDR
// if tmp then
15208: LD_VAR 0 2
15212: IFFALSE 15365
// repeat wait ( 0 0$1 ) ;
15214: LD_INT 35
15216: PPUSH
15217: CALL_OW 67
// for i in tmp do
15221: LD_ADDR_VAR 0 1
15225: PUSH
15226: LD_VAR 0 2
15230: PUSH
15231: FOR_IN
15232: IFFALSE 15314
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15234: LD_VAR 0 1
15238: PPUSH
15239: CALL_OW 310
15243: PUSH
15244: LD_VAR 0 1
15248: PPUSH
15249: CALL_OW 310
15253: PPUSH
15254: CALL_OW 247
15258: PUSH
15259: LD_INT 3
15261: EQUAL
15262: AND
15263: IFFALSE 15274
// ComExitBuilding ( i ) ;
15265: LD_VAR 0 1
15269: PPUSH
15270: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15274: LD_VAR 0 1
15278: PPUSH
15279: LD_INT 254
15281: PPUSH
15282: LD_INT 268
15284: PPUSH
15285: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15289: LD_VAR 0 1
15293: PPUSH
15294: LD_INT 34
15296: PPUSH
15297: CALL_OW 308
15301: IFFALSE 15312
// RemoveUnit ( i ) ;
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 64
// end ;
15312: GO 15231
15314: POP
15315: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15316: LD_INT 22
15318: PUSH
15319: LD_INT 2
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 2
15328: PUSH
15329: LD_INT 21
15331: PUSH
15332: LD_INT 1
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: LD_INT 33
15341: PUSH
15342: LD_INT 1
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: LIST
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: PPUSH
15358: CALL_OW 69
15362: NOT
15363: IFFALSE 15214
// end ;
15365: PPOPN 2
15367: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15368: LD_EXP 3
15372: IFFALSE 15724
15374: GO 15376
15376: DISABLE
15377: LD_INT 0
15379: PPUSH
15380: PPUSH
// begin MC_Kill ( 3 ) ;
15381: LD_INT 3
15383: PPUSH
15384: CALL 20752 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15388: LD_INT 8
15390: PPUSH
15391: LD_INT 7
15393: PPUSH
15394: LD_INT 1
15396: PPUSH
15397: LD_INT 1
15399: PPUSH
15400: CALL_OW 80
// DialogueOn ;
15404: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15408: LD_EXP 54
15412: PPUSH
15413: LD_STRING D15-Szulc-1
15415: PPUSH
15416: CALL_OW 94
// DialogueOff ;
15420: CALL_OW 7
// legionCapitulated := true ;
15424: LD_ADDR_EXP 8
15428: PUSH
15429: LD_INT 1
15431: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15432: LD_ADDR_VAR 0 1
15436: PUSH
15437: LD_INT 22
15439: PUSH
15440: LD_INT 8
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: PUSH
15447: LD_INT 21
15449: PUSH
15450: LD_INT 3
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: PUSH
15457: LD_INT 23
15459: PUSH
15460: LD_INT 3
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: PPUSH
15472: CALL_OW 69
15476: PUSH
15477: FOR_IN
15478: IFFALSE 15494
// SetLives ( i , 3 ) ;
15480: LD_VAR 0 1
15484: PPUSH
15485: LD_INT 3
15487: PPUSH
15488: CALL_OW 234
15492: GO 15477
15494: POP
15495: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15496: LD_ADDR_VAR 0 2
15500: PUSH
15501: LD_INT 22
15503: PUSH
15504: LD_INT 8
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: LD_INT 21
15513: PUSH
15514: LD_INT 1
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: PPUSH
15525: CALL_OW 69
15529: PUSH
15530: LD_INT 22
15532: PUSH
15533: LD_INT 8
15535: PUSH
15536: EMPTY
15537: LIST
15538: LIST
15539: PUSH
15540: LD_INT 21
15542: PUSH
15543: LD_INT 2
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: PUSH
15550: LD_INT 1
15552: PUSH
15553: EMPTY
15554: LIST
15555: PUSH
15556: EMPTY
15557: LIST
15558: LIST
15559: LIST
15560: PPUSH
15561: CALL_OW 69
15565: ADD
15566: ST_TO_ADDR
// if tmp then
15567: LD_VAR 0 2
15571: IFFALSE 15724
// repeat wait ( 0 0$1 ) ;
15573: LD_INT 35
15575: PPUSH
15576: CALL_OW 67
// for i in tmp do
15580: LD_ADDR_VAR 0 1
15584: PUSH
15585: LD_VAR 0 2
15589: PUSH
15590: FOR_IN
15591: IFFALSE 15673
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15593: LD_VAR 0 1
15597: PPUSH
15598: CALL_OW 310
15602: PUSH
15603: LD_VAR 0 1
15607: PPUSH
15608: CALL_OW 310
15612: PPUSH
15613: CALL_OW 247
15617: PUSH
15618: LD_INT 3
15620: EQUAL
15621: AND
15622: IFFALSE 15633
// ComExitBuilding ( i ) ;
15624: LD_VAR 0 1
15628: PPUSH
15629: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15633: LD_VAR 0 1
15637: PPUSH
15638: LD_INT 10
15640: PPUSH
15641: LD_INT 1
15643: PPUSH
15644: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15648: LD_VAR 0 1
15652: PPUSH
15653: LD_INT 32
15655: PPUSH
15656: CALL_OW 308
15660: IFFALSE 15671
// RemoveUnit ( i ) ;
15662: LD_VAR 0 1
15666: PPUSH
15667: CALL_OW 64
// end ;
15671: GO 15590
15673: POP
15674: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15675: LD_INT 22
15677: PUSH
15678: LD_INT 8
15680: PUSH
15681: EMPTY
15682: LIST
15683: LIST
15684: PUSH
15685: LD_INT 2
15687: PUSH
15688: LD_INT 21
15690: PUSH
15691: LD_INT 1
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 33
15700: PUSH
15701: LD_INT 1
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: LIST
15712: PUSH
15713: EMPTY
15714: LIST
15715: LIST
15716: PPUSH
15717: CALL_OW 69
15721: NOT
15722: IFFALSE 15573
// end ;
15724: PPOPN 2
15726: END
// every 0 0$10 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated do var med1 , med2 ;
15727: LD_EXP 4
15731: PUSH
15732: LD_EXP 2
15736: AND
15737: PUSH
15738: LD_EXP 3
15742: AND
15743: PUSH
15744: LD_EXP 5
15748: AND
15749: PUSH
15750: LD_EXP 6
15754: AND
15755: PUSH
15756: LD_EXP 7
15760: AND
15761: PUSH
15762: LD_EXP 8
15766: AND
15767: IFFALSE 17151
15769: GO 15771
15771: DISABLE
15772: LD_INT 0
15774: PPUSH
15775: PPUSH
// begin music_class := 5 ;
15776: LD_ADDR_OWVAR 72
15780: PUSH
15781: LD_INT 5
15783: ST_TO_ADDR
// music_nat := 5 ;
15784: LD_ADDR_OWVAR 71
15788: PUSH
15789: LD_INT 5
15791: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15792: LD_EXP 15
15796: PUSH
15797: LD_INT 3
15799: LESS
15800: IFFALSE 15809
// SetAchievement ( ACH_ECONOMY ) ;
15802: LD_STRING ACH_ECONOMY
15804: PPUSH
15805: CALL_OW 543
// if tick < 60 60$00 then
15809: LD_OWVAR 1
15813: PUSH
15814: LD_INT 126000
15816: LESS
15817: IFFALSE 15833
// begin wait ( 3 ) ;
15819: LD_INT 3
15821: PPUSH
15822: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15826: LD_STRING ACH_ASPEED_19
15828: PPUSH
15829: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15833: LD_EXP 17
15837: PPUSH
15838: CALL_OW 87
// InGameOn ;
15842: CALL_OW 8
// DialogueOn ;
15846: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15850: LD_EXP 17
15854: PPUSH
15855: LD_STRING DEnd-JMM-JMM-1
15857: PPUSH
15858: CALL_OW 88
// if Joan then
15862: LD_EXP 32
15866: IFFALSE 15882
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15868: LD_EXP 32
15872: PPUSH
15873: LD_STRING DEnd-JMM-Joan-1
15875: PPUSH
15876: CALL_OW 88
15880: GO 15926
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15882: LD_EXP 19
15886: PUSH
15887: LD_EXP 19
15891: PPUSH
15892: CALL_OW 255
15896: PUSH
15897: LD_INT 7
15899: EQUAL
15900: AND
15901: PUSH
15902: LD_EXP 19
15906: PPUSH
15907: CALL_OW 305
15911: AND
15912: IFFALSE 15926
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15914: LD_EXP 19
15918: PPUSH
15919: LD_STRING DEnd-JMM-Lisa-1
15921: PPUSH
15922: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15926: LD_EXP 29
15930: PUSH
15931: LD_EXP 29
15935: PPUSH
15936: CALL_OW 305
15940: AND
15941: IFFALSE 15955
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15943: LD_EXP 29
15947: PPUSH
15948: LD_STRING DEnd-JMM-Frank-1
15950: PPUSH
15951: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15955: LD_EXP 22
15959: PUSH
15960: LD_EXP 22
15964: PPUSH
15965: CALL_OW 255
15969: PUSH
15970: LD_INT 7
15972: EQUAL
15973: AND
15974: PUSH
15975: LD_EXP 22
15979: PPUSH
15980: CALL_OW 305
15984: AND
15985: IFFALSE 15999
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15987: LD_EXP 22
15991: PPUSH
15992: LD_STRING DEnd-JMM-Cyrus-1
15994: PPUSH
15995: CALL_OW 88
// if Burlak then
15999: LD_EXP 49
16003: IFFALSE 16017
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16005: LD_EXP 49
16009: PPUSH
16010: LD_STRING DEnd-JMM-Bur-1
16012: PPUSH
16013: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16017: LD_EXP 32
16021: PUSH
16022: LD_EXP 19
16026: AND
16027: PUSH
16028: LD_EXP 19
16032: PPUSH
16033: CALL_OW 255
16037: PUSH
16038: LD_INT 7
16040: EQUAL
16041: AND
16042: PUSH
16043: LD_EXP 19
16047: PPUSH
16048: CALL_OW 305
16052: AND
16053: IFFALSE 16067
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16055: LD_EXP 19
16059: PPUSH
16060: LD_STRING DEnd-Burlak-Lisa-1
16062: PPUSH
16063: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16067: LD_EXP 50
16071: PUSH
16072: LD_EXP 50
16076: PPUSH
16077: CALL_OW 305
16081: AND
16082: IFFALSE 16096
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16084: LD_EXP 50
16088: PPUSH
16089: LD_STRING DEnd-JMM-Bel-1
16091: PPUSH
16092: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16096: LD_EXP 51
16100: PUSH
16101: LD_EXP 51
16105: PPUSH
16106: CALL_OW 305
16110: AND
16111: IFFALSE 16125
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16113: LD_EXP 51
16117: PPUSH
16118: LD_STRING DEnd-JMM-Gny-1
16120: PPUSH
16121: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16125: LD_EXP 27
16129: PUSH
16130: LD_EXP 27
16134: PPUSH
16135: CALL_OW 255
16139: PUSH
16140: LD_INT 7
16142: EQUAL
16143: AND
16144: PUSH
16145: LD_EXP 27
16149: PPUSH
16150: CALL_OW 305
16154: AND
16155: IFFALSE 16169
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16157: LD_EXP 27
16161: PPUSH
16162: LD_STRING DEnd-JMM-Corn-1
16164: PPUSH
16165: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16169: LD_EXP 20
16173: PUSH
16174: LD_EXP 20
16178: PPUSH
16179: CALL_OW 255
16183: PUSH
16184: LD_INT 7
16186: EQUAL
16187: AND
16188: PUSH
16189: LD_EXP 20
16193: PPUSH
16194: CALL_OW 305
16198: AND
16199: IFFALSE 16213
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16201: LD_EXP 20
16205: PPUSH
16206: LD_STRING DEnd-JMM-Don-1
16208: PPUSH
16209: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16213: LD_EXP 21
16217: PUSH
16218: LD_EXP 21
16222: PPUSH
16223: CALL_OW 255
16227: PUSH
16228: LD_INT 7
16230: EQUAL
16231: AND
16232: PUSH
16233: LD_EXP 21
16237: PPUSH
16238: CALL_OW 305
16242: AND
16243: IFFALSE 16257
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16245: LD_EXP 21
16249: PPUSH
16250: LD_STRING DEnd-JMM-Bobby-1
16252: PPUSH
16253: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16257: LD_EXP 23
16261: PUSH
16262: LD_EXP 23
16266: PPUSH
16267: CALL_OW 255
16271: PUSH
16272: LD_INT 7
16274: EQUAL
16275: AND
16276: PUSH
16277: LD_EXP 23
16281: PPUSH
16282: CALL_OW 305
16286: AND
16287: IFFALSE 16301
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16289: LD_EXP 23
16293: PPUSH
16294: LD_STRING DEnd-JMM-Den-1
16296: PPUSH
16297: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16301: LD_EXP 25
16305: PUSH
16306: LD_EXP 25
16310: PPUSH
16311: CALL_OW 255
16315: PUSH
16316: LD_INT 7
16318: EQUAL
16319: AND
16320: PUSH
16321: LD_EXP 25
16325: PPUSH
16326: CALL_OW 305
16330: AND
16331: IFFALSE 16345
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16333: LD_EXP 25
16337: PPUSH
16338: LD_STRING DEnd-JMM-Glad-1
16340: PPUSH
16341: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16345: LD_EXP 30
16349: PUSH
16350: LD_EXP 30
16354: PPUSH
16355: CALL_OW 255
16359: PUSH
16360: LD_INT 7
16362: EQUAL
16363: AND
16364: PUSH
16365: LD_EXP 30
16369: PPUSH
16370: CALL_OW 305
16374: AND
16375: IFFALSE 16389
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16377: LD_EXP 30
16381: PPUSH
16382: LD_STRING DEnd-JMM-Yam-1
16384: PPUSH
16385: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16389: LD_EXP 24
16393: PUSH
16394: LD_EXP 24
16398: PPUSH
16399: CALL_OW 255
16403: PUSH
16404: LD_INT 7
16406: EQUAL
16407: AND
16408: PUSH
16409: LD_EXP 24
16413: PPUSH
16414: CALL_OW 305
16418: AND
16419: IFFALSE 16433
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16421: LD_EXP 24
16425: PPUSH
16426: LD_STRING DEnd-JMM-Brown-1
16428: PPUSH
16429: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16433: LD_EXP 34
16437: PUSH
16438: LD_EXP 34
16442: PPUSH
16443: CALL_OW 255
16447: PUSH
16448: LD_INT 7
16450: EQUAL
16451: AND
16452: PUSH
16453: LD_EXP 34
16457: PPUSH
16458: CALL_OW 305
16462: AND
16463: IFFALSE 16477
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16465: LD_EXP 34
16469: PPUSH
16470: LD_STRING DEnd-JMM-Con-1
16472: PPUSH
16473: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16477: LD_EXP 28
16481: PUSH
16482: LD_EXP 28
16486: PPUSH
16487: CALL_OW 255
16491: PUSH
16492: LD_INT 7
16494: EQUAL
16495: AND
16496: PUSH
16497: LD_EXP 28
16501: PPUSH
16502: CALL_OW 305
16506: AND
16507: IFFALSE 16521
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16509: LD_EXP 28
16513: PPUSH
16514: LD_STRING DEnd-JMM-Gary-1
16516: PPUSH
16517: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16521: LD_EXP 31
16525: PUSH
16526: LD_EXP 18
16530: AND
16531: PUSH
16532: LD_EXP 31
16536: PPUSH
16537: CALL_OW 305
16541: AND
16542: IFFALSE 16556
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16544: LD_EXP 31
16548: PPUSH
16549: LD_STRING DEnd-JMM-Sim-1
16551: PPUSH
16552: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16556: LD_EXP 26
16560: PUSH
16561: LD_EXP 26
16565: PPUSH
16566: CALL_OW 255
16570: PUSH
16571: LD_INT 7
16573: EQUAL
16574: AND
16575: PUSH
16576: LD_EXP 26
16580: PPUSH
16581: CALL_OW 305
16585: AND
16586: IFFALSE 16600
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16588: LD_EXP 26
16592: PPUSH
16593: LD_STRING DEnd-JMM-VanH-1
16595: PPUSH
16596: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16600: LD_EXP 39
16604: PUSH
16605: LD_EXP 39
16609: PPUSH
16610: CALL_OW 305
16614: AND
16615: IFFALSE 16629
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16617: LD_EXP 39
16621: PPUSH
16622: LD_STRING DEnd-JMM-Dol-1
16624: PPUSH
16625: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16629: LD_EXP 43
16633: PUSH
16634: LD_EXP 43
16638: PPUSH
16639: CALL_OW 305
16643: AND
16644: IFFALSE 16658
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16646: LD_EXP 43
16650: PPUSH
16651: LD_STRING DEnd-JMM-Kap-1
16653: PPUSH
16654: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16658: LD_EXP 46
16662: PUSH
16663: LD_EXP 46
16667: PPUSH
16668: CALL_OW 305
16672: AND
16673: IFFALSE 16687
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16675: LD_EXP 46
16679: PPUSH
16680: LD_STRING DEnd-JMM-Kov-1
16682: PPUSH
16683: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16687: LD_EXP 41
16691: PUSH
16692: LD_EXP 41
16696: PPUSH
16697: CALL_OW 305
16701: AND
16702: IFFALSE 16716
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16704: LD_EXP 41
16708: PPUSH
16709: LD_STRING DEnd-JMM-Sch-1
16711: PPUSH
16712: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16716: LD_EXP 37
16720: PUSH
16721: LD_EXP 37
16725: PPUSH
16726: CALL_OW 305
16730: AND
16731: IFFALSE 16745
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16733: LD_EXP 37
16737: PPUSH
16738: LD_STRING DEnd-JMM-Tit-1
16740: PPUSH
16741: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16745: LD_EXP 42
16749: PUSH
16750: LD_EXP 42
16754: PPUSH
16755: CALL_OW 305
16759: AND
16760: IFFALSE 16774
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16762: LD_EXP 42
16766: PPUSH
16767: LD_STRING DEnd-JMM-Obl-1
16769: PPUSH
16770: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16774: LD_EXP 44
16778: PUSH
16779: LD_EXP 44
16783: PPUSH
16784: CALL_OW 305
16788: AND
16789: IFFALSE 16803
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16791: LD_EXP 44
16795: PPUSH
16796: LD_STRING DEnd-JMM-Lip-1
16798: PPUSH
16799: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16803: LD_EXP 38
16807: PUSH
16808: LD_EXP 38
16812: PPUSH
16813: CALL_OW 305
16817: AND
16818: PUSH
16819: LD_EXP 49
16823: AND
16824: IFFALSE 16838
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16826: LD_EXP 38
16830: PPUSH
16831: LD_STRING DEnd-Burlak-Fad-1
16833: PPUSH
16834: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16838: LD_EXP 45
16842: PUSH
16843: LD_EXP 45
16847: PPUSH
16848: CALL_OW 305
16852: AND
16853: IFFALSE 16867
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16855: LD_EXP 45
16859: PPUSH
16860: LD_STRING DEnd-Burlak-Ptr-1
16862: PPUSH
16863: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16867: LD_EXP 47
16871: PUSH
16872: LD_EXP 47
16876: PPUSH
16877: CALL_OW 305
16881: AND
16882: IFFALSE 16896
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16884: LD_EXP 47
16888: PPUSH
16889: LD_STRING DEnd-Burlak-Kuz-1
16891: PPUSH
16892: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16896: LD_EXP 36
16900: PUSH
16901: LD_EXP 36
16905: PPUSH
16906: CALL_OW 305
16910: AND
16911: PUSH
16912: LD_EXP 49
16916: AND
16917: IFFALSE 16931
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16919: LD_EXP 36
16923: PPUSH
16924: LD_STRING DEnd-Burlak-Kir-1
16926: PPUSH
16927: CALL_OW 88
// if Burlak then
16931: LD_EXP 49
16935: IFFALSE 16949
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16937: LD_EXP 17
16941: PPUSH
16942: LD_STRING DEnd-Burlak-JMM-1
16944: PPUSH
16945: CALL_OW 88
// dwait ( 0 0$2 ) ;
16949: LD_INT 70
16951: PPUSH
16952: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16956: LD_EXP 54
16960: PPUSH
16961: LD_STRING DEnd-Szulc
16963: PPUSH
16964: CALL_OW 94
// dwait ( 0 0$1 ) ;
16968: LD_INT 35
16970: PPUSH
16971: CALL_OW 68
// if IsLive ( Burlak ) then
16975: LD_EXP 49
16979: PPUSH
16980: CALL_OW 300
16984: IFFALSE 16996
// med1 := 1 else
16986: LD_ADDR_VAR 0 1
16990: PUSH
16991: LD_INT 1
16993: ST_TO_ADDR
16994: GO 17005
// med1 := - 1 ;
16996: LD_ADDR_VAR 0 1
17000: PUSH
17001: LD_INT 1
17003: NEG
17004: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17005: LD_EXP 12
17009: PUSH
17010: LD_EXP 13
17014: AND
17015: PUSH
17016: LD_EXP 14
17020: AND
17021: IFFALSE 17033
// med2 := 1 else
17023: LD_ADDR_VAR 0 2
17027: PUSH
17028: LD_INT 1
17030: ST_TO_ADDR
17031: GO 17042
// med2 := - 1 ;
17033: LD_ADDR_VAR 0 2
17037: PUSH
17038: LD_INT 1
17040: NEG
17041: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17042: LD_STRING Hero
17044: PPUSH
17045: LD_INT 1
17047: PPUSH
17048: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17052: LD_STRING Artefact
17054: PPUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17064: LD_STRING ReconcileBurlak
17066: PPUSH
17067: LD_VAR 0 1
17071: PPUSH
17072: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17076: LD_OWVAR 67
17080: PUSH
17081: LD_INT 3
17083: EQUAL
17084: PUSH
17085: LD_VAR 0 1
17089: PUSH
17090: LD_INT 1
17092: EQUAL
17093: AND
17094: PUSH
17095: LD_VAR 0 2
17099: PUSH
17100: LD_INT 1
17102: EQUAL
17103: AND
17104: IFFALSE 17116
// SetAchievementEX ( ACH_AMER , 19 ) ;
17106: LD_STRING ACH_AMER
17108: PPUSH
17109: LD_INT 19
17111: PPUSH
17112: CALL_OW 564
// GiveMedals ( MAIN ) ;
17116: LD_STRING MAIN
17118: PPUSH
17119: CALL_OW 102
// InGameOff ;
17123: CALL_OW 9
// DialogueOff ;
17127: CALL_OW 7
// music_nat := 1 ;
17131: LD_ADDR_OWVAR 71
17135: PUSH
17136: LD_INT 1
17138: ST_TO_ADDR
// music_class := 4 ;
17139: LD_ADDR_OWVAR 72
17143: PUSH
17144: LD_INT 4
17146: ST_TO_ADDR
// YouWin ;
17147: CALL_OW 103
// end ; end_of_file
17151: PPOPN 2
17153: END
// export function InitNature ; begin
17154: LD_INT 0
17156: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17157: LD_INT 3
17159: PPUSH
17160: LD_INT 3
17162: PPUSH
17163: LD_INT 2
17165: PPUSH
17166: LD_INT 1
17168: PPUSH
17169: LD_INT 1
17171: PPUSH
17172: LD_INT 0
17174: PPUSH
17175: LD_INT 0
17177: PPUSH
17178: LD_INT 17
17180: PPUSH
17181: LD_INT 0
17183: PPUSH
17184: CALL 85462 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17188: LD_INT 2
17190: PPUSH
17191: LD_INT 1
17193: PPUSH
17194: LD_INT 1
17196: PPUSH
17197: LD_INT 1
17199: PPUSH
17200: LD_INT 1
17202: PPUSH
17203: LD_INT 0
17205: PPUSH
17206: LD_INT 0
17208: PPUSH
17209: LD_INT 18
17211: PPUSH
17212: LD_INT 0
17214: PPUSH
17215: CALL 85462 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17219: LD_INT 4
17221: PPUSH
17222: LD_INT 1
17224: PPUSH
17225: LD_INT 2
17227: PPUSH
17228: LD_INT 4
17230: PPUSH
17231: LD_INT 2
17233: PPUSH
17234: LD_INT 1
17236: PPUSH
17237: LD_INT 0
17239: PPUSH
17240: LD_INT 19
17242: PPUSH
17243: LD_INT 0
17245: PPUSH
17246: CALL 85462 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17250: LD_INT 0
17252: PPUSH
17253: LD_INT 0
17255: PPUSH
17256: LD_INT 0
17258: PPUSH
17259: LD_INT 0
17261: PPUSH
17262: LD_INT 0
17264: PPUSH
17265: LD_INT 0
17267: PPUSH
17268: LD_INT 9
17270: PPUSH
17271: LD_INT 0
17273: PPUSH
17274: LD_INT 20
17276: PPUSH
17277: CALL 85462 0 9
// end ; end_of_file
17281: LD_VAR 0 1
17285: RET
// every 0 0$30 do var time ;
17286: GO 17288
17288: DISABLE
17289: LD_INT 0
17291: PPUSH
// begin time := 0 0$50 ;
17292: LD_ADDR_VAR 0 1
17296: PUSH
17297: LD_INT 1750
17299: ST_TO_ADDR
// repeat wait ( time ) ;
17300: LD_VAR 0 1
17304: PPUSH
17305: CALL_OW 67
// if Prob ( 50 ) then
17309: LD_INT 50
17311: PPUSH
17312: CALL_OW 13
17316: IFFALSE 17345
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17318: LD_INT 1
17320: PPUSH
17321: LD_INT 5
17323: PPUSH
17324: CALL_OW 12
17328: PPUSH
17329: LD_INT 106
17331: PPUSH
17332: LD_INT 89
17334: PPUSH
17335: LD_INT 45
17337: PPUSH
17338: LD_INT 1
17340: PPUSH
17341: CALL_OW 56
// time := time + 0 0$3 ;
17345: LD_ADDR_VAR 0 1
17349: PUSH
17350: LD_VAR 0 1
17354: PUSH
17355: LD_INT 105
17357: PLUS
17358: ST_TO_ADDR
// if Prob ( 30 ) then
17359: LD_INT 30
17361: PPUSH
17362: CALL_OW 13
17366: IFFALSE 17412
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17368: LD_INT 525
17370: PPUSH
17371: LD_INT 735
17373: PPUSH
17374: CALL_OW 12
17378: PPUSH
17379: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17383: LD_INT 1
17385: PPUSH
17386: LD_INT 5
17388: PPUSH
17389: CALL_OW 12
17393: PPUSH
17394: LD_INT 21
17396: PPUSH
17397: LD_INT 26
17399: PPUSH
17400: LD_INT 12
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: CALL_OW 56
// end else
17410: GO 17448
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17412: LD_INT 700
17414: PPUSH
17415: LD_INT 1225
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17427: LD_INT 1
17429: PPUSH
17430: LD_INT 5
17432: PPUSH
17433: CALL_OW 12
17437: PPUSH
17438: LD_INT 14
17440: PPUSH
17441: LD_INT 1
17443: PPUSH
17444: CALL_OW 55
// end ; if Prob ( 50 ) then
17448: LD_INT 50
17450: PPUSH
17451: CALL_OW 13
17455: IFFALSE 17501
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17457: LD_INT 700
17459: PPUSH
17460: LD_INT 1050
17462: PPUSH
17463: CALL_OW 12
17467: PPUSH
17468: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17472: LD_INT 1
17474: PPUSH
17475: LD_INT 5
17477: PPUSH
17478: CALL_OW 12
17482: PPUSH
17483: LD_INT 181
17485: PPUSH
17486: LD_INT 218
17488: PPUSH
17489: LD_INT 16
17491: PPUSH
17492: LD_INT 1
17494: PPUSH
17495: CALL_OW 56
// end else
17499: GO 17573
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17501: LD_INT 350
17503: PPUSH
17504: LD_INT 525
17506: PPUSH
17507: CALL_OW 12
17511: PPUSH
17512: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17516: LD_INT 1
17518: PPUSH
17519: LD_INT 5
17521: PPUSH
17522: CALL_OW 12
17526: PPUSH
17527: LD_INT 13
17529: PPUSH
17530: LD_INT 1
17532: PPUSH
17533: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17537: LD_INT 350
17539: PPUSH
17540: LD_INT 700
17542: PPUSH
17543: CALL_OW 12
17547: PPUSH
17548: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17552: LD_INT 1
17554: PPUSH
17555: LD_INT 5
17557: PPUSH
17558: CALL_OW 12
17562: PPUSH
17563: LD_INT 33
17565: PPUSH
17566: LD_INT 1
17568: PPUSH
17569: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17573: LD_INT 65
17575: PUSH
17576: LD_INT 62
17578: PUSH
17579: LD_INT 55
17581: PUSH
17582: EMPTY
17583: LIST
17584: LIST
17585: LIST
17586: PUSH
17587: LD_OWVAR 67
17591: ARRAY
17592: PPUSH
17593: CALL_OW 13
17597: IFFALSE 17643
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17599: LD_INT 525
17601: PPUSH
17602: LD_INT 875
17604: PPUSH
17605: CALL_OW 12
17609: PPUSH
17610: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17614: LD_INT 1
17616: PPUSH
17617: LD_INT 5
17619: PPUSH
17620: CALL_OW 12
17624: PPUSH
17625: LD_INT 294
17627: PPUSH
17628: LD_INT 211
17630: PPUSH
17631: LD_INT 30
17633: PPUSH
17634: LD_INT 1
17636: PPUSH
17637: CALL_OW 56
// end else
17641: GO 17685
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17643: LD_INT 420
17645: PPUSH
17646: LD_INT 770
17648: PPUSH
17649: CALL_OW 12
17653: PPUSH
17654: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17658: LD_INT 1
17660: PPUSH
17661: LD_INT 5
17663: PPUSH
17664: CALL_OW 12
17668: PPUSH
17669: LD_INT 294
17671: PPUSH
17672: LD_INT 211
17674: PPUSH
17675: LD_INT 30
17677: PPUSH
17678: LD_INT 1
17680: PPUSH
17681: CALL_OW 56
// end ; if time > 2 2$20 then
17685: LD_VAR 0 1
17689: PUSH
17690: LD_INT 4900
17692: GREATER
17693: IFFALSE 17703
// time := 0 0$50 ;
17695: LD_ADDR_VAR 0 1
17699: PUSH
17700: LD_INT 1750
17702: ST_TO_ADDR
// until false ;
17703: LD_INT 0
17705: IFFALSE 17300
// end ;
17707: PPOPN 1
17709: END
// every 0 0$45 trigger tick < 10 10$00 do
17710: LD_OWVAR 1
17714: PUSH
17715: LD_INT 21000
17717: LESS
17718: IFFALSE 17766
17720: GO 17722
17722: DISABLE
// begin enable ;
17723: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17724: LD_INT 350
17726: PPUSH
17727: LD_INT 700
17729: PPUSH
17730: CALL_OW 12
17734: PPUSH
17735: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17739: LD_INT 3
17741: PPUSH
17742: LD_INT 5
17744: PPUSH
17745: CALL_OW 12
17749: PPUSH
17750: LD_INT 181
17752: PPUSH
17753: LD_INT 13
17755: PPUSH
17756: LD_INT 20
17758: PPUSH
17759: LD_INT 1
17761: PPUSH
17762: CALL_OW 56
// end ; end_of_file
17766: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17767: LD_INT 0
17769: PPUSH
// SetArtifactRes ( 7 , true ) ;
17770: LD_INT 7
17772: PPUSH
17773: LD_INT 1
17775: PPUSH
17776: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17780: LD_ADDR_EXP 62
17784: PUSH
17785: EMPTY
17786: PUSH
17787: EMPTY
17788: PUSH
17789: EMPTY
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: LIST
17795: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17796: LD_ADDR_EXP 63
17800: PUSH
17801: LD_INT 1050
17803: PUSH
17804: LD_OWVAR 67
17808: MUL
17809: PUSH
17810: LD_INT 2800
17812: PUSH
17813: LD_OWVAR 67
17817: MUL
17818: PUSH
17819: LD_INT 1
17821: NEG
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: LIST
17827: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17828: LD_ADDR_EXP 64
17832: PUSH
17833: LD_INT 10
17835: PUSH
17836: LD_INT 35
17838: PUSH
17839: LD_INT 100
17841: PUSH
17842: EMPTY
17843: LIST
17844: LIST
17845: LIST
17846: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17847: LD_ADDR_EXP 65
17851: PUSH
17852: LD_INT 0
17854: PUSH
17855: LD_INT 0
17857: PUSH
17858: LD_INT 0
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17866: LD_ADDR_EXP 67
17870: PUSH
17871: LD_INT 300
17873: PUSH
17874: LD_INT 500
17876: PUSH
17877: LD_INT 800
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: LIST
17884: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17885: LD_ADDR_EXP 68
17889: PUSH
17890: LD_INT 0
17892: PUSH
17893: LD_INT 0
17895: PUSH
17896: LD_INT 0
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: LIST
17903: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17904: LD_ADDR_EXP 69
17908: PUSH
17909: LD_INT 0
17911: PUSH
17912: LD_INT 0
17914: PUSH
17915: LD_INT 0
17917: PUSH
17918: EMPTY
17919: LIST
17920: LIST
17921: LIST
17922: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17923: LD_ADDR_EXP 66
17927: PUSH
17928: LD_INT 0
17930: PUSH
17931: LD_INT 0
17933: PUSH
17934: LD_INT 0
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: LIST
17941: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17942: LD_ADDR_EXP 70
17946: PUSH
17947: LD_INT 4
17949: PUSH
17950: LD_INT 3
17952: PUSH
17953: LD_INT 1
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 5
17963: PUSH
17964: LD_INT 4
17966: PUSH
17967: LD_INT 2
17969: PUSH
17970: EMPTY
17971: LIST
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 6
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 3
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: LIST
17993: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17994: LD_ADDR_EXP 71
17998: PUSH
17999: LD_INT 0
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: EMPTY
18009: LIST
18010: LIST
18011: LIST
18012: ST_TO_ADDR
// end ;
18013: LD_VAR 0 1
18017: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18018: LD_INT 24
18020: PPUSH
18021: LD_INT 7
18023: PPUSH
18024: CALL_OW 321
18028: PUSH
18029: LD_INT 2
18031: EQUAL
18032: IFFALSE 18958
18034: GO 18036
18036: DISABLE
18037: LD_INT 0
18039: PPUSH
18040: PPUSH
18041: PPUSH
18042: PPUSH
18043: PPUSH
// begin enable ;
18044: ENABLE
// for i = 1 to 3 do
18045: LD_ADDR_VAR 0 1
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_INT 3
18057: PUSH
18058: FOR_TO
18059: IFFALSE 18956
// begin pos := FindArtifact ( i + 2 ) ;
18061: LD_ADDR_VAR 0 2
18065: PUSH
18066: LD_VAR 0 1
18070: PUSH
18071: LD_INT 2
18073: PLUS
18074: PPUSH
18075: CALL_OW 469
18079: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18080: LD_ADDR_EXP 62
18084: PUSH
18085: LD_EXP 62
18089: PPUSH
18090: LD_VAR 0 1
18094: PPUSH
18095: LD_VAR 0 2
18099: PPUSH
18100: CALL_OW 1
18104: ST_TO_ADDR
// if pos then
18105: LD_VAR 0 2
18109: IFFALSE 18817
// begin case i of 1 :
18111: LD_VAR 0 1
18115: PUSH
18116: LD_INT 1
18118: DOUBLE
18119: EQUAL
18120: IFTRUE 18124
18122: GO 18201
18124: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18125: LD_ADDR_VAR 0 4
18129: PUSH
18130: LD_INT 22
18132: PUSH
18133: LD_INT 7
18135: PUSH
18136: EMPTY
18137: LIST
18138: LIST
18139: PUSH
18140: LD_INT 23
18142: PUSH
18143: LD_INT 1
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: PUSH
18150: LD_INT 2
18152: PUSH
18153: LD_INT 30
18155: PUSH
18156: LD_INT 8
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: PUSH
18163: LD_INT 30
18165: PUSH
18166: LD_INT 7
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 30
18175: PUSH
18176: LD_INT 11
18178: PUSH
18179: EMPTY
18180: LIST
18181: LIST
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: LIST
18187: LIST
18188: PUSH
18189: EMPTY
18190: LIST
18191: LIST
18192: LIST
18193: PPUSH
18194: CALL_OW 69
18198: ST_TO_ADDR
18199: GO 18309
18201: LD_INT 2
18203: DOUBLE
18204: EQUAL
18205: IFTRUE 18209
18207: GO 18286
18209: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18210: LD_ADDR_VAR 0 4
18214: PUSH
18215: LD_INT 22
18217: PUSH
18218: LD_INT 7
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 23
18227: PUSH
18228: LD_INT 3
18230: PUSH
18231: EMPTY
18232: LIST
18233: LIST
18234: PUSH
18235: LD_INT 2
18237: PUSH
18238: LD_INT 30
18240: PUSH
18241: LD_INT 8
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PUSH
18248: LD_INT 30
18250: PUSH
18251: LD_INT 7
18253: PUSH
18254: EMPTY
18255: LIST
18256: LIST
18257: PUSH
18258: LD_INT 30
18260: PUSH
18261: LD_INT 11
18263: PUSH
18264: EMPTY
18265: LIST
18266: LIST
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: PUSH
18274: EMPTY
18275: LIST
18276: LIST
18277: LIST
18278: PPUSH
18279: CALL_OW 69
18283: ST_TO_ADDR
18284: GO 18309
18286: LD_INT 3
18288: DOUBLE
18289: EQUAL
18290: IFTRUE 18294
18292: GO 18308
18294: POP
// labs := [ alien ] ; end ;
18295: LD_ADDR_VAR 0 4
18299: PUSH
18300: LD_INT 1
18302: PUSH
18303: EMPTY
18304: LIST
18305: ST_TO_ADDR
18306: GO 18309
18308: POP
// if not labs then
18309: LD_VAR 0 4
18313: NOT
18314: IFFALSE 18318
// continue ;
18316: GO 18058
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18318: LD_ADDR_VAR 0 5
18322: PUSH
18323: LD_VAR 0 4
18327: PPUSH
18328: LD_EXP 62
18332: PUSH
18333: LD_VAR 0 1
18337: ARRAY
18338: PUSH
18339: LD_INT 1
18341: ARRAY
18342: PPUSH
18343: LD_EXP 62
18347: PUSH
18348: LD_VAR 0 1
18352: ARRAY
18353: PUSH
18354: LD_INT 2
18356: ARRAY
18357: PPUSH
18358: CALL_OW 73
18362: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18363: LD_VAR 0 5
18367: NOT
18368: PUSH
18369: LD_VAR 0 5
18373: PUSH
18374: LD_EXP 69
18378: PUSH
18379: LD_VAR 0 1
18383: ARRAY
18384: NONEQUAL
18385: OR
18386: IFFALSE 18491
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18388: LD_INT 7
18390: PPUSH
18391: LD_EXP 70
18395: PUSH
18396: LD_VAR 0 1
18400: ARRAY
18401: PUSH
18402: LD_INT 3
18404: ARRAY
18405: PPUSH
18406: LD_INT 0
18408: PPUSH
18409: LD_EXP 69
18413: PUSH
18414: LD_VAR 0 1
18418: ARRAY
18419: PPUSH
18420: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18424: LD_INT 7
18426: PPUSH
18427: LD_EXP 70
18431: PUSH
18432: LD_VAR 0 1
18436: ARRAY
18437: PUSH
18438: LD_INT 1
18440: ARRAY
18441: PPUSH
18442: LD_INT 0
18444: PPUSH
18445: LD_EXP 69
18449: PUSH
18450: LD_VAR 0 1
18454: ARRAY
18455: PPUSH
18456: CALL_OW 468
// if nearestLab then
18460: LD_VAR 0 5
18464: IFFALSE 18491
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18466: LD_ADDR_EXP 69
18470: PUSH
18471: LD_EXP 69
18475: PPUSH
18476: LD_VAR 0 1
18480: PPUSH
18481: LD_VAR 0 5
18485: PPUSH
18486: CALL_OW 1
18490: ST_TO_ADDR
// end ; if not nearestLab then
18491: LD_VAR 0 5
18495: NOT
18496: IFFALSE 18500
// continue ;
18498: GO 18058
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18500: LD_VAR 0 5
18504: PPUSH
18505: LD_EXP 62
18509: PUSH
18510: LD_VAR 0 1
18514: ARRAY
18515: PUSH
18516: LD_INT 1
18518: ARRAY
18519: PPUSH
18520: LD_EXP 62
18524: PUSH
18525: LD_VAR 0 1
18529: ARRAY
18530: PUSH
18531: LD_INT 2
18533: ARRAY
18534: PPUSH
18535: CALL_OW 297
18539: PUSH
18540: LD_INT 8
18542: LESS
18543: IFFALSE 18740
// begin if not artifactsResearched [ i ] then
18545: LD_EXP 65
18549: PUSH
18550: LD_VAR 0 1
18554: ARRAY
18555: NOT
18556: IFFALSE 18637
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18558: LD_VAR 0 5
18562: PPUSH
18563: CALL_OW 461
18567: PUSH
18568: LD_INT 2
18570: EQUAL
18571: IFFALSE 18605
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18573: LD_INT 7
18575: PPUSH
18576: LD_EXP 70
18580: PUSH
18581: LD_VAR 0 1
18585: ARRAY
18586: PUSH
18587: LD_INT 3
18589: ARRAY
18590: PPUSH
18591: LD_INT 2
18593: PPUSH
18594: LD_VAR 0 5
18598: PPUSH
18599: CALL_OW 468
18603: GO 18635
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18605: LD_INT 7
18607: PPUSH
18608: LD_EXP 70
18612: PUSH
18613: LD_VAR 0 1
18617: ARRAY
18618: PUSH
18619: LD_INT 3
18621: ARRAY
18622: PPUSH
18623: LD_INT 1
18625: PPUSH
18626: LD_VAR 0 5
18630: PPUSH
18631: CALL_OW 468
// end else
18635: GO 18738
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18637: LD_VAR 0 5
18641: PPUSH
18642: CALL_OW 461
18646: PUSH
18647: LD_INT 2
18649: EQUAL
18650: PUSH
18651: LD_EXP 71
18655: PUSH
18656: LD_VAR 0 1
18660: ARRAY
18661: AND
18662: IFFALSE 18708
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18664: LD_INT 7
18666: PPUSH
18667: LD_EXP 70
18671: PUSH
18672: LD_VAR 0 1
18676: ARRAY
18677: PUSH
18678: LD_INT 1
18680: ARRAY
18681: PPUSH
18682: LD_EXP 70
18686: PUSH
18687: LD_VAR 0 1
18691: ARRAY
18692: PUSH
18693: LD_INT 2
18695: ARRAY
18696: PPUSH
18697: LD_VAR 0 5
18701: PPUSH
18702: CALL_OW 468
18706: GO 18738
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18708: LD_INT 7
18710: PPUSH
18711: LD_EXP 70
18715: PUSH
18716: LD_VAR 0 1
18720: ARRAY
18721: PUSH
18722: LD_INT 1
18724: ARRAY
18725: PPUSH
18726: LD_INT 1
18728: PPUSH
18729: LD_VAR 0 5
18733: PPUSH
18734: CALL_OW 468
// end else
18738: GO 18815
// begin if not artifactsResearched [ i ] then
18740: LD_EXP 65
18744: PUSH
18745: LD_VAR 0 1
18749: ARRAY
18750: NOT
18751: IFFALSE 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18753: LD_INT 7
18755: PPUSH
18756: LD_EXP 70
18760: PUSH
18761: LD_VAR 0 1
18765: ARRAY
18766: PUSH
18767: LD_INT 3
18769: ARRAY
18770: PPUSH
18771: LD_INT 0
18773: PPUSH
18774: LD_VAR 0 5
18778: PPUSH
18779: CALL_OW 468
18783: GO 18815
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18785: LD_INT 7
18787: PPUSH
18788: LD_EXP 70
18792: PUSH
18793: LD_VAR 0 1
18797: ARRAY
18798: PUSH
18799: LD_INT 1
18801: ARRAY
18802: PPUSH
18803: LD_INT 0
18805: PPUSH
18806: LD_VAR 0 5
18810: PPUSH
18811: CALL_OW 468
// end ; end else
18815: GO 18954
// begin if not artifactsLabs [ i ] then
18817: LD_EXP 69
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: NOT
18828: IFFALSE 18832
// continue ;
18830: GO 18058
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18832: LD_INT 7
18834: PPUSH
18835: LD_EXP 70
18839: PUSH
18840: LD_VAR 0 1
18844: ARRAY
18845: PUSH
18846: LD_INT 3
18848: ARRAY
18849: PPUSH
18850: LD_INT 0
18852: PPUSH
18853: LD_EXP 69
18857: PUSH
18858: LD_VAR 0 1
18862: ARRAY
18863: PPUSH
18864: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18868: LD_INT 7
18870: PPUSH
18871: LD_EXP 70
18875: PUSH
18876: LD_VAR 0 1
18880: ARRAY
18881: PUSH
18882: LD_INT 1
18884: ARRAY
18885: PPUSH
18886: LD_INT 0
18888: PPUSH
18889: LD_EXP 69
18893: PUSH
18894: LD_VAR 0 1
18898: ARRAY
18899: PPUSH
18900: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18904: LD_EXP 66
18908: PUSH
18909: LD_VAR 0 1
18913: ARRAY
18914: IFFALSE 18954
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18916: LD_ADDR_EXP 66
18920: PUSH
18921: LD_EXP 66
18925: PPUSH
18926: LD_VAR 0 1
18930: PPUSH
18931: LD_INT 0
18933: PPUSH
18934: CALL_OW 1
18938: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18939: LD_EXP 69
18943: PUSH
18944: LD_VAR 0 1
18948: ARRAY
18949: PPUSH
18950: CALL_OW 127
// end ; end ; end ;
18954: GO 18058
18956: POP
18957: POP
// end ;
18958: PPOPN 5
18960: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18961: LD_INT 0
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18968: LD_VAR 0 2
18972: PUSH
18973: LD_EXP 70
18977: PUSH
18978: LD_INT 1
18980: ARRAY
18981: PUSH
18982: LD_INT 3
18984: ARRAY
18985: EQUAL
18986: IFFALSE 19109
// begin lab := artifactsLabs [ 1 ] ;
18988: LD_ADDR_VAR 0 6
18992: PUSH
18993: LD_EXP 69
18997: PUSH
18998: LD_INT 1
19000: ARRAY
19001: ST_TO_ADDR
// if not lab then
19002: LD_VAR 0 6
19006: NOT
19007: IFFALSE 19011
// exit ;
19009: GO 20078
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19011: LD_VAR 0 6
19015: PPUSH
19016: LD_EXP 67
19020: PUSH
19021: LD_INT 1
19023: ARRAY
19024: PPUSH
19025: LD_INT 1
19027: PPUSH
19028: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19032: LD_EXP 68
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: IFFALSE 19060
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19042: LD_VAR 0 6
19046: PPUSH
19047: LD_EXP 68
19051: PUSH
19052: LD_INT 1
19054: ARRAY
19055: PPUSH
19056: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19060: LD_ADDR_EXP 66
19064: PUSH
19065: LD_EXP 66
19069: PPUSH
19070: LD_INT 1
19072: PPUSH
19073: LD_INT 1
19075: PPUSH
19076: CALL_OW 1
19080: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19081: LD_INT 7
19083: PPUSH
19084: LD_EXP 70
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: PUSH
19093: LD_INT 3
19095: ARRAY
19096: PPUSH
19097: LD_INT 0
19099: PPUSH
19100: LD_VAR 0 6
19104: PPUSH
19105: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19109: LD_VAR 0 2
19113: PUSH
19114: LD_EXP 70
19118: PUSH
19119: LD_INT 2
19121: ARRAY
19122: PUSH
19123: LD_INT 3
19125: ARRAY
19126: EQUAL
19127: IFFALSE 19250
// begin lab := artifactsLabs [ 2 ] ;
19129: LD_ADDR_VAR 0 6
19133: PUSH
19134: LD_EXP 69
19138: PUSH
19139: LD_INT 2
19141: ARRAY
19142: ST_TO_ADDR
// if not lab then
19143: LD_VAR 0 6
19147: NOT
19148: IFFALSE 19152
// exit ;
19150: GO 20078
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19152: LD_VAR 0 6
19156: PPUSH
19157: LD_EXP 67
19161: PUSH
19162: LD_INT 2
19164: ARRAY
19165: PPUSH
19166: LD_INT 1
19168: PPUSH
19169: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19173: LD_EXP 68
19177: PUSH
19178: LD_INT 2
19180: ARRAY
19181: IFFALSE 19201
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19183: LD_VAR 0 6
19187: PPUSH
19188: LD_EXP 68
19192: PUSH
19193: LD_INT 2
19195: ARRAY
19196: PPUSH
19197: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19201: LD_ADDR_EXP 66
19205: PUSH
19206: LD_EXP 66
19210: PPUSH
19211: LD_INT 2
19213: PPUSH
19214: LD_INT 1
19216: PPUSH
19217: CALL_OW 1
19221: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19222: LD_INT 7
19224: PPUSH
19225: LD_EXP 70
19229: PUSH
19230: LD_INT 2
19232: ARRAY
19233: PUSH
19234: LD_INT 3
19236: ARRAY
19237: PPUSH
19238: LD_INT 0
19240: PPUSH
19241: LD_VAR 0 6
19245: PPUSH
19246: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19250: LD_VAR 0 2
19254: PUSH
19255: LD_EXP 70
19259: PUSH
19260: LD_INT 3
19262: ARRAY
19263: PUSH
19264: LD_INT 3
19266: ARRAY
19267: EQUAL
19268: IFFALSE 19391
// begin lab := artifactsLabs [ 3 ] ;
19270: LD_ADDR_VAR 0 6
19274: PUSH
19275: LD_EXP 69
19279: PUSH
19280: LD_INT 3
19282: ARRAY
19283: ST_TO_ADDR
// if not lab then
19284: LD_VAR 0 6
19288: NOT
19289: IFFALSE 19293
// exit ;
19291: GO 20078
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19293: LD_VAR 0 6
19297: PPUSH
19298: LD_EXP 67
19302: PUSH
19303: LD_INT 3
19305: ARRAY
19306: PPUSH
19307: LD_INT 1
19309: PPUSH
19310: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19314: LD_EXP 68
19318: PUSH
19319: LD_INT 3
19321: ARRAY
19322: IFFALSE 19342
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19324: LD_VAR 0 6
19328: PPUSH
19329: LD_EXP 68
19333: PUSH
19334: LD_INT 3
19336: ARRAY
19337: PPUSH
19338: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19342: LD_ADDR_EXP 66
19346: PUSH
19347: LD_EXP 66
19351: PPUSH
19352: LD_INT 3
19354: PPUSH
19355: LD_INT 1
19357: PPUSH
19358: CALL_OW 1
19362: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19363: LD_INT 7
19365: PPUSH
19366: LD_EXP 70
19370: PUSH
19371: LD_INT 3
19373: ARRAY
19374: PUSH
19375: LD_INT 3
19377: ARRAY
19378: PPUSH
19379: LD_INT 0
19381: PPUSH
19382: LD_VAR 0 6
19386: PPUSH
19387: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19391: LD_VAR 0 2
19395: PUSH
19396: LD_EXP 70
19400: PUSH
19401: LD_INT 1
19403: ARRAY
19404: PUSH
19405: LD_INT 1
19407: ARRAY
19408: EQUAL
19409: IFFALSE 19567
// begin lab := artifactsLabs [ 1 ] ;
19411: LD_ADDR_VAR 0 6
19415: PUSH
19416: LD_EXP 69
19420: PUSH
19421: LD_INT 1
19423: ARRAY
19424: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19425: LD_VAR 0 6
19429: PPUSH
19430: CALL_OW 274
19434: PPUSH
19435: CALL 93643 0 1
19439: PUSH
19440: LD_INT 3
19442: ARRAY
19443: PUSH
19444: LD_EXP 64
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: LESS
19453: IFFALSE 19467
// begin HintSpec ( ArtifactCost , 2 ) ;
19455: LD_STRING ArtifactCost
19457: PPUSH
19458: LD_INT 2
19460: PPUSH
19461: CALL_OW 338
// exit ;
19465: GO 20078
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19467: LD_ADDR_EXP 71
19471: PUSH
19472: LD_EXP 71
19476: PPUSH
19477: LD_INT 1
19479: PPUSH
19480: LD_INT 0
19482: PPUSH
19483: CALL_OW 1
19487: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19488: LD_VAR 0 3
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: LD_INT 7
19500: PPUSH
19501: LD_INT 12
19503: NEG
19504: PPUSH
19505: CALL_OW 330
// wait ( 0 0$30 ) ;
19509: LD_INT 1050
19511: PPUSH
19512: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19516: LD_VAR 0 3
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: LD_INT 7
19528: PPUSH
19529: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19533: LD_EXP 63
19537: PUSH
19538: LD_INT 1
19540: ARRAY
19541: PPUSH
19542: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19546: LD_ADDR_EXP 71
19550: PUSH
19551: LD_EXP 71
19555: PPUSH
19556: LD_INT 1
19558: PPUSH
19559: LD_INT 1
19561: PPUSH
19562: CALL_OW 1
19566: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19567: LD_VAR 0 2
19571: PUSH
19572: LD_EXP 70
19576: PUSH
19577: LD_INT 2
19579: ARRAY
19580: PUSH
19581: LD_INT 1
19583: ARRAY
19584: EQUAL
19585: IFFALSE 19811
// begin lab := artifactsLabs [ 2 ] ;
19587: LD_ADDR_VAR 0 6
19591: PUSH
19592: LD_EXP 69
19596: PUSH
19597: LD_INT 2
19599: ARRAY
19600: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19601: LD_VAR 0 3
19605: PUSH
19606: LD_INT 81
19608: PUSH
19609: LD_INT 7
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: PUSH
19616: LD_INT 2
19618: PUSH
19619: LD_INT 32
19621: PUSH
19622: LD_INT 3
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: PUSH
19629: LD_INT 30
19631: PUSH
19632: LD_INT 28
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: PUSH
19639: LD_INT 30
19641: PUSH
19642: LD_INT 30
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: PUSH
19649: LD_INT 35
19651: PUSH
19652: LD_INT 49
19654: PUSH
19655: EMPTY
19656: LIST
19657: LIST
19658: PUSH
19659: LD_INT 34
19661: PUSH
19662: LD_INT 49
19664: PUSH
19665: EMPTY
19666: LIST
19667: LIST
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: PUSH
19677: EMPTY
19678: LIST
19679: LIST
19680: PPUSH
19681: CALL_OW 69
19685: IN
19686: NOT
19687: IFFALSE 19691
// exit ;
19689: GO 20078
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19691: LD_VAR 0 6
19695: PPUSH
19696: CALL_OW 274
19700: PPUSH
19701: CALL 93643 0 1
19705: PUSH
19706: LD_INT 3
19708: ARRAY
19709: PUSH
19710: LD_EXP 64
19714: PUSH
19715: LD_INT 2
19717: ARRAY
19718: LESS
19719: IFFALSE 19733
// begin HintSpec ( ArtifactCost , 2 ) ;
19721: LD_STRING ArtifactCost
19723: PPUSH
19724: LD_INT 2
19726: PPUSH
19727: CALL_OW 338
// exit ;
19731: GO 20078
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19733: LD_ADDR_EXP 71
19737: PUSH
19738: LD_EXP 71
19742: PPUSH
19743: LD_INT 2
19745: PPUSH
19746: LD_INT 0
19748: PPUSH
19749: CALL_OW 1
19753: ST_TO_ADDR
// KillUnit ( x ) ;
19754: LD_VAR 0 3
19758: PPUSH
19759: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19763: LD_ADDR_EXP 16
19767: PUSH
19768: LD_EXP 16
19772: PUSH
19773: LD_INT 1
19775: PLUS
19776: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19777: LD_EXP 63
19781: PUSH
19782: LD_INT 2
19784: ARRAY
19785: PPUSH
19786: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19790: LD_ADDR_EXP 71
19794: PUSH
19795: LD_EXP 71
19799: PPUSH
19800: LD_INT 2
19802: PPUSH
19803: LD_INT 1
19805: PPUSH
19806: CALL_OW 1
19810: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19811: LD_VAR 0 2
19815: PUSH
19816: LD_EXP 70
19820: PUSH
19821: LD_INT 3
19823: ARRAY
19824: PUSH
19825: LD_INT 1
19827: ARRAY
19828: EQUAL
19829: IFFALSE 20078
// begin lab := artifactsLabs [ 3 ] ;
19831: LD_ADDR_VAR 0 6
19835: PUSH
19836: LD_EXP 69
19840: PUSH
19841: LD_INT 3
19843: ARRAY
19844: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19845: LD_VAR 0 6
19849: PPUSH
19850: CALL_OW 274
19854: PPUSH
19855: CALL 93643 0 1
19859: PUSH
19860: LD_INT 3
19862: ARRAY
19863: PUSH
19864: LD_EXP 64
19868: PUSH
19869: LD_INT 3
19871: ARRAY
19872: LESS
19873: IFFALSE 19887
// begin HintSpec ( ArtifactCost , 2 ) ;
19875: LD_STRING ArtifactCost
19877: PPUSH
19878: LD_INT 2
19880: PPUSH
19881: CALL_OW 338
// exit ;
19885: GO 20078
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19887: LD_INT 37
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 424
// time := 0 0$30 ;
19897: LD_ADDR_VAR 0 7
19901: PUSH
19902: LD_INT 1050
19904: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19905: LD_ADDR_EXP 71
19909: PUSH
19910: LD_EXP 71
19914: PPUSH
19915: LD_INT 3
19917: PPUSH
19918: LD_INT 0
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19926: LD_ADDR_OWVAR 47
19930: PUSH
19931: LD_STRING #Am15a-1
19933: PUSH
19934: LD_VAR 0 7
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19943: LD_INT 35
19945: PPUSH
19946: CALL_OW 67
// time := time - 0 0$1 ;
19950: LD_ADDR_VAR 0 7
19954: PUSH
19955: LD_VAR 0 7
19959: PUSH
19960: LD_INT 35
19962: MINUS
19963: ST_TO_ADDR
// until time = 0 0$00 ;
19964: LD_VAR 0 7
19968: PUSH
19969: LD_INT 0
19971: EQUAL
19972: IFFALSE 19926
// display_strings :=  ;
19974: LD_ADDR_OWVAR 47
19978: PUSH
19979: LD_STRING 
19981: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19982: LD_INT 37
19984: PPUSH
19985: LD_INT 0
19987: PPUSH
19988: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19992: LD_ADDR_VAR 0 8
19996: PUSH
19997: LD_INT 37
19999: PPUSH
20000: LD_INT 3
20002: PUSH
20003: LD_INT 21
20005: PUSH
20006: LD_INT 3
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: PPUSH
20017: CALL_OW 70
20021: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20022: LD_VAR 0 3
20026: PPUSH
20027: LD_VAR 0 4
20031: PPUSH
20032: CALL_OW 84
// for un in list do
20036: LD_ADDR_VAR 0 9
20040: PUSH
20041: LD_VAR 0 8
20045: PUSH
20046: FOR_IN
20047: IFFALSE 20076
// TeleportUnit ( un , x , y , 12 , true ) ;
20049: LD_VAR 0 9
20053: PPUSH
20054: LD_VAR 0 3
20058: PPUSH
20059: LD_VAR 0 4
20063: PPUSH
20064: LD_INT 12
20066: PPUSH
20067: LD_INT 1
20069: PPUSH
20070: CALL_OW 483
20074: GO 20046
20076: POP
20077: POP
// end ; end ;
20078: PPOPN 9
20080: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20081: LD_INT 0
20083: PPUSH
20084: PPUSH
// begin labNum := 0 ;
20085: LD_ADDR_VAR 0 4
20089: PUSH
20090: LD_INT 0
20092: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20093: LD_ADDR_VAR 0 3
20097: PUSH
20098: DOUBLE
20099: LD_INT 1
20101: DEC
20102: ST_TO_ADDR
20103: LD_EXP 69
20107: PUSH
20108: FOR_TO
20109: IFFALSE 20143
// if artifactsLabs [ i ] = lab then
20111: LD_EXP 69
20115: PUSH
20116: LD_VAR 0 3
20120: ARRAY
20121: PUSH
20122: LD_VAR 0 1
20126: EQUAL
20127: IFFALSE 20141
// begin labNum := i ;
20129: LD_ADDR_VAR 0 4
20133: PUSH
20134: LD_VAR 0 3
20138: ST_TO_ADDR
// break ;
20139: GO 20143
// end ;
20141: GO 20108
20143: POP
20144: POP
// if not labNum then
20145: LD_VAR 0 4
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20232
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20154: LD_INT 7
20156: PPUSH
20157: LD_EXP 70
20161: PUSH
20162: LD_VAR 0 4
20166: ARRAY
20167: PUSH
20168: LD_INT 3
20170: ARRAY
20171: PPUSH
20172: LD_INT 2
20174: PPUSH
20175: LD_VAR 0 1
20179: PPUSH
20180: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20184: LD_ADDR_EXP 68
20188: PUSH
20189: LD_EXP 68
20193: PPUSH
20194: LD_VAR 0 4
20198: PPUSH
20199: LD_VAR 0 2
20203: PPUSH
20204: CALL_OW 1
20208: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20209: LD_ADDR_EXP 66
20213: PUSH
20214: LD_EXP 66
20218: PPUSH
20219: LD_VAR 0 4
20223: PPUSH
20224: LD_INT 0
20226: PPUSH
20227: CALL_OW 1
20231: ST_TO_ADDR
// end ;
20232: PPOPN 4
20234: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20235: LD_INT 0
20237: PPUSH
20238: PPUSH
// begin labNum := 0 ;
20239: LD_ADDR_VAR 0 3
20243: PUSH
20244: LD_INT 0
20246: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20247: LD_ADDR_VAR 0 2
20251: PUSH
20252: DOUBLE
20253: LD_INT 1
20255: DEC
20256: ST_TO_ADDR
20257: LD_EXP 69
20261: PUSH
20262: FOR_TO
20263: IFFALSE 20297
// if artifactsLabs [ i ] = lab then
20265: LD_EXP 69
20269: PUSH
20270: LD_VAR 0 2
20274: ARRAY
20275: PUSH
20276: LD_VAR 0 1
20280: EQUAL
20281: IFFALSE 20295
// begin labNum := i ;
20283: LD_ADDR_VAR 0 3
20287: PUSH
20288: LD_VAR 0 2
20292: ST_TO_ADDR
// break ;
20293: GO 20297
// end ;
20295: GO 20262
20297: POP
20298: POP
// if not labNum then
20299: LD_VAR 0 3
20303: NOT
20304: IFFALSE 20308
// exit ;
20306: GO 20470
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20308: LD_INT 7
20310: PPUSH
20311: LD_EXP 70
20315: PUSH
20316: LD_VAR 0 3
20320: ARRAY
20321: PUSH
20322: LD_INT 3
20324: ARRAY
20325: PPUSH
20326: LD_INT 0
20328: PPUSH
20329: LD_VAR 0 1
20333: PPUSH
20334: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20338: LD_ADDR_EXP 65
20342: PUSH
20343: LD_EXP 65
20347: PPUSH
20348: LD_VAR 0 3
20352: PPUSH
20353: LD_INT 1
20355: PPUSH
20356: CALL_OW 1
20360: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20361: LD_ADDR_EXP 71
20365: PUSH
20366: LD_EXP 71
20370: PPUSH
20371: LD_VAR 0 3
20375: PPUSH
20376: LD_INT 1
20378: PPUSH
20379: CALL_OW 1
20383: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20384: LD_ADDR_EXP 66
20388: PUSH
20389: LD_EXP 66
20393: PPUSH
20394: LD_VAR 0 3
20398: PPUSH
20399: LD_INT 0
20401: PPUSH
20402: CALL_OW 1
20406: ST_TO_ADDR
// case labNum of 1 :
20407: LD_VAR 0 3
20411: PUSH
20412: LD_INT 1
20414: DOUBLE
20415: EQUAL
20416: IFTRUE 20420
20418: GO 20431
20420: POP
// artifactIResearched := true ; 2 :
20421: LD_ADDR_EXP 12
20425: PUSH
20426: LD_INT 1
20428: ST_TO_ADDR
20429: GO 20470
20431: LD_INT 2
20433: DOUBLE
20434: EQUAL
20435: IFTRUE 20439
20437: GO 20450
20439: POP
// artifactIIResearched := true ; 3 :
20440: LD_ADDR_EXP 13
20444: PUSH
20445: LD_INT 1
20447: ST_TO_ADDR
20448: GO 20470
20450: LD_INT 3
20452: DOUBLE
20453: EQUAL
20454: IFTRUE 20458
20456: GO 20469
20458: POP
// artifactIIIResearched := true ; end ;
20459: LD_ADDR_EXP 14
20463: PUSH
20464: LD_INT 1
20466: ST_TO_ADDR
20467: GO 20470
20469: POP
// end ; end_of_file
20470: PPOPN 3
20472: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20473: GO 20475
20475: DISABLE
// begin ru_radar := 98 ;
20476: LD_ADDR_EXP 72
20480: PUSH
20481: LD_INT 98
20483: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20484: LD_ADDR_EXP 73
20488: PUSH
20489: LD_INT 89
20491: ST_TO_ADDR
// us_hack := 99 ;
20492: LD_ADDR_EXP 74
20496: PUSH
20497: LD_INT 99
20499: ST_TO_ADDR
// us_artillery := 97 ;
20500: LD_ADDR_EXP 75
20504: PUSH
20505: LD_INT 97
20507: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20508: LD_ADDR_EXP 76
20512: PUSH
20513: LD_INT 91
20515: ST_TO_ADDR
// end ; end_of_file
20516: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20517: LD_INT 0
20519: PPUSH
20520: PPUSH
// skirmish := false ;
20521: LD_ADDR_EXP 77
20525: PUSH
20526: LD_INT 0
20528: ST_TO_ADDR
// debug_mc := false ;
20529: LD_ADDR_EXP 78
20533: PUSH
20534: LD_INT 0
20536: ST_TO_ADDR
// mc_bases := [ ] ;
20537: LD_ADDR_EXP 79
20541: PUSH
20542: EMPTY
20543: ST_TO_ADDR
// mc_sides := [ ] ;
20544: LD_ADDR_EXP 105
20548: PUSH
20549: EMPTY
20550: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20551: LD_ADDR_EXP 80
20555: PUSH
20556: EMPTY
20557: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20558: LD_ADDR_EXP 81
20562: PUSH
20563: EMPTY
20564: ST_TO_ADDR
// mc_need_heal := [ ] ;
20565: LD_ADDR_EXP 82
20569: PUSH
20570: EMPTY
20571: ST_TO_ADDR
// mc_healers := [ ] ;
20572: LD_ADDR_EXP 83
20576: PUSH
20577: EMPTY
20578: ST_TO_ADDR
// mc_build_list := [ ] ;
20579: LD_ADDR_EXP 84
20583: PUSH
20584: EMPTY
20585: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20586: LD_ADDR_EXP 111
20590: PUSH
20591: EMPTY
20592: ST_TO_ADDR
// mc_builders := [ ] ;
20593: LD_ADDR_EXP 85
20597: PUSH
20598: EMPTY
20599: ST_TO_ADDR
// mc_construct_list := [ ] ;
20600: LD_ADDR_EXP 86
20604: PUSH
20605: EMPTY
20606: ST_TO_ADDR
// mc_turret_list := [ ] ;
20607: LD_ADDR_EXP 87
20611: PUSH
20612: EMPTY
20613: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20614: LD_ADDR_EXP 88
20618: PUSH
20619: EMPTY
20620: ST_TO_ADDR
// mc_miners := [ ] ;
20621: LD_ADDR_EXP 93
20625: PUSH
20626: EMPTY
20627: ST_TO_ADDR
// mc_mines := [ ] ;
20628: LD_ADDR_EXP 92
20632: PUSH
20633: EMPTY
20634: ST_TO_ADDR
// mc_minefields := [ ] ;
20635: LD_ADDR_EXP 94
20639: PUSH
20640: EMPTY
20641: ST_TO_ADDR
// mc_crates := [ ] ;
20642: LD_ADDR_EXP 95
20646: PUSH
20647: EMPTY
20648: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20649: LD_ADDR_EXP 96
20653: PUSH
20654: EMPTY
20655: ST_TO_ADDR
// mc_crates_area := [ ] ;
20656: LD_ADDR_EXP 97
20660: PUSH
20661: EMPTY
20662: ST_TO_ADDR
// mc_vehicles := [ ] ;
20663: LD_ADDR_EXP 98
20667: PUSH
20668: EMPTY
20669: ST_TO_ADDR
// mc_attack := [ ] ;
20670: LD_ADDR_EXP 99
20674: PUSH
20675: EMPTY
20676: ST_TO_ADDR
// mc_produce := [ ] ;
20677: LD_ADDR_EXP 100
20681: PUSH
20682: EMPTY
20683: ST_TO_ADDR
// mc_defender := [ ] ;
20684: LD_ADDR_EXP 101
20688: PUSH
20689: EMPTY
20690: ST_TO_ADDR
// mc_parking := [ ] ;
20691: LD_ADDR_EXP 103
20695: PUSH
20696: EMPTY
20697: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20698: LD_ADDR_EXP 89
20702: PUSH
20703: EMPTY
20704: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20705: LD_ADDR_EXP 91
20709: PUSH
20710: EMPTY
20711: ST_TO_ADDR
// mc_scan := [ ] ;
20712: LD_ADDR_EXP 102
20716: PUSH
20717: EMPTY
20718: ST_TO_ADDR
// mc_scan_area := [ ] ;
20719: LD_ADDR_EXP 104
20723: PUSH
20724: EMPTY
20725: ST_TO_ADDR
// mc_tech := [ ] ;
20726: LD_ADDR_EXP 106
20730: PUSH
20731: EMPTY
20732: ST_TO_ADDR
// mc_class := [ ] ;
20733: LD_ADDR_EXP 120
20737: PUSH
20738: EMPTY
20739: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20740: LD_ADDR_EXP 121
20744: PUSH
20745: EMPTY
20746: ST_TO_ADDR
// end ;
20747: LD_VAR 0 1
20751: RET
// export function MC_Kill ( base ) ; begin
20752: LD_INT 0
20754: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20755: LD_ADDR_EXP 79
20759: PUSH
20760: LD_EXP 79
20764: PPUSH
20765: LD_VAR 0 1
20769: PPUSH
20770: EMPTY
20771: PPUSH
20772: CALL_OW 1
20776: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20777: LD_ADDR_EXP 80
20781: PUSH
20782: LD_EXP 80
20786: PPUSH
20787: LD_VAR 0 1
20791: PPUSH
20792: EMPTY
20793: PPUSH
20794: CALL_OW 1
20798: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20799: LD_ADDR_EXP 81
20803: PUSH
20804: LD_EXP 81
20808: PPUSH
20809: LD_VAR 0 1
20813: PPUSH
20814: EMPTY
20815: PPUSH
20816: CALL_OW 1
20820: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20821: LD_ADDR_EXP 82
20825: PUSH
20826: LD_EXP 82
20830: PPUSH
20831: LD_VAR 0 1
20835: PPUSH
20836: EMPTY
20837: PPUSH
20838: CALL_OW 1
20842: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20843: LD_ADDR_EXP 83
20847: PUSH
20848: LD_EXP 83
20852: PPUSH
20853: LD_VAR 0 1
20857: PPUSH
20858: EMPTY
20859: PPUSH
20860: CALL_OW 1
20864: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20865: LD_ADDR_EXP 84
20869: PUSH
20870: LD_EXP 84
20874: PPUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: EMPTY
20881: PPUSH
20882: CALL_OW 1
20886: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20887: LD_ADDR_EXP 85
20891: PUSH
20892: LD_EXP 85
20896: PPUSH
20897: LD_VAR 0 1
20901: PPUSH
20902: EMPTY
20903: PPUSH
20904: CALL_OW 1
20908: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20909: LD_ADDR_EXP 86
20913: PUSH
20914: LD_EXP 86
20918: PPUSH
20919: LD_VAR 0 1
20923: PPUSH
20924: EMPTY
20925: PPUSH
20926: CALL_OW 1
20930: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20931: LD_ADDR_EXP 87
20935: PUSH
20936: LD_EXP 87
20940: PPUSH
20941: LD_VAR 0 1
20945: PPUSH
20946: EMPTY
20947: PPUSH
20948: CALL_OW 1
20952: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20953: LD_ADDR_EXP 88
20957: PUSH
20958: LD_EXP 88
20962: PPUSH
20963: LD_VAR 0 1
20967: PPUSH
20968: EMPTY
20969: PPUSH
20970: CALL_OW 1
20974: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20975: LD_ADDR_EXP 89
20979: PUSH
20980: LD_EXP 89
20984: PPUSH
20985: LD_VAR 0 1
20989: PPUSH
20990: EMPTY
20991: PPUSH
20992: CALL_OW 1
20996: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20997: LD_ADDR_EXP 90
21001: PUSH
21002: LD_EXP 90
21006: PPUSH
21007: LD_VAR 0 1
21011: PPUSH
21012: LD_INT 0
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21020: LD_ADDR_EXP 91
21024: PUSH
21025: LD_EXP 91
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21042: LD_ADDR_EXP 92
21046: PUSH
21047: LD_EXP 92
21051: PPUSH
21052: LD_VAR 0 1
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21064: LD_ADDR_EXP 93
21068: PUSH
21069: LD_EXP 93
21073: PPUSH
21074: LD_VAR 0 1
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21086: LD_ADDR_EXP 94
21090: PUSH
21091: LD_EXP 94
21095: PPUSH
21096: LD_VAR 0 1
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21108: LD_ADDR_EXP 95
21112: PUSH
21113: LD_EXP 95
21117: PPUSH
21118: LD_VAR 0 1
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21130: LD_ADDR_EXP 96
21134: PUSH
21135: LD_EXP 96
21139: PPUSH
21140: LD_VAR 0 1
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21152: LD_ADDR_EXP 97
21156: PUSH
21157: LD_EXP 97
21161: PPUSH
21162: LD_VAR 0 1
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21174: LD_ADDR_EXP 98
21178: PUSH
21179: LD_EXP 98
21183: PPUSH
21184: LD_VAR 0 1
21188: PPUSH
21189: EMPTY
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21196: LD_ADDR_EXP 99
21200: PUSH
21201: LD_EXP 99
21205: PPUSH
21206: LD_VAR 0 1
21210: PPUSH
21211: EMPTY
21212: PPUSH
21213: CALL_OW 1
21217: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21218: LD_ADDR_EXP 100
21222: PUSH
21223: LD_EXP 100
21227: PPUSH
21228: LD_VAR 0 1
21232: PPUSH
21233: EMPTY
21234: PPUSH
21235: CALL_OW 1
21239: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21240: LD_ADDR_EXP 101
21244: PUSH
21245: LD_EXP 101
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: EMPTY
21256: PPUSH
21257: CALL_OW 1
21261: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21262: LD_ADDR_EXP 102
21266: PUSH
21267: LD_EXP 102
21271: PPUSH
21272: LD_VAR 0 1
21276: PPUSH
21277: EMPTY
21278: PPUSH
21279: CALL_OW 1
21283: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21284: LD_ADDR_EXP 103
21288: PUSH
21289: LD_EXP 103
21293: PPUSH
21294: LD_VAR 0 1
21298: PPUSH
21299: EMPTY
21300: PPUSH
21301: CALL_OW 1
21305: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21306: LD_ADDR_EXP 104
21310: PUSH
21311: LD_EXP 104
21315: PPUSH
21316: LD_VAR 0 1
21320: PPUSH
21321: EMPTY
21322: PPUSH
21323: CALL_OW 1
21327: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21328: LD_ADDR_EXP 106
21332: PUSH
21333: LD_EXP 106
21337: PPUSH
21338: LD_VAR 0 1
21342: PPUSH
21343: EMPTY
21344: PPUSH
21345: CALL_OW 1
21349: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21350: LD_ADDR_EXP 108
21354: PUSH
21355: LD_EXP 108
21359: PPUSH
21360: LD_VAR 0 1
21364: PPUSH
21365: EMPTY
21366: PPUSH
21367: CALL_OW 1
21371: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21372: LD_ADDR_EXP 109
21376: PUSH
21377: LD_EXP 109
21381: PPUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: EMPTY
21388: PPUSH
21389: CALL_OW 1
21393: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21394: LD_ADDR_EXP 110
21398: PUSH
21399: LD_EXP 110
21403: PPUSH
21404: LD_VAR 0 1
21408: PPUSH
21409: EMPTY
21410: PPUSH
21411: CALL_OW 1
21415: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21416: LD_ADDR_EXP 111
21420: PUSH
21421: LD_EXP 111
21425: PPUSH
21426: LD_VAR 0 1
21430: PPUSH
21431: EMPTY
21432: PPUSH
21433: CALL_OW 1
21437: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21438: LD_ADDR_EXP 112
21442: PUSH
21443: LD_EXP 112
21447: PPUSH
21448: LD_VAR 0 1
21452: PPUSH
21453: EMPTY
21454: PPUSH
21455: CALL_OW 1
21459: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21460: LD_ADDR_EXP 113
21464: PUSH
21465: LD_EXP 113
21469: PPUSH
21470: LD_VAR 0 1
21474: PPUSH
21475: EMPTY
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21482: LD_ADDR_EXP 114
21486: PUSH
21487: LD_EXP 114
21491: PPUSH
21492: LD_VAR 0 1
21496: PPUSH
21497: EMPTY
21498: PPUSH
21499: CALL_OW 1
21503: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21504: LD_ADDR_EXP 115
21508: PUSH
21509: LD_EXP 115
21513: PPUSH
21514: LD_VAR 0 1
21518: PPUSH
21519: EMPTY
21520: PPUSH
21521: CALL_OW 1
21525: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21526: LD_ADDR_EXP 116
21530: PUSH
21531: LD_EXP 116
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: EMPTY
21542: PPUSH
21543: CALL_OW 1
21547: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21548: LD_ADDR_EXP 117
21552: PUSH
21553: LD_EXP 117
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: EMPTY
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21570: LD_ADDR_EXP 118
21574: PUSH
21575: LD_EXP 118
21579: PPUSH
21580: LD_VAR 0 1
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21592: LD_ADDR_EXP 119
21596: PUSH
21597: LD_EXP 119
21601: PPUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21614: LD_ADDR_EXP 120
21618: PUSH
21619: LD_EXP 120
21623: PPUSH
21624: LD_VAR 0 1
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21636: LD_ADDR_EXP 121
21640: PUSH
21641: LD_EXP 121
21645: PPUSH
21646: LD_VAR 0 1
21650: PPUSH
21651: LD_INT 0
21653: PPUSH
21654: CALL_OW 1
21658: ST_TO_ADDR
// end ;
21659: LD_VAR 0 2
21663: RET
// export function MC_Add ( side , units ) ; var base ; begin
21664: LD_INT 0
21666: PPUSH
21667: PPUSH
// base := mc_bases + 1 ;
21668: LD_ADDR_VAR 0 4
21672: PUSH
21673: LD_EXP 79
21677: PUSH
21678: LD_INT 1
21680: PLUS
21681: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21682: LD_ADDR_EXP 105
21686: PUSH
21687: LD_EXP 105
21691: PPUSH
21692: LD_VAR 0 4
21696: PPUSH
21697: LD_VAR 0 1
21701: PPUSH
21702: CALL_OW 1
21706: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21707: LD_ADDR_EXP 79
21711: PUSH
21712: LD_EXP 79
21716: PPUSH
21717: LD_VAR 0 4
21721: PPUSH
21722: LD_VAR 0 2
21726: PPUSH
21727: CALL_OW 1
21731: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21732: LD_ADDR_EXP 80
21736: PUSH
21737: LD_EXP 80
21741: PPUSH
21742: LD_VAR 0 4
21746: PPUSH
21747: EMPTY
21748: PPUSH
21749: CALL_OW 1
21753: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21754: LD_ADDR_EXP 81
21758: PUSH
21759: LD_EXP 81
21763: PPUSH
21764: LD_VAR 0 4
21768: PPUSH
21769: EMPTY
21770: PPUSH
21771: CALL_OW 1
21775: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21776: LD_ADDR_EXP 82
21780: PUSH
21781: LD_EXP 82
21785: PPUSH
21786: LD_VAR 0 4
21790: PPUSH
21791: EMPTY
21792: PPUSH
21793: CALL_OW 1
21797: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21798: LD_ADDR_EXP 83
21802: PUSH
21803: LD_EXP 83
21807: PPUSH
21808: LD_VAR 0 4
21812: PPUSH
21813: EMPTY
21814: PPUSH
21815: CALL_OW 1
21819: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21820: LD_ADDR_EXP 84
21824: PUSH
21825: LD_EXP 84
21829: PPUSH
21830: LD_VAR 0 4
21834: PPUSH
21835: EMPTY
21836: PPUSH
21837: CALL_OW 1
21841: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21842: LD_ADDR_EXP 85
21846: PUSH
21847: LD_EXP 85
21851: PPUSH
21852: LD_VAR 0 4
21856: PPUSH
21857: EMPTY
21858: PPUSH
21859: CALL_OW 1
21863: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21864: LD_ADDR_EXP 86
21868: PUSH
21869: LD_EXP 86
21873: PPUSH
21874: LD_VAR 0 4
21878: PPUSH
21879: EMPTY
21880: PPUSH
21881: CALL_OW 1
21885: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21886: LD_ADDR_EXP 87
21890: PUSH
21891: LD_EXP 87
21895: PPUSH
21896: LD_VAR 0 4
21900: PPUSH
21901: EMPTY
21902: PPUSH
21903: CALL_OW 1
21907: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21908: LD_ADDR_EXP 88
21912: PUSH
21913: LD_EXP 88
21917: PPUSH
21918: LD_VAR 0 4
21922: PPUSH
21923: EMPTY
21924: PPUSH
21925: CALL_OW 1
21929: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21930: LD_ADDR_EXP 89
21934: PUSH
21935: LD_EXP 89
21939: PPUSH
21940: LD_VAR 0 4
21944: PPUSH
21945: EMPTY
21946: PPUSH
21947: CALL_OW 1
21951: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21952: LD_ADDR_EXP 90
21956: PUSH
21957: LD_EXP 90
21961: PPUSH
21962: LD_VAR 0 4
21966: PPUSH
21967: LD_INT 0
21969: PPUSH
21970: CALL_OW 1
21974: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21975: LD_ADDR_EXP 91
21979: PUSH
21980: LD_EXP 91
21984: PPUSH
21985: LD_VAR 0 4
21989: PPUSH
21990: EMPTY
21991: PPUSH
21992: CALL_OW 1
21996: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21997: LD_ADDR_EXP 92
22001: PUSH
22002: LD_EXP 92
22006: PPUSH
22007: LD_VAR 0 4
22011: PPUSH
22012: EMPTY
22013: PPUSH
22014: CALL_OW 1
22018: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22019: LD_ADDR_EXP 93
22023: PUSH
22024: LD_EXP 93
22028: PPUSH
22029: LD_VAR 0 4
22033: PPUSH
22034: EMPTY
22035: PPUSH
22036: CALL_OW 1
22040: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22041: LD_ADDR_EXP 94
22045: PUSH
22046: LD_EXP 94
22050: PPUSH
22051: LD_VAR 0 4
22055: PPUSH
22056: EMPTY
22057: PPUSH
22058: CALL_OW 1
22062: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22063: LD_ADDR_EXP 95
22067: PUSH
22068: LD_EXP 95
22072: PPUSH
22073: LD_VAR 0 4
22077: PPUSH
22078: EMPTY
22079: PPUSH
22080: CALL_OW 1
22084: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22085: LD_ADDR_EXP 96
22089: PUSH
22090: LD_EXP 96
22094: PPUSH
22095: LD_VAR 0 4
22099: PPUSH
22100: EMPTY
22101: PPUSH
22102: CALL_OW 1
22106: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22107: LD_ADDR_EXP 97
22111: PUSH
22112: LD_EXP 97
22116: PPUSH
22117: LD_VAR 0 4
22121: PPUSH
22122: EMPTY
22123: PPUSH
22124: CALL_OW 1
22128: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22129: LD_ADDR_EXP 98
22133: PUSH
22134: LD_EXP 98
22138: PPUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: EMPTY
22145: PPUSH
22146: CALL_OW 1
22150: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22151: LD_ADDR_EXP 99
22155: PUSH
22156: LD_EXP 99
22160: PPUSH
22161: LD_VAR 0 4
22165: PPUSH
22166: EMPTY
22167: PPUSH
22168: CALL_OW 1
22172: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22173: LD_ADDR_EXP 100
22177: PUSH
22178: LD_EXP 100
22182: PPUSH
22183: LD_VAR 0 4
22187: PPUSH
22188: EMPTY
22189: PPUSH
22190: CALL_OW 1
22194: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22195: LD_ADDR_EXP 101
22199: PUSH
22200: LD_EXP 101
22204: PPUSH
22205: LD_VAR 0 4
22209: PPUSH
22210: EMPTY
22211: PPUSH
22212: CALL_OW 1
22216: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22217: LD_ADDR_EXP 102
22221: PUSH
22222: LD_EXP 102
22226: PPUSH
22227: LD_VAR 0 4
22231: PPUSH
22232: EMPTY
22233: PPUSH
22234: CALL_OW 1
22238: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22239: LD_ADDR_EXP 103
22243: PUSH
22244: LD_EXP 103
22248: PPUSH
22249: LD_VAR 0 4
22253: PPUSH
22254: EMPTY
22255: PPUSH
22256: CALL_OW 1
22260: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22261: LD_ADDR_EXP 104
22265: PUSH
22266: LD_EXP 104
22270: PPUSH
22271: LD_VAR 0 4
22275: PPUSH
22276: EMPTY
22277: PPUSH
22278: CALL_OW 1
22282: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22283: LD_ADDR_EXP 106
22287: PUSH
22288: LD_EXP 106
22292: PPUSH
22293: LD_VAR 0 4
22297: PPUSH
22298: EMPTY
22299: PPUSH
22300: CALL_OW 1
22304: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22305: LD_ADDR_EXP 108
22309: PUSH
22310: LD_EXP 108
22314: PPUSH
22315: LD_VAR 0 4
22319: PPUSH
22320: EMPTY
22321: PPUSH
22322: CALL_OW 1
22326: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22327: LD_ADDR_EXP 109
22331: PUSH
22332: LD_EXP 109
22336: PPUSH
22337: LD_VAR 0 4
22341: PPUSH
22342: EMPTY
22343: PPUSH
22344: CALL_OW 1
22348: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22349: LD_ADDR_EXP 110
22353: PUSH
22354: LD_EXP 110
22358: PPUSH
22359: LD_VAR 0 4
22363: PPUSH
22364: EMPTY
22365: PPUSH
22366: CALL_OW 1
22370: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22371: LD_ADDR_EXP 111
22375: PUSH
22376: LD_EXP 111
22380: PPUSH
22381: LD_VAR 0 4
22385: PPUSH
22386: EMPTY
22387: PPUSH
22388: CALL_OW 1
22392: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22393: LD_ADDR_EXP 112
22397: PUSH
22398: LD_EXP 112
22402: PPUSH
22403: LD_VAR 0 4
22407: PPUSH
22408: EMPTY
22409: PPUSH
22410: CALL_OW 1
22414: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22415: LD_ADDR_EXP 113
22419: PUSH
22420: LD_EXP 113
22424: PPUSH
22425: LD_VAR 0 4
22429: PPUSH
22430: EMPTY
22431: PPUSH
22432: CALL_OW 1
22436: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22437: LD_ADDR_EXP 114
22441: PUSH
22442: LD_EXP 114
22446: PPUSH
22447: LD_VAR 0 4
22451: PPUSH
22452: EMPTY
22453: PPUSH
22454: CALL_OW 1
22458: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22459: LD_ADDR_EXP 115
22463: PUSH
22464: LD_EXP 115
22468: PPUSH
22469: LD_VAR 0 4
22473: PPUSH
22474: EMPTY
22475: PPUSH
22476: CALL_OW 1
22480: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22481: LD_ADDR_EXP 116
22485: PUSH
22486: LD_EXP 116
22490: PPUSH
22491: LD_VAR 0 4
22495: PPUSH
22496: EMPTY
22497: PPUSH
22498: CALL_OW 1
22502: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22503: LD_ADDR_EXP 117
22507: PUSH
22508: LD_EXP 117
22512: PPUSH
22513: LD_VAR 0 4
22517: PPUSH
22518: EMPTY
22519: PPUSH
22520: CALL_OW 1
22524: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22525: LD_ADDR_EXP 118
22529: PUSH
22530: LD_EXP 118
22534: PPUSH
22535: LD_VAR 0 4
22539: PPUSH
22540: EMPTY
22541: PPUSH
22542: CALL_OW 1
22546: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22547: LD_ADDR_EXP 119
22551: PUSH
22552: LD_EXP 119
22556: PPUSH
22557: LD_VAR 0 4
22561: PPUSH
22562: EMPTY
22563: PPUSH
22564: CALL_OW 1
22568: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22569: LD_ADDR_EXP 120
22573: PUSH
22574: LD_EXP 120
22578: PPUSH
22579: LD_VAR 0 4
22583: PPUSH
22584: EMPTY
22585: PPUSH
22586: CALL_OW 1
22590: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22591: LD_ADDR_EXP 121
22595: PUSH
22596: LD_EXP 121
22600: PPUSH
22601: LD_VAR 0 4
22605: PPUSH
22606: LD_INT 0
22608: PPUSH
22609: CALL_OW 1
22613: ST_TO_ADDR
// result := base ;
22614: LD_ADDR_VAR 0 3
22618: PUSH
22619: LD_VAR 0 4
22623: ST_TO_ADDR
// end ;
22624: LD_VAR 0 3
22628: RET
// export function MC_Start ( ) ; var i ; begin
22629: LD_INT 0
22631: PPUSH
22632: PPUSH
// for i = 1 to mc_bases do
22633: LD_ADDR_VAR 0 2
22637: PUSH
22638: DOUBLE
22639: LD_INT 1
22641: DEC
22642: ST_TO_ADDR
22643: LD_EXP 79
22647: PUSH
22648: FOR_TO
22649: IFFALSE 23726
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22651: LD_ADDR_EXP 79
22655: PUSH
22656: LD_EXP 79
22660: PPUSH
22661: LD_VAR 0 2
22665: PPUSH
22666: LD_EXP 79
22670: PUSH
22671: LD_VAR 0 2
22675: ARRAY
22676: PUSH
22677: LD_INT 0
22679: DIFF
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22686: LD_ADDR_EXP 80
22690: PUSH
22691: LD_EXP 80
22695: PPUSH
22696: LD_VAR 0 2
22700: PPUSH
22701: EMPTY
22702: PPUSH
22703: CALL_OW 1
22707: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22708: LD_ADDR_EXP 81
22712: PUSH
22713: LD_EXP 81
22717: PPUSH
22718: LD_VAR 0 2
22722: PPUSH
22723: EMPTY
22724: PPUSH
22725: CALL_OW 1
22729: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22730: LD_ADDR_EXP 82
22734: PUSH
22735: LD_EXP 82
22739: PPUSH
22740: LD_VAR 0 2
22744: PPUSH
22745: EMPTY
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22752: LD_ADDR_EXP 83
22756: PUSH
22757: LD_EXP 83
22761: PPUSH
22762: LD_VAR 0 2
22766: PPUSH
22767: EMPTY
22768: PUSH
22769: EMPTY
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PPUSH
22775: CALL_OW 1
22779: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22780: LD_ADDR_EXP 84
22784: PUSH
22785: LD_EXP 84
22789: PPUSH
22790: LD_VAR 0 2
22794: PPUSH
22795: EMPTY
22796: PPUSH
22797: CALL_OW 1
22801: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22802: LD_ADDR_EXP 111
22806: PUSH
22807: LD_EXP 111
22811: PPUSH
22812: LD_VAR 0 2
22816: PPUSH
22817: EMPTY
22818: PPUSH
22819: CALL_OW 1
22823: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22824: LD_ADDR_EXP 85
22828: PUSH
22829: LD_EXP 85
22833: PPUSH
22834: LD_VAR 0 2
22838: PPUSH
22839: EMPTY
22840: PPUSH
22841: CALL_OW 1
22845: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22846: LD_ADDR_EXP 86
22850: PUSH
22851: LD_EXP 86
22855: PPUSH
22856: LD_VAR 0 2
22860: PPUSH
22861: EMPTY
22862: PPUSH
22863: CALL_OW 1
22867: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22868: LD_ADDR_EXP 87
22872: PUSH
22873: LD_EXP 87
22877: PPUSH
22878: LD_VAR 0 2
22882: PPUSH
22883: LD_EXP 79
22887: PUSH
22888: LD_VAR 0 2
22892: ARRAY
22893: PPUSH
22894: LD_INT 2
22896: PUSH
22897: LD_INT 30
22899: PUSH
22900: LD_INT 32
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: PUSH
22907: LD_INT 30
22909: PUSH
22910: LD_INT 33
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: LIST
22921: PPUSH
22922: CALL_OW 72
22926: PPUSH
22927: CALL_OW 1
22931: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22932: LD_ADDR_EXP 88
22936: PUSH
22937: LD_EXP 88
22941: PPUSH
22942: LD_VAR 0 2
22946: PPUSH
22947: LD_EXP 79
22951: PUSH
22952: LD_VAR 0 2
22956: ARRAY
22957: PPUSH
22958: LD_INT 2
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 32
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 30
22973: PUSH
22974: LD_INT 31
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: PUSH
22986: LD_INT 58
22988: PUSH
22989: EMPTY
22990: LIST
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: PPUSH
22996: CALL_OW 72
23000: PPUSH
23001: CALL_OW 1
23005: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23006: LD_ADDR_EXP 89
23010: PUSH
23011: LD_EXP 89
23015: PPUSH
23016: LD_VAR 0 2
23020: PPUSH
23021: EMPTY
23022: PPUSH
23023: CALL_OW 1
23027: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23028: LD_ADDR_EXP 93
23032: PUSH
23033: LD_EXP 93
23037: PPUSH
23038: LD_VAR 0 2
23042: PPUSH
23043: EMPTY
23044: PPUSH
23045: CALL_OW 1
23049: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23050: LD_ADDR_EXP 92
23054: PUSH
23055: LD_EXP 92
23059: PPUSH
23060: LD_VAR 0 2
23064: PPUSH
23065: EMPTY
23066: PPUSH
23067: CALL_OW 1
23071: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23072: LD_ADDR_EXP 94
23076: PUSH
23077: LD_EXP 94
23081: PPUSH
23082: LD_VAR 0 2
23086: PPUSH
23087: EMPTY
23088: PPUSH
23089: CALL_OW 1
23093: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23094: LD_ADDR_EXP 95
23098: PUSH
23099: LD_EXP 95
23103: PPUSH
23104: LD_VAR 0 2
23108: PPUSH
23109: EMPTY
23110: PPUSH
23111: CALL_OW 1
23115: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23116: LD_ADDR_EXP 96
23120: PUSH
23121: LD_EXP 96
23125: PPUSH
23126: LD_VAR 0 2
23130: PPUSH
23131: EMPTY
23132: PPUSH
23133: CALL_OW 1
23137: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23138: LD_ADDR_EXP 97
23142: PUSH
23143: LD_EXP 97
23147: PPUSH
23148: LD_VAR 0 2
23152: PPUSH
23153: EMPTY
23154: PPUSH
23155: CALL_OW 1
23159: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23160: LD_ADDR_EXP 98
23164: PUSH
23165: LD_EXP 98
23169: PPUSH
23170: LD_VAR 0 2
23174: PPUSH
23175: EMPTY
23176: PPUSH
23177: CALL_OW 1
23181: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23182: LD_ADDR_EXP 99
23186: PUSH
23187: LD_EXP 99
23191: PPUSH
23192: LD_VAR 0 2
23196: PPUSH
23197: EMPTY
23198: PPUSH
23199: CALL_OW 1
23203: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23204: LD_ADDR_EXP 100
23208: PUSH
23209: LD_EXP 100
23213: PPUSH
23214: LD_VAR 0 2
23218: PPUSH
23219: EMPTY
23220: PPUSH
23221: CALL_OW 1
23225: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23226: LD_ADDR_EXP 101
23230: PUSH
23231: LD_EXP 101
23235: PPUSH
23236: LD_VAR 0 2
23240: PPUSH
23241: EMPTY
23242: PPUSH
23243: CALL_OW 1
23247: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23248: LD_ADDR_EXP 90
23252: PUSH
23253: LD_EXP 90
23257: PPUSH
23258: LD_VAR 0 2
23262: PPUSH
23263: LD_INT 0
23265: PPUSH
23266: CALL_OW 1
23270: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23271: LD_ADDR_EXP 103
23275: PUSH
23276: LD_EXP 103
23280: PPUSH
23281: LD_VAR 0 2
23285: PPUSH
23286: LD_INT 0
23288: PPUSH
23289: CALL_OW 1
23293: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23294: LD_ADDR_EXP 91
23298: PUSH
23299: LD_EXP 91
23303: PPUSH
23304: LD_VAR 0 2
23308: PPUSH
23309: EMPTY
23310: PPUSH
23311: CALL_OW 1
23315: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23316: LD_ADDR_EXP 102
23320: PUSH
23321: LD_EXP 102
23325: PPUSH
23326: LD_VAR 0 2
23330: PPUSH
23331: LD_INT 0
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23339: LD_ADDR_EXP 104
23343: PUSH
23344: LD_EXP 104
23348: PPUSH
23349: LD_VAR 0 2
23353: PPUSH
23354: EMPTY
23355: PPUSH
23356: CALL_OW 1
23360: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23361: LD_ADDR_EXP 107
23365: PUSH
23366: LD_EXP 107
23370: PPUSH
23371: LD_VAR 0 2
23375: PPUSH
23376: LD_INT 0
23378: PPUSH
23379: CALL_OW 1
23383: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23384: LD_ADDR_EXP 108
23388: PUSH
23389: LD_EXP 108
23393: PPUSH
23394: LD_VAR 0 2
23398: PPUSH
23399: EMPTY
23400: PPUSH
23401: CALL_OW 1
23405: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23406: LD_ADDR_EXP 109
23410: PUSH
23411: LD_EXP 109
23415: PPUSH
23416: LD_VAR 0 2
23420: PPUSH
23421: EMPTY
23422: PPUSH
23423: CALL_OW 1
23427: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23428: LD_ADDR_EXP 110
23432: PUSH
23433: LD_EXP 110
23437: PPUSH
23438: LD_VAR 0 2
23442: PPUSH
23443: EMPTY
23444: PPUSH
23445: CALL_OW 1
23449: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23450: LD_ADDR_EXP 112
23454: PUSH
23455: LD_EXP 112
23459: PPUSH
23460: LD_VAR 0 2
23464: PPUSH
23465: LD_EXP 79
23469: PUSH
23470: LD_VAR 0 2
23474: ARRAY
23475: PPUSH
23476: LD_INT 2
23478: PUSH
23479: LD_INT 30
23481: PUSH
23482: LD_INT 6
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 30
23491: PUSH
23492: LD_INT 7
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PUSH
23499: LD_INT 30
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: LIST
23513: LIST
23514: PPUSH
23515: CALL_OW 72
23519: PPUSH
23520: CALL_OW 1
23524: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23525: LD_ADDR_EXP 113
23529: PUSH
23530: LD_EXP 113
23534: PPUSH
23535: LD_VAR 0 2
23539: PPUSH
23540: EMPTY
23541: PPUSH
23542: CALL_OW 1
23546: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23547: LD_ADDR_EXP 114
23551: PUSH
23552: LD_EXP 114
23556: PPUSH
23557: LD_VAR 0 2
23561: PPUSH
23562: EMPTY
23563: PPUSH
23564: CALL_OW 1
23568: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23569: LD_ADDR_EXP 115
23573: PUSH
23574: LD_EXP 115
23578: PPUSH
23579: LD_VAR 0 2
23583: PPUSH
23584: EMPTY
23585: PPUSH
23586: CALL_OW 1
23590: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23591: LD_ADDR_EXP 116
23595: PUSH
23596: LD_EXP 116
23600: PPUSH
23601: LD_VAR 0 2
23605: PPUSH
23606: EMPTY
23607: PPUSH
23608: CALL_OW 1
23612: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23613: LD_ADDR_EXP 117
23617: PUSH
23618: LD_EXP 117
23622: PPUSH
23623: LD_VAR 0 2
23627: PPUSH
23628: EMPTY
23629: PPUSH
23630: CALL_OW 1
23634: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23635: LD_ADDR_EXP 118
23639: PUSH
23640: LD_EXP 118
23644: PPUSH
23645: LD_VAR 0 2
23649: PPUSH
23650: EMPTY
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23657: LD_ADDR_EXP 119
23661: PUSH
23662: LD_EXP 119
23666: PPUSH
23667: LD_VAR 0 2
23671: PPUSH
23672: EMPTY
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23679: LD_ADDR_EXP 120
23683: PUSH
23684: LD_EXP 120
23688: PPUSH
23689: LD_VAR 0 2
23693: PPUSH
23694: EMPTY
23695: PPUSH
23696: CALL_OW 1
23700: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23701: LD_ADDR_EXP 121
23705: PUSH
23706: LD_EXP 121
23710: PPUSH
23711: LD_VAR 0 2
23715: PPUSH
23716: LD_INT 0
23718: PPUSH
23719: CALL_OW 1
23723: ST_TO_ADDR
// end ;
23724: GO 22648
23726: POP
23727: POP
// MC_InitSides ( ) ;
23728: CALL 24014 0 0
// MC_InitResearch ( ) ;
23732: CALL 23753 0 0
// CustomInitMacro ( ) ;
23736: CALL 213 0 0
// skirmish := true ;
23740: LD_ADDR_EXP 77
23744: PUSH
23745: LD_INT 1
23747: ST_TO_ADDR
// end ;
23748: LD_VAR 0 1
23752: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23753: LD_INT 0
23755: PPUSH
23756: PPUSH
23757: PPUSH
23758: PPUSH
23759: PPUSH
23760: PPUSH
// if not mc_bases then
23761: LD_EXP 79
23765: NOT
23766: IFFALSE 23770
// exit ;
23768: GO 24009
// for i = 1 to 8 do
23770: LD_ADDR_VAR 0 2
23774: PUSH
23775: DOUBLE
23776: LD_INT 1
23778: DEC
23779: ST_TO_ADDR
23780: LD_INT 8
23782: PUSH
23783: FOR_TO
23784: IFFALSE 23810
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23786: LD_ADDR_EXP 106
23790: PUSH
23791: LD_EXP 106
23795: PPUSH
23796: LD_VAR 0 2
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
23808: GO 23783
23810: POP
23811: POP
// tmp := [ ] ;
23812: LD_ADDR_VAR 0 5
23816: PUSH
23817: EMPTY
23818: ST_TO_ADDR
// for i = 1 to mc_sides do
23819: LD_ADDR_VAR 0 2
23823: PUSH
23824: DOUBLE
23825: LD_INT 1
23827: DEC
23828: ST_TO_ADDR
23829: LD_EXP 105
23833: PUSH
23834: FOR_TO
23835: IFFALSE 23893
// if not mc_sides [ i ] in tmp then
23837: LD_EXP 105
23841: PUSH
23842: LD_VAR 0 2
23846: ARRAY
23847: PUSH
23848: LD_VAR 0 5
23852: IN
23853: NOT
23854: IFFALSE 23891
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23856: LD_ADDR_VAR 0 5
23860: PUSH
23861: LD_VAR 0 5
23865: PPUSH
23866: LD_VAR 0 5
23870: PUSH
23871: LD_INT 1
23873: PLUS
23874: PPUSH
23875: LD_EXP 105
23879: PUSH
23880: LD_VAR 0 2
23884: ARRAY
23885: PPUSH
23886: CALL_OW 2
23890: ST_TO_ADDR
23891: GO 23834
23893: POP
23894: POP
// if not tmp then
23895: LD_VAR 0 5
23899: NOT
23900: IFFALSE 23904
// exit ;
23902: GO 24009
// for j in tmp do
23904: LD_ADDR_VAR 0 3
23908: PUSH
23909: LD_VAR 0 5
23913: PUSH
23914: FOR_IN
23915: IFFALSE 24007
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23917: LD_ADDR_VAR 0 6
23921: PUSH
23922: LD_INT 22
23924: PUSH
23925: LD_VAR 0 3
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PPUSH
23934: CALL_OW 69
23938: ST_TO_ADDR
// if not un then
23939: LD_VAR 0 6
23943: NOT
23944: IFFALSE 23948
// continue ;
23946: GO 23914
// nation := GetNation ( un [ 1 ] ) ;
23948: LD_ADDR_VAR 0 4
23952: PUSH
23953: LD_VAR 0 6
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: PPUSH
23962: CALL_OW 248
23966: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23967: LD_ADDR_EXP 106
23971: PUSH
23972: LD_EXP 106
23976: PPUSH
23977: LD_VAR 0 3
23981: PPUSH
23982: LD_VAR 0 3
23986: PPUSH
23987: LD_VAR 0 4
23991: PPUSH
23992: LD_INT 1
23994: PPUSH
23995: CALL 50619 0 3
23999: PPUSH
24000: CALL_OW 1
24004: ST_TO_ADDR
// end ;
24005: GO 23914
24007: POP
24008: POP
// end ;
24009: LD_VAR 0 1
24013: RET
// export function MC_InitSides ( ) ; var i ; begin
24014: LD_INT 0
24016: PPUSH
24017: PPUSH
// if not mc_bases then
24018: LD_EXP 79
24022: NOT
24023: IFFALSE 24027
// exit ;
24025: GO 24101
// for i = 1 to mc_bases do
24027: LD_ADDR_VAR 0 2
24031: PUSH
24032: DOUBLE
24033: LD_INT 1
24035: DEC
24036: ST_TO_ADDR
24037: LD_EXP 79
24041: PUSH
24042: FOR_TO
24043: IFFALSE 24099
// if mc_bases [ i ] then
24045: LD_EXP 79
24049: PUSH
24050: LD_VAR 0 2
24054: ARRAY
24055: IFFALSE 24097
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24057: LD_ADDR_EXP 105
24061: PUSH
24062: LD_EXP 105
24066: PPUSH
24067: LD_VAR 0 2
24071: PPUSH
24072: LD_EXP 79
24076: PUSH
24077: LD_VAR 0 2
24081: ARRAY
24082: PUSH
24083: LD_INT 1
24085: ARRAY
24086: PPUSH
24087: CALL_OW 255
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
24097: GO 24042
24099: POP
24100: POP
// end ;
24101: LD_VAR 0 1
24105: RET
// every 0 0$01 trigger skirmish do
24106: LD_EXP 77
24110: IFFALSE 24264
24112: GO 24114
24114: DISABLE
// begin enable ;
24115: ENABLE
// MC_CheckBuildings ( ) ;
24116: CALL 28762 0 0
// MC_CheckPeopleLife ( ) ;
24120: CALL 28887 0 0
// RaiseSailEvent ( 100 ) ;
24124: LD_INT 100
24126: PPUSH
24127: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24131: LD_INT 103
24133: PPUSH
24134: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24138: LD_INT 104
24140: PPUSH
24141: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24145: LD_INT 105
24147: PPUSH
24148: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24152: LD_INT 106
24154: PPUSH
24155: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24159: LD_INT 107
24161: PPUSH
24162: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24166: LD_INT 108
24168: PPUSH
24169: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24173: LD_INT 109
24175: PPUSH
24176: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24180: LD_INT 110
24182: PPUSH
24183: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24187: LD_INT 111
24189: PPUSH
24190: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24194: LD_INT 112
24196: PPUSH
24197: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24201: LD_INT 113
24203: PPUSH
24204: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24208: LD_INT 120
24210: PPUSH
24211: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24215: LD_INT 121
24217: PPUSH
24218: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24222: LD_INT 122
24224: PPUSH
24225: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24229: LD_INT 123
24231: PPUSH
24232: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24236: LD_INT 124
24238: PPUSH
24239: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24243: LD_INT 125
24245: PPUSH
24246: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24250: LD_INT 126
24252: PPUSH
24253: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24257: LD_INT 200
24259: PPUSH
24260: CALL_OW 427
// end ;
24264: END
// on SailEvent ( event ) do begin if event < 100 then
24265: LD_VAR 0 1
24269: PUSH
24270: LD_INT 100
24272: LESS
24273: IFFALSE 24284
// CustomEvent ( event ) ;
24275: LD_VAR 0 1
24279: PPUSH
24280: CALL 10371 0 1
// if event = 100 then
24284: LD_VAR 0 1
24288: PUSH
24289: LD_INT 100
24291: EQUAL
24292: IFFALSE 24298
// MC_ClassManager ( ) ;
24294: CALL 24690 0 0
// if event = 101 then
24298: LD_VAR 0 1
24302: PUSH
24303: LD_INT 101
24305: EQUAL
24306: IFFALSE 24312
// MC_RepairBuildings ( ) ;
24308: CALL 29483 0 0
// if event = 102 then
24312: LD_VAR 0 1
24316: PUSH
24317: LD_INT 102
24319: EQUAL
24320: IFFALSE 24326
// MC_Heal ( ) ;
24322: CALL 30347 0 0
// if event = 103 then
24326: LD_VAR 0 1
24330: PUSH
24331: LD_INT 103
24333: EQUAL
24334: IFFALSE 24340
// MC_Build ( ) ;
24336: CALL 30769 0 0
// if event = 104 then
24340: LD_VAR 0 1
24344: PUSH
24345: LD_INT 104
24347: EQUAL
24348: IFFALSE 24354
// MC_TurretWeapon ( ) ;
24350: CALL 32382 0 0
// if event = 105 then
24354: LD_VAR 0 1
24358: PUSH
24359: LD_INT 105
24361: EQUAL
24362: IFFALSE 24368
// MC_BuildUpgrade ( ) ;
24364: CALL 31933 0 0
// if event = 106 then
24368: LD_VAR 0 1
24372: PUSH
24373: LD_INT 106
24375: EQUAL
24376: IFFALSE 24382
// MC_PlantMines ( ) ;
24378: CALL 32812 0 0
// if event = 107 then
24382: LD_VAR 0 1
24386: PUSH
24387: LD_INT 107
24389: EQUAL
24390: IFFALSE 24396
// MC_CollectCrates ( ) ;
24392: CALL 33610 0 0
// if event = 108 then
24396: LD_VAR 0 1
24400: PUSH
24401: LD_INT 108
24403: EQUAL
24404: IFFALSE 24410
// MC_LinkRemoteControl ( ) ;
24406: CALL 35386 0 0
// if event = 109 then
24410: LD_VAR 0 1
24414: PUSH
24415: LD_INT 109
24417: EQUAL
24418: IFFALSE 24424
// MC_ProduceVehicle ( ) ;
24420: CALL 35567 0 0
// if event = 110 then
24424: LD_VAR 0 1
24428: PUSH
24429: LD_INT 110
24431: EQUAL
24432: IFFALSE 24438
// MC_SendAttack ( ) ;
24434: CALL 36033 0 0
// if event = 111 then
24438: LD_VAR 0 1
24442: PUSH
24443: LD_INT 111
24445: EQUAL
24446: IFFALSE 24452
// MC_Defend ( ) ;
24448: CALL 36141 0 0
// if event = 112 then
24452: LD_VAR 0 1
24456: PUSH
24457: LD_INT 112
24459: EQUAL
24460: IFFALSE 24466
// MC_Research ( ) ;
24462: CALL 36746 0 0
// if event = 113 then
24466: LD_VAR 0 1
24470: PUSH
24471: LD_INT 113
24473: EQUAL
24474: IFFALSE 24480
// MC_MinesTrigger ( ) ;
24476: CALL 37860 0 0
// if event = 120 then
24480: LD_VAR 0 1
24484: PUSH
24485: LD_INT 120
24487: EQUAL
24488: IFFALSE 24494
// MC_RepairVehicle ( ) ;
24490: CALL 37959 0 0
// if event = 121 then
24494: LD_VAR 0 1
24498: PUSH
24499: LD_INT 121
24501: EQUAL
24502: IFFALSE 24508
// MC_TameApe ( ) ;
24504: CALL 38689 0 0
// if event = 122 then
24508: LD_VAR 0 1
24512: PUSH
24513: LD_INT 122
24515: EQUAL
24516: IFFALSE 24522
// MC_ChangeApeClass ( ) ;
24518: CALL 39518 0 0
// if event = 123 then
24522: LD_VAR 0 1
24526: PUSH
24527: LD_INT 123
24529: EQUAL
24530: IFFALSE 24536
// MC_Bazooka ( ) ;
24532: CALL 40168 0 0
// if event = 124 then
24536: LD_VAR 0 1
24540: PUSH
24541: LD_INT 124
24543: EQUAL
24544: IFFALSE 24550
// MC_TeleportExit ( ) ;
24546: CALL 40366 0 0
// if event = 125 then
24550: LD_VAR 0 1
24554: PUSH
24555: LD_INT 125
24557: EQUAL
24558: IFFALSE 24564
// MC_Deposits ( ) ;
24560: CALL 41013 0 0
// if event = 126 then
24564: LD_VAR 0 1
24568: PUSH
24569: LD_INT 126
24571: EQUAL
24572: IFFALSE 24578
// MC_RemoteDriver ( ) ;
24574: CALL 41638 0 0
// if event = 200 then
24578: LD_VAR 0 1
24582: PUSH
24583: LD_INT 200
24585: EQUAL
24586: IFFALSE 24592
// MC_Idle ( ) ;
24588: CALL 43587 0 0
// end ;
24592: PPOPN 1
24594: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24595: LD_INT 0
24597: PPUSH
24598: PPUSH
// if not mc_bases [ base ] or not tag then
24599: LD_EXP 79
24603: PUSH
24604: LD_VAR 0 1
24608: ARRAY
24609: NOT
24610: PUSH
24611: LD_VAR 0 2
24615: NOT
24616: OR
24617: IFFALSE 24621
// exit ;
24619: GO 24685
// for i in mc_bases [ base ] union mc_ape [ base ] do
24621: LD_ADDR_VAR 0 4
24625: PUSH
24626: LD_EXP 79
24630: PUSH
24631: LD_VAR 0 1
24635: ARRAY
24636: PUSH
24637: LD_EXP 108
24641: PUSH
24642: LD_VAR 0 1
24646: ARRAY
24647: UNION
24648: PUSH
24649: FOR_IN
24650: IFFALSE 24683
// if GetTag ( i ) = tag then
24652: LD_VAR 0 4
24656: PPUSH
24657: CALL_OW 110
24661: PUSH
24662: LD_VAR 0 2
24666: EQUAL
24667: IFFALSE 24681
// SetTag ( i , 0 ) ;
24669: LD_VAR 0 4
24673: PPUSH
24674: LD_INT 0
24676: PPUSH
24677: CALL_OW 109
24681: GO 24649
24683: POP
24684: POP
// end ;
24685: LD_VAR 0 3
24689: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24690: LD_INT 0
24692: PPUSH
24693: PPUSH
24694: PPUSH
24695: PPUSH
24696: PPUSH
24697: PPUSH
24698: PPUSH
24699: PPUSH
// if not mc_bases then
24700: LD_EXP 79
24704: NOT
24705: IFFALSE 24709
// exit ;
24707: GO 25167
// for i = 1 to mc_bases do
24709: LD_ADDR_VAR 0 2
24713: PUSH
24714: DOUBLE
24715: LD_INT 1
24717: DEC
24718: ST_TO_ADDR
24719: LD_EXP 79
24723: PUSH
24724: FOR_TO
24725: IFFALSE 25165
// begin tmp := MC_ClassCheckReq ( i ) ;
24727: LD_ADDR_VAR 0 4
24731: PUSH
24732: LD_VAR 0 2
24736: PPUSH
24737: CALL 25172 0 1
24741: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24742: LD_ADDR_EXP 120
24746: PUSH
24747: LD_EXP 120
24751: PPUSH
24752: LD_VAR 0 2
24756: PPUSH
24757: LD_VAR 0 4
24761: PPUSH
24762: CALL_OW 1
24766: ST_TO_ADDR
// if not tmp then
24767: LD_VAR 0 4
24771: NOT
24772: IFFALSE 24776
// continue ;
24774: GO 24724
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24776: LD_ADDR_VAR 0 6
24780: PUSH
24781: LD_EXP 79
24785: PUSH
24786: LD_VAR 0 2
24790: ARRAY
24791: PPUSH
24792: LD_INT 2
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 4
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 30
24807: PUSH
24808: LD_INT 5
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 72
24824: PUSH
24825: LD_EXP 79
24829: PUSH
24830: LD_VAR 0 2
24834: ARRAY
24835: PPUSH
24836: LD_INT 2
24838: PUSH
24839: LD_INT 30
24841: PUSH
24842: LD_INT 0
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: PUSH
24849: LD_INT 30
24851: PUSH
24852: LD_INT 1
24854: PUSH
24855: EMPTY
24856: LIST
24857: LIST
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: LIST
24863: PPUSH
24864: CALL_OW 72
24868: PUSH
24869: LD_EXP 79
24873: PUSH
24874: LD_VAR 0 2
24878: ARRAY
24879: PPUSH
24880: LD_INT 30
24882: PUSH
24883: LD_INT 3
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PPUSH
24890: CALL_OW 72
24894: PUSH
24895: LD_EXP 79
24899: PUSH
24900: LD_VAR 0 2
24904: ARRAY
24905: PPUSH
24906: LD_INT 2
24908: PUSH
24909: LD_INT 30
24911: PUSH
24912: LD_INT 6
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 30
24921: PUSH
24922: LD_INT 7
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 30
24931: PUSH
24932: LD_INT 8
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 72
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: ST_TO_ADDR
// for j = 1 to 4 do
24956: LD_ADDR_VAR 0 3
24960: PUSH
24961: DOUBLE
24962: LD_INT 1
24964: DEC
24965: ST_TO_ADDR
24966: LD_INT 4
24968: PUSH
24969: FOR_TO
24970: IFFALSE 25161
// begin if not tmp [ j ] then
24972: LD_VAR 0 4
24976: PUSH
24977: LD_VAR 0 3
24981: ARRAY
24982: NOT
24983: IFFALSE 24987
// continue ;
24985: GO 24969
// for p in tmp [ j ] do
24987: LD_ADDR_VAR 0 5
24991: PUSH
24992: LD_VAR 0 4
24996: PUSH
24997: LD_VAR 0 3
25001: ARRAY
25002: PUSH
25003: FOR_IN
25004: IFFALSE 25157
// begin if not b [ j ] then
25006: LD_VAR 0 6
25010: PUSH
25011: LD_VAR 0 3
25015: ARRAY
25016: NOT
25017: IFFALSE 25021
// break ;
25019: GO 25157
// e := 0 ;
25021: LD_ADDR_VAR 0 7
25025: PUSH
25026: LD_INT 0
25028: ST_TO_ADDR
// for k in b [ j ] do
25029: LD_ADDR_VAR 0 8
25033: PUSH
25034: LD_VAR 0 6
25038: PUSH
25039: LD_VAR 0 3
25043: ARRAY
25044: PUSH
25045: FOR_IN
25046: IFFALSE 25073
// if IsNotFull ( k ) then
25048: LD_VAR 0 8
25052: PPUSH
25053: CALL 55059 0 1
25057: IFFALSE 25071
// begin e := k ;
25059: LD_ADDR_VAR 0 7
25063: PUSH
25064: LD_VAR 0 8
25068: ST_TO_ADDR
// break ;
25069: GO 25073
// end ;
25071: GO 25045
25073: POP
25074: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25075: LD_VAR 0 7
25079: PUSH
25080: LD_VAR 0 5
25084: PPUSH
25085: LD_VAR 0 7
25089: PPUSH
25090: CALL 92188 0 2
25094: NOT
25095: AND
25096: IFFALSE 25155
// begin if IsInUnit ( p ) then
25098: LD_VAR 0 5
25102: PPUSH
25103: CALL_OW 310
25107: IFFALSE 25118
// ComExitBuilding ( p ) ;
25109: LD_VAR 0 5
25113: PPUSH
25114: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25118: LD_VAR 0 5
25122: PPUSH
25123: LD_VAR 0 7
25127: PPUSH
25128: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25132: LD_VAR 0 5
25136: PPUSH
25137: LD_VAR 0 3
25141: PPUSH
25142: CALL_OW 183
// AddComExitBuilding ( p ) ;
25146: LD_VAR 0 5
25150: PPUSH
25151: CALL_OW 182
// end ; end ;
25155: GO 25003
25157: POP
25158: POP
// end ;
25159: GO 24969
25161: POP
25162: POP
// end ;
25163: GO 24724
25165: POP
25166: POP
// end ;
25167: LD_VAR 0 1
25171: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25172: LD_INT 0
25174: PPUSH
25175: PPUSH
25176: PPUSH
25177: PPUSH
25178: PPUSH
25179: PPUSH
25180: PPUSH
25181: PPUSH
25182: PPUSH
25183: PPUSH
25184: PPUSH
25185: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25186: LD_VAR 0 1
25190: NOT
25191: PUSH
25192: LD_EXP 79
25196: PUSH
25197: LD_VAR 0 1
25201: ARRAY
25202: NOT
25203: OR
25204: PUSH
25205: LD_EXP 79
25209: PUSH
25210: LD_VAR 0 1
25214: ARRAY
25215: PPUSH
25216: LD_INT 2
25218: PUSH
25219: LD_INT 30
25221: PUSH
25222: LD_INT 0
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PUSH
25229: LD_INT 30
25231: PUSH
25232: LD_INT 1
25234: PUSH
25235: EMPTY
25236: LIST
25237: LIST
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: LIST
25243: PPUSH
25244: CALL_OW 72
25248: NOT
25249: OR
25250: IFFALSE 25254
// exit ;
25252: GO 28757
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25254: LD_ADDR_VAR 0 4
25258: PUSH
25259: LD_EXP 79
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: LD_INT 2
25272: PUSH
25273: LD_INT 25
25275: PUSH
25276: LD_INT 1
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 25
25285: PUSH
25286: LD_INT 2
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 25
25295: PUSH
25296: LD_INT 3
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 25
25305: PUSH
25306: LD_INT 4
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: LD_INT 25
25315: PUSH
25316: LD_INT 5
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: PUSH
25323: LD_INT 25
25325: PUSH
25326: LD_INT 8
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: LD_INT 25
25335: PUSH
25336: LD_INT 9
25338: PUSH
25339: EMPTY
25340: LIST
25341: LIST
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: LIST
25347: LIST
25348: LIST
25349: LIST
25350: LIST
25351: LIST
25352: PPUSH
25353: CALL_OW 72
25357: ST_TO_ADDR
// if not tmp then
25358: LD_VAR 0 4
25362: NOT
25363: IFFALSE 25367
// exit ;
25365: GO 28757
// for i in tmp do
25367: LD_ADDR_VAR 0 3
25371: PUSH
25372: LD_VAR 0 4
25376: PUSH
25377: FOR_IN
25378: IFFALSE 25409
// if GetTag ( i ) then
25380: LD_VAR 0 3
25384: PPUSH
25385: CALL_OW 110
25389: IFFALSE 25407
// tmp := tmp diff i ;
25391: LD_ADDR_VAR 0 4
25395: PUSH
25396: LD_VAR 0 4
25400: PUSH
25401: LD_VAR 0 3
25405: DIFF
25406: ST_TO_ADDR
25407: GO 25377
25409: POP
25410: POP
// if not tmp then
25411: LD_VAR 0 4
25415: NOT
25416: IFFALSE 25420
// exit ;
25418: GO 28757
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25420: LD_ADDR_VAR 0 5
25424: PUSH
25425: LD_EXP 79
25429: PUSH
25430: LD_VAR 0 1
25434: ARRAY
25435: PPUSH
25436: LD_INT 2
25438: PUSH
25439: LD_INT 25
25441: PUSH
25442: LD_INT 1
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: LD_INT 25
25451: PUSH
25452: LD_INT 5
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: PUSH
25459: LD_INT 25
25461: PUSH
25462: LD_INT 8
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 25
25471: PUSH
25472: LD_INT 9
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: PPUSH
25486: CALL_OW 72
25490: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25491: LD_ADDR_VAR 0 6
25495: PUSH
25496: LD_EXP 79
25500: PUSH
25501: LD_VAR 0 1
25505: ARRAY
25506: PPUSH
25507: LD_INT 25
25509: PUSH
25510: LD_INT 2
25512: PUSH
25513: EMPTY
25514: LIST
25515: LIST
25516: PPUSH
25517: CALL_OW 72
25521: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25522: LD_ADDR_VAR 0 7
25526: PUSH
25527: LD_EXP 79
25531: PUSH
25532: LD_VAR 0 1
25536: ARRAY
25537: PPUSH
25538: LD_INT 25
25540: PUSH
25541: LD_INT 3
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PPUSH
25548: CALL_OW 72
25552: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25553: LD_ADDR_VAR 0 8
25557: PUSH
25558: LD_EXP 79
25562: PUSH
25563: LD_VAR 0 1
25567: ARRAY
25568: PPUSH
25569: LD_INT 25
25571: PUSH
25572: LD_INT 4
25574: PUSH
25575: EMPTY
25576: LIST
25577: LIST
25578: PUSH
25579: LD_INT 24
25581: PUSH
25582: LD_INT 251
25584: PUSH
25585: EMPTY
25586: LIST
25587: LIST
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PPUSH
25593: CALL_OW 72
25597: ST_TO_ADDR
// if mc_scan [ base ] then
25598: LD_EXP 102
25602: PUSH
25603: LD_VAR 0 1
25607: ARRAY
25608: IFFALSE 26069
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25610: LD_ADDR_EXP 121
25614: PUSH
25615: LD_EXP 121
25619: PPUSH
25620: LD_VAR 0 1
25624: PPUSH
25625: LD_INT 4
25627: PPUSH
25628: CALL_OW 1
25632: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25633: LD_ADDR_VAR 0 12
25637: PUSH
25638: LD_EXP 79
25642: PUSH
25643: LD_VAR 0 1
25647: ARRAY
25648: PPUSH
25649: LD_INT 2
25651: PUSH
25652: LD_INT 30
25654: PUSH
25655: LD_INT 4
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: LD_INT 30
25664: PUSH
25665: LD_INT 5
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: LIST
25676: PPUSH
25677: CALL_OW 72
25681: ST_TO_ADDR
// if not b then
25682: LD_VAR 0 12
25686: NOT
25687: IFFALSE 25691
// exit ;
25689: GO 28757
// p := [ ] ;
25691: LD_ADDR_VAR 0 11
25695: PUSH
25696: EMPTY
25697: ST_TO_ADDR
// if sci >= 2 then
25698: LD_VAR 0 8
25702: PUSH
25703: LD_INT 2
25705: GREATEREQUAL
25706: IFFALSE 25737
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25708: LD_ADDR_VAR 0 8
25712: PUSH
25713: LD_VAR 0 8
25717: PUSH
25718: LD_INT 1
25720: ARRAY
25721: PUSH
25722: LD_VAR 0 8
25726: PUSH
25727: LD_INT 2
25729: ARRAY
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: ST_TO_ADDR
25735: GO 25798
// if sci = 1 then
25737: LD_VAR 0 8
25741: PUSH
25742: LD_INT 1
25744: EQUAL
25745: IFFALSE 25766
// sci := [ sci [ 1 ] ] else
25747: LD_ADDR_VAR 0 8
25751: PUSH
25752: LD_VAR 0 8
25756: PUSH
25757: LD_INT 1
25759: ARRAY
25760: PUSH
25761: EMPTY
25762: LIST
25763: ST_TO_ADDR
25764: GO 25798
// if sci = 0 then
25766: LD_VAR 0 8
25770: PUSH
25771: LD_INT 0
25773: EQUAL
25774: IFFALSE 25798
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25776: LD_ADDR_VAR 0 11
25780: PUSH
25781: LD_VAR 0 4
25785: PPUSH
25786: LD_INT 4
25788: PPUSH
25789: CALL 92051 0 2
25793: PUSH
25794: LD_INT 1
25796: ARRAY
25797: ST_TO_ADDR
// if eng > 4 then
25798: LD_VAR 0 6
25802: PUSH
25803: LD_INT 4
25805: GREATER
25806: IFFALSE 25852
// for i = eng downto 4 do
25808: LD_ADDR_VAR 0 3
25812: PUSH
25813: DOUBLE
25814: LD_VAR 0 6
25818: INC
25819: ST_TO_ADDR
25820: LD_INT 4
25822: PUSH
25823: FOR_DOWNTO
25824: IFFALSE 25850
// eng := eng diff eng [ i ] ;
25826: LD_ADDR_VAR 0 6
25830: PUSH
25831: LD_VAR 0 6
25835: PUSH
25836: LD_VAR 0 6
25840: PUSH
25841: LD_VAR 0 3
25845: ARRAY
25846: DIFF
25847: ST_TO_ADDR
25848: GO 25823
25850: POP
25851: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25852: LD_ADDR_VAR 0 4
25856: PUSH
25857: LD_VAR 0 4
25861: PUSH
25862: LD_VAR 0 5
25866: PUSH
25867: LD_VAR 0 6
25871: UNION
25872: PUSH
25873: LD_VAR 0 7
25877: UNION
25878: PUSH
25879: LD_VAR 0 8
25883: UNION
25884: DIFF
25885: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25886: LD_ADDR_VAR 0 13
25890: PUSH
25891: LD_EXP 79
25895: PUSH
25896: LD_VAR 0 1
25900: ARRAY
25901: PPUSH
25902: LD_INT 2
25904: PUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 32
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 30
25917: PUSH
25918: LD_INT 31
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: LIST
25929: PPUSH
25930: CALL_OW 72
25934: PUSH
25935: LD_EXP 79
25939: PUSH
25940: LD_VAR 0 1
25944: ARRAY
25945: PPUSH
25946: LD_INT 2
25948: PUSH
25949: LD_INT 30
25951: PUSH
25952: LD_INT 4
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: LD_INT 30
25961: PUSH
25962: LD_INT 5
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: LIST
25973: PPUSH
25974: CALL_OW 72
25978: PUSH
25979: LD_INT 6
25981: MUL
25982: PLUS
25983: ST_TO_ADDR
// if bcount < tmp then
25984: LD_VAR 0 13
25988: PUSH
25989: LD_VAR 0 4
25993: LESS
25994: IFFALSE 26040
// for i = tmp downto bcount do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_VAR 0 4
26006: INC
26007: ST_TO_ADDR
26008: LD_VAR 0 13
26012: PUSH
26013: FOR_DOWNTO
26014: IFFALSE 26038
// tmp := Delete ( tmp , tmp ) ;
26016: LD_ADDR_VAR 0 4
26020: PUSH
26021: LD_VAR 0 4
26025: PPUSH
26026: LD_VAR 0 4
26030: PPUSH
26031: CALL_OW 3
26035: ST_TO_ADDR
26036: GO 26013
26038: POP
26039: POP
// result := [ tmp , 0 , 0 , p ] ;
26040: LD_ADDR_VAR 0 2
26044: PUSH
26045: LD_VAR 0 4
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 0
26055: PUSH
26056: LD_VAR 0 11
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: ST_TO_ADDR
// exit ;
26067: GO 28757
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26069: LD_EXP 79
26073: PUSH
26074: LD_VAR 0 1
26078: ARRAY
26079: PPUSH
26080: LD_INT 2
26082: PUSH
26083: LD_INT 30
26085: PUSH
26086: LD_INT 6
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 30
26095: PUSH
26096: LD_INT 7
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 30
26105: PUSH
26106: LD_INT 8
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: LIST
26117: LIST
26118: PPUSH
26119: CALL_OW 72
26123: NOT
26124: PUSH
26125: LD_EXP 79
26129: PUSH
26130: LD_VAR 0 1
26134: ARRAY
26135: PPUSH
26136: LD_INT 30
26138: PUSH
26139: LD_INT 3
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PPUSH
26146: CALL_OW 72
26150: NOT
26151: AND
26152: IFFALSE 26224
// begin if eng = tmp then
26154: LD_VAR 0 6
26158: PUSH
26159: LD_VAR 0 4
26163: EQUAL
26164: IFFALSE 26168
// exit ;
26166: GO 28757
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26168: LD_ADDR_EXP 121
26172: PUSH
26173: LD_EXP 121
26177: PPUSH
26178: LD_VAR 0 1
26182: PPUSH
26183: LD_INT 1
26185: PPUSH
26186: CALL_OW 1
26190: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26191: LD_ADDR_VAR 0 2
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: LD_VAR 0 4
26203: PUSH
26204: LD_VAR 0 6
26208: DIFF
26209: PUSH
26210: LD_INT 0
26212: PUSH
26213: LD_INT 0
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: LIST
26220: LIST
26221: ST_TO_ADDR
// exit ;
26222: GO 28757
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26224: LD_EXP 106
26228: PUSH
26229: LD_EXP 105
26233: PUSH
26234: LD_VAR 0 1
26238: ARRAY
26239: ARRAY
26240: PUSH
26241: LD_EXP 79
26245: PUSH
26246: LD_VAR 0 1
26250: ARRAY
26251: PPUSH
26252: LD_INT 2
26254: PUSH
26255: LD_INT 30
26257: PUSH
26258: LD_INT 6
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PUSH
26265: LD_INT 30
26267: PUSH
26268: LD_INT 7
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 30
26277: PUSH
26278: LD_INT 8
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: PPUSH
26291: CALL_OW 72
26295: AND
26296: PUSH
26297: LD_EXP 79
26301: PUSH
26302: LD_VAR 0 1
26306: ARRAY
26307: PPUSH
26308: LD_INT 30
26310: PUSH
26311: LD_INT 3
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PPUSH
26318: CALL_OW 72
26322: NOT
26323: AND
26324: IFFALSE 26538
// begin if sci >= 6 then
26326: LD_VAR 0 8
26330: PUSH
26331: LD_INT 6
26333: GREATEREQUAL
26334: IFFALSE 26338
// exit ;
26336: GO 28757
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26338: LD_ADDR_EXP 121
26342: PUSH
26343: LD_EXP 121
26347: PPUSH
26348: LD_VAR 0 1
26352: PPUSH
26353: LD_INT 2
26355: PPUSH
26356: CALL_OW 1
26360: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26361: LD_ADDR_VAR 0 9
26365: PUSH
26366: LD_VAR 0 4
26370: PUSH
26371: LD_VAR 0 8
26375: DIFF
26376: PPUSH
26377: LD_INT 4
26379: PPUSH
26380: CALL 92051 0 2
26384: ST_TO_ADDR
// p := [ ] ;
26385: LD_ADDR_VAR 0 11
26389: PUSH
26390: EMPTY
26391: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26392: LD_VAR 0 8
26396: PUSH
26397: LD_INT 6
26399: LESS
26400: PUSH
26401: LD_VAR 0 9
26405: PUSH
26406: LD_INT 6
26408: GREATER
26409: AND
26410: IFFALSE 26491
// begin for i = 1 to 6 - sci do
26412: LD_ADDR_VAR 0 3
26416: PUSH
26417: DOUBLE
26418: LD_INT 1
26420: DEC
26421: ST_TO_ADDR
26422: LD_INT 6
26424: PUSH
26425: LD_VAR 0 8
26429: MINUS
26430: PUSH
26431: FOR_TO
26432: IFFALSE 26487
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26434: LD_ADDR_VAR 0 11
26438: PUSH
26439: LD_VAR 0 11
26443: PPUSH
26444: LD_VAR 0 11
26448: PUSH
26449: LD_INT 1
26451: PLUS
26452: PPUSH
26453: LD_VAR 0 9
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: PPUSH
26462: CALL_OW 2
26466: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26467: LD_ADDR_VAR 0 9
26471: PUSH
26472: LD_VAR 0 9
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 3
26484: ST_TO_ADDR
// end ;
26485: GO 26431
26487: POP
26488: POP
// end else
26489: GO 26511
// if sort then
26491: LD_VAR 0 9
26495: IFFALSE 26511
// p := sort [ 1 ] ;
26497: LD_ADDR_VAR 0 11
26501: PUSH
26502: LD_VAR 0 9
26506: PUSH
26507: LD_INT 1
26509: ARRAY
26510: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26511: LD_ADDR_VAR 0 2
26515: PUSH
26516: LD_INT 0
26518: PUSH
26519: LD_INT 0
26521: PUSH
26522: LD_INT 0
26524: PUSH
26525: LD_VAR 0 11
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: ST_TO_ADDR
// exit ;
26536: GO 28757
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26538: LD_EXP 106
26542: PUSH
26543: LD_EXP 105
26547: PUSH
26548: LD_VAR 0 1
26552: ARRAY
26553: ARRAY
26554: PUSH
26555: LD_EXP 79
26559: PUSH
26560: LD_VAR 0 1
26564: ARRAY
26565: PPUSH
26566: LD_INT 2
26568: PUSH
26569: LD_INT 30
26571: PUSH
26572: LD_INT 6
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 30
26581: PUSH
26582: LD_INT 7
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: LD_INT 30
26591: PUSH
26592: LD_INT 8
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: PPUSH
26605: CALL_OW 72
26609: AND
26610: PUSH
26611: LD_EXP 79
26615: PUSH
26616: LD_VAR 0 1
26620: ARRAY
26621: PPUSH
26622: LD_INT 30
26624: PUSH
26625: LD_INT 3
26627: PUSH
26628: EMPTY
26629: LIST
26630: LIST
26631: PPUSH
26632: CALL_OW 72
26636: AND
26637: IFFALSE 27371
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26639: LD_ADDR_EXP 121
26643: PUSH
26644: LD_EXP 121
26648: PPUSH
26649: LD_VAR 0 1
26653: PPUSH
26654: LD_INT 3
26656: PPUSH
26657: CALL_OW 1
26661: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26662: LD_ADDR_VAR 0 2
26666: PUSH
26667: LD_INT 0
26669: PUSH
26670: LD_INT 0
26672: PUSH
26673: LD_INT 0
26675: PUSH
26676: LD_INT 0
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: LIST
26683: LIST
26684: ST_TO_ADDR
// if not eng then
26685: LD_VAR 0 6
26689: NOT
26690: IFFALSE 26753
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26692: LD_ADDR_VAR 0 11
26696: PUSH
26697: LD_VAR 0 4
26701: PPUSH
26702: LD_INT 2
26704: PPUSH
26705: CALL 92051 0 2
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26714: LD_ADDR_VAR 0 2
26718: PUSH
26719: LD_VAR 0 2
26723: PPUSH
26724: LD_INT 2
26726: PPUSH
26727: LD_VAR 0 11
26731: PPUSH
26732: CALL_OW 1
26736: ST_TO_ADDR
// tmp := tmp diff p ;
26737: LD_ADDR_VAR 0 4
26741: PUSH
26742: LD_VAR 0 4
26746: PUSH
26747: LD_VAR 0 11
26751: DIFF
26752: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26753: LD_VAR 0 4
26757: PUSH
26758: LD_VAR 0 8
26762: PUSH
26763: LD_INT 6
26765: LESS
26766: AND
26767: IFFALSE 26955
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26769: LD_ADDR_VAR 0 9
26773: PUSH
26774: LD_VAR 0 4
26778: PUSH
26779: LD_VAR 0 8
26783: PUSH
26784: LD_VAR 0 7
26788: UNION
26789: DIFF
26790: PPUSH
26791: LD_INT 4
26793: PPUSH
26794: CALL 92051 0 2
26798: ST_TO_ADDR
// p := [ ] ;
26799: LD_ADDR_VAR 0 11
26803: PUSH
26804: EMPTY
26805: ST_TO_ADDR
// if sort then
26806: LD_VAR 0 9
26810: IFFALSE 26926
// for i = 1 to 6 - sci do
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: DOUBLE
26818: LD_INT 1
26820: DEC
26821: ST_TO_ADDR
26822: LD_INT 6
26824: PUSH
26825: LD_VAR 0 8
26829: MINUS
26830: PUSH
26831: FOR_TO
26832: IFFALSE 26924
// begin if i = sort then
26834: LD_VAR 0 3
26838: PUSH
26839: LD_VAR 0 9
26843: EQUAL
26844: IFFALSE 26848
// break ;
26846: GO 26924
// if GetClass ( i ) = 4 then
26848: LD_VAR 0 3
26852: PPUSH
26853: CALL_OW 257
26857: PUSH
26858: LD_INT 4
26860: EQUAL
26861: IFFALSE 26865
// continue ;
26863: GO 26831
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26865: LD_ADDR_VAR 0 11
26869: PUSH
26870: LD_VAR 0 11
26874: PPUSH
26875: LD_VAR 0 11
26879: PUSH
26880: LD_INT 1
26882: PLUS
26883: PPUSH
26884: LD_VAR 0 9
26888: PUSH
26889: LD_VAR 0 3
26893: ARRAY
26894: PPUSH
26895: CALL_OW 2
26899: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26900: LD_ADDR_VAR 0 4
26904: PUSH
26905: LD_VAR 0 4
26909: PUSH
26910: LD_VAR 0 9
26914: PUSH
26915: LD_VAR 0 3
26919: ARRAY
26920: DIFF
26921: ST_TO_ADDR
// end ;
26922: GO 26831
26924: POP
26925: POP
// if p then
26926: LD_VAR 0 11
26930: IFFALSE 26955
// result := Replace ( result , 4 , p ) ;
26932: LD_ADDR_VAR 0 2
26936: PUSH
26937: LD_VAR 0 2
26941: PPUSH
26942: LD_INT 4
26944: PPUSH
26945: LD_VAR 0 11
26949: PPUSH
26950: CALL_OW 1
26954: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26955: LD_VAR 0 4
26959: PUSH
26960: LD_VAR 0 7
26964: PUSH
26965: LD_INT 6
26967: LESS
26968: AND
26969: IFFALSE 27157
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26971: LD_ADDR_VAR 0 9
26975: PUSH
26976: LD_VAR 0 4
26980: PUSH
26981: LD_VAR 0 8
26985: PUSH
26986: LD_VAR 0 7
26990: UNION
26991: DIFF
26992: PPUSH
26993: LD_INT 3
26995: PPUSH
26996: CALL 92051 0 2
27000: ST_TO_ADDR
// p := [ ] ;
27001: LD_ADDR_VAR 0 11
27005: PUSH
27006: EMPTY
27007: ST_TO_ADDR
// if sort then
27008: LD_VAR 0 9
27012: IFFALSE 27128
// for i = 1 to 6 - mech do
27014: LD_ADDR_VAR 0 3
27018: PUSH
27019: DOUBLE
27020: LD_INT 1
27022: DEC
27023: ST_TO_ADDR
27024: LD_INT 6
27026: PUSH
27027: LD_VAR 0 7
27031: MINUS
27032: PUSH
27033: FOR_TO
27034: IFFALSE 27126
// begin if i = sort then
27036: LD_VAR 0 3
27040: PUSH
27041: LD_VAR 0 9
27045: EQUAL
27046: IFFALSE 27050
// break ;
27048: GO 27126
// if GetClass ( i ) = 3 then
27050: LD_VAR 0 3
27054: PPUSH
27055: CALL_OW 257
27059: PUSH
27060: LD_INT 3
27062: EQUAL
27063: IFFALSE 27067
// continue ;
27065: GO 27033
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27067: LD_ADDR_VAR 0 11
27071: PUSH
27072: LD_VAR 0 11
27076: PPUSH
27077: LD_VAR 0 11
27081: PUSH
27082: LD_INT 1
27084: PLUS
27085: PPUSH
27086: LD_VAR 0 9
27090: PUSH
27091: LD_VAR 0 3
27095: ARRAY
27096: PPUSH
27097: CALL_OW 2
27101: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27102: LD_ADDR_VAR 0 4
27106: PUSH
27107: LD_VAR 0 4
27111: PUSH
27112: LD_VAR 0 9
27116: PUSH
27117: LD_VAR 0 3
27121: ARRAY
27122: DIFF
27123: ST_TO_ADDR
// end ;
27124: GO 27033
27126: POP
27127: POP
// if p then
27128: LD_VAR 0 11
27132: IFFALSE 27157
// result := Replace ( result , 3 , p ) ;
27134: LD_ADDR_VAR 0 2
27138: PUSH
27139: LD_VAR 0 2
27143: PPUSH
27144: LD_INT 3
27146: PPUSH
27147: LD_VAR 0 11
27151: PPUSH
27152: CALL_OW 1
27156: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27157: LD_VAR 0 4
27161: PUSH
27162: LD_INT 6
27164: GREATER
27165: PUSH
27166: LD_VAR 0 6
27170: PUSH
27171: LD_INT 6
27173: LESS
27174: AND
27175: IFFALSE 27369
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27177: LD_ADDR_VAR 0 9
27181: PUSH
27182: LD_VAR 0 4
27186: PUSH
27187: LD_VAR 0 8
27191: PUSH
27192: LD_VAR 0 7
27196: UNION
27197: PUSH
27198: LD_VAR 0 6
27202: UNION
27203: DIFF
27204: PPUSH
27205: LD_INT 2
27207: PPUSH
27208: CALL 92051 0 2
27212: ST_TO_ADDR
// p := [ ] ;
27213: LD_ADDR_VAR 0 11
27217: PUSH
27218: EMPTY
27219: ST_TO_ADDR
// if sort then
27220: LD_VAR 0 9
27224: IFFALSE 27340
// for i = 1 to 6 - eng do
27226: LD_ADDR_VAR 0 3
27230: PUSH
27231: DOUBLE
27232: LD_INT 1
27234: DEC
27235: ST_TO_ADDR
27236: LD_INT 6
27238: PUSH
27239: LD_VAR 0 6
27243: MINUS
27244: PUSH
27245: FOR_TO
27246: IFFALSE 27338
// begin if i = sort then
27248: LD_VAR 0 3
27252: PUSH
27253: LD_VAR 0 9
27257: EQUAL
27258: IFFALSE 27262
// break ;
27260: GO 27338
// if GetClass ( i ) = 2 then
27262: LD_VAR 0 3
27266: PPUSH
27267: CALL_OW 257
27271: PUSH
27272: LD_INT 2
27274: EQUAL
27275: IFFALSE 27279
// continue ;
27277: GO 27245
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27279: LD_ADDR_VAR 0 11
27283: PUSH
27284: LD_VAR 0 11
27288: PPUSH
27289: LD_VAR 0 11
27293: PUSH
27294: LD_INT 1
27296: PLUS
27297: PPUSH
27298: LD_VAR 0 9
27302: PUSH
27303: LD_VAR 0 3
27307: ARRAY
27308: PPUSH
27309: CALL_OW 2
27313: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27314: LD_ADDR_VAR 0 4
27318: PUSH
27319: LD_VAR 0 4
27323: PUSH
27324: LD_VAR 0 9
27328: PUSH
27329: LD_VAR 0 3
27333: ARRAY
27334: DIFF
27335: ST_TO_ADDR
// end ;
27336: GO 27245
27338: POP
27339: POP
// if p then
27340: LD_VAR 0 11
27344: IFFALSE 27369
// result := Replace ( result , 2 , p ) ;
27346: LD_ADDR_VAR 0 2
27350: PUSH
27351: LD_VAR 0 2
27355: PPUSH
27356: LD_INT 2
27358: PPUSH
27359: LD_VAR 0 11
27363: PPUSH
27364: CALL_OW 1
27368: ST_TO_ADDR
// end ; exit ;
27369: GO 28757
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27371: LD_EXP 106
27375: PUSH
27376: LD_EXP 105
27380: PUSH
27381: LD_VAR 0 1
27385: ARRAY
27386: ARRAY
27387: NOT
27388: PUSH
27389: LD_EXP 79
27393: PUSH
27394: LD_VAR 0 1
27398: ARRAY
27399: PPUSH
27400: LD_INT 30
27402: PUSH
27403: LD_INT 3
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PPUSH
27410: CALL_OW 72
27414: AND
27415: PUSH
27416: LD_EXP 84
27420: PUSH
27421: LD_VAR 0 1
27425: ARRAY
27426: AND
27427: IFFALSE 28035
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27429: LD_ADDR_EXP 121
27433: PUSH
27434: LD_EXP 121
27438: PPUSH
27439: LD_VAR 0 1
27443: PPUSH
27444: LD_INT 5
27446: PPUSH
27447: CALL_OW 1
27451: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27452: LD_ADDR_VAR 0 2
27456: PUSH
27457: LD_INT 0
27459: PUSH
27460: LD_INT 0
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: LD_INT 0
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: ST_TO_ADDR
// if sci > 1 then
27475: LD_VAR 0 8
27479: PUSH
27480: LD_INT 1
27482: GREATER
27483: IFFALSE 27511
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27485: LD_ADDR_VAR 0 4
27489: PUSH
27490: LD_VAR 0 4
27494: PUSH
27495: LD_VAR 0 8
27499: PUSH
27500: LD_VAR 0 8
27504: PUSH
27505: LD_INT 1
27507: ARRAY
27508: DIFF
27509: DIFF
27510: ST_TO_ADDR
// if tmp and not sci then
27511: LD_VAR 0 4
27515: PUSH
27516: LD_VAR 0 8
27520: NOT
27521: AND
27522: IFFALSE 27591
// begin sort := SortBySkill ( tmp , 4 ) ;
27524: LD_ADDR_VAR 0 9
27528: PUSH
27529: LD_VAR 0 4
27533: PPUSH
27534: LD_INT 4
27536: PPUSH
27537: CALL 92051 0 2
27541: ST_TO_ADDR
// if sort then
27542: LD_VAR 0 9
27546: IFFALSE 27562
// p := sort [ 1 ] ;
27548: LD_ADDR_VAR 0 11
27552: PUSH
27553: LD_VAR 0 9
27557: PUSH
27558: LD_INT 1
27560: ARRAY
27561: ST_TO_ADDR
// if p then
27562: LD_VAR 0 11
27566: IFFALSE 27591
// result := Replace ( result , 4 , p ) ;
27568: LD_ADDR_VAR 0 2
27572: PUSH
27573: LD_VAR 0 2
27577: PPUSH
27578: LD_INT 4
27580: PPUSH
27581: LD_VAR 0 11
27585: PPUSH
27586: CALL_OW 1
27590: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27591: LD_ADDR_VAR 0 4
27595: PUSH
27596: LD_VAR 0 4
27600: PUSH
27601: LD_VAR 0 7
27605: DIFF
27606: ST_TO_ADDR
// if tmp and mech < 6 then
27607: LD_VAR 0 4
27611: PUSH
27612: LD_VAR 0 7
27616: PUSH
27617: LD_INT 6
27619: LESS
27620: AND
27621: IFFALSE 27809
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27623: LD_ADDR_VAR 0 9
27627: PUSH
27628: LD_VAR 0 4
27632: PUSH
27633: LD_VAR 0 8
27637: PUSH
27638: LD_VAR 0 7
27642: UNION
27643: DIFF
27644: PPUSH
27645: LD_INT 3
27647: PPUSH
27648: CALL 92051 0 2
27652: ST_TO_ADDR
// p := [ ] ;
27653: LD_ADDR_VAR 0 11
27657: PUSH
27658: EMPTY
27659: ST_TO_ADDR
// if sort then
27660: LD_VAR 0 9
27664: IFFALSE 27780
// for i = 1 to 6 - mech do
27666: LD_ADDR_VAR 0 3
27670: PUSH
27671: DOUBLE
27672: LD_INT 1
27674: DEC
27675: ST_TO_ADDR
27676: LD_INT 6
27678: PUSH
27679: LD_VAR 0 7
27683: MINUS
27684: PUSH
27685: FOR_TO
27686: IFFALSE 27778
// begin if i = sort then
27688: LD_VAR 0 3
27692: PUSH
27693: LD_VAR 0 9
27697: EQUAL
27698: IFFALSE 27702
// break ;
27700: GO 27778
// if GetClass ( i ) = 3 then
27702: LD_VAR 0 3
27706: PPUSH
27707: CALL_OW 257
27711: PUSH
27712: LD_INT 3
27714: EQUAL
27715: IFFALSE 27719
// continue ;
27717: GO 27685
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27719: LD_ADDR_VAR 0 11
27723: PUSH
27724: LD_VAR 0 11
27728: PPUSH
27729: LD_VAR 0 11
27733: PUSH
27734: LD_INT 1
27736: PLUS
27737: PPUSH
27738: LD_VAR 0 9
27742: PUSH
27743: LD_VAR 0 3
27747: ARRAY
27748: PPUSH
27749: CALL_OW 2
27753: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27754: LD_ADDR_VAR 0 4
27758: PUSH
27759: LD_VAR 0 4
27763: PUSH
27764: LD_VAR 0 9
27768: PUSH
27769: LD_VAR 0 3
27773: ARRAY
27774: DIFF
27775: ST_TO_ADDR
// end ;
27776: GO 27685
27778: POP
27779: POP
// if p then
27780: LD_VAR 0 11
27784: IFFALSE 27809
// result := Replace ( result , 3 , p ) ;
27786: LD_ADDR_VAR 0 2
27790: PUSH
27791: LD_VAR 0 2
27795: PPUSH
27796: LD_INT 3
27798: PPUSH
27799: LD_VAR 0 11
27803: PPUSH
27804: CALL_OW 1
27808: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27809: LD_ADDR_VAR 0 4
27813: PUSH
27814: LD_VAR 0 4
27818: PUSH
27819: LD_VAR 0 6
27823: DIFF
27824: ST_TO_ADDR
// if tmp and eng < 6 then
27825: LD_VAR 0 4
27829: PUSH
27830: LD_VAR 0 6
27834: PUSH
27835: LD_INT 6
27837: LESS
27838: AND
27839: IFFALSE 28033
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27841: LD_ADDR_VAR 0 9
27845: PUSH
27846: LD_VAR 0 4
27850: PUSH
27851: LD_VAR 0 8
27855: PUSH
27856: LD_VAR 0 7
27860: UNION
27861: PUSH
27862: LD_VAR 0 6
27866: UNION
27867: DIFF
27868: PPUSH
27869: LD_INT 2
27871: PPUSH
27872: CALL 92051 0 2
27876: ST_TO_ADDR
// p := [ ] ;
27877: LD_ADDR_VAR 0 11
27881: PUSH
27882: EMPTY
27883: ST_TO_ADDR
// if sort then
27884: LD_VAR 0 9
27888: IFFALSE 28004
// for i = 1 to 6 - eng do
27890: LD_ADDR_VAR 0 3
27894: PUSH
27895: DOUBLE
27896: LD_INT 1
27898: DEC
27899: ST_TO_ADDR
27900: LD_INT 6
27902: PUSH
27903: LD_VAR 0 6
27907: MINUS
27908: PUSH
27909: FOR_TO
27910: IFFALSE 28002
// begin if i = sort then
27912: LD_VAR 0 3
27916: PUSH
27917: LD_VAR 0 9
27921: EQUAL
27922: IFFALSE 27926
// break ;
27924: GO 28002
// if GetClass ( i ) = 2 then
27926: LD_VAR 0 3
27930: PPUSH
27931: CALL_OW 257
27935: PUSH
27936: LD_INT 2
27938: EQUAL
27939: IFFALSE 27943
// continue ;
27941: GO 27909
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27943: LD_ADDR_VAR 0 11
27947: PUSH
27948: LD_VAR 0 11
27952: PPUSH
27953: LD_VAR 0 11
27957: PUSH
27958: LD_INT 1
27960: PLUS
27961: PPUSH
27962: LD_VAR 0 9
27966: PUSH
27967: LD_VAR 0 3
27971: ARRAY
27972: PPUSH
27973: CALL_OW 2
27977: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27978: LD_ADDR_VAR 0 4
27982: PUSH
27983: LD_VAR 0 4
27987: PUSH
27988: LD_VAR 0 9
27992: PUSH
27993: LD_VAR 0 3
27997: ARRAY
27998: DIFF
27999: ST_TO_ADDR
// end ;
28000: GO 27909
28002: POP
28003: POP
// if p then
28004: LD_VAR 0 11
28008: IFFALSE 28033
// result := Replace ( result , 2 , p ) ;
28010: LD_ADDR_VAR 0 2
28014: PUSH
28015: LD_VAR 0 2
28019: PPUSH
28020: LD_INT 2
28022: PPUSH
28023: LD_VAR 0 11
28027: PPUSH
28028: CALL_OW 1
28032: ST_TO_ADDR
// end ; exit ;
28033: GO 28757
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28035: LD_EXP 106
28039: PUSH
28040: LD_EXP 105
28044: PUSH
28045: LD_VAR 0 1
28049: ARRAY
28050: ARRAY
28051: NOT
28052: PUSH
28053: LD_EXP 79
28057: PUSH
28058: LD_VAR 0 1
28062: ARRAY
28063: PPUSH
28064: LD_INT 30
28066: PUSH
28067: LD_INT 3
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PPUSH
28074: CALL_OW 72
28078: AND
28079: PUSH
28080: LD_EXP 84
28084: PUSH
28085: LD_VAR 0 1
28089: ARRAY
28090: NOT
28091: AND
28092: IFFALSE 28757
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28094: LD_ADDR_EXP 121
28098: PUSH
28099: LD_EXP 121
28103: PPUSH
28104: LD_VAR 0 1
28108: PPUSH
28109: LD_INT 6
28111: PPUSH
28112: CALL_OW 1
28116: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28117: LD_ADDR_VAR 0 2
28121: PUSH
28122: LD_INT 0
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 0
28133: PUSH
28134: EMPTY
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: ST_TO_ADDR
// if sci >= 1 then
28140: LD_VAR 0 8
28144: PUSH
28145: LD_INT 1
28147: GREATEREQUAL
28148: IFFALSE 28170
// tmp := tmp diff sci [ 1 ] ;
28150: LD_ADDR_VAR 0 4
28154: PUSH
28155: LD_VAR 0 4
28159: PUSH
28160: LD_VAR 0 8
28164: PUSH
28165: LD_INT 1
28167: ARRAY
28168: DIFF
28169: ST_TO_ADDR
// if tmp and not sci then
28170: LD_VAR 0 4
28174: PUSH
28175: LD_VAR 0 8
28179: NOT
28180: AND
28181: IFFALSE 28250
// begin sort := SortBySkill ( tmp , 4 ) ;
28183: LD_ADDR_VAR 0 9
28187: PUSH
28188: LD_VAR 0 4
28192: PPUSH
28193: LD_INT 4
28195: PPUSH
28196: CALL 92051 0 2
28200: ST_TO_ADDR
// if sort then
28201: LD_VAR 0 9
28205: IFFALSE 28221
// p := sort [ 1 ] ;
28207: LD_ADDR_VAR 0 11
28211: PUSH
28212: LD_VAR 0 9
28216: PUSH
28217: LD_INT 1
28219: ARRAY
28220: ST_TO_ADDR
// if p then
28221: LD_VAR 0 11
28225: IFFALSE 28250
// result := Replace ( result , 4 , p ) ;
28227: LD_ADDR_VAR 0 2
28231: PUSH
28232: LD_VAR 0 2
28236: PPUSH
28237: LD_INT 4
28239: PPUSH
28240: LD_VAR 0 11
28244: PPUSH
28245: CALL_OW 1
28249: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28250: LD_ADDR_VAR 0 4
28254: PUSH
28255: LD_VAR 0 4
28259: PUSH
28260: LD_VAR 0 7
28264: DIFF
28265: ST_TO_ADDR
// if tmp and mech < 6 then
28266: LD_VAR 0 4
28270: PUSH
28271: LD_VAR 0 7
28275: PUSH
28276: LD_INT 6
28278: LESS
28279: AND
28280: IFFALSE 28462
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28282: LD_ADDR_VAR 0 9
28286: PUSH
28287: LD_VAR 0 4
28291: PUSH
28292: LD_VAR 0 7
28296: DIFF
28297: PPUSH
28298: LD_INT 3
28300: PPUSH
28301: CALL 92051 0 2
28305: ST_TO_ADDR
// p := [ ] ;
28306: LD_ADDR_VAR 0 11
28310: PUSH
28311: EMPTY
28312: ST_TO_ADDR
// if sort then
28313: LD_VAR 0 9
28317: IFFALSE 28433
// for i = 1 to 6 - mech do
28319: LD_ADDR_VAR 0 3
28323: PUSH
28324: DOUBLE
28325: LD_INT 1
28327: DEC
28328: ST_TO_ADDR
28329: LD_INT 6
28331: PUSH
28332: LD_VAR 0 7
28336: MINUS
28337: PUSH
28338: FOR_TO
28339: IFFALSE 28431
// begin if i = sort then
28341: LD_VAR 0 3
28345: PUSH
28346: LD_VAR 0 9
28350: EQUAL
28351: IFFALSE 28355
// break ;
28353: GO 28431
// if GetClass ( i ) = 3 then
28355: LD_VAR 0 3
28359: PPUSH
28360: CALL_OW 257
28364: PUSH
28365: LD_INT 3
28367: EQUAL
28368: IFFALSE 28372
// continue ;
28370: GO 28338
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28372: LD_ADDR_VAR 0 11
28376: PUSH
28377: LD_VAR 0 11
28381: PPUSH
28382: LD_VAR 0 11
28386: PUSH
28387: LD_INT 1
28389: PLUS
28390: PPUSH
28391: LD_VAR 0 9
28395: PUSH
28396: LD_VAR 0 3
28400: ARRAY
28401: PPUSH
28402: CALL_OW 2
28406: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28407: LD_ADDR_VAR 0 4
28411: PUSH
28412: LD_VAR 0 4
28416: PUSH
28417: LD_VAR 0 9
28421: PUSH
28422: LD_VAR 0 3
28426: ARRAY
28427: DIFF
28428: ST_TO_ADDR
// end ;
28429: GO 28338
28431: POP
28432: POP
// if p then
28433: LD_VAR 0 11
28437: IFFALSE 28462
// result := Replace ( result , 3 , p ) ;
28439: LD_ADDR_VAR 0 2
28443: PUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: LD_INT 3
28451: PPUSH
28452: LD_VAR 0 11
28456: PPUSH
28457: CALL_OW 1
28461: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28462: LD_ADDR_VAR 0 4
28466: PUSH
28467: LD_VAR 0 4
28471: PUSH
28472: LD_VAR 0 6
28476: DIFF
28477: ST_TO_ADDR
// if tmp and eng < 4 then
28478: LD_VAR 0 4
28482: PUSH
28483: LD_VAR 0 6
28487: PUSH
28488: LD_INT 4
28490: LESS
28491: AND
28492: IFFALSE 28682
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28494: LD_ADDR_VAR 0 9
28498: PUSH
28499: LD_VAR 0 4
28503: PUSH
28504: LD_VAR 0 7
28508: PUSH
28509: LD_VAR 0 6
28513: UNION
28514: DIFF
28515: PPUSH
28516: LD_INT 2
28518: PPUSH
28519: CALL 92051 0 2
28523: ST_TO_ADDR
// p := [ ] ;
28524: LD_ADDR_VAR 0 11
28528: PUSH
28529: EMPTY
28530: ST_TO_ADDR
// if sort then
28531: LD_VAR 0 9
28535: IFFALSE 28651
// for i = 1 to 4 - eng do
28537: LD_ADDR_VAR 0 3
28541: PUSH
28542: DOUBLE
28543: LD_INT 1
28545: DEC
28546: ST_TO_ADDR
28547: LD_INT 4
28549: PUSH
28550: LD_VAR 0 6
28554: MINUS
28555: PUSH
28556: FOR_TO
28557: IFFALSE 28649
// begin if i = sort then
28559: LD_VAR 0 3
28563: PUSH
28564: LD_VAR 0 9
28568: EQUAL
28569: IFFALSE 28573
// break ;
28571: GO 28649
// if GetClass ( i ) = 2 then
28573: LD_VAR 0 3
28577: PPUSH
28578: CALL_OW 257
28582: PUSH
28583: LD_INT 2
28585: EQUAL
28586: IFFALSE 28590
// continue ;
28588: GO 28556
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28590: LD_ADDR_VAR 0 11
28594: PUSH
28595: LD_VAR 0 11
28599: PPUSH
28600: LD_VAR 0 11
28604: PUSH
28605: LD_INT 1
28607: PLUS
28608: PPUSH
28609: LD_VAR 0 9
28613: PUSH
28614: LD_VAR 0 3
28618: ARRAY
28619: PPUSH
28620: CALL_OW 2
28624: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28625: LD_ADDR_VAR 0 4
28629: PUSH
28630: LD_VAR 0 4
28634: PUSH
28635: LD_VAR 0 9
28639: PUSH
28640: LD_VAR 0 3
28644: ARRAY
28645: DIFF
28646: ST_TO_ADDR
// end ;
28647: GO 28556
28649: POP
28650: POP
// if p then
28651: LD_VAR 0 11
28655: IFFALSE 28680
// result := Replace ( result , 2 , p ) ;
28657: LD_ADDR_VAR 0 2
28661: PUSH
28662: LD_VAR 0 2
28666: PPUSH
28667: LD_INT 2
28669: PPUSH
28670: LD_VAR 0 11
28674: PPUSH
28675: CALL_OW 1
28679: ST_TO_ADDR
// end else
28680: GO 28726
// for i = eng downto 5 do
28682: LD_ADDR_VAR 0 3
28686: PUSH
28687: DOUBLE
28688: LD_VAR 0 6
28692: INC
28693: ST_TO_ADDR
28694: LD_INT 5
28696: PUSH
28697: FOR_DOWNTO
28698: IFFALSE 28724
// tmp := tmp union eng [ i ] ;
28700: LD_ADDR_VAR 0 4
28704: PUSH
28705: LD_VAR 0 4
28709: PUSH
28710: LD_VAR 0 6
28714: PUSH
28715: LD_VAR 0 3
28719: ARRAY
28720: UNION
28721: ST_TO_ADDR
28722: GO 28697
28724: POP
28725: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28726: LD_ADDR_VAR 0 2
28730: PUSH
28731: LD_VAR 0 2
28735: PPUSH
28736: LD_INT 1
28738: PPUSH
28739: LD_VAR 0 4
28743: PUSH
28744: LD_VAR 0 5
28748: DIFF
28749: PPUSH
28750: CALL_OW 1
28754: ST_TO_ADDR
// exit ;
28755: GO 28757
// end ; end ;
28757: LD_VAR 0 2
28761: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28762: LD_INT 0
28764: PPUSH
28765: PPUSH
28766: PPUSH
// if not mc_bases then
28767: LD_EXP 79
28771: NOT
28772: IFFALSE 28776
// exit ;
28774: GO 28882
// for i = 1 to mc_bases do
28776: LD_ADDR_VAR 0 2
28780: PUSH
28781: DOUBLE
28782: LD_INT 1
28784: DEC
28785: ST_TO_ADDR
28786: LD_EXP 79
28790: PUSH
28791: FOR_TO
28792: IFFALSE 28873
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28794: LD_ADDR_VAR 0 3
28798: PUSH
28799: LD_EXP 79
28803: PUSH
28804: LD_VAR 0 2
28808: ARRAY
28809: PPUSH
28810: LD_INT 21
28812: PUSH
28813: LD_INT 3
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 3
28822: PUSH
28823: LD_INT 24
28825: PUSH
28826: LD_INT 1000
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: EMPTY
28838: LIST
28839: LIST
28840: PPUSH
28841: CALL_OW 72
28845: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28846: LD_ADDR_EXP 80
28850: PUSH
28851: LD_EXP 80
28855: PPUSH
28856: LD_VAR 0 2
28860: PPUSH
28861: LD_VAR 0 3
28865: PPUSH
28866: CALL_OW 1
28870: ST_TO_ADDR
// end ;
28871: GO 28791
28873: POP
28874: POP
// RaiseSailEvent ( 101 ) ;
28875: LD_INT 101
28877: PPUSH
28878: CALL_OW 427
// end ;
28882: LD_VAR 0 1
28886: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28887: LD_INT 0
28889: PPUSH
28890: PPUSH
28891: PPUSH
28892: PPUSH
28893: PPUSH
28894: PPUSH
28895: PPUSH
// if not mc_bases then
28896: LD_EXP 79
28900: NOT
28901: IFFALSE 28905
// exit ;
28903: GO 29478
// for i = 1 to mc_bases do
28905: LD_ADDR_VAR 0 2
28909: PUSH
28910: DOUBLE
28911: LD_INT 1
28913: DEC
28914: ST_TO_ADDR
28915: LD_EXP 79
28919: PUSH
28920: FOR_TO
28921: IFFALSE 29469
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28923: LD_ADDR_VAR 0 5
28927: PUSH
28928: LD_EXP 79
28932: PUSH
28933: LD_VAR 0 2
28937: ARRAY
28938: PUSH
28939: LD_EXP 108
28943: PUSH
28944: LD_VAR 0 2
28948: ARRAY
28949: UNION
28950: PPUSH
28951: LD_INT 21
28953: PUSH
28954: LD_INT 1
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: PUSH
28964: LD_INT 3
28966: PUSH
28967: LD_INT 54
28969: PUSH
28970: EMPTY
28971: LIST
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 3
28979: PUSH
28980: LD_INT 24
28982: PUSH
28983: LD_INT 800
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: LIST
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PPUSH
29003: CALL_OW 72
29007: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29008: LD_ADDR_VAR 0 6
29012: PUSH
29013: LD_EXP 79
29017: PUSH
29018: LD_VAR 0 2
29022: ARRAY
29023: PPUSH
29024: LD_INT 21
29026: PUSH
29027: LD_INT 1
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: LD_INT 3
29039: PUSH
29040: LD_INT 54
29042: PUSH
29043: EMPTY
29044: LIST
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: PUSH
29050: LD_INT 3
29052: PUSH
29053: LD_INT 24
29055: PUSH
29056: LD_INT 250
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: LIST
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PPUSH
29076: CALL_OW 72
29080: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29081: LD_ADDR_VAR 0 7
29085: PUSH
29086: LD_VAR 0 5
29090: PUSH
29091: LD_VAR 0 6
29095: DIFF
29096: ST_TO_ADDR
// if not need_heal_1 then
29097: LD_VAR 0 6
29101: NOT
29102: IFFALSE 29135
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29104: LD_ADDR_EXP 82
29108: PUSH
29109: LD_EXP 82
29113: PPUSH
29114: LD_VAR 0 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PPUSH
29126: EMPTY
29127: PPUSH
29128: CALL 57793 0 3
29132: ST_TO_ADDR
29133: GO 29205
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29135: LD_ADDR_EXP 82
29139: PUSH
29140: LD_EXP 82
29144: PPUSH
29145: LD_VAR 0 2
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PPUSH
29157: LD_EXP 82
29161: PUSH
29162: LD_VAR 0 2
29166: ARRAY
29167: PUSH
29168: LD_INT 1
29170: ARRAY
29171: PPUSH
29172: LD_INT 3
29174: PUSH
29175: LD_INT 24
29177: PUSH
29178: LD_INT 1000
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PPUSH
29189: CALL_OW 72
29193: PUSH
29194: LD_VAR 0 6
29198: UNION
29199: PPUSH
29200: CALL 57793 0 3
29204: ST_TO_ADDR
// if not need_heal_2 then
29205: LD_VAR 0 7
29209: NOT
29210: IFFALSE 29243
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29212: LD_ADDR_EXP 82
29216: PUSH
29217: LD_EXP 82
29221: PPUSH
29222: LD_VAR 0 2
29226: PUSH
29227: LD_INT 2
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PPUSH
29234: EMPTY
29235: PPUSH
29236: CALL 57793 0 3
29240: ST_TO_ADDR
29241: GO 29275
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29243: LD_ADDR_EXP 82
29247: PUSH
29248: LD_EXP 82
29252: PPUSH
29253: LD_VAR 0 2
29257: PUSH
29258: LD_INT 2
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PPUSH
29265: LD_VAR 0 7
29269: PPUSH
29270: CALL 57793 0 3
29274: ST_TO_ADDR
// if need_heal_2 then
29275: LD_VAR 0 7
29279: IFFALSE 29451
// for j in need_heal_2 do
29281: LD_ADDR_VAR 0 3
29285: PUSH
29286: LD_VAR 0 7
29290: PUSH
29291: FOR_IN
29292: IFFALSE 29449
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29294: LD_ADDR_VAR 0 5
29298: PUSH
29299: LD_EXP 79
29303: PUSH
29304: LD_VAR 0 2
29308: ARRAY
29309: PPUSH
29310: LD_INT 2
29312: PUSH
29313: LD_INT 30
29315: PUSH
29316: LD_INT 6
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 30
29325: PUSH
29326: LD_INT 7
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 30
29335: PUSH
29336: LD_INT 8
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 30
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 30
29355: PUSH
29356: LD_INT 1
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 25
29365: PUSH
29366: LD_INT 4
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: LIST
29377: LIST
29378: LIST
29379: LIST
29380: LIST
29381: PPUSH
29382: CALL_OW 72
29386: ST_TO_ADDR
// if tmp then
29387: LD_VAR 0 5
29391: IFFALSE 29447
// begin k := NearestUnitToUnit ( tmp , j ) ;
29393: LD_ADDR_VAR 0 4
29397: PUSH
29398: LD_VAR 0 5
29402: PPUSH
29403: LD_VAR 0 3
29407: PPUSH
29408: CALL_OW 74
29412: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29413: LD_VAR 0 3
29417: PPUSH
29418: LD_VAR 0 4
29422: PPUSH
29423: CALL_OW 296
29427: PUSH
29428: LD_INT 7
29430: GREATER
29431: IFFALSE 29447
// ComMoveUnit ( j , k ) ;
29433: LD_VAR 0 3
29437: PPUSH
29438: LD_VAR 0 4
29442: PPUSH
29443: CALL_OW 112
// end ; end ;
29447: GO 29291
29449: POP
29450: POP
// if not need_heal_1 and not need_heal_2 then
29451: LD_VAR 0 6
29455: NOT
29456: PUSH
29457: LD_VAR 0 7
29461: NOT
29462: AND
29463: IFFALSE 29467
// continue ;
29465: GO 28920
// end ;
29467: GO 28920
29469: POP
29470: POP
// RaiseSailEvent ( 102 ) ;
29471: LD_INT 102
29473: PPUSH
29474: CALL_OW 427
// end ;
29478: LD_VAR 0 1
29482: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29483: LD_INT 0
29485: PPUSH
29486: PPUSH
29487: PPUSH
29488: PPUSH
29489: PPUSH
29490: PPUSH
29491: PPUSH
29492: PPUSH
// if not mc_bases then
29493: LD_EXP 79
29497: NOT
29498: IFFALSE 29502
// exit ;
29500: GO 30342
// for i = 1 to mc_bases do
29502: LD_ADDR_VAR 0 2
29506: PUSH
29507: DOUBLE
29508: LD_INT 1
29510: DEC
29511: ST_TO_ADDR
29512: LD_EXP 79
29516: PUSH
29517: FOR_TO
29518: IFFALSE 30340
// begin if not mc_building_need_repair [ i ] then
29520: LD_EXP 80
29524: PUSH
29525: LD_VAR 0 2
29529: ARRAY
29530: NOT
29531: IFFALSE 29705
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29533: LD_ADDR_VAR 0 6
29537: PUSH
29538: LD_EXP 98
29542: PUSH
29543: LD_VAR 0 2
29547: ARRAY
29548: PPUSH
29549: LD_INT 3
29551: PUSH
29552: LD_INT 24
29554: PUSH
29555: LD_INT 1000
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 34
29571: PUSH
29572: LD_INT 13
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: LD_INT 34
29581: PUSH
29582: LD_INT 52
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: LIST
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PPUSH
29598: CALL_OW 72
29602: ST_TO_ADDR
// if cranes then
29603: LD_VAR 0 6
29607: IFFALSE 29669
// for j in cranes do
29609: LD_ADDR_VAR 0 3
29613: PUSH
29614: LD_VAR 0 6
29618: PUSH
29619: FOR_IN
29620: IFFALSE 29667
// if not IsInArea ( j , mc_parking [ i ] ) then
29622: LD_VAR 0 3
29626: PPUSH
29627: LD_EXP 103
29631: PUSH
29632: LD_VAR 0 2
29636: ARRAY
29637: PPUSH
29638: CALL_OW 308
29642: NOT
29643: IFFALSE 29665
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29645: LD_VAR 0 3
29649: PPUSH
29650: LD_EXP 103
29654: PUSH
29655: LD_VAR 0 2
29659: ARRAY
29660: PPUSH
29661: CALL_OW 113
29665: GO 29619
29667: POP
29668: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29669: LD_ADDR_EXP 81
29673: PUSH
29674: LD_EXP 81
29678: PPUSH
29679: LD_VAR 0 2
29683: PPUSH
29684: EMPTY
29685: PPUSH
29686: CALL_OW 1
29690: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29691: LD_VAR 0 2
29695: PPUSH
29696: LD_INT 101
29698: PPUSH
29699: CALL 24595 0 2
// continue ;
29703: GO 29517
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29705: LD_ADDR_EXP 85
29709: PUSH
29710: LD_EXP 85
29714: PPUSH
29715: LD_VAR 0 2
29719: PPUSH
29720: EMPTY
29721: PPUSH
29722: CALL_OW 1
29726: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29727: LD_VAR 0 2
29731: PPUSH
29732: LD_INT 103
29734: PPUSH
29735: CALL 24595 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29739: LD_ADDR_VAR 0 5
29743: PUSH
29744: LD_EXP 79
29748: PUSH
29749: LD_VAR 0 2
29753: ARRAY
29754: PUSH
29755: LD_EXP 108
29759: PUSH
29760: LD_VAR 0 2
29764: ARRAY
29765: UNION
29766: PPUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 25
29772: PUSH
29773: LD_INT 2
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 25
29782: PUSH
29783: LD_INT 16
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: LIST
29794: PUSH
29795: EMPTY
29796: LIST
29797: PPUSH
29798: CALL_OW 72
29802: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29803: LD_ADDR_VAR 0 6
29807: PUSH
29808: LD_EXP 98
29812: PUSH
29813: LD_VAR 0 2
29817: ARRAY
29818: PPUSH
29819: LD_INT 2
29821: PUSH
29822: LD_INT 34
29824: PUSH
29825: LD_INT 13
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 34
29834: PUSH
29835: LD_INT 52
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: LIST
29846: PPUSH
29847: CALL_OW 72
29851: ST_TO_ADDR
// if cranes then
29852: LD_VAR 0 6
29856: IFFALSE 29992
// begin for j in cranes do
29858: LD_ADDR_VAR 0 3
29862: PUSH
29863: LD_VAR 0 6
29867: PUSH
29868: FOR_IN
29869: IFFALSE 29990
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29871: LD_VAR 0 3
29875: PPUSH
29876: CALL_OW 256
29880: PUSH
29881: LD_INT 500
29883: GREATEREQUAL
29884: PUSH
29885: LD_VAR 0 3
29889: PPUSH
29890: CALL_OW 314
29894: NOT
29895: AND
29896: IFFALSE 29930
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29898: LD_VAR 0 3
29902: PPUSH
29903: LD_EXP 80
29907: PUSH
29908: LD_VAR 0 2
29912: ARRAY
29913: PPUSH
29914: LD_VAR 0 3
29918: PPUSH
29919: CALL_OW 74
29923: PPUSH
29924: CALL_OW 130
29928: GO 29988
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29930: LD_VAR 0 3
29934: PPUSH
29935: CALL_OW 256
29939: PUSH
29940: LD_INT 500
29942: LESS
29943: PUSH
29944: LD_VAR 0 3
29948: PPUSH
29949: LD_EXP 103
29953: PUSH
29954: LD_VAR 0 2
29958: ARRAY
29959: PPUSH
29960: CALL_OW 308
29964: NOT
29965: AND
29966: IFFALSE 29988
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29968: LD_VAR 0 3
29972: PPUSH
29973: LD_EXP 103
29977: PUSH
29978: LD_VAR 0 2
29982: ARRAY
29983: PPUSH
29984: CALL_OW 113
29988: GO 29868
29990: POP
29991: POP
// end ; if not tmp then
29992: LD_VAR 0 5
29996: NOT
29997: IFFALSE 30001
// continue ;
29999: GO 29517
// for j in tmp do
30001: LD_ADDR_VAR 0 3
30005: PUSH
30006: LD_VAR 0 5
30010: PUSH
30011: FOR_IN
30012: IFFALSE 30336
// begin if mc_need_heal [ i ] then
30014: LD_EXP 82
30018: PUSH
30019: LD_VAR 0 2
30023: ARRAY
30024: IFFALSE 30072
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
30026: LD_VAR 0 3
30030: PUSH
30031: LD_EXP 82
30035: PUSH
30036: LD_VAR 0 2
30040: ARRAY
30041: PUSH
30042: LD_INT 1
30044: ARRAY
30045: IN
30046: PUSH
30047: LD_VAR 0 3
30051: PUSH
30052: LD_EXP 82
30056: PUSH
30057: LD_VAR 0 2
30061: ARRAY
30062: PUSH
30063: LD_INT 2
30065: ARRAY
30066: IN
30067: OR
30068: IFFALSE 30072
// continue ;
30070: GO 30011
// if IsInUnit ( j ) then
30072: LD_VAR 0 3
30076: PPUSH
30077: CALL_OW 310
30081: IFFALSE 30092
// ComExitBuilding ( j ) ;
30083: LD_VAR 0 3
30087: PPUSH
30088: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30092: LD_VAR 0 3
30096: PUSH
30097: LD_EXP 81
30101: PUSH
30102: LD_VAR 0 2
30106: ARRAY
30107: IN
30108: NOT
30109: IFFALSE 30167
// begin SetTag ( j , 101 ) ;
30111: LD_VAR 0 3
30115: PPUSH
30116: LD_INT 101
30118: PPUSH
30119: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30123: LD_ADDR_EXP 81
30127: PUSH
30128: LD_EXP 81
30132: PPUSH
30133: LD_VAR 0 2
30137: PUSH
30138: LD_EXP 81
30142: PUSH
30143: LD_VAR 0 2
30147: ARRAY
30148: PUSH
30149: LD_INT 1
30151: PLUS
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PPUSH
30157: LD_VAR 0 3
30161: PPUSH
30162: CALL 57793 0 3
30166: ST_TO_ADDR
// end ; wait ( 1 ) ;
30167: LD_INT 1
30169: PPUSH
30170: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30174: LD_ADDR_VAR 0 7
30178: PUSH
30179: LD_EXP 80
30183: PUSH
30184: LD_VAR 0 2
30188: ARRAY
30189: ST_TO_ADDR
// if mc_scan [ i ] then
30190: LD_EXP 102
30194: PUSH
30195: LD_VAR 0 2
30199: ARRAY
30200: IFFALSE 30269
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
30202: LD_ADDR_VAR 0 7
30206: PUSH
30207: LD_EXP 80
30211: PUSH
30212: LD_VAR 0 2
30216: ARRAY
30217: PPUSH
30218: LD_INT 3
30220: PUSH
30221: LD_INT 2
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 32
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 30
30236: PUSH
30237: LD_INT 33
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 30
30246: PUSH
30247: LD_INT 31
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PPUSH
30264: CALL_OW 72
30268: ST_TO_ADDR
// if not to_repair_tmp then
30269: LD_VAR 0 7
30273: NOT
30274: IFFALSE 30278
// continue ;
30276: GO 30011
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30278: LD_ADDR_VAR 0 8
30282: PUSH
30283: LD_VAR 0 7
30287: PPUSH
30288: LD_VAR 0 3
30292: PPUSH
30293: CALL_OW 74
30297: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30298: LD_VAR 0 8
30302: PPUSH
30303: LD_INT 14
30305: PPUSH
30306: CALL 60386 0 2
30310: PUSH
30311: LD_INT 4
30313: ARRAY
30314: PUSH
30315: LD_INT 5
30317: LESS
30318: IFFALSE 30334
// ComRepairBuilding ( j , to_repair ) ;
30320: LD_VAR 0 3
30324: PPUSH
30325: LD_VAR 0 8
30329: PPUSH
30330: CALL_OW 130
// end ;
30334: GO 30011
30336: POP
30337: POP
// end ;
30338: GO 29517
30340: POP
30341: POP
// end ;
30342: LD_VAR 0 1
30346: RET
// export function MC_Heal ; var i , j , tmp ; begin
30347: LD_INT 0
30349: PPUSH
30350: PPUSH
30351: PPUSH
30352: PPUSH
// if not mc_bases then
30353: LD_EXP 79
30357: NOT
30358: IFFALSE 30362
// exit ;
30360: GO 30764
// for i = 1 to mc_bases do
30362: LD_ADDR_VAR 0 2
30366: PUSH
30367: DOUBLE
30368: LD_INT 1
30370: DEC
30371: ST_TO_ADDR
30372: LD_EXP 79
30376: PUSH
30377: FOR_TO
30378: IFFALSE 30762
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30380: LD_EXP 82
30384: PUSH
30385: LD_VAR 0 2
30389: ARRAY
30390: PUSH
30391: LD_INT 1
30393: ARRAY
30394: NOT
30395: PUSH
30396: LD_EXP 82
30400: PUSH
30401: LD_VAR 0 2
30405: ARRAY
30406: PUSH
30407: LD_INT 2
30409: ARRAY
30410: NOT
30411: AND
30412: IFFALSE 30450
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30414: LD_ADDR_EXP 83
30418: PUSH
30419: LD_EXP 83
30423: PPUSH
30424: LD_VAR 0 2
30428: PPUSH
30429: EMPTY
30430: PPUSH
30431: CALL_OW 1
30435: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30436: LD_VAR 0 2
30440: PPUSH
30441: LD_INT 102
30443: PPUSH
30444: CALL 24595 0 2
// continue ;
30448: GO 30377
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30450: LD_ADDR_VAR 0 4
30454: PUSH
30455: LD_EXP 79
30459: PUSH
30460: LD_VAR 0 2
30464: ARRAY
30465: PPUSH
30466: LD_INT 25
30468: PUSH
30469: LD_INT 4
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PPUSH
30476: CALL_OW 72
30480: ST_TO_ADDR
// if not tmp then
30481: LD_VAR 0 4
30485: NOT
30486: IFFALSE 30490
// continue ;
30488: GO 30377
// if mc_taming [ i ] then
30490: LD_EXP 110
30494: PUSH
30495: LD_VAR 0 2
30499: ARRAY
30500: IFFALSE 30524
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30502: LD_ADDR_EXP 110
30506: PUSH
30507: LD_EXP 110
30511: PPUSH
30512: LD_VAR 0 2
30516: PPUSH
30517: EMPTY
30518: PPUSH
30519: CALL_OW 1
30523: ST_TO_ADDR
// for j in tmp do
30524: LD_ADDR_VAR 0 3
30528: PUSH
30529: LD_VAR 0 4
30533: PUSH
30534: FOR_IN
30535: IFFALSE 30758
// begin if IsInUnit ( j ) then
30537: LD_VAR 0 3
30541: PPUSH
30542: CALL_OW 310
30546: IFFALSE 30557
// ComExitBuilding ( j ) ;
30548: LD_VAR 0 3
30552: PPUSH
30553: CALL_OW 122
// if not j in mc_healers [ i ] then
30557: LD_VAR 0 3
30561: PUSH
30562: LD_EXP 83
30566: PUSH
30567: LD_VAR 0 2
30571: ARRAY
30572: IN
30573: NOT
30574: IFFALSE 30620
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30576: LD_ADDR_EXP 83
30580: PUSH
30581: LD_EXP 83
30585: PPUSH
30586: LD_VAR 0 2
30590: PUSH
30591: LD_EXP 83
30595: PUSH
30596: LD_VAR 0 2
30600: ARRAY
30601: PUSH
30602: LD_INT 1
30604: PLUS
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PPUSH
30610: LD_VAR 0 3
30614: PPUSH
30615: CALL 57793 0 3
30619: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30620: LD_VAR 0 3
30624: PPUSH
30625: CALL_OW 110
30629: PUSH
30630: LD_INT 102
30632: NONEQUAL
30633: IFFALSE 30647
// SetTag ( j , 102 ) ;
30635: LD_VAR 0 3
30639: PPUSH
30640: LD_INT 102
30642: PPUSH
30643: CALL_OW 109
// Wait ( 3 ) ;
30647: LD_INT 3
30649: PPUSH
30650: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30654: LD_EXP 82
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: PUSH
30665: LD_INT 1
30667: ARRAY
30668: IFFALSE 30700
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30670: LD_VAR 0 3
30674: PPUSH
30675: LD_EXP 82
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: PUSH
30686: LD_INT 1
30688: ARRAY
30689: PUSH
30690: LD_INT 1
30692: ARRAY
30693: PPUSH
30694: CALL_OW 128
30698: GO 30756
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30700: LD_VAR 0 3
30704: PPUSH
30705: CALL_OW 314
30709: NOT
30710: PUSH
30711: LD_EXP 82
30715: PUSH
30716: LD_VAR 0 2
30720: ARRAY
30721: PUSH
30722: LD_INT 2
30724: ARRAY
30725: AND
30726: IFFALSE 30756
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30728: LD_VAR 0 3
30732: PPUSH
30733: LD_EXP 82
30737: PUSH
30738: LD_VAR 0 2
30742: ARRAY
30743: PUSH
30744: LD_INT 2
30746: ARRAY
30747: PUSH
30748: LD_INT 1
30750: ARRAY
30751: PPUSH
30752: CALL_OW 128
// end ;
30756: GO 30534
30758: POP
30759: POP
// end ;
30760: GO 30377
30762: POP
30763: POP
// end ;
30764: LD_VAR 0 1
30768: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30769: LD_INT 0
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
// if not mc_bases then
30776: LD_EXP 79
30780: NOT
30781: IFFALSE 30785
// exit ;
30783: GO 31928
// for i = 1 to mc_bases do
30785: LD_ADDR_VAR 0 2
30789: PUSH
30790: DOUBLE
30791: LD_INT 1
30793: DEC
30794: ST_TO_ADDR
30795: LD_EXP 79
30799: PUSH
30800: FOR_TO
30801: IFFALSE 31926
// begin if mc_scan [ i ] then
30803: LD_EXP 102
30807: PUSH
30808: LD_VAR 0 2
30812: ARRAY
30813: IFFALSE 30817
// continue ;
30815: GO 30800
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30817: LD_EXP 84
30821: PUSH
30822: LD_VAR 0 2
30826: ARRAY
30827: NOT
30828: PUSH
30829: LD_EXP 86
30833: PUSH
30834: LD_VAR 0 2
30838: ARRAY
30839: NOT
30840: AND
30841: PUSH
30842: LD_EXP 85
30846: PUSH
30847: LD_VAR 0 2
30851: ARRAY
30852: AND
30853: IFFALSE 30891
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30855: LD_ADDR_EXP 85
30859: PUSH
30860: LD_EXP 85
30864: PPUSH
30865: LD_VAR 0 2
30869: PPUSH
30870: EMPTY
30871: PPUSH
30872: CALL_OW 1
30876: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30877: LD_VAR 0 2
30881: PPUSH
30882: LD_INT 103
30884: PPUSH
30885: CALL 24595 0 2
// continue ;
30889: GO 30800
// end ; if mc_construct_list [ i ] then
30891: LD_EXP 86
30895: PUSH
30896: LD_VAR 0 2
30900: ARRAY
30901: IFFALSE 31121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30903: LD_ADDR_VAR 0 4
30907: PUSH
30908: LD_EXP 79
30912: PUSH
30913: LD_VAR 0 2
30917: ARRAY
30918: PPUSH
30919: LD_INT 25
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PPUSH
30929: CALL_OW 72
30933: PUSH
30934: LD_EXP 81
30938: PUSH
30939: LD_VAR 0 2
30943: ARRAY
30944: DIFF
30945: ST_TO_ADDR
// if not tmp then
30946: LD_VAR 0 4
30950: NOT
30951: IFFALSE 30955
// continue ;
30953: GO 30800
// for j in tmp do
30955: LD_ADDR_VAR 0 3
30959: PUSH
30960: LD_VAR 0 4
30964: PUSH
30965: FOR_IN
30966: IFFALSE 31117
// begin if not mc_builders [ i ] then
30968: LD_EXP 85
30972: PUSH
30973: LD_VAR 0 2
30977: ARRAY
30978: NOT
30979: IFFALSE 31037
// begin SetTag ( j , 103 ) ;
30981: LD_VAR 0 3
30985: PPUSH
30986: LD_INT 103
30988: PPUSH
30989: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30993: LD_ADDR_EXP 85
30997: PUSH
30998: LD_EXP 85
31002: PPUSH
31003: LD_VAR 0 2
31007: PUSH
31008: LD_EXP 85
31012: PUSH
31013: LD_VAR 0 2
31017: ARRAY
31018: PUSH
31019: LD_INT 1
31021: PLUS
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: PPUSH
31027: LD_VAR 0 3
31031: PPUSH
31032: CALL 57793 0 3
31036: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31037: LD_VAR 0 3
31041: PPUSH
31042: CALL_OW 310
31046: IFFALSE 31057
// ComExitBuilding ( j ) ;
31048: LD_VAR 0 3
31052: PPUSH
31053: CALL_OW 122
// wait ( 3 ) ;
31057: LD_INT 3
31059: PPUSH
31060: CALL_OW 67
// if not mc_construct_list [ i ] then
31064: LD_EXP 86
31068: PUSH
31069: LD_VAR 0 2
31073: ARRAY
31074: NOT
31075: IFFALSE 31079
// break ;
31077: GO 31117
// if not HasTask ( j ) then
31079: LD_VAR 0 3
31083: PPUSH
31084: CALL_OW 314
31088: NOT
31089: IFFALSE 31115
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31091: LD_VAR 0 3
31095: PPUSH
31096: LD_EXP 86
31100: PUSH
31101: LD_VAR 0 2
31105: ARRAY
31106: PUSH
31107: LD_INT 1
31109: ARRAY
31110: PPUSH
31111: CALL 60644 0 2
// end ;
31115: GO 30965
31117: POP
31118: POP
// end else
31119: GO 31924
// if mc_build_list [ i ] then
31121: LD_EXP 84
31125: PUSH
31126: LD_VAR 0 2
31130: ARRAY
31131: IFFALSE 31924
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31133: LD_ADDR_VAR 0 5
31137: PUSH
31138: LD_EXP 79
31142: PUSH
31143: LD_VAR 0 2
31147: ARRAY
31148: PPUSH
31149: LD_INT 2
31151: PUSH
31152: LD_INT 30
31154: PUSH
31155: LD_INT 0
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 30
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: LIST
31176: PPUSH
31177: CALL_OW 72
31181: ST_TO_ADDR
// if depot then
31182: LD_VAR 0 5
31186: IFFALSE 31204
// depot := depot [ 1 ] else
31188: LD_ADDR_VAR 0 5
31192: PUSH
31193: LD_VAR 0 5
31197: PUSH
31198: LD_INT 1
31200: ARRAY
31201: ST_TO_ADDR
31202: GO 31212
// depot := 0 ;
31204: LD_ADDR_VAR 0 5
31208: PUSH
31209: LD_INT 0
31211: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31212: LD_EXP 84
31216: PUSH
31217: LD_VAR 0 2
31221: ARRAY
31222: PUSH
31223: LD_INT 1
31225: ARRAY
31226: PUSH
31227: LD_INT 1
31229: ARRAY
31230: PPUSH
31231: CALL 60474 0 1
31235: PUSH
31236: LD_EXP 79
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PPUSH
31247: LD_INT 2
31249: PUSH
31250: LD_INT 30
31252: PUSH
31253: LD_INT 2
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 30
31262: PUSH
31263: LD_INT 3
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: LIST
31274: PPUSH
31275: CALL_OW 72
31279: NOT
31280: AND
31281: IFFALSE 31386
// begin for j = 1 to mc_build_list [ i ] do
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: DOUBLE
31289: LD_INT 1
31291: DEC
31292: ST_TO_ADDR
31293: LD_EXP 84
31297: PUSH
31298: LD_VAR 0 2
31302: ARRAY
31303: PUSH
31304: FOR_TO
31305: IFFALSE 31384
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31307: LD_EXP 84
31311: PUSH
31312: LD_VAR 0 2
31316: ARRAY
31317: PUSH
31318: LD_VAR 0 3
31322: ARRAY
31323: PUSH
31324: LD_INT 1
31326: ARRAY
31327: PUSH
31328: LD_INT 2
31330: EQUAL
31331: IFFALSE 31382
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31333: LD_ADDR_EXP 84
31337: PUSH
31338: LD_EXP 84
31342: PPUSH
31343: LD_VAR 0 2
31347: PPUSH
31348: LD_EXP 84
31352: PUSH
31353: LD_VAR 0 2
31357: ARRAY
31358: PPUSH
31359: LD_VAR 0 3
31363: PPUSH
31364: LD_INT 1
31366: PPUSH
31367: LD_INT 0
31369: PPUSH
31370: CALL 57211 0 4
31374: PPUSH
31375: CALL_OW 1
31379: ST_TO_ADDR
// break ;
31380: GO 31384
// end ;
31382: GO 31304
31384: POP
31385: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31386: LD_EXP 84
31390: PUSH
31391: LD_VAR 0 2
31395: ARRAY
31396: PUSH
31397: LD_INT 1
31399: ARRAY
31400: PUSH
31401: LD_INT 1
31403: ARRAY
31404: PUSH
31405: LD_INT 0
31407: EQUAL
31408: PUSH
31409: LD_VAR 0 5
31413: PUSH
31414: LD_VAR 0 5
31418: PPUSH
31419: LD_EXP 84
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: PUSH
31434: LD_INT 1
31436: ARRAY
31437: PPUSH
31438: LD_EXP 84
31442: PUSH
31443: LD_VAR 0 2
31447: ARRAY
31448: PUSH
31449: LD_INT 1
31451: ARRAY
31452: PUSH
31453: LD_INT 2
31455: ARRAY
31456: PPUSH
31457: LD_EXP 84
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: PUSH
31468: LD_INT 1
31470: ARRAY
31471: PUSH
31472: LD_INT 3
31474: ARRAY
31475: PPUSH
31476: LD_EXP 84
31480: PUSH
31481: LD_VAR 0 2
31485: ARRAY
31486: PUSH
31487: LD_INT 1
31489: ARRAY
31490: PUSH
31491: LD_INT 4
31493: ARRAY
31494: PPUSH
31495: CALL 65208 0 5
31499: AND
31500: OR
31501: IFFALSE 31782
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31503: LD_ADDR_VAR 0 4
31507: PUSH
31508: LD_EXP 79
31512: PUSH
31513: LD_VAR 0 2
31517: ARRAY
31518: PPUSH
31519: LD_INT 25
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 72
31533: PUSH
31534: LD_EXP 81
31538: PUSH
31539: LD_VAR 0 2
31543: ARRAY
31544: DIFF
31545: ST_TO_ADDR
// if not tmp then
31546: LD_VAR 0 4
31550: NOT
31551: IFFALSE 31555
// continue ;
31553: GO 30800
// for j in tmp do
31555: LD_ADDR_VAR 0 3
31559: PUSH
31560: LD_VAR 0 4
31564: PUSH
31565: FOR_IN
31566: IFFALSE 31778
// begin if not mc_builders [ i ] then
31568: LD_EXP 85
31572: PUSH
31573: LD_VAR 0 2
31577: ARRAY
31578: NOT
31579: IFFALSE 31637
// begin SetTag ( j , 103 ) ;
31581: LD_VAR 0 3
31585: PPUSH
31586: LD_INT 103
31588: PPUSH
31589: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31593: LD_ADDR_EXP 85
31597: PUSH
31598: LD_EXP 85
31602: PPUSH
31603: LD_VAR 0 2
31607: PUSH
31608: LD_EXP 85
31612: PUSH
31613: LD_VAR 0 2
31617: ARRAY
31618: PUSH
31619: LD_INT 1
31621: PLUS
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PPUSH
31627: LD_VAR 0 3
31631: PPUSH
31632: CALL 57793 0 3
31636: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31637: LD_VAR 0 3
31641: PPUSH
31642: CALL_OW 310
31646: IFFALSE 31657
// ComExitBuilding ( j ) ;
31648: LD_VAR 0 3
31652: PPUSH
31653: CALL_OW 122
// wait ( 3 ) ;
31657: LD_INT 3
31659: PPUSH
31660: CALL_OW 67
// if not mc_build_list [ i ] then
31664: LD_EXP 84
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: NOT
31675: IFFALSE 31679
// break ;
31677: GO 31778
// if not HasTask ( j ) then
31679: LD_VAR 0 3
31683: PPUSH
31684: CALL_OW 314
31688: NOT
31689: IFFALSE 31776
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31691: LD_VAR 0 3
31695: PPUSH
31696: LD_EXP 84
31700: PUSH
31701: LD_VAR 0 2
31705: ARRAY
31706: PUSH
31707: LD_INT 1
31709: ARRAY
31710: PUSH
31711: LD_INT 1
31713: ARRAY
31714: PPUSH
31715: LD_EXP 84
31719: PUSH
31720: LD_VAR 0 2
31724: ARRAY
31725: PUSH
31726: LD_INT 1
31728: ARRAY
31729: PUSH
31730: LD_INT 2
31732: ARRAY
31733: PPUSH
31734: LD_EXP 84
31738: PUSH
31739: LD_VAR 0 2
31743: ARRAY
31744: PUSH
31745: LD_INT 1
31747: ARRAY
31748: PUSH
31749: LD_INT 3
31751: ARRAY
31752: PPUSH
31753: LD_EXP 84
31757: PUSH
31758: LD_VAR 0 2
31762: ARRAY
31763: PUSH
31764: LD_INT 1
31766: ARRAY
31767: PUSH
31768: LD_INT 4
31770: ARRAY
31771: PPUSH
31772: CALL_OW 145
// end ;
31776: GO 31565
31778: POP
31779: POP
// end else
31780: GO 31924
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31782: LD_EXP 79
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PPUSH
31793: LD_EXP 84
31797: PUSH
31798: LD_VAR 0 2
31802: ARRAY
31803: PUSH
31804: LD_INT 1
31806: ARRAY
31807: PUSH
31808: LD_INT 1
31810: ARRAY
31811: PPUSH
31812: LD_EXP 84
31816: PUSH
31817: LD_VAR 0 2
31821: ARRAY
31822: PUSH
31823: LD_INT 1
31825: ARRAY
31826: PUSH
31827: LD_INT 2
31829: ARRAY
31830: PPUSH
31831: LD_EXP 84
31835: PUSH
31836: LD_VAR 0 2
31840: ARRAY
31841: PUSH
31842: LD_INT 1
31844: ARRAY
31845: PUSH
31846: LD_INT 3
31848: ARRAY
31849: PPUSH
31850: LD_EXP 84
31854: PUSH
31855: LD_VAR 0 2
31859: ARRAY
31860: PUSH
31861: LD_INT 1
31863: ARRAY
31864: PUSH
31865: LD_INT 4
31867: ARRAY
31868: PPUSH
31869: CALL 64544 0 5
31873: NOT
31874: IFFALSE 31924
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31876: LD_ADDR_EXP 84
31880: PUSH
31881: LD_EXP 84
31885: PPUSH
31886: LD_VAR 0 2
31890: PPUSH
31891: LD_EXP 84
31895: PUSH
31896: LD_VAR 0 2
31900: ARRAY
31901: PPUSH
31902: LD_INT 1
31904: PPUSH
31905: LD_INT 1
31907: NEG
31908: PPUSH
31909: LD_INT 0
31911: PPUSH
31912: CALL 57211 0 4
31916: PPUSH
31917: CALL_OW 1
31921: ST_TO_ADDR
// continue ;
31922: GO 30800
// end ; end ; end ;
31924: GO 30800
31926: POP
31927: POP
// end ;
31928: LD_VAR 0 1
31932: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31933: LD_INT 0
31935: PPUSH
31936: PPUSH
31937: PPUSH
31938: PPUSH
31939: PPUSH
31940: PPUSH
// if not mc_bases then
31941: LD_EXP 79
31945: NOT
31946: IFFALSE 31950
// exit ;
31948: GO 32377
// for i = 1 to mc_bases do
31950: LD_ADDR_VAR 0 2
31954: PUSH
31955: DOUBLE
31956: LD_INT 1
31958: DEC
31959: ST_TO_ADDR
31960: LD_EXP 79
31964: PUSH
31965: FOR_TO
31966: IFFALSE 32375
// begin tmp := mc_build_upgrade [ i ] ;
31968: LD_ADDR_VAR 0 4
31972: PUSH
31973: LD_EXP 111
31977: PUSH
31978: LD_VAR 0 2
31982: ARRAY
31983: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31984: LD_ADDR_VAR 0 6
31988: PUSH
31989: LD_EXP 112
31993: PUSH
31994: LD_VAR 0 2
31998: ARRAY
31999: PPUSH
32000: LD_INT 2
32002: PUSH
32003: LD_INT 30
32005: PUSH
32006: LD_INT 6
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 30
32015: PUSH
32016: LD_INT 7
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: LIST
32027: PPUSH
32028: CALL_OW 72
32032: ST_TO_ADDR
// if not tmp and not lab then
32033: LD_VAR 0 4
32037: NOT
32038: PUSH
32039: LD_VAR 0 6
32043: NOT
32044: AND
32045: IFFALSE 32049
// continue ;
32047: GO 31965
// if tmp then
32049: LD_VAR 0 4
32053: IFFALSE 32173
// for j in tmp do
32055: LD_ADDR_VAR 0 3
32059: PUSH
32060: LD_VAR 0 4
32064: PUSH
32065: FOR_IN
32066: IFFALSE 32171
// begin if UpgradeCost ( j ) then
32068: LD_VAR 0 3
32072: PPUSH
32073: CALL 64204 0 1
32077: IFFALSE 32169
// begin ComUpgrade ( j ) ;
32079: LD_VAR 0 3
32083: PPUSH
32084: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32088: LD_ADDR_EXP 111
32092: PUSH
32093: LD_EXP 111
32097: PPUSH
32098: LD_VAR 0 2
32102: PPUSH
32103: LD_EXP 111
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PUSH
32114: LD_VAR 0 3
32118: DIFF
32119: PPUSH
32120: CALL_OW 1
32124: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32125: LD_ADDR_EXP 86
32129: PUSH
32130: LD_EXP 86
32134: PPUSH
32135: LD_VAR 0 2
32139: PUSH
32140: LD_EXP 86
32144: PUSH
32145: LD_VAR 0 2
32149: ARRAY
32150: PUSH
32151: LD_INT 1
32153: PLUS
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PPUSH
32159: LD_VAR 0 3
32163: PPUSH
32164: CALL 57793 0 3
32168: ST_TO_ADDR
// end ; end ;
32169: GO 32065
32171: POP
32172: POP
// if not lab or not mc_lab_upgrade [ i ] then
32173: LD_VAR 0 6
32177: NOT
32178: PUSH
32179: LD_EXP 113
32183: PUSH
32184: LD_VAR 0 2
32188: ARRAY
32189: NOT
32190: OR
32191: IFFALSE 32195
// continue ;
32193: GO 31965
// for j in lab do
32195: LD_ADDR_VAR 0 3
32199: PUSH
32200: LD_VAR 0 6
32204: PUSH
32205: FOR_IN
32206: IFFALSE 32371
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32208: LD_VAR 0 3
32212: PPUSH
32213: CALL_OW 266
32217: PUSH
32218: LD_INT 6
32220: PUSH
32221: LD_INT 7
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: IN
32228: PUSH
32229: LD_VAR 0 3
32233: PPUSH
32234: CALL_OW 461
32238: PUSH
32239: LD_INT 1
32241: NONEQUAL
32242: AND
32243: IFFALSE 32369
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32245: LD_VAR 0 3
32249: PPUSH
32250: LD_EXP 113
32254: PUSH
32255: LD_VAR 0 2
32259: ARRAY
32260: PUSH
32261: LD_INT 1
32263: ARRAY
32264: PPUSH
32265: CALL 64409 0 2
32269: IFFALSE 32369
// begin ComCancel ( j ) ;
32271: LD_VAR 0 3
32275: PPUSH
32276: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32280: LD_VAR 0 3
32284: PPUSH
32285: LD_EXP 113
32289: PUSH
32290: LD_VAR 0 2
32294: ARRAY
32295: PUSH
32296: LD_INT 1
32298: ARRAY
32299: PPUSH
32300: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32304: LD_VAR 0 3
32308: PUSH
32309: LD_EXP 86
32313: PUSH
32314: LD_VAR 0 2
32318: ARRAY
32319: IN
32320: NOT
32321: IFFALSE 32367
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32323: LD_ADDR_EXP 86
32327: PUSH
32328: LD_EXP 86
32332: PPUSH
32333: LD_VAR 0 2
32337: PUSH
32338: LD_EXP 86
32342: PUSH
32343: LD_VAR 0 2
32347: ARRAY
32348: PUSH
32349: LD_INT 1
32351: PLUS
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PPUSH
32357: LD_VAR 0 3
32361: PPUSH
32362: CALL 57793 0 3
32366: ST_TO_ADDR
// break ;
32367: GO 32371
// end ; end ; end ;
32369: GO 32205
32371: POP
32372: POP
// end ;
32373: GO 31965
32375: POP
32376: POP
// end ;
32377: LD_VAR 0 1
32381: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32382: LD_INT 0
32384: PPUSH
32385: PPUSH
32386: PPUSH
32387: PPUSH
32388: PPUSH
32389: PPUSH
32390: PPUSH
32391: PPUSH
32392: PPUSH
// if not mc_bases then
32393: LD_EXP 79
32397: NOT
32398: IFFALSE 32402
// exit ;
32400: GO 32807
// for i = 1 to mc_bases do
32402: LD_ADDR_VAR 0 2
32406: PUSH
32407: DOUBLE
32408: LD_INT 1
32410: DEC
32411: ST_TO_ADDR
32412: LD_EXP 79
32416: PUSH
32417: FOR_TO
32418: IFFALSE 32805
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32420: LD_EXP 87
32424: PUSH
32425: LD_VAR 0 2
32429: ARRAY
32430: NOT
32431: PUSH
32432: LD_EXP 79
32436: PUSH
32437: LD_VAR 0 2
32441: ARRAY
32442: PPUSH
32443: LD_INT 30
32445: PUSH
32446: LD_INT 3
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PPUSH
32453: CALL_OW 72
32457: NOT
32458: OR
32459: IFFALSE 32463
// continue ;
32461: GO 32417
// busy := false ;
32463: LD_ADDR_VAR 0 8
32467: PUSH
32468: LD_INT 0
32470: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32471: LD_ADDR_VAR 0 4
32475: PUSH
32476: LD_EXP 79
32480: PUSH
32481: LD_VAR 0 2
32485: ARRAY
32486: PPUSH
32487: LD_INT 30
32489: PUSH
32490: LD_INT 3
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PPUSH
32497: CALL_OW 72
32501: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32502: LD_ADDR_VAR 0 6
32506: PUSH
32507: LD_EXP 87
32511: PUSH
32512: LD_VAR 0 2
32516: ARRAY
32517: PPUSH
32518: LD_INT 2
32520: PUSH
32521: LD_INT 30
32523: PUSH
32524: LD_INT 32
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 30
32533: PUSH
32534: LD_INT 33
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: LIST
32545: PPUSH
32546: CALL_OW 72
32550: ST_TO_ADDR
// if not t then
32551: LD_VAR 0 6
32555: NOT
32556: IFFALSE 32560
// continue ;
32558: GO 32417
// for j in tmp do
32560: LD_ADDR_VAR 0 3
32564: PUSH
32565: LD_VAR 0 4
32569: PUSH
32570: FOR_IN
32571: IFFALSE 32601
// if not BuildingStatus ( j ) = bs_idle then
32573: LD_VAR 0 3
32577: PPUSH
32578: CALL_OW 461
32582: PUSH
32583: LD_INT 2
32585: EQUAL
32586: NOT
32587: IFFALSE 32599
// begin busy := true ;
32589: LD_ADDR_VAR 0 8
32593: PUSH
32594: LD_INT 1
32596: ST_TO_ADDR
// break ;
32597: GO 32601
// end ;
32599: GO 32570
32601: POP
32602: POP
// if busy then
32603: LD_VAR 0 8
32607: IFFALSE 32611
// continue ;
32609: GO 32417
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32611: LD_ADDR_VAR 0 7
32615: PUSH
32616: LD_VAR 0 6
32620: PPUSH
32621: LD_INT 35
32623: PUSH
32624: LD_INT 0
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PPUSH
32631: CALL_OW 72
32635: ST_TO_ADDR
// if tw then
32636: LD_VAR 0 7
32640: IFFALSE 32717
// begin tw := tw [ 1 ] ;
32642: LD_ADDR_VAR 0 7
32646: PUSH
32647: LD_VAR 0 7
32651: PUSH
32652: LD_INT 1
32654: ARRAY
32655: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32656: LD_ADDR_VAR 0 9
32660: PUSH
32661: LD_VAR 0 7
32665: PPUSH
32666: LD_EXP 104
32670: PUSH
32671: LD_VAR 0 2
32675: ARRAY
32676: PPUSH
32677: CALL 62763 0 2
32681: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32682: LD_EXP 118
32686: PUSH
32687: LD_VAR 0 2
32691: ARRAY
32692: IFFALSE 32715
// if not weapon in mc_allowed_tower_weapons [ i ] then
32694: LD_VAR 0 9
32698: PUSH
32699: LD_EXP 118
32703: PUSH
32704: LD_VAR 0 2
32708: ARRAY
32709: IN
32710: NOT
32711: IFFALSE 32715
// continue ;
32713: GO 32417
// end else
32715: GO 32780
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32717: LD_ADDR_VAR 0 5
32721: PUSH
32722: LD_EXP 87
32726: PUSH
32727: LD_VAR 0 2
32731: ARRAY
32732: PPUSH
32733: LD_VAR 0 4
32737: PPUSH
32738: CALL 92974 0 2
32742: ST_TO_ADDR
// if not tmp2 then
32743: LD_VAR 0 5
32747: NOT
32748: IFFALSE 32752
// continue ;
32750: GO 32417
// tw := tmp2 [ 1 ] ;
32752: LD_ADDR_VAR 0 7
32756: PUSH
32757: LD_VAR 0 5
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32766: LD_ADDR_VAR 0 9
32770: PUSH
32771: LD_VAR 0 5
32775: PUSH
32776: LD_INT 2
32778: ARRAY
32779: ST_TO_ADDR
// end ; if not weapon then
32780: LD_VAR 0 9
32784: NOT
32785: IFFALSE 32789
// continue ;
32787: GO 32417
// ComPlaceWeapon ( tw , weapon ) ;
32789: LD_VAR 0 7
32793: PPUSH
32794: LD_VAR 0 9
32798: PPUSH
32799: CALL_OW 148
// end ;
32803: GO 32417
32805: POP
32806: POP
// end ;
32807: LD_VAR 0 1
32811: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32812: LD_INT 0
32814: PPUSH
32815: PPUSH
32816: PPUSH
32817: PPUSH
32818: PPUSH
32819: PPUSH
// if not mc_bases then
32820: LD_EXP 79
32824: NOT
32825: IFFALSE 32829
// exit ;
32827: GO 33605
// for i = 1 to mc_bases do
32829: LD_ADDR_VAR 0 2
32833: PUSH
32834: DOUBLE
32835: LD_INT 1
32837: DEC
32838: ST_TO_ADDR
32839: LD_EXP 79
32843: PUSH
32844: FOR_TO
32845: IFFALSE 33603
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32847: LD_EXP 92
32851: PUSH
32852: LD_VAR 0 2
32856: ARRAY
32857: NOT
32858: PUSH
32859: LD_EXP 92
32863: PUSH
32864: LD_VAR 0 2
32868: ARRAY
32869: PUSH
32870: LD_EXP 93
32874: PUSH
32875: LD_VAR 0 2
32879: ARRAY
32880: EQUAL
32881: OR
32882: PUSH
32883: LD_EXP 102
32887: PUSH
32888: LD_VAR 0 2
32892: ARRAY
32893: OR
32894: IFFALSE 32898
// continue ;
32896: GO 32844
// if mc_miners [ i ] then
32898: LD_EXP 93
32902: PUSH
32903: LD_VAR 0 2
32907: ARRAY
32908: IFFALSE 33290
// begin for j = mc_miners [ i ] downto 1 do
32910: LD_ADDR_VAR 0 3
32914: PUSH
32915: DOUBLE
32916: LD_EXP 93
32920: PUSH
32921: LD_VAR 0 2
32925: ARRAY
32926: INC
32927: ST_TO_ADDR
32928: LD_INT 1
32930: PUSH
32931: FOR_DOWNTO
32932: IFFALSE 33288
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32934: LD_EXP 93
32938: PUSH
32939: LD_VAR 0 2
32943: ARRAY
32944: PUSH
32945: LD_VAR 0 3
32949: ARRAY
32950: PPUSH
32951: CALL_OW 301
32955: PUSH
32956: LD_EXP 93
32960: PUSH
32961: LD_VAR 0 2
32965: ARRAY
32966: PUSH
32967: LD_VAR 0 3
32971: ARRAY
32972: PPUSH
32973: CALL_OW 257
32977: PUSH
32978: LD_INT 1
32980: NONEQUAL
32981: OR
32982: IFFALSE 33045
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32984: LD_ADDR_VAR 0 5
32988: PUSH
32989: LD_EXP 93
32993: PUSH
32994: LD_VAR 0 2
32998: ARRAY
32999: PUSH
33000: LD_EXP 93
33004: PUSH
33005: LD_VAR 0 2
33009: ARRAY
33010: PUSH
33011: LD_VAR 0 3
33015: ARRAY
33016: DIFF
33017: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33018: LD_ADDR_EXP 93
33022: PUSH
33023: LD_EXP 93
33027: PPUSH
33028: LD_VAR 0 2
33032: PPUSH
33033: LD_VAR 0 5
33037: PPUSH
33038: CALL_OW 1
33042: ST_TO_ADDR
// continue ;
33043: GO 32931
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33045: LD_EXP 93
33049: PUSH
33050: LD_VAR 0 2
33054: ARRAY
33055: PUSH
33056: LD_VAR 0 3
33060: ARRAY
33061: PPUSH
33062: CALL_OW 257
33066: PUSH
33067: LD_INT 1
33069: EQUAL
33070: PUSH
33071: LD_EXP 93
33075: PUSH
33076: LD_VAR 0 2
33080: ARRAY
33081: PUSH
33082: LD_VAR 0 3
33086: ARRAY
33087: PPUSH
33088: CALL_OW 459
33092: NOT
33093: AND
33094: PUSH
33095: LD_EXP 93
33099: PUSH
33100: LD_VAR 0 2
33104: ARRAY
33105: PUSH
33106: LD_VAR 0 3
33110: ARRAY
33111: PPUSH
33112: CALL_OW 314
33116: NOT
33117: AND
33118: IFFALSE 33286
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33120: LD_EXP 93
33124: PUSH
33125: LD_VAR 0 2
33129: ARRAY
33130: PUSH
33131: LD_VAR 0 3
33135: ARRAY
33136: PPUSH
33137: CALL_OW 310
33141: IFFALSE 33164
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33143: LD_EXP 93
33147: PUSH
33148: LD_VAR 0 2
33152: ARRAY
33153: PUSH
33154: LD_VAR 0 3
33158: ARRAY
33159: PPUSH
33160: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33164: LD_EXP 93
33168: PUSH
33169: LD_VAR 0 2
33173: ARRAY
33174: PUSH
33175: LD_VAR 0 3
33179: ARRAY
33180: PPUSH
33181: CALL_OW 314
33185: NOT
33186: IFFALSE 33286
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33188: LD_EXP 93
33192: PUSH
33193: LD_VAR 0 2
33197: ARRAY
33198: PUSH
33199: LD_VAR 0 3
33203: ARRAY
33204: PPUSH
33205: LD_EXP 92
33209: PUSH
33210: LD_VAR 0 2
33214: ARRAY
33215: PUSH
33216: LD_VAR 0 3
33220: PUSH
33221: LD_EXP 92
33225: PUSH
33226: LD_VAR 0 2
33230: ARRAY
33231: MOD
33232: PUSH
33233: LD_INT 1
33235: PLUS
33236: ARRAY
33237: PUSH
33238: LD_INT 1
33240: ARRAY
33241: PPUSH
33242: LD_EXP 92
33246: PUSH
33247: LD_VAR 0 2
33251: ARRAY
33252: PUSH
33253: LD_VAR 0 3
33257: PUSH
33258: LD_EXP 92
33262: PUSH
33263: LD_VAR 0 2
33267: ARRAY
33268: MOD
33269: PUSH
33270: LD_INT 1
33272: PLUS
33273: ARRAY
33274: PUSH
33275: LD_INT 2
33277: ARRAY
33278: PPUSH
33279: LD_INT 0
33281: PPUSH
33282: CALL_OW 193
// end ; end ;
33286: GO 32931
33288: POP
33289: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33290: LD_ADDR_VAR 0 5
33294: PUSH
33295: LD_EXP 79
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PPUSH
33306: LD_INT 2
33308: PUSH
33309: LD_INT 30
33311: PUSH
33312: LD_INT 4
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 30
33321: PUSH
33322: LD_INT 5
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 30
33331: PUSH
33332: LD_INT 32
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: PPUSH
33345: CALL_OW 72
33349: ST_TO_ADDR
// if not tmp then
33350: LD_VAR 0 5
33354: NOT
33355: IFFALSE 33359
// continue ;
33357: GO 32844
// list := [ ] ;
33359: LD_ADDR_VAR 0 6
33363: PUSH
33364: EMPTY
33365: ST_TO_ADDR
// for j in tmp do
33366: LD_ADDR_VAR 0 3
33370: PUSH
33371: LD_VAR 0 5
33375: PUSH
33376: FOR_IN
33377: IFFALSE 33446
// begin for k in UnitsInside ( j ) do
33379: LD_ADDR_VAR 0 4
33383: PUSH
33384: LD_VAR 0 3
33388: PPUSH
33389: CALL_OW 313
33393: PUSH
33394: FOR_IN
33395: IFFALSE 33442
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33397: LD_VAR 0 4
33401: PPUSH
33402: CALL_OW 257
33406: PUSH
33407: LD_INT 1
33409: EQUAL
33410: PUSH
33411: LD_VAR 0 4
33415: PPUSH
33416: CALL_OW 459
33420: NOT
33421: AND
33422: IFFALSE 33440
// list := list ^ k ;
33424: LD_ADDR_VAR 0 6
33428: PUSH
33429: LD_VAR 0 6
33433: PUSH
33434: LD_VAR 0 4
33438: ADD
33439: ST_TO_ADDR
33440: GO 33394
33442: POP
33443: POP
// end ;
33444: GO 33376
33446: POP
33447: POP
// list := list diff mc_miners [ i ] ;
33448: LD_ADDR_VAR 0 6
33452: PUSH
33453: LD_VAR 0 6
33457: PUSH
33458: LD_EXP 93
33462: PUSH
33463: LD_VAR 0 2
33467: ARRAY
33468: DIFF
33469: ST_TO_ADDR
// if not list then
33470: LD_VAR 0 6
33474: NOT
33475: IFFALSE 33479
// continue ;
33477: GO 32844
// k := mc_mines [ i ] - mc_miners [ i ] ;
33479: LD_ADDR_VAR 0 4
33483: PUSH
33484: LD_EXP 92
33488: PUSH
33489: LD_VAR 0 2
33493: ARRAY
33494: PUSH
33495: LD_EXP 93
33499: PUSH
33500: LD_VAR 0 2
33504: ARRAY
33505: MINUS
33506: ST_TO_ADDR
// if k > list then
33507: LD_VAR 0 4
33511: PUSH
33512: LD_VAR 0 6
33516: GREATER
33517: IFFALSE 33529
// k := list ;
33519: LD_ADDR_VAR 0 4
33523: PUSH
33524: LD_VAR 0 6
33528: ST_TO_ADDR
// for j = 1 to k do
33529: LD_ADDR_VAR 0 3
33533: PUSH
33534: DOUBLE
33535: LD_INT 1
33537: DEC
33538: ST_TO_ADDR
33539: LD_VAR 0 4
33543: PUSH
33544: FOR_TO
33545: IFFALSE 33599
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33547: LD_ADDR_EXP 93
33551: PUSH
33552: LD_EXP 93
33556: PPUSH
33557: LD_VAR 0 2
33561: PUSH
33562: LD_EXP 93
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: PUSH
33573: LD_INT 1
33575: PLUS
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PPUSH
33581: LD_VAR 0 6
33585: PUSH
33586: LD_VAR 0 3
33590: ARRAY
33591: PPUSH
33592: CALL 57793 0 3
33596: ST_TO_ADDR
33597: GO 33544
33599: POP
33600: POP
// end ;
33601: GO 32844
33603: POP
33604: POP
// end ;
33605: LD_VAR 0 1
33609: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33610: LD_INT 0
33612: PPUSH
33613: PPUSH
33614: PPUSH
33615: PPUSH
33616: PPUSH
33617: PPUSH
33618: PPUSH
33619: PPUSH
33620: PPUSH
33621: PPUSH
// if not mc_bases then
33622: LD_EXP 79
33626: NOT
33627: IFFALSE 33631
// exit ;
33629: GO 35381
// for i = 1 to mc_bases do
33631: LD_ADDR_VAR 0 2
33635: PUSH
33636: DOUBLE
33637: LD_INT 1
33639: DEC
33640: ST_TO_ADDR
33641: LD_EXP 79
33645: PUSH
33646: FOR_TO
33647: IFFALSE 35379
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33649: LD_EXP 79
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: NOT
33660: PUSH
33661: LD_EXP 86
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: OR
33672: IFFALSE 33676
// continue ;
33674: GO 33646
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33676: LD_EXP 95
33680: PUSH
33681: LD_VAR 0 2
33685: ARRAY
33686: NOT
33687: PUSH
33688: LD_EXP 96
33692: PUSH
33693: LD_VAR 0 2
33697: ARRAY
33698: AND
33699: IFFALSE 33737
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33701: LD_ADDR_EXP 96
33705: PUSH
33706: LD_EXP 96
33710: PPUSH
33711: LD_VAR 0 2
33715: PPUSH
33716: EMPTY
33717: PPUSH
33718: CALL_OW 1
33722: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33723: LD_VAR 0 2
33727: PPUSH
33728: LD_INT 107
33730: PPUSH
33731: CALL 24595 0 2
// continue ;
33735: GO 33646
// end ; target := [ ] ;
33737: LD_ADDR_VAR 0 6
33741: PUSH
33742: EMPTY
33743: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33744: LD_ADDR_VAR 0 3
33748: PUSH
33749: DOUBLE
33750: LD_EXP 95
33754: PUSH
33755: LD_VAR 0 2
33759: ARRAY
33760: INC
33761: ST_TO_ADDR
33762: LD_INT 1
33764: PUSH
33765: FOR_DOWNTO
33766: IFFALSE 34026
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33768: LD_EXP 95
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: LD_VAR 0 3
33783: ARRAY
33784: PUSH
33785: LD_INT 2
33787: ARRAY
33788: PPUSH
33789: LD_EXP 95
33793: PUSH
33794: LD_VAR 0 2
33798: ARRAY
33799: PUSH
33800: LD_VAR 0 3
33804: ARRAY
33805: PUSH
33806: LD_INT 3
33808: ARRAY
33809: PPUSH
33810: CALL_OW 488
33814: PUSH
33815: LD_EXP 95
33819: PUSH
33820: LD_VAR 0 2
33824: ARRAY
33825: PUSH
33826: LD_VAR 0 3
33830: ARRAY
33831: PUSH
33832: LD_INT 2
33834: ARRAY
33835: PPUSH
33836: LD_EXP 95
33840: PUSH
33841: LD_VAR 0 2
33845: ARRAY
33846: PUSH
33847: LD_VAR 0 3
33851: ARRAY
33852: PUSH
33853: LD_INT 3
33855: ARRAY
33856: PPUSH
33857: CALL_OW 284
33861: PUSH
33862: LD_INT 0
33864: EQUAL
33865: AND
33866: IFFALSE 33921
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33868: LD_ADDR_VAR 0 5
33872: PUSH
33873: LD_EXP 95
33877: PUSH
33878: LD_VAR 0 2
33882: ARRAY
33883: PPUSH
33884: LD_VAR 0 3
33888: PPUSH
33889: CALL_OW 3
33893: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33894: LD_ADDR_EXP 95
33898: PUSH
33899: LD_EXP 95
33903: PPUSH
33904: LD_VAR 0 2
33908: PPUSH
33909: LD_VAR 0 5
33913: PPUSH
33914: CALL_OW 1
33918: ST_TO_ADDR
// continue ;
33919: GO 33765
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33921: LD_EXP 79
33925: PUSH
33926: LD_VAR 0 2
33930: ARRAY
33931: PUSH
33932: LD_INT 1
33934: ARRAY
33935: PPUSH
33936: CALL_OW 255
33940: PPUSH
33941: LD_EXP 95
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: PUSH
33952: LD_VAR 0 3
33956: ARRAY
33957: PUSH
33958: LD_INT 2
33960: ARRAY
33961: PPUSH
33962: LD_EXP 95
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_VAR 0 3
33977: ARRAY
33978: PUSH
33979: LD_INT 3
33981: ARRAY
33982: PPUSH
33983: LD_INT 30
33985: PPUSH
33986: CALL 58689 0 4
33990: PUSH
33991: LD_INT 4
33993: ARRAY
33994: PUSH
33995: LD_INT 0
33997: EQUAL
33998: IFFALSE 34024
// begin target := mc_crates [ i ] [ j ] ;
34000: LD_ADDR_VAR 0 6
34004: PUSH
34005: LD_EXP 95
34009: PUSH
34010: LD_VAR 0 2
34014: ARRAY
34015: PUSH
34016: LD_VAR 0 3
34020: ARRAY
34021: ST_TO_ADDR
// break ;
34022: GO 34026
// end ; end ;
34024: GO 33765
34026: POP
34027: POP
// if not target then
34028: LD_VAR 0 6
34032: NOT
34033: IFFALSE 34037
// continue ;
34035: GO 33646
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34037: LD_ADDR_VAR 0 7
34041: PUSH
34042: LD_EXP 98
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PPUSH
34053: LD_INT 2
34055: PUSH
34056: LD_INT 3
34058: PUSH
34059: LD_INT 58
34061: PUSH
34062: EMPTY
34063: LIST
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 61
34071: PUSH
34072: EMPTY
34073: LIST
34074: PUSH
34075: LD_INT 33
34077: PUSH
34078: LD_INT 5
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 33
34087: PUSH
34088: LD_INT 3
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 2
34104: PUSH
34105: LD_INT 34
34107: PUSH
34108: LD_INT 32
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: PUSH
34115: LD_INT 34
34117: PUSH
34118: LD_INT 51
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 34
34127: PUSH
34128: LD_INT 12
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PPUSH
34145: CALL_OW 72
34149: ST_TO_ADDR
// if not cargo then
34150: LD_VAR 0 7
34154: NOT
34155: IFFALSE 34798
// begin if mc_crates_collector [ i ] < 5 then
34157: LD_EXP 96
34161: PUSH
34162: LD_VAR 0 2
34166: ARRAY
34167: PUSH
34168: LD_INT 5
34170: LESS
34171: IFFALSE 34537
// begin if mc_ape [ i ] then
34173: LD_EXP 108
34177: PUSH
34178: LD_VAR 0 2
34182: ARRAY
34183: IFFALSE 34230
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34185: LD_ADDR_VAR 0 5
34189: PUSH
34190: LD_EXP 108
34194: PUSH
34195: LD_VAR 0 2
34199: ARRAY
34200: PPUSH
34201: LD_INT 25
34203: PUSH
34204: LD_INT 16
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 24
34213: PUSH
34214: LD_INT 750
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PPUSH
34225: CALL_OW 72
34229: ST_TO_ADDR
// if not tmp then
34230: LD_VAR 0 5
34234: NOT
34235: IFFALSE 34282
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34237: LD_ADDR_VAR 0 5
34241: PUSH
34242: LD_EXP 79
34246: PUSH
34247: LD_VAR 0 2
34251: ARRAY
34252: PPUSH
34253: LD_INT 25
34255: PUSH
34256: LD_INT 2
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 24
34265: PUSH
34266: LD_INT 750
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PPUSH
34277: CALL_OW 72
34281: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34282: LD_EXP 108
34286: PUSH
34287: LD_VAR 0 2
34291: ARRAY
34292: PUSH
34293: LD_EXP 79
34297: PUSH
34298: LD_VAR 0 2
34302: ARRAY
34303: PPUSH
34304: LD_INT 25
34306: PUSH
34307: LD_INT 2
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PUSH
34314: LD_INT 24
34316: PUSH
34317: LD_INT 750
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PPUSH
34328: CALL_OW 72
34332: AND
34333: PUSH
34334: LD_VAR 0 5
34338: PUSH
34339: LD_INT 5
34341: LESS
34342: AND
34343: IFFALSE 34425
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34345: LD_ADDR_VAR 0 3
34349: PUSH
34350: LD_EXP 79
34354: PUSH
34355: LD_VAR 0 2
34359: ARRAY
34360: PPUSH
34361: LD_INT 25
34363: PUSH
34364: LD_INT 2
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 24
34373: PUSH
34374: LD_INT 750
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PPUSH
34385: CALL_OW 72
34389: PUSH
34390: FOR_IN
34391: IFFALSE 34423
// begin tmp := tmp union j ;
34393: LD_ADDR_VAR 0 5
34397: PUSH
34398: LD_VAR 0 5
34402: PUSH
34403: LD_VAR 0 3
34407: UNION
34408: ST_TO_ADDR
// if tmp >= 5 then
34409: LD_VAR 0 5
34413: PUSH
34414: LD_INT 5
34416: GREATEREQUAL
34417: IFFALSE 34421
// break ;
34419: GO 34423
// end ;
34421: GO 34390
34423: POP
34424: POP
// end ; if not tmp then
34425: LD_VAR 0 5
34429: NOT
34430: IFFALSE 34434
// continue ;
34432: GO 33646
// for j in tmp do
34434: LD_ADDR_VAR 0 3
34438: PUSH
34439: LD_VAR 0 5
34443: PUSH
34444: FOR_IN
34445: IFFALSE 34535
// if not GetTag ( j ) then
34447: LD_VAR 0 3
34451: PPUSH
34452: CALL_OW 110
34456: NOT
34457: IFFALSE 34533
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34459: LD_ADDR_EXP 96
34463: PUSH
34464: LD_EXP 96
34468: PPUSH
34469: LD_VAR 0 2
34473: PUSH
34474: LD_EXP 96
34478: PUSH
34479: LD_VAR 0 2
34483: ARRAY
34484: PUSH
34485: LD_INT 1
34487: PLUS
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PPUSH
34493: LD_VAR 0 3
34497: PPUSH
34498: CALL 57793 0 3
34502: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34503: LD_VAR 0 3
34507: PPUSH
34508: LD_INT 107
34510: PPUSH
34511: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34515: LD_EXP 96
34519: PUSH
34520: LD_VAR 0 2
34524: ARRAY
34525: PUSH
34526: LD_INT 5
34528: GREATEREQUAL
34529: IFFALSE 34533
// break ;
34531: GO 34535
// end ;
34533: GO 34444
34535: POP
34536: POP
// end ; if mc_crates_collector [ i ] and target then
34537: LD_EXP 96
34541: PUSH
34542: LD_VAR 0 2
34546: ARRAY
34547: PUSH
34548: LD_VAR 0 6
34552: AND
34553: IFFALSE 34796
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34555: LD_EXP 96
34559: PUSH
34560: LD_VAR 0 2
34564: ARRAY
34565: PUSH
34566: LD_VAR 0 6
34570: PUSH
34571: LD_INT 1
34573: ARRAY
34574: LESS
34575: IFFALSE 34595
// tmp := mc_crates_collector [ i ] else
34577: LD_ADDR_VAR 0 5
34581: PUSH
34582: LD_EXP 96
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: ST_TO_ADDR
34593: GO 34609
// tmp := target [ 1 ] ;
34595: LD_ADDR_VAR 0 5
34599: PUSH
34600: LD_VAR 0 6
34604: PUSH
34605: LD_INT 1
34607: ARRAY
34608: ST_TO_ADDR
// k := 0 ;
34609: LD_ADDR_VAR 0 4
34613: PUSH
34614: LD_INT 0
34616: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34617: LD_ADDR_VAR 0 3
34621: PUSH
34622: LD_EXP 96
34626: PUSH
34627: LD_VAR 0 2
34631: ARRAY
34632: PUSH
34633: FOR_IN
34634: IFFALSE 34794
// begin k := k + 1 ;
34636: LD_ADDR_VAR 0 4
34640: PUSH
34641: LD_VAR 0 4
34645: PUSH
34646: LD_INT 1
34648: PLUS
34649: ST_TO_ADDR
// if k > tmp then
34650: LD_VAR 0 4
34654: PUSH
34655: LD_VAR 0 5
34659: GREATER
34660: IFFALSE 34664
// break ;
34662: GO 34794
// if not GetClass ( j ) in [ 2 , 16 ] then
34664: LD_VAR 0 3
34668: PPUSH
34669: CALL_OW 257
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: LD_INT 16
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: IN
34684: NOT
34685: IFFALSE 34738
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34687: LD_ADDR_EXP 96
34691: PUSH
34692: LD_EXP 96
34696: PPUSH
34697: LD_VAR 0 2
34701: PPUSH
34702: LD_EXP 96
34706: PUSH
34707: LD_VAR 0 2
34711: ARRAY
34712: PUSH
34713: LD_VAR 0 3
34717: DIFF
34718: PPUSH
34719: CALL_OW 1
34723: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34724: LD_VAR 0 3
34728: PPUSH
34729: LD_INT 0
34731: PPUSH
34732: CALL_OW 109
// continue ;
34736: GO 34633
// end ; if IsInUnit ( j ) then
34738: LD_VAR 0 3
34742: PPUSH
34743: CALL_OW 310
34747: IFFALSE 34758
// ComExitBuilding ( j ) ;
34749: LD_VAR 0 3
34753: PPUSH
34754: CALL_OW 122
// wait ( 3 ) ;
34758: LD_INT 3
34760: PPUSH
34761: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34765: LD_VAR 0 3
34769: PPUSH
34770: LD_VAR 0 6
34774: PUSH
34775: LD_INT 2
34777: ARRAY
34778: PPUSH
34779: LD_VAR 0 6
34783: PUSH
34784: LD_INT 3
34786: ARRAY
34787: PPUSH
34788: CALL_OW 117
// end ;
34792: GO 34633
34794: POP
34795: POP
// end ; end else
34796: GO 35377
// begin for j in cargo do
34798: LD_ADDR_VAR 0 3
34802: PUSH
34803: LD_VAR 0 7
34807: PUSH
34808: FOR_IN
34809: IFFALSE 35375
// begin if GetTag ( j ) <> 0 then
34811: LD_VAR 0 3
34815: PPUSH
34816: CALL_OW 110
34820: PUSH
34821: LD_INT 0
34823: NONEQUAL
34824: IFFALSE 34828
// continue ;
34826: GO 34808
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34828: LD_VAR 0 3
34832: PPUSH
34833: CALL_OW 256
34837: PUSH
34838: LD_INT 1000
34840: LESS
34841: PUSH
34842: LD_VAR 0 3
34846: PPUSH
34847: LD_EXP 103
34851: PUSH
34852: LD_VAR 0 2
34856: ARRAY
34857: PPUSH
34858: CALL_OW 308
34862: NOT
34863: AND
34864: IFFALSE 34886
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34866: LD_VAR 0 3
34870: PPUSH
34871: LD_EXP 103
34875: PUSH
34876: LD_VAR 0 2
34880: ARRAY
34881: PPUSH
34882: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34886: LD_VAR 0 3
34890: PPUSH
34891: CALL_OW 256
34895: PUSH
34896: LD_INT 1000
34898: LESS
34899: PUSH
34900: LD_VAR 0 3
34904: PPUSH
34905: LD_EXP 103
34909: PUSH
34910: LD_VAR 0 2
34914: ARRAY
34915: PPUSH
34916: CALL_OW 308
34920: AND
34921: IFFALSE 34925
// continue ;
34923: GO 34808
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34925: LD_VAR 0 3
34929: PPUSH
34930: CALL_OW 262
34934: PUSH
34935: LD_INT 2
34937: EQUAL
34938: PUSH
34939: LD_VAR 0 3
34943: PPUSH
34944: CALL_OW 261
34948: PUSH
34949: LD_INT 15
34951: LESS
34952: AND
34953: IFFALSE 34957
// continue ;
34955: GO 34808
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34957: LD_VAR 0 3
34961: PPUSH
34962: CALL_OW 262
34966: PUSH
34967: LD_INT 1
34969: EQUAL
34970: PUSH
34971: LD_VAR 0 3
34975: PPUSH
34976: CALL_OW 261
34980: PUSH
34981: LD_INT 10
34983: LESS
34984: AND
34985: IFFALSE 35314
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34987: LD_ADDR_VAR 0 8
34991: PUSH
34992: LD_EXP 79
34996: PUSH
34997: LD_VAR 0 2
35001: ARRAY
35002: PPUSH
35003: LD_INT 2
35005: PUSH
35006: LD_INT 30
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 30
35018: PUSH
35019: LD_INT 1
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: LIST
35030: PPUSH
35031: CALL_OW 72
35035: ST_TO_ADDR
// if not depot then
35036: LD_VAR 0 8
35040: NOT
35041: IFFALSE 35045
// continue ;
35043: GO 34808
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35045: LD_VAR 0 3
35049: PPUSH
35050: LD_VAR 0 8
35054: PPUSH
35055: LD_VAR 0 3
35059: PPUSH
35060: CALL_OW 74
35064: PPUSH
35065: CALL_OW 296
35069: PUSH
35070: LD_INT 6
35072: LESS
35073: IFFALSE 35089
// SetFuel ( j , 100 ) else
35075: LD_VAR 0 3
35079: PPUSH
35080: LD_INT 100
35082: PPUSH
35083: CALL_OW 240
35087: GO 35314
// if GetFuel ( j ) = 0 then
35089: LD_VAR 0 3
35093: PPUSH
35094: CALL_OW 261
35098: PUSH
35099: LD_INT 0
35101: EQUAL
35102: IFFALSE 35314
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35104: LD_ADDR_EXP 98
35108: PUSH
35109: LD_EXP 98
35113: PPUSH
35114: LD_VAR 0 2
35118: PPUSH
35119: LD_EXP 98
35123: PUSH
35124: LD_VAR 0 2
35128: ARRAY
35129: PUSH
35130: LD_VAR 0 3
35134: DIFF
35135: PPUSH
35136: CALL_OW 1
35140: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35141: LD_VAR 0 3
35145: PPUSH
35146: CALL_OW 263
35150: PUSH
35151: LD_INT 1
35153: EQUAL
35154: IFFALSE 35170
// ComExitVehicle ( IsInUnit ( j ) ) ;
35156: LD_VAR 0 3
35160: PPUSH
35161: CALL_OW 310
35165: PPUSH
35166: CALL_OW 121
// if GetControl ( j ) = control_remote then
35170: LD_VAR 0 3
35174: PPUSH
35175: CALL_OW 263
35179: PUSH
35180: LD_INT 2
35182: EQUAL
35183: IFFALSE 35194
// ComUnlink ( j ) ;
35185: LD_VAR 0 3
35189: PPUSH
35190: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35194: LD_ADDR_VAR 0 9
35198: PUSH
35199: LD_VAR 0 2
35203: PPUSH
35204: LD_INT 3
35206: PPUSH
35207: CALL 44667 0 2
35211: ST_TO_ADDR
// if fac then
35212: LD_VAR 0 9
35216: IFFALSE 35312
// begin for k in fac do
35218: LD_ADDR_VAR 0 4
35222: PUSH
35223: LD_VAR 0 9
35227: PUSH
35228: FOR_IN
35229: IFFALSE 35310
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35231: LD_ADDR_VAR 0 10
35235: PUSH
35236: LD_VAR 0 9
35240: PPUSH
35241: LD_VAR 0 3
35245: PPUSH
35246: CALL_OW 265
35250: PPUSH
35251: LD_VAR 0 3
35255: PPUSH
35256: CALL_OW 262
35260: PPUSH
35261: LD_VAR 0 3
35265: PPUSH
35266: CALL_OW 263
35270: PPUSH
35271: LD_VAR 0 3
35275: PPUSH
35276: CALL_OW 264
35280: PPUSH
35281: CALL 55325 0 5
35285: ST_TO_ADDR
// if components then
35286: LD_VAR 0 10
35290: IFFALSE 35308
// begin MC_InsertProduceList ( i , components ) ;
35292: LD_VAR 0 2
35296: PPUSH
35297: LD_VAR 0 10
35301: PPUSH
35302: CALL 44212 0 2
// break ;
35306: GO 35310
// end ; end ;
35308: GO 35228
35310: POP
35311: POP
// end ; continue ;
35312: GO 34808
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35314: LD_VAR 0 3
35318: PPUSH
35319: LD_INT 1
35321: PPUSH
35322: CALL_OW 289
35326: PUSH
35327: LD_INT 100
35329: LESS
35330: PUSH
35331: LD_VAR 0 3
35335: PPUSH
35336: CALL_OW 314
35340: NOT
35341: AND
35342: IFFALSE 35371
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35344: LD_VAR 0 3
35348: PPUSH
35349: LD_VAR 0 6
35353: PUSH
35354: LD_INT 2
35356: ARRAY
35357: PPUSH
35358: LD_VAR 0 6
35362: PUSH
35363: LD_INT 3
35365: ARRAY
35366: PPUSH
35367: CALL_OW 117
// break ;
35371: GO 35375
// end ;
35373: GO 34808
35375: POP
35376: POP
// end ; end ;
35377: GO 33646
35379: POP
35380: POP
// end ;
35381: LD_VAR 0 1
35385: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35386: LD_INT 0
35388: PPUSH
35389: PPUSH
35390: PPUSH
35391: PPUSH
// if not mc_bases then
35392: LD_EXP 79
35396: NOT
35397: IFFALSE 35401
// exit ;
35399: GO 35562
// for i = 1 to mc_bases do
35401: LD_ADDR_VAR 0 2
35405: PUSH
35406: DOUBLE
35407: LD_INT 1
35409: DEC
35410: ST_TO_ADDR
35411: LD_EXP 79
35415: PUSH
35416: FOR_TO
35417: IFFALSE 35560
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35419: LD_ADDR_VAR 0 4
35423: PUSH
35424: LD_EXP 98
35428: PUSH
35429: LD_VAR 0 2
35433: ARRAY
35434: PUSH
35435: LD_EXP 101
35439: PUSH
35440: LD_VAR 0 2
35444: ARRAY
35445: UNION
35446: PPUSH
35447: LD_INT 33
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PPUSH
35457: CALL_OW 72
35461: ST_TO_ADDR
// if tmp then
35462: LD_VAR 0 4
35466: IFFALSE 35558
// for j in tmp do
35468: LD_ADDR_VAR 0 3
35472: PUSH
35473: LD_VAR 0 4
35477: PUSH
35478: FOR_IN
35479: IFFALSE 35556
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35481: LD_VAR 0 3
35485: PPUSH
35486: CALL_OW 312
35490: NOT
35491: PUSH
35492: LD_VAR 0 3
35496: PPUSH
35497: CALL_OW 256
35501: PUSH
35502: LD_INT 250
35504: GREATEREQUAL
35505: AND
35506: IFFALSE 35519
// Connect ( j ) else
35508: LD_VAR 0 3
35512: PPUSH
35513: CALL 60726 0 1
35517: GO 35554
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 256
35528: PUSH
35529: LD_INT 250
35531: LESS
35532: PUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: CALL_OW 312
35542: AND
35543: IFFALSE 35554
// ComUnlink ( j ) ;
35545: LD_VAR 0 3
35549: PPUSH
35550: CALL_OW 136
35554: GO 35478
35556: POP
35557: POP
// end ;
35558: GO 35416
35560: POP
35561: POP
// end ;
35562: LD_VAR 0 1
35566: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35567: LD_INT 0
35569: PPUSH
35570: PPUSH
35571: PPUSH
35572: PPUSH
35573: PPUSH
// if not mc_bases then
35574: LD_EXP 79
35578: NOT
35579: IFFALSE 35583
// exit ;
35581: GO 36028
// for i = 1 to mc_bases do
35583: LD_ADDR_VAR 0 2
35587: PUSH
35588: DOUBLE
35589: LD_INT 1
35591: DEC
35592: ST_TO_ADDR
35593: LD_EXP 79
35597: PUSH
35598: FOR_TO
35599: IFFALSE 36026
// begin if not mc_produce [ i ] then
35601: LD_EXP 100
35605: PUSH
35606: LD_VAR 0 2
35610: ARRAY
35611: NOT
35612: IFFALSE 35616
// continue ;
35614: GO 35598
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35616: LD_ADDR_VAR 0 5
35620: PUSH
35621: LD_EXP 79
35625: PUSH
35626: LD_VAR 0 2
35630: ARRAY
35631: PPUSH
35632: LD_INT 30
35634: PUSH
35635: LD_INT 3
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PPUSH
35642: CALL_OW 72
35646: ST_TO_ADDR
// if not fac then
35647: LD_VAR 0 5
35651: NOT
35652: IFFALSE 35656
// continue ;
35654: GO 35598
// for j in fac do
35656: LD_ADDR_VAR 0 3
35660: PUSH
35661: LD_VAR 0 5
35665: PUSH
35666: FOR_IN
35667: IFFALSE 36022
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35669: LD_VAR 0 3
35673: PPUSH
35674: CALL_OW 461
35678: PUSH
35679: LD_INT 2
35681: NONEQUAL
35682: PUSH
35683: LD_VAR 0 3
35687: PPUSH
35688: LD_INT 15
35690: PPUSH
35691: CALL 60386 0 2
35695: PUSH
35696: LD_INT 4
35698: ARRAY
35699: OR
35700: IFFALSE 35704
// continue ;
35702: GO 35666
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35704: LD_VAR 0 3
35708: PPUSH
35709: LD_EXP 100
35713: PUSH
35714: LD_VAR 0 2
35718: ARRAY
35719: PUSH
35720: LD_INT 1
35722: ARRAY
35723: PUSH
35724: LD_INT 1
35726: ARRAY
35727: PPUSH
35728: LD_EXP 100
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PUSH
35739: LD_INT 1
35741: ARRAY
35742: PUSH
35743: LD_INT 2
35745: ARRAY
35746: PPUSH
35747: LD_EXP 100
35751: PUSH
35752: LD_VAR 0 2
35756: ARRAY
35757: PUSH
35758: LD_INT 1
35760: ARRAY
35761: PUSH
35762: LD_INT 3
35764: ARRAY
35765: PPUSH
35766: LD_EXP 100
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: PUSH
35777: LD_INT 1
35779: ARRAY
35780: PUSH
35781: LD_INT 4
35783: ARRAY
35784: PPUSH
35785: CALL_OW 448
35789: PUSH
35790: LD_VAR 0 3
35794: PPUSH
35795: LD_EXP 100
35799: PUSH
35800: LD_VAR 0 2
35804: ARRAY
35805: PUSH
35806: LD_INT 1
35808: ARRAY
35809: PUSH
35810: LD_INT 1
35812: ARRAY
35813: PUSH
35814: LD_EXP 100
35818: PUSH
35819: LD_VAR 0 2
35823: ARRAY
35824: PUSH
35825: LD_INT 1
35827: ARRAY
35828: PUSH
35829: LD_INT 2
35831: ARRAY
35832: PUSH
35833: LD_EXP 100
35837: PUSH
35838: LD_VAR 0 2
35842: ARRAY
35843: PUSH
35844: LD_INT 1
35846: ARRAY
35847: PUSH
35848: LD_INT 3
35850: ARRAY
35851: PUSH
35852: LD_EXP 100
35856: PUSH
35857: LD_VAR 0 2
35861: ARRAY
35862: PUSH
35863: LD_INT 1
35865: ARRAY
35866: PUSH
35867: LD_INT 4
35869: ARRAY
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: PPUSH
35877: CALL 64057 0 2
35881: AND
35882: IFFALSE 36020
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35884: LD_VAR 0 3
35888: PPUSH
35889: LD_EXP 100
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 1
35902: ARRAY
35903: PUSH
35904: LD_INT 1
35906: ARRAY
35907: PPUSH
35908: LD_EXP 100
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_INT 1
35921: ARRAY
35922: PUSH
35923: LD_INT 2
35925: ARRAY
35926: PPUSH
35927: LD_EXP 100
35931: PUSH
35932: LD_VAR 0 2
35936: ARRAY
35937: PUSH
35938: LD_INT 1
35940: ARRAY
35941: PUSH
35942: LD_INT 3
35944: ARRAY
35945: PPUSH
35946: LD_EXP 100
35950: PUSH
35951: LD_VAR 0 2
35955: ARRAY
35956: PUSH
35957: LD_INT 1
35959: ARRAY
35960: PUSH
35961: LD_INT 4
35963: ARRAY
35964: PPUSH
35965: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35969: LD_ADDR_VAR 0 4
35973: PUSH
35974: LD_EXP 100
35978: PUSH
35979: LD_VAR 0 2
35983: ARRAY
35984: PPUSH
35985: LD_INT 1
35987: PPUSH
35988: CALL_OW 3
35992: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35993: LD_ADDR_EXP 100
35997: PUSH
35998: LD_EXP 100
36002: PPUSH
36003: LD_VAR 0 2
36007: PPUSH
36008: LD_VAR 0 4
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// break ;
36018: GO 36022
// end ; end ;
36020: GO 35666
36022: POP
36023: POP
// end ;
36024: GO 35598
36026: POP
36027: POP
// end ;
36028: LD_VAR 0 1
36032: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36033: LD_INT 0
36035: PPUSH
36036: PPUSH
36037: PPUSH
// if not mc_bases then
36038: LD_EXP 79
36042: NOT
36043: IFFALSE 36047
// exit ;
36045: GO 36136
// for i = 1 to mc_bases do
36047: LD_ADDR_VAR 0 2
36051: PUSH
36052: DOUBLE
36053: LD_INT 1
36055: DEC
36056: ST_TO_ADDR
36057: LD_EXP 79
36061: PUSH
36062: FOR_TO
36063: IFFALSE 36134
// begin if mc_attack [ i ] then
36065: LD_EXP 99
36069: PUSH
36070: LD_VAR 0 2
36074: ARRAY
36075: IFFALSE 36132
// begin tmp := mc_attack [ i ] [ 1 ] ;
36077: LD_ADDR_VAR 0 3
36081: PUSH
36082: LD_EXP 99
36086: PUSH
36087: LD_VAR 0 2
36091: ARRAY
36092: PUSH
36093: LD_INT 1
36095: ARRAY
36096: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36097: LD_ADDR_EXP 99
36101: PUSH
36102: LD_EXP 99
36106: PPUSH
36107: LD_VAR 0 2
36111: PPUSH
36112: EMPTY
36113: PPUSH
36114: CALL_OW 1
36118: ST_TO_ADDR
// Attack ( tmp ) ;
36119: LD_VAR 0 3
36123: PPUSH
36124: CALL 86247 0 1
// exit ;
36128: POP
36129: POP
36130: GO 36136
// end ; end ;
36132: GO 36062
36134: POP
36135: POP
// end ;
36136: LD_VAR 0 1
36140: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36141: LD_INT 0
36143: PPUSH
36144: PPUSH
36145: PPUSH
36146: PPUSH
36147: PPUSH
36148: PPUSH
36149: PPUSH
// if not mc_bases then
36150: LD_EXP 79
36154: NOT
36155: IFFALSE 36159
// exit ;
36157: GO 36741
// for i = 1 to mc_bases do
36159: LD_ADDR_VAR 0 2
36163: PUSH
36164: DOUBLE
36165: LD_INT 1
36167: DEC
36168: ST_TO_ADDR
36169: LD_EXP 79
36173: PUSH
36174: FOR_TO
36175: IFFALSE 36739
// begin if not mc_bases [ i ] then
36177: LD_EXP 79
36181: PUSH
36182: LD_VAR 0 2
36186: ARRAY
36187: NOT
36188: IFFALSE 36192
// continue ;
36190: GO 36174
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36192: LD_ADDR_VAR 0 7
36196: PUSH
36197: LD_EXP 79
36201: PUSH
36202: LD_VAR 0 2
36206: ARRAY
36207: PUSH
36208: LD_INT 1
36210: ARRAY
36211: PPUSH
36212: CALL 54629 0 1
36216: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36217: LD_ADDR_EXP 102
36221: PUSH
36222: LD_EXP 102
36226: PPUSH
36227: LD_VAR 0 2
36231: PPUSH
36232: LD_EXP 79
36236: PUSH
36237: LD_VAR 0 2
36241: ARRAY
36242: PUSH
36243: LD_INT 1
36245: ARRAY
36246: PPUSH
36247: CALL_OW 255
36251: PPUSH
36252: LD_EXP 104
36256: PUSH
36257: LD_VAR 0 2
36261: ARRAY
36262: PPUSH
36263: CALL 52183 0 2
36267: PPUSH
36268: CALL_OW 1
36272: ST_TO_ADDR
// if not mc_scan [ i ] then
36273: LD_EXP 102
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: NOT
36284: IFFALSE 36439
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36286: LD_ADDR_VAR 0 4
36290: PUSH
36291: LD_EXP 79
36295: PUSH
36296: LD_VAR 0 2
36300: ARRAY
36301: PPUSH
36302: LD_INT 2
36304: PUSH
36305: LD_INT 25
36307: PUSH
36308: LD_INT 5
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 25
36317: PUSH
36318: LD_INT 8
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 25
36327: PUSH
36328: LD_INT 9
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: PPUSH
36341: CALL_OW 72
36345: ST_TO_ADDR
// if not tmp then
36346: LD_VAR 0 4
36350: NOT
36351: IFFALSE 36355
// continue ;
36353: GO 36174
// for j in tmp do
36355: LD_ADDR_VAR 0 3
36359: PUSH
36360: LD_VAR 0 4
36364: PUSH
36365: FOR_IN
36366: IFFALSE 36437
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36368: LD_VAR 0 3
36372: PPUSH
36373: CALL_OW 310
36377: PPUSH
36378: CALL_OW 266
36382: PUSH
36383: LD_INT 5
36385: EQUAL
36386: PUSH
36387: LD_VAR 0 3
36391: PPUSH
36392: CALL_OW 257
36396: PUSH
36397: LD_INT 1
36399: EQUAL
36400: AND
36401: PUSH
36402: LD_VAR 0 3
36406: PPUSH
36407: CALL_OW 459
36411: NOT
36412: AND
36413: PUSH
36414: LD_VAR 0 7
36418: AND
36419: IFFALSE 36435
// ComChangeProfession ( j , class ) ;
36421: LD_VAR 0 3
36425: PPUSH
36426: LD_VAR 0 7
36430: PPUSH
36431: CALL_OW 123
36435: GO 36365
36437: POP
36438: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36439: LD_EXP 102
36443: PUSH
36444: LD_VAR 0 2
36448: ARRAY
36449: PUSH
36450: LD_EXP 101
36454: PUSH
36455: LD_VAR 0 2
36459: ARRAY
36460: NOT
36461: AND
36462: PUSH
36463: LD_EXP 79
36467: PUSH
36468: LD_VAR 0 2
36472: ARRAY
36473: PPUSH
36474: LD_INT 30
36476: PUSH
36477: LD_INT 32
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PPUSH
36484: CALL_OW 72
36488: NOT
36489: AND
36490: PUSH
36491: LD_EXP 79
36495: PUSH
36496: LD_VAR 0 2
36500: ARRAY
36501: PPUSH
36502: LD_INT 2
36504: PUSH
36505: LD_INT 30
36507: PUSH
36508: LD_INT 4
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 30
36517: PUSH
36518: LD_INT 5
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: LIST
36529: PPUSH
36530: CALL_OW 72
36534: NOT
36535: AND
36536: IFFALSE 36668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36538: LD_ADDR_VAR 0 4
36542: PUSH
36543: LD_EXP 79
36547: PUSH
36548: LD_VAR 0 2
36552: ARRAY
36553: PPUSH
36554: LD_INT 2
36556: PUSH
36557: LD_INT 25
36559: PUSH
36560: LD_INT 1
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PUSH
36567: LD_INT 25
36569: PUSH
36570: LD_INT 5
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 25
36579: PUSH
36580: LD_INT 8
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 25
36589: PUSH
36590: LD_INT 9
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: PPUSH
36604: CALL_OW 72
36608: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36609: LD_ADDR_VAR 0 4
36613: PUSH
36614: LD_VAR 0 4
36618: PUSH
36619: LD_VAR 0 4
36623: PPUSH
36624: LD_INT 18
36626: PPUSH
36627: CALL 91063 0 2
36631: DIFF
36632: ST_TO_ADDR
// if tmp then
36633: LD_VAR 0 4
36637: IFFALSE 36668
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36639: LD_VAR 0 2
36643: PPUSH
36644: LD_VAR 0 4
36648: PPUSH
36649: LD_EXP 104
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: PPUSH
36660: CALL 52218 0 3
// exit ;
36664: POP
36665: POP
36666: GO 36741
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36668: LD_EXP 102
36672: PUSH
36673: LD_VAR 0 2
36677: ARRAY
36678: PUSH
36679: LD_EXP 101
36683: PUSH
36684: LD_VAR 0 2
36688: ARRAY
36689: AND
36690: IFFALSE 36737
// begin tmp := mc_defender [ i ] ;
36692: LD_ADDR_VAR 0 4
36696: PUSH
36697: LD_EXP 101
36701: PUSH
36702: LD_VAR 0 2
36706: ARRAY
36707: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36708: LD_VAR 0 2
36712: PPUSH
36713: LD_VAR 0 4
36717: PPUSH
36718: LD_EXP 102
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: PPUSH
36729: CALL 52779 0 3
// exit ;
36733: POP
36734: POP
36735: GO 36741
// end ; end ;
36737: GO 36174
36739: POP
36740: POP
// end ;
36741: LD_VAR 0 1
36745: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36746: LD_INT 0
36748: PPUSH
36749: PPUSH
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
36754: PPUSH
36755: PPUSH
36756: PPUSH
36757: PPUSH
36758: PPUSH
// if not mc_bases then
36759: LD_EXP 79
36763: NOT
36764: IFFALSE 36768
// exit ;
36766: GO 37855
// for i = 1 to mc_bases do
36768: LD_ADDR_VAR 0 2
36772: PUSH
36773: DOUBLE
36774: LD_INT 1
36776: DEC
36777: ST_TO_ADDR
36778: LD_EXP 79
36782: PUSH
36783: FOR_TO
36784: IFFALSE 37853
// begin tmp := mc_lab [ i ] ;
36786: LD_ADDR_VAR 0 6
36790: PUSH
36791: LD_EXP 112
36795: PUSH
36796: LD_VAR 0 2
36800: ARRAY
36801: ST_TO_ADDR
// if not tmp then
36802: LD_VAR 0 6
36806: NOT
36807: IFFALSE 36811
// continue ;
36809: GO 36783
// idle_lab := 0 ;
36811: LD_ADDR_VAR 0 11
36815: PUSH
36816: LD_INT 0
36818: ST_TO_ADDR
// for j in tmp do
36819: LD_ADDR_VAR 0 3
36823: PUSH
36824: LD_VAR 0 6
36828: PUSH
36829: FOR_IN
36830: IFFALSE 37849
// begin researching := false ;
36832: LD_ADDR_VAR 0 10
36836: PUSH
36837: LD_INT 0
36839: ST_TO_ADDR
// side := GetSide ( j ) ;
36840: LD_ADDR_VAR 0 4
36844: PUSH
36845: LD_VAR 0 3
36849: PPUSH
36850: CALL_OW 255
36854: ST_TO_ADDR
// if not mc_tech [ side ] then
36855: LD_EXP 106
36859: PUSH
36860: LD_VAR 0 4
36864: ARRAY
36865: NOT
36866: IFFALSE 36870
// continue ;
36868: GO 36829
// if BuildingStatus ( j ) = bs_idle then
36870: LD_VAR 0 3
36874: PPUSH
36875: CALL_OW 461
36879: PUSH
36880: LD_INT 2
36882: EQUAL
36883: IFFALSE 37071
// begin if idle_lab and UnitsInside ( j ) < 6 then
36885: LD_VAR 0 11
36889: PUSH
36890: LD_VAR 0 3
36894: PPUSH
36895: CALL_OW 313
36899: PUSH
36900: LD_INT 6
36902: LESS
36903: AND
36904: IFFALSE 36975
// begin tmp2 := UnitsInside ( idle_lab ) ;
36906: LD_ADDR_VAR 0 9
36910: PUSH
36911: LD_VAR 0 11
36915: PPUSH
36916: CALL_OW 313
36920: ST_TO_ADDR
// if tmp2 then
36921: LD_VAR 0 9
36925: IFFALSE 36967
// for x in tmp2 do
36927: LD_ADDR_VAR 0 7
36931: PUSH
36932: LD_VAR 0 9
36936: PUSH
36937: FOR_IN
36938: IFFALSE 36965
// begin ComExitBuilding ( x ) ;
36940: LD_VAR 0 7
36944: PPUSH
36945: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36949: LD_VAR 0 7
36953: PPUSH
36954: LD_VAR 0 3
36958: PPUSH
36959: CALL_OW 180
// end ;
36963: GO 36937
36965: POP
36966: POP
// idle_lab := 0 ;
36967: LD_ADDR_VAR 0 11
36971: PUSH
36972: LD_INT 0
36974: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36975: LD_ADDR_VAR 0 5
36979: PUSH
36980: LD_EXP 106
36984: PUSH
36985: LD_VAR 0 4
36989: ARRAY
36990: PUSH
36991: FOR_IN
36992: IFFALSE 37052
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36994: LD_VAR 0 3
36998: PPUSH
36999: LD_VAR 0 5
37003: PPUSH
37004: CALL_OW 430
37008: PUSH
37009: LD_VAR 0 4
37013: PPUSH
37014: LD_VAR 0 5
37018: PPUSH
37019: CALL 51288 0 2
37023: AND
37024: IFFALSE 37050
// begin researching := true ;
37026: LD_ADDR_VAR 0 10
37030: PUSH
37031: LD_INT 1
37033: ST_TO_ADDR
// ComResearch ( j , t ) ;
37034: LD_VAR 0 3
37038: PPUSH
37039: LD_VAR 0 5
37043: PPUSH
37044: CALL_OW 124
// break ;
37048: GO 37052
// end ;
37050: GO 36991
37052: POP
37053: POP
// if not researching then
37054: LD_VAR 0 10
37058: NOT
37059: IFFALSE 37071
// idle_lab := j ;
37061: LD_ADDR_VAR 0 11
37065: PUSH
37066: LD_VAR 0 3
37070: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37071: LD_VAR 0 3
37075: PPUSH
37076: CALL_OW 461
37080: PUSH
37081: LD_INT 10
37083: EQUAL
37084: IFFALSE 37672
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37086: LD_EXP 108
37090: PUSH
37091: LD_VAR 0 2
37095: ARRAY
37096: NOT
37097: PUSH
37098: LD_EXP 109
37102: PUSH
37103: LD_VAR 0 2
37107: ARRAY
37108: NOT
37109: AND
37110: PUSH
37111: LD_EXP 106
37115: PUSH
37116: LD_VAR 0 4
37120: ARRAY
37121: PUSH
37122: LD_INT 1
37124: GREATER
37125: AND
37126: IFFALSE 37257
// begin ComCancel ( j ) ;
37128: LD_VAR 0 3
37132: PPUSH
37133: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37137: LD_ADDR_EXP 106
37141: PUSH
37142: LD_EXP 106
37146: PPUSH
37147: LD_VAR 0 4
37151: PPUSH
37152: LD_EXP 106
37156: PUSH
37157: LD_VAR 0 4
37161: ARRAY
37162: PPUSH
37163: LD_EXP 106
37167: PUSH
37168: LD_VAR 0 4
37172: ARRAY
37173: PUSH
37174: LD_INT 1
37176: MINUS
37177: PPUSH
37178: LD_EXP 106
37182: PUSH
37183: LD_VAR 0 4
37187: ARRAY
37188: PPUSH
37189: LD_INT 0
37191: PPUSH
37192: CALL 57211 0 4
37196: PPUSH
37197: CALL_OW 1
37201: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37202: LD_ADDR_EXP 106
37206: PUSH
37207: LD_EXP 106
37211: PPUSH
37212: LD_VAR 0 4
37216: PPUSH
37217: LD_EXP 106
37221: PUSH
37222: LD_VAR 0 4
37226: ARRAY
37227: PPUSH
37228: LD_EXP 106
37232: PUSH
37233: LD_VAR 0 4
37237: ARRAY
37238: PPUSH
37239: LD_INT 1
37241: PPUSH
37242: LD_INT 0
37244: PPUSH
37245: CALL 57211 0 4
37249: PPUSH
37250: CALL_OW 1
37254: ST_TO_ADDR
// continue ;
37255: GO 36829
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37257: LD_EXP 108
37261: PUSH
37262: LD_VAR 0 2
37266: ARRAY
37267: PUSH
37268: LD_EXP 109
37272: PUSH
37273: LD_VAR 0 2
37277: ARRAY
37278: NOT
37279: AND
37280: IFFALSE 37407
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37282: LD_ADDR_EXP 109
37286: PUSH
37287: LD_EXP 109
37291: PPUSH
37292: LD_VAR 0 2
37296: PUSH
37297: LD_EXP 109
37301: PUSH
37302: LD_VAR 0 2
37306: ARRAY
37307: PUSH
37308: LD_INT 1
37310: PLUS
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PPUSH
37316: LD_EXP 108
37320: PUSH
37321: LD_VAR 0 2
37325: ARRAY
37326: PUSH
37327: LD_INT 1
37329: ARRAY
37330: PPUSH
37331: CALL 57793 0 3
37335: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37336: LD_EXP 108
37340: PUSH
37341: LD_VAR 0 2
37345: ARRAY
37346: PUSH
37347: LD_INT 1
37349: ARRAY
37350: PPUSH
37351: LD_INT 112
37353: PPUSH
37354: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37358: LD_ADDR_VAR 0 9
37362: PUSH
37363: LD_EXP 108
37367: PUSH
37368: LD_VAR 0 2
37372: ARRAY
37373: PPUSH
37374: LD_INT 1
37376: PPUSH
37377: CALL_OW 3
37381: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37382: LD_ADDR_EXP 108
37386: PUSH
37387: LD_EXP 108
37391: PPUSH
37392: LD_VAR 0 2
37396: PPUSH
37397: LD_VAR 0 9
37401: PPUSH
37402: CALL_OW 1
37406: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37407: LD_EXP 108
37411: PUSH
37412: LD_VAR 0 2
37416: ARRAY
37417: PUSH
37418: LD_EXP 109
37422: PUSH
37423: LD_VAR 0 2
37427: ARRAY
37428: AND
37429: PUSH
37430: LD_EXP 109
37434: PUSH
37435: LD_VAR 0 2
37439: ARRAY
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: PPUSH
37445: CALL_OW 310
37449: NOT
37450: AND
37451: PUSH
37452: LD_VAR 0 3
37456: PPUSH
37457: CALL_OW 313
37461: PUSH
37462: LD_INT 6
37464: EQUAL
37465: AND
37466: IFFALSE 37522
// begin tmp2 := UnitsInside ( j ) ;
37468: LD_ADDR_VAR 0 9
37472: PUSH
37473: LD_VAR 0 3
37477: PPUSH
37478: CALL_OW 313
37482: ST_TO_ADDR
// if tmp2 = 6 then
37483: LD_VAR 0 9
37487: PUSH
37488: LD_INT 6
37490: EQUAL
37491: IFFALSE 37522
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37493: LD_VAR 0 9
37497: PUSH
37498: LD_INT 1
37500: ARRAY
37501: PPUSH
37502: LD_INT 112
37504: PPUSH
37505: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37509: LD_VAR 0 9
37513: PUSH
37514: LD_INT 1
37516: ARRAY
37517: PPUSH
37518: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37522: LD_EXP 109
37526: PUSH
37527: LD_VAR 0 2
37531: ARRAY
37532: PUSH
37533: LD_EXP 109
37537: PUSH
37538: LD_VAR 0 2
37542: ARRAY
37543: PUSH
37544: LD_INT 1
37546: ARRAY
37547: PPUSH
37548: CALL_OW 314
37552: NOT
37553: AND
37554: PUSH
37555: LD_EXP 109
37559: PUSH
37560: LD_VAR 0 2
37564: ARRAY
37565: PUSH
37566: LD_INT 1
37568: ARRAY
37569: PPUSH
37570: CALL_OW 310
37574: NOT
37575: AND
37576: IFFALSE 37602
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37578: LD_EXP 109
37582: PUSH
37583: LD_VAR 0 2
37587: ARRAY
37588: PUSH
37589: LD_INT 1
37591: ARRAY
37592: PPUSH
37593: LD_VAR 0 3
37597: PPUSH
37598: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37602: LD_EXP 109
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: PUSH
37613: LD_INT 1
37615: ARRAY
37616: PPUSH
37617: CALL_OW 310
37621: PUSH
37622: LD_EXP 109
37626: PUSH
37627: LD_VAR 0 2
37631: ARRAY
37632: PUSH
37633: LD_INT 1
37635: ARRAY
37636: PPUSH
37637: CALL_OW 310
37641: PPUSH
37642: CALL_OW 461
37646: PUSH
37647: LD_INT 3
37649: NONEQUAL
37650: AND
37651: IFFALSE 37672
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37653: LD_EXP 109
37657: PUSH
37658: LD_VAR 0 2
37662: ARRAY
37663: PUSH
37664: LD_INT 1
37666: ARRAY
37667: PPUSH
37668: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37672: LD_VAR 0 3
37676: PPUSH
37677: CALL_OW 461
37681: PUSH
37682: LD_INT 6
37684: EQUAL
37685: PUSH
37686: LD_VAR 0 6
37690: PUSH
37691: LD_INT 1
37693: GREATER
37694: AND
37695: IFFALSE 37847
// begin sci := [ ] ;
37697: LD_ADDR_VAR 0 8
37701: PUSH
37702: EMPTY
37703: ST_TO_ADDR
// for x in ( tmp diff j ) do
37704: LD_ADDR_VAR 0 7
37708: PUSH
37709: LD_VAR 0 6
37713: PUSH
37714: LD_VAR 0 3
37718: DIFF
37719: PUSH
37720: FOR_IN
37721: IFFALSE 37773
// begin if sci = 6 then
37723: LD_VAR 0 8
37727: PUSH
37728: LD_INT 6
37730: EQUAL
37731: IFFALSE 37735
// break ;
37733: GO 37773
// if BuildingStatus ( x ) = bs_idle then
37735: LD_VAR 0 7
37739: PPUSH
37740: CALL_OW 461
37744: PUSH
37745: LD_INT 2
37747: EQUAL
37748: IFFALSE 37771
// sci := sci ^ UnitsInside ( x ) ;
37750: LD_ADDR_VAR 0 8
37754: PUSH
37755: LD_VAR 0 8
37759: PUSH
37760: LD_VAR 0 7
37764: PPUSH
37765: CALL_OW 313
37769: ADD
37770: ST_TO_ADDR
// end ;
37771: GO 37720
37773: POP
37774: POP
// if not sci then
37775: LD_VAR 0 8
37779: NOT
37780: IFFALSE 37784
// continue ;
37782: GO 36829
// for x in sci do
37784: LD_ADDR_VAR 0 7
37788: PUSH
37789: LD_VAR 0 8
37793: PUSH
37794: FOR_IN
37795: IFFALSE 37845
// if IsInUnit ( x ) and not HasTask ( x ) then
37797: LD_VAR 0 7
37801: PPUSH
37802: CALL_OW 310
37806: PUSH
37807: LD_VAR 0 7
37811: PPUSH
37812: CALL_OW 314
37816: NOT
37817: AND
37818: IFFALSE 37843
// begin ComExitBuilding ( x ) ;
37820: LD_VAR 0 7
37824: PPUSH
37825: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37829: LD_VAR 0 7
37833: PPUSH
37834: LD_VAR 0 3
37838: PPUSH
37839: CALL_OW 180
// end ;
37843: GO 37794
37845: POP
37846: POP
// end ; end ;
37847: GO 36829
37849: POP
37850: POP
// end ;
37851: GO 36783
37853: POP
37854: POP
// end ;
37855: LD_VAR 0 1
37859: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37860: LD_INT 0
37862: PPUSH
37863: PPUSH
// if not mc_bases then
37864: LD_EXP 79
37868: NOT
37869: IFFALSE 37873
// exit ;
37871: GO 37954
// for i = 1 to mc_bases do
37873: LD_ADDR_VAR 0 2
37877: PUSH
37878: DOUBLE
37879: LD_INT 1
37881: DEC
37882: ST_TO_ADDR
37883: LD_EXP 79
37887: PUSH
37888: FOR_TO
37889: IFFALSE 37952
// if mc_mines [ i ] and mc_miners [ i ] then
37891: LD_EXP 92
37895: PUSH
37896: LD_VAR 0 2
37900: ARRAY
37901: PUSH
37902: LD_EXP 93
37906: PUSH
37907: LD_VAR 0 2
37911: ARRAY
37912: AND
37913: IFFALSE 37950
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37915: LD_EXP 93
37919: PUSH
37920: LD_VAR 0 2
37924: ARRAY
37925: PUSH
37926: LD_INT 1
37928: ARRAY
37929: PPUSH
37930: CALL_OW 255
37934: PPUSH
37935: LD_EXP 92
37939: PUSH
37940: LD_VAR 0 2
37944: ARRAY
37945: PPUSH
37946: CALL 54782 0 2
37950: GO 37888
37952: POP
37953: POP
// end ;
37954: LD_VAR 0 1
37958: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37959: LD_INT 0
37961: PPUSH
37962: PPUSH
37963: PPUSH
37964: PPUSH
37965: PPUSH
37966: PPUSH
37967: PPUSH
37968: PPUSH
// if not mc_bases or not mc_parking then
37969: LD_EXP 79
37973: NOT
37974: PUSH
37975: LD_EXP 103
37979: NOT
37980: OR
37981: IFFALSE 37985
// exit ;
37983: GO 38684
// for i = 1 to mc_bases do
37985: LD_ADDR_VAR 0 2
37989: PUSH
37990: DOUBLE
37991: LD_INT 1
37993: DEC
37994: ST_TO_ADDR
37995: LD_EXP 79
37999: PUSH
38000: FOR_TO
38001: IFFALSE 38682
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38003: LD_EXP 79
38007: PUSH
38008: LD_VAR 0 2
38012: ARRAY
38013: NOT
38014: PUSH
38015: LD_EXP 103
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: NOT
38026: OR
38027: IFFALSE 38031
// continue ;
38029: GO 38000
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38031: LD_ADDR_VAR 0 5
38035: PUSH
38036: LD_EXP 79
38040: PUSH
38041: LD_VAR 0 2
38045: ARRAY
38046: PUSH
38047: LD_INT 1
38049: ARRAY
38050: PPUSH
38051: CALL_OW 255
38055: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38056: LD_ADDR_VAR 0 6
38060: PUSH
38061: LD_EXP 79
38065: PUSH
38066: LD_VAR 0 2
38070: ARRAY
38071: PPUSH
38072: LD_INT 30
38074: PUSH
38075: LD_INT 3
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PPUSH
38082: CALL_OW 72
38086: ST_TO_ADDR
// if not fac then
38087: LD_VAR 0 6
38091: NOT
38092: IFFALSE 38143
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38094: LD_ADDR_VAR 0 6
38098: PUSH
38099: LD_EXP 79
38103: PUSH
38104: LD_VAR 0 2
38108: ARRAY
38109: PPUSH
38110: LD_INT 2
38112: PUSH
38113: LD_INT 30
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 30
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: LIST
38137: PPUSH
38138: CALL_OW 72
38142: ST_TO_ADDR
// if not fac then
38143: LD_VAR 0 6
38147: NOT
38148: IFFALSE 38152
// continue ;
38150: GO 38000
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38152: LD_ADDR_VAR 0 7
38156: PUSH
38157: LD_EXP 103
38161: PUSH
38162: LD_VAR 0 2
38166: ARRAY
38167: PPUSH
38168: LD_INT 22
38170: PUSH
38171: LD_VAR 0 5
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 21
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 3
38192: PUSH
38193: LD_INT 24
38195: PUSH
38196: LD_INT 1000
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 70
38216: ST_TO_ADDR
// for j in fac do
38217: LD_ADDR_VAR 0 3
38221: PUSH
38222: LD_VAR 0 6
38226: PUSH
38227: FOR_IN
38228: IFFALSE 38309
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38230: LD_ADDR_VAR 0 7
38234: PUSH
38235: LD_VAR 0 7
38239: PUSH
38240: LD_INT 22
38242: PUSH
38243: LD_VAR 0 5
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 91
38254: PUSH
38255: LD_VAR 0 3
38259: PUSH
38260: LD_INT 15
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 21
38270: PUSH
38271: LD_INT 2
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 3
38280: PUSH
38281: LD_INT 24
38283: PUSH
38284: LD_INT 1000
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: PPUSH
38301: CALL_OW 69
38305: UNION
38306: ST_TO_ADDR
38307: GO 38227
38309: POP
38310: POP
// if not vehs then
38311: LD_VAR 0 7
38315: NOT
38316: IFFALSE 38342
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38318: LD_ADDR_EXP 91
38322: PUSH
38323: LD_EXP 91
38327: PPUSH
38328: LD_VAR 0 2
38332: PPUSH
38333: EMPTY
38334: PPUSH
38335: CALL_OW 1
38339: ST_TO_ADDR
// continue ;
38340: GO 38000
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38342: LD_ADDR_VAR 0 8
38346: PUSH
38347: LD_EXP 79
38351: PUSH
38352: LD_VAR 0 2
38356: ARRAY
38357: PPUSH
38358: LD_INT 30
38360: PUSH
38361: LD_INT 3
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PPUSH
38368: CALL_OW 72
38372: ST_TO_ADDR
// if tmp then
38373: LD_VAR 0 8
38377: IFFALSE 38480
// begin for j in tmp do
38379: LD_ADDR_VAR 0 3
38383: PUSH
38384: LD_VAR 0 8
38388: PUSH
38389: FOR_IN
38390: IFFALSE 38478
// for k in UnitsInside ( j ) do
38392: LD_ADDR_VAR 0 4
38396: PUSH
38397: LD_VAR 0 3
38401: PPUSH
38402: CALL_OW 313
38406: PUSH
38407: FOR_IN
38408: IFFALSE 38474
// if k then
38410: LD_VAR 0 4
38414: IFFALSE 38472
// if not k in mc_repair_vehicle [ i ] then
38416: LD_VAR 0 4
38420: PUSH
38421: LD_EXP 91
38425: PUSH
38426: LD_VAR 0 2
38430: ARRAY
38431: IN
38432: NOT
38433: IFFALSE 38472
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38435: LD_ADDR_EXP 91
38439: PUSH
38440: LD_EXP 91
38444: PPUSH
38445: LD_VAR 0 2
38449: PPUSH
38450: LD_EXP 91
38454: PUSH
38455: LD_VAR 0 2
38459: ARRAY
38460: PUSH
38461: LD_VAR 0 4
38465: UNION
38466: PPUSH
38467: CALL_OW 1
38471: ST_TO_ADDR
38472: GO 38407
38474: POP
38475: POP
38476: GO 38389
38478: POP
38479: POP
// end ; if not mc_repair_vehicle [ i ] then
38480: LD_EXP 91
38484: PUSH
38485: LD_VAR 0 2
38489: ARRAY
38490: NOT
38491: IFFALSE 38495
// continue ;
38493: GO 38000
// for j in mc_repair_vehicle [ i ] do
38495: LD_ADDR_VAR 0 3
38499: PUSH
38500: LD_EXP 91
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: PUSH
38511: FOR_IN
38512: IFFALSE 38678
// begin if GetClass ( j ) <> 3 then
38514: LD_VAR 0 3
38518: PPUSH
38519: CALL_OW 257
38523: PUSH
38524: LD_INT 3
38526: NONEQUAL
38527: IFFALSE 38568
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38529: LD_ADDR_EXP 91
38533: PUSH
38534: LD_EXP 91
38538: PPUSH
38539: LD_VAR 0 2
38543: PPUSH
38544: LD_EXP 91
38548: PUSH
38549: LD_VAR 0 2
38553: ARRAY
38554: PUSH
38555: LD_VAR 0 3
38559: DIFF
38560: PPUSH
38561: CALL_OW 1
38565: ST_TO_ADDR
// continue ;
38566: GO 38511
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38568: LD_VAR 0 3
38572: PPUSH
38573: CALL_OW 311
38577: NOT
38578: PUSH
38579: LD_VAR 0 3
38583: PUSH
38584: LD_EXP 82
38588: PUSH
38589: LD_VAR 0 2
38593: ARRAY
38594: PUSH
38595: LD_INT 1
38597: ARRAY
38598: IN
38599: NOT
38600: AND
38601: PUSH
38602: LD_VAR 0 3
38606: PUSH
38607: LD_EXP 82
38611: PUSH
38612: LD_VAR 0 2
38616: ARRAY
38617: PUSH
38618: LD_INT 2
38620: ARRAY
38621: IN
38622: NOT
38623: AND
38624: IFFALSE 38676
// begin if IsInUnit ( j ) then
38626: LD_VAR 0 3
38630: PPUSH
38631: CALL_OW 310
38635: IFFALSE 38646
// ComExitBuilding ( j ) ;
38637: LD_VAR 0 3
38641: PPUSH
38642: CALL_OW 122
// if not HasTask ( j ) then
38646: LD_VAR 0 3
38650: PPUSH
38651: CALL_OW 314
38655: NOT
38656: IFFALSE 38676
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38658: LD_VAR 0 3
38662: PPUSH
38663: LD_VAR 0 7
38667: PUSH
38668: LD_INT 1
38670: ARRAY
38671: PPUSH
38672: CALL_OW 189
// end ; end ;
38676: GO 38511
38678: POP
38679: POP
// end ;
38680: GO 38000
38682: POP
38683: POP
// end ;
38684: LD_VAR 0 1
38688: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38689: LD_INT 0
38691: PPUSH
38692: PPUSH
38693: PPUSH
38694: PPUSH
38695: PPUSH
38696: PPUSH
38697: PPUSH
38698: PPUSH
38699: PPUSH
38700: PPUSH
38701: PPUSH
// if not mc_bases then
38702: LD_EXP 79
38706: NOT
38707: IFFALSE 38711
// exit ;
38709: GO 39513
// for i = 1 to mc_bases do
38711: LD_ADDR_VAR 0 2
38715: PUSH
38716: DOUBLE
38717: LD_INT 1
38719: DEC
38720: ST_TO_ADDR
38721: LD_EXP 79
38725: PUSH
38726: FOR_TO
38727: IFFALSE 39511
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38729: LD_EXP 107
38733: PUSH
38734: LD_VAR 0 2
38738: ARRAY
38739: NOT
38740: PUSH
38741: LD_EXP 82
38745: PUSH
38746: LD_VAR 0 2
38750: ARRAY
38751: PUSH
38752: LD_INT 1
38754: ARRAY
38755: OR
38756: PUSH
38757: LD_EXP 82
38761: PUSH
38762: LD_VAR 0 2
38766: ARRAY
38767: PUSH
38768: LD_INT 2
38770: ARRAY
38771: OR
38772: PUSH
38773: LD_EXP 105
38777: PUSH
38778: LD_VAR 0 2
38782: ARRAY
38783: PPUSH
38784: LD_INT 1
38786: PPUSH
38787: CALL_OW 325
38791: NOT
38792: OR
38793: PUSH
38794: LD_EXP 102
38798: PUSH
38799: LD_VAR 0 2
38803: ARRAY
38804: OR
38805: IFFALSE 38809
// continue ;
38807: GO 38726
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38809: LD_ADDR_VAR 0 8
38813: PUSH
38814: LD_EXP 79
38818: PUSH
38819: LD_VAR 0 2
38823: ARRAY
38824: PPUSH
38825: LD_INT 25
38827: PUSH
38828: LD_INT 4
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 50
38837: PUSH
38838: EMPTY
38839: LIST
38840: PUSH
38841: LD_INT 3
38843: PUSH
38844: LD_INT 60
38846: PUSH
38847: EMPTY
38848: LIST
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: LIST
38858: PPUSH
38859: CALL_OW 72
38863: PUSH
38864: LD_EXP 83
38868: PUSH
38869: LD_VAR 0 2
38873: ARRAY
38874: DIFF
38875: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38876: LD_ADDR_VAR 0 9
38880: PUSH
38881: LD_EXP 79
38885: PUSH
38886: LD_VAR 0 2
38890: ARRAY
38891: PPUSH
38892: LD_INT 2
38894: PUSH
38895: LD_INT 30
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 30
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: LIST
38919: PPUSH
38920: CALL_OW 72
38924: ST_TO_ADDR
// if not tmp or not dep then
38925: LD_VAR 0 8
38929: NOT
38930: PUSH
38931: LD_VAR 0 9
38935: NOT
38936: OR
38937: IFFALSE 38941
// continue ;
38939: GO 38726
// side := GetSide ( tmp [ 1 ] ) ;
38941: LD_ADDR_VAR 0 11
38945: PUSH
38946: LD_VAR 0 8
38950: PUSH
38951: LD_INT 1
38953: ARRAY
38954: PPUSH
38955: CALL_OW 255
38959: ST_TO_ADDR
// dep := dep [ 1 ] ;
38960: LD_ADDR_VAR 0 9
38964: PUSH
38965: LD_VAR 0 9
38969: PUSH
38970: LD_INT 1
38972: ARRAY
38973: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38974: LD_ADDR_VAR 0 7
38978: PUSH
38979: LD_EXP 107
38983: PUSH
38984: LD_VAR 0 2
38988: ARRAY
38989: PPUSH
38990: LD_INT 22
38992: PUSH
38993: LD_INT 0
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 25
39002: PUSH
39003: LD_INT 12
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PPUSH
39014: CALL_OW 70
39018: PUSH
39019: LD_INT 22
39021: PUSH
39022: LD_INT 0
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 25
39031: PUSH
39032: LD_INT 12
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 91
39041: PUSH
39042: LD_VAR 0 9
39046: PUSH
39047: LD_INT 20
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: LIST
39059: PPUSH
39060: CALL_OW 69
39064: UNION
39065: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39066: LD_ADDR_VAR 0 10
39070: PUSH
39071: LD_EXP 107
39075: PUSH
39076: LD_VAR 0 2
39080: ARRAY
39081: PPUSH
39082: LD_INT 81
39084: PUSH
39085: LD_VAR 0 11
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PPUSH
39094: CALL_OW 70
39098: ST_TO_ADDR
// if not apes or danger_at_area then
39099: LD_VAR 0 7
39103: NOT
39104: PUSH
39105: LD_VAR 0 10
39109: OR
39110: IFFALSE 39160
// begin if mc_taming [ i ] then
39112: LD_EXP 110
39116: PUSH
39117: LD_VAR 0 2
39121: ARRAY
39122: IFFALSE 39158
// begin MC_Reset ( i , 121 ) ;
39124: LD_VAR 0 2
39128: PPUSH
39129: LD_INT 121
39131: PPUSH
39132: CALL 24595 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39136: LD_ADDR_EXP 110
39140: PUSH
39141: LD_EXP 110
39145: PPUSH
39146: LD_VAR 0 2
39150: PPUSH
39151: EMPTY
39152: PPUSH
39153: CALL_OW 1
39157: ST_TO_ADDR
// end ; continue ;
39158: GO 38726
// end ; for j in tmp do
39160: LD_ADDR_VAR 0 3
39164: PUSH
39165: LD_VAR 0 8
39169: PUSH
39170: FOR_IN
39171: IFFALSE 39507
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39173: LD_VAR 0 3
39177: PUSH
39178: LD_EXP 110
39182: PUSH
39183: LD_VAR 0 2
39187: ARRAY
39188: IN
39189: NOT
39190: PUSH
39191: LD_EXP 110
39195: PUSH
39196: LD_VAR 0 2
39200: ARRAY
39201: PUSH
39202: LD_INT 3
39204: LESS
39205: AND
39206: IFFALSE 39264
// begin SetTag ( j , 121 ) ;
39208: LD_VAR 0 3
39212: PPUSH
39213: LD_INT 121
39215: PPUSH
39216: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39220: LD_ADDR_EXP 110
39224: PUSH
39225: LD_EXP 110
39229: PPUSH
39230: LD_VAR 0 2
39234: PUSH
39235: LD_EXP 110
39239: PUSH
39240: LD_VAR 0 2
39244: ARRAY
39245: PUSH
39246: LD_INT 1
39248: PLUS
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PPUSH
39254: LD_VAR 0 3
39258: PPUSH
39259: CALL 57793 0 3
39263: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39264: LD_VAR 0 3
39268: PUSH
39269: LD_EXP 110
39273: PUSH
39274: LD_VAR 0 2
39278: ARRAY
39279: IN
39280: IFFALSE 39505
// begin if GetClass ( j ) <> 4 then
39282: LD_VAR 0 3
39286: PPUSH
39287: CALL_OW 257
39291: PUSH
39292: LD_INT 4
39294: NONEQUAL
39295: IFFALSE 39348
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39297: LD_ADDR_EXP 110
39301: PUSH
39302: LD_EXP 110
39306: PPUSH
39307: LD_VAR 0 2
39311: PPUSH
39312: LD_EXP 110
39316: PUSH
39317: LD_VAR 0 2
39321: ARRAY
39322: PUSH
39323: LD_VAR 0 3
39327: DIFF
39328: PPUSH
39329: CALL_OW 1
39333: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39334: LD_VAR 0 3
39338: PPUSH
39339: LD_INT 0
39341: PPUSH
39342: CALL_OW 109
// continue ;
39346: GO 39170
// end ; if IsInUnit ( j ) then
39348: LD_VAR 0 3
39352: PPUSH
39353: CALL_OW 310
39357: IFFALSE 39368
// ComExitBuilding ( j ) ;
39359: LD_VAR 0 3
39363: PPUSH
39364: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39368: LD_ADDR_VAR 0 6
39372: PUSH
39373: LD_VAR 0 7
39377: PPUSH
39378: LD_VAR 0 3
39382: PPUSH
39383: CALL_OW 74
39387: ST_TO_ADDR
// if not ape then
39388: LD_VAR 0 6
39392: NOT
39393: IFFALSE 39397
// break ;
39395: GO 39507
// x := GetX ( ape ) ;
39397: LD_ADDR_VAR 0 4
39401: PUSH
39402: LD_VAR 0 6
39406: PPUSH
39407: CALL_OW 250
39411: ST_TO_ADDR
// y := GetY ( ape ) ;
39412: LD_ADDR_VAR 0 5
39416: PUSH
39417: LD_VAR 0 6
39421: PPUSH
39422: CALL_OW 251
39426: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39427: LD_VAR 0 4
39431: PPUSH
39432: LD_VAR 0 5
39436: PPUSH
39437: CALL_OW 488
39441: NOT
39442: PUSH
39443: LD_VAR 0 11
39447: PPUSH
39448: LD_VAR 0 4
39452: PPUSH
39453: LD_VAR 0 5
39457: PPUSH
39458: LD_INT 20
39460: PPUSH
39461: CALL 58689 0 4
39465: PUSH
39466: LD_INT 4
39468: ARRAY
39469: OR
39470: IFFALSE 39474
// break ;
39472: GO 39507
// if not HasTask ( j ) then
39474: LD_VAR 0 3
39478: PPUSH
39479: CALL_OW 314
39483: NOT
39484: IFFALSE 39505
// ComTameXY ( j , x , y ) ;
39486: LD_VAR 0 3
39490: PPUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: LD_VAR 0 5
39500: PPUSH
39501: CALL_OW 131
// end ; end ;
39505: GO 39170
39507: POP
39508: POP
// end ;
39509: GO 38726
39511: POP
39512: POP
// end ;
39513: LD_VAR 0 1
39517: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39518: LD_INT 0
39520: PPUSH
39521: PPUSH
39522: PPUSH
39523: PPUSH
39524: PPUSH
39525: PPUSH
39526: PPUSH
39527: PPUSH
// if not mc_bases then
39528: LD_EXP 79
39532: NOT
39533: IFFALSE 39537
// exit ;
39535: GO 40163
// for i = 1 to mc_bases do
39537: LD_ADDR_VAR 0 2
39541: PUSH
39542: DOUBLE
39543: LD_INT 1
39545: DEC
39546: ST_TO_ADDR
39547: LD_EXP 79
39551: PUSH
39552: FOR_TO
39553: IFFALSE 40161
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39555: LD_EXP 108
39559: PUSH
39560: LD_VAR 0 2
39564: ARRAY
39565: NOT
39566: PUSH
39567: LD_EXP 108
39571: PUSH
39572: LD_VAR 0 2
39576: ARRAY
39577: PPUSH
39578: LD_INT 25
39580: PUSH
39581: LD_INT 12
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PPUSH
39588: CALL_OW 72
39592: NOT
39593: OR
39594: IFFALSE 39598
// continue ;
39596: GO 39552
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39598: LD_ADDR_VAR 0 5
39602: PUSH
39603: LD_EXP 108
39607: PUSH
39608: LD_VAR 0 2
39612: ARRAY
39613: PUSH
39614: LD_INT 1
39616: ARRAY
39617: PPUSH
39618: CALL_OW 255
39622: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39623: LD_VAR 0 5
39627: PPUSH
39628: LD_INT 2
39630: PPUSH
39631: CALL_OW 325
39635: IFFALSE 39888
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39637: LD_ADDR_VAR 0 4
39641: PUSH
39642: LD_EXP 108
39646: PUSH
39647: LD_VAR 0 2
39651: ARRAY
39652: PPUSH
39653: LD_INT 25
39655: PUSH
39656: LD_INT 16
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PPUSH
39663: CALL_OW 72
39667: ST_TO_ADDR
// if tmp < 6 then
39668: LD_VAR 0 4
39672: PUSH
39673: LD_INT 6
39675: LESS
39676: IFFALSE 39888
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39678: LD_ADDR_VAR 0 6
39682: PUSH
39683: LD_EXP 79
39687: PUSH
39688: LD_VAR 0 2
39692: ARRAY
39693: PPUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 30
39699: PUSH
39700: LD_INT 0
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 30
39709: PUSH
39710: LD_INT 1
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: LIST
39721: PPUSH
39722: CALL_OW 72
39726: ST_TO_ADDR
// if depot then
39727: LD_VAR 0 6
39731: IFFALSE 39888
// begin selected := 0 ;
39733: LD_ADDR_VAR 0 7
39737: PUSH
39738: LD_INT 0
39740: ST_TO_ADDR
// for j in depot do
39741: LD_ADDR_VAR 0 3
39745: PUSH
39746: LD_VAR 0 6
39750: PUSH
39751: FOR_IN
39752: IFFALSE 39783
// begin if UnitsInside ( j ) < 6 then
39754: LD_VAR 0 3
39758: PPUSH
39759: CALL_OW 313
39763: PUSH
39764: LD_INT 6
39766: LESS
39767: IFFALSE 39781
// begin selected := j ;
39769: LD_ADDR_VAR 0 7
39773: PUSH
39774: LD_VAR 0 3
39778: ST_TO_ADDR
// break ;
39779: GO 39783
// end ; end ;
39781: GO 39751
39783: POP
39784: POP
// if selected then
39785: LD_VAR 0 7
39789: IFFALSE 39888
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39791: LD_ADDR_VAR 0 3
39795: PUSH
39796: LD_EXP 108
39800: PUSH
39801: LD_VAR 0 2
39805: ARRAY
39806: PPUSH
39807: LD_INT 25
39809: PUSH
39810: LD_INT 12
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PPUSH
39817: CALL_OW 72
39821: PUSH
39822: FOR_IN
39823: IFFALSE 39886
// if not HasTask ( j ) then
39825: LD_VAR 0 3
39829: PPUSH
39830: CALL_OW 314
39834: NOT
39835: IFFALSE 39884
// begin if not IsInUnit ( j ) then
39837: LD_VAR 0 3
39841: PPUSH
39842: CALL_OW 310
39846: NOT
39847: IFFALSE 39863
// ComEnterUnit ( j , selected ) ;
39849: LD_VAR 0 3
39853: PPUSH
39854: LD_VAR 0 7
39858: PPUSH
39859: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39863: LD_VAR 0 3
39867: PPUSH
39868: LD_INT 16
39870: PPUSH
39871: CALL_OW 183
// AddComExitBuilding ( j ) ;
39875: LD_VAR 0 3
39879: PPUSH
39880: CALL_OW 182
// end ;
39884: GO 39822
39886: POP
39887: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39888: LD_VAR 0 5
39892: PPUSH
39893: LD_INT 11
39895: PPUSH
39896: CALL_OW 325
39900: IFFALSE 40159
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39902: LD_ADDR_VAR 0 4
39906: PUSH
39907: LD_EXP 108
39911: PUSH
39912: LD_VAR 0 2
39916: ARRAY
39917: PPUSH
39918: LD_INT 25
39920: PUSH
39921: LD_INT 16
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PPUSH
39928: CALL_OW 72
39932: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39933: LD_VAR 0 4
39937: PUSH
39938: LD_INT 6
39940: GREATEREQUAL
39941: PUSH
39942: LD_VAR 0 5
39946: PPUSH
39947: LD_INT 2
39949: PPUSH
39950: CALL_OW 325
39954: NOT
39955: OR
39956: IFFALSE 40159
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39958: LD_ADDR_VAR 0 8
39962: PUSH
39963: LD_EXP 79
39967: PUSH
39968: LD_VAR 0 2
39972: ARRAY
39973: PPUSH
39974: LD_INT 2
39976: PUSH
39977: LD_INT 30
39979: PUSH
39980: LD_INT 4
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 30
39989: PUSH
39990: LD_INT 5
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: LIST
40001: PPUSH
40002: CALL_OW 72
40006: ST_TO_ADDR
// if barracks then
40007: LD_VAR 0 8
40011: IFFALSE 40159
// begin selected := 0 ;
40013: LD_ADDR_VAR 0 7
40017: PUSH
40018: LD_INT 0
40020: ST_TO_ADDR
// for j in barracks do
40021: LD_ADDR_VAR 0 3
40025: PUSH
40026: LD_VAR 0 8
40030: PUSH
40031: FOR_IN
40032: IFFALSE 40063
// begin if UnitsInside ( j ) < 6 then
40034: LD_VAR 0 3
40038: PPUSH
40039: CALL_OW 313
40043: PUSH
40044: LD_INT 6
40046: LESS
40047: IFFALSE 40061
// begin selected := j ;
40049: LD_ADDR_VAR 0 7
40053: PUSH
40054: LD_VAR 0 3
40058: ST_TO_ADDR
// break ;
40059: GO 40063
// end ; end ;
40061: GO 40031
40063: POP
40064: POP
// if selected then
40065: LD_VAR 0 7
40069: IFFALSE 40159
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40071: LD_ADDR_VAR 0 3
40075: PUSH
40076: LD_EXP 108
40080: PUSH
40081: LD_VAR 0 2
40085: ARRAY
40086: PPUSH
40087: LD_INT 25
40089: PUSH
40090: LD_INT 12
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PPUSH
40097: CALL_OW 72
40101: PUSH
40102: FOR_IN
40103: IFFALSE 40157
// if not IsInUnit ( j ) and not HasTask ( j ) then
40105: LD_VAR 0 3
40109: PPUSH
40110: CALL_OW 310
40114: NOT
40115: PUSH
40116: LD_VAR 0 3
40120: PPUSH
40121: CALL_OW 314
40125: NOT
40126: AND
40127: IFFALSE 40155
// begin ComEnterUnit ( j , selected ) ;
40129: LD_VAR 0 3
40133: PPUSH
40134: LD_VAR 0 7
40138: PPUSH
40139: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40143: LD_VAR 0 3
40147: PPUSH
40148: LD_INT 15
40150: PPUSH
40151: CALL_OW 183
// end ;
40155: GO 40102
40157: POP
40158: POP
// end ; end ; end ; end ; end ;
40159: GO 39552
40161: POP
40162: POP
// end ;
40163: LD_VAR 0 1
40167: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40168: LD_INT 0
40170: PPUSH
40171: PPUSH
40172: PPUSH
40173: PPUSH
// if not mc_bases then
40174: LD_EXP 79
40178: NOT
40179: IFFALSE 40183
// exit ;
40181: GO 40361
// for i = 1 to mc_bases do
40183: LD_ADDR_VAR 0 2
40187: PUSH
40188: DOUBLE
40189: LD_INT 1
40191: DEC
40192: ST_TO_ADDR
40193: LD_EXP 79
40197: PUSH
40198: FOR_TO
40199: IFFALSE 40359
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40201: LD_ADDR_VAR 0 4
40205: PUSH
40206: LD_EXP 79
40210: PUSH
40211: LD_VAR 0 2
40215: ARRAY
40216: PPUSH
40217: LD_INT 25
40219: PUSH
40220: LD_INT 9
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PPUSH
40227: CALL_OW 72
40231: ST_TO_ADDR
// if not tmp then
40232: LD_VAR 0 4
40236: NOT
40237: IFFALSE 40241
// continue ;
40239: GO 40198
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40241: LD_EXP 105
40245: PUSH
40246: LD_VAR 0 2
40250: ARRAY
40251: PPUSH
40252: LD_INT 29
40254: PPUSH
40255: CALL_OW 325
40259: NOT
40260: PUSH
40261: LD_EXP 105
40265: PUSH
40266: LD_VAR 0 2
40270: ARRAY
40271: PPUSH
40272: LD_INT 28
40274: PPUSH
40275: CALL_OW 325
40279: NOT
40280: AND
40281: IFFALSE 40285
// continue ;
40283: GO 40198
// for j in tmp do
40285: LD_ADDR_VAR 0 3
40289: PUSH
40290: LD_VAR 0 4
40294: PUSH
40295: FOR_IN
40296: IFFALSE 40355
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40298: LD_VAR 0 3
40302: PUSH
40303: LD_EXP 82
40307: PUSH
40308: LD_VAR 0 2
40312: ARRAY
40313: PUSH
40314: LD_INT 1
40316: ARRAY
40317: IN
40318: NOT
40319: PUSH
40320: LD_VAR 0 3
40324: PUSH
40325: LD_EXP 82
40329: PUSH
40330: LD_VAR 0 2
40334: ARRAY
40335: PUSH
40336: LD_INT 2
40338: ARRAY
40339: IN
40340: NOT
40341: AND
40342: IFFALSE 40353
// ComSpaceTimeShoot ( j ) ;
40344: LD_VAR 0 3
40348: PPUSH
40349: CALL 51379 0 1
40353: GO 40295
40355: POP
40356: POP
// end ;
40357: GO 40198
40359: POP
40360: POP
// end ;
40361: LD_VAR 0 1
40365: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40366: LD_INT 0
40368: PPUSH
40369: PPUSH
40370: PPUSH
40371: PPUSH
40372: PPUSH
40373: PPUSH
40374: PPUSH
40375: PPUSH
40376: PPUSH
// if not mc_bases then
40377: LD_EXP 79
40381: NOT
40382: IFFALSE 40386
// exit ;
40384: GO 41008
// for i = 1 to mc_bases do
40386: LD_ADDR_VAR 0 2
40390: PUSH
40391: DOUBLE
40392: LD_INT 1
40394: DEC
40395: ST_TO_ADDR
40396: LD_EXP 79
40400: PUSH
40401: FOR_TO
40402: IFFALSE 41006
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40404: LD_EXP 114
40408: PUSH
40409: LD_VAR 0 2
40413: ARRAY
40414: NOT
40415: PUSH
40416: LD_INT 38
40418: PPUSH
40419: LD_EXP 105
40423: PUSH
40424: LD_VAR 0 2
40428: ARRAY
40429: PPUSH
40430: CALL_OW 321
40434: PUSH
40435: LD_INT 2
40437: NONEQUAL
40438: OR
40439: IFFALSE 40443
// continue ;
40441: GO 40401
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40443: LD_ADDR_VAR 0 8
40447: PUSH
40448: LD_EXP 79
40452: PUSH
40453: LD_VAR 0 2
40457: ARRAY
40458: PPUSH
40459: LD_INT 30
40461: PUSH
40462: LD_INT 34
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PPUSH
40469: CALL_OW 72
40473: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40474: LD_ADDR_VAR 0 9
40478: PUSH
40479: LD_EXP 79
40483: PUSH
40484: LD_VAR 0 2
40488: ARRAY
40489: PPUSH
40490: LD_INT 25
40492: PUSH
40493: LD_INT 4
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PPUSH
40500: CALL_OW 72
40504: PPUSH
40505: LD_INT 0
40507: PPUSH
40508: CALL 91063 0 2
40512: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40513: LD_VAR 0 9
40517: NOT
40518: PUSH
40519: LD_VAR 0 8
40523: NOT
40524: OR
40525: PUSH
40526: LD_EXP 79
40530: PUSH
40531: LD_VAR 0 2
40535: ARRAY
40536: PPUSH
40537: LD_INT 124
40539: PPUSH
40540: CALL 91063 0 2
40544: OR
40545: IFFALSE 40549
// continue ;
40547: GO 40401
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40549: LD_EXP 115
40553: PUSH
40554: LD_VAR 0 2
40558: ARRAY
40559: PUSH
40560: LD_EXP 114
40564: PUSH
40565: LD_VAR 0 2
40569: ARRAY
40570: LESS
40571: PUSH
40572: LD_EXP 115
40576: PUSH
40577: LD_VAR 0 2
40581: ARRAY
40582: PUSH
40583: LD_VAR 0 8
40587: LESS
40588: AND
40589: IFFALSE 41004
// begin tmp := sci [ 1 ] ;
40591: LD_ADDR_VAR 0 7
40595: PUSH
40596: LD_VAR 0 9
40600: PUSH
40601: LD_INT 1
40603: ARRAY
40604: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40605: LD_VAR 0 7
40609: PPUSH
40610: LD_INT 124
40612: PPUSH
40613: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40617: LD_ADDR_VAR 0 3
40621: PUSH
40622: DOUBLE
40623: LD_EXP 114
40627: PUSH
40628: LD_VAR 0 2
40632: ARRAY
40633: INC
40634: ST_TO_ADDR
40635: LD_EXP 114
40639: PUSH
40640: LD_VAR 0 2
40644: ARRAY
40645: PUSH
40646: FOR_DOWNTO
40647: IFFALSE 40990
// begin if IsInUnit ( tmp ) then
40649: LD_VAR 0 7
40653: PPUSH
40654: CALL_OW 310
40658: IFFALSE 40669
// ComExitBuilding ( tmp ) ;
40660: LD_VAR 0 7
40664: PPUSH
40665: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40669: LD_INT 35
40671: PPUSH
40672: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40676: LD_VAR 0 7
40680: PPUSH
40681: CALL_OW 310
40685: NOT
40686: PUSH
40687: LD_VAR 0 7
40691: PPUSH
40692: CALL_OW 314
40696: NOT
40697: AND
40698: IFFALSE 40669
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40700: LD_ADDR_VAR 0 6
40704: PUSH
40705: LD_VAR 0 7
40709: PPUSH
40710: CALL_OW 250
40714: PUSH
40715: LD_VAR 0 7
40719: PPUSH
40720: CALL_OW 251
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40729: LD_INT 35
40731: PPUSH
40732: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40736: LD_ADDR_VAR 0 4
40740: PUSH
40741: LD_EXP 114
40745: PUSH
40746: LD_VAR 0 2
40750: ARRAY
40751: PUSH
40752: LD_VAR 0 3
40756: ARRAY
40757: PUSH
40758: LD_INT 1
40760: ARRAY
40761: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40762: LD_ADDR_VAR 0 5
40766: PUSH
40767: LD_EXP 114
40771: PUSH
40772: LD_VAR 0 2
40776: ARRAY
40777: PUSH
40778: LD_VAR 0 3
40782: ARRAY
40783: PUSH
40784: LD_INT 2
40786: ARRAY
40787: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40788: LD_VAR 0 7
40792: PPUSH
40793: LD_INT 10
40795: PPUSH
40796: CALL 60386 0 2
40800: PUSH
40801: LD_INT 4
40803: ARRAY
40804: IFFALSE 40842
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40806: LD_VAR 0 7
40810: PPUSH
40811: LD_VAR 0 6
40815: PUSH
40816: LD_INT 1
40818: ARRAY
40819: PPUSH
40820: LD_VAR 0 6
40824: PUSH
40825: LD_INT 2
40827: ARRAY
40828: PPUSH
40829: CALL_OW 111
// wait ( 0 0$10 ) ;
40833: LD_INT 350
40835: PPUSH
40836: CALL_OW 67
// end else
40840: GO 40868
// begin ComMoveXY ( tmp , x , y ) ;
40842: LD_VAR 0 7
40846: PPUSH
40847: LD_VAR 0 4
40851: PPUSH
40852: LD_VAR 0 5
40856: PPUSH
40857: CALL_OW 111
// wait ( 0 0$3 ) ;
40861: LD_INT 105
40863: PPUSH
40864: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40868: LD_VAR 0 7
40872: PPUSH
40873: LD_VAR 0 4
40877: PPUSH
40878: LD_VAR 0 5
40882: PPUSH
40883: CALL_OW 307
40887: IFFALSE 40729
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40889: LD_VAR 0 7
40893: PPUSH
40894: LD_VAR 0 4
40898: PPUSH
40899: LD_VAR 0 5
40903: PPUSH
40904: LD_VAR 0 8
40908: PUSH
40909: LD_VAR 0 3
40913: ARRAY
40914: PPUSH
40915: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40919: LD_INT 35
40921: PPUSH
40922: CALL_OW 67
// until not HasTask ( tmp ) ;
40926: LD_VAR 0 7
40930: PPUSH
40931: CALL_OW 314
40935: NOT
40936: IFFALSE 40919
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40938: LD_ADDR_EXP 115
40942: PUSH
40943: LD_EXP 115
40947: PPUSH
40948: LD_VAR 0 2
40952: PUSH
40953: LD_EXP 115
40957: PUSH
40958: LD_VAR 0 2
40962: ARRAY
40963: PUSH
40964: LD_INT 1
40966: PLUS
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: LD_VAR 0 8
40976: PUSH
40977: LD_VAR 0 3
40981: ARRAY
40982: PPUSH
40983: CALL 57793 0 3
40987: ST_TO_ADDR
// end ;
40988: GO 40646
40990: POP
40991: POP
// MC_Reset ( i , 124 ) ;
40992: LD_VAR 0 2
40996: PPUSH
40997: LD_INT 124
40999: PPUSH
41000: CALL 24595 0 2
// end ; end ;
41004: GO 40401
41006: POP
41007: POP
// end ;
41008: LD_VAR 0 1
41012: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41013: LD_INT 0
41015: PPUSH
41016: PPUSH
41017: PPUSH
// if not mc_bases then
41018: LD_EXP 79
41022: NOT
41023: IFFALSE 41027
// exit ;
41025: GO 41633
// for i = 1 to mc_bases do
41027: LD_ADDR_VAR 0 2
41031: PUSH
41032: DOUBLE
41033: LD_INT 1
41035: DEC
41036: ST_TO_ADDR
41037: LD_EXP 79
41041: PUSH
41042: FOR_TO
41043: IFFALSE 41631
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41045: LD_ADDR_VAR 0 3
41049: PUSH
41050: LD_EXP 79
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PPUSH
41061: LD_INT 25
41063: PUSH
41064: LD_INT 4
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PPUSH
41071: CALL_OW 72
41075: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41076: LD_VAR 0 3
41080: NOT
41081: PUSH
41082: LD_EXP 116
41086: PUSH
41087: LD_VAR 0 2
41091: ARRAY
41092: NOT
41093: OR
41094: PUSH
41095: LD_EXP 79
41099: PUSH
41100: LD_VAR 0 2
41104: ARRAY
41105: PPUSH
41106: LD_INT 2
41108: PUSH
41109: LD_INT 30
41111: PUSH
41112: LD_INT 0
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 30
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: LIST
41133: PPUSH
41134: CALL_OW 72
41138: NOT
41139: OR
41140: IFFALSE 41190
// begin if mc_deposits_finder [ i ] then
41142: LD_EXP 117
41146: PUSH
41147: LD_VAR 0 2
41151: ARRAY
41152: IFFALSE 41188
// begin MC_Reset ( i , 125 ) ;
41154: LD_VAR 0 2
41158: PPUSH
41159: LD_INT 125
41161: PPUSH
41162: CALL 24595 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41166: LD_ADDR_EXP 117
41170: PUSH
41171: LD_EXP 117
41175: PPUSH
41176: LD_VAR 0 2
41180: PPUSH
41181: EMPTY
41182: PPUSH
41183: CALL_OW 1
41187: ST_TO_ADDR
// end ; continue ;
41188: GO 41042
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41190: LD_EXP 116
41194: PUSH
41195: LD_VAR 0 2
41199: ARRAY
41200: PUSH
41201: LD_INT 1
41203: ARRAY
41204: PUSH
41205: LD_INT 3
41207: ARRAY
41208: PUSH
41209: LD_INT 1
41211: EQUAL
41212: PUSH
41213: LD_INT 20
41215: PPUSH
41216: LD_EXP 105
41220: PUSH
41221: LD_VAR 0 2
41225: ARRAY
41226: PPUSH
41227: CALL_OW 321
41231: PUSH
41232: LD_INT 2
41234: NONEQUAL
41235: AND
41236: IFFALSE 41286
// begin if mc_deposits_finder [ i ] then
41238: LD_EXP 117
41242: PUSH
41243: LD_VAR 0 2
41247: ARRAY
41248: IFFALSE 41284
// begin MC_Reset ( i , 125 ) ;
41250: LD_VAR 0 2
41254: PPUSH
41255: LD_INT 125
41257: PPUSH
41258: CALL 24595 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41262: LD_ADDR_EXP 117
41266: PUSH
41267: LD_EXP 117
41271: PPUSH
41272: LD_VAR 0 2
41276: PPUSH
41277: EMPTY
41278: PPUSH
41279: CALL_OW 1
41283: ST_TO_ADDR
// end ; continue ;
41284: GO 41042
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41286: LD_EXP 116
41290: PUSH
41291: LD_VAR 0 2
41295: ARRAY
41296: PUSH
41297: LD_INT 1
41299: ARRAY
41300: PUSH
41301: LD_INT 1
41303: ARRAY
41304: PPUSH
41305: LD_EXP 116
41309: PUSH
41310: LD_VAR 0 2
41314: ARRAY
41315: PUSH
41316: LD_INT 1
41318: ARRAY
41319: PUSH
41320: LD_INT 2
41322: ARRAY
41323: PPUSH
41324: LD_EXP 105
41328: PUSH
41329: LD_VAR 0 2
41333: ARRAY
41334: PPUSH
41335: CALL_OW 440
41339: IFFALSE 41382
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41341: LD_ADDR_EXP 116
41345: PUSH
41346: LD_EXP 116
41350: PPUSH
41351: LD_VAR 0 2
41355: PPUSH
41356: LD_EXP 116
41360: PUSH
41361: LD_VAR 0 2
41365: ARRAY
41366: PPUSH
41367: LD_INT 1
41369: PPUSH
41370: CALL_OW 3
41374: PPUSH
41375: CALL_OW 1
41379: ST_TO_ADDR
41380: GO 41629
// begin if not mc_deposits_finder [ i ] then
41382: LD_EXP 117
41386: PUSH
41387: LD_VAR 0 2
41391: ARRAY
41392: NOT
41393: IFFALSE 41445
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41395: LD_ADDR_EXP 117
41399: PUSH
41400: LD_EXP 117
41404: PPUSH
41405: LD_VAR 0 2
41409: PPUSH
41410: LD_VAR 0 3
41414: PUSH
41415: LD_INT 1
41417: ARRAY
41418: PUSH
41419: EMPTY
41420: LIST
41421: PPUSH
41422: CALL_OW 1
41426: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41427: LD_VAR 0 3
41431: PUSH
41432: LD_INT 1
41434: ARRAY
41435: PPUSH
41436: LD_INT 125
41438: PPUSH
41439: CALL_OW 109
// end else
41443: GO 41629
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41445: LD_EXP 117
41449: PUSH
41450: LD_VAR 0 2
41454: ARRAY
41455: PUSH
41456: LD_INT 1
41458: ARRAY
41459: PPUSH
41460: CALL_OW 310
41464: IFFALSE 41487
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41466: LD_EXP 117
41470: PUSH
41471: LD_VAR 0 2
41475: ARRAY
41476: PUSH
41477: LD_INT 1
41479: ARRAY
41480: PPUSH
41481: CALL_OW 122
41485: GO 41629
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41487: LD_EXP 117
41491: PUSH
41492: LD_VAR 0 2
41496: ARRAY
41497: PUSH
41498: LD_INT 1
41500: ARRAY
41501: PPUSH
41502: CALL_OW 314
41506: NOT
41507: PUSH
41508: LD_EXP 117
41512: PUSH
41513: LD_VAR 0 2
41517: ARRAY
41518: PUSH
41519: LD_INT 1
41521: ARRAY
41522: PPUSH
41523: LD_EXP 116
41527: PUSH
41528: LD_VAR 0 2
41532: ARRAY
41533: PUSH
41534: LD_INT 1
41536: ARRAY
41537: PUSH
41538: LD_INT 1
41540: ARRAY
41541: PPUSH
41542: LD_EXP 116
41546: PUSH
41547: LD_VAR 0 2
41551: ARRAY
41552: PUSH
41553: LD_INT 1
41555: ARRAY
41556: PUSH
41557: LD_INT 2
41559: ARRAY
41560: PPUSH
41561: CALL_OW 297
41565: PUSH
41566: LD_INT 6
41568: GREATER
41569: AND
41570: IFFALSE 41629
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41572: LD_EXP 117
41576: PUSH
41577: LD_VAR 0 2
41581: ARRAY
41582: PUSH
41583: LD_INT 1
41585: ARRAY
41586: PPUSH
41587: LD_EXP 116
41591: PUSH
41592: LD_VAR 0 2
41596: ARRAY
41597: PUSH
41598: LD_INT 1
41600: ARRAY
41601: PUSH
41602: LD_INT 1
41604: ARRAY
41605: PPUSH
41606: LD_EXP 116
41610: PUSH
41611: LD_VAR 0 2
41615: ARRAY
41616: PUSH
41617: LD_INT 1
41619: ARRAY
41620: PUSH
41621: LD_INT 2
41623: ARRAY
41624: PPUSH
41625: CALL_OW 111
// end ; end ; end ;
41629: GO 41042
41631: POP
41632: POP
// end ;
41633: LD_VAR 0 1
41637: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41638: LD_INT 0
41640: PPUSH
41641: PPUSH
41642: PPUSH
41643: PPUSH
41644: PPUSH
41645: PPUSH
41646: PPUSH
41647: PPUSH
41648: PPUSH
41649: PPUSH
41650: PPUSH
// if not mc_bases then
41651: LD_EXP 79
41655: NOT
41656: IFFALSE 41660
// exit ;
41658: GO 42600
// for i = 1 to mc_bases do
41660: LD_ADDR_VAR 0 2
41664: PUSH
41665: DOUBLE
41666: LD_INT 1
41668: DEC
41669: ST_TO_ADDR
41670: LD_EXP 79
41674: PUSH
41675: FOR_TO
41676: IFFALSE 42598
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41678: LD_EXP 79
41682: PUSH
41683: LD_VAR 0 2
41687: ARRAY
41688: NOT
41689: PUSH
41690: LD_EXP 102
41694: PUSH
41695: LD_VAR 0 2
41699: ARRAY
41700: OR
41701: IFFALSE 41705
// continue ;
41703: GO 41675
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41705: LD_ADDR_VAR 0 7
41709: PUSH
41710: LD_EXP 79
41714: PUSH
41715: LD_VAR 0 2
41719: ARRAY
41720: PUSH
41721: LD_INT 1
41723: ARRAY
41724: PPUSH
41725: CALL_OW 248
41729: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41730: LD_VAR 0 7
41734: PUSH
41735: LD_INT 3
41737: EQUAL
41738: PUSH
41739: LD_EXP 98
41743: PUSH
41744: LD_VAR 0 2
41748: ARRAY
41749: PUSH
41750: LD_EXP 101
41754: PUSH
41755: LD_VAR 0 2
41759: ARRAY
41760: UNION
41761: PPUSH
41762: LD_INT 33
41764: PUSH
41765: LD_INT 2
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PPUSH
41772: CALL_OW 72
41776: NOT
41777: OR
41778: IFFALSE 41782
// continue ;
41780: GO 41675
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41782: LD_ADDR_VAR 0 9
41786: PUSH
41787: LD_EXP 79
41791: PUSH
41792: LD_VAR 0 2
41796: ARRAY
41797: PPUSH
41798: LD_INT 30
41800: PUSH
41801: LD_INT 36
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PPUSH
41808: CALL_OW 72
41812: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41813: LD_ADDR_VAR 0 10
41817: PUSH
41818: LD_EXP 98
41822: PUSH
41823: LD_VAR 0 2
41827: ARRAY
41828: PPUSH
41829: LD_INT 34
41831: PUSH
41832: LD_INT 31
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PPUSH
41839: CALL_OW 72
41843: ST_TO_ADDR
// if not cts and not mcts then
41844: LD_VAR 0 9
41848: NOT
41849: PUSH
41850: LD_VAR 0 10
41854: NOT
41855: AND
41856: IFFALSE 41860
// continue ;
41858: GO 41675
// x := cts ;
41860: LD_ADDR_VAR 0 11
41864: PUSH
41865: LD_VAR 0 9
41869: ST_TO_ADDR
// if not x then
41870: LD_VAR 0 11
41874: NOT
41875: IFFALSE 41887
// x := mcts ;
41877: LD_ADDR_VAR 0 11
41881: PUSH
41882: LD_VAR 0 10
41886: ST_TO_ADDR
// if not x then
41887: LD_VAR 0 11
41891: NOT
41892: IFFALSE 41896
// continue ;
41894: GO 41675
// if mc_remote_driver [ i ] then
41896: LD_EXP 119
41900: PUSH
41901: LD_VAR 0 2
41905: ARRAY
41906: IFFALSE 42293
// for j in mc_remote_driver [ i ] do
41908: LD_ADDR_VAR 0 3
41912: PUSH
41913: LD_EXP 119
41917: PUSH
41918: LD_VAR 0 2
41922: ARRAY
41923: PUSH
41924: FOR_IN
41925: IFFALSE 42291
// begin if GetClass ( j ) <> 3 then
41927: LD_VAR 0 3
41931: PPUSH
41932: CALL_OW 257
41936: PUSH
41937: LD_INT 3
41939: NONEQUAL
41940: IFFALSE 41993
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41942: LD_ADDR_EXP 119
41946: PUSH
41947: LD_EXP 119
41951: PPUSH
41952: LD_VAR 0 2
41956: PPUSH
41957: LD_EXP 119
41961: PUSH
41962: LD_VAR 0 2
41966: ARRAY
41967: PUSH
41968: LD_VAR 0 3
41972: DIFF
41973: PPUSH
41974: CALL_OW 1
41978: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41979: LD_VAR 0 3
41983: PPUSH
41984: LD_INT 0
41986: PPUSH
41987: CALL_OW 109
// continue ;
41991: GO 41924
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41993: LD_EXP 98
41997: PUSH
41998: LD_VAR 0 2
42002: ARRAY
42003: PPUSH
42004: LD_INT 34
42006: PUSH
42007: LD_INT 31
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 58
42016: PUSH
42017: EMPTY
42018: LIST
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PPUSH
42024: CALL_OW 72
42028: PUSH
42029: LD_VAR 0 3
42033: PPUSH
42034: CALL 91151 0 1
42038: NOT
42039: AND
42040: IFFALSE 42111
// begin if IsInUnit ( j ) then
42042: LD_VAR 0 3
42046: PPUSH
42047: CALL_OW 310
42051: IFFALSE 42062
// ComExitBuilding ( j ) ;
42053: LD_VAR 0 3
42057: PPUSH
42058: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42062: LD_VAR 0 3
42066: PPUSH
42067: LD_EXP 98
42071: PUSH
42072: LD_VAR 0 2
42076: ARRAY
42077: PPUSH
42078: LD_INT 34
42080: PUSH
42081: LD_INT 31
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 58
42090: PUSH
42091: EMPTY
42092: LIST
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PPUSH
42098: CALL_OW 72
42102: PUSH
42103: LD_INT 1
42105: ARRAY
42106: PPUSH
42107: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42111: LD_VAR 0 3
42115: PPUSH
42116: CALL_OW 310
42120: NOT
42121: PUSH
42122: LD_VAR 0 3
42126: PPUSH
42127: CALL_OW 310
42131: PPUSH
42132: CALL_OW 266
42136: PUSH
42137: LD_INT 36
42139: NONEQUAL
42140: PUSH
42141: LD_VAR 0 3
42145: PPUSH
42146: CALL 91151 0 1
42150: NOT
42151: AND
42152: OR
42153: IFFALSE 42289
// begin if IsInUnit ( j ) then
42155: LD_VAR 0 3
42159: PPUSH
42160: CALL_OW 310
42164: IFFALSE 42175
// ComExitBuilding ( j ) ;
42166: LD_VAR 0 3
42170: PPUSH
42171: CALL_OW 122
// ct := 0 ;
42175: LD_ADDR_VAR 0 8
42179: PUSH
42180: LD_INT 0
42182: ST_TO_ADDR
// for k in x do
42183: LD_ADDR_VAR 0 4
42187: PUSH
42188: LD_VAR 0 11
42192: PUSH
42193: FOR_IN
42194: IFFALSE 42267
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42196: LD_VAR 0 4
42200: PPUSH
42201: CALL_OW 264
42205: PUSH
42206: LD_INT 31
42208: EQUAL
42209: PUSH
42210: LD_VAR 0 4
42214: PPUSH
42215: CALL_OW 311
42219: NOT
42220: AND
42221: PUSH
42222: LD_VAR 0 4
42226: PPUSH
42227: CALL_OW 266
42231: PUSH
42232: LD_INT 36
42234: EQUAL
42235: PUSH
42236: LD_VAR 0 4
42240: PPUSH
42241: CALL_OW 313
42245: PUSH
42246: LD_INT 3
42248: LESS
42249: AND
42250: OR
42251: IFFALSE 42265
// begin ct := k ;
42253: LD_ADDR_VAR 0 8
42257: PUSH
42258: LD_VAR 0 4
42262: ST_TO_ADDR
// break ;
42263: GO 42267
// end ;
42265: GO 42193
42267: POP
42268: POP
// if ct then
42269: LD_VAR 0 8
42273: IFFALSE 42289
// ComEnterUnit ( j , ct ) ;
42275: LD_VAR 0 3
42279: PPUSH
42280: LD_VAR 0 8
42284: PPUSH
42285: CALL_OW 120
// end ; end ;
42289: GO 41924
42291: POP
42292: POP
// places := 0 ;
42293: LD_ADDR_VAR 0 5
42297: PUSH
42298: LD_INT 0
42300: ST_TO_ADDR
// for j = 1 to x do
42301: LD_ADDR_VAR 0 3
42305: PUSH
42306: DOUBLE
42307: LD_INT 1
42309: DEC
42310: ST_TO_ADDR
42311: LD_VAR 0 11
42315: PUSH
42316: FOR_TO
42317: IFFALSE 42393
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42319: LD_VAR 0 11
42323: PUSH
42324: LD_VAR 0 3
42328: ARRAY
42329: PPUSH
42330: CALL_OW 264
42334: PUSH
42335: LD_INT 31
42337: EQUAL
42338: IFFALSE 42356
// places := places + 1 else
42340: LD_ADDR_VAR 0 5
42344: PUSH
42345: LD_VAR 0 5
42349: PUSH
42350: LD_INT 1
42352: PLUS
42353: ST_TO_ADDR
42354: GO 42391
// if GetBType ( x [ j ] ) = b_control_tower then
42356: LD_VAR 0 11
42360: PUSH
42361: LD_VAR 0 3
42365: ARRAY
42366: PPUSH
42367: CALL_OW 266
42371: PUSH
42372: LD_INT 36
42374: EQUAL
42375: IFFALSE 42391
// places := places + 3 ;
42377: LD_ADDR_VAR 0 5
42381: PUSH
42382: LD_VAR 0 5
42386: PUSH
42387: LD_INT 3
42389: PLUS
42390: ST_TO_ADDR
42391: GO 42316
42393: POP
42394: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42395: LD_VAR 0 5
42399: PUSH
42400: LD_INT 0
42402: EQUAL
42403: PUSH
42404: LD_VAR 0 5
42408: PUSH
42409: LD_EXP 119
42413: PUSH
42414: LD_VAR 0 2
42418: ARRAY
42419: LESSEQUAL
42420: OR
42421: IFFALSE 42425
// continue ;
42423: GO 41675
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42425: LD_ADDR_VAR 0 6
42429: PUSH
42430: LD_EXP 79
42434: PUSH
42435: LD_VAR 0 2
42439: ARRAY
42440: PPUSH
42441: LD_INT 25
42443: PUSH
42444: LD_INT 3
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PPUSH
42451: CALL_OW 72
42455: PUSH
42456: LD_EXP 119
42460: PUSH
42461: LD_VAR 0 2
42465: ARRAY
42466: DIFF
42467: PPUSH
42468: LD_INT 3
42470: PPUSH
42471: CALL 92051 0 2
42475: ST_TO_ADDR
// for j in tmp do
42476: LD_ADDR_VAR 0 3
42480: PUSH
42481: LD_VAR 0 6
42485: PUSH
42486: FOR_IN
42487: IFFALSE 42522
// if GetTag ( j ) > 0 then
42489: LD_VAR 0 3
42493: PPUSH
42494: CALL_OW 110
42498: PUSH
42499: LD_INT 0
42501: GREATER
42502: IFFALSE 42520
// tmp := tmp diff j ;
42504: LD_ADDR_VAR 0 6
42508: PUSH
42509: LD_VAR 0 6
42513: PUSH
42514: LD_VAR 0 3
42518: DIFF
42519: ST_TO_ADDR
42520: GO 42486
42522: POP
42523: POP
// if not tmp then
42524: LD_VAR 0 6
42528: NOT
42529: IFFALSE 42533
// continue ;
42531: GO 41675
// if places then
42533: LD_VAR 0 5
42537: IFFALSE 42596
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42539: LD_ADDR_EXP 119
42543: PUSH
42544: LD_EXP 119
42548: PPUSH
42549: LD_VAR 0 2
42553: PPUSH
42554: LD_EXP 119
42558: PUSH
42559: LD_VAR 0 2
42563: ARRAY
42564: PUSH
42565: LD_VAR 0 6
42569: PUSH
42570: LD_INT 1
42572: ARRAY
42573: UNION
42574: PPUSH
42575: CALL_OW 1
42579: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42580: LD_VAR 0 6
42584: PUSH
42585: LD_INT 1
42587: ARRAY
42588: PPUSH
42589: LD_INT 126
42591: PPUSH
42592: CALL_OW 109
// end ; end ;
42596: GO 41675
42598: POP
42599: POP
// end ;
42600: LD_VAR 0 1
42604: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42605: LD_INT 0
42607: PPUSH
42608: PPUSH
42609: PPUSH
42610: PPUSH
42611: PPUSH
42612: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42613: LD_VAR 0 1
42617: NOT
42618: PUSH
42619: LD_VAR 0 2
42623: NOT
42624: OR
42625: PUSH
42626: LD_VAR 0 3
42630: NOT
42631: OR
42632: PUSH
42633: LD_VAR 0 4
42637: PUSH
42638: LD_INT 1
42640: PUSH
42641: LD_INT 2
42643: PUSH
42644: LD_INT 3
42646: PUSH
42647: LD_INT 4
42649: PUSH
42650: LD_INT 5
42652: PUSH
42653: LD_INT 8
42655: PUSH
42656: LD_INT 9
42658: PUSH
42659: LD_INT 15
42661: PUSH
42662: LD_INT 16
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: LIST
42673: LIST
42674: LIST
42675: IN
42676: NOT
42677: OR
42678: IFFALSE 42682
// exit ;
42680: GO 43582
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42682: LD_ADDR_VAR 0 2
42686: PUSH
42687: LD_VAR 0 2
42691: PPUSH
42692: LD_INT 21
42694: PUSH
42695: LD_INT 3
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 24
42704: PUSH
42705: LD_INT 250
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PPUSH
42716: CALL_OW 72
42720: ST_TO_ADDR
// case class of 1 , 15 :
42721: LD_VAR 0 4
42725: PUSH
42726: LD_INT 1
42728: DOUBLE
42729: EQUAL
42730: IFTRUE 42740
42732: LD_INT 15
42734: DOUBLE
42735: EQUAL
42736: IFTRUE 42740
42738: GO 42825
42740: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42741: LD_ADDR_VAR 0 8
42745: PUSH
42746: LD_VAR 0 2
42750: PPUSH
42751: LD_INT 2
42753: PUSH
42754: LD_INT 30
42756: PUSH
42757: LD_INT 32
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 30
42766: PUSH
42767: LD_INT 31
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: LIST
42778: PPUSH
42779: CALL_OW 72
42783: PUSH
42784: LD_VAR 0 2
42788: PPUSH
42789: LD_INT 2
42791: PUSH
42792: LD_INT 30
42794: PUSH
42795: LD_INT 4
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 30
42804: PUSH
42805: LD_INT 5
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: LIST
42816: PPUSH
42817: CALL_OW 72
42821: ADD
42822: ST_TO_ADDR
42823: GO 43071
42825: LD_INT 2
42827: DOUBLE
42828: EQUAL
42829: IFTRUE 42839
42831: LD_INT 16
42833: DOUBLE
42834: EQUAL
42835: IFTRUE 42839
42837: GO 42885
42839: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42840: LD_ADDR_VAR 0 8
42844: PUSH
42845: LD_VAR 0 2
42849: PPUSH
42850: LD_INT 2
42852: PUSH
42853: LD_INT 30
42855: PUSH
42856: LD_INT 0
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: LD_INT 30
42865: PUSH
42866: LD_INT 1
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: LIST
42877: PPUSH
42878: CALL_OW 72
42882: ST_TO_ADDR
42883: GO 43071
42885: LD_INT 3
42887: DOUBLE
42888: EQUAL
42889: IFTRUE 42893
42891: GO 42939
42893: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42894: LD_ADDR_VAR 0 8
42898: PUSH
42899: LD_VAR 0 2
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 2
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 3
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: LIST
42931: PPUSH
42932: CALL_OW 72
42936: ST_TO_ADDR
42937: GO 43071
42939: LD_INT 4
42941: DOUBLE
42942: EQUAL
42943: IFTRUE 42947
42945: GO 43004
42947: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42948: LD_ADDR_VAR 0 8
42952: PUSH
42953: LD_VAR 0 2
42957: PPUSH
42958: LD_INT 2
42960: PUSH
42961: LD_INT 30
42963: PUSH
42964: LD_INT 6
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 30
42973: PUSH
42974: LD_INT 7
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 30
42983: PUSH
42984: LD_INT 8
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: PPUSH
42997: CALL_OW 72
43001: ST_TO_ADDR
43002: GO 43071
43004: LD_INT 5
43006: DOUBLE
43007: EQUAL
43008: IFTRUE 43024
43010: LD_INT 8
43012: DOUBLE
43013: EQUAL
43014: IFTRUE 43024
43016: LD_INT 9
43018: DOUBLE
43019: EQUAL
43020: IFTRUE 43024
43022: GO 43070
43024: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43025: LD_ADDR_VAR 0 8
43029: PUSH
43030: LD_VAR 0 2
43034: PPUSH
43035: LD_INT 2
43037: PUSH
43038: LD_INT 30
43040: PUSH
43041: LD_INT 4
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 30
43050: PUSH
43051: LD_INT 5
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: LIST
43062: PPUSH
43063: CALL_OW 72
43067: ST_TO_ADDR
43068: GO 43071
43070: POP
// if not tmp then
43071: LD_VAR 0 8
43075: NOT
43076: IFFALSE 43080
// exit ;
43078: GO 43582
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43080: LD_VAR 0 4
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: LD_INT 15
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: IN
43095: PUSH
43096: LD_EXP 88
43100: PUSH
43101: LD_VAR 0 1
43105: ARRAY
43106: AND
43107: IFFALSE 43263
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43109: LD_ADDR_VAR 0 9
43113: PUSH
43114: LD_EXP 88
43118: PUSH
43119: LD_VAR 0 1
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43129: LD_VAR 0 9
43133: PUSH
43134: LD_EXP 89
43138: PUSH
43139: LD_VAR 0 1
43143: ARRAY
43144: IN
43145: NOT
43146: IFFALSE 43261
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43148: LD_ADDR_EXP 89
43152: PUSH
43153: LD_EXP 89
43157: PPUSH
43158: LD_VAR 0 1
43162: PUSH
43163: LD_EXP 89
43167: PUSH
43168: LD_VAR 0 1
43172: ARRAY
43173: PUSH
43174: LD_INT 1
43176: PLUS
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PPUSH
43182: LD_VAR 0 9
43186: PPUSH
43187: CALL 57793 0 3
43191: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43192: LD_ADDR_EXP 88
43196: PUSH
43197: LD_EXP 88
43201: PPUSH
43202: LD_VAR 0 1
43206: PPUSH
43207: LD_EXP 88
43211: PUSH
43212: LD_VAR 0 1
43216: ARRAY
43217: PUSH
43218: LD_VAR 0 9
43222: DIFF
43223: PPUSH
43224: CALL_OW 1
43228: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43229: LD_VAR 0 3
43233: PPUSH
43234: LD_EXP 89
43238: PUSH
43239: LD_VAR 0 1
43243: ARRAY
43244: PUSH
43245: LD_EXP 89
43249: PUSH
43250: LD_VAR 0 1
43254: ARRAY
43255: ARRAY
43256: PPUSH
43257: CALL_OW 120
// end ; exit ;
43261: GO 43582
// end ; if tmp > 1 then
43263: LD_VAR 0 8
43267: PUSH
43268: LD_INT 1
43270: GREATER
43271: IFFALSE 43375
// for i = 2 to tmp do
43273: LD_ADDR_VAR 0 6
43277: PUSH
43278: DOUBLE
43279: LD_INT 2
43281: DEC
43282: ST_TO_ADDR
43283: LD_VAR 0 8
43287: PUSH
43288: FOR_TO
43289: IFFALSE 43373
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43291: LD_VAR 0 8
43295: PUSH
43296: LD_VAR 0 6
43300: ARRAY
43301: PPUSH
43302: CALL_OW 461
43306: PUSH
43307: LD_INT 6
43309: EQUAL
43310: IFFALSE 43371
// begin x := tmp [ i ] ;
43312: LD_ADDR_VAR 0 9
43316: PUSH
43317: LD_VAR 0 8
43321: PUSH
43322: LD_VAR 0 6
43326: ARRAY
43327: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43328: LD_ADDR_VAR 0 8
43332: PUSH
43333: LD_VAR 0 8
43337: PPUSH
43338: LD_VAR 0 6
43342: PPUSH
43343: CALL_OW 3
43347: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43348: LD_ADDR_VAR 0 8
43352: PUSH
43353: LD_VAR 0 8
43357: PPUSH
43358: LD_INT 1
43360: PPUSH
43361: LD_VAR 0 9
43365: PPUSH
43366: CALL_OW 2
43370: ST_TO_ADDR
// end ;
43371: GO 43288
43373: POP
43374: POP
// for i in tmp do
43375: LD_ADDR_VAR 0 6
43379: PUSH
43380: LD_VAR 0 8
43384: PUSH
43385: FOR_IN
43386: IFFALSE 43455
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43388: LD_VAR 0 6
43392: PPUSH
43393: CALL_OW 313
43397: PUSH
43398: LD_INT 6
43400: LESS
43401: PUSH
43402: LD_VAR 0 6
43406: PPUSH
43407: CALL_OW 266
43411: PUSH
43412: LD_INT 31
43414: PUSH
43415: LD_INT 32
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: IN
43422: NOT
43423: AND
43424: PUSH
43425: LD_VAR 0 6
43429: PPUSH
43430: CALL_OW 313
43434: PUSH
43435: LD_INT 0
43437: EQUAL
43438: OR
43439: IFFALSE 43453
// begin j := i ;
43441: LD_ADDR_VAR 0 7
43445: PUSH
43446: LD_VAR 0 6
43450: ST_TO_ADDR
// break ;
43451: GO 43455
// end ; end ;
43453: GO 43385
43455: POP
43456: POP
// if j then
43457: LD_VAR 0 7
43461: IFFALSE 43479
// ComEnterUnit ( unit , j ) else
43463: LD_VAR 0 3
43467: PPUSH
43468: LD_VAR 0 7
43472: PPUSH
43473: CALL_OW 120
43477: GO 43582
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43479: LD_ADDR_VAR 0 10
43483: PUSH
43484: LD_VAR 0 2
43488: PPUSH
43489: LD_INT 2
43491: PUSH
43492: LD_INT 30
43494: PUSH
43495: LD_INT 0
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 30
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: LIST
43516: PPUSH
43517: CALL_OW 72
43521: ST_TO_ADDR
// if depot then
43522: LD_VAR 0 10
43526: IFFALSE 43582
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43528: LD_ADDR_VAR 0 10
43532: PUSH
43533: LD_VAR 0 10
43537: PPUSH
43538: LD_VAR 0 3
43542: PPUSH
43543: CALL_OW 74
43547: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43548: LD_VAR 0 3
43552: PPUSH
43553: LD_VAR 0 10
43557: PPUSH
43558: CALL_OW 296
43562: PUSH
43563: LD_INT 10
43565: GREATER
43566: IFFALSE 43582
// ComStandNearbyBuilding ( unit , depot ) ;
43568: LD_VAR 0 3
43572: PPUSH
43573: LD_VAR 0 10
43577: PPUSH
43578: CALL 51996 0 2
// end ; end ; end ;
43582: LD_VAR 0 5
43586: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43587: LD_INT 0
43589: PPUSH
43590: PPUSH
43591: PPUSH
43592: PPUSH
// if not mc_bases then
43593: LD_EXP 79
43597: NOT
43598: IFFALSE 43602
// exit ;
43600: GO 43841
// for i = 1 to mc_bases do
43602: LD_ADDR_VAR 0 2
43606: PUSH
43607: DOUBLE
43608: LD_INT 1
43610: DEC
43611: ST_TO_ADDR
43612: LD_EXP 79
43616: PUSH
43617: FOR_TO
43618: IFFALSE 43839
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43620: LD_ADDR_VAR 0 4
43624: PUSH
43625: LD_EXP 79
43629: PUSH
43630: LD_VAR 0 2
43634: ARRAY
43635: PPUSH
43636: LD_INT 21
43638: PUSH
43639: LD_INT 1
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PPUSH
43646: CALL_OW 72
43650: PUSH
43651: LD_EXP 108
43655: PUSH
43656: LD_VAR 0 2
43660: ARRAY
43661: UNION
43662: ST_TO_ADDR
// if not tmp then
43663: LD_VAR 0 4
43667: NOT
43668: IFFALSE 43672
// continue ;
43670: GO 43617
// for j in tmp do
43672: LD_ADDR_VAR 0 3
43676: PUSH
43677: LD_VAR 0 4
43681: PUSH
43682: FOR_IN
43683: IFFALSE 43835
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43685: LD_VAR 0 3
43689: PPUSH
43690: CALL_OW 110
43694: NOT
43695: PUSH
43696: LD_VAR 0 3
43700: PPUSH
43701: CALL_OW 314
43705: NOT
43706: AND
43707: PUSH
43708: LD_VAR 0 3
43712: PPUSH
43713: CALL_OW 311
43717: NOT
43718: AND
43719: PUSH
43720: LD_VAR 0 3
43724: PPUSH
43725: CALL_OW 310
43729: NOT
43730: AND
43731: PUSH
43732: LD_VAR 0 3
43736: PUSH
43737: LD_EXP 82
43741: PUSH
43742: LD_VAR 0 2
43746: ARRAY
43747: PUSH
43748: LD_INT 1
43750: ARRAY
43751: IN
43752: NOT
43753: AND
43754: PUSH
43755: LD_VAR 0 3
43759: PUSH
43760: LD_EXP 82
43764: PUSH
43765: LD_VAR 0 2
43769: ARRAY
43770: PUSH
43771: LD_INT 2
43773: ARRAY
43774: IN
43775: NOT
43776: AND
43777: PUSH
43778: LD_VAR 0 3
43782: PUSH
43783: LD_EXP 91
43787: PUSH
43788: LD_VAR 0 2
43792: ARRAY
43793: IN
43794: NOT
43795: AND
43796: IFFALSE 43833
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43798: LD_VAR 0 2
43802: PPUSH
43803: LD_EXP 79
43807: PUSH
43808: LD_VAR 0 2
43812: ARRAY
43813: PPUSH
43814: LD_VAR 0 3
43818: PPUSH
43819: LD_VAR 0 3
43823: PPUSH
43824: CALL_OW 257
43828: PPUSH
43829: CALL 42605 0 4
// end ;
43833: GO 43682
43835: POP
43836: POP
// end ;
43837: GO 43617
43839: POP
43840: POP
// end ;
43841: LD_VAR 0 1
43845: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43846: LD_INT 0
43848: PPUSH
43849: PPUSH
43850: PPUSH
43851: PPUSH
43852: PPUSH
43853: PPUSH
// if not mc_bases [ base ] then
43854: LD_EXP 79
43858: PUSH
43859: LD_VAR 0 1
43863: ARRAY
43864: NOT
43865: IFFALSE 43869
// exit ;
43867: GO 44051
// tmp := [ ] ;
43869: LD_ADDR_VAR 0 6
43873: PUSH
43874: EMPTY
43875: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43876: LD_ADDR_VAR 0 7
43880: PUSH
43881: LD_VAR 0 3
43885: PPUSH
43886: LD_INT 0
43888: PPUSH
43889: CALL_OW 517
43893: ST_TO_ADDR
// if not list then
43894: LD_VAR 0 7
43898: NOT
43899: IFFALSE 43903
// exit ;
43901: GO 44051
// for i = 1 to amount do
43903: LD_ADDR_VAR 0 5
43907: PUSH
43908: DOUBLE
43909: LD_INT 1
43911: DEC
43912: ST_TO_ADDR
43913: LD_VAR 0 2
43917: PUSH
43918: FOR_TO
43919: IFFALSE 43999
// begin x := rand ( 1 , list [ 1 ] ) ;
43921: LD_ADDR_VAR 0 8
43925: PUSH
43926: LD_INT 1
43928: PPUSH
43929: LD_VAR 0 7
43933: PUSH
43934: LD_INT 1
43936: ARRAY
43937: PPUSH
43938: CALL_OW 12
43942: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43943: LD_ADDR_VAR 0 6
43947: PUSH
43948: LD_VAR 0 6
43952: PPUSH
43953: LD_VAR 0 5
43957: PPUSH
43958: LD_VAR 0 7
43962: PUSH
43963: LD_INT 1
43965: ARRAY
43966: PUSH
43967: LD_VAR 0 8
43971: ARRAY
43972: PUSH
43973: LD_VAR 0 7
43977: PUSH
43978: LD_INT 2
43980: ARRAY
43981: PUSH
43982: LD_VAR 0 8
43986: ARRAY
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PPUSH
43992: CALL_OW 1
43996: ST_TO_ADDR
// end ;
43997: GO 43918
43999: POP
44000: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44001: LD_ADDR_EXP 92
44005: PUSH
44006: LD_EXP 92
44010: PPUSH
44011: LD_VAR 0 1
44015: PPUSH
44016: LD_VAR 0 6
44020: PPUSH
44021: CALL_OW 1
44025: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44026: LD_ADDR_EXP 94
44030: PUSH
44031: LD_EXP 94
44035: PPUSH
44036: LD_VAR 0 1
44040: PPUSH
44041: LD_VAR 0 3
44045: PPUSH
44046: CALL_OW 1
44050: ST_TO_ADDR
// end ;
44051: LD_VAR 0 4
44055: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44056: LD_INT 0
44058: PPUSH
// if not mc_bases [ base ] then
44059: LD_EXP 79
44063: PUSH
44064: LD_VAR 0 1
44068: ARRAY
44069: NOT
44070: IFFALSE 44074
// exit ;
44072: GO 44099
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44074: LD_ADDR_EXP 84
44078: PUSH
44079: LD_EXP 84
44083: PPUSH
44084: LD_VAR 0 1
44088: PPUSH
44089: LD_VAR 0 2
44093: PPUSH
44094: CALL_OW 1
44098: ST_TO_ADDR
// end ;
44099: LD_VAR 0 3
44103: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44104: LD_INT 0
44106: PPUSH
// if not mc_bases [ base ] then
44107: LD_EXP 79
44111: PUSH
44112: LD_VAR 0 1
44116: ARRAY
44117: NOT
44118: IFFALSE 44122
// exit ;
44120: GO 44159
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44122: LD_ADDR_EXP 84
44126: PUSH
44127: LD_EXP 84
44131: PPUSH
44132: LD_VAR 0 1
44136: PPUSH
44137: LD_EXP 84
44141: PUSH
44142: LD_VAR 0 1
44146: ARRAY
44147: PUSH
44148: LD_VAR 0 2
44152: UNION
44153: PPUSH
44154: CALL_OW 1
44158: ST_TO_ADDR
// end ;
44159: LD_VAR 0 3
44163: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44164: LD_INT 0
44166: PPUSH
// if not mc_bases [ base ] then
44167: LD_EXP 79
44171: PUSH
44172: LD_VAR 0 1
44176: ARRAY
44177: NOT
44178: IFFALSE 44182
// exit ;
44180: GO 44207
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44182: LD_ADDR_EXP 100
44186: PUSH
44187: LD_EXP 100
44191: PPUSH
44192: LD_VAR 0 1
44196: PPUSH
44197: LD_VAR 0 2
44201: PPUSH
44202: CALL_OW 1
44206: ST_TO_ADDR
// end ;
44207: LD_VAR 0 3
44211: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44212: LD_INT 0
44214: PPUSH
// if not mc_bases [ base ] then
44215: LD_EXP 79
44219: PUSH
44220: LD_VAR 0 1
44224: ARRAY
44225: NOT
44226: IFFALSE 44230
// exit ;
44228: GO 44267
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44230: LD_ADDR_EXP 100
44234: PUSH
44235: LD_EXP 100
44239: PPUSH
44240: LD_VAR 0 1
44244: PPUSH
44245: LD_EXP 100
44249: PUSH
44250: LD_VAR 0 1
44254: ARRAY
44255: PUSH
44256: LD_VAR 0 2
44260: ADD
44261: PPUSH
44262: CALL_OW 1
44266: ST_TO_ADDR
// end ;
44267: LD_VAR 0 3
44271: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44272: LD_INT 0
44274: PPUSH
// if not mc_bases [ base ] then
44275: LD_EXP 79
44279: PUSH
44280: LD_VAR 0 1
44284: ARRAY
44285: NOT
44286: IFFALSE 44290
// exit ;
44288: GO 44344
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44290: LD_ADDR_EXP 101
44294: PUSH
44295: LD_EXP 101
44299: PPUSH
44300: LD_VAR 0 1
44304: PPUSH
44305: LD_VAR 0 2
44309: PPUSH
44310: CALL_OW 1
44314: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44315: LD_ADDR_EXP 90
44319: PUSH
44320: LD_EXP 90
44324: PPUSH
44325: LD_VAR 0 1
44329: PPUSH
44330: LD_VAR 0 2
44334: PUSH
44335: LD_INT 0
44337: PLUS
44338: PPUSH
44339: CALL_OW 1
44343: ST_TO_ADDR
// end ;
44344: LD_VAR 0 3
44348: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44349: LD_INT 0
44351: PPUSH
// if not mc_bases [ base ] then
44352: LD_EXP 79
44356: PUSH
44357: LD_VAR 0 1
44361: ARRAY
44362: NOT
44363: IFFALSE 44367
// exit ;
44365: GO 44392
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44367: LD_ADDR_EXP 90
44371: PUSH
44372: LD_EXP 90
44376: PPUSH
44377: LD_VAR 0 1
44381: PPUSH
44382: LD_VAR 0 2
44386: PPUSH
44387: CALL_OW 1
44391: ST_TO_ADDR
// end ;
44392: LD_VAR 0 3
44396: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44397: LD_INT 0
44399: PPUSH
44400: PPUSH
44401: PPUSH
44402: PPUSH
// if not mc_bases [ base ] then
44403: LD_EXP 79
44407: PUSH
44408: LD_VAR 0 1
44412: ARRAY
44413: NOT
44414: IFFALSE 44418
// exit ;
44416: GO 44483
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44418: LD_ADDR_EXP 99
44422: PUSH
44423: LD_EXP 99
44427: PPUSH
44428: LD_VAR 0 1
44432: PUSH
44433: LD_EXP 99
44437: PUSH
44438: LD_VAR 0 1
44442: ARRAY
44443: PUSH
44444: LD_INT 1
44446: PLUS
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PPUSH
44452: LD_VAR 0 1
44456: PUSH
44457: LD_VAR 0 2
44461: PUSH
44462: LD_VAR 0 3
44466: PUSH
44467: LD_VAR 0 4
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: PPUSH
44478: CALL 57793 0 3
44482: ST_TO_ADDR
// end ;
44483: LD_VAR 0 5
44487: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44488: LD_INT 0
44490: PPUSH
// if not mc_bases [ base ] then
44491: LD_EXP 79
44495: PUSH
44496: LD_VAR 0 1
44500: ARRAY
44501: NOT
44502: IFFALSE 44506
// exit ;
44504: GO 44531
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44506: LD_ADDR_EXP 116
44510: PUSH
44511: LD_EXP 116
44515: PPUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: LD_VAR 0 2
44525: PPUSH
44526: CALL_OW 1
44530: ST_TO_ADDR
// end ;
44531: LD_VAR 0 3
44535: RET
// export function MC_GetMinesField ( base ) ; begin
44536: LD_INT 0
44538: PPUSH
// result := mc_mines [ base ] ;
44539: LD_ADDR_VAR 0 2
44543: PUSH
44544: LD_EXP 92
44548: PUSH
44549: LD_VAR 0 1
44553: ARRAY
44554: ST_TO_ADDR
// end ;
44555: LD_VAR 0 2
44559: RET
// export function MC_GetProduceList ( base ) ; begin
44560: LD_INT 0
44562: PPUSH
// result := mc_produce [ base ] ;
44563: LD_ADDR_VAR 0 2
44567: PUSH
44568: LD_EXP 100
44572: PUSH
44573: LD_VAR 0 1
44577: ARRAY
44578: ST_TO_ADDR
// end ;
44579: LD_VAR 0 2
44583: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44584: LD_INT 0
44586: PPUSH
44587: PPUSH
// if not mc_bases then
44588: LD_EXP 79
44592: NOT
44593: IFFALSE 44597
// exit ;
44595: GO 44662
// if mc_bases [ base ] then
44597: LD_EXP 79
44601: PUSH
44602: LD_VAR 0 1
44606: ARRAY
44607: IFFALSE 44662
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44609: LD_ADDR_VAR 0 3
44613: PUSH
44614: LD_EXP 79
44618: PUSH
44619: LD_VAR 0 1
44623: ARRAY
44624: PPUSH
44625: LD_INT 30
44627: PUSH
44628: LD_VAR 0 2
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PPUSH
44637: CALL_OW 72
44641: ST_TO_ADDR
// if result then
44642: LD_VAR 0 3
44646: IFFALSE 44662
// result := result [ 1 ] ;
44648: LD_ADDR_VAR 0 3
44652: PUSH
44653: LD_VAR 0 3
44657: PUSH
44658: LD_INT 1
44660: ARRAY
44661: ST_TO_ADDR
// end ; end ;
44662: LD_VAR 0 3
44666: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44667: LD_INT 0
44669: PPUSH
44670: PPUSH
// if not mc_bases then
44671: LD_EXP 79
44675: NOT
44676: IFFALSE 44680
// exit ;
44678: GO 44725
// if mc_bases [ base ] then
44680: LD_EXP 79
44684: PUSH
44685: LD_VAR 0 1
44689: ARRAY
44690: IFFALSE 44725
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44692: LD_ADDR_VAR 0 3
44696: PUSH
44697: LD_EXP 79
44701: PUSH
44702: LD_VAR 0 1
44706: ARRAY
44707: PPUSH
44708: LD_INT 30
44710: PUSH
44711: LD_VAR 0 2
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PPUSH
44720: CALL_OW 72
44724: ST_TO_ADDR
// end ;
44725: LD_VAR 0 3
44729: RET
// export function MC_SetTame ( base , area ) ; begin
44730: LD_INT 0
44732: PPUSH
// if not mc_bases or not base then
44733: LD_EXP 79
44737: NOT
44738: PUSH
44739: LD_VAR 0 1
44743: NOT
44744: OR
44745: IFFALSE 44749
// exit ;
44747: GO 44774
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44749: LD_ADDR_EXP 107
44753: PUSH
44754: LD_EXP 107
44758: PPUSH
44759: LD_VAR 0 1
44763: PPUSH
44764: LD_VAR 0 2
44768: PPUSH
44769: CALL_OW 1
44773: ST_TO_ADDR
// end ;
44774: LD_VAR 0 3
44778: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44779: LD_INT 0
44781: PPUSH
44782: PPUSH
// if not mc_bases or not base then
44783: LD_EXP 79
44787: NOT
44788: PUSH
44789: LD_VAR 0 1
44793: NOT
44794: OR
44795: IFFALSE 44799
// exit ;
44797: GO 44901
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44799: LD_ADDR_VAR 0 4
44803: PUSH
44804: LD_EXP 79
44808: PUSH
44809: LD_VAR 0 1
44813: ARRAY
44814: PPUSH
44815: LD_INT 30
44817: PUSH
44818: LD_VAR 0 2
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: PPUSH
44827: CALL_OW 72
44831: ST_TO_ADDR
// if not tmp then
44832: LD_VAR 0 4
44836: NOT
44837: IFFALSE 44841
// exit ;
44839: GO 44901
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44841: LD_ADDR_EXP 111
44845: PUSH
44846: LD_EXP 111
44850: PPUSH
44851: LD_VAR 0 1
44855: PPUSH
44856: LD_EXP 111
44860: PUSH
44861: LD_VAR 0 1
44865: ARRAY
44866: PPUSH
44867: LD_EXP 111
44871: PUSH
44872: LD_VAR 0 1
44876: ARRAY
44877: PUSH
44878: LD_INT 1
44880: PLUS
44881: PPUSH
44882: LD_VAR 0 4
44886: PUSH
44887: LD_INT 1
44889: ARRAY
44890: PPUSH
44891: CALL_OW 2
44895: PPUSH
44896: CALL_OW 1
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 3
44905: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44906: LD_INT 0
44908: PPUSH
44909: PPUSH
// if not mc_bases or not base or not kinds then
44910: LD_EXP 79
44914: NOT
44915: PUSH
44916: LD_VAR 0 1
44920: NOT
44921: OR
44922: PUSH
44923: LD_VAR 0 2
44927: NOT
44928: OR
44929: IFFALSE 44933
// exit ;
44931: GO 44994
// for i in kinds do
44933: LD_ADDR_VAR 0 4
44937: PUSH
44938: LD_VAR 0 2
44942: PUSH
44943: FOR_IN
44944: IFFALSE 44992
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44946: LD_ADDR_EXP 113
44950: PUSH
44951: LD_EXP 113
44955: PPUSH
44956: LD_VAR 0 1
44960: PUSH
44961: LD_EXP 113
44965: PUSH
44966: LD_VAR 0 1
44970: ARRAY
44971: PUSH
44972: LD_INT 1
44974: PLUS
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PPUSH
44980: LD_VAR 0 4
44984: PPUSH
44985: CALL 57793 0 3
44989: ST_TO_ADDR
44990: GO 44943
44992: POP
44993: POP
// end ;
44994: LD_VAR 0 3
44998: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44999: LD_INT 0
45001: PPUSH
// if not mc_bases or not base or not areas then
45002: LD_EXP 79
45006: NOT
45007: PUSH
45008: LD_VAR 0 1
45012: NOT
45013: OR
45014: PUSH
45015: LD_VAR 0 2
45019: NOT
45020: OR
45021: IFFALSE 45025
// exit ;
45023: GO 45050
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45025: LD_ADDR_EXP 97
45029: PUSH
45030: LD_EXP 97
45034: PPUSH
45035: LD_VAR 0 1
45039: PPUSH
45040: LD_VAR 0 2
45044: PPUSH
45045: CALL_OW 1
45049: ST_TO_ADDR
// end ;
45050: LD_VAR 0 3
45054: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45055: LD_INT 0
45057: PPUSH
// if not mc_bases or not base or not teleports_exit then
45058: LD_EXP 79
45062: NOT
45063: PUSH
45064: LD_VAR 0 1
45068: NOT
45069: OR
45070: PUSH
45071: LD_VAR 0 2
45075: NOT
45076: OR
45077: IFFALSE 45081
// exit ;
45079: GO 45106
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45081: LD_ADDR_EXP 114
45085: PUSH
45086: LD_EXP 114
45090: PPUSH
45091: LD_VAR 0 1
45095: PPUSH
45096: LD_VAR 0 2
45100: PPUSH
45101: CALL_OW 1
45105: ST_TO_ADDR
// end ;
45106: LD_VAR 0 3
45110: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45111: LD_INT 0
45113: PPUSH
45114: PPUSH
45115: PPUSH
// if not mc_bases or not base or not ext_list then
45116: LD_EXP 79
45120: NOT
45121: PUSH
45122: LD_VAR 0 1
45126: NOT
45127: OR
45128: PUSH
45129: LD_VAR 0 5
45133: NOT
45134: OR
45135: IFFALSE 45139
// exit ;
45137: GO 45312
// tmp := GetFacExtXYD ( x , y , d ) ;
45139: LD_ADDR_VAR 0 8
45143: PUSH
45144: LD_VAR 0 2
45148: PPUSH
45149: LD_VAR 0 3
45153: PPUSH
45154: LD_VAR 0 4
45158: PPUSH
45159: CALL 91181 0 3
45163: ST_TO_ADDR
// if not tmp then
45164: LD_VAR 0 8
45168: NOT
45169: IFFALSE 45173
// exit ;
45171: GO 45312
// for i in tmp do
45173: LD_ADDR_VAR 0 7
45177: PUSH
45178: LD_VAR 0 8
45182: PUSH
45183: FOR_IN
45184: IFFALSE 45310
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45186: LD_ADDR_EXP 84
45190: PUSH
45191: LD_EXP 84
45195: PPUSH
45196: LD_VAR 0 1
45200: PPUSH
45201: LD_EXP 84
45205: PUSH
45206: LD_VAR 0 1
45210: ARRAY
45211: PPUSH
45212: LD_EXP 84
45216: PUSH
45217: LD_VAR 0 1
45221: ARRAY
45222: PUSH
45223: LD_INT 1
45225: PLUS
45226: PPUSH
45227: LD_VAR 0 5
45231: PUSH
45232: LD_INT 1
45234: ARRAY
45235: PUSH
45236: LD_VAR 0 7
45240: PUSH
45241: LD_INT 1
45243: ARRAY
45244: PUSH
45245: LD_VAR 0 7
45249: PUSH
45250: LD_INT 2
45252: ARRAY
45253: PUSH
45254: LD_VAR 0 7
45258: PUSH
45259: LD_INT 3
45261: ARRAY
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: PPUSH
45269: CALL_OW 2
45273: PPUSH
45274: CALL_OW 1
45278: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45279: LD_ADDR_VAR 0 5
45283: PUSH
45284: LD_VAR 0 5
45288: PPUSH
45289: LD_INT 1
45291: PPUSH
45292: CALL_OW 3
45296: ST_TO_ADDR
// if not ext_list then
45297: LD_VAR 0 5
45301: NOT
45302: IFFALSE 45308
// exit ;
45304: POP
45305: POP
45306: GO 45312
// end ;
45308: GO 45183
45310: POP
45311: POP
// end ;
45312: LD_VAR 0 6
45316: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45317: LD_INT 0
45319: PPUSH
// if not mc_bases or not base or not weapon_list then
45320: LD_EXP 79
45324: NOT
45325: PUSH
45326: LD_VAR 0 1
45330: NOT
45331: OR
45332: PUSH
45333: LD_VAR 0 2
45337: NOT
45338: OR
45339: IFFALSE 45343
// exit ;
45341: GO 45368
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45343: LD_ADDR_EXP 118
45347: PUSH
45348: LD_EXP 118
45352: PPUSH
45353: LD_VAR 0 1
45357: PPUSH
45358: LD_VAR 0 2
45362: PPUSH
45363: CALL_OW 1
45367: ST_TO_ADDR
// end ;
45368: LD_VAR 0 3
45372: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45373: LD_INT 0
45375: PPUSH
// if not mc_bases or not base or not tech_list then
45376: LD_EXP 79
45380: NOT
45381: PUSH
45382: LD_VAR 0 1
45386: NOT
45387: OR
45388: PUSH
45389: LD_VAR 0 2
45393: NOT
45394: OR
45395: IFFALSE 45399
// exit ;
45397: GO 45424
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45399: LD_ADDR_EXP 106
45403: PUSH
45404: LD_EXP 106
45408: PPUSH
45409: LD_VAR 0 1
45413: PPUSH
45414: LD_VAR 0 2
45418: PPUSH
45419: CALL_OW 1
45423: ST_TO_ADDR
// end ;
45424: LD_VAR 0 3
45428: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45429: LD_INT 0
45431: PPUSH
// if not mc_bases or not parking_area or not base then
45432: LD_EXP 79
45436: NOT
45437: PUSH
45438: LD_VAR 0 2
45442: NOT
45443: OR
45444: PUSH
45445: LD_VAR 0 1
45449: NOT
45450: OR
45451: IFFALSE 45455
// exit ;
45453: GO 45480
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45455: LD_ADDR_EXP 103
45459: PUSH
45460: LD_EXP 103
45464: PPUSH
45465: LD_VAR 0 1
45469: PPUSH
45470: LD_VAR 0 2
45474: PPUSH
45475: CALL_OW 1
45479: ST_TO_ADDR
// end ;
45480: LD_VAR 0 3
45484: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45485: LD_INT 0
45487: PPUSH
// if not mc_bases or not base or not scan_area then
45488: LD_EXP 79
45492: NOT
45493: PUSH
45494: LD_VAR 0 1
45498: NOT
45499: OR
45500: PUSH
45501: LD_VAR 0 2
45505: NOT
45506: OR
45507: IFFALSE 45511
// exit ;
45509: GO 45536
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45511: LD_ADDR_EXP 104
45515: PUSH
45516: LD_EXP 104
45520: PPUSH
45521: LD_VAR 0 1
45525: PPUSH
45526: LD_VAR 0 2
45530: PPUSH
45531: CALL_OW 1
45535: ST_TO_ADDR
// end ;
45536: LD_VAR 0 3
45540: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45541: LD_INT 0
45543: PPUSH
45544: PPUSH
// if not mc_bases or not base then
45545: LD_EXP 79
45549: NOT
45550: PUSH
45551: LD_VAR 0 1
45555: NOT
45556: OR
45557: IFFALSE 45561
// exit ;
45559: GO 45625
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45561: LD_ADDR_VAR 0 3
45565: PUSH
45566: LD_INT 1
45568: PUSH
45569: LD_INT 2
45571: PUSH
45572: LD_INT 3
45574: PUSH
45575: LD_INT 4
45577: PUSH
45578: LD_INT 11
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45588: LD_ADDR_EXP 106
45592: PUSH
45593: LD_EXP 106
45597: PPUSH
45598: LD_VAR 0 1
45602: PPUSH
45603: LD_EXP 106
45607: PUSH
45608: LD_VAR 0 1
45612: ARRAY
45613: PUSH
45614: LD_VAR 0 3
45618: DIFF
45619: PPUSH
45620: CALL_OW 1
45624: ST_TO_ADDR
// end ;
45625: LD_VAR 0 2
45629: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45630: LD_INT 0
45632: PPUSH
// result := mc_vehicles [ base ] ;
45633: LD_ADDR_VAR 0 3
45637: PUSH
45638: LD_EXP 98
45642: PUSH
45643: LD_VAR 0 1
45647: ARRAY
45648: ST_TO_ADDR
// if onlyCombat then
45649: LD_VAR 0 2
45653: IFFALSE 45818
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45655: LD_ADDR_VAR 0 3
45659: PUSH
45660: LD_VAR 0 3
45664: PUSH
45665: LD_VAR 0 3
45669: PPUSH
45670: LD_INT 2
45672: PUSH
45673: LD_INT 34
45675: PUSH
45676: LD_INT 12
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 34
45685: PUSH
45686: LD_INT 51
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 34
45695: PUSH
45696: LD_EXP 73
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 34
45707: PUSH
45708: LD_INT 32
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 34
45717: PUSH
45718: LD_INT 13
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 34
45727: PUSH
45728: LD_INT 52
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: PUSH
45735: LD_INT 34
45737: PUSH
45738: LD_INT 14
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 34
45747: PUSH
45748: LD_INT 53
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 34
45757: PUSH
45758: LD_EXP 72
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 34
45769: PUSH
45770: LD_INT 31
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 34
45779: PUSH
45780: LD_INT 48
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 34
45789: PUSH
45790: LD_INT 8
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: PPUSH
45812: CALL_OW 72
45816: DIFF
45817: ST_TO_ADDR
// end ; end_of_file
45818: LD_VAR 0 3
45822: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45823: LD_INT 0
45825: PPUSH
45826: PPUSH
45827: PPUSH
// if not mc_bases or not skirmish then
45828: LD_EXP 79
45832: NOT
45833: PUSH
45834: LD_EXP 77
45838: NOT
45839: OR
45840: IFFALSE 45844
// exit ;
45842: GO 46009
// for i = 1 to mc_bases do
45844: LD_ADDR_VAR 0 4
45848: PUSH
45849: DOUBLE
45850: LD_INT 1
45852: DEC
45853: ST_TO_ADDR
45854: LD_EXP 79
45858: PUSH
45859: FOR_TO
45860: IFFALSE 46007
// begin if sci in mc_bases [ i ] then
45862: LD_VAR 0 2
45866: PUSH
45867: LD_EXP 79
45871: PUSH
45872: LD_VAR 0 4
45876: ARRAY
45877: IN
45878: IFFALSE 46005
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45880: LD_ADDR_EXP 108
45884: PUSH
45885: LD_EXP 108
45889: PPUSH
45890: LD_VAR 0 4
45894: PUSH
45895: LD_EXP 108
45899: PUSH
45900: LD_VAR 0 4
45904: ARRAY
45905: PUSH
45906: LD_INT 1
45908: PLUS
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PPUSH
45914: LD_VAR 0 1
45918: PPUSH
45919: CALL 57793 0 3
45923: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45924: LD_ADDR_VAR 0 5
45928: PUSH
45929: LD_EXP 79
45933: PUSH
45934: LD_VAR 0 4
45938: ARRAY
45939: PPUSH
45940: LD_INT 2
45942: PUSH
45943: LD_INT 30
45945: PUSH
45946: LD_INT 0
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 30
45955: PUSH
45956: LD_INT 1
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: LIST
45967: PPUSH
45968: CALL_OW 72
45972: PPUSH
45973: LD_VAR 0 1
45977: PPUSH
45978: CALL_OW 74
45982: ST_TO_ADDR
// if tmp then
45983: LD_VAR 0 5
45987: IFFALSE 46003
// ComStandNearbyBuilding ( ape , tmp ) ;
45989: LD_VAR 0 1
45993: PPUSH
45994: LD_VAR 0 5
45998: PPUSH
45999: CALL 51996 0 2
// break ;
46003: GO 46007
// end ; end ;
46005: GO 45859
46007: POP
46008: POP
// end ;
46009: LD_VAR 0 3
46013: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46014: LD_INT 0
46016: PPUSH
46017: PPUSH
46018: PPUSH
// if not mc_bases or not skirmish then
46019: LD_EXP 79
46023: NOT
46024: PUSH
46025: LD_EXP 77
46029: NOT
46030: OR
46031: IFFALSE 46035
// exit ;
46033: GO 46124
// for i = 1 to mc_bases do
46035: LD_ADDR_VAR 0 4
46039: PUSH
46040: DOUBLE
46041: LD_INT 1
46043: DEC
46044: ST_TO_ADDR
46045: LD_EXP 79
46049: PUSH
46050: FOR_TO
46051: IFFALSE 46122
// begin if building in mc_busy_turret_list [ i ] then
46053: LD_VAR 0 1
46057: PUSH
46058: LD_EXP 89
46062: PUSH
46063: LD_VAR 0 4
46067: ARRAY
46068: IN
46069: IFFALSE 46120
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46071: LD_ADDR_VAR 0 5
46075: PUSH
46076: LD_EXP 89
46080: PUSH
46081: LD_VAR 0 4
46085: ARRAY
46086: PUSH
46087: LD_VAR 0 1
46091: DIFF
46092: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46093: LD_ADDR_EXP 89
46097: PUSH
46098: LD_EXP 89
46102: PPUSH
46103: LD_VAR 0 4
46107: PPUSH
46108: LD_VAR 0 5
46112: PPUSH
46113: CALL_OW 1
46117: ST_TO_ADDR
// break ;
46118: GO 46122
// end ; end ;
46120: GO 46050
46122: POP
46123: POP
// end ;
46124: LD_VAR 0 3
46128: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46129: LD_INT 0
46131: PPUSH
46132: PPUSH
46133: PPUSH
// if not mc_bases or not skirmish then
46134: LD_EXP 79
46138: NOT
46139: PUSH
46140: LD_EXP 77
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46349
// for i = 1 to mc_bases do
46150: LD_ADDR_VAR 0 5
46154: PUSH
46155: DOUBLE
46156: LD_INT 1
46158: DEC
46159: ST_TO_ADDR
46160: LD_EXP 79
46164: PUSH
46165: FOR_TO
46166: IFFALSE 46347
// if building in mc_bases [ i ] then
46168: LD_VAR 0 1
46172: PUSH
46173: LD_EXP 79
46177: PUSH
46178: LD_VAR 0 5
46182: ARRAY
46183: IN
46184: IFFALSE 46345
// begin tmp := mc_bases [ i ] diff building ;
46186: LD_ADDR_VAR 0 6
46190: PUSH
46191: LD_EXP 79
46195: PUSH
46196: LD_VAR 0 5
46200: ARRAY
46201: PUSH
46202: LD_VAR 0 1
46206: DIFF
46207: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46208: LD_ADDR_EXP 79
46212: PUSH
46213: LD_EXP 79
46217: PPUSH
46218: LD_VAR 0 5
46222: PPUSH
46223: LD_VAR 0 6
46227: PPUSH
46228: CALL_OW 1
46232: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46233: LD_VAR 0 1
46237: PUSH
46238: LD_EXP 87
46242: PUSH
46243: LD_VAR 0 5
46247: ARRAY
46248: IN
46249: IFFALSE 46288
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46251: LD_ADDR_EXP 87
46255: PUSH
46256: LD_EXP 87
46260: PPUSH
46261: LD_VAR 0 5
46265: PPUSH
46266: LD_EXP 87
46270: PUSH
46271: LD_VAR 0 5
46275: ARRAY
46276: PUSH
46277: LD_VAR 0 1
46281: DIFF
46282: PPUSH
46283: CALL_OW 1
46287: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46288: LD_VAR 0 1
46292: PUSH
46293: LD_EXP 88
46297: PUSH
46298: LD_VAR 0 5
46302: ARRAY
46303: IN
46304: IFFALSE 46343
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46306: LD_ADDR_EXP 88
46310: PUSH
46311: LD_EXP 88
46315: PPUSH
46316: LD_VAR 0 5
46320: PPUSH
46321: LD_EXP 88
46325: PUSH
46326: LD_VAR 0 5
46330: ARRAY
46331: PUSH
46332: LD_VAR 0 1
46336: DIFF
46337: PPUSH
46338: CALL_OW 1
46342: ST_TO_ADDR
// break ;
46343: GO 46347
// end ;
46345: GO 46165
46347: POP
46348: POP
// end ;
46349: LD_VAR 0 4
46353: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46354: LD_INT 0
46356: PPUSH
46357: PPUSH
46358: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46359: LD_EXP 79
46363: NOT
46364: PUSH
46365: LD_EXP 77
46369: NOT
46370: OR
46371: PUSH
46372: LD_VAR 0 3
46376: PUSH
46377: LD_EXP 105
46381: IN
46382: NOT
46383: OR
46384: IFFALSE 46388
// exit ;
46386: GO 46511
// for i = 1 to mc_vehicles do
46388: LD_ADDR_VAR 0 6
46392: PUSH
46393: DOUBLE
46394: LD_INT 1
46396: DEC
46397: ST_TO_ADDR
46398: LD_EXP 98
46402: PUSH
46403: FOR_TO
46404: IFFALSE 46509
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46406: LD_VAR 0 2
46410: PUSH
46411: LD_EXP 98
46415: PUSH
46416: LD_VAR 0 6
46420: ARRAY
46421: IN
46422: PUSH
46423: LD_VAR 0 1
46427: PUSH
46428: LD_EXP 98
46432: PUSH
46433: LD_VAR 0 6
46437: ARRAY
46438: IN
46439: OR
46440: IFFALSE 46507
// begin tmp := mc_vehicles [ i ] diff old ;
46442: LD_ADDR_VAR 0 7
46446: PUSH
46447: LD_EXP 98
46451: PUSH
46452: LD_VAR 0 6
46456: ARRAY
46457: PUSH
46458: LD_VAR 0 2
46462: DIFF
46463: ST_TO_ADDR
// tmp := tmp diff new ;
46464: LD_ADDR_VAR 0 7
46468: PUSH
46469: LD_VAR 0 7
46473: PUSH
46474: LD_VAR 0 1
46478: DIFF
46479: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46480: LD_ADDR_EXP 98
46484: PUSH
46485: LD_EXP 98
46489: PPUSH
46490: LD_VAR 0 6
46494: PPUSH
46495: LD_VAR 0 7
46499: PPUSH
46500: CALL_OW 1
46504: ST_TO_ADDR
// break ;
46505: GO 46509
// end ;
46507: GO 46403
46509: POP
46510: POP
// end ;
46511: LD_VAR 0 5
46515: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46516: LD_INT 0
46518: PPUSH
46519: PPUSH
46520: PPUSH
46521: PPUSH
// if not mc_bases or not skirmish then
46522: LD_EXP 79
46526: NOT
46527: PUSH
46528: LD_EXP 77
46532: NOT
46533: OR
46534: IFFALSE 46538
// exit ;
46536: GO 46915
// side := GetSide ( vehicle ) ;
46538: LD_ADDR_VAR 0 5
46542: PUSH
46543: LD_VAR 0 1
46547: PPUSH
46548: CALL_OW 255
46552: ST_TO_ADDR
// for i = 1 to mc_bases do
46553: LD_ADDR_VAR 0 4
46557: PUSH
46558: DOUBLE
46559: LD_INT 1
46561: DEC
46562: ST_TO_ADDR
46563: LD_EXP 79
46567: PUSH
46568: FOR_TO
46569: IFFALSE 46913
// begin if factory in mc_bases [ i ] then
46571: LD_VAR 0 2
46575: PUSH
46576: LD_EXP 79
46580: PUSH
46581: LD_VAR 0 4
46585: ARRAY
46586: IN
46587: IFFALSE 46911
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46589: LD_EXP 101
46593: PUSH
46594: LD_VAR 0 4
46598: ARRAY
46599: PUSH
46600: LD_EXP 90
46604: PUSH
46605: LD_VAR 0 4
46609: ARRAY
46610: LESS
46611: PUSH
46612: LD_VAR 0 1
46616: PPUSH
46617: CALL_OW 264
46621: PUSH
46622: LD_INT 31
46624: PUSH
46625: LD_INT 32
46627: PUSH
46628: LD_INT 51
46630: PUSH
46631: LD_EXP 73
46635: PUSH
46636: LD_INT 12
46638: PUSH
46639: LD_INT 30
46641: PUSH
46642: LD_EXP 72
46646: PUSH
46647: LD_INT 11
46649: PUSH
46650: LD_INT 53
46652: PUSH
46653: LD_INT 14
46655: PUSH
46656: LD_EXP 76
46660: PUSH
46661: LD_INT 29
46663: PUSH
46664: LD_EXP 74
46668: PUSH
46669: LD_INT 13
46671: PUSH
46672: LD_INT 52
46674: PUSH
46675: LD_INT 48
46677: PUSH
46678: LD_INT 8
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: IN
46700: NOT
46701: AND
46702: IFFALSE 46750
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46704: LD_ADDR_EXP 101
46708: PUSH
46709: LD_EXP 101
46713: PPUSH
46714: LD_VAR 0 4
46718: PUSH
46719: LD_EXP 101
46723: PUSH
46724: LD_VAR 0 4
46728: ARRAY
46729: PUSH
46730: LD_INT 1
46732: PLUS
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PPUSH
46738: LD_VAR 0 1
46742: PPUSH
46743: CALL 57793 0 3
46747: ST_TO_ADDR
46748: GO 46794
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46750: LD_ADDR_EXP 98
46754: PUSH
46755: LD_EXP 98
46759: PPUSH
46760: LD_VAR 0 4
46764: PUSH
46765: LD_EXP 98
46769: PUSH
46770: LD_VAR 0 4
46774: ARRAY
46775: PUSH
46776: LD_INT 1
46778: PLUS
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PPUSH
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL 57793 0 3
46793: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46794: LD_VAR 0 1
46798: PPUSH
46799: CALL_OW 263
46803: PUSH
46804: LD_INT 2
46806: EQUAL
46807: IFFALSE 46827
// begin repeat wait ( 0 0$1 ) ;
46809: LD_INT 35
46811: PPUSH
46812: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46816: LD_VAR 0 1
46820: PPUSH
46821: CALL_OW 312
46825: IFFALSE 46809
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46827: LD_VAR 0 1
46831: PPUSH
46832: LD_EXP 103
46836: PUSH
46837: LD_VAR 0 4
46841: ARRAY
46842: PPUSH
46843: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46847: LD_VAR 0 1
46851: PPUSH
46852: CALL_OW 263
46856: PUSH
46857: LD_INT 1
46859: NONEQUAL
46860: IFFALSE 46864
// break ;
46862: GO 46913
// repeat wait ( 0 0$1 ) ;
46864: LD_INT 35
46866: PPUSH
46867: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46871: LD_VAR 0 1
46875: PPUSH
46876: LD_EXP 103
46880: PUSH
46881: LD_VAR 0 4
46885: ARRAY
46886: PPUSH
46887: CALL_OW 308
46891: IFFALSE 46864
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46893: LD_VAR 0 1
46897: PPUSH
46898: CALL_OW 311
46902: PPUSH
46903: CALL_OW 121
// exit ;
46907: POP
46908: POP
46909: GO 46915
// end ; end ;
46911: GO 46568
46913: POP
46914: POP
// end ;
46915: LD_VAR 0 3
46919: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46920: LD_INT 0
46922: PPUSH
46923: PPUSH
46924: PPUSH
46925: PPUSH
// if not mc_bases or not skirmish then
46926: LD_EXP 79
46930: NOT
46931: PUSH
46932: LD_EXP 77
46936: NOT
46937: OR
46938: IFFALSE 46942
// exit ;
46940: GO 47295
// repeat wait ( 0 0$1 ) ;
46942: LD_INT 35
46944: PPUSH
46945: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46949: LD_VAR 0 2
46953: PPUSH
46954: LD_VAR 0 3
46958: PPUSH
46959: CALL_OW 284
46963: IFFALSE 46942
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46965: LD_VAR 0 2
46969: PPUSH
46970: LD_VAR 0 3
46974: PPUSH
46975: CALL_OW 283
46979: PUSH
46980: LD_INT 4
46982: EQUAL
46983: IFFALSE 46987
// exit ;
46985: GO 47295
// for i = 1 to mc_bases do
46987: LD_ADDR_VAR 0 7
46991: PUSH
46992: DOUBLE
46993: LD_INT 1
46995: DEC
46996: ST_TO_ADDR
46997: LD_EXP 79
47001: PUSH
47002: FOR_TO
47003: IFFALSE 47293
// begin if mc_crates_area [ i ] then
47005: LD_EXP 97
47009: PUSH
47010: LD_VAR 0 7
47014: ARRAY
47015: IFFALSE 47126
// for j in mc_crates_area [ i ] do
47017: LD_ADDR_VAR 0 8
47021: PUSH
47022: LD_EXP 97
47026: PUSH
47027: LD_VAR 0 7
47031: ARRAY
47032: PUSH
47033: FOR_IN
47034: IFFALSE 47124
// if InArea ( x , y , j ) then
47036: LD_VAR 0 2
47040: PPUSH
47041: LD_VAR 0 3
47045: PPUSH
47046: LD_VAR 0 8
47050: PPUSH
47051: CALL_OW 309
47055: IFFALSE 47122
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47057: LD_ADDR_EXP 95
47061: PUSH
47062: LD_EXP 95
47066: PPUSH
47067: LD_VAR 0 7
47071: PUSH
47072: LD_EXP 95
47076: PUSH
47077: LD_VAR 0 7
47081: ARRAY
47082: PUSH
47083: LD_INT 1
47085: PLUS
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PPUSH
47091: LD_VAR 0 4
47095: PUSH
47096: LD_VAR 0 2
47100: PUSH
47101: LD_VAR 0 3
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: LIST
47110: PPUSH
47111: CALL 57793 0 3
47115: ST_TO_ADDR
// exit ;
47116: POP
47117: POP
47118: POP
47119: POP
47120: GO 47295
// end ;
47122: GO 47033
47124: POP
47125: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47126: LD_ADDR_VAR 0 9
47130: PUSH
47131: LD_EXP 79
47135: PUSH
47136: LD_VAR 0 7
47140: ARRAY
47141: PPUSH
47142: LD_INT 2
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 0
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 30
47157: PUSH
47158: LD_INT 1
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: LIST
47169: PPUSH
47170: CALL_OW 72
47174: ST_TO_ADDR
// if not depot then
47175: LD_VAR 0 9
47179: NOT
47180: IFFALSE 47184
// continue ;
47182: GO 47002
// for j in depot do
47184: LD_ADDR_VAR 0 8
47188: PUSH
47189: LD_VAR 0 9
47193: PUSH
47194: FOR_IN
47195: IFFALSE 47289
// if GetDistUnitXY ( j , x , y ) < 30 then
47197: LD_VAR 0 8
47201: PPUSH
47202: LD_VAR 0 2
47206: PPUSH
47207: LD_VAR 0 3
47211: PPUSH
47212: CALL_OW 297
47216: PUSH
47217: LD_INT 30
47219: LESS
47220: IFFALSE 47287
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47222: LD_ADDR_EXP 95
47226: PUSH
47227: LD_EXP 95
47231: PPUSH
47232: LD_VAR 0 7
47236: PUSH
47237: LD_EXP 95
47241: PUSH
47242: LD_VAR 0 7
47246: ARRAY
47247: PUSH
47248: LD_INT 1
47250: PLUS
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PPUSH
47256: LD_VAR 0 4
47260: PUSH
47261: LD_VAR 0 2
47265: PUSH
47266: LD_VAR 0 3
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: LIST
47275: PPUSH
47276: CALL 57793 0 3
47280: ST_TO_ADDR
// exit ;
47281: POP
47282: POP
47283: POP
47284: POP
47285: GO 47295
// end ;
47287: GO 47194
47289: POP
47290: POP
// end ;
47291: GO 47002
47293: POP
47294: POP
// end ;
47295: LD_VAR 0 6
47299: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47300: LD_INT 0
47302: PPUSH
47303: PPUSH
47304: PPUSH
47305: PPUSH
// if not mc_bases or not skirmish then
47306: LD_EXP 79
47310: NOT
47311: PUSH
47312: LD_EXP 77
47316: NOT
47317: OR
47318: IFFALSE 47322
// exit ;
47320: GO 47599
// side := GetSide ( lab ) ;
47322: LD_ADDR_VAR 0 4
47326: PUSH
47327: LD_VAR 0 2
47331: PPUSH
47332: CALL_OW 255
47336: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47337: LD_VAR 0 4
47341: PUSH
47342: LD_EXP 105
47346: IN
47347: NOT
47348: PUSH
47349: LD_EXP 106
47353: NOT
47354: OR
47355: PUSH
47356: LD_EXP 79
47360: NOT
47361: OR
47362: IFFALSE 47366
// exit ;
47364: GO 47599
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47366: LD_ADDR_EXP 106
47370: PUSH
47371: LD_EXP 106
47375: PPUSH
47376: LD_VAR 0 4
47380: PPUSH
47381: LD_EXP 106
47385: PUSH
47386: LD_VAR 0 4
47390: ARRAY
47391: PUSH
47392: LD_VAR 0 1
47396: DIFF
47397: PPUSH
47398: CALL_OW 1
47402: ST_TO_ADDR
// for i = 1 to mc_bases do
47403: LD_ADDR_VAR 0 5
47407: PUSH
47408: DOUBLE
47409: LD_INT 1
47411: DEC
47412: ST_TO_ADDR
47413: LD_EXP 79
47417: PUSH
47418: FOR_TO
47419: IFFALSE 47597
// begin if lab in mc_bases [ i ] then
47421: LD_VAR 0 2
47425: PUSH
47426: LD_EXP 79
47430: PUSH
47431: LD_VAR 0 5
47435: ARRAY
47436: IN
47437: IFFALSE 47595
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47439: LD_VAR 0 1
47443: PUSH
47444: LD_INT 11
47446: PUSH
47447: LD_INT 4
47449: PUSH
47450: LD_INT 3
47452: PUSH
47453: LD_INT 2
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: IN
47462: PUSH
47463: LD_EXP 109
47467: PUSH
47468: LD_VAR 0 5
47472: ARRAY
47473: AND
47474: IFFALSE 47595
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47476: LD_ADDR_VAR 0 6
47480: PUSH
47481: LD_EXP 109
47485: PUSH
47486: LD_VAR 0 5
47490: ARRAY
47491: PUSH
47492: LD_INT 1
47494: ARRAY
47495: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47496: LD_ADDR_EXP 109
47500: PUSH
47501: LD_EXP 109
47505: PPUSH
47506: LD_VAR 0 5
47510: PPUSH
47511: EMPTY
47512: PPUSH
47513: CALL_OW 1
47517: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47518: LD_VAR 0 6
47522: PPUSH
47523: LD_INT 0
47525: PPUSH
47526: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47530: LD_VAR 0 6
47534: PPUSH
47535: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47539: LD_ADDR_EXP 108
47543: PUSH
47544: LD_EXP 108
47548: PPUSH
47549: LD_VAR 0 5
47553: PPUSH
47554: LD_EXP 108
47558: PUSH
47559: LD_VAR 0 5
47563: ARRAY
47564: PPUSH
47565: LD_INT 1
47567: PPUSH
47568: LD_VAR 0 6
47572: PPUSH
47573: CALL_OW 2
47577: PPUSH
47578: CALL_OW 1
47582: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47583: LD_VAR 0 5
47587: PPUSH
47588: LD_INT 112
47590: PPUSH
47591: CALL 24595 0 2
// end ; end ; end ;
47595: GO 47418
47597: POP
47598: POP
// end ;
47599: LD_VAR 0 3
47603: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47604: LD_INT 0
47606: PPUSH
47607: PPUSH
47608: PPUSH
47609: PPUSH
47610: PPUSH
47611: PPUSH
47612: PPUSH
47613: PPUSH
// if not mc_bases or not skirmish then
47614: LD_EXP 79
47618: NOT
47619: PUSH
47620: LD_EXP 77
47624: NOT
47625: OR
47626: IFFALSE 47630
// exit ;
47628: GO 49001
// for i = 1 to mc_bases do
47630: LD_ADDR_VAR 0 3
47634: PUSH
47635: DOUBLE
47636: LD_INT 1
47638: DEC
47639: ST_TO_ADDR
47640: LD_EXP 79
47644: PUSH
47645: FOR_TO
47646: IFFALSE 48999
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47648: LD_VAR 0 1
47652: PUSH
47653: LD_EXP 79
47657: PUSH
47658: LD_VAR 0 3
47662: ARRAY
47663: IN
47664: PUSH
47665: LD_VAR 0 1
47669: PUSH
47670: LD_EXP 86
47674: PUSH
47675: LD_VAR 0 3
47679: ARRAY
47680: IN
47681: OR
47682: PUSH
47683: LD_VAR 0 1
47687: PUSH
47688: LD_EXP 101
47692: PUSH
47693: LD_VAR 0 3
47697: ARRAY
47698: IN
47699: OR
47700: PUSH
47701: LD_VAR 0 1
47705: PUSH
47706: LD_EXP 98
47710: PUSH
47711: LD_VAR 0 3
47715: ARRAY
47716: IN
47717: OR
47718: PUSH
47719: LD_VAR 0 1
47723: PUSH
47724: LD_EXP 108
47728: PUSH
47729: LD_VAR 0 3
47733: ARRAY
47734: IN
47735: OR
47736: PUSH
47737: LD_VAR 0 1
47741: PUSH
47742: LD_EXP 109
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: IN
47753: OR
47754: IFFALSE 48997
// begin if un in mc_ape [ i ] then
47756: LD_VAR 0 1
47760: PUSH
47761: LD_EXP 108
47765: PUSH
47766: LD_VAR 0 3
47770: ARRAY
47771: IN
47772: IFFALSE 47811
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47774: LD_ADDR_EXP 108
47778: PUSH
47779: LD_EXP 108
47783: PPUSH
47784: LD_VAR 0 3
47788: PPUSH
47789: LD_EXP 108
47793: PUSH
47794: LD_VAR 0 3
47798: ARRAY
47799: PUSH
47800: LD_VAR 0 1
47804: DIFF
47805: PPUSH
47806: CALL_OW 1
47810: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47811: LD_VAR 0 1
47815: PUSH
47816: LD_EXP 109
47820: PUSH
47821: LD_VAR 0 3
47825: ARRAY
47826: IN
47827: IFFALSE 47851
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47829: LD_ADDR_EXP 109
47833: PUSH
47834: LD_EXP 109
47838: PPUSH
47839: LD_VAR 0 3
47843: PPUSH
47844: EMPTY
47845: PPUSH
47846: CALL_OW 1
47850: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47851: LD_VAR 0 1
47855: PPUSH
47856: CALL_OW 247
47860: PUSH
47861: LD_INT 2
47863: EQUAL
47864: PUSH
47865: LD_VAR 0 1
47869: PPUSH
47870: CALL_OW 110
47874: PUSH
47875: LD_INT 20
47877: EQUAL
47878: PUSH
47879: LD_VAR 0 1
47883: PUSH
47884: LD_EXP 101
47888: PUSH
47889: LD_VAR 0 3
47893: ARRAY
47894: IN
47895: OR
47896: PUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: CALL_OW 264
47906: PUSH
47907: LD_INT 12
47909: PUSH
47910: LD_INT 51
47912: PUSH
47913: LD_EXP 73
47917: PUSH
47918: LD_INT 32
47920: PUSH
47921: LD_INT 13
47923: PUSH
47924: LD_INT 52
47926: PUSH
47927: LD_INT 31
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: IN
47939: OR
47940: AND
47941: IFFALSE 48249
// begin if un in mc_defender [ i ] then
47943: LD_VAR 0 1
47947: PUSH
47948: LD_EXP 101
47952: PUSH
47953: LD_VAR 0 3
47957: ARRAY
47958: IN
47959: IFFALSE 47998
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47961: LD_ADDR_EXP 101
47965: PUSH
47966: LD_EXP 101
47970: PPUSH
47971: LD_VAR 0 3
47975: PPUSH
47976: LD_EXP 101
47980: PUSH
47981: LD_VAR 0 3
47985: ARRAY
47986: PUSH
47987: LD_VAR 0 1
47991: DIFF
47992: PPUSH
47993: CALL_OW 1
47997: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47998: LD_ADDR_VAR 0 8
48002: PUSH
48003: LD_VAR 0 3
48007: PPUSH
48008: LD_INT 3
48010: PPUSH
48011: CALL 44667 0 2
48015: ST_TO_ADDR
// if fac then
48016: LD_VAR 0 8
48020: IFFALSE 48249
// begin for j in fac do
48022: LD_ADDR_VAR 0 4
48026: PUSH
48027: LD_VAR 0 8
48031: PUSH
48032: FOR_IN
48033: IFFALSE 48247
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48035: LD_ADDR_VAR 0 9
48039: PUSH
48040: LD_VAR 0 8
48044: PPUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 265
48054: PPUSH
48055: LD_VAR 0 1
48059: PPUSH
48060: CALL_OW 262
48064: PPUSH
48065: LD_VAR 0 1
48069: PPUSH
48070: CALL_OW 263
48074: PPUSH
48075: LD_VAR 0 1
48079: PPUSH
48080: CALL_OW 264
48084: PPUSH
48085: CALL 55325 0 5
48089: ST_TO_ADDR
// if components then
48090: LD_VAR 0 9
48094: IFFALSE 48245
// begin if GetWeapon ( un ) = ar_control_tower then
48096: LD_VAR 0 1
48100: PPUSH
48101: CALL_OW 264
48105: PUSH
48106: LD_INT 31
48108: EQUAL
48109: IFFALSE 48226
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48111: LD_VAR 0 1
48115: PPUSH
48116: CALL_OW 311
48120: PPUSH
48121: LD_INT 0
48123: PPUSH
48124: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48128: LD_ADDR_EXP 119
48132: PUSH
48133: LD_EXP 119
48137: PPUSH
48138: LD_VAR 0 3
48142: PPUSH
48143: LD_EXP 119
48147: PUSH
48148: LD_VAR 0 3
48152: ARRAY
48153: PUSH
48154: LD_VAR 0 1
48158: PPUSH
48159: CALL_OW 311
48163: DIFF
48164: PPUSH
48165: CALL_OW 1
48169: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48170: LD_ADDR_VAR 0 7
48174: PUSH
48175: LD_EXP 100
48179: PUSH
48180: LD_VAR 0 3
48184: ARRAY
48185: PPUSH
48186: LD_INT 1
48188: PPUSH
48189: LD_VAR 0 9
48193: PPUSH
48194: CALL_OW 2
48198: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48199: LD_ADDR_EXP 100
48203: PUSH
48204: LD_EXP 100
48208: PPUSH
48209: LD_VAR 0 3
48213: PPUSH
48214: LD_VAR 0 7
48218: PPUSH
48219: CALL_OW 1
48223: ST_TO_ADDR
// end else
48224: GO 48243
// MC_InsertProduceList ( i , [ components ] ) ;
48226: LD_VAR 0 3
48230: PPUSH
48231: LD_VAR 0 9
48235: PUSH
48236: EMPTY
48237: LIST
48238: PPUSH
48239: CALL 44212 0 2
// break ;
48243: GO 48247
// end ; end ;
48245: GO 48032
48247: POP
48248: POP
// end ; end ; if GetType ( un ) = unit_building then
48249: LD_VAR 0 1
48253: PPUSH
48254: CALL_OW 247
48258: PUSH
48259: LD_INT 3
48261: EQUAL
48262: IFFALSE 48665
// begin btype := GetBType ( un ) ;
48264: LD_ADDR_VAR 0 5
48268: PUSH
48269: LD_VAR 0 1
48273: PPUSH
48274: CALL_OW 266
48278: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48279: LD_VAR 0 5
48283: PUSH
48284: LD_INT 29
48286: PUSH
48287: LD_INT 30
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: IN
48294: IFFALSE 48367
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48296: LD_VAR 0 1
48300: PPUSH
48301: CALL_OW 250
48305: PPUSH
48306: LD_VAR 0 1
48310: PPUSH
48311: CALL_OW 251
48315: PPUSH
48316: LD_VAR 0 1
48320: PPUSH
48321: CALL_OW 255
48325: PPUSH
48326: CALL_OW 440
48330: NOT
48331: IFFALSE 48367
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48333: LD_VAR 0 1
48337: PPUSH
48338: CALL_OW 250
48342: PPUSH
48343: LD_VAR 0 1
48347: PPUSH
48348: CALL_OW 251
48352: PPUSH
48353: LD_VAR 0 1
48357: PPUSH
48358: CALL_OW 255
48362: PPUSH
48363: CALL_OW 441
// end ; if btype = b_warehouse then
48367: LD_VAR 0 5
48371: PUSH
48372: LD_INT 1
48374: EQUAL
48375: IFFALSE 48393
// begin btype := b_depot ;
48377: LD_ADDR_VAR 0 5
48381: PUSH
48382: LD_INT 0
48384: ST_TO_ADDR
// pos := 1 ;
48385: LD_ADDR_VAR 0 6
48389: PUSH
48390: LD_INT 1
48392: ST_TO_ADDR
// end ; if btype = b_factory then
48393: LD_VAR 0 5
48397: PUSH
48398: LD_INT 3
48400: EQUAL
48401: IFFALSE 48419
// begin btype := b_workshop ;
48403: LD_ADDR_VAR 0 5
48407: PUSH
48408: LD_INT 2
48410: ST_TO_ADDR
// pos := 1 ;
48411: LD_ADDR_VAR 0 6
48415: PUSH
48416: LD_INT 1
48418: ST_TO_ADDR
// end ; if btype = b_barracks then
48419: LD_VAR 0 5
48423: PUSH
48424: LD_INT 5
48426: EQUAL
48427: IFFALSE 48437
// btype := b_armoury ;
48429: LD_ADDR_VAR 0 5
48433: PUSH
48434: LD_INT 4
48436: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48437: LD_VAR 0 5
48441: PUSH
48442: LD_INT 7
48444: PUSH
48445: LD_INT 8
48447: PUSH
48448: EMPTY
48449: LIST
48450: LIST
48451: IN
48452: IFFALSE 48462
// btype := b_lab ;
48454: LD_ADDR_VAR 0 5
48458: PUSH
48459: LD_INT 6
48461: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48462: LD_ADDR_EXP 84
48466: PUSH
48467: LD_EXP 84
48471: PPUSH
48472: LD_VAR 0 3
48476: PUSH
48477: LD_EXP 84
48481: PUSH
48482: LD_VAR 0 3
48486: ARRAY
48487: PUSH
48488: LD_INT 1
48490: PLUS
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: PPUSH
48496: LD_VAR 0 5
48500: PUSH
48501: LD_VAR 0 1
48505: PPUSH
48506: CALL_OW 250
48510: PUSH
48511: LD_VAR 0 1
48515: PPUSH
48516: CALL_OW 251
48520: PUSH
48521: LD_VAR 0 1
48525: PPUSH
48526: CALL_OW 254
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: PPUSH
48537: CALL 57793 0 3
48541: ST_TO_ADDR
// if pos = 1 then
48542: LD_VAR 0 6
48546: PUSH
48547: LD_INT 1
48549: EQUAL
48550: IFFALSE 48665
// begin tmp := mc_build_list [ i ] ;
48552: LD_ADDR_VAR 0 7
48556: PUSH
48557: LD_EXP 84
48561: PUSH
48562: LD_VAR 0 3
48566: ARRAY
48567: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48568: LD_VAR 0 7
48572: PPUSH
48573: LD_INT 2
48575: PUSH
48576: LD_INT 30
48578: PUSH
48579: LD_INT 0
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_INT 30
48588: PUSH
48589: LD_INT 1
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: LIST
48600: PPUSH
48601: CALL_OW 72
48605: IFFALSE 48615
// pos := 2 ;
48607: LD_ADDR_VAR 0 6
48611: PUSH
48612: LD_INT 2
48614: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48615: LD_ADDR_VAR 0 7
48619: PUSH
48620: LD_VAR 0 7
48624: PPUSH
48625: LD_VAR 0 6
48629: PPUSH
48630: LD_VAR 0 7
48634: PPUSH
48635: CALL 58119 0 3
48639: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48640: LD_ADDR_EXP 84
48644: PUSH
48645: LD_EXP 84
48649: PPUSH
48650: LD_VAR 0 3
48654: PPUSH
48655: LD_VAR 0 7
48659: PPUSH
48660: CALL_OW 1
48664: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48665: LD_VAR 0 1
48669: PUSH
48670: LD_EXP 79
48674: PUSH
48675: LD_VAR 0 3
48679: ARRAY
48680: IN
48681: IFFALSE 48720
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48683: LD_ADDR_EXP 79
48687: PUSH
48688: LD_EXP 79
48692: PPUSH
48693: LD_VAR 0 3
48697: PPUSH
48698: LD_EXP 79
48702: PUSH
48703: LD_VAR 0 3
48707: ARRAY
48708: PUSH
48709: LD_VAR 0 1
48713: DIFF
48714: PPUSH
48715: CALL_OW 1
48719: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48720: LD_VAR 0 1
48724: PUSH
48725: LD_EXP 86
48729: PUSH
48730: LD_VAR 0 3
48734: ARRAY
48735: IN
48736: IFFALSE 48775
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48738: LD_ADDR_EXP 86
48742: PUSH
48743: LD_EXP 86
48747: PPUSH
48748: LD_VAR 0 3
48752: PPUSH
48753: LD_EXP 86
48757: PUSH
48758: LD_VAR 0 3
48762: ARRAY
48763: PUSH
48764: LD_VAR 0 1
48768: DIFF
48769: PPUSH
48770: CALL_OW 1
48774: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48775: LD_VAR 0 1
48779: PUSH
48780: LD_EXP 98
48784: PUSH
48785: LD_VAR 0 3
48789: ARRAY
48790: IN
48791: IFFALSE 48830
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48793: LD_ADDR_EXP 98
48797: PUSH
48798: LD_EXP 98
48802: PPUSH
48803: LD_VAR 0 3
48807: PPUSH
48808: LD_EXP 98
48812: PUSH
48813: LD_VAR 0 3
48817: ARRAY
48818: PUSH
48819: LD_VAR 0 1
48823: DIFF
48824: PPUSH
48825: CALL_OW 1
48829: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48830: LD_VAR 0 1
48834: PUSH
48835: LD_EXP 101
48839: PUSH
48840: LD_VAR 0 3
48844: ARRAY
48845: IN
48846: IFFALSE 48885
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48848: LD_ADDR_EXP 101
48852: PUSH
48853: LD_EXP 101
48857: PPUSH
48858: LD_VAR 0 3
48862: PPUSH
48863: LD_EXP 101
48867: PUSH
48868: LD_VAR 0 3
48872: ARRAY
48873: PUSH
48874: LD_VAR 0 1
48878: DIFF
48879: PPUSH
48880: CALL_OW 1
48884: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48885: LD_VAR 0 1
48889: PUSH
48890: LD_EXP 88
48894: PUSH
48895: LD_VAR 0 3
48899: ARRAY
48900: IN
48901: IFFALSE 48940
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48903: LD_ADDR_EXP 88
48907: PUSH
48908: LD_EXP 88
48912: PPUSH
48913: LD_VAR 0 3
48917: PPUSH
48918: LD_EXP 88
48922: PUSH
48923: LD_VAR 0 3
48927: ARRAY
48928: PUSH
48929: LD_VAR 0 1
48933: DIFF
48934: PPUSH
48935: CALL_OW 1
48939: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48940: LD_VAR 0 1
48944: PUSH
48945: LD_EXP 87
48949: PUSH
48950: LD_VAR 0 3
48954: ARRAY
48955: IN
48956: IFFALSE 48995
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48958: LD_ADDR_EXP 87
48962: PUSH
48963: LD_EXP 87
48967: PPUSH
48968: LD_VAR 0 3
48972: PPUSH
48973: LD_EXP 87
48977: PUSH
48978: LD_VAR 0 3
48982: ARRAY
48983: PUSH
48984: LD_VAR 0 1
48988: DIFF
48989: PPUSH
48990: CALL_OW 1
48994: ST_TO_ADDR
// end ; break ;
48995: GO 48999
// end ;
48997: GO 47645
48999: POP
49000: POP
// end ;
49001: LD_VAR 0 2
49005: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49006: LD_INT 0
49008: PPUSH
49009: PPUSH
49010: PPUSH
// if not mc_bases or not skirmish then
49011: LD_EXP 79
49015: NOT
49016: PUSH
49017: LD_EXP 77
49021: NOT
49022: OR
49023: IFFALSE 49027
// exit ;
49025: GO 49242
// for i = 1 to mc_bases do
49027: LD_ADDR_VAR 0 3
49031: PUSH
49032: DOUBLE
49033: LD_INT 1
49035: DEC
49036: ST_TO_ADDR
49037: LD_EXP 79
49041: PUSH
49042: FOR_TO
49043: IFFALSE 49240
// begin if building in mc_construct_list [ i ] then
49045: LD_VAR 0 1
49049: PUSH
49050: LD_EXP 86
49054: PUSH
49055: LD_VAR 0 3
49059: ARRAY
49060: IN
49061: IFFALSE 49238
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49063: LD_ADDR_EXP 86
49067: PUSH
49068: LD_EXP 86
49072: PPUSH
49073: LD_VAR 0 3
49077: PPUSH
49078: LD_EXP 86
49082: PUSH
49083: LD_VAR 0 3
49087: ARRAY
49088: PUSH
49089: LD_VAR 0 1
49093: DIFF
49094: PPUSH
49095: CALL_OW 1
49099: ST_TO_ADDR
// if building in mc_lab [ i ] then
49100: LD_VAR 0 1
49104: PUSH
49105: LD_EXP 112
49109: PUSH
49110: LD_VAR 0 3
49114: ARRAY
49115: IN
49116: IFFALSE 49171
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49118: LD_ADDR_EXP 113
49122: PUSH
49123: LD_EXP 113
49127: PPUSH
49128: LD_VAR 0 3
49132: PPUSH
49133: LD_EXP 113
49137: PUSH
49138: LD_VAR 0 3
49142: ARRAY
49143: PPUSH
49144: LD_INT 1
49146: PPUSH
49147: LD_EXP 113
49151: PUSH
49152: LD_VAR 0 3
49156: ARRAY
49157: PPUSH
49158: LD_INT 0
49160: PPUSH
49161: CALL 57211 0 4
49165: PPUSH
49166: CALL_OW 1
49170: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49171: LD_VAR 0 1
49175: PUSH
49176: LD_EXP 79
49180: PUSH
49181: LD_VAR 0 3
49185: ARRAY
49186: IN
49187: NOT
49188: IFFALSE 49234
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49190: LD_ADDR_EXP 79
49194: PUSH
49195: LD_EXP 79
49199: PPUSH
49200: LD_VAR 0 3
49204: PUSH
49205: LD_EXP 79
49209: PUSH
49210: LD_VAR 0 3
49214: ARRAY
49215: PUSH
49216: LD_INT 1
49218: PLUS
49219: PUSH
49220: EMPTY
49221: LIST
49222: LIST
49223: PPUSH
49224: LD_VAR 0 1
49228: PPUSH
49229: CALL 57793 0 3
49233: ST_TO_ADDR
// exit ;
49234: POP
49235: POP
49236: GO 49242
// end ; end ;
49238: GO 49042
49240: POP
49241: POP
// end ;
49242: LD_VAR 0 2
49246: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49247: LD_INT 0
49249: PPUSH
49250: PPUSH
49251: PPUSH
49252: PPUSH
49253: PPUSH
49254: PPUSH
49255: PPUSH
// if not mc_bases or not skirmish then
49256: LD_EXP 79
49260: NOT
49261: PUSH
49262: LD_EXP 77
49266: NOT
49267: OR
49268: IFFALSE 49272
// exit ;
49270: GO 49933
// for i = 1 to mc_bases do
49272: LD_ADDR_VAR 0 3
49276: PUSH
49277: DOUBLE
49278: LD_INT 1
49280: DEC
49281: ST_TO_ADDR
49282: LD_EXP 79
49286: PUSH
49287: FOR_TO
49288: IFFALSE 49931
// begin if building in mc_construct_list [ i ] then
49290: LD_VAR 0 1
49294: PUSH
49295: LD_EXP 86
49299: PUSH
49300: LD_VAR 0 3
49304: ARRAY
49305: IN
49306: IFFALSE 49929
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49308: LD_ADDR_EXP 86
49312: PUSH
49313: LD_EXP 86
49317: PPUSH
49318: LD_VAR 0 3
49322: PPUSH
49323: LD_EXP 86
49327: PUSH
49328: LD_VAR 0 3
49332: ARRAY
49333: PUSH
49334: LD_VAR 0 1
49338: DIFF
49339: PPUSH
49340: CALL_OW 1
49344: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49345: LD_ADDR_EXP 79
49349: PUSH
49350: LD_EXP 79
49354: PPUSH
49355: LD_VAR 0 3
49359: PUSH
49360: LD_EXP 79
49364: PUSH
49365: LD_VAR 0 3
49369: ARRAY
49370: PUSH
49371: LD_INT 1
49373: PLUS
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PPUSH
49379: LD_VAR 0 1
49383: PPUSH
49384: CALL 57793 0 3
49388: ST_TO_ADDR
// btype := GetBType ( building ) ;
49389: LD_ADDR_VAR 0 5
49393: PUSH
49394: LD_VAR 0 1
49398: PPUSH
49399: CALL_OW 266
49403: ST_TO_ADDR
// side := GetSide ( building ) ;
49404: LD_ADDR_VAR 0 8
49408: PUSH
49409: LD_VAR 0 1
49413: PPUSH
49414: CALL_OW 255
49418: ST_TO_ADDR
// if btype = b_lab then
49419: LD_VAR 0 5
49423: PUSH
49424: LD_INT 6
49426: EQUAL
49427: IFFALSE 49477
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49429: LD_ADDR_EXP 112
49433: PUSH
49434: LD_EXP 112
49438: PPUSH
49439: LD_VAR 0 3
49443: PUSH
49444: LD_EXP 112
49448: PUSH
49449: LD_VAR 0 3
49453: ARRAY
49454: PUSH
49455: LD_INT 1
49457: PLUS
49458: PUSH
49459: EMPTY
49460: LIST
49461: LIST
49462: PPUSH
49463: LD_VAR 0 1
49467: PPUSH
49468: CALL 57793 0 3
49472: ST_TO_ADDR
// exit ;
49473: POP
49474: POP
49475: GO 49933
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49477: LD_VAR 0 5
49481: PUSH
49482: LD_INT 0
49484: PUSH
49485: LD_INT 2
49487: PUSH
49488: LD_INT 4
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: LIST
49495: IN
49496: IFFALSE 49620
// begin if btype = b_armoury then
49498: LD_VAR 0 5
49502: PUSH
49503: LD_INT 4
49505: EQUAL
49506: IFFALSE 49516
// btype := b_barracks ;
49508: LD_ADDR_VAR 0 5
49512: PUSH
49513: LD_INT 5
49515: ST_TO_ADDR
// if btype = b_depot then
49516: LD_VAR 0 5
49520: PUSH
49521: LD_INT 0
49523: EQUAL
49524: IFFALSE 49534
// btype := b_warehouse ;
49526: LD_ADDR_VAR 0 5
49530: PUSH
49531: LD_INT 1
49533: ST_TO_ADDR
// if btype = b_workshop then
49534: LD_VAR 0 5
49538: PUSH
49539: LD_INT 2
49541: EQUAL
49542: IFFALSE 49552
// btype := b_factory ;
49544: LD_ADDR_VAR 0 5
49548: PUSH
49549: LD_INT 3
49551: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49552: LD_VAR 0 5
49556: PPUSH
49557: LD_VAR 0 8
49561: PPUSH
49562: CALL_OW 323
49566: PUSH
49567: LD_INT 1
49569: EQUAL
49570: IFFALSE 49616
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49572: LD_ADDR_EXP 111
49576: PUSH
49577: LD_EXP 111
49581: PPUSH
49582: LD_VAR 0 3
49586: PUSH
49587: LD_EXP 111
49591: PUSH
49592: LD_VAR 0 3
49596: ARRAY
49597: PUSH
49598: LD_INT 1
49600: PLUS
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PPUSH
49606: LD_VAR 0 1
49610: PPUSH
49611: CALL 57793 0 3
49615: ST_TO_ADDR
// exit ;
49616: POP
49617: POP
49618: GO 49933
// end ; if btype in [ b_bunker , b_turret ] then
49620: LD_VAR 0 5
49624: PUSH
49625: LD_INT 32
49627: PUSH
49628: LD_INT 33
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: IN
49635: IFFALSE 49925
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49637: LD_ADDR_EXP 87
49641: PUSH
49642: LD_EXP 87
49646: PPUSH
49647: LD_VAR 0 3
49651: PUSH
49652: LD_EXP 87
49656: PUSH
49657: LD_VAR 0 3
49661: ARRAY
49662: PUSH
49663: LD_INT 1
49665: PLUS
49666: PUSH
49667: EMPTY
49668: LIST
49669: LIST
49670: PPUSH
49671: LD_VAR 0 1
49675: PPUSH
49676: CALL 57793 0 3
49680: ST_TO_ADDR
// if btype = b_bunker then
49681: LD_VAR 0 5
49685: PUSH
49686: LD_INT 32
49688: EQUAL
49689: IFFALSE 49925
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49691: LD_ADDR_EXP 88
49695: PUSH
49696: LD_EXP 88
49700: PPUSH
49701: LD_VAR 0 3
49705: PUSH
49706: LD_EXP 88
49710: PUSH
49711: LD_VAR 0 3
49715: ARRAY
49716: PUSH
49717: LD_INT 1
49719: PLUS
49720: PUSH
49721: EMPTY
49722: LIST
49723: LIST
49724: PPUSH
49725: LD_VAR 0 1
49729: PPUSH
49730: CALL 57793 0 3
49734: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49735: LD_ADDR_VAR 0 6
49739: PUSH
49740: LD_EXP 79
49744: PUSH
49745: LD_VAR 0 3
49749: ARRAY
49750: PPUSH
49751: LD_INT 25
49753: PUSH
49754: LD_INT 1
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 3
49763: PUSH
49764: LD_INT 54
49766: PUSH
49767: EMPTY
49768: LIST
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: PUSH
49774: EMPTY
49775: LIST
49776: LIST
49777: PPUSH
49778: CALL_OW 72
49782: ST_TO_ADDR
// if tmp then
49783: LD_VAR 0 6
49787: IFFALSE 49793
// exit ;
49789: POP
49790: POP
49791: GO 49933
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49793: LD_ADDR_VAR 0 6
49797: PUSH
49798: LD_EXP 79
49802: PUSH
49803: LD_VAR 0 3
49807: ARRAY
49808: PPUSH
49809: LD_INT 2
49811: PUSH
49812: LD_INT 30
49814: PUSH
49815: LD_INT 4
49817: PUSH
49818: EMPTY
49819: LIST
49820: LIST
49821: PUSH
49822: LD_INT 30
49824: PUSH
49825: LD_INT 5
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: LIST
49836: PPUSH
49837: CALL_OW 72
49841: ST_TO_ADDR
// if not tmp then
49842: LD_VAR 0 6
49846: NOT
49847: IFFALSE 49853
// exit ;
49849: POP
49850: POP
49851: GO 49933
// for j in tmp do
49853: LD_ADDR_VAR 0 4
49857: PUSH
49858: LD_VAR 0 6
49862: PUSH
49863: FOR_IN
49864: IFFALSE 49923
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49866: LD_ADDR_VAR 0 7
49870: PUSH
49871: LD_VAR 0 4
49875: PPUSH
49876: CALL_OW 313
49880: PPUSH
49881: LD_INT 25
49883: PUSH
49884: LD_INT 1
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: PPUSH
49891: CALL_OW 72
49895: ST_TO_ADDR
// if units then
49896: LD_VAR 0 7
49900: IFFALSE 49921
// begin ComExitBuilding ( units [ 1 ] ) ;
49902: LD_VAR 0 7
49906: PUSH
49907: LD_INT 1
49909: ARRAY
49910: PPUSH
49911: CALL_OW 122
// exit ;
49915: POP
49916: POP
49917: POP
49918: POP
49919: GO 49933
// end ; end ;
49921: GO 49863
49923: POP
49924: POP
// end ; end ; exit ;
49925: POP
49926: POP
49927: GO 49933
// end ; end ;
49929: GO 49287
49931: POP
49932: POP
// end ;
49933: LD_VAR 0 2
49937: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49938: LD_INT 0
49940: PPUSH
49941: PPUSH
49942: PPUSH
49943: PPUSH
49944: PPUSH
49945: PPUSH
49946: PPUSH
// if not mc_bases or not skirmish then
49947: LD_EXP 79
49951: NOT
49952: PUSH
49953: LD_EXP 77
49957: NOT
49958: OR
49959: IFFALSE 49963
// exit ;
49961: GO 50194
// btype := GetBType ( building ) ;
49963: LD_ADDR_VAR 0 6
49967: PUSH
49968: LD_VAR 0 1
49972: PPUSH
49973: CALL_OW 266
49977: ST_TO_ADDR
// x := GetX ( building ) ;
49978: LD_ADDR_VAR 0 7
49982: PUSH
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL_OW 250
49992: ST_TO_ADDR
// y := GetY ( building ) ;
49993: LD_ADDR_VAR 0 8
49997: PUSH
49998: LD_VAR 0 1
50002: PPUSH
50003: CALL_OW 251
50007: ST_TO_ADDR
// d := GetDir ( building ) ;
50008: LD_ADDR_VAR 0 9
50012: PUSH
50013: LD_VAR 0 1
50017: PPUSH
50018: CALL_OW 254
50022: ST_TO_ADDR
// for i = 1 to mc_bases do
50023: LD_ADDR_VAR 0 4
50027: PUSH
50028: DOUBLE
50029: LD_INT 1
50031: DEC
50032: ST_TO_ADDR
50033: LD_EXP 79
50037: PUSH
50038: FOR_TO
50039: IFFALSE 50192
// begin if not mc_build_list [ i ] then
50041: LD_EXP 84
50045: PUSH
50046: LD_VAR 0 4
50050: ARRAY
50051: NOT
50052: IFFALSE 50056
// continue ;
50054: GO 50038
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50056: LD_VAR 0 6
50060: PUSH
50061: LD_VAR 0 7
50065: PUSH
50066: LD_VAR 0 8
50070: PUSH
50071: LD_VAR 0 9
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: LIST
50080: LIST
50081: PPUSH
50082: LD_EXP 84
50086: PUSH
50087: LD_VAR 0 4
50091: ARRAY
50092: PUSH
50093: LD_INT 1
50095: ARRAY
50096: PPUSH
50097: CALL 63962 0 2
50101: IFFALSE 50190
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50103: LD_ADDR_EXP 84
50107: PUSH
50108: LD_EXP 84
50112: PPUSH
50113: LD_VAR 0 4
50117: PPUSH
50118: LD_EXP 84
50122: PUSH
50123: LD_VAR 0 4
50127: ARRAY
50128: PPUSH
50129: LD_INT 1
50131: PPUSH
50132: CALL_OW 3
50136: PPUSH
50137: CALL_OW 1
50141: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50142: LD_ADDR_EXP 86
50146: PUSH
50147: LD_EXP 86
50151: PPUSH
50152: LD_VAR 0 4
50156: PUSH
50157: LD_EXP 86
50161: PUSH
50162: LD_VAR 0 4
50166: ARRAY
50167: PUSH
50168: LD_INT 1
50170: PLUS
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: PPUSH
50176: LD_VAR 0 1
50180: PPUSH
50181: CALL 57793 0 3
50185: ST_TO_ADDR
// exit ;
50186: POP
50187: POP
50188: GO 50194
// end ; end ;
50190: GO 50038
50192: POP
50193: POP
// end ;
50194: LD_VAR 0 3
50198: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50199: LD_INT 0
50201: PPUSH
50202: PPUSH
50203: PPUSH
// if not mc_bases or not skirmish then
50204: LD_EXP 79
50208: NOT
50209: PUSH
50210: LD_EXP 77
50214: NOT
50215: OR
50216: IFFALSE 50220
// exit ;
50218: GO 50410
// for i = 1 to mc_bases do
50220: LD_ADDR_VAR 0 4
50224: PUSH
50225: DOUBLE
50226: LD_INT 1
50228: DEC
50229: ST_TO_ADDR
50230: LD_EXP 79
50234: PUSH
50235: FOR_TO
50236: IFFALSE 50323
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50238: LD_VAR 0 1
50242: PUSH
50243: LD_EXP 87
50247: PUSH
50248: LD_VAR 0 4
50252: ARRAY
50253: IN
50254: PUSH
50255: LD_VAR 0 1
50259: PUSH
50260: LD_EXP 88
50264: PUSH
50265: LD_VAR 0 4
50269: ARRAY
50270: IN
50271: NOT
50272: AND
50273: IFFALSE 50321
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50275: LD_ADDR_EXP 88
50279: PUSH
50280: LD_EXP 88
50284: PPUSH
50285: LD_VAR 0 4
50289: PUSH
50290: LD_EXP 88
50294: PUSH
50295: LD_VAR 0 4
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: PLUS
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: PPUSH
50309: LD_VAR 0 1
50313: PPUSH
50314: CALL 57793 0 3
50318: ST_TO_ADDR
// break ;
50319: GO 50323
// end ; end ;
50321: GO 50235
50323: POP
50324: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50325: LD_VAR 0 1
50329: PPUSH
50330: CALL_OW 257
50334: PUSH
50335: LD_EXP 105
50339: IN
50340: PUSH
50341: LD_VAR 0 1
50345: PPUSH
50346: CALL_OW 266
50350: PUSH
50351: LD_INT 5
50353: EQUAL
50354: AND
50355: PUSH
50356: LD_VAR 0 2
50360: PPUSH
50361: CALL_OW 110
50365: PUSH
50366: LD_INT 18
50368: NONEQUAL
50369: AND
50370: IFFALSE 50410
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50372: LD_VAR 0 2
50376: PPUSH
50377: CALL_OW 257
50381: PUSH
50382: LD_INT 5
50384: PUSH
50385: LD_INT 8
50387: PUSH
50388: LD_INT 9
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: LIST
50395: IN
50396: IFFALSE 50410
// SetClass ( unit , 1 ) ;
50398: LD_VAR 0 2
50402: PPUSH
50403: LD_INT 1
50405: PPUSH
50406: CALL_OW 336
// end ;
50410: LD_VAR 0 3
50414: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50415: LD_INT 0
50417: PPUSH
50418: PPUSH
// if not mc_bases or not skirmish then
50419: LD_EXP 79
50423: NOT
50424: PUSH
50425: LD_EXP 77
50429: NOT
50430: OR
50431: IFFALSE 50435
// exit ;
50433: GO 50551
// if GetLives ( abandoned_vehicle ) > 250 then
50435: LD_VAR 0 2
50439: PPUSH
50440: CALL_OW 256
50444: PUSH
50445: LD_INT 250
50447: GREATER
50448: IFFALSE 50452
// exit ;
50450: GO 50551
// for i = 1 to mc_bases do
50452: LD_ADDR_VAR 0 6
50456: PUSH
50457: DOUBLE
50458: LD_INT 1
50460: DEC
50461: ST_TO_ADDR
50462: LD_EXP 79
50466: PUSH
50467: FOR_TO
50468: IFFALSE 50549
// begin if driver in mc_bases [ i ] then
50470: LD_VAR 0 1
50474: PUSH
50475: LD_EXP 79
50479: PUSH
50480: LD_VAR 0 6
50484: ARRAY
50485: IN
50486: IFFALSE 50547
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50488: LD_VAR 0 1
50492: PPUSH
50493: LD_EXP 79
50497: PUSH
50498: LD_VAR 0 6
50502: ARRAY
50503: PPUSH
50504: LD_INT 2
50506: PUSH
50507: LD_INT 30
50509: PUSH
50510: LD_INT 0
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 30
50519: PUSH
50520: LD_INT 1
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: LIST
50531: PPUSH
50532: CALL_OW 72
50536: PUSH
50537: LD_INT 1
50539: ARRAY
50540: PPUSH
50541: CALL_OW 112
// break ;
50545: GO 50549
// end ; end ;
50547: GO 50467
50549: POP
50550: POP
// end ; end_of_file
50551: LD_VAR 0 5
50555: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50556: LD_INT 0
50558: PPUSH
50559: PPUSH
// if exist_mode then
50560: LD_VAR 0 2
50564: IFFALSE 50589
// unit := CreateCharacter ( prefix & ident ) else
50566: LD_ADDR_VAR 0 5
50570: PUSH
50571: LD_VAR 0 3
50575: PUSH
50576: LD_VAR 0 1
50580: STR
50581: PPUSH
50582: CALL_OW 34
50586: ST_TO_ADDR
50587: GO 50604
// unit := NewCharacter ( ident ) ;
50589: LD_ADDR_VAR 0 5
50593: PUSH
50594: LD_VAR 0 1
50598: PPUSH
50599: CALL_OW 25
50603: ST_TO_ADDR
// result := unit ;
50604: LD_ADDR_VAR 0 4
50608: PUSH
50609: LD_VAR 0 5
50613: ST_TO_ADDR
// end ;
50614: LD_VAR 0 4
50618: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50619: LD_INT 0
50621: PPUSH
50622: PPUSH
// if not side or not nation then
50623: LD_VAR 0 1
50627: NOT
50628: PUSH
50629: LD_VAR 0 2
50633: NOT
50634: OR
50635: IFFALSE 50639
// exit ;
50637: GO 51283
// case nation of nation_american :
50639: LD_VAR 0 2
50643: PUSH
50644: LD_INT 1
50646: DOUBLE
50647: EQUAL
50648: IFTRUE 50652
50650: GO 50826
50652: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50653: LD_ADDR_VAR 0 4
50657: PUSH
50658: LD_INT 35
50660: PUSH
50661: LD_INT 45
50663: PUSH
50664: LD_INT 46
50666: PUSH
50667: LD_INT 47
50669: PUSH
50670: LD_INT 1
50672: PUSH
50673: LD_INT 2
50675: PUSH
50676: LD_INT 6
50678: PUSH
50679: LD_INT 15
50681: PUSH
50682: LD_INT 16
50684: PUSH
50685: LD_INT 7
50687: PUSH
50688: LD_INT 12
50690: PUSH
50691: LD_INT 13
50693: PUSH
50694: LD_INT 10
50696: PUSH
50697: LD_INT 14
50699: PUSH
50700: LD_INT 20
50702: PUSH
50703: LD_INT 21
50705: PUSH
50706: LD_INT 22
50708: PUSH
50709: LD_INT 25
50711: PUSH
50712: LD_INT 32
50714: PUSH
50715: LD_INT 27
50717: PUSH
50718: LD_INT 36
50720: PUSH
50721: LD_INT 69
50723: PUSH
50724: LD_INT 39
50726: PUSH
50727: LD_INT 34
50729: PUSH
50730: LD_INT 40
50732: PUSH
50733: LD_INT 48
50735: PUSH
50736: LD_INT 49
50738: PUSH
50739: LD_INT 50
50741: PUSH
50742: LD_INT 51
50744: PUSH
50745: LD_INT 52
50747: PUSH
50748: LD_INT 53
50750: PUSH
50751: LD_INT 54
50753: PUSH
50754: LD_INT 55
50756: PUSH
50757: LD_INT 56
50759: PUSH
50760: LD_INT 57
50762: PUSH
50763: LD_INT 58
50765: PUSH
50766: LD_INT 59
50768: PUSH
50769: LD_INT 60
50771: PUSH
50772: LD_INT 61
50774: PUSH
50775: LD_INT 62
50777: PUSH
50778: LD_INT 80
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: LIST
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: LIST
50797: LIST
50798: LIST
50799: LIST
50800: LIST
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: ST_TO_ADDR
50824: GO 51207
50826: LD_INT 2
50828: DOUBLE
50829: EQUAL
50830: IFTRUE 50834
50832: GO 51016
50834: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50835: LD_ADDR_VAR 0 4
50839: PUSH
50840: LD_INT 35
50842: PUSH
50843: LD_INT 45
50845: PUSH
50846: LD_INT 46
50848: PUSH
50849: LD_INT 47
50851: PUSH
50852: LD_INT 70
50854: PUSH
50855: LD_INT 1
50857: PUSH
50858: LD_INT 11
50860: PUSH
50861: LD_INT 3
50863: PUSH
50864: LD_INT 4
50866: PUSH
50867: LD_INT 5
50869: PUSH
50870: LD_INT 6
50872: PUSH
50873: LD_INT 15
50875: PUSH
50876: LD_INT 18
50878: PUSH
50879: LD_INT 7
50881: PUSH
50882: LD_INT 17
50884: PUSH
50885: LD_INT 8
50887: PUSH
50888: LD_INT 20
50890: PUSH
50891: LD_INT 21
50893: PUSH
50894: LD_INT 22
50896: PUSH
50897: LD_INT 72
50899: PUSH
50900: LD_INT 26
50902: PUSH
50903: LD_INT 69
50905: PUSH
50906: LD_INT 39
50908: PUSH
50909: LD_INT 40
50911: PUSH
50912: LD_INT 41
50914: PUSH
50915: LD_INT 42
50917: PUSH
50918: LD_INT 43
50920: PUSH
50921: LD_INT 48
50923: PUSH
50924: LD_INT 49
50926: PUSH
50927: LD_INT 50
50929: PUSH
50930: LD_INT 51
50932: PUSH
50933: LD_INT 52
50935: PUSH
50936: LD_INT 53
50938: PUSH
50939: LD_INT 54
50941: PUSH
50942: LD_INT 55
50944: PUSH
50945: LD_INT 56
50947: PUSH
50948: LD_INT 60
50950: PUSH
50951: LD_INT 61
50953: PUSH
50954: LD_INT 62
50956: PUSH
50957: LD_INT 66
50959: PUSH
50960: LD_INT 67
50962: PUSH
50963: LD_INT 68
50965: PUSH
50966: LD_INT 81
50968: PUSH
50969: EMPTY
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: LIST
50992: LIST
50993: LIST
50994: LIST
50995: LIST
50996: LIST
50997: LIST
50998: LIST
50999: LIST
51000: LIST
51001: LIST
51002: LIST
51003: LIST
51004: LIST
51005: LIST
51006: LIST
51007: LIST
51008: LIST
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: ST_TO_ADDR
51014: GO 51207
51016: LD_INT 3
51018: DOUBLE
51019: EQUAL
51020: IFTRUE 51024
51022: GO 51206
51024: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
51025: LD_ADDR_VAR 0 4
51029: PUSH
51030: LD_INT 46
51032: PUSH
51033: LD_INT 47
51035: PUSH
51036: LD_INT 1
51038: PUSH
51039: LD_INT 2
51041: PUSH
51042: LD_INT 11
51044: PUSH
51045: LD_INT 9
51047: PUSH
51048: LD_INT 20
51050: PUSH
51051: LD_INT 19
51053: PUSH
51054: LD_INT 21
51056: PUSH
51057: LD_INT 24
51059: PUSH
51060: LD_INT 22
51062: PUSH
51063: LD_INT 25
51065: PUSH
51066: LD_INT 28
51068: PUSH
51069: LD_INT 29
51071: PUSH
51072: LD_INT 30
51074: PUSH
51075: LD_INT 31
51077: PUSH
51078: LD_INT 37
51080: PUSH
51081: LD_INT 38
51083: PUSH
51084: LD_INT 32
51086: PUSH
51087: LD_INT 27
51089: PUSH
51090: LD_INT 33
51092: PUSH
51093: LD_INT 69
51095: PUSH
51096: LD_INT 39
51098: PUSH
51099: LD_INT 34
51101: PUSH
51102: LD_INT 40
51104: PUSH
51105: LD_INT 71
51107: PUSH
51108: LD_INT 23
51110: PUSH
51111: LD_INT 44
51113: PUSH
51114: LD_INT 48
51116: PUSH
51117: LD_INT 49
51119: PUSH
51120: LD_INT 50
51122: PUSH
51123: LD_INT 51
51125: PUSH
51126: LD_INT 52
51128: PUSH
51129: LD_INT 53
51131: PUSH
51132: LD_INT 54
51134: PUSH
51135: LD_INT 55
51137: PUSH
51138: LD_INT 56
51140: PUSH
51141: LD_INT 57
51143: PUSH
51144: LD_INT 58
51146: PUSH
51147: LD_INT 59
51149: PUSH
51150: LD_INT 63
51152: PUSH
51153: LD_INT 64
51155: PUSH
51156: LD_INT 65
51158: PUSH
51159: EMPTY
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: LIST
51200: LIST
51201: LIST
51202: LIST
51203: ST_TO_ADDR
51204: GO 51207
51206: POP
// if state > - 1 and state < 3 then
51207: LD_VAR 0 3
51211: PUSH
51212: LD_INT 1
51214: NEG
51215: GREATER
51216: PUSH
51217: LD_VAR 0 3
51221: PUSH
51222: LD_INT 3
51224: LESS
51225: AND
51226: IFFALSE 51283
// for i in result do
51228: LD_ADDR_VAR 0 5
51232: PUSH
51233: LD_VAR 0 4
51237: PUSH
51238: FOR_IN
51239: IFFALSE 51281
// if GetTech ( i , side ) <> state then
51241: LD_VAR 0 5
51245: PPUSH
51246: LD_VAR 0 1
51250: PPUSH
51251: CALL_OW 321
51255: PUSH
51256: LD_VAR 0 3
51260: NONEQUAL
51261: IFFALSE 51279
// result := result diff i ;
51263: LD_ADDR_VAR 0 4
51267: PUSH
51268: LD_VAR 0 4
51272: PUSH
51273: LD_VAR 0 5
51277: DIFF
51278: ST_TO_ADDR
51279: GO 51238
51281: POP
51282: POP
// end ;
51283: LD_VAR 0 4
51287: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51288: LD_INT 0
51290: PPUSH
51291: PPUSH
51292: PPUSH
// result := true ;
51293: LD_ADDR_VAR 0 3
51297: PUSH
51298: LD_INT 1
51300: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51301: LD_ADDR_VAR 0 5
51305: PUSH
51306: LD_VAR 0 2
51310: PPUSH
51311: CALL_OW 480
51315: ST_TO_ADDR
// if not tmp then
51316: LD_VAR 0 5
51320: NOT
51321: IFFALSE 51325
// exit ;
51323: GO 51374
// for i in tmp do
51325: LD_ADDR_VAR 0 4
51329: PUSH
51330: LD_VAR 0 5
51334: PUSH
51335: FOR_IN
51336: IFFALSE 51372
// if GetTech ( i , side ) <> state_researched then
51338: LD_VAR 0 4
51342: PPUSH
51343: LD_VAR 0 1
51347: PPUSH
51348: CALL_OW 321
51352: PUSH
51353: LD_INT 2
51355: NONEQUAL
51356: IFFALSE 51370
// begin result := false ;
51358: LD_ADDR_VAR 0 3
51362: PUSH
51363: LD_INT 0
51365: ST_TO_ADDR
// exit ;
51366: POP
51367: POP
51368: GO 51374
// end ;
51370: GO 51335
51372: POP
51373: POP
// end ;
51374: LD_VAR 0 3
51378: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51379: LD_INT 0
51381: PPUSH
51382: PPUSH
51383: PPUSH
51384: PPUSH
51385: PPUSH
51386: PPUSH
51387: PPUSH
51388: PPUSH
51389: PPUSH
51390: PPUSH
51391: PPUSH
51392: PPUSH
51393: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51394: LD_VAR 0 1
51398: NOT
51399: PUSH
51400: LD_VAR 0 1
51404: PPUSH
51405: CALL_OW 257
51409: PUSH
51410: LD_INT 9
51412: NONEQUAL
51413: OR
51414: IFFALSE 51418
// exit ;
51416: GO 51991
// side := GetSide ( unit ) ;
51418: LD_ADDR_VAR 0 9
51422: PUSH
51423: LD_VAR 0 1
51427: PPUSH
51428: CALL_OW 255
51432: ST_TO_ADDR
// tech_space := tech_spacanom ;
51433: LD_ADDR_VAR 0 12
51437: PUSH
51438: LD_INT 29
51440: ST_TO_ADDR
// tech_time := tech_taurad ;
51441: LD_ADDR_VAR 0 13
51445: PUSH
51446: LD_INT 28
51448: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51449: LD_ADDR_VAR 0 11
51453: PUSH
51454: LD_VAR 0 1
51458: PPUSH
51459: CALL_OW 310
51463: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51464: LD_VAR 0 11
51468: PPUSH
51469: CALL_OW 247
51473: PUSH
51474: LD_INT 2
51476: EQUAL
51477: IFFALSE 51481
// exit ;
51479: GO 51991
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51481: LD_ADDR_VAR 0 8
51485: PUSH
51486: LD_INT 81
51488: PUSH
51489: LD_VAR 0 9
51493: PUSH
51494: EMPTY
51495: LIST
51496: LIST
51497: PUSH
51498: LD_INT 3
51500: PUSH
51501: LD_INT 21
51503: PUSH
51504: LD_INT 3
51506: PUSH
51507: EMPTY
51508: LIST
51509: LIST
51510: PUSH
51511: EMPTY
51512: LIST
51513: LIST
51514: PUSH
51515: EMPTY
51516: LIST
51517: LIST
51518: PPUSH
51519: CALL_OW 69
51523: ST_TO_ADDR
// if not tmp then
51524: LD_VAR 0 8
51528: NOT
51529: IFFALSE 51533
// exit ;
51531: GO 51991
// if in_unit then
51533: LD_VAR 0 11
51537: IFFALSE 51561
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51539: LD_ADDR_VAR 0 10
51543: PUSH
51544: LD_VAR 0 8
51548: PPUSH
51549: LD_VAR 0 11
51553: PPUSH
51554: CALL_OW 74
51558: ST_TO_ADDR
51559: GO 51581
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51561: LD_ADDR_VAR 0 10
51565: PUSH
51566: LD_VAR 0 8
51570: PPUSH
51571: LD_VAR 0 1
51575: PPUSH
51576: CALL_OW 74
51580: ST_TO_ADDR
// if not enemy then
51581: LD_VAR 0 10
51585: NOT
51586: IFFALSE 51590
// exit ;
51588: GO 51991
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51590: LD_VAR 0 11
51594: PUSH
51595: LD_VAR 0 11
51599: PPUSH
51600: LD_VAR 0 10
51604: PPUSH
51605: CALL_OW 296
51609: PUSH
51610: LD_INT 13
51612: GREATER
51613: AND
51614: PUSH
51615: LD_VAR 0 1
51619: PPUSH
51620: LD_VAR 0 10
51624: PPUSH
51625: CALL_OW 296
51629: PUSH
51630: LD_INT 12
51632: GREATER
51633: OR
51634: IFFALSE 51638
// exit ;
51636: GO 51991
// missile := [ 1 ] ;
51638: LD_ADDR_VAR 0 14
51642: PUSH
51643: LD_INT 1
51645: PUSH
51646: EMPTY
51647: LIST
51648: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51649: LD_VAR 0 9
51653: PPUSH
51654: LD_VAR 0 12
51658: PPUSH
51659: CALL_OW 325
51663: IFFALSE 51692
// missile := Insert ( missile , missile + 1 , 2 ) ;
51665: LD_ADDR_VAR 0 14
51669: PUSH
51670: LD_VAR 0 14
51674: PPUSH
51675: LD_VAR 0 14
51679: PUSH
51680: LD_INT 1
51682: PLUS
51683: PPUSH
51684: LD_INT 2
51686: PPUSH
51687: CALL_OW 2
51691: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51692: LD_VAR 0 9
51696: PPUSH
51697: LD_VAR 0 13
51701: PPUSH
51702: CALL_OW 325
51706: PUSH
51707: LD_VAR 0 10
51711: PPUSH
51712: CALL_OW 255
51716: PPUSH
51717: LD_VAR 0 13
51721: PPUSH
51722: CALL_OW 325
51726: NOT
51727: AND
51728: IFFALSE 51757
// missile := Insert ( missile , missile + 1 , 3 ) ;
51730: LD_ADDR_VAR 0 14
51734: PUSH
51735: LD_VAR 0 14
51739: PPUSH
51740: LD_VAR 0 14
51744: PUSH
51745: LD_INT 1
51747: PLUS
51748: PPUSH
51749: LD_INT 3
51751: PPUSH
51752: CALL_OW 2
51756: ST_TO_ADDR
// if missile < 2 then
51757: LD_VAR 0 14
51761: PUSH
51762: LD_INT 2
51764: LESS
51765: IFFALSE 51769
// exit ;
51767: GO 51991
// x := GetX ( enemy ) ;
51769: LD_ADDR_VAR 0 4
51773: PUSH
51774: LD_VAR 0 10
51778: PPUSH
51779: CALL_OW 250
51783: ST_TO_ADDR
// y := GetY ( enemy ) ;
51784: LD_ADDR_VAR 0 5
51788: PUSH
51789: LD_VAR 0 10
51793: PPUSH
51794: CALL_OW 251
51798: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51799: LD_ADDR_VAR 0 6
51803: PUSH
51804: LD_VAR 0 4
51808: PUSH
51809: LD_INT 1
51811: NEG
51812: PPUSH
51813: LD_INT 1
51815: PPUSH
51816: CALL_OW 12
51820: PLUS
51821: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51822: LD_ADDR_VAR 0 7
51826: PUSH
51827: LD_VAR 0 5
51831: PUSH
51832: LD_INT 1
51834: NEG
51835: PPUSH
51836: LD_INT 1
51838: PPUSH
51839: CALL_OW 12
51843: PLUS
51844: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51845: LD_VAR 0 6
51849: PPUSH
51850: LD_VAR 0 7
51854: PPUSH
51855: CALL_OW 488
51859: NOT
51860: IFFALSE 51882
// begin _x := x ;
51862: LD_ADDR_VAR 0 6
51866: PUSH
51867: LD_VAR 0 4
51871: ST_TO_ADDR
// _y := y ;
51872: LD_ADDR_VAR 0 7
51876: PUSH
51877: LD_VAR 0 5
51881: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51882: LD_ADDR_VAR 0 3
51886: PUSH
51887: LD_INT 1
51889: PPUSH
51890: LD_VAR 0 14
51894: PPUSH
51895: CALL_OW 12
51899: ST_TO_ADDR
// case i of 1 :
51900: LD_VAR 0 3
51904: PUSH
51905: LD_INT 1
51907: DOUBLE
51908: EQUAL
51909: IFTRUE 51913
51911: GO 51930
51913: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51914: LD_VAR 0 1
51918: PPUSH
51919: LD_VAR 0 10
51923: PPUSH
51924: CALL_OW 115
51928: GO 51991
51930: LD_INT 2
51932: DOUBLE
51933: EQUAL
51934: IFTRUE 51938
51936: GO 51960
51938: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51939: LD_VAR 0 1
51943: PPUSH
51944: LD_VAR 0 6
51948: PPUSH
51949: LD_VAR 0 7
51953: PPUSH
51954: CALL_OW 153
51958: GO 51991
51960: LD_INT 3
51962: DOUBLE
51963: EQUAL
51964: IFTRUE 51968
51966: GO 51990
51968: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51969: LD_VAR 0 1
51973: PPUSH
51974: LD_VAR 0 6
51978: PPUSH
51979: LD_VAR 0 7
51983: PPUSH
51984: CALL_OW 154
51988: GO 51991
51990: POP
// end ;
51991: LD_VAR 0 2
51995: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51996: LD_INT 0
51998: PPUSH
51999: PPUSH
52000: PPUSH
52001: PPUSH
52002: PPUSH
52003: PPUSH
// if not unit or not building then
52004: LD_VAR 0 1
52008: NOT
52009: PUSH
52010: LD_VAR 0 2
52014: NOT
52015: OR
52016: IFFALSE 52020
// exit ;
52018: GO 52178
// x := GetX ( building ) ;
52020: LD_ADDR_VAR 0 5
52024: PUSH
52025: LD_VAR 0 2
52029: PPUSH
52030: CALL_OW 250
52034: ST_TO_ADDR
// y := GetY ( building ) ;
52035: LD_ADDR_VAR 0 6
52039: PUSH
52040: LD_VAR 0 2
52044: PPUSH
52045: CALL_OW 251
52049: ST_TO_ADDR
// for i = 0 to 5 do
52050: LD_ADDR_VAR 0 4
52054: PUSH
52055: DOUBLE
52056: LD_INT 0
52058: DEC
52059: ST_TO_ADDR
52060: LD_INT 5
52062: PUSH
52063: FOR_TO
52064: IFFALSE 52176
// begin _x := ShiftX ( x , i , 3 ) ;
52066: LD_ADDR_VAR 0 7
52070: PUSH
52071: LD_VAR 0 5
52075: PPUSH
52076: LD_VAR 0 4
52080: PPUSH
52081: LD_INT 3
52083: PPUSH
52084: CALL_OW 272
52088: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52089: LD_ADDR_VAR 0 8
52093: PUSH
52094: LD_VAR 0 6
52098: PPUSH
52099: LD_VAR 0 4
52103: PPUSH
52104: LD_INT 3
52106: PPUSH
52107: CALL_OW 273
52111: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52112: LD_VAR 0 7
52116: PPUSH
52117: LD_VAR 0 8
52121: PPUSH
52122: CALL_OW 488
52126: NOT
52127: IFFALSE 52131
// continue ;
52129: GO 52063
// if HexInfo ( _x , _y ) = 0 then
52131: LD_VAR 0 7
52135: PPUSH
52136: LD_VAR 0 8
52140: PPUSH
52141: CALL_OW 428
52145: PUSH
52146: LD_INT 0
52148: EQUAL
52149: IFFALSE 52174
// begin ComMoveXY ( unit , _x , _y ) ;
52151: LD_VAR 0 1
52155: PPUSH
52156: LD_VAR 0 7
52160: PPUSH
52161: LD_VAR 0 8
52165: PPUSH
52166: CALL_OW 111
// exit ;
52170: POP
52171: POP
52172: GO 52178
// end ; end ;
52174: GO 52063
52176: POP
52177: POP
// end ;
52178: LD_VAR 0 3
52182: RET
// export function ScanBase ( side , base_area ) ; begin
52183: LD_INT 0
52185: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52186: LD_ADDR_VAR 0 3
52190: PUSH
52191: LD_VAR 0 2
52195: PPUSH
52196: LD_INT 81
52198: PUSH
52199: LD_VAR 0 1
52203: PUSH
52204: EMPTY
52205: LIST
52206: LIST
52207: PPUSH
52208: CALL_OW 70
52212: ST_TO_ADDR
// end ;
52213: LD_VAR 0 3
52217: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52218: LD_INT 0
52220: PPUSH
52221: PPUSH
52222: PPUSH
52223: PPUSH
52224: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52225: LD_VAR 0 1
52229: NOT
52230: PUSH
52231: LD_EXP 79
52235: PUSH
52236: LD_VAR 0 1
52240: ARRAY
52241: NOT
52242: OR
52243: PUSH
52244: LD_VAR 0 2
52248: NOT
52249: OR
52250: PUSH
52251: LD_VAR 0 3
52255: NOT
52256: OR
52257: IFFALSE 52261
// exit ;
52259: GO 52774
// side := mc_sides [ base ] ;
52261: LD_ADDR_VAR 0 6
52265: PUSH
52266: LD_EXP 105
52270: PUSH
52271: LD_VAR 0 1
52275: ARRAY
52276: ST_TO_ADDR
// if not side then
52277: LD_VAR 0 6
52281: NOT
52282: IFFALSE 52286
// exit ;
52284: GO 52774
// for i in solds do
52286: LD_ADDR_VAR 0 7
52290: PUSH
52291: LD_VAR 0 2
52295: PUSH
52296: FOR_IN
52297: IFFALSE 52358
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52299: LD_VAR 0 7
52303: PPUSH
52304: CALL_OW 310
52308: PPUSH
52309: CALL_OW 266
52313: PUSH
52314: LD_INT 32
52316: PUSH
52317: LD_INT 31
52319: PUSH
52320: EMPTY
52321: LIST
52322: LIST
52323: IN
52324: IFFALSE 52344
// solds := solds diff i else
52326: LD_ADDR_VAR 0 2
52330: PUSH
52331: LD_VAR 0 2
52335: PUSH
52336: LD_VAR 0 7
52340: DIFF
52341: ST_TO_ADDR
52342: GO 52356
// SetTag ( i , 18 ) ;
52344: LD_VAR 0 7
52348: PPUSH
52349: LD_INT 18
52351: PPUSH
52352: CALL_OW 109
52356: GO 52296
52358: POP
52359: POP
// if not solds then
52360: LD_VAR 0 2
52364: NOT
52365: IFFALSE 52369
// exit ;
52367: GO 52774
// repeat wait ( 0 0$1 ) ;
52369: LD_INT 35
52371: PPUSH
52372: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52376: LD_ADDR_VAR 0 5
52380: PUSH
52381: LD_VAR 0 6
52385: PPUSH
52386: LD_VAR 0 3
52390: PPUSH
52391: CALL 52183 0 2
52395: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52396: LD_EXP 79
52400: PUSH
52401: LD_VAR 0 1
52405: ARRAY
52406: NOT
52407: PUSH
52408: LD_EXP 79
52412: PUSH
52413: LD_VAR 0 1
52417: ARRAY
52418: PUSH
52419: EMPTY
52420: EQUAL
52421: OR
52422: IFFALSE 52459
// begin for i in solds do
52424: LD_ADDR_VAR 0 7
52428: PUSH
52429: LD_VAR 0 2
52433: PUSH
52434: FOR_IN
52435: IFFALSE 52448
// ComStop ( i ) ;
52437: LD_VAR 0 7
52441: PPUSH
52442: CALL_OW 141
52446: GO 52434
52448: POP
52449: POP
// solds := [ ] ;
52450: LD_ADDR_VAR 0 2
52454: PUSH
52455: EMPTY
52456: ST_TO_ADDR
// exit ;
52457: GO 52774
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52459: LD_VAR 0 5
52463: NOT
52464: PUSH
52465: LD_VAR 0 5
52469: PUSH
52470: LD_INT 3
52472: GREATER
52473: OR
52474: PUSH
52475: LD_EXP 101
52479: PUSH
52480: LD_VAR 0 1
52484: ARRAY
52485: OR
52486: IFFALSE 52527
// begin for i in solds do
52488: LD_ADDR_VAR 0 7
52492: PUSH
52493: LD_VAR 0 2
52497: PUSH
52498: FOR_IN
52499: IFFALSE 52523
// if HasTask ( i ) then
52501: LD_VAR 0 7
52505: PPUSH
52506: CALL_OW 314
52510: IFFALSE 52521
// ComStop ( i ) ;
52512: LD_VAR 0 7
52516: PPUSH
52517: CALL_OW 141
52521: GO 52498
52523: POP
52524: POP
// break ;
52525: GO 52762
// end ; for i in solds do
52527: LD_ADDR_VAR 0 7
52531: PUSH
52532: LD_VAR 0 2
52536: PUSH
52537: FOR_IN
52538: IFFALSE 52754
// begin if IsInUnit ( i ) then
52540: LD_VAR 0 7
52544: PPUSH
52545: CALL_OW 310
52549: IFFALSE 52560
// ComExitBuilding ( i ) ;
52551: LD_VAR 0 7
52555: PPUSH
52556: CALL_OW 122
// if GetLives ( i ) > 333 then
52560: LD_VAR 0 7
52564: PPUSH
52565: CALL_OW 256
52569: PUSH
52570: LD_INT 333
52572: GREATER
52573: IFFALSE 52601
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52575: LD_VAR 0 7
52579: PPUSH
52580: LD_VAR 0 5
52584: PPUSH
52585: LD_VAR 0 7
52589: PPUSH
52590: CALL_OW 74
52594: PPUSH
52595: CALL_OW 115
52599: GO 52752
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52601: LD_ADDR_VAR 0 8
52605: PUSH
52606: LD_EXP 79
52610: PUSH
52611: LD_VAR 0 1
52615: ARRAY
52616: PPUSH
52617: LD_INT 2
52619: PUSH
52620: LD_INT 30
52622: PUSH
52623: LD_INT 0
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: PUSH
52630: LD_INT 30
52632: PUSH
52633: LD_INT 1
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: PUSH
52640: LD_INT 30
52642: PUSH
52643: LD_INT 6
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PUSH
52650: EMPTY
52651: LIST
52652: LIST
52653: LIST
52654: LIST
52655: PPUSH
52656: CALL_OW 72
52660: PPUSH
52661: LD_VAR 0 7
52665: PPUSH
52666: CALL_OW 74
52670: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52671: LD_VAR 0 7
52675: PPUSH
52676: LD_VAR 0 8
52680: PPUSH
52681: CALL_OW 250
52685: PPUSH
52686: LD_INT 3
52688: PPUSH
52689: LD_INT 5
52691: PPUSH
52692: CALL_OW 272
52696: PPUSH
52697: LD_VAR 0 8
52701: PPUSH
52702: CALL_OW 251
52706: PPUSH
52707: LD_INT 3
52709: PPUSH
52710: LD_INT 5
52712: PPUSH
52713: CALL_OW 273
52717: PPUSH
52718: CALL_OW 111
// SetTag ( i , 0 ) ;
52722: LD_VAR 0 7
52726: PPUSH
52727: LD_INT 0
52729: PPUSH
52730: CALL_OW 109
// solds := solds diff i ;
52734: LD_ADDR_VAR 0 2
52738: PUSH
52739: LD_VAR 0 2
52743: PUSH
52744: LD_VAR 0 7
52748: DIFF
52749: ST_TO_ADDR
// continue ;
52750: GO 52537
// end ; end ;
52752: GO 52537
52754: POP
52755: POP
// until solds ;
52756: LD_VAR 0 2
52760: IFFALSE 52369
// MC_Reset ( base , 18 ) ;
52762: LD_VAR 0 1
52766: PPUSH
52767: LD_INT 18
52769: PPUSH
52770: CALL 24595 0 2
// end ;
52774: LD_VAR 0 4
52778: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52779: LD_INT 0
52781: PPUSH
52782: PPUSH
52783: PPUSH
52784: PPUSH
52785: PPUSH
52786: PPUSH
52787: PPUSH
52788: PPUSH
52789: PPUSH
52790: PPUSH
52791: PPUSH
52792: PPUSH
52793: PPUSH
52794: PPUSH
52795: PPUSH
52796: PPUSH
52797: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52798: LD_ADDR_VAR 0 13
52802: PUSH
52803: LD_EXP 79
52807: PUSH
52808: LD_VAR 0 1
52812: ARRAY
52813: PPUSH
52814: LD_INT 25
52816: PUSH
52817: LD_INT 3
52819: PUSH
52820: EMPTY
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 72
52828: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52829: LD_EXP 119
52833: PUSH
52834: LD_VAR 0 1
52838: ARRAY
52839: IFFALSE 52863
// mechs := mechs diff mc_remote_driver [ base ] ;
52841: LD_ADDR_VAR 0 13
52845: PUSH
52846: LD_VAR 0 13
52850: PUSH
52851: LD_EXP 119
52855: PUSH
52856: LD_VAR 0 1
52860: ARRAY
52861: DIFF
52862: ST_TO_ADDR
// for i in mechs do
52863: LD_ADDR_VAR 0 5
52867: PUSH
52868: LD_VAR 0 13
52872: PUSH
52873: FOR_IN
52874: IFFALSE 52909
// if GetTag ( i ) > 0 then
52876: LD_VAR 0 5
52880: PPUSH
52881: CALL_OW 110
52885: PUSH
52886: LD_INT 0
52888: GREATER
52889: IFFALSE 52907
// mechs := mechs diff i ;
52891: LD_ADDR_VAR 0 13
52895: PUSH
52896: LD_VAR 0 13
52900: PUSH
52901: LD_VAR 0 5
52905: DIFF
52906: ST_TO_ADDR
52907: GO 52873
52909: POP
52910: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52911: LD_ADDR_VAR 0 9
52915: PUSH
52916: LD_EXP 79
52920: PUSH
52921: LD_VAR 0 1
52925: ARRAY
52926: PPUSH
52927: LD_INT 2
52929: PUSH
52930: LD_INT 25
52932: PUSH
52933: LD_INT 1
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: PUSH
52940: LD_INT 25
52942: PUSH
52943: LD_INT 5
52945: PUSH
52946: EMPTY
52947: LIST
52948: LIST
52949: PUSH
52950: LD_INT 25
52952: PUSH
52953: LD_INT 8
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 25
52962: PUSH
52963: LD_INT 9
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: LIST
52976: PPUSH
52977: CALL_OW 72
52981: ST_TO_ADDR
// if not defenders and not solds then
52982: LD_VAR 0 2
52986: NOT
52987: PUSH
52988: LD_VAR 0 9
52992: NOT
52993: AND
52994: IFFALSE 52998
// exit ;
52996: GO 54624
// depot_under_attack := false ;
52998: LD_ADDR_VAR 0 17
53002: PUSH
53003: LD_INT 0
53005: ST_TO_ADDR
// sold_defenders := [ ] ;
53006: LD_ADDR_VAR 0 18
53010: PUSH
53011: EMPTY
53012: ST_TO_ADDR
// if mechs then
53013: LD_VAR 0 13
53017: IFFALSE 53146
// for i in defenders do
53019: LD_ADDR_VAR 0 5
53023: PUSH
53024: LD_VAR 0 2
53028: PUSH
53029: FOR_IN
53030: IFFALSE 53144
// begin SetTag ( i , 20 ) ;
53032: LD_VAR 0 5
53036: PPUSH
53037: LD_INT 20
53039: PPUSH
53040: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
53044: LD_VAR 0 5
53048: PPUSH
53049: CALL_OW 263
53053: PUSH
53054: LD_INT 1
53056: EQUAL
53057: PUSH
53058: LD_VAR 0 5
53062: PPUSH
53063: CALL_OW 311
53067: NOT
53068: AND
53069: PUSH
53070: LD_VAR 0 13
53074: AND
53075: IFFALSE 53142
// begin un := mechs [ 1 ] ;
53077: LD_ADDR_VAR 0 11
53081: PUSH
53082: LD_VAR 0 13
53086: PUSH
53087: LD_INT 1
53089: ARRAY
53090: ST_TO_ADDR
// ComExitBuilding ( un ) ;
53091: LD_VAR 0 11
53095: PPUSH
53096: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
53100: LD_VAR 0 11
53104: PPUSH
53105: LD_VAR 0 5
53109: PPUSH
53110: CALL_OW 180
// SetTag ( un , 19 ) ;
53114: LD_VAR 0 11
53118: PPUSH
53119: LD_INT 19
53121: PPUSH
53122: CALL_OW 109
// mechs := mechs diff un ;
53126: LD_ADDR_VAR 0 13
53130: PUSH
53131: LD_VAR 0 13
53135: PUSH
53136: LD_VAR 0 11
53140: DIFF
53141: ST_TO_ADDR
// end ; end ;
53142: GO 53029
53144: POP
53145: POP
// if solds then
53146: LD_VAR 0 9
53150: IFFALSE 53209
// for i in solds do
53152: LD_ADDR_VAR 0 5
53156: PUSH
53157: LD_VAR 0 9
53161: PUSH
53162: FOR_IN
53163: IFFALSE 53207
// if not GetTag ( i ) then
53165: LD_VAR 0 5
53169: PPUSH
53170: CALL_OW 110
53174: NOT
53175: IFFALSE 53205
// begin defenders := defenders union i ;
53177: LD_ADDR_VAR 0 2
53181: PUSH
53182: LD_VAR 0 2
53186: PUSH
53187: LD_VAR 0 5
53191: UNION
53192: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53193: LD_VAR 0 5
53197: PPUSH
53198: LD_INT 18
53200: PPUSH
53201: CALL_OW 109
// end ;
53205: GO 53162
53207: POP
53208: POP
// repeat wait ( 0 0$1 ) ;
53209: LD_INT 35
53211: PPUSH
53212: CALL_OW 67
// enemy := mc_scan [ base ] ;
53216: LD_ADDR_VAR 0 3
53220: PUSH
53221: LD_EXP 102
53225: PUSH
53226: LD_VAR 0 1
53230: ARRAY
53231: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53232: LD_EXP 79
53236: PUSH
53237: LD_VAR 0 1
53241: ARRAY
53242: NOT
53243: PUSH
53244: LD_EXP 79
53248: PUSH
53249: LD_VAR 0 1
53253: ARRAY
53254: PUSH
53255: EMPTY
53256: EQUAL
53257: OR
53258: IFFALSE 53295
// begin for i in defenders do
53260: LD_ADDR_VAR 0 5
53264: PUSH
53265: LD_VAR 0 2
53269: PUSH
53270: FOR_IN
53271: IFFALSE 53284
// ComStop ( i ) ;
53273: LD_VAR 0 5
53277: PPUSH
53278: CALL_OW 141
53282: GO 53270
53284: POP
53285: POP
// defenders := [ ] ;
53286: LD_ADDR_VAR 0 2
53290: PUSH
53291: EMPTY
53292: ST_TO_ADDR
// exit ;
53293: GO 54624
// end ; for i in defenders do
53295: LD_ADDR_VAR 0 5
53299: PUSH
53300: LD_VAR 0 2
53304: PUSH
53305: FOR_IN
53306: IFFALSE 54124
// begin e := NearestUnitToUnit ( enemy , i ) ;
53308: LD_ADDR_VAR 0 14
53312: PUSH
53313: LD_VAR 0 3
53317: PPUSH
53318: LD_VAR 0 5
53322: PPUSH
53323: CALL_OW 74
53327: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53328: LD_ADDR_VAR 0 8
53332: PUSH
53333: LD_EXP 79
53337: PUSH
53338: LD_VAR 0 1
53342: ARRAY
53343: PPUSH
53344: LD_INT 2
53346: PUSH
53347: LD_INT 30
53349: PUSH
53350: LD_INT 0
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: PUSH
53357: LD_INT 30
53359: PUSH
53360: LD_INT 1
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: LIST
53371: PPUSH
53372: CALL_OW 72
53376: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53377: LD_ADDR_VAR 0 17
53381: PUSH
53382: LD_VAR 0 8
53386: NOT
53387: PUSH
53388: LD_VAR 0 8
53392: PPUSH
53393: LD_INT 3
53395: PUSH
53396: LD_INT 24
53398: PUSH
53399: LD_INT 600
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: PUSH
53406: EMPTY
53407: LIST
53408: LIST
53409: PPUSH
53410: CALL_OW 72
53414: OR
53415: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53416: LD_VAR 0 5
53420: PPUSH
53421: CALL_OW 247
53425: PUSH
53426: LD_INT 2
53428: DOUBLE
53429: EQUAL
53430: IFTRUE 53434
53432: GO 53830
53434: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53435: LD_VAR 0 5
53439: PPUSH
53440: CALL_OW 256
53444: PUSH
53445: LD_INT 650
53447: GREATER
53448: PUSH
53449: LD_VAR 0 5
53453: PPUSH
53454: LD_VAR 0 14
53458: PPUSH
53459: CALL_OW 296
53463: PUSH
53464: LD_INT 40
53466: LESS
53467: PUSH
53468: LD_VAR 0 14
53472: PPUSH
53473: LD_EXP 104
53477: PUSH
53478: LD_VAR 0 1
53482: ARRAY
53483: PPUSH
53484: CALL_OW 308
53488: OR
53489: AND
53490: IFFALSE 53612
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53492: LD_VAR 0 5
53496: PPUSH
53497: CALL_OW 262
53501: PUSH
53502: LD_INT 1
53504: EQUAL
53505: PUSH
53506: LD_VAR 0 5
53510: PPUSH
53511: CALL_OW 261
53515: PUSH
53516: LD_INT 30
53518: LESS
53519: AND
53520: PUSH
53521: LD_VAR 0 8
53525: AND
53526: IFFALSE 53596
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53528: LD_VAR 0 5
53532: PPUSH
53533: LD_VAR 0 8
53537: PPUSH
53538: LD_VAR 0 5
53542: PPUSH
53543: CALL_OW 74
53547: PPUSH
53548: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53552: LD_VAR 0 5
53556: PPUSH
53557: LD_VAR 0 8
53561: PPUSH
53562: LD_VAR 0 5
53566: PPUSH
53567: CALL_OW 74
53571: PPUSH
53572: CALL_OW 296
53576: PUSH
53577: LD_INT 6
53579: LESS
53580: IFFALSE 53594
// SetFuel ( i , 100 ) ;
53582: LD_VAR 0 5
53586: PPUSH
53587: LD_INT 100
53589: PPUSH
53590: CALL_OW 240
// end else
53594: GO 53610
// ComAttackUnit ( i , e ) ;
53596: LD_VAR 0 5
53600: PPUSH
53601: LD_VAR 0 14
53605: PPUSH
53606: CALL_OW 115
// end else
53610: GO 53713
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53612: LD_VAR 0 14
53616: PPUSH
53617: LD_EXP 104
53621: PUSH
53622: LD_VAR 0 1
53626: ARRAY
53627: PPUSH
53628: CALL_OW 308
53632: NOT
53633: PUSH
53634: LD_VAR 0 5
53638: PPUSH
53639: LD_VAR 0 14
53643: PPUSH
53644: CALL_OW 296
53648: PUSH
53649: LD_INT 40
53651: GREATEREQUAL
53652: AND
53653: PUSH
53654: LD_VAR 0 5
53658: PPUSH
53659: CALL_OW 256
53663: PUSH
53664: LD_INT 650
53666: LESSEQUAL
53667: OR
53668: PUSH
53669: LD_VAR 0 5
53673: PPUSH
53674: LD_EXP 103
53678: PUSH
53679: LD_VAR 0 1
53683: ARRAY
53684: PPUSH
53685: CALL_OW 308
53689: NOT
53690: AND
53691: IFFALSE 53713
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53693: LD_VAR 0 5
53697: PPUSH
53698: LD_EXP 103
53702: PUSH
53703: LD_VAR 0 1
53707: ARRAY
53708: PPUSH
53709: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53713: LD_VAR 0 5
53717: PPUSH
53718: CALL_OW 256
53722: PUSH
53723: LD_INT 998
53725: LESS
53726: PUSH
53727: LD_VAR 0 5
53731: PPUSH
53732: CALL_OW 263
53736: PUSH
53737: LD_INT 1
53739: EQUAL
53740: AND
53741: PUSH
53742: LD_VAR 0 5
53746: PPUSH
53747: CALL_OW 311
53751: AND
53752: PUSH
53753: LD_VAR 0 5
53757: PPUSH
53758: LD_EXP 103
53762: PUSH
53763: LD_VAR 0 1
53767: ARRAY
53768: PPUSH
53769: CALL_OW 308
53773: AND
53774: IFFALSE 53828
// begin mech := IsDrivenBy ( i ) ;
53776: LD_ADDR_VAR 0 10
53780: PUSH
53781: LD_VAR 0 5
53785: PPUSH
53786: CALL_OW 311
53790: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53791: LD_VAR 0 10
53795: PPUSH
53796: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53800: LD_VAR 0 10
53804: PPUSH
53805: LD_VAR 0 5
53809: PPUSH
53810: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53814: LD_VAR 0 10
53818: PPUSH
53819: LD_VAR 0 5
53823: PPUSH
53824: CALL_OW 180
// end ; end ; unit_human :
53828: GO 54095
53830: LD_INT 1
53832: DOUBLE
53833: EQUAL
53834: IFTRUE 53838
53836: GO 54094
53838: POP
// begin b := IsInUnit ( i ) ;
53839: LD_ADDR_VAR 0 19
53843: PUSH
53844: LD_VAR 0 5
53848: PPUSH
53849: CALL_OW 310
53853: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53854: LD_ADDR_VAR 0 20
53858: PUSH
53859: LD_VAR 0 19
53863: NOT
53864: PUSH
53865: LD_VAR 0 19
53869: PPUSH
53870: CALL_OW 266
53874: PUSH
53875: LD_INT 32
53877: PUSH
53878: LD_INT 31
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: IN
53885: OR
53886: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53887: LD_VAR 0 17
53891: PUSH
53892: LD_VAR 0 2
53896: PPUSH
53897: LD_INT 21
53899: PUSH
53900: LD_INT 2
53902: PUSH
53903: EMPTY
53904: LIST
53905: LIST
53906: PPUSH
53907: CALL_OW 72
53911: PUSH
53912: LD_INT 1
53914: LESSEQUAL
53915: OR
53916: PUSH
53917: LD_VAR 0 20
53921: AND
53922: PUSH
53923: LD_VAR 0 5
53927: PUSH
53928: LD_VAR 0 18
53932: IN
53933: NOT
53934: AND
53935: IFFALSE 54028
// begin if b then
53937: LD_VAR 0 19
53941: IFFALSE 53990
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53943: LD_VAR 0 19
53947: PPUSH
53948: LD_VAR 0 3
53952: PPUSH
53953: LD_VAR 0 19
53957: PPUSH
53958: CALL_OW 74
53962: PPUSH
53963: CALL_OW 296
53967: PUSH
53968: LD_INT 10
53970: LESS
53971: PUSH
53972: LD_VAR 0 19
53976: PPUSH
53977: CALL_OW 461
53981: PUSH
53982: LD_INT 7
53984: NONEQUAL
53985: AND
53986: IFFALSE 53990
// continue ;
53988: GO 53305
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53990: LD_ADDR_VAR 0 18
53994: PUSH
53995: LD_VAR 0 18
53999: PPUSH
54000: LD_VAR 0 18
54004: PUSH
54005: LD_INT 1
54007: PLUS
54008: PPUSH
54009: LD_VAR 0 5
54013: PPUSH
54014: CALL_OW 1
54018: ST_TO_ADDR
// ComExitBuilding ( i ) ;
54019: LD_VAR 0 5
54023: PPUSH
54024: CALL_OW 122
// end ; if sold_defenders then
54028: LD_VAR 0 18
54032: IFFALSE 54092
// if i in sold_defenders then
54034: LD_VAR 0 5
54038: PUSH
54039: LD_VAR 0 18
54043: IN
54044: IFFALSE 54092
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
54046: LD_VAR 0 5
54050: PPUSH
54051: CALL_OW 314
54055: NOT
54056: PUSH
54057: LD_VAR 0 5
54061: PPUSH
54062: LD_VAR 0 14
54066: PPUSH
54067: CALL_OW 296
54071: PUSH
54072: LD_INT 30
54074: LESS
54075: AND
54076: IFFALSE 54092
// ComAttackUnit ( i , e ) ;
54078: LD_VAR 0 5
54082: PPUSH
54083: LD_VAR 0 14
54087: PPUSH
54088: CALL_OW 115
// end ; end ; end ;
54092: GO 54095
54094: POP
// if IsDead ( i ) then
54095: LD_VAR 0 5
54099: PPUSH
54100: CALL_OW 301
54104: IFFALSE 54122
// defenders := defenders diff i ;
54106: LD_ADDR_VAR 0 2
54110: PUSH
54111: LD_VAR 0 2
54115: PUSH
54116: LD_VAR 0 5
54120: DIFF
54121: ST_TO_ADDR
// end ;
54122: GO 53305
54124: POP
54125: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
54126: LD_VAR 0 3
54130: NOT
54131: PUSH
54132: LD_VAR 0 2
54136: NOT
54137: OR
54138: PUSH
54139: LD_EXP 79
54143: PUSH
54144: LD_VAR 0 1
54148: ARRAY
54149: NOT
54150: OR
54151: IFFALSE 53209
// MC_Reset ( base , 18 ) ;
54153: LD_VAR 0 1
54157: PPUSH
54158: LD_INT 18
54160: PPUSH
54161: CALL 24595 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54165: LD_ADDR_VAR 0 2
54169: PUSH
54170: LD_VAR 0 2
54174: PUSH
54175: LD_VAR 0 2
54179: PPUSH
54180: LD_INT 2
54182: PUSH
54183: LD_INT 25
54185: PUSH
54186: LD_INT 1
54188: PUSH
54189: EMPTY
54190: LIST
54191: LIST
54192: PUSH
54193: LD_INT 25
54195: PUSH
54196: LD_INT 5
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PUSH
54203: LD_INT 25
54205: PUSH
54206: LD_INT 8
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PUSH
54213: LD_INT 25
54215: PUSH
54216: LD_INT 9
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: LIST
54227: LIST
54228: LIST
54229: PPUSH
54230: CALL_OW 72
54234: DIFF
54235: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54236: LD_VAR 0 3
54240: NOT
54241: PUSH
54242: LD_VAR 0 2
54246: PPUSH
54247: LD_INT 21
54249: PUSH
54250: LD_INT 2
54252: PUSH
54253: EMPTY
54254: LIST
54255: LIST
54256: PPUSH
54257: CALL_OW 72
54261: AND
54262: IFFALSE 54600
// begin tmp := FilterByTag ( defenders , 19 ) ;
54264: LD_ADDR_VAR 0 12
54268: PUSH
54269: LD_VAR 0 2
54273: PPUSH
54274: LD_INT 19
54276: PPUSH
54277: CALL 91063 0 2
54281: ST_TO_ADDR
// if tmp then
54282: LD_VAR 0 12
54286: IFFALSE 54356
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54288: LD_ADDR_VAR 0 12
54292: PUSH
54293: LD_VAR 0 12
54297: PPUSH
54298: LD_INT 25
54300: PUSH
54301: LD_INT 3
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: PPUSH
54308: CALL_OW 72
54312: ST_TO_ADDR
// if tmp then
54313: LD_VAR 0 12
54317: IFFALSE 54356
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54319: LD_ADDR_EXP 91
54323: PUSH
54324: LD_EXP 91
54328: PPUSH
54329: LD_VAR 0 1
54333: PPUSH
54334: LD_EXP 91
54338: PUSH
54339: LD_VAR 0 1
54343: ARRAY
54344: PUSH
54345: LD_VAR 0 12
54349: UNION
54350: PPUSH
54351: CALL_OW 1
54355: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54356: LD_VAR 0 1
54360: PPUSH
54361: LD_INT 19
54363: PPUSH
54364: CALL 24595 0 2
// repeat wait ( 0 0$1 ) ;
54368: LD_INT 35
54370: PPUSH
54371: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54375: LD_EXP 79
54379: PUSH
54380: LD_VAR 0 1
54384: ARRAY
54385: NOT
54386: PUSH
54387: LD_EXP 79
54391: PUSH
54392: LD_VAR 0 1
54396: ARRAY
54397: PUSH
54398: EMPTY
54399: EQUAL
54400: OR
54401: IFFALSE 54438
// begin for i in defenders do
54403: LD_ADDR_VAR 0 5
54407: PUSH
54408: LD_VAR 0 2
54412: PUSH
54413: FOR_IN
54414: IFFALSE 54427
// ComStop ( i ) ;
54416: LD_VAR 0 5
54420: PPUSH
54421: CALL_OW 141
54425: GO 54413
54427: POP
54428: POP
// defenders := [ ] ;
54429: LD_ADDR_VAR 0 2
54433: PUSH
54434: EMPTY
54435: ST_TO_ADDR
// exit ;
54436: GO 54624
// end ; for i in defenders do
54438: LD_ADDR_VAR 0 5
54442: PUSH
54443: LD_VAR 0 2
54447: PUSH
54448: FOR_IN
54449: IFFALSE 54538
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54451: LD_VAR 0 5
54455: PPUSH
54456: LD_EXP 103
54460: PUSH
54461: LD_VAR 0 1
54465: ARRAY
54466: PPUSH
54467: CALL_OW 308
54471: NOT
54472: IFFALSE 54496
// ComMoveToArea ( i , mc_parking [ base ] ) else
54474: LD_VAR 0 5
54478: PPUSH
54479: LD_EXP 103
54483: PUSH
54484: LD_VAR 0 1
54488: ARRAY
54489: PPUSH
54490: CALL_OW 113
54494: GO 54536
// if GetControl ( i ) = control_manual then
54496: LD_VAR 0 5
54500: PPUSH
54501: CALL_OW 263
54505: PUSH
54506: LD_INT 1
54508: EQUAL
54509: IFFALSE 54536
// if IsDrivenBy ( i ) then
54511: LD_VAR 0 5
54515: PPUSH
54516: CALL_OW 311
54520: IFFALSE 54536
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54522: LD_VAR 0 5
54526: PPUSH
54527: CALL_OW 311
54531: PPUSH
54532: CALL_OW 121
// end ;
54536: GO 54448
54538: POP
54539: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54540: LD_VAR 0 2
54544: PPUSH
54545: LD_INT 95
54547: PUSH
54548: LD_EXP 103
54552: PUSH
54553: LD_VAR 0 1
54557: ARRAY
54558: PUSH
54559: EMPTY
54560: LIST
54561: LIST
54562: PPUSH
54563: CALL_OW 72
54567: PUSH
54568: LD_VAR 0 2
54572: EQUAL
54573: PUSH
54574: LD_EXP 102
54578: PUSH
54579: LD_VAR 0 1
54583: ARRAY
54584: OR
54585: PUSH
54586: LD_EXP 79
54590: PUSH
54591: LD_VAR 0 1
54595: ARRAY
54596: NOT
54597: OR
54598: IFFALSE 54368
// end ; MC_Reset ( base , 19 ) ;
54600: LD_VAR 0 1
54604: PPUSH
54605: LD_INT 19
54607: PPUSH
54608: CALL 24595 0 2
// MC_Reset ( base , 20 ) ;
54612: LD_VAR 0 1
54616: PPUSH
54617: LD_INT 20
54619: PPUSH
54620: CALL 24595 0 2
// end ;
54624: LD_VAR 0 4
54628: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54629: LD_INT 0
54631: PPUSH
54632: PPUSH
54633: PPUSH
54634: PPUSH
// result := false ;
54635: LD_ADDR_VAR 0 2
54639: PUSH
54640: LD_INT 0
54642: ST_TO_ADDR
// side := GetSide ( unit ) ;
54643: LD_ADDR_VAR 0 3
54647: PUSH
54648: LD_VAR 0 1
54652: PPUSH
54653: CALL_OW 255
54657: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54658: LD_ADDR_VAR 0 4
54662: PUSH
54663: LD_VAR 0 1
54667: PPUSH
54668: CALL_OW 248
54672: ST_TO_ADDR
// case nat of 1 :
54673: LD_VAR 0 4
54677: PUSH
54678: LD_INT 1
54680: DOUBLE
54681: EQUAL
54682: IFTRUE 54686
54684: GO 54697
54686: POP
// tech := tech_lassight ; 2 :
54687: LD_ADDR_VAR 0 5
54691: PUSH
54692: LD_INT 12
54694: ST_TO_ADDR
54695: GO 54736
54697: LD_INT 2
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54716
54705: POP
// tech := tech_mortar ; 3 :
54706: LD_ADDR_VAR 0 5
54710: PUSH
54711: LD_INT 41
54713: ST_TO_ADDR
54714: GO 54736
54716: LD_INT 3
54718: DOUBLE
54719: EQUAL
54720: IFTRUE 54724
54722: GO 54735
54724: POP
// tech := tech_bazooka ; end ;
54725: LD_ADDR_VAR 0 5
54729: PUSH
54730: LD_INT 44
54732: ST_TO_ADDR
54733: GO 54736
54735: POP
// if Researched ( side , tech ) then
54736: LD_VAR 0 3
54740: PPUSH
54741: LD_VAR 0 5
54745: PPUSH
54746: CALL_OW 325
54750: IFFALSE 54777
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54752: LD_ADDR_VAR 0 2
54756: PUSH
54757: LD_INT 5
54759: PUSH
54760: LD_INT 8
54762: PUSH
54763: LD_INT 9
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: LIST
54770: PUSH
54771: LD_VAR 0 4
54775: ARRAY
54776: ST_TO_ADDR
// end ;
54777: LD_VAR 0 2
54781: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54782: LD_INT 0
54784: PPUSH
54785: PPUSH
54786: PPUSH
// if not mines then
54787: LD_VAR 0 2
54791: NOT
54792: IFFALSE 54796
// exit ;
54794: GO 54940
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54796: LD_ADDR_VAR 0 5
54800: PUSH
54801: LD_INT 81
54803: PUSH
54804: LD_VAR 0 1
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: PUSH
54813: LD_INT 3
54815: PUSH
54816: LD_INT 21
54818: PUSH
54819: LD_INT 3
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: PUSH
54826: EMPTY
54827: LIST
54828: LIST
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: PPUSH
54834: CALL_OW 69
54838: ST_TO_ADDR
// for i in mines do
54839: LD_ADDR_VAR 0 4
54843: PUSH
54844: LD_VAR 0 2
54848: PUSH
54849: FOR_IN
54850: IFFALSE 54938
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54852: LD_VAR 0 4
54856: PUSH
54857: LD_INT 1
54859: ARRAY
54860: PPUSH
54861: LD_VAR 0 4
54865: PUSH
54866: LD_INT 2
54868: ARRAY
54869: PPUSH
54870: CALL_OW 458
54874: NOT
54875: IFFALSE 54879
// continue ;
54877: GO 54849
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54879: LD_VAR 0 4
54883: PUSH
54884: LD_INT 1
54886: ARRAY
54887: PPUSH
54888: LD_VAR 0 4
54892: PUSH
54893: LD_INT 2
54895: ARRAY
54896: PPUSH
54897: CALL_OW 428
54901: PUSH
54902: LD_VAR 0 5
54906: IN
54907: IFFALSE 54936
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54909: LD_VAR 0 4
54913: PUSH
54914: LD_INT 1
54916: ARRAY
54917: PPUSH
54918: LD_VAR 0 4
54922: PUSH
54923: LD_INT 2
54925: ARRAY
54926: PPUSH
54927: LD_VAR 0 1
54931: PPUSH
54932: CALL_OW 456
// end ;
54936: GO 54849
54938: POP
54939: POP
// end ;
54940: LD_VAR 0 3
54944: RET
// export function Count ( array ) ; var i ; begin
54945: LD_INT 0
54947: PPUSH
54948: PPUSH
// result := 0 ;
54949: LD_ADDR_VAR 0 2
54953: PUSH
54954: LD_INT 0
54956: ST_TO_ADDR
// for i in array do
54957: LD_ADDR_VAR 0 3
54961: PUSH
54962: LD_VAR 0 1
54966: PUSH
54967: FOR_IN
54968: IFFALSE 54992
// if i then
54970: LD_VAR 0 3
54974: IFFALSE 54990
// result := result + 1 ;
54976: LD_ADDR_VAR 0 2
54980: PUSH
54981: LD_VAR 0 2
54985: PUSH
54986: LD_INT 1
54988: PLUS
54989: ST_TO_ADDR
54990: GO 54967
54992: POP
54993: POP
// end ;
54994: LD_VAR 0 2
54998: RET
// export function IsEmpty ( building ) ; begin
54999: LD_INT 0
55001: PPUSH
// if not building then
55002: LD_VAR 0 1
55006: NOT
55007: IFFALSE 55011
// exit ;
55009: GO 55054
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55011: LD_ADDR_VAR 0 2
55015: PUSH
55016: LD_VAR 0 1
55020: PUSH
55021: LD_INT 22
55023: PUSH
55024: LD_VAR 0 1
55028: PPUSH
55029: CALL_OW 255
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: PUSH
55038: LD_INT 58
55040: PUSH
55041: EMPTY
55042: LIST
55043: PUSH
55044: EMPTY
55045: LIST
55046: LIST
55047: PPUSH
55048: CALL_OW 69
55052: IN
55053: ST_TO_ADDR
// end ;
55054: LD_VAR 0 2
55058: RET
// export function IsNotFull ( building ) ; begin
55059: LD_INT 0
55061: PPUSH
// if not building then
55062: LD_VAR 0 1
55066: NOT
55067: IFFALSE 55071
// exit ;
55069: GO 55090
// result := UnitsInside ( building ) < 6 ;
55071: LD_ADDR_VAR 0 2
55075: PUSH
55076: LD_VAR 0 1
55080: PPUSH
55081: CALL_OW 313
55085: PUSH
55086: LD_INT 6
55088: LESS
55089: ST_TO_ADDR
// end ;
55090: LD_VAR 0 2
55094: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55095: LD_INT 0
55097: PPUSH
55098: PPUSH
55099: PPUSH
55100: PPUSH
// tmp := [ ] ;
55101: LD_ADDR_VAR 0 3
55105: PUSH
55106: EMPTY
55107: ST_TO_ADDR
// list := [ ] ;
55108: LD_ADDR_VAR 0 5
55112: PUSH
55113: EMPTY
55114: ST_TO_ADDR
// for i = 16 to 25 do
55115: LD_ADDR_VAR 0 4
55119: PUSH
55120: DOUBLE
55121: LD_INT 16
55123: DEC
55124: ST_TO_ADDR
55125: LD_INT 25
55127: PUSH
55128: FOR_TO
55129: IFFALSE 55202
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55131: LD_ADDR_VAR 0 3
55135: PUSH
55136: LD_VAR 0 3
55140: PUSH
55141: LD_INT 22
55143: PUSH
55144: LD_VAR 0 1
55148: PPUSH
55149: CALL_OW 255
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: PUSH
55158: LD_INT 91
55160: PUSH
55161: LD_VAR 0 1
55165: PUSH
55166: LD_INT 6
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: PUSH
55174: LD_INT 30
55176: PUSH
55177: LD_VAR 0 4
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PUSH
55191: EMPTY
55192: LIST
55193: PPUSH
55194: CALL_OW 69
55198: ADD
55199: ST_TO_ADDR
55200: GO 55128
55202: POP
55203: POP
// for i = 1 to tmp do
55204: LD_ADDR_VAR 0 4
55208: PUSH
55209: DOUBLE
55210: LD_INT 1
55212: DEC
55213: ST_TO_ADDR
55214: LD_VAR 0 3
55218: PUSH
55219: FOR_TO
55220: IFFALSE 55308
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55222: LD_ADDR_VAR 0 5
55226: PUSH
55227: LD_VAR 0 5
55231: PUSH
55232: LD_VAR 0 3
55236: PUSH
55237: LD_VAR 0 4
55241: ARRAY
55242: PPUSH
55243: CALL_OW 266
55247: PUSH
55248: LD_VAR 0 3
55252: PUSH
55253: LD_VAR 0 4
55257: ARRAY
55258: PPUSH
55259: CALL_OW 250
55263: PUSH
55264: LD_VAR 0 3
55268: PUSH
55269: LD_VAR 0 4
55273: ARRAY
55274: PPUSH
55275: CALL_OW 251
55279: PUSH
55280: LD_VAR 0 3
55284: PUSH
55285: LD_VAR 0 4
55289: ARRAY
55290: PPUSH
55291: CALL_OW 254
55295: PUSH
55296: EMPTY
55297: LIST
55298: LIST
55299: LIST
55300: LIST
55301: PUSH
55302: EMPTY
55303: LIST
55304: ADD
55305: ST_TO_ADDR
55306: GO 55219
55308: POP
55309: POP
// result := list ;
55310: LD_ADDR_VAR 0 2
55314: PUSH
55315: LD_VAR 0 5
55319: ST_TO_ADDR
// end ;
55320: LD_VAR 0 2
55324: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55325: LD_INT 0
55327: PPUSH
55328: PPUSH
55329: PPUSH
55330: PPUSH
55331: PPUSH
55332: PPUSH
55333: PPUSH
// if not factory then
55334: LD_VAR 0 1
55338: NOT
55339: IFFALSE 55343
// exit ;
55341: GO 55936
// if control = control_apeman then
55343: LD_VAR 0 4
55347: PUSH
55348: LD_INT 5
55350: EQUAL
55351: IFFALSE 55460
// begin tmp := UnitsInside ( factory ) ;
55353: LD_ADDR_VAR 0 8
55357: PUSH
55358: LD_VAR 0 1
55362: PPUSH
55363: CALL_OW 313
55367: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55368: LD_VAR 0 8
55372: PPUSH
55373: LD_INT 25
55375: PUSH
55376: LD_INT 12
55378: PUSH
55379: EMPTY
55380: LIST
55381: LIST
55382: PPUSH
55383: CALL_OW 72
55387: NOT
55388: IFFALSE 55398
// control := control_manual ;
55390: LD_ADDR_VAR 0 4
55394: PUSH
55395: LD_INT 1
55397: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55398: LD_ADDR_VAR 0 8
55402: PUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: CALL 55095 0 1
55412: ST_TO_ADDR
// if tmp then
55413: LD_VAR 0 8
55417: IFFALSE 55460
// begin for i in tmp do
55419: LD_ADDR_VAR 0 7
55423: PUSH
55424: LD_VAR 0 8
55428: PUSH
55429: FOR_IN
55430: IFFALSE 55458
// if i [ 1 ] = b_ext_radio then
55432: LD_VAR 0 7
55436: PUSH
55437: LD_INT 1
55439: ARRAY
55440: PUSH
55441: LD_INT 22
55443: EQUAL
55444: IFFALSE 55456
// begin control := control_remote ;
55446: LD_ADDR_VAR 0 4
55450: PUSH
55451: LD_INT 2
55453: ST_TO_ADDR
// break ;
55454: GO 55458
// end ;
55456: GO 55429
55458: POP
55459: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55460: LD_VAR 0 1
55464: PPUSH
55465: LD_VAR 0 2
55469: PPUSH
55470: LD_VAR 0 3
55474: PPUSH
55475: LD_VAR 0 4
55479: PPUSH
55480: LD_VAR 0 5
55484: PPUSH
55485: CALL_OW 448
55489: IFFALSE 55524
// begin result := [ chassis , engine , control , weapon ] ;
55491: LD_ADDR_VAR 0 6
55495: PUSH
55496: LD_VAR 0 2
55500: PUSH
55501: LD_VAR 0 3
55505: PUSH
55506: LD_VAR 0 4
55510: PUSH
55511: LD_VAR 0 5
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: LIST
55520: LIST
55521: ST_TO_ADDR
// exit ;
55522: GO 55936
// end ; _chassis := AvailableChassisList ( factory ) ;
55524: LD_ADDR_VAR 0 9
55528: PUSH
55529: LD_VAR 0 1
55533: PPUSH
55534: CALL_OW 475
55538: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55539: LD_ADDR_VAR 0 11
55543: PUSH
55544: LD_VAR 0 1
55548: PPUSH
55549: CALL_OW 476
55553: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55554: LD_ADDR_VAR 0 12
55558: PUSH
55559: LD_VAR 0 1
55563: PPUSH
55564: CALL_OW 477
55568: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55569: LD_ADDR_VAR 0 10
55573: PUSH
55574: LD_VAR 0 1
55578: PPUSH
55579: CALL_OW 478
55583: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55584: LD_VAR 0 9
55588: NOT
55589: PUSH
55590: LD_VAR 0 11
55594: NOT
55595: OR
55596: PUSH
55597: LD_VAR 0 12
55601: NOT
55602: OR
55603: PUSH
55604: LD_VAR 0 10
55608: NOT
55609: OR
55610: IFFALSE 55645
// begin result := [ chassis , engine , control , weapon ] ;
55612: LD_ADDR_VAR 0 6
55616: PUSH
55617: LD_VAR 0 2
55621: PUSH
55622: LD_VAR 0 3
55626: PUSH
55627: LD_VAR 0 4
55631: PUSH
55632: LD_VAR 0 5
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: LIST
55641: LIST
55642: ST_TO_ADDR
// exit ;
55643: GO 55936
// end ; if not chassis in _chassis then
55645: LD_VAR 0 2
55649: PUSH
55650: LD_VAR 0 9
55654: IN
55655: NOT
55656: IFFALSE 55682
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55658: LD_ADDR_VAR 0 2
55662: PUSH
55663: LD_VAR 0 9
55667: PUSH
55668: LD_INT 1
55670: PPUSH
55671: LD_VAR 0 9
55675: PPUSH
55676: CALL_OW 12
55680: ARRAY
55681: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55682: LD_VAR 0 2
55686: PPUSH
55687: LD_VAR 0 3
55691: PPUSH
55692: CALL 55941 0 2
55696: NOT
55697: IFFALSE 55756
// repeat engine := _engine [ 1 ] ;
55699: LD_ADDR_VAR 0 3
55703: PUSH
55704: LD_VAR 0 11
55708: PUSH
55709: LD_INT 1
55711: ARRAY
55712: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55713: LD_ADDR_VAR 0 11
55717: PUSH
55718: LD_VAR 0 11
55722: PPUSH
55723: LD_INT 1
55725: PPUSH
55726: CALL_OW 3
55730: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55731: LD_VAR 0 2
55735: PPUSH
55736: LD_VAR 0 3
55740: PPUSH
55741: CALL 55941 0 2
55745: PUSH
55746: LD_VAR 0 11
55750: PUSH
55751: EMPTY
55752: EQUAL
55753: OR
55754: IFFALSE 55699
// if not control in _control then
55756: LD_VAR 0 4
55760: PUSH
55761: LD_VAR 0 12
55765: IN
55766: NOT
55767: IFFALSE 55793
// control := _control [ rand ( 1 , _control ) ] ;
55769: LD_ADDR_VAR 0 4
55773: PUSH
55774: LD_VAR 0 12
55778: PUSH
55779: LD_INT 1
55781: PPUSH
55782: LD_VAR 0 12
55786: PPUSH
55787: CALL_OW 12
55791: ARRAY
55792: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55793: LD_VAR 0 2
55797: PPUSH
55798: LD_VAR 0 5
55802: PPUSH
55803: CALL 56161 0 2
55807: NOT
55808: IFFALSE 55867
// repeat weapon := _weapon [ 1 ] ;
55810: LD_ADDR_VAR 0 5
55814: PUSH
55815: LD_VAR 0 10
55819: PUSH
55820: LD_INT 1
55822: ARRAY
55823: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55824: LD_ADDR_VAR 0 10
55828: PUSH
55829: LD_VAR 0 10
55833: PPUSH
55834: LD_INT 1
55836: PPUSH
55837: CALL_OW 3
55841: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55842: LD_VAR 0 2
55846: PPUSH
55847: LD_VAR 0 5
55851: PPUSH
55852: CALL 56161 0 2
55856: PUSH
55857: LD_VAR 0 10
55861: PUSH
55862: EMPTY
55863: EQUAL
55864: OR
55865: IFFALSE 55810
// result := [ ] ;
55867: LD_ADDR_VAR 0 6
55871: PUSH
55872: EMPTY
55873: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55874: LD_VAR 0 1
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: LD_VAR 0 3
55888: PPUSH
55889: LD_VAR 0 4
55893: PPUSH
55894: LD_VAR 0 5
55898: PPUSH
55899: CALL_OW 448
55903: IFFALSE 55936
// result := [ chassis , engine , control , weapon ] ;
55905: LD_ADDR_VAR 0 6
55909: PUSH
55910: LD_VAR 0 2
55914: PUSH
55915: LD_VAR 0 3
55919: PUSH
55920: LD_VAR 0 4
55924: PUSH
55925: LD_VAR 0 5
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: LIST
55934: LIST
55935: ST_TO_ADDR
// end ;
55936: LD_VAR 0 6
55940: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55941: LD_INT 0
55943: PPUSH
// if not chassis or not engine then
55944: LD_VAR 0 1
55948: NOT
55949: PUSH
55950: LD_VAR 0 2
55954: NOT
55955: OR
55956: IFFALSE 55960
// exit ;
55958: GO 56156
// case engine of engine_solar :
55960: LD_VAR 0 2
55964: PUSH
55965: LD_INT 2
55967: DOUBLE
55968: EQUAL
55969: IFTRUE 55973
55971: GO 56011
55973: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55974: LD_ADDR_VAR 0 3
55978: PUSH
55979: LD_INT 11
55981: PUSH
55982: LD_INT 12
55984: PUSH
55985: LD_INT 13
55987: PUSH
55988: LD_INT 14
55990: PUSH
55991: LD_INT 1
55993: PUSH
55994: LD_INT 2
55996: PUSH
55997: LD_INT 3
55999: PUSH
56000: EMPTY
56001: LIST
56002: LIST
56003: LIST
56004: LIST
56005: LIST
56006: LIST
56007: LIST
56008: ST_TO_ADDR
56009: GO 56140
56011: LD_INT 1
56013: DOUBLE
56014: EQUAL
56015: IFTRUE 56019
56017: GO 56081
56019: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56020: LD_ADDR_VAR 0 3
56024: PUSH
56025: LD_INT 11
56027: PUSH
56028: LD_INT 12
56030: PUSH
56031: LD_INT 13
56033: PUSH
56034: LD_INT 14
56036: PUSH
56037: LD_INT 1
56039: PUSH
56040: LD_INT 2
56042: PUSH
56043: LD_INT 3
56045: PUSH
56046: LD_INT 4
56048: PUSH
56049: LD_INT 5
56051: PUSH
56052: LD_INT 21
56054: PUSH
56055: LD_INT 23
56057: PUSH
56058: LD_INT 22
56060: PUSH
56061: LD_INT 24
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: LIST
56072: LIST
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: ST_TO_ADDR
56079: GO 56140
56081: LD_INT 3
56083: DOUBLE
56084: EQUAL
56085: IFTRUE 56089
56087: GO 56139
56089: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56090: LD_ADDR_VAR 0 3
56094: PUSH
56095: LD_INT 13
56097: PUSH
56098: LD_INT 14
56100: PUSH
56101: LD_INT 2
56103: PUSH
56104: LD_INT 3
56106: PUSH
56107: LD_INT 4
56109: PUSH
56110: LD_INT 5
56112: PUSH
56113: LD_INT 21
56115: PUSH
56116: LD_INT 22
56118: PUSH
56119: LD_INT 23
56121: PUSH
56122: LD_INT 24
56124: PUSH
56125: EMPTY
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: LIST
56131: LIST
56132: LIST
56133: LIST
56134: LIST
56135: LIST
56136: ST_TO_ADDR
56137: GO 56140
56139: POP
// result := ( chassis in result ) ;
56140: LD_ADDR_VAR 0 3
56144: PUSH
56145: LD_VAR 0 1
56149: PUSH
56150: LD_VAR 0 3
56154: IN
56155: ST_TO_ADDR
// end ;
56156: LD_VAR 0 3
56160: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56161: LD_INT 0
56163: PPUSH
// if not chassis or not weapon then
56164: LD_VAR 0 1
56168: NOT
56169: PUSH
56170: LD_VAR 0 2
56174: NOT
56175: OR
56176: IFFALSE 56180
// exit ;
56178: GO 57206
// case weapon of us_machine_gun :
56180: LD_VAR 0 2
56184: PUSH
56185: LD_INT 2
56187: DOUBLE
56188: EQUAL
56189: IFTRUE 56193
56191: GO 56223
56193: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56194: LD_ADDR_VAR 0 3
56198: PUSH
56199: LD_INT 1
56201: PUSH
56202: LD_INT 2
56204: PUSH
56205: LD_INT 3
56207: PUSH
56208: LD_INT 4
56210: PUSH
56211: LD_INT 5
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: LIST
56218: LIST
56219: LIST
56220: ST_TO_ADDR
56221: GO 57190
56223: LD_INT 3
56225: DOUBLE
56226: EQUAL
56227: IFTRUE 56231
56229: GO 56261
56231: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56232: LD_ADDR_VAR 0 3
56236: PUSH
56237: LD_INT 1
56239: PUSH
56240: LD_INT 2
56242: PUSH
56243: LD_INT 3
56245: PUSH
56246: LD_INT 4
56248: PUSH
56249: LD_INT 5
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: LIST
56256: LIST
56257: LIST
56258: ST_TO_ADDR
56259: GO 57190
56261: LD_INT 11
56263: DOUBLE
56264: EQUAL
56265: IFTRUE 56269
56267: GO 56299
56269: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56270: LD_ADDR_VAR 0 3
56274: PUSH
56275: LD_INT 1
56277: PUSH
56278: LD_INT 2
56280: PUSH
56281: LD_INT 3
56283: PUSH
56284: LD_INT 4
56286: PUSH
56287: LD_INT 5
56289: PUSH
56290: EMPTY
56291: LIST
56292: LIST
56293: LIST
56294: LIST
56295: LIST
56296: ST_TO_ADDR
56297: GO 57190
56299: LD_INT 4
56301: DOUBLE
56302: EQUAL
56303: IFTRUE 56307
56305: GO 56333
56307: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56308: LD_ADDR_VAR 0 3
56312: PUSH
56313: LD_INT 2
56315: PUSH
56316: LD_INT 3
56318: PUSH
56319: LD_INT 4
56321: PUSH
56322: LD_INT 5
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: LIST
56329: LIST
56330: ST_TO_ADDR
56331: GO 57190
56333: LD_INT 5
56335: DOUBLE
56336: EQUAL
56337: IFTRUE 56341
56339: GO 56367
56341: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56342: LD_ADDR_VAR 0 3
56346: PUSH
56347: LD_INT 2
56349: PUSH
56350: LD_INT 3
56352: PUSH
56353: LD_INT 4
56355: PUSH
56356: LD_INT 5
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: LIST
56363: LIST
56364: ST_TO_ADDR
56365: GO 57190
56367: LD_INT 9
56369: DOUBLE
56370: EQUAL
56371: IFTRUE 56375
56373: GO 56401
56375: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56376: LD_ADDR_VAR 0 3
56380: PUSH
56381: LD_INT 2
56383: PUSH
56384: LD_INT 3
56386: PUSH
56387: LD_INT 4
56389: PUSH
56390: LD_INT 5
56392: PUSH
56393: EMPTY
56394: LIST
56395: LIST
56396: LIST
56397: LIST
56398: ST_TO_ADDR
56399: GO 57190
56401: LD_INT 7
56403: DOUBLE
56404: EQUAL
56405: IFTRUE 56409
56407: GO 56435
56409: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56410: LD_ADDR_VAR 0 3
56414: PUSH
56415: LD_INT 2
56417: PUSH
56418: LD_INT 3
56420: PUSH
56421: LD_INT 4
56423: PUSH
56424: LD_INT 5
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: LIST
56431: LIST
56432: ST_TO_ADDR
56433: GO 57190
56435: LD_INT 12
56437: DOUBLE
56438: EQUAL
56439: IFTRUE 56443
56441: GO 56469
56443: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56444: LD_ADDR_VAR 0 3
56448: PUSH
56449: LD_INT 2
56451: PUSH
56452: LD_INT 3
56454: PUSH
56455: LD_INT 4
56457: PUSH
56458: LD_INT 5
56460: PUSH
56461: EMPTY
56462: LIST
56463: LIST
56464: LIST
56465: LIST
56466: ST_TO_ADDR
56467: GO 57190
56469: LD_INT 13
56471: DOUBLE
56472: EQUAL
56473: IFTRUE 56477
56475: GO 56503
56477: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56478: LD_ADDR_VAR 0 3
56482: PUSH
56483: LD_INT 2
56485: PUSH
56486: LD_INT 3
56488: PUSH
56489: LD_INT 4
56491: PUSH
56492: LD_INT 5
56494: PUSH
56495: EMPTY
56496: LIST
56497: LIST
56498: LIST
56499: LIST
56500: ST_TO_ADDR
56501: GO 57190
56503: LD_INT 14
56505: DOUBLE
56506: EQUAL
56507: IFTRUE 56511
56509: GO 56529
56511: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56512: LD_ADDR_VAR 0 3
56516: PUSH
56517: LD_INT 4
56519: PUSH
56520: LD_INT 5
56522: PUSH
56523: EMPTY
56524: LIST
56525: LIST
56526: ST_TO_ADDR
56527: GO 57190
56529: LD_INT 6
56531: DOUBLE
56532: EQUAL
56533: IFTRUE 56537
56535: GO 56555
56537: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56538: LD_ADDR_VAR 0 3
56542: PUSH
56543: LD_INT 4
56545: PUSH
56546: LD_INT 5
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: ST_TO_ADDR
56553: GO 57190
56555: LD_INT 10
56557: DOUBLE
56558: EQUAL
56559: IFTRUE 56563
56561: GO 56581
56563: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56564: LD_ADDR_VAR 0 3
56568: PUSH
56569: LD_INT 4
56571: PUSH
56572: LD_INT 5
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: ST_TO_ADDR
56579: GO 57190
56581: LD_INT 22
56583: DOUBLE
56584: EQUAL
56585: IFTRUE 56589
56587: GO 56615
56589: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56590: LD_ADDR_VAR 0 3
56594: PUSH
56595: LD_INT 11
56597: PUSH
56598: LD_INT 12
56600: PUSH
56601: LD_INT 13
56603: PUSH
56604: LD_INT 14
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: LIST
56611: LIST
56612: ST_TO_ADDR
56613: GO 57190
56615: LD_INT 23
56617: DOUBLE
56618: EQUAL
56619: IFTRUE 56623
56621: GO 56649
56623: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56624: LD_ADDR_VAR 0 3
56628: PUSH
56629: LD_INT 11
56631: PUSH
56632: LD_INT 12
56634: PUSH
56635: LD_INT 13
56637: PUSH
56638: LD_INT 14
56640: PUSH
56641: EMPTY
56642: LIST
56643: LIST
56644: LIST
56645: LIST
56646: ST_TO_ADDR
56647: GO 57190
56649: LD_INT 24
56651: DOUBLE
56652: EQUAL
56653: IFTRUE 56657
56655: GO 56683
56657: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56658: LD_ADDR_VAR 0 3
56662: PUSH
56663: LD_INT 11
56665: PUSH
56666: LD_INT 12
56668: PUSH
56669: LD_INT 13
56671: PUSH
56672: LD_INT 14
56674: PUSH
56675: EMPTY
56676: LIST
56677: LIST
56678: LIST
56679: LIST
56680: ST_TO_ADDR
56681: GO 57190
56683: LD_INT 30
56685: DOUBLE
56686: EQUAL
56687: IFTRUE 56691
56689: GO 56717
56691: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56692: LD_ADDR_VAR 0 3
56696: PUSH
56697: LD_INT 11
56699: PUSH
56700: LD_INT 12
56702: PUSH
56703: LD_INT 13
56705: PUSH
56706: LD_INT 14
56708: PUSH
56709: EMPTY
56710: LIST
56711: LIST
56712: LIST
56713: LIST
56714: ST_TO_ADDR
56715: GO 57190
56717: LD_INT 25
56719: DOUBLE
56720: EQUAL
56721: IFTRUE 56725
56723: GO 56743
56725: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56726: LD_ADDR_VAR 0 3
56730: PUSH
56731: LD_INT 13
56733: PUSH
56734: LD_INT 14
56736: PUSH
56737: EMPTY
56738: LIST
56739: LIST
56740: ST_TO_ADDR
56741: GO 57190
56743: LD_INT 27
56745: DOUBLE
56746: EQUAL
56747: IFTRUE 56751
56749: GO 56769
56751: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56752: LD_ADDR_VAR 0 3
56756: PUSH
56757: LD_INT 13
56759: PUSH
56760: LD_INT 14
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: ST_TO_ADDR
56767: GO 57190
56769: LD_INT 28
56771: DOUBLE
56772: EQUAL
56773: IFTRUE 56777
56775: GO 56795
56777: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56778: LD_ADDR_VAR 0 3
56782: PUSH
56783: LD_INT 13
56785: PUSH
56786: LD_INT 14
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: ST_TO_ADDR
56793: GO 57190
56795: LD_INT 29
56797: DOUBLE
56798: EQUAL
56799: IFTRUE 56803
56801: GO 56821
56803: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56804: LD_ADDR_VAR 0 3
56808: PUSH
56809: LD_INT 13
56811: PUSH
56812: LD_INT 14
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: ST_TO_ADDR
56819: GO 57190
56821: LD_INT 31
56823: DOUBLE
56824: EQUAL
56825: IFTRUE 56829
56827: GO 56847
56829: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56830: LD_ADDR_VAR 0 3
56834: PUSH
56835: LD_INT 13
56837: PUSH
56838: LD_INT 14
56840: PUSH
56841: EMPTY
56842: LIST
56843: LIST
56844: ST_TO_ADDR
56845: GO 57190
56847: LD_INT 26
56849: DOUBLE
56850: EQUAL
56851: IFTRUE 56855
56853: GO 56873
56855: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56856: LD_ADDR_VAR 0 3
56860: PUSH
56861: LD_INT 13
56863: PUSH
56864: LD_INT 14
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: ST_TO_ADDR
56871: GO 57190
56873: LD_INT 42
56875: DOUBLE
56876: EQUAL
56877: IFTRUE 56881
56879: GO 56907
56881: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56882: LD_ADDR_VAR 0 3
56886: PUSH
56887: LD_INT 21
56889: PUSH
56890: LD_INT 22
56892: PUSH
56893: LD_INT 23
56895: PUSH
56896: LD_INT 24
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: ST_TO_ADDR
56905: GO 57190
56907: LD_INT 43
56909: DOUBLE
56910: EQUAL
56911: IFTRUE 56915
56913: GO 56941
56915: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56916: LD_ADDR_VAR 0 3
56920: PUSH
56921: LD_INT 21
56923: PUSH
56924: LD_INT 22
56926: PUSH
56927: LD_INT 23
56929: PUSH
56930: LD_INT 24
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: LIST
56937: LIST
56938: ST_TO_ADDR
56939: GO 57190
56941: LD_INT 44
56943: DOUBLE
56944: EQUAL
56945: IFTRUE 56949
56947: GO 56975
56949: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56950: LD_ADDR_VAR 0 3
56954: PUSH
56955: LD_INT 21
56957: PUSH
56958: LD_INT 22
56960: PUSH
56961: LD_INT 23
56963: PUSH
56964: LD_INT 24
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: LIST
56971: LIST
56972: ST_TO_ADDR
56973: GO 57190
56975: LD_INT 45
56977: DOUBLE
56978: EQUAL
56979: IFTRUE 56983
56981: GO 57009
56983: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56984: LD_ADDR_VAR 0 3
56988: PUSH
56989: LD_INT 21
56991: PUSH
56992: LD_INT 22
56994: PUSH
56995: LD_INT 23
56997: PUSH
56998: LD_INT 24
57000: PUSH
57001: EMPTY
57002: LIST
57003: LIST
57004: LIST
57005: LIST
57006: ST_TO_ADDR
57007: GO 57190
57009: LD_INT 49
57011: DOUBLE
57012: EQUAL
57013: IFTRUE 57017
57015: GO 57043
57017: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57018: LD_ADDR_VAR 0 3
57022: PUSH
57023: LD_INT 21
57025: PUSH
57026: LD_INT 22
57028: PUSH
57029: LD_INT 23
57031: PUSH
57032: LD_INT 24
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: LIST
57039: LIST
57040: ST_TO_ADDR
57041: GO 57190
57043: LD_INT 51
57045: DOUBLE
57046: EQUAL
57047: IFTRUE 57051
57049: GO 57077
57051: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57052: LD_ADDR_VAR 0 3
57056: PUSH
57057: LD_INT 21
57059: PUSH
57060: LD_INT 22
57062: PUSH
57063: LD_INT 23
57065: PUSH
57066: LD_INT 24
57068: PUSH
57069: EMPTY
57070: LIST
57071: LIST
57072: LIST
57073: LIST
57074: ST_TO_ADDR
57075: GO 57190
57077: LD_INT 52
57079: DOUBLE
57080: EQUAL
57081: IFTRUE 57085
57083: GO 57111
57085: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57086: LD_ADDR_VAR 0 3
57090: PUSH
57091: LD_INT 21
57093: PUSH
57094: LD_INT 22
57096: PUSH
57097: LD_INT 23
57099: PUSH
57100: LD_INT 24
57102: PUSH
57103: EMPTY
57104: LIST
57105: LIST
57106: LIST
57107: LIST
57108: ST_TO_ADDR
57109: GO 57190
57111: LD_INT 53
57113: DOUBLE
57114: EQUAL
57115: IFTRUE 57119
57117: GO 57137
57119: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57120: LD_ADDR_VAR 0 3
57124: PUSH
57125: LD_INT 23
57127: PUSH
57128: LD_INT 24
57130: PUSH
57131: EMPTY
57132: LIST
57133: LIST
57134: ST_TO_ADDR
57135: GO 57190
57137: LD_INT 46
57139: DOUBLE
57140: EQUAL
57141: IFTRUE 57145
57143: GO 57163
57145: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57146: LD_ADDR_VAR 0 3
57150: PUSH
57151: LD_INT 23
57153: PUSH
57154: LD_INT 24
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: ST_TO_ADDR
57161: GO 57190
57163: LD_INT 47
57165: DOUBLE
57166: EQUAL
57167: IFTRUE 57171
57169: GO 57189
57171: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57172: LD_ADDR_VAR 0 3
57176: PUSH
57177: LD_INT 23
57179: PUSH
57180: LD_INT 24
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: ST_TO_ADDR
57187: GO 57190
57189: POP
// result := ( chassis in result ) ;
57190: LD_ADDR_VAR 0 3
57194: PUSH
57195: LD_VAR 0 1
57199: PUSH
57200: LD_VAR 0 3
57204: IN
57205: ST_TO_ADDR
// end ;
57206: LD_VAR 0 3
57210: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57211: LD_INT 0
57213: PPUSH
57214: PPUSH
57215: PPUSH
57216: PPUSH
57217: PPUSH
57218: PPUSH
57219: PPUSH
// result := array ;
57220: LD_ADDR_VAR 0 5
57224: PUSH
57225: LD_VAR 0 1
57229: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57230: LD_VAR 0 1
57234: NOT
57235: PUSH
57236: LD_VAR 0 2
57240: NOT
57241: OR
57242: PUSH
57243: LD_VAR 0 3
57247: NOT
57248: OR
57249: PUSH
57250: LD_VAR 0 2
57254: PUSH
57255: LD_VAR 0 1
57259: GREATER
57260: OR
57261: PUSH
57262: LD_VAR 0 3
57266: PUSH
57267: LD_VAR 0 1
57271: GREATER
57272: OR
57273: IFFALSE 57277
// exit ;
57275: GO 57573
// if direction then
57277: LD_VAR 0 4
57281: IFFALSE 57345
// begin d := 1 ;
57283: LD_ADDR_VAR 0 9
57287: PUSH
57288: LD_INT 1
57290: ST_TO_ADDR
// if i_from > i_to then
57291: LD_VAR 0 2
57295: PUSH
57296: LD_VAR 0 3
57300: GREATER
57301: IFFALSE 57327
// length := ( array - i_from ) + i_to else
57303: LD_ADDR_VAR 0 11
57307: PUSH
57308: LD_VAR 0 1
57312: PUSH
57313: LD_VAR 0 2
57317: MINUS
57318: PUSH
57319: LD_VAR 0 3
57323: PLUS
57324: ST_TO_ADDR
57325: GO 57343
// length := i_to - i_from ;
57327: LD_ADDR_VAR 0 11
57331: PUSH
57332: LD_VAR 0 3
57336: PUSH
57337: LD_VAR 0 2
57341: MINUS
57342: ST_TO_ADDR
// end else
57343: GO 57406
// begin d := - 1 ;
57345: LD_ADDR_VAR 0 9
57349: PUSH
57350: LD_INT 1
57352: NEG
57353: ST_TO_ADDR
// if i_from > i_to then
57354: LD_VAR 0 2
57358: PUSH
57359: LD_VAR 0 3
57363: GREATER
57364: IFFALSE 57384
// length := i_from - i_to else
57366: LD_ADDR_VAR 0 11
57370: PUSH
57371: LD_VAR 0 2
57375: PUSH
57376: LD_VAR 0 3
57380: MINUS
57381: ST_TO_ADDR
57382: GO 57406
// length := ( array - i_to ) + i_from ;
57384: LD_ADDR_VAR 0 11
57388: PUSH
57389: LD_VAR 0 1
57393: PUSH
57394: LD_VAR 0 3
57398: MINUS
57399: PUSH
57400: LD_VAR 0 2
57404: PLUS
57405: ST_TO_ADDR
// end ; if not length then
57406: LD_VAR 0 11
57410: NOT
57411: IFFALSE 57415
// exit ;
57413: GO 57573
// tmp := array ;
57415: LD_ADDR_VAR 0 10
57419: PUSH
57420: LD_VAR 0 1
57424: ST_TO_ADDR
// for i = 1 to length do
57425: LD_ADDR_VAR 0 6
57429: PUSH
57430: DOUBLE
57431: LD_INT 1
57433: DEC
57434: ST_TO_ADDR
57435: LD_VAR 0 11
57439: PUSH
57440: FOR_TO
57441: IFFALSE 57561
// begin for j = 1 to array do
57443: LD_ADDR_VAR 0 7
57447: PUSH
57448: DOUBLE
57449: LD_INT 1
57451: DEC
57452: ST_TO_ADDR
57453: LD_VAR 0 1
57457: PUSH
57458: FOR_TO
57459: IFFALSE 57547
// begin k := j + d ;
57461: LD_ADDR_VAR 0 8
57465: PUSH
57466: LD_VAR 0 7
57470: PUSH
57471: LD_VAR 0 9
57475: PLUS
57476: ST_TO_ADDR
// if k > array then
57477: LD_VAR 0 8
57481: PUSH
57482: LD_VAR 0 1
57486: GREATER
57487: IFFALSE 57497
// k := 1 ;
57489: LD_ADDR_VAR 0 8
57493: PUSH
57494: LD_INT 1
57496: ST_TO_ADDR
// if not k then
57497: LD_VAR 0 8
57501: NOT
57502: IFFALSE 57514
// k := array ;
57504: LD_ADDR_VAR 0 8
57508: PUSH
57509: LD_VAR 0 1
57513: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57514: LD_ADDR_VAR 0 10
57518: PUSH
57519: LD_VAR 0 10
57523: PPUSH
57524: LD_VAR 0 8
57528: PPUSH
57529: LD_VAR 0 1
57533: PUSH
57534: LD_VAR 0 7
57538: ARRAY
57539: PPUSH
57540: CALL_OW 1
57544: ST_TO_ADDR
// end ;
57545: GO 57458
57547: POP
57548: POP
// array := tmp ;
57549: LD_ADDR_VAR 0 1
57553: PUSH
57554: LD_VAR 0 10
57558: ST_TO_ADDR
// end ;
57559: GO 57440
57561: POP
57562: POP
// result := array ;
57563: LD_ADDR_VAR 0 5
57567: PUSH
57568: LD_VAR 0 1
57572: ST_TO_ADDR
// end ;
57573: LD_VAR 0 5
57577: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57578: LD_INT 0
57580: PPUSH
57581: PPUSH
// result := 0 ;
57582: LD_ADDR_VAR 0 3
57586: PUSH
57587: LD_INT 0
57589: ST_TO_ADDR
// if not array or not value in array then
57590: LD_VAR 0 1
57594: NOT
57595: PUSH
57596: LD_VAR 0 2
57600: PUSH
57601: LD_VAR 0 1
57605: IN
57606: NOT
57607: OR
57608: IFFALSE 57612
// exit ;
57610: GO 57666
// for i = 1 to array do
57612: LD_ADDR_VAR 0 4
57616: PUSH
57617: DOUBLE
57618: LD_INT 1
57620: DEC
57621: ST_TO_ADDR
57622: LD_VAR 0 1
57626: PUSH
57627: FOR_TO
57628: IFFALSE 57664
// if value = array [ i ] then
57630: LD_VAR 0 2
57634: PUSH
57635: LD_VAR 0 1
57639: PUSH
57640: LD_VAR 0 4
57644: ARRAY
57645: EQUAL
57646: IFFALSE 57662
// begin result := i ;
57648: LD_ADDR_VAR 0 3
57652: PUSH
57653: LD_VAR 0 4
57657: ST_TO_ADDR
// exit ;
57658: POP
57659: POP
57660: GO 57666
// end ;
57662: GO 57627
57664: POP
57665: POP
// end ;
57666: LD_VAR 0 3
57670: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57671: LD_INT 0
57673: PPUSH
// vc_chassis := chassis ;
57674: LD_ADDR_OWVAR 37
57678: PUSH
57679: LD_VAR 0 1
57683: ST_TO_ADDR
// vc_engine := engine ;
57684: LD_ADDR_OWVAR 39
57688: PUSH
57689: LD_VAR 0 2
57693: ST_TO_ADDR
// vc_control := control ;
57694: LD_ADDR_OWVAR 38
57698: PUSH
57699: LD_VAR 0 3
57703: ST_TO_ADDR
// vc_weapon := weapon ;
57704: LD_ADDR_OWVAR 40
57708: PUSH
57709: LD_VAR 0 4
57713: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57714: LD_ADDR_OWVAR 41
57718: PUSH
57719: LD_VAR 0 5
57723: ST_TO_ADDR
// end ;
57724: LD_VAR 0 6
57728: RET
// export function WantPlant ( unit ) ; var task ; begin
57729: LD_INT 0
57731: PPUSH
57732: PPUSH
// result := false ;
57733: LD_ADDR_VAR 0 2
57737: PUSH
57738: LD_INT 0
57740: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57741: LD_ADDR_VAR 0 3
57745: PUSH
57746: LD_VAR 0 1
57750: PPUSH
57751: CALL_OW 437
57755: ST_TO_ADDR
// if task then
57756: LD_VAR 0 3
57760: IFFALSE 57788
// if task [ 1 ] [ 1 ] = p then
57762: LD_VAR 0 3
57766: PUSH
57767: LD_INT 1
57769: ARRAY
57770: PUSH
57771: LD_INT 1
57773: ARRAY
57774: PUSH
57775: LD_STRING p
57777: EQUAL
57778: IFFALSE 57788
// result := true ;
57780: LD_ADDR_VAR 0 2
57784: PUSH
57785: LD_INT 1
57787: ST_TO_ADDR
// end ;
57788: LD_VAR 0 2
57792: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57793: LD_INT 0
57795: PPUSH
57796: PPUSH
57797: PPUSH
57798: PPUSH
// if pos < 1 then
57799: LD_VAR 0 2
57803: PUSH
57804: LD_INT 1
57806: LESS
57807: IFFALSE 57811
// exit ;
57809: GO 58114
// if pos = 1 then
57811: LD_VAR 0 2
57815: PUSH
57816: LD_INT 1
57818: EQUAL
57819: IFFALSE 57852
// result := Replace ( arr , pos [ 1 ] , value ) else
57821: LD_ADDR_VAR 0 4
57825: PUSH
57826: LD_VAR 0 1
57830: PPUSH
57831: LD_VAR 0 2
57835: PUSH
57836: LD_INT 1
57838: ARRAY
57839: PPUSH
57840: LD_VAR 0 3
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
57850: GO 58114
// begin tmp := arr ;
57852: LD_ADDR_VAR 0 6
57856: PUSH
57857: LD_VAR 0 1
57861: ST_TO_ADDR
// s_arr := [ tmp ] ;
57862: LD_ADDR_VAR 0 7
57866: PUSH
57867: LD_VAR 0 6
57871: PUSH
57872: EMPTY
57873: LIST
57874: ST_TO_ADDR
// for i = 1 to pos - 1 do
57875: LD_ADDR_VAR 0 5
57879: PUSH
57880: DOUBLE
57881: LD_INT 1
57883: DEC
57884: ST_TO_ADDR
57885: LD_VAR 0 2
57889: PUSH
57890: LD_INT 1
57892: MINUS
57893: PUSH
57894: FOR_TO
57895: IFFALSE 57940
// begin tmp := tmp [ pos [ i ] ] ;
57897: LD_ADDR_VAR 0 6
57901: PUSH
57902: LD_VAR 0 6
57906: PUSH
57907: LD_VAR 0 2
57911: PUSH
57912: LD_VAR 0 5
57916: ARRAY
57917: ARRAY
57918: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57919: LD_ADDR_VAR 0 7
57923: PUSH
57924: LD_VAR 0 7
57928: PUSH
57929: LD_VAR 0 6
57933: PUSH
57934: EMPTY
57935: LIST
57936: ADD
57937: ST_TO_ADDR
// end ;
57938: GO 57894
57940: POP
57941: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57942: LD_ADDR_VAR 0 6
57946: PUSH
57947: LD_VAR 0 6
57951: PPUSH
57952: LD_VAR 0 2
57956: PUSH
57957: LD_VAR 0 2
57961: ARRAY
57962: PPUSH
57963: LD_VAR 0 3
57967: PPUSH
57968: CALL_OW 1
57972: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57973: LD_ADDR_VAR 0 7
57977: PUSH
57978: LD_VAR 0 7
57982: PPUSH
57983: LD_VAR 0 7
57987: PPUSH
57988: LD_VAR 0 6
57992: PPUSH
57993: CALL_OW 1
57997: ST_TO_ADDR
// for i = s_arr downto 2 do
57998: LD_ADDR_VAR 0 5
58002: PUSH
58003: DOUBLE
58004: LD_VAR 0 7
58008: INC
58009: ST_TO_ADDR
58010: LD_INT 2
58012: PUSH
58013: FOR_DOWNTO
58014: IFFALSE 58098
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58016: LD_ADDR_VAR 0 6
58020: PUSH
58021: LD_VAR 0 7
58025: PUSH
58026: LD_VAR 0 5
58030: PUSH
58031: LD_INT 1
58033: MINUS
58034: ARRAY
58035: PPUSH
58036: LD_VAR 0 2
58040: PUSH
58041: LD_VAR 0 5
58045: PUSH
58046: LD_INT 1
58048: MINUS
58049: ARRAY
58050: PPUSH
58051: LD_VAR 0 7
58055: PUSH
58056: LD_VAR 0 5
58060: ARRAY
58061: PPUSH
58062: CALL_OW 1
58066: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58067: LD_ADDR_VAR 0 7
58071: PUSH
58072: LD_VAR 0 7
58076: PPUSH
58077: LD_VAR 0 5
58081: PUSH
58082: LD_INT 1
58084: MINUS
58085: PPUSH
58086: LD_VAR 0 6
58090: PPUSH
58091: CALL_OW 1
58095: ST_TO_ADDR
// end ;
58096: GO 58013
58098: POP
58099: POP
// result := s_arr [ 1 ] ;
58100: LD_ADDR_VAR 0 4
58104: PUSH
58105: LD_VAR 0 7
58109: PUSH
58110: LD_INT 1
58112: ARRAY
58113: ST_TO_ADDR
// end ; end ;
58114: LD_VAR 0 4
58118: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58119: LD_INT 0
58121: PPUSH
58122: PPUSH
// if not list then
58123: LD_VAR 0 1
58127: NOT
58128: IFFALSE 58132
// exit ;
58130: GO 58223
// i := list [ pos1 ] ;
58132: LD_ADDR_VAR 0 5
58136: PUSH
58137: LD_VAR 0 1
58141: PUSH
58142: LD_VAR 0 2
58146: ARRAY
58147: ST_TO_ADDR
// if not i then
58148: LD_VAR 0 5
58152: NOT
58153: IFFALSE 58157
// exit ;
58155: GO 58223
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58157: LD_ADDR_VAR 0 1
58161: PUSH
58162: LD_VAR 0 1
58166: PPUSH
58167: LD_VAR 0 2
58171: PPUSH
58172: LD_VAR 0 1
58176: PUSH
58177: LD_VAR 0 3
58181: ARRAY
58182: PPUSH
58183: CALL_OW 1
58187: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58188: LD_ADDR_VAR 0 1
58192: PUSH
58193: LD_VAR 0 1
58197: PPUSH
58198: LD_VAR 0 3
58202: PPUSH
58203: LD_VAR 0 5
58207: PPUSH
58208: CALL_OW 1
58212: ST_TO_ADDR
// result := list ;
58213: LD_ADDR_VAR 0 4
58217: PUSH
58218: LD_VAR 0 1
58222: ST_TO_ADDR
// end ;
58223: LD_VAR 0 4
58227: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58228: LD_INT 0
58230: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58231: LD_ADDR_VAR 0 5
58235: PUSH
58236: LD_VAR 0 1
58240: PPUSH
58241: CALL_OW 250
58245: PPUSH
58246: LD_VAR 0 1
58250: PPUSH
58251: CALL_OW 251
58255: PPUSH
58256: LD_VAR 0 2
58260: PPUSH
58261: LD_VAR 0 3
58265: PPUSH
58266: LD_VAR 0 4
58270: PPUSH
58271: CALL 58281 0 5
58275: ST_TO_ADDR
// end ;
58276: LD_VAR 0 5
58280: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58281: LD_INT 0
58283: PPUSH
58284: PPUSH
58285: PPUSH
58286: PPUSH
// if not list then
58287: LD_VAR 0 3
58291: NOT
58292: IFFALSE 58296
// exit ;
58294: GO 58684
// result := [ ] ;
58296: LD_ADDR_VAR 0 6
58300: PUSH
58301: EMPTY
58302: ST_TO_ADDR
// for i in list do
58303: LD_ADDR_VAR 0 7
58307: PUSH
58308: LD_VAR 0 3
58312: PUSH
58313: FOR_IN
58314: IFFALSE 58516
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58316: LD_ADDR_VAR 0 9
58320: PUSH
58321: LD_VAR 0 7
58325: PPUSH
58326: LD_VAR 0 1
58330: PPUSH
58331: LD_VAR 0 2
58335: PPUSH
58336: CALL_OW 297
58340: ST_TO_ADDR
// if not result then
58341: LD_VAR 0 6
58345: NOT
58346: IFFALSE 58372
// result := [ [ i , tmp ] ] else
58348: LD_ADDR_VAR 0 6
58352: PUSH
58353: LD_VAR 0 7
58357: PUSH
58358: LD_VAR 0 9
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PUSH
58367: EMPTY
58368: LIST
58369: ST_TO_ADDR
58370: GO 58514
// begin if result [ result ] [ 2 ] < tmp then
58372: LD_VAR 0 6
58376: PUSH
58377: LD_VAR 0 6
58381: ARRAY
58382: PUSH
58383: LD_INT 2
58385: ARRAY
58386: PUSH
58387: LD_VAR 0 9
58391: LESS
58392: IFFALSE 58434
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58394: LD_ADDR_VAR 0 6
58398: PUSH
58399: LD_VAR 0 6
58403: PPUSH
58404: LD_VAR 0 6
58408: PUSH
58409: LD_INT 1
58411: PLUS
58412: PPUSH
58413: LD_VAR 0 7
58417: PUSH
58418: LD_VAR 0 9
58422: PUSH
58423: EMPTY
58424: LIST
58425: LIST
58426: PPUSH
58427: CALL_OW 2
58431: ST_TO_ADDR
58432: GO 58514
// for j = 1 to result do
58434: LD_ADDR_VAR 0 8
58438: PUSH
58439: DOUBLE
58440: LD_INT 1
58442: DEC
58443: ST_TO_ADDR
58444: LD_VAR 0 6
58448: PUSH
58449: FOR_TO
58450: IFFALSE 58512
// begin if tmp < result [ j ] [ 2 ] then
58452: LD_VAR 0 9
58456: PUSH
58457: LD_VAR 0 6
58461: PUSH
58462: LD_VAR 0 8
58466: ARRAY
58467: PUSH
58468: LD_INT 2
58470: ARRAY
58471: LESS
58472: IFFALSE 58510
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58474: LD_ADDR_VAR 0 6
58478: PUSH
58479: LD_VAR 0 6
58483: PPUSH
58484: LD_VAR 0 8
58488: PPUSH
58489: LD_VAR 0 7
58493: PUSH
58494: LD_VAR 0 9
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PPUSH
58503: CALL_OW 2
58507: ST_TO_ADDR
// break ;
58508: GO 58512
// end ; end ;
58510: GO 58449
58512: POP
58513: POP
// end ; end ;
58514: GO 58313
58516: POP
58517: POP
// if result and not asc then
58518: LD_VAR 0 6
58522: PUSH
58523: LD_VAR 0 4
58527: NOT
58528: AND
58529: IFFALSE 58604
// begin tmp := result ;
58531: LD_ADDR_VAR 0 9
58535: PUSH
58536: LD_VAR 0 6
58540: ST_TO_ADDR
// for i = tmp downto 1 do
58541: LD_ADDR_VAR 0 7
58545: PUSH
58546: DOUBLE
58547: LD_VAR 0 9
58551: INC
58552: ST_TO_ADDR
58553: LD_INT 1
58555: PUSH
58556: FOR_DOWNTO
58557: IFFALSE 58602
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58559: LD_ADDR_VAR 0 6
58563: PUSH
58564: LD_VAR 0 6
58568: PPUSH
58569: LD_VAR 0 9
58573: PUSH
58574: LD_VAR 0 7
58578: MINUS
58579: PUSH
58580: LD_INT 1
58582: PLUS
58583: PPUSH
58584: LD_VAR 0 9
58588: PUSH
58589: LD_VAR 0 7
58593: ARRAY
58594: PPUSH
58595: CALL_OW 1
58599: ST_TO_ADDR
58600: GO 58556
58602: POP
58603: POP
// end ; tmp := [ ] ;
58604: LD_ADDR_VAR 0 9
58608: PUSH
58609: EMPTY
58610: ST_TO_ADDR
// if mode then
58611: LD_VAR 0 5
58615: IFFALSE 58684
// begin for i = 1 to result do
58617: LD_ADDR_VAR 0 7
58621: PUSH
58622: DOUBLE
58623: LD_INT 1
58625: DEC
58626: ST_TO_ADDR
58627: LD_VAR 0 6
58631: PUSH
58632: FOR_TO
58633: IFFALSE 58672
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58635: LD_ADDR_VAR 0 9
58639: PUSH
58640: LD_VAR 0 9
58644: PPUSH
58645: LD_VAR 0 7
58649: PPUSH
58650: LD_VAR 0 6
58654: PUSH
58655: LD_VAR 0 7
58659: ARRAY
58660: PUSH
58661: LD_INT 1
58663: ARRAY
58664: PPUSH
58665: CALL_OW 1
58669: ST_TO_ADDR
58670: GO 58632
58672: POP
58673: POP
// result := tmp ;
58674: LD_ADDR_VAR 0 6
58678: PUSH
58679: LD_VAR 0 9
58683: ST_TO_ADDR
// end ; end ;
58684: LD_VAR 0 6
58688: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58689: LD_INT 0
58691: PPUSH
58692: PPUSH
58693: PPUSH
58694: PPUSH
58695: PPUSH
58696: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58697: LD_ADDR_VAR 0 5
58701: PUSH
58702: LD_INT 0
58704: PUSH
58705: LD_INT 0
58707: PUSH
58708: LD_INT 0
58710: PUSH
58711: EMPTY
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: LIST
58717: LIST
58718: ST_TO_ADDR
// if not x or not y then
58719: LD_VAR 0 2
58723: NOT
58724: PUSH
58725: LD_VAR 0 3
58729: NOT
58730: OR
58731: IFFALSE 58735
// exit ;
58733: GO 60381
// if not range then
58735: LD_VAR 0 4
58739: NOT
58740: IFFALSE 58750
// range := 10 ;
58742: LD_ADDR_VAR 0 4
58746: PUSH
58747: LD_INT 10
58749: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58750: LD_ADDR_VAR 0 8
58754: PUSH
58755: LD_INT 81
58757: PUSH
58758: LD_VAR 0 1
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PUSH
58767: LD_INT 92
58769: PUSH
58770: LD_VAR 0 2
58774: PUSH
58775: LD_VAR 0 3
58779: PUSH
58780: LD_VAR 0 4
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: LIST
58789: LIST
58790: PUSH
58791: LD_INT 3
58793: PUSH
58794: LD_INT 21
58796: PUSH
58797: LD_INT 3
58799: PUSH
58800: EMPTY
58801: LIST
58802: LIST
58803: PUSH
58804: EMPTY
58805: LIST
58806: LIST
58807: PUSH
58808: EMPTY
58809: LIST
58810: LIST
58811: LIST
58812: PPUSH
58813: CALL_OW 69
58817: ST_TO_ADDR
// if not tmp then
58818: LD_VAR 0 8
58822: NOT
58823: IFFALSE 58827
// exit ;
58825: GO 60381
// for i in tmp do
58827: LD_ADDR_VAR 0 6
58831: PUSH
58832: LD_VAR 0 8
58836: PUSH
58837: FOR_IN
58838: IFFALSE 60356
// begin points := [ 0 , 0 , 0 ] ;
58840: LD_ADDR_VAR 0 9
58844: PUSH
58845: LD_INT 0
58847: PUSH
58848: LD_INT 0
58850: PUSH
58851: LD_INT 0
58853: PUSH
58854: EMPTY
58855: LIST
58856: LIST
58857: LIST
58858: ST_TO_ADDR
// bpoints := 1 ;
58859: LD_ADDR_VAR 0 10
58863: PUSH
58864: LD_INT 1
58866: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58867: LD_VAR 0 6
58871: PPUSH
58872: CALL_OW 247
58876: PUSH
58877: LD_INT 1
58879: DOUBLE
58880: EQUAL
58881: IFTRUE 58885
58883: GO 59463
58885: POP
// begin if GetClass ( i ) = 1 then
58886: LD_VAR 0 6
58890: PPUSH
58891: CALL_OW 257
58895: PUSH
58896: LD_INT 1
58898: EQUAL
58899: IFFALSE 58920
// points := [ 10 , 5 , 3 ] ;
58901: LD_ADDR_VAR 0 9
58905: PUSH
58906: LD_INT 10
58908: PUSH
58909: LD_INT 5
58911: PUSH
58912: LD_INT 3
58914: PUSH
58915: EMPTY
58916: LIST
58917: LIST
58918: LIST
58919: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58920: LD_VAR 0 6
58924: PPUSH
58925: CALL_OW 257
58929: PUSH
58930: LD_INT 2
58932: PUSH
58933: LD_INT 3
58935: PUSH
58936: LD_INT 4
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: LIST
58943: IN
58944: IFFALSE 58965
// points := [ 3 , 2 , 1 ] ;
58946: LD_ADDR_VAR 0 9
58950: PUSH
58951: LD_INT 3
58953: PUSH
58954: LD_INT 2
58956: PUSH
58957: LD_INT 1
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: LIST
58964: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58965: LD_VAR 0 6
58969: PPUSH
58970: CALL_OW 257
58974: PUSH
58975: LD_INT 5
58977: EQUAL
58978: IFFALSE 58999
// points := [ 130 , 5 , 2 ] ;
58980: LD_ADDR_VAR 0 9
58984: PUSH
58985: LD_INT 130
58987: PUSH
58988: LD_INT 5
58990: PUSH
58991: LD_INT 2
58993: PUSH
58994: EMPTY
58995: LIST
58996: LIST
58997: LIST
58998: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58999: LD_VAR 0 6
59003: PPUSH
59004: CALL_OW 257
59008: PUSH
59009: LD_INT 8
59011: EQUAL
59012: IFFALSE 59033
// points := [ 35 , 35 , 30 ] ;
59014: LD_ADDR_VAR 0 9
59018: PUSH
59019: LD_INT 35
59021: PUSH
59022: LD_INT 35
59024: PUSH
59025: LD_INT 30
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59033: LD_VAR 0 6
59037: PPUSH
59038: CALL_OW 257
59042: PUSH
59043: LD_INT 9
59045: EQUAL
59046: IFFALSE 59067
// points := [ 20 , 55 , 40 ] ;
59048: LD_ADDR_VAR 0 9
59052: PUSH
59053: LD_INT 20
59055: PUSH
59056: LD_INT 55
59058: PUSH
59059: LD_INT 40
59061: PUSH
59062: EMPTY
59063: LIST
59064: LIST
59065: LIST
59066: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59067: LD_VAR 0 6
59071: PPUSH
59072: CALL_OW 257
59076: PUSH
59077: LD_INT 12
59079: PUSH
59080: LD_INT 16
59082: PUSH
59083: EMPTY
59084: LIST
59085: LIST
59086: IN
59087: IFFALSE 59108
// points := [ 5 , 3 , 2 ] ;
59089: LD_ADDR_VAR 0 9
59093: PUSH
59094: LD_INT 5
59096: PUSH
59097: LD_INT 3
59099: PUSH
59100: LD_INT 2
59102: PUSH
59103: EMPTY
59104: LIST
59105: LIST
59106: LIST
59107: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59108: LD_VAR 0 6
59112: PPUSH
59113: CALL_OW 257
59117: PUSH
59118: LD_INT 17
59120: EQUAL
59121: IFFALSE 59142
// points := [ 100 , 50 , 75 ] ;
59123: LD_ADDR_VAR 0 9
59127: PUSH
59128: LD_INT 100
59130: PUSH
59131: LD_INT 50
59133: PUSH
59134: LD_INT 75
59136: PUSH
59137: EMPTY
59138: LIST
59139: LIST
59140: LIST
59141: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59142: LD_VAR 0 6
59146: PPUSH
59147: CALL_OW 257
59151: PUSH
59152: LD_INT 15
59154: EQUAL
59155: IFFALSE 59176
// points := [ 10 , 5 , 3 ] ;
59157: LD_ADDR_VAR 0 9
59161: PUSH
59162: LD_INT 10
59164: PUSH
59165: LD_INT 5
59167: PUSH
59168: LD_INT 3
59170: PUSH
59171: EMPTY
59172: LIST
59173: LIST
59174: LIST
59175: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59176: LD_VAR 0 6
59180: PPUSH
59181: CALL_OW 257
59185: PUSH
59186: LD_INT 14
59188: EQUAL
59189: IFFALSE 59210
// points := [ 10 , 0 , 0 ] ;
59191: LD_ADDR_VAR 0 9
59195: PUSH
59196: LD_INT 10
59198: PUSH
59199: LD_INT 0
59201: PUSH
59202: LD_INT 0
59204: PUSH
59205: EMPTY
59206: LIST
59207: LIST
59208: LIST
59209: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59210: LD_VAR 0 6
59214: PPUSH
59215: CALL_OW 257
59219: PUSH
59220: LD_INT 11
59222: EQUAL
59223: IFFALSE 59244
// points := [ 30 , 10 , 5 ] ;
59225: LD_ADDR_VAR 0 9
59229: PUSH
59230: LD_INT 30
59232: PUSH
59233: LD_INT 10
59235: PUSH
59236: LD_INT 5
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: LIST
59243: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59244: LD_VAR 0 1
59248: PPUSH
59249: LD_INT 5
59251: PPUSH
59252: CALL_OW 321
59256: PUSH
59257: LD_INT 2
59259: EQUAL
59260: IFFALSE 59277
// bpoints := bpoints * 1.8 ;
59262: LD_ADDR_VAR 0 10
59266: PUSH
59267: LD_VAR 0 10
59271: PUSH
59272: LD_REAL  1.80000000000000E+0000
59275: MUL
59276: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59277: LD_VAR 0 6
59281: PPUSH
59282: CALL_OW 257
59286: PUSH
59287: LD_INT 1
59289: PUSH
59290: LD_INT 2
59292: PUSH
59293: LD_INT 3
59295: PUSH
59296: LD_INT 4
59298: PUSH
59299: EMPTY
59300: LIST
59301: LIST
59302: LIST
59303: LIST
59304: IN
59305: PUSH
59306: LD_VAR 0 1
59310: PPUSH
59311: LD_INT 51
59313: PPUSH
59314: CALL_OW 321
59318: PUSH
59319: LD_INT 2
59321: EQUAL
59322: AND
59323: IFFALSE 59340
// bpoints := bpoints * 1.2 ;
59325: LD_ADDR_VAR 0 10
59329: PUSH
59330: LD_VAR 0 10
59334: PUSH
59335: LD_REAL  1.20000000000000E+0000
59338: MUL
59339: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59340: LD_VAR 0 6
59344: PPUSH
59345: CALL_OW 257
59349: PUSH
59350: LD_INT 5
59352: PUSH
59353: LD_INT 7
59355: PUSH
59356: LD_INT 9
59358: PUSH
59359: EMPTY
59360: LIST
59361: LIST
59362: LIST
59363: IN
59364: PUSH
59365: LD_VAR 0 1
59369: PPUSH
59370: LD_INT 52
59372: PPUSH
59373: CALL_OW 321
59377: PUSH
59378: LD_INT 2
59380: EQUAL
59381: AND
59382: IFFALSE 59399
// bpoints := bpoints * 1.5 ;
59384: LD_ADDR_VAR 0 10
59388: PUSH
59389: LD_VAR 0 10
59393: PUSH
59394: LD_REAL  1.50000000000000E+0000
59397: MUL
59398: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59399: LD_VAR 0 1
59403: PPUSH
59404: LD_INT 66
59406: PPUSH
59407: CALL_OW 321
59411: PUSH
59412: LD_INT 2
59414: EQUAL
59415: IFFALSE 59432
// bpoints := bpoints * 1.1 ;
59417: LD_ADDR_VAR 0 10
59421: PUSH
59422: LD_VAR 0 10
59426: PUSH
59427: LD_REAL  1.10000000000000E+0000
59430: MUL
59431: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59432: LD_ADDR_VAR 0 10
59436: PUSH
59437: LD_VAR 0 10
59441: PUSH
59442: LD_VAR 0 6
59446: PPUSH
59447: LD_INT 1
59449: PPUSH
59450: CALL_OW 259
59454: PUSH
59455: LD_REAL  1.15000000000000E+0000
59458: MUL
59459: MUL
59460: ST_TO_ADDR
// end ; unit_vehicle :
59461: GO 60285
59463: LD_INT 2
59465: DOUBLE
59466: EQUAL
59467: IFTRUE 59471
59469: GO 60273
59471: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59472: LD_VAR 0 6
59476: PPUSH
59477: CALL_OW 264
59481: PUSH
59482: LD_INT 2
59484: PUSH
59485: LD_INT 42
59487: PUSH
59488: LD_INT 24
59490: PUSH
59491: EMPTY
59492: LIST
59493: LIST
59494: LIST
59495: IN
59496: IFFALSE 59517
// points := [ 25 , 5 , 3 ] ;
59498: LD_ADDR_VAR 0 9
59502: PUSH
59503: LD_INT 25
59505: PUSH
59506: LD_INT 5
59508: PUSH
59509: LD_INT 3
59511: PUSH
59512: EMPTY
59513: LIST
59514: LIST
59515: LIST
59516: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59517: LD_VAR 0 6
59521: PPUSH
59522: CALL_OW 264
59526: PUSH
59527: LD_INT 4
59529: PUSH
59530: LD_INT 43
59532: PUSH
59533: LD_INT 25
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: IN
59541: IFFALSE 59562
// points := [ 40 , 15 , 5 ] ;
59543: LD_ADDR_VAR 0 9
59547: PUSH
59548: LD_INT 40
59550: PUSH
59551: LD_INT 15
59553: PUSH
59554: LD_INT 5
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: LIST
59561: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59562: LD_VAR 0 6
59566: PPUSH
59567: CALL_OW 264
59571: PUSH
59572: LD_INT 3
59574: PUSH
59575: LD_INT 23
59577: PUSH
59578: EMPTY
59579: LIST
59580: LIST
59581: IN
59582: IFFALSE 59603
// points := [ 7 , 25 , 8 ] ;
59584: LD_ADDR_VAR 0 9
59588: PUSH
59589: LD_INT 7
59591: PUSH
59592: LD_INT 25
59594: PUSH
59595: LD_INT 8
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: LIST
59602: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59603: LD_VAR 0 6
59607: PPUSH
59608: CALL_OW 264
59612: PUSH
59613: LD_INT 5
59615: PUSH
59616: LD_INT 27
59618: PUSH
59619: LD_INT 44
59621: PUSH
59622: EMPTY
59623: LIST
59624: LIST
59625: LIST
59626: IN
59627: IFFALSE 59648
// points := [ 14 , 50 , 16 ] ;
59629: LD_ADDR_VAR 0 9
59633: PUSH
59634: LD_INT 14
59636: PUSH
59637: LD_INT 50
59639: PUSH
59640: LD_INT 16
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: LIST
59647: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59648: LD_VAR 0 6
59652: PPUSH
59653: CALL_OW 264
59657: PUSH
59658: LD_INT 6
59660: PUSH
59661: LD_INT 46
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: IN
59668: IFFALSE 59689
// points := [ 32 , 120 , 70 ] ;
59670: LD_ADDR_VAR 0 9
59674: PUSH
59675: LD_INT 32
59677: PUSH
59678: LD_INT 120
59680: PUSH
59681: LD_INT 70
59683: PUSH
59684: EMPTY
59685: LIST
59686: LIST
59687: LIST
59688: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59689: LD_VAR 0 6
59693: PPUSH
59694: CALL_OW 264
59698: PUSH
59699: LD_INT 7
59701: PUSH
59702: LD_INT 28
59704: PUSH
59705: LD_INT 45
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: LIST
59712: IN
59713: IFFALSE 59734
// points := [ 35 , 20 , 45 ] ;
59715: LD_ADDR_VAR 0 9
59719: PUSH
59720: LD_INT 35
59722: PUSH
59723: LD_INT 20
59725: PUSH
59726: LD_INT 45
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: LIST
59733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59734: LD_VAR 0 6
59738: PPUSH
59739: CALL_OW 264
59743: PUSH
59744: LD_INT 47
59746: PUSH
59747: EMPTY
59748: LIST
59749: IN
59750: IFFALSE 59771
// points := [ 67 , 45 , 75 ] ;
59752: LD_ADDR_VAR 0 9
59756: PUSH
59757: LD_INT 67
59759: PUSH
59760: LD_INT 45
59762: PUSH
59763: LD_INT 75
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: LIST
59770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59771: LD_VAR 0 6
59775: PPUSH
59776: CALL_OW 264
59780: PUSH
59781: LD_INT 26
59783: PUSH
59784: EMPTY
59785: LIST
59786: IN
59787: IFFALSE 59808
// points := [ 120 , 30 , 80 ] ;
59789: LD_ADDR_VAR 0 9
59793: PUSH
59794: LD_INT 120
59796: PUSH
59797: LD_INT 30
59799: PUSH
59800: LD_INT 80
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: LIST
59807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59808: LD_VAR 0 6
59812: PPUSH
59813: CALL_OW 264
59817: PUSH
59818: LD_INT 22
59820: PUSH
59821: EMPTY
59822: LIST
59823: IN
59824: IFFALSE 59845
// points := [ 40 , 1 , 1 ] ;
59826: LD_ADDR_VAR 0 9
59830: PUSH
59831: LD_INT 40
59833: PUSH
59834: LD_INT 1
59836: PUSH
59837: LD_INT 1
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: LIST
59844: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59845: LD_VAR 0 6
59849: PPUSH
59850: CALL_OW 264
59854: PUSH
59855: LD_INT 29
59857: PUSH
59858: EMPTY
59859: LIST
59860: IN
59861: IFFALSE 59882
// points := [ 70 , 200 , 400 ] ;
59863: LD_ADDR_VAR 0 9
59867: PUSH
59868: LD_INT 70
59870: PUSH
59871: LD_INT 200
59873: PUSH
59874: LD_INT 400
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59882: LD_VAR 0 6
59886: PPUSH
59887: CALL_OW 264
59891: PUSH
59892: LD_INT 14
59894: PUSH
59895: LD_INT 53
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: IN
59902: IFFALSE 59923
// points := [ 40 , 10 , 20 ] ;
59904: LD_ADDR_VAR 0 9
59908: PUSH
59909: LD_INT 40
59911: PUSH
59912: LD_INT 10
59914: PUSH
59915: LD_INT 20
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: LIST
59922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59923: LD_VAR 0 6
59927: PPUSH
59928: CALL_OW 264
59932: PUSH
59933: LD_INT 9
59935: PUSH
59936: EMPTY
59937: LIST
59938: IN
59939: IFFALSE 59960
// points := [ 5 , 70 , 20 ] ;
59941: LD_ADDR_VAR 0 9
59945: PUSH
59946: LD_INT 5
59948: PUSH
59949: LD_INT 70
59951: PUSH
59952: LD_INT 20
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: LIST
59959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59960: LD_VAR 0 6
59964: PPUSH
59965: CALL_OW 264
59969: PUSH
59970: LD_INT 10
59972: PUSH
59973: EMPTY
59974: LIST
59975: IN
59976: IFFALSE 59997
// points := [ 35 , 110 , 70 ] ;
59978: LD_ADDR_VAR 0 9
59982: PUSH
59983: LD_INT 35
59985: PUSH
59986: LD_INT 110
59988: PUSH
59989: LD_INT 70
59991: PUSH
59992: EMPTY
59993: LIST
59994: LIST
59995: LIST
59996: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59997: LD_VAR 0 6
60001: PPUSH
60002: CALL_OW 265
60006: PUSH
60007: LD_INT 25
60009: EQUAL
60010: IFFALSE 60031
// points := [ 80 , 65 , 100 ] ;
60012: LD_ADDR_VAR 0 9
60016: PUSH
60017: LD_INT 80
60019: PUSH
60020: LD_INT 65
60022: PUSH
60023: LD_INT 100
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: LIST
60030: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60031: LD_VAR 0 6
60035: PPUSH
60036: CALL_OW 263
60040: PUSH
60041: LD_INT 1
60043: EQUAL
60044: IFFALSE 60079
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60046: LD_ADDR_VAR 0 10
60050: PUSH
60051: LD_VAR 0 10
60055: PUSH
60056: LD_VAR 0 6
60060: PPUSH
60061: CALL_OW 311
60065: PPUSH
60066: LD_INT 3
60068: PPUSH
60069: CALL_OW 259
60073: PUSH
60074: LD_INT 4
60076: MUL
60077: MUL
60078: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60079: LD_VAR 0 6
60083: PPUSH
60084: CALL_OW 263
60088: PUSH
60089: LD_INT 2
60091: EQUAL
60092: IFFALSE 60143
// begin j := IsControledBy ( i ) ;
60094: LD_ADDR_VAR 0 7
60098: PUSH
60099: LD_VAR 0 6
60103: PPUSH
60104: CALL_OW 312
60108: ST_TO_ADDR
// if j then
60109: LD_VAR 0 7
60113: IFFALSE 60143
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60115: LD_ADDR_VAR 0 10
60119: PUSH
60120: LD_VAR 0 10
60124: PUSH
60125: LD_VAR 0 7
60129: PPUSH
60130: LD_INT 3
60132: PPUSH
60133: CALL_OW 259
60137: PUSH
60138: LD_INT 3
60140: MUL
60141: MUL
60142: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60143: LD_VAR 0 6
60147: PPUSH
60148: CALL_OW 264
60152: PUSH
60153: LD_INT 5
60155: PUSH
60156: LD_INT 6
60158: PUSH
60159: LD_INT 46
60161: PUSH
60162: LD_INT 44
60164: PUSH
60165: LD_INT 47
60167: PUSH
60168: LD_INT 45
60170: PUSH
60171: LD_INT 28
60173: PUSH
60174: LD_INT 7
60176: PUSH
60177: LD_INT 27
60179: PUSH
60180: LD_INT 29
60182: PUSH
60183: EMPTY
60184: LIST
60185: LIST
60186: LIST
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: IN
60195: PUSH
60196: LD_VAR 0 1
60200: PPUSH
60201: LD_INT 52
60203: PPUSH
60204: CALL_OW 321
60208: PUSH
60209: LD_INT 2
60211: EQUAL
60212: AND
60213: IFFALSE 60230
// bpoints := bpoints * 1.2 ;
60215: LD_ADDR_VAR 0 10
60219: PUSH
60220: LD_VAR 0 10
60224: PUSH
60225: LD_REAL  1.20000000000000E+0000
60228: MUL
60229: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60230: LD_VAR 0 6
60234: PPUSH
60235: CALL_OW 264
60239: PUSH
60240: LD_INT 6
60242: PUSH
60243: LD_INT 46
60245: PUSH
60246: LD_INT 47
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: LIST
60253: IN
60254: IFFALSE 60271
// bpoints := bpoints * 1.2 ;
60256: LD_ADDR_VAR 0 10
60260: PUSH
60261: LD_VAR 0 10
60265: PUSH
60266: LD_REAL  1.20000000000000E+0000
60269: MUL
60270: ST_TO_ADDR
// end ; unit_building :
60271: GO 60285
60273: LD_INT 3
60275: DOUBLE
60276: EQUAL
60277: IFTRUE 60281
60279: GO 60284
60281: POP
// ; end ;
60282: GO 60285
60284: POP
// for j = 1 to 3 do
60285: LD_ADDR_VAR 0 7
60289: PUSH
60290: DOUBLE
60291: LD_INT 1
60293: DEC
60294: ST_TO_ADDR
60295: LD_INT 3
60297: PUSH
60298: FOR_TO
60299: IFFALSE 60352
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60301: LD_ADDR_VAR 0 5
60305: PUSH
60306: LD_VAR 0 5
60310: PPUSH
60311: LD_VAR 0 7
60315: PPUSH
60316: LD_VAR 0 5
60320: PUSH
60321: LD_VAR 0 7
60325: ARRAY
60326: PUSH
60327: LD_VAR 0 9
60331: PUSH
60332: LD_VAR 0 7
60336: ARRAY
60337: PUSH
60338: LD_VAR 0 10
60342: MUL
60343: PLUS
60344: PPUSH
60345: CALL_OW 1
60349: ST_TO_ADDR
60350: GO 60298
60352: POP
60353: POP
// end ;
60354: GO 58837
60356: POP
60357: POP
// result := Replace ( result , 4 , tmp ) ;
60358: LD_ADDR_VAR 0 5
60362: PUSH
60363: LD_VAR 0 5
60367: PPUSH
60368: LD_INT 4
60370: PPUSH
60371: LD_VAR 0 8
60375: PPUSH
60376: CALL_OW 1
60380: ST_TO_ADDR
// end ;
60381: LD_VAR 0 5
60385: RET
// export function DangerAtRange ( unit , range ) ; begin
60386: LD_INT 0
60388: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60389: LD_ADDR_VAR 0 3
60393: PUSH
60394: LD_VAR 0 1
60398: PPUSH
60399: CALL_OW 255
60403: PPUSH
60404: LD_VAR 0 1
60408: PPUSH
60409: CALL_OW 250
60413: PPUSH
60414: LD_VAR 0 1
60418: PPUSH
60419: CALL_OW 251
60423: PPUSH
60424: LD_VAR 0 2
60428: PPUSH
60429: CALL 58689 0 4
60433: ST_TO_ADDR
// end ;
60434: LD_VAR 0 3
60438: RET
// export function DangerInArea ( side , area ) ; begin
60439: LD_INT 0
60441: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60442: LD_ADDR_VAR 0 3
60446: PUSH
60447: LD_VAR 0 2
60451: PPUSH
60452: LD_INT 81
60454: PUSH
60455: LD_VAR 0 1
60459: PUSH
60460: EMPTY
60461: LIST
60462: LIST
60463: PPUSH
60464: CALL_OW 70
60468: ST_TO_ADDR
// end ;
60469: LD_VAR 0 3
60473: RET
// export function IsExtension ( b ) ; begin
60474: LD_INT 0
60476: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60477: LD_ADDR_VAR 0 2
60481: PUSH
60482: LD_VAR 0 1
60486: PUSH
60487: LD_INT 23
60489: PUSH
60490: LD_INT 20
60492: PUSH
60493: LD_INT 22
60495: PUSH
60496: LD_INT 17
60498: PUSH
60499: LD_INT 24
60501: PUSH
60502: LD_INT 21
60504: PUSH
60505: LD_INT 19
60507: PUSH
60508: LD_INT 16
60510: PUSH
60511: LD_INT 25
60513: PUSH
60514: LD_INT 18
60516: PUSH
60517: EMPTY
60518: LIST
60519: LIST
60520: LIST
60521: LIST
60522: LIST
60523: LIST
60524: LIST
60525: LIST
60526: LIST
60527: LIST
60528: IN
60529: ST_TO_ADDR
// end ;
60530: LD_VAR 0 2
60534: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60535: LD_INT 0
60537: PPUSH
60538: PPUSH
60539: PPUSH
// result := [ ] ;
60540: LD_ADDR_VAR 0 3
60544: PUSH
60545: EMPTY
60546: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60547: LD_ADDR_VAR 0 4
60551: PUSH
60552: LD_VAR 0 2
60556: PPUSH
60557: LD_INT 21
60559: PUSH
60560: LD_INT 3
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PPUSH
60567: CALL_OW 70
60571: ST_TO_ADDR
// if not tmp then
60572: LD_VAR 0 4
60576: NOT
60577: IFFALSE 60581
// exit ;
60579: GO 60639
// for i in tmp do
60581: LD_ADDR_VAR 0 5
60585: PUSH
60586: LD_VAR 0 4
60590: PUSH
60591: FOR_IN
60592: IFFALSE 60627
// if GetBase ( i ) <> base then
60594: LD_VAR 0 5
60598: PPUSH
60599: CALL_OW 274
60603: PUSH
60604: LD_VAR 0 1
60608: NONEQUAL
60609: IFFALSE 60625
// ComLinkToBase ( base , i ) ;
60611: LD_VAR 0 1
60615: PPUSH
60616: LD_VAR 0 5
60620: PPUSH
60621: CALL_OW 169
60625: GO 60591
60627: POP
60628: POP
// result := tmp ;
60629: LD_ADDR_VAR 0 3
60633: PUSH
60634: LD_VAR 0 4
60638: ST_TO_ADDR
// end ;
60639: LD_VAR 0 3
60643: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60644: LD_INT 0
60646: PPUSH
60647: PPUSH
// if BuildingStatus ( b ) = bs_build then
60648: LD_VAR 0 2
60652: PPUSH
60653: CALL_OW 461
60657: PUSH
60658: LD_INT 1
60660: EQUAL
60661: IFFALSE 60721
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60663: LD_VAR 0 1
60667: PPUSH
60668: LD_STRING h
60670: PUSH
60671: LD_VAR 0 2
60675: PPUSH
60676: CALL_OW 250
60680: PUSH
60681: LD_VAR 0 2
60685: PPUSH
60686: CALL_OW 251
60690: PUSH
60691: LD_VAR 0 2
60695: PUSH
60696: LD_INT 0
60698: PUSH
60699: LD_INT 0
60701: PUSH
60702: LD_INT 0
60704: PUSH
60705: EMPTY
60706: LIST
60707: LIST
60708: LIST
60709: LIST
60710: LIST
60711: LIST
60712: LIST
60713: PUSH
60714: EMPTY
60715: LIST
60716: PPUSH
60717: CALL_OW 446
// end ;
60721: LD_VAR 0 3
60725: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60726: LD_INT 0
60728: PPUSH
60729: PPUSH
60730: PPUSH
60731: PPUSH
60732: PPUSH
60733: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60734: LD_VAR 0 1
60738: NOT
60739: PUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: CALL_OW 263
60749: PUSH
60750: LD_INT 2
60752: EQUAL
60753: NOT
60754: OR
60755: IFFALSE 60759
// exit ;
60757: GO 61075
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60759: LD_ADDR_VAR 0 6
60763: PUSH
60764: LD_INT 22
60766: PUSH
60767: LD_VAR 0 1
60771: PPUSH
60772: CALL_OW 255
60776: PUSH
60777: EMPTY
60778: LIST
60779: LIST
60780: PUSH
60781: LD_INT 2
60783: PUSH
60784: LD_INT 30
60786: PUSH
60787: LD_INT 36
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: LD_INT 34
60796: PUSH
60797: LD_INT 31
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: LIST
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: PPUSH
60813: CALL_OW 69
60817: ST_TO_ADDR
// if not tmp then
60818: LD_VAR 0 6
60822: NOT
60823: IFFALSE 60827
// exit ;
60825: GO 61075
// result := [ ] ;
60827: LD_ADDR_VAR 0 2
60831: PUSH
60832: EMPTY
60833: ST_TO_ADDR
// for i in tmp do
60834: LD_ADDR_VAR 0 3
60838: PUSH
60839: LD_VAR 0 6
60843: PUSH
60844: FOR_IN
60845: IFFALSE 60916
// begin t := UnitsInside ( i ) ;
60847: LD_ADDR_VAR 0 4
60851: PUSH
60852: LD_VAR 0 3
60856: PPUSH
60857: CALL_OW 313
60861: ST_TO_ADDR
// if t then
60862: LD_VAR 0 4
60866: IFFALSE 60914
// for j in t do
60868: LD_ADDR_VAR 0 7
60872: PUSH
60873: LD_VAR 0 4
60877: PUSH
60878: FOR_IN
60879: IFFALSE 60912
// result := Insert ( result , result + 1 , j ) ;
60881: LD_ADDR_VAR 0 2
60885: PUSH
60886: LD_VAR 0 2
60890: PPUSH
60891: LD_VAR 0 2
60895: PUSH
60896: LD_INT 1
60898: PLUS
60899: PPUSH
60900: LD_VAR 0 7
60904: PPUSH
60905: CALL_OW 2
60909: ST_TO_ADDR
60910: GO 60878
60912: POP
60913: POP
// end ;
60914: GO 60844
60916: POP
60917: POP
// if not result then
60918: LD_VAR 0 2
60922: NOT
60923: IFFALSE 60927
// exit ;
60925: GO 61075
// mech := result [ 1 ] ;
60927: LD_ADDR_VAR 0 5
60931: PUSH
60932: LD_VAR 0 2
60936: PUSH
60937: LD_INT 1
60939: ARRAY
60940: ST_TO_ADDR
// if result > 1 then
60941: LD_VAR 0 2
60945: PUSH
60946: LD_INT 1
60948: GREATER
60949: IFFALSE 61061
// for i = 2 to result do
60951: LD_ADDR_VAR 0 3
60955: PUSH
60956: DOUBLE
60957: LD_INT 2
60959: DEC
60960: ST_TO_ADDR
60961: LD_VAR 0 2
60965: PUSH
60966: FOR_TO
60967: IFFALSE 61059
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60969: LD_ADDR_VAR 0 4
60973: PUSH
60974: LD_VAR 0 2
60978: PUSH
60979: LD_VAR 0 3
60983: ARRAY
60984: PPUSH
60985: LD_INT 3
60987: PPUSH
60988: CALL_OW 259
60992: PUSH
60993: LD_VAR 0 2
60997: PUSH
60998: LD_VAR 0 3
61002: ARRAY
61003: PPUSH
61004: CALL_OW 432
61008: MINUS
61009: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61010: LD_VAR 0 4
61014: PUSH
61015: LD_VAR 0 5
61019: PPUSH
61020: LD_INT 3
61022: PPUSH
61023: CALL_OW 259
61027: PUSH
61028: LD_VAR 0 5
61032: PPUSH
61033: CALL_OW 432
61037: MINUS
61038: GREATEREQUAL
61039: IFFALSE 61057
// mech := result [ i ] ;
61041: LD_ADDR_VAR 0 5
61045: PUSH
61046: LD_VAR 0 2
61050: PUSH
61051: LD_VAR 0 3
61055: ARRAY
61056: ST_TO_ADDR
// end ;
61057: GO 60966
61059: POP
61060: POP
// ComLinkTo ( vehicle , mech ) ;
61061: LD_VAR 0 1
61065: PPUSH
61066: LD_VAR 0 5
61070: PPUSH
61071: CALL_OW 135
// end ;
61075: LD_VAR 0 2
61079: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61080: LD_INT 0
61082: PPUSH
61083: PPUSH
61084: PPUSH
61085: PPUSH
61086: PPUSH
61087: PPUSH
61088: PPUSH
61089: PPUSH
61090: PPUSH
61091: PPUSH
61092: PPUSH
61093: PPUSH
61094: PPUSH
// result := [ ] ;
61095: LD_ADDR_VAR 0 7
61099: PUSH
61100: EMPTY
61101: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61102: LD_VAR 0 1
61106: PPUSH
61107: CALL_OW 266
61111: PUSH
61112: LD_INT 0
61114: PUSH
61115: LD_INT 1
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: IN
61122: NOT
61123: IFFALSE 61127
// exit ;
61125: GO 62758
// if name then
61127: LD_VAR 0 3
61131: IFFALSE 61147
// SetBName ( base_dep , name ) ;
61133: LD_VAR 0 1
61137: PPUSH
61138: LD_VAR 0 3
61142: PPUSH
61143: CALL_OW 500
// base := GetBase ( base_dep ) ;
61147: LD_ADDR_VAR 0 15
61151: PUSH
61152: LD_VAR 0 1
61156: PPUSH
61157: CALL_OW 274
61161: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61162: LD_ADDR_VAR 0 16
61166: PUSH
61167: LD_VAR 0 1
61171: PPUSH
61172: CALL_OW 255
61176: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61177: LD_ADDR_VAR 0 17
61181: PUSH
61182: LD_VAR 0 1
61186: PPUSH
61187: CALL_OW 248
61191: ST_TO_ADDR
// if sources then
61192: LD_VAR 0 5
61196: IFFALSE 61243
// for i = 1 to 3 do
61198: LD_ADDR_VAR 0 8
61202: PUSH
61203: DOUBLE
61204: LD_INT 1
61206: DEC
61207: ST_TO_ADDR
61208: LD_INT 3
61210: PUSH
61211: FOR_TO
61212: IFFALSE 61241
// AddResourceType ( base , i , sources [ i ] ) ;
61214: LD_VAR 0 15
61218: PPUSH
61219: LD_VAR 0 8
61223: PPUSH
61224: LD_VAR 0 5
61228: PUSH
61229: LD_VAR 0 8
61233: ARRAY
61234: PPUSH
61235: CALL_OW 276
61239: GO 61211
61241: POP
61242: POP
// buildings := GetBaseBuildings ( base , area ) ;
61243: LD_ADDR_VAR 0 18
61247: PUSH
61248: LD_VAR 0 15
61252: PPUSH
61253: LD_VAR 0 2
61257: PPUSH
61258: CALL 60535 0 2
61262: ST_TO_ADDR
// InitHc ;
61263: CALL_OW 19
// InitUc ;
61267: CALL_OW 18
// uc_side := side ;
61271: LD_ADDR_OWVAR 20
61275: PUSH
61276: LD_VAR 0 16
61280: ST_TO_ADDR
// uc_nation := nation ;
61281: LD_ADDR_OWVAR 21
61285: PUSH
61286: LD_VAR 0 17
61290: ST_TO_ADDR
// if buildings then
61291: LD_VAR 0 18
61295: IFFALSE 62617
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61297: LD_ADDR_VAR 0 19
61301: PUSH
61302: LD_VAR 0 18
61306: PPUSH
61307: LD_INT 2
61309: PUSH
61310: LD_INT 30
61312: PUSH
61313: LD_INT 29
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: LD_INT 30
61322: PUSH
61323: LD_INT 30
61325: PUSH
61326: EMPTY
61327: LIST
61328: LIST
61329: PUSH
61330: EMPTY
61331: LIST
61332: LIST
61333: LIST
61334: PPUSH
61335: CALL_OW 72
61339: ST_TO_ADDR
// if tmp then
61340: LD_VAR 0 19
61344: IFFALSE 61392
// for i in tmp do
61346: LD_ADDR_VAR 0 8
61350: PUSH
61351: LD_VAR 0 19
61355: PUSH
61356: FOR_IN
61357: IFFALSE 61390
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61359: LD_VAR 0 8
61363: PPUSH
61364: CALL_OW 250
61368: PPUSH
61369: LD_VAR 0 8
61373: PPUSH
61374: CALL_OW 251
61378: PPUSH
61379: LD_VAR 0 16
61383: PPUSH
61384: CALL_OW 441
61388: GO 61356
61390: POP
61391: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61392: LD_VAR 0 18
61396: PPUSH
61397: LD_INT 2
61399: PUSH
61400: LD_INT 30
61402: PUSH
61403: LD_INT 32
61405: PUSH
61406: EMPTY
61407: LIST
61408: LIST
61409: PUSH
61410: LD_INT 30
61412: PUSH
61413: LD_INT 33
61415: PUSH
61416: EMPTY
61417: LIST
61418: LIST
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: LIST
61424: PPUSH
61425: CALL_OW 72
61429: IFFALSE 61517
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61431: LD_ADDR_VAR 0 8
61435: PUSH
61436: LD_VAR 0 18
61440: PPUSH
61441: LD_INT 2
61443: PUSH
61444: LD_INT 30
61446: PUSH
61447: LD_INT 32
61449: PUSH
61450: EMPTY
61451: LIST
61452: LIST
61453: PUSH
61454: LD_INT 30
61456: PUSH
61457: LD_INT 33
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: LIST
61468: PPUSH
61469: CALL_OW 72
61473: PUSH
61474: FOR_IN
61475: IFFALSE 61515
// begin if not GetBWeapon ( i ) then
61477: LD_VAR 0 8
61481: PPUSH
61482: CALL_OW 269
61486: NOT
61487: IFFALSE 61513
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61489: LD_VAR 0 8
61493: PPUSH
61494: LD_VAR 0 8
61498: PPUSH
61499: LD_VAR 0 2
61503: PPUSH
61504: CALL 62763 0 2
61508: PPUSH
61509: CALL_OW 431
// end ;
61513: GO 61474
61515: POP
61516: POP
// end ; for i = 1 to personel do
61517: LD_ADDR_VAR 0 8
61521: PUSH
61522: DOUBLE
61523: LD_INT 1
61525: DEC
61526: ST_TO_ADDR
61527: LD_VAR 0 6
61531: PUSH
61532: FOR_TO
61533: IFFALSE 62597
// begin if i > 4 then
61535: LD_VAR 0 8
61539: PUSH
61540: LD_INT 4
61542: GREATER
61543: IFFALSE 61547
// break ;
61545: GO 62597
// case i of 1 :
61547: LD_VAR 0 8
61551: PUSH
61552: LD_INT 1
61554: DOUBLE
61555: EQUAL
61556: IFTRUE 61560
61558: GO 61640
61560: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61561: LD_ADDR_VAR 0 12
61565: PUSH
61566: LD_VAR 0 18
61570: PPUSH
61571: LD_INT 22
61573: PUSH
61574: LD_VAR 0 16
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: LD_INT 58
61585: PUSH
61586: EMPTY
61587: LIST
61588: PUSH
61589: LD_INT 2
61591: PUSH
61592: LD_INT 30
61594: PUSH
61595: LD_INT 32
61597: PUSH
61598: EMPTY
61599: LIST
61600: LIST
61601: PUSH
61602: LD_INT 30
61604: PUSH
61605: LD_INT 4
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PUSH
61612: LD_INT 30
61614: PUSH
61615: LD_INT 5
61617: PUSH
61618: EMPTY
61619: LIST
61620: LIST
61621: PUSH
61622: EMPTY
61623: LIST
61624: LIST
61625: LIST
61626: LIST
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: LIST
61632: PPUSH
61633: CALL_OW 72
61637: ST_TO_ADDR
61638: GO 61862
61640: LD_INT 2
61642: DOUBLE
61643: EQUAL
61644: IFTRUE 61648
61646: GO 61710
61648: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61649: LD_ADDR_VAR 0 12
61653: PUSH
61654: LD_VAR 0 18
61658: PPUSH
61659: LD_INT 22
61661: PUSH
61662: LD_VAR 0 16
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 2
61673: PUSH
61674: LD_INT 30
61676: PUSH
61677: LD_INT 0
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: LD_INT 30
61686: PUSH
61687: LD_INT 1
61689: PUSH
61690: EMPTY
61691: LIST
61692: LIST
61693: PUSH
61694: EMPTY
61695: LIST
61696: LIST
61697: LIST
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PPUSH
61703: CALL_OW 72
61707: ST_TO_ADDR
61708: GO 61862
61710: LD_INT 3
61712: DOUBLE
61713: EQUAL
61714: IFTRUE 61718
61716: GO 61780
61718: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61719: LD_ADDR_VAR 0 12
61723: PUSH
61724: LD_VAR 0 18
61728: PPUSH
61729: LD_INT 22
61731: PUSH
61732: LD_VAR 0 16
61736: PUSH
61737: EMPTY
61738: LIST
61739: LIST
61740: PUSH
61741: LD_INT 2
61743: PUSH
61744: LD_INT 30
61746: PUSH
61747: LD_INT 2
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: PUSH
61754: LD_INT 30
61756: PUSH
61757: LD_INT 3
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: PUSH
61764: EMPTY
61765: LIST
61766: LIST
61767: LIST
61768: PUSH
61769: EMPTY
61770: LIST
61771: LIST
61772: PPUSH
61773: CALL_OW 72
61777: ST_TO_ADDR
61778: GO 61862
61780: LD_INT 4
61782: DOUBLE
61783: EQUAL
61784: IFTRUE 61788
61786: GO 61861
61788: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61789: LD_ADDR_VAR 0 12
61793: PUSH
61794: LD_VAR 0 18
61798: PPUSH
61799: LD_INT 22
61801: PUSH
61802: LD_VAR 0 16
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: PUSH
61811: LD_INT 2
61813: PUSH
61814: LD_INT 30
61816: PUSH
61817: LD_INT 6
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PUSH
61824: LD_INT 30
61826: PUSH
61827: LD_INT 7
61829: PUSH
61830: EMPTY
61831: LIST
61832: LIST
61833: PUSH
61834: LD_INT 30
61836: PUSH
61837: LD_INT 8
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: LIST
61848: LIST
61849: PUSH
61850: EMPTY
61851: LIST
61852: LIST
61853: PPUSH
61854: CALL_OW 72
61858: ST_TO_ADDR
61859: GO 61862
61861: POP
// if i = 1 then
61862: LD_VAR 0 8
61866: PUSH
61867: LD_INT 1
61869: EQUAL
61870: IFFALSE 61981
// begin tmp := [ ] ;
61872: LD_ADDR_VAR 0 19
61876: PUSH
61877: EMPTY
61878: ST_TO_ADDR
// for j in f do
61879: LD_ADDR_VAR 0 9
61883: PUSH
61884: LD_VAR 0 12
61888: PUSH
61889: FOR_IN
61890: IFFALSE 61963
// if GetBType ( j ) = b_bunker then
61892: LD_VAR 0 9
61896: PPUSH
61897: CALL_OW 266
61901: PUSH
61902: LD_INT 32
61904: EQUAL
61905: IFFALSE 61932
// tmp := Insert ( tmp , 1 , j ) else
61907: LD_ADDR_VAR 0 19
61911: PUSH
61912: LD_VAR 0 19
61916: PPUSH
61917: LD_INT 1
61919: PPUSH
61920: LD_VAR 0 9
61924: PPUSH
61925: CALL_OW 2
61929: ST_TO_ADDR
61930: GO 61961
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61932: LD_ADDR_VAR 0 19
61936: PUSH
61937: LD_VAR 0 19
61941: PPUSH
61942: LD_VAR 0 19
61946: PUSH
61947: LD_INT 1
61949: PLUS
61950: PPUSH
61951: LD_VAR 0 9
61955: PPUSH
61956: CALL_OW 2
61960: ST_TO_ADDR
61961: GO 61889
61963: POP
61964: POP
// if tmp then
61965: LD_VAR 0 19
61969: IFFALSE 61981
// f := tmp ;
61971: LD_ADDR_VAR 0 12
61975: PUSH
61976: LD_VAR 0 19
61980: ST_TO_ADDR
// end ; x := personel [ i ] ;
61981: LD_ADDR_VAR 0 13
61985: PUSH
61986: LD_VAR 0 6
61990: PUSH
61991: LD_VAR 0 8
61995: ARRAY
61996: ST_TO_ADDR
// if x = - 1 then
61997: LD_VAR 0 13
62001: PUSH
62002: LD_INT 1
62004: NEG
62005: EQUAL
62006: IFFALSE 62215
// begin for j in f do
62008: LD_ADDR_VAR 0 9
62012: PUSH
62013: LD_VAR 0 12
62017: PUSH
62018: FOR_IN
62019: IFFALSE 62211
// repeat InitHc ;
62021: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62025: LD_VAR 0 9
62029: PPUSH
62030: CALL_OW 266
62034: PUSH
62035: LD_INT 5
62037: EQUAL
62038: IFFALSE 62108
// begin if UnitsInside ( j ) < 3 then
62040: LD_VAR 0 9
62044: PPUSH
62045: CALL_OW 313
62049: PUSH
62050: LD_INT 3
62052: LESS
62053: IFFALSE 62089
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62055: LD_INT 0
62057: PPUSH
62058: LD_INT 5
62060: PUSH
62061: LD_INT 8
62063: PUSH
62064: LD_INT 9
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: LIST
62071: PUSH
62072: LD_VAR 0 17
62076: ARRAY
62077: PPUSH
62078: LD_VAR 0 4
62082: PPUSH
62083: CALL_OW 380
62087: GO 62106
// PrepareHuman ( false , i , skill ) ;
62089: LD_INT 0
62091: PPUSH
62092: LD_VAR 0 8
62096: PPUSH
62097: LD_VAR 0 4
62101: PPUSH
62102: CALL_OW 380
// end else
62106: GO 62125
// PrepareHuman ( false , i , skill ) ;
62108: LD_INT 0
62110: PPUSH
62111: LD_VAR 0 8
62115: PPUSH
62116: LD_VAR 0 4
62120: PPUSH
62121: CALL_OW 380
// un := CreateHuman ;
62125: LD_ADDR_VAR 0 14
62129: PUSH
62130: CALL_OW 44
62134: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62135: LD_ADDR_VAR 0 7
62139: PUSH
62140: LD_VAR 0 7
62144: PPUSH
62145: LD_INT 1
62147: PPUSH
62148: LD_VAR 0 14
62152: PPUSH
62153: CALL_OW 2
62157: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62158: LD_VAR 0 14
62162: PPUSH
62163: LD_VAR 0 9
62167: PPUSH
62168: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62172: LD_VAR 0 9
62176: PPUSH
62177: CALL_OW 313
62181: PUSH
62182: LD_INT 6
62184: EQUAL
62185: PUSH
62186: LD_VAR 0 9
62190: PPUSH
62191: CALL_OW 266
62195: PUSH
62196: LD_INT 32
62198: PUSH
62199: LD_INT 31
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: IN
62206: OR
62207: IFFALSE 62021
62209: GO 62018
62211: POP
62212: POP
// end else
62213: GO 62595
// for j = 1 to x do
62215: LD_ADDR_VAR 0 9
62219: PUSH
62220: DOUBLE
62221: LD_INT 1
62223: DEC
62224: ST_TO_ADDR
62225: LD_VAR 0 13
62229: PUSH
62230: FOR_TO
62231: IFFALSE 62593
// begin InitHc ;
62233: CALL_OW 19
// if not f then
62237: LD_VAR 0 12
62241: NOT
62242: IFFALSE 62331
// begin PrepareHuman ( false , i , skill ) ;
62244: LD_INT 0
62246: PPUSH
62247: LD_VAR 0 8
62251: PPUSH
62252: LD_VAR 0 4
62256: PPUSH
62257: CALL_OW 380
// un := CreateHuman ;
62261: LD_ADDR_VAR 0 14
62265: PUSH
62266: CALL_OW 44
62270: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62271: LD_ADDR_VAR 0 7
62275: PUSH
62276: LD_VAR 0 7
62280: PPUSH
62281: LD_INT 1
62283: PPUSH
62284: LD_VAR 0 14
62288: PPUSH
62289: CALL_OW 2
62293: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62294: LD_VAR 0 14
62298: PPUSH
62299: LD_VAR 0 1
62303: PPUSH
62304: CALL_OW 250
62308: PPUSH
62309: LD_VAR 0 1
62313: PPUSH
62314: CALL_OW 251
62318: PPUSH
62319: LD_INT 10
62321: PPUSH
62322: LD_INT 0
62324: PPUSH
62325: CALL_OW 50
// continue ;
62329: GO 62230
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62331: LD_VAR 0 12
62335: PUSH
62336: LD_INT 1
62338: ARRAY
62339: PPUSH
62340: CALL_OW 313
62344: PUSH
62345: LD_VAR 0 12
62349: PUSH
62350: LD_INT 1
62352: ARRAY
62353: PPUSH
62354: CALL_OW 266
62358: PUSH
62359: LD_INT 32
62361: PUSH
62362: LD_INT 31
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: IN
62369: AND
62370: PUSH
62371: LD_VAR 0 12
62375: PUSH
62376: LD_INT 1
62378: ARRAY
62379: PPUSH
62380: CALL_OW 313
62384: PUSH
62385: LD_INT 6
62387: EQUAL
62388: OR
62389: IFFALSE 62409
// f := Delete ( f , 1 ) ;
62391: LD_ADDR_VAR 0 12
62395: PUSH
62396: LD_VAR 0 12
62400: PPUSH
62401: LD_INT 1
62403: PPUSH
62404: CALL_OW 3
62408: ST_TO_ADDR
// if not f then
62409: LD_VAR 0 12
62413: NOT
62414: IFFALSE 62432
// begin x := x + 2 ;
62416: LD_ADDR_VAR 0 13
62420: PUSH
62421: LD_VAR 0 13
62425: PUSH
62426: LD_INT 2
62428: PLUS
62429: ST_TO_ADDR
// continue ;
62430: GO 62230
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62432: LD_VAR 0 12
62436: PUSH
62437: LD_INT 1
62439: ARRAY
62440: PPUSH
62441: CALL_OW 266
62445: PUSH
62446: LD_INT 5
62448: EQUAL
62449: IFFALSE 62523
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62451: LD_VAR 0 12
62455: PUSH
62456: LD_INT 1
62458: ARRAY
62459: PPUSH
62460: CALL_OW 313
62464: PUSH
62465: LD_INT 3
62467: LESS
62468: IFFALSE 62504
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62470: LD_INT 0
62472: PPUSH
62473: LD_INT 5
62475: PUSH
62476: LD_INT 8
62478: PUSH
62479: LD_INT 9
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: LIST
62486: PUSH
62487: LD_VAR 0 17
62491: ARRAY
62492: PPUSH
62493: LD_VAR 0 4
62497: PPUSH
62498: CALL_OW 380
62502: GO 62521
// PrepareHuman ( false , i , skill ) ;
62504: LD_INT 0
62506: PPUSH
62507: LD_VAR 0 8
62511: PPUSH
62512: LD_VAR 0 4
62516: PPUSH
62517: CALL_OW 380
// end else
62521: GO 62540
// PrepareHuman ( false , i , skill ) ;
62523: LD_INT 0
62525: PPUSH
62526: LD_VAR 0 8
62530: PPUSH
62531: LD_VAR 0 4
62535: PPUSH
62536: CALL_OW 380
// un := CreateHuman ;
62540: LD_ADDR_VAR 0 14
62544: PUSH
62545: CALL_OW 44
62549: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62550: LD_ADDR_VAR 0 7
62554: PUSH
62555: LD_VAR 0 7
62559: PPUSH
62560: LD_INT 1
62562: PPUSH
62563: LD_VAR 0 14
62567: PPUSH
62568: CALL_OW 2
62572: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62573: LD_VAR 0 14
62577: PPUSH
62578: LD_VAR 0 12
62582: PUSH
62583: LD_INT 1
62585: ARRAY
62586: PPUSH
62587: CALL_OW 52
// end ;
62591: GO 62230
62593: POP
62594: POP
// end ;
62595: GO 61532
62597: POP
62598: POP
// result := result ^ buildings ;
62599: LD_ADDR_VAR 0 7
62603: PUSH
62604: LD_VAR 0 7
62608: PUSH
62609: LD_VAR 0 18
62613: ADD
62614: ST_TO_ADDR
// end else
62615: GO 62758
// begin for i = 1 to personel do
62617: LD_ADDR_VAR 0 8
62621: PUSH
62622: DOUBLE
62623: LD_INT 1
62625: DEC
62626: ST_TO_ADDR
62627: LD_VAR 0 6
62631: PUSH
62632: FOR_TO
62633: IFFALSE 62756
// begin if i > 4 then
62635: LD_VAR 0 8
62639: PUSH
62640: LD_INT 4
62642: GREATER
62643: IFFALSE 62647
// break ;
62645: GO 62756
// x := personel [ i ] ;
62647: LD_ADDR_VAR 0 13
62651: PUSH
62652: LD_VAR 0 6
62656: PUSH
62657: LD_VAR 0 8
62661: ARRAY
62662: ST_TO_ADDR
// if x = - 1 then
62663: LD_VAR 0 13
62667: PUSH
62668: LD_INT 1
62670: NEG
62671: EQUAL
62672: IFFALSE 62676
// continue ;
62674: GO 62632
// PrepareHuman ( false , i , skill ) ;
62676: LD_INT 0
62678: PPUSH
62679: LD_VAR 0 8
62683: PPUSH
62684: LD_VAR 0 4
62688: PPUSH
62689: CALL_OW 380
// un := CreateHuman ;
62693: LD_ADDR_VAR 0 14
62697: PUSH
62698: CALL_OW 44
62702: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62703: LD_VAR 0 14
62707: PPUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 250
62717: PPUSH
62718: LD_VAR 0 1
62722: PPUSH
62723: CALL_OW 251
62727: PPUSH
62728: LD_INT 10
62730: PPUSH
62731: LD_INT 0
62733: PPUSH
62734: CALL_OW 50
// result := result ^ un ;
62738: LD_ADDR_VAR 0 7
62742: PUSH
62743: LD_VAR 0 7
62747: PUSH
62748: LD_VAR 0 14
62752: ADD
62753: ST_TO_ADDR
// end ;
62754: GO 62632
62756: POP
62757: POP
// end ; end ;
62758: LD_VAR 0 7
62762: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62763: LD_INT 0
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
// result := false ;
62781: LD_ADDR_VAR 0 3
62785: PUSH
62786: LD_INT 0
62788: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62789: LD_VAR 0 1
62793: NOT
62794: PUSH
62795: LD_VAR 0 1
62799: PPUSH
62800: CALL_OW 266
62804: PUSH
62805: LD_INT 32
62807: PUSH
62808: LD_INT 33
62810: PUSH
62811: EMPTY
62812: LIST
62813: LIST
62814: IN
62815: NOT
62816: OR
62817: IFFALSE 62821
// exit ;
62819: GO 63957
// nat := GetNation ( tower ) ;
62821: LD_ADDR_VAR 0 12
62825: PUSH
62826: LD_VAR 0 1
62830: PPUSH
62831: CALL_OW 248
62835: ST_TO_ADDR
// side := GetSide ( tower ) ;
62836: LD_ADDR_VAR 0 16
62840: PUSH
62841: LD_VAR 0 1
62845: PPUSH
62846: CALL_OW 255
62850: ST_TO_ADDR
// x := GetX ( tower ) ;
62851: LD_ADDR_VAR 0 10
62855: PUSH
62856: LD_VAR 0 1
62860: PPUSH
62861: CALL_OW 250
62865: ST_TO_ADDR
// y := GetY ( tower ) ;
62866: LD_ADDR_VAR 0 11
62870: PUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: CALL_OW 251
62880: ST_TO_ADDR
// if not x or not y then
62881: LD_VAR 0 10
62885: NOT
62886: PUSH
62887: LD_VAR 0 11
62891: NOT
62892: OR
62893: IFFALSE 62897
// exit ;
62895: GO 63957
// weapon := 0 ;
62897: LD_ADDR_VAR 0 18
62901: PUSH
62902: LD_INT 0
62904: ST_TO_ADDR
// fac_list := [ ] ;
62905: LD_ADDR_VAR 0 17
62909: PUSH
62910: EMPTY
62911: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62912: LD_ADDR_VAR 0 6
62916: PUSH
62917: LD_VAR 0 1
62921: PPUSH
62922: CALL_OW 274
62926: PPUSH
62927: LD_VAR 0 2
62931: PPUSH
62932: CALL 60535 0 2
62936: PPUSH
62937: LD_INT 30
62939: PUSH
62940: LD_INT 3
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PPUSH
62947: CALL_OW 72
62951: ST_TO_ADDR
// if not factories then
62952: LD_VAR 0 6
62956: NOT
62957: IFFALSE 62961
// exit ;
62959: GO 63957
// for i in factories do
62961: LD_ADDR_VAR 0 8
62965: PUSH
62966: LD_VAR 0 6
62970: PUSH
62971: FOR_IN
62972: IFFALSE 62997
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62974: LD_ADDR_VAR 0 17
62978: PUSH
62979: LD_VAR 0 17
62983: PUSH
62984: LD_VAR 0 8
62988: PPUSH
62989: CALL_OW 478
62993: UNION
62994: ST_TO_ADDR
62995: GO 62971
62997: POP
62998: POP
// if not fac_list then
62999: LD_VAR 0 17
63003: NOT
63004: IFFALSE 63008
// exit ;
63006: GO 63957
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63008: LD_ADDR_VAR 0 5
63012: PUSH
63013: LD_INT 4
63015: PUSH
63016: LD_INT 5
63018: PUSH
63019: LD_INT 9
63021: PUSH
63022: LD_INT 10
63024: PUSH
63025: LD_INT 6
63027: PUSH
63028: LD_INT 7
63030: PUSH
63031: LD_INT 11
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: LIST
63041: LIST
63042: PUSH
63043: LD_INT 27
63045: PUSH
63046: LD_INT 28
63048: PUSH
63049: LD_INT 26
63051: PUSH
63052: LD_INT 30
63054: PUSH
63055: EMPTY
63056: LIST
63057: LIST
63058: LIST
63059: LIST
63060: PUSH
63061: LD_INT 43
63063: PUSH
63064: LD_INT 44
63066: PUSH
63067: LD_INT 46
63069: PUSH
63070: LD_INT 45
63072: PUSH
63073: LD_INT 47
63075: PUSH
63076: LD_INT 49
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: LIST
63083: LIST
63084: LIST
63085: LIST
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: LIST
63091: PUSH
63092: LD_VAR 0 12
63096: ARRAY
63097: ST_TO_ADDR
// for i in list do
63098: LD_ADDR_VAR 0 8
63102: PUSH
63103: LD_VAR 0 5
63107: PUSH
63108: FOR_IN
63109: IFFALSE 63142
// if not i in fac_list then
63111: LD_VAR 0 8
63115: PUSH
63116: LD_VAR 0 17
63120: IN
63121: NOT
63122: IFFALSE 63140
// list := list diff i ;
63124: LD_ADDR_VAR 0 5
63128: PUSH
63129: LD_VAR 0 5
63133: PUSH
63134: LD_VAR 0 8
63138: DIFF
63139: ST_TO_ADDR
63140: GO 63108
63142: POP
63143: POP
// if not list then
63144: LD_VAR 0 5
63148: NOT
63149: IFFALSE 63153
// exit ;
63151: GO 63957
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63153: LD_VAR 0 12
63157: PUSH
63158: LD_INT 3
63160: EQUAL
63161: PUSH
63162: LD_INT 49
63164: PUSH
63165: LD_VAR 0 5
63169: IN
63170: AND
63171: PUSH
63172: LD_INT 31
63174: PPUSH
63175: LD_VAR 0 16
63179: PPUSH
63180: CALL_OW 321
63184: PUSH
63185: LD_INT 2
63187: EQUAL
63188: AND
63189: IFFALSE 63249
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63191: LD_INT 22
63193: PUSH
63194: LD_VAR 0 16
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 35
63205: PUSH
63206: LD_INT 49
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: PUSH
63213: LD_INT 91
63215: PUSH
63216: LD_VAR 0 1
63220: PUSH
63221: LD_INT 10
63223: PUSH
63224: EMPTY
63225: LIST
63226: LIST
63227: LIST
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: LIST
63233: PPUSH
63234: CALL_OW 69
63238: NOT
63239: IFFALSE 63249
// weapon := ru_time_lapser ;
63241: LD_ADDR_VAR 0 18
63245: PUSH
63246: LD_INT 49
63248: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63249: LD_VAR 0 12
63253: PUSH
63254: LD_INT 1
63256: PUSH
63257: LD_INT 2
63259: PUSH
63260: EMPTY
63261: LIST
63262: LIST
63263: IN
63264: PUSH
63265: LD_INT 11
63267: PUSH
63268: LD_VAR 0 5
63272: IN
63273: PUSH
63274: LD_INT 30
63276: PUSH
63277: LD_VAR 0 5
63281: IN
63282: OR
63283: AND
63284: PUSH
63285: LD_INT 6
63287: PPUSH
63288: LD_VAR 0 16
63292: PPUSH
63293: CALL_OW 321
63297: PUSH
63298: LD_INT 2
63300: EQUAL
63301: AND
63302: IFFALSE 63467
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63304: LD_INT 22
63306: PUSH
63307: LD_VAR 0 16
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: LD_INT 2
63318: PUSH
63319: LD_INT 35
63321: PUSH
63322: LD_INT 11
63324: PUSH
63325: EMPTY
63326: LIST
63327: LIST
63328: PUSH
63329: LD_INT 35
63331: PUSH
63332: LD_INT 30
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 91
63346: PUSH
63347: LD_VAR 0 1
63351: PUSH
63352: LD_INT 18
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: LIST
63359: PUSH
63360: EMPTY
63361: LIST
63362: LIST
63363: LIST
63364: PPUSH
63365: CALL_OW 69
63369: NOT
63370: PUSH
63371: LD_INT 22
63373: PUSH
63374: LD_VAR 0 16
63378: PUSH
63379: EMPTY
63380: LIST
63381: LIST
63382: PUSH
63383: LD_INT 2
63385: PUSH
63386: LD_INT 30
63388: PUSH
63389: LD_INT 32
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PUSH
63396: LD_INT 30
63398: PUSH
63399: LD_INT 33
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 91
63413: PUSH
63414: LD_VAR 0 1
63418: PUSH
63419: LD_INT 12
63421: PUSH
63422: EMPTY
63423: LIST
63424: LIST
63425: LIST
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: LIST
63431: PUSH
63432: EMPTY
63433: LIST
63434: PPUSH
63435: CALL_OW 69
63439: PUSH
63440: LD_INT 2
63442: GREATER
63443: AND
63444: IFFALSE 63467
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63446: LD_ADDR_VAR 0 18
63450: PUSH
63451: LD_INT 11
63453: PUSH
63454: LD_INT 30
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_VAR 0 12
63465: ARRAY
63466: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63467: LD_VAR 0 18
63471: NOT
63472: PUSH
63473: LD_INT 40
63475: PPUSH
63476: LD_VAR 0 16
63480: PPUSH
63481: CALL_OW 321
63485: PUSH
63486: LD_INT 2
63488: EQUAL
63489: AND
63490: PUSH
63491: LD_INT 7
63493: PUSH
63494: LD_VAR 0 5
63498: IN
63499: PUSH
63500: LD_INT 28
63502: PUSH
63503: LD_VAR 0 5
63507: IN
63508: OR
63509: PUSH
63510: LD_INT 45
63512: PUSH
63513: LD_VAR 0 5
63517: IN
63518: OR
63519: AND
63520: IFFALSE 63774
// begin hex := GetHexInfo ( x , y ) ;
63522: LD_ADDR_VAR 0 4
63526: PUSH
63527: LD_VAR 0 10
63531: PPUSH
63532: LD_VAR 0 11
63536: PPUSH
63537: CALL_OW 546
63541: ST_TO_ADDR
// if hex [ 1 ] then
63542: LD_VAR 0 4
63546: PUSH
63547: LD_INT 1
63549: ARRAY
63550: IFFALSE 63554
// exit ;
63552: GO 63957
// height := hex [ 2 ] ;
63554: LD_ADDR_VAR 0 15
63558: PUSH
63559: LD_VAR 0 4
63563: PUSH
63564: LD_INT 2
63566: ARRAY
63567: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63568: LD_ADDR_VAR 0 14
63572: PUSH
63573: LD_INT 0
63575: PUSH
63576: LD_INT 2
63578: PUSH
63579: LD_INT 3
63581: PUSH
63582: LD_INT 5
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: ST_TO_ADDR
// for i in tmp do
63591: LD_ADDR_VAR 0 8
63595: PUSH
63596: LD_VAR 0 14
63600: PUSH
63601: FOR_IN
63602: IFFALSE 63772
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63604: LD_ADDR_VAR 0 9
63608: PUSH
63609: LD_VAR 0 10
63613: PPUSH
63614: LD_VAR 0 8
63618: PPUSH
63619: LD_INT 5
63621: PPUSH
63622: CALL_OW 272
63626: PUSH
63627: LD_VAR 0 11
63631: PPUSH
63632: LD_VAR 0 8
63636: PPUSH
63637: LD_INT 5
63639: PPUSH
63640: CALL_OW 273
63644: PUSH
63645: EMPTY
63646: LIST
63647: LIST
63648: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63649: LD_VAR 0 9
63653: PUSH
63654: LD_INT 1
63656: ARRAY
63657: PPUSH
63658: LD_VAR 0 9
63662: PUSH
63663: LD_INT 2
63665: ARRAY
63666: PPUSH
63667: CALL_OW 488
63671: IFFALSE 63770
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63673: LD_ADDR_VAR 0 4
63677: PUSH
63678: LD_VAR 0 9
63682: PUSH
63683: LD_INT 1
63685: ARRAY
63686: PPUSH
63687: LD_VAR 0 9
63691: PUSH
63692: LD_INT 2
63694: ARRAY
63695: PPUSH
63696: CALL_OW 546
63700: ST_TO_ADDR
// if hex [ 1 ] then
63701: LD_VAR 0 4
63705: PUSH
63706: LD_INT 1
63708: ARRAY
63709: IFFALSE 63713
// continue ;
63711: GO 63601
// h := hex [ 2 ] ;
63713: LD_ADDR_VAR 0 13
63717: PUSH
63718: LD_VAR 0 4
63722: PUSH
63723: LD_INT 2
63725: ARRAY
63726: ST_TO_ADDR
// if h + 7 < height then
63727: LD_VAR 0 13
63731: PUSH
63732: LD_INT 7
63734: PLUS
63735: PUSH
63736: LD_VAR 0 15
63740: LESS
63741: IFFALSE 63770
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63743: LD_ADDR_VAR 0 18
63747: PUSH
63748: LD_INT 7
63750: PUSH
63751: LD_INT 28
63753: PUSH
63754: LD_INT 45
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: LIST
63761: PUSH
63762: LD_VAR 0 12
63766: ARRAY
63767: ST_TO_ADDR
// break ;
63768: GO 63772
// end ; end ; end ;
63770: GO 63601
63772: POP
63773: POP
// end ; if not weapon then
63774: LD_VAR 0 18
63778: NOT
63779: IFFALSE 63839
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63781: LD_ADDR_VAR 0 5
63785: PUSH
63786: LD_VAR 0 5
63790: PUSH
63791: LD_INT 11
63793: PUSH
63794: LD_INT 30
63796: PUSH
63797: LD_INT 49
63799: PUSH
63800: EMPTY
63801: LIST
63802: LIST
63803: LIST
63804: DIFF
63805: ST_TO_ADDR
// if not list then
63806: LD_VAR 0 5
63810: NOT
63811: IFFALSE 63815
// exit ;
63813: GO 63957
// weapon := list [ rand ( 1 , list ) ] ;
63815: LD_ADDR_VAR 0 18
63819: PUSH
63820: LD_VAR 0 5
63824: PUSH
63825: LD_INT 1
63827: PPUSH
63828: LD_VAR 0 5
63832: PPUSH
63833: CALL_OW 12
63837: ARRAY
63838: ST_TO_ADDR
// end ; if weapon then
63839: LD_VAR 0 18
63843: IFFALSE 63957
// begin tmp := CostOfWeapon ( weapon ) ;
63845: LD_ADDR_VAR 0 14
63849: PUSH
63850: LD_VAR 0 18
63854: PPUSH
63855: CALL_OW 451
63859: ST_TO_ADDR
// j := GetBase ( tower ) ;
63860: LD_ADDR_VAR 0 9
63864: PUSH
63865: LD_VAR 0 1
63869: PPUSH
63870: CALL_OW 274
63874: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63875: LD_VAR 0 9
63879: PPUSH
63880: LD_INT 1
63882: PPUSH
63883: CALL_OW 275
63887: PUSH
63888: LD_VAR 0 14
63892: PUSH
63893: LD_INT 1
63895: ARRAY
63896: GREATEREQUAL
63897: PUSH
63898: LD_VAR 0 9
63902: PPUSH
63903: LD_INT 2
63905: PPUSH
63906: CALL_OW 275
63910: PUSH
63911: LD_VAR 0 14
63915: PUSH
63916: LD_INT 2
63918: ARRAY
63919: GREATEREQUAL
63920: AND
63921: PUSH
63922: LD_VAR 0 9
63926: PPUSH
63927: LD_INT 3
63929: PPUSH
63930: CALL_OW 275
63934: PUSH
63935: LD_VAR 0 14
63939: PUSH
63940: LD_INT 3
63942: ARRAY
63943: GREATEREQUAL
63944: AND
63945: IFFALSE 63957
// result := weapon ;
63947: LD_ADDR_VAR 0 3
63951: PUSH
63952: LD_VAR 0 18
63956: ST_TO_ADDR
// end ; end ;
63957: LD_VAR 0 3
63961: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63962: LD_INT 0
63964: PPUSH
63965: PPUSH
// result := true ;
63966: LD_ADDR_VAR 0 3
63970: PUSH
63971: LD_INT 1
63973: ST_TO_ADDR
// if array1 = array2 then
63974: LD_VAR 0 1
63978: PUSH
63979: LD_VAR 0 2
63983: EQUAL
63984: IFFALSE 64044
// begin for i = 1 to array1 do
63986: LD_ADDR_VAR 0 4
63990: PUSH
63991: DOUBLE
63992: LD_INT 1
63994: DEC
63995: ST_TO_ADDR
63996: LD_VAR 0 1
64000: PUSH
64001: FOR_TO
64002: IFFALSE 64040
// if array1 [ i ] <> array2 [ i ] then
64004: LD_VAR 0 1
64008: PUSH
64009: LD_VAR 0 4
64013: ARRAY
64014: PUSH
64015: LD_VAR 0 2
64019: PUSH
64020: LD_VAR 0 4
64024: ARRAY
64025: NONEQUAL
64026: IFFALSE 64038
// begin result := false ;
64028: LD_ADDR_VAR 0 3
64032: PUSH
64033: LD_INT 0
64035: ST_TO_ADDR
// break ;
64036: GO 64040
// end ;
64038: GO 64001
64040: POP
64041: POP
// end else
64042: GO 64052
// result := false ;
64044: LD_ADDR_VAR 0 3
64048: PUSH
64049: LD_INT 0
64051: ST_TO_ADDR
// end ;
64052: LD_VAR 0 3
64056: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64057: LD_INT 0
64059: PPUSH
64060: PPUSH
64061: PPUSH
// pom := GetBase ( fac ) ;
64062: LD_ADDR_VAR 0 5
64066: PUSH
64067: LD_VAR 0 1
64071: PPUSH
64072: CALL_OW 274
64076: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64077: LD_ADDR_VAR 0 4
64081: PUSH
64082: LD_VAR 0 2
64086: PUSH
64087: LD_INT 1
64089: ARRAY
64090: PPUSH
64091: LD_VAR 0 2
64095: PUSH
64096: LD_INT 2
64098: ARRAY
64099: PPUSH
64100: LD_VAR 0 2
64104: PUSH
64105: LD_INT 3
64107: ARRAY
64108: PPUSH
64109: LD_VAR 0 2
64113: PUSH
64114: LD_INT 4
64116: ARRAY
64117: PPUSH
64118: CALL_OW 449
64122: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64123: LD_ADDR_VAR 0 3
64127: PUSH
64128: LD_VAR 0 5
64132: PPUSH
64133: LD_INT 1
64135: PPUSH
64136: CALL_OW 275
64140: PUSH
64141: LD_VAR 0 4
64145: PUSH
64146: LD_INT 1
64148: ARRAY
64149: GREATEREQUAL
64150: PUSH
64151: LD_VAR 0 5
64155: PPUSH
64156: LD_INT 2
64158: PPUSH
64159: CALL_OW 275
64163: PUSH
64164: LD_VAR 0 4
64168: PUSH
64169: LD_INT 2
64171: ARRAY
64172: GREATEREQUAL
64173: AND
64174: PUSH
64175: LD_VAR 0 5
64179: PPUSH
64180: LD_INT 3
64182: PPUSH
64183: CALL_OW 275
64187: PUSH
64188: LD_VAR 0 4
64192: PUSH
64193: LD_INT 3
64195: ARRAY
64196: GREATEREQUAL
64197: AND
64198: ST_TO_ADDR
// end ;
64199: LD_VAR 0 3
64203: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64204: LD_INT 0
64206: PPUSH
64207: PPUSH
64208: PPUSH
64209: PPUSH
// pom := GetBase ( building ) ;
64210: LD_ADDR_VAR 0 3
64214: PUSH
64215: LD_VAR 0 1
64219: PPUSH
64220: CALL_OW 274
64224: ST_TO_ADDR
// if not pom then
64225: LD_VAR 0 3
64229: NOT
64230: IFFALSE 64234
// exit ;
64232: GO 64404
// btype := GetBType ( building ) ;
64234: LD_ADDR_VAR 0 5
64238: PUSH
64239: LD_VAR 0 1
64243: PPUSH
64244: CALL_OW 266
64248: ST_TO_ADDR
// if btype = b_armoury then
64249: LD_VAR 0 5
64253: PUSH
64254: LD_INT 4
64256: EQUAL
64257: IFFALSE 64267
// btype := b_barracks ;
64259: LD_ADDR_VAR 0 5
64263: PUSH
64264: LD_INT 5
64266: ST_TO_ADDR
// if btype = b_depot then
64267: LD_VAR 0 5
64271: PUSH
64272: LD_INT 0
64274: EQUAL
64275: IFFALSE 64285
// btype := b_warehouse ;
64277: LD_ADDR_VAR 0 5
64281: PUSH
64282: LD_INT 1
64284: ST_TO_ADDR
// if btype = b_workshop then
64285: LD_VAR 0 5
64289: PUSH
64290: LD_INT 2
64292: EQUAL
64293: IFFALSE 64303
// btype := b_factory ;
64295: LD_ADDR_VAR 0 5
64299: PUSH
64300: LD_INT 3
64302: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64303: LD_ADDR_VAR 0 4
64307: PUSH
64308: LD_VAR 0 5
64312: PPUSH
64313: LD_VAR 0 1
64317: PPUSH
64318: CALL_OW 248
64322: PPUSH
64323: CALL_OW 450
64327: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64328: LD_ADDR_VAR 0 2
64332: PUSH
64333: LD_VAR 0 3
64337: PPUSH
64338: LD_INT 1
64340: PPUSH
64341: CALL_OW 275
64345: PUSH
64346: LD_VAR 0 4
64350: PUSH
64351: LD_INT 1
64353: ARRAY
64354: GREATEREQUAL
64355: PUSH
64356: LD_VAR 0 3
64360: PPUSH
64361: LD_INT 2
64363: PPUSH
64364: CALL_OW 275
64368: PUSH
64369: LD_VAR 0 4
64373: PUSH
64374: LD_INT 2
64376: ARRAY
64377: GREATEREQUAL
64378: AND
64379: PUSH
64380: LD_VAR 0 3
64384: PPUSH
64385: LD_INT 3
64387: PPUSH
64388: CALL_OW 275
64392: PUSH
64393: LD_VAR 0 4
64397: PUSH
64398: LD_INT 3
64400: ARRAY
64401: GREATEREQUAL
64402: AND
64403: ST_TO_ADDR
// end ;
64404: LD_VAR 0 2
64408: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64409: LD_INT 0
64411: PPUSH
64412: PPUSH
64413: PPUSH
// pom := GetBase ( building ) ;
64414: LD_ADDR_VAR 0 4
64418: PUSH
64419: LD_VAR 0 1
64423: PPUSH
64424: CALL_OW 274
64428: ST_TO_ADDR
// if not pom then
64429: LD_VAR 0 4
64433: NOT
64434: IFFALSE 64438
// exit ;
64436: GO 64539
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64438: LD_ADDR_VAR 0 5
64442: PUSH
64443: LD_VAR 0 2
64447: PPUSH
64448: LD_VAR 0 1
64452: PPUSH
64453: CALL_OW 248
64457: PPUSH
64458: CALL_OW 450
64462: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64463: LD_ADDR_VAR 0 3
64467: PUSH
64468: LD_VAR 0 4
64472: PPUSH
64473: LD_INT 1
64475: PPUSH
64476: CALL_OW 275
64480: PUSH
64481: LD_VAR 0 5
64485: PUSH
64486: LD_INT 1
64488: ARRAY
64489: GREATEREQUAL
64490: PUSH
64491: LD_VAR 0 4
64495: PPUSH
64496: LD_INT 2
64498: PPUSH
64499: CALL_OW 275
64503: PUSH
64504: LD_VAR 0 5
64508: PUSH
64509: LD_INT 2
64511: ARRAY
64512: GREATEREQUAL
64513: AND
64514: PUSH
64515: LD_VAR 0 4
64519: PPUSH
64520: LD_INT 3
64522: PPUSH
64523: CALL_OW 275
64527: PUSH
64528: LD_VAR 0 5
64532: PUSH
64533: LD_INT 3
64535: ARRAY
64536: GREATEREQUAL
64537: AND
64538: ST_TO_ADDR
// end ;
64539: LD_VAR 0 3
64543: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64544: LD_INT 0
64546: PPUSH
64547: PPUSH
64548: PPUSH
64549: PPUSH
64550: PPUSH
64551: PPUSH
64552: PPUSH
64553: PPUSH
64554: PPUSH
64555: PPUSH
// result := false ;
64556: LD_ADDR_VAR 0 6
64560: PUSH
64561: LD_INT 0
64563: ST_TO_ADDR
// if not base or not btype or not x or not y then
64564: LD_VAR 0 1
64568: NOT
64569: PUSH
64570: LD_VAR 0 2
64574: NOT
64575: OR
64576: PUSH
64577: LD_VAR 0 3
64581: NOT
64582: OR
64583: PUSH
64584: LD_VAR 0 4
64588: NOT
64589: OR
64590: IFFALSE 64594
// exit ;
64592: GO 65203
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64594: LD_ADDR_VAR 0 12
64598: PUSH
64599: LD_VAR 0 2
64603: PPUSH
64604: LD_VAR 0 3
64608: PPUSH
64609: LD_VAR 0 4
64613: PPUSH
64614: LD_VAR 0 5
64618: PPUSH
64619: LD_VAR 0 1
64623: PUSH
64624: LD_INT 1
64626: ARRAY
64627: PPUSH
64628: CALL_OW 248
64632: PPUSH
64633: LD_INT 0
64635: PPUSH
64636: CALL 66040 0 6
64640: ST_TO_ADDR
// if not hexes then
64641: LD_VAR 0 12
64645: NOT
64646: IFFALSE 64650
// exit ;
64648: GO 65203
// for i = 1 to hexes do
64650: LD_ADDR_VAR 0 7
64654: PUSH
64655: DOUBLE
64656: LD_INT 1
64658: DEC
64659: ST_TO_ADDR
64660: LD_VAR 0 12
64664: PUSH
64665: FOR_TO
64666: IFFALSE 65201
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64668: LD_ADDR_VAR 0 11
64672: PUSH
64673: LD_VAR 0 12
64677: PUSH
64678: LD_VAR 0 7
64682: ARRAY
64683: PUSH
64684: LD_INT 1
64686: ARRAY
64687: PPUSH
64688: LD_VAR 0 12
64692: PUSH
64693: LD_VAR 0 7
64697: ARRAY
64698: PUSH
64699: LD_INT 2
64701: ARRAY
64702: PPUSH
64703: CALL_OW 428
64707: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64708: LD_VAR 0 12
64712: PUSH
64713: LD_VAR 0 7
64717: ARRAY
64718: PUSH
64719: LD_INT 1
64721: ARRAY
64722: PPUSH
64723: LD_VAR 0 12
64727: PUSH
64728: LD_VAR 0 7
64732: ARRAY
64733: PUSH
64734: LD_INT 2
64736: ARRAY
64737: PPUSH
64738: CALL_OW 351
64742: PUSH
64743: LD_VAR 0 12
64747: PUSH
64748: LD_VAR 0 7
64752: ARRAY
64753: PUSH
64754: LD_INT 1
64756: ARRAY
64757: PPUSH
64758: LD_VAR 0 12
64762: PUSH
64763: LD_VAR 0 7
64767: ARRAY
64768: PUSH
64769: LD_INT 2
64771: ARRAY
64772: PPUSH
64773: CALL_OW 488
64777: NOT
64778: OR
64779: PUSH
64780: LD_VAR 0 11
64784: PPUSH
64785: CALL_OW 247
64789: PUSH
64790: LD_INT 3
64792: EQUAL
64793: OR
64794: IFFALSE 64800
// exit ;
64796: POP
64797: POP
64798: GO 65203
// if not tmp or not tmp in base then
64800: LD_VAR 0 11
64804: NOT
64805: PUSH
64806: LD_VAR 0 11
64810: PUSH
64811: LD_VAR 0 1
64815: IN
64816: NOT
64817: OR
64818: IFFALSE 64822
// continue ;
64820: GO 64665
// result := true ;
64822: LD_ADDR_VAR 0 6
64826: PUSH
64827: LD_INT 1
64829: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64830: LD_ADDR_VAR 0 15
64834: PUSH
64835: LD_VAR 0 1
64839: PPUSH
64840: LD_INT 22
64842: PUSH
64843: LD_VAR 0 11
64847: PPUSH
64848: CALL_OW 255
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 2
64859: PUSH
64860: LD_INT 30
64862: PUSH
64863: LD_INT 0
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: LD_INT 30
64872: PUSH
64873: LD_INT 1
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: LIST
64884: PUSH
64885: EMPTY
64886: LIST
64887: LIST
64888: PPUSH
64889: CALL_OW 72
64893: ST_TO_ADDR
// if dep then
64894: LD_VAR 0 15
64898: IFFALSE 65034
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64900: LD_ADDR_VAR 0 14
64904: PUSH
64905: LD_VAR 0 15
64909: PUSH
64910: LD_INT 1
64912: ARRAY
64913: PPUSH
64914: CALL_OW 250
64918: PPUSH
64919: LD_VAR 0 15
64923: PUSH
64924: LD_INT 1
64926: ARRAY
64927: PPUSH
64928: CALL_OW 254
64932: PPUSH
64933: LD_INT 5
64935: PPUSH
64936: CALL_OW 272
64940: PUSH
64941: LD_VAR 0 15
64945: PUSH
64946: LD_INT 1
64948: ARRAY
64949: PPUSH
64950: CALL_OW 251
64954: PPUSH
64955: LD_VAR 0 15
64959: PUSH
64960: LD_INT 1
64962: ARRAY
64963: PPUSH
64964: CALL_OW 254
64968: PPUSH
64969: LD_INT 5
64971: PPUSH
64972: CALL_OW 273
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64981: LD_VAR 0 14
64985: PUSH
64986: LD_INT 1
64988: ARRAY
64989: PPUSH
64990: LD_VAR 0 14
64994: PUSH
64995: LD_INT 2
64997: ARRAY
64998: PPUSH
64999: CALL_OW 488
65003: IFFALSE 65034
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65005: LD_VAR 0 11
65009: PPUSH
65010: LD_VAR 0 14
65014: PUSH
65015: LD_INT 1
65017: ARRAY
65018: PPUSH
65019: LD_VAR 0 14
65023: PUSH
65024: LD_INT 2
65026: ARRAY
65027: PPUSH
65028: CALL_OW 111
// continue ;
65032: GO 64665
// end ; end ; r := GetDir ( tmp ) ;
65034: LD_ADDR_VAR 0 13
65038: PUSH
65039: LD_VAR 0 11
65043: PPUSH
65044: CALL_OW 254
65048: ST_TO_ADDR
// if r = 5 then
65049: LD_VAR 0 13
65053: PUSH
65054: LD_INT 5
65056: EQUAL
65057: IFFALSE 65067
// r := 0 ;
65059: LD_ADDR_VAR 0 13
65063: PUSH
65064: LD_INT 0
65066: ST_TO_ADDR
// for j = r to 5 do
65067: LD_ADDR_VAR 0 8
65071: PUSH
65072: DOUBLE
65073: LD_VAR 0 13
65077: DEC
65078: ST_TO_ADDR
65079: LD_INT 5
65081: PUSH
65082: FOR_TO
65083: IFFALSE 65197
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65085: LD_ADDR_VAR 0 9
65089: PUSH
65090: LD_VAR 0 11
65094: PPUSH
65095: CALL_OW 250
65099: PPUSH
65100: LD_VAR 0 8
65104: PPUSH
65105: LD_INT 2
65107: PPUSH
65108: CALL_OW 272
65112: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65113: LD_ADDR_VAR 0 10
65117: PUSH
65118: LD_VAR 0 11
65122: PPUSH
65123: CALL_OW 251
65127: PPUSH
65128: LD_VAR 0 8
65132: PPUSH
65133: LD_INT 2
65135: PPUSH
65136: CALL_OW 273
65140: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65141: LD_VAR 0 9
65145: PPUSH
65146: LD_VAR 0 10
65150: PPUSH
65151: CALL_OW 488
65155: PUSH
65156: LD_VAR 0 9
65160: PPUSH
65161: LD_VAR 0 10
65165: PPUSH
65166: CALL_OW 428
65170: NOT
65171: AND
65172: IFFALSE 65195
// begin ComMoveXY ( tmp , _x , _y ) ;
65174: LD_VAR 0 11
65178: PPUSH
65179: LD_VAR 0 9
65183: PPUSH
65184: LD_VAR 0 10
65188: PPUSH
65189: CALL_OW 111
// break ;
65193: GO 65197
// end ; end ;
65195: GO 65082
65197: POP
65198: POP
// end ;
65199: GO 64665
65201: POP
65202: POP
// end ;
65203: LD_VAR 0 6
65207: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65208: LD_INT 0
65210: PPUSH
65211: PPUSH
65212: PPUSH
65213: PPUSH
65214: PPUSH
65215: PPUSH
65216: PPUSH
65217: PPUSH
65218: PPUSH
65219: PPUSH
// result := false ;
65220: LD_ADDR_VAR 0 6
65224: PUSH
65225: LD_INT 0
65227: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65228: LD_VAR 0 1
65232: NOT
65233: PUSH
65234: LD_VAR 0 1
65238: PPUSH
65239: CALL_OW 266
65243: PUSH
65244: LD_INT 0
65246: PUSH
65247: LD_INT 1
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: IN
65254: NOT
65255: OR
65256: PUSH
65257: LD_VAR 0 2
65261: NOT
65262: OR
65263: PUSH
65264: LD_VAR 0 5
65268: PUSH
65269: LD_INT 0
65271: PUSH
65272: LD_INT 1
65274: PUSH
65275: LD_INT 2
65277: PUSH
65278: LD_INT 3
65280: PUSH
65281: LD_INT 4
65283: PUSH
65284: LD_INT 5
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: IN
65295: NOT
65296: OR
65297: PUSH
65298: LD_VAR 0 3
65302: PPUSH
65303: LD_VAR 0 4
65307: PPUSH
65308: CALL_OW 488
65312: NOT
65313: OR
65314: IFFALSE 65318
// exit ;
65316: GO 66035
// pom := GetBase ( depot ) ;
65318: LD_ADDR_VAR 0 10
65322: PUSH
65323: LD_VAR 0 1
65327: PPUSH
65328: CALL_OW 274
65332: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65333: LD_ADDR_VAR 0 11
65337: PUSH
65338: LD_VAR 0 2
65342: PPUSH
65343: LD_VAR 0 1
65347: PPUSH
65348: CALL_OW 248
65352: PPUSH
65353: CALL_OW 450
65357: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65358: LD_VAR 0 10
65362: PPUSH
65363: LD_INT 1
65365: PPUSH
65366: CALL_OW 275
65370: PUSH
65371: LD_VAR 0 11
65375: PUSH
65376: LD_INT 1
65378: ARRAY
65379: GREATEREQUAL
65380: PUSH
65381: LD_VAR 0 10
65385: PPUSH
65386: LD_INT 2
65388: PPUSH
65389: CALL_OW 275
65393: PUSH
65394: LD_VAR 0 11
65398: PUSH
65399: LD_INT 2
65401: ARRAY
65402: GREATEREQUAL
65403: AND
65404: PUSH
65405: LD_VAR 0 10
65409: PPUSH
65410: LD_INT 3
65412: PPUSH
65413: CALL_OW 275
65417: PUSH
65418: LD_VAR 0 11
65422: PUSH
65423: LD_INT 3
65425: ARRAY
65426: GREATEREQUAL
65427: AND
65428: NOT
65429: IFFALSE 65433
// exit ;
65431: GO 66035
// if GetBType ( depot ) = b_depot then
65433: LD_VAR 0 1
65437: PPUSH
65438: CALL_OW 266
65442: PUSH
65443: LD_INT 0
65445: EQUAL
65446: IFFALSE 65458
// dist := 28 else
65448: LD_ADDR_VAR 0 14
65452: PUSH
65453: LD_INT 28
65455: ST_TO_ADDR
65456: GO 65466
// dist := 36 ;
65458: LD_ADDR_VAR 0 14
65462: PUSH
65463: LD_INT 36
65465: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65466: LD_VAR 0 1
65470: PPUSH
65471: LD_VAR 0 3
65475: PPUSH
65476: LD_VAR 0 4
65480: PPUSH
65481: CALL_OW 297
65485: PUSH
65486: LD_VAR 0 14
65490: GREATER
65491: IFFALSE 65495
// exit ;
65493: GO 66035
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65495: LD_ADDR_VAR 0 12
65499: PUSH
65500: LD_VAR 0 2
65504: PPUSH
65505: LD_VAR 0 3
65509: PPUSH
65510: LD_VAR 0 4
65514: PPUSH
65515: LD_VAR 0 5
65519: PPUSH
65520: LD_VAR 0 1
65524: PPUSH
65525: CALL_OW 248
65529: PPUSH
65530: LD_INT 0
65532: PPUSH
65533: CALL 66040 0 6
65537: ST_TO_ADDR
// if not hexes then
65538: LD_VAR 0 12
65542: NOT
65543: IFFALSE 65547
// exit ;
65545: GO 66035
// hex := GetHexInfo ( x , y ) ;
65547: LD_ADDR_VAR 0 15
65551: PUSH
65552: LD_VAR 0 3
65556: PPUSH
65557: LD_VAR 0 4
65561: PPUSH
65562: CALL_OW 546
65566: ST_TO_ADDR
// if hex [ 1 ] then
65567: LD_VAR 0 15
65571: PUSH
65572: LD_INT 1
65574: ARRAY
65575: IFFALSE 65579
// exit ;
65577: GO 66035
// height := hex [ 2 ] ;
65579: LD_ADDR_VAR 0 13
65583: PUSH
65584: LD_VAR 0 15
65588: PUSH
65589: LD_INT 2
65591: ARRAY
65592: ST_TO_ADDR
// for i = 1 to hexes do
65593: LD_ADDR_VAR 0 7
65597: PUSH
65598: DOUBLE
65599: LD_INT 1
65601: DEC
65602: ST_TO_ADDR
65603: LD_VAR 0 12
65607: PUSH
65608: FOR_TO
65609: IFFALSE 65939
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65611: LD_VAR 0 12
65615: PUSH
65616: LD_VAR 0 7
65620: ARRAY
65621: PUSH
65622: LD_INT 1
65624: ARRAY
65625: PPUSH
65626: LD_VAR 0 12
65630: PUSH
65631: LD_VAR 0 7
65635: ARRAY
65636: PUSH
65637: LD_INT 2
65639: ARRAY
65640: PPUSH
65641: CALL_OW 488
65645: NOT
65646: PUSH
65647: LD_VAR 0 12
65651: PUSH
65652: LD_VAR 0 7
65656: ARRAY
65657: PUSH
65658: LD_INT 1
65660: ARRAY
65661: PPUSH
65662: LD_VAR 0 12
65666: PUSH
65667: LD_VAR 0 7
65671: ARRAY
65672: PUSH
65673: LD_INT 2
65675: ARRAY
65676: PPUSH
65677: CALL_OW 428
65681: PUSH
65682: LD_INT 0
65684: GREATER
65685: OR
65686: PUSH
65687: LD_VAR 0 12
65691: PUSH
65692: LD_VAR 0 7
65696: ARRAY
65697: PUSH
65698: LD_INT 1
65700: ARRAY
65701: PPUSH
65702: LD_VAR 0 12
65706: PUSH
65707: LD_VAR 0 7
65711: ARRAY
65712: PUSH
65713: LD_INT 2
65715: ARRAY
65716: PPUSH
65717: CALL_OW 351
65721: OR
65722: IFFALSE 65728
// exit ;
65724: POP
65725: POP
65726: GO 66035
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65728: LD_ADDR_VAR 0 8
65732: PUSH
65733: LD_VAR 0 12
65737: PUSH
65738: LD_VAR 0 7
65742: ARRAY
65743: PUSH
65744: LD_INT 1
65746: ARRAY
65747: PPUSH
65748: LD_VAR 0 12
65752: PUSH
65753: LD_VAR 0 7
65757: ARRAY
65758: PUSH
65759: LD_INT 2
65761: ARRAY
65762: PPUSH
65763: CALL_OW 546
65767: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65768: LD_VAR 0 8
65772: PUSH
65773: LD_INT 1
65775: ARRAY
65776: PUSH
65777: LD_VAR 0 8
65781: PUSH
65782: LD_INT 2
65784: ARRAY
65785: PUSH
65786: LD_VAR 0 13
65790: PUSH
65791: LD_INT 2
65793: PLUS
65794: GREATER
65795: OR
65796: PUSH
65797: LD_VAR 0 8
65801: PUSH
65802: LD_INT 2
65804: ARRAY
65805: PUSH
65806: LD_VAR 0 13
65810: PUSH
65811: LD_INT 2
65813: MINUS
65814: LESS
65815: OR
65816: PUSH
65817: LD_VAR 0 8
65821: PUSH
65822: LD_INT 3
65824: ARRAY
65825: PUSH
65826: LD_INT 0
65828: PUSH
65829: LD_INT 8
65831: PUSH
65832: LD_INT 9
65834: PUSH
65835: LD_INT 10
65837: PUSH
65838: LD_INT 11
65840: PUSH
65841: LD_INT 12
65843: PUSH
65844: LD_INT 13
65846: PUSH
65847: LD_INT 16
65849: PUSH
65850: LD_INT 17
65852: PUSH
65853: LD_INT 18
65855: PUSH
65856: LD_INT 19
65858: PUSH
65859: LD_INT 20
65861: PUSH
65862: LD_INT 21
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: LIST
65879: IN
65880: NOT
65881: OR
65882: PUSH
65883: LD_VAR 0 8
65887: PUSH
65888: LD_INT 5
65890: ARRAY
65891: NOT
65892: OR
65893: PUSH
65894: LD_VAR 0 8
65898: PUSH
65899: LD_INT 6
65901: ARRAY
65902: PUSH
65903: LD_INT 1
65905: PUSH
65906: LD_INT 2
65908: PUSH
65909: LD_INT 7
65911: PUSH
65912: LD_INT 9
65914: PUSH
65915: LD_INT 10
65917: PUSH
65918: LD_INT 11
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: IN
65929: NOT
65930: OR
65931: IFFALSE 65937
// exit ;
65933: POP
65934: POP
65935: GO 66035
// end ;
65937: GO 65608
65939: POP
65940: POP
// side := GetSide ( depot ) ;
65941: LD_ADDR_VAR 0 9
65945: PUSH
65946: LD_VAR 0 1
65950: PPUSH
65951: CALL_OW 255
65955: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65956: LD_VAR 0 9
65960: PPUSH
65961: LD_VAR 0 3
65965: PPUSH
65966: LD_VAR 0 4
65970: PPUSH
65971: LD_INT 20
65973: PPUSH
65974: CALL 58689 0 4
65978: PUSH
65979: LD_INT 4
65981: ARRAY
65982: IFFALSE 65986
// exit ;
65984: GO 66035
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65986: LD_VAR 0 2
65990: PUSH
65991: LD_INT 29
65993: PUSH
65994: LD_INT 30
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: IN
66001: PUSH
66002: LD_VAR 0 3
66006: PPUSH
66007: LD_VAR 0 4
66011: PPUSH
66012: LD_VAR 0 9
66016: PPUSH
66017: CALL_OW 440
66021: NOT
66022: AND
66023: IFFALSE 66027
// exit ;
66025: GO 66035
// result := true ;
66027: LD_ADDR_VAR 0 6
66031: PUSH
66032: LD_INT 1
66034: ST_TO_ADDR
// end ;
66035: LD_VAR 0 6
66039: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
66040: LD_INT 0
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
66062: PPUSH
66063: PPUSH
66064: PPUSH
66065: PPUSH
66066: PPUSH
66067: PPUSH
66068: PPUSH
66069: PPUSH
66070: PPUSH
66071: PPUSH
66072: PPUSH
66073: PPUSH
66074: PPUSH
66075: PPUSH
66076: PPUSH
66077: PPUSH
66078: PPUSH
66079: PPUSH
66080: PPUSH
66081: PPUSH
66082: PPUSH
66083: PPUSH
66084: PPUSH
66085: PPUSH
66086: PPUSH
66087: PPUSH
66088: PPUSH
66089: PPUSH
66090: PPUSH
66091: PPUSH
66092: PPUSH
66093: PPUSH
66094: PPUSH
66095: PPUSH
66096: PPUSH
66097: PPUSH
66098: PPUSH
66099: PPUSH
// result = [ ] ;
66100: LD_ADDR_VAR 0 7
66104: PUSH
66105: EMPTY
66106: ST_TO_ADDR
// temp_list = [ ] ;
66107: LD_ADDR_VAR 0 9
66111: PUSH
66112: EMPTY
66113: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66114: LD_VAR 0 4
66118: PUSH
66119: LD_INT 0
66121: PUSH
66122: LD_INT 1
66124: PUSH
66125: LD_INT 2
66127: PUSH
66128: LD_INT 3
66130: PUSH
66131: LD_INT 4
66133: PUSH
66134: LD_INT 5
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: IN
66145: NOT
66146: PUSH
66147: LD_VAR 0 1
66151: PUSH
66152: LD_INT 0
66154: PUSH
66155: LD_INT 1
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: IN
66162: PUSH
66163: LD_VAR 0 5
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: LD_INT 2
66173: PUSH
66174: LD_INT 3
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: LIST
66181: IN
66182: NOT
66183: AND
66184: OR
66185: IFFALSE 66189
// exit ;
66187: GO 84580
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66189: LD_VAR 0 1
66193: PUSH
66194: LD_INT 6
66196: PUSH
66197: LD_INT 7
66199: PUSH
66200: LD_INT 8
66202: PUSH
66203: LD_INT 13
66205: PUSH
66206: LD_INT 12
66208: PUSH
66209: LD_INT 15
66211: PUSH
66212: LD_INT 11
66214: PUSH
66215: LD_INT 14
66217: PUSH
66218: LD_INT 10
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: IN
66232: IFFALSE 66242
// btype = b_lab ;
66234: LD_ADDR_VAR 0 1
66238: PUSH
66239: LD_INT 6
66241: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66242: LD_VAR 0 6
66246: PUSH
66247: LD_INT 0
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 2
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: LIST
66260: IN
66261: NOT
66262: PUSH
66263: LD_VAR 0 1
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: LD_INT 1
66273: PUSH
66274: LD_INT 2
66276: PUSH
66277: LD_INT 3
66279: PUSH
66280: LD_INT 6
66282: PUSH
66283: LD_INT 36
66285: PUSH
66286: LD_INT 4
66288: PUSH
66289: LD_INT 5
66291: PUSH
66292: LD_INT 31
66294: PUSH
66295: LD_INT 32
66297: PUSH
66298: LD_INT 33
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: IN
66314: NOT
66315: PUSH
66316: LD_VAR 0 6
66320: PUSH
66321: LD_INT 1
66323: EQUAL
66324: AND
66325: OR
66326: PUSH
66327: LD_VAR 0 1
66331: PUSH
66332: LD_INT 2
66334: PUSH
66335: LD_INT 3
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: IN
66342: NOT
66343: PUSH
66344: LD_VAR 0 6
66348: PUSH
66349: LD_INT 2
66351: EQUAL
66352: AND
66353: OR
66354: IFFALSE 66364
// mode = 0 ;
66356: LD_ADDR_VAR 0 6
66360: PUSH
66361: LD_INT 0
66363: ST_TO_ADDR
// case mode of 0 :
66364: LD_VAR 0 6
66368: PUSH
66369: LD_INT 0
66371: DOUBLE
66372: EQUAL
66373: IFTRUE 66377
66375: GO 77830
66377: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66378: LD_ADDR_VAR 0 11
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 0
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: LD_INT 0
66395: PUSH
66396: LD_INT 1
66398: NEG
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: LD_INT 0
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 1
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 1
66436: NEG
66437: PUSH
66438: LD_INT 0
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 1
66447: NEG
66448: PUSH
66449: LD_INT 1
66451: NEG
66452: PUSH
66453: EMPTY
66454: LIST
66455: LIST
66456: PUSH
66457: LD_INT 1
66459: NEG
66460: PUSH
66461: LD_INT 2
66463: NEG
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: LD_INT 2
66474: NEG
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 1
66482: PUSH
66483: LD_INT 1
66485: NEG
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 0
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 1
66513: NEG
66514: PUSH
66515: LD_INT 1
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 3
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: LD_INT 3
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: LD_INT 2
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66571: LD_ADDR_VAR 0 12
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: LD_INT 0
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: LD_INT 1
66591: NEG
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 1
66599: PUSH
66600: LD_INT 0
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: LD_INT 1
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 0
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 1
66629: NEG
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 1
66640: NEG
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: LD_INT 0
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 2
66673: PUSH
66674: LD_INT 1
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: LD_INT 1
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PUSH
66692: LD_INT 2
66694: NEG
66695: PUSH
66696: LD_INT 0
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: LD_INT 2
66705: NEG
66706: PUSH
66707: LD_INT 1
66709: NEG
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 2
66717: NEG
66718: PUSH
66719: LD_INT 1
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 3
66728: NEG
66729: PUSH
66730: LD_INT 0
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: LD_INT 3
66739: NEG
66740: PUSH
66741: LD_INT 1
66743: NEG
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66767: LD_ADDR_VAR 0 13
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 1
66787: NEG
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: LD_INT 0
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: LD_INT 1
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 2
66852: NEG
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 2
66860: PUSH
66861: LD_INT 1
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 2
66870: PUSH
66871: LD_INT 2
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: LD_INT 1
66880: PUSH
66881: LD_INT 2
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 2
66890: NEG
66891: PUSH
66892: LD_INT 1
66894: NEG
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 2
66902: NEG
66903: PUSH
66904: LD_INT 2
66906: NEG
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: PUSH
66912: LD_INT 2
66914: NEG
66915: PUSH
66916: LD_INT 3
66918: NEG
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 3
66926: NEG
66927: PUSH
66928: LD_INT 2
66930: NEG
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 3
66938: NEG
66939: PUSH
66940: LD_INT 3
66942: NEG
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66966: LD_ADDR_VAR 0 14
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: LD_INT 0
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: LD_INT 1
66986: NEG
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 1
67004: PUSH
67005: LD_INT 1
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: LD_INT 0
67014: PUSH
67015: LD_INT 1
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 1
67024: NEG
67025: PUSH
67026: LD_INT 0
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 1
67047: NEG
67048: PUSH
67049: LD_INT 2
67051: NEG
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: LD_INT 2
67062: NEG
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 1
67070: PUSH
67071: LD_INT 1
67073: NEG
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 1
67081: PUSH
67082: LD_INT 2
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 2
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: NEG
67113: PUSH
67114: LD_INT 3
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 3
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 1
67135: PUSH
67136: LD_INT 2
67138: NEG
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67162: LD_ADDR_VAR 0 15
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 1
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 1
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 0
67210: PUSH
67211: LD_INT 1
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: LD_INT 1
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: PUSH
67244: LD_INT 1
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: LD_INT 0
67257: PUSH
67258: EMPTY
67259: LIST
67260: LIST
67261: PUSH
67262: LD_INT 2
67264: PUSH
67265: LD_INT 1
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: LD_INT 1
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 2
67285: NEG
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 2
67296: NEG
67297: PUSH
67298: LD_INT 1
67300: NEG
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 2
67308: PUSH
67309: LD_INT 1
67311: NEG
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 3
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 3
67329: PUSH
67330: LD_INT 1
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67355: LD_ADDR_VAR 0 16
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 0
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 0
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 1
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 0
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 1
67413: NEG
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 1
67424: NEG
67425: PUSH
67426: LD_INT 1
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 1
67436: NEG
67437: PUSH
67438: LD_INT 2
67440: NEG
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 2
67448: PUSH
67449: LD_INT 1
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 2
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 1
67468: PUSH
67469: LD_INT 2
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 2
67478: NEG
67479: PUSH
67480: LD_INT 1
67482: NEG
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 2
67490: NEG
67491: PUSH
67492: LD_INT 2
67494: NEG
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 3
67502: PUSH
67503: LD_INT 2
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 3
67512: PUSH
67513: LD_INT 3
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: LD_INT 3
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: LIST
67542: LIST
67543: LIST
67544: LIST
67545: LIST
67546: LIST
67547: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67548: LD_ADDR_VAR 0 17
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: LD_INT 0
67558: PUSH
67559: EMPTY
67560: LIST
67561: LIST
67562: PUSH
67563: LD_INT 0
67565: PUSH
67566: LD_INT 1
67568: NEG
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 0
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 1
67586: PUSH
67587: LD_INT 1
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 0
67596: PUSH
67597: LD_INT 1
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 1
67606: NEG
67607: PUSH
67608: LD_INT 0
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 1
67617: NEG
67618: PUSH
67619: LD_INT 1
67621: NEG
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 1
67629: NEG
67630: PUSH
67631: LD_INT 2
67633: NEG
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: LD_INT 0
67641: PUSH
67642: LD_INT 2
67644: NEG
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: LD_INT 1
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 2
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 2
67673: PUSH
67674: LD_INT 1
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 2
67683: PUSH
67684: LD_INT 2
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: PUSH
67691: LD_INT 1
67693: PUSH
67694: LD_INT 2
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: PUSH
67701: LD_INT 0
67703: PUSH
67704: LD_INT 2
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 1
67713: NEG
67714: PUSH
67715: LD_INT 1
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 2
67724: NEG
67725: PUSH
67726: LD_INT 0
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 2
67735: NEG
67736: PUSH
67737: LD_INT 1
67739: NEG
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 2
67747: NEG
67748: PUSH
67749: LD_INT 2
67751: NEG
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67778: LD_ADDR_VAR 0 18
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 1
67798: NEG
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: LD_INT 0
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 0
67826: PUSH
67827: LD_INT 1
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 1
67836: NEG
67837: PUSH
67838: LD_INT 0
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: LD_INT 1
67851: NEG
67852: PUSH
67853: EMPTY
67854: LIST
67855: LIST
67856: PUSH
67857: LD_INT 1
67859: NEG
67860: PUSH
67861: LD_INT 2
67863: NEG
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 0
67871: PUSH
67872: LD_INT 2
67874: NEG
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 1
67882: PUSH
67883: LD_INT 1
67885: NEG
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 2
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: LD_INT 1
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: LD_INT 2
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 1
67923: PUSH
67924: LD_INT 2
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 0
67933: PUSH
67934: LD_INT 2
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 1
67943: NEG
67944: PUSH
67945: LD_INT 1
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 2
67954: NEG
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 2
67965: NEG
67966: PUSH
67967: LD_INT 1
67969: NEG
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: LD_INT 2
67977: NEG
67978: PUSH
67979: LD_INT 2
67981: NEG
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68008: LD_ADDR_VAR 0 19
68012: PUSH
68013: LD_INT 0
68015: PUSH
68016: LD_INT 0
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 1
68028: NEG
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 1
68036: PUSH
68037: LD_INT 0
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 1
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 0
68056: PUSH
68057: LD_INT 1
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: NEG
68067: PUSH
68068: LD_INT 0
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 1
68077: NEG
68078: PUSH
68079: LD_INT 1
68081: NEG
68082: PUSH
68083: EMPTY
68084: LIST
68085: LIST
68086: PUSH
68087: LD_INT 1
68089: NEG
68090: PUSH
68091: LD_INT 2
68093: NEG
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PUSH
68099: LD_INT 0
68101: PUSH
68102: LD_INT 2
68104: NEG
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 1
68112: PUSH
68113: LD_INT 1
68115: NEG
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 2
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 2
68133: PUSH
68134: LD_INT 1
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 2
68143: PUSH
68144: LD_INT 2
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: LD_INT 2
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 0
68163: PUSH
68164: LD_INT 2
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 1
68173: NEG
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 2
68184: NEG
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 2
68195: NEG
68196: PUSH
68197: LD_INT 1
68199: NEG
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: LD_INT 2
68207: NEG
68208: PUSH
68209: LD_INT 2
68211: NEG
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68238: LD_ADDR_VAR 0 20
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: LD_INT 0
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 1
68258: NEG
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 1
68266: PUSH
68267: LD_INT 0
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: LD_INT 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 1
68296: NEG
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 1
68307: NEG
68308: PUSH
68309: LD_INT 1
68311: NEG
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: LD_INT 1
68319: NEG
68320: PUSH
68321: LD_INT 2
68323: NEG
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 0
68331: PUSH
68332: LD_INT 2
68334: NEG
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: LD_INT 1
68342: PUSH
68343: LD_INT 1
68345: NEG
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 2
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 1
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 2
68373: PUSH
68374: LD_INT 2
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 1
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 0
68393: PUSH
68394: LD_INT 2
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 2
68414: NEG
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 2
68437: NEG
68438: PUSH
68439: LD_INT 2
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68468: LD_ADDR_VAR 0 21
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 1
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 0
68516: PUSH
68517: LD_INT 1
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 1
68526: NEG
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 1
68537: NEG
68538: PUSH
68539: LD_INT 1
68541: NEG
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 1
68549: NEG
68550: PUSH
68551: LD_INT 2
68553: NEG
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 0
68561: PUSH
68562: LD_INT 2
68564: NEG
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: LD_INT 1
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 2
68583: PUSH
68584: LD_INT 0
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 2
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 2
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 1
68613: PUSH
68614: LD_INT 2
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 0
68623: PUSH
68624: LD_INT 2
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 1
68633: NEG
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 2
68644: NEG
68645: PUSH
68646: LD_INT 0
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 2
68655: NEG
68656: PUSH
68657: LD_INT 1
68659: NEG
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 2
68667: NEG
68668: PUSH
68669: LD_INT 2
68671: NEG
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68698: LD_ADDR_VAR 0 22
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: LD_INT 0
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: LD_INT 1
68718: NEG
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 1
68736: PUSH
68737: LD_INT 1
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 0
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: NEG
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: LD_INT 1
68771: NEG
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 1
68779: NEG
68780: PUSH
68781: LD_INT 2
68783: NEG
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: LD_INT 0
68791: PUSH
68792: LD_INT 2
68794: NEG
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 1
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 1
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 2
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 1
68843: PUSH
68844: LD_INT 2
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 0
68853: PUSH
68854: LD_INT 2
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 1
68863: NEG
68864: PUSH
68865: LD_INT 1
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 2
68874: NEG
68875: PUSH
68876: LD_INT 0
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 2
68885: NEG
68886: PUSH
68887: LD_INT 1
68889: NEG
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 2
68897: NEG
68898: PUSH
68899: LD_INT 2
68901: NEG
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68928: LD_ADDR_VAR 0 23
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: LD_INT 1
68948: NEG
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 1
68956: PUSH
68957: LD_INT 0
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 1
68966: PUSH
68967: LD_INT 1
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: LD_INT 1
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: NEG
68987: PUSH
68988: LD_INT 0
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 1
68997: NEG
68998: PUSH
68999: LD_INT 1
69001: NEG
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: NEG
69010: PUSH
69011: LD_INT 2
69013: NEG
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 0
69021: PUSH
69022: LD_INT 2
69024: NEG
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: LD_INT 1
69032: PUSH
69033: LD_INT 1
69035: NEG
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 0
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: LD_INT 1
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: LD_INT 2
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 1
69073: PUSH
69074: LD_INT 2
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 0
69083: PUSH
69084: LD_INT 2
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 1
69093: NEG
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 2
69104: NEG
69105: PUSH
69106: LD_INT 0
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 2
69115: NEG
69116: PUSH
69117: LD_INT 1
69119: NEG
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 2
69127: NEG
69128: PUSH
69129: LD_INT 2
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 2
69139: NEG
69140: PUSH
69141: LD_INT 3
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: LD_INT 3
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 2
69166: NEG
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: LD_INT 1
69177: NEG
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69208: LD_ADDR_VAR 0 24
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: LD_INT 0
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PUSH
69223: LD_INT 0
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: LD_INT 0
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: LD_INT 1
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: LD_INT 0
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 1
69277: NEG
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 1
69289: NEG
69290: PUSH
69291: LD_INT 2
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 0
69301: PUSH
69302: LD_INT 2
69304: NEG
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 2
69323: PUSH
69324: LD_INT 0
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: LD_INT 1
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 2
69343: PUSH
69344: LD_INT 2
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 1
69353: PUSH
69354: LD_INT 2
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 0
69363: PUSH
69364: LD_INT 2
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 1
69373: NEG
69374: PUSH
69375: LD_INT 1
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 2
69384: NEG
69385: PUSH
69386: LD_INT 0
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 2
69395: NEG
69396: PUSH
69397: LD_INT 1
69399: NEG
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 2
69407: NEG
69408: PUSH
69409: LD_INT 2
69411: NEG
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: LD_INT 2
69422: NEG
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 2
69430: PUSH
69431: LD_INT 1
69433: NEG
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 3
69441: PUSH
69442: LD_INT 1
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 3
69451: PUSH
69452: LD_INT 2
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69484: LD_ADDR_VAR 0 25
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: LD_INT 0
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: PUSH
69499: LD_INT 0
69501: PUSH
69502: LD_INT 1
69504: NEG
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: LD_INT 0
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 1
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: LD_INT 1
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 1
69542: NEG
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 1
69553: NEG
69554: PUSH
69555: LD_INT 1
69557: NEG
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 1
69565: NEG
69566: PUSH
69567: LD_INT 2
69569: NEG
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 0
69577: PUSH
69578: LD_INT 2
69580: NEG
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 1
69588: PUSH
69589: LD_INT 1
69591: NEG
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: LD_INT 1
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 2
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 1
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 0
69639: PUSH
69640: LD_INT 2
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 1
69649: NEG
69650: PUSH
69651: LD_INT 1
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 2
69660: NEG
69661: PUSH
69662: LD_INT 0
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 2
69671: NEG
69672: PUSH
69673: LD_INT 1
69675: NEG
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 2
69683: NEG
69684: PUSH
69685: LD_INT 2
69687: NEG
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 3
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 3
69705: PUSH
69706: LD_INT 2
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 2
69715: PUSH
69716: LD_INT 3
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 1
69725: PUSH
69726: LD_INT 3
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69758: LD_ADDR_VAR 0 26
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: LD_INT 0
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 0
69775: PUSH
69776: LD_INT 1
69778: NEG
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: LD_INT 0
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 1
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 0
69806: PUSH
69807: LD_INT 1
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 1
69816: NEG
69817: PUSH
69818: LD_INT 0
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: LD_INT 1
69831: NEG
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 1
69839: NEG
69840: PUSH
69841: LD_INT 2
69843: NEG
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 0
69851: PUSH
69852: LD_INT 2
69854: NEG
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PUSH
69860: LD_INT 1
69862: PUSH
69863: LD_INT 1
69865: NEG
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 2
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 2
69883: PUSH
69884: LD_INT 1
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 1
69903: PUSH
69904: LD_INT 2
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 0
69913: PUSH
69914: LD_INT 2
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: LD_INT 1
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 2
69934: NEG
69935: PUSH
69936: LD_INT 0
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 2
69945: NEG
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 2
69957: NEG
69958: PUSH
69959: LD_INT 2
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 2
69969: PUSH
69970: LD_INT 3
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 1
69979: PUSH
69980: LD_INT 3
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: NEG
69990: PUSH
69991: LD_INT 2
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 2
70000: NEG
70001: PUSH
70002: LD_INT 1
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70034: LD_ADDR_VAR 0 27
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: LD_INT 0
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 0
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 1
70072: PUSH
70073: LD_INT 1
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: LD_INT 1
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 1
70103: NEG
70104: PUSH
70105: LD_INT 1
70107: NEG
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: LD_INT 2
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: LD_INT 2
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 1
70138: PUSH
70139: LD_INT 1
70141: NEG
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 2
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: PUSH
70160: LD_INT 1
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: PUSH
70170: LD_INT 2
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 1
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 0
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 1
70199: NEG
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 2
70210: NEG
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: NEG
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: LD_INT 2
70237: NEG
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 1
70245: NEG
70246: PUSH
70247: LD_INT 2
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 2
70256: NEG
70257: PUSH
70258: LD_INT 1
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 3
70267: NEG
70268: PUSH
70269: LD_INT 1
70271: NEG
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 3
70279: NEG
70280: PUSH
70281: LD_INT 2
70283: NEG
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70314: LD_ADDR_VAR 0 28
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: LD_INT 0
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: LD_INT 1
70334: NEG
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 1
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 1
70352: PUSH
70353: LD_INT 1
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 0
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: NEG
70373: PUSH
70374: LD_INT 0
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 1
70383: NEG
70384: PUSH
70385: LD_INT 1
70387: NEG
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 1
70395: NEG
70396: PUSH
70397: LD_INT 2
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 0
70407: PUSH
70408: LD_INT 2
70410: NEG
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PUSH
70416: LD_INT 1
70418: PUSH
70419: LD_INT 1
70421: NEG
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 2
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 2
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 1
70459: PUSH
70460: LD_INT 2
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 0
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 1
70479: NEG
70480: PUSH
70481: LD_INT 1
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 2
70490: NEG
70491: PUSH
70492: LD_INT 0
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 2
70501: NEG
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 2
70513: NEG
70514: PUSH
70515: LD_INT 2
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 2
70525: NEG
70526: PUSH
70527: LD_INT 3
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: NEG
70538: PUSH
70539: LD_INT 3
70541: NEG
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 3
70549: NEG
70550: PUSH
70551: LD_INT 1
70553: NEG
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 3
70561: NEG
70562: PUSH
70563: LD_INT 2
70565: NEG
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70596: LD_ADDR_VAR 0 29
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: LD_INT 0
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: LD_INT 1
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: PUSH
70625: LD_INT 0
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: LD_INT 1
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 0
70644: PUSH
70645: LD_INT 1
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 1
70654: NEG
70655: PUSH
70656: LD_INT 0
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 1
70665: NEG
70666: PUSH
70667: LD_INT 1
70669: NEG
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 1
70677: NEG
70678: PUSH
70679: LD_INT 2
70681: NEG
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 0
70689: PUSH
70690: LD_INT 2
70692: NEG
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 1
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 2
70711: PUSH
70712: LD_INT 0
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 2
70721: PUSH
70722: LD_INT 1
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 1
70731: PUSH
70732: LD_INT 2
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 0
70741: PUSH
70742: LD_INT 2
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: NEG
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 2
70762: NEG
70763: PUSH
70764: LD_INT 1
70766: NEG
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 2
70774: NEG
70775: PUSH
70776: LD_INT 2
70778: NEG
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 2
70786: NEG
70787: PUSH
70788: LD_INT 3
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 3
70809: PUSH
70810: LD_INT 1
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: PUSH
70820: LD_INT 3
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 1
70829: NEG
70830: PUSH
70831: LD_INT 2
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 3
70840: NEG
70841: PUSH
70842: LD_INT 2
70844: NEG
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70875: LD_ADDR_VAR 0 30
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: LD_INT 0
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 0
70892: PUSH
70893: LD_INT 1
70895: NEG
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 1
70903: PUSH
70904: LD_INT 0
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 1
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 0
70923: PUSH
70924: LD_INT 1
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 1
70933: NEG
70934: PUSH
70935: LD_INT 0
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 1
70944: NEG
70945: PUSH
70946: LD_INT 1
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 1
70956: NEG
70957: PUSH
70958: LD_INT 2
70960: NEG
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: LD_INT 2
70971: NEG
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: LD_INT 1
70982: NEG
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 2
70990: PUSH
70991: LD_INT 0
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 2
71000: PUSH
71001: LD_INT 1
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 2
71010: PUSH
71011: LD_INT 2
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: PUSH
71021: LD_INT 2
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 1
71030: NEG
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 2
71041: NEG
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 2
71052: NEG
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: LD_INT 3
71068: NEG
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 1
71076: PUSH
71077: LD_INT 2
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 3
71087: PUSH
71088: LD_INT 2
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 2
71097: PUSH
71098: LD_INT 3
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 2
71107: NEG
71108: PUSH
71109: LD_INT 1
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 3
71118: NEG
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71153: LD_ADDR_VAR 0 31
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: LD_INT 0
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 0
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 1
71211: NEG
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: NEG
71223: PUSH
71224: LD_INT 1
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 1
71234: NEG
71235: PUSH
71236: LD_INT 2
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: LD_INT 1
71249: NEG
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 2
71257: PUSH
71258: LD_INT 0
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 2
71267: PUSH
71268: LD_INT 1
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 2
71277: PUSH
71278: LD_INT 2
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 1
71287: PUSH
71288: LD_INT 2
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 0
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 1
71307: NEG
71308: PUSH
71309: LD_INT 1
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: PUSH
71316: LD_INT 2
71318: NEG
71319: PUSH
71320: LD_INT 1
71322: NEG
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 2
71330: NEG
71331: PUSH
71332: LD_INT 2
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 2
71342: NEG
71343: PUSH
71344: LD_INT 3
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 2
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 3
71365: PUSH
71366: LD_INT 1
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 1
71375: PUSH
71376: LD_INT 3
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 1
71385: NEG
71386: PUSH
71387: LD_INT 2
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 3
71396: NEG
71397: PUSH
71398: LD_INT 2
71400: NEG
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71431: LD_ADDR_VAR 0 32
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: LD_INT 0
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: PUSH
71460: LD_INT 0
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: LD_INT 1
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 0
71479: PUSH
71480: LD_INT 1
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 1
71489: NEG
71490: PUSH
71491: LD_INT 0
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 1
71500: NEG
71501: PUSH
71502: LD_INT 1
71504: NEG
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: LD_INT 2
71516: NEG
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 0
71524: PUSH
71525: LD_INT 2
71527: NEG
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: LD_INT 1
71538: NEG
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: PUSH
71544: LD_INT 2
71546: PUSH
71547: LD_INT 1
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: LD_INT 2
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 1
71566: PUSH
71567: LD_INT 2
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 0
71576: PUSH
71577: LD_INT 2
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 1
71586: NEG
71587: PUSH
71588: LD_INT 1
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 2
71597: NEG
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 2
71608: NEG
71609: PUSH
71610: LD_INT 1
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: LD_INT 3
71624: NEG
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 1
71632: PUSH
71633: LD_INT 2
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 3
71643: PUSH
71644: LD_INT 2
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 2
71653: PUSH
71654: LD_INT 3
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 2
71663: NEG
71664: PUSH
71665: LD_INT 1
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 3
71674: NEG
71675: PUSH
71676: LD_INT 1
71678: NEG
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: LIST
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71709: LD_ADDR_VAR 0 33
71713: PUSH
71714: LD_INT 0
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 0
71726: PUSH
71727: LD_INT 1
71729: NEG
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 1
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: LD_INT 1
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: LD_INT 1
71767: NEG
71768: PUSH
71769: LD_INT 0
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: LD_INT 1
71778: NEG
71779: PUSH
71780: LD_INT 1
71782: NEG
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 1
71790: NEG
71791: PUSH
71792: LD_INT 2
71794: NEG
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 1
71802: PUSH
71803: LD_INT 1
71805: NEG
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: LD_INT 2
71813: PUSH
71814: LD_INT 0
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 2
71823: PUSH
71824: LD_INT 1
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: LD_INT 1
71833: PUSH
71834: LD_INT 2
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: LD_INT 2
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: LD_INT 1
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 2
71864: NEG
71865: PUSH
71866: LD_INT 0
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 2
71875: NEG
71876: PUSH
71877: LD_INT 1
71879: NEG
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: PUSH
71885: LD_INT 2
71887: NEG
71888: PUSH
71889: LD_INT 2
71891: NEG
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 2
71899: NEG
71900: PUSH
71901: LD_INT 3
71903: NEG
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 2
71911: PUSH
71912: LD_INT 1
71914: NEG
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 3
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: LD_INT 3
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 1
71942: NEG
71943: PUSH
71944: LD_INT 2
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 3
71953: NEG
71954: PUSH
71955: LD_INT 2
71957: NEG
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71988: LD_ADDR_VAR 0 34
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: LD_INT 0
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 1
72008: NEG
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: LD_INT 1
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: LD_INT 1
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 1
72046: NEG
72047: PUSH
72048: LD_INT 0
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 1
72057: NEG
72058: PUSH
72059: LD_INT 1
72061: NEG
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: NEG
72070: PUSH
72071: LD_INT 2
72073: NEG
72074: PUSH
72075: EMPTY
72076: LIST
72077: LIST
72078: PUSH
72079: LD_INT 0
72081: PUSH
72082: LD_INT 2
72084: NEG
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 1
72092: PUSH
72093: LD_INT 1
72095: NEG
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 2
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 2
72113: PUSH
72114: LD_INT 2
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: PUSH
72124: LD_INT 2
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 1
72133: NEG
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 2
72144: NEG
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 2
72155: NEG
72156: PUSH
72157: LD_INT 1
72159: NEG
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 2
72167: NEG
72168: PUSH
72169: LD_INT 2
72171: NEG
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 1
72179: NEG
72180: PUSH
72181: LD_INT 3
72183: NEG
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 1
72191: PUSH
72192: LD_INT 2
72194: NEG
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 3
72202: PUSH
72203: LD_INT 2
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 2
72212: PUSH
72213: LD_INT 3
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 2
72222: NEG
72223: PUSH
72224: LD_INT 1
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: LD_INT 3
72233: NEG
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: LIST
72256: LIST
72257: LIST
72258: LIST
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72268: LD_ADDR_VAR 0 35
72272: PUSH
72273: LD_INT 0
72275: PUSH
72276: LD_INT 0
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 0
72285: PUSH
72286: LD_INT 1
72288: NEG
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 1
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 0
72316: PUSH
72317: LD_INT 1
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 1
72326: NEG
72327: PUSH
72328: LD_INT 0
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 1
72337: NEG
72338: PUSH
72339: LD_INT 1
72341: NEG
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 2
72349: PUSH
72350: LD_INT 1
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 2
72359: NEG
72360: PUSH
72361: LD_INT 1
72363: NEG
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72380: LD_ADDR_VAR 0 36
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 0
72397: PUSH
72398: LD_INT 1
72400: NEG
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 1
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 1
72418: PUSH
72419: LD_INT 1
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 0
72428: PUSH
72429: LD_INT 1
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 1
72438: NEG
72439: PUSH
72440: LD_INT 0
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: NEG
72462: PUSH
72463: LD_INT 2
72465: NEG
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: PUSH
72474: LD_INT 2
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72492: LD_ADDR_VAR 0 37
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: LD_INT 0
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 0
72509: PUSH
72510: LD_INT 1
72512: NEG
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: LD_INT 0
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PUSH
72528: LD_INT 1
72530: PUSH
72531: LD_INT 1
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 0
72540: PUSH
72541: LD_INT 1
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 1
72550: NEG
72551: PUSH
72552: LD_INT 0
72554: PUSH
72555: EMPTY
72556: LIST
72557: LIST
72558: PUSH
72559: LD_INT 1
72561: NEG
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: PUSH
72574: LD_INT 1
72576: NEG
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 1
72584: NEG
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72604: LD_ADDR_VAR 0 38
72608: PUSH
72609: LD_INT 0
72611: PUSH
72612: LD_INT 0
72614: PUSH
72615: EMPTY
72616: LIST
72617: LIST
72618: PUSH
72619: LD_INT 0
72621: PUSH
72622: LD_INT 1
72624: NEG
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 1
72632: PUSH
72633: LD_INT 0
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 1
72642: PUSH
72643: LD_INT 1
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 0
72652: PUSH
72653: LD_INT 1
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 1
72662: NEG
72663: PUSH
72664: LD_INT 0
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: PUSH
72671: LD_INT 1
72673: NEG
72674: PUSH
72675: LD_INT 1
72677: NEG
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 2
72685: PUSH
72686: LD_INT 1
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 2
72695: NEG
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: LIST
72714: LIST
72715: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72716: LD_ADDR_VAR 0 39
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: LD_INT 0
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: LD_INT 1
72736: NEG
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: LD_INT 0
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: LD_INT 1
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 0
72764: PUSH
72765: LD_INT 1
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 1
72774: NEG
72775: PUSH
72776: LD_INT 0
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: LD_INT 1
72789: NEG
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 1
72797: NEG
72798: PUSH
72799: LD_INT 2
72801: NEG
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 1
72809: PUSH
72810: LD_INT 2
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72828: LD_ADDR_VAR 0 40
72832: PUSH
72833: LD_INT 0
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 0
72845: PUSH
72846: LD_INT 1
72848: NEG
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 1
72856: PUSH
72857: LD_INT 0
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 1
72866: PUSH
72867: LD_INT 1
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 0
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 1
72886: NEG
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: LD_INT 1
72901: NEG
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: PUSH
72910: LD_INT 1
72912: NEG
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 1
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72940: LD_ADDR_VAR 0 41
72944: PUSH
72945: LD_INT 0
72947: PUSH
72948: LD_INT 0
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 0
72957: PUSH
72958: LD_INT 1
72960: NEG
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 1
72968: PUSH
72969: LD_INT 0
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 1
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: LD_INT 1
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: LD_INT 0
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: LD_INT 1
73013: NEG
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: LD_INT 1
73021: NEG
73022: PUSH
73023: LD_INT 2
73025: NEG
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 1
73033: PUSH
73034: LD_INT 1
73036: NEG
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 2
73044: PUSH
73045: LD_INT 0
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 2
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 2
73064: PUSH
73065: LD_INT 2
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 1
73074: PUSH
73075: LD_INT 2
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 1
73084: NEG
73085: PUSH
73086: LD_INT 1
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 2
73095: NEG
73096: PUSH
73097: LD_INT 0
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 2
73106: NEG
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: NEG
73119: PUSH
73120: LD_INT 2
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 2
73130: NEG
73131: PUSH
73132: LD_INT 3
73134: NEG
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 2
73142: PUSH
73143: LD_INT 1
73145: NEG
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 3
73153: PUSH
73154: LD_INT 0
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 3
73163: PUSH
73164: LD_INT 1
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 3
73173: PUSH
73174: LD_INT 2
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 3
73183: PUSH
73184: LD_INT 3
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 2
73193: PUSH
73194: LD_INT 3
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: NEG
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 3
73214: NEG
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 3
73225: NEG
73226: PUSH
73227: LD_INT 1
73229: NEG
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 3
73237: NEG
73238: PUSH
73239: LD_INT 2
73241: NEG
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 3
73249: NEG
73250: PUSH
73251: LD_INT 3
73253: NEG
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73290: LD_ADDR_VAR 0 42
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 0
73307: PUSH
73308: LD_INT 1
73310: NEG
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: LD_INT 0
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 1
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 0
73338: PUSH
73339: LD_INT 1
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 1
73348: NEG
73349: PUSH
73350: LD_INT 0
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 1
73359: NEG
73360: PUSH
73361: LD_INT 1
73363: NEG
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 1
73371: NEG
73372: PUSH
73373: LD_INT 2
73375: NEG
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: LD_INT 2
73386: NEG
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 1
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 2
73405: PUSH
73406: LD_INT 1
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 2
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 1
73425: PUSH
73426: LD_INT 2
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 0
73435: PUSH
73436: LD_INT 2
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 1
73445: NEG
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 2
73456: NEG
73457: PUSH
73458: LD_INT 1
73460: NEG
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: LD_INT 2
73472: NEG
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: LD_INT 3
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: LD_INT 3
73496: NEG
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 0
73504: PUSH
73505: LD_INT 3
73507: NEG
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: LD_INT 2
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 3
73526: PUSH
73527: LD_INT 2
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 3
73536: PUSH
73537: LD_INT 3
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 2
73546: PUSH
73547: LD_INT 3
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 1
73556: PUSH
73557: LD_INT 3
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 0
73566: PUSH
73567: LD_INT 3
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 1
73576: NEG
73577: PUSH
73578: LD_INT 2
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 3
73587: NEG
73588: PUSH
73589: LD_INT 2
73591: NEG
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 3
73599: NEG
73600: PUSH
73601: LD_INT 3
73603: NEG
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: LIST
73638: LIST
73639: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73640: LD_ADDR_VAR 0 43
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: LD_INT 0
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 0
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 0
73688: PUSH
73689: LD_INT 1
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 1
73698: NEG
73699: PUSH
73700: LD_INT 0
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: LD_INT 1
73709: NEG
73710: PUSH
73711: LD_INT 1
73713: NEG
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 1
73721: NEG
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: LD_INT 2
73736: NEG
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 1
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 2
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 2
73765: PUSH
73766: LD_INT 1
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 1
73775: PUSH
73776: LD_INT 2
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: LD_INT 2
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 1
73795: NEG
73796: PUSH
73797: LD_INT 1
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 2
73806: NEG
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 2
73817: NEG
73818: PUSH
73819: LD_INT 1
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: LD_INT 3
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: LD_INT 3
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: PUSH
73853: LD_INT 2
73855: NEG
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 2
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 3
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 3
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 1
73894: PUSH
73895: LD_INT 3
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: LD_INT 3
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 2
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 2
73925: NEG
73926: PUSH
73927: LD_INT 1
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 3
73936: NEG
73937: PUSH
73938: LD_INT 0
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 3
73947: NEG
73948: PUSH
73949: LD_INT 1
73951: NEG
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73988: LD_ADDR_VAR 0 44
73992: PUSH
73993: LD_INT 0
73995: PUSH
73996: LD_INT 0
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: LD_INT 1
74008: NEG
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 1
74016: PUSH
74017: LD_INT 0
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: LD_INT 1
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 1
74046: NEG
74047: PUSH
74048: LD_INT 0
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 1
74057: NEG
74058: PUSH
74059: LD_INT 1
74061: NEG
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PUSH
74067: LD_INT 1
74069: NEG
74070: PUSH
74071: LD_INT 2
74073: NEG
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 1
74081: PUSH
74082: LD_INT 1
74084: NEG
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 2
74092: PUSH
74093: LD_INT 0
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 2
74102: PUSH
74103: LD_INT 1
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 2
74112: PUSH
74113: LD_INT 2
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 2
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: NEG
74133: PUSH
74134: LD_INT 1
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 2
74143: NEG
74144: PUSH
74145: LD_INT 0
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 2
74154: NEG
74155: PUSH
74156: LD_INT 1
74158: NEG
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 2
74166: NEG
74167: PUSH
74168: LD_INT 2
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 2
74178: NEG
74179: PUSH
74180: LD_INT 3
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 2
74190: PUSH
74191: LD_INT 1
74193: NEG
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: LD_INT 3
74201: PUSH
74202: LD_INT 0
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: LD_INT 3
74211: PUSH
74212: LD_INT 1
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 3
74221: PUSH
74222: LD_INT 2
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 3
74231: PUSH
74232: LD_INT 3
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 2
74241: PUSH
74242: LD_INT 3
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 3
74262: NEG
74263: PUSH
74264: LD_INT 0
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 3
74273: NEG
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 3
74285: NEG
74286: PUSH
74287: LD_INT 2
74289: NEG
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 3
74297: NEG
74298: PUSH
74299: LD_INT 3
74301: NEG
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: LIST
74335: LIST
74336: LIST
74337: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74338: LD_ADDR_VAR 0 45
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: LD_INT 0
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 0
74355: PUSH
74356: LD_INT 1
74358: NEG
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: LD_INT 1
74366: PUSH
74367: LD_INT 0
74369: PUSH
74370: EMPTY
74371: LIST
74372: LIST
74373: PUSH
74374: LD_INT 1
74376: PUSH
74377: LD_INT 1
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: LD_INT 1
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 1
74396: NEG
74397: PUSH
74398: LD_INT 0
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 1
74407: NEG
74408: PUSH
74409: LD_INT 1
74411: NEG
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 1
74419: NEG
74420: PUSH
74421: LD_INT 2
74423: NEG
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: LD_INT 2
74434: NEG
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 1
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 2
74453: PUSH
74454: LD_INT 1
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 2
74463: PUSH
74464: LD_INT 2
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 1
74473: PUSH
74474: LD_INT 2
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: LD_INT 2
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: PUSH
74491: LD_INT 1
74493: NEG
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 2
74504: NEG
74505: PUSH
74506: LD_INT 1
74508: NEG
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 2
74516: NEG
74517: PUSH
74518: LD_INT 2
74520: NEG
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: LD_INT 3
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 1
74540: NEG
74541: PUSH
74542: LD_INT 3
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: LD_INT 3
74555: NEG
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: PUSH
74575: LD_INT 2
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 3
74584: PUSH
74585: LD_INT 3
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 2
74594: PUSH
74595: LD_INT 3
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: LD_INT 3
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 1
74624: NEG
74625: PUSH
74626: LD_INT 2
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 3
74635: NEG
74636: PUSH
74637: LD_INT 2
74639: NEG
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 3
74647: NEG
74648: PUSH
74649: LD_INT 3
74651: NEG
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74688: LD_ADDR_VAR 0 46
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: LD_INT 0
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: LD_INT 1
74708: NEG
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 1
74716: PUSH
74717: LD_INT 0
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 1
74726: PUSH
74727: LD_INT 1
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 0
74736: PUSH
74737: LD_INT 1
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 1
74746: NEG
74747: PUSH
74748: LD_INT 0
74750: PUSH
74751: EMPTY
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 1
74757: NEG
74758: PUSH
74759: LD_INT 1
74761: NEG
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: LD_INT 1
74769: NEG
74770: PUSH
74771: LD_INT 2
74773: NEG
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: LD_INT 2
74784: NEG
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: LD_INT 1
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 2
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 2
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: PUSH
74824: LD_INT 2
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: LD_INT 2
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 2
74854: NEG
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 2
74865: NEG
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 3
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 3
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 2
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 2
74911: PUSH
74912: LD_INT 1
74914: NEG
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 3
74922: PUSH
74923: LD_INT 0
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 3
74932: PUSH
74933: LD_INT 1
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 1
74942: PUSH
74943: LD_INT 3
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 0
74952: PUSH
74953: LD_INT 3
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: LD_INT 1
74962: NEG
74963: PUSH
74964: LD_INT 2
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 2
74973: NEG
74974: PUSH
74975: LD_INT 1
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 3
74984: NEG
74985: PUSH
74986: LD_INT 0
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 3
74995: NEG
74996: PUSH
74997: LD_INT 1
74999: NEG
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75036: LD_ADDR_VAR 0 47
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: LD_INT 0
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 0
75053: PUSH
75054: LD_INT 1
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 1
75064: PUSH
75065: LD_INT 0
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: LD_INT 1
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 0
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 1
75105: NEG
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 1
75117: NEG
75118: PUSH
75119: LD_INT 2
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: LD_INT 2
75132: NEG
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 1
75140: PUSH
75141: LD_INT 1
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 2
75151: NEG
75152: PUSH
75153: LD_INT 1
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 2
75163: NEG
75164: PUSH
75165: LD_INT 2
75167: NEG
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: LIST
75185: LIST
75186: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75187: LD_ADDR_VAR 0 48
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: LD_INT 0
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 0
75204: PUSH
75205: LD_INT 1
75207: NEG
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 1
75245: NEG
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: NEG
75257: PUSH
75258: LD_INT 1
75260: NEG
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 1
75268: NEG
75269: PUSH
75270: LD_INT 2
75272: NEG
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 1
75291: PUSH
75292: LD_INT 1
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 2
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 2
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: LIST
75333: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75334: LD_ADDR_VAR 0 49
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: LD_INT 0
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: LD_INT 0
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: LD_INT 0
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: LD_INT 1
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 0
75382: PUSH
75383: LD_INT 1
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 1
75392: NEG
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 1
75403: NEG
75404: PUSH
75405: LD_INT 1
75407: NEG
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: LD_INT 1
75418: NEG
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 2
75426: PUSH
75427: LD_INT 0
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 2
75436: PUSH
75437: LD_INT 1
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 2
75446: PUSH
75447: LD_INT 2
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: LD_INT 2
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: LIST
75474: LIST
75475: LIST
75476: LIST
75477: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75478: LD_ADDR_VAR 0 50
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 0
75495: PUSH
75496: LD_INT 1
75498: NEG
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 0
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 0
75526: PUSH
75527: LD_INT 1
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 1
75536: NEG
75537: PUSH
75538: LD_INT 0
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 1
75547: NEG
75548: PUSH
75549: LD_INT 1
75551: NEG
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 2
75559: PUSH
75560: LD_INT 1
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 2
75569: PUSH
75570: LD_INT 2
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 1
75579: PUSH
75580: LD_INT 2
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 0
75589: PUSH
75590: LD_INT 2
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 1
75599: NEG
75600: PUSH
75601: LD_INT 1
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: LIST
75620: LIST
75621: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75622: LD_ADDR_VAR 0 51
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 0
75639: PUSH
75640: LD_INT 1
75642: NEG
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: LD_INT 0
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 1
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 1
75680: NEG
75681: PUSH
75682: LD_INT 0
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: NEG
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 1
75703: PUSH
75704: LD_INT 2
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 0
75713: PUSH
75714: LD_INT 2
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 1
75723: NEG
75724: PUSH
75725: LD_INT 1
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 2
75734: NEG
75735: PUSH
75736: LD_INT 0
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 2
75745: NEG
75746: PUSH
75747: LD_INT 1
75749: NEG
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75769: LD_ADDR_VAR 0 52
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: PUSH
75798: LD_INT 0
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: LD_INT 1
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: NEG
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: LD_INT 1
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: LD_INT 2
75873: NEG
75874: PUSH
75875: LD_INT 0
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 2
75884: NEG
75885: PUSH
75886: LD_INT 1
75888: NEG
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: PUSH
75894: LD_INT 2
75896: NEG
75897: PUSH
75898: LD_INT 2
75900: NEG
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: LIST
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75920: LD_ADDR_VAR 0 53
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: LD_INT 0
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: LD_INT 1
75940: NEG
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 1
75948: PUSH
75949: LD_INT 0
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: PUSH
75959: LD_INT 1
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 0
75968: PUSH
75969: LD_INT 1
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 1
75978: NEG
75979: PUSH
75980: LD_INT 0
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 1
75989: NEG
75990: PUSH
75991: LD_INT 1
75993: NEG
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: LD_INT 2
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: LD_INT 2
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 1
76024: PUSH
76025: LD_INT 1
76027: NEG
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 1
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 2
76055: PUSH
76056: LD_INT 2
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: LD_INT 2
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 2
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: LD_INT 1
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 2
76096: NEG
76097: PUSH
76098: LD_INT 0
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 2
76107: NEG
76108: PUSH
76109: LD_INT 1
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 2
76119: NEG
76120: PUSH
76121: LD_INT 2
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76150: LD_ADDR_VAR 0 54
76154: PUSH
76155: LD_INT 0
76157: PUSH
76158: LD_INT 0
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 0
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 1
76178: PUSH
76179: LD_INT 0
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 1
76188: PUSH
76189: LD_INT 1
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 0
76198: PUSH
76199: LD_INT 1
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 1
76208: NEG
76209: PUSH
76210: LD_INT 0
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 1
76219: NEG
76220: PUSH
76221: LD_INT 1
76223: NEG
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 1
76231: NEG
76232: PUSH
76233: LD_INT 2
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 0
76243: PUSH
76244: LD_INT 2
76246: NEG
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 1
76254: PUSH
76255: LD_INT 1
76257: NEG
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: PUSH
76263: LD_INT 2
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 2
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 2
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 1
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 0
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: LD_INT 1
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 2
76326: NEG
76327: PUSH
76328: LD_INT 0
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 2
76337: NEG
76338: PUSH
76339: LD_INT 1
76341: NEG
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 2
76349: NEG
76350: PUSH
76351: LD_INT 2
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: LIST
76363: LIST
76364: LIST
76365: LIST
76366: LIST
76367: LIST
76368: LIST
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: LIST
76379: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76380: LD_ADDR_VAR 0 55
76384: PUSH
76385: LD_INT 0
76387: PUSH
76388: LD_INT 0
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 1
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 0
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 1
76418: PUSH
76419: LD_INT 1
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 0
76428: PUSH
76429: LD_INT 1
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 1
76438: NEG
76439: PUSH
76440: LD_INT 0
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 1
76449: NEG
76450: PUSH
76451: LD_INT 1
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 1
76461: NEG
76462: PUSH
76463: LD_INT 2
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 0
76473: PUSH
76474: LD_INT 2
76476: NEG
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 1
76484: PUSH
76485: LD_INT 1
76487: NEG
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 2
76495: PUSH
76496: LD_INT 0
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 2
76505: PUSH
76506: LD_INT 1
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: LD_INT 2
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 1
76525: PUSH
76526: LD_INT 2
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 0
76535: PUSH
76536: LD_INT 2
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: LD_INT 1
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 2
76556: NEG
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 2
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 2
76579: NEG
76580: PUSH
76581: LD_INT 2
76583: NEG
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76610: LD_ADDR_VAR 0 56
76614: PUSH
76615: LD_INT 0
76617: PUSH
76618: LD_INT 0
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 0
76627: PUSH
76628: LD_INT 1
76630: NEG
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 1
76638: PUSH
76639: LD_INT 0
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 1
76648: PUSH
76649: LD_INT 1
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 0
76658: PUSH
76659: LD_INT 1
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 1
76668: NEG
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 1
76679: NEG
76680: PUSH
76681: LD_INT 1
76683: NEG
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 1
76691: NEG
76692: PUSH
76693: LD_INT 2
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 0
76703: PUSH
76704: LD_INT 2
76706: NEG
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 1
76714: PUSH
76715: LD_INT 1
76717: NEG
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 2
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 2
76735: PUSH
76736: LD_INT 1
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 2
76745: PUSH
76746: LD_INT 2
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 1
76755: PUSH
76756: LD_INT 2
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 0
76765: PUSH
76766: LD_INT 2
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 1
76775: NEG
76776: PUSH
76777: LD_INT 1
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 2
76786: NEG
76787: PUSH
76788: LD_INT 0
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 2
76797: NEG
76798: PUSH
76799: LD_INT 1
76801: NEG
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 2
76809: NEG
76810: PUSH
76811: LD_INT 2
76813: NEG
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: LIST
76823: LIST
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: LIST
76837: LIST
76838: LIST
76839: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76840: LD_ADDR_VAR 0 57
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: LD_INT 0
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: LD_INT 1
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 1
76878: PUSH
76879: LD_INT 1
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 0
76888: PUSH
76889: LD_INT 1
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: NEG
76899: PUSH
76900: LD_INT 0
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: NEG
76910: PUSH
76911: LD_INT 1
76913: NEG
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 1
76921: NEG
76922: PUSH
76923: LD_INT 2
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: LD_INT 0
76933: PUSH
76934: LD_INT 2
76936: NEG
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 1
76944: PUSH
76945: LD_INT 1
76947: NEG
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 2
76955: PUSH
76956: LD_INT 0
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: LD_INT 2
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 1
76985: PUSH
76986: LD_INT 2
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 0
76995: PUSH
76996: LD_INT 2
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 1
77005: NEG
77006: PUSH
77007: LD_INT 1
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 2
77016: NEG
77017: PUSH
77018: LD_INT 0
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 2
77027: NEG
77028: PUSH
77029: LD_INT 1
77031: NEG
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 2
77039: NEG
77040: PUSH
77041: LD_INT 2
77043: NEG
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77070: LD_ADDR_VAR 0 58
77074: PUSH
77075: LD_INT 0
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: LD_INT 1
77090: NEG
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: LD_INT 1
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 0
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 1
77128: NEG
77129: PUSH
77130: LD_INT 0
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: LD_INT 1
77143: NEG
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 1
77151: NEG
77152: PUSH
77153: LD_INT 2
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 0
77163: PUSH
77164: LD_INT 2
77166: NEG
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: LD_INT 1
77177: NEG
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 0
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 2
77195: PUSH
77196: LD_INT 1
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: LD_INT 2
77205: PUSH
77206: LD_INT 2
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 1
77215: PUSH
77216: LD_INT 2
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 0
77225: PUSH
77226: LD_INT 2
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: LD_INT 1
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 2
77246: NEG
77247: PUSH
77248: LD_INT 0
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 2
77257: NEG
77258: PUSH
77259: LD_INT 1
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 2
77269: NEG
77270: PUSH
77271: LD_INT 2
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77300: LD_ADDR_VAR 0 59
77304: PUSH
77305: LD_INT 0
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 0
77317: PUSH
77318: LD_INT 1
77320: NEG
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 1
77328: PUSH
77329: LD_INT 0
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 1
77338: PUSH
77339: LD_INT 1
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 0
77348: PUSH
77349: LD_INT 1
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 1
77358: NEG
77359: PUSH
77360: LD_INT 0
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 1
77369: NEG
77370: PUSH
77371: LD_INT 1
77373: NEG
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: LIST
77385: LIST
77386: LIST
77387: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77388: LD_ADDR_VAR 0 60
77392: PUSH
77393: LD_INT 0
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 0
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: PUSH
77417: LD_INT 0
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 1
77426: PUSH
77427: LD_INT 1
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 0
77436: PUSH
77437: LD_INT 1
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 1
77446: NEG
77447: PUSH
77448: LD_INT 0
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 1
77457: NEG
77458: PUSH
77459: LD_INT 1
77461: NEG
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77476: LD_ADDR_VAR 0 61
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: LD_INT 0
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: LD_INT 0
77493: PUSH
77494: LD_INT 1
77496: NEG
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 1
77504: PUSH
77505: LD_INT 0
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 0
77524: PUSH
77525: LD_INT 1
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: NEG
77535: PUSH
77536: LD_INT 0
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: LD_INT 1
77545: NEG
77546: PUSH
77547: LD_INT 1
77549: NEG
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77564: LD_ADDR_VAR 0 62
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: LD_INT 0
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 0
77581: PUSH
77582: LD_INT 1
77584: NEG
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 1
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: LD_INT 1
77602: PUSH
77603: LD_INT 1
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 0
77612: PUSH
77613: LD_INT 1
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: NEG
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 1
77633: NEG
77634: PUSH
77635: LD_INT 1
77637: NEG
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77652: LD_ADDR_VAR 0 63
77656: PUSH
77657: LD_INT 0
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 0
77669: PUSH
77670: LD_INT 1
77672: NEG
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 1
77690: PUSH
77691: LD_INT 1
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: LD_INT 1
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 1
77721: NEG
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77740: LD_ADDR_VAR 0 64
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 0
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 0
77757: PUSH
77758: LD_INT 1
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 0
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 1
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 1
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 1
77798: NEG
77799: PUSH
77800: LD_INT 0
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: LD_INT 1
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: ST_TO_ADDR
// end ; 1 :
77828: GO 83725
77830: LD_INT 1
77832: DOUBLE
77833: EQUAL
77834: IFTRUE 77838
77836: GO 80461
77838: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77839: LD_ADDR_VAR 0 11
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: LD_INT 3
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: LD_INT 3
77861: NEG
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 1
77869: PUSH
77870: LD_INT 2
77872: NEG
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: LIST
77882: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77883: LD_ADDR_VAR 0 12
77887: PUSH
77888: LD_INT 2
77890: PUSH
77891: LD_INT 1
77893: NEG
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 0
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: LD_INT 1
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: LIST
77923: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77924: LD_ADDR_VAR 0 13
77928: PUSH
77929: LD_INT 3
77931: PUSH
77932: LD_INT 2
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 3
77941: PUSH
77942: LD_INT 3
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 2
77951: PUSH
77952: LD_INT 3
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: LIST
77963: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77964: LD_ADDR_VAR 0 14
77968: PUSH
77969: LD_INT 1
77971: PUSH
77972: LD_INT 3
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 0
77981: PUSH
77982: LD_INT 3
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 1
77991: NEG
77992: PUSH
77993: LD_INT 2
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: LIST
78004: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78005: LD_ADDR_VAR 0 15
78009: PUSH
78010: LD_INT 2
78012: NEG
78013: PUSH
78014: LD_INT 1
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 3
78023: NEG
78024: PUSH
78025: LD_INT 0
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 3
78034: NEG
78035: PUSH
78036: LD_INT 1
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: LIST
78048: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78049: LD_ADDR_VAR 0 16
78053: PUSH
78054: LD_INT 2
78056: NEG
78057: PUSH
78058: LD_INT 3
78060: NEG
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 3
78068: NEG
78069: PUSH
78070: LD_INT 2
78072: NEG
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 3
78080: NEG
78081: PUSH
78082: LD_INT 3
78084: NEG
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: LIST
78094: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78095: LD_ADDR_VAR 0 17
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: LD_INT 3
78106: NEG
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: LD_INT 3
78117: NEG
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 1
78125: PUSH
78126: LD_INT 2
78128: NEG
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: LIST
78138: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78139: LD_ADDR_VAR 0 18
78143: PUSH
78144: LD_INT 2
78146: PUSH
78147: LD_INT 1
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: LD_INT 0
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 3
78167: PUSH
78168: LD_INT 1
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: LIST
78179: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78180: LD_ADDR_VAR 0 19
78184: PUSH
78185: LD_INT 3
78187: PUSH
78188: LD_INT 2
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 3
78197: PUSH
78198: LD_INT 3
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 2
78207: PUSH
78208: LD_INT 3
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: LIST
78219: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78220: LD_ADDR_VAR 0 20
78224: PUSH
78225: LD_INT 1
78227: PUSH
78228: LD_INT 3
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 3
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: LD_INT 2
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: LIST
78260: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78261: LD_ADDR_VAR 0 21
78265: PUSH
78266: LD_INT 2
78268: NEG
78269: PUSH
78270: LD_INT 1
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 3
78279: NEG
78280: PUSH
78281: LD_INT 0
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 3
78290: NEG
78291: PUSH
78292: LD_INT 1
78294: NEG
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: LIST
78304: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78305: LD_ADDR_VAR 0 22
78309: PUSH
78310: LD_INT 2
78312: NEG
78313: PUSH
78314: LD_INT 3
78316: NEG
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 3
78324: NEG
78325: PUSH
78326: LD_INT 2
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 3
78336: NEG
78337: PUSH
78338: LD_INT 3
78340: NEG
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: LIST
78350: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78351: LD_ADDR_VAR 0 23
78355: PUSH
78356: LD_INT 0
78358: PUSH
78359: LD_INT 3
78361: NEG
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: LD_INT 1
78369: NEG
78370: PUSH
78371: LD_INT 4
78373: NEG
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 1
78381: PUSH
78382: LD_INT 3
78384: NEG
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: LIST
78394: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78395: LD_ADDR_VAR 0 24
78399: PUSH
78400: LD_INT 3
78402: PUSH
78403: LD_INT 0
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 3
78412: PUSH
78413: LD_INT 1
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 4
78423: PUSH
78424: LD_INT 1
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: LIST
78435: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78436: LD_ADDR_VAR 0 25
78440: PUSH
78441: LD_INT 3
78443: PUSH
78444: LD_INT 3
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 4
78453: PUSH
78454: LD_INT 3
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 3
78463: PUSH
78464: LD_INT 4
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: LIST
78475: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78476: LD_ADDR_VAR 0 26
78480: PUSH
78481: LD_INT 0
78483: PUSH
78484: LD_INT 3
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 1
78493: PUSH
78494: LD_INT 4
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: LIST
78516: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78517: LD_ADDR_VAR 0 27
78521: PUSH
78522: LD_INT 3
78524: NEG
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 3
78535: NEG
78536: PUSH
78537: LD_INT 1
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 4
78546: NEG
78547: PUSH
78548: LD_INT 1
78550: NEG
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78561: LD_ADDR_VAR 0 28
78565: PUSH
78566: LD_INT 3
78568: NEG
78569: PUSH
78570: LD_INT 3
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 3
78580: NEG
78581: PUSH
78582: LD_INT 4
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 4
78592: NEG
78593: PUSH
78594: LD_INT 3
78596: NEG
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: LIST
78606: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78607: LD_ADDR_VAR 0 29
78611: PUSH
78612: LD_INT 1
78614: NEG
78615: PUSH
78616: LD_INT 3
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 3
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: LD_INT 2
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 1
78648: NEG
78649: PUSH
78650: LD_INT 4
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 0
78660: PUSH
78661: LD_INT 4
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 1
78671: PUSH
78672: LD_INT 3
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: LD_INT 5
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 0
78694: PUSH
78695: LD_INT 5
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 1
78705: PUSH
78706: LD_INT 4
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: LD_INT 6
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 0
78728: PUSH
78729: LD_INT 6
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 1
78739: PUSH
78740: LD_INT 5
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78762: LD_ADDR_VAR 0 30
78766: PUSH
78767: LD_INT 2
78769: PUSH
78770: LD_INT 1
78772: NEG
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: PUSH
78791: LD_INT 1
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 3
78800: PUSH
78801: LD_INT 1
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 4
78811: PUSH
78812: LD_INT 0
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 4
78821: PUSH
78822: LD_INT 1
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 4
78831: PUSH
78832: LD_INT 1
78834: NEG
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 5
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 5
78852: PUSH
78853: LD_INT 1
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 5
78862: PUSH
78863: LD_INT 1
78865: NEG
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 6
78873: PUSH
78874: LD_INT 0
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 6
78883: PUSH
78884: LD_INT 1
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78905: LD_ADDR_VAR 0 31
78909: PUSH
78910: LD_INT 3
78912: PUSH
78913: LD_INT 2
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 3
78922: PUSH
78923: LD_INT 3
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 2
78932: PUSH
78933: LD_INT 3
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 4
78942: PUSH
78943: LD_INT 3
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 4
78952: PUSH
78953: LD_INT 4
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 3
78962: PUSH
78963: LD_INT 4
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 5
78972: PUSH
78973: LD_INT 4
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 5
78982: PUSH
78983: LD_INT 5
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 4
78992: PUSH
78993: LD_INT 5
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 6
79002: PUSH
79003: LD_INT 5
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 6
79012: PUSH
79013: LD_INT 6
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 5
79022: PUSH
79023: LD_INT 6
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: LIST
79042: LIST
79043: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79044: LD_ADDR_VAR 0 32
79048: PUSH
79049: LD_INT 1
79051: PUSH
79052: LD_INT 3
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 0
79061: PUSH
79062: LD_INT 3
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: LD_INT 2
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 1
79082: PUSH
79083: LD_INT 4
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 0
79092: PUSH
79093: LD_INT 4
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: LD_INT 3
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 1
79113: PUSH
79114: LD_INT 5
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 0
79123: PUSH
79124: LD_INT 5
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 1
79133: NEG
79134: PUSH
79135: LD_INT 4
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 1
79144: PUSH
79145: LD_INT 6
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: LD_INT 6
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 1
79164: NEG
79165: PUSH
79166: LD_INT 5
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79187: LD_ADDR_VAR 0 33
79191: PUSH
79192: LD_INT 2
79194: NEG
79195: PUSH
79196: LD_INT 1
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 3
79205: NEG
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 3
79216: NEG
79217: PUSH
79218: LD_INT 1
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 3
79228: NEG
79229: PUSH
79230: LD_INT 1
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 4
79239: NEG
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 4
79250: NEG
79251: PUSH
79252: LD_INT 1
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 4
79262: NEG
79263: PUSH
79264: LD_INT 1
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 5
79273: NEG
79274: PUSH
79275: LD_INT 0
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 5
79284: NEG
79285: PUSH
79286: LD_INT 1
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 5
79296: NEG
79297: PUSH
79298: LD_INT 1
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 6
79307: NEG
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 6
79318: NEG
79319: PUSH
79320: LD_INT 1
79322: NEG
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79342: LD_ADDR_VAR 0 34
79346: PUSH
79347: LD_INT 2
79349: NEG
79350: PUSH
79351: LD_INT 3
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 3
79361: NEG
79362: PUSH
79363: LD_INT 2
79365: NEG
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 3
79373: NEG
79374: PUSH
79375: LD_INT 3
79377: NEG
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PUSH
79383: LD_INT 3
79385: NEG
79386: PUSH
79387: LD_INT 4
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 4
79397: NEG
79398: PUSH
79399: LD_INT 3
79401: NEG
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 4
79409: NEG
79410: PUSH
79411: LD_INT 4
79413: NEG
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 4
79421: NEG
79422: PUSH
79423: LD_INT 5
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 5
79433: NEG
79434: PUSH
79435: LD_INT 4
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 5
79445: NEG
79446: PUSH
79447: LD_INT 5
79449: NEG
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 5
79457: NEG
79458: PUSH
79459: LD_INT 6
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 6
79469: NEG
79470: PUSH
79471: LD_INT 5
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 6
79481: NEG
79482: PUSH
79483: LD_INT 6
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79505: LD_ADDR_VAR 0 41
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: LD_INT 2
79515: NEG
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 1
79523: NEG
79524: PUSH
79525: LD_INT 3
79527: NEG
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: LD_INT 2
79538: NEG
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: LIST
79548: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79549: LD_ADDR_VAR 0 42
79553: PUSH
79554: LD_INT 2
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 2
79566: PUSH
79567: LD_INT 1
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 3
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: LIST
79589: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79590: LD_ADDR_VAR 0 43
79594: PUSH
79595: LD_INT 2
79597: PUSH
79598: LD_INT 2
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 3
79607: PUSH
79608: LD_INT 2
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: LD_INT 2
79617: PUSH
79618: LD_INT 3
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: LIST
79629: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79630: LD_ADDR_VAR 0 44
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: LD_INT 2
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: LD_INT 3
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: LD_INT 2
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: LIST
79670: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79671: LD_ADDR_VAR 0 45
79675: PUSH
79676: LD_INT 2
79678: NEG
79679: PUSH
79680: LD_INT 0
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: LD_INT 1
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: LD_INT 1
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: LIST
79714: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79715: LD_ADDR_VAR 0 46
79719: PUSH
79720: LD_INT 2
79722: NEG
79723: PUSH
79724: LD_INT 2
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 2
79734: NEG
79735: PUSH
79736: LD_INT 3
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 3
79746: NEG
79747: PUSH
79748: LD_INT 2
79750: NEG
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: LIST
79760: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79761: LD_ADDR_VAR 0 47
79765: PUSH
79766: LD_INT 2
79768: NEG
79769: PUSH
79770: LD_INT 3
79772: NEG
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 1
79780: NEG
79781: PUSH
79782: LD_INT 3
79784: NEG
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79794: LD_ADDR_VAR 0 48
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: LD_INT 2
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 2
79812: PUSH
79813: LD_INT 1
79815: NEG
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79825: LD_ADDR_VAR 0 49
79829: PUSH
79830: LD_INT 3
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 3
79842: PUSH
79843: LD_INT 2
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: EMPTY
79851: LIST
79852: LIST
79853: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79854: LD_ADDR_VAR 0 50
79858: PUSH
79859: LD_INT 2
79861: PUSH
79862: LD_INT 3
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 3
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79883: LD_ADDR_VAR 0 51
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: LD_INT 2
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: LD_INT 2
79901: NEG
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79914: LD_ADDR_VAR 0 52
79918: PUSH
79919: LD_INT 3
79921: NEG
79922: PUSH
79923: LD_INT 1
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 3
79933: NEG
79934: PUSH
79935: LD_INT 2
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79947: LD_ADDR_VAR 0 53
79951: PUSH
79952: LD_INT 1
79954: NEG
79955: PUSH
79956: LD_INT 3
79958: NEG
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 0
79966: PUSH
79967: LD_INT 3
79969: NEG
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 1
79977: PUSH
79978: LD_INT 2
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: LIST
79990: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79991: LD_ADDR_VAR 0 54
79995: PUSH
79996: LD_INT 2
79998: PUSH
79999: LD_INT 1
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 0
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: LD_INT 1
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: LIST
80031: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80032: LD_ADDR_VAR 0 55
80036: PUSH
80037: LD_INT 3
80039: PUSH
80040: LD_INT 2
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 3
80049: PUSH
80050: LD_INT 3
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 2
80059: PUSH
80060: LD_INT 3
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: LIST
80071: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80072: LD_ADDR_VAR 0 56
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: LD_INT 3
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 3
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: LD_INT 2
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: LIST
80112: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80113: LD_ADDR_VAR 0 57
80117: PUSH
80118: LD_INT 2
80120: NEG
80121: PUSH
80122: LD_INT 1
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 3
80131: NEG
80132: PUSH
80133: LD_INT 0
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: LD_INT 1
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: LIST
80156: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80157: LD_ADDR_VAR 0 58
80161: PUSH
80162: LD_INT 2
80164: NEG
80165: PUSH
80166: LD_INT 3
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 3
80176: NEG
80177: PUSH
80178: LD_INT 2
80180: NEG
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 3
80188: NEG
80189: PUSH
80190: LD_INT 3
80192: NEG
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: LIST
80202: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80203: LD_ADDR_VAR 0 59
80207: PUSH
80208: LD_INT 1
80210: NEG
80211: PUSH
80212: LD_INT 2
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: LD_INT 2
80225: NEG
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: LD_INT 1
80236: NEG
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: LIST
80246: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80247: LD_ADDR_VAR 0 60
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 2
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 2
80275: PUSH
80276: LD_INT 1
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: LIST
80287: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80288: LD_ADDR_VAR 0 61
80292: PUSH
80293: LD_INT 2
80295: PUSH
80296: LD_INT 1
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 2
80305: PUSH
80306: LD_INT 2
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 1
80315: PUSH
80316: LD_INT 2
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: LIST
80327: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80328: LD_ADDR_VAR 0 62
80332: PUSH
80333: LD_INT 1
80335: PUSH
80336: LD_INT 2
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: LD_INT 2
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 1
80355: NEG
80356: PUSH
80357: LD_INT 1
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: LIST
80368: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80369: LD_ADDR_VAR 0 63
80373: PUSH
80374: LD_INT 1
80376: NEG
80377: PUSH
80378: LD_INT 1
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 2
80387: NEG
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 2
80398: NEG
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: LIST
80412: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80413: LD_ADDR_VAR 0 64
80417: PUSH
80418: LD_INT 1
80420: NEG
80421: PUSH
80422: LD_INT 2
80424: NEG
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 2
80432: NEG
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 2
80444: NEG
80445: PUSH
80446: LD_INT 2
80448: NEG
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: LIST
80458: ST_TO_ADDR
// end ; 2 :
80459: GO 83725
80461: LD_INT 2
80463: DOUBLE
80464: EQUAL
80465: IFTRUE 80469
80467: GO 83724
80469: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80470: LD_ADDR_VAR 0 29
80474: PUSH
80475: LD_INT 4
80477: PUSH
80478: LD_INT 0
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 4
80487: PUSH
80488: LD_INT 1
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 5
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 5
80508: PUSH
80509: LD_INT 1
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 4
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 3
80528: PUSH
80529: LD_INT 0
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 3
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 3
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 5
80560: PUSH
80561: LD_INT 2
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 3
80570: PUSH
80571: LD_INT 3
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 3
80580: PUSH
80581: LD_INT 2
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 4
80590: PUSH
80591: LD_INT 3
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 4
80600: PUSH
80601: LD_INT 4
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 3
80610: PUSH
80611: LD_INT 4
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 2
80620: PUSH
80621: LD_INT 3
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: LD_INT 2
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 4
80640: PUSH
80641: LD_INT 2
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 2
80650: PUSH
80651: LD_INT 4
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: LD_INT 4
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 0
80670: PUSH
80671: LD_INT 3
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: LD_INT 4
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 1
80690: PUSH
80691: LD_INT 5
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 0
80700: PUSH
80701: LD_INT 5
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 1
80710: NEG
80711: PUSH
80712: LD_INT 4
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 1
80721: NEG
80722: PUSH
80723: LD_INT 3
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 2
80732: PUSH
80733: LD_INT 5
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 2
80742: NEG
80743: PUSH
80744: LD_INT 3
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 3
80753: NEG
80754: PUSH
80755: LD_INT 0
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 3
80764: NEG
80765: PUSH
80766: LD_INT 1
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 2
80776: NEG
80777: PUSH
80778: LD_INT 0
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 2
80787: NEG
80788: PUSH
80789: LD_INT 1
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 3
80798: NEG
80799: PUSH
80800: LD_INT 1
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 4
80809: NEG
80810: PUSH
80811: LD_INT 0
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 4
80820: NEG
80821: PUSH
80822: LD_INT 1
80824: NEG
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 4
80832: NEG
80833: PUSH
80834: LD_INT 2
80836: NEG
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 2
80844: NEG
80845: PUSH
80846: LD_INT 2
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 4
80855: NEG
80856: PUSH
80857: LD_INT 4
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 4
80867: NEG
80868: PUSH
80869: LD_INT 5
80871: NEG
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 3
80879: NEG
80880: PUSH
80881: LD_INT 4
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 3
80891: NEG
80892: PUSH
80893: LD_INT 3
80895: NEG
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 4
80903: NEG
80904: PUSH
80905: LD_INT 3
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 5
80915: NEG
80916: PUSH
80917: LD_INT 4
80919: NEG
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 5
80927: NEG
80928: PUSH
80929: LD_INT 5
80931: NEG
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 3
80939: NEG
80940: PUSH
80941: LD_INT 5
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 5
80951: NEG
80952: PUSH
80953: LD_INT 3
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81008: LD_ADDR_VAR 0 30
81012: PUSH
81013: LD_INT 4
81015: PUSH
81016: LD_INT 4
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 4
81025: PUSH
81026: LD_INT 3
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: PUSH
81036: LD_INT 4
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 5
81045: PUSH
81046: LD_INT 5
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 4
81055: PUSH
81056: LD_INT 5
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 3
81065: PUSH
81066: LD_INT 4
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 3
81075: PUSH
81076: LD_INT 3
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 5
81085: PUSH
81086: LD_INT 3
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 3
81095: PUSH
81096: LD_INT 5
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: LD_INT 3
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 0
81115: PUSH
81116: LD_INT 2
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: LD_INT 3
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 1
81135: PUSH
81136: LD_INT 4
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: LD_INT 4
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 1
81155: NEG
81156: PUSH
81157: LD_INT 3
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 1
81166: NEG
81167: PUSH
81168: LD_INT 2
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: PUSH
81178: LD_INT 4
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: NEG
81188: PUSH
81189: LD_INT 2
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 4
81198: NEG
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 4
81209: NEG
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 3
81221: NEG
81222: PUSH
81223: LD_INT 0
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 3
81232: NEG
81233: PUSH
81234: LD_INT 1
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 4
81243: NEG
81244: PUSH
81245: LD_INT 1
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 5
81254: NEG
81255: PUSH
81256: LD_INT 0
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 5
81265: NEG
81266: PUSH
81267: LD_INT 1
81269: NEG
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 5
81277: NEG
81278: PUSH
81279: LD_INT 2
81281: NEG
81282: PUSH
81283: EMPTY
81284: LIST
81285: LIST
81286: PUSH
81287: LD_INT 3
81289: NEG
81290: PUSH
81291: LD_INT 2
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 3
81300: NEG
81301: PUSH
81302: LD_INT 3
81304: NEG
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 3
81312: NEG
81313: PUSH
81314: LD_INT 4
81316: NEG
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 2
81324: NEG
81325: PUSH
81326: LD_INT 3
81328: NEG
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 2
81336: NEG
81337: PUSH
81338: LD_INT 2
81340: NEG
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 3
81348: NEG
81349: PUSH
81350: LD_INT 2
81352: NEG
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 4
81360: NEG
81361: PUSH
81362: LD_INT 3
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 4
81372: NEG
81373: PUSH
81374: LD_INT 4
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 2
81384: NEG
81385: PUSH
81386: LD_INT 4
81388: NEG
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 4
81396: NEG
81397: PUSH
81398: LD_INT 2
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 0
81408: PUSH
81409: LD_INT 4
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 5
81422: NEG
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 4
81433: NEG
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 1
81441: PUSH
81442: LD_INT 3
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 0
81452: PUSH
81453: LD_INT 3
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: NEG
81464: PUSH
81465: LD_INT 4
81467: NEG
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 1
81475: NEG
81476: PUSH
81477: LD_INT 5
81479: NEG
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 2
81487: PUSH
81488: LD_INT 3
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 2
81498: NEG
81499: PUSH
81500: LD_INT 5
81502: NEG
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81555: LD_ADDR_VAR 0 31
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: LD_INT 4
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: LD_INT 4
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 1
81592: PUSH
81593: LD_INT 5
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 0
81602: PUSH
81603: LD_INT 5
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 1
81612: NEG
81613: PUSH
81614: LD_INT 4
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: NEG
81624: PUSH
81625: LD_INT 3
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: PUSH
81635: LD_INT 5
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 2
81644: NEG
81645: PUSH
81646: LD_INT 3
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 3
81655: NEG
81656: PUSH
81657: LD_INT 0
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 3
81666: NEG
81667: PUSH
81668: LD_INT 1
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 2
81678: NEG
81679: PUSH
81680: LD_INT 0
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 2
81689: NEG
81690: PUSH
81691: LD_INT 1
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 3
81700: NEG
81701: PUSH
81702: LD_INT 1
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 4
81711: NEG
81712: PUSH
81713: LD_INT 0
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 4
81722: NEG
81723: PUSH
81724: LD_INT 1
81726: NEG
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 4
81734: NEG
81735: PUSH
81736: LD_INT 2
81738: NEG
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 2
81746: NEG
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 4
81757: NEG
81758: PUSH
81759: LD_INT 4
81761: NEG
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 4
81769: NEG
81770: PUSH
81771: LD_INT 5
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 3
81781: NEG
81782: PUSH
81783: LD_INT 4
81785: NEG
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 3
81793: NEG
81794: PUSH
81795: LD_INT 3
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 4
81805: NEG
81806: PUSH
81807: LD_INT 3
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 5
81817: NEG
81818: PUSH
81819: LD_INT 4
81821: NEG
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 5
81829: NEG
81830: PUSH
81831: LD_INT 5
81833: NEG
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 3
81841: NEG
81842: PUSH
81843: LD_INT 5
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 5
81853: NEG
81854: PUSH
81855: LD_INT 3
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 0
81865: PUSH
81866: LD_INT 3
81868: NEG
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 0
81876: PUSH
81877: LD_INT 4
81879: NEG
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 1
81887: PUSH
81888: LD_INT 3
81890: NEG
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: LD_INT 2
81901: NEG
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: LD_INT 3
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: LD_INT 4
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: LD_INT 2
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 2
81955: NEG
81956: PUSH
81957: LD_INT 4
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 4
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 4
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 5
81988: PUSH
81989: LD_INT 0
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 5
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 4
82008: PUSH
82009: LD_INT 1
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 3
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 3
82028: PUSH
82029: LD_INT 1
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 3
82039: PUSH
82040: LD_INT 2
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 5
82050: PUSH
82051: LD_INT 2
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82105: LD_ADDR_VAR 0 32
82109: PUSH
82110: LD_INT 4
82112: NEG
82113: PUSH
82114: LD_INT 0
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 4
82123: NEG
82124: PUSH
82125: LD_INT 1
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 3
82135: NEG
82136: PUSH
82137: LD_INT 0
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 3
82146: NEG
82147: PUSH
82148: LD_INT 1
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: LD_INT 4
82157: NEG
82158: PUSH
82159: LD_INT 1
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 5
82168: NEG
82169: PUSH
82170: LD_INT 0
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 5
82179: NEG
82180: PUSH
82181: LD_INT 1
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 5
82191: NEG
82192: PUSH
82193: LD_INT 2
82195: NEG
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 3
82203: NEG
82204: PUSH
82205: LD_INT 2
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 3
82214: NEG
82215: PUSH
82216: LD_INT 3
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 3
82226: NEG
82227: PUSH
82228: LD_INT 4
82230: NEG
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 2
82238: NEG
82239: PUSH
82240: LD_INT 3
82242: NEG
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 2
82250: NEG
82251: PUSH
82252: LD_INT 2
82254: NEG
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 3
82262: NEG
82263: PUSH
82264: LD_INT 2
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 4
82274: NEG
82275: PUSH
82276: LD_INT 3
82278: NEG
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 4
82286: NEG
82287: PUSH
82288: LD_INT 4
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 2
82298: NEG
82299: PUSH
82300: LD_INT 4
82302: NEG
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 4
82310: NEG
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: LD_INT 4
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: LD_INT 5
82336: NEG
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: PUSH
82345: LD_INT 4
82347: NEG
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 1
82355: PUSH
82356: LD_INT 3
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: LD_INT 3
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: NEG
82378: PUSH
82379: LD_INT 4
82381: NEG
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: LD_INT 5
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 2
82401: PUSH
82402: LD_INT 3
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 2
82412: NEG
82413: PUSH
82414: LD_INT 5
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 3
82424: PUSH
82425: LD_INT 0
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 3
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 4
82445: PUSH
82446: LD_INT 0
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 4
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 3
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 2
82475: PUSH
82476: LD_INT 0
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 2
82485: PUSH
82486: LD_INT 1
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 2
82496: PUSH
82497: LD_INT 2
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 4
82507: PUSH
82508: LD_INT 2
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PUSH
82515: LD_INT 4
82517: PUSH
82518: LD_INT 4
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: LD_INT 4
82527: PUSH
82528: LD_INT 3
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 5
82537: PUSH
82538: LD_INT 4
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 5
82547: PUSH
82548: LD_INT 5
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 4
82557: PUSH
82558: LD_INT 5
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 3
82567: PUSH
82568: LD_INT 4
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 3
82577: PUSH
82578: LD_INT 3
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 5
82587: PUSH
82588: LD_INT 3
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 3
82597: PUSH
82598: LD_INT 5
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82652: LD_ADDR_VAR 0 33
82656: PUSH
82657: LD_INT 4
82659: NEG
82660: PUSH
82661: LD_INT 4
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 4
82671: NEG
82672: PUSH
82673: LD_INT 5
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 3
82683: NEG
82684: PUSH
82685: LD_INT 4
82687: NEG
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 3
82695: NEG
82696: PUSH
82697: LD_INT 3
82699: NEG
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 4
82707: NEG
82708: PUSH
82709: LD_INT 3
82711: NEG
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 5
82719: NEG
82720: PUSH
82721: LD_INT 4
82723: NEG
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 5
82731: NEG
82732: PUSH
82733: LD_INT 5
82735: NEG
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 3
82743: NEG
82744: PUSH
82745: LD_INT 5
82747: NEG
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 5
82755: NEG
82756: PUSH
82757: LD_INT 3
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: LD_INT 3
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 0
82778: PUSH
82779: LD_INT 4
82781: NEG
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 1
82789: PUSH
82790: LD_INT 3
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: PUSH
82801: LD_INT 2
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 0
82811: PUSH
82812: LD_INT 2
82814: NEG
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 1
82822: NEG
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: NEG
82835: PUSH
82836: LD_INT 4
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 2
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 2
82857: NEG
82858: PUSH
82859: LD_INT 4
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 4
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 4
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 5
82890: PUSH
82891: LD_INT 0
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 5
82900: PUSH
82901: LD_INT 1
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 4
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 3
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 3
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 5
82952: PUSH
82953: LD_INT 2
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 3
82962: PUSH
82963: LD_INT 3
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 3
82972: PUSH
82973: LD_INT 2
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: LD_INT 3
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 4
82992: PUSH
82993: LD_INT 4
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 3
83002: PUSH
83003: LD_INT 4
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 2
83012: PUSH
83013: LD_INT 3
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 2
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 4
83032: PUSH
83033: LD_INT 2
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 2
83042: PUSH
83043: LD_INT 4
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 0
83052: PUSH
83053: LD_INT 4
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 0
83062: PUSH
83063: LD_INT 3
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: LD_INT 4
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: LD_INT 5
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: LD_INT 5
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: NEG
83103: PUSH
83104: LD_INT 4
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 1
83113: NEG
83114: PUSH
83115: LD_INT 3
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: LD_INT 5
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 2
83134: NEG
83135: PUSH
83136: LD_INT 3
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83190: LD_ADDR_VAR 0 34
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: LD_INT 4
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 0
83208: PUSH
83209: LD_INT 5
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: LD_INT 4
83222: NEG
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: LD_INT 3
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 0
83241: PUSH
83242: LD_INT 3
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 1
83252: NEG
83253: PUSH
83254: LD_INT 4
83256: NEG
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 1
83264: NEG
83265: PUSH
83266: LD_INT 5
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 2
83276: PUSH
83277: LD_INT 3
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 2
83287: NEG
83288: PUSH
83289: LD_INT 5
83291: NEG
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 3
83299: PUSH
83300: LD_INT 0
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 3
83309: PUSH
83310: LD_INT 1
83312: NEG
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 4
83320: PUSH
83321: LD_INT 0
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 4
83330: PUSH
83331: LD_INT 1
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 3
83340: PUSH
83341: LD_INT 1
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 2
83350: PUSH
83351: LD_INT 0
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 2
83360: PUSH
83361: LD_INT 1
83363: NEG
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 2
83371: PUSH
83372: LD_INT 2
83374: NEG
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 4
83382: PUSH
83383: LD_INT 2
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 4
83392: PUSH
83393: LD_INT 4
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 4
83402: PUSH
83403: LD_INT 3
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 5
83412: PUSH
83413: LD_INT 4
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 5
83422: PUSH
83423: LD_INT 5
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 4
83432: PUSH
83433: LD_INT 5
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 3
83442: PUSH
83443: LD_INT 4
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 3
83452: PUSH
83453: LD_INT 3
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 5
83462: PUSH
83463: LD_INT 3
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 3
83472: PUSH
83473: LD_INT 5
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: LD_INT 3
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 0
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: LD_INT 3
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 1
83512: PUSH
83513: LD_INT 4
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: LD_INT 0
83522: PUSH
83523: LD_INT 4
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 1
83532: NEG
83533: PUSH
83534: LD_INT 3
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: LD_INT 2
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 2
83554: PUSH
83555: LD_INT 4
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 2
83564: NEG
83565: PUSH
83566: LD_INT 2
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 4
83575: NEG
83576: PUSH
83577: LD_INT 0
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 4
83586: NEG
83587: PUSH
83588: LD_INT 1
83590: NEG
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 3
83598: NEG
83599: PUSH
83600: LD_INT 0
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_INT 3
83609: NEG
83610: PUSH
83611: LD_INT 1
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 4
83620: NEG
83621: PUSH
83622: LD_INT 1
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 5
83631: NEG
83632: PUSH
83633: LD_INT 0
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 5
83642: NEG
83643: PUSH
83644: LD_INT 1
83646: NEG
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 5
83654: NEG
83655: PUSH
83656: LD_INT 2
83658: NEG
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 3
83666: NEG
83667: PUSH
83668: LD_INT 2
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: ST_TO_ADDR
// end ; end ;
83722: GO 83725
83724: POP
// case btype of b_depot , b_warehouse :
83725: LD_VAR 0 1
83729: PUSH
83730: LD_INT 0
83732: DOUBLE
83733: EQUAL
83734: IFTRUE 83744
83736: LD_INT 1
83738: DOUBLE
83739: EQUAL
83740: IFTRUE 83744
83742: GO 83945
83744: POP
// case nation of nation_american :
83745: LD_VAR 0 5
83749: PUSH
83750: LD_INT 1
83752: DOUBLE
83753: EQUAL
83754: IFTRUE 83758
83756: GO 83814
83758: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83759: LD_ADDR_VAR 0 9
83763: PUSH
83764: LD_VAR 0 11
83768: PUSH
83769: LD_VAR 0 12
83773: PUSH
83774: LD_VAR 0 13
83778: PUSH
83779: LD_VAR 0 14
83783: PUSH
83784: LD_VAR 0 15
83788: PUSH
83789: LD_VAR 0 16
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: PUSH
83802: LD_VAR 0 4
83806: PUSH
83807: LD_INT 1
83809: PLUS
83810: ARRAY
83811: ST_TO_ADDR
83812: GO 83943
83814: LD_INT 2
83816: DOUBLE
83817: EQUAL
83818: IFTRUE 83822
83820: GO 83878
83822: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83823: LD_ADDR_VAR 0 9
83827: PUSH
83828: LD_VAR 0 17
83832: PUSH
83833: LD_VAR 0 18
83837: PUSH
83838: LD_VAR 0 19
83842: PUSH
83843: LD_VAR 0 20
83847: PUSH
83848: LD_VAR 0 21
83852: PUSH
83853: LD_VAR 0 22
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: PUSH
83866: LD_VAR 0 4
83870: PUSH
83871: LD_INT 1
83873: PLUS
83874: ARRAY
83875: ST_TO_ADDR
83876: GO 83943
83878: LD_INT 3
83880: DOUBLE
83881: EQUAL
83882: IFTRUE 83886
83884: GO 83942
83886: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83887: LD_ADDR_VAR 0 9
83891: PUSH
83892: LD_VAR 0 23
83896: PUSH
83897: LD_VAR 0 24
83901: PUSH
83902: LD_VAR 0 25
83906: PUSH
83907: LD_VAR 0 26
83911: PUSH
83912: LD_VAR 0 27
83916: PUSH
83917: LD_VAR 0 28
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: PUSH
83930: LD_VAR 0 4
83934: PUSH
83935: LD_INT 1
83937: PLUS
83938: ARRAY
83939: ST_TO_ADDR
83940: GO 83943
83942: POP
83943: GO 84498
83945: LD_INT 2
83947: DOUBLE
83948: EQUAL
83949: IFTRUE 83959
83951: LD_INT 3
83953: DOUBLE
83954: EQUAL
83955: IFTRUE 83959
83957: GO 84015
83959: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83960: LD_ADDR_VAR 0 9
83964: PUSH
83965: LD_VAR 0 29
83969: PUSH
83970: LD_VAR 0 30
83974: PUSH
83975: LD_VAR 0 31
83979: PUSH
83980: LD_VAR 0 32
83984: PUSH
83985: LD_VAR 0 33
83989: PUSH
83990: LD_VAR 0 34
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: PUSH
84003: LD_VAR 0 4
84007: PUSH
84008: LD_INT 1
84010: PLUS
84011: ARRAY
84012: ST_TO_ADDR
84013: GO 84498
84015: LD_INT 16
84017: DOUBLE
84018: EQUAL
84019: IFTRUE 84077
84021: LD_INT 17
84023: DOUBLE
84024: EQUAL
84025: IFTRUE 84077
84027: LD_INT 18
84029: DOUBLE
84030: EQUAL
84031: IFTRUE 84077
84033: LD_INT 19
84035: DOUBLE
84036: EQUAL
84037: IFTRUE 84077
84039: LD_INT 22
84041: DOUBLE
84042: EQUAL
84043: IFTRUE 84077
84045: LD_INT 20
84047: DOUBLE
84048: EQUAL
84049: IFTRUE 84077
84051: LD_INT 21
84053: DOUBLE
84054: EQUAL
84055: IFTRUE 84077
84057: LD_INT 23
84059: DOUBLE
84060: EQUAL
84061: IFTRUE 84077
84063: LD_INT 24
84065: DOUBLE
84066: EQUAL
84067: IFTRUE 84077
84069: LD_INT 25
84071: DOUBLE
84072: EQUAL
84073: IFTRUE 84077
84075: GO 84133
84077: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84078: LD_ADDR_VAR 0 9
84082: PUSH
84083: LD_VAR 0 35
84087: PUSH
84088: LD_VAR 0 36
84092: PUSH
84093: LD_VAR 0 37
84097: PUSH
84098: LD_VAR 0 38
84102: PUSH
84103: LD_VAR 0 39
84107: PUSH
84108: LD_VAR 0 40
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: PUSH
84121: LD_VAR 0 4
84125: PUSH
84126: LD_INT 1
84128: PLUS
84129: ARRAY
84130: ST_TO_ADDR
84131: GO 84498
84133: LD_INT 6
84135: DOUBLE
84136: EQUAL
84137: IFTRUE 84189
84139: LD_INT 7
84141: DOUBLE
84142: EQUAL
84143: IFTRUE 84189
84145: LD_INT 8
84147: DOUBLE
84148: EQUAL
84149: IFTRUE 84189
84151: LD_INT 13
84153: DOUBLE
84154: EQUAL
84155: IFTRUE 84189
84157: LD_INT 12
84159: DOUBLE
84160: EQUAL
84161: IFTRUE 84189
84163: LD_INT 15
84165: DOUBLE
84166: EQUAL
84167: IFTRUE 84189
84169: LD_INT 11
84171: DOUBLE
84172: EQUAL
84173: IFTRUE 84189
84175: LD_INT 14
84177: DOUBLE
84178: EQUAL
84179: IFTRUE 84189
84181: LD_INT 10
84183: DOUBLE
84184: EQUAL
84185: IFTRUE 84189
84187: GO 84245
84189: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84190: LD_ADDR_VAR 0 9
84194: PUSH
84195: LD_VAR 0 41
84199: PUSH
84200: LD_VAR 0 42
84204: PUSH
84205: LD_VAR 0 43
84209: PUSH
84210: LD_VAR 0 44
84214: PUSH
84215: LD_VAR 0 45
84219: PUSH
84220: LD_VAR 0 46
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: PUSH
84233: LD_VAR 0 4
84237: PUSH
84238: LD_INT 1
84240: PLUS
84241: ARRAY
84242: ST_TO_ADDR
84243: GO 84498
84245: LD_INT 36
84247: DOUBLE
84248: EQUAL
84249: IFTRUE 84253
84251: GO 84309
84253: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84254: LD_ADDR_VAR 0 9
84258: PUSH
84259: LD_VAR 0 47
84263: PUSH
84264: LD_VAR 0 48
84268: PUSH
84269: LD_VAR 0 49
84273: PUSH
84274: LD_VAR 0 50
84278: PUSH
84279: LD_VAR 0 51
84283: PUSH
84284: LD_VAR 0 52
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: PUSH
84297: LD_VAR 0 4
84301: PUSH
84302: LD_INT 1
84304: PLUS
84305: ARRAY
84306: ST_TO_ADDR
84307: GO 84498
84309: LD_INT 4
84311: DOUBLE
84312: EQUAL
84313: IFTRUE 84335
84315: LD_INT 5
84317: DOUBLE
84318: EQUAL
84319: IFTRUE 84335
84321: LD_INT 34
84323: DOUBLE
84324: EQUAL
84325: IFTRUE 84335
84327: LD_INT 37
84329: DOUBLE
84330: EQUAL
84331: IFTRUE 84335
84333: GO 84391
84335: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84336: LD_ADDR_VAR 0 9
84340: PUSH
84341: LD_VAR 0 53
84345: PUSH
84346: LD_VAR 0 54
84350: PUSH
84351: LD_VAR 0 55
84355: PUSH
84356: LD_VAR 0 56
84360: PUSH
84361: LD_VAR 0 57
84365: PUSH
84366: LD_VAR 0 58
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: PUSH
84379: LD_VAR 0 4
84383: PUSH
84384: LD_INT 1
84386: PLUS
84387: ARRAY
84388: ST_TO_ADDR
84389: GO 84498
84391: LD_INT 31
84393: DOUBLE
84394: EQUAL
84395: IFTRUE 84441
84397: LD_INT 32
84399: DOUBLE
84400: EQUAL
84401: IFTRUE 84441
84403: LD_INT 33
84405: DOUBLE
84406: EQUAL
84407: IFTRUE 84441
84409: LD_INT 27
84411: DOUBLE
84412: EQUAL
84413: IFTRUE 84441
84415: LD_INT 26
84417: DOUBLE
84418: EQUAL
84419: IFTRUE 84441
84421: LD_INT 28
84423: DOUBLE
84424: EQUAL
84425: IFTRUE 84441
84427: LD_INT 29
84429: DOUBLE
84430: EQUAL
84431: IFTRUE 84441
84433: LD_INT 30
84435: DOUBLE
84436: EQUAL
84437: IFTRUE 84441
84439: GO 84497
84441: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84442: LD_ADDR_VAR 0 9
84446: PUSH
84447: LD_VAR 0 59
84451: PUSH
84452: LD_VAR 0 60
84456: PUSH
84457: LD_VAR 0 61
84461: PUSH
84462: LD_VAR 0 62
84466: PUSH
84467: LD_VAR 0 63
84471: PUSH
84472: LD_VAR 0 64
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: PUSH
84485: LD_VAR 0 4
84489: PUSH
84490: LD_INT 1
84492: PLUS
84493: ARRAY
84494: ST_TO_ADDR
84495: GO 84498
84497: POP
// temp_list2 = [ ] ;
84498: LD_ADDR_VAR 0 10
84502: PUSH
84503: EMPTY
84504: ST_TO_ADDR
// for i in temp_list do
84505: LD_ADDR_VAR 0 8
84509: PUSH
84510: LD_VAR 0 9
84514: PUSH
84515: FOR_IN
84516: IFFALSE 84568
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84518: LD_ADDR_VAR 0 10
84522: PUSH
84523: LD_VAR 0 10
84527: PUSH
84528: LD_VAR 0 8
84532: PUSH
84533: LD_INT 1
84535: ARRAY
84536: PUSH
84537: LD_VAR 0 2
84541: PLUS
84542: PUSH
84543: LD_VAR 0 8
84547: PUSH
84548: LD_INT 2
84550: ARRAY
84551: PUSH
84552: LD_VAR 0 3
84556: PLUS
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: EMPTY
84563: LIST
84564: ADD
84565: ST_TO_ADDR
84566: GO 84515
84568: POP
84569: POP
// result = temp_list2 ;
84570: LD_ADDR_VAR 0 7
84574: PUSH
84575: LD_VAR 0 10
84579: ST_TO_ADDR
// end ;
84580: LD_VAR 0 7
84584: RET
// export function EnemyInRange ( unit , dist ) ; begin
84585: LD_INT 0
84587: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84588: LD_ADDR_VAR 0 3
84592: PUSH
84593: LD_VAR 0 1
84597: PPUSH
84598: CALL_OW 255
84602: PPUSH
84603: LD_VAR 0 1
84607: PPUSH
84608: CALL_OW 250
84612: PPUSH
84613: LD_VAR 0 1
84617: PPUSH
84618: CALL_OW 251
84622: PPUSH
84623: LD_VAR 0 2
84627: PPUSH
84628: CALL 58689 0 4
84632: PUSH
84633: LD_INT 4
84635: ARRAY
84636: ST_TO_ADDR
// end ;
84637: LD_VAR 0 3
84641: RET
// export function PlayerSeeMe ( unit ) ; begin
84642: LD_INT 0
84644: PPUSH
// result := See ( your_side , unit ) ;
84645: LD_ADDR_VAR 0 2
84649: PUSH
84650: LD_OWVAR 2
84654: PPUSH
84655: LD_VAR 0 1
84659: PPUSH
84660: CALL_OW 292
84664: ST_TO_ADDR
// end ;
84665: LD_VAR 0 2
84669: RET
// export function ReverseDir ( unit ) ; begin
84670: LD_INT 0
84672: PPUSH
// if not unit then
84673: LD_VAR 0 1
84677: NOT
84678: IFFALSE 84682
// exit ;
84680: GO 84705
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84682: LD_ADDR_VAR 0 2
84686: PUSH
84687: LD_VAR 0 1
84691: PPUSH
84692: CALL_OW 254
84696: PUSH
84697: LD_INT 3
84699: PLUS
84700: PUSH
84701: LD_INT 6
84703: MOD
84704: ST_TO_ADDR
// end ;
84705: LD_VAR 0 2
84709: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84710: LD_INT 0
84712: PPUSH
84713: PPUSH
84714: PPUSH
84715: PPUSH
84716: PPUSH
// if not hexes then
84717: LD_VAR 0 2
84721: NOT
84722: IFFALSE 84726
// exit ;
84724: GO 84874
// dist := 9999 ;
84726: LD_ADDR_VAR 0 5
84730: PUSH
84731: LD_INT 9999
84733: ST_TO_ADDR
// for i = 1 to hexes do
84734: LD_ADDR_VAR 0 4
84738: PUSH
84739: DOUBLE
84740: LD_INT 1
84742: DEC
84743: ST_TO_ADDR
84744: LD_VAR 0 2
84748: PUSH
84749: FOR_TO
84750: IFFALSE 84862
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84752: LD_VAR 0 1
84756: PPUSH
84757: LD_VAR 0 2
84761: PUSH
84762: LD_VAR 0 4
84766: ARRAY
84767: PUSH
84768: LD_INT 1
84770: ARRAY
84771: PPUSH
84772: LD_VAR 0 2
84776: PUSH
84777: LD_VAR 0 4
84781: ARRAY
84782: PUSH
84783: LD_INT 2
84785: ARRAY
84786: PPUSH
84787: CALL_OW 297
84791: PUSH
84792: LD_VAR 0 5
84796: LESS
84797: IFFALSE 84860
// begin hex := hexes [ i ] ;
84799: LD_ADDR_VAR 0 7
84803: PUSH
84804: LD_VAR 0 2
84808: PUSH
84809: LD_VAR 0 4
84813: ARRAY
84814: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84815: LD_ADDR_VAR 0 5
84819: PUSH
84820: LD_VAR 0 1
84824: PPUSH
84825: LD_VAR 0 2
84829: PUSH
84830: LD_VAR 0 4
84834: ARRAY
84835: PUSH
84836: LD_INT 1
84838: ARRAY
84839: PPUSH
84840: LD_VAR 0 2
84844: PUSH
84845: LD_VAR 0 4
84849: ARRAY
84850: PUSH
84851: LD_INT 2
84853: ARRAY
84854: PPUSH
84855: CALL_OW 297
84859: ST_TO_ADDR
// end ; end ;
84860: GO 84749
84862: POP
84863: POP
// result := hex ;
84864: LD_ADDR_VAR 0 3
84868: PUSH
84869: LD_VAR 0 7
84873: ST_TO_ADDR
// end ;
84874: LD_VAR 0 3
84878: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84879: LD_INT 0
84881: PPUSH
84882: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84883: LD_VAR 0 1
84887: NOT
84888: PUSH
84889: LD_VAR 0 1
84893: PUSH
84894: LD_INT 21
84896: PUSH
84897: LD_INT 2
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 23
84906: PUSH
84907: LD_INT 2
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PPUSH
84918: CALL_OW 69
84922: IN
84923: NOT
84924: OR
84925: IFFALSE 84929
// exit ;
84927: GO 84976
// for i = 1 to 3 do
84929: LD_ADDR_VAR 0 3
84933: PUSH
84934: DOUBLE
84935: LD_INT 1
84937: DEC
84938: ST_TO_ADDR
84939: LD_INT 3
84941: PUSH
84942: FOR_TO
84943: IFFALSE 84974
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84945: LD_VAR 0 1
84949: PPUSH
84950: CALL_OW 250
84954: PPUSH
84955: LD_VAR 0 1
84959: PPUSH
84960: CALL_OW 251
84964: PPUSH
84965: LD_INT 1
84967: PPUSH
84968: CALL_OW 453
84972: GO 84942
84974: POP
84975: POP
// end ;
84976: LD_VAR 0 2
84980: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84981: LD_INT 0
84983: PPUSH
84984: PPUSH
84985: PPUSH
84986: PPUSH
84987: PPUSH
84988: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84989: LD_VAR 0 1
84993: NOT
84994: PUSH
84995: LD_VAR 0 2
84999: NOT
85000: OR
85001: PUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 314
85011: OR
85012: IFFALSE 85016
// exit ;
85014: GO 85457
// x := GetX ( enemy_unit ) ;
85016: LD_ADDR_VAR 0 7
85020: PUSH
85021: LD_VAR 0 2
85025: PPUSH
85026: CALL_OW 250
85030: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85031: LD_ADDR_VAR 0 8
85035: PUSH
85036: LD_VAR 0 2
85040: PPUSH
85041: CALL_OW 251
85045: ST_TO_ADDR
// if not x or not y then
85046: LD_VAR 0 7
85050: NOT
85051: PUSH
85052: LD_VAR 0 8
85056: NOT
85057: OR
85058: IFFALSE 85062
// exit ;
85060: GO 85457
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85062: LD_ADDR_VAR 0 6
85066: PUSH
85067: LD_VAR 0 7
85071: PPUSH
85072: LD_INT 0
85074: PPUSH
85075: LD_INT 4
85077: PPUSH
85078: CALL_OW 272
85082: PUSH
85083: LD_VAR 0 8
85087: PPUSH
85088: LD_INT 0
85090: PPUSH
85091: LD_INT 4
85093: PPUSH
85094: CALL_OW 273
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_VAR 0 7
85107: PPUSH
85108: LD_INT 1
85110: PPUSH
85111: LD_INT 4
85113: PPUSH
85114: CALL_OW 272
85118: PUSH
85119: LD_VAR 0 8
85123: PPUSH
85124: LD_INT 1
85126: PPUSH
85127: LD_INT 4
85129: PPUSH
85130: CALL_OW 273
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_VAR 0 7
85143: PPUSH
85144: LD_INT 2
85146: PPUSH
85147: LD_INT 4
85149: PPUSH
85150: CALL_OW 272
85154: PUSH
85155: LD_VAR 0 8
85159: PPUSH
85160: LD_INT 2
85162: PPUSH
85163: LD_INT 4
85165: PPUSH
85166: CALL_OW 273
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_VAR 0 7
85179: PPUSH
85180: LD_INT 3
85182: PPUSH
85183: LD_INT 4
85185: PPUSH
85186: CALL_OW 272
85190: PUSH
85191: LD_VAR 0 8
85195: PPUSH
85196: LD_INT 3
85198: PPUSH
85199: LD_INT 4
85201: PPUSH
85202: CALL_OW 273
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_VAR 0 7
85215: PPUSH
85216: LD_INT 4
85218: PPUSH
85219: LD_INT 4
85221: PPUSH
85222: CALL_OW 272
85226: PUSH
85227: LD_VAR 0 8
85231: PPUSH
85232: LD_INT 4
85234: PPUSH
85235: LD_INT 4
85237: PPUSH
85238: CALL_OW 273
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_VAR 0 7
85251: PPUSH
85252: LD_INT 5
85254: PPUSH
85255: LD_INT 4
85257: PPUSH
85258: CALL_OW 272
85262: PUSH
85263: LD_VAR 0 8
85267: PPUSH
85268: LD_INT 5
85270: PPUSH
85271: LD_INT 4
85273: PPUSH
85274: CALL_OW 273
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: ST_TO_ADDR
// for i = tmp downto 1 do
85291: LD_ADDR_VAR 0 4
85295: PUSH
85296: DOUBLE
85297: LD_VAR 0 6
85301: INC
85302: ST_TO_ADDR
85303: LD_INT 1
85305: PUSH
85306: FOR_DOWNTO
85307: IFFALSE 85408
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85309: LD_VAR 0 6
85313: PUSH
85314: LD_VAR 0 4
85318: ARRAY
85319: PUSH
85320: LD_INT 1
85322: ARRAY
85323: PPUSH
85324: LD_VAR 0 6
85328: PUSH
85329: LD_VAR 0 4
85333: ARRAY
85334: PUSH
85335: LD_INT 2
85337: ARRAY
85338: PPUSH
85339: CALL_OW 488
85343: NOT
85344: PUSH
85345: LD_VAR 0 6
85349: PUSH
85350: LD_VAR 0 4
85354: ARRAY
85355: PUSH
85356: LD_INT 1
85358: ARRAY
85359: PPUSH
85360: LD_VAR 0 6
85364: PUSH
85365: LD_VAR 0 4
85369: ARRAY
85370: PUSH
85371: LD_INT 2
85373: ARRAY
85374: PPUSH
85375: CALL_OW 428
85379: PUSH
85380: LD_INT 0
85382: NONEQUAL
85383: OR
85384: IFFALSE 85406
// tmp := Delete ( tmp , i ) ;
85386: LD_ADDR_VAR 0 6
85390: PUSH
85391: LD_VAR 0 6
85395: PPUSH
85396: LD_VAR 0 4
85400: PPUSH
85401: CALL_OW 3
85405: ST_TO_ADDR
85406: GO 85306
85408: POP
85409: POP
// j := GetClosestHex ( unit , tmp ) ;
85410: LD_ADDR_VAR 0 5
85414: PUSH
85415: LD_VAR 0 1
85419: PPUSH
85420: LD_VAR 0 6
85424: PPUSH
85425: CALL 84710 0 2
85429: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85430: LD_VAR 0 1
85434: PPUSH
85435: LD_VAR 0 5
85439: PUSH
85440: LD_INT 1
85442: ARRAY
85443: PPUSH
85444: LD_VAR 0 5
85448: PUSH
85449: LD_INT 2
85451: ARRAY
85452: PPUSH
85453: CALL_OW 111
// end ;
85457: LD_VAR 0 3
85461: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85462: LD_INT 0
85464: PPUSH
85465: PPUSH
85466: PPUSH
// uc_side = 0 ;
85467: LD_ADDR_OWVAR 20
85471: PUSH
85472: LD_INT 0
85474: ST_TO_ADDR
// uc_nation = 0 ;
85475: LD_ADDR_OWVAR 21
85479: PUSH
85480: LD_INT 0
85482: ST_TO_ADDR
// InitHc ;
85483: CALL_OW 19
// InitVc ;
85487: CALL_OW 20
// if mastodonts then
85491: LD_VAR 0 6
85495: IFFALSE 85562
// for i = 1 to mastodonts do
85497: LD_ADDR_VAR 0 11
85501: PUSH
85502: DOUBLE
85503: LD_INT 1
85505: DEC
85506: ST_TO_ADDR
85507: LD_VAR 0 6
85511: PUSH
85512: FOR_TO
85513: IFFALSE 85560
// begin vc_chassis := 31 ;
85515: LD_ADDR_OWVAR 37
85519: PUSH
85520: LD_INT 31
85522: ST_TO_ADDR
// vc_control := control_rider ;
85523: LD_ADDR_OWVAR 38
85527: PUSH
85528: LD_INT 4
85530: ST_TO_ADDR
// animal := CreateVehicle ;
85531: LD_ADDR_VAR 0 12
85535: PUSH
85536: CALL_OW 45
85540: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85541: LD_VAR 0 12
85545: PPUSH
85546: LD_VAR 0 8
85550: PPUSH
85551: LD_INT 0
85553: PPUSH
85554: CALL 92340 0 3
// end ;
85558: GO 85512
85560: POP
85561: POP
// if horses then
85562: LD_VAR 0 5
85566: IFFALSE 85633
// for i = 1 to horses do
85568: LD_ADDR_VAR 0 11
85572: PUSH
85573: DOUBLE
85574: LD_INT 1
85576: DEC
85577: ST_TO_ADDR
85578: LD_VAR 0 5
85582: PUSH
85583: FOR_TO
85584: IFFALSE 85631
// begin hc_class := 21 ;
85586: LD_ADDR_OWVAR 28
85590: PUSH
85591: LD_INT 21
85593: ST_TO_ADDR
// hc_gallery :=  ;
85594: LD_ADDR_OWVAR 33
85598: PUSH
85599: LD_STRING 
85601: ST_TO_ADDR
// animal := CreateHuman ;
85602: LD_ADDR_VAR 0 12
85606: PUSH
85607: CALL_OW 44
85611: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85612: LD_VAR 0 12
85616: PPUSH
85617: LD_VAR 0 8
85621: PPUSH
85622: LD_INT 0
85624: PPUSH
85625: CALL 92340 0 3
// end ;
85629: GO 85583
85631: POP
85632: POP
// if birds then
85633: LD_VAR 0 1
85637: IFFALSE 85704
// for i = 1 to birds do
85639: LD_ADDR_VAR 0 11
85643: PUSH
85644: DOUBLE
85645: LD_INT 1
85647: DEC
85648: ST_TO_ADDR
85649: LD_VAR 0 1
85653: PUSH
85654: FOR_TO
85655: IFFALSE 85702
// begin hc_class = 18 ;
85657: LD_ADDR_OWVAR 28
85661: PUSH
85662: LD_INT 18
85664: ST_TO_ADDR
// hc_gallery =  ;
85665: LD_ADDR_OWVAR 33
85669: PUSH
85670: LD_STRING 
85672: ST_TO_ADDR
// animal := CreateHuman ;
85673: LD_ADDR_VAR 0 12
85677: PUSH
85678: CALL_OW 44
85682: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85683: LD_VAR 0 12
85687: PPUSH
85688: LD_VAR 0 8
85692: PPUSH
85693: LD_INT 0
85695: PPUSH
85696: CALL 92340 0 3
// end ;
85700: GO 85654
85702: POP
85703: POP
// if tigers then
85704: LD_VAR 0 2
85708: IFFALSE 85792
// for i = 1 to tigers do
85710: LD_ADDR_VAR 0 11
85714: PUSH
85715: DOUBLE
85716: LD_INT 1
85718: DEC
85719: ST_TO_ADDR
85720: LD_VAR 0 2
85724: PUSH
85725: FOR_TO
85726: IFFALSE 85790
// begin hc_class = class_tiger ;
85728: LD_ADDR_OWVAR 28
85732: PUSH
85733: LD_INT 14
85735: ST_TO_ADDR
// hc_gallery =  ;
85736: LD_ADDR_OWVAR 33
85740: PUSH
85741: LD_STRING 
85743: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85744: LD_ADDR_OWVAR 35
85748: PUSH
85749: LD_INT 7
85751: NEG
85752: PPUSH
85753: LD_INT 7
85755: PPUSH
85756: CALL_OW 12
85760: ST_TO_ADDR
// animal := CreateHuman ;
85761: LD_ADDR_VAR 0 12
85765: PUSH
85766: CALL_OW 44
85770: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85771: LD_VAR 0 12
85775: PPUSH
85776: LD_VAR 0 8
85780: PPUSH
85781: LD_INT 0
85783: PPUSH
85784: CALL 92340 0 3
// end ;
85788: GO 85725
85790: POP
85791: POP
// if apemans then
85792: LD_VAR 0 3
85796: IFFALSE 85919
// for i = 1 to apemans do
85798: LD_ADDR_VAR 0 11
85802: PUSH
85803: DOUBLE
85804: LD_INT 1
85806: DEC
85807: ST_TO_ADDR
85808: LD_VAR 0 3
85812: PUSH
85813: FOR_TO
85814: IFFALSE 85917
// begin hc_class = class_apeman ;
85816: LD_ADDR_OWVAR 28
85820: PUSH
85821: LD_INT 12
85823: ST_TO_ADDR
// hc_gallery =  ;
85824: LD_ADDR_OWVAR 33
85828: PUSH
85829: LD_STRING 
85831: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85832: LD_ADDR_OWVAR 35
85836: PUSH
85837: LD_INT 5
85839: NEG
85840: PPUSH
85841: LD_INT 5
85843: PPUSH
85844: CALL_OW 12
85848: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85849: LD_ADDR_OWVAR 31
85853: PUSH
85854: LD_INT 1
85856: PPUSH
85857: LD_INT 3
85859: PPUSH
85860: CALL_OW 12
85864: PUSH
85865: LD_INT 1
85867: PPUSH
85868: LD_INT 3
85870: PPUSH
85871: CALL_OW 12
85875: PUSH
85876: LD_INT 0
85878: PUSH
85879: LD_INT 0
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: ST_TO_ADDR
// animal := CreateHuman ;
85888: LD_ADDR_VAR 0 12
85892: PUSH
85893: CALL_OW 44
85897: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85898: LD_VAR 0 12
85902: PPUSH
85903: LD_VAR 0 8
85907: PPUSH
85908: LD_INT 0
85910: PPUSH
85911: CALL 92340 0 3
// end ;
85915: GO 85813
85917: POP
85918: POP
// if enchidnas then
85919: LD_VAR 0 4
85923: IFFALSE 85990
// for i = 1 to enchidnas do
85925: LD_ADDR_VAR 0 11
85929: PUSH
85930: DOUBLE
85931: LD_INT 1
85933: DEC
85934: ST_TO_ADDR
85935: LD_VAR 0 4
85939: PUSH
85940: FOR_TO
85941: IFFALSE 85988
// begin hc_class = 13 ;
85943: LD_ADDR_OWVAR 28
85947: PUSH
85948: LD_INT 13
85950: ST_TO_ADDR
// hc_gallery =  ;
85951: LD_ADDR_OWVAR 33
85955: PUSH
85956: LD_STRING 
85958: ST_TO_ADDR
// animal := CreateHuman ;
85959: LD_ADDR_VAR 0 12
85963: PUSH
85964: CALL_OW 44
85968: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85969: LD_VAR 0 12
85973: PPUSH
85974: LD_VAR 0 8
85978: PPUSH
85979: LD_INT 0
85981: PPUSH
85982: CALL 92340 0 3
// end ;
85986: GO 85940
85988: POP
85989: POP
// if fishes then
85990: LD_VAR 0 7
85994: IFFALSE 86061
// for i = 1 to fishes do
85996: LD_ADDR_VAR 0 11
86000: PUSH
86001: DOUBLE
86002: LD_INT 1
86004: DEC
86005: ST_TO_ADDR
86006: LD_VAR 0 7
86010: PUSH
86011: FOR_TO
86012: IFFALSE 86059
// begin hc_class = 20 ;
86014: LD_ADDR_OWVAR 28
86018: PUSH
86019: LD_INT 20
86021: ST_TO_ADDR
// hc_gallery =  ;
86022: LD_ADDR_OWVAR 33
86026: PUSH
86027: LD_STRING 
86029: ST_TO_ADDR
// animal := CreateHuman ;
86030: LD_ADDR_VAR 0 12
86034: PUSH
86035: CALL_OW 44
86039: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86040: LD_VAR 0 12
86044: PPUSH
86045: LD_VAR 0 9
86049: PPUSH
86050: LD_INT 0
86052: PPUSH
86053: CALL 92340 0 3
// end ;
86057: GO 86011
86059: POP
86060: POP
// end ;
86061: LD_VAR 0 10
86065: RET
// export function WantHeal ( sci , unit ) ; begin
86066: LD_INT 0
86068: PPUSH
// if GetTaskList ( sci ) > 0 then
86069: LD_VAR 0 1
86073: PPUSH
86074: CALL_OW 437
86078: PUSH
86079: LD_INT 0
86081: GREATER
86082: IFFALSE 86152
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86084: LD_VAR 0 1
86088: PPUSH
86089: CALL_OW 437
86093: PUSH
86094: LD_INT 1
86096: ARRAY
86097: PUSH
86098: LD_INT 1
86100: ARRAY
86101: PUSH
86102: LD_STRING l
86104: EQUAL
86105: PUSH
86106: LD_VAR 0 1
86110: PPUSH
86111: CALL_OW 437
86115: PUSH
86116: LD_INT 1
86118: ARRAY
86119: PUSH
86120: LD_INT 4
86122: ARRAY
86123: PUSH
86124: LD_VAR 0 2
86128: EQUAL
86129: AND
86130: IFFALSE 86142
// result := true else
86132: LD_ADDR_VAR 0 3
86136: PUSH
86137: LD_INT 1
86139: ST_TO_ADDR
86140: GO 86150
// result := false ;
86142: LD_ADDR_VAR 0 3
86146: PUSH
86147: LD_INT 0
86149: ST_TO_ADDR
// end else
86150: GO 86160
// result := false ;
86152: LD_ADDR_VAR 0 3
86156: PUSH
86157: LD_INT 0
86159: ST_TO_ADDR
// end ;
86160: LD_VAR 0 3
86164: RET
// export function HealTarget ( sci ) ; begin
86165: LD_INT 0
86167: PPUSH
// if not sci then
86168: LD_VAR 0 1
86172: NOT
86173: IFFALSE 86177
// exit ;
86175: GO 86242
// result := 0 ;
86177: LD_ADDR_VAR 0 2
86181: PUSH
86182: LD_INT 0
86184: ST_TO_ADDR
// if GetTaskList ( sci ) then
86185: LD_VAR 0 1
86189: PPUSH
86190: CALL_OW 437
86194: IFFALSE 86242
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86196: LD_VAR 0 1
86200: PPUSH
86201: CALL_OW 437
86205: PUSH
86206: LD_INT 1
86208: ARRAY
86209: PUSH
86210: LD_INT 1
86212: ARRAY
86213: PUSH
86214: LD_STRING l
86216: EQUAL
86217: IFFALSE 86242
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86219: LD_ADDR_VAR 0 2
86223: PUSH
86224: LD_VAR 0 1
86228: PPUSH
86229: CALL_OW 437
86233: PUSH
86234: LD_INT 1
86236: ARRAY
86237: PUSH
86238: LD_INT 4
86240: ARRAY
86241: ST_TO_ADDR
// end ;
86242: LD_VAR 0 2
86246: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86247: LD_INT 0
86249: PPUSH
86250: PPUSH
86251: PPUSH
86252: PPUSH
86253: PPUSH
86254: PPUSH
86255: PPUSH
86256: PPUSH
86257: PPUSH
86258: PPUSH
86259: PPUSH
86260: PPUSH
86261: PPUSH
86262: PPUSH
86263: PPUSH
86264: PPUSH
86265: PPUSH
86266: PPUSH
86267: PPUSH
86268: PPUSH
86269: PPUSH
86270: PPUSH
86271: PPUSH
86272: PPUSH
86273: PPUSH
86274: PPUSH
86275: PPUSH
86276: PPUSH
86277: PPUSH
86278: PPUSH
86279: PPUSH
86280: PPUSH
86281: PPUSH
86282: PPUSH
// if not list then
86283: LD_VAR 0 1
86287: NOT
86288: IFFALSE 86292
// exit ;
86290: GO 90951
// base := list [ 1 ] ;
86292: LD_ADDR_VAR 0 3
86296: PUSH
86297: LD_VAR 0 1
86301: PUSH
86302: LD_INT 1
86304: ARRAY
86305: ST_TO_ADDR
// group := list [ 2 ] ;
86306: LD_ADDR_VAR 0 4
86310: PUSH
86311: LD_VAR 0 1
86315: PUSH
86316: LD_INT 2
86318: ARRAY
86319: ST_TO_ADDR
// path := list [ 3 ] ;
86320: LD_ADDR_VAR 0 5
86324: PUSH
86325: LD_VAR 0 1
86329: PUSH
86330: LD_INT 3
86332: ARRAY
86333: ST_TO_ADDR
// flags := list [ 4 ] ;
86334: LD_ADDR_VAR 0 6
86338: PUSH
86339: LD_VAR 0 1
86343: PUSH
86344: LD_INT 4
86346: ARRAY
86347: ST_TO_ADDR
// mined := [ ] ;
86348: LD_ADDR_VAR 0 27
86352: PUSH
86353: EMPTY
86354: ST_TO_ADDR
// bombed := [ ] ;
86355: LD_ADDR_VAR 0 28
86359: PUSH
86360: EMPTY
86361: ST_TO_ADDR
// healers := [ ] ;
86362: LD_ADDR_VAR 0 31
86366: PUSH
86367: EMPTY
86368: ST_TO_ADDR
// to_heal := [ ] ;
86369: LD_ADDR_VAR 0 30
86373: PUSH
86374: EMPTY
86375: ST_TO_ADDR
// repairs := [ ] ;
86376: LD_ADDR_VAR 0 33
86380: PUSH
86381: EMPTY
86382: ST_TO_ADDR
// to_repair := [ ] ;
86383: LD_ADDR_VAR 0 32
86387: PUSH
86388: EMPTY
86389: ST_TO_ADDR
// if not group or not path then
86390: LD_VAR 0 4
86394: NOT
86395: PUSH
86396: LD_VAR 0 5
86400: NOT
86401: OR
86402: IFFALSE 86406
// exit ;
86404: GO 90951
// side := GetSide ( group [ 1 ] ) ;
86406: LD_ADDR_VAR 0 35
86410: PUSH
86411: LD_VAR 0 4
86415: PUSH
86416: LD_INT 1
86418: ARRAY
86419: PPUSH
86420: CALL_OW 255
86424: ST_TO_ADDR
// if flags then
86425: LD_VAR 0 6
86429: IFFALSE 86573
// begin f_ignore_area := flags [ 1 ] ;
86431: LD_ADDR_VAR 0 17
86435: PUSH
86436: LD_VAR 0 6
86440: PUSH
86441: LD_INT 1
86443: ARRAY
86444: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86445: LD_ADDR_VAR 0 18
86449: PUSH
86450: LD_VAR 0 6
86454: PUSH
86455: LD_INT 2
86457: ARRAY
86458: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86459: LD_ADDR_VAR 0 19
86463: PUSH
86464: LD_VAR 0 6
86468: PUSH
86469: LD_INT 3
86471: ARRAY
86472: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86473: LD_ADDR_VAR 0 20
86477: PUSH
86478: LD_VAR 0 6
86482: PUSH
86483: LD_INT 4
86485: ARRAY
86486: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86487: LD_ADDR_VAR 0 21
86491: PUSH
86492: LD_VAR 0 6
86496: PUSH
86497: LD_INT 5
86499: ARRAY
86500: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86501: LD_ADDR_VAR 0 22
86505: PUSH
86506: LD_VAR 0 6
86510: PUSH
86511: LD_INT 6
86513: ARRAY
86514: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86515: LD_ADDR_VAR 0 23
86519: PUSH
86520: LD_VAR 0 6
86524: PUSH
86525: LD_INT 7
86527: ARRAY
86528: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86529: LD_ADDR_VAR 0 24
86533: PUSH
86534: LD_VAR 0 6
86538: PUSH
86539: LD_INT 8
86541: ARRAY
86542: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86543: LD_ADDR_VAR 0 25
86547: PUSH
86548: LD_VAR 0 6
86552: PUSH
86553: LD_INT 9
86555: ARRAY
86556: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86557: LD_ADDR_VAR 0 26
86561: PUSH
86562: LD_VAR 0 6
86566: PUSH
86567: LD_INT 10
86569: ARRAY
86570: ST_TO_ADDR
// end else
86571: GO 86653
// begin f_ignore_area := false ;
86573: LD_ADDR_VAR 0 17
86577: PUSH
86578: LD_INT 0
86580: ST_TO_ADDR
// f_capture := false ;
86581: LD_ADDR_VAR 0 18
86585: PUSH
86586: LD_INT 0
86588: ST_TO_ADDR
// f_ignore_civ := false ;
86589: LD_ADDR_VAR 0 19
86593: PUSH
86594: LD_INT 0
86596: ST_TO_ADDR
// f_murder := false ;
86597: LD_ADDR_VAR 0 20
86601: PUSH
86602: LD_INT 0
86604: ST_TO_ADDR
// f_mines := false ;
86605: LD_ADDR_VAR 0 21
86609: PUSH
86610: LD_INT 0
86612: ST_TO_ADDR
// f_repair := false ;
86613: LD_ADDR_VAR 0 22
86617: PUSH
86618: LD_INT 0
86620: ST_TO_ADDR
// f_heal := false ;
86621: LD_ADDR_VAR 0 23
86625: PUSH
86626: LD_INT 0
86628: ST_TO_ADDR
// f_spacetime := false ;
86629: LD_ADDR_VAR 0 24
86633: PUSH
86634: LD_INT 0
86636: ST_TO_ADDR
// f_attack_depot := false ;
86637: LD_ADDR_VAR 0 25
86641: PUSH
86642: LD_INT 0
86644: ST_TO_ADDR
// f_crawl := false ;
86645: LD_ADDR_VAR 0 26
86649: PUSH
86650: LD_INT 0
86652: ST_TO_ADDR
// end ; if f_heal then
86653: LD_VAR 0 23
86657: IFFALSE 86684
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86659: LD_ADDR_VAR 0 31
86663: PUSH
86664: LD_VAR 0 4
86668: PPUSH
86669: LD_INT 25
86671: PUSH
86672: LD_INT 4
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PPUSH
86679: CALL_OW 72
86683: ST_TO_ADDR
// if f_repair then
86684: LD_VAR 0 22
86688: IFFALSE 86715
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86690: LD_ADDR_VAR 0 33
86694: PUSH
86695: LD_VAR 0 4
86699: PPUSH
86700: LD_INT 25
86702: PUSH
86703: LD_INT 3
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PPUSH
86710: CALL_OW 72
86714: ST_TO_ADDR
// units_path := [ ] ;
86715: LD_ADDR_VAR 0 16
86719: PUSH
86720: EMPTY
86721: ST_TO_ADDR
// for i = 1 to group do
86722: LD_ADDR_VAR 0 7
86726: PUSH
86727: DOUBLE
86728: LD_INT 1
86730: DEC
86731: ST_TO_ADDR
86732: LD_VAR 0 4
86736: PUSH
86737: FOR_TO
86738: IFFALSE 86767
// units_path := Replace ( units_path , i , path ) ;
86740: LD_ADDR_VAR 0 16
86744: PUSH
86745: LD_VAR 0 16
86749: PPUSH
86750: LD_VAR 0 7
86754: PPUSH
86755: LD_VAR 0 5
86759: PPUSH
86760: CALL_OW 1
86764: ST_TO_ADDR
86765: GO 86737
86767: POP
86768: POP
// repeat for i = group downto 1 do
86769: LD_ADDR_VAR 0 7
86773: PUSH
86774: DOUBLE
86775: LD_VAR 0 4
86779: INC
86780: ST_TO_ADDR
86781: LD_INT 1
86783: PUSH
86784: FOR_DOWNTO
86785: IFFALSE 90907
// begin wait ( 5 ) ;
86787: LD_INT 5
86789: PPUSH
86790: CALL_OW 67
// tmp := [ ] ;
86794: LD_ADDR_VAR 0 14
86798: PUSH
86799: EMPTY
86800: ST_TO_ADDR
// attacking := false ;
86801: LD_ADDR_VAR 0 29
86805: PUSH
86806: LD_INT 0
86808: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86809: LD_VAR 0 4
86813: PUSH
86814: LD_VAR 0 7
86818: ARRAY
86819: PPUSH
86820: CALL_OW 301
86824: PUSH
86825: LD_VAR 0 4
86829: PUSH
86830: LD_VAR 0 7
86834: ARRAY
86835: NOT
86836: OR
86837: IFFALSE 86946
// begin if GetType ( group [ i ] ) = unit_human then
86839: LD_VAR 0 4
86843: PUSH
86844: LD_VAR 0 7
86848: ARRAY
86849: PPUSH
86850: CALL_OW 247
86854: PUSH
86855: LD_INT 1
86857: EQUAL
86858: IFFALSE 86904
// begin to_heal := to_heal diff group [ i ] ;
86860: LD_ADDR_VAR 0 30
86864: PUSH
86865: LD_VAR 0 30
86869: PUSH
86870: LD_VAR 0 4
86874: PUSH
86875: LD_VAR 0 7
86879: ARRAY
86880: DIFF
86881: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86882: LD_ADDR_VAR 0 31
86886: PUSH
86887: LD_VAR 0 31
86891: PUSH
86892: LD_VAR 0 4
86896: PUSH
86897: LD_VAR 0 7
86901: ARRAY
86902: DIFF
86903: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86904: LD_ADDR_VAR 0 4
86908: PUSH
86909: LD_VAR 0 4
86913: PPUSH
86914: LD_VAR 0 7
86918: PPUSH
86919: CALL_OW 3
86923: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86924: LD_ADDR_VAR 0 16
86928: PUSH
86929: LD_VAR 0 16
86933: PPUSH
86934: LD_VAR 0 7
86938: PPUSH
86939: CALL_OW 3
86943: ST_TO_ADDR
// continue ;
86944: GO 86784
// end ; if f_repair then
86946: LD_VAR 0 22
86950: IFFALSE 87439
// begin if GetType ( group [ i ] ) = unit_vehicle then
86952: LD_VAR 0 4
86956: PUSH
86957: LD_VAR 0 7
86961: ARRAY
86962: PPUSH
86963: CALL_OW 247
86967: PUSH
86968: LD_INT 2
86970: EQUAL
86971: IFFALSE 87161
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86973: LD_VAR 0 4
86977: PUSH
86978: LD_VAR 0 7
86982: ARRAY
86983: PPUSH
86984: CALL_OW 256
86988: PUSH
86989: LD_INT 700
86991: LESS
86992: PUSH
86993: LD_VAR 0 4
86997: PUSH
86998: LD_VAR 0 7
87002: ARRAY
87003: PUSH
87004: LD_VAR 0 32
87008: IN
87009: NOT
87010: AND
87011: IFFALSE 87035
// to_repair := to_repair union group [ i ] ;
87013: LD_ADDR_VAR 0 32
87017: PUSH
87018: LD_VAR 0 32
87022: PUSH
87023: LD_VAR 0 4
87027: PUSH
87028: LD_VAR 0 7
87032: ARRAY
87033: UNION
87034: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
87035: LD_VAR 0 4
87039: PUSH
87040: LD_VAR 0 7
87044: ARRAY
87045: PPUSH
87046: CALL_OW 256
87050: PUSH
87051: LD_INT 1000
87053: EQUAL
87054: PUSH
87055: LD_VAR 0 4
87059: PUSH
87060: LD_VAR 0 7
87064: ARRAY
87065: PUSH
87066: LD_VAR 0 32
87070: IN
87071: AND
87072: IFFALSE 87096
// to_repair := to_repair diff group [ i ] ;
87074: LD_ADDR_VAR 0 32
87078: PUSH
87079: LD_VAR 0 32
87083: PUSH
87084: LD_VAR 0 4
87088: PUSH
87089: LD_VAR 0 7
87093: ARRAY
87094: DIFF
87095: ST_TO_ADDR
// if group [ i ] in to_repair then
87096: LD_VAR 0 4
87100: PUSH
87101: LD_VAR 0 7
87105: ARRAY
87106: PUSH
87107: LD_VAR 0 32
87111: IN
87112: IFFALSE 87159
// begin if not IsInArea ( group [ i ] , f_repair ) then
87114: LD_VAR 0 4
87118: PUSH
87119: LD_VAR 0 7
87123: ARRAY
87124: PPUSH
87125: LD_VAR 0 22
87129: PPUSH
87130: CALL_OW 308
87134: NOT
87135: IFFALSE 87157
// ComMoveToArea ( group [ i ] , f_repair ) ;
87137: LD_VAR 0 4
87141: PUSH
87142: LD_VAR 0 7
87146: ARRAY
87147: PPUSH
87148: LD_VAR 0 22
87152: PPUSH
87153: CALL_OW 113
// continue ;
87157: GO 86784
// end ; end else
87159: GO 87439
// if group [ i ] in repairs then
87161: LD_VAR 0 4
87165: PUSH
87166: LD_VAR 0 7
87170: ARRAY
87171: PUSH
87172: LD_VAR 0 33
87176: IN
87177: IFFALSE 87439
// begin if IsInUnit ( group [ i ] ) then
87179: LD_VAR 0 4
87183: PUSH
87184: LD_VAR 0 7
87188: ARRAY
87189: PPUSH
87190: CALL_OW 310
87194: IFFALSE 87262
// begin z := IsInUnit ( group [ i ] ) ;
87196: LD_ADDR_VAR 0 13
87200: PUSH
87201: LD_VAR 0 4
87205: PUSH
87206: LD_VAR 0 7
87210: ARRAY
87211: PPUSH
87212: CALL_OW 310
87216: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87217: LD_VAR 0 13
87221: PUSH
87222: LD_VAR 0 32
87226: IN
87227: PUSH
87228: LD_VAR 0 13
87232: PPUSH
87233: LD_VAR 0 22
87237: PPUSH
87238: CALL_OW 308
87242: AND
87243: IFFALSE 87260
// ComExitVehicle ( group [ i ] ) ;
87245: LD_VAR 0 4
87249: PUSH
87250: LD_VAR 0 7
87254: ARRAY
87255: PPUSH
87256: CALL_OW 121
// end else
87260: GO 87439
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87262: LD_ADDR_VAR 0 13
87266: PUSH
87267: LD_VAR 0 4
87271: PPUSH
87272: LD_INT 95
87274: PUSH
87275: LD_VAR 0 22
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 58
87286: PUSH
87287: EMPTY
87288: LIST
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PPUSH
87294: CALL_OW 72
87298: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87299: LD_VAR 0 4
87303: PUSH
87304: LD_VAR 0 7
87308: ARRAY
87309: PPUSH
87310: CALL_OW 314
87314: NOT
87315: IFFALSE 87437
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87317: LD_ADDR_VAR 0 10
87321: PUSH
87322: LD_VAR 0 13
87326: PPUSH
87327: LD_VAR 0 4
87331: PUSH
87332: LD_VAR 0 7
87336: ARRAY
87337: PPUSH
87338: CALL_OW 74
87342: ST_TO_ADDR
// if not x then
87343: LD_VAR 0 10
87347: NOT
87348: IFFALSE 87352
// continue ;
87350: GO 86784
// if GetLives ( x ) < 1000 then
87352: LD_VAR 0 10
87356: PPUSH
87357: CALL_OW 256
87361: PUSH
87362: LD_INT 1000
87364: LESS
87365: IFFALSE 87389
// ComRepairVehicle ( group [ i ] , x ) else
87367: LD_VAR 0 4
87371: PUSH
87372: LD_VAR 0 7
87376: ARRAY
87377: PPUSH
87378: LD_VAR 0 10
87382: PPUSH
87383: CALL_OW 129
87387: GO 87437
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87389: LD_VAR 0 23
87393: PUSH
87394: LD_VAR 0 4
87398: PUSH
87399: LD_VAR 0 7
87403: ARRAY
87404: PPUSH
87405: CALL_OW 256
87409: PUSH
87410: LD_INT 1000
87412: LESS
87413: AND
87414: NOT
87415: IFFALSE 87437
// ComEnterUnit ( group [ i ] , x ) ;
87417: LD_VAR 0 4
87421: PUSH
87422: LD_VAR 0 7
87426: ARRAY
87427: PPUSH
87428: LD_VAR 0 10
87432: PPUSH
87433: CALL_OW 120
// end ; continue ;
87437: GO 86784
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87439: LD_VAR 0 23
87443: PUSH
87444: LD_VAR 0 4
87448: PUSH
87449: LD_VAR 0 7
87453: ARRAY
87454: PPUSH
87455: CALL_OW 247
87459: PUSH
87460: LD_INT 1
87462: EQUAL
87463: AND
87464: IFFALSE 87942
// begin if group [ i ] in healers then
87466: LD_VAR 0 4
87470: PUSH
87471: LD_VAR 0 7
87475: ARRAY
87476: PUSH
87477: LD_VAR 0 31
87481: IN
87482: IFFALSE 87755
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87484: LD_VAR 0 4
87488: PUSH
87489: LD_VAR 0 7
87493: ARRAY
87494: PPUSH
87495: LD_VAR 0 23
87499: PPUSH
87500: CALL_OW 308
87504: NOT
87505: PUSH
87506: LD_VAR 0 4
87510: PUSH
87511: LD_VAR 0 7
87515: ARRAY
87516: PPUSH
87517: CALL_OW 314
87521: NOT
87522: AND
87523: IFFALSE 87547
// ComMoveToArea ( group [ i ] , f_heal ) else
87525: LD_VAR 0 4
87529: PUSH
87530: LD_VAR 0 7
87534: ARRAY
87535: PPUSH
87536: LD_VAR 0 23
87540: PPUSH
87541: CALL_OW 113
87545: GO 87753
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87547: LD_VAR 0 4
87551: PUSH
87552: LD_VAR 0 7
87556: ARRAY
87557: PPUSH
87558: CALL 86165 0 1
87562: PPUSH
87563: CALL_OW 256
87567: PUSH
87568: LD_INT 1000
87570: EQUAL
87571: IFFALSE 87590
// ComStop ( group [ i ] ) else
87573: LD_VAR 0 4
87577: PUSH
87578: LD_VAR 0 7
87582: ARRAY
87583: PPUSH
87584: CALL_OW 141
87588: GO 87753
// if not HasTask ( group [ i ] ) and to_heal then
87590: LD_VAR 0 4
87594: PUSH
87595: LD_VAR 0 7
87599: ARRAY
87600: PPUSH
87601: CALL_OW 314
87605: NOT
87606: PUSH
87607: LD_VAR 0 30
87611: AND
87612: IFFALSE 87753
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87614: LD_ADDR_VAR 0 13
87618: PUSH
87619: LD_VAR 0 30
87623: PPUSH
87624: LD_INT 3
87626: PUSH
87627: LD_INT 54
87629: PUSH
87630: EMPTY
87631: LIST
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PPUSH
87637: CALL_OW 72
87641: PPUSH
87642: LD_VAR 0 4
87646: PUSH
87647: LD_VAR 0 7
87651: ARRAY
87652: PPUSH
87653: CALL_OW 74
87657: ST_TO_ADDR
// if z then
87658: LD_VAR 0 13
87662: IFFALSE 87753
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87664: LD_INT 91
87666: PUSH
87667: LD_VAR 0 13
87671: PUSH
87672: LD_INT 10
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 81
87682: PUSH
87683: LD_VAR 0 13
87687: PPUSH
87688: CALL_OW 255
87692: PUSH
87693: EMPTY
87694: LIST
87695: LIST
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PPUSH
87701: CALL_OW 69
87705: PUSH
87706: LD_INT 0
87708: EQUAL
87709: IFFALSE 87733
// ComHeal ( group [ i ] , z ) else
87711: LD_VAR 0 4
87715: PUSH
87716: LD_VAR 0 7
87720: ARRAY
87721: PPUSH
87722: LD_VAR 0 13
87726: PPUSH
87727: CALL_OW 128
87731: GO 87753
// ComMoveToArea ( group [ i ] , f_heal ) ;
87733: LD_VAR 0 4
87737: PUSH
87738: LD_VAR 0 7
87742: ARRAY
87743: PPUSH
87744: LD_VAR 0 23
87748: PPUSH
87749: CALL_OW 113
// end ; continue ;
87753: GO 86784
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87755: LD_VAR 0 4
87759: PUSH
87760: LD_VAR 0 7
87764: ARRAY
87765: PPUSH
87766: CALL_OW 256
87770: PUSH
87771: LD_INT 700
87773: LESS
87774: PUSH
87775: LD_VAR 0 4
87779: PUSH
87780: LD_VAR 0 7
87784: ARRAY
87785: PUSH
87786: LD_VAR 0 30
87790: IN
87791: NOT
87792: AND
87793: IFFALSE 87817
// to_heal := to_heal union group [ i ] ;
87795: LD_ADDR_VAR 0 30
87799: PUSH
87800: LD_VAR 0 30
87804: PUSH
87805: LD_VAR 0 4
87809: PUSH
87810: LD_VAR 0 7
87814: ARRAY
87815: UNION
87816: ST_TO_ADDR
// if group [ i ] in to_heal then
87817: LD_VAR 0 4
87821: PUSH
87822: LD_VAR 0 7
87826: ARRAY
87827: PUSH
87828: LD_VAR 0 30
87832: IN
87833: IFFALSE 87942
// begin if GetLives ( group [ i ] ) = 1000 then
87835: LD_VAR 0 4
87839: PUSH
87840: LD_VAR 0 7
87844: ARRAY
87845: PPUSH
87846: CALL_OW 256
87850: PUSH
87851: LD_INT 1000
87853: EQUAL
87854: IFFALSE 87880
// to_heal := to_heal diff group [ i ] else
87856: LD_ADDR_VAR 0 30
87860: PUSH
87861: LD_VAR 0 30
87865: PUSH
87866: LD_VAR 0 4
87870: PUSH
87871: LD_VAR 0 7
87875: ARRAY
87876: DIFF
87877: ST_TO_ADDR
87878: GO 87942
// begin if not IsInArea ( group [ i ] , to_heal ) then
87880: LD_VAR 0 4
87884: PUSH
87885: LD_VAR 0 7
87889: ARRAY
87890: PPUSH
87891: LD_VAR 0 30
87895: PPUSH
87896: CALL_OW 308
87900: NOT
87901: IFFALSE 87925
// ComMoveToArea ( group [ i ] , f_heal ) else
87903: LD_VAR 0 4
87907: PUSH
87908: LD_VAR 0 7
87912: ARRAY
87913: PPUSH
87914: LD_VAR 0 23
87918: PPUSH
87919: CALL_OW 113
87923: GO 87940
// ComHold ( group [ i ] ) ;
87925: LD_VAR 0 4
87929: PUSH
87930: LD_VAR 0 7
87934: ARRAY
87935: PPUSH
87936: CALL_OW 140
// continue ;
87940: GO 86784
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87942: LD_VAR 0 4
87946: PUSH
87947: LD_VAR 0 7
87951: ARRAY
87952: PPUSH
87953: LD_INT 10
87955: PPUSH
87956: CALL 84585 0 2
87960: NOT
87961: PUSH
87962: LD_VAR 0 16
87966: PUSH
87967: LD_VAR 0 7
87971: ARRAY
87972: PUSH
87973: EMPTY
87974: EQUAL
87975: NOT
87976: AND
87977: IFFALSE 88243
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87979: LD_VAR 0 4
87983: PUSH
87984: LD_VAR 0 7
87988: ARRAY
87989: PPUSH
87990: CALL_OW 262
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: IN
88005: IFFALSE 88046
// if GetFuel ( group [ i ] ) < 10 then
88007: LD_VAR 0 4
88011: PUSH
88012: LD_VAR 0 7
88016: ARRAY
88017: PPUSH
88018: CALL_OW 261
88022: PUSH
88023: LD_INT 10
88025: LESS
88026: IFFALSE 88046
// SetFuel ( group [ i ] , 12 ) ;
88028: LD_VAR 0 4
88032: PUSH
88033: LD_VAR 0 7
88037: ARRAY
88038: PPUSH
88039: LD_INT 12
88041: PPUSH
88042: CALL_OW 240
// if units_path [ i ] then
88046: LD_VAR 0 16
88050: PUSH
88051: LD_VAR 0 7
88055: ARRAY
88056: IFFALSE 88241
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
88058: LD_VAR 0 4
88062: PUSH
88063: LD_VAR 0 7
88067: ARRAY
88068: PPUSH
88069: LD_VAR 0 16
88073: PUSH
88074: LD_VAR 0 7
88078: ARRAY
88079: PUSH
88080: LD_INT 1
88082: ARRAY
88083: PUSH
88084: LD_INT 1
88086: ARRAY
88087: PPUSH
88088: LD_VAR 0 16
88092: PUSH
88093: LD_VAR 0 7
88097: ARRAY
88098: PUSH
88099: LD_INT 1
88101: ARRAY
88102: PUSH
88103: LD_INT 2
88105: ARRAY
88106: PPUSH
88107: CALL_OW 297
88111: PUSH
88112: LD_INT 6
88114: GREATER
88115: IFFALSE 88190
// begin if not HasTask ( group [ i ] ) then
88117: LD_VAR 0 4
88121: PUSH
88122: LD_VAR 0 7
88126: ARRAY
88127: PPUSH
88128: CALL_OW 314
88132: NOT
88133: IFFALSE 88188
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
88135: LD_VAR 0 4
88139: PUSH
88140: LD_VAR 0 7
88144: ARRAY
88145: PPUSH
88146: LD_VAR 0 16
88150: PUSH
88151: LD_VAR 0 7
88155: ARRAY
88156: PUSH
88157: LD_INT 1
88159: ARRAY
88160: PUSH
88161: LD_INT 1
88163: ARRAY
88164: PPUSH
88165: LD_VAR 0 16
88169: PUSH
88170: LD_VAR 0 7
88174: ARRAY
88175: PUSH
88176: LD_INT 1
88178: ARRAY
88179: PUSH
88180: LD_INT 2
88182: ARRAY
88183: PPUSH
88184: CALL_OW 114
// end else
88188: GO 88241
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88190: LD_ADDR_VAR 0 15
88194: PUSH
88195: LD_VAR 0 16
88199: PUSH
88200: LD_VAR 0 7
88204: ARRAY
88205: PPUSH
88206: LD_INT 1
88208: PPUSH
88209: CALL_OW 3
88213: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88214: LD_ADDR_VAR 0 16
88218: PUSH
88219: LD_VAR 0 16
88223: PPUSH
88224: LD_VAR 0 7
88228: PPUSH
88229: LD_VAR 0 15
88233: PPUSH
88234: CALL_OW 1
88238: ST_TO_ADDR
// continue ;
88239: GO 86784
// end ; end ; end else
88241: GO 90905
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88243: LD_ADDR_VAR 0 14
88247: PUSH
88248: LD_INT 81
88250: PUSH
88251: LD_VAR 0 4
88255: PUSH
88256: LD_VAR 0 7
88260: ARRAY
88261: PPUSH
88262: CALL_OW 255
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PPUSH
88271: CALL_OW 69
88275: ST_TO_ADDR
// if not tmp then
88276: LD_VAR 0 14
88280: NOT
88281: IFFALSE 88285
// continue ;
88283: GO 86784
// if f_ignore_area then
88285: LD_VAR 0 17
88289: IFFALSE 88377
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88291: LD_ADDR_VAR 0 15
88295: PUSH
88296: LD_VAR 0 14
88300: PPUSH
88301: LD_INT 3
88303: PUSH
88304: LD_INT 92
88306: PUSH
88307: LD_VAR 0 17
88311: PUSH
88312: LD_INT 1
88314: ARRAY
88315: PUSH
88316: LD_VAR 0 17
88320: PUSH
88321: LD_INT 2
88323: ARRAY
88324: PUSH
88325: LD_VAR 0 17
88329: PUSH
88330: LD_INT 3
88332: ARRAY
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PPUSH
88344: CALL_OW 72
88348: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88349: LD_VAR 0 14
88353: PUSH
88354: LD_VAR 0 15
88358: DIFF
88359: IFFALSE 88377
// tmp := tmp diff tmp2 ;
88361: LD_ADDR_VAR 0 14
88365: PUSH
88366: LD_VAR 0 14
88370: PUSH
88371: LD_VAR 0 15
88375: DIFF
88376: ST_TO_ADDR
// end ; if not f_murder then
88377: LD_VAR 0 20
88381: NOT
88382: IFFALSE 88440
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88384: LD_ADDR_VAR 0 15
88388: PUSH
88389: LD_VAR 0 14
88393: PPUSH
88394: LD_INT 3
88396: PUSH
88397: LD_INT 50
88399: PUSH
88400: EMPTY
88401: LIST
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PPUSH
88407: CALL_OW 72
88411: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88412: LD_VAR 0 14
88416: PUSH
88417: LD_VAR 0 15
88421: DIFF
88422: IFFALSE 88440
// tmp := tmp diff tmp2 ;
88424: LD_ADDR_VAR 0 14
88428: PUSH
88429: LD_VAR 0 14
88433: PUSH
88434: LD_VAR 0 15
88438: DIFF
88439: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88440: LD_ADDR_VAR 0 14
88444: PUSH
88445: LD_VAR 0 4
88449: PUSH
88450: LD_VAR 0 7
88454: ARRAY
88455: PPUSH
88456: LD_VAR 0 14
88460: PPUSH
88461: LD_INT 1
88463: PPUSH
88464: LD_INT 1
88466: PPUSH
88467: CALL 58228 0 4
88471: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88472: LD_VAR 0 4
88476: PUSH
88477: LD_VAR 0 7
88481: ARRAY
88482: PPUSH
88483: CALL_OW 257
88487: PUSH
88488: LD_INT 1
88490: EQUAL
88491: IFFALSE 88939
// begin if WantPlant ( group [ i ] ) then
88493: LD_VAR 0 4
88497: PUSH
88498: LD_VAR 0 7
88502: ARRAY
88503: PPUSH
88504: CALL 57729 0 1
88508: IFFALSE 88512
// continue ;
88510: GO 86784
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88512: LD_VAR 0 18
88516: PUSH
88517: LD_VAR 0 4
88521: PUSH
88522: LD_VAR 0 7
88526: ARRAY
88527: PPUSH
88528: CALL_OW 310
88532: NOT
88533: AND
88534: PUSH
88535: LD_VAR 0 14
88539: PUSH
88540: LD_INT 1
88542: ARRAY
88543: PUSH
88544: LD_VAR 0 14
88548: PPUSH
88549: LD_INT 21
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 58
88561: PUSH
88562: EMPTY
88563: LIST
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PPUSH
88569: CALL_OW 72
88573: IN
88574: AND
88575: IFFALSE 88611
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88577: LD_VAR 0 4
88581: PUSH
88582: LD_VAR 0 7
88586: ARRAY
88587: PPUSH
88588: LD_VAR 0 14
88592: PUSH
88593: LD_INT 1
88595: ARRAY
88596: PPUSH
88597: CALL_OW 120
// attacking := true ;
88601: LD_ADDR_VAR 0 29
88605: PUSH
88606: LD_INT 1
88608: ST_TO_ADDR
// continue ;
88609: GO 86784
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88611: LD_VAR 0 26
88615: PUSH
88616: LD_VAR 0 4
88620: PUSH
88621: LD_VAR 0 7
88625: ARRAY
88626: PPUSH
88627: CALL_OW 257
88631: PUSH
88632: LD_INT 1
88634: EQUAL
88635: AND
88636: PUSH
88637: LD_VAR 0 4
88641: PUSH
88642: LD_VAR 0 7
88646: ARRAY
88647: PPUSH
88648: CALL_OW 256
88652: PUSH
88653: LD_INT 800
88655: LESS
88656: AND
88657: PUSH
88658: LD_VAR 0 4
88662: PUSH
88663: LD_VAR 0 7
88667: ARRAY
88668: PPUSH
88669: CALL_OW 318
88673: NOT
88674: AND
88675: IFFALSE 88692
// ComCrawl ( group [ i ] ) ;
88677: LD_VAR 0 4
88681: PUSH
88682: LD_VAR 0 7
88686: ARRAY
88687: PPUSH
88688: CALL_OW 137
// if f_mines then
88692: LD_VAR 0 21
88696: IFFALSE 88939
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88698: LD_VAR 0 14
88702: PUSH
88703: LD_INT 1
88705: ARRAY
88706: PPUSH
88707: CALL_OW 247
88711: PUSH
88712: LD_INT 3
88714: EQUAL
88715: PUSH
88716: LD_VAR 0 14
88720: PUSH
88721: LD_INT 1
88723: ARRAY
88724: PUSH
88725: LD_VAR 0 27
88729: IN
88730: NOT
88731: AND
88732: IFFALSE 88939
// begin x := GetX ( tmp [ 1 ] ) ;
88734: LD_ADDR_VAR 0 10
88738: PUSH
88739: LD_VAR 0 14
88743: PUSH
88744: LD_INT 1
88746: ARRAY
88747: PPUSH
88748: CALL_OW 250
88752: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88753: LD_ADDR_VAR 0 11
88757: PUSH
88758: LD_VAR 0 14
88762: PUSH
88763: LD_INT 1
88765: ARRAY
88766: PPUSH
88767: CALL_OW 251
88771: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88772: LD_ADDR_VAR 0 12
88776: PUSH
88777: LD_VAR 0 4
88781: PUSH
88782: LD_VAR 0 7
88786: ARRAY
88787: PPUSH
88788: CALL 84670 0 1
88792: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88793: LD_VAR 0 4
88797: PUSH
88798: LD_VAR 0 7
88802: ARRAY
88803: PPUSH
88804: LD_VAR 0 10
88808: PPUSH
88809: LD_VAR 0 11
88813: PPUSH
88814: LD_VAR 0 14
88818: PUSH
88819: LD_INT 1
88821: ARRAY
88822: PPUSH
88823: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88827: LD_VAR 0 4
88831: PUSH
88832: LD_VAR 0 7
88836: ARRAY
88837: PPUSH
88838: LD_VAR 0 10
88842: PPUSH
88843: LD_VAR 0 12
88847: PPUSH
88848: LD_INT 7
88850: PPUSH
88851: CALL_OW 272
88855: PPUSH
88856: LD_VAR 0 11
88860: PPUSH
88861: LD_VAR 0 12
88865: PPUSH
88866: LD_INT 7
88868: PPUSH
88869: CALL_OW 273
88873: PPUSH
88874: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88878: LD_VAR 0 4
88882: PUSH
88883: LD_VAR 0 7
88887: ARRAY
88888: PPUSH
88889: LD_INT 71
88891: PPUSH
88892: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88896: LD_ADDR_VAR 0 27
88900: PUSH
88901: LD_VAR 0 27
88905: PPUSH
88906: LD_VAR 0 27
88910: PUSH
88911: LD_INT 1
88913: PLUS
88914: PPUSH
88915: LD_VAR 0 14
88919: PUSH
88920: LD_INT 1
88922: ARRAY
88923: PPUSH
88924: CALL_OW 1
88928: ST_TO_ADDR
// attacking := true ;
88929: LD_ADDR_VAR 0 29
88933: PUSH
88934: LD_INT 1
88936: ST_TO_ADDR
// continue ;
88937: GO 86784
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88939: LD_VAR 0 4
88943: PUSH
88944: LD_VAR 0 7
88948: ARRAY
88949: PPUSH
88950: CALL_OW 257
88954: PUSH
88955: LD_INT 17
88957: EQUAL
88958: PUSH
88959: LD_VAR 0 4
88963: PUSH
88964: LD_VAR 0 7
88968: ARRAY
88969: PPUSH
88970: CALL_OW 110
88974: PUSH
88975: LD_INT 71
88977: EQUAL
88978: NOT
88979: AND
88980: IFFALSE 89126
// begin attacking := false ;
88982: LD_ADDR_VAR 0 29
88986: PUSH
88987: LD_INT 0
88989: ST_TO_ADDR
// k := 5 ;
88990: LD_ADDR_VAR 0 9
88994: PUSH
88995: LD_INT 5
88997: ST_TO_ADDR
// if tmp < k then
88998: LD_VAR 0 14
89002: PUSH
89003: LD_VAR 0 9
89007: LESS
89008: IFFALSE 89020
// k := tmp ;
89010: LD_ADDR_VAR 0 9
89014: PUSH
89015: LD_VAR 0 14
89019: ST_TO_ADDR
// for j = 1 to k do
89020: LD_ADDR_VAR 0 8
89024: PUSH
89025: DOUBLE
89026: LD_INT 1
89028: DEC
89029: ST_TO_ADDR
89030: LD_VAR 0 9
89034: PUSH
89035: FOR_TO
89036: IFFALSE 89124
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
89038: LD_VAR 0 14
89042: PUSH
89043: LD_VAR 0 8
89047: ARRAY
89048: PUSH
89049: LD_VAR 0 14
89053: PPUSH
89054: LD_INT 58
89056: PUSH
89057: EMPTY
89058: LIST
89059: PPUSH
89060: CALL_OW 72
89064: IN
89065: NOT
89066: IFFALSE 89122
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89068: LD_VAR 0 4
89072: PUSH
89073: LD_VAR 0 7
89077: ARRAY
89078: PPUSH
89079: LD_VAR 0 14
89083: PUSH
89084: LD_VAR 0 8
89088: ARRAY
89089: PPUSH
89090: CALL_OW 115
// attacking := true ;
89094: LD_ADDR_VAR 0 29
89098: PUSH
89099: LD_INT 1
89101: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
89102: LD_VAR 0 4
89106: PUSH
89107: LD_VAR 0 7
89111: ARRAY
89112: PPUSH
89113: LD_INT 71
89115: PPUSH
89116: CALL_OW 109
// continue ;
89120: GO 89035
// end ; end ;
89122: GO 89035
89124: POP
89125: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
89126: LD_VAR 0 4
89130: PUSH
89131: LD_VAR 0 7
89135: ARRAY
89136: PPUSH
89137: CALL_OW 257
89141: PUSH
89142: LD_INT 8
89144: EQUAL
89145: PUSH
89146: LD_VAR 0 4
89150: PUSH
89151: LD_VAR 0 7
89155: ARRAY
89156: PPUSH
89157: CALL_OW 264
89161: PUSH
89162: LD_INT 28
89164: PUSH
89165: LD_INT 45
89167: PUSH
89168: LD_INT 7
89170: PUSH
89171: LD_INT 47
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: IN
89180: OR
89181: IFFALSE 89437
// begin attacking := false ;
89183: LD_ADDR_VAR 0 29
89187: PUSH
89188: LD_INT 0
89190: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89191: LD_VAR 0 14
89195: PUSH
89196: LD_INT 1
89198: ARRAY
89199: PPUSH
89200: CALL_OW 266
89204: PUSH
89205: LD_INT 32
89207: PUSH
89208: LD_INT 31
89210: PUSH
89211: LD_INT 33
89213: PUSH
89214: LD_INT 4
89216: PUSH
89217: LD_INT 5
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: IN
89227: IFFALSE 89413
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89229: LD_ADDR_VAR 0 9
89233: PUSH
89234: LD_VAR 0 14
89238: PUSH
89239: LD_INT 1
89241: ARRAY
89242: PPUSH
89243: CALL_OW 266
89247: PPUSH
89248: LD_VAR 0 14
89252: PUSH
89253: LD_INT 1
89255: ARRAY
89256: PPUSH
89257: CALL_OW 250
89261: PPUSH
89262: LD_VAR 0 14
89266: PUSH
89267: LD_INT 1
89269: ARRAY
89270: PPUSH
89271: CALL_OW 251
89275: PPUSH
89276: LD_VAR 0 14
89280: PUSH
89281: LD_INT 1
89283: ARRAY
89284: PPUSH
89285: CALL_OW 254
89289: PPUSH
89290: LD_VAR 0 14
89294: PUSH
89295: LD_INT 1
89297: ARRAY
89298: PPUSH
89299: CALL_OW 248
89303: PPUSH
89304: LD_INT 0
89306: PPUSH
89307: CALL 66040 0 6
89311: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89312: LD_ADDR_VAR 0 8
89316: PUSH
89317: LD_VAR 0 4
89321: PUSH
89322: LD_VAR 0 7
89326: ARRAY
89327: PPUSH
89328: LD_VAR 0 9
89332: PPUSH
89333: CALL 84710 0 2
89337: ST_TO_ADDR
// if j then
89338: LD_VAR 0 8
89342: IFFALSE 89411
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89344: LD_VAR 0 8
89348: PUSH
89349: LD_INT 1
89351: ARRAY
89352: PPUSH
89353: LD_VAR 0 8
89357: PUSH
89358: LD_INT 2
89360: ARRAY
89361: PPUSH
89362: CALL_OW 488
89366: IFFALSE 89411
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89368: LD_VAR 0 4
89372: PUSH
89373: LD_VAR 0 7
89377: ARRAY
89378: PPUSH
89379: LD_VAR 0 8
89383: PUSH
89384: LD_INT 1
89386: ARRAY
89387: PPUSH
89388: LD_VAR 0 8
89392: PUSH
89393: LD_INT 2
89395: ARRAY
89396: PPUSH
89397: CALL_OW 116
// attacking := true ;
89401: LD_ADDR_VAR 0 29
89405: PUSH
89406: LD_INT 1
89408: ST_TO_ADDR
// continue ;
89409: GO 86784
// end ; end else
89411: GO 89437
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89413: LD_VAR 0 4
89417: PUSH
89418: LD_VAR 0 7
89422: ARRAY
89423: PPUSH
89424: LD_VAR 0 14
89428: PUSH
89429: LD_INT 1
89431: ARRAY
89432: PPUSH
89433: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89437: LD_VAR 0 4
89441: PUSH
89442: LD_VAR 0 7
89446: ARRAY
89447: PPUSH
89448: CALL_OW 265
89452: PUSH
89453: LD_INT 11
89455: EQUAL
89456: IFFALSE 89734
// begin k := 10 ;
89458: LD_ADDR_VAR 0 9
89462: PUSH
89463: LD_INT 10
89465: ST_TO_ADDR
// x := 0 ;
89466: LD_ADDR_VAR 0 10
89470: PUSH
89471: LD_INT 0
89473: ST_TO_ADDR
// if tmp < k then
89474: LD_VAR 0 14
89478: PUSH
89479: LD_VAR 0 9
89483: LESS
89484: IFFALSE 89496
// k := tmp ;
89486: LD_ADDR_VAR 0 9
89490: PUSH
89491: LD_VAR 0 14
89495: ST_TO_ADDR
// for j = k downto 1 do
89496: LD_ADDR_VAR 0 8
89500: PUSH
89501: DOUBLE
89502: LD_VAR 0 9
89506: INC
89507: ST_TO_ADDR
89508: LD_INT 1
89510: PUSH
89511: FOR_DOWNTO
89512: IFFALSE 89587
// begin if GetType ( tmp [ j ] ) = unit_human then
89514: LD_VAR 0 14
89518: PUSH
89519: LD_VAR 0 8
89523: ARRAY
89524: PPUSH
89525: CALL_OW 247
89529: PUSH
89530: LD_INT 1
89532: EQUAL
89533: IFFALSE 89585
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89535: LD_VAR 0 4
89539: PUSH
89540: LD_VAR 0 7
89544: ARRAY
89545: PPUSH
89546: LD_VAR 0 14
89550: PUSH
89551: LD_VAR 0 8
89555: ARRAY
89556: PPUSH
89557: CALL 84981 0 2
// x := tmp [ j ] ;
89561: LD_ADDR_VAR 0 10
89565: PUSH
89566: LD_VAR 0 14
89570: PUSH
89571: LD_VAR 0 8
89575: ARRAY
89576: ST_TO_ADDR
// attacking := true ;
89577: LD_ADDR_VAR 0 29
89581: PUSH
89582: LD_INT 1
89584: ST_TO_ADDR
// end ; end ;
89585: GO 89511
89587: POP
89588: POP
// if not x then
89589: LD_VAR 0 10
89593: NOT
89594: IFFALSE 89734
// begin attacking := true ;
89596: LD_ADDR_VAR 0 29
89600: PUSH
89601: LD_INT 1
89603: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89604: LD_VAR 0 4
89608: PUSH
89609: LD_VAR 0 7
89613: ARRAY
89614: PPUSH
89615: CALL_OW 250
89619: PPUSH
89620: LD_VAR 0 4
89624: PUSH
89625: LD_VAR 0 7
89629: ARRAY
89630: PPUSH
89631: CALL_OW 251
89635: PPUSH
89636: CALL_OW 546
89640: PUSH
89641: LD_INT 2
89643: ARRAY
89644: PUSH
89645: LD_VAR 0 14
89649: PUSH
89650: LD_INT 1
89652: ARRAY
89653: PPUSH
89654: CALL_OW 250
89658: PPUSH
89659: LD_VAR 0 14
89663: PUSH
89664: LD_INT 1
89666: ARRAY
89667: PPUSH
89668: CALL_OW 251
89672: PPUSH
89673: CALL_OW 546
89677: PUSH
89678: LD_INT 2
89680: ARRAY
89681: EQUAL
89682: IFFALSE 89710
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89684: LD_VAR 0 4
89688: PUSH
89689: LD_VAR 0 7
89693: ARRAY
89694: PPUSH
89695: LD_VAR 0 14
89699: PUSH
89700: LD_INT 1
89702: ARRAY
89703: PPUSH
89704: CALL 84981 0 2
89708: GO 89734
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89710: LD_VAR 0 4
89714: PUSH
89715: LD_VAR 0 7
89719: ARRAY
89720: PPUSH
89721: LD_VAR 0 14
89725: PUSH
89726: LD_INT 1
89728: ARRAY
89729: PPUSH
89730: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89734: LD_VAR 0 4
89738: PUSH
89739: LD_VAR 0 7
89743: ARRAY
89744: PPUSH
89745: CALL_OW 264
89749: PUSH
89750: LD_INT 29
89752: EQUAL
89753: IFFALSE 90119
// begin if WantsToAttack ( group [ i ] ) in bombed then
89755: LD_VAR 0 4
89759: PUSH
89760: LD_VAR 0 7
89764: ARRAY
89765: PPUSH
89766: CALL_OW 319
89770: PUSH
89771: LD_VAR 0 28
89775: IN
89776: IFFALSE 89780
// continue ;
89778: GO 86784
// k := 8 ;
89780: LD_ADDR_VAR 0 9
89784: PUSH
89785: LD_INT 8
89787: ST_TO_ADDR
// x := 0 ;
89788: LD_ADDR_VAR 0 10
89792: PUSH
89793: LD_INT 0
89795: ST_TO_ADDR
// if tmp < k then
89796: LD_VAR 0 14
89800: PUSH
89801: LD_VAR 0 9
89805: LESS
89806: IFFALSE 89818
// k := tmp ;
89808: LD_ADDR_VAR 0 9
89812: PUSH
89813: LD_VAR 0 14
89817: ST_TO_ADDR
// for j = 1 to k do
89818: LD_ADDR_VAR 0 8
89822: PUSH
89823: DOUBLE
89824: LD_INT 1
89826: DEC
89827: ST_TO_ADDR
89828: LD_VAR 0 9
89832: PUSH
89833: FOR_TO
89834: IFFALSE 89966
// begin if GetType ( tmp [ j ] ) = unit_building then
89836: LD_VAR 0 14
89840: PUSH
89841: LD_VAR 0 8
89845: ARRAY
89846: PPUSH
89847: CALL_OW 247
89851: PUSH
89852: LD_INT 3
89854: EQUAL
89855: IFFALSE 89964
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89857: LD_VAR 0 14
89861: PUSH
89862: LD_VAR 0 8
89866: ARRAY
89867: PUSH
89868: LD_VAR 0 28
89872: IN
89873: NOT
89874: PUSH
89875: LD_VAR 0 14
89879: PUSH
89880: LD_VAR 0 8
89884: ARRAY
89885: PPUSH
89886: CALL_OW 313
89890: AND
89891: IFFALSE 89964
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89893: LD_VAR 0 4
89897: PUSH
89898: LD_VAR 0 7
89902: ARRAY
89903: PPUSH
89904: LD_VAR 0 14
89908: PUSH
89909: LD_VAR 0 8
89913: ARRAY
89914: PPUSH
89915: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89919: LD_ADDR_VAR 0 28
89923: PUSH
89924: LD_VAR 0 28
89928: PPUSH
89929: LD_VAR 0 28
89933: PUSH
89934: LD_INT 1
89936: PLUS
89937: PPUSH
89938: LD_VAR 0 14
89942: PUSH
89943: LD_VAR 0 8
89947: ARRAY
89948: PPUSH
89949: CALL_OW 1
89953: ST_TO_ADDR
// attacking := true ;
89954: LD_ADDR_VAR 0 29
89958: PUSH
89959: LD_INT 1
89961: ST_TO_ADDR
// break ;
89962: GO 89966
// end ; end ;
89964: GO 89833
89966: POP
89967: POP
// if not attacking and f_attack_depot then
89968: LD_VAR 0 29
89972: NOT
89973: PUSH
89974: LD_VAR 0 25
89978: AND
89979: IFFALSE 90074
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89981: LD_ADDR_VAR 0 13
89985: PUSH
89986: LD_VAR 0 14
89990: PPUSH
89991: LD_INT 2
89993: PUSH
89994: LD_INT 30
89996: PUSH
89997: LD_INT 0
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 30
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: LIST
90018: PPUSH
90019: CALL_OW 72
90023: ST_TO_ADDR
// if z then
90024: LD_VAR 0 13
90028: IFFALSE 90074
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
90030: LD_VAR 0 4
90034: PUSH
90035: LD_VAR 0 7
90039: ARRAY
90040: PPUSH
90041: LD_VAR 0 13
90045: PPUSH
90046: LD_VAR 0 4
90050: PUSH
90051: LD_VAR 0 7
90055: ARRAY
90056: PPUSH
90057: CALL_OW 74
90061: PPUSH
90062: CALL_OW 115
// attacking := true ;
90066: LD_ADDR_VAR 0 29
90070: PUSH
90071: LD_INT 1
90073: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
90074: LD_VAR 0 4
90078: PUSH
90079: LD_VAR 0 7
90083: ARRAY
90084: PPUSH
90085: CALL_OW 256
90089: PUSH
90090: LD_INT 500
90092: LESS
90093: IFFALSE 90119
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90095: LD_VAR 0 4
90099: PUSH
90100: LD_VAR 0 7
90104: ARRAY
90105: PPUSH
90106: LD_VAR 0 14
90110: PUSH
90111: LD_INT 1
90113: ARRAY
90114: PPUSH
90115: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
90119: LD_VAR 0 4
90123: PUSH
90124: LD_VAR 0 7
90128: ARRAY
90129: PPUSH
90130: CALL_OW 264
90134: PUSH
90135: LD_INT 49
90137: EQUAL
90138: IFFALSE 90259
// begin if not HasTask ( group [ i ] ) then
90140: LD_VAR 0 4
90144: PUSH
90145: LD_VAR 0 7
90149: ARRAY
90150: PPUSH
90151: CALL_OW 314
90155: NOT
90156: IFFALSE 90259
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
90158: LD_ADDR_VAR 0 9
90162: PUSH
90163: LD_INT 81
90165: PUSH
90166: LD_VAR 0 4
90170: PUSH
90171: LD_VAR 0 7
90175: ARRAY
90176: PPUSH
90177: CALL_OW 255
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PPUSH
90186: CALL_OW 69
90190: PPUSH
90191: LD_VAR 0 4
90195: PUSH
90196: LD_VAR 0 7
90200: ARRAY
90201: PPUSH
90202: CALL_OW 74
90206: ST_TO_ADDR
// if k then
90207: LD_VAR 0 9
90211: IFFALSE 90259
// if GetDistUnits ( group [ i ] , k ) > 10 then
90213: LD_VAR 0 4
90217: PUSH
90218: LD_VAR 0 7
90222: ARRAY
90223: PPUSH
90224: LD_VAR 0 9
90228: PPUSH
90229: CALL_OW 296
90233: PUSH
90234: LD_INT 10
90236: GREATER
90237: IFFALSE 90259
// ComMoveUnit ( group [ i ] , k ) ;
90239: LD_VAR 0 4
90243: PUSH
90244: LD_VAR 0 7
90248: ARRAY
90249: PPUSH
90250: LD_VAR 0 9
90254: PPUSH
90255: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90259: LD_VAR 0 4
90263: PUSH
90264: LD_VAR 0 7
90268: ARRAY
90269: PPUSH
90270: CALL_OW 256
90274: PUSH
90275: LD_INT 250
90277: LESS
90278: PUSH
90279: LD_VAR 0 4
90283: PUSH
90284: LD_VAR 0 7
90288: ARRAY
90289: PUSH
90290: LD_INT 21
90292: PUSH
90293: LD_INT 2
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 23
90302: PUSH
90303: LD_INT 2
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PPUSH
90314: CALL_OW 69
90318: IN
90319: AND
90320: IFFALSE 90445
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90322: LD_ADDR_VAR 0 9
90326: PUSH
90327: LD_OWVAR 3
90331: PUSH
90332: LD_VAR 0 4
90336: PUSH
90337: LD_VAR 0 7
90341: ARRAY
90342: DIFF
90343: PPUSH
90344: LD_VAR 0 4
90348: PUSH
90349: LD_VAR 0 7
90353: ARRAY
90354: PPUSH
90355: CALL_OW 74
90359: ST_TO_ADDR
// if not k then
90360: LD_VAR 0 9
90364: NOT
90365: IFFALSE 90369
// continue ;
90367: GO 86784
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90369: LD_VAR 0 9
90373: PUSH
90374: LD_INT 81
90376: PUSH
90377: LD_VAR 0 4
90381: PUSH
90382: LD_VAR 0 7
90386: ARRAY
90387: PPUSH
90388: CALL_OW 255
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PPUSH
90397: CALL_OW 69
90401: IN
90402: PUSH
90403: LD_VAR 0 9
90407: PPUSH
90408: LD_VAR 0 4
90412: PUSH
90413: LD_VAR 0 7
90417: ARRAY
90418: PPUSH
90419: CALL_OW 296
90423: PUSH
90424: LD_INT 5
90426: LESS
90427: AND
90428: IFFALSE 90445
// ComAutodestruct ( group [ i ] ) ;
90430: LD_VAR 0 4
90434: PUSH
90435: LD_VAR 0 7
90439: ARRAY
90440: PPUSH
90441: CALL 84879 0 1
// end ; if f_attack_depot then
90445: LD_VAR 0 25
90449: IFFALSE 90561
// begin k := 6 ;
90451: LD_ADDR_VAR 0 9
90455: PUSH
90456: LD_INT 6
90458: ST_TO_ADDR
// if tmp < k then
90459: LD_VAR 0 14
90463: PUSH
90464: LD_VAR 0 9
90468: LESS
90469: IFFALSE 90481
// k := tmp ;
90471: LD_ADDR_VAR 0 9
90475: PUSH
90476: LD_VAR 0 14
90480: ST_TO_ADDR
// for j = 1 to k do
90481: LD_ADDR_VAR 0 8
90485: PUSH
90486: DOUBLE
90487: LD_INT 1
90489: DEC
90490: ST_TO_ADDR
90491: LD_VAR 0 9
90495: PUSH
90496: FOR_TO
90497: IFFALSE 90559
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90499: LD_VAR 0 8
90503: PPUSH
90504: CALL_OW 266
90508: PUSH
90509: LD_INT 0
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: IN
90519: IFFALSE 90557
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90521: LD_VAR 0 4
90525: PUSH
90526: LD_VAR 0 7
90530: ARRAY
90531: PPUSH
90532: LD_VAR 0 14
90536: PUSH
90537: LD_VAR 0 8
90541: ARRAY
90542: PPUSH
90543: CALL_OW 115
// attacking := true ;
90547: LD_ADDR_VAR 0 29
90551: PUSH
90552: LD_INT 1
90554: ST_TO_ADDR
// break ;
90555: GO 90559
// end ;
90557: GO 90496
90559: POP
90560: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90561: LD_VAR 0 4
90565: PUSH
90566: LD_VAR 0 7
90570: ARRAY
90571: PPUSH
90572: CALL_OW 302
90576: PUSH
90577: LD_VAR 0 29
90581: NOT
90582: AND
90583: IFFALSE 90905
// begin if GetTag ( group [ i ] ) = 71 then
90585: LD_VAR 0 4
90589: PUSH
90590: LD_VAR 0 7
90594: ARRAY
90595: PPUSH
90596: CALL_OW 110
90600: PUSH
90601: LD_INT 71
90603: EQUAL
90604: IFFALSE 90645
// begin if HasTask ( group [ i ] ) then
90606: LD_VAR 0 4
90610: PUSH
90611: LD_VAR 0 7
90615: ARRAY
90616: PPUSH
90617: CALL_OW 314
90621: IFFALSE 90627
// continue else
90623: GO 86784
90625: GO 90645
// SetTag ( group [ i ] , 0 ) ;
90627: LD_VAR 0 4
90631: PUSH
90632: LD_VAR 0 7
90636: ARRAY
90637: PPUSH
90638: LD_INT 0
90640: PPUSH
90641: CALL_OW 109
// end ; k := 8 ;
90645: LD_ADDR_VAR 0 9
90649: PUSH
90650: LD_INT 8
90652: ST_TO_ADDR
// x := 0 ;
90653: LD_ADDR_VAR 0 10
90657: PUSH
90658: LD_INT 0
90660: ST_TO_ADDR
// if tmp < k then
90661: LD_VAR 0 14
90665: PUSH
90666: LD_VAR 0 9
90670: LESS
90671: IFFALSE 90683
// k := tmp ;
90673: LD_ADDR_VAR 0 9
90677: PUSH
90678: LD_VAR 0 14
90682: ST_TO_ADDR
// for j = 1 to k do
90683: LD_ADDR_VAR 0 8
90687: PUSH
90688: DOUBLE
90689: LD_INT 1
90691: DEC
90692: ST_TO_ADDR
90693: LD_VAR 0 9
90697: PUSH
90698: FOR_TO
90699: IFFALSE 90797
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90701: LD_VAR 0 14
90705: PUSH
90706: LD_VAR 0 8
90710: ARRAY
90711: PPUSH
90712: CALL_OW 247
90716: PUSH
90717: LD_INT 1
90719: EQUAL
90720: PUSH
90721: LD_VAR 0 14
90725: PUSH
90726: LD_VAR 0 8
90730: ARRAY
90731: PPUSH
90732: CALL_OW 256
90736: PUSH
90737: LD_INT 250
90739: LESS
90740: PUSH
90741: LD_VAR 0 20
90745: AND
90746: PUSH
90747: LD_VAR 0 20
90751: NOT
90752: PUSH
90753: LD_VAR 0 14
90757: PUSH
90758: LD_VAR 0 8
90762: ARRAY
90763: PPUSH
90764: CALL_OW 256
90768: PUSH
90769: LD_INT 250
90771: GREATEREQUAL
90772: AND
90773: OR
90774: AND
90775: IFFALSE 90795
// begin x := tmp [ j ] ;
90777: LD_ADDR_VAR 0 10
90781: PUSH
90782: LD_VAR 0 14
90786: PUSH
90787: LD_VAR 0 8
90791: ARRAY
90792: ST_TO_ADDR
// break ;
90793: GO 90797
// end ;
90795: GO 90698
90797: POP
90798: POP
// if x then
90799: LD_VAR 0 10
90803: IFFALSE 90827
// ComAttackUnit ( group [ i ] , x ) else
90805: LD_VAR 0 4
90809: PUSH
90810: LD_VAR 0 7
90814: ARRAY
90815: PPUSH
90816: LD_VAR 0 10
90820: PPUSH
90821: CALL_OW 115
90825: GO 90851
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90827: LD_VAR 0 4
90831: PUSH
90832: LD_VAR 0 7
90836: ARRAY
90837: PPUSH
90838: LD_VAR 0 14
90842: PUSH
90843: LD_INT 1
90845: ARRAY
90846: PPUSH
90847: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90851: LD_VAR 0 4
90855: PUSH
90856: LD_VAR 0 7
90860: ARRAY
90861: PPUSH
90862: CALL_OW 314
90866: NOT
90867: IFFALSE 90905
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90869: LD_VAR 0 4
90873: PUSH
90874: LD_VAR 0 7
90878: ARRAY
90879: PPUSH
90880: LD_VAR 0 14
90884: PPUSH
90885: LD_VAR 0 4
90889: PUSH
90890: LD_VAR 0 7
90894: ARRAY
90895: PPUSH
90896: CALL_OW 74
90900: PPUSH
90901: CALL_OW 115
// end ; end ; end ;
90905: GO 86784
90907: POP
90908: POP
// wait ( 0 0$2 ) ;
90909: LD_INT 70
90911: PPUSH
90912: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90916: LD_VAR 0 4
90920: NOT
90921: PUSH
90922: LD_VAR 0 4
90926: PUSH
90927: EMPTY
90928: EQUAL
90929: OR
90930: PUSH
90931: LD_INT 81
90933: PUSH
90934: LD_VAR 0 35
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PPUSH
90943: CALL_OW 69
90947: NOT
90948: OR
90949: IFFALSE 86769
// end ;
90951: LD_VAR 0 2
90955: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90956: LD_INT 0
90958: PPUSH
90959: PPUSH
90960: PPUSH
90961: PPUSH
// if not base_units then
90962: LD_VAR 0 1
90966: NOT
90967: IFFALSE 90971
// exit ;
90969: GO 91058
// result := false ;
90971: LD_ADDR_VAR 0 2
90975: PUSH
90976: LD_INT 0
90978: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90979: LD_ADDR_VAR 0 5
90983: PUSH
90984: LD_VAR 0 1
90988: PPUSH
90989: LD_INT 21
90991: PUSH
90992: LD_INT 3
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PPUSH
90999: CALL_OW 72
91003: ST_TO_ADDR
// if not tmp then
91004: LD_VAR 0 5
91008: NOT
91009: IFFALSE 91013
// exit ;
91011: GO 91058
// for i in tmp do
91013: LD_ADDR_VAR 0 3
91017: PUSH
91018: LD_VAR 0 5
91022: PUSH
91023: FOR_IN
91024: IFFALSE 91056
// begin result := EnemyInRange ( i , 22 ) ;
91026: LD_ADDR_VAR 0 2
91030: PUSH
91031: LD_VAR 0 3
91035: PPUSH
91036: LD_INT 22
91038: PPUSH
91039: CALL 84585 0 2
91043: ST_TO_ADDR
// if result then
91044: LD_VAR 0 2
91048: IFFALSE 91054
// exit ;
91050: POP
91051: POP
91052: GO 91058
// end ;
91054: GO 91023
91056: POP
91057: POP
// end ;
91058: LD_VAR 0 2
91062: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91063: LD_INT 0
91065: PPUSH
91066: PPUSH
// if not units then
91067: LD_VAR 0 1
91071: NOT
91072: IFFALSE 91076
// exit ;
91074: GO 91146
// result := [ ] ;
91076: LD_ADDR_VAR 0 3
91080: PUSH
91081: EMPTY
91082: ST_TO_ADDR
// for i in units do
91083: LD_ADDR_VAR 0 4
91087: PUSH
91088: LD_VAR 0 1
91092: PUSH
91093: FOR_IN
91094: IFFALSE 91144
// if GetTag ( i ) = tag then
91096: LD_VAR 0 4
91100: PPUSH
91101: CALL_OW 110
91105: PUSH
91106: LD_VAR 0 2
91110: EQUAL
91111: IFFALSE 91142
// result := Insert ( result , result + 1 , i ) ;
91113: LD_ADDR_VAR 0 3
91117: PUSH
91118: LD_VAR 0 3
91122: PPUSH
91123: LD_VAR 0 3
91127: PUSH
91128: LD_INT 1
91130: PLUS
91131: PPUSH
91132: LD_VAR 0 4
91136: PPUSH
91137: CALL_OW 2
91141: ST_TO_ADDR
91142: GO 91093
91144: POP
91145: POP
// end ;
91146: LD_VAR 0 3
91150: RET
// export function IsDriver ( un ) ; begin
91151: LD_INT 0
91153: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91154: LD_ADDR_VAR 0 2
91158: PUSH
91159: LD_VAR 0 1
91163: PUSH
91164: LD_INT 55
91166: PUSH
91167: EMPTY
91168: LIST
91169: PPUSH
91170: CALL_OW 69
91174: IN
91175: ST_TO_ADDR
// end ;
91176: LD_VAR 0 2
91180: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91181: LD_INT 0
91183: PPUSH
91184: PPUSH
// list := [ ] ;
91185: LD_ADDR_VAR 0 5
91189: PUSH
91190: EMPTY
91191: ST_TO_ADDR
// case d of 0 :
91192: LD_VAR 0 3
91196: PUSH
91197: LD_INT 0
91199: DOUBLE
91200: EQUAL
91201: IFTRUE 91205
91203: GO 91338
91205: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91206: LD_ADDR_VAR 0 5
91210: PUSH
91211: LD_VAR 0 1
91215: PUSH
91216: LD_INT 4
91218: MINUS
91219: PUSH
91220: LD_VAR 0 2
91224: PUSH
91225: LD_INT 4
91227: MINUS
91228: PUSH
91229: LD_INT 2
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: LIST
91236: PUSH
91237: LD_VAR 0 1
91241: PUSH
91242: LD_INT 3
91244: MINUS
91245: PUSH
91246: LD_VAR 0 2
91250: PUSH
91251: LD_INT 1
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: LIST
91258: PUSH
91259: LD_VAR 0 1
91263: PUSH
91264: LD_INT 4
91266: PLUS
91267: PUSH
91268: LD_VAR 0 2
91272: PUSH
91273: LD_INT 4
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: LIST
91280: PUSH
91281: LD_VAR 0 1
91285: PUSH
91286: LD_INT 3
91288: PLUS
91289: PUSH
91290: LD_VAR 0 2
91294: PUSH
91295: LD_INT 3
91297: PLUS
91298: PUSH
91299: LD_INT 5
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: LIST
91306: PUSH
91307: LD_VAR 0 1
91311: PUSH
91312: LD_VAR 0 2
91316: PUSH
91317: LD_INT 4
91319: PLUS
91320: PUSH
91321: LD_INT 0
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: ST_TO_ADDR
// end ; 1 :
91336: GO 92036
91338: LD_INT 1
91340: DOUBLE
91341: EQUAL
91342: IFTRUE 91346
91344: GO 91479
91346: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91347: LD_ADDR_VAR 0 5
91351: PUSH
91352: LD_VAR 0 1
91356: PUSH
91357: LD_VAR 0 2
91361: PUSH
91362: LD_INT 4
91364: MINUS
91365: PUSH
91366: LD_INT 3
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: LIST
91373: PUSH
91374: LD_VAR 0 1
91378: PUSH
91379: LD_INT 3
91381: MINUS
91382: PUSH
91383: LD_VAR 0 2
91387: PUSH
91388: LD_INT 3
91390: MINUS
91391: PUSH
91392: LD_INT 2
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: LIST
91399: PUSH
91400: LD_VAR 0 1
91404: PUSH
91405: LD_INT 4
91407: MINUS
91408: PUSH
91409: LD_VAR 0 2
91413: PUSH
91414: LD_INT 1
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: LIST
91421: PUSH
91422: LD_VAR 0 1
91426: PUSH
91427: LD_VAR 0 2
91431: PUSH
91432: LD_INT 3
91434: PLUS
91435: PUSH
91436: LD_INT 0
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: LIST
91443: PUSH
91444: LD_VAR 0 1
91448: PUSH
91449: LD_INT 4
91451: PLUS
91452: PUSH
91453: LD_VAR 0 2
91457: PUSH
91458: LD_INT 4
91460: PLUS
91461: PUSH
91462: LD_INT 5
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: LIST
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: ST_TO_ADDR
// end ; 2 :
91477: GO 92036
91479: LD_INT 2
91481: DOUBLE
91482: EQUAL
91483: IFTRUE 91487
91485: GO 91616
91487: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91488: LD_ADDR_VAR 0 5
91492: PUSH
91493: LD_VAR 0 1
91497: PUSH
91498: LD_VAR 0 2
91502: PUSH
91503: LD_INT 3
91505: MINUS
91506: PUSH
91507: LD_INT 3
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: LIST
91514: PUSH
91515: LD_VAR 0 1
91519: PUSH
91520: LD_INT 4
91522: PLUS
91523: PUSH
91524: LD_VAR 0 2
91528: PUSH
91529: LD_INT 4
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: LIST
91536: PUSH
91537: LD_VAR 0 1
91541: PUSH
91542: LD_VAR 0 2
91546: PUSH
91547: LD_INT 4
91549: PLUS
91550: PUSH
91551: LD_INT 0
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: LIST
91558: PUSH
91559: LD_VAR 0 1
91563: PUSH
91564: LD_INT 3
91566: MINUS
91567: PUSH
91568: LD_VAR 0 2
91572: PUSH
91573: LD_INT 1
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: LIST
91580: PUSH
91581: LD_VAR 0 1
91585: PUSH
91586: LD_INT 4
91588: MINUS
91589: PUSH
91590: LD_VAR 0 2
91594: PUSH
91595: LD_INT 4
91597: MINUS
91598: PUSH
91599: LD_INT 2
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: LIST
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// end ; 3 :
91614: GO 92036
91616: LD_INT 3
91618: DOUBLE
91619: EQUAL
91620: IFTRUE 91624
91622: GO 91757
91624: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91625: LD_ADDR_VAR 0 5
91629: PUSH
91630: LD_VAR 0 1
91634: PUSH
91635: LD_INT 3
91637: PLUS
91638: PUSH
91639: LD_VAR 0 2
91643: PUSH
91644: LD_INT 4
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: LIST
91651: PUSH
91652: LD_VAR 0 1
91656: PUSH
91657: LD_INT 4
91659: PLUS
91660: PUSH
91661: LD_VAR 0 2
91665: PUSH
91666: LD_INT 4
91668: PLUS
91669: PUSH
91670: LD_INT 5
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: LIST
91677: PUSH
91678: LD_VAR 0 1
91682: PUSH
91683: LD_INT 4
91685: MINUS
91686: PUSH
91687: LD_VAR 0 2
91691: PUSH
91692: LD_INT 1
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: LIST
91699: PUSH
91700: LD_VAR 0 1
91704: PUSH
91705: LD_VAR 0 2
91709: PUSH
91710: LD_INT 4
91712: MINUS
91713: PUSH
91714: LD_INT 3
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: LIST
91721: PUSH
91722: LD_VAR 0 1
91726: PUSH
91727: LD_INT 3
91729: MINUS
91730: PUSH
91731: LD_VAR 0 2
91735: PUSH
91736: LD_INT 3
91738: MINUS
91739: PUSH
91740: LD_INT 2
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: LIST
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: ST_TO_ADDR
// end ; 4 :
91755: GO 92036
91757: LD_INT 4
91759: DOUBLE
91760: EQUAL
91761: IFTRUE 91765
91763: GO 91898
91765: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91766: LD_ADDR_VAR 0 5
91770: PUSH
91771: LD_VAR 0 1
91775: PUSH
91776: LD_VAR 0 2
91780: PUSH
91781: LD_INT 4
91783: PLUS
91784: PUSH
91785: LD_INT 0
91787: PUSH
91788: EMPTY
91789: LIST
91790: LIST
91791: LIST
91792: PUSH
91793: LD_VAR 0 1
91797: PUSH
91798: LD_INT 3
91800: PLUS
91801: PUSH
91802: LD_VAR 0 2
91806: PUSH
91807: LD_INT 3
91809: PLUS
91810: PUSH
91811: LD_INT 5
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: LIST
91818: PUSH
91819: LD_VAR 0 1
91823: PUSH
91824: LD_INT 4
91826: PLUS
91827: PUSH
91828: LD_VAR 0 2
91832: PUSH
91833: LD_INT 4
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: LIST
91840: PUSH
91841: LD_VAR 0 1
91845: PUSH
91846: LD_VAR 0 2
91850: PUSH
91851: LD_INT 3
91853: MINUS
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: LIST
91862: PUSH
91863: LD_VAR 0 1
91867: PUSH
91868: LD_INT 4
91870: MINUS
91871: PUSH
91872: LD_VAR 0 2
91876: PUSH
91877: LD_INT 4
91879: MINUS
91880: PUSH
91881: LD_INT 2
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: LIST
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: ST_TO_ADDR
// end ; 5 :
91896: GO 92036
91898: LD_INT 5
91900: DOUBLE
91901: EQUAL
91902: IFTRUE 91906
91904: GO 92035
91906: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91907: LD_ADDR_VAR 0 5
91911: PUSH
91912: LD_VAR 0 1
91916: PUSH
91917: LD_INT 4
91919: MINUS
91920: PUSH
91921: LD_VAR 0 2
91925: PUSH
91926: LD_INT 1
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: LIST
91933: PUSH
91934: LD_VAR 0 1
91938: PUSH
91939: LD_VAR 0 2
91943: PUSH
91944: LD_INT 4
91946: MINUS
91947: PUSH
91948: LD_INT 3
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: LIST
91955: PUSH
91956: LD_VAR 0 1
91960: PUSH
91961: LD_INT 4
91963: PLUS
91964: PUSH
91965: LD_VAR 0 2
91969: PUSH
91970: LD_INT 4
91972: PLUS
91973: PUSH
91974: LD_INT 5
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: LIST
91981: PUSH
91982: LD_VAR 0 1
91986: PUSH
91987: LD_INT 3
91989: PLUS
91990: PUSH
91991: LD_VAR 0 2
91995: PUSH
91996: LD_INT 4
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: LIST
92003: PUSH
92004: LD_VAR 0 1
92008: PUSH
92009: LD_VAR 0 2
92013: PUSH
92014: LD_INT 3
92016: PLUS
92017: PUSH
92018: LD_INT 0
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: LIST
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: ST_TO_ADDR
// end ; end ;
92033: GO 92036
92035: POP
// result := list ;
92036: LD_ADDR_VAR 0 4
92040: PUSH
92041: LD_VAR 0 5
92045: ST_TO_ADDR
// end ;
92046: LD_VAR 0 4
92050: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
92051: LD_INT 0
92053: PPUSH
92054: PPUSH
92055: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
92056: LD_VAR 0 1
92060: NOT
92061: PUSH
92062: LD_VAR 0 2
92066: PUSH
92067: LD_INT 1
92069: PUSH
92070: LD_INT 2
92072: PUSH
92073: LD_INT 3
92075: PUSH
92076: LD_INT 4
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: IN
92085: NOT
92086: OR
92087: IFFALSE 92091
// exit ;
92089: GO 92183
// tmp := [ ] ;
92091: LD_ADDR_VAR 0 5
92095: PUSH
92096: EMPTY
92097: ST_TO_ADDR
// for i in units do
92098: LD_ADDR_VAR 0 4
92102: PUSH
92103: LD_VAR 0 1
92107: PUSH
92108: FOR_IN
92109: IFFALSE 92152
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92111: LD_ADDR_VAR 0 5
92115: PUSH
92116: LD_VAR 0 5
92120: PPUSH
92121: LD_VAR 0 5
92125: PUSH
92126: LD_INT 1
92128: PLUS
92129: PPUSH
92130: LD_VAR 0 4
92134: PPUSH
92135: LD_VAR 0 2
92139: PPUSH
92140: CALL_OW 259
92144: PPUSH
92145: CALL_OW 2
92149: ST_TO_ADDR
92150: GO 92108
92152: POP
92153: POP
// if not tmp then
92154: LD_VAR 0 5
92158: NOT
92159: IFFALSE 92163
// exit ;
92161: GO 92183
// result := SortListByListDesc ( units , tmp ) ;
92163: LD_ADDR_VAR 0 3
92167: PUSH
92168: LD_VAR 0 1
92172: PPUSH
92173: LD_VAR 0 5
92177: PPUSH
92178: CALL_OW 77
92182: ST_TO_ADDR
// end ;
92183: LD_VAR 0 3
92187: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92188: LD_INT 0
92190: PPUSH
92191: PPUSH
92192: PPUSH
// x := GetX ( building ) ;
92193: LD_ADDR_VAR 0 4
92197: PUSH
92198: LD_VAR 0 2
92202: PPUSH
92203: CALL_OW 250
92207: ST_TO_ADDR
// y := GetY ( building ) ;
92208: LD_ADDR_VAR 0 5
92212: PUSH
92213: LD_VAR 0 2
92217: PPUSH
92218: CALL_OW 251
92222: ST_TO_ADDR
// if GetTaskList ( unit ) then
92223: LD_VAR 0 1
92227: PPUSH
92228: CALL_OW 437
92232: IFFALSE 92327
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92234: LD_STRING e
92236: PUSH
92237: LD_VAR 0 1
92241: PPUSH
92242: CALL_OW 437
92246: PUSH
92247: LD_INT 1
92249: ARRAY
92250: PUSH
92251: LD_INT 1
92253: ARRAY
92254: EQUAL
92255: PUSH
92256: LD_VAR 0 4
92260: PUSH
92261: LD_VAR 0 1
92265: PPUSH
92266: CALL_OW 437
92270: PUSH
92271: LD_INT 1
92273: ARRAY
92274: PUSH
92275: LD_INT 2
92277: ARRAY
92278: EQUAL
92279: AND
92280: PUSH
92281: LD_VAR 0 5
92285: PUSH
92286: LD_VAR 0 1
92290: PPUSH
92291: CALL_OW 437
92295: PUSH
92296: LD_INT 1
92298: ARRAY
92299: PUSH
92300: LD_INT 3
92302: ARRAY
92303: EQUAL
92304: AND
92305: IFFALSE 92317
// result := true else
92307: LD_ADDR_VAR 0 3
92311: PUSH
92312: LD_INT 1
92314: ST_TO_ADDR
92315: GO 92325
// result := false ;
92317: LD_ADDR_VAR 0 3
92321: PUSH
92322: LD_INT 0
92324: ST_TO_ADDR
// end else
92325: GO 92335
// result := false ;
92327: LD_ADDR_VAR 0 3
92331: PUSH
92332: LD_INT 0
92334: ST_TO_ADDR
// end ;
92335: LD_VAR 0 3
92339: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92340: LD_INT 0
92342: PPUSH
92343: PPUSH
92344: PPUSH
92345: PPUSH
// if not unit or not area then
92346: LD_VAR 0 1
92350: NOT
92351: PUSH
92352: LD_VAR 0 2
92356: NOT
92357: OR
92358: IFFALSE 92362
// exit ;
92360: GO 92526
// tmp := AreaToList ( area , i ) ;
92362: LD_ADDR_VAR 0 6
92366: PUSH
92367: LD_VAR 0 2
92371: PPUSH
92372: LD_VAR 0 5
92376: PPUSH
92377: CALL_OW 517
92381: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92382: LD_ADDR_VAR 0 5
92386: PUSH
92387: DOUBLE
92388: LD_INT 1
92390: DEC
92391: ST_TO_ADDR
92392: LD_VAR 0 6
92396: PUSH
92397: LD_INT 1
92399: ARRAY
92400: PUSH
92401: FOR_TO
92402: IFFALSE 92524
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92404: LD_ADDR_VAR 0 7
92408: PUSH
92409: LD_VAR 0 6
92413: PUSH
92414: LD_INT 1
92416: ARRAY
92417: PUSH
92418: LD_VAR 0 5
92422: ARRAY
92423: PUSH
92424: LD_VAR 0 6
92428: PUSH
92429: LD_INT 2
92431: ARRAY
92432: PUSH
92433: LD_VAR 0 5
92437: ARRAY
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92443: LD_VAR 0 7
92447: PUSH
92448: LD_INT 1
92450: ARRAY
92451: PPUSH
92452: LD_VAR 0 7
92456: PUSH
92457: LD_INT 2
92459: ARRAY
92460: PPUSH
92461: CALL_OW 428
92465: PUSH
92466: LD_INT 0
92468: EQUAL
92469: IFFALSE 92522
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92471: LD_VAR 0 1
92475: PPUSH
92476: LD_VAR 0 7
92480: PUSH
92481: LD_INT 1
92483: ARRAY
92484: PPUSH
92485: LD_VAR 0 7
92489: PUSH
92490: LD_INT 2
92492: ARRAY
92493: PPUSH
92494: LD_VAR 0 3
92498: PPUSH
92499: CALL_OW 48
// result := IsPlaced ( unit ) ;
92503: LD_ADDR_VAR 0 4
92507: PUSH
92508: LD_VAR 0 1
92512: PPUSH
92513: CALL_OW 305
92517: ST_TO_ADDR
// exit ;
92518: POP
92519: POP
92520: GO 92526
// end ; end ;
92522: GO 92401
92524: POP
92525: POP
// end ;
92526: LD_VAR 0 4
92530: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92531: LD_INT 0
92533: PPUSH
92534: PPUSH
92535: PPUSH
// if not side or side > 8 then
92536: LD_VAR 0 1
92540: NOT
92541: PUSH
92542: LD_VAR 0 1
92546: PUSH
92547: LD_INT 8
92549: GREATER
92550: OR
92551: IFFALSE 92555
// exit ;
92553: GO 92742
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92555: LD_ADDR_VAR 0 4
92559: PUSH
92560: LD_INT 22
92562: PUSH
92563: LD_VAR 0 1
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: LD_INT 21
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PPUSH
92586: CALL_OW 69
92590: ST_TO_ADDR
// if not tmp then
92591: LD_VAR 0 4
92595: NOT
92596: IFFALSE 92600
// exit ;
92598: GO 92742
// enable_addtolog := true ;
92600: LD_ADDR_OWVAR 81
92604: PUSH
92605: LD_INT 1
92607: ST_TO_ADDR
// AddToLog ( [ ) ;
92608: LD_STRING [
92610: PPUSH
92611: CALL_OW 561
// for i in tmp do
92615: LD_ADDR_VAR 0 3
92619: PUSH
92620: LD_VAR 0 4
92624: PUSH
92625: FOR_IN
92626: IFFALSE 92733
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92628: LD_STRING [
92630: PUSH
92631: LD_VAR 0 3
92635: PPUSH
92636: CALL_OW 266
92640: STR
92641: PUSH
92642: LD_STRING , 
92644: STR
92645: PUSH
92646: LD_VAR 0 3
92650: PPUSH
92651: CALL_OW 250
92655: STR
92656: PUSH
92657: LD_STRING , 
92659: STR
92660: PUSH
92661: LD_VAR 0 3
92665: PPUSH
92666: CALL_OW 251
92670: STR
92671: PUSH
92672: LD_STRING , 
92674: STR
92675: PUSH
92676: LD_VAR 0 3
92680: PPUSH
92681: CALL_OW 254
92685: STR
92686: PUSH
92687: LD_STRING , 
92689: STR
92690: PUSH
92691: LD_VAR 0 3
92695: PPUSH
92696: LD_INT 1
92698: PPUSH
92699: CALL_OW 268
92703: STR
92704: PUSH
92705: LD_STRING , 
92707: STR
92708: PUSH
92709: LD_VAR 0 3
92713: PPUSH
92714: LD_INT 2
92716: PPUSH
92717: CALL_OW 268
92721: STR
92722: PUSH
92723: LD_STRING ],
92725: STR
92726: PPUSH
92727: CALL_OW 561
// end ;
92731: GO 92625
92733: POP
92734: POP
// AddToLog ( ]; ) ;
92735: LD_STRING ];
92737: PPUSH
92738: CALL_OW 561
// end ;
92742: LD_VAR 0 2
92746: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92747: LD_INT 0
92749: PPUSH
92750: PPUSH
92751: PPUSH
92752: PPUSH
92753: PPUSH
// if not area or not rate or not max then
92754: LD_VAR 0 1
92758: NOT
92759: PUSH
92760: LD_VAR 0 2
92764: NOT
92765: OR
92766: PUSH
92767: LD_VAR 0 4
92771: NOT
92772: OR
92773: IFFALSE 92777
// exit ;
92775: GO 92969
// while 1 do
92777: LD_INT 1
92779: IFFALSE 92969
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92781: LD_ADDR_VAR 0 9
92785: PUSH
92786: LD_VAR 0 1
92790: PPUSH
92791: LD_INT 1
92793: PPUSH
92794: CALL_OW 287
92798: PUSH
92799: LD_INT 10
92801: MUL
92802: ST_TO_ADDR
// r := rate / 10 ;
92803: LD_ADDR_VAR 0 7
92807: PUSH
92808: LD_VAR 0 2
92812: PUSH
92813: LD_INT 10
92815: DIVREAL
92816: ST_TO_ADDR
// time := 1 1$00 ;
92817: LD_ADDR_VAR 0 8
92821: PUSH
92822: LD_INT 2100
92824: ST_TO_ADDR
// if amount < min then
92825: LD_VAR 0 9
92829: PUSH
92830: LD_VAR 0 3
92834: LESS
92835: IFFALSE 92853
// r := r * 2 else
92837: LD_ADDR_VAR 0 7
92841: PUSH
92842: LD_VAR 0 7
92846: PUSH
92847: LD_INT 2
92849: MUL
92850: ST_TO_ADDR
92851: GO 92879
// if amount > max then
92853: LD_VAR 0 9
92857: PUSH
92858: LD_VAR 0 4
92862: GREATER
92863: IFFALSE 92879
// r := r / 2 ;
92865: LD_ADDR_VAR 0 7
92869: PUSH
92870: LD_VAR 0 7
92874: PUSH
92875: LD_INT 2
92877: DIVREAL
92878: ST_TO_ADDR
// time := time / r ;
92879: LD_ADDR_VAR 0 8
92883: PUSH
92884: LD_VAR 0 8
92888: PUSH
92889: LD_VAR 0 7
92893: DIVREAL
92894: ST_TO_ADDR
// if time < 0 then
92895: LD_VAR 0 8
92899: PUSH
92900: LD_INT 0
92902: LESS
92903: IFFALSE 92920
// time := time * - 1 ;
92905: LD_ADDR_VAR 0 8
92909: PUSH
92910: LD_VAR 0 8
92914: PUSH
92915: LD_INT 1
92917: NEG
92918: MUL
92919: ST_TO_ADDR
// wait ( time ) ;
92920: LD_VAR 0 8
92924: PPUSH
92925: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92929: LD_INT 35
92931: PPUSH
92932: LD_INT 875
92934: PPUSH
92935: CALL_OW 12
92939: PPUSH
92940: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92944: LD_INT 1
92946: PPUSH
92947: LD_INT 5
92949: PPUSH
92950: CALL_OW 12
92954: PPUSH
92955: LD_VAR 0 1
92959: PPUSH
92960: LD_INT 1
92962: PPUSH
92963: CALL_OW 55
// end ;
92967: GO 92777
// end ;
92969: LD_VAR 0 5
92973: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92974: LD_INT 0
92976: PPUSH
92977: PPUSH
92978: PPUSH
92979: PPUSH
92980: PPUSH
92981: PPUSH
92982: PPUSH
92983: PPUSH
// if not turrets or not factories then
92984: LD_VAR 0 1
92988: NOT
92989: PUSH
92990: LD_VAR 0 2
92994: NOT
92995: OR
92996: IFFALSE 93000
// exit ;
92998: GO 93307
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
93000: LD_ADDR_VAR 0 10
93004: PUSH
93005: LD_INT 5
93007: PUSH
93008: LD_INT 6
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 2
93017: PUSH
93018: LD_INT 4
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 3
93027: PUSH
93028: LD_INT 5
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 24
93042: PUSH
93043: LD_INT 25
93045: PUSH
93046: EMPTY
93047: LIST
93048: LIST
93049: PUSH
93050: LD_INT 23
93052: PUSH
93053: LD_INT 27
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 42
93066: PUSH
93067: LD_INT 43
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 44
93076: PUSH
93077: LD_INT 46
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 45
93086: PUSH
93087: LD_INT 47
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: LIST
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: LIST
93103: ST_TO_ADDR
// result := [ ] ;
93104: LD_ADDR_VAR 0 3
93108: PUSH
93109: EMPTY
93110: ST_TO_ADDR
// for i in turrets do
93111: LD_ADDR_VAR 0 4
93115: PUSH
93116: LD_VAR 0 1
93120: PUSH
93121: FOR_IN
93122: IFFALSE 93305
// begin nat := GetNation ( i ) ;
93124: LD_ADDR_VAR 0 7
93128: PUSH
93129: LD_VAR 0 4
93133: PPUSH
93134: CALL_OW 248
93138: ST_TO_ADDR
// weapon := 0 ;
93139: LD_ADDR_VAR 0 8
93143: PUSH
93144: LD_INT 0
93146: ST_TO_ADDR
// if not nat then
93147: LD_VAR 0 7
93151: NOT
93152: IFFALSE 93156
// continue ;
93154: GO 93121
// for j in list [ nat ] do
93156: LD_ADDR_VAR 0 5
93160: PUSH
93161: LD_VAR 0 10
93165: PUSH
93166: LD_VAR 0 7
93170: ARRAY
93171: PUSH
93172: FOR_IN
93173: IFFALSE 93214
// if GetBWeapon ( i ) = j [ 1 ] then
93175: LD_VAR 0 4
93179: PPUSH
93180: CALL_OW 269
93184: PUSH
93185: LD_VAR 0 5
93189: PUSH
93190: LD_INT 1
93192: ARRAY
93193: EQUAL
93194: IFFALSE 93212
// begin weapon := j [ 2 ] ;
93196: LD_ADDR_VAR 0 8
93200: PUSH
93201: LD_VAR 0 5
93205: PUSH
93206: LD_INT 2
93208: ARRAY
93209: ST_TO_ADDR
// break ;
93210: GO 93214
// end ;
93212: GO 93172
93214: POP
93215: POP
// if not weapon then
93216: LD_VAR 0 8
93220: NOT
93221: IFFALSE 93225
// continue ;
93223: GO 93121
// for k in factories do
93225: LD_ADDR_VAR 0 6
93229: PUSH
93230: LD_VAR 0 2
93234: PUSH
93235: FOR_IN
93236: IFFALSE 93301
// begin weapons := AvailableWeaponList ( k ) ;
93238: LD_ADDR_VAR 0 9
93242: PUSH
93243: LD_VAR 0 6
93247: PPUSH
93248: CALL_OW 478
93252: ST_TO_ADDR
// if not weapons then
93253: LD_VAR 0 9
93257: NOT
93258: IFFALSE 93262
// continue ;
93260: GO 93235
// if weapon in weapons then
93262: LD_VAR 0 8
93266: PUSH
93267: LD_VAR 0 9
93271: IN
93272: IFFALSE 93299
// begin result := [ i , weapon ] ;
93274: LD_ADDR_VAR 0 3
93278: PUSH
93279: LD_VAR 0 4
93283: PUSH
93284: LD_VAR 0 8
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: ST_TO_ADDR
// exit ;
93293: POP
93294: POP
93295: POP
93296: POP
93297: GO 93307
// end ; end ;
93299: GO 93235
93301: POP
93302: POP
// end ;
93303: GO 93121
93305: POP
93306: POP
// end ;
93307: LD_VAR 0 3
93311: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93312: LD_INT 0
93314: PPUSH
// if not side or side > 8 then
93315: LD_VAR 0 3
93319: NOT
93320: PUSH
93321: LD_VAR 0 3
93325: PUSH
93326: LD_INT 8
93328: GREATER
93329: OR
93330: IFFALSE 93334
// exit ;
93332: GO 93393
// if not range then
93334: LD_VAR 0 4
93338: NOT
93339: IFFALSE 93350
// range := - 12 ;
93341: LD_ADDR_VAR 0 4
93345: PUSH
93346: LD_INT 12
93348: NEG
93349: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93350: LD_VAR 0 1
93354: PPUSH
93355: LD_VAR 0 2
93359: PPUSH
93360: LD_VAR 0 3
93364: PPUSH
93365: LD_VAR 0 4
93369: PPUSH
93370: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93374: LD_VAR 0 1
93378: PPUSH
93379: LD_VAR 0 2
93383: PPUSH
93384: LD_VAR 0 3
93388: PPUSH
93389: CALL_OW 331
// end ;
93393: LD_VAR 0 5
93397: RET
// export function Video ( mode ) ; begin
93398: LD_INT 0
93400: PPUSH
// ingame_video = mode ;
93401: LD_ADDR_OWVAR 52
93405: PUSH
93406: LD_VAR 0 1
93410: ST_TO_ADDR
// interface_hidden = mode ;
93411: LD_ADDR_OWVAR 54
93415: PUSH
93416: LD_VAR 0 1
93420: ST_TO_ADDR
// end ;
93421: LD_VAR 0 2
93425: RET
// export function Join ( array , element ) ; begin
93426: LD_INT 0
93428: PPUSH
// result := array ^ element ;
93429: LD_ADDR_VAR 0 3
93433: PUSH
93434: LD_VAR 0 1
93438: PUSH
93439: LD_VAR 0 2
93443: ADD
93444: ST_TO_ADDR
// end ;
93445: LD_VAR 0 3
93449: RET
// export function JoinUnion ( array , element ) ; begin
93450: LD_INT 0
93452: PPUSH
// result := array union element ;
93453: LD_ADDR_VAR 0 3
93457: PUSH
93458: LD_VAR 0 1
93462: PUSH
93463: LD_VAR 0 2
93467: UNION
93468: ST_TO_ADDR
// end ;
93469: LD_VAR 0 3
93473: RET
// export function GetBehemoths ( side ) ; begin
93474: LD_INT 0
93476: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93477: LD_ADDR_VAR 0 2
93481: PUSH
93482: LD_INT 22
93484: PUSH
93485: LD_VAR 0 1
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: LD_INT 31
93496: PUSH
93497: LD_INT 25
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PPUSH
93508: CALL_OW 69
93512: ST_TO_ADDR
// end ;
93513: LD_VAR 0 2
93517: RET
// export function Shuffle ( array ) ; var i , index ; begin
93518: LD_INT 0
93520: PPUSH
93521: PPUSH
93522: PPUSH
// result := [ ] ;
93523: LD_ADDR_VAR 0 2
93527: PUSH
93528: EMPTY
93529: ST_TO_ADDR
// if not array then
93530: LD_VAR 0 1
93534: NOT
93535: IFFALSE 93539
// exit ;
93537: GO 93638
// Randomize ;
93539: CALL_OW 10
// for i = array downto 1 do
93543: LD_ADDR_VAR 0 3
93547: PUSH
93548: DOUBLE
93549: LD_VAR 0 1
93553: INC
93554: ST_TO_ADDR
93555: LD_INT 1
93557: PUSH
93558: FOR_DOWNTO
93559: IFFALSE 93636
// begin index := rand ( 1 , array ) ;
93561: LD_ADDR_VAR 0 4
93565: PUSH
93566: LD_INT 1
93568: PPUSH
93569: LD_VAR 0 1
93573: PPUSH
93574: CALL_OW 12
93578: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93579: LD_ADDR_VAR 0 2
93583: PUSH
93584: LD_VAR 0 2
93588: PPUSH
93589: LD_VAR 0 2
93593: PUSH
93594: LD_INT 1
93596: PLUS
93597: PPUSH
93598: LD_VAR 0 1
93602: PUSH
93603: LD_VAR 0 4
93607: ARRAY
93608: PPUSH
93609: CALL_OW 2
93613: ST_TO_ADDR
// array := Delete ( array , index ) ;
93614: LD_ADDR_VAR 0 1
93618: PUSH
93619: LD_VAR 0 1
93623: PPUSH
93624: LD_VAR 0 4
93628: PPUSH
93629: CALL_OW 3
93633: ST_TO_ADDR
// end ;
93634: GO 93558
93636: POP
93637: POP
// end ;
93638: LD_VAR 0 2
93642: RET
// export function GetBaseMaterials ( base ) ; begin
93643: LD_INT 0
93645: PPUSH
// result := [ 0 , 0 , 0 ] ;
93646: LD_ADDR_VAR 0 2
93650: PUSH
93651: LD_INT 0
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: LD_INT 0
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: LIST
93664: ST_TO_ADDR
// if not base then
93665: LD_VAR 0 1
93669: NOT
93670: IFFALSE 93674
// exit ;
93672: GO 93723
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93674: LD_ADDR_VAR 0 2
93678: PUSH
93679: LD_VAR 0 1
93683: PPUSH
93684: LD_INT 1
93686: PPUSH
93687: CALL_OW 275
93691: PUSH
93692: LD_VAR 0 1
93696: PPUSH
93697: LD_INT 2
93699: PPUSH
93700: CALL_OW 275
93704: PUSH
93705: LD_VAR 0 1
93709: PPUSH
93710: LD_INT 3
93712: PPUSH
93713: CALL_OW 275
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: LIST
93722: ST_TO_ADDR
// end ; end_of_file end_of_file
93723: LD_VAR 0 2
93727: RET
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
93728: GO 93730
93730: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93731: LD_STRING initStreamRollete();
93733: PPUSH
93734: CALL_OW 559
// InitStreamMode ;
93738: CALL 93743 0 0
// end ;
93742: END
// function InitStreamMode ; begin
93743: LD_INT 0
93745: PPUSH
// streamModeActive := false ;
93746: LD_ADDR_EXP 122
93750: PUSH
93751: LD_INT 0
93753: ST_TO_ADDR
// sRocket := false ;
93754: LD_ADDR_EXP 125
93758: PUSH
93759: LD_INT 0
93761: ST_TO_ADDR
// sSpeed := false ;
93762: LD_ADDR_EXP 124
93766: PUSH
93767: LD_INT 0
93769: ST_TO_ADDR
// sEngine := false ;
93770: LD_ADDR_EXP 126
93774: PUSH
93775: LD_INT 0
93777: ST_TO_ADDR
// sSpec := false ;
93778: LD_ADDR_EXP 123
93782: PUSH
93783: LD_INT 0
93785: ST_TO_ADDR
// sLevel := false ;
93786: LD_ADDR_EXP 127
93790: PUSH
93791: LD_INT 0
93793: ST_TO_ADDR
// sArmoury := false ;
93794: LD_ADDR_EXP 128
93798: PUSH
93799: LD_INT 0
93801: ST_TO_ADDR
// sRadar := false ;
93802: LD_ADDR_EXP 129
93806: PUSH
93807: LD_INT 0
93809: ST_TO_ADDR
// sBunker := false ;
93810: LD_ADDR_EXP 130
93814: PUSH
93815: LD_INT 0
93817: ST_TO_ADDR
// sHack := false ;
93818: LD_ADDR_EXP 131
93822: PUSH
93823: LD_INT 0
93825: ST_TO_ADDR
// sFire := false ;
93826: LD_ADDR_EXP 132
93830: PUSH
93831: LD_INT 0
93833: ST_TO_ADDR
// sRefresh := false ;
93834: LD_ADDR_EXP 133
93838: PUSH
93839: LD_INT 0
93841: ST_TO_ADDR
// sExp := false ;
93842: LD_ADDR_EXP 134
93846: PUSH
93847: LD_INT 0
93849: ST_TO_ADDR
// sDepot := false ;
93850: LD_ADDR_EXP 135
93854: PUSH
93855: LD_INT 0
93857: ST_TO_ADDR
// sFlag := false ;
93858: LD_ADDR_EXP 136
93862: PUSH
93863: LD_INT 0
93865: ST_TO_ADDR
// sSold := false ;
93866: LD_ADDR_EXP 137
93870: PUSH
93871: LD_INT 0
93873: ST_TO_ADDR
// sDiff := false ;
93874: LD_ADDR_EXP 138
93878: PUSH
93879: LD_INT 0
93881: ST_TO_ADDR
// sTiger := false ;
93882: LD_ADDR_EXP 139
93886: PUSH
93887: LD_INT 0
93889: ST_TO_ADDR
// sBomb := false ;
93890: LD_ADDR_EXP 140
93894: PUSH
93895: LD_INT 0
93897: ST_TO_ADDR
// sFog := false ;
93898: LD_ADDR_EXP 141
93902: PUSH
93903: LD_INT 0
93905: ST_TO_ADDR
// sReset := false ;
93906: LD_ADDR_EXP 142
93910: PUSH
93911: LD_INT 0
93913: ST_TO_ADDR
// sSun := false ;
93914: LD_ADDR_EXP 143
93918: PUSH
93919: LD_INT 0
93921: ST_TO_ADDR
// end ;
93922: LD_VAR 0 1
93926: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
93927: LD_VAR 0 2
93931: PUSH
93932: LD_INT 100
93934: EQUAL
93935: IFFALSE 94344
// begin if not StreamModeActive then
93937: LD_EXP 122
93941: NOT
93942: IFFALSE 93952
// StreamModeActive := true ;
93944: LD_ADDR_EXP 122
93948: PUSH
93949: LD_INT 1
93951: ST_TO_ADDR
// if p3 = 0 then
93952: LD_VAR 0 3
93956: PUSH
93957: LD_INT 0
93959: EQUAL
93960: IFFALSE 93966
// InitStreamMode ;
93962: CALL 93743 0 0
// if p3 = 1 then
93966: LD_VAR 0 3
93970: PUSH
93971: LD_INT 1
93973: EQUAL
93974: IFFALSE 93984
// sRocket := true ;
93976: LD_ADDR_EXP 125
93980: PUSH
93981: LD_INT 1
93983: ST_TO_ADDR
// if p3 = 2 then
93984: LD_VAR 0 3
93988: PUSH
93989: LD_INT 2
93991: EQUAL
93992: IFFALSE 94002
// sSpeed := true ;
93994: LD_ADDR_EXP 124
93998: PUSH
93999: LD_INT 1
94001: ST_TO_ADDR
// if p3 = 3 then
94002: LD_VAR 0 3
94006: PUSH
94007: LD_INT 3
94009: EQUAL
94010: IFFALSE 94020
// sEngine := true ;
94012: LD_ADDR_EXP 126
94016: PUSH
94017: LD_INT 1
94019: ST_TO_ADDR
// if p3 = 4 then
94020: LD_VAR 0 3
94024: PUSH
94025: LD_INT 4
94027: EQUAL
94028: IFFALSE 94038
// sSpec := true ;
94030: LD_ADDR_EXP 123
94034: PUSH
94035: LD_INT 1
94037: ST_TO_ADDR
// if p3 = 5 then
94038: LD_VAR 0 3
94042: PUSH
94043: LD_INT 5
94045: EQUAL
94046: IFFALSE 94056
// sLevel := true ;
94048: LD_ADDR_EXP 127
94052: PUSH
94053: LD_INT 1
94055: ST_TO_ADDR
// if p3 = 6 then
94056: LD_VAR 0 3
94060: PUSH
94061: LD_INT 6
94063: EQUAL
94064: IFFALSE 94074
// sArmoury := true ;
94066: LD_ADDR_EXP 128
94070: PUSH
94071: LD_INT 1
94073: ST_TO_ADDR
// if p3 = 7 then
94074: LD_VAR 0 3
94078: PUSH
94079: LD_INT 7
94081: EQUAL
94082: IFFALSE 94092
// sRadar := true ;
94084: LD_ADDR_EXP 129
94088: PUSH
94089: LD_INT 1
94091: ST_TO_ADDR
// if p3 = 8 then
94092: LD_VAR 0 3
94096: PUSH
94097: LD_INT 8
94099: EQUAL
94100: IFFALSE 94110
// sBunker := true ;
94102: LD_ADDR_EXP 130
94106: PUSH
94107: LD_INT 1
94109: ST_TO_ADDR
// if p3 = 9 then
94110: LD_VAR 0 3
94114: PUSH
94115: LD_INT 9
94117: EQUAL
94118: IFFALSE 94128
// sHack := true ;
94120: LD_ADDR_EXP 131
94124: PUSH
94125: LD_INT 1
94127: ST_TO_ADDR
// if p3 = 10 then
94128: LD_VAR 0 3
94132: PUSH
94133: LD_INT 10
94135: EQUAL
94136: IFFALSE 94146
// sFire := true ;
94138: LD_ADDR_EXP 132
94142: PUSH
94143: LD_INT 1
94145: ST_TO_ADDR
// if p3 = 11 then
94146: LD_VAR 0 3
94150: PUSH
94151: LD_INT 11
94153: EQUAL
94154: IFFALSE 94164
// sRefresh := true ;
94156: LD_ADDR_EXP 133
94160: PUSH
94161: LD_INT 1
94163: ST_TO_ADDR
// if p3 = 12 then
94164: LD_VAR 0 3
94168: PUSH
94169: LD_INT 12
94171: EQUAL
94172: IFFALSE 94182
// sExp := true ;
94174: LD_ADDR_EXP 134
94178: PUSH
94179: LD_INT 1
94181: ST_TO_ADDR
// if p3 = 13 then
94182: LD_VAR 0 3
94186: PUSH
94187: LD_INT 13
94189: EQUAL
94190: IFFALSE 94200
// sDepot := true ;
94192: LD_ADDR_EXP 135
94196: PUSH
94197: LD_INT 1
94199: ST_TO_ADDR
// if p3 = 14 then
94200: LD_VAR 0 3
94204: PUSH
94205: LD_INT 14
94207: EQUAL
94208: IFFALSE 94218
// sFlag := true ;
94210: LD_ADDR_EXP 136
94214: PUSH
94215: LD_INT 1
94217: ST_TO_ADDR
// if p3 = 101 then
94218: LD_VAR 0 3
94222: PUSH
94223: LD_INT 101
94225: EQUAL
94226: IFFALSE 94236
// sSold := true ;
94228: LD_ADDR_EXP 137
94232: PUSH
94233: LD_INT 1
94235: ST_TO_ADDR
// if p3 = 102 then
94236: LD_VAR 0 3
94240: PUSH
94241: LD_INT 102
94243: EQUAL
94244: IFFALSE 94254
// sDiff := true ;
94246: LD_ADDR_EXP 138
94250: PUSH
94251: LD_INT 1
94253: ST_TO_ADDR
// if p3 = 103 then
94254: LD_VAR 0 3
94258: PUSH
94259: LD_INT 103
94261: EQUAL
94262: IFFALSE 94272
// sFog := true ;
94264: LD_ADDR_EXP 141
94268: PUSH
94269: LD_INT 1
94271: ST_TO_ADDR
// if p3 = 104 then
94272: LD_VAR 0 3
94276: PUSH
94277: LD_INT 104
94279: EQUAL
94280: IFFALSE 94290
// sReset := true ;
94282: LD_ADDR_EXP 142
94286: PUSH
94287: LD_INT 1
94289: ST_TO_ADDR
// if p3 = 105 then
94290: LD_VAR 0 3
94294: PUSH
94295: LD_INT 105
94297: EQUAL
94298: IFFALSE 94308
// sSun := true ;
94300: LD_ADDR_EXP 143
94304: PUSH
94305: LD_INT 1
94307: ST_TO_ADDR
// if p3 = 106 then
94308: LD_VAR 0 3
94312: PUSH
94313: LD_INT 106
94315: EQUAL
94316: IFFALSE 94326
// sTiger := true ;
94318: LD_ADDR_EXP 139
94322: PUSH
94323: LD_INT 1
94325: ST_TO_ADDR
// if p3 = 107 then
94326: LD_VAR 0 3
94330: PUSH
94331: LD_INT 107
94333: EQUAL
94334: IFFALSE 94344
// sBomb := true ;
94336: LD_ADDR_EXP 140
94340: PUSH
94341: LD_INT 1
94343: ST_TO_ADDR
// end ; end ;
94344: PPOPN 6
94346: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94347: LD_EXP 122
94351: PUSH
94352: LD_EXP 125
94356: AND
94357: IFFALSE 94478
94359: GO 94361
94361: DISABLE
94362: LD_INT 0
94364: PPUSH
94365: PPUSH
// begin enable ;
94366: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94367: LD_ADDR_VAR 0 2
94371: PUSH
94372: LD_INT 22
94374: PUSH
94375: LD_OWVAR 2
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 2
94386: PUSH
94387: LD_INT 34
94389: PUSH
94390: LD_INT 7
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: LD_INT 34
94399: PUSH
94400: LD_INT 45
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 34
94409: PUSH
94410: LD_INT 28
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 34
94419: PUSH
94420: LD_INT 47
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PPUSH
94438: CALL_OW 69
94442: ST_TO_ADDR
// if not tmp then
94443: LD_VAR 0 2
94447: NOT
94448: IFFALSE 94452
// exit ;
94450: GO 94478
// for i in tmp do
94452: LD_ADDR_VAR 0 1
94456: PUSH
94457: LD_VAR 0 2
94461: PUSH
94462: FOR_IN
94463: IFFALSE 94476
// begin DestroyUnit ( i ) ;
94465: LD_VAR 0 1
94469: PPUSH
94470: CALL_OW 65
// end ;
94474: GO 94462
94476: POP
94477: POP
// end ;
94478: PPOPN 2
94480: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94481: LD_EXP 122
94485: PUSH
94486: LD_EXP 126
94490: AND
94491: IFFALSE 94572
94493: GO 94495
94495: DISABLE
94496: LD_INT 0
94498: PPUSH
94499: PPUSH
// begin enable ;
94500: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94501: LD_ADDR_VAR 0 2
94505: PUSH
94506: LD_INT 22
94508: PUSH
94509: LD_OWVAR 2
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: PUSH
94518: LD_INT 32
94520: PUSH
94521: LD_INT 3
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PPUSH
94532: CALL_OW 69
94536: ST_TO_ADDR
// if not tmp then
94537: LD_VAR 0 2
94541: NOT
94542: IFFALSE 94546
// exit ;
94544: GO 94572
// for i in tmp do
94546: LD_ADDR_VAR 0 1
94550: PUSH
94551: LD_VAR 0 2
94555: PUSH
94556: FOR_IN
94557: IFFALSE 94570
// begin DestroyUnit ( i ) ;
94559: LD_VAR 0 1
94563: PPUSH
94564: CALL_OW 65
// end ;
94568: GO 94556
94570: POP
94571: POP
// end ;
94572: PPOPN 2
94574: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94575: LD_EXP 122
94579: PUSH
94580: LD_EXP 123
94584: AND
94585: IFFALSE 94678
94587: GO 94589
94589: DISABLE
94590: LD_INT 0
94592: PPUSH
// begin enable ;
94593: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94594: LD_ADDR_VAR 0 1
94598: PUSH
94599: LD_INT 22
94601: PUSH
94602: LD_OWVAR 2
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: PUSH
94611: LD_INT 2
94613: PUSH
94614: LD_INT 25
94616: PUSH
94617: LD_INT 5
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 25
94626: PUSH
94627: LD_INT 9
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 25
94636: PUSH
94637: LD_INT 8
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PPUSH
94654: CALL_OW 69
94658: PUSH
94659: FOR_IN
94660: IFFALSE 94676
// begin SetClass ( i , 1 ) ;
94662: LD_VAR 0 1
94666: PPUSH
94667: LD_INT 1
94669: PPUSH
94670: CALL_OW 336
// end ;
94674: GO 94659
94676: POP
94677: POP
// end ;
94678: PPOPN 1
94680: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94681: LD_EXP 122
94685: PUSH
94686: LD_EXP 124
94690: AND
94691: PUSH
94692: LD_OWVAR 65
94696: PUSH
94697: LD_INT 7
94699: LESS
94700: AND
94701: IFFALSE 94715
94703: GO 94705
94705: DISABLE
// begin enable ;
94706: ENABLE
// game_speed := 7 ;
94707: LD_ADDR_OWVAR 65
94711: PUSH
94712: LD_INT 7
94714: ST_TO_ADDR
// end ;
94715: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94716: LD_EXP 122
94720: PUSH
94721: LD_EXP 127
94725: AND
94726: IFFALSE 94928
94728: GO 94730
94730: DISABLE
94731: LD_INT 0
94733: PPUSH
94734: PPUSH
94735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94736: LD_ADDR_VAR 0 3
94740: PUSH
94741: LD_INT 81
94743: PUSH
94744: LD_OWVAR 2
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 21
94755: PUSH
94756: LD_INT 1
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PPUSH
94767: CALL_OW 69
94771: ST_TO_ADDR
// if not tmp then
94772: LD_VAR 0 3
94776: NOT
94777: IFFALSE 94781
// exit ;
94779: GO 94928
// if tmp > 5 then
94781: LD_VAR 0 3
94785: PUSH
94786: LD_INT 5
94788: GREATER
94789: IFFALSE 94801
// k := 5 else
94791: LD_ADDR_VAR 0 2
94795: PUSH
94796: LD_INT 5
94798: ST_TO_ADDR
94799: GO 94811
// k := tmp ;
94801: LD_ADDR_VAR 0 2
94805: PUSH
94806: LD_VAR 0 3
94810: ST_TO_ADDR
// for i := 1 to k do
94811: LD_ADDR_VAR 0 1
94815: PUSH
94816: DOUBLE
94817: LD_INT 1
94819: DEC
94820: ST_TO_ADDR
94821: LD_VAR 0 2
94825: PUSH
94826: FOR_TO
94827: IFFALSE 94926
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94829: LD_VAR 0 3
94833: PUSH
94834: LD_VAR 0 1
94838: ARRAY
94839: PPUSH
94840: LD_VAR 0 1
94844: PUSH
94845: LD_INT 4
94847: MOD
94848: PUSH
94849: LD_INT 1
94851: PLUS
94852: PPUSH
94853: CALL_OW 259
94857: PUSH
94858: LD_INT 10
94860: LESS
94861: IFFALSE 94924
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94863: LD_VAR 0 3
94867: PUSH
94868: LD_VAR 0 1
94872: ARRAY
94873: PPUSH
94874: LD_VAR 0 1
94878: PUSH
94879: LD_INT 4
94881: MOD
94882: PUSH
94883: LD_INT 1
94885: PLUS
94886: PPUSH
94887: LD_VAR 0 3
94891: PUSH
94892: LD_VAR 0 1
94896: ARRAY
94897: PPUSH
94898: LD_VAR 0 1
94902: PUSH
94903: LD_INT 4
94905: MOD
94906: PUSH
94907: LD_INT 1
94909: PLUS
94910: PPUSH
94911: CALL_OW 259
94915: PUSH
94916: LD_INT 1
94918: PLUS
94919: PPUSH
94920: CALL_OW 237
94924: GO 94826
94926: POP
94927: POP
// end ;
94928: PPOPN 3
94930: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94931: LD_EXP 122
94935: PUSH
94936: LD_EXP 128
94940: AND
94941: IFFALSE 94961
94943: GO 94945
94945: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94946: LD_INT 4
94948: PPUSH
94949: LD_OWVAR 2
94953: PPUSH
94954: LD_INT 0
94956: PPUSH
94957: CALL_OW 324
94961: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94962: LD_EXP 122
94966: PUSH
94967: LD_EXP 129
94971: AND
94972: IFFALSE 95071
94974: GO 94976
94976: DISABLE
94977: LD_INT 0
94979: PPUSH
94980: PPUSH
// begin enable ;
94981: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94982: LD_ADDR_VAR 0 2
94986: PUSH
94987: LD_INT 22
94989: PUSH
94990: LD_OWVAR 2
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 2
95001: PUSH
95002: LD_INT 34
95004: PUSH
95005: LD_INT 11
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: LD_INT 34
95014: PUSH
95015: LD_INT 30
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: LIST
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PPUSH
95031: CALL_OW 69
95035: ST_TO_ADDR
// if not tmp then
95036: LD_VAR 0 2
95040: NOT
95041: IFFALSE 95045
// exit ;
95043: GO 95071
// for i in tmp do
95045: LD_ADDR_VAR 0 1
95049: PUSH
95050: LD_VAR 0 2
95054: PUSH
95055: FOR_IN
95056: IFFALSE 95069
// begin DestroyUnit ( i ) ;
95058: LD_VAR 0 1
95062: PPUSH
95063: CALL_OW 65
// end ;
95067: GO 95055
95069: POP
95070: POP
// end ;
95071: PPOPN 2
95073: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95074: LD_EXP 122
95078: PUSH
95079: LD_EXP 130
95083: AND
95084: IFFALSE 95104
95086: GO 95088
95088: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95089: LD_INT 32
95091: PPUSH
95092: LD_OWVAR 2
95096: PPUSH
95097: LD_INT 0
95099: PPUSH
95100: CALL_OW 324
95104: END
// every 0 0$1 trigger StreamModeActive and sHack do
95105: LD_EXP 122
95109: PUSH
95110: LD_EXP 131
95114: AND
95115: IFFALSE 95135
95117: GO 95119
95119: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
95120: LD_INT 33
95122: PPUSH
95123: LD_OWVAR 2
95127: PPUSH
95128: LD_INT 0
95130: PPUSH
95131: CALL_OW 322
95135: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95136: LD_EXP 122
95140: PUSH
95141: LD_EXP 132
95145: AND
95146: IFFALSE 95225
95148: GO 95150
95150: DISABLE
95151: LD_INT 0
95153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95154: LD_ADDR_VAR 0 1
95158: PUSH
95159: LD_INT 22
95161: PUSH
95162: LD_OWVAR 2
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 21
95173: PUSH
95174: LD_INT 3
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PPUSH
95185: CALL_OW 69
95189: ST_TO_ADDR
// if not tmp then
95190: LD_VAR 0 1
95194: NOT
95195: IFFALSE 95199
// exit ;
95197: GO 95225
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95199: LD_VAR 0 1
95203: PUSH
95204: LD_INT 1
95206: PPUSH
95207: LD_VAR 0 1
95211: PPUSH
95212: CALL_OW 12
95216: ARRAY
95217: PPUSH
95218: LD_INT 100
95220: PPUSH
95221: CALL_OW 234
// end ;
95225: PPOPN 1
95227: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95228: LD_EXP 122
95232: PUSH
95233: LD_EXP 134
95237: AND
95238: IFFALSE 95336
95240: GO 95242
95242: DISABLE
95243: LD_INT 0
95245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95246: LD_ADDR_VAR 0 1
95250: PUSH
95251: LD_INT 22
95253: PUSH
95254: LD_OWVAR 2
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 21
95265: PUSH
95266: LD_INT 1
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PPUSH
95277: CALL_OW 69
95281: ST_TO_ADDR
// if not tmp then
95282: LD_VAR 0 1
95286: NOT
95287: IFFALSE 95291
// exit ;
95289: GO 95336
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95291: LD_VAR 0 1
95295: PUSH
95296: LD_INT 1
95298: PPUSH
95299: LD_VAR 0 1
95303: PPUSH
95304: CALL_OW 12
95308: ARRAY
95309: PPUSH
95310: LD_INT 1
95312: PPUSH
95313: LD_INT 4
95315: PPUSH
95316: CALL_OW 12
95320: PPUSH
95321: LD_INT 3000
95323: PPUSH
95324: LD_INT 9000
95326: PPUSH
95327: CALL_OW 12
95331: PPUSH
95332: CALL_OW 492
// end ;
95336: PPOPN 1
95338: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95339: LD_EXP 122
95343: PUSH
95344: LD_EXP 135
95348: AND
95349: IFFALSE 95369
95351: GO 95353
95353: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95354: LD_INT 1
95356: PPUSH
95357: LD_OWVAR 2
95361: PPUSH
95362: LD_INT 0
95364: PPUSH
95365: CALL_OW 324
95369: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95370: LD_EXP 122
95374: PUSH
95375: LD_EXP 136
95379: AND
95380: IFFALSE 95463
95382: GO 95384
95384: DISABLE
95385: LD_INT 0
95387: PPUSH
95388: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95389: LD_ADDR_VAR 0 2
95393: PUSH
95394: LD_INT 22
95396: PUSH
95397: LD_OWVAR 2
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 21
95408: PUSH
95409: LD_INT 3
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PPUSH
95420: CALL_OW 69
95424: ST_TO_ADDR
// if not tmp then
95425: LD_VAR 0 2
95429: NOT
95430: IFFALSE 95434
// exit ;
95432: GO 95463
// for i in tmp do
95434: LD_ADDR_VAR 0 1
95438: PUSH
95439: LD_VAR 0 2
95443: PUSH
95444: FOR_IN
95445: IFFALSE 95461
// SetBLevel ( i , 10 ) ;
95447: LD_VAR 0 1
95451: PPUSH
95452: LD_INT 10
95454: PPUSH
95455: CALL_OW 241
95459: GO 95444
95461: POP
95462: POP
// end ;
95463: PPOPN 2
95465: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
95466: LD_EXP 122
95470: PUSH
95471: LD_EXP 137
95475: AND
95476: IFFALSE 95559
95478: GO 95480
95480: DISABLE
95481: LD_INT 0
95483: PPUSH
95484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95485: LD_ADDR_VAR 0 2
95489: PUSH
95490: LD_INT 22
95492: PUSH
95493: LD_OWVAR 2
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: LD_INT 25
95504: PUSH
95505: LD_INT 1
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: PPUSH
95516: CALL_OW 69
95520: ST_TO_ADDR
// if not tmp then
95521: LD_VAR 0 2
95525: NOT
95526: IFFALSE 95530
// exit ;
95528: GO 95559
// for i in tmp do
95530: LD_ADDR_VAR 0 1
95534: PUSH
95535: LD_VAR 0 2
95539: PUSH
95540: FOR_IN
95541: IFFALSE 95557
// SetClass ( i , 4 ) ;
95543: LD_VAR 0 1
95547: PPUSH
95548: LD_INT 4
95550: PPUSH
95551: CALL_OW 336
95555: GO 95540
95557: POP
95558: POP
// end ;
95559: PPOPN 2
95561: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95562: LD_EXP 122
95566: PUSH
95567: LD_EXP 138
95571: AND
95572: PUSH
95573: LD_OWVAR 67
95577: PUSH
95578: LD_INT 3
95580: LESS
95581: AND
95582: IFFALSE 95601
95584: GO 95586
95586: DISABLE
// Difficulty := Difficulty + 1 ;
95587: LD_ADDR_OWVAR 67
95591: PUSH
95592: LD_OWVAR 67
95596: PUSH
95597: LD_INT 1
95599: PLUS
95600: ST_TO_ADDR
95601: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95602: LD_EXP 122
95606: PUSH
95607: LD_EXP 139
95611: AND
95612: IFFALSE 95715
95614: GO 95616
95616: DISABLE
95617: LD_INT 0
95619: PPUSH
// begin for i := 1 to 5 do
95620: LD_ADDR_VAR 0 1
95624: PUSH
95625: DOUBLE
95626: LD_INT 1
95628: DEC
95629: ST_TO_ADDR
95630: LD_INT 5
95632: PUSH
95633: FOR_TO
95634: IFFALSE 95713
// begin uc_nation := nation_nature ;
95636: LD_ADDR_OWVAR 21
95640: PUSH
95641: LD_INT 0
95643: ST_TO_ADDR
// uc_side := 0 ;
95644: LD_ADDR_OWVAR 20
95648: PUSH
95649: LD_INT 0
95651: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95652: LD_ADDR_OWVAR 29
95656: PUSH
95657: LD_INT 12
95659: PUSH
95660: LD_INT 12
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: ST_TO_ADDR
// hc_agressivity := 20 ;
95667: LD_ADDR_OWVAR 35
95671: PUSH
95672: LD_INT 20
95674: ST_TO_ADDR
// hc_class := class_tiger ;
95675: LD_ADDR_OWVAR 28
95679: PUSH
95680: LD_INT 14
95682: ST_TO_ADDR
// hc_gallery :=  ;
95683: LD_ADDR_OWVAR 33
95687: PUSH
95688: LD_STRING 
95690: ST_TO_ADDR
// hc_name :=  ;
95691: LD_ADDR_OWVAR 26
95695: PUSH
95696: LD_STRING 
95698: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95699: CALL_OW 44
95703: PPUSH
95704: LD_INT 0
95706: PPUSH
95707: CALL_OW 51
// end ;
95711: GO 95633
95713: POP
95714: POP
// end ;
95715: PPOPN 1
95717: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
95718: LD_EXP 122
95722: PUSH
95723: LD_EXP 140
95727: AND
95728: IFFALSE 95902
95730: GO 95732
95732: DISABLE
95733: LD_INT 0
95735: PPUSH
95736: PPUSH
95737: PPUSH
95738: PPUSH
// begin result := false ;
95739: LD_ADDR_VAR 0 4
95743: PUSH
95744: LD_INT 0
95746: ST_TO_ADDR
// for i := 1 to 8 do
95747: LD_ADDR_VAR 0 1
95751: PUSH
95752: DOUBLE
95753: LD_INT 1
95755: DEC
95756: ST_TO_ADDR
95757: LD_INT 8
95759: PUSH
95760: FOR_TO
95761: IFFALSE 95872
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
95763: LD_ADDR_VAR 0 2
95767: PUSH
95768: LD_INT 10
95770: PUSH
95771: LD_INT 50
95773: PUSH
95774: LD_INT 90
95776: PUSH
95777: LD_INT 140
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 1
95788: PPUSH
95789: LD_INT 4
95791: PPUSH
95792: CALL_OW 12
95796: ARRAY
95797: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
95798: LD_ADDR_VAR 0 3
95802: PUSH
95803: LD_INT 10
95805: PUSH
95806: LD_INT 50
95808: PUSH
95809: LD_INT 90
95811: PUSH
95812: LD_INT 140
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: PUSH
95821: LD_INT 1
95823: PPUSH
95824: LD_INT 4
95826: PPUSH
95827: CALL_OW 12
95831: ARRAY
95832: ST_TO_ADDR
// if ValidHex ( x , y ) then
95833: LD_VAR 0 2
95837: PPUSH
95838: LD_VAR 0 3
95842: PPUSH
95843: CALL_OW 488
95847: IFFALSE 95870
// begin result := [ x , y ] ;
95849: LD_ADDR_VAR 0 4
95853: PUSH
95854: LD_VAR 0 2
95858: PUSH
95859: LD_VAR 0 3
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: ST_TO_ADDR
// break ;
95868: GO 95872
// end ; end ;
95870: GO 95760
95872: POP
95873: POP
// if result then
95874: LD_VAR 0 4
95878: IFFALSE 95902
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95880: LD_VAR 0 4
95884: PUSH
95885: LD_INT 1
95887: ARRAY
95888: PPUSH
95889: LD_VAR 0 4
95893: PUSH
95894: LD_INT 2
95896: ARRAY
95897: PPUSH
95898: CALL_OW 429
// end ;
95902: PPOPN 4
95904: END
// every 0 0$1 trigger StreamModeActive and sReset do
95905: LD_EXP 122
95909: PUSH
95910: LD_EXP 142
95914: AND
95915: IFFALSE 95927
95917: GO 95919
95919: DISABLE
// YouLost (  ) ;
95920: LD_STRING 
95922: PPUSH
95923: CALL_OW 104
95927: END
// every 0 0$1 trigger StreamModeActive and sFog do
95928: LD_EXP 122
95932: PUSH
95933: LD_EXP 141
95937: AND
95938: IFFALSE 95952
95940: GO 95942
95942: DISABLE
// FogOff ( your_side ) ;
95943: LD_OWVAR 2
95947: PPUSH
95948: CALL_OW 344
95952: END
// every 0 0$1 trigger StreamModeActive and sSun do
95953: LD_EXP 122
95957: PUSH
95958: LD_EXP 143
95962: AND
95963: IFFALSE 95991
95965: GO 95967
95967: DISABLE
// begin solar_recharge_percent := 0 ;
95968: LD_ADDR_OWVAR 79
95972: PUSH
95973: LD_INT 0
95975: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95976: LD_INT 10500
95978: PPUSH
95979: CALL_OW 67
// solar_recharge_percent := 100 ;
95983: LD_ADDR_OWVAR 79
95987: PUSH
95988: LD_INT 100
95990: ST_TO_ADDR
// end ; end_of_file
95991: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
95992: LD_INT 0
95994: PPUSH
95995: PPUSH
95996: PPUSH
95997: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
95998: LD_VAR 0 1
96002: PPUSH
96003: CALL_OW 264
96007: PUSH
96008: LD_EXP 76
96012: EQUAL
96013: IFFALSE 96085
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
96015: LD_INT 68
96017: PPUSH
96018: LD_VAR 0 1
96022: PPUSH
96023: CALL_OW 255
96027: PPUSH
96028: CALL_OW 321
96032: PUSH
96033: LD_INT 2
96035: EQUAL
96036: IFFALSE 96048
// eff := 70 else
96038: LD_ADDR_VAR 0 6
96042: PUSH
96043: LD_INT 70
96045: ST_TO_ADDR
96046: GO 96056
// eff := 30 ;
96048: LD_ADDR_VAR 0 6
96052: PUSH
96053: LD_INT 30
96055: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
96056: LD_VAR 0 1
96060: PPUSH
96061: CALL_OW 250
96065: PPUSH
96066: LD_VAR 0 1
96070: PPUSH
96071: CALL_OW 251
96075: PPUSH
96076: LD_VAR 0 6
96080: PPUSH
96081: CALL_OW 495
// end ; end ;
96085: LD_VAR 0 4
96089: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
96090: LD_INT 0
96092: PPUSH
96093: PPUSH
96094: PPUSH
96095: PPUSH
96096: PPUSH
96097: PPUSH
// if cmd = 124 then
96098: LD_VAR 0 1
96102: PUSH
96103: LD_INT 124
96105: EQUAL
96106: IFFALSE 96312
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
96108: LD_ADDR_VAR 0 5
96112: PUSH
96113: LD_INT 2
96115: PUSH
96116: LD_INT 34
96118: PUSH
96119: LD_INT 53
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PUSH
96126: LD_INT 34
96128: PUSH
96129: LD_INT 14
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: LIST
96140: PPUSH
96141: CALL_OW 69
96145: ST_TO_ADDR
// if not tmp then
96146: LD_VAR 0 5
96150: NOT
96151: IFFALSE 96155
// exit ;
96153: GO 96312
// for i in tmp do
96155: LD_ADDR_VAR 0 3
96159: PUSH
96160: LD_VAR 0 5
96164: PUSH
96165: FOR_IN
96166: IFFALSE 96310
// begin taskList := GetTaskList ( i ) ;
96168: LD_ADDR_VAR 0 6
96172: PUSH
96173: LD_VAR 0 3
96177: PPUSH
96178: CALL_OW 437
96182: ST_TO_ADDR
// if not taskList then
96183: LD_VAR 0 6
96187: NOT
96188: IFFALSE 96192
// continue ;
96190: GO 96165
// for j = 1 to taskList do
96192: LD_ADDR_VAR 0 4
96196: PUSH
96197: DOUBLE
96198: LD_INT 1
96200: DEC
96201: ST_TO_ADDR
96202: LD_VAR 0 6
96206: PUSH
96207: FOR_TO
96208: IFFALSE 96306
// if taskList [ j ] [ 1 ] = | then
96210: LD_VAR 0 6
96214: PUSH
96215: LD_VAR 0 4
96219: ARRAY
96220: PUSH
96221: LD_INT 1
96223: ARRAY
96224: PUSH
96225: LD_STRING |
96227: EQUAL
96228: IFFALSE 96304
// begin _taskList := Delete ( taskList , 1 ) ;
96230: LD_ADDR_VAR 0 7
96234: PUSH
96235: LD_VAR 0 6
96239: PPUSH
96240: LD_INT 1
96242: PPUSH
96243: CALL_OW 3
96247: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
96248: LD_VAR 0 3
96252: PPUSH
96253: LD_VAR 0 7
96257: PPUSH
96258: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
96262: LD_VAR 0 3
96266: PPUSH
96267: LD_VAR 0 6
96271: PUSH
96272: LD_VAR 0 4
96276: ARRAY
96277: PUSH
96278: LD_INT 2
96280: ARRAY
96281: PPUSH
96282: LD_VAR 0 6
96286: PUSH
96287: LD_VAR 0 4
96291: ARRAY
96292: PUSH
96293: LD_INT 3
96295: ARRAY
96296: PPUSH
96297: LD_INT 8
96299: PPUSH
96300: CALL 96317 0 4
// end ;
96304: GO 96207
96306: POP
96307: POP
// end ;
96308: GO 96165
96310: POP
96311: POP
// end ; end ;
96312: LD_VAR 0 2
96316: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
96317: LD_INT 0
96319: PPUSH
96320: PPUSH
96321: PPUSH
96322: PPUSH
96323: PPUSH
96324: PPUSH
96325: PPUSH
96326: PPUSH
96327: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
96328: LD_VAR 0 1
96332: NOT
96333: PUSH
96334: LD_VAR 0 2
96338: PPUSH
96339: LD_VAR 0 3
96343: PPUSH
96344: CALL_OW 488
96348: NOT
96349: OR
96350: PUSH
96351: LD_VAR 0 4
96355: NOT
96356: OR
96357: IFFALSE 96361
// exit ;
96359: GO 96701
// list := [ ] ;
96361: LD_ADDR_VAR 0 13
96365: PUSH
96366: EMPTY
96367: ST_TO_ADDR
// if x - r < 0 then
96368: LD_VAR 0 2
96372: PUSH
96373: LD_VAR 0 4
96377: MINUS
96378: PUSH
96379: LD_INT 0
96381: LESS
96382: IFFALSE 96394
// min_x := 0 else
96384: LD_ADDR_VAR 0 7
96388: PUSH
96389: LD_INT 0
96391: ST_TO_ADDR
96392: GO 96410
// min_x := x - r ;
96394: LD_ADDR_VAR 0 7
96398: PUSH
96399: LD_VAR 0 2
96403: PUSH
96404: LD_VAR 0 4
96408: MINUS
96409: ST_TO_ADDR
// if y - r < 0 then
96410: LD_VAR 0 3
96414: PUSH
96415: LD_VAR 0 4
96419: MINUS
96420: PUSH
96421: LD_INT 0
96423: LESS
96424: IFFALSE 96436
// min_y := 0 else
96426: LD_ADDR_VAR 0 8
96430: PUSH
96431: LD_INT 0
96433: ST_TO_ADDR
96434: GO 96452
// min_y := y - r ;
96436: LD_ADDR_VAR 0 8
96440: PUSH
96441: LD_VAR 0 3
96445: PUSH
96446: LD_VAR 0 4
96450: MINUS
96451: ST_TO_ADDR
// max_x := x + r ;
96452: LD_ADDR_VAR 0 9
96456: PUSH
96457: LD_VAR 0 2
96461: PUSH
96462: LD_VAR 0 4
96466: PLUS
96467: ST_TO_ADDR
// max_y := y + r ;
96468: LD_ADDR_VAR 0 10
96472: PUSH
96473: LD_VAR 0 3
96477: PUSH
96478: LD_VAR 0 4
96482: PLUS
96483: ST_TO_ADDR
// for _x = min_x to max_x do
96484: LD_ADDR_VAR 0 11
96488: PUSH
96489: DOUBLE
96490: LD_VAR 0 7
96494: DEC
96495: ST_TO_ADDR
96496: LD_VAR 0 9
96500: PUSH
96501: FOR_TO
96502: IFFALSE 96619
// for _y = min_y to max_y do
96504: LD_ADDR_VAR 0 12
96508: PUSH
96509: DOUBLE
96510: LD_VAR 0 8
96514: DEC
96515: ST_TO_ADDR
96516: LD_VAR 0 10
96520: PUSH
96521: FOR_TO
96522: IFFALSE 96615
// begin if not ValidHex ( _x , _y ) then
96524: LD_VAR 0 11
96528: PPUSH
96529: LD_VAR 0 12
96533: PPUSH
96534: CALL_OW 488
96538: NOT
96539: IFFALSE 96543
// continue ;
96541: GO 96521
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
96543: LD_VAR 0 11
96547: PPUSH
96548: LD_VAR 0 12
96552: PPUSH
96553: CALL_OW 351
96557: PUSH
96558: LD_VAR 0 11
96562: PPUSH
96563: LD_VAR 0 12
96567: PPUSH
96568: CALL_OW 554
96572: AND
96573: IFFALSE 96613
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
96575: LD_ADDR_VAR 0 13
96579: PUSH
96580: LD_VAR 0 13
96584: PPUSH
96585: LD_VAR 0 13
96589: PUSH
96590: LD_INT 1
96592: PLUS
96593: PPUSH
96594: LD_VAR 0 11
96598: PUSH
96599: LD_VAR 0 12
96603: PUSH
96604: EMPTY
96605: LIST
96606: LIST
96607: PPUSH
96608: CALL_OW 2
96612: ST_TO_ADDR
// end ;
96613: GO 96521
96615: POP
96616: POP
96617: GO 96501
96619: POP
96620: POP
// if not list then
96621: LD_VAR 0 13
96625: NOT
96626: IFFALSE 96630
// exit ;
96628: GO 96701
// for i in list do
96630: LD_ADDR_VAR 0 6
96634: PUSH
96635: LD_VAR 0 13
96639: PUSH
96640: FOR_IN
96641: IFFALSE 96699
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
96643: LD_VAR 0 1
96647: PPUSH
96648: LD_STRING M
96650: PUSH
96651: LD_VAR 0 6
96655: PUSH
96656: LD_INT 1
96658: ARRAY
96659: PUSH
96660: LD_VAR 0 6
96664: PUSH
96665: LD_INT 2
96667: ARRAY
96668: PUSH
96669: LD_INT 0
96671: PUSH
96672: LD_INT 0
96674: PUSH
96675: LD_INT 0
96677: PUSH
96678: LD_INT 0
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: PUSH
96690: EMPTY
96691: LIST
96692: PPUSH
96693: CALL_OW 447
96697: GO 96640
96699: POP
96700: POP
// end ;
96701: LD_VAR 0 5
96705: RET
