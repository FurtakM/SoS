// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21252 0 0
// InitMacro ;
  19: CALL 21412 0 0
// InitNature ;
  23: CALL 17918 0 0
// InitArtifact ;
  27: CALL 18535 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11481 0 0
// MC_Start ( ) ;
  68: CALL 23577 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 118
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 119
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45266 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46326 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46419 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 123
 357: PUSH
 358: LD_EXP 123
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45584 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45769 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46326 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46419 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45584 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45769 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46199 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45266 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46326 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46419 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 123
 849: PUSH
 850: LD_EXP 123
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45584 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45769 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46326 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46419 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46737 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46531 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45584 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45769 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46150 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 52038 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 52038 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 52038 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 52038 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 52038 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 52038 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 52038 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 52038 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 52038 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 52038 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 52038 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 52038 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 52038 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 52038 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 52038 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 52038 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 52038 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 52038 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 52038 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 52038 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 52038 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 52038 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 52038 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 52038 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 52038 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 52038 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 52038 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 52038 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 52038 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 52038 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 52038 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 52038 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 52038 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 52038 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 57055 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 57055 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 57055 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 57055 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 57055 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 57055 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 57055 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 57055 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 57055 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 57055 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 57055 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 57055 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 57055 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 57055 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 57055 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 57055 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 57055 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 57055 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 52038 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 52038 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 52038 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 52038 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 52038 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 52038 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 52038 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 52038 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 52038 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 52038 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 94
5868: PUSH
5869: LD_EXP 94
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47050 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45632 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45632 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47050 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47050 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 113
6351: PUSH
6352: LD_EXP 113
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 113
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45632 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60501 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 94
7133: PUSH
7134: LD_EXP 94
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 52038 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60501 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 94
7667: PUSH
7668: LD_EXP 94
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47050 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45632 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45632 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47050 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47050 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 113
8332: PUSH
8333: LD_EXP 113
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 113
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: LD_EXP 1
9038: NOT
9039: PPUSH
9040: LD_STRING 09_
9042: PPUSH
9043: CALL 52038 0 3
9047: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9048: LD_ADDR_EXP 60
9052: PUSH
9053: LD_STRING Gleb
9055: PPUSH
9056: CALL_OW 25
9060: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9061: LD_STRING 03_Cornel
9063: PPUSH
9064: CALL_OW 28
9068: IFFALSE 9116
// begin Bierezov := NewCharacter ( Mikhail ) ;
9070: LD_ADDR_EXP 61
9074: PUSH
9075: LD_STRING Mikhail
9077: PPUSH
9078: CALL_OW 25
9082: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9083: LD_EXP 61
9087: PPUSH
9088: LD_INT 197
9090: PPUSH
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 9
9096: PPUSH
9097: LD_INT 0
9099: PPUSH
9100: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9104: LD_EXP 61
9108: PPUSH
9109: LD_INT 3
9111: PPUSH
9112: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9116: LD_EXP 58
9120: PPUSH
9121: LD_INT 126
9123: PPUSH
9124: CALL_OW 52
// if Yakotich then
9128: LD_EXP 59
9132: IFFALSE 9155
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9134: LD_EXP 59
9138: PPUSH
9139: LD_INT 197
9141: PPUSH
9142: LD_INT 111
9144: PPUSH
9145: LD_INT 9
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9155: LD_EXP 60
9159: PPUSH
9160: LD_INT 197
9162: PPUSH
9163: LD_INT 111
9165: PPUSH
9166: LD_INT 9
9168: PPUSH
9169: LD_INT 0
9171: PPUSH
9172: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9176: LD_ADDR_VAR 0 5
9180: PUSH
9181: LD_INT 126
9183: PPUSH
9184: LD_INT 2
9186: PPUSH
9187: LD_STRING zhukov
9189: PPUSH
9190: LD_INT 9
9192: PUSH
9193: LD_INT 10
9195: PUSH
9196: LD_INT 10
9198: PUSH
9199: LD_INT 10
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: PUSH
9208: LD_OWVAR 67
9212: ARRAY
9213: PPUSH
9214: LD_INT 9000
9216: PUSH
9217: LD_INT 1000
9219: PUSH
9220: LD_INT 300
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: LIST
9227: PPUSH
9228: LD_INT 21
9230: PUSH
9231: LD_INT 8
9233: PUSH
9234: LD_INT 13
9236: PUSH
9237: LD_INT 8
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: PPUSH
9246: CALL 60501 0 6
9250: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9251: LD_ADDR_VAR 0 4
9255: PUSH
9256: LD_INT 267
9258: PPUSH
9259: CALL_OW 274
9263: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 1
9271: PPUSH
9272: LD_INT 5000
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 2
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9294: LD_VAR 0 4
9298: PPUSH
9299: LD_INT 3
9301: PPUSH
9302: LD_INT 200
9304: PPUSH
9305: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9309: LD_ADDR_EXP 94
9313: PUSH
9314: LD_EXP 94
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: LD_VAR 0 5
9326: PUSH
9327: LD_INT 22
9329: PUSH
9330: LD_VAR 0 6
9334: PUSH
9335: EMPTY
9336: LIST
9337: LIST
9338: PUSH
9339: LD_INT 3
9341: PUSH
9342: LD_INT 21
9344: PUSH
9345: LD_INT 2
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: PPUSH
9360: CALL_OW 69
9364: UNION
9365: PUSH
9366: LD_EXP 58
9370: DIFF
9371: PPUSH
9372: CALL_OW 1
9376: ST_TO_ADDR
// behemoths := [ ] ;
9377: LD_ADDR_EXP 62
9381: PUSH
9382: EMPTY
9383: ST_TO_ADDR
// behemothBuilders := [ ] ;
9384: LD_ADDR_EXP 63
9388: PUSH
9389: EMPTY
9390: ST_TO_ADDR
// j := 3 ;
9391: LD_ADDR_VAR 0 3
9395: PUSH
9396: LD_INT 3
9398: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9399: LD_ADDR_VAR 0 2
9403: PUSH
9404: LD_INT 22
9406: PUSH
9407: LD_INT 3
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: LD_INT 25
9416: PUSH
9417: LD_INT 3
9419: PUSH
9420: EMPTY
9421: LIST
9422: LIST
9423: PUSH
9424: EMPTY
9425: LIST
9426: LIST
9427: PPUSH
9428: CALL_OW 69
9432: PUSH
9433: FOR_IN
9434: IFFALSE 9484
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9436: LD_ADDR_EXP 63
9440: PUSH
9441: LD_EXP 63
9445: PPUSH
9446: LD_VAR 0 2
9450: PPUSH
9451: CALL 89439 0 2
9455: ST_TO_ADDR
// j := j - 1 ;
9456: LD_ADDR_VAR 0 3
9460: PUSH
9461: LD_VAR 0 3
9465: PUSH
9466: LD_INT 1
9468: MINUS
9469: ST_TO_ADDR
// if j = 0 then
9470: LD_VAR 0 3
9474: PUSH
9475: LD_INT 0
9477: EQUAL
9478: IFFALSE 9482
// break ;
9480: GO 9484
// end ;
9482: GO 9433
9484: POP
9485: POP
// end ;
9486: LD_VAR 0 1
9490: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9491: LD_INT 0
9493: PPUSH
9494: PPUSH
9495: PPUSH
9496: PPUSH
9497: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9498: LD_ADDR_VAR 0 4
9502: PUSH
9503: LD_INT 209
9505: PUSH
9506: LD_INT 149
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: PUSH
9513: LD_INT 219
9515: PUSH
9516: LD_INT 154
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PUSH
9523: LD_INT 223
9525: PUSH
9526: LD_INT 149
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: PUSH
9533: LD_INT 232
9535: PUSH
9536: LD_INT 155
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: ST_TO_ADDR
// if not behemothBuilders then
9549: LD_EXP 63
9553: NOT
9554: IFFALSE 9558
// exit ;
9556: GO 9662
// j := 1 ;
9558: LD_ADDR_VAR 0 3
9562: PUSH
9563: LD_INT 1
9565: ST_TO_ADDR
// for i in behemothBuilders do
9566: LD_ADDR_VAR 0 2
9570: PUSH
9571: LD_EXP 63
9575: PUSH
9576: FOR_IN
9577: IFFALSE 9660
// begin if IsInUnit ( i ) then
9579: LD_VAR 0 2
9583: PPUSH
9584: CALL_OW 310
9588: IFFALSE 9599
// ComExitBuilding ( i ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9599: LD_VAR 0 2
9603: PPUSH
9604: LD_INT 37
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 1
9620: ARRAY
9621: PPUSH
9622: LD_VAR 0 4
9626: PUSH
9627: LD_VAR 0 3
9631: ARRAY
9632: PUSH
9633: LD_INT 2
9635: ARRAY
9636: PPUSH
9637: LD_INT 0
9639: PPUSH
9640: CALL_OW 230
// j := j + 1 ;
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 3
9653: PUSH
9654: LD_INT 1
9656: PLUS
9657: ST_TO_ADDR
// end ;
9658: GO 9576
9660: POP
9661: POP
// end ;
9662: LD_VAR 0 1
9666: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9667: LD_INT 3
9669: PPUSH
9670: CALL 89500 0 1
9674: PUSH
9675: LD_INT 22
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: PUSH
9685: LD_INT 30
9687: PUSH
9688: LD_INT 37
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: NOT
9704: AND
9705: IFFALSE 9891
9707: GO 9709
9709: DISABLE
9710: LD_INT 0
9712: PPUSH
9713: PPUSH
// begin enable ;
9714: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9715: LD_ADDR_VAR 0 2
9719: PUSH
9720: LD_INT 3
9722: PPUSH
9723: CALL 89500 0 1
9727: ST_TO_ADDR
// for i in tmp do
9728: LD_ADDR_VAR 0 1
9732: PUSH
9733: LD_VAR 0 2
9737: PUSH
9738: FOR_IN
9739: IFFALSE 9889
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 7
9748: PPUSH
9749: CALL_OW 308
9753: PUSH
9754: LD_VAR 0 1
9758: PPUSH
9759: CALL_OW 110
9763: PUSH
9764: LD_INT 2
9766: EQUAL
9767: NOT
9768: AND
9769: IFFALSE 9783
// SetTag ( i , 2 ) ;
9771: LD_VAR 0 1
9775: PPUSH
9776: LD_INT 2
9778: PPUSH
9779: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9783: LD_INT 81
9785: PUSH
9786: LD_INT 3
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PUSH
9793: LD_INT 91
9795: PUSH
9796: LD_VAR 0 1
9800: PUSH
9801: LD_INT 12
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: LIST
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 69
9817: NOT
9818: PUSH
9819: LD_VAR 0 1
9823: PPUSH
9824: CALL_OW 110
9828: PUSH
9829: LD_INT 2
9831: EQUAL
9832: NOT
9833: AND
9834: IFFALSE 9853
// ComAgressiveMove ( i , 64 , 93 ) else
9836: LD_VAR 0 1
9840: PPUSH
9841: LD_INT 64
9843: PPUSH
9844: LD_INT 93
9846: PPUSH
9847: CALL_OW 114
9851: GO 9887
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9853: LD_VAR 0 1
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 3
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 69
9872: PPUSH
9873: LD_VAR 0 1
9877: PPUSH
9878: CALL_OW 74
9882: PPUSH
9883: CALL_OW 115
// end ;
9887: GO 9738
9889: POP
9890: POP
// end ;
9891: PPOPN 2
9893: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 2
9898: NOT
9899: PUSH
9900: LD_INT 2
9902: PPUSH
9903: LD_INT 1
9905: PPUSH
9906: CALL 47050 0 2
9910: NOT
9911: AND
9912: IFFALSE 10836
9914: GO 9916
9916: DISABLE
9917: LD_INT 0
9919: PPUSH
9920: PPUSH
9921: PPUSH
9922: PPUSH
// begin enable ;
9923: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9924: LD_INT 22
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 30
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PPUSH
9948: CALL_OW 69
9952: NOT
9953: IFFALSE 9957
// exit ;
9955: GO 10836
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9957: LD_ADDR_VAR 0 4
9961: PUSH
9962: LD_INT 22
9964: PUSH
9965: LD_INT 3
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: PUSH
9972: LD_INT 30
9974: PUSH
9975: LD_INT 34
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: PPUSH
9986: CALL_OW 69
9990: ST_TO_ADDR
// if Prob ( 40 ) then
9991: LD_INT 40
9993: PPUSH
9994: CALL_OW 13
9998: IFFALSE 10125
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10000: LD_INT 2
10002: PPUSH
10003: LD_INT 22
10005: PUSH
10006: LD_INT 3
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 49
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 22
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 49
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_INT 22
10041: PUSH
10042: LD_INT 3
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 49
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: PUSH
10057: LD_INT 24
10059: PUSH
10060: LD_INT 3
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 46
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: PUSH
10075: LD_INT 24
10077: PUSH
10078: LD_INT 3
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 46
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 24
10095: PUSH
10096: LD_INT 3
10098: PUSH
10099: LD_INT 3
10101: PUSH
10102: LD_INT 46
10104: PUSH
10105: EMPTY
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: PPUSH
10119: CALL 45632 0 2
// end else
10123: GO 10248
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 24
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 47
10139: PUSH
10140: EMPTY
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: PUSH
10146: LD_INT 24
10148: PUSH
10149: LD_INT 3
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 47
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 24
10166: PUSH
10167: LD_INT 3
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 47
10175: PUSH
10176: EMPTY
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PUSH
10182: LD_INT 24
10184: PUSH
10185: LD_INT 3
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 46
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 24
10202: PUSH
10203: LD_INT 3
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 46
10211: PUSH
10212: EMPTY
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: PUSH
10218: LD_INT 24
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: LD_INT 3
10226: PUSH
10227: LD_INT 46
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL 45632 0 2
// end ; if Difficulty > 1 then
10248: LD_OWVAR 67
10252: PUSH
10253: LD_INT 1
10255: GREATER
10256: IFFALSE 10286
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10258: LD_INT 2
10260: PPUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 47
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: EMPTY
10280: LIST
10281: PPUSH
10282: CALL 45632 0 2
// repeat wait ( 0 0$1 ) ;
10286: LD_INT 35
10288: PPUSH
10289: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10293: LD_INT 2
10295: PPUSH
10296: LD_INT 1
10298: PPUSH
10299: CALL 47050 0 2
10303: PUSH
10304: LD_INT 6
10306: PUSH
10307: LD_INT 7
10309: PUSH
10310: LD_INT 7
10312: PUSH
10313: LD_INT 7
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: PUSH
10322: LD_OWVAR 67
10326: ARRAY
10327: GREATEREQUAL
10328: IFFALSE 10286
// wait ( 0 0$30 ) ;
10330: LD_INT 1050
10332: PPUSH
10333: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10337: LD_ADDR_VAR 0 2
10341: PUSH
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: CALL 47050 0 2
10352: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10353: LD_ADDR_EXP 113
10357: PUSH
10358: LD_EXP 113
10362: PPUSH
10363: LD_INT 2
10365: PPUSH
10366: LD_EXP 113
10370: PUSH
10371: LD_INT 2
10373: ARRAY
10374: PUSH
10375: LD_VAR 0 2
10379: DIFF
10380: PPUSH
10381: CALL_OW 1
10385: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10386: LD_ADDR_VAR 0 3
10390: PUSH
10391: LD_INT 0
10393: PPUSH
10394: LD_INT 1
10396: PPUSH
10397: CALL_OW 12
10401: ST_TO_ADDR
// if target then
10402: LD_VAR 0 3
10406: IFFALSE 10534
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10408: LD_ADDR_VAR 0 2
10412: PUSH
10413: LD_VAR 0 2
10417: PPUSH
10418: LD_INT 24
10420: PUSH
10421: LD_INT 250
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PPUSH
10428: CALL_OW 72
10432: ST_TO_ADDR
// for i in tmp do
10433: LD_ADDR_VAR 0 1
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: FOR_IN
10444: IFFALSE 10484
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10446: LD_VAR 0 1
10450: PPUSH
10451: LD_INT 139
10453: PPUSH
10454: LD_INT 89
10456: PPUSH
10457: CALL_OW 297
10461: PUSH
10462: LD_INT 9
10464: GREATER
10465: IFFALSE 10482
// ComMoveXY ( i , 139 , 89 ) ;
10467: LD_VAR 0 1
10471: PPUSH
10472: LD_INT 139
10474: PPUSH
10475: LD_INT 89
10477: PPUSH
10478: CALL_OW 111
10482: GO 10443
10484: POP
10485: POP
// wait ( 0 0$1 ) ;
10486: LD_INT 35
10488: PPUSH
10489: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10493: LD_VAR 0 2
10497: PPUSH
10498: LD_INT 92
10500: PUSH
10501: LD_INT 139
10503: PUSH
10504: LD_INT 89
10506: PUSH
10507: LD_INT 9
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: PPUSH
10516: CALL_OW 72
10520: PUSH
10521: LD_VAR 0 2
10525: PUSH
10526: LD_INT 1
10528: MINUS
10529: GREATEREQUAL
10530: IFFALSE 10408
// end else
10532: GO 10676
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 4
10543: PUSH
10544: LD_INT 1
10546: ARRAY
10547: PPUSH
10548: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10552: LD_ADDR_VAR 0 2
10556: PUSH
10557: LD_VAR 0 2
10561: PPUSH
10562: LD_INT 24
10564: PUSH
10565: LD_INT 250
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: PPUSH
10572: CALL_OW 72
10576: ST_TO_ADDR
// for i in tmp do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: FOR_IN
10588: IFFALSE 10628
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_INT 124
10597: PPUSH
10598: LD_INT 139
10600: PPUSH
10601: CALL_OW 297
10605: PUSH
10606: LD_INT 9
10608: GREATER
10609: IFFALSE 10626
// ComMoveXY ( i , 124 , 139 ) ;
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_INT 124
10618: PPUSH
10619: LD_INT 139
10621: PPUSH
10622: CALL_OW 111
10626: GO 10587
10628: POP
10629: POP
// wait ( 0 0$1 ) ;
10630: LD_INT 35
10632: PPUSH
10633: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10637: LD_VAR 0 2
10641: PPUSH
10642: LD_INT 92
10644: PUSH
10645: LD_INT 124
10647: PUSH
10648: LD_INT 139
10650: PUSH
10651: LD_INT 9
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 72
10664: PUSH
10665: LD_VAR 0 2
10669: PUSH
10670: LD_INT 1
10672: MINUS
10673: GREATEREQUAL
10674: IFFALSE 10552
// end ; repeat wait ( 0 0$1 ) ;
10676: LD_INT 35
10678: PPUSH
10679: CALL_OW 67
// for i in tmp do
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 2
10692: PUSH
10693: FOR_IN
10694: IFFALSE 10827
// begin if GetLives ( i ) > 251 then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 256
10705: PUSH
10706: LD_INT 251
10708: GREATER
10709: IFFALSE 10798
// begin if GetWeapon ( i ) = ru_time_lapser then
10711: LD_VAR 0 1
10715: PPUSH
10716: CALL_OW 264
10720: PUSH
10721: LD_INT 49
10723: EQUAL
10724: IFFALSE 10762
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_INT 81
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PPUSH
10741: CALL_OW 69
10745: PPUSH
10746: LD_VAR 0 1
10750: PPUSH
10751: CALL_OW 74
10755: PPUSH
10756: CALL_OW 112
10760: GO 10796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10762: LD_VAR 0 1
10766: PPUSH
10767: LD_INT 81
10769: PUSH
10770: LD_INT 3
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: PPUSH
10777: CALL_OW 69
10781: PPUSH
10782: LD_VAR 0 1
10786: PPUSH
10787: CALL_OW 74
10791: PPUSH
10792: CALL_OW 115
// end else
10796: GO 10825
// if IsDead ( i ) then
10798: LD_VAR 0 1
10802: PPUSH
10803: CALL_OW 301
10807: IFFALSE 10825
// tmp := tmp diff i ;
10809: LD_ADDR_VAR 0 2
10813: PUSH
10814: LD_VAR 0 2
10818: PUSH
10819: LD_VAR 0 1
10823: DIFF
10824: ST_TO_ADDR
// end ;
10825: GO 10693
10827: POP
10828: POP
// until not tmp ;
10829: LD_VAR 0 2
10833: NOT
10834: IFFALSE 10676
// end ;
10836: PPOPN 4
10838: END
// every 30 30$00 trigger not russianDestroyed do
10839: LD_EXP 2
10843: NOT
10844: IFFALSE 10913
10846: GO 10848
10848: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10849: LD_INT 105000
10851: PUSH
10852: LD_INT 84000
10854: PUSH
10855: LD_INT 63000
10857: PUSH
10858: LD_INT 52500
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: PUSH
10867: LD_OWVAR 67
10871: ARRAY
10872: PPUSH
10873: CALL_OW 67
// if russianDestroyed then
10877: LD_EXP 2
10881: IFFALSE 10885
// exit ;
10883: GO 10913
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10885: LD_INT 2
10887: PPUSH
10888: LD_INT 23
10890: PUSH
10891: LD_INT 3
10893: PUSH
10894: LD_INT 1
10896: PUSH
10897: LD_INT 48
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: PUSH
10906: EMPTY
10907: LIST
10908: PPUSH
10909: CALL 45632 0 2
// end ; end_of_file
10913: END
// export function CustomEvent ( event ) ; begin
10914: LD_INT 0
10916: PPUSH
// end ;
10917: LD_VAR 0 2
10921: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10922: LD_VAR 0 2
10926: PPUSH
10927: LD_VAR 0 3
10931: PPUSH
10932: LD_INT 15
10934: PPUSH
10935: CALL_OW 309
10939: IFFALSE 10948
// YouLost ( MothContaminate ) ;
10941: LD_STRING MothContaminate
10943: PPUSH
10944: CALL_OW 104
// end ;
10948: PPOPN 3
10950: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10951: LD_VAR 0 2
10955: PPUSH
10956: LD_VAR 0 3
10960: PPUSH
10961: LD_INT 15
10963: PPUSH
10964: CALL_OW 309
10968: IFFALSE 10984
// begin wait ( 0 0$6 ) ;
10970: LD_INT 210
10972: PPUSH
10973: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10977: LD_STRING MothContaminateBomb
10979: PPUSH
10980: CALL_OW 104
// end ; end ;
10984: PPOPN 3
10986: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10987: LD_VAR 0 1
10991: PPUSH
10992: CALL 108905 0 1
// if un = JMM then
10996: LD_VAR 0 1
11000: PUSH
11001: LD_EXP 19
11005: EQUAL
11006: IFFALSE 11017
// begin YouLost ( JMM ) ;
11008: LD_STRING JMM
11010: PPUSH
11011: CALL_OW 104
// exit ;
11015: GO 11146
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11017: LD_VAR 0 1
11021: PPUSH
11022: CALL_OW 255
11026: PUSH
11027: LD_INT 2
11029: EQUAL
11030: PUSH
11031: LD_EXP 18
11035: NOT
11036: AND
11037: IFFALSE 11047
// arabianAttacked := true ;
11039: LD_ADDR_EXP 18
11043: PUSH
11044: LD_INT 1
11046: ST_TO_ADDR
// if un = Powell then
11047: LD_VAR 0 1
11051: PUSH
11052: LD_EXP 54
11056: EQUAL
11057: IFFALSE 11067
// americanDestroyed := true ;
11059: LD_ADDR_EXP 4
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// if un = Platonov then
11067: LD_VAR 0 1
11071: PUSH
11072: LD_EXP 58
11076: EQUAL
11077: IFFALSE 11087
// russianDestroyed := true ;
11079: LD_ADDR_EXP 2
11083: PUSH
11084: LD_INT 1
11086: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11087: LD_VAR 0 1
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 7
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: LD_INT 21
11104: PUSH
11105: LD_INT 2
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PUSH
11112: EMPTY
11113: LIST
11114: LIST
11115: PPUSH
11116: CALL_OW 69
11120: IN
11121: IFFALSE 11137
// vehicleLostCounter := vehicleLostCounter + 1 ;
11123: LD_ADDR_EXP 15
11127: PUSH
11128: LD_EXP 15
11132: PUSH
11133: LD_INT 1
11135: PLUS
11136: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11137: LD_VAR 0 1
11141: PPUSH
11142: CALL 49052 0 1
// end ;
11146: PPOPN 1
11148: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11149: LD_VAR 0 1
11153: PPUSH
11154: LD_VAR 0 2
11158: PPUSH
11159: CALL 51386 0 2
// end ;
11163: PPOPN 2
11165: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11166: LD_VAR 0 1
11170: PPUSH
11171: CALL 50454 0 1
// end ;
11175: PPOPN 1
11177: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11178: LD_VAR 0 1
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 8
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 30
11195: PUSH
11196: LD_INT 2
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 23
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: IN
11223: IFFALSE 11250
// begin ComUpgrade ( building ) ;
11225: LD_VAR 0 1
11229: PPUSH
11230: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11234: LD_EXP 57
11238: PPUSH
11239: LD_VAR 0 1
11243: PPUSH
11244: CALL 60040 0 2
// exit ;
11248: GO 11259
// end ; MCE_BuildingComplete ( building ) ;
11250: LD_VAR 0 1
11254: PPUSH
11255: CALL 50695 0 1
// end ;
11259: PPOPN 1
11261: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11262: LD_VAR 0 1
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 48748 0 2
// end ;
11276: PPOPN 2
11278: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11279: LD_VAR 0 1
11283: PPUSH
11284: LD_VAR 0 2
11288: PPUSH
11289: LD_VAR 0 3
11293: PPUSH
11294: LD_VAR 0 4
11298: PPUSH
11299: LD_VAR 0 5
11303: PPUSH
11304: CALL 48368 0 5
// end ;
11308: PPOPN 5
11310: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11311: LD_VAR 0 1
11315: PPUSH
11316: LD_VAR 0 2
11320: PPUSH
11321: CALL 109027 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11325: LD_VAR 0 1
11329: PPUSH
11330: LD_VAR 0 2
11334: PPUSH
11335: CALL 47949 0 2
// end ;
11339: PPOPN 2
11341: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11342: LD_VAR 0 1
11346: PPUSH
11347: LD_VAR 0 2
11351: PPUSH
11352: LD_VAR 0 3
11356: PPUSH
11357: LD_VAR 0 4
11361: PPUSH
11362: CALL 47787 0 4
// end ;
11366: PPOPN 4
11368: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11369: LD_VAR 0 1
11373: PPUSH
11374: LD_VAR 0 2
11378: PPUSH
11379: LD_VAR 0 3
11383: PPUSH
11384: CALL 47562 0 3
// end ;
11388: PPOPN 3
11390: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11391: LD_VAR 0 1
11395: PPUSH
11396: LD_VAR 0 2
11400: PPUSH
11401: CALL 47447 0 2
// end ;
11405: PPOPN 2
11407: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11408: LD_VAR 0 1
11412: PPUSH
11413: LD_VAR 0 2
11417: PPUSH
11418: CALL 51681 0 2
// end ;
11422: PPOPN 2
11424: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11425: LD_VAR 0 1
11429: PPUSH
11430: LD_VAR 0 2
11434: PPUSH
11435: LD_VAR 0 3
11439: PPUSH
11440: LD_VAR 0 4
11444: PPUSH
11445: CALL 51897 0 4
// end ;
11449: PPOPN 4
11451: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_VAR 0 2
11461: PPUSH
11462: CALL 47256 0 2
// end ;
11466: PPOPN 2
11468: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11469: LD_VAR 0 1
11473: PPUSH
11474: CALL 109011 0 1
// end ; end_of_file
11478: PPOPN 1
11480: END
// export function Action ; begin
11481: LD_INT 0
11483: PPUSH
// InGameOn ;
11484: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11488: LD_INT 206
11490: PPUSH
11491: LD_INT 11
11493: PPUSH
11494: CALL_OW 86
// wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11505: LD_EXP 19
11509: PPUSH
11510: LD_STRING DStart-JMM-JMM-1
11512: PPUSH
11513: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11517: LD_EXP 51
11521: PPUSH
11522: LD_STRING DStart-JMM-Bur-1
11524: PPUSH
11525: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11529: LD_EXP 19
11533: PPUSH
11534: LD_STRING DStart-JMM-JMM-2
11536: PPUSH
11537: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11541: LD_EXP 51
11545: PPUSH
11546: LD_STRING DStart-JMM-Bur-2
11548: PPUSH
11549: CALL_OW 88
// InGameOff ;
11553: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11557: LD_STRING MStart
11559: PPUSH
11560: CALL_OW 337
// SaveForQuickRestart ;
11564: CALL_OW 22
// end ;
11568: LD_VAR 0 1
11572: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11573: LD_INT 7
11575: PPUSH
11576: LD_INT 255
11578: PPUSH
11579: LD_INT 219
11581: PPUSH
11582: CALL_OW 293
11586: IFFALSE 12195
11588: GO 11590
11590: DISABLE
11591: LD_INT 0
11593: PPUSH
// begin wait ( 0 0$3 ) ;
11594: LD_INT 105
11596: PPUSH
11597: CALL_OW 67
// alienSpotted := true ;
11601: LD_ADDR_EXP 10
11605: PUSH
11606: LD_INT 1
11608: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11609: LD_ADDR_VAR 0 1
11613: PUSH
11614: LD_INT 22
11616: PUSH
11617: LD_INT 7
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PUSH
11624: LD_INT 23
11626: PUSH
11627: LD_INT 3
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 21
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 26
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: EMPTY
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: PUSH
11665: LD_EXP 51
11669: PUSH
11670: LD_EXP 39
11674: PUSH
11675: LD_EXP 41
11679: PUSH
11680: LD_EXP 42
11684: PUSH
11685: LD_EXP 49
11689: PUSH
11690: LD_EXP 48
11694: PUSH
11695: LD_EXP 43
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: DIFF
11709: ST_TO_ADDR
// DialogueOn ;
11710: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11714: LD_INT 255
11716: PPUSH
11717: LD_INT 219
11719: PPUSH
11720: LD_INT 7
11722: PPUSH
11723: LD_INT 20
11725: NEG
11726: PPUSH
11727: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11731: LD_INT 255
11733: PPUSH
11734: LD_INT 219
11736: PPUSH
11737: CALL_OW 86
// if speaker then
11741: LD_VAR 0 1
11745: IFFALSE 11763
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11747: LD_VAR 0 1
11751: PUSH
11752: LD_INT 1
11754: ARRAY
11755: PPUSH
11756: LD_STRING DAlienBase-RSol1-1
11758: PPUSH
11759: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11763: LD_EXP 19
11767: PPUSH
11768: LD_STRING DAlienBase-JMM-1
11770: PPUSH
11771: CALL_OW 88
// if IsOk ( Burlak ) then
11775: LD_EXP 51
11779: PPUSH
11780: CALL_OW 302
11784: IFFALSE 11805
// begin dwait ( 0 0$1 ) ;
11786: LD_INT 35
11788: PPUSH
11789: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11793: LD_EXP 51
11797: PPUSH
11798: LD_STRING DAlienBase-Bur-1
11800: PPUSH
11801: CALL_OW 88
// end ; if IsOk ( Roth ) then
11805: LD_EXP 20
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Roth , DAlienBase-Roth-1 ) ;
11816: LD_EXP 20
11820: PPUSH
11821: LD_STRING DAlienBase-Roth-1
11823: PPUSH
11824: CALL_OW 88
// if IsOk ( Gossudarov ) then
11828: LD_EXP 37
11832: PPUSH
11833: CALL_OW 302
11837: IFFALSE 11853
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11839: LD_EXP 37
11843: PPUSH
11844: LD_STRING DAlienBase-Gos-1
11846: PPUSH
11847: CALL_OW 88
11851: GO 11970
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11853: LD_ADDR_VAR 0 1
11857: PUSH
11858: LD_INT 22
11860: PUSH
11861: LD_INT 7
11863: PUSH
11864: EMPTY
11865: LIST
11866: LIST
11867: PUSH
11868: LD_INT 25
11870: PUSH
11871: LD_INT 4
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: PUSH
11878: LD_INT 21
11880: PUSH
11881: LD_INT 1
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: PUSH
11888: LD_INT 26
11890: PUSH
11891: LD_INT 1
11893: PUSH
11894: EMPTY
11895: LIST
11896: LIST
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL_OW 69
11908: PUSH
11909: LD_EXP 20
11913: PUSH
11914: LD_EXP 19
11918: PUSH
11919: LD_EXP 51
11923: PUSH
11924: LD_EXP 39
11928: PUSH
11929: LD_EXP 49
11933: PUSH
11934: LD_EXP 48
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: DIFF
11947: ST_TO_ADDR
// if speaker then
11948: LD_VAR 0 1
11952: IFFALSE 11970
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11954: LD_VAR 0 1
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: LD_STRING DAlienBase-Sci1-1
11965: PPUSH
11966: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11970: LD_INT 255
11972: PPUSH
11973: LD_INT 219
11975: PPUSH
11976: LD_INT 7
11978: PPUSH
11979: CALL_OW 331
// DialogueOff ;
11983: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11987: LD_INT 35
11989: PPUSH
11990: CALL_OW 67
// until IsSelected ( alien ) ;
11994: LD_INT 1
11996: PPUSH
11997: CALL_OW 306
12001: IFFALSE 11987
// if not artifactIResearched or not artifactIIResearched then
12003: LD_EXP 12
12007: NOT
12008: PUSH
12009: LD_EXP 13
12013: NOT
12014: OR
12015: IFFALSE 12195
// begin if IsOk ( Roth ) then
12017: LD_EXP 20
12021: PPUSH
12022: CALL_OW 302
12026: IFFALSE 12042
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12028: LD_EXP 20
12032: PPUSH
12033: LD_STRING DAlieBaseNotReady-Roth-1
12035: PPUSH
12036: CALL_OW 88
12040: GO 12195
// if IsOk ( Gossudarov ) then
12042: LD_EXP 37
12046: PPUSH
12047: CALL_OW 302
12051: IFFALSE 12067
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12053: LD_EXP 37
12057: PPUSH
12058: LD_STRING DAlieBaseNotReady-Gos-1
12060: PPUSH
12061: CALL_OW 88
12065: GO 12195
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12067: LD_ADDR_VAR 0 1
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_INT 7
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 23
12084: PUSH
12085: LD_INT 3
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: LD_INT 25
12094: PUSH
12095: LD_INT 4
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: LD_INT 21
12104: PUSH
12105: LD_INT 1
12107: PUSH
12108: EMPTY
12109: LIST
12110: LIST
12111: PUSH
12112: LD_INT 26
12114: PUSH
12115: LD_INT 1
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PUSH
12122: EMPTY
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: PPUSH
12129: CALL_OW 69
12133: PUSH
12134: LD_EXP 20
12138: PUSH
12139: LD_EXP 19
12143: PUSH
12144: LD_EXP 51
12148: PUSH
12149: LD_EXP 39
12153: PUSH
12154: LD_EXP 49
12158: PUSH
12159: LD_EXP 48
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: DIFF
12172: ST_TO_ADDR
// if speaker then
12173: LD_VAR 0 1
12177: IFFALSE 12195
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12179: LD_VAR 0 1
12183: PUSH
12184: LD_INT 1
12186: ARRAY
12187: PPUSH
12188: LD_STRING DAlieBaseNotReady-RSci1-1
12190: PPUSH
12191: CALL_OW 88
// end ; end ; end ;
12195: PPOPN 1
12197: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12198: LD_INT 24
12200: PPUSH
12201: LD_INT 7
12203: PPUSH
12204: CALL_OW 321
12208: PUSH
12209: LD_INT 2
12211: EQUAL
12212: IFFALSE 12903
12214: GO 12216
12216: DISABLE
12217: LD_INT 0
12219: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12220: LD_ADDR_VAR 0 1
12224: PUSH
12225: LD_INT 22
12227: PUSH
12228: LD_INT 7
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 23
12237: PUSH
12238: LD_INT 3
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 25
12247: PUSH
12248: LD_INT 4
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PUSH
12255: LD_INT 21
12257: PUSH
12258: LD_INT 1
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 26
12267: PUSH
12268: LD_INT 1
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: LIST
12279: LIST
12280: LIST
12281: PPUSH
12282: CALL_OW 69
12286: PUSH
12287: LD_EXP 20
12291: PUSH
12292: LD_EXP 19
12296: PUSH
12297: LD_EXP 51
12301: PUSH
12302: LD_EXP 39
12306: PUSH
12307: LD_EXP 49
12311: PUSH
12312: LD_EXP 48
12316: PUSH
12317: EMPTY
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: DIFF
12325: ST_TO_ADDR
// if not speaker then
12326: LD_VAR 0 1
12330: NOT
12331: IFFALSE 12335
// exit ;
12333: GO 12903
// DialogueOn ;
12335: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12339: LD_VAR 0 1
12343: PUSH
12344: LD_INT 1
12346: ARRAY
12347: PPUSH
12348: LD_STRING DArtefTechnology-RSci1-1
12350: PPUSH
12351: CALL_OW 88
// if IsOk ( Burlak ) then
12355: LD_EXP 51
12359: PPUSH
12360: CALL_OW 302
12364: IFFALSE 12378
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12366: LD_EXP 51
12370: PPUSH
12371: LD_STRING DArtefTechnology-Bur-1
12373: PPUSH
12374: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12378: LD_VAR 0 1
12382: PUSH
12383: LD_INT 1
12385: ARRAY
12386: PPUSH
12387: LD_STRING DArtefTechnology-RSci1-2
12389: PPUSH
12390: CALL_OW 88
// if Denis then
12394: LD_EXP 25
12398: IFFALSE 12415
// speaker := [ Denis ] else
12400: LD_ADDR_VAR 0 1
12404: PUSH
12405: LD_EXP 25
12409: PUSH
12410: EMPTY
12411: LIST
12412: ST_TO_ADDR
12413: GO 12521
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12415: LD_ADDR_VAR 0 1
12419: PUSH
12420: LD_INT 22
12422: PUSH
12423: LD_INT 7
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: PUSH
12430: LD_INT 23
12432: PUSH
12433: LD_INT 1
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: PUSH
12440: LD_INT 25
12442: PUSH
12443: LD_INT 4
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 21
12452: PUSH
12453: LD_INT 1
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 26
12462: PUSH
12463: LD_INT 1
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: LIST
12474: LIST
12475: LIST
12476: PPUSH
12477: CALL_OW 69
12481: PUSH
12482: LD_EXP 20
12486: PUSH
12487: LD_EXP 19
12491: PUSH
12492: LD_EXP 51
12496: PUSH
12497: LD_EXP 39
12501: PUSH
12502: LD_EXP 49
12506: PUSH
12507: LD_EXP 48
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: DIFF
12520: ST_TO_ADDR
// if speaker then
12521: LD_VAR 0 1
12525: IFFALSE 12543
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12527: LD_VAR 0 1
12531: PUSH
12532: LD_INT 1
12534: ARRAY
12535: PPUSH
12536: LD_STRING DArtefTechnology-Sci1-2
12538: PPUSH
12539: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12543: LD_ADDR_VAR 0 1
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_INT 7
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PUSH
12558: LD_INT 23
12560: PUSH
12561: LD_INT 3
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PUSH
12568: LD_INT 25
12570: PUSH
12571: LD_INT 4
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: PUSH
12578: LD_INT 21
12580: PUSH
12581: LD_INT 1
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: PUSH
12588: LD_INT 26
12590: PUSH
12591: LD_INT 1
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: PUSH
12610: LD_EXP 20
12614: PUSH
12615: LD_EXP 19
12619: PUSH
12620: LD_EXP 51
12624: PUSH
12625: LD_EXP 39
12629: PUSH
12630: LD_EXP 49
12634: PUSH
12635: LD_EXP 48
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: DIFF
12648: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12649: LD_VAR 0 1
12653: PUSH
12654: LD_EXP 9
12658: PUSH
12659: LD_EXP 5
12663: OR
12664: AND
12665: IFFALSE 12899
// begin if arabianDestroyed and IsOk ( Burlak ) then
12667: LD_EXP 5
12671: PUSH
12672: LD_EXP 51
12676: PPUSH
12677: CALL_OW 302
12681: AND
12682: IFFALSE 12698
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12684: LD_EXP 51
12688: PPUSH
12689: LD_STRING DArtefTechnology-Bur-2
12691: PPUSH
12692: CALL_OW 88
12696: GO 12710
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12698: LD_EXP 19
12702: PPUSH
12703: LD_STRING DArtefTechnology-JMM-2
12705: PPUSH
12706: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12710: LD_VAR 0 1
12714: PUSH
12715: LD_INT 1
12717: ARRAY
12718: PPUSH
12719: LD_STRING DArtefTechnology-RSci1-3
12721: PPUSH
12722: CALL_OW 88
// if Denis then
12726: LD_EXP 25
12730: IFFALSE 12747
// speaker := [ Denis ] else
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_EXP 25
12741: PUSH
12742: EMPTY
12743: LIST
12744: ST_TO_ADDR
12745: GO 12853
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12747: LD_ADDR_VAR 0 1
12751: PUSH
12752: LD_INT 22
12754: PUSH
12755: LD_INT 7
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 23
12764: PUSH
12765: LD_INT 1
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: LD_INT 25
12774: PUSH
12775: LD_INT 4
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PUSH
12782: LD_INT 21
12784: PUSH
12785: LD_INT 1
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: PUSH
12792: LD_INT 26
12794: PUSH
12795: LD_INT 1
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: PPUSH
12809: CALL_OW 69
12813: PUSH
12814: LD_EXP 20
12818: PUSH
12819: LD_EXP 19
12823: PUSH
12824: LD_EXP 51
12828: PUSH
12829: LD_EXP 39
12833: PUSH
12834: LD_EXP 49
12838: PUSH
12839: LD_EXP 48
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: LIST
12851: DIFF
12852: ST_TO_ADDR
// if speaker then
12853: LD_VAR 0 1
12857: IFFALSE 12899
// if alienSpotted then
12859: LD_EXP 10
12863: IFFALSE 12883
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12865: LD_VAR 0 1
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: PPUSH
12874: LD_STRING DArtefTechnology-Sci1-3
12876: PPUSH
12877: CALL_OW 88
12881: GO 12899
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12883: LD_VAR 0 1
12887: PUSH
12888: LD_INT 1
12890: ARRAY
12891: PPUSH
12892: LD_STRING DArtefTechnology-Sci1-3a
12894: PPUSH
12895: CALL_OW 88
// end ; DialogueOff ;
12899: CALL_OW 7
// end ;
12903: PPOPN 1
12905: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12906: LD_EXP 12
12910: IFFALSE 13113
12912: GO 12914
12914: DISABLE
12915: LD_INT 0
12917: PPUSH
// begin if Denis then
12918: LD_EXP 25
12922: IFFALSE 12939
// speaker := [ Denis ] else
12924: LD_ADDR_VAR 0 1
12928: PUSH
12929: LD_EXP 25
12933: PUSH
12934: EMPTY
12935: LIST
12936: ST_TO_ADDR
12937: GO 13045
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12939: LD_ADDR_VAR 0 1
12943: PUSH
12944: LD_INT 22
12946: PUSH
12947: LD_INT 7
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 23
12956: PUSH
12957: LD_INT 1
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 4
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 21
12976: PUSH
12977: LD_INT 1
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 26
12986: PUSH
12987: LD_INT 1
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: PPUSH
13001: CALL_OW 69
13005: PUSH
13006: LD_EXP 20
13010: PUSH
13011: LD_EXP 19
13015: PUSH
13016: LD_EXP 51
13020: PUSH
13021: LD_EXP 39
13025: PUSH
13026: LD_EXP 49
13030: PUSH
13031: LD_EXP 48
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: DIFF
13044: ST_TO_ADDR
// if not speaker then
13045: LD_VAR 0 1
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13113
// DialogueOn ;
13054: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAm-Sci1-1
13069: PPUSH
13070: CALL_OW 88
// if IsOk ( Burlak ) then
13074: LD_EXP 51
13078: PPUSH
13079: CALL_OW 302
13083: IFFALSE 13097
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13085: LD_EXP 51
13089: PPUSH
13090: LD_STRING DArtefTechnologyAm-Bur-1
13092: PPUSH
13093: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13097: LD_EXP 19
13101: PPUSH
13102: LD_STRING DArtefTechnologyAm-JMM-1
13104: PPUSH
13105: CALL_OW 88
// DialogueOff ;
13109: CALL_OW 7
// end ;
13113: PPOPN 1
13115: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13116: LD_EXP 13
13120: IFFALSE 13322
13122: GO 13124
13124: DISABLE
13125: LD_INT 0
13127: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13128: LD_ADDR_VAR 0 1
13132: PUSH
13133: LD_INT 22
13135: PUSH
13136: LD_INT 7
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 23
13145: PUSH
13146: LD_INT 3
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PUSH
13153: LD_INT 25
13155: PUSH
13156: LD_INT 4
13158: PUSH
13159: EMPTY
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 21
13165: PUSH
13166: LD_INT 1
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 26
13175: PUSH
13176: LD_INT 1
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PPUSH
13190: CALL_OW 69
13194: PUSH
13195: LD_EXP 20
13199: PUSH
13200: LD_EXP 19
13204: PUSH
13205: LD_EXP 51
13209: PUSH
13210: LD_EXP 39
13214: PUSH
13215: LD_EXP 49
13219: PUSH
13220: LD_EXP 48
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: DIFF
13233: ST_TO_ADDR
// if not speaker then
13234: LD_VAR 0 1
13238: NOT
13239: IFFALSE 13243
// exit ;
13241: GO 13322
// DialogueOn ;
13243: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13247: LD_VAR 0 1
13251: PUSH
13252: LD_VAR 0 1
13256: ARRAY
13257: PPUSH
13258: LD_STRING DArtefTechnologyRu-RSci1-1
13260: PPUSH
13261: CALL_OW 88
// if IsOk ( Burlak ) then
13265: LD_EXP 51
13269: PPUSH
13270: CALL_OW 302
13274: IFFALSE 13288
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13276: LD_EXP 51
13280: PPUSH
13281: LD_STRING DArtefTechnologyRu-Bur-1
13283: PPUSH
13284: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13288: LD_VAR 0 1
13292: PUSH
13293: LD_VAR 0 1
13297: ARRAY
13298: PPUSH
13299: LD_STRING DArtefTechnologyRu-RSci1-2
13301: PPUSH
13302: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13306: LD_EXP 19
13310: PPUSH
13311: LD_STRING DArtefTechnologyRu-JMM-1
13313: PPUSH
13314: CALL_OW 88
// DialogueOff ;
13318: CALL_OW 7
// end ;
13322: PPOPN 1
13324: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13325: LD_INT 24
13327: PPUSH
13328: LD_INT 7
13330: PPUSH
13331: CALL_OW 321
13335: PUSH
13336: LD_INT 2
13338: EQUAL
13339: PUSH
13340: LD_INT 1
13342: PPUSH
13343: CALL_OW 255
13347: PUSH
13348: LD_INT 7
13350: EQUAL
13351: AND
13352: IFFALSE 13520
13354: GO 13356
13356: DISABLE
13357: LD_INT 0
13359: PPUSH
// begin if Denis then
13360: LD_EXP 25
13364: IFFALSE 13381
// speaker := [ Denis ] else
13366: LD_ADDR_VAR 0 1
13370: PUSH
13371: LD_EXP 25
13375: PUSH
13376: EMPTY
13377: LIST
13378: ST_TO_ADDR
13379: GO 13487
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13381: LD_ADDR_VAR 0 1
13385: PUSH
13386: LD_INT 22
13388: PUSH
13389: LD_INT 7
13391: PUSH
13392: EMPTY
13393: LIST
13394: LIST
13395: PUSH
13396: LD_INT 23
13398: PUSH
13399: LD_INT 1
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 25
13408: PUSH
13409: LD_INT 4
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 21
13418: PUSH
13419: LD_INT 1
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: LD_INT 26
13428: PUSH
13429: LD_INT 1
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 69
13447: PUSH
13448: LD_EXP 20
13452: PUSH
13453: LD_EXP 19
13457: PUSH
13458: LD_EXP 51
13462: PUSH
13463: LD_EXP 39
13467: PUSH
13468: LD_EXP 49
13472: PUSH
13473: LD_EXP 48
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: DIFF
13486: ST_TO_ADDR
// if not speaker then
13487: LD_VAR 0 1
13491: NOT
13492: IFFALSE 13496
// exit ;
13494: GO 13520
// DialogueOn ;
13496: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13500: LD_VAR 0 1
13504: PUSH
13505: LD_INT 1
13507: ARRAY
13508: PPUSH
13509: LD_STRING DArtefTechnologyArStart-Sci1-1
13511: PPUSH
13512: CALL_OW 88
// DialogueOff ;
13516: CALL_OW 7
// end ;
13520: PPOPN 1
13522: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13523: LD_EXP 14
13527: IFFALSE 13808
13529: GO 13531
13531: DISABLE
13532: LD_INT 0
13534: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13535: LD_ADDR_VAR 0 1
13539: PUSH
13540: LD_INT 22
13542: PUSH
13543: LD_INT 7
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PUSH
13550: LD_INT 23
13552: PUSH
13553: LD_INT 3
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PUSH
13560: LD_INT 25
13562: PUSH
13563: LD_INT 4
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PUSH
13570: LD_INT 21
13572: PUSH
13573: LD_INT 1
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PUSH
13580: LD_INT 26
13582: PUSH
13583: LD_INT 1
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 69
13601: PUSH
13602: LD_EXP 20
13606: PUSH
13607: LD_EXP 19
13611: PUSH
13612: LD_EXP 51
13616: PUSH
13617: LD_EXP 39
13621: PUSH
13622: LD_EXP 49
13626: PUSH
13627: LD_EXP 48
13631: PUSH
13632: EMPTY
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: DIFF
13640: ST_TO_ADDR
// if not speaker then
13641: LD_VAR 0 1
13645: NOT
13646: IFFALSE 13650
// exit ;
13648: GO 13808
// DialogueOn ;
13650: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13654: LD_VAR 0 1
13658: PUSH
13659: LD_INT 1
13661: ARRAY
13662: PPUSH
13663: LD_STRING DArtefTechnologyAr-RSci1-1
13665: PPUSH
13666: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13670: LD_EXP 19
13674: PPUSH
13675: LD_STRING DArtefTechnologyAr-JMM-1
13677: PPUSH
13678: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13682: LD_VAR 0 1
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PPUSH
13691: LD_STRING DArtefTechnologyAr-RSci1-2
13693: PPUSH
13694: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13698: LD_EXP 19
13702: PPUSH
13703: LD_STRING DArtefTechnologyAr-JMM-2
13705: PPUSH
13706: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13710: LD_VAR 0 1
13714: PUSH
13715: LD_INT 1
13717: ARRAY
13718: PPUSH
13719: LD_STRING DArtefTechnologyAr-RSci1-3
13721: PPUSH
13722: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13726: LD_EXP 19
13730: PPUSH
13731: LD_STRING DArtefTechnologyAr-JMM-3
13733: PPUSH
13734: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13738: LD_VAR 0 1
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: PPUSH
13747: LD_STRING DArtefTechnologyAr-RSci1-4
13749: PPUSH
13750: CALL_OW 88
// if IsOk ( Burlak ) then
13754: LD_EXP 51
13758: PPUSH
13759: CALL_OW 302
13763: IFFALSE 13777
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13765: LD_EXP 51
13769: PPUSH
13770: LD_STRING DArtefTechnologyAr-Bur-4
13772: PPUSH
13773: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13777: LD_EXP 19
13781: PPUSH
13782: LD_STRING DArtefTechnologyAr-JMM-4
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// wait ( 0 0$45 ) ;
13793: LD_INT 1575
13795: PPUSH
13796: CALL_OW 67
// spawnOmar := true ;
13800: LD_ADDR_EXP 11
13804: PUSH
13805: LD_INT 1
13807: ST_TO_ADDR
// end ;
13808: PPOPN 1
13810: END
// every 0 0$1 trigger spawnOmar do
13811: LD_EXP 11
13815: IFFALSE 14195
13817: GO 13819
13819: DISABLE
// begin PrepareOmarAli ;
13820: CALL 7201 0 0
// if not HasTask ( Omar ) then
13824: LD_EXP 55
13828: PPUSH
13829: CALL_OW 314
13833: NOT
13834: IFFALSE 13851
// ComMoveXY ( Omar , 252 , 220 ) ;
13836: LD_EXP 55
13840: PPUSH
13841: LD_INT 252
13843: PPUSH
13844: LD_INT 220
13846: PPUSH
13847: CALL_OW 111
// if not Omar then
13851: LD_EXP 55
13855: NOT
13856: IFFALSE 13860
// exit ;
13858: GO 14195
// repeat wait ( 0 0$1 ) ;
13860: LD_INT 35
13862: PPUSH
13863: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13867: LD_EXP 55
13871: PPUSH
13872: CALL_OW 314
13876: NOT
13877: PUSH
13878: LD_EXP 55
13882: PPUSH
13883: LD_INT 252
13885: PPUSH
13886: LD_INT 220
13888: PPUSH
13889: CALL_OW 297
13893: PUSH
13894: LD_INT 6
13896: GREATER
13897: AND
13898: IFFALSE 13915
// ComMoveXY ( Omar , 252 , 220 ) ;
13900: LD_EXP 55
13904: PPUSH
13905: LD_INT 252
13907: PPUSH
13908: LD_INT 220
13910: PPUSH
13911: CALL_OW 111
// until See ( 7 , Omar ) ;
13915: LD_INT 7
13917: PPUSH
13918: LD_EXP 55
13922: PPUSH
13923: CALL_OW 292
13927: IFFALSE 13860
// CenterNowOnUnits ( Omar ) ;
13929: LD_EXP 55
13933: PPUSH
13934: CALL_OW 87
// DialogueOn ;
13938: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13942: LD_EXP 55
13946: PPUSH
13947: LD_STRING DOmar-Omar-1
13949: PPUSH
13950: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13954: LD_EXP 19
13958: PPUSH
13959: LD_STRING DOmar-JMM-1
13961: PPUSH
13962: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13966: LD_EXP 55
13970: PPUSH
13971: LD_STRING DOmar-Omar-2
13973: PPUSH
13974: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13978: LD_EXP 19
13982: PPUSH
13983: LD_STRING DOmar-JMM-2
13985: PPUSH
13986: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13990: LD_EXP 55
13994: PPUSH
13995: LD_STRING DOmar-Omar-3
13997: PPUSH
13998: CALL_OW 88
// if IsOk ( Burlak ) then
14002: LD_EXP 51
14006: PPUSH
14007: CALL_OW 302
14011: IFFALSE 14027
// Say ( Burlak , DOmar-Bur-3 ) else
14013: LD_EXP 51
14017: PPUSH
14018: LD_STRING DOmar-Bur-3
14020: PPUSH
14021: CALL_OW 88
14025: GO 14039
// Say ( JMM , DOmar-JMM-3 ) ;
14027: LD_EXP 19
14031: PPUSH
14032: LD_STRING DOmar-JMM-3
14034: PPUSH
14035: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14039: LD_EXP 55
14043: PPUSH
14044: LD_STRING DOmar-Omar-4
14046: PPUSH
14047: CALL_OW 88
// case Query ( QAccept ) of 1 :
14051: LD_STRING QAccept
14053: PPUSH
14054: CALL_OW 97
14058: PUSH
14059: LD_INT 1
14061: DOUBLE
14062: EQUAL
14063: IFTRUE 14067
14065: GO 14103
14067: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14068: LD_EXP 19
14072: PPUSH
14073: LD_STRING DQrAccept#1-JMM-1
14075: PPUSH
14076: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14080: LD_EXP 55
14084: PPUSH
14085: LD_INT 7
14087: PPUSH
14088: CALL_OW 235
// ComStop ( Omar ) ;
14092: LD_EXP 55
14096: PPUSH
14097: CALL_OW 141
// end ; 2 :
14101: GO 14152
14103: LD_INT 2
14105: DOUBLE
14106: EQUAL
14107: IFTRUE 14111
14109: GO 14151
14111: POP
// begin if IsOk ( Burlak ) then
14112: LD_EXP 51
14116: PPUSH
14117: CALL_OW 302
14121: IFFALSE 14137
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14123: LD_EXP 51
14127: PPUSH
14128: LD_STRING DQrAccept#2-Bur-1
14130: PPUSH
14131: CALL_OW 88
14135: GO 14149
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14137: LD_EXP 19
14141: PPUSH
14142: LD_STRING DQrAccept#2-JMM-1
14144: PPUSH
14145: CALL_OW 88
// end ; end ;
14149: GO 14152
14151: POP
// DialogueOff ;
14152: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14156: LD_EXP 55
14160: PPUSH
14161: CALL_OW 255
14165: PUSH
14166: LD_INT 7
14168: EQUAL
14169: IFFALSE 14180
// begin SetAchievement ( ACH_OMAR ) ;
14171: LD_STRING ACH_OMAR
14173: PPUSH
14174: CALL_OW 543
// exit ;
14178: GO 14195
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14180: LD_EXP 55
14184: PPUSH
14185: LD_INT 202
14187: PPUSH
14188: LD_INT 115
14190: PPUSH
14191: CALL_OW 111
// end ;
14195: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14196: LD_EXP 55
14200: PPUSH
14201: LD_INT 200
14203: PPUSH
14204: LD_INT 98
14206: PPUSH
14207: CALL_OW 297
14211: PUSH
14212: LD_INT 40
14214: LESS
14215: PUSH
14216: LD_EXP 2
14220: AND
14221: IFFALSE 14439
14223: GO 14225
14225: DISABLE
// begin SetSide ( Omar , 5 ) ;
14226: LD_EXP 55
14230: PPUSH
14231: LD_INT 5
14233: PPUSH
14234: CALL_OW 235
// if IsInUnit ( Omar ) then
14238: LD_EXP 55
14242: PPUSH
14243: CALL_OW 310
14247: IFFALSE 14258
// ComExitVehicle ( Omar ) ;
14249: LD_EXP 55
14253: PPUSH
14254: CALL_OW 121
// if IsInUnit ( Omar ) then
14258: LD_EXP 55
14262: PPUSH
14263: CALL_OW 310
14267: IFFALSE 14278
// ComExitBuilding ( Omar ) ;
14269: LD_EXP 55
14273: PPUSH
14274: CALL_OW 122
// wait ( 0 0$1 ) ;
14278: LD_INT 35
14280: PPUSH
14281: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14285: LD_EXP 55
14289: PPUSH
14290: LD_INT 203
14292: PPUSH
14293: LD_INT 120
14295: PPUSH
14296: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14300: LD_INT 35
14302: PPUSH
14303: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14307: LD_EXP 55
14311: PPUSH
14312: CALL_OW 306
14316: PUSH
14317: LD_EXP 55
14321: PPUSH
14322: LD_INT 203
14324: PPUSH
14325: LD_INT 120
14327: PPUSH
14328: CALL_OW 297
14332: PUSH
14333: LD_INT 6
14335: LESS
14336: OR
14337: IFFALSE 14300
// CenterNowOnUnits ( Omar ) ;
14339: LD_EXP 55
14343: PPUSH
14344: CALL_OW 87
// DialogueOn ;
14348: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14352: LD_EXP 19
14356: PPUSH
14357: LD_STRING DOmarContam-JMM-1
14359: PPUSH
14360: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14364: LD_EXP 55
14368: PPUSH
14369: LD_STRING DOmarContam-Omar-1
14371: PPUSH
14372: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14376: LD_EXP 19
14380: PPUSH
14381: LD_STRING DOmarContam-JMM-2
14383: PPUSH
14384: CALL_OW 88
// DialogueOff ;
14388: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14392: LD_INT 5
14394: PPUSH
14395: LD_INT 7
14397: PPUSH
14398: LD_INT 2
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14408: LD_INT 105
14410: PPUSH
14411: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14415: LD_EXP 55
14419: PPUSH
14420: LD_INT 203
14422: PPUSH
14423: LD_INT 120
14425: PPUSH
14426: CALL_OW 307
14430: IFFALSE 14408
// YouLost ( MothContaminate ) ;
14432: LD_STRING MothContaminate
14434: PPUSH
14435: CALL_OW 104
// end ;
14439: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14440: LD_EXP 4
14444: NOT
14445: PUSH
14446: LD_INT 22
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 34
14458: PUSH
14459: LD_INT 8
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: AND
14475: IFFALSE 14594
14477: GO 14479
14479: DISABLE
// begin wait ( 0 0$5 ) ;
14480: LD_INT 175
14482: PPUSH
14483: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14487: LD_EXP 54
14491: PPUSH
14492: CALL_OW 302
14496: NOT
14497: PUSH
14498: LD_INT 22
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: LD_INT 34
14510: PUSH
14511: LD_INT 8
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PPUSH
14522: CALL_OW 69
14526: NOT
14527: OR
14528: IFFALSE 14532
// exit ;
14530: GO 14594
// DialogueOn ;
14532: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14536: LD_EXP 54
14540: PPUSH
14541: LD_STRING DWinAmericans-Pow-1
14543: PPUSH
14544: CALL_OW 94
// if IsOk ( Burlak ) then
14548: LD_EXP 51
14552: PPUSH
14553: CALL_OW 302
14557: IFFALSE 14571
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14559: LD_EXP 51
14563: PPUSH
14564: LD_STRING DWinAmericans-Bur-1
14566: PPUSH
14567: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14571: LD_EXP 19
14575: PPUSH
14576: LD_STRING DWinAmericans-JMM-1
14578: PPUSH
14579: CALL_OW 88
// DialogueOff ;
14583: CALL_OW 7
// YouLost ( AmBomb ) ;
14587: LD_STRING AmBomb
14589: PPUSH
14590: CALL_OW 104
// end ;
14594: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14595: LD_EXP 2
14599: NOT
14600: PUSH
14601: LD_INT 22
14603: PUSH
14604: LD_INT 3
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: PUSH
14611: LD_INT 34
14613: PUSH
14614: LD_INT 48
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PPUSH
14625: CALL_OW 69
14629: AND
14630: IFFALSE 14749
14632: GO 14634
14634: DISABLE
// begin wait ( 0 0$5 ) ;
14635: LD_INT 175
14637: PPUSH
14638: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14642: LD_EXP 58
14646: PPUSH
14647: CALL_OW 302
14651: NOT
14652: PUSH
14653: LD_INT 22
14655: PUSH
14656: LD_INT 3
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 34
14665: PUSH
14666: LD_INT 48
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PPUSH
14677: CALL_OW 69
14681: NOT
14682: OR
14683: IFFALSE 14687
// exit ;
14685: GO 14749
// DialogueOn ;
14687: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14691: LD_EXP 58
14695: PPUSH
14696: LD_STRING DWinRussians-Pla-1
14698: PPUSH
14699: CALL_OW 94
// if IsOk ( Burlak ) then
14703: LD_EXP 51
14707: PPUSH
14708: CALL_OW 302
14712: IFFALSE 14726
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14714: LD_EXP 51
14718: PPUSH
14719: LD_STRING DWinRussians-Bur-1
14721: PPUSH
14722: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14726: LD_EXP 19
14730: PPUSH
14731: LD_STRING DWinRussians-JMM-1
14733: PPUSH
14734: CALL_OW 88
// DialogueOff ;
14738: CALL_OW 7
// YouLost ( RuBomb ) ;
14742: LD_STRING RuBomb
14744: PPUSH
14745: CALL_OW 104
// end ;
14749: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14750: LD_INT 7
14752: PPUSH
14753: LD_INT 22
14755: PUSH
14756: LD_INT 7
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PPUSH
14763: CALL_OW 70
14767: PUSH
14768: LD_EXP 4
14772: NOT
14773: AND
14774: IFFALSE 14803
14776: GO 14778
14778: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14779: LD_EXP 54
14783: PPUSH
14784: LD_STRING DSurrenderAmericans-Pow-1
14786: PPUSH
14787: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14791: LD_EXP 19
14795: PPUSH
14796: LD_STRING DSurrenderAmericans-JMM-1
14798: PPUSH
14799: CALL_OW 88
// end ;
14803: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14804: LD_INT 2
14806: PPUSH
14807: LD_INT 22
14809: PUSH
14810: LD_INT 7
14812: PUSH
14813: EMPTY
14814: LIST
14815: LIST
14816: PPUSH
14817: CALL_OW 70
14821: PUSH
14822: LD_EXP 2
14826: NOT
14827: AND
14828: PUSH
14829: LD_EXP 51
14833: AND
14834: IFFALSE 14863
14836: GO 14838
14838: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14839: LD_EXP 58
14843: PPUSH
14844: LD_STRING DSurrenderRussians-Pla-1
14846: PPUSH
14847: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14851: LD_EXP 51
14855: PPUSH
14856: LD_STRING DSurrenderRussians-Bur-1
14858: PPUSH
14859: CALL_OW 88
// end ;
14863: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14864: LD_EXP 4
14868: IFFALSE 15251
14870: GO 14872
14872: DISABLE
14873: LD_INT 0
14875: PPUSH
14876: PPUSH
14877: PPUSH
// begin MC_Kill ( 4 ) ;
14878: LD_INT 4
14880: PPUSH
14881: CALL 21654 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14885: LD_INT 1
14887: PPUSH
14888: LD_INT 7
14890: PPUSH
14891: LD_INT 1
14893: PPUSH
14894: LD_INT 1
14896: PPUSH
14897: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14901: LD_ADDR_VAR 0 3
14905: PUSH
14906: LD_INT 22
14908: PUSH
14909: LD_INT 1
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 26
14918: PUSH
14919: LD_INT 1
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: PUSH
14926: LD_INT 23
14928: PUSH
14929: LD_INT 1
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: PUSH
14946: LD_EXP 54
14950: PUSH
14951: LD_EXP 27
14955: PUSH
14956: LD_EXP 24
14960: PUSH
14961: LD_EXP 23
14965: PUSH
14966: LD_EXP 30
14970: PUSH
14971: LD_EXP 28
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: DIFF
14984: ST_TO_ADDR
// if speaker then
14985: LD_VAR 0 3
14989: IFFALSE 15015
// begin DialogueOn ;
14991: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14995: LD_VAR 0 3
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PPUSH
15004: LD_STRING DSurrenderAmericans-Sol1-1a
15006: PPUSH
15007: CALL_OW 94
// DialogueOff ;
15011: CALL_OW 7
// end ; americanCapitulated := true ;
15015: LD_ADDR_EXP 6
15019: PUSH
15020: LD_INT 1
15022: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15023: LD_ADDR_VAR 0 2
15027: PUSH
15028: LD_INT 22
15030: PUSH
15031: LD_INT 1
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: PUSH
15038: LD_INT 21
15040: PUSH
15041: LD_INT 1
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PPUSH
15052: CALL_OW 69
15056: PUSH
15057: LD_INT 22
15059: PUSH
15060: LD_INT 1
15062: PUSH
15063: EMPTY
15064: LIST
15065: LIST
15066: PUSH
15067: LD_INT 21
15069: PUSH
15070: LD_INT 2
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PUSH
15077: LD_INT 1
15079: PUSH
15080: EMPTY
15081: LIST
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PPUSH
15088: CALL_OW 69
15092: ADD
15093: ST_TO_ADDR
// if tmp then
15094: LD_VAR 0 2
15098: IFFALSE 15251
// repeat wait ( 0 0$1 ) ;
15100: LD_INT 35
15102: PPUSH
15103: CALL_OW 67
// for i in tmp do
15107: LD_ADDR_VAR 0 1
15111: PUSH
15112: LD_VAR 0 2
15116: PUSH
15117: FOR_IN
15118: IFFALSE 15200
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15120: LD_VAR 0 1
15124: PPUSH
15125: CALL_OW 310
15129: PUSH
15130: LD_VAR 0 1
15134: PPUSH
15135: CALL_OW 310
15139: PPUSH
15140: CALL_OW 247
15144: PUSH
15145: LD_INT 3
15147: EQUAL
15148: AND
15149: IFFALSE 15160
// ComExitBuilding ( i ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15160: LD_VAR 0 1
15164: PPUSH
15165: LD_INT 122
15167: PPUSH
15168: LD_INT 242
15170: PPUSH
15171: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15175: LD_VAR 0 1
15179: PPUSH
15180: LD_INT 35
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( i ) ;
15189: LD_VAR 0 1
15193: PPUSH
15194: CALL_OW 64
// end ;
15198: GO 15117
15200: POP
15201: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15202: LD_INT 22
15204: PUSH
15205: LD_INT 1
15207: PUSH
15208: EMPTY
15209: LIST
15210: LIST
15211: PUSH
15212: LD_INT 2
15214: PUSH
15215: LD_INT 21
15217: PUSH
15218: LD_INT 1
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 33
15227: PUSH
15228: LD_INT 1
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: LIST
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: PPUSH
15244: CALL_OW 69
15248: NOT
15249: IFFALSE 15100
// end ;
15251: PPOPN 3
15253: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15254: LD_EXP 2
15258: IFFALSE 15659
15260: GO 15262
15262: DISABLE
15263: LD_INT 0
15265: PPUSH
15266: PPUSH
15267: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15268: LD_INT 35
15270: PPUSH
15271: CALL_OW 67
// until IsDead ( Yakotich ) ;
15275: LD_EXP 59
15279: PPUSH
15280: CALL_OW 301
15284: IFFALSE 15268
// MC_Kill ( 2 ) ;
15286: LD_INT 2
15288: PPUSH
15289: CALL 21654 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15293: LD_INT 3
15295: PPUSH
15296: LD_INT 7
15298: PPUSH
15299: LD_INT 1
15301: PPUSH
15302: LD_INT 1
15304: PPUSH
15305: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15309: LD_ADDR_VAR 0 3
15313: PUSH
15314: LD_INT 22
15316: PUSH
15317: LD_INT 3
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 26
15326: PUSH
15327: LD_INT 1
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: PUSH
15334: LD_INT 23
15336: PUSH
15337: LD_INT 3
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: LIST
15348: PPUSH
15349: CALL_OW 69
15353: PUSH
15354: LD_EXP 58
15358: PUSH
15359: LD_EXP 59
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: DIFF
15368: ST_TO_ADDR
// if speaker then
15369: LD_VAR 0 3
15373: IFFALSE 15423
// begin DialogueOn ;
15375: CALL_OW 6
// if Burlak then
15379: LD_EXP 51
15383: IFFALSE 15403
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15385: LD_VAR 0 3
15389: PUSH
15390: LD_INT 1
15392: ARRAY
15393: PPUSH
15394: LD_STRING DSurrenderRussians-RSol1-1
15396: PPUSH
15397: CALL_OW 94
15401: GO 15419
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15403: LD_VAR 0 3
15407: PUSH
15408: LD_INT 1
15410: ARRAY
15411: PPUSH
15412: LD_STRING DSurrenderRussians-RSol1-1a
15414: PPUSH
15415: CALL_OW 94
// DialogueOff ;
15419: CALL_OW 7
// end ; russianCapitulated := true ;
15423: LD_ADDR_EXP 7
15427: PUSH
15428: LD_INT 1
15430: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15431: LD_ADDR_VAR 0 2
15435: PUSH
15436: LD_INT 22
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: LD_INT 21
15448: PUSH
15449: LD_INT 1
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 69
15464: PUSH
15465: LD_INT 22
15467: PUSH
15468: LD_INT 3
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PUSH
15475: LD_INT 21
15477: PUSH
15478: LD_INT 2
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: LIST
15495: PPUSH
15496: CALL_OW 69
15500: ADD
15501: ST_TO_ADDR
// if tmp then
15502: LD_VAR 0 2
15506: IFFALSE 15659
// repeat wait ( 0 0$1 ) ;
15508: LD_INT 35
15510: PPUSH
15511: CALL_OW 67
// for i in tmp do
15515: LD_ADDR_VAR 0 1
15519: PUSH
15520: LD_VAR 0 2
15524: PUSH
15525: FOR_IN
15526: IFFALSE 15608
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15528: LD_VAR 0 1
15532: PPUSH
15533: CALL_OW 310
15537: PUSH
15538: LD_VAR 0 1
15542: PPUSH
15543: CALL_OW 310
15547: PPUSH
15548: CALL_OW 247
15552: PUSH
15553: LD_INT 3
15555: EQUAL
15556: AND
15557: IFFALSE 15568
// ComExitBuilding ( i ) ;
15559: LD_VAR 0 1
15563: PPUSH
15564: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15568: LD_VAR 0 1
15572: PPUSH
15573: LD_INT 154
15575: PPUSH
15576: LD_INT 1
15578: PPUSH
15579: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15583: LD_VAR 0 1
15587: PPUSH
15588: LD_INT 36
15590: PPUSH
15591: CALL_OW 308
15595: IFFALSE 15606
// RemoveUnit ( i ) ;
15597: LD_VAR 0 1
15601: PPUSH
15602: CALL_OW 64
// end ;
15606: GO 15525
15608: POP
15609: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15610: LD_INT 22
15612: PUSH
15613: LD_INT 3
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PUSH
15620: LD_INT 2
15622: PUSH
15623: LD_INT 21
15625: PUSH
15626: LD_INT 1
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 33
15635: PUSH
15636: LD_INT 1
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: NOT
15657: IFFALSE 15508
// end ;
15659: PPOPN 3
15661: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15662: LD_INT 22
15664: PUSH
15665: LD_INT 8
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 21
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: LD_INT 23
15684: PUSH
15685: LD_INT 2
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: PPUSH
15697: CALL_OW 69
15701: PUSH
15702: LD_INT 18
15704: LESS
15705: PUSH
15706: LD_EXP 57
15710: PPUSH
15711: CALL_OW 301
15715: OR
15716: PUSH
15717: LD_INT 324
15719: PPUSH
15720: CALL_OW 255
15724: PUSH
15725: LD_INT 7
15727: EQUAL
15728: OR
15729: IFFALSE 15742
15731: GO 15733
15733: DISABLE
// legionDestroyed := true ;
15734: LD_ADDR_EXP 3
15738: PUSH
15739: LD_INT 1
15741: ST_TO_ADDR
15742: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15743: LD_INT 22
15745: PUSH
15746: LD_INT 2
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 1
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 23
15765: PUSH
15766: LD_INT 2
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: LIST
15777: PPUSH
15778: CALL_OW 69
15782: PUSH
15783: LD_INT 9
15785: LESS
15786: IFFALSE 15799
15788: GO 15790
15790: DISABLE
// arabianDestroyed := true ;
15791: LD_ADDR_EXP 5
15795: PUSH
15796: LD_INT 1
15798: ST_TO_ADDR
15799: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15800: LD_EXP 5
15804: IFFALSE 16048
15806: GO 15808
15808: DISABLE
15809: LD_INT 0
15811: PPUSH
15812: PPUSH
// begin MC_Kill ( 1 ) ;
15813: LD_INT 1
15815: PPUSH
15816: CALL 21654 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15820: LD_ADDR_VAR 0 2
15824: PUSH
15825: LD_INT 22
15827: PUSH
15828: LD_INT 2
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 21
15837: PUSH
15838: LD_INT 1
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 22
15856: PUSH
15857: LD_INT 8
15859: PUSH
15860: EMPTY
15861: LIST
15862: LIST
15863: PUSH
15864: LD_INT 21
15866: PUSH
15867: LD_INT 2
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: LIST
15884: PPUSH
15885: CALL_OW 69
15889: ADD
15890: ST_TO_ADDR
// if tmp then
15891: LD_VAR 0 2
15895: IFFALSE 16048
// repeat wait ( 0 0$1 ) ;
15897: LD_INT 35
15899: PPUSH
15900: CALL_OW 67
// for i in tmp do
15904: LD_ADDR_VAR 0 1
15908: PUSH
15909: LD_VAR 0 2
15913: PUSH
15914: FOR_IN
15915: IFFALSE 15997
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15917: LD_VAR 0 1
15921: PPUSH
15922: CALL_OW 310
15926: PUSH
15927: LD_VAR 0 1
15931: PPUSH
15932: CALL_OW 310
15936: PPUSH
15937: CALL_OW 247
15941: PUSH
15942: LD_INT 3
15944: EQUAL
15945: AND
15946: IFFALSE 15957
// ComExitBuilding ( i ) ;
15948: LD_VAR 0 1
15952: PPUSH
15953: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15957: LD_VAR 0 1
15961: PPUSH
15962: LD_INT 254
15964: PPUSH
15965: LD_INT 268
15967: PPUSH
15968: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15972: LD_VAR 0 1
15976: PPUSH
15977: LD_INT 34
15979: PPUSH
15980: CALL_OW 308
15984: IFFALSE 15995
// RemoveUnit ( i ) ;
15986: LD_VAR 0 1
15990: PPUSH
15991: CALL_OW 64
// end ;
15995: GO 15914
15997: POP
15998: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15999: LD_INT 22
16001: PUSH
16002: LD_INT 2
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: PUSH
16009: LD_INT 2
16011: PUSH
16012: LD_INT 21
16014: PUSH
16015: LD_INT 1
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PUSH
16022: LD_INT 33
16024: PUSH
16025: LD_INT 1
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: PPUSH
16041: CALL_OW 69
16045: NOT
16046: IFFALSE 15897
// end ;
16048: PPOPN 2
16050: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16051: LD_EXP 3
16055: IFFALSE 16407
16057: GO 16059
16059: DISABLE
16060: LD_INT 0
16062: PPUSH
16063: PPUSH
// begin MC_Kill ( 3 ) ;
16064: LD_INT 3
16066: PPUSH
16067: CALL 21654 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16071: LD_INT 8
16073: PPUSH
16074: LD_INT 7
16076: PPUSH
16077: LD_INT 1
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: CALL_OW 80
// DialogueOn ;
16087: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16091: LD_EXP 56
16095: PPUSH
16096: LD_STRING D15-Szulc-1
16098: PPUSH
16099: CALL_OW 94
// DialogueOff ;
16103: CALL_OW 7
// legionCapitulated := true ;
16107: LD_ADDR_EXP 8
16111: PUSH
16112: LD_INT 1
16114: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16115: LD_ADDR_VAR 0 1
16119: PUSH
16120: LD_INT 22
16122: PUSH
16123: LD_INT 8
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: PUSH
16130: LD_INT 21
16132: PUSH
16133: LD_INT 3
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 23
16142: PUSH
16143: LD_INT 3
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: PPUSH
16155: CALL_OW 69
16159: PUSH
16160: FOR_IN
16161: IFFALSE 16177
// SetLives ( i , 3 ) ;
16163: LD_VAR 0 1
16167: PPUSH
16168: LD_INT 3
16170: PPUSH
16171: CALL_OW 234
16175: GO 16160
16177: POP
16178: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16179: LD_ADDR_VAR 0 2
16183: PUSH
16184: LD_INT 22
16186: PUSH
16187: LD_INT 8
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: PUSH
16194: LD_INT 21
16196: PUSH
16197: LD_INT 1
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PPUSH
16208: CALL_OW 69
16212: PUSH
16213: LD_INT 22
16215: PUSH
16216: LD_INT 8
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: LD_INT 21
16225: PUSH
16226: LD_INT 2
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: LIST
16243: PPUSH
16244: CALL_OW 69
16248: ADD
16249: ST_TO_ADDR
// if tmp then
16250: LD_VAR 0 2
16254: IFFALSE 16407
// repeat wait ( 0 0$1 ) ;
16256: LD_INT 35
16258: PPUSH
16259: CALL_OW 67
// for i in tmp do
16263: LD_ADDR_VAR 0 1
16267: PUSH
16268: LD_VAR 0 2
16272: PUSH
16273: FOR_IN
16274: IFFALSE 16356
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16276: LD_VAR 0 1
16280: PPUSH
16281: CALL_OW 310
16285: PUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 310
16295: PPUSH
16296: CALL_OW 247
16300: PUSH
16301: LD_INT 3
16303: EQUAL
16304: AND
16305: IFFALSE 16316
// ComExitBuilding ( i ) ;
16307: LD_VAR 0 1
16311: PPUSH
16312: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16316: LD_VAR 0 1
16320: PPUSH
16321: LD_INT 10
16323: PPUSH
16324: LD_INT 1
16326: PPUSH
16327: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16331: LD_VAR 0 1
16335: PPUSH
16336: LD_INT 32
16338: PPUSH
16339: CALL_OW 308
16343: IFFALSE 16354
// RemoveUnit ( i ) ;
16345: LD_VAR 0 1
16349: PPUSH
16350: CALL_OW 64
// end ;
16354: GO 16273
16356: POP
16357: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16358: LD_INT 22
16360: PUSH
16361: LD_INT 8
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 2
16370: PUSH
16371: LD_INT 21
16373: PUSH
16374: LD_INT 1
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 33
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: PPUSH
16400: CALL_OW 69
16404: NOT
16405: IFFALSE 16256
// end ;
16407: PPOPN 2
16409: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16410: LD_EXP 5
16414: NOT
16415: PUSH
16416: LD_OWVAR 1
16420: PUSH
16421: LD_INT 63000
16423: GREATEREQUAL
16424: AND
16425: IFFALSE 16434
16427: GO 16429
16429: DISABLE
// AllianceSupport ;
16430: CALL 4642 0 0
16434: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16435: LD_EXP 4
16439: PUSH
16440: LD_EXP 2
16444: AND
16445: PUSH
16446: LD_EXP 3
16450: AND
16451: PUSH
16452: LD_EXP 5
16456: AND
16457: PUSH
16458: LD_EXP 6
16462: AND
16463: PUSH
16464: LD_EXP 7
16468: AND
16469: PUSH
16470: LD_EXP 8
16474: AND
16475: PUSH
16476: LD_EXP 55
16480: PPUSH
16481: CALL_OW 255
16485: PUSH
16486: LD_INT 5
16488: NONEQUAL
16489: PUSH
16490: LD_EXP 55
16494: PPUSH
16495: CALL_OW 301
16499: OR
16500: PUSH
16501: LD_EXP 55
16505: PPUSH
16506: CALL_OW 305
16510: NOT
16511: OR
16512: AND
16513: IFFALSE 17915
16515: GO 16517
16517: DISABLE
16518: LD_INT 0
16520: PPUSH
16521: PPUSH
// begin wait ( 0 0$5 ) ;
16522: LD_INT 175
16524: PPUSH
16525: CALL_OW 67
// music_class := 5 ;
16529: LD_ADDR_OWVAR 72
16533: PUSH
16534: LD_INT 5
16536: ST_TO_ADDR
// music_nat := 5 ;
16537: LD_ADDR_OWVAR 71
16541: PUSH
16542: LD_INT 5
16544: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16545: LD_EXP 15
16549: PUSH
16550: LD_INT 3
16552: LESS
16553: IFFALSE 16562
// SetAchievement ( ACH_ECONOMY ) ;
16555: LD_STRING ACH_ECONOMY
16557: PPUSH
16558: CALL_OW 543
// if tick < 60 60$00 then
16562: LD_OWVAR 1
16566: PUSH
16567: LD_INT 126000
16569: LESS
16570: IFFALSE 16586
// begin wait ( 3 ) ;
16572: LD_INT 3
16574: PPUSH
16575: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16579: LD_STRING ACH_ASPEED_19
16581: PPUSH
16582: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16586: LD_EXP 19
16590: PPUSH
16591: CALL_OW 87
// InGameOn ;
16595: CALL_OW 8
// DialogueOn ;
16599: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16603: LD_EXP 19
16607: PPUSH
16608: LD_STRING DEnd-JMM-JMM-1
16610: PPUSH
16611: CALL_OW 88
// if Joan then
16615: LD_EXP 34
16619: IFFALSE 16635
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16621: LD_EXP 34
16625: PPUSH
16626: LD_STRING DEnd-JMM-Joan-1
16628: PPUSH
16629: CALL_OW 88
16633: GO 16679
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16635: LD_EXP 21
16639: PUSH
16640: LD_EXP 21
16644: PPUSH
16645: CALL_OW 255
16649: PUSH
16650: LD_INT 7
16652: EQUAL
16653: AND
16654: PUSH
16655: LD_EXP 21
16659: PPUSH
16660: CALL_OW 305
16664: AND
16665: IFFALSE 16679
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16667: LD_EXP 21
16671: PPUSH
16672: LD_STRING DEnd-JMM-Lisa-1
16674: PPUSH
16675: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16679: LD_EXP 31
16683: PUSH
16684: LD_EXP 31
16688: PPUSH
16689: CALL_OW 305
16693: AND
16694: IFFALSE 16708
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16696: LD_EXP 31
16700: PPUSH
16701: LD_STRING DEnd-JMM-Frank-1
16703: PPUSH
16704: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16708: LD_EXP 24
16712: PUSH
16713: LD_EXP 24
16717: PPUSH
16718: CALL_OW 255
16722: PUSH
16723: LD_INT 7
16725: EQUAL
16726: AND
16727: PUSH
16728: LD_EXP 24
16732: PPUSH
16733: CALL_OW 305
16737: AND
16738: IFFALSE 16752
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16740: LD_EXP 24
16744: PPUSH
16745: LD_STRING DEnd-JMM-Cyrus-1
16747: PPUSH
16748: CALL_OW 88
// if Burlak then
16752: LD_EXP 51
16756: IFFALSE 16770
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16758: LD_EXP 51
16762: PPUSH
16763: LD_STRING DEnd-JMM-Bur-1
16765: PPUSH
16766: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16770: LD_EXP 34
16774: PUSH
16775: LD_EXP 21
16779: AND
16780: PUSH
16781: LD_EXP 21
16785: PPUSH
16786: CALL_OW 255
16790: PUSH
16791: LD_INT 7
16793: EQUAL
16794: AND
16795: PUSH
16796: LD_EXP 21
16800: PPUSH
16801: CALL_OW 305
16805: AND
16806: PUSH
16807: LD_EXP 51
16811: PPUSH
16812: CALL_OW 302
16816: AND
16817: IFFALSE 16831
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16819: LD_EXP 21
16823: PPUSH
16824: LD_STRING DEnd-Burlak-Lisa-1
16826: PPUSH
16827: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16831: LD_EXP 52
16835: PUSH
16836: LD_EXP 52
16840: PPUSH
16841: CALL_OW 305
16845: AND
16846: IFFALSE 16860
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16848: LD_EXP 52
16852: PPUSH
16853: LD_STRING DEnd-JMM-Bel-1
16855: PPUSH
16856: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16860: LD_EXP 53
16864: PUSH
16865: LD_EXP 53
16869: PPUSH
16870: CALL_OW 305
16874: AND
16875: IFFALSE 16889
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16877: LD_EXP 53
16881: PPUSH
16882: LD_STRING DEnd-JMM-Gny-1
16884: PPUSH
16885: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16889: LD_EXP 29
16893: PUSH
16894: LD_EXP 29
16898: PPUSH
16899: CALL_OW 255
16903: PUSH
16904: LD_INT 7
16906: EQUAL
16907: AND
16908: PUSH
16909: LD_EXP 29
16913: PPUSH
16914: CALL_OW 305
16918: AND
16919: IFFALSE 16933
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16921: LD_EXP 29
16925: PPUSH
16926: LD_STRING DEnd-JMM-Corn-1
16928: PPUSH
16929: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16933: LD_EXP 22
16937: PUSH
16938: LD_EXP 22
16942: PPUSH
16943: CALL_OW 255
16947: PUSH
16948: LD_INT 7
16950: EQUAL
16951: AND
16952: PUSH
16953: LD_EXP 22
16957: PPUSH
16958: CALL_OW 305
16962: AND
16963: IFFALSE 16977
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16965: LD_EXP 22
16969: PPUSH
16970: LD_STRING DEnd-JMM-Don-1
16972: PPUSH
16973: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16977: LD_EXP 23
16981: PUSH
16982: LD_EXP 23
16986: PPUSH
16987: CALL_OW 255
16991: PUSH
16992: LD_INT 7
16994: EQUAL
16995: AND
16996: PUSH
16997: LD_EXP 23
17001: PPUSH
17002: CALL_OW 305
17006: AND
17007: IFFALSE 17021
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17009: LD_EXP 23
17013: PPUSH
17014: LD_STRING DEnd-JMM-Bobby-1
17016: PPUSH
17017: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17021: LD_EXP 25
17025: PUSH
17026: LD_EXP 25
17030: PPUSH
17031: CALL_OW 255
17035: PUSH
17036: LD_INT 7
17038: EQUAL
17039: AND
17040: PUSH
17041: LD_EXP 25
17045: PPUSH
17046: CALL_OW 305
17050: AND
17051: IFFALSE 17065
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17053: LD_EXP 25
17057: PPUSH
17058: LD_STRING DEnd-JMM-Den-1
17060: PPUSH
17061: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17065: LD_EXP 27
17069: PUSH
17070: LD_EXP 27
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 7
17082: EQUAL
17083: AND
17084: PUSH
17085: LD_EXP 27
17089: PPUSH
17090: CALL_OW 305
17094: AND
17095: IFFALSE 17109
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17097: LD_EXP 27
17101: PPUSH
17102: LD_STRING DEnd-JMM-Glad-1
17104: PPUSH
17105: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17109: LD_EXP 32
17113: PUSH
17114: LD_EXP 32
17118: PPUSH
17119: CALL_OW 255
17123: PUSH
17124: LD_INT 7
17126: EQUAL
17127: AND
17128: PUSH
17129: LD_EXP 32
17133: PPUSH
17134: CALL_OW 305
17138: AND
17139: IFFALSE 17153
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17141: LD_EXP 32
17145: PPUSH
17146: LD_STRING DEnd-JMM-Yam-1
17148: PPUSH
17149: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17153: LD_EXP 26
17157: PUSH
17158: LD_EXP 26
17162: PPUSH
17163: CALL_OW 255
17167: PUSH
17168: LD_INT 7
17170: EQUAL
17171: AND
17172: PUSH
17173: LD_EXP 26
17177: PPUSH
17178: CALL_OW 305
17182: AND
17183: IFFALSE 17197
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17185: LD_EXP 26
17189: PPUSH
17190: LD_STRING DEnd-JMM-Brown-1
17192: PPUSH
17193: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17197: LD_EXP 36
17201: PUSH
17202: LD_EXP 36
17206: PPUSH
17207: CALL_OW 255
17211: PUSH
17212: LD_INT 7
17214: EQUAL
17215: AND
17216: PUSH
17217: LD_EXP 36
17221: PPUSH
17222: CALL_OW 305
17226: AND
17227: IFFALSE 17241
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17229: LD_EXP 36
17233: PPUSH
17234: LD_STRING DEnd-JMM-Con-1
17236: PPUSH
17237: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17241: LD_EXP 30
17245: PUSH
17246: LD_EXP 30
17250: PPUSH
17251: CALL_OW 255
17255: PUSH
17256: LD_INT 7
17258: EQUAL
17259: AND
17260: PUSH
17261: LD_EXP 30
17265: PPUSH
17266: CALL_OW 305
17270: AND
17271: IFFALSE 17285
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17273: LD_EXP 30
17277: PPUSH
17278: LD_STRING DEnd-JMM-Gary-1
17280: PPUSH
17281: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17285: LD_EXP 33
17289: PUSH
17290: LD_EXP 20
17294: AND
17295: PUSH
17296: LD_EXP 33
17300: PPUSH
17301: CALL_OW 305
17305: AND
17306: IFFALSE 17320
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17308: LD_EXP 33
17312: PPUSH
17313: LD_STRING DEnd-JMM-Sim-1
17315: PPUSH
17316: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17320: LD_EXP 28
17324: PUSH
17325: LD_EXP 28
17329: PPUSH
17330: CALL_OW 255
17334: PUSH
17335: LD_INT 7
17337: EQUAL
17338: AND
17339: PUSH
17340: LD_EXP 28
17344: PPUSH
17345: CALL_OW 305
17349: AND
17350: IFFALSE 17364
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17352: LD_EXP 28
17356: PPUSH
17357: LD_STRING DEnd-JMM-VanH-1
17359: PPUSH
17360: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17364: LD_EXP 41
17368: PUSH
17369: LD_EXP 41
17373: PPUSH
17374: CALL_OW 305
17378: AND
17379: IFFALSE 17393
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17381: LD_EXP 41
17385: PPUSH
17386: LD_STRING DEnd-JMM-Dol-1
17388: PPUSH
17389: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17393: LD_EXP 45
17397: PUSH
17398: LD_EXP 45
17402: PPUSH
17403: CALL_OW 305
17407: AND
17408: IFFALSE 17422
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17410: LD_EXP 45
17414: PPUSH
17415: LD_STRING DEnd-JMM-Kap-1
17417: PPUSH
17418: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17422: LD_EXP 48
17426: PUSH
17427: LD_EXP 48
17431: PPUSH
17432: CALL_OW 305
17436: AND
17437: IFFALSE 17451
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17439: LD_EXP 48
17443: PPUSH
17444: LD_STRING DEnd-JMM-Kov-1
17446: PPUSH
17447: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17451: LD_EXP 43
17455: PUSH
17456: LD_EXP 43
17460: PPUSH
17461: CALL_OW 305
17465: AND
17466: IFFALSE 17480
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17468: LD_EXP 43
17472: PPUSH
17473: LD_STRING DEnd-JMM-Sch-1
17475: PPUSH
17476: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17480: LD_EXP 39
17484: PUSH
17485: LD_EXP 39
17489: PPUSH
17490: CALL_OW 305
17494: AND
17495: IFFALSE 17509
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17497: LD_EXP 39
17501: PPUSH
17502: LD_STRING DEnd-JMM-Tit-1
17504: PPUSH
17505: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17509: LD_EXP 44
17513: PUSH
17514: LD_EXP 44
17518: PPUSH
17519: CALL_OW 305
17523: AND
17524: IFFALSE 17538
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17526: LD_EXP 44
17530: PPUSH
17531: LD_STRING DEnd-JMM-Obl-1
17533: PPUSH
17534: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17538: LD_EXP 46
17542: PUSH
17543: LD_EXP 46
17547: PPUSH
17548: CALL_OW 305
17552: AND
17553: IFFALSE 17567
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17555: LD_EXP 46
17559: PPUSH
17560: LD_STRING DEnd-JMM-Lip-1
17562: PPUSH
17563: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17567: LD_EXP 40
17571: PUSH
17572: LD_EXP 40
17576: PPUSH
17577: CALL_OW 305
17581: AND
17582: PUSH
17583: LD_EXP 51
17587: AND
17588: IFFALSE 17602
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17590: LD_EXP 40
17594: PPUSH
17595: LD_STRING DEnd-Burlak-Fad-1
17597: PPUSH
17598: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17602: LD_EXP 47
17606: PUSH
17607: LD_EXP 47
17611: PPUSH
17612: CALL_OW 305
17616: AND
17617: IFFALSE 17631
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17619: LD_EXP 47
17623: PPUSH
17624: LD_STRING DEnd-Burlak-Ptr-1
17626: PPUSH
17627: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17631: LD_EXP 49
17635: PUSH
17636: LD_EXP 49
17640: PPUSH
17641: CALL_OW 305
17645: AND
17646: IFFALSE 17660
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17648: LD_EXP 49
17652: PPUSH
17653: LD_STRING DEnd-Burlak-Kuz-1
17655: PPUSH
17656: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17660: LD_EXP 38
17664: PUSH
17665: LD_EXP 38
17669: PPUSH
17670: CALL_OW 305
17674: AND
17675: PUSH
17676: LD_EXP 51
17680: AND
17681: IFFALSE 17695
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17683: LD_EXP 38
17687: PPUSH
17688: LD_STRING DEnd-Burlak-Kir-1
17690: PPUSH
17691: CALL_OW 88
// if Burlak then
17695: LD_EXP 51
17699: IFFALSE 17713
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17701: LD_EXP 19
17705: PPUSH
17706: LD_STRING DEnd-Burlak-JMM-1
17708: PPUSH
17709: CALL_OW 88
// dwait ( 0 0$2 ) ;
17713: LD_INT 70
17715: PPUSH
17716: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17720: LD_EXP 56
17724: PPUSH
17725: LD_STRING DEnd-Szulc
17727: PPUSH
17728: CALL_OW 94
// dwait ( 0 0$1 ) ;
17732: LD_INT 35
17734: PPUSH
17735: CALL_OW 68
// if IsLive ( Burlak ) then
17739: LD_EXP 51
17743: PPUSH
17744: CALL_OW 300
17748: IFFALSE 17760
// med1 := 1 else
17750: LD_ADDR_VAR 0 1
17754: PUSH
17755: LD_INT 1
17757: ST_TO_ADDR
17758: GO 17769
// med1 := - 1 ;
17760: LD_ADDR_VAR 0 1
17764: PUSH
17765: LD_INT 1
17767: NEG
17768: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17769: LD_EXP 12
17773: PUSH
17774: LD_EXP 13
17778: AND
17779: PUSH
17780: LD_EXP 14
17784: AND
17785: IFFALSE 17797
// med2 := 1 else
17787: LD_ADDR_VAR 0 2
17791: PUSH
17792: LD_INT 1
17794: ST_TO_ADDR
17795: GO 17806
// med2 := - 1 ;
17797: LD_ADDR_VAR 0 2
17801: PUSH
17802: LD_INT 1
17804: NEG
17805: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17806: LD_STRING Hero
17808: PPUSH
17809: LD_INT 1
17811: PPUSH
17812: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17816: LD_STRING Artefact
17818: PPUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17828: LD_STRING ReconcileBurlak
17830: PPUSH
17831: LD_VAR 0 1
17835: PPUSH
17836: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17840: LD_OWVAR 67
17844: PUSH
17845: LD_INT 3
17847: GREATEREQUAL
17848: PUSH
17849: LD_VAR 0 1
17853: PUSH
17854: LD_INT 1
17856: EQUAL
17857: AND
17858: PUSH
17859: LD_VAR 0 2
17863: PUSH
17864: LD_INT 1
17866: EQUAL
17867: AND
17868: IFFALSE 17880
// SetAchievementEX ( ACH_AMER , 19 ) ;
17870: LD_STRING ACH_AMER
17872: PPUSH
17873: LD_INT 19
17875: PPUSH
17876: CALL_OW 564
// GiveMedals ( MAIN ) ;
17880: LD_STRING MAIN
17882: PPUSH
17883: CALL_OW 102
// InGameOff ;
17887: CALL_OW 9
// DialogueOff ;
17891: CALL_OW 7
// music_nat := 1 ;
17895: LD_ADDR_OWVAR 71
17899: PUSH
17900: LD_INT 1
17902: ST_TO_ADDR
// music_class := 4 ;
17903: LD_ADDR_OWVAR 72
17907: PUSH
17908: LD_INT 4
17910: ST_TO_ADDR
// YouWin ;
17911: CALL_OW 103
// end ; end_of_file
17915: PPOPN 2
17917: END
// export function InitNature ; begin
17918: LD_INT 0
17920: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17921: LD_INT 3
17923: PPUSH
17924: LD_INT 3
17926: PPUSH
17927: LD_INT 2
17929: PPUSH
17930: LD_INT 1
17932: PPUSH
17933: LD_INT 1
17935: PPUSH
17936: LD_INT 0
17938: PPUSH
17939: LD_INT 0
17941: PPUSH
17942: LD_INT 17
17944: PPUSH
17945: LD_INT 0
17947: PPUSH
17948: CALL 86121 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17952: LD_INT 2
17954: PPUSH
17955: LD_INT 1
17957: PPUSH
17958: LD_INT 1
17960: PPUSH
17961: LD_INT 1
17963: PPUSH
17964: LD_INT 1
17966: PPUSH
17967: LD_INT 0
17969: PPUSH
17970: LD_INT 0
17972: PPUSH
17973: LD_INT 18
17975: PPUSH
17976: LD_INT 0
17978: PPUSH
17979: CALL 86121 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17983: LD_INT 4
17985: PPUSH
17986: LD_INT 1
17988: PPUSH
17989: LD_INT 2
17991: PPUSH
17992: LD_INT 4
17994: PPUSH
17995: LD_INT 2
17997: PPUSH
17998: LD_INT 1
18000: PPUSH
18001: LD_INT 0
18003: PPUSH
18004: LD_INT 19
18006: PPUSH
18007: LD_INT 0
18009: PPUSH
18010: CALL 86121 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18014: LD_INT 0
18016: PPUSH
18017: LD_INT 0
18019: PPUSH
18020: LD_INT 0
18022: PPUSH
18023: LD_INT 0
18025: PPUSH
18026: LD_INT 0
18028: PPUSH
18029: LD_INT 0
18031: PPUSH
18032: LD_INT 9
18034: PPUSH
18035: LD_INT 0
18037: PPUSH
18038: LD_INT 20
18040: PPUSH
18041: CALL 86121 0 9
// end ; end_of_file
18045: LD_VAR 0 1
18049: RET
// every 0 0$30 do var time ;
18050: GO 18052
18052: DISABLE
18053: LD_INT 0
18055: PPUSH
// begin time := 0 0$30 ;
18056: LD_ADDR_VAR 0 1
18060: PUSH
18061: LD_INT 1050
18063: ST_TO_ADDR
// repeat wait ( time ) ;
18064: LD_VAR 0 1
18068: PPUSH
18069: CALL_OW 67
// if Prob ( 50 ) then
18073: LD_INT 50
18075: PPUSH
18076: CALL_OW 13
18080: IFFALSE 18109
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18082: LD_INT 1
18084: PPUSH
18085: LD_INT 5
18087: PPUSH
18088: CALL_OW 12
18092: PPUSH
18093: LD_INT 106
18095: PPUSH
18096: LD_INT 89
18098: PPUSH
18099: LD_INT 45
18101: PPUSH
18102: LD_INT 1
18104: PPUSH
18105: CALL_OW 56
// time := time + 0 0$3 ;
18109: LD_ADDR_VAR 0 1
18113: PUSH
18114: LD_VAR 0 1
18118: PUSH
18119: LD_INT 105
18121: PLUS
18122: ST_TO_ADDR
// if Prob ( 30 ) then
18123: LD_INT 30
18125: PPUSH
18126: CALL_OW 13
18130: IFFALSE 18176
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18132: LD_INT 525
18134: PPUSH
18135: LD_INT 735
18137: PPUSH
18138: CALL_OW 12
18142: PPUSH
18143: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18147: LD_INT 1
18149: PPUSH
18150: LD_INT 5
18152: PPUSH
18153: CALL_OW 12
18157: PPUSH
18158: LD_INT 21
18160: PPUSH
18161: LD_INT 26
18163: PPUSH
18164: LD_INT 12
18166: PPUSH
18167: LD_INT 1
18169: PPUSH
18170: CALL_OW 56
// end else
18174: GO 18212
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18176: LD_INT 700
18178: PPUSH
18179: LD_INT 1225
18181: PPUSH
18182: CALL_OW 12
18186: PPUSH
18187: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18191: LD_INT 1
18193: PPUSH
18194: LD_INT 5
18196: PPUSH
18197: CALL_OW 12
18201: PPUSH
18202: LD_INT 14
18204: PPUSH
18205: LD_INT 1
18207: PPUSH
18208: CALL_OW 55
// end ; if Prob ( 50 ) then
18212: LD_INT 50
18214: PPUSH
18215: CALL_OW 13
18219: IFFALSE 18265
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18221: LD_INT 700
18223: PPUSH
18224: LD_INT 1050
18226: PPUSH
18227: CALL_OW 12
18231: PPUSH
18232: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18236: LD_INT 1
18238: PPUSH
18239: LD_INT 5
18241: PPUSH
18242: CALL_OW 12
18246: PPUSH
18247: LD_INT 181
18249: PPUSH
18250: LD_INT 218
18252: PPUSH
18253: LD_INT 16
18255: PPUSH
18256: LD_INT 1
18258: PPUSH
18259: CALL_OW 56
// end else
18263: GO 18337
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18265: LD_INT 350
18267: PPUSH
18268: LD_INT 525
18270: PPUSH
18271: CALL_OW 12
18275: PPUSH
18276: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18280: LD_INT 1
18282: PPUSH
18283: LD_INT 5
18285: PPUSH
18286: CALL_OW 12
18290: PPUSH
18291: LD_INT 13
18293: PPUSH
18294: LD_INT 1
18296: PPUSH
18297: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18301: LD_INT 350
18303: PPUSH
18304: LD_INT 700
18306: PPUSH
18307: CALL_OW 12
18311: PPUSH
18312: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18316: LD_INT 1
18318: PPUSH
18319: LD_INT 5
18321: PPUSH
18322: CALL_OW 12
18326: PPUSH
18327: LD_INT 33
18329: PPUSH
18330: LD_INT 1
18332: PPUSH
18333: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18337: LD_INT 65
18339: PUSH
18340: LD_INT 62
18342: PUSH
18343: LD_INT 55
18345: PUSH
18346: LD_INT 50
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: LIST
18353: LIST
18354: PUSH
18355: LD_OWVAR 67
18359: ARRAY
18360: PPUSH
18361: CALL_OW 13
18365: IFFALSE 18411
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18367: LD_INT 525
18369: PPUSH
18370: LD_INT 875
18372: PPUSH
18373: CALL_OW 12
18377: PPUSH
18378: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18382: LD_INT 1
18384: PPUSH
18385: LD_INT 5
18387: PPUSH
18388: CALL_OW 12
18392: PPUSH
18393: LD_INT 294
18395: PPUSH
18396: LD_INT 211
18398: PPUSH
18399: LD_INT 30
18401: PPUSH
18402: LD_INT 1
18404: PPUSH
18405: CALL_OW 56
// end else
18409: GO 18453
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18411: LD_INT 420
18413: PPUSH
18414: LD_INT 770
18416: PPUSH
18417: CALL_OW 12
18421: PPUSH
18422: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18426: LD_INT 1
18428: PPUSH
18429: LD_INT 5
18431: PPUSH
18432: CALL_OW 12
18436: PPUSH
18437: LD_INT 294
18439: PPUSH
18440: LD_INT 211
18442: PPUSH
18443: LD_INT 30
18445: PPUSH
18446: LD_INT 1
18448: PPUSH
18449: CALL_OW 56
// end ; if time > 2 2$20 then
18453: LD_VAR 0 1
18457: PUSH
18458: LD_INT 4900
18460: GREATER
18461: IFFALSE 18471
// time := 0 0$50 ;
18463: LD_ADDR_VAR 0 1
18467: PUSH
18468: LD_INT 1750
18470: ST_TO_ADDR
// until false ;
18471: LD_INT 0
18473: IFFALSE 18064
// end ;
18475: PPOPN 1
18477: END
// every 0 0$45 trigger tick < 10 10$00 do
18478: LD_OWVAR 1
18482: PUSH
18483: LD_INT 21000
18485: LESS
18486: IFFALSE 18534
18488: GO 18490
18490: DISABLE
// begin enable ;
18491: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18492: LD_INT 350
18494: PPUSH
18495: LD_INT 700
18497: PPUSH
18498: CALL_OW 12
18502: PPUSH
18503: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18507: LD_INT 3
18509: PPUSH
18510: LD_INT 5
18512: PPUSH
18513: CALL_OW 12
18517: PPUSH
18518: LD_INT 181
18520: PPUSH
18521: LD_INT 13
18523: PPUSH
18524: LD_INT 20
18526: PPUSH
18527: LD_INT 1
18529: PPUSH
18530: CALL_OW 56
// end ; end_of_file
18534: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18535: LD_INT 0
18537: PPUSH
// SetArtifactRes ( 7 , true ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_INT 1
18543: PPUSH
18544: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18548: LD_ADDR_EXP 64
18552: PUSH
18553: EMPTY
18554: PUSH
18555: EMPTY
18556: PUSH
18557: EMPTY
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: LIST
18563: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18564: LD_ADDR_EXP 65
18568: PUSH
18569: LD_INT 1050
18571: PUSH
18572: LD_OWVAR 67
18576: MUL
18577: PUSH
18578: LD_INT 2800
18580: PUSH
18581: LD_OWVAR 67
18585: MUL
18586: PUSH
18587: LD_INT 1
18589: NEG
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: LIST
18595: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18596: LD_ADDR_EXP 66
18600: PUSH
18601: LD_INT 10
18603: PUSH
18604: LD_INT 35
18606: PUSH
18607: LD_INT 100
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: LIST
18614: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18615: LD_ADDR_EXP 67
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: LD_INT 0
18625: PUSH
18626: LD_INT 0
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: LIST
18633: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18634: LD_ADDR_EXP 69
18638: PUSH
18639: LD_INT 300
18641: PUSH
18642: LD_INT 500
18644: PUSH
18645: LD_INT 800
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18653: LD_ADDR_EXP 70
18657: PUSH
18658: LD_INT 0
18660: PUSH
18661: LD_INT 0
18663: PUSH
18664: LD_INT 0
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: LIST
18671: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18672: LD_ADDR_EXP 71
18676: PUSH
18677: LD_INT 0
18679: PUSH
18680: LD_INT 0
18682: PUSH
18683: LD_INT 0
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18691: LD_ADDR_EXP 68
18695: PUSH
18696: LD_INT 0
18698: PUSH
18699: LD_INT 0
18701: PUSH
18702: LD_INT 0
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18710: LD_ADDR_EXP 72
18714: PUSH
18715: LD_INT 4
18717: PUSH
18718: LD_INT 3
18720: PUSH
18721: LD_INT 1
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 5
18731: PUSH
18732: LD_INT 4
18734: PUSH
18735: LD_INT 2
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: LIST
18742: PUSH
18743: LD_INT 6
18745: PUSH
18746: LD_INT 3
18748: PUSH
18749: LD_INT 3
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18762: LD_ADDR_EXP 73
18766: PUSH
18767: LD_INT 0
18769: PUSH
18770: LD_INT 0
18772: PUSH
18773: LD_INT 0
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: LIST
18780: ST_TO_ADDR
// end ;
18781: LD_VAR 0 1
18785: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18786: LD_INT 24
18788: PPUSH
18789: LD_INT 7
18791: PPUSH
18792: CALL_OW 321
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: IFFALSE 19726
18802: GO 18804
18804: DISABLE
18805: LD_INT 0
18807: PPUSH
18808: PPUSH
18809: PPUSH
18810: PPUSH
18811: PPUSH
// begin enable ;
18812: ENABLE
// for i = 1 to 3 do
18813: LD_ADDR_VAR 0 1
18817: PUSH
18818: DOUBLE
18819: LD_INT 1
18821: DEC
18822: ST_TO_ADDR
18823: LD_INT 3
18825: PUSH
18826: FOR_TO
18827: IFFALSE 19724
// begin pos := FindArtifact ( i + 2 ) ;
18829: LD_ADDR_VAR 0 2
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_INT 2
18841: PLUS
18842: PPUSH
18843: CALL_OW 469
18847: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18848: LD_ADDR_EXP 64
18852: PUSH
18853: LD_EXP 64
18857: PPUSH
18858: LD_VAR 0 1
18862: PPUSH
18863: LD_VAR 0 2
18867: PPUSH
18868: CALL_OW 1
18872: ST_TO_ADDR
// if pos then
18873: LD_VAR 0 2
18877: IFFALSE 19585
// begin case i of 1 :
18879: LD_VAR 0 1
18883: PUSH
18884: LD_INT 1
18886: DOUBLE
18887: EQUAL
18888: IFTRUE 18892
18890: GO 18969
18892: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18893: LD_ADDR_VAR 0 4
18897: PUSH
18898: LD_INT 22
18900: PUSH
18901: LD_INT 7
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 23
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 8
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: LD_INT 30
18933: PUSH
18934: LD_INT 7
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PUSH
18941: LD_INT 30
18943: PUSH
18944: LD_INT 11
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: EMPTY
18952: LIST
18953: LIST
18954: LIST
18955: LIST
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: PPUSH
18962: CALL_OW 69
18966: ST_TO_ADDR
18967: GO 19077
18969: LD_INT 2
18971: DOUBLE
18972: EQUAL
18973: IFTRUE 18977
18975: GO 19054
18977: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18978: LD_ADDR_VAR 0 4
18982: PUSH
18983: LD_INT 22
18985: PUSH
18986: LD_INT 7
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: PUSH
18993: LD_INT 23
18995: PUSH
18996: LD_INT 3
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: PUSH
19003: LD_INT 2
19005: PUSH
19006: LD_INT 30
19008: PUSH
19009: LD_INT 8
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PUSH
19016: LD_INT 30
19018: PUSH
19019: LD_INT 7
19021: PUSH
19022: EMPTY
19023: LIST
19024: LIST
19025: PUSH
19026: LD_INT 30
19028: PUSH
19029: LD_INT 11
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PUSH
19036: EMPTY
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
19052: GO 19077
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19076
19062: POP
// labs := [ alien ] ; end ;
19063: LD_ADDR_VAR 0 4
19067: PUSH
19068: LD_INT 1
19070: PUSH
19071: EMPTY
19072: LIST
19073: ST_TO_ADDR
19074: GO 19077
19076: POP
// if not labs then
19077: LD_VAR 0 4
19081: NOT
19082: IFFALSE 19086
// continue ;
19084: GO 18826
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19086: LD_ADDR_VAR 0 5
19090: PUSH
19091: LD_VAR 0 4
19095: PPUSH
19096: LD_EXP 64
19100: PUSH
19101: LD_VAR 0 1
19105: ARRAY
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_EXP 64
19115: PUSH
19116: LD_VAR 0 1
19120: ARRAY
19121: PUSH
19122: LD_INT 2
19124: ARRAY
19125: PPUSH
19126: CALL_OW 73
19130: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19131: LD_VAR 0 5
19135: NOT
19136: PUSH
19137: LD_VAR 0 5
19141: PUSH
19142: LD_EXP 71
19146: PUSH
19147: LD_VAR 0 1
19151: ARRAY
19152: NONEQUAL
19153: OR
19154: IFFALSE 19259
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19156: LD_INT 7
19158: PPUSH
19159: LD_EXP 72
19163: PUSH
19164: LD_VAR 0 1
19168: ARRAY
19169: PUSH
19170: LD_INT 3
19172: ARRAY
19173: PPUSH
19174: LD_INT 0
19176: PPUSH
19177: LD_EXP 71
19181: PUSH
19182: LD_VAR 0 1
19186: ARRAY
19187: PPUSH
19188: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19192: LD_INT 7
19194: PPUSH
19195: LD_EXP 72
19199: PUSH
19200: LD_VAR 0 1
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: LD_INT 0
19212: PPUSH
19213: LD_EXP 71
19217: PUSH
19218: LD_VAR 0 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 468
// if nearestLab then
19228: LD_VAR 0 5
19232: IFFALSE 19259
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19234: LD_ADDR_EXP 71
19238: PUSH
19239: LD_EXP 71
19243: PPUSH
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: CALL_OW 1
19258: ST_TO_ADDR
// end ; if not nearestLab then
19259: LD_VAR 0 5
19263: NOT
19264: IFFALSE 19268
// continue ;
19266: GO 18826
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19268: LD_VAR 0 5
19272: PPUSH
19273: LD_EXP 64
19277: PUSH
19278: LD_VAR 0 1
19282: ARRAY
19283: PUSH
19284: LD_INT 1
19286: ARRAY
19287: PPUSH
19288: LD_EXP 64
19292: PUSH
19293: LD_VAR 0 1
19297: ARRAY
19298: PUSH
19299: LD_INT 2
19301: ARRAY
19302: PPUSH
19303: CALL_OW 297
19307: PUSH
19308: LD_INT 8
19310: LESS
19311: IFFALSE 19508
// begin if not artifactsResearched [ i ] then
19313: LD_EXP 67
19317: PUSH
19318: LD_VAR 0 1
19322: ARRAY
19323: NOT
19324: IFFALSE 19405
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19326: LD_VAR 0 5
19330: PPUSH
19331: CALL_OW 461
19335: PUSH
19336: LD_INT 2
19338: EQUAL
19339: IFFALSE 19373
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19341: LD_INT 7
19343: PPUSH
19344: LD_EXP 72
19348: PUSH
19349: LD_VAR 0 1
19353: ARRAY
19354: PUSH
19355: LD_INT 3
19357: ARRAY
19358: PPUSH
19359: LD_INT 2
19361: PPUSH
19362: LD_VAR 0 5
19366: PPUSH
19367: CALL_OW 468
19371: GO 19403
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19373: LD_INT 7
19375: PPUSH
19376: LD_EXP 72
19380: PUSH
19381: LD_VAR 0 1
19385: ARRAY
19386: PUSH
19387: LD_INT 3
19389: ARRAY
19390: PPUSH
19391: LD_INT 1
19393: PPUSH
19394: LD_VAR 0 5
19398: PPUSH
19399: CALL_OW 468
// end else
19403: GO 19506
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19405: LD_VAR 0 5
19409: PPUSH
19410: CALL_OW 461
19414: PUSH
19415: LD_INT 2
19417: EQUAL
19418: PUSH
19419: LD_EXP 73
19423: PUSH
19424: LD_VAR 0 1
19428: ARRAY
19429: AND
19430: IFFALSE 19476
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19432: LD_INT 7
19434: PPUSH
19435: LD_EXP 72
19439: PUSH
19440: LD_VAR 0 1
19444: ARRAY
19445: PUSH
19446: LD_INT 1
19448: ARRAY
19449: PPUSH
19450: LD_EXP 72
19454: PUSH
19455: LD_VAR 0 1
19459: ARRAY
19460: PUSH
19461: LD_INT 2
19463: ARRAY
19464: PPUSH
19465: LD_VAR 0 5
19469: PPUSH
19470: CALL_OW 468
19474: GO 19506
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19476: LD_INT 7
19478: PPUSH
19479: LD_EXP 72
19483: PUSH
19484: LD_VAR 0 1
19488: ARRAY
19489: PUSH
19490: LD_INT 1
19492: ARRAY
19493: PPUSH
19494: LD_INT 1
19496: PPUSH
19497: LD_VAR 0 5
19501: PPUSH
19502: CALL_OW 468
// end else
19506: GO 19583
// begin if not artifactsResearched [ i ] then
19508: LD_EXP 67
19512: PUSH
19513: LD_VAR 0 1
19517: ARRAY
19518: NOT
19519: IFFALSE 19553
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19521: LD_INT 7
19523: PPUSH
19524: LD_EXP 72
19528: PUSH
19529: LD_VAR 0 1
19533: ARRAY
19534: PUSH
19535: LD_INT 3
19537: ARRAY
19538: PPUSH
19539: LD_INT 0
19541: PPUSH
19542: LD_VAR 0 5
19546: PPUSH
19547: CALL_OW 468
19551: GO 19583
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19553: LD_INT 7
19555: PPUSH
19556: LD_EXP 72
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: PPUSH
19571: LD_INT 0
19573: PPUSH
19574: LD_VAR 0 5
19578: PPUSH
19579: CALL_OW 468
// end ; end else
19583: GO 19722
// begin if not artifactsLabs [ i ] then
19585: LD_EXP 71
19589: PUSH
19590: LD_VAR 0 1
19594: ARRAY
19595: NOT
19596: IFFALSE 19600
// continue ;
19598: GO 18826
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19600: LD_INT 7
19602: PPUSH
19603: LD_EXP 72
19607: PUSH
19608: LD_VAR 0 1
19612: ARRAY
19613: PUSH
19614: LD_INT 3
19616: ARRAY
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: LD_EXP 71
19625: PUSH
19626: LD_VAR 0 1
19630: ARRAY
19631: PPUSH
19632: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19636: LD_INT 7
19638: PPUSH
19639: LD_EXP 72
19643: PUSH
19644: LD_VAR 0 1
19648: ARRAY
19649: PUSH
19650: LD_INT 1
19652: ARRAY
19653: PPUSH
19654: LD_INT 0
19656: PPUSH
19657: LD_EXP 71
19661: PUSH
19662: LD_VAR 0 1
19666: ARRAY
19667: PPUSH
19668: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19672: LD_EXP 68
19676: PUSH
19677: LD_VAR 0 1
19681: ARRAY
19682: IFFALSE 19722
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19684: LD_ADDR_EXP 68
19688: PUSH
19689: LD_EXP 68
19693: PPUSH
19694: LD_VAR 0 1
19698: PPUSH
19699: LD_INT 0
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19707: LD_EXP 71
19711: PUSH
19712: LD_VAR 0 1
19716: ARRAY
19717: PPUSH
19718: CALL_OW 127
// end ; end ; end ;
19722: GO 18826
19724: POP
19725: POP
// end ;
19726: PPOPN 5
19728: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19729: LD_INT 0
19731: PPUSH
19732: PPUSH
19733: PPUSH
19734: PPUSH
19735: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19736: LD_VAR 0 2
19740: PUSH
19741: LD_EXP 72
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: PUSH
19750: LD_INT 3
19752: ARRAY
19753: EQUAL
19754: IFFALSE 19877
// begin lab := artifactsLabs [ 1 ] ;
19756: LD_ADDR_VAR 0 6
19760: PUSH
19761: LD_EXP 71
19765: PUSH
19766: LD_INT 1
19768: ARRAY
19769: ST_TO_ADDR
// if not lab then
19770: LD_VAR 0 6
19774: NOT
19775: IFFALSE 19779
// exit ;
19777: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19779: LD_VAR 0 6
19783: PPUSH
19784: LD_EXP 69
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19800: LD_EXP 70
19804: PUSH
19805: LD_INT 1
19807: ARRAY
19808: IFFALSE 19828
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19810: LD_VAR 0 6
19814: PPUSH
19815: LD_EXP 70
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19828: LD_ADDR_EXP 68
19832: PUSH
19833: LD_EXP 68
19837: PPUSH
19838: LD_INT 1
19840: PPUSH
19841: LD_INT 1
19843: PPUSH
19844: CALL_OW 1
19848: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19849: LD_INT 7
19851: PPUSH
19852: LD_EXP 72
19856: PUSH
19857: LD_INT 1
19859: ARRAY
19860: PUSH
19861: LD_INT 3
19863: ARRAY
19864: PPUSH
19865: LD_INT 0
19867: PPUSH
19868: LD_VAR 0 6
19872: PPUSH
19873: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19877: LD_VAR 0 2
19881: PUSH
19882: LD_EXP 72
19886: PUSH
19887: LD_INT 2
19889: ARRAY
19890: PUSH
19891: LD_INT 3
19893: ARRAY
19894: EQUAL
19895: IFFALSE 20018
// begin lab := artifactsLabs [ 2 ] ;
19897: LD_ADDR_VAR 0 6
19901: PUSH
19902: LD_EXP 71
19906: PUSH
19907: LD_INT 2
19909: ARRAY
19910: ST_TO_ADDR
// if not lab then
19911: LD_VAR 0 6
19915: NOT
19916: IFFALSE 19920
// exit ;
19918: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19920: LD_VAR 0 6
19924: PPUSH
19925: LD_EXP 69
19929: PUSH
19930: LD_INT 2
19932: ARRAY
19933: PPUSH
19934: LD_INT 1
19936: PPUSH
19937: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19941: LD_EXP 70
19945: PUSH
19946: LD_INT 2
19948: ARRAY
19949: IFFALSE 19969
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19951: LD_VAR 0 6
19955: PPUSH
19956: LD_EXP 70
19960: PUSH
19961: LD_INT 2
19963: ARRAY
19964: PPUSH
19965: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19969: LD_ADDR_EXP 68
19973: PUSH
19974: LD_EXP 68
19978: PPUSH
19979: LD_INT 2
19981: PPUSH
19982: LD_INT 1
19984: PPUSH
19985: CALL_OW 1
19989: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19990: LD_INT 7
19992: PPUSH
19993: LD_EXP 72
19997: PUSH
19998: LD_INT 2
20000: ARRAY
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: PPUSH
20006: LD_INT 0
20008: PPUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20018: LD_VAR 0 2
20022: PUSH
20023: LD_EXP 72
20027: PUSH
20028: LD_INT 3
20030: ARRAY
20031: PUSH
20032: LD_INT 3
20034: ARRAY
20035: EQUAL
20036: IFFALSE 20159
// begin lab := artifactsLabs [ 3 ] ;
20038: LD_ADDR_VAR 0 6
20042: PUSH
20043: LD_EXP 71
20047: PUSH
20048: LD_INT 3
20050: ARRAY
20051: ST_TO_ADDR
// if not lab then
20052: LD_VAR 0 6
20056: NOT
20057: IFFALSE 20061
// exit ;
20059: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20061: LD_VAR 0 6
20065: PPUSH
20066: LD_EXP 69
20070: PUSH
20071: LD_INT 3
20073: ARRAY
20074: PPUSH
20075: LD_INT 1
20077: PPUSH
20078: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20082: LD_EXP 70
20086: PUSH
20087: LD_INT 3
20089: ARRAY
20090: IFFALSE 20110
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20092: LD_VAR 0 6
20096: PPUSH
20097: LD_EXP 70
20101: PUSH
20102: LD_INT 3
20104: ARRAY
20105: PPUSH
20106: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20110: LD_ADDR_EXP 68
20114: PUSH
20115: LD_EXP 68
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 1
20125: PPUSH
20126: CALL_OW 1
20130: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20131: LD_INT 7
20133: PPUSH
20134: LD_EXP 72
20138: PUSH
20139: LD_INT 3
20141: ARRAY
20142: PUSH
20143: LD_INT 3
20145: ARRAY
20146: PPUSH
20147: LD_INT 0
20149: PPUSH
20150: LD_VAR 0 6
20154: PPUSH
20155: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20159: LD_VAR 0 2
20163: PUSH
20164: LD_EXP 72
20168: PUSH
20169: LD_INT 1
20171: ARRAY
20172: PUSH
20173: LD_INT 1
20175: ARRAY
20176: EQUAL
20177: IFFALSE 20335
// begin lab := artifactsLabs [ 1 ] ;
20179: LD_ADDR_VAR 0 6
20183: PUSH
20184: LD_EXP 71
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20193: LD_VAR 0 6
20197: PPUSH
20198: CALL_OW 274
20202: PPUSH
20203: CALL 89669 0 1
20207: PUSH
20208: LD_INT 3
20210: ARRAY
20211: PUSH
20212: LD_EXP 66
20216: PUSH
20217: LD_INT 1
20219: ARRAY
20220: LESS
20221: IFFALSE 20235
// begin HintSpec ( ArtifactCost , 2 ) ;
20223: LD_STRING ArtifactCost
20225: PPUSH
20226: LD_INT 2
20228: PPUSH
20229: CALL_OW 338
// exit ;
20233: GO 20857
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20235: LD_ADDR_EXP 73
20239: PUSH
20240: LD_EXP 73
20244: PPUSH
20245: LD_INT 1
20247: PPUSH
20248: LD_INT 0
20250: PPUSH
20251: CALL_OW 1
20255: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20256: LD_VAR 0 3
20260: PPUSH
20261: LD_VAR 0 4
20265: PPUSH
20266: LD_INT 7
20268: PPUSH
20269: LD_INT 12
20271: NEG
20272: PPUSH
20273: CALL_OW 330
// wait ( 0 0$30 ) ;
20277: LD_INT 1050
20279: PPUSH
20280: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20284: LD_VAR 0 3
20288: PPUSH
20289: LD_VAR 0 4
20293: PPUSH
20294: LD_INT 7
20296: PPUSH
20297: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20301: LD_EXP 65
20305: PUSH
20306: LD_INT 1
20308: ARRAY
20309: PPUSH
20310: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20314: LD_ADDR_EXP 73
20318: PUSH
20319: LD_EXP 73
20323: PPUSH
20324: LD_INT 1
20326: PPUSH
20327: LD_INT 1
20329: PPUSH
20330: CALL_OW 1
20334: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20335: LD_VAR 0 2
20339: PUSH
20340: LD_EXP 72
20344: PUSH
20345: LD_INT 2
20347: ARRAY
20348: PUSH
20349: LD_INT 1
20351: ARRAY
20352: EQUAL
20353: IFFALSE 20590
// begin lab := artifactsLabs [ 2 ] ;
20355: LD_ADDR_VAR 0 6
20359: PUSH
20360: LD_EXP 71
20364: PUSH
20365: LD_INT 2
20367: ARRAY
20368: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20369: LD_VAR 0 3
20373: PUSH
20374: LD_INT 81
20376: PUSH
20377: LD_INT 7
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: PUSH
20384: LD_INT 2
20386: PUSH
20387: LD_INT 32
20389: PUSH
20390: LD_INT 3
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 30
20399: PUSH
20400: LD_INT 28
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 30
20409: PUSH
20410: LD_INT 30
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 35
20419: PUSH
20420: LD_INT 49
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: PUSH
20427: LD_INT 34
20429: PUSH
20430: LD_INT 49
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: PUSH
20437: LD_INT 30
20439: PUSH
20440: LD_INT 21
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: IN
20465: NOT
20466: IFFALSE 20470
// exit ;
20468: GO 20857
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20470: LD_VAR 0 6
20474: PPUSH
20475: CALL_OW 274
20479: PPUSH
20480: CALL 89669 0 1
20484: PUSH
20485: LD_INT 3
20487: ARRAY
20488: PUSH
20489: LD_EXP 66
20493: PUSH
20494: LD_INT 2
20496: ARRAY
20497: LESS
20498: IFFALSE 20512
// begin HintSpec ( ArtifactCost , 2 ) ;
20500: LD_STRING ArtifactCost
20502: PPUSH
20503: LD_INT 2
20505: PPUSH
20506: CALL_OW 338
// exit ;
20510: GO 20857
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20512: LD_ADDR_EXP 73
20516: PUSH
20517: LD_EXP 73
20521: PPUSH
20522: LD_INT 2
20524: PPUSH
20525: LD_INT 0
20527: PPUSH
20528: CALL_OW 1
20532: ST_TO_ADDR
// KillUnit ( x ) ;
20533: LD_VAR 0 3
20537: PPUSH
20538: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20542: LD_ADDR_EXP 16
20546: PUSH
20547: LD_EXP 16
20551: PUSH
20552: LD_INT 1
20554: PLUS
20555: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20556: LD_EXP 65
20560: PUSH
20561: LD_INT 2
20563: ARRAY
20564: PPUSH
20565: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20569: LD_ADDR_EXP 73
20573: PUSH
20574: LD_EXP 73
20578: PPUSH
20579: LD_INT 2
20581: PPUSH
20582: LD_INT 1
20584: PPUSH
20585: CALL_OW 1
20589: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20590: LD_VAR 0 2
20594: PUSH
20595: LD_EXP 72
20599: PUSH
20600: LD_INT 3
20602: ARRAY
20603: PUSH
20604: LD_INT 1
20606: ARRAY
20607: EQUAL
20608: IFFALSE 20857
// begin lab := artifactsLabs [ 3 ] ;
20610: LD_ADDR_VAR 0 6
20614: PUSH
20615: LD_EXP 71
20619: PUSH
20620: LD_INT 3
20622: ARRAY
20623: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20624: LD_VAR 0 6
20628: PPUSH
20629: CALL_OW 274
20633: PPUSH
20634: CALL 89669 0 1
20638: PUSH
20639: LD_INT 3
20641: ARRAY
20642: PUSH
20643: LD_EXP 66
20647: PUSH
20648: LD_INT 3
20650: ARRAY
20651: LESS
20652: IFFALSE 20666
// begin HintSpec ( ArtifactCost , 2 ) ;
20654: LD_STRING ArtifactCost
20656: PPUSH
20657: LD_INT 2
20659: PPUSH
20660: CALL_OW 338
// exit ;
20664: GO 20857
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20666: LD_INT 37
20668: PPUSH
20669: LD_INT 1
20671: PPUSH
20672: CALL_OW 424
// time := 0 0$30 ;
20676: LD_ADDR_VAR 0 7
20680: PUSH
20681: LD_INT 1050
20683: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20684: LD_ADDR_EXP 73
20688: PUSH
20689: LD_EXP 73
20693: PPUSH
20694: LD_INT 3
20696: PPUSH
20697: LD_INT 0
20699: PPUSH
20700: CALL_OW 1
20704: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20705: LD_ADDR_OWVAR 47
20709: PUSH
20710: LD_STRING #Am15a-1
20712: PUSH
20713: LD_VAR 0 7
20717: PUSH
20718: EMPTY
20719: LIST
20720: LIST
20721: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20722: LD_INT 35
20724: PPUSH
20725: CALL_OW 67
// time := time - 0 0$1 ;
20729: LD_ADDR_VAR 0 7
20733: PUSH
20734: LD_VAR 0 7
20738: PUSH
20739: LD_INT 35
20741: MINUS
20742: ST_TO_ADDR
// until time = 0 0$00 ;
20743: LD_VAR 0 7
20747: PUSH
20748: LD_INT 0
20750: EQUAL
20751: IFFALSE 20705
// display_strings :=  ;
20753: LD_ADDR_OWVAR 47
20757: PUSH
20758: LD_STRING 
20760: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20761: LD_INT 37
20763: PPUSH
20764: LD_INT 0
20766: PPUSH
20767: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20771: LD_ADDR_VAR 0 8
20775: PUSH
20776: LD_INT 37
20778: PPUSH
20779: LD_INT 3
20781: PUSH
20782: LD_INT 21
20784: PUSH
20785: LD_INT 3
20787: PUSH
20788: EMPTY
20789: LIST
20790: LIST
20791: PUSH
20792: EMPTY
20793: LIST
20794: LIST
20795: PPUSH
20796: CALL_OW 70
20800: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20801: LD_VAR 0 3
20805: PPUSH
20806: LD_VAR 0 4
20810: PPUSH
20811: CALL_OW 84
// for un in list do
20815: LD_ADDR_VAR 0 9
20819: PUSH
20820: LD_VAR 0 8
20824: PUSH
20825: FOR_IN
20826: IFFALSE 20855
// TeleportUnit ( un , x , y , 12 , true ) ;
20828: LD_VAR 0 9
20832: PPUSH
20833: LD_VAR 0 3
20837: PPUSH
20838: LD_VAR 0 4
20842: PPUSH
20843: LD_INT 12
20845: PPUSH
20846: LD_INT 1
20848: PPUSH
20849: CALL_OW 483
20853: GO 20825
20855: POP
20856: POP
// end ; end ;
20857: PPOPN 9
20859: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20860: LD_INT 0
20862: PPUSH
20863: PPUSH
// begin labNum := 0 ;
20864: LD_ADDR_VAR 0 4
20868: PUSH
20869: LD_INT 0
20871: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20872: LD_ADDR_VAR 0 3
20876: PUSH
20877: DOUBLE
20878: LD_INT 1
20880: DEC
20881: ST_TO_ADDR
20882: LD_EXP 71
20886: PUSH
20887: FOR_TO
20888: IFFALSE 20922
// if artifactsLabs [ i ] = lab then
20890: LD_EXP 71
20894: PUSH
20895: LD_VAR 0 3
20899: ARRAY
20900: PUSH
20901: LD_VAR 0 1
20905: EQUAL
20906: IFFALSE 20920
// begin labNum := i ;
20908: LD_ADDR_VAR 0 4
20912: PUSH
20913: LD_VAR 0 3
20917: ST_TO_ADDR
// break ;
20918: GO 20922
// end ;
20920: GO 20887
20922: POP
20923: POP
// if not labNum then
20924: LD_VAR 0 4
20928: NOT
20929: IFFALSE 20933
// exit ;
20931: GO 21011
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20933: LD_INT 7
20935: PPUSH
20936: LD_EXP 72
20940: PUSH
20941: LD_VAR 0 4
20945: ARRAY
20946: PUSH
20947: LD_INT 3
20949: ARRAY
20950: PPUSH
20951: LD_INT 2
20953: PPUSH
20954: LD_VAR 0 1
20958: PPUSH
20959: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20963: LD_ADDR_EXP 70
20967: PUSH
20968: LD_EXP 70
20972: PPUSH
20973: LD_VAR 0 4
20977: PPUSH
20978: LD_VAR 0 2
20982: PPUSH
20983: CALL_OW 1
20987: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20988: LD_ADDR_EXP 68
20992: PUSH
20993: LD_EXP 68
20997: PPUSH
20998: LD_VAR 0 4
21002: PPUSH
21003: LD_INT 0
21005: PPUSH
21006: CALL_OW 1
21010: ST_TO_ADDR
// end ;
21011: PPOPN 4
21013: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21014: LD_INT 0
21016: PPUSH
21017: PPUSH
// begin labNum := 0 ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21026: LD_ADDR_VAR 0 2
21030: PUSH
21031: DOUBLE
21032: LD_INT 1
21034: DEC
21035: ST_TO_ADDR
21036: LD_EXP 71
21040: PUSH
21041: FOR_TO
21042: IFFALSE 21076
// if artifactsLabs [ i ] = lab then
21044: LD_EXP 71
21048: PUSH
21049: LD_VAR 0 2
21053: ARRAY
21054: PUSH
21055: LD_VAR 0 1
21059: EQUAL
21060: IFFALSE 21074
// begin labNum := i ;
21062: LD_ADDR_VAR 0 3
21066: PUSH
21067: LD_VAR 0 2
21071: ST_TO_ADDR
// break ;
21072: GO 21076
// end ;
21074: GO 21041
21076: POP
21077: POP
// if not labNum then
21078: LD_VAR 0 3
21082: NOT
21083: IFFALSE 21087
// exit ;
21085: GO 21249
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21087: LD_INT 7
21089: PPUSH
21090: LD_EXP 72
21094: PUSH
21095: LD_VAR 0 3
21099: ARRAY
21100: PUSH
21101: LD_INT 3
21103: ARRAY
21104: PPUSH
21105: LD_INT 0
21107: PPUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21117: LD_ADDR_EXP 67
21121: PUSH
21122: LD_EXP 67
21126: PPUSH
21127: LD_VAR 0 3
21131: PPUSH
21132: LD_INT 1
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21140: LD_ADDR_EXP 73
21144: PUSH
21145: LD_EXP 73
21149: PPUSH
21150: LD_VAR 0 3
21154: PPUSH
21155: LD_INT 1
21157: PPUSH
21158: CALL_OW 1
21162: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21163: LD_ADDR_EXP 68
21167: PUSH
21168: LD_EXP 68
21172: PPUSH
21173: LD_VAR 0 3
21177: PPUSH
21178: LD_INT 0
21180: PPUSH
21181: CALL_OW 1
21185: ST_TO_ADDR
// case labNum of 1 :
21186: LD_VAR 0 3
21190: PUSH
21191: LD_INT 1
21193: DOUBLE
21194: EQUAL
21195: IFTRUE 21199
21197: GO 21210
21199: POP
// artifactIResearched := true ; 2 :
21200: LD_ADDR_EXP 12
21204: PUSH
21205: LD_INT 1
21207: ST_TO_ADDR
21208: GO 21249
21210: LD_INT 2
21212: DOUBLE
21213: EQUAL
21214: IFTRUE 21218
21216: GO 21229
21218: POP
// artifactIIResearched := true ; 3 :
21219: LD_ADDR_EXP 13
21223: PUSH
21224: LD_INT 1
21226: ST_TO_ADDR
21227: GO 21249
21229: LD_INT 3
21231: DOUBLE
21232: EQUAL
21233: IFTRUE 21237
21235: GO 21248
21237: POP
// artifactIIIResearched := true ; end ;
21238: LD_ADDR_EXP 14
21242: PUSH
21243: LD_INT 1
21245: ST_TO_ADDR
21246: GO 21249
21248: POP
// end ; end_of_file
21249: PPOPN 3
21251: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
21252: LD_INT 0
21254: PPUSH
// ar_miner := 81 ;
21255: LD_ADDR_EXP 81
21259: PUSH
21260: LD_INT 81
21262: ST_TO_ADDR
// ar_crane := 88 ;
21263: LD_ADDR_EXP 80
21267: PUSH
21268: LD_INT 88
21270: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21271: LD_ADDR_EXP 75
21275: PUSH
21276: LD_INT 89
21278: ST_TO_ADDR
// us_hack := 99 ;
21279: LD_ADDR_EXP 76
21283: PUSH
21284: LD_INT 99
21286: ST_TO_ADDR
// us_artillery := 97 ;
21287: LD_ADDR_EXP 77
21291: PUSH
21292: LD_INT 97
21294: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21295: LD_ADDR_EXP 78
21299: PUSH
21300: LD_INT 91
21302: ST_TO_ADDR
// ar_mortar := 92 ;
21303: LD_ADDR_EXP 79
21307: PUSH
21308: LD_INT 92
21310: ST_TO_ADDR
// ru_flamethrower := 93 ;
21311: LD_ADDR_EXP 82
21315: PUSH
21316: LD_INT 93
21318: ST_TO_ADDR
// ru_radar := 98 ;
21319: LD_ADDR_EXP 74
21323: PUSH
21324: LD_INT 98
21326: ST_TO_ADDR
// tech_Artillery := 80 ;
21327: LD_ADDR_EXP 83
21331: PUSH
21332: LD_INT 80
21334: ST_TO_ADDR
// tech_RadMat := 81 ;
21335: LD_ADDR_EXP 84
21339: PUSH
21340: LD_INT 81
21342: ST_TO_ADDR
// tech_BasicTools := 82 ;
21343: LD_ADDR_EXP 85
21347: PUSH
21348: LD_INT 82
21350: ST_TO_ADDR
// tech_Cargo := 83 ;
21351: LD_ADDR_EXP 86
21355: PUSH
21356: LD_INT 83
21358: ST_TO_ADDR
// tech_Track := 84 ;
21359: LD_ADDR_EXP 87
21363: PUSH
21364: LD_INT 84
21366: ST_TO_ADDR
// tech_Crane := 85 ;
21367: LD_ADDR_EXP 88
21371: PUSH
21372: LD_INT 85
21374: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21375: LD_ADDR_EXP 89
21379: PUSH
21380: LD_INT 86
21382: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21383: LD_ADDR_EXP 90
21387: PUSH
21388: LD_INT 87
21390: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21391: LD_ADDR_EXP 91
21395: PUSH
21396: LD_INT 88
21398: ST_TO_ADDR
// end ;
21399: LD_VAR 0 1
21403: RET
// every 1 do
21404: GO 21406
21406: DISABLE
// InitGlobalVariables ; end_of_file
21407: CALL 21252 0 0
21411: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21412: LD_INT 0
21414: PPUSH
21415: PPUSH
// skirmish := false ;
21416: LD_ADDR_EXP 92
21420: PUSH
21421: LD_INT 0
21423: ST_TO_ADDR
// debug_mc := false ;
21424: LD_ADDR_EXP 93
21428: PUSH
21429: LD_INT 0
21431: ST_TO_ADDR
// mc_bases := [ ] ;
21432: LD_ADDR_EXP 94
21436: PUSH
21437: EMPTY
21438: ST_TO_ADDR
// mc_sides := [ ] ;
21439: LD_ADDR_EXP 120
21443: PUSH
21444: EMPTY
21445: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21446: LD_ADDR_EXP 95
21450: PUSH
21451: EMPTY
21452: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21453: LD_ADDR_EXP 96
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// mc_need_heal := [ ] ;
21460: LD_ADDR_EXP 97
21464: PUSH
21465: EMPTY
21466: ST_TO_ADDR
// mc_healers := [ ] ;
21467: LD_ADDR_EXP 98
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// mc_build_list := [ ] ;
21474: LD_ADDR_EXP 99
21478: PUSH
21479: EMPTY
21480: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21481: LD_ADDR_EXP 126
21485: PUSH
21486: EMPTY
21487: ST_TO_ADDR
// mc_builders := [ ] ;
21488: LD_ADDR_EXP 100
21492: PUSH
21493: EMPTY
21494: ST_TO_ADDR
// mc_construct_list := [ ] ;
21495: LD_ADDR_EXP 101
21499: PUSH
21500: EMPTY
21501: ST_TO_ADDR
// mc_turret_list := [ ] ;
21502: LD_ADDR_EXP 102
21506: PUSH
21507: EMPTY
21508: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21509: LD_ADDR_EXP 103
21513: PUSH
21514: EMPTY
21515: ST_TO_ADDR
// mc_miners := [ ] ;
21516: LD_ADDR_EXP 108
21520: PUSH
21521: EMPTY
21522: ST_TO_ADDR
// mc_mines := [ ] ;
21523: LD_ADDR_EXP 107
21527: PUSH
21528: EMPTY
21529: ST_TO_ADDR
// mc_minefields := [ ] ;
21530: LD_ADDR_EXP 109
21534: PUSH
21535: EMPTY
21536: ST_TO_ADDR
// mc_crates := [ ] ;
21537: LD_ADDR_EXP 110
21541: PUSH
21542: EMPTY
21543: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21544: LD_ADDR_EXP 111
21548: PUSH
21549: EMPTY
21550: ST_TO_ADDR
// mc_crates_area := [ ] ;
21551: LD_ADDR_EXP 112
21555: PUSH
21556: EMPTY
21557: ST_TO_ADDR
// mc_vehicles := [ ] ;
21558: LD_ADDR_EXP 113
21562: PUSH
21563: EMPTY
21564: ST_TO_ADDR
// mc_attack := [ ] ;
21565: LD_ADDR_EXP 114
21569: PUSH
21570: EMPTY
21571: ST_TO_ADDR
// mc_produce := [ ] ;
21572: LD_ADDR_EXP 115
21576: PUSH
21577: EMPTY
21578: ST_TO_ADDR
// mc_defender := [ ] ;
21579: LD_ADDR_EXP 116
21583: PUSH
21584: EMPTY
21585: ST_TO_ADDR
// mc_parking := [ ] ;
21586: LD_ADDR_EXP 118
21590: PUSH
21591: EMPTY
21592: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21593: LD_ADDR_EXP 104
21597: PUSH
21598: EMPTY
21599: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21600: LD_ADDR_EXP 106
21604: PUSH
21605: EMPTY
21606: ST_TO_ADDR
// mc_scan := [ ] ;
21607: LD_ADDR_EXP 117
21611: PUSH
21612: EMPTY
21613: ST_TO_ADDR
// mc_scan_area := [ ] ;
21614: LD_ADDR_EXP 119
21618: PUSH
21619: EMPTY
21620: ST_TO_ADDR
// mc_tech := [ ] ;
21621: LD_ADDR_EXP 121
21625: PUSH
21626: EMPTY
21627: ST_TO_ADDR
// mc_class := [ ] ;
21628: LD_ADDR_EXP 135
21632: PUSH
21633: EMPTY
21634: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21635: LD_ADDR_EXP 136
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// mc_is_defending := [ ] ;
21642: LD_ADDR_EXP 137
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// end ;
21649: LD_VAR 0 1
21653: RET
// export function MC_Kill ( base ) ; begin
21654: LD_INT 0
21656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21657: LD_ADDR_EXP 94
21661: PUSH
21662: LD_EXP 94
21666: PPUSH
21667: LD_VAR 0 1
21671: PPUSH
21672: EMPTY
21673: PPUSH
21674: CALL_OW 1
21678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21679: LD_ADDR_EXP 95
21683: PUSH
21684: LD_EXP 95
21688: PPUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: EMPTY
21695: PPUSH
21696: CALL_OW 1
21700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21701: LD_ADDR_EXP 96
21705: PUSH
21706: LD_EXP 96
21710: PPUSH
21711: LD_VAR 0 1
21715: PPUSH
21716: EMPTY
21717: PPUSH
21718: CALL_OW 1
21722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21723: LD_ADDR_EXP 97
21727: PUSH
21728: LD_EXP 97
21732: PPUSH
21733: LD_VAR 0 1
21737: PPUSH
21738: EMPTY
21739: PPUSH
21740: CALL_OW 1
21744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21745: LD_ADDR_EXP 98
21749: PUSH
21750: LD_EXP 98
21754: PPUSH
21755: LD_VAR 0 1
21759: PPUSH
21760: EMPTY
21761: PPUSH
21762: CALL_OW 1
21766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21767: LD_ADDR_EXP 99
21771: PUSH
21772: LD_EXP 99
21776: PPUSH
21777: LD_VAR 0 1
21781: PPUSH
21782: EMPTY
21783: PPUSH
21784: CALL_OW 1
21788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21789: LD_ADDR_EXP 100
21793: PUSH
21794: LD_EXP 100
21798: PPUSH
21799: LD_VAR 0 1
21803: PPUSH
21804: EMPTY
21805: PPUSH
21806: CALL_OW 1
21810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21811: LD_ADDR_EXP 101
21815: PUSH
21816: LD_EXP 101
21820: PPUSH
21821: LD_VAR 0 1
21825: PPUSH
21826: EMPTY
21827: PPUSH
21828: CALL_OW 1
21832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21833: LD_ADDR_EXP 102
21837: PUSH
21838: LD_EXP 102
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: EMPTY
21849: PPUSH
21850: CALL_OW 1
21854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21855: LD_ADDR_EXP 103
21859: PUSH
21860: LD_EXP 103
21864: PPUSH
21865: LD_VAR 0 1
21869: PPUSH
21870: EMPTY
21871: PPUSH
21872: CALL_OW 1
21876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21877: LD_ADDR_EXP 104
21881: PUSH
21882: LD_EXP 104
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: EMPTY
21893: PPUSH
21894: CALL_OW 1
21898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21899: LD_ADDR_EXP 105
21903: PUSH
21904: LD_EXP 105
21908: PPUSH
21909: LD_VAR 0 1
21913: PPUSH
21914: LD_INT 0
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21922: LD_ADDR_EXP 106
21926: PUSH
21927: LD_EXP 106
21931: PPUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21944: LD_ADDR_EXP 107
21948: PUSH
21949: LD_EXP 107
21953: PPUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21966: LD_ADDR_EXP 108
21970: PUSH
21971: LD_EXP 108
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21988: LD_ADDR_EXP 109
21992: PUSH
21993: LD_EXP 109
21997: PPUSH
21998: LD_VAR 0 1
22002: PPUSH
22003: EMPTY
22004: PPUSH
22005: CALL_OW 1
22009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22010: LD_ADDR_EXP 110
22014: PUSH
22015: LD_EXP 110
22019: PPUSH
22020: LD_VAR 0 1
22024: PPUSH
22025: EMPTY
22026: PPUSH
22027: CALL_OW 1
22031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22032: LD_ADDR_EXP 111
22036: PUSH
22037: LD_EXP 111
22041: PPUSH
22042: LD_VAR 0 1
22046: PPUSH
22047: EMPTY
22048: PPUSH
22049: CALL_OW 1
22053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22054: LD_ADDR_EXP 112
22058: PUSH
22059: LD_EXP 112
22063: PPUSH
22064: LD_VAR 0 1
22068: PPUSH
22069: EMPTY
22070: PPUSH
22071: CALL_OW 1
22075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22076: LD_ADDR_EXP 113
22080: PUSH
22081: LD_EXP 113
22085: PPUSH
22086: LD_VAR 0 1
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL_OW 1
22097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22098: LD_ADDR_EXP 114
22102: PUSH
22103: LD_EXP 114
22107: PPUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: EMPTY
22114: PPUSH
22115: CALL_OW 1
22119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22120: LD_ADDR_EXP 115
22124: PUSH
22125: LD_EXP 115
22129: PPUSH
22130: LD_VAR 0 1
22134: PPUSH
22135: EMPTY
22136: PPUSH
22137: CALL_OW 1
22141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22142: LD_ADDR_EXP 116
22146: PUSH
22147: LD_EXP 116
22151: PPUSH
22152: LD_VAR 0 1
22156: PPUSH
22157: EMPTY
22158: PPUSH
22159: CALL_OW 1
22163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22164: LD_ADDR_EXP 117
22168: PUSH
22169: LD_EXP 117
22173: PPUSH
22174: LD_VAR 0 1
22178: PPUSH
22179: EMPTY
22180: PPUSH
22181: CALL_OW 1
22185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22186: LD_ADDR_EXP 118
22190: PUSH
22191: LD_EXP 118
22195: PPUSH
22196: LD_VAR 0 1
22200: PPUSH
22201: EMPTY
22202: PPUSH
22203: CALL_OW 1
22207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22208: LD_ADDR_EXP 119
22212: PUSH
22213: LD_EXP 119
22217: PPUSH
22218: LD_VAR 0 1
22222: PPUSH
22223: EMPTY
22224: PPUSH
22225: CALL_OW 1
22229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22230: LD_ADDR_EXP 121
22234: PUSH
22235: LD_EXP 121
22239: PPUSH
22240: LD_VAR 0 1
22244: PPUSH
22245: EMPTY
22246: PPUSH
22247: CALL_OW 1
22251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22252: LD_ADDR_EXP 123
22256: PUSH
22257: LD_EXP 123
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: EMPTY
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22274: LD_ADDR_EXP 124
22278: PUSH
22279: LD_EXP 124
22283: PPUSH
22284: LD_VAR 0 1
22288: PPUSH
22289: EMPTY
22290: PPUSH
22291: CALL_OW 1
22295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22296: LD_ADDR_EXP 125
22300: PUSH
22301: LD_EXP 125
22305: PPUSH
22306: LD_VAR 0 1
22310: PPUSH
22311: EMPTY
22312: PPUSH
22313: CALL_OW 1
22317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22318: LD_ADDR_EXP 126
22322: PUSH
22323: LD_EXP 126
22327: PPUSH
22328: LD_VAR 0 1
22332: PPUSH
22333: EMPTY
22334: PPUSH
22335: CALL_OW 1
22339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22340: LD_ADDR_EXP 127
22344: PUSH
22345: LD_EXP 127
22349: PPUSH
22350: LD_VAR 0 1
22354: PPUSH
22355: EMPTY
22356: PPUSH
22357: CALL_OW 1
22361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22362: LD_ADDR_EXP 128
22366: PUSH
22367: LD_EXP 128
22371: PPUSH
22372: LD_VAR 0 1
22376: PPUSH
22377: EMPTY
22378: PPUSH
22379: CALL_OW 1
22383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22384: LD_ADDR_EXP 129
22388: PUSH
22389: LD_EXP 129
22393: PPUSH
22394: LD_VAR 0 1
22398: PPUSH
22399: EMPTY
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22406: LD_ADDR_EXP 130
22410: PUSH
22411: LD_EXP 130
22415: PPUSH
22416: LD_VAR 0 1
22420: PPUSH
22421: EMPTY
22422: PPUSH
22423: CALL_OW 1
22427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22428: LD_ADDR_EXP 131
22432: PUSH
22433: LD_EXP 131
22437: PPUSH
22438: LD_VAR 0 1
22442: PPUSH
22443: EMPTY
22444: PPUSH
22445: CALL_OW 1
22449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22450: LD_ADDR_EXP 132
22454: PUSH
22455: LD_EXP 132
22459: PPUSH
22460: LD_VAR 0 1
22464: PPUSH
22465: EMPTY
22466: PPUSH
22467: CALL_OW 1
22471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22472: LD_ADDR_EXP 133
22476: PUSH
22477: LD_EXP 133
22481: PPUSH
22482: LD_VAR 0 1
22486: PPUSH
22487: EMPTY
22488: PPUSH
22489: CALL_OW 1
22493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22494: LD_ADDR_EXP 134
22498: PUSH
22499: LD_EXP 134
22503: PPUSH
22504: LD_VAR 0 1
22508: PPUSH
22509: EMPTY
22510: PPUSH
22511: CALL_OW 1
22515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22516: LD_ADDR_EXP 135
22520: PUSH
22521: LD_EXP 135
22525: PPUSH
22526: LD_VAR 0 1
22530: PPUSH
22531: EMPTY
22532: PPUSH
22533: CALL_OW 1
22537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22538: LD_ADDR_EXP 136
22542: PUSH
22543: LD_EXP 136
22547: PPUSH
22548: LD_VAR 0 1
22552: PPUSH
22553: LD_INT 0
22555: PPUSH
22556: CALL_OW 1
22560: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22561: LD_ADDR_EXP 137
22565: PUSH
22566: LD_EXP 137
22570: PPUSH
22571: LD_VAR 0 1
22575: PPUSH
22576: LD_INT 0
22578: PPUSH
22579: CALL_OW 1
22583: ST_TO_ADDR
// end ;
22584: LD_VAR 0 2
22588: RET
// export function MC_Add ( side , units ) ; var base ; begin
22589: LD_INT 0
22591: PPUSH
22592: PPUSH
// base := mc_bases + 1 ;
22593: LD_ADDR_VAR 0 4
22597: PUSH
22598: LD_EXP 94
22602: PUSH
22603: LD_INT 1
22605: PLUS
22606: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22607: LD_ADDR_EXP 120
22611: PUSH
22612: LD_EXP 120
22616: PPUSH
22617: LD_VAR 0 4
22621: PPUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: CALL_OW 1
22631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22632: LD_ADDR_EXP 94
22636: PUSH
22637: LD_EXP 94
22641: PPUSH
22642: LD_VAR 0 4
22646: PPUSH
22647: LD_VAR 0 2
22651: PPUSH
22652: CALL_OW 1
22656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22657: LD_ADDR_EXP 95
22661: PUSH
22662: LD_EXP 95
22666: PPUSH
22667: LD_VAR 0 4
22671: PPUSH
22672: EMPTY
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22679: LD_ADDR_EXP 96
22683: PUSH
22684: LD_EXP 96
22688: PPUSH
22689: LD_VAR 0 4
22693: PPUSH
22694: EMPTY
22695: PPUSH
22696: CALL_OW 1
22700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22701: LD_ADDR_EXP 97
22705: PUSH
22706: LD_EXP 97
22710: PPUSH
22711: LD_VAR 0 4
22715: PPUSH
22716: EMPTY
22717: PPUSH
22718: CALL_OW 1
22722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22723: LD_ADDR_EXP 98
22727: PUSH
22728: LD_EXP 98
22732: PPUSH
22733: LD_VAR 0 4
22737: PPUSH
22738: EMPTY
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22745: LD_ADDR_EXP 99
22749: PUSH
22750: LD_EXP 99
22754: PPUSH
22755: LD_VAR 0 4
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22767: LD_ADDR_EXP 100
22771: PUSH
22772: LD_EXP 100
22776: PPUSH
22777: LD_VAR 0 4
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22789: LD_ADDR_EXP 101
22793: PUSH
22794: LD_EXP 101
22798: PPUSH
22799: LD_VAR 0 4
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22811: LD_ADDR_EXP 102
22815: PUSH
22816: LD_EXP 102
22820: PPUSH
22821: LD_VAR 0 4
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22833: LD_ADDR_EXP 103
22837: PUSH
22838: LD_EXP 103
22842: PPUSH
22843: LD_VAR 0 4
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22855: LD_ADDR_EXP 104
22859: PUSH
22860: LD_EXP 104
22864: PPUSH
22865: LD_VAR 0 4
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22877: LD_ADDR_EXP 105
22881: PUSH
22882: LD_EXP 105
22886: PPUSH
22887: LD_VAR 0 4
22891: PPUSH
22892: LD_INT 0
22894: PPUSH
22895: CALL_OW 1
22899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22900: LD_ADDR_EXP 106
22904: PUSH
22905: LD_EXP 106
22909: PPUSH
22910: LD_VAR 0 4
22914: PPUSH
22915: EMPTY
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22922: LD_ADDR_EXP 107
22926: PUSH
22927: LD_EXP 107
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: EMPTY
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22944: LD_ADDR_EXP 108
22948: PUSH
22949: LD_EXP 108
22953: PPUSH
22954: LD_VAR 0 4
22958: PPUSH
22959: EMPTY
22960: PPUSH
22961: CALL_OW 1
22965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22966: LD_ADDR_EXP 109
22970: PUSH
22971: LD_EXP 109
22975: PPUSH
22976: LD_VAR 0 4
22980: PPUSH
22981: EMPTY
22982: PPUSH
22983: CALL_OW 1
22987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22988: LD_ADDR_EXP 110
22992: PUSH
22993: LD_EXP 110
22997: PPUSH
22998: LD_VAR 0 4
23002: PPUSH
23003: EMPTY
23004: PPUSH
23005: CALL_OW 1
23009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23010: LD_ADDR_EXP 111
23014: PUSH
23015: LD_EXP 111
23019: PPUSH
23020: LD_VAR 0 4
23024: PPUSH
23025: EMPTY
23026: PPUSH
23027: CALL_OW 1
23031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23032: LD_ADDR_EXP 112
23036: PUSH
23037: LD_EXP 112
23041: PPUSH
23042: LD_VAR 0 4
23046: PPUSH
23047: EMPTY
23048: PPUSH
23049: CALL_OW 1
23053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23054: LD_ADDR_EXP 113
23058: PUSH
23059: LD_EXP 113
23063: PPUSH
23064: LD_VAR 0 4
23068: PPUSH
23069: EMPTY
23070: PPUSH
23071: CALL_OW 1
23075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23076: LD_ADDR_EXP 114
23080: PUSH
23081: LD_EXP 114
23085: PPUSH
23086: LD_VAR 0 4
23090: PPUSH
23091: EMPTY
23092: PPUSH
23093: CALL_OW 1
23097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23098: LD_ADDR_EXP 115
23102: PUSH
23103: LD_EXP 115
23107: PPUSH
23108: LD_VAR 0 4
23112: PPUSH
23113: EMPTY
23114: PPUSH
23115: CALL_OW 1
23119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23120: LD_ADDR_EXP 116
23124: PUSH
23125: LD_EXP 116
23129: PPUSH
23130: LD_VAR 0 4
23134: PPUSH
23135: EMPTY
23136: PPUSH
23137: CALL_OW 1
23141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23142: LD_ADDR_EXP 117
23146: PUSH
23147: LD_EXP 117
23151: PPUSH
23152: LD_VAR 0 4
23156: PPUSH
23157: EMPTY
23158: PPUSH
23159: CALL_OW 1
23163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23164: LD_ADDR_EXP 118
23168: PUSH
23169: LD_EXP 118
23173: PPUSH
23174: LD_VAR 0 4
23178: PPUSH
23179: EMPTY
23180: PPUSH
23181: CALL_OW 1
23185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23186: LD_ADDR_EXP 119
23190: PUSH
23191: LD_EXP 119
23195: PPUSH
23196: LD_VAR 0 4
23200: PPUSH
23201: EMPTY
23202: PPUSH
23203: CALL_OW 1
23207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23208: LD_ADDR_EXP 121
23212: PUSH
23213: LD_EXP 121
23217: PPUSH
23218: LD_VAR 0 4
23222: PPUSH
23223: EMPTY
23224: PPUSH
23225: CALL_OW 1
23229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23230: LD_ADDR_EXP 123
23234: PUSH
23235: LD_EXP 123
23239: PPUSH
23240: LD_VAR 0 4
23244: PPUSH
23245: EMPTY
23246: PPUSH
23247: CALL_OW 1
23251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23252: LD_ADDR_EXP 124
23256: PUSH
23257: LD_EXP 124
23261: PPUSH
23262: LD_VAR 0 4
23266: PPUSH
23267: EMPTY
23268: PPUSH
23269: CALL_OW 1
23273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23274: LD_ADDR_EXP 125
23278: PUSH
23279: LD_EXP 125
23283: PPUSH
23284: LD_VAR 0 4
23288: PPUSH
23289: EMPTY
23290: PPUSH
23291: CALL_OW 1
23295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23296: LD_ADDR_EXP 126
23300: PUSH
23301: LD_EXP 126
23305: PPUSH
23306: LD_VAR 0 4
23310: PPUSH
23311: EMPTY
23312: PPUSH
23313: CALL_OW 1
23317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23318: LD_ADDR_EXP 127
23322: PUSH
23323: LD_EXP 127
23327: PPUSH
23328: LD_VAR 0 4
23332: PPUSH
23333: EMPTY
23334: PPUSH
23335: CALL_OW 1
23339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23340: LD_ADDR_EXP 128
23344: PUSH
23345: LD_EXP 128
23349: PPUSH
23350: LD_VAR 0 4
23354: PPUSH
23355: EMPTY
23356: PPUSH
23357: CALL_OW 1
23361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23362: LD_ADDR_EXP 129
23366: PUSH
23367: LD_EXP 129
23371: PPUSH
23372: LD_VAR 0 4
23376: PPUSH
23377: EMPTY
23378: PPUSH
23379: CALL_OW 1
23383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23384: LD_ADDR_EXP 130
23388: PUSH
23389: LD_EXP 130
23393: PPUSH
23394: LD_VAR 0 4
23398: PPUSH
23399: EMPTY
23400: PPUSH
23401: CALL_OW 1
23405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23406: LD_ADDR_EXP 131
23410: PUSH
23411: LD_EXP 131
23415: PPUSH
23416: LD_VAR 0 4
23420: PPUSH
23421: EMPTY
23422: PPUSH
23423: CALL_OW 1
23427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23428: LD_ADDR_EXP 132
23432: PUSH
23433: LD_EXP 132
23437: PPUSH
23438: LD_VAR 0 4
23442: PPUSH
23443: EMPTY
23444: PPUSH
23445: CALL_OW 1
23449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23450: LD_ADDR_EXP 133
23454: PUSH
23455: LD_EXP 133
23459: PPUSH
23460: LD_VAR 0 4
23464: PPUSH
23465: EMPTY
23466: PPUSH
23467: CALL_OW 1
23471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23472: LD_ADDR_EXP 134
23476: PUSH
23477: LD_EXP 134
23481: PPUSH
23482: LD_VAR 0 4
23486: PPUSH
23487: EMPTY
23488: PPUSH
23489: CALL_OW 1
23493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23494: LD_ADDR_EXP 135
23498: PUSH
23499: LD_EXP 135
23503: PPUSH
23504: LD_VAR 0 4
23508: PPUSH
23509: EMPTY
23510: PPUSH
23511: CALL_OW 1
23515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23516: LD_ADDR_EXP 136
23520: PUSH
23521: LD_EXP 136
23525: PPUSH
23526: LD_VAR 0 4
23530: PPUSH
23531: LD_INT 0
23533: PPUSH
23534: CALL_OW 1
23538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23539: LD_ADDR_EXP 137
23543: PUSH
23544: LD_EXP 137
23548: PPUSH
23549: LD_VAR 0 4
23553: PPUSH
23554: LD_INT 0
23556: PPUSH
23557: CALL_OW 1
23561: ST_TO_ADDR
// result := base ;
23562: LD_ADDR_VAR 0 3
23566: PUSH
23567: LD_VAR 0 4
23571: ST_TO_ADDR
// end ;
23572: LD_VAR 0 3
23576: RET
// export function MC_Start ( ) ; var i ; begin
23577: LD_INT 0
23579: PPUSH
23580: PPUSH
// for i = 1 to mc_bases do
23581: LD_ADDR_VAR 0 2
23585: PUSH
23586: DOUBLE
23587: LD_INT 1
23589: DEC
23590: ST_TO_ADDR
23591: LD_EXP 94
23595: PUSH
23596: FOR_TO
23597: IFFALSE 24697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23599: LD_ADDR_EXP 94
23603: PUSH
23604: LD_EXP 94
23608: PPUSH
23609: LD_VAR 0 2
23613: PPUSH
23614: LD_EXP 94
23618: PUSH
23619: LD_VAR 0 2
23623: ARRAY
23624: PUSH
23625: LD_INT 0
23627: DIFF
23628: PPUSH
23629: CALL_OW 1
23633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23634: LD_ADDR_EXP 95
23638: PUSH
23639: LD_EXP 95
23643: PPUSH
23644: LD_VAR 0 2
23648: PPUSH
23649: EMPTY
23650: PPUSH
23651: CALL_OW 1
23655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23656: LD_ADDR_EXP 96
23660: PUSH
23661: LD_EXP 96
23665: PPUSH
23666: LD_VAR 0 2
23670: PPUSH
23671: EMPTY
23672: PPUSH
23673: CALL_OW 1
23677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23678: LD_ADDR_EXP 97
23682: PUSH
23683: LD_EXP 97
23687: PPUSH
23688: LD_VAR 0 2
23692: PPUSH
23693: EMPTY
23694: PPUSH
23695: CALL_OW 1
23699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23700: LD_ADDR_EXP 98
23704: PUSH
23705: LD_EXP 98
23709: PPUSH
23710: LD_VAR 0 2
23714: PPUSH
23715: EMPTY
23716: PUSH
23717: EMPTY
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: PPUSH
23723: CALL_OW 1
23727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23728: LD_ADDR_EXP 99
23732: PUSH
23733: LD_EXP 99
23737: PPUSH
23738: LD_VAR 0 2
23742: PPUSH
23743: EMPTY
23744: PPUSH
23745: CALL_OW 1
23749: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23750: LD_ADDR_EXP 126
23754: PUSH
23755: LD_EXP 126
23759: PPUSH
23760: LD_VAR 0 2
23764: PPUSH
23765: EMPTY
23766: PPUSH
23767: CALL_OW 1
23771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23772: LD_ADDR_EXP 100
23776: PUSH
23777: LD_EXP 100
23781: PPUSH
23782: LD_VAR 0 2
23786: PPUSH
23787: EMPTY
23788: PPUSH
23789: CALL_OW 1
23793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23794: LD_ADDR_EXP 101
23798: PUSH
23799: LD_EXP 101
23803: PPUSH
23804: LD_VAR 0 2
23808: PPUSH
23809: EMPTY
23810: PPUSH
23811: CALL_OW 1
23815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23816: LD_ADDR_EXP 102
23820: PUSH
23821: LD_EXP 102
23825: PPUSH
23826: LD_VAR 0 2
23830: PPUSH
23831: LD_EXP 94
23835: PUSH
23836: LD_VAR 0 2
23840: ARRAY
23841: PPUSH
23842: LD_INT 2
23844: PUSH
23845: LD_INT 30
23847: PUSH
23848: LD_INT 32
23850: PUSH
23851: EMPTY
23852: LIST
23853: LIST
23854: PUSH
23855: LD_INT 30
23857: PUSH
23858: LD_INT 33
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: LIST
23869: PPUSH
23870: CALL_OW 72
23874: PPUSH
23875: CALL_OW 1
23879: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23880: LD_ADDR_EXP 103
23884: PUSH
23885: LD_EXP 103
23889: PPUSH
23890: LD_VAR 0 2
23894: PPUSH
23895: LD_EXP 94
23899: PUSH
23900: LD_VAR 0 2
23904: ARRAY
23905: PPUSH
23906: LD_INT 2
23908: PUSH
23909: LD_INT 30
23911: PUSH
23912: LD_INT 32
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: PUSH
23919: LD_INT 30
23921: PUSH
23922: LD_INT 31
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: PUSH
23929: EMPTY
23930: LIST
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 58
23936: PUSH
23937: EMPTY
23938: LIST
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PPUSH
23944: CALL_OW 72
23948: PPUSH
23949: CALL_OW 1
23953: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23954: LD_ADDR_EXP 104
23958: PUSH
23959: LD_EXP 104
23963: PPUSH
23964: LD_VAR 0 2
23968: PPUSH
23969: EMPTY
23970: PPUSH
23971: CALL_OW 1
23975: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23976: LD_ADDR_EXP 108
23980: PUSH
23981: LD_EXP 108
23985: PPUSH
23986: LD_VAR 0 2
23990: PPUSH
23991: EMPTY
23992: PPUSH
23993: CALL_OW 1
23997: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23998: LD_ADDR_EXP 107
24002: PUSH
24003: LD_EXP 107
24007: PPUSH
24008: LD_VAR 0 2
24012: PPUSH
24013: EMPTY
24014: PPUSH
24015: CALL_OW 1
24019: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24020: LD_ADDR_EXP 109
24024: PUSH
24025: LD_EXP 109
24029: PPUSH
24030: LD_VAR 0 2
24034: PPUSH
24035: EMPTY
24036: PPUSH
24037: CALL_OW 1
24041: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24042: LD_ADDR_EXP 110
24046: PUSH
24047: LD_EXP 110
24051: PPUSH
24052: LD_VAR 0 2
24056: PPUSH
24057: EMPTY
24058: PPUSH
24059: CALL_OW 1
24063: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24064: LD_ADDR_EXP 111
24068: PUSH
24069: LD_EXP 111
24073: PPUSH
24074: LD_VAR 0 2
24078: PPUSH
24079: EMPTY
24080: PPUSH
24081: CALL_OW 1
24085: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24086: LD_ADDR_EXP 112
24090: PUSH
24091: LD_EXP 112
24095: PPUSH
24096: LD_VAR 0 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL_OW 1
24107: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24108: LD_ADDR_EXP 113
24112: PUSH
24113: LD_EXP 113
24117: PPUSH
24118: LD_VAR 0 2
24122: PPUSH
24123: EMPTY
24124: PPUSH
24125: CALL_OW 1
24129: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24130: LD_ADDR_EXP 114
24134: PUSH
24135: LD_EXP 114
24139: PPUSH
24140: LD_VAR 0 2
24144: PPUSH
24145: EMPTY
24146: PPUSH
24147: CALL_OW 1
24151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24152: LD_ADDR_EXP 115
24156: PUSH
24157: LD_EXP 115
24161: PPUSH
24162: LD_VAR 0 2
24166: PPUSH
24167: EMPTY
24168: PPUSH
24169: CALL_OW 1
24173: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24174: LD_ADDR_EXP 116
24178: PUSH
24179: LD_EXP 116
24183: PPUSH
24184: LD_VAR 0 2
24188: PPUSH
24189: EMPTY
24190: PPUSH
24191: CALL_OW 1
24195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24196: LD_ADDR_EXP 105
24200: PUSH
24201: LD_EXP 105
24205: PPUSH
24206: LD_VAR 0 2
24210: PPUSH
24211: LD_INT 0
24213: PPUSH
24214: CALL_OW 1
24218: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24219: LD_ADDR_EXP 118
24223: PUSH
24224: LD_EXP 118
24228: PPUSH
24229: LD_VAR 0 2
24233: PPUSH
24234: LD_INT 0
24236: PPUSH
24237: CALL_OW 1
24241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24242: LD_ADDR_EXP 106
24246: PUSH
24247: LD_EXP 106
24251: PPUSH
24252: LD_VAR 0 2
24256: PPUSH
24257: EMPTY
24258: PPUSH
24259: CALL_OW 1
24263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24264: LD_ADDR_EXP 117
24268: PUSH
24269: LD_EXP 117
24273: PPUSH
24274: LD_VAR 0 2
24278: PPUSH
24279: LD_INT 0
24281: PPUSH
24282: CALL_OW 1
24286: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24287: LD_ADDR_EXP 119
24291: PUSH
24292: LD_EXP 119
24296: PPUSH
24297: LD_VAR 0 2
24301: PPUSH
24302: EMPTY
24303: PPUSH
24304: CALL_OW 1
24308: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24309: LD_ADDR_EXP 122
24313: PUSH
24314: LD_EXP 122
24318: PPUSH
24319: LD_VAR 0 2
24323: PPUSH
24324: LD_INT 0
24326: PPUSH
24327: CALL_OW 1
24331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24332: LD_ADDR_EXP 123
24336: PUSH
24337: LD_EXP 123
24341: PPUSH
24342: LD_VAR 0 2
24346: PPUSH
24347: EMPTY
24348: PPUSH
24349: CALL_OW 1
24353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24354: LD_ADDR_EXP 124
24358: PUSH
24359: LD_EXP 124
24363: PPUSH
24364: LD_VAR 0 2
24368: PPUSH
24369: EMPTY
24370: PPUSH
24371: CALL_OW 1
24375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24376: LD_ADDR_EXP 125
24380: PUSH
24381: LD_EXP 125
24385: PPUSH
24386: LD_VAR 0 2
24390: PPUSH
24391: EMPTY
24392: PPUSH
24393: CALL_OW 1
24397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24398: LD_ADDR_EXP 127
24402: PUSH
24403: LD_EXP 127
24407: PPUSH
24408: LD_VAR 0 2
24412: PPUSH
24413: LD_EXP 94
24417: PUSH
24418: LD_VAR 0 2
24422: ARRAY
24423: PPUSH
24424: LD_INT 2
24426: PUSH
24427: LD_INT 30
24429: PUSH
24430: LD_INT 6
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: PUSH
24437: LD_INT 30
24439: PUSH
24440: LD_INT 7
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 30
24449: PUSH
24450: LD_INT 8
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: LIST
24461: LIST
24462: PPUSH
24463: CALL_OW 72
24467: PPUSH
24468: CALL_OW 1
24472: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24473: LD_ADDR_EXP 128
24477: PUSH
24478: LD_EXP 128
24482: PPUSH
24483: LD_VAR 0 2
24487: PPUSH
24488: EMPTY
24489: PPUSH
24490: CALL_OW 1
24494: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24495: LD_ADDR_EXP 129
24499: PUSH
24500: LD_EXP 129
24504: PPUSH
24505: LD_VAR 0 2
24509: PPUSH
24510: EMPTY
24511: PPUSH
24512: CALL_OW 1
24516: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24517: LD_ADDR_EXP 130
24521: PUSH
24522: LD_EXP 130
24526: PPUSH
24527: LD_VAR 0 2
24531: PPUSH
24532: EMPTY
24533: PPUSH
24534: CALL_OW 1
24538: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24539: LD_ADDR_EXP 131
24543: PUSH
24544: LD_EXP 131
24548: PPUSH
24549: LD_VAR 0 2
24553: PPUSH
24554: EMPTY
24555: PPUSH
24556: CALL_OW 1
24560: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24561: LD_ADDR_EXP 132
24565: PUSH
24566: LD_EXP 132
24570: PPUSH
24571: LD_VAR 0 2
24575: PPUSH
24576: EMPTY
24577: PPUSH
24578: CALL_OW 1
24582: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24583: LD_ADDR_EXP 133
24587: PUSH
24588: LD_EXP 133
24592: PPUSH
24593: LD_VAR 0 2
24597: PPUSH
24598: EMPTY
24599: PPUSH
24600: CALL_OW 1
24604: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24605: LD_ADDR_EXP 134
24609: PUSH
24610: LD_EXP 134
24614: PPUSH
24615: LD_VAR 0 2
24619: PPUSH
24620: EMPTY
24621: PPUSH
24622: CALL_OW 1
24626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24627: LD_ADDR_EXP 135
24631: PUSH
24632: LD_EXP 135
24636: PPUSH
24637: LD_VAR 0 2
24641: PPUSH
24642: EMPTY
24643: PPUSH
24644: CALL_OW 1
24648: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24649: LD_ADDR_EXP 136
24653: PUSH
24654: LD_EXP 136
24658: PPUSH
24659: LD_VAR 0 2
24663: PPUSH
24664: LD_INT 0
24666: PPUSH
24667: CALL_OW 1
24671: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24672: LD_ADDR_EXP 137
24676: PUSH
24677: LD_EXP 137
24681: PPUSH
24682: LD_VAR 0 2
24686: PPUSH
24687: LD_INT 0
24689: PPUSH
24690: CALL_OW 1
24694: ST_TO_ADDR
// end ;
24695: GO 23596
24697: POP
24698: POP
// MC_InitSides ( ) ;
24699: CALL 24985 0 0
// MC_InitResearch ( ) ;
24703: CALL 24724 0 0
// CustomInitMacro ( ) ;
24707: CALL 232 0 0
// skirmish := true ;
24711: LD_ADDR_EXP 92
24715: PUSH
24716: LD_INT 1
24718: ST_TO_ADDR
// end ;
24719: LD_VAR 0 1
24723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24724: LD_INT 0
24726: PPUSH
24727: PPUSH
24728: PPUSH
24729: PPUSH
24730: PPUSH
24731: PPUSH
// if not mc_bases then
24732: LD_EXP 94
24736: NOT
24737: IFFALSE 24741
// exit ;
24739: GO 24980
// for i = 1 to 8 do
24741: LD_ADDR_VAR 0 2
24745: PUSH
24746: DOUBLE
24747: LD_INT 1
24749: DEC
24750: ST_TO_ADDR
24751: LD_INT 8
24753: PUSH
24754: FOR_TO
24755: IFFALSE 24781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24757: LD_ADDR_EXP 121
24761: PUSH
24762: LD_EXP 121
24766: PPUSH
24767: LD_VAR 0 2
24771: PPUSH
24772: EMPTY
24773: PPUSH
24774: CALL_OW 1
24778: ST_TO_ADDR
24779: GO 24754
24781: POP
24782: POP
// tmp := [ ] ;
24783: LD_ADDR_VAR 0 5
24787: PUSH
24788: EMPTY
24789: ST_TO_ADDR
// for i = 1 to mc_sides do
24790: LD_ADDR_VAR 0 2
24794: PUSH
24795: DOUBLE
24796: LD_INT 1
24798: DEC
24799: ST_TO_ADDR
24800: LD_EXP 120
24804: PUSH
24805: FOR_TO
24806: IFFALSE 24864
// if not mc_sides [ i ] in tmp then
24808: LD_EXP 120
24812: PUSH
24813: LD_VAR 0 2
24817: ARRAY
24818: PUSH
24819: LD_VAR 0 5
24823: IN
24824: NOT
24825: IFFALSE 24862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24827: LD_ADDR_VAR 0 5
24831: PUSH
24832: LD_VAR 0 5
24836: PPUSH
24837: LD_VAR 0 5
24841: PUSH
24842: LD_INT 1
24844: PLUS
24845: PPUSH
24846: LD_EXP 120
24850: PUSH
24851: LD_VAR 0 2
24855: ARRAY
24856: PPUSH
24857: CALL_OW 2
24861: ST_TO_ADDR
24862: GO 24805
24864: POP
24865: POP
// if not tmp then
24866: LD_VAR 0 5
24870: NOT
24871: IFFALSE 24875
// exit ;
24873: GO 24980
// for j in tmp do
24875: LD_ADDR_VAR 0 3
24879: PUSH
24880: LD_VAR 0 5
24884: PUSH
24885: FOR_IN
24886: IFFALSE 24978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24888: LD_ADDR_VAR 0 6
24892: PUSH
24893: LD_INT 22
24895: PUSH
24896: LD_VAR 0 3
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: ST_TO_ADDR
// if not un then
24910: LD_VAR 0 6
24914: NOT
24915: IFFALSE 24919
// continue ;
24917: GO 24885
// nation := GetNation ( un [ 1 ] ) ;
24919: LD_ADDR_VAR 0 4
24923: PUSH
24924: LD_VAR 0 6
24928: PUSH
24929: LD_INT 1
24931: ARRAY
24932: PPUSH
24933: CALL_OW 248
24937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24938: LD_ADDR_EXP 121
24942: PUSH
24943: LD_EXP 121
24947: PPUSH
24948: LD_VAR 0 3
24952: PPUSH
24953: LD_VAR 0 3
24957: PPUSH
24958: LD_VAR 0 4
24962: PPUSH
24963: LD_INT 1
24965: PPUSH
24966: CALL 52101 0 3
24970: PPUSH
24971: CALL_OW 1
24975: ST_TO_ADDR
// end ;
24976: GO 24885
24978: POP
24979: POP
// end ;
24980: LD_VAR 0 1
24984: RET
// export function MC_InitSides ( ) ; var i ; begin
24985: LD_INT 0
24987: PPUSH
24988: PPUSH
// if not mc_bases then
24989: LD_EXP 94
24993: NOT
24994: IFFALSE 24998
// exit ;
24996: GO 25072
// for i = 1 to mc_bases do
24998: LD_ADDR_VAR 0 2
25002: PUSH
25003: DOUBLE
25004: LD_INT 1
25006: DEC
25007: ST_TO_ADDR
25008: LD_EXP 94
25012: PUSH
25013: FOR_TO
25014: IFFALSE 25070
// if mc_bases [ i ] then
25016: LD_EXP 94
25020: PUSH
25021: LD_VAR 0 2
25025: ARRAY
25026: IFFALSE 25068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25028: LD_ADDR_EXP 120
25032: PUSH
25033: LD_EXP 120
25037: PPUSH
25038: LD_VAR 0 2
25042: PPUSH
25043: LD_EXP 94
25047: PUSH
25048: LD_VAR 0 2
25052: ARRAY
25053: PUSH
25054: LD_INT 1
25056: ARRAY
25057: PPUSH
25058: CALL_OW 255
25062: PPUSH
25063: CALL_OW 1
25067: ST_TO_ADDR
25068: GO 25013
25070: POP
25071: POP
// end ;
25072: LD_VAR 0 1
25076: RET
// every 0 0$03 trigger skirmish do
25077: LD_EXP 92
25081: IFFALSE 25235
25083: GO 25085
25085: DISABLE
// begin enable ;
25086: ENABLE
// MC_CheckBuildings ( ) ;
25087: CALL 29733 0 0
// MC_CheckPeopleLife ( ) ;
25091: CALL 29894 0 0
// RaiseSailEvent ( 100 ) ;
25095: LD_INT 100
25097: PPUSH
25098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25102: LD_INT 103
25104: PPUSH
25105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25109: LD_INT 104
25111: PPUSH
25112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25116: LD_INT 105
25118: PPUSH
25119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25123: LD_INT 106
25125: PPUSH
25126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25130: LD_INT 107
25132: PPUSH
25133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25137: LD_INT 108
25139: PPUSH
25140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25144: LD_INT 109
25146: PPUSH
25147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25151: LD_INT 110
25153: PPUSH
25154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25158: LD_INT 111
25160: PPUSH
25161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25165: LD_INT 112
25167: PPUSH
25168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25172: LD_INT 113
25174: PPUSH
25175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25179: LD_INT 120
25181: PPUSH
25182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25186: LD_INT 121
25188: PPUSH
25189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25193: LD_INT 122
25195: PPUSH
25196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25200: LD_INT 123
25202: PPUSH
25203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25207: LD_INT 124
25209: PPUSH
25210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25214: LD_INT 125
25216: PPUSH
25217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25221: LD_INT 126
25223: PPUSH
25224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25228: LD_INT 200
25230: PPUSH
25231: CALL_OW 427
// end ;
25235: END
// on SailEvent ( event ) do begin if event < 100 then
25236: LD_VAR 0 1
25240: PUSH
25241: LD_INT 100
25243: LESS
25244: IFFALSE 25255
// CustomEvent ( event ) ;
25246: LD_VAR 0 1
25250: PPUSH
25251: CALL 10914 0 1
// if event = 100 then
25255: LD_VAR 0 1
25259: PUSH
25260: LD_INT 100
25262: EQUAL
25263: IFFALSE 25269
// MC_ClassManager ( ) ;
25265: CALL 25661 0 0
// if event = 101 then
25269: LD_VAR 0 1
25273: PUSH
25274: LD_INT 101
25276: EQUAL
25277: IFFALSE 25283
// MC_RepairBuildings ( ) ;
25279: CALL 30479 0 0
// if event = 102 then
25283: LD_VAR 0 1
25287: PUSH
25288: LD_INT 102
25290: EQUAL
25291: IFFALSE 25297
// MC_Heal ( ) ;
25293: CALL 31386 0 0
// if event = 103 then
25297: LD_VAR 0 1
25301: PUSH
25302: LD_INT 103
25304: EQUAL
25305: IFFALSE 25311
// MC_Build ( ) ;
25307: CALL 31808 0 0
// if event = 104 then
25311: LD_VAR 0 1
25315: PUSH
25316: LD_INT 104
25318: EQUAL
25319: IFFALSE 25325
// MC_TurretWeapon ( ) ;
25321: CALL 33449 0 0
// if event = 105 then
25325: LD_VAR 0 1
25329: PUSH
25330: LD_INT 105
25332: EQUAL
25333: IFFALSE 25339
// MC_BuildUpgrade ( ) ;
25335: CALL 33000 0 0
// if event = 106 then
25339: LD_VAR 0 1
25343: PUSH
25344: LD_INT 106
25346: EQUAL
25347: IFFALSE 25353
// MC_PlantMines ( ) ;
25349: CALL 33879 0 0
// if event = 107 then
25353: LD_VAR 0 1
25357: PUSH
25358: LD_INT 107
25360: EQUAL
25361: IFFALSE 25367
// MC_CollectCrates ( ) ;
25363: CALL 34670 0 0
// if event = 108 then
25367: LD_VAR 0 1
25371: PUSH
25372: LD_INT 108
25374: EQUAL
25375: IFFALSE 25381
// MC_LinkRemoteControl ( ) ;
25377: CALL 36520 0 0
// if event = 109 then
25381: LD_VAR 0 1
25385: PUSH
25386: LD_INT 109
25388: EQUAL
25389: IFFALSE 25395
// MC_ProduceVehicle ( ) ;
25391: CALL 36701 0 0
// if event = 110 then
25395: LD_VAR 0 1
25399: PUSH
25400: LD_INT 110
25402: EQUAL
25403: IFFALSE 25409
// MC_SendAttack ( ) ;
25405: CALL 37167 0 0
// if event = 111 then
25409: LD_VAR 0 1
25413: PUSH
25414: LD_INT 111
25416: EQUAL
25417: IFFALSE 25423
// MC_Defend ( ) ;
25419: CALL 37275 0 0
// if event = 112 then
25423: LD_VAR 0 1
25427: PUSH
25428: LD_INT 112
25430: EQUAL
25431: IFFALSE 25437
// MC_Research ( ) ;
25433: CALL 38155 0 0
// if event = 113 then
25437: LD_VAR 0 1
25441: PUSH
25442: LD_INT 113
25444: EQUAL
25445: IFFALSE 25451
// MC_MinesTrigger ( ) ;
25447: CALL 39269 0 0
// if event = 120 then
25451: LD_VAR 0 1
25455: PUSH
25456: LD_INT 120
25458: EQUAL
25459: IFFALSE 25465
// MC_RepairVehicle ( ) ;
25461: CALL 39368 0 0
// if event = 121 then
25465: LD_VAR 0 1
25469: PUSH
25470: LD_INT 121
25472: EQUAL
25473: IFFALSE 25479
// MC_TameApe ( ) ;
25475: CALL 40109 0 0
// if event = 122 then
25479: LD_VAR 0 1
25483: PUSH
25484: LD_INT 122
25486: EQUAL
25487: IFFALSE 25493
// MC_ChangeApeClass ( ) ;
25489: CALL 40938 0 0
// if event = 123 then
25493: LD_VAR 0 1
25497: PUSH
25498: LD_INT 123
25500: EQUAL
25501: IFFALSE 25507
// MC_Bazooka ( ) ;
25503: CALL 41588 0 0
// if event = 124 then
25507: LD_VAR 0 1
25511: PUSH
25512: LD_INT 124
25514: EQUAL
25515: IFFALSE 25521
// MC_TeleportExit ( ) ;
25517: CALL 41786 0 0
// if event = 125 then
25521: LD_VAR 0 1
25525: PUSH
25526: LD_INT 125
25528: EQUAL
25529: IFFALSE 25535
// MC_Deposits ( ) ;
25531: CALL 42433 0 0
// if event = 126 then
25535: LD_VAR 0 1
25539: PUSH
25540: LD_INT 126
25542: EQUAL
25543: IFFALSE 25549
// MC_RemoteDriver ( ) ;
25545: CALL 43058 0 0
// if event = 200 then
25549: LD_VAR 0 1
25553: PUSH
25554: LD_INT 200
25556: EQUAL
25557: IFFALSE 25563
// MC_Idle ( ) ;
25559: CALL 45007 0 0
// end ;
25563: PPOPN 1
25565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25566: LD_INT 0
25568: PPUSH
25569: PPUSH
// if not mc_bases [ base ] or not tag then
25570: LD_EXP 94
25574: PUSH
25575: LD_VAR 0 1
25579: ARRAY
25580: NOT
25581: PUSH
25582: LD_VAR 0 2
25586: NOT
25587: OR
25588: IFFALSE 25592
// exit ;
25590: GO 25656
// for i in mc_bases [ base ] union mc_ape [ base ] do
25592: LD_ADDR_VAR 0 4
25596: PUSH
25597: LD_EXP 94
25601: PUSH
25602: LD_VAR 0 1
25606: ARRAY
25607: PUSH
25608: LD_EXP 123
25612: PUSH
25613: LD_VAR 0 1
25617: ARRAY
25618: UNION
25619: PUSH
25620: FOR_IN
25621: IFFALSE 25654
// if GetTag ( i ) = tag then
25623: LD_VAR 0 4
25627: PPUSH
25628: CALL_OW 110
25632: PUSH
25633: LD_VAR 0 2
25637: EQUAL
25638: IFFALSE 25652
// SetTag ( i , 0 ) ;
25640: LD_VAR 0 4
25644: PPUSH
25645: LD_INT 0
25647: PPUSH
25648: CALL_OW 109
25652: GO 25620
25654: POP
25655: POP
// end ;
25656: LD_VAR 0 3
25660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25661: LD_INT 0
25663: PPUSH
25664: PPUSH
25665: PPUSH
25666: PPUSH
25667: PPUSH
25668: PPUSH
25669: PPUSH
25670: PPUSH
// if not mc_bases then
25671: LD_EXP 94
25675: NOT
25676: IFFALSE 25680
// exit ;
25678: GO 26138
// for i = 1 to mc_bases do
25680: LD_ADDR_VAR 0 2
25684: PUSH
25685: DOUBLE
25686: LD_INT 1
25688: DEC
25689: ST_TO_ADDR
25690: LD_EXP 94
25694: PUSH
25695: FOR_TO
25696: IFFALSE 26136
// begin tmp := MC_ClassCheckReq ( i ) ;
25698: LD_ADDR_VAR 0 4
25702: PUSH
25703: LD_VAR 0 2
25707: PPUSH
25708: CALL 26143 0 1
25712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25713: LD_ADDR_EXP 135
25717: PUSH
25718: LD_EXP 135
25722: PPUSH
25723: LD_VAR 0 2
25727: PPUSH
25728: LD_VAR 0 4
25732: PPUSH
25733: CALL_OW 1
25737: ST_TO_ADDR
// if not tmp then
25738: LD_VAR 0 4
25742: NOT
25743: IFFALSE 25747
// continue ;
25745: GO 25695
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25747: LD_ADDR_VAR 0 6
25751: PUSH
25752: LD_EXP 94
25756: PUSH
25757: LD_VAR 0 2
25761: ARRAY
25762: PPUSH
25763: LD_INT 2
25765: PUSH
25766: LD_INT 30
25768: PUSH
25769: LD_INT 4
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 30
25778: PUSH
25779: LD_INT 5
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: LIST
25790: PPUSH
25791: CALL_OW 72
25795: PUSH
25796: LD_EXP 94
25800: PUSH
25801: LD_VAR 0 2
25805: ARRAY
25806: PPUSH
25807: LD_INT 2
25809: PUSH
25810: LD_INT 30
25812: PUSH
25813: LD_INT 0
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 30
25822: PUSH
25823: LD_INT 1
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: EMPTY
25831: LIST
25832: LIST
25833: LIST
25834: PPUSH
25835: CALL_OW 72
25839: PUSH
25840: LD_EXP 94
25844: PUSH
25845: LD_VAR 0 2
25849: ARRAY
25850: PPUSH
25851: LD_INT 30
25853: PUSH
25854: LD_INT 3
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PPUSH
25861: CALL_OW 72
25865: PUSH
25866: LD_EXP 94
25870: PUSH
25871: LD_VAR 0 2
25875: ARRAY
25876: PPUSH
25877: LD_INT 2
25879: PUSH
25880: LD_INT 30
25882: PUSH
25883: LD_INT 6
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 30
25892: PUSH
25893: LD_INT 7
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: LD_INT 30
25902: PUSH
25903: LD_INT 8
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: PUSH
25910: EMPTY
25911: LIST
25912: LIST
25913: LIST
25914: LIST
25915: PPUSH
25916: CALL_OW 72
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: LIST
25925: LIST
25926: ST_TO_ADDR
// for j = 1 to 4 do
25927: LD_ADDR_VAR 0 3
25931: PUSH
25932: DOUBLE
25933: LD_INT 1
25935: DEC
25936: ST_TO_ADDR
25937: LD_INT 4
25939: PUSH
25940: FOR_TO
25941: IFFALSE 26132
// begin if not tmp [ j ] then
25943: LD_VAR 0 4
25947: PUSH
25948: LD_VAR 0 3
25952: ARRAY
25953: NOT
25954: IFFALSE 25958
// continue ;
25956: GO 25940
// for p in tmp [ j ] do
25958: LD_ADDR_VAR 0 5
25962: PUSH
25963: LD_VAR 0 4
25967: PUSH
25968: LD_VAR 0 3
25972: ARRAY
25973: PUSH
25974: FOR_IN
25975: IFFALSE 26128
// begin if not b [ j ] then
25977: LD_VAR 0 6
25981: PUSH
25982: LD_VAR 0 3
25986: ARRAY
25987: NOT
25988: IFFALSE 25992
// break ;
25990: GO 26128
// e := 0 ;
25992: LD_ADDR_VAR 0 7
25996: PUSH
25997: LD_INT 0
25999: ST_TO_ADDR
// for k in b [ j ] do
26000: LD_ADDR_VAR 0 8
26004: PUSH
26005: LD_VAR 0 6
26009: PUSH
26010: LD_VAR 0 3
26014: ARRAY
26015: PUSH
26016: FOR_IN
26017: IFFALSE 26044
// if IsNotFull ( k ) then
26019: LD_VAR 0 8
26023: PPUSH
26024: CALL 54254 0 1
26028: IFFALSE 26042
// begin e := k ;
26030: LD_ADDR_VAR 0 7
26034: PUSH
26035: LD_VAR 0 8
26039: ST_TO_ADDR
// break ;
26040: GO 26044
// end ;
26042: GO 26016
26044: POP
26045: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26046: LD_VAR 0 7
26050: PUSH
26051: LD_VAR 0 5
26055: PPUSH
26056: LD_VAR 0 7
26060: PPUSH
26061: CALL 88085 0 2
26065: NOT
26066: AND
26067: IFFALSE 26126
// begin if IsInUnit ( p ) then
26069: LD_VAR 0 5
26073: PPUSH
26074: CALL_OW 310
26078: IFFALSE 26089
// ComExitBuilding ( p ) ;
26080: LD_VAR 0 5
26084: PPUSH
26085: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26089: LD_VAR 0 5
26093: PPUSH
26094: LD_VAR 0 7
26098: PPUSH
26099: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26103: LD_VAR 0 5
26107: PPUSH
26108: LD_VAR 0 3
26112: PPUSH
26113: CALL_OW 183
// AddComExitBuilding ( p ) ;
26117: LD_VAR 0 5
26121: PPUSH
26122: CALL_OW 182
// end ; end ;
26126: GO 25974
26128: POP
26129: POP
// end ;
26130: GO 25940
26132: POP
26133: POP
// end ;
26134: GO 25695
26136: POP
26137: POP
// end ;
26138: LD_VAR 0 1
26142: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26143: LD_INT 0
26145: PPUSH
26146: PPUSH
26147: PPUSH
26148: PPUSH
26149: PPUSH
26150: PPUSH
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
26155: PPUSH
26156: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26157: LD_VAR 0 1
26161: NOT
26162: PUSH
26163: LD_EXP 94
26167: PUSH
26168: LD_VAR 0 1
26172: ARRAY
26173: NOT
26174: OR
26175: PUSH
26176: LD_EXP 94
26180: PUSH
26181: LD_VAR 0 1
26185: ARRAY
26186: PPUSH
26187: LD_INT 2
26189: PUSH
26190: LD_INT 30
26192: PUSH
26193: LD_INT 0
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PUSH
26200: LD_INT 30
26202: PUSH
26203: LD_INT 1
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: LIST
26214: PPUSH
26215: CALL_OW 72
26219: NOT
26220: OR
26221: IFFALSE 26225
// exit ;
26223: GO 29728
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26225: LD_ADDR_VAR 0 4
26229: PUSH
26230: LD_EXP 94
26234: PUSH
26235: LD_VAR 0 1
26239: ARRAY
26240: PPUSH
26241: LD_INT 2
26243: PUSH
26244: LD_INT 25
26246: PUSH
26247: LD_INT 1
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PUSH
26254: LD_INT 25
26256: PUSH
26257: LD_INT 2
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PUSH
26264: LD_INT 25
26266: PUSH
26267: LD_INT 3
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PUSH
26274: LD_INT 25
26276: PUSH
26277: LD_INT 4
26279: PUSH
26280: EMPTY
26281: LIST
26282: LIST
26283: PUSH
26284: LD_INT 25
26286: PUSH
26287: LD_INT 5
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: PUSH
26294: LD_INT 25
26296: PUSH
26297: LD_INT 8
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: PUSH
26304: LD_INT 25
26306: PUSH
26307: LD_INT 9
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: LIST
26322: LIST
26323: PPUSH
26324: CALL_OW 72
26328: ST_TO_ADDR
// if not tmp then
26329: LD_VAR 0 4
26333: NOT
26334: IFFALSE 26338
// exit ;
26336: GO 29728
// for i in tmp do
26338: LD_ADDR_VAR 0 3
26342: PUSH
26343: LD_VAR 0 4
26347: PUSH
26348: FOR_IN
26349: IFFALSE 26380
// if GetTag ( i ) then
26351: LD_VAR 0 3
26355: PPUSH
26356: CALL_OW 110
26360: IFFALSE 26378
// tmp := tmp diff i ;
26362: LD_ADDR_VAR 0 4
26366: PUSH
26367: LD_VAR 0 4
26371: PUSH
26372: LD_VAR 0 3
26376: DIFF
26377: ST_TO_ADDR
26378: GO 26348
26380: POP
26381: POP
// if not tmp then
26382: LD_VAR 0 4
26386: NOT
26387: IFFALSE 26391
// exit ;
26389: GO 29728
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26391: LD_ADDR_VAR 0 5
26395: PUSH
26396: LD_EXP 94
26400: PUSH
26401: LD_VAR 0 1
26405: ARRAY
26406: PPUSH
26407: LD_INT 2
26409: PUSH
26410: LD_INT 25
26412: PUSH
26413: LD_INT 1
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 25
26422: PUSH
26423: LD_INT 5
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: LD_INT 25
26432: PUSH
26433: LD_INT 8
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 25
26442: PUSH
26443: LD_INT 9
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: LIST
26454: LIST
26455: LIST
26456: PPUSH
26457: CALL_OW 72
26461: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26462: LD_ADDR_VAR 0 6
26466: PUSH
26467: LD_EXP 94
26471: PUSH
26472: LD_VAR 0 1
26476: ARRAY
26477: PPUSH
26478: LD_INT 25
26480: PUSH
26481: LD_INT 2
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PPUSH
26488: CALL_OW 72
26492: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26493: LD_ADDR_VAR 0 7
26497: PUSH
26498: LD_EXP 94
26502: PUSH
26503: LD_VAR 0 1
26507: ARRAY
26508: PPUSH
26509: LD_INT 25
26511: PUSH
26512: LD_INT 3
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PPUSH
26519: CALL_OW 72
26523: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26524: LD_ADDR_VAR 0 8
26528: PUSH
26529: LD_EXP 94
26533: PUSH
26534: LD_VAR 0 1
26538: ARRAY
26539: PPUSH
26540: LD_INT 25
26542: PUSH
26543: LD_INT 4
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 24
26552: PUSH
26553: LD_INT 251
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PPUSH
26564: CALL_OW 72
26568: ST_TO_ADDR
// if mc_is_defending [ base ] then
26569: LD_EXP 137
26573: PUSH
26574: LD_VAR 0 1
26578: ARRAY
26579: IFFALSE 27040
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26581: LD_ADDR_EXP 136
26585: PUSH
26586: LD_EXP 136
26590: PPUSH
26591: LD_VAR 0 1
26595: PPUSH
26596: LD_INT 4
26598: PPUSH
26599: CALL_OW 1
26603: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26604: LD_ADDR_VAR 0 12
26608: PUSH
26609: LD_EXP 94
26613: PUSH
26614: LD_VAR 0 1
26618: ARRAY
26619: PPUSH
26620: LD_INT 2
26622: PUSH
26623: LD_INT 30
26625: PUSH
26626: LD_INT 4
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PUSH
26633: LD_INT 30
26635: PUSH
26636: LD_INT 5
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: LIST
26647: PPUSH
26648: CALL_OW 72
26652: ST_TO_ADDR
// if not b then
26653: LD_VAR 0 12
26657: NOT
26658: IFFALSE 26662
// exit ;
26660: GO 29728
// p := [ ] ;
26662: LD_ADDR_VAR 0 11
26666: PUSH
26667: EMPTY
26668: ST_TO_ADDR
// if sci >= 2 then
26669: LD_VAR 0 8
26673: PUSH
26674: LD_INT 2
26676: GREATEREQUAL
26677: IFFALSE 26708
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26679: LD_ADDR_VAR 0 8
26683: PUSH
26684: LD_VAR 0 8
26688: PUSH
26689: LD_INT 1
26691: ARRAY
26692: PUSH
26693: LD_VAR 0 8
26697: PUSH
26698: LD_INT 2
26700: ARRAY
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: ST_TO_ADDR
26706: GO 26769
// if sci = 1 then
26708: LD_VAR 0 8
26712: PUSH
26713: LD_INT 1
26715: EQUAL
26716: IFFALSE 26737
// sci := [ sci [ 1 ] ] else
26718: LD_ADDR_VAR 0 8
26722: PUSH
26723: LD_VAR 0 8
26727: PUSH
26728: LD_INT 1
26730: ARRAY
26731: PUSH
26732: EMPTY
26733: LIST
26734: ST_TO_ADDR
26735: GO 26769
// if sci = 0 then
26737: LD_VAR 0 8
26741: PUSH
26742: LD_INT 0
26744: EQUAL
26745: IFFALSE 26769
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26747: LD_ADDR_VAR 0 11
26751: PUSH
26752: LD_VAR 0 4
26756: PPUSH
26757: LD_INT 4
26759: PPUSH
26760: CALL 87948 0 2
26764: PUSH
26765: LD_INT 1
26767: ARRAY
26768: ST_TO_ADDR
// if eng > 4 then
26769: LD_VAR 0 6
26773: PUSH
26774: LD_INT 4
26776: GREATER
26777: IFFALSE 26823
// for i = eng downto 4 do
26779: LD_ADDR_VAR 0 3
26783: PUSH
26784: DOUBLE
26785: LD_VAR 0 6
26789: INC
26790: ST_TO_ADDR
26791: LD_INT 4
26793: PUSH
26794: FOR_DOWNTO
26795: IFFALSE 26821
// eng := eng diff eng [ i ] ;
26797: LD_ADDR_VAR 0 6
26801: PUSH
26802: LD_VAR 0 6
26806: PUSH
26807: LD_VAR 0 6
26811: PUSH
26812: LD_VAR 0 3
26816: ARRAY
26817: DIFF
26818: ST_TO_ADDR
26819: GO 26794
26821: POP
26822: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26823: LD_ADDR_VAR 0 4
26827: PUSH
26828: LD_VAR 0 4
26832: PUSH
26833: LD_VAR 0 5
26837: PUSH
26838: LD_VAR 0 6
26842: UNION
26843: PUSH
26844: LD_VAR 0 7
26848: UNION
26849: PUSH
26850: LD_VAR 0 8
26854: UNION
26855: DIFF
26856: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26857: LD_ADDR_VAR 0 13
26861: PUSH
26862: LD_EXP 94
26866: PUSH
26867: LD_VAR 0 1
26871: ARRAY
26872: PPUSH
26873: LD_INT 2
26875: PUSH
26876: LD_INT 30
26878: PUSH
26879: LD_INT 32
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: PUSH
26886: LD_INT 30
26888: PUSH
26889: LD_INT 31
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: LIST
26900: PPUSH
26901: CALL_OW 72
26905: PUSH
26906: LD_EXP 94
26910: PUSH
26911: LD_VAR 0 1
26915: ARRAY
26916: PPUSH
26917: LD_INT 2
26919: PUSH
26920: LD_INT 30
26922: PUSH
26923: LD_INT 4
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 30
26932: PUSH
26933: LD_INT 5
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: PPUSH
26945: CALL_OW 72
26949: PUSH
26950: LD_INT 6
26952: MUL
26953: PLUS
26954: ST_TO_ADDR
// if bcount < tmp then
26955: LD_VAR 0 13
26959: PUSH
26960: LD_VAR 0 4
26964: LESS
26965: IFFALSE 27011
// for i = tmp downto bcount do
26967: LD_ADDR_VAR 0 3
26971: PUSH
26972: DOUBLE
26973: LD_VAR 0 4
26977: INC
26978: ST_TO_ADDR
26979: LD_VAR 0 13
26983: PUSH
26984: FOR_DOWNTO
26985: IFFALSE 27009
// tmp := Delete ( tmp , tmp ) ;
26987: LD_ADDR_VAR 0 4
26991: PUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_VAR 0 4
27001: PPUSH
27002: CALL_OW 3
27006: ST_TO_ADDR
27007: GO 26984
27009: POP
27010: POP
// result := [ tmp , 0 , 0 , p ] ;
27011: LD_ADDR_VAR 0 2
27015: PUSH
27016: LD_VAR 0 4
27020: PUSH
27021: LD_INT 0
27023: PUSH
27024: LD_INT 0
27026: PUSH
27027: LD_VAR 0 11
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: ST_TO_ADDR
// exit ;
27038: GO 29728
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27040: LD_EXP 94
27044: PUSH
27045: LD_VAR 0 1
27049: ARRAY
27050: PPUSH
27051: LD_INT 2
27053: PUSH
27054: LD_INT 30
27056: PUSH
27057: LD_INT 6
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 30
27066: PUSH
27067: LD_INT 7
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 30
27076: PUSH
27077: LD_INT 8
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: PPUSH
27090: CALL_OW 72
27094: NOT
27095: PUSH
27096: LD_EXP 94
27100: PUSH
27101: LD_VAR 0 1
27105: ARRAY
27106: PPUSH
27107: LD_INT 30
27109: PUSH
27110: LD_INT 3
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PPUSH
27117: CALL_OW 72
27121: NOT
27122: AND
27123: IFFALSE 27195
// begin if eng = tmp then
27125: LD_VAR 0 6
27129: PUSH
27130: LD_VAR 0 4
27134: EQUAL
27135: IFFALSE 27139
// exit ;
27137: GO 29728
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27139: LD_ADDR_EXP 136
27143: PUSH
27144: LD_EXP 136
27148: PPUSH
27149: LD_VAR 0 1
27153: PPUSH
27154: LD_INT 1
27156: PPUSH
27157: CALL_OW 1
27161: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27162: LD_ADDR_VAR 0 2
27166: PUSH
27167: LD_INT 0
27169: PUSH
27170: LD_VAR 0 4
27174: PUSH
27175: LD_VAR 0 6
27179: DIFF
27180: PUSH
27181: LD_INT 0
27183: PUSH
27184: LD_INT 0
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: LIST
27192: ST_TO_ADDR
// exit ;
27193: GO 29728
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27195: LD_EXP 121
27199: PUSH
27200: LD_EXP 120
27204: PUSH
27205: LD_VAR 0 1
27209: ARRAY
27210: ARRAY
27211: PUSH
27212: LD_EXP 94
27216: PUSH
27217: LD_VAR 0 1
27221: ARRAY
27222: PPUSH
27223: LD_INT 2
27225: PUSH
27226: LD_INT 30
27228: PUSH
27229: LD_INT 6
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 30
27238: PUSH
27239: LD_INT 7
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 30
27248: PUSH
27249: LD_INT 8
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: LIST
27260: LIST
27261: PPUSH
27262: CALL_OW 72
27266: AND
27267: PUSH
27268: LD_EXP 94
27272: PUSH
27273: LD_VAR 0 1
27277: ARRAY
27278: PPUSH
27279: LD_INT 30
27281: PUSH
27282: LD_INT 3
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: PPUSH
27289: CALL_OW 72
27293: NOT
27294: AND
27295: IFFALSE 27509
// begin if sci >= 6 then
27297: LD_VAR 0 8
27301: PUSH
27302: LD_INT 6
27304: GREATEREQUAL
27305: IFFALSE 27309
// exit ;
27307: GO 29728
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27309: LD_ADDR_EXP 136
27313: PUSH
27314: LD_EXP 136
27318: PPUSH
27319: LD_VAR 0 1
27323: PPUSH
27324: LD_INT 2
27326: PPUSH
27327: CALL_OW 1
27331: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 4
27341: PUSH
27342: LD_VAR 0 8
27346: DIFF
27347: PPUSH
27348: LD_INT 4
27350: PPUSH
27351: CALL 87948 0 2
27355: ST_TO_ADDR
// p := [ ] ;
27356: LD_ADDR_VAR 0 11
27360: PUSH
27361: EMPTY
27362: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27363: LD_VAR 0 8
27367: PUSH
27368: LD_INT 6
27370: LESS
27371: PUSH
27372: LD_VAR 0 9
27376: PUSH
27377: LD_INT 6
27379: GREATER
27380: AND
27381: IFFALSE 27462
// begin for i = 1 to 6 - sci do
27383: LD_ADDR_VAR 0 3
27387: PUSH
27388: DOUBLE
27389: LD_INT 1
27391: DEC
27392: ST_TO_ADDR
27393: LD_INT 6
27395: PUSH
27396: LD_VAR 0 8
27400: MINUS
27401: PUSH
27402: FOR_TO
27403: IFFALSE 27458
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27405: LD_ADDR_VAR 0 11
27409: PUSH
27410: LD_VAR 0 11
27414: PPUSH
27415: LD_VAR 0 11
27419: PUSH
27420: LD_INT 1
27422: PLUS
27423: PPUSH
27424: LD_VAR 0 9
27428: PUSH
27429: LD_INT 1
27431: ARRAY
27432: PPUSH
27433: CALL_OW 2
27437: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27438: LD_ADDR_VAR 0 9
27442: PUSH
27443: LD_VAR 0 9
27447: PPUSH
27448: LD_INT 1
27450: PPUSH
27451: CALL_OW 3
27455: ST_TO_ADDR
// end ;
27456: GO 27402
27458: POP
27459: POP
// end else
27460: GO 27482
// if sort then
27462: LD_VAR 0 9
27466: IFFALSE 27482
// p := sort [ 1 ] ;
27468: LD_ADDR_VAR 0 11
27472: PUSH
27473: LD_VAR 0 9
27477: PUSH
27478: LD_INT 1
27480: ARRAY
27481: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27482: LD_ADDR_VAR 0 2
27486: PUSH
27487: LD_INT 0
27489: PUSH
27490: LD_INT 0
27492: PUSH
27493: LD_INT 0
27495: PUSH
27496: LD_VAR 0 11
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: LIST
27505: LIST
27506: ST_TO_ADDR
// exit ;
27507: GO 29728
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27509: LD_EXP 121
27513: PUSH
27514: LD_EXP 120
27518: PUSH
27519: LD_VAR 0 1
27523: ARRAY
27524: ARRAY
27525: PUSH
27526: LD_EXP 94
27530: PUSH
27531: LD_VAR 0 1
27535: ARRAY
27536: PPUSH
27537: LD_INT 2
27539: PUSH
27540: LD_INT 30
27542: PUSH
27543: LD_INT 6
27545: PUSH
27546: EMPTY
27547: LIST
27548: LIST
27549: PUSH
27550: LD_INT 30
27552: PUSH
27553: LD_INT 7
27555: PUSH
27556: EMPTY
27557: LIST
27558: LIST
27559: PUSH
27560: LD_INT 30
27562: PUSH
27563: LD_INT 8
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: PPUSH
27576: CALL_OW 72
27580: AND
27581: PUSH
27582: LD_EXP 94
27586: PUSH
27587: LD_VAR 0 1
27591: ARRAY
27592: PPUSH
27593: LD_INT 30
27595: PUSH
27596: LD_INT 3
27598: PUSH
27599: EMPTY
27600: LIST
27601: LIST
27602: PPUSH
27603: CALL_OW 72
27607: AND
27608: IFFALSE 28342
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27610: LD_ADDR_EXP 136
27614: PUSH
27615: LD_EXP 136
27619: PPUSH
27620: LD_VAR 0 1
27624: PPUSH
27625: LD_INT 3
27627: PPUSH
27628: CALL_OW 1
27632: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27633: LD_ADDR_VAR 0 2
27637: PUSH
27638: LD_INT 0
27640: PUSH
27641: LD_INT 0
27643: PUSH
27644: LD_INT 0
27646: PUSH
27647: LD_INT 0
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: ST_TO_ADDR
// if not eng then
27656: LD_VAR 0 6
27660: NOT
27661: IFFALSE 27724
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27663: LD_ADDR_VAR 0 11
27667: PUSH
27668: LD_VAR 0 4
27672: PPUSH
27673: LD_INT 2
27675: PPUSH
27676: CALL 87948 0 2
27680: PUSH
27681: LD_INT 1
27683: ARRAY
27684: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27685: LD_ADDR_VAR 0 2
27689: PUSH
27690: LD_VAR 0 2
27694: PPUSH
27695: LD_INT 2
27697: PPUSH
27698: LD_VAR 0 11
27702: PPUSH
27703: CALL_OW 1
27707: ST_TO_ADDR
// tmp := tmp diff p ;
27708: LD_ADDR_VAR 0 4
27712: PUSH
27713: LD_VAR 0 4
27717: PUSH
27718: LD_VAR 0 11
27722: DIFF
27723: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27724: LD_VAR 0 4
27728: PUSH
27729: LD_VAR 0 8
27733: PUSH
27734: LD_INT 6
27736: LESS
27737: AND
27738: IFFALSE 27926
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27740: LD_ADDR_VAR 0 9
27744: PUSH
27745: LD_VAR 0 4
27749: PUSH
27750: LD_VAR 0 8
27754: PUSH
27755: LD_VAR 0 7
27759: UNION
27760: DIFF
27761: PPUSH
27762: LD_INT 4
27764: PPUSH
27765: CALL 87948 0 2
27769: ST_TO_ADDR
// p := [ ] ;
27770: LD_ADDR_VAR 0 11
27774: PUSH
27775: EMPTY
27776: ST_TO_ADDR
// if sort then
27777: LD_VAR 0 9
27781: IFFALSE 27897
// for i = 1 to 6 - sci do
27783: LD_ADDR_VAR 0 3
27787: PUSH
27788: DOUBLE
27789: LD_INT 1
27791: DEC
27792: ST_TO_ADDR
27793: LD_INT 6
27795: PUSH
27796: LD_VAR 0 8
27800: MINUS
27801: PUSH
27802: FOR_TO
27803: IFFALSE 27895
// begin if i = sort then
27805: LD_VAR 0 3
27809: PUSH
27810: LD_VAR 0 9
27814: EQUAL
27815: IFFALSE 27819
// break ;
27817: GO 27895
// if GetClass ( i ) = 4 then
27819: LD_VAR 0 3
27823: PPUSH
27824: CALL_OW 257
27828: PUSH
27829: LD_INT 4
27831: EQUAL
27832: IFFALSE 27836
// continue ;
27834: GO 27802
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27836: LD_ADDR_VAR 0 11
27840: PUSH
27841: LD_VAR 0 11
27845: PPUSH
27846: LD_VAR 0 11
27850: PUSH
27851: LD_INT 1
27853: PLUS
27854: PPUSH
27855: LD_VAR 0 9
27859: PUSH
27860: LD_VAR 0 3
27864: ARRAY
27865: PPUSH
27866: CALL_OW 2
27870: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27871: LD_ADDR_VAR 0 4
27875: PUSH
27876: LD_VAR 0 4
27880: PUSH
27881: LD_VAR 0 9
27885: PUSH
27886: LD_VAR 0 3
27890: ARRAY
27891: DIFF
27892: ST_TO_ADDR
// end ;
27893: GO 27802
27895: POP
27896: POP
// if p then
27897: LD_VAR 0 11
27901: IFFALSE 27926
// result := Replace ( result , 4 , p ) ;
27903: LD_ADDR_VAR 0 2
27907: PUSH
27908: LD_VAR 0 2
27912: PPUSH
27913: LD_INT 4
27915: PPUSH
27916: LD_VAR 0 11
27920: PPUSH
27921: CALL_OW 1
27925: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27926: LD_VAR 0 4
27930: PUSH
27931: LD_VAR 0 7
27935: PUSH
27936: LD_INT 6
27938: LESS
27939: AND
27940: IFFALSE 28128
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27942: LD_ADDR_VAR 0 9
27946: PUSH
27947: LD_VAR 0 4
27951: PUSH
27952: LD_VAR 0 8
27956: PUSH
27957: LD_VAR 0 7
27961: UNION
27962: DIFF
27963: PPUSH
27964: LD_INT 3
27966: PPUSH
27967: CALL 87948 0 2
27971: ST_TO_ADDR
// p := [ ] ;
27972: LD_ADDR_VAR 0 11
27976: PUSH
27977: EMPTY
27978: ST_TO_ADDR
// if sort then
27979: LD_VAR 0 9
27983: IFFALSE 28099
// for i = 1 to 6 - mech do
27985: LD_ADDR_VAR 0 3
27989: PUSH
27990: DOUBLE
27991: LD_INT 1
27993: DEC
27994: ST_TO_ADDR
27995: LD_INT 6
27997: PUSH
27998: LD_VAR 0 7
28002: MINUS
28003: PUSH
28004: FOR_TO
28005: IFFALSE 28097
// begin if i = sort then
28007: LD_VAR 0 3
28011: PUSH
28012: LD_VAR 0 9
28016: EQUAL
28017: IFFALSE 28021
// break ;
28019: GO 28097
// if GetClass ( i ) = 3 then
28021: LD_VAR 0 3
28025: PPUSH
28026: CALL_OW 257
28030: PUSH
28031: LD_INT 3
28033: EQUAL
28034: IFFALSE 28038
// continue ;
28036: GO 28004
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28038: LD_ADDR_VAR 0 11
28042: PUSH
28043: LD_VAR 0 11
28047: PPUSH
28048: LD_VAR 0 11
28052: PUSH
28053: LD_INT 1
28055: PLUS
28056: PPUSH
28057: LD_VAR 0 9
28061: PUSH
28062: LD_VAR 0 3
28066: ARRAY
28067: PPUSH
28068: CALL_OW 2
28072: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28073: LD_ADDR_VAR 0 4
28077: PUSH
28078: LD_VAR 0 4
28082: PUSH
28083: LD_VAR 0 9
28087: PUSH
28088: LD_VAR 0 3
28092: ARRAY
28093: DIFF
28094: ST_TO_ADDR
// end ;
28095: GO 28004
28097: POP
28098: POP
// if p then
28099: LD_VAR 0 11
28103: IFFALSE 28128
// result := Replace ( result , 3 , p ) ;
28105: LD_ADDR_VAR 0 2
28109: PUSH
28110: LD_VAR 0 2
28114: PPUSH
28115: LD_INT 3
28117: PPUSH
28118: LD_VAR 0 11
28122: PPUSH
28123: CALL_OW 1
28127: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28128: LD_VAR 0 4
28132: PUSH
28133: LD_INT 6
28135: GREATER
28136: PUSH
28137: LD_VAR 0 6
28141: PUSH
28142: LD_INT 6
28144: LESS
28145: AND
28146: IFFALSE 28340
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28148: LD_ADDR_VAR 0 9
28152: PUSH
28153: LD_VAR 0 4
28157: PUSH
28158: LD_VAR 0 8
28162: PUSH
28163: LD_VAR 0 7
28167: UNION
28168: PUSH
28169: LD_VAR 0 6
28173: UNION
28174: DIFF
28175: PPUSH
28176: LD_INT 2
28178: PPUSH
28179: CALL 87948 0 2
28183: ST_TO_ADDR
// p := [ ] ;
28184: LD_ADDR_VAR 0 11
28188: PUSH
28189: EMPTY
28190: ST_TO_ADDR
// if sort then
28191: LD_VAR 0 9
28195: IFFALSE 28311
// for i = 1 to 6 - eng do
28197: LD_ADDR_VAR 0 3
28201: PUSH
28202: DOUBLE
28203: LD_INT 1
28205: DEC
28206: ST_TO_ADDR
28207: LD_INT 6
28209: PUSH
28210: LD_VAR 0 6
28214: MINUS
28215: PUSH
28216: FOR_TO
28217: IFFALSE 28309
// begin if i = sort then
28219: LD_VAR 0 3
28223: PUSH
28224: LD_VAR 0 9
28228: EQUAL
28229: IFFALSE 28233
// break ;
28231: GO 28309
// if GetClass ( i ) = 2 then
28233: LD_VAR 0 3
28237: PPUSH
28238: CALL_OW 257
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28250
// continue ;
28248: GO 28216
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28250: LD_ADDR_VAR 0 11
28254: PUSH
28255: LD_VAR 0 11
28259: PPUSH
28260: LD_VAR 0 11
28264: PUSH
28265: LD_INT 1
28267: PLUS
28268: PPUSH
28269: LD_VAR 0 9
28273: PUSH
28274: LD_VAR 0 3
28278: ARRAY
28279: PPUSH
28280: CALL_OW 2
28284: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28285: LD_ADDR_VAR 0 4
28289: PUSH
28290: LD_VAR 0 4
28294: PUSH
28295: LD_VAR 0 9
28299: PUSH
28300: LD_VAR 0 3
28304: ARRAY
28305: DIFF
28306: ST_TO_ADDR
// end ;
28307: GO 28216
28309: POP
28310: POP
// if p then
28311: LD_VAR 0 11
28315: IFFALSE 28340
// result := Replace ( result , 2 , p ) ;
28317: LD_ADDR_VAR 0 2
28321: PUSH
28322: LD_VAR 0 2
28326: PPUSH
28327: LD_INT 2
28329: PPUSH
28330: LD_VAR 0 11
28334: PPUSH
28335: CALL_OW 1
28339: ST_TO_ADDR
// end ; exit ;
28340: GO 29728
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28342: LD_EXP 121
28346: PUSH
28347: LD_EXP 120
28351: PUSH
28352: LD_VAR 0 1
28356: ARRAY
28357: ARRAY
28358: NOT
28359: PUSH
28360: LD_EXP 94
28364: PUSH
28365: LD_VAR 0 1
28369: ARRAY
28370: PPUSH
28371: LD_INT 30
28373: PUSH
28374: LD_INT 3
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PPUSH
28381: CALL_OW 72
28385: AND
28386: PUSH
28387: LD_EXP 99
28391: PUSH
28392: LD_VAR 0 1
28396: ARRAY
28397: AND
28398: IFFALSE 29006
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28400: LD_ADDR_EXP 136
28404: PUSH
28405: LD_EXP 136
28409: PPUSH
28410: LD_VAR 0 1
28414: PPUSH
28415: LD_INT 5
28417: PPUSH
28418: CALL_OW 1
28422: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28423: LD_ADDR_VAR 0 2
28427: PUSH
28428: LD_INT 0
28430: PUSH
28431: LD_INT 0
28433: PUSH
28434: LD_INT 0
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: LIST
28444: LIST
28445: ST_TO_ADDR
// if sci > 1 then
28446: LD_VAR 0 8
28450: PUSH
28451: LD_INT 1
28453: GREATER
28454: IFFALSE 28482
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28456: LD_ADDR_VAR 0 4
28460: PUSH
28461: LD_VAR 0 4
28465: PUSH
28466: LD_VAR 0 8
28470: PUSH
28471: LD_VAR 0 8
28475: PUSH
28476: LD_INT 1
28478: ARRAY
28479: DIFF
28480: DIFF
28481: ST_TO_ADDR
// if tmp and not sci then
28482: LD_VAR 0 4
28486: PUSH
28487: LD_VAR 0 8
28491: NOT
28492: AND
28493: IFFALSE 28562
// begin sort := SortBySkill ( tmp , 4 ) ;
28495: LD_ADDR_VAR 0 9
28499: PUSH
28500: LD_VAR 0 4
28504: PPUSH
28505: LD_INT 4
28507: PPUSH
28508: CALL 87948 0 2
28512: ST_TO_ADDR
// if sort then
28513: LD_VAR 0 9
28517: IFFALSE 28533
// p := sort [ 1 ] ;
28519: LD_ADDR_VAR 0 11
28523: PUSH
28524: LD_VAR 0 9
28528: PUSH
28529: LD_INT 1
28531: ARRAY
28532: ST_TO_ADDR
// if p then
28533: LD_VAR 0 11
28537: IFFALSE 28562
// result := Replace ( result , 4 , p ) ;
28539: LD_ADDR_VAR 0 2
28543: PUSH
28544: LD_VAR 0 2
28548: PPUSH
28549: LD_INT 4
28551: PPUSH
28552: LD_VAR 0 11
28556: PPUSH
28557: CALL_OW 1
28561: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28562: LD_ADDR_VAR 0 4
28566: PUSH
28567: LD_VAR 0 4
28571: PUSH
28572: LD_VAR 0 7
28576: DIFF
28577: ST_TO_ADDR
// if tmp and mech < 6 then
28578: LD_VAR 0 4
28582: PUSH
28583: LD_VAR 0 7
28587: PUSH
28588: LD_INT 6
28590: LESS
28591: AND
28592: IFFALSE 28780
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28594: LD_ADDR_VAR 0 9
28598: PUSH
28599: LD_VAR 0 4
28603: PUSH
28604: LD_VAR 0 8
28608: PUSH
28609: LD_VAR 0 7
28613: UNION
28614: DIFF
28615: PPUSH
28616: LD_INT 3
28618: PPUSH
28619: CALL 87948 0 2
28623: ST_TO_ADDR
// p := [ ] ;
28624: LD_ADDR_VAR 0 11
28628: PUSH
28629: EMPTY
28630: ST_TO_ADDR
// if sort then
28631: LD_VAR 0 9
28635: IFFALSE 28751
// for i = 1 to 6 - mech do
28637: LD_ADDR_VAR 0 3
28641: PUSH
28642: DOUBLE
28643: LD_INT 1
28645: DEC
28646: ST_TO_ADDR
28647: LD_INT 6
28649: PUSH
28650: LD_VAR 0 7
28654: MINUS
28655: PUSH
28656: FOR_TO
28657: IFFALSE 28749
// begin if i = sort then
28659: LD_VAR 0 3
28663: PUSH
28664: LD_VAR 0 9
28668: EQUAL
28669: IFFALSE 28673
// break ;
28671: GO 28749
// if GetClass ( i ) = 3 then
28673: LD_VAR 0 3
28677: PPUSH
28678: CALL_OW 257
28682: PUSH
28683: LD_INT 3
28685: EQUAL
28686: IFFALSE 28690
// continue ;
28688: GO 28656
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28690: LD_ADDR_VAR 0 11
28694: PUSH
28695: LD_VAR 0 11
28699: PPUSH
28700: LD_VAR 0 11
28704: PUSH
28705: LD_INT 1
28707: PLUS
28708: PPUSH
28709: LD_VAR 0 9
28713: PUSH
28714: LD_VAR 0 3
28718: ARRAY
28719: PPUSH
28720: CALL_OW 2
28724: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28725: LD_ADDR_VAR 0 4
28729: PUSH
28730: LD_VAR 0 4
28734: PUSH
28735: LD_VAR 0 9
28739: PUSH
28740: LD_VAR 0 3
28744: ARRAY
28745: DIFF
28746: ST_TO_ADDR
// end ;
28747: GO 28656
28749: POP
28750: POP
// if p then
28751: LD_VAR 0 11
28755: IFFALSE 28780
// result := Replace ( result , 3 , p ) ;
28757: LD_ADDR_VAR 0 2
28761: PUSH
28762: LD_VAR 0 2
28766: PPUSH
28767: LD_INT 3
28769: PPUSH
28770: LD_VAR 0 11
28774: PPUSH
28775: CALL_OW 1
28779: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28780: LD_ADDR_VAR 0 4
28784: PUSH
28785: LD_VAR 0 4
28789: PUSH
28790: LD_VAR 0 6
28794: DIFF
28795: ST_TO_ADDR
// if tmp and eng < 6 then
28796: LD_VAR 0 4
28800: PUSH
28801: LD_VAR 0 6
28805: PUSH
28806: LD_INT 6
28808: LESS
28809: AND
28810: IFFALSE 29004
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28812: LD_ADDR_VAR 0 9
28816: PUSH
28817: LD_VAR 0 4
28821: PUSH
28822: LD_VAR 0 8
28826: PUSH
28827: LD_VAR 0 7
28831: UNION
28832: PUSH
28833: LD_VAR 0 6
28837: UNION
28838: DIFF
28839: PPUSH
28840: LD_INT 2
28842: PPUSH
28843: CALL 87948 0 2
28847: ST_TO_ADDR
// p := [ ] ;
28848: LD_ADDR_VAR 0 11
28852: PUSH
28853: EMPTY
28854: ST_TO_ADDR
// if sort then
28855: LD_VAR 0 9
28859: IFFALSE 28975
// for i = 1 to 6 - eng do
28861: LD_ADDR_VAR 0 3
28865: PUSH
28866: DOUBLE
28867: LD_INT 1
28869: DEC
28870: ST_TO_ADDR
28871: LD_INT 6
28873: PUSH
28874: LD_VAR 0 6
28878: MINUS
28879: PUSH
28880: FOR_TO
28881: IFFALSE 28973
// begin if i = sort then
28883: LD_VAR 0 3
28887: PUSH
28888: LD_VAR 0 9
28892: EQUAL
28893: IFFALSE 28897
// break ;
28895: GO 28973
// if GetClass ( i ) = 2 then
28897: LD_VAR 0 3
28901: PPUSH
28902: CALL_OW 257
28906: PUSH
28907: LD_INT 2
28909: EQUAL
28910: IFFALSE 28914
// continue ;
28912: GO 28880
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28914: LD_ADDR_VAR 0 11
28918: PUSH
28919: LD_VAR 0 11
28923: PPUSH
28924: LD_VAR 0 11
28928: PUSH
28929: LD_INT 1
28931: PLUS
28932: PPUSH
28933: LD_VAR 0 9
28937: PUSH
28938: LD_VAR 0 3
28942: ARRAY
28943: PPUSH
28944: CALL_OW 2
28948: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28949: LD_ADDR_VAR 0 4
28953: PUSH
28954: LD_VAR 0 4
28958: PUSH
28959: LD_VAR 0 9
28963: PUSH
28964: LD_VAR 0 3
28968: ARRAY
28969: DIFF
28970: ST_TO_ADDR
// end ;
28971: GO 28880
28973: POP
28974: POP
// if p then
28975: LD_VAR 0 11
28979: IFFALSE 29004
// result := Replace ( result , 2 , p ) ;
28981: LD_ADDR_VAR 0 2
28985: PUSH
28986: LD_VAR 0 2
28990: PPUSH
28991: LD_INT 2
28993: PPUSH
28994: LD_VAR 0 11
28998: PPUSH
28999: CALL_OW 1
29003: ST_TO_ADDR
// end ; exit ;
29004: GO 29728
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29006: LD_EXP 121
29010: PUSH
29011: LD_EXP 120
29015: PUSH
29016: LD_VAR 0 1
29020: ARRAY
29021: ARRAY
29022: NOT
29023: PUSH
29024: LD_EXP 94
29028: PUSH
29029: LD_VAR 0 1
29033: ARRAY
29034: PPUSH
29035: LD_INT 30
29037: PUSH
29038: LD_INT 3
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PPUSH
29045: CALL_OW 72
29049: AND
29050: PUSH
29051: LD_EXP 99
29055: PUSH
29056: LD_VAR 0 1
29060: ARRAY
29061: NOT
29062: AND
29063: IFFALSE 29728
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29065: LD_ADDR_EXP 136
29069: PUSH
29070: LD_EXP 136
29074: PPUSH
29075: LD_VAR 0 1
29079: PPUSH
29080: LD_INT 6
29082: PPUSH
29083: CALL_OW 1
29087: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29088: LD_ADDR_VAR 0 2
29092: PUSH
29093: LD_INT 0
29095: PUSH
29096: LD_INT 0
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: LIST
29109: LIST
29110: ST_TO_ADDR
// if sci >= 1 then
29111: LD_VAR 0 8
29115: PUSH
29116: LD_INT 1
29118: GREATEREQUAL
29119: IFFALSE 29141
// tmp := tmp diff sci [ 1 ] ;
29121: LD_ADDR_VAR 0 4
29125: PUSH
29126: LD_VAR 0 4
29130: PUSH
29131: LD_VAR 0 8
29135: PUSH
29136: LD_INT 1
29138: ARRAY
29139: DIFF
29140: ST_TO_ADDR
// if tmp and not sci then
29141: LD_VAR 0 4
29145: PUSH
29146: LD_VAR 0 8
29150: NOT
29151: AND
29152: IFFALSE 29221
// begin sort := SortBySkill ( tmp , 4 ) ;
29154: LD_ADDR_VAR 0 9
29158: PUSH
29159: LD_VAR 0 4
29163: PPUSH
29164: LD_INT 4
29166: PPUSH
29167: CALL 87948 0 2
29171: ST_TO_ADDR
// if sort then
29172: LD_VAR 0 9
29176: IFFALSE 29192
// p := sort [ 1 ] ;
29178: LD_ADDR_VAR 0 11
29182: PUSH
29183: LD_VAR 0 9
29187: PUSH
29188: LD_INT 1
29190: ARRAY
29191: ST_TO_ADDR
// if p then
29192: LD_VAR 0 11
29196: IFFALSE 29221
// result := Replace ( result , 4 , p ) ;
29198: LD_ADDR_VAR 0 2
29202: PUSH
29203: LD_VAR 0 2
29207: PPUSH
29208: LD_INT 4
29210: PPUSH
29211: LD_VAR 0 11
29215: PPUSH
29216: CALL_OW 1
29220: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29221: LD_ADDR_VAR 0 4
29225: PUSH
29226: LD_VAR 0 4
29230: PUSH
29231: LD_VAR 0 7
29235: DIFF
29236: ST_TO_ADDR
// if tmp and mech < 6 then
29237: LD_VAR 0 4
29241: PUSH
29242: LD_VAR 0 7
29246: PUSH
29247: LD_INT 6
29249: LESS
29250: AND
29251: IFFALSE 29433
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29253: LD_ADDR_VAR 0 9
29257: PUSH
29258: LD_VAR 0 4
29262: PUSH
29263: LD_VAR 0 7
29267: DIFF
29268: PPUSH
29269: LD_INT 3
29271: PPUSH
29272: CALL 87948 0 2
29276: ST_TO_ADDR
// p := [ ] ;
29277: LD_ADDR_VAR 0 11
29281: PUSH
29282: EMPTY
29283: ST_TO_ADDR
// if sort then
29284: LD_VAR 0 9
29288: IFFALSE 29404
// for i = 1 to 6 - mech do
29290: LD_ADDR_VAR 0 3
29294: PUSH
29295: DOUBLE
29296: LD_INT 1
29298: DEC
29299: ST_TO_ADDR
29300: LD_INT 6
29302: PUSH
29303: LD_VAR 0 7
29307: MINUS
29308: PUSH
29309: FOR_TO
29310: IFFALSE 29402
// begin if i = sort then
29312: LD_VAR 0 3
29316: PUSH
29317: LD_VAR 0 9
29321: EQUAL
29322: IFFALSE 29326
// break ;
29324: GO 29402
// if GetClass ( i ) = 3 then
29326: LD_VAR 0 3
29330: PPUSH
29331: CALL_OW 257
29335: PUSH
29336: LD_INT 3
29338: EQUAL
29339: IFFALSE 29343
// continue ;
29341: GO 29309
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29343: LD_ADDR_VAR 0 11
29347: PUSH
29348: LD_VAR 0 11
29352: PPUSH
29353: LD_VAR 0 11
29357: PUSH
29358: LD_INT 1
29360: PLUS
29361: PPUSH
29362: LD_VAR 0 9
29366: PUSH
29367: LD_VAR 0 3
29371: ARRAY
29372: PPUSH
29373: CALL_OW 2
29377: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29378: LD_ADDR_VAR 0 4
29382: PUSH
29383: LD_VAR 0 4
29387: PUSH
29388: LD_VAR 0 9
29392: PUSH
29393: LD_VAR 0 3
29397: ARRAY
29398: DIFF
29399: ST_TO_ADDR
// end ;
29400: GO 29309
29402: POP
29403: POP
// if p then
29404: LD_VAR 0 11
29408: IFFALSE 29433
// result := Replace ( result , 3 , p ) ;
29410: LD_ADDR_VAR 0 2
29414: PUSH
29415: LD_VAR 0 2
29419: PPUSH
29420: LD_INT 3
29422: PPUSH
29423: LD_VAR 0 11
29427: PPUSH
29428: CALL_OW 1
29432: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29433: LD_ADDR_VAR 0 4
29437: PUSH
29438: LD_VAR 0 4
29442: PUSH
29443: LD_VAR 0 6
29447: DIFF
29448: ST_TO_ADDR
// if tmp and eng < 4 then
29449: LD_VAR 0 4
29453: PUSH
29454: LD_VAR 0 6
29458: PUSH
29459: LD_INT 4
29461: LESS
29462: AND
29463: IFFALSE 29653
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29465: LD_ADDR_VAR 0 9
29469: PUSH
29470: LD_VAR 0 4
29474: PUSH
29475: LD_VAR 0 7
29479: PUSH
29480: LD_VAR 0 6
29484: UNION
29485: DIFF
29486: PPUSH
29487: LD_INT 2
29489: PPUSH
29490: CALL 87948 0 2
29494: ST_TO_ADDR
// p := [ ] ;
29495: LD_ADDR_VAR 0 11
29499: PUSH
29500: EMPTY
29501: ST_TO_ADDR
// if sort then
29502: LD_VAR 0 9
29506: IFFALSE 29622
// for i = 1 to 4 - eng do
29508: LD_ADDR_VAR 0 3
29512: PUSH
29513: DOUBLE
29514: LD_INT 1
29516: DEC
29517: ST_TO_ADDR
29518: LD_INT 4
29520: PUSH
29521: LD_VAR 0 6
29525: MINUS
29526: PUSH
29527: FOR_TO
29528: IFFALSE 29620
// begin if i = sort then
29530: LD_VAR 0 3
29534: PUSH
29535: LD_VAR 0 9
29539: EQUAL
29540: IFFALSE 29544
// break ;
29542: GO 29620
// if GetClass ( i ) = 2 then
29544: LD_VAR 0 3
29548: PPUSH
29549: CALL_OW 257
29553: PUSH
29554: LD_INT 2
29556: EQUAL
29557: IFFALSE 29561
// continue ;
29559: GO 29527
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29561: LD_ADDR_VAR 0 11
29565: PUSH
29566: LD_VAR 0 11
29570: PPUSH
29571: LD_VAR 0 11
29575: PUSH
29576: LD_INT 1
29578: PLUS
29579: PPUSH
29580: LD_VAR 0 9
29584: PUSH
29585: LD_VAR 0 3
29589: ARRAY
29590: PPUSH
29591: CALL_OW 2
29595: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29596: LD_ADDR_VAR 0 4
29600: PUSH
29601: LD_VAR 0 4
29605: PUSH
29606: LD_VAR 0 9
29610: PUSH
29611: LD_VAR 0 3
29615: ARRAY
29616: DIFF
29617: ST_TO_ADDR
// end ;
29618: GO 29527
29620: POP
29621: POP
// if p then
29622: LD_VAR 0 11
29626: IFFALSE 29651
// result := Replace ( result , 2 , p ) ;
29628: LD_ADDR_VAR 0 2
29632: PUSH
29633: LD_VAR 0 2
29637: PPUSH
29638: LD_INT 2
29640: PPUSH
29641: LD_VAR 0 11
29645: PPUSH
29646: CALL_OW 1
29650: ST_TO_ADDR
// end else
29651: GO 29697
// for i = eng downto 5 do
29653: LD_ADDR_VAR 0 3
29657: PUSH
29658: DOUBLE
29659: LD_VAR 0 6
29663: INC
29664: ST_TO_ADDR
29665: LD_INT 5
29667: PUSH
29668: FOR_DOWNTO
29669: IFFALSE 29695
// tmp := tmp union eng [ i ] ;
29671: LD_ADDR_VAR 0 4
29675: PUSH
29676: LD_VAR 0 4
29680: PUSH
29681: LD_VAR 0 6
29685: PUSH
29686: LD_VAR 0 3
29690: ARRAY
29691: UNION
29692: ST_TO_ADDR
29693: GO 29668
29695: POP
29696: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29697: LD_ADDR_VAR 0 2
29701: PUSH
29702: LD_VAR 0 2
29706: PPUSH
29707: LD_INT 1
29709: PPUSH
29710: LD_VAR 0 4
29714: PUSH
29715: LD_VAR 0 5
29719: DIFF
29720: PPUSH
29721: CALL_OW 1
29725: ST_TO_ADDR
// exit ;
29726: GO 29728
// end ; end ;
29728: LD_VAR 0 2
29732: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29733: LD_INT 0
29735: PPUSH
29736: PPUSH
29737: PPUSH
// if not mc_bases then
29738: LD_EXP 94
29742: NOT
29743: IFFALSE 29747
// exit ;
29745: GO 29889
// for i = 1 to mc_bases do
29747: LD_ADDR_VAR 0 2
29751: PUSH
29752: DOUBLE
29753: LD_INT 1
29755: DEC
29756: ST_TO_ADDR
29757: LD_EXP 94
29761: PUSH
29762: FOR_TO
29763: IFFALSE 29880
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29765: LD_ADDR_VAR 0 3
29769: PUSH
29770: LD_EXP 94
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: PPUSH
29781: LD_INT 21
29783: PUSH
29784: LD_INT 3
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: PUSH
29791: LD_INT 3
29793: PUSH
29794: LD_INT 2
29796: PUSH
29797: LD_INT 30
29799: PUSH
29800: LD_INT 29
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 30
29809: PUSH
29810: LD_INT 30
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: LIST
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: LD_INT 24
29831: PUSH
29832: LD_INT 1000
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: LIST
29847: PPUSH
29848: CALL_OW 72
29852: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29853: LD_ADDR_EXP 95
29857: PUSH
29858: LD_EXP 95
29862: PPUSH
29863: LD_VAR 0 2
29867: PPUSH
29868: LD_VAR 0 3
29872: PPUSH
29873: CALL_OW 1
29877: ST_TO_ADDR
// end ;
29878: GO 29762
29880: POP
29881: POP
// RaiseSailEvent ( 101 ) ;
29882: LD_INT 101
29884: PPUSH
29885: CALL_OW 427
// end ;
29889: LD_VAR 0 1
29893: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29894: LD_INT 0
29896: PPUSH
29897: PPUSH
29898: PPUSH
29899: PPUSH
29900: PPUSH
29901: PPUSH
29902: PPUSH
// if not mc_bases then
29903: LD_EXP 94
29907: NOT
29908: IFFALSE 29912
// exit ;
29910: GO 30474
// for i = 1 to mc_bases do
29912: LD_ADDR_VAR 0 2
29916: PUSH
29917: DOUBLE
29918: LD_INT 1
29920: DEC
29921: ST_TO_ADDR
29922: LD_EXP 94
29926: PUSH
29927: FOR_TO
29928: IFFALSE 30465
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29930: LD_ADDR_VAR 0 5
29934: PUSH
29935: LD_EXP 94
29939: PUSH
29940: LD_VAR 0 2
29944: ARRAY
29945: PUSH
29946: LD_EXP 123
29950: PUSH
29951: LD_VAR 0 2
29955: ARRAY
29956: UNION
29957: PPUSH
29958: LD_INT 21
29960: PUSH
29961: LD_INT 1
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: LD_INT 3
29973: PUSH
29974: LD_INT 54
29976: PUSH
29977: EMPTY
29978: LIST
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 3
29986: PUSH
29987: LD_INT 24
29989: PUSH
29990: LD_INT 1000
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: LIST
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PPUSH
30010: CALL_OW 72
30014: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30015: LD_ADDR_VAR 0 6
30019: PUSH
30020: LD_EXP 94
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: PPUSH
30031: LD_INT 21
30033: PUSH
30034: LD_INT 1
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 1
30043: PUSH
30044: LD_INT 3
30046: PUSH
30047: LD_INT 54
30049: PUSH
30050: EMPTY
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: LD_INT 3
30059: PUSH
30060: LD_INT 24
30062: PUSH
30063: LD_INT 250
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: LIST
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PPUSH
30083: CALL_OW 72
30087: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30088: LD_ADDR_VAR 0 7
30092: PUSH
30093: LD_VAR 0 5
30097: PUSH
30098: LD_VAR 0 6
30102: DIFF
30103: ST_TO_ADDR
// if not need_heal_1 then
30104: LD_VAR 0 6
30108: NOT
30109: IFFALSE 30142
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30111: LD_ADDR_EXP 97
30115: PUSH
30116: LD_EXP 97
30120: PPUSH
30121: LD_VAR 0 2
30125: PUSH
30126: LD_INT 1
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PPUSH
30133: EMPTY
30134: PPUSH
30135: CALL 57177 0 3
30139: ST_TO_ADDR
30140: GO 30212
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30142: LD_ADDR_EXP 97
30146: PUSH
30147: LD_EXP 97
30151: PPUSH
30152: LD_VAR 0 2
30156: PUSH
30157: LD_INT 1
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PPUSH
30164: LD_EXP 97
30168: PUSH
30169: LD_VAR 0 2
30173: ARRAY
30174: PUSH
30175: LD_INT 1
30177: ARRAY
30178: PPUSH
30179: LD_INT 3
30181: PUSH
30182: LD_INT 24
30184: PUSH
30185: LD_INT 1000
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PPUSH
30196: CALL_OW 72
30200: PUSH
30201: LD_VAR 0 6
30205: UNION
30206: PPUSH
30207: CALL 57177 0 3
30211: ST_TO_ADDR
// if not need_heal_2 then
30212: LD_VAR 0 7
30216: NOT
30217: IFFALSE 30250
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30219: LD_ADDR_EXP 97
30223: PUSH
30224: LD_EXP 97
30228: PPUSH
30229: LD_VAR 0 2
30233: PUSH
30234: LD_INT 2
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PPUSH
30241: EMPTY
30242: PPUSH
30243: CALL 57177 0 3
30247: ST_TO_ADDR
30248: GO 30282
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30250: LD_ADDR_EXP 97
30254: PUSH
30255: LD_EXP 97
30259: PPUSH
30260: LD_VAR 0 2
30264: PUSH
30265: LD_INT 2
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: PPUSH
30272: LD_VAR 0 7
30276: PPUSH
30277: CALL 57177 0 3
30281: ST_TO_ADDR
// if need_heal_2 then
30282: LD_VAR 0 7
30286: IFFALSE 30447
// for j in need_heal_2 do
30288: LD_ADDR_VAR 0 3
30292: PUSH
30293: LD_VAR 0 7
30297: PUSH
30298: FOR_IN
30299: IFFALSE 30445
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30301: LD_ADDR_VAR 0 5
30305: PUSH
30306: LD_EXP 94
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PPUSH
30317: LD_INT 2
30319: PUSH
30320: LD_INT 30
30322: PUSH
30323: LD_INT 6
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 30
30332: PUSH
30333: LD_INT 7
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 30
30342: PUSH
30343: LD_INT 8
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 30
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 30
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: PPUSH
30378: CALL_OW 72
30382: ST_TO_ADDR
// if tmp then
30383: LD_VAR 0 5
30387: IFFALSE 30443
// begin k := NearestUnitToUnit ( tmp , j ) ;
30389: LD_ADDR_VAR 0 4
30393: PUSH
30394: LD_VAR 0 5
30398: PPUSH
30399: LD_VAR 0 3
30403: PPUSH
30404: CALL_OW 74
30408: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30409: LD_VAR 0 3
30413: PPUSH
30414: LD_VAR 0 4
30418: PPUSH
30419: CALL_OW 296
30423: PUSH
30424: LD_INT 5
30426: GREATER
30427: IFFALSE 30443
// ComMoveToNearbyEntrance ( j , k ) ;
30429: LD_VAR 0 3
30433: PPUSH
30434: LD_VAR 0 4
30438: PPUSH
30439: CALL 90316 0 2
// end ; end ;
30443: GO 30298
30445: POP
30446: POP
// if not need_heal_1 and not need_heal_2 then
30447: LD_VAR 0 6
30451: NOT
30452: PUSH
30453: LD_VAR 0 7
30457: NOT
30458: AND
30459: IFFALSE 30463
// continue ;
30461: GO 29927
// end ;
30463: GO 29927
30465: POP
30466: POP
// RaiseSailEvent ( 102 ) ;
30467: LD_INT 102
30469: PPUSH
30470: CALL_OW 427
// end ;
30474: LD_VAR 0 1
30478: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30479: LD_INT 0
30481: PPUSH
30482: PPUSH
30483: PPUSH
30484: PPUSH
30485: PPUSH
30486: PPUSH
30487: PPUSH
30488: PPUSH
// if not mc_bases then
30489: LD_EXP 94
30493: NOT
30494: IFFALSE 30498
// exit ;
30496: GO 31381
// for i = 1 to mc_bases do
30498: LD_ADDR_VAR 0 2
30502: PUSH
30503: DOUBLE
30504: LD_INT 1
30506: DEC
30507: ST_TO_ADDR
30508: LD_EXP 94
30512: PUSH
30513: FOR_TO
30514: IFFALSE 31379
// begin if not mc_building_need_repair [ i ] then
30516: LD_EXP 95
30520: PUSH
30521: LD_VAR 0 2
30525: ARRAY
30526: NOT
30527: IFFALSE 30714
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30529: LD_ADDR_VAR 0 6
30533: PUSH
30534: LD_EXP 113
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PPUSH
30545: LD_INT 3
30547: PUSH
30548: LD_INT 24
30550: PUSH
30551: LD_INT 1000
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: LD_INT 34
30567: PUSH
30568: LD_INT 13
30570: PUSH
30571: EMPTY
30572: LIST
30573: LIST
30574: PUSH
30575: LD_INT 34
30577: PUSH
30578: LD_INT 52
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 34
30587: PUSH
30588: LD_EXP 80
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PPUSH
30607: CALL_OW 72
30611: ST_TO_ADDR
// if cranes then
30612: LD_VAR 0 6
30616: IFFALSE 30678
// for j in cranes do
30618: LD_ADDR_VAR 0 3
30622: PUSH
30623: LD_VAR 0 6
30627: PUSH
30628: FOR_IN
30629: IFFALSE 30676
// if not IsInArea ( j , mc_parking [ i ] ) then
30631: LD_VAR 0 3
30635: PPUSH
30636: LD_EXP 118
30640: PUSH
30641: LD_VAR 0 2
30645: ARRAY
30646: PPUSH
30647: CALL_OW 308
30651: NOT
30652: IFFALSE 30674
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30654: LD_VAR 0 3
30658: PPUSH
30659: LD_EXP 118
30663: PUSH
30664: LD_VAR 0 2
30668: ARRAY
30669: PPUSH
30670: CALL_OW 113
30674: GO 30628
30676: POP
30677: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30678: LD_ADDR_EXP 96
30682: PUSH
30683: LD_EXP 96
30687: PPUSH
30688: LD_VAR 0 2
30692: PPUSH
30693: EMPTY
30694: PPUSH
30695: CALL_OW 1
30699: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30700: LD_VAR 0 2
30704: PPUSH
30705: LD_INT 101
30707: PPUSH
30708: CALL 25566 0 2
// continue ;
30712: GO 30513
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30714: LD_ADDR_EXP 100
30718: PUSH
30719: LD_EXP 100
30723: PPUSH
30724: LD_VAR 0 2
30728: PPUSH
30729: EMPTY
30730: PPUSH
30731: CALL_OW 1
30735: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30736: LD_VAR 0 2
30740: PPUSH
30741: LD_INT 103
30743: PPUSH
30744: CALL 25566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30748: LD_ADDR_VAR 0 5
30752: PUSH
30753: LD_EXP 94
30757: PUSH
30758: LD_VAR 0 2
30762: ARRAY
30763: PUSH
30764: LD_EXP 123
30768: PUSH
30769: LD_VAR 0 2
30773: ARRAY
30774: UNION
30775: PPUSH
30776: LD_INT 2
30778: PUSH
30779: LD_INT 25
30781: PUSH
30782: LD_INT 2
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 25
30791: PUSH
30792: LD_INT 16
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: LIST
30803: PUSH
30804: EMPTY
30805: LIST
30806: PPUSH
30807: CALL_OW 72
30811: ST_TO_ADDR
// if mc_need_heal [ i ] then
30812: LD_EXP 97
30816: PUSH
30817: LD_VAR 0 2
30821: ARRAY
30822: IFFALSE 30866
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30824: LD_ADDR_VAR 0 5
30828: PUSH
30829: LD_VAR 0 5
30833: PUSH
30834: LD_EXP 97
30838: PUSH
30839: LD_VAR 0 2
30843: ARRAY
30844: PUSH
30845: LD_INT 1
30847: ARRAY
30848: PUSH
30849: LD_EXP 97
30853: PUSH
30854: LD_VAR 0 2
30858: ARRAY
30859: PUSH
30860: LD_INT 2
30862: ARRAY
30863: UNION
30864: DIFF
30865: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30866: LD_ADDR_VAR 0 6
30870: PUSH
30871: LD_EXP 113
30875: PUSH
30876: LD_VAR 0 2
30880: ARRAY
30881: PPUSH
30882: LD_INT 2
30884: PUSH
30885: LD_INT 34
30887: PUSH
30888: LD_INT 13
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 34
30897: PUSH
30898: LD_INT 52
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 34
30907: PUSH
30908: LD_EXP 80
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: PPUSH
30923: CALL_OW 72
30927: ST_TO_ADDR
// if cranes then
30928: LD_VAR 0 6
30932: IFFALSE 31068
// begin for j in cranes do
30934: LD_ADDR_VAR 0 3
30938: PUSH
30939: LD_VAR 0 6
30943: PUSH
30944: FOR_IN
30945: IFFALSE 31066
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30947: LD_VAR 0 3
30951: PPUSH
30952: CALL_OW 256
30956: PUSH
30957: LD_INT 1000
30959: EQUAL
30960: PUSH
30961: LD_VAR 0 3
30965: PPUSH
30966: CALL_OW 314
30970: NOT
30971: AND
30972: IFFALSE 31006
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30974: LD_VAR 0 3
30978: PPUSH
30979: LD_EXP 95
30983: PUSH
30984: LD_VAR 0 2
30988: ARRAY
30989: PPUSH
30990: LD_VAR 0 3
30994: PPUSH
30995: CALL_OW 74
30999: PPUSH
31000: CALL_OW 130
31004: GO 31064
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31006: LD_VAR 0 3
31010: PPUSH
31011: CALL_OW 256
31015: PUSH
31016: LD_INT 500
31018: LESS
31019: PUSH
31020: LD_VAR 0 3
31024: PPUSH
31025: LD_EXP 118
31029: PUSH
31030: LD_VAR 0 2
31034: ARRAY
31035: PPUSH
31036: CALL_OW 308
31040: NOT
31041: AND
31042: IFFALSE 31064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31044: LD_VAR 0 3
31048: PPUSH
31049: LD_EXP 118
31053: PUSH
31054: LD_VAR 0 2
31058: ARRAY
31059: PPUSH
31060: CALL_OW 113
// end ;
31064: GO 30944
31066: POP
31067: POP
// end ; if tmp > 3 then
31068: LD_VAR 0 5
31072: PUSH
31073: LD_INT 3
31075: GREATER
31076: IFFALSE 31096
// tmp := ShrinkArray ( tmp , 4 ) ;
31078: LD_ADDR_VAR 0 5
31082: PUSH
31083: LD_VAR 0 5
31087: PPUSH
31088: LD_INT 4
31090: PPUSH
31091: CALL 89754 0 2
31095: ST_TO_ADDR
// if not tmp then
31096: LD_VAR 0 5
31100: NOT
31101: IFFALSE 31105
// continue ;
31103: GO 30513
// for j in tmp do
31105: LD_ADDR_VAR 0 3
31109: PUSH
31110: LD_VAR 0 5
31114: PUSH
31115: FOR_IN
31116: IFFALSE 31375
// begin if IsInUnit ( j ) then
31118: LD_VAR 0 3
31122: PPUSH
31123: CALL_OW 310
31127: IFFALSE 31138
// ComExitBuilding ( j ) ;
31129: LD_VAR 0 3
31133: PPUSH
31134: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31138: LD_VAR 0 3
31142: PUSH
31143: LD_EXP 96
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: IN
31154: NOT
31155: IFFALSE 31213
// begin SetTag ( j , 101 ) ;
31157: LD_VAR 0 3
31161: PPUSH
31162: LD_INT 101
31164: PPUSH
31165: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31169: LD_ADDR_EXP 96
31173: PUSH
31174: LD_EXP 96
31178: PPUSH
31179: LD_VAR 0 2
31183: PUSH
31184: LD_EXP 96
31188: PUSH
31189: LD_VAR 0 2
31193: ARRAY
31194: PUSH
31195: LD_INT 1
31197: PLUS
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PPUSH
31203: LD_VAR 0 3
31207: PPUSH
31208: CALL 57177 0 3
31212: ST_TO_ADDR
// end ; wait ( 1 ) ;
31213: LD_INT 1
31215: PPUSH
31216: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31220: LD_ADDR_VAR 0 7
31224: PUSH
31225: LD_EXP 95
31229: PUSH
31230: LD_VAR 0 2
31234: ARRAY
31235: ST_TO_ADDR
// if mc_scan [ i ] then
31236: LD_EXP 117
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: IFFALSE 31308
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31248: LD_ADDR_VAR 0 7
31252: PUSH
31253: LD_EXP 95
31257: PUSH
31258: LD_VAR 0 2
31262: ARRAY
31263: PPUSH
31264: LD_INT 3
31266: PUSH
31267: LD_INT 30
31269: PUSH
31270: LD_INT 32
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 30
31279: PUSH
31280: LD_INT 33
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 30
31289: PUSH
31290: LD_INT 31
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: PPUSH
31303: CALL_OW 72
31307: ST_TO_ADDR
// if not to_repair_tmp then
31308: LD_VAR 0 7
31312: NOT
31313: IFFALSE 31317
// continue ;
31315: GO 31115
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31317: LD_ADDR_VAR 0 8
31321: PUSH
31322: LD_VAR 0 7
31326: PPUSH
31327: LD_VAR 0 3
31331: PPUSH
31332: CALL_OW 74
31336: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31337: LD_VAR 0 8
31341: PPUSH
31342: LD_INT 16
31344: PPUSH
31345: CALL 59776 0 2
31349: PUSH
31350: LD_INT 4
31352: ARRAY
31353: PUSH
31354: LD_INT 10
31356: LESS
31357: IFFALSE 31373
// ComRepairBuilding ( j , to_repair ) ;
31359: LD_VAR 0 3
31363: PPUSH
31364: LD_VAR 0 8
31368: PPUSH
31369: CALL_OW 130
// end ;
31373: GO 31115
31375: POP
31376: POP
// end ;
31377: GO 30513
31379: POP
31380: POP
// end ;
31381: LD_VAR 0 1
31385: RET
// export function MC_Heal ; var i , j , tmp ; begin
31386: LD_INT 0
31388: PPUSH
31389: PPUSH
31390: PPUSH
31391: PPUSH
// if not mc_bases then
31392: LD_EXP 94
31396: NOT
31397: IFFALSE 31401
// exit ;
31399: GO 31803
// for i = 1 to mc_bases do
31401: LD_ADDR_VAR 0 2
31405: PUSH
31406: DOUBLE
31407: LD_INT 1
31409: DEC
31410: ST_TO_ADDR
31411: LD_EXP 94
31415: PUSH
31416: FOR_TO
31417: IFFALSE 31801
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31419: LD_EXP 97
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: NOT
31434: PUSH
31435: LD_EXP 97
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: PUSH
31446: LD_INT 2
31448: ARRAY
31449: NOT
31450: AND
31451: IFFALSE 31489
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31453: LD_ADDR_EXP 98
31457: PUSH
31458: LD_EXP 98
31462: PPUSH
31463: LD_VAR 0 2
31467: PPUSH
31468: EMPTY
31469: PPUSH
31470: CALL_OW 1
31474: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31475: LD_VAR 0 2
31479: PPUSH
31480: LD_INT 102
31482: PPUSH
31483: CALL 25566 0 2
// continue ;
31487: GO 31416
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31489: LD_ADDR_VAR 0 4
31493: PUSH
31494: LD_EXP 94
31498: PUSH
31499: LD_VAR 0 2
31503: ARRAY
31504: PPUSH
31505: LD_INT 25
31507: PUSH
31508: LD_INT 4
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PPUSH
31515: CALL_OW 72
31519: ST_TO_ADDR
// if not tmp then
31520: LD_VAR 0 4
31524: NOT
31525: IFFALSE 31529
// continue ;
31527: GO 31416
// if mc_taming [ i ] then
31529: LD_EXP 125
31533: PUSH
31534: LD_VAR 0 2
31538: ARRAY
31539: IFFALSE 31563
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31541: LD_ADDR_EXP 125
31545: PUSH
31546: LD_EXP 125
31550: PPUSH
31551: LD_VAR 0 2
31555: PPUSH
31556: EMPTY
31557: PPUSH
31558: CALL_OW 1
31562: ST_TO_ADDR
// for j in tmp do
31563: LD_ADDR_VAR 0 3
31567: PUSH
31568: LD_VAR 0 4
31572: PUSH
31573: FOR_IN
31574: IFFALSE 31797
// begin if IsInUnit ( j ) then
31576: LD_VAR 0 3
31580: PPUSH
31581: CALL_OW 310
31585: IFFALSE 31596
// ComExitBuilding ( j ) ;
31587: LD_VAR 0 3
31591: PPUSH
31592: CALL_OW 122
// if not j in mc_healers [ i ] then
31596: LD_VAR 0 3
31600: PUSH
31601: LD_EXP 98
31605: PUSH
31606: LD_VAR 0 2
31610: ARRAY
31611: IN
31612: NOT
31613: IFFALSE 31659
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31615: LD_ADDR_EXP 98
31619: PUSH
31620: LD_EXP 98
31624: PPUSH
31625: LD_VAR 0 2
31629: PUSH
31630: LD_EXP 98
31634: PUSH
31635: LD_VAR 0 2
31639: ARRAY
31640: PUSH
31641: LD_INT 1
31643: PLUS
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PPUSH
31649: LD_VAR 0 3
31653: PPUSH
31654: CALL 57177 0 3
31658: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31659: LD_VAR 0 3
31663: PPUSH
31664: CALL_OW 110
31668: PUSH
31669: LD_INT 102
31671: NONEQUAL
31672: IFFALSE 31686
// SetTag ( j , 102 ) ;
31674: LD_VAR 0 3
31678: PPUSH
31679: LD_INT 102
31681: PPUSH
31682: CALL_OW 109
// Wait ( 3 ) ;
31686: LD_INT 3
31688: PPUSH
31689: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31693: LD_EXP 97
31697: PUSH
31698: LD_VAR 0 2
31702: ARRAY
31703: PUSH
31704: LD_INT 1
31706: ARRAY
31707: IFFALSE 31739
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31709: LD_VAR 0 3
31713: PPUSH
31714: LD_EXP 97
31718: PUSH
31719: LD_VAR 0 2
31723: ARRAY
31724: PUSH
31725: LD_INT 1
31727: ARRAY
31728: PUSH
31729: LD_INT 1
31731: ARRAY
31732: PPUSH
31733: CALL_OW 128
31737: GO 31795
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31739: LD_VAR 0 3
31743: PPUSH
31744: CALL_OW 314
31748: NOT
31749: PUSH
31750: LD_EXP 97
31754: PUSH
31755: LD_VAR 0 2
31759: ARRAY
31760: PUSH
31761: LD_INT 2
31763: ARRAY
31764: AND
31765: IFFALSE 31795
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31767: LD_VAR 0 3
31771: PPUSH
31772: LD_EXP 97
31776: PUSH
31777: LD_VAR 0 2
31781: ARRAY
31782: PUSH
31783: LD_INT 2
31785: ARRAY
31786: PUSH
31787: LD_INT 1
31789: ARRAY
31790: PPUSH
31791: CALL_OW 128
// end ;
31795: GO 31573
31797: POP
31798: POP
// end ;
31799: GO 31416
31801: POP
31802: POP
// end ;
31803: LD_VAR 0 1
31807: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31808: LD_INT 0
31810: PPUSH
31811: PPUSH
31812: PPUSH
31813: PPUSH
31814: PPUSH
// if not mc_bases then
31815: LD_EXP 94
31819: NOT
31820: IFFALSE 31824
// exit ;
31822: GO 32995
// for i = 1 to mc_bases do
31824: LD_ADDR_VAR 0 2
31828: PUSH
31829: DOUBLE
31830: LD_INT 1
31832: DEC
31833: ST_TO_ADDR
31834: LD_EXP 94
31838: PUSH
31839: FOR_TO
31840: IFFALSE 32993
// begin if mc_scan [ i ] then
31842: LD_EXP 117
31846: PUSH
31847: LD_VAR 0 2
31851: ARRAY
31852: IFFALSE 31856
// continue ;
31854: GO 31839
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31856: LD_EXP 99
31860: PUSH
31861: LD_VAR 0 2
31865: ARRAY
31866: NOT
31867: PUSH
31868: LD_EXP 101
31872: PUSH
31873: LD_VAR 0 2
31877: ARRAY
31878: NOT
31879: AND
31880: PUSH
31881: LD_EXP 100
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: AND
31892: IFFALSE 31930
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31894: LD_ADDR_EXP 100
31898: PUSH
31899: LD_EXP 100
31903: PPUSH
31904: LD_VAR 0 2
31908: PPUSH
31909: EMPTY
31910: PPUSH
31911: CALL_OW 1
31915: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31916: LD_VAR 0 2
31920: PPUSH
31921: LD_INT 103
31923: PPUSH
31924: CALL 25566 0 2
// continue ;
31928: GO 31839
// end ; if mc_construct_list [ i ] then
31930: LD_EXP 101
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: IFFALSE 32160
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31942: LD_ADDR_VAR 0 4
31946: PUSH
31947: LD_EXP 94
31951: PUSH
31952: LD_VAR 0 2
31956: ARRAY
31957: PPUSH
31958: LD_INT 25
31960: PUSH
31961: LD_INT 2
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PPUSH
31968: CALL_OW 72
31972: PUSH
31973: LD_EXP 96
31977: PUSH
31978: LD_VAR 0 2
31982: ARRAY
31983: DIFF
31984: ST_TO_ADDR
// if not tmp then
31985: LD_VAR 0 4
31989: NOT
31990: IFFALSE 31994
// continue ;
31992: GO 31839
// for j in tmp do
31994: LD_ADDR_VAR 0 3
31998: PUSH
31999: LD_VAR 0 4
32003: PUSH
32004: FOR_IN
32005: IFFALSE 32156
// begin if not mc_builders [ i ] then
32007: LD_EXP 100
32011: PUSH
32012: LD_VAR 0 2
32016: ARRAY
32017: NOT
32018: IFFALSE 32076
// begin SetTag ( j , 103 ) ;
32020: LD_VAR 0 3
32024: PPUSH
32025: LD_INT 103
32027: PPUSH
32028: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32032: LD_ADDR_EXP 100
32036: PUSH
32037: LD_EXP 100
32041: PPUSH
32042: LD_VAR 0 2
32046: PUSH
32047: LD_EXP 100
32051: PUSH
32052: LD_VAR 0 2
32056: ARRAY
32057: PUSH
32058: LD_INT 1
32060: PLUS
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PPUSH
32066: LD_VAR 0 3
32070: PPUSH
32071: CALL 57177 0 3
32075: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32076: LD_VAR 0 3
32080: PPUSH
32081: CALL_OW 310
32085: IFFALSE 32096
// ComExitBuilding ( j ) ;
32087: LD_VAR 0 3
32091: PPUSH
32092: CALL_OW 122
// wait ( 3 ) ;
32096: LD_INT 3
32098: PPUSH
32099: CALL_OW 67
// if not mc_construct_list [ i ] then
32103: LD_EXP 101
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: NOT
32114: IFFALSE 32118
// break ;
32116: GO 32156
// if not HasTask ( j ) then
32118: LD_VAR 0 3
32122: PPUSH
32123: CALL_OW 314
32127: NOT
32128: IFFALSE 32154
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32130: LD_VAR 0 3
32134: PPUSH
32135: LD_EXP 101
32139: PUSH
32140: LD_VAR 0 2
32144: ARRAY
32145: PUSH
32146: LD_INT 1
32148: ARRAY
32149: PPUSH
32150: CALL 60040 0 2
// end ;
32154: GO 32004
32156: POP
32157: POP
// end else
32158: GO 32991
// if mc_build_list [ i ] then
32160: LD_EXP 99
32164: PUSH
32165: LD_VAR 0 2
32169: ARRAY
32170: IFFALSE 32991
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32172: LD_ADDR_VAR 0 5
32176: PUSH
32177: LD_EXP 94
32181: PUSH
32182: LD_VAR 0 2
32186: ARRAY
32187: PPUSH
32188: LD_INT 2
32190: PUSH
32191: LD_INT 30
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 30
32203: PUSH
32204: LD_INT 1
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: LIST
32215: PPUSH
32216: CALL_OW 72
32220: ST_TO_ADDR
// if depot then
32221: LD_VAR 0 5
32225: IFFALSE 32243
// depot := depot [ 1 ] else
32227: LD_ADDR_VAR 0 5
32231: PUSH
32232: LD_VAR 0 5
32236: PUSH
32237: LD_INT 1
32239: ARRAY
32240: ST_TO_ADDR
32241: GO 32251
// depot := 0 ;
32243: LD_ADDR_VAR 0 5
32247: PUSH
32248: LD_INT 0
32250: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32251: LD_EXP 99
32255: PUSH
32256: LD_VAR 0 2
32260: ARRAY
32261: PUSH
32262: LD_INT 1
32264: ARRAY
32265: PUSH
32266: LD_INT 1
32268: ARRAY
32269: PPUSH
32270: CALL 59864 0 1
32274: PUSH
32275: LD_EXP 94
32279: PUSH
32280: LD_VAR 0 2
32284: ARRAY
32285: PPUSH
32286: LD_INT 2
32288: PUSH
32289: LD_INT 30
32291: PUSH
32292: LD_INT 2
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 30
32301: PUSH
32302: LD_INT 3
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: LIST
32313: PPUSH
32314: CALL_OW 72
32318: NOT
32319: AND
32320: IFFALSE 32425
// begin for j = 1 to mc_build_list [ i ] do
32322: LD_ADDR_VAR 0 3
32326: PUSH
32327: DOUBLE
32328: LD_INT 1
32330: DEC
32331: ST_TO_ADDR
32332: LD_EXP 99
32336: PUSH
32337: LD_VAR 0 2
32341: ARRAY
32342: PUSH
32343: FOR_TO
32344: IFFALSE 32423
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32346: LD_EXP 99
32350: PUSH
32351: LD_VAR 0 2
32355: ARRAY
32356: PUSH
32357: LD_VAR 0 3
32361: ARRAY
32362: PUSH
32363: LD_INT 1
32365: ARRAY
32366: PUSH
32367: LD_INT 2
32369: EQUAL
32370: IFFALSE 32421
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32372: LD_ADDR_EXP 99
32376: PUSH
32377: LD_EXP 99
32381: PPUSH
32382: LD_VAR 0 2
32386: PPUSH
32387: LD_EXP 99
32391: PUSH
32392: LD_VAR 0 2
32396: ARRAY
32397: PPUSH
32398: LD_VAR 0 3
32402: PPUSH
32403: LD_INT 1
32405: PPUSH
32406: LD_INT 0
32408: PPUSH
32409: CALL 56595 0 4
32413: PPUSH
32414: CALL_OW 1
32418: ST_TO_ADDR
// break ;
32419: GO 32423
// end ;
32421: GO 32343
32423: POP
32424: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32425: LD_EXP 99
32429: PUSH
32430: LD_VAR 0 2
32434: ARRAY
32435: PUSH
32436: LD_INT 1
32438: ARRAY
32439: PUSH
32440: LD_INT 1
32442: ARRAY
32443: PUSH
32444: LD_INT 0
32446: EQUAL
32447: PUSH
32448: LD_VAR 0 5
32452: PUSH
32453: LD_VAR 0 5
32457: PPUSH
32458: LD_EXP 99
32462: PUSH
32463: LD_VAR 0 2
32467: ARRAY
32468: PUSH
32469: LD_INT 1
32471: ARRAY
32472: PUSH
32473: LD_INT 1
32475: ARRAY
32476: PPUSH
32477: LD_EXP 99
32481: PUSH
32482: LD_VAR 0 2
32486: ARRAY
32487: PUSH
32488: LD_INT 1
32490: ARRAY
32491: PUSH
32492: LD_INT 2
32494: ARRAY
32495: PPUSH
32496: LD_EXP 99
32500: PUSH
32501: LD_VAR 0 2
32505: ARRAY
32506: PUSH
32507: LD_INT 1
32509: ARRAY
32510: PUSH
32511: LD_INT 3
32513: ARRAY
32514: PPUSH
32515: LD_EXP 99
32519: PUSH
32520: LD_VAR 0 2
32524: ARRAY
32525: PUSH
32526: LD_INT 1
32528: ARRAY
32529: PUSH
32530: LD_INT 4
32532: ARRAY
32533: PPUSH
32534: CALL 65280 0 5
32538: AND
32539: OR
32540: IFFALSE 32821
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32542: LD_ADDR_VAR 0 4
32546: PUSH
32547: LD_EXP 94
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PPUSH
32558: LD_INT 25
32560: PUSH
32561: LD_INT 2
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PPUSH
32568: CALL_OW 72
32572: PUSH
32573: LD_EXP 96
32577: PUSH
32578: LD_VAR 0 2
32582: ARRAY
32583: DIFF
32584: ST_TO_ADDR
// if not tmp then
32585: LD_VAR 0 4
32589: NOT
32590: IFFALSE 32594
// continue ;
32592: GO 31839
// for j in tmp do
32594: LD_ADDR_VAR 0 3
32598: PUSH
32599: LD_VAR 0 4
32603: PUSH
32604: FOR_IN
32605: IFFALSE 32817
// begin if not mc_builders [ i ] then
32607: LD_EXP 100
32611: PUSH
32612: LD_VAR 0 2
32616: ARRAY
32617: NOT
32618: IFFALSE 32676
// begin SetTag ( j , 103 ) ;
32620: LD_VAR 0 3
32624: PPUSH
32625: LD_INT 103
32627: PPUSH
32628: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32632: LD_ADDR_EXP 100
32636: PUSH
32637: LD_EXP 100
32641: PPUSH
32642: LD_VAR 0 2
32646: PUSH
32647: LD_EXP 100
32651: PUSH
32652: LD_VAR 0 2
32656: ARRAY
32657: PUSH
32658: LD_INT 1
32660: PLUS
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PPUSH
32666: LD_VAR 0 3
32670: PPUSH
32671: CALL 57177 0 3
32675: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32676: LD_VAR 0 3
32680: PPUSH
32681: CALL_OW 310
32685: IFFALSE 32696
// ComExitBuilding ( j ) ;
32687: LD_VAR 0 3
32691: PPUSH
32692: CALL_OW 122
// wait ( 3 ) ;
32696: LD_INT 3
32698: PPUSH
32699: CALL_OW 67
// if not mc_build_list [ i ] then
32703: LD_EXP 99
32707: PUSH
32708: LD_VAR 0 2
32712: ARRAY
32713: NOT
32714: IFFALSE 32718
// break ;
32716: GO 32817
// if not HasTask ( j ) then
32718: LD_VAR 0 3
32722: PPUSH
32723: CALL_OW 314
32727: NOT
32728: IFFALSE 32815
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32730: LD_VAR 0 3
32734: PPUSH
32735: LD_EXP 99
32739: PUSH
32740: LD_VAR 0 2
32744: ARRAY
32745: PUSH
32746: LD_INT 1
32748: ARRAY
32749: PUSH
32750: LD_INT 1
32752: ARRAY
32753: PPUSH
32754: LD_EXP 99
32758: PUSH
32759: LD_VAR 0 2
32763: ARRAY
32764: PUSH
32765: LD_INT 1
32767: ARRAY
32768: PUSH
32769: LD_INT 2
32771: ARRAY
32772: PPUSH
32773: LD_EXP 99
32777: PUSH
32778: LD_VAR 0 2
32782: ARRAY
32783: PUSH
32784: LD_INT 1
32786: ARRAY
32787: PUSH
32788: LD_INT 3
32790: ARRAY
32791: PPUSH
32792: LD_EXP 99
32796: PUSH
32797: LD_VAR 0 2
32801: ARRAY
32802: PUSH
32803: LD_INT 1
32805: ARRAY
32806: PUSH
32807: LD_INT 4
32809: ARRAY
32810: PPUSH
32811: CALL_OW 145
// end ;
32815: GO 32604
32817: POP
32818: POP
// end else
32819: GO 32991
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32821: LD_EXP 94
32825: PUSH
32826: LD_VAR 0 2
32830: ARRAY
32831: PPUSH
32832: LD_EXP 99
32836: PUSH
32837: LD_VAR 0 2
32841: ARRAY
32842: PUSH
32843: LD_INT 1
32845: ARRAY
32846: PUSH
32847: LD_INT 1
32849: ARRAY
32850: PPUSH
32851: LD_EXP 99
32855: PUSH
32856: LD_VAR 0 2
32860: ARRAY
32861: PUSH
32862: LD_INT 1
32864: ARRAY
32865: PUSH
32866: LD_INT 2
32868: ARRAY
32869: PPUSH
32870: LD_EXP 99
32874: PUSH
32875: LD_VAR 0 2
32879: ARRAY
32880: PUSH
32881: LD_INT 1
32883: ARRAY
32884: PUSH
32885: LD_INT 3
32887: ARRAY
32888: PPUSH
32889: LD_EXP 99
32893: PUSH
32894: LD_VAR 0 2
32898: ARRAY
32899: PUSH
32900: LD_INT 1
32902: ARRAY
32903: PUSH
32904: LD_INT 4
32906: ARRAY
32907: PPUSH
32908: LD_EXP 94
32912: PUSH
32913: LD_VAR 0 2
32917: ARRAY
32918: PPUSH
32919: LD_INT 21
32921: PUSH
32922: LD_INT 3
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PPUSH
32929: CALL_OW 72
32933: PPUSH
32934: EMPTY
32935: PPUSH
32936: CALL 64030 0 7
32940: NOT
32941: IFFALSE 32991
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32943: LD_ADDR_EXP 99
32947: PUSH
32948: LD_EXP 99
32952: PPUSH
32953: LD_VAR 0 2
32957: PPUSH
32958: LD_EXP 99
32962: PUSH
32963: LD_VAR 0 2
32967: ARRAY
32968: PPUSH
32969: LD_INT 1
32971: PPUSH
32972: LD_INT 1
32974: NEG
32975: PPUSH
32976: LD_INT 0
32978: PPUSH
32979: CALL 56595 0 4
32983: PPUSH
32984: CALL_OW 1
32988: ST_TO_ADDR
// continue ;
32989: GO 31839
// end ; end ; end ;
32991: GO 31839
32993: POP
32994: POP
// end ;
32995: LD_VAR 0 1
32999: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33000: LD_INT 0
33002: PPUSH
33003: PPUSH
33004: PPUSH
33005: PPUSH
33006: PPUSH
33007: PPUSH
// if not mc_bases then
33008: LD_EXP 94
33012: NOT
33013: IFFALSE 33017
// exit ;
33015: GO 33444
// for i = 1 to mc_bases do
33017: LD_ADDR_VAR 0 2
33021: PUSH
33022: DOUBLE
33023: LD_INT 1
33025: DEC
33026: ST_TO_ADDR
33027: LD_EXP 94
33031: PUSH
33032: FOR_TO
33033: IFFALSE 33442
// begin tmp := mc_build_upgrade [ i ] ;
33035: LD_ADDR_VAR 0 4
33039: PUSH
33040: LD_EXP 126
33044: PUSH
33045: LD_VAR 0 2
33049: ARRAY
33050: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33051: LD_ADDR_VAR 0 6
33055: PUSH
33056: LD_EXP 127
33060: PUSH
33061: LD_VAR 0 2
33065: ARRAY
33066: PPUSH
33067: LD_INT 2
33069: PUSH
33070: LD_INT 30
33072: PUSH
33073: LD_INT 6
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 30
33082: PUSH
33083: LD_INT 7
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: LIST
33094: PPUSH
33095: CALL_OW 72
33099: ST_TO_ADDR
// if not tmp and not lab then
33100: LD_VAR 0 4
33104: NOT
33105: PUSH
33106: LD_VAR 0 6
33110: NOT
33111: AND
33112: IFFALSE 33116
// continue ;
33114: GO 33032
// if tmp then
33116: LD_VAR 0 4
33120: IFFALSE 33240
// for j in tmp do
33122: LD_ADDR_VAR 0 3
33126: PUSH
33127: LD_VAR 0 4
33131: PUSH
33132: FOR_IN
33133: IFFALSE 33238
// begin if UpgradeCost ( j ) then
33135: LD_VAR 0 3
33139: PPUSH
33140: CALL 63690 0 1
33144: IFFALSE 33236
// begin ComUpgrade ( j ) ;
33146: LD_VAR 0 3
33150: PPUSH
33151: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33155: LD_ADDR_EXP 126
33159: PUSH
33160: LD_EXP 126
33164: PPUSH
33165: LD_VAR 0 2
33169: PPUSH
33170: LD_EXP 126
33174: PUSH
33175: LD_VAR 0 2
33179: ARRAY
33180: PUSH
33181: LD_VAR 0 3
33185: DIFF
33186: PPUSH
33187: CALL_OW 1
33191: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33192: LD_ADDR_EXP 101
33196: PUSH
33197: LD_EXP 101
33201: PPUSH
33202: LD_VAR 0 2
33206: PUSH
33207: LD_EXP 101
33211: PUSH
33212: LD_VAR 0 2
33216: ARRAY
33217: PUSH
33218: LD_INT 1
33220: PLUS
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PPUSH
33226: LD_VAR 0 3
33230: PPUSH
33231: CALL 57177 0 3
33235: ST_TO_ADDR
// end ; end ;
33236: GO 33132
33238: POP
33239: POP
// if not lab or not mc_lab_upgrade [ i ] then
33240: LD_VAR 0 6
33244: NOT
33245: PUSH
33246: LD_EXP 128
33250: PUSH
33251: LD_VAR 0 2
33255: ARRAY
33256: NOT
33257: OR
33258: IFFALSE 33262
// continue ;
33260: GO 33032
// for j in lab do
33262: LD_ADDR_VAR 0 3
33266: PUSH
33267: LD_VAR 0 6
33271: PUSH
33272: FOR_IN
33273: IFFALSE 33438
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33275: LD_VAR 0 3
33279: PPUSH
33280: CALL_OW 266
33284: PUSH
33285: LD_INT 6
33287: PUSH
33288: LD_INT 7
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: IN
33295: PUSH
33296: LD_VAR 0 3
33300: PPUSH
33301: CALL_OW 461
33305: PUSH
33306: LD_INT 1
33308: NONEQUAL
33309: AND
33310: IFFALSE 33436
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33312: LD_VAR 0 3
33316: PPUSH
33317: LD_EXP 128
33321: PUSH
33322: LD_VAR 0 2
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: PPUSH
33332: CALL 63895 0 2
33336: IFFALSE 33436
// begin ComCancel ( j ) ;
33338: LD_VAR 0 3
33342: PPUSH
33343: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33347: LD_VAR 0 3
33351: PPUSH
33352: LD_EXP 128
33356: PUSH
33357: LD_VAR 0 2
33361: ARRAY
33362: PUSH
33363: LD_INT 1
33365: ARRAY
33366: PPUSH
33367: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33371: LD_VAR 0 3
33375: PUSH
33376: LD_EXP 101
33380: PUSH
33381: LD_VAR 0 2
33385: ARRAY
33386: IN
33387: NOT
33388: IFFALSE 33434
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33390: LD_ADDR_EXP 101
33394: PUSH
33395: LD_EXP 101
33399: PPUSH
33400: LD_VAR 0 2
33404: PUSH
33405: LD_EXP 101
33409: PUSH
33410: LD_VAR 0 2
33414: ARRAY
33415: PUSH
33416: LD_INT 1
33418: PLUS
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PPUSH
33424: LD_VAR 0 3
33428: PPUSH
33429: CALL 57177 0 3
33433: ST_TO_ADDR
// break ;
33434: GO 33438
// end ; end ; end ;
33436: GO 33272
33438: POP
33439: POP
// end ;
33440: GO 33032
33442: POP
33443: POP
// end ;
33444: LD_VAR 0 1
33448: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33449: LD_INT 0
33451: PPUSH
33452: PPUSH
33453: PPUSH
33454: PPUSH
33455: PPUSH
33456: PPUSH
33457: PPUSH
33458: PPUSH
33459: PPUSH
// if not mc_bases then
33460: LD_EXP 94
33464: NOT
33465: IFFALSE 33469
// exit ;
33467: GO 33874
// for i = 1 to mc_bases do
33469: LD_ADDR_VAR 0 2
33473: PUSH
33474: DOUBLE
33475: LD_INT 1
33477: DEC
33478: ST_TO_ADDR
33479: LD_EXP 94
33483: PUSH
33484: FOR_TO
33485: IFFALSE 33872
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33487: LD_EXP 102
33491: PUSH
33492: LD_VAR 0 2
33496: ARRAY
33497: NOT
33498: PUSH
33499: LD_EXP 94
33503: PUSH
33504: LD_VAR 0 2
33508: ARRAY
33509: PPUSH
33510: LD_INT 30
33512: PUSH
33513: LD_INT 3
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PPUSH
33520: CALL_OW 72
33524: NOT
33525: OR
33526: IFFALSE 33530
// continue ;
33528: GO 33484
// busy := false ;
33530: LD_ADDR_VAR 0 8
33534: PUSH
33535: LD_INT 0
33537: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33538: LD_ADDR_VAR 0 4
33542: PUSH
33543: LD_EXP 94
33547: PUSH
33548: LD_VAR 0 2
33552: ARRAY
33553: PPUSH
33554: LD_INT 30
33556: PUSH
33557: LD_INT 3
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PPUSH
33564: CALL_OW 72
33568: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33569: LD_ADDR_VAR 0 6
33573: PUSH
33574: LD_EXP 102
33578: PUSH
33579: LD_VAR 0 2
33583: ARRAY
33584: PPUSH
33585: LD_INT 2
33587: PUSH
33588: LD_INT 30
33590: PUSH
33591: LD_INT 32
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 30
33600: PUSH
33601: LD_INT 33
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: LIST
33612: PPUSH
33613: CALL_OW 72
33617: ST_TO_ADDR
// if not t then
33618: LD_VAR 0 6
33622: NOT
33623: IFFALSE 33627
// continue ;
33625: GO 33484
// for j in tmp do
33627: LD_ADDR_VAR 0 3
33631: PUSH
33632: LD_VAR 0 4
33636: PUSH
33637: FOR_IN
33638: IFFALSE 33668
// if not BuildingStatus ( j ) = bs_idle then
33640: LD_VAR 0 3
33644: PPUSH
33645: CALL_OW 461
33649: PUSH
33650: LD_INT 2
33652: EQUAL
33653: NOT
33654: IFFALSE 33666
// begin busy := true ;
33656: LD_ADDR_VAR 0 8
33660: PUSH
33661: LD_INT 1
33663: ST_TO_ADDR
// break ;
33664: GO 33668
// end ;
33666: GO 33637
33668: POP
33669: POP
// if busy then
33670: LD_VAR 0 8
33674: IFFALSE 33678
// continue ;
33676: GO 33484
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33678: LD_ADDR_VAR 0 7
33682: PUSH
33683: LD_VAR 0 6
33687: PPUSH
33688: LD_INT 35
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PPUSH
33698: CALL_OW 72
33702: ST_TO_ADDR
// if tw then
33703: LD_VAR 0 7
33707: IFFALSE 33784
// begin tw := tw [ 1 ] ;
33709: LD_ADDR_VAR 0 7
33713: PUSH
33714: LD_VAR 0 7
33718: PUSH
33719: LD_INT 1
33721: ARRAY
33722: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33723: LD_ADDR_VAR 0 9
33727: PUSH
33728: LD_VAR 0 7
33732: PPUSH
33733: LD_EXP 119
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: PPUSH
33744: CALL 62187 0 2
33748: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33749: LD_EXP 133
33753: PUSH
33754: LD_VAR 0 2
33758: ARRAY
33759: IFFALSE 33782
// if not weapon in mc_allowed_tower_weapons [ i ] then
33761: LD_VAR 0 9
33765: PUSH
33766: LD_EXP 133
33770: PUSH
33771: LD_VAR 0 2
33775: ARRAY
33776: IN
33777: NOT
33778: IFFALSE 33782
// continue ;
33780: GO 33484
// end else
33782: GO 33847
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33784: LD_ADDR_VAR 0 5
33788: PUSH
33789: LD_EXP 102
33793: PUSH
33794: LD_VAR 0 2
33798: ARRAY
33799: PPUSH
33800: LD_VAR 0 4
33804: PPUSH
33805: CALL 88987 0 2
33809: ST_TO_ADDR
// if not tmp2 then
33810: LD_VAR 0 5
33814: NOT
33815: IFFALSE 33819
// continue ;
33817: GO 33484
// tw := tmp2 [ 1 ] ;
33819: LD_ADDR_VAR 0 7
33823: PUSH
33824: LD_VAR 0 5
33828: PUSH
33829: LD_INT 1
33831: ARRAY
33832: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33833: LD_ADDR_VAR 0 9
33837: PUSH
33838: LD_VAR 0 5
33842: PUSH
33843: LD_INT 2
33845: ARRAY
33846: ST_TO_ADDR
// end ; if not weapon then
33847: LD_VAR 0 9
33851: NOT
33852: IFFALSE 33856
// continue ;
33854: GO 33484
// ComPlaceWeapon ( tw , weapon ) ;
33856: LD_VAR 0 7
33860: PPUSH
33861: LD_VAR 0 9
33865: PPUSH
33866: CALL_OW 148
// end ;
33870: GO 33484
33872: POP
33873: POP
// end ;
33874: LD_VAR 0 1
33878: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33879: LD_INT 0
33881: PPUSH
33882: PPUSH
33883: PPUSH
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
// if not mc_bases then
33888: LD_EXP 94
33892: NOT
33893: IFFALSE 33897
// exit ;
33895: GO 34665
// for i = 1 to mc_bases do
33897: LD_ADDR_VAR 0 2
33901: PUSH
33902: DOUBLE
33903: LD_INT 1
33905: DEC
33906: ST_TO_ADDR
33907: LD_EXP 94
33911: PUSH
33912: FOR_TO
33913: IFFALSE 34663
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33915: LD_EXP 107
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: NOT
33926: PUSH
33927: LD_EXP 107
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: PUSH
33938: LD_EXP 108
33942: PUSH
33943: LD_VAR 0 2
33947: ARRAY
33948: EQUAL
33949: OR
33950: PUSH
33951: LD_EXP 117
33955: PUSH
33956: LD_VAR 0 2
33960: ARRAY
33961: OR
33962: IFFALSE 33966
// continue ;
33964: GO 33912
// if mc_miners [ i ] then
33966: LD_EXP 108
33970: PUSH
33971: LD_VAR 0 2
33975: ARRAY
33976: IFFALSE 34350
// begin for j = mc_miners [ i ] downto 1 do
33978: LD_ADDR_VAR 0 3
33982: PUSH
33983: DOUBLE
33984: LD_EXP 108
33988: PUSH
33989: LD_VAR 0 2
33993: ARRAY
33994: INC
33995: ST_TO_ADDR
33996: LD_INT 1
33998: PUSH
33999: FOR_DOWNTO
34000: IFFALSE 34348
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34002: LD_EXP 108
34006: PUSH
34007: LD_VAR 0 2
34011: ARRAY
34012: PUSH
34013: LD_VAR 0 3
34017: ARRAY
34018: PPUSH
34019: CALL_OW 301
34023: PUSH
34024: LD_EXP 108
34028: PUSH
34029: LD_VAR 0 2
34033: ARRAY
34034: PUSH
34035: LD_VAR 0 3
34039: ARRAY
34040: PPUSH
34041: CALL_OW 257
34045: PUSH
34046: LD_INT 1
34048: NONEQUAL
34049: OR
34050: IFFALSE 34113
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34052: LD_ADDR_VAR 0 5
34056: PUSH
34057: LD_EXP 108
34061: PUSH
34062: LD_VAR 0 2
34066: ARRAY
34067: PUSH
34068: LD_EXP 108
34072: PUSH
34073: LD_VAR 0 2
34077: ARRAY
34078: PUSH
34079: LD_VAR 0 3
34083: ARRAY
34084: DIFF
34085: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34086: LD_ADDR_EXP 108
34090: PUSH
34091: LD_EXP 108
34095: PPUSH
34096: LD_VAR 0 2
34100: PPUSH
34101: LD_VAR 0 5
34105: PPUSH
34106: CALL_OW 1
34110: ST_TO_ADDR
// continue ;
34111: GO 33999
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34113: LD_EXP 108
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_VAR 0 3
34128: ARRAY
34129: PPUSH
34130: CALL_OW 257
34134: PUSH
34135: LD_INT 1
34137: EQUAL
34138: PUSH
34139: LD_EXP 108
34143: PUSH
34144: LD_VAR 0 2
34148: ARRAY
34149: PUSH
34150: LD_VAR 0 3
34154: ARRAY
34155: PPUSH
34156: CALL_OW 459
34160: NOT
34161: AND
34162: PUSH
34163: LD_EXP 108
34167: PUSH
34168: LD_VAR 0 2
34172: ARRAY
34173: PUSH
34174: LD_VAR 0 3
34178: ARRAY
34179: PPUSH
34180: CALL_OW 314
34184: NOT
34185: AND
34186: IFFALSE 34346
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34188: LD_EXP 108
34192: PUSH
34193: LD_VAR 0 2
34197: ARRAY
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PPUSH
34205: CALL_OW 310
34209: IFFALSE 34232
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34211: LD_EXP 108
34215: PUSH
34216: LD_VAR 0 2
34220: ARRAY
34221: PUSH
34222: LD_VAR 0 3
34226: ARRAY
34227: PPUSH
34228: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34232: LD_EXP 108
34236: PUSH
34237: LD_VAR 0 2
34241: ARRAY
34242: PUSH
34243: LD_VAR 0 3
34247: ARRAY
34248: PPUSH
34249: CALL_OW 314
34253: NOT
34254: IFFALSE 34346
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34256: LD_ADDR_VAR 0 7
34260: PUSH
34261: LD_INT 1
34263: PPUSH
34264: LD_EXP 107
34268: PUSH
34269: LD_VAR 0 2
34273: ARRAY
34274: PPUSH
34275: CALL_OW 12
34279: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34280: LD_EXP 108
34284: PUSH
34285: LD_VAR 0 2
34289: ARRAY
34290: PUSH
34291: LD_VAR 0 3
34295: ARRAY
34296: PPUSH
34297: LD_EXP 107
34301: PUSH
34302: LD_VAR 0 2
34306: ARRAY
34307: PUSH
34308: LD_VAR 0 7
34312: ARRAY
34313: PUSH
34314: LD_INT 1
34316: ARRAY
34317: PPUSH
34318: LD_EXP 107
34322: PUSH
34323: LD_VAR 0 2
34327: ARRAY
34328: PUSH
34329: LD_VAR 0 7
34333: ARRAY
34334: PUSH
34335: LD_INT 2
34337: ARRAY
34338: PPUSH
34339: LD_INT 0
34341: PPUSH
34342: CALL_OW 193
// end ; end ; end ;
34346: GO 33999
34348: POP
34349: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34350: LD_ADDR_VAR 0 5
34354: PUSH
34355: LD_EXP 94
34359: PUSH
34360: LD_VAR 0 2
34364: ARRAY
34365: PPUSH
34366: LD_INT 2
34368: PUSH
34369: LD_INT 30
34371: PUSH
34372: LD_INT 4
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 30
34381: PUSH
34382: LD_INT 5
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 30
34391: PUSH
34392: LD_INT 32
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: PPUSH
34405: CALL_OW 72
34409: ST_TO_ADDR
// if not tmp then
34410: LD_VAR 0 5
34414: NOT
34415: IFFALSE 34419
// continue ;
34417: GO 33912
// list := [ ] ;
34419: LD_ADDR_VAR 0 6
34423: PUSH
34424: EMPTY
34425: ST_TO_ADDR
// for j in tmp do
34426: LD_ADDR_VAR 0 3
34430: PUSH
34431: LD_VAR 0 5
34435: PUSH
34436: FOR_IN
34437: IFFALSE 34506
// begin for k in UnitsInside ( j ) do
34439: LD_ADDR_VAR 0 4
34443: PUSH
34444: LD_VAR 0 3
34448: PPUSH
34449: CALL_OW 313
34453: PUSH
34454: FOR_IN
34455: IFFALSE 34502
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34457: LD_VAR 0 4
34461: PPUSH
34462: CALL_OW 257
34466: PUSH
34467: LD_INT 1
34469: EQUAL
34470: PUSH
34471: LD_VAR 0 4
34475: PPUSH
34476: CALL_OW 459
34480: NOT
34481: AND
34482: IFFALSE 34500
// list := list ^ k ;
34484: LD_ADDR_VAR 0 6
34488: PUSH
34489: LD_VAR 0 6
34493: PUSH
34494: LD_VAR 0 4
34498: ADD
34499: ST_TO_ADDR
34500: GO 34454
34502: POP
34503: POP
// end ;
34504: GO 34436
34506: POP
34507: POP
// list := list diff mc_miners [ i ] ;
34508: LD_ADDR_VAR 0 6
34512: PUSH
34513: LD_VAR 0 6
34517: PUSH
34518: LD_EXP 108
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: DIFF
34529: ST_TO_ADDR
// if not list then
34530: LD_VAR 0 6
34534: NOT
34535: IFFALSE 34539
// continue ;
34537: GO 33912
// k := mc_mines [ i ] - mc_miners [ i ] ;
34539: LD_ADDR_VAR 0 4
34543: PUSH
34544: LD_EXP 107
34548: PUSH
34549: LD_VAR 0 2
34553: ARRAY
34554: PUSH
34555: LD_EXP 108
34559: PUSH
34560: LD_VAR 0 2
34564: ARRAY
34565: MINUS
34566: ST_TO_ADDR
// if k > list then
34567: LD_VAR 0 4
34571: PUSH
34572: LD_VAR 0 6
34576: GREATER
34577: IFFALSE 34589
// k := list ;
34579: LD_ADDR_VAR 0 4
34583: PUSH
34584: LD_VAR 0 6
34588: ST_TO_ADDR
// for j = 1 to k do
34589: LD_ADDR_VAR 0 3
34593: PUSH
34594: DOUBLE
34595: LD_INT 1
34597: DEC
34598: ST_TO_ADDR
34599: LD_VAR 0 4
34603: PUSH
34604: FOR_TO
34605: IFFALSE 34659
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34607: LD_ADDR_EXP 108
34611: PUSH
34612: LD_EXP 108
34616: PPUSH
34617: LD_VAR 0 2
34621: PUSH
34622: LD_EXP 108
34626: PUSH
34627: LD_VAR 0 2
34631: ARRAY
34632: PUSH
34633: LD_INT 1
34635: PLUS
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PPUSH
34641: LD_VAR 0 6
34645: PUSH
34646: LD_VAR 0 3
34650: ARRAY
34651: PPUSH
34652: CALL 57177 0 3
34656: ST_TO_ADDR
34657: GO 34604
34659: POP
34660: POP
// end ;
34661: GO 33912
34663: POP
34664: POP
// end ;
34665: LD_VAR 0 1
34669: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34670: LD_INT 0
34672: PPUSH
34673: PPUSH
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
34679: PPUSH
34680: PPUSH
34681: PPUSH
34682: PPUSH
// if not mc_bases then
34683: LD_EXP 94
34687: NOT
34688: IFFALSE 34692
// exit ;
34690: GO 36515
// for i = 1 to mc_bases do
34692: LD_ADDR_VAR 0 2
34696: PUSH
34697: DOUBLE
34698: LD_INT 1
34700: DEC
34701: ST_TO_ADDR
34702: LD_EXP 94
34706: PUSH
34707: FOR_TO
34708: IFFALSE 36513
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34710: LD_EXP 94
34714: PUSH
34715: LD_VAR 0 2
34719: ARRAY
34720: NOT
34721: PUSH
34722: LD_EXP 101
34726: PUSH
34727: LD_VAR 0 2
34731: ARRAY
34732: OR
34733: IFFALSE 34737
// continue ;
34735: GO 34707
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34737: LD_EXP 110
34741: PUSH
34742: LD_VAR 0 2
34746: ARRAY
34747: NOT
34748: PUSH
34749: LD_EXP 111
34753: PUSH
34754: LD_VAR 0 2
34758: ARRAY
34759: AND
34760: IFFALSE 34798
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34762: LD_ADDR_EXP 111
34766: PUSH
34767: LD_EXP 111
34771: PPUSH
34772: LD_VAR 0 2
34776: PPUSH
34777: EMPTY
34778: PPUSH
34779: CALL_OW 1
34783: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34784: LD_VAR 0 2
34788: PPUSH
34789: LD_INT 107
34791: PPUSH
34792: CALL 25566 0 2
// continue ;
34796: GO 34707
// end ; target := [ ] ;
34798: LD_ADDR_VAR 0 7
34802: PUSH
34803: EMPTY
34804: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34805: LD_ADDR_VAR 0 6
34809: PUSH
34810: LD_EXP 94
34814: PUSH
34815: LD_VAR 0 2
34819: ARRAY
34820: PUSH
34821: LD_INT 1
34823: ARRAY
34824: PPUSH
34825: CALL_OW 255
34829: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34830: LD_ADDR_VAR 0 9
34834: PUSH
34835: LD_EXP 94
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PPUSH
34846: LD_INT 2
34848: PUSH
34849: LD_INT 30
34851: PUSH
34852: LD_INT 0
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: LIST
34873: PPUSH
34874: CALL_OW 72
34878: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34879: LD_ADDR_VAR 0 3
34883: PUSH
34884: DOUBLE
34885: LD_EXP 110
34889: PUSH
34890: LD_VAR 0 2
34894: ARRAY
34895: INC
34896: ST_TO_ADDR
34897: LD_INT 1
34899: PUSH
34900: FOR_DOWNTO
34901: IFFALSE 35146
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34903: LD_EXP 110
34907: PUSH
34908: LD_VAR 0 2
34912: ARRAY
34913: PUSH
34914: LD_VAR 0 3
34918: ARRAY
34919: PUSH
34920: LD_INT 2
34922: ARRAY
34923: PPUSH
34924: LD_EXP 110
34928: PUSH
34929: LD_VAR 0 2
34933: ARRAY
34934: PUSH
34935: LD_VAR 0 3
34939: ARRAY
34940: PUSH
34941: LD_INT 3
34943: ARRAY
34944: PPUSH
34945: CALL_OW 488
34949: PUSH
34950: LD_EXP 110
34954: PUSH
34955: LD_VAR 0 2
34959: ARRAY
34960: PUSH
34961: LD_VAR 0 3
34965: ARRAY
34966: PUSH
34967: LD_INT 2
34969: ARRAY
34970: PPUSH
34971: LD_EXP 110
34975: PUSH
34976: LD_VAR 0 2
34980: ARRAY
34981: PUSH
34982: LD_VAR 0 3
34986: ARRAY
34987: PUSH
34988: LD_INT 3
34990: ARRAY
34991: PPUSH
34992: CALL_OW 284
34996: PUSH
34997: LD_INT 0
34999: EQUAL
35000: AND
35001: IFFALSE 35056
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35003: LD_ADDR_VAR 0 5
35007: PUSH
35008: LD_EXP 110
35012: PUSH
35013: LD_VAR 0 2
35017: ARRAY
35018: PPUSH
35019: LD_VAR 0 3
35023: PPUSH
35024: CALL_OW 3
35028: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35029: LD_ADDR_EXP 110
35033: PUSH
35034: LD_EXP 110
35038: PPUSH
35039: LD_VAR 0 2
35043: PPUSH
35044: LD_VAR 0 5
35048: PPUSH
35049: CALL_OW 1
35053: ST_TO_ADDR
// continue ;
35054: GO 34900
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35056: LD_VAR 0 6
35060: PPUSH
35061: LD_EXP 110
35065: PUSH
35066: LD_VAR 0 2
35070: ARRAY
35071: PUSH
35072: LD_VAR 0 3
35076: ARRAY
35077: PUSH
35078: LD_INT 2
35080: ARRAY
35081: PPUSH
35082: LD_EXP 110
35086: PUSH
35087: LD_VAR 0 2
35091: ARRAY
35092: PUSH
35093: LD_VAR 0 3
35097: ARRAY
35098: PUSH
35099: LD_INT 3
35101: ARRAY
35102: PPUSH
35103: LD_INT 30
35105: PPUSH
35106: CALL 58073 0 4
35110: PUSH
35111: LD_INT 4
35113: ARRAY
35114: PUSH
35115: LD_INT 0
35117: EQUAL
35118: IFFALSE 35144
// begin target := mc_crates [ i ] [ j ] ;
35120: LD_ADDR_VAR 0 7
35124: PUSH
35125: LD_EXP 110
35129: PUSH
35130: LD_VAR 0 2
35134: ARRAY
35135: PUSH
35136: LD_VAR 0 3
35140: ARRAY
35141: ST_TO_ADDR
// break ;
35142: GO 35146
// end ; end ;
35144: GO 34900
35146: POP
35147: POP
// if not target then
35148: LD_VAR 0 7
35152: NOT
35153: IFFALSE 35157
// continue ;
35155: GO 34707
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35157: LD_ADDR_VAR 0 8
35161: PUSH
35162: LD_EXP 113
35166: PUSH
35167: LD_VAR 0 2
35171: ARRAY
35172: PPUSH
35173: LD_INT 2
35175: PUSH
35176: LD_INT 3
35178: PUSH
35179: LD_INT 58
35181: PUSH
35182: EMPTY
35183: LIST
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 61
35191: PUSH
35192: EMPTY
35193: LIST
35194: PUSH
35195: LD_INT 33
35197: PUSH
35198: LD_INT 5
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 33
35207: PUSH
35208: LD_INT 3
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: LIST
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 2
35224: PUSH
35225: LD_INT 34
35227: PUSH
35228: LD_INT 32
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 34
35237: PUSH
35238: LD_INT 51
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 34
35247: PUSH
35248: LD_INT 12
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: LIST
35259: LIST
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PPUSH
35265: CALL_OW 72
35269: ST_TO_ADDR
// if not cargo then
35270: LD_VAR 0 8
35274: NOT
35275: IFFALSE 35981
// begin if mc_crates_collector [ i ] < 5 then
35277: LD_EXP 111
35281: PUSH
35282: LD_VAR 0 2
35286: ARRAY
35287: PUSH
35288: LD_INT 5
35290: LESS
35291: IFFALSE 35657
// begin if mc_ape [ i ] then
35293: LD_EXP 123
35297: PUSH
35298: LD_VAR 0 2
35302: ARRAY
35303: IFFALSE 35350
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35305: LD_ADDR_VAR 0 5
35309: PUSH
35310: LD_EXP 123
35314: PUSH
35315: LD_VAR 0 2
35319: ARRAY
35320: PPUSH
35321: LD_INT 25
35323: PUSH
35324: LD_INT 16
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 24
35333: PUSH
35334: LD_INT 750
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PPUSH
35345: CALL_OW 72
35349: ST_TO_ADDR
// if not tmp then
35350: LD_VAR 0 5
35354: NOT
35355: IFFALSE 35402
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35357: LD_ADDR_VAR 0 5
35361: PUSH
35362: LD_EXP 94
35366: PUSH
35367: LD_VAR 0 2
35371: ARRAY
35372: PPUSH
35373: LD_INT 25
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 24
35385: PUSH
35386: LD_INT 750
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PPUSH
35397: CALL_OW 72
35401: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35402: LD_EXP 123
35406: PUSH
35407: LD_VAR 0 2
35411: ARRAY
35412: PUSH
35413: LD_EXP 94
35417: PUSH
35418: LD_VAR 0 2
35422: ARRAY
35423: PPUSH
35424: LD_INT 25
35426: PUSH
35427: LD_INT 2
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 24
35436: PUSH
35437: LD_INT 750
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PPUSH
35448: CALL_OW 72
35452: AND
35453: PUSH
35454: LD_VAR 0 5
35458: PUSH
35459: LD_INT 5
35461: LESS
35462: AND
35463: IFFALSE 35545
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35465: LD_ADDR_VAR 0 3
35469: PUSH
35470: LD_EXP 94
35474: PUSH
35475: LD_VAR 0 2
35479: ARRAY
35480: PPUSH
35481: LD_INT 25
35483: PUSH
35484: LD_INT 2
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 24
35493: PUSH
35494: LD_INT 750
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PPUSH
35505: CALL_OW 72
35509: PUSH
35510: FOR_IN
35511: IFFALSE 35543
// begin tmp := tmp union j ;
35513: LD_ADDR_VAR 0 5
35517: PUSH
35518: LD_VAR 0 5
35522: PUSH
35523: LD_VAR 0 3
35527: UNION
35528: ST_TO_ADDR
// if tmp >= 5 then
35529: LD_VAR 0 5
35533: PUSH
35534: LD_INT 5
35536: GREATEREQUAL
35537: IFFALSE 35541
// break ;
35539: GO 35543
// end ;
35541: GO 35510
35543: POP
35544: POP
// end ; if not tmp then
35545: LD_VAR 0 5
35549: NOT
35550: IFFALSE 35554
// continue ;
35552: GO 34707
// for j in tmp do
35554: LD_ADDR_VAR 0 3
35558: PUSH
35559: LD_VAR 0 5
35563: PUSH
35564: FOR_IN
35565: IFFALSE 35655
// if not GetTag ( j ) then
35567: LD_VAR 0 3
35571: PPUSH
35572: CALL_OW 110
35576: NOT
35577: IFFALSE 35653
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35579: LD_ADDR_EXP 111
35583: PUSH
35584: LD_EXP 111
35588: PPUSH
35589: LD_VAR 0 2
35593: PUSH
35594: LD_EXP 111
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: PUSH
35605: LD_INT 1
35607: PLUS
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PPUSH
35613: LD_VAR 0 3
35617: PPUSH
35618: CALL 57177 0 3
35622: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35623: LD_VAR 0 3
35627: PPUSH
35628: LD_INT 107
35630: PPUSH
35631: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35635: LD_EXP 111
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 5
35648: GREATEREQUAL
35649: IFFALSE 35653
// break ;
35651: GO 35655
// end ;
35653: GO 35564
35655: POP
35656: POP
// end ; if mc_crates_collector [ i ] and target then
35657: LD_EXP 111
35661: PUSH
35662: LD_VAR 0 2
35666: ARRAY
35667: PUSH
35668: LD_VAR 0 7
35672: AND
35673: IFFALSE 35979
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35675: LD_EXP 111
35679: PUSH
35680: LD_VAR 0 2
35684: ARRAY
35685: PUSH
35686: LD_VAR 0 7
35690: PUSH
35691: LD_INT 1
35693: ARRAY
35694: LESS
35695: IFFALSE 35715
// tmp := mc_crates_collector [ i ] else
35697: LD_ADDR_VAR 0 5
35701: PUSH
35702: LD_EXP 111
35706: PUSH
35707: LD_VAR 0 2
35711: ARRAY
35712: ST_TO_ADDR
35713: GO 35729
// tmp := target [ 1 ] ;
35715: LD_ADDR_VAR 0 5
35719: PUSH
35720: LD_VAR 0 7
35724: PUSH
35725: LD_INT 1
35727: ARRAY
35728: ST_TO_ADDR
// k := 0 ;
35729: LD_ADDR_VAR 0 4
35733: PUSH
35734: LD_INT 0
35736: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35737: LD_ADDR_VAR 0 3
35741: PUSH
35742: LD_EXP 111
35746: PUSH
35747: LD_VAR 0 2
35751: ARRAY
35752: PUSH
35753: FOR_IN
35754: IFFALSE 35977
// begin k := k + 1 ;
35756: LD_ADDR_VAR 0 4
35760: PUSH
35761: LD_VAR 0 4
35765: PUSH
35766: LD_INT 1
35768: PLUS
35769: ST_TO_ADDR
// if k > tmp then
35770: LD_VAR 0 4
35774: PUSH
35775: LD_VAR 0 5
35779: GREATER
35780: IFFALSE 35784
// break ;
35782: GO 35977
// if not GetClass ( j ) in [ 2 , 16 ] then
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 257
35793: PUSH
35794: LD_INT 2
35796: PUSH
35797: LD_INT 16
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: IN
35804: NOT
35805: IFFALSE 35858
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35807: LD_ADDR_EXP 111
35811: PUSH
35812: LD_EXP 111
35816: PPUSH
35817: LD_VAR 0 2
35821: PPUSH
35822: LD_EXP 111
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PUSH
35833: LD_VAR 0 3
35837: DIFF
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35844: LD_VAR 0 3
35848: PPUSH
35849: LD_INT 0
35851: PPUSH
35852: CALL_OW 109
// continue ;
35856: GO 35753
// end ; if IsInUnit ( j ) then
35858: LD_VAR 0 3
35862: PPUSH
35863: CALL_OW 310
35867: IFFALSE 35878
// ComExitBuilding ( j ) ;
35869: LD_VAR 0 3
35873: PPUSH
35874: CALL_OW 122
// wait ( 3 ) ;
35878: LD_INT 3
35880: PPUSH
35881: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35885: LD_VAR 0 3
35889: PPUSH
35890: CALL_OW 314
35894: PUSH
35895: LD_VAR 0 6
35899: PPUSH
35900: LD_VAR 0 7
35904: PUSH
35905: LD_INT 2
35907: ARRAY
35908: PPUSH
35909: LD_VAR 0 7
35913: PUSH
35914: LD_INT 3
35916: ARRAY
35917: PPUSH
35918: LD_INT 30
35920: PPUSH
35921: CALL 58073 0 4
35925: PUSH
35926: LD_INT 4
35928: ARRAY
35929: AND
35930: IFFALSE 35948
// ComStandNearbyBuilding ( j , depot ) else
35932: LD_VAR 0 3
35936: PPUSH
35937: LD_VAR 0 9
35941: PPUSH
35942: CALL 53602 0 2
35946: GO 35975
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35948: LD_VAR 0 3
35952: PPUSH
35953: LD_VAR 0 7
35957: PUSH
35958: LD_INT 2
35960: ARRAY
35961: PPUSH
35962: LD_VAR 0 7
35966: PUSH
35967: LD_INT 3
35969: ARRAY
35970: PPUSH
35971: CALL_OW 117
// end ;
35975: GO 35753
35977: POP
35978: POP
// end ; end else
35979: GO 36511
// begin for j in cargo do
35981: LD_ADDR_VAR 0 3
35985: PUSH
35986: LD_VAR 0 8
35990: PUSH
35991: FOR_IN
35992: IFFALSE 36509
// begin if GetTag ( j ) <> 0 then
35994: LD_VAR 0 3
35998: PPUSH
35999: CALL_OW 110
36003: PUSH
36004: LD_INT 0
36006: NONEQUAL
36007: IFFALSE 36011
// continue ;
36009: GO 35991
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36011: LD_VAR 0 3
36015: PPUSH
36016: CALL_OW 256
36020: PUSH
36021: LD_INT 1000
36023: LESS
36024: PUSH
36025: LD_VAR 0 3
36029: PPUSH
36030: LD_EXP 118
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PPUSH
36041: CALL_OW 308
36045: NOT
36046: AND
36047: IFFALSE 36069
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36049: LD_VAR 0 3
36053: PPUSH
36054: LD_EXP 118
36058: PUSH
36059: LD_VAR 0 2
36063: ARRAY
36064: PPUSH
36065: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36069: LD_VAR 0 3
36073: PPUSH
36074: CALL_OW 256
36078: PUSH
36079: LD_INT 1000
36081: LESS
36082: PUSH
36083: LD_VAR 0 3
36087: PPUSH
36088: LD_EXP 118
36092: PUSH
36093: LD_VAR 0 2
36097: ARRAY
36098: PPUSH
36099: CALL_OW 308
36103: AND
36104: IFFALSE 36108
// continue ;
36106: GO 35991
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36108: LD_VAR 0 3
36112: PPUSH
36113: CALL_OW 262
36117: PUSH
36118: LD_INT 2
36120: EQUAL
36121: PUSH
36122: LD_VAR 0 3
36126: PPUSH
36127: CALL_OW 261
36131: PUSH
36132: LD_INT 15
36134: LESS
36135: AND
36136: IFFALSE 36140
// continue ;
36138: GO 35991
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36140: LD_VAR 0 3
36144: PPUSH
36145: CALL_OW 262
36149: PUSH
36150: LD_INT 1
36152: EQUAL
36153: PUSH
36154: LD_VAR 0 3
36158: PPUSH
36159: CALL_OW 261
36163: PUSH
36164: LD_INT 10
36166: LESS
36167: AND
36168: IFFALSE 36448
// begin if not depot then
36170: LD_VAR 0 9
36174: NOT
36175: IFFALSE 36179
// continue ;
36177: GO 35991
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36179: LD_VAR 0 3
36183: PPUSH
36184: LD_VAR 0 9
36188: PPUSH
36189: LD_VAR 0 3
36193: PPUSH
36194: CALL_OW 74
36198: PPUSH
36199: CALL_OW 296
36203: PUSH
36204: LD_INT 6
36206: LESS
36207: IFFALSE 36223
// SetFuel ( j , 100 ) else
36209: LD_VAR 0 3
36213: PPUSH
36214: LD_INT 100
36216: PPUSH
36217: CALL_OW 240
36221: GO 36448
// if GetFuel ( j ) = 0 then
36223: LD_VAR 0 3
36227: PPUSH
36228: CALL_OW 261
36232: PUSH
36233: LD_INT 0
36235: EQUAL
36236: IFFALSE 36448
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36238: LD_ADDR_EXP 113
36242: PUSH
36243: LD_EXP 113
36247: PPUSH
36248: LD_VAR 0 2
36252: PPUSH
36253: LD_EXP 113
36257: PUSH
36258: LD_VAR 0 2
36262: ARRAY
36263: PUSH
36264: LD_VAR 0 3
36268: DIFF
36269: PPUSH
36270: CALL_OW 1
36274: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36275: LD_VAR 0 3
36279: PPUSH
36280: CALL_OW 263
36284: PUSH
36285: LD_INT 1
36287: EQUAL
36288: IFFALSE 36304
// ComExitVehicle ( IsInUnit ( j ) ) ;
36290: LD_VAR 0 3
36294: PPUSH
36295: CALL_OW 310
36299: PPUSH
36300: CALL_OW 121
// if GetControl ( j ) = control_remote then
36304: LD_VAR 0 3
36308: PPUSH
36309: CALL_OW 263
36313: PUSH
36314: LD_INT 2
36316: EQUAL
36317: IFFALSE 36328
// ComUnlink ( j ) ;
36319: LD_VAR 0 3
36323: PPUSH
36324: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36328: LD_ADDR_VAR 0 10
36332: PUSH
36333: LD_VAR 0 2
36337: PPUSH
36338: LD_INT 3
36340: PPUSH
36341: CALL 46087 0 2
36345: ST_TO_ADDR
// if fac then
36346: LD_VAR 0 10
36350: IFFALSE 36446
// begin for k in fac do
36352: LD_ADDR_VAR 0 4
36356: PUSH
36357: LD_VAR 0 10
36361: PUSH
36362: FOR_IN
36363: IFFALSE 36444
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36365: LD_ADDR_VAR 0 11
36369: PUSH
36370: LD_VAR 0 10
36374: PPUSH
36375: LD_VAR 0 3
36379: PPUSH
36380: CALL_OW 265
36384: PPUSH
36385: LD_VAR 0 3
36389: PPUSH
36390: CALL_OW 262
36394: PPUSH
36395: LD_VAR 0 3
36399: PPUSH
36400: CALL_OW 263
36404: PPUSH
36405: LD_VAR 0 3
36409: PPUSH
36410: CALL_OW 264
36414: PPUSH
36415: CALL 54673 0 5
36419: ST_TO_ADDR
// if components then
36420: LD_VAR 0 11
36424: IFFALSE 36442
// begin MC_InsertProduceList ( i , components ) ;
36426: LD_VAR 0 2
36430: PPUSH
36431: LD_VAR 0 11
36435: PPUSH
36436: CALL 45632 0 2
// break ;
36440: GO 36444
// end ; end ;
36442: GO 36362
36444: POP
36445: POP
// end ; continue ;
36446: GO 35991
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36448: LD_VAR 0 3
36452: PPUSH
36453: LD_INT 1
36455: PPUSH
36456: CALL_OW 289
36460: PUSH
36461: LD_INT 100
36463: LESS
36464: PUSH
36465: LD_VAR 0 3
36469: PPUSH
36470: CALL_OW 314
36474: NOT
36475: AND
36476: IFFALSE 36505
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36478: LD_VAR 0 3
36482: PPUSH
36483: LD_VAR 0 7
36487: PUSH
36488: LD_INT 2
36490: ARRAY
36491: PPUSH
36492: LD_VAR 0 7
36496: PUSH
36497: LD_INT 3
36499: ARRAY
36500: PPUSH
36501: CALL_OW 117
// break ;
36505: GO 36509
// end ;
36507: GO 35991
36509: POP
36510: POP
// end ; end ;
36511: GO 34707
36513: POP
36514: POP
// end ;
36515: LD_VAR 0 1
36519: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36520: LD_INT 0
36522: PPUSH
36523: PPUSH
36524: PPUSH
36525: PPUSH
// if not mc_bases then
36526: LD_EXP 94
36530: NOT
36531: IFFALSE 36535
// exit ;
36533: GO 36696
// for i = 1 to mc_bases do
36535: LD_ADDR_VAR 0 2
36539: PUSH
36540: DOUBLE
36541: LD_INT 1
36543: DEC
36544: ST_TO_ADDR
36545: LD_EXP 94
36549: PUSH
36550: FOR_TO
36551: IFFALSE 36694
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36553: LD_ADDR_VAR 0 4
36557: PUSH
36558: LD_EXP 113
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PUSH
36569: LD_EXP 116
36573: PUSH
36574: LD_VAR 0 2
36578: ARRAY
36579: UNION
36580: PPUSH
36581: LD_INT 33
36583: PUSH
36584: LD_INT 2
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PPUSH
36591: CALL_OW 72
36595: ST_TO_ADDR
// if tmp then
36596: LD_VAR 0 4
36600: IFFALSE 36692
// for j in tmp do
36602: LD_ADDR_VAR 0 3
36606: PUSH
36607: LD_VAR 0 4
36611: PUSH
36612: FOR_IN
36613: IFFALSE 36690
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36615: LD_VAR 0 3
36619: PPUSH
36620: CALL_OW 312
36624: NOT
36625: PUSH
36626: LD_VAR 0 3
36630: PPUSH
36631: CALL_OW 256
36635: PUSH
36636: LD_INT 250
36638: GREATEREQUAL
36639: AND
36640: IFFALSE 36653
// Connect ( j ) else
36642: LD_VAR 0 3
36646: PPUSH
36647: CALL 60148 0 1
36651: GO 36688
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36653: LD_VAR 0 3
36657: PPUSH
36658: CALL_OW 256
36662: PUSH
36663: LD_INT 250
36665: LESS
36666: PUSH
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 312
36676: AND
36677: IFFALSE 36688
// ComUnlink ( j ) ;
36679: LD_VAR 0 3
36683: PPUSH
36684: CALL_OW 136
36688: GO 36612
36690: POP
36691: POP
// end ;
36692: GO 36550
36694: POP
36695: POP
// end ;
36696: LD_VAR 0 1
36700: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36701: LD_INT 0
36703: PPUSH
36704: PPUSH
36705: PPUSH
36706: PPUSH
36707: PPUSH
// if not mc_bases then
36708: LD_EXP 94
36712: NOT
36713: IFFALSE 36717
// exit ;
36715: GO 37162
// for i = 1 to mc_bases do
36717: LD_ADDR_VAR 0 2
36721: PUSH
36722: DOUBLE
36723: LD_INT 1
36725: DEC
36726: ST_TO_ADDR
36727: LD_EXP 94
36731: PUSH
36732: FOR_TO
36733: IFFALSE 37160
// begin if not mc_produce [ i ] then
36735: LD_EXP 115
36739: PUSH
36740: LD_VAR 0 2
36744: ARRAY
36745: NOT
36746: IFFALSE 36750
// continue ;
36748: GO 36732
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36750: LD_ADDR_VAR 0 5
36754: PUSH
36755: LD_EXP 94
36759: PUSH
36760: LD_VAR 0 2
36764: ARRAY
36765: PPUSH
36766: LD_INT 30
36768: PUSH
36769: LD_INT 3
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PPUSH
36776: CALL_OW 72
36780: ST_TO_ADDR
// if not fac then
36781: LD_VAR 0 5
36785: NOT
36786: IFFALSE 36790
// continue ;
36788: GO 36732
// for j in fac do
36790: LD_ADDR_VAR 0 3
36794: PUSH
36795: LD_VAR 0 5
36799: PUSH
36800: FOR_IN
36801: IFFALSE 37156
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36803: LD_VAR 0 3
36807: PPUSH
36808: CALL_OW 461
36812: PUSH
36813: LD_INT 2
36815: NONEQUAL
36816: PUSH
36817: LD_VAR 0 3
36821: PPUSH
36822: LD_INT 15
36824: PPUSH
36825: CALL 59776 0 2
36829: PUSH
36830: LD_INT 4
36832: ARRAY
36833: OR
36834: IFFALSE 36838
// continue ;
36836: GO 36800
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36838: LD_VAR 0 3
36842: PPUSH
36843: LD_EXP 115
36847: PUSH
36848: LD_VAR 0 2
36852: ARRAY
36853: PUSH
36854: LD_INT 1
36856: ARRAY
36857: PUSH
36858: LD_INT 1
36860: ARRAY
36861: PPUSH
36862: LD_EXP 115
36866: PUSH
36867: LD_VAR 0 2
36871: ARRAY
36872: PUSH
36873: LD_INT 1
36875: ARRAY
36876: PUSH
36877: LD_INT 2
36879: ARRAY
36880: PPUSH
36881: LD_EXP 115
36885: PUSH
36886: LD_VAR 0 2
36890: ARRAY
36891: PUSH
36892: LD_INT 1
36894: ARRAY
36895: PUSH
36896: LD_INT 3
36898: ARRAY
36899: PPUSH
36900: LD_EXP 115
36904: PUSH
36905: LD_VAR 0 2
36909: ARRAY
36910: PUSH
36911: LD_INT 1
36913: ARRAY
36914: PUSH
36915: LD_INT 4
36917: ARRAY
36918: PPUSH
36919: CALL_OW 448
36923: PUSH
36924: LD_VAR 0 3
36928: PPUSH
36929: LD_EXP 115
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PUSH
36940: LD_INT 1
36942: ARRAY
36943: PUSH
36944: LD_INT 1
36946: ARRAY
36947: PUSH
36948: LD_EXP 115
36952: PUSH
36953: LD_VAR 0 2
36957: ARRAY
36958: PUSH
36959: LD_INT 1
36961: ARRAY
36962: PUSH
36963: LD_INT 2
36965: ARRAY
36966: PUSH
36967: LD_EXP 115
36971: PUSH
36972: LD_VAR 0 2
36976: ARRAY
36977: PUSH
36978: LD_INT 1
36980: ARRAY
36981: PUSH
36982: LD_INT 3
36984: ARRAY
36985: PUSH
36986: LD_EXP 115
36990: PUSH
36991: LD_VAR 0 2
36995: ARRAY
36996: PUSH
36997: LD_INT 1
36999: ARRAY
37000: PUSH
37001: LD_INT 4
37003: ARRAY
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: PPUSH
37011: CALL 63543 0 2
37015: AND
37016: IFFALSE 37154
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37018: LD_VAR 0 3
37022: PPUSH
37023: LD_EXP 115
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PUSH
37034: LD_INT 1
37036: ARRAY
37037: PUSH
37038: LD_INT 1
37040: ARRAY
37041: PPUSH
37042: LD_EXP 115
37046: PUSH
37047: LD_VAR 0 2
37051: ARRAY
37052: PUSH
37053: LD_INT 1
37055: ARRAY
37056: PUSH
37057: LD_INT 2
37059: ARRAY
37060: PPUSH
37061: LD_EXP 115
37065: PUSH
37066: LD_VAR 0 2
37070: ARRAY
37071: PUSH
37072: LD_INT 1
37074: ARRAY
37075: PUSH
37076: LD_INT 3
37078: ARRAY
37079: PPUSH
37080: LD_EXP 115
37084: PUSH
37085: LD_VAR 0 2
37089: ARRAY
37090: PUSH
37091: LD_INT 1
37093: ARRAY
37094: PUSH
37095: LD_INT 4
37097: ARRAY
37098: PPUSH
37099: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37103: LD_ADDR_VAR 0 4
37107: PUSH
37108: LD_EXP 115
37112: PUSH
37113: LD_VAR 0 2
37117: ARRAY
37118: PPUSH
37119: LD_INT 1
37121: PPUSH
37122: CALL_OW 3
37126: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37127: LD_ADDR_EXP 115
37131: PUSH
37132: LD_EXP 115
37136: PPUSH
37137: LD_VAR 0 2
37141: PPUSH
37142: LD_VAR 0 4
37146: PPUSH
37147: CALL_OW 1
37151: ST_TO_ADDR
// break ;
37152: GO 37156
// end ; end ;
37154: GO 36800
37156: POP
37157: POP
// end ;
37158: GO 36732
37160: POP
37161: POP
// end ;
37162: LD_VAR 0 1
37166: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37167: LD_INT 0
37169: PPUSH
37170: PPUSH
37171: PPUSH
// if not mc_bases then
37172: LD_EXP 94
37176: NOT
37177: IFFALSE 37181
// exit ;
37179: GO 37270
// for i = 1 to mc_bases do
37181: LD_ADDR_VAR 0 2
37185: PUSH
37186: DOUBLE
37187: LD_INT 1
37189: DEC
37190: ST_TO_ADDR
37191: LD_EXP 94
37195: PUSH
37196: FOR_TO
37197: IFFALSE 37268
// begin if mc_attack [ i ] then
37199: LD_EXP 114
37203: PUSH
37204: LD_VAR 0 2
37208: ARRAY
37209: IFFALSE 37266
// begin tmp := mc_attack [ i ] [ 1 ] ;
37211: LD_ADDR_VAR 0 3
37215: PUSH
37216: LD_EXP 114
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: PUSH
37227: LD_INT 1
37229: ARRAY
37230: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37231: LD_ADDR_EXP 114
37235: PUSH
37236: LD_EXP 114
37240: PPUSH
37241: LD_VAR 0 2
37245: PPUSH
37246: EMPTY
37247: PPUSH
37248: CALL_OW 1
37252: ST_TO_ADDR
// Attack ( tmp ) ;
37253: LD_VAR 0 3
37257: PPUSH
37258: CALL 113216 0 1
// exit ;
37262: POP
37263: POP
37264: GO 37270
// end ; end ;
37266: GO 37196
37268: POP
37269: POP
// end ;
37270: LD_VAR 0 1
37274: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37275: LD_INT 0
37277: PPUSH
37278: PPUSH
37279: PPUSH
37280: PPUSH
37281: PPUSH
37282: PPUSH
37283: PPUSH
// if not mc_bases then
37284: LD_EXP 94
37288: NOT
37289: IFFALSE 37293
// exit ;
37291: GO 38150
// for i = 1 to mc_bases do
37293: LD_ADDR_VAR 0 2
37297: PUSH
37298: DOUBLE
37299: LD_INT 1
37301: DEC
37302: ST_TO_ADDR
37303: LD_EXP 94
37307: PUSH
37308: FOR_TO
37309: IFFALSE 38148
// begin if not mc_bases [ i ] then
37311: LD_EXP 94
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: NOT
37322: IFFALSE 37326
// continue ;
37324: GO 37308
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37326: LD_ADDR_VAR 0 7
37330: PUSH
37331: LD_EXP 94
37335: PUSH
37336: LD_VAR 0 2
37340: ARRAY
37341: PUSH
37342: LD_INT 1
37344: ARRAY
37345: PPUSH
37346: CALL 53824 0 1
37350: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37351: LD_ADDR_EXP 117
37355: PUSH
37356: LD_EXP 117
37360: PPUSH
37361: LD_VAR 0 2
37365: PPUSH
37366: LD_EXP 94
37370: PUSH
37371: LD_VAR 0 2
37375: ARRAY
37376: PUSH
37377: LD_INT 1
37379: ARRAY
37380: PPUSH
37381: CALL_OW 255
37385: PPUSH
37386: LD_EXP 119
37390: PUSH
37391: LD_VAR 0 2
37395: ARRAY
37396: PPUSH
37397: CALL 53789 0 2
37401: PPUSH
37402: CALL_OW 1
37406: ST_TO_ADDR
// if not mc_scan [ i ] then
37407: LD_EXP 117
37411: PUSH
37412: LD_VAR 0 2
37416: ARRAY
37417: NOT
37418: IFFALSE 37596
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37420: LD_ADDR_EXP 137
37424: PUSH
37425: LD_EXP 137
37429: PPUSH
37430: LD_VAR 0 2
37434: PPUSH
37435: LD_INT 0
37437: PPUSH
37438: CALL_OW 1
37442: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37443: LD_ADDR_VAR 0 4
37447: PUSH
37448: LD_EXP 94
37452: PUSH
37453: LD_VAR 0 2
37457: ARRAY
37458: PPUSH
37459: LD_INT 2
37461: PUSH
37462: LD_INT 25
37464: PUSH
37465: LD_INT 5
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 25
37474: PUSH
37475: LD_INT 8
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 25
37484: PUSH
37485: LD_INT 9
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: LIST
37496: LIST
37497: PPUSH
37498: CALL_OW 72
37502: ST_TO_ADDR
// if not tmp then
37503: LD_VAR 0 4
37507: NOT
37508: IFFALSE 37512
// continue ;
37510: GO 37308
// for j in tmp do
37512: LD_ADDR_VAR 0 3
37516: PUSH
37517: LD_VAR 0 4
37521: PUSH
37522: FOR_IN
37523: IFFALSE 37594
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37525: LD_VAR 0 3
37529: PPUSH
37530: CALL_OW 310
37534: PPUSH
37535: CALL_OW 266
37539: PUSH
37540: LD_INT 5
37542: EQUAL
37543: PUSH
37544: LD_VAR 0 3
37548: PPUSH
37549: CALL_OW 257
37553: PUSH
37554: LD_INT 1
37556: EQUAL
37557: AND
37558: PUSH
37559: LD_VAR 0 3
37563: PPUSH
37564: CALL_OW 459
37568: NOT
37569: AND
37570: PUSH
37571: LD_VAR 0 7
37575: AND
37576: IFFALSE 37592
// ComChangeProfession ( j , class ) ;
37578: LD_VAR 0 3
37582: PPUSH
37583: LD_VAR 0 7
37587: PPUSH
37588: CALL_OW 123
37592: GO 37522
37594: POP
37595: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37596: LD_EXP 117
37600: PUSH
37601: LD_VAR 0 2
37605: ARRAY
37606: PUSH
37607: LD_EXP 137
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: NOT
37618: AND
37619: PUSH
37620: LD_EXP 116
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: NOT
37631: AND
37632: PUSH
37633: LD_EXP 94
37637: PUSH
37638: LD_VAR 0 2
37642: ARRAY
37643: PPUSH
37644: LD_INT 50
37646: PUSH
37647: EMPTY
37648: LIST
37649: PUSH
37650: LD_INT 2
37652: PUSH
37653: LD_INT 30
37655: PUSH
37656: LD_INT 32
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 30
37665: PUSH
37666: LD_INT 33
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 30
37675: PUSH
37676: LD_INT 4
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 30
37685: PUSH
37686: LD_INT 5
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PPUSH
37704: CALL_OW 72
37708: PUSH
37709: LD_INT 4
37711: LESS
37712: PUSH
37713: LD_EXP 94
37717: PUSH
37718: LD_VAR 0 2
37722: ARRAY
37723: PPUSH
37724: LD_INT 3
37726: PUSH
37727: LD_INT 24
37729: PUSH
37730: LD_INT 1000
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: LD_INT 30
37746: PUSH
37747: LD_INT 0
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 30
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: LIST
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PPUSH
37773: CALL_OW 72
37777: OR
37778: AND
37779: IFFALSE 38030
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37781: LD_ADDR_EXP 137
37785: PUSH
37786: LD_EXP 137
37790: PPUSH
37791: LD_VAR 0 2
37795: PPUSH
37796: LD_INT 1
37798: PPUSH
37799: CALL_OW 1
37803: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37804: LD_ADDR_VAR 0 4
37808: PUSH
37809: LD_EXP 94
37813: PUSH
37814: LD_VAR 0 2
37818: ARRAY
37819: PPUSH
37820: LD_INT 2
37822: PUSH
37823: LD_INT 25
37825: PUSH
37826: LD_INT 1
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 25
37835: PUSH
37836: LD_INT 5
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 25
37845: PUSH
37846: LD_INT 8
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 25
37855: PUSH
37856: LD_INT 9
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: PPUSH
37870: CALL_OW 72
37874: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37875: LD_ADDR_VAR 0 4
37879: PUSH
37880: LD_VAR 0 4
37884: PUSH
37885: LD_VAR 0 4
37889: PPUSH
37890: LD_INT 18
37892: PPUSH
37893: CALL 87013 0 2
37897: DIFF
37898: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37899: LD_VAR 0 4
37903: NOT
37904: PUSH
37905: LD_EXP 94
37909: PUSH
37910: LD_VAR 0 2
37914: ARRAY
37915: PPUSH
37916: LD_INT 2
37918: PUSH
37919: LD_INT 30
37921: PUSH
37922: LD_INT 4
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 30
37931: PUSH
37932: LD_INT 5
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: PPUSH
37944: CALL_OW 72
37948: NOT
37949: AND
37950: IFFALSE 38012
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37952: LD_ADDR_VAR 0 4
37956: PUSH
37957: LD_EXP 94
37961: PUSH
37962: LD_VAR 0 2
37966: ARRAY
37967: PPUSH
37968: LD_INT 2
37970: PUSH
37971: LD_INT 25
37973: PUSH
37974: LD_INT 2
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 25
37983: PUSH
37984: LD_INT 3
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 25
37993: PUSH
37994: LD_INT 4
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL_OW 72
38011: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38012: LD_VAR 0 2
38016: PPUSH
38017: LD_VAR 0 4
38021: PPUSH
38022: CALL 117925 0 2
// exit ;
38026: POP
38027: POP
38028: GO 38150
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38030: LD_EXP 117
38034: PUSH
38035: LD_VAR 0 2
38039: ARRAY
38040: PUSH
38041: LD_EXP 137
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: NOT
38052: AND
38053: PUSH
38054: LD_EXP 116
38058: PUSH
38059: LD_VAR 0 2
38063: ARRAY
38064: AND
38065: IFFALSE 38146
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38067: LD_ADDR_EXP 137
38071: PUSH
38072: LD_EXP 137
38076: PPUSH
38077: LD_VAR 0 2
38081: PPUSH
38082: LD_INT 1
38084: PPUSH
38085: CALL_OW 1
38089: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38090: LD_ADDR_VAR 0 4
38094: PUSH
38095: LD_EXP 116
38099: PUSH
38100: LD_VAR 0 2
38104: ARRAY
38105: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38106: LD_ADDR_EXP 116
38110: PUSH
38111: LD_EXP 116
38115: PPUSH
38116: LD_VAR 0 2
38120: PPUSH
38121: EMPTY
38122: PPUSH
38123: CALL_OW 1
38127: ST_TO_ADDR
// Defend ( i , tmp ) ;
38128: LD_VAR 0 2
38132: PPUSH
38133: LD_VAR 0 4
38137: PPUSH
38138: CALL 118521 0 2
// exit ;
38142: POP
38143: POP
38144: GO 38150
// end ; end ;
38146: GO 37308
38148: POP
38149: POP
// end ;
38150: LD_VAR 0 1
38154: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38155: LD_INT 0
38157: PPUSH
38158: PPUSH
38159: PPUSH
38160: PPUSH
38161: PPUSH
38162: PPUSH
38163: PPUSH
38164: PPUSH
38165: PPUSH
38166: PPUSH
38167: PPUSH
// if not mc_bases then
38168: LD_EXP 94
38172: NOT
38173: IFFALSE 38177
// exit ;
38175: GO 39264
// for i = 1 to mc_bases do
38177: LD_ADDR_VAR 0 2
38181: PUSH
38182: DOUBLE
38183: LD_INT 1
38185: DEC
38186: ST_TO_ADDR
38187: LD_EXP 94
38191: PUSH
38192: FOR_TO
38193: IFFALSE 39262
// begin tmp := mc_lab [ i ] ;
38195: LD_ADDR_VAR 0 6
38199: PUSH
38200: LD_EXP 127
38204: PUSH
38205: LD_VAR 0 2
38209: ARRAY
38210: ST_TO_ADDR
// if not tmp then
38211: LD_VAR 0 6
38215: NOT
38216: IFFALSE 38220
// continue ;
38218: GO 38192
// idle_lab := 0 ;
38220: LD_ADDR_VAR 0 11
38224: PUSH
38225: LD_INT 0
38227: ST_TO_ADDR
// for j in tmp do
38228: LD_ADDR_VAR 0 3
38232: PUSH
38233: LD_VAR 0 6
38237: PUSH
38238: FOR_IN
38239: IFFALSE 39258
// begin researching := false ;
38241: LD_ADDR_VAR 0 10
38245: PUSH
38246: LD_INT 0
38248: ST_TO_ADDR
// side := GetSide ( j ) ;
38249: LD_ADDR_VAR 0 4
38253: PUSH
38254: LD_VAR 0 3
38258: PPUSH
38259: CALL_OW 255
38263: ST_TO_ADDR
// if not mc_tech [ side ] then
38264: LD_EXP 121
38268: PUSH
38269: LD_VAR 0 4
38273: ARRAY
38274: NOT
38275: IFFALSE 38279
// continue ;
38277: GO 38238
// if BuildingStatus ( j ) = bs_idle then
38279: LD_VAR 0 3
38283: PPUSH
38284: CALL_OW 461
38288: PUSH
38289: LD_INT 2
38291: EQUAL
38292: IFFALSE 38480
// begin if idle_lab and UnitsInside ( j ) < 6 then
38294: LD_VAR 0 11
38298: PUSH
38299: LD_VAR 0 3
38303: PPUSH
38304: CALL_OW 313
38308: PUSH
38309: LD_INT 6
38311: LESS
38312: AND
38313: IFFALSE 38384
// begin tmp2 := UnitsInside ( idle_lab ) ;
38315: LD_ADDR_VAR 0 9
38319: PUSH
38320: LD_VAR 0 11
38324: PPUSH
38325: CALL_OW 313
38329: ST_TO_ADDR
// if tmp2 then
38330: LD_VAR 0 9
38334: IFFALSE 38376
// for x in tmp2 do
38336: LD_ADDR_VAR 0 7
38340: PUSH
38341: LD_VAR 0 9
38345: PUSH
38346: FOR_IN
38347: IFFALSE 38374
// begin ComExitBuilding ( x ) ;
38349: LD_VAR 0 7
38353: PPUSH
38354: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38358: LD_VAR 0 7
38362: PPUSH
38363: LD_VAR 0 3
38367: PPUSH
38368: CALL_OW 180
// end ;
38372: GO 38346
38374: POP
38375: POP
// idle_lab := 0 ;
38376: LD_ADDR_VAR 0 11
38380: PUSH
38381: LD_INT 0
38383: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38384: LD_ADDR_VAR 0 5
38388: PUSH
38389: LD_EXP 121
38393: PUSH
38394: LD_VAR 0 4
38398: ARRAY
38399: PUSH
38400: FOR_IN
38401: IFFALSE 38461
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38403: LD_VAR 0 3
38407: PPUSH
38408: LD_VAR 0 5
38412: PPUSH
38413: CALL_OW 430
38417: PUSH
38418: LD_VAR 0 4
38422: PPUSH
38423: LD_VAR 0 5
38427: PPUSH
38428: CALL 52894 0 2
38432: AND
38433: IFFALSE 38459
// begin researching := true ;
38435: LD_ADDR_VAR 0 10
38439: PUSH
38440: LD_INT 1
38442: ST_TO_ADDR
// ComResearch ( j , t ) ;
38443: LD_VAR 0 3
38447: PPUSH
38448: LD_VAR 0 5
38452: PPUSH
38453: CALL_OW 124
// break ;
38457: GO 38461
// end ;
38459: GO 38400
38461: POP
38462: POP
// if not researching then
38463: LD_VAR 0 10
38467: NOT
38468: IFFALSE 38480
// idle_lab := j ;
38470: LD_ADDR_VAR 0 11
38474: PUSH
38475: LD_VAR 0 3
38479: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38480: LD_VAR 0 3
38484: PPUSH
38485: CALL_OW 461
38489: PUSH
38490: LD_INT 10
38492: EQUAL
38493: IFFALSE 39081
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38495: LD_EXP 123
38499: PUSH
38500: LD_VAR 0 2
38504: ARRAY
38505: NOT
38506: PUSH
38507: LD_EXP 124
38511: PUSH
38512: LD_VAR 0 2
38516: ARRAY
38517: NOT
38518: AND
38519: PUSH
38520: LD_EXP 121
38524: PUSH
38525: LD_VAR 0 4
38529: ARRAY
38530: PUSH
38531: LD_INT 1
38533: GREATER
38534: AND
38535: IFFALSE 38666
// begin ComCancel ( j ) ;
38537: LD_VAR 0 3
38541: PPUSH
38542: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38546: LD_ADDR_EXP 121
38550: PUSH
38551: LD_EXP 121
38555: PPUSH
38556: LD_VAR 0 4
38560: PPUSH
38561: LD_EXP 121
38565: PUSH
38566: LD_VAR 0 4
38570: ARRAY
38571: PPUSH
38572: LD_EXP 121
38576: PUSH
38577: LD_VAR 0 4
38581: ARRAY
38582: PUSH
38583: LD_INT 1
38585: MINUS
38586: PPUSH
38587: LD_EXP 121
38591: PUSH
38592: LD_VAR 0 4
38596: ARRAY
38597: PPUSH
38598: LD_INT 0
38600: PPUSH
38601: CALL 56595 0 4
38605: PPUSH
38606: CALL_OW 1
38610: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38611: LD_ADDR_EXP 121
38615: PUSH
38616: LD_EXP 121
38620: PPUSH
38621: LD_VAR 0 4
38625: PPUSH
38626: LD_EXP 121
38630: PUSH
38631: LD_VAR 0 4
38635: ARRAY
38636: PPUSH
38637: LD_EXP 121
38641: PUSH
38642: LD_VAR 0 4
38646: ARRAY
38647: PPUSH
38648: LD_INT 1
38650: PPUSH
38651: LD_INT 0
38653: PPUSH
38654: CALL 56595 0 4
38658: PPUSH
38659: CALL_OW 1
38663: ST_TO_ADDR
// continue ;
38664: GO 38238
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38666: LD_EXP 123
38670: PUSH
38671: LD_VAR 0 2
38675: ARRAY
38676: PUSH
38677: LD_EXP 124
38681: PUSH
38682: LD_VAR 0 2
38686: ARRAY
38687: NOT
38688: AND
38689: IFFALSE 38816
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38691: LD_ADDR_EXP 124
38695: PUSH
38696: LD_EXP 124
38700: PPUSH
38701: LD_VAR 0 2
38705: PUSH
38706: LD_EXP 124
38710: PUSH
38711: LD_VAR 0 2
38715: ARRAY
38716: PUSH
38717: LD_INT 1
38719: PLUS
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PPUSH
38725: LD_EXP 123
38729: PUSH
38730: LD_VAR 0 2
38734: ARRAY
38735: PUSH
38736: LD_INT 1
38738: ARRAY
38739: PPUSH
38740: CALL 57177 0 3
38744: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38745: LD_EXP 123
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: PUSH
38756: LD_INT 1
38758: ARRAY
38759: PPUSH
38760: LD_INT 112
38762: PPUSH
38763: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38767: LD_ADDR_VAR 0 9
38771: PUSH
38772: LD_EXP 123
38776: PUSH
38777: LD_VAR 0 2
38781: ARRAY
38782: PPUSH
38783: LD_INT 1
38785: PPUSH
38786: CALL_OW 3
38790: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38791: LD_ADDR_EXP 123
38795: PUSH
38796: LD_EXP 123
38800: PPUSH
38801: LD_VAR 0 2
38805: PPUSH
38806: LD_VAR 0 9
38810: PPUSH
38811: CALL_OW 1
38815: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38816: LD_EXP 123
38820: PUSH
38821: LD_VAR 0 2
38825: ARRAY
38826: PUSH
38827: LD_EXP 124
38831: PUSH
38832: LD_VAR 0 2
38836: ARRAY
38837: AND
38838: PUSH
38839: LD_EXP 124
38843: PUSH
38844: LD_VAR 0 2
38848: ARRAY
38849: PUSH
38850: LD_INT 1
38852: ARRAY
38853: PPUSH
38854: CALL_OW 310
38858: NOT
38859: AND
38860: PUSH
38861: LD_VAR 0 3
38865: PPUSH
38866: CALL_OW 313
38870: PUSH
38871: LD_INT 6
38873: EQUAL
38874: AND
38875: IFFALSE 38931
// begin tmp2 := UnitsInside ( j ) ;
38877: LD_ADDR_VAR 0 9
38881: PUSH
38882: LD_VAR 0 3
38886: PPUSH
38887: CALL_OW 313
38891: ST_TO_ADDR
// if tmp2 = 6 then
38892: LD_VAR 0 9
38896: PUSH
38897: LD_INT 6
38899: EQUAL
38900: IFFALSE 38931
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38902: LD_VAR 0 9
38906: PUSH
38907: LD_INT 1
38909: ARRAY
38910: PPUSH
38911: LD_INT 112
38913: PPUSH
38914: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38918: LD_VAR 0 9
38922: PUSH
38923: LD_INT 1
38925: ARRAY
38926: PPUSH
38927: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38931: LD_EXP 124
38935: PUSH
38936: LD_VAR 0 2
38940: ARRAY
38941: PUSH
38942: LD_EXP 124
38946: PUSH
38947: LD_VAR 0 2
38951: ARRAY
38952: PUSH
38953: LD_INT 1
38955: ARRAY
38956: PPUSH
38957: CALL_OW 314
38961: NOT
38962: AND
38963: PUSH
38964: LD_EXP 124
38968: PUSH
38969: LD_VAR 0 2
38973: ARRAY
38974: PUSH
38975: LD_INT 1
38977: ARRAY
38978: PPUSH
38979: CALL_OW 310
38983: NOT
38984: AND
38985: IFFALSE 39011
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38987: LD_EXP 124
38991: PUSH
38992: LD_VAR 0 2
38996: ARRAY
38997: PUSH
38998: LD_INT 1
39000: ARRAY
39001: PPUSH
39002: LD_VAR 0 3
39006: PPUSH
39007: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39011: LD_EXP 124
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PUSH
39022: LD_INT 1
39024: ARRAY
39025: PPUSH
39026: CALL_OW 310
39030: PUSH
39031: LD_EXP 124
39035: PUSH
39036: LD_VAR 0 2
39040: ARRAY
39041: PUSH
39042: LD_INT 1
39044: ARRAY
39045: PPUSH
39046: CALL_OW 310
39050: PPUSH
39051: CALL_OW 461
39055: PUSH
39056: LD_INT 3
39058: NONEQUAL
39059: AND
39060: IFFALSE 39081
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39062: LD_EXP 124
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_INT 1
39075: ARRAY
39076: PPUSH
39077: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39081: LD_VAR 0 3
39085: PPUSH
39086: CALL_OW 461
39090: PUSH
39091: LD_INT 6
39093: EQUAL
39094: PUSH
39095: LD_VAR 0 6
39099: PUSH
39100: LD_INT 1
39102: GREATER
39103: AND
39104: IFFALSE 39256
// begin sci := [ ] ;
39106: LD_ADDR_VAR 0 8
39110: PUSH
39111: EMPTY
39112: ST_TO_ADDR
// for x in ( tmp diff j ) do
39113: LD_ADDR_VAR 0 7
39117: PUSH
39118: LD_VAR 0 6
39122: PUSH
39123: LD_VAR 0 3
39127: DIFF
39128: PUSH
39129: FOR_IN
39130: IFFALSE 39182
// begin if sci = 6 then
39132: LD_VAR 0 8
39136: PUSH
39137: LD_INT 6
39139: EQUAL
39140: IFFALSE 39144
// break ;
39142: GO 39182
// if BuildingStatus ( x ) = bs_idle then
39144: LD_VAR 0 7
39148: PPUSH
39149: CALL_OW 461
39153: PUSH
39154: LD_INT 2
39156: EQUAL
39157: IFFALSE 39180
// sci := sci ^ UnitsInside ( x ) ;
39159: LD_ADDR_VAR 0 8
39163: PUSH
39164: LD_VAR 0 8
39168: PUSH
39169: LD_VAR 0 7
39173: PPUSH
39174: CALL_OW 313
39178: ADD
39179: ST_TO_ADDR
// end ;
39180: GO 39129
39182: POP
39183: POP
// if not sci then
39184: LD_VAR 0 8
39188: NOT
39189: IFFALSE 39193
// continue ;
39191: GO 38238
// for x in sci do
39193: LD_ADDR_VAR 0 7
39197: PUSH
39198: LD_VAR 0 8
39202: PUSH
39203: FOR_IN
39204: IFFALSE 39254
// if IsInUnit ( x ) and not HasTask ( x ) then
39206: LD_VAR 0 7
39210: PPUSH
39211: CALL_OW 310
39215: PUSH
39216: LD_VAR 0 7
39220: PPUSH
39221: CALL_OW 314
39225: NOT
39226: AND
39227: IFFALSE 39252
// begin ComExitBuilding ( x ) ;
39229: LD_VAR 0 7
39233: PPUSH
39234: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39238: LD_VAR 0 7
39242: PPUSH
39243: LD_VAR 0 3
39247: PPUSH
39248: CALL_OW 180
// end ;
39252: GO 39203
39254: POP
39255: POP
// end ; end ;
39256: GO 38238
39258: POP
39259: POP
// end ;
39260: GO 38192
39262: POP
39263: POP
// end ;
39264: LD_VAR 0 1
39268: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39269: LD_INT 0
39271: PPUSH
39272: PPUSH
// if not mc_bases then
39273: LD_EXP 94
39277: NOT
39278: IFFALSE 39282
// exit ;
39280: GO 39363
// for i = 1 to mc_bases do
39282: LD_ADDR_VAR 0 2
39286: PUSH
39287: DOUBLE
39288: LD_INT 1
39290: DEC
39291: ST_TO_ADDR
39292: LD_EXP 94
39296: PUSH
39297: FOR_TO
39298: IFFALSE 39361
// if mc_mines [ i ] and mc_miners [ i ] then
39300: LD_EXP 107
39304: PUSH
39305: LD_VAR 0 2
39309: ARRAY
39310: PUSH
39311: LD_EXP 108
39315: PUSH
39316: LD_VAR 0 2
39320: ARRAY
39321: AND
39322: IFFALSE 39359
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39324: LD_EXP 108
39328: PUSH
39329: LD_VAR 0 2
39333: ARRAY
39334: PUSH
39335: LD_INT 1
39337: ARRAY
39338: PPUSH
39339: CALL_OW 255
39343: PPUSH
39344: LD_EXP 107
39348: PUSH
39349: LD_VAR 0 2
39353: ARRAY
39354: PPUSH
39355: CALL 53977 0 2
39359: GO 39297
39361: POP
39362: POP
// end ;
39363: LD_VAR 0 1
39367: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39368: LD_INT 0
39370: PPUSH
39371: PPUSH
39372: PPUSH
39373: PPUSH
39374: PPUSH
39375: PPUSH
39376: PPUSH
39377: PPUSH
// if not mc_bases or not mc_parking then
39378: LD_EXP 94
39382: NOT
39383: PUSH
39384: LD_EXP 118
39388: NOT
39389: OR
39390: IFFALSE 39394
// exit ;
39392: GO 40104
// for i = 1 to mc_bases do
39394: LD_ADDR_VAR 0 2
39398: PUSH
39399: DOUBLE
39400: LD_INT 1
39402: DEC
39403: ST_TO_ADDR
39404: LD_EXP 94
39408: PUSH
39409: FOR_TO
39410: IFFALSE 40102
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39412: LD_EXP 94
39416: PUSH
39417: LD_VAR 0 2
39421: ARRAY
39422: NOT
39423: PUSH
39424: LD_EXP 118
39428: PUSH
39429: LD_VAR 0 2
39433: ARRAY
39434: NOT
39435: OR
39436: IFFALSE 39440
// continue ;
39438: GO 39409
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39440: LD_ADDR_VAR 0 5
39444: PUSH
39445: LD_EXP 94
39449: PUSH
39450: LD_VAR 0 2
39454: ARRAY
39455: PUSH
39456: LD_INT 1
39458: ARRAY
39459: PPUSH
39460: CALL_OW 255
39464: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39465: LD_ADDR_VAR 0 6
39469: PUSH
39470: LD_EXP 94
39474: PUSH
39475: LD_VAR 0 2
39479: ARRAY
39480: PPUSH
39481: LD_INT 30
39483: PUSH
39484: LD_INT 3
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PPUSH
39491: CALL_OW 72
39495: ST_TO_ADDR
// if not fac then
39496: LD_VAR 0 6
39500: NOT
39501: IFFALSE 39552
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39503: LD_ADDR_VAR 0 6
39507: PUSH
39508: LD_EXP 94
39512: PUSH
39513: LD_VAR 0 2
39517: ARRAY
39518: PPUSH
39519: LD_INT 2
39521: PUSH
39522: LD_INT 30
39524: PUSH
39525: LD_INT 0
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 30
39534: PUSH
39535: LD_INT 1
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: LIST
39546: PPUSH
39547: CALL_OW 72
39551: ST_TO_ADDR
// if not fac then
39552: LD_VAR 0 6
39556: NOT
39557: IFFALSE 39561
// continue ;
39559: GO 39409
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39561: LD_ADDR_VAR 0 7
39565: PUSH
39566: LD_EXP 118
39570: PUSH
39571: LD_VAR 0 2
39575: ARRAY
39576: PPUSH
39577: LD_INT 22
39579: PUSH
39580: LD_VAR 0 5
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 21
39591: PUSH
39592: LD_INT 2
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 3
39601: PUSH
39602: LD_INT 24
39604: PUSH
39605: LD_INT 1000
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: LIST
39620: PPUSH
39621: CALL_OW 70
39625: ST_TO_ADDR
// for j in fac do
39626: LD_ADDR_VAR 0 3
39630: PUSH
39631: LD_VAR 0 6
39635: PUSH
39636: FOR_IN
39637: IFFALSE 39718
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39639: LD_ADDR_VAR 0 7
39643: PUSH
39644: LD_VAR 0 7
39648: PUSH
39649: LD_INT 22
39651: PUSH
39652: LD_VAR 0 5
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 91
39663: PUSH
39664: LD_VAR 0 3
39668: PUSH
39669: LD_INT 15
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 21
39679: PUSH
39680: LD_INT 2
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 3
39689: PUSH
39690: LD_INT 24
39692: PUSH
39693: LD_INT 1000
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: PPUSH
39710: CALL_OW 69
39714: UNION
39715: ST_TO_ADDR
39716: GO 39636
39718: POP
39719: POP
// if not vehs then
39720: LD_VAR 0 7
39724: NOT
39725: IFFALSE 39751
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39727: LD_ADDR_EXP 106
39731: PUSH
39732: LD_EXP 106
39736: PPUSH
39737: LD_VAR 0 2
39741: PPUSH
39742: EMPTY
39743: PPUSH
39744: CALL_OW 1
39748: ST_TO_ADDR
// continue ;
39749: GO 39409
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39751: LD_ADDR_VAR 0 8
39755: PUSH
39756: LD_EXP 94
39760: PUSH
39761: LD_VAR 0 2
39765: ARRAY
39766: PPUSH
39767: LD_INT 30
39769: PUSH
39770: LD_INT 3
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PPUSH
39777: CALL_OW 72
39781: ST_TO_ADDR
// if tmp then
39782: LD_VAR 0 8
39786: IFFALSE 39889
// begin for j in tmp do
39788: LD_ADDR_VAR 0 3
39792: PUSH
39793: LD_VAR 0 8
39797: PUSH
39798: FOR_IN
39799: IFFALSE 39887
// for k in UnitsInside ( j ) do
39801: LD_ADDR_VAR 0 4
39805: PUSH
39806: LD_VAR 0 3
39810: PPUSH
39811: CALL_OW 313
39815: PUSH
39816: FOR_IN
39817: IFFALSE 39883
// if k then
39819: LD_VAR 0 4
39823: IFFALSE 39881
// if not k in mc_repair_vehicle [ i ] then
39825: LD_VAR 0 4
39829: PUSH
39830: LD_EXP 106
39834: PUSH
39835: LD_VAR 0 2
39839: ARRAY
39840: IN
39841: NOT
39842: IFFALSE 39881
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39844: LD_ADDR_EXP 106
39848: PUSH
39849: LD_EXP 106
39853: PPUSH
39854: LD_VAR 0 2
39858: PPUSH
39859: LD_EXP 106
39863: PUSH
39864: LD_VAR 0 2
39868: ARRAY
39869: PUSH
39870: LD_VAR 0 4
39874: UNION
39875: PPUSH
39876: CALL_OW 1
39880: ST_TO_ADDR
39881: GO 39816
39883: POP
39884: POP
39885: GO 39798
39887: POP
39888: POP
// end ; if not mc_repair_vehicle [ i ] then
39889: LD_EXP 106
39893: PUSH
39894: LD_VAR 0 2
39898: ARRAY
39899: NOT
39900: IFFALSE 39904
// continue ;
39902: GO 39409
// for j in mc_repair_vehicle [ i ] do
39904: LD_ADDR_VAR 0 3
39908: PUSH
39909: LD_EXP 106
39913: PUSH
39914: LD_VAR 0 2
39918: ARRAY
39919: PUSH
39920: FOR_IN
39921: IFFALSE 40098
// begin if GetClass ( j ) <> 3 then
39923: LD_VAR 0 3
39927: PPUSH
39928: CALL_OW 257
39932: PUSH
39933: LD_INT 3
39935: NONEQUAL
39936: IFFALSE 39977
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39938: LD_ADDR_EXP 106
39942: PUSH
39943: LD_EXP 106
39947: PPUSH
39948: LD_VAR 0 2
39952: PPUSH
39953: LD_EXP 106
39957: PUSH
39958: LD_VAR 0 2
39962: ARRAY
39963: PUSH
39964: LD_VAR 0 3
39968: DIFF
39969: PPUSH
39970: CALL_OW 1
39974: ST_TO_ADDR
// continue ;
39975: GO 39920
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39977: LD_VAR 0 3
39981: PPUSH
39982: CALL_OW 311
39986: NOT
39987: PUSH
39988: LD_VAR 0 3
39992: PUSH
39993: LD_EXP 97
39997: PUSH
39998: LD_VAR 0 2
40002: ARRAY
40003: PUSH
40004: LD_INT 1
40006: ARRAY
40007: IN
40008: NOT
40009: AND
40010: PUSH
40011: LD_VAR 0 3
40015: PUSH
40016: LD_EXP 97
40020: PUSH
40021: LD_VAR 0 2
40025: ARRAY
40026: PUSH
40027: LD_INT 2
40029: ARRAY
40030: IN
40031: NOT
40032: AND
40033: IFFALSE 40096
// begin if IsInUnit ( j ) then
40035: LD_VAR 0 3
40039: PPUSH
40040: CALL_OW 310
40044: IFFALSE 40057
// ComExitBuilding ( j ) else
40046: LD_VAR 0 3
40050: PPUSH
40051: CALL_OW 122
40055: GO 40096
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40057: LD_VAR 0 3
40061: PPUSH
40062: LD_VAR 0 7
40066: PUSH
40067: LD_INT 1
40069: ARRAY
40070: PPUSH
40071: CALL 91506 0 2
40075: NOT
40076: IFFALSE 40096
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40078: LD_VAR 0 3
40082: PPUSH
40083: LD_VAR 0 7
40087: PUSH
40088: LD_INT 1
40090: ARRAY
40091: PPUSH
40092: CALL_OW 129
// end ; end ;
40096: GO 39920
40098: POP
40099: POP
// end ;
40100: GO 39409
40102: POP
40103: POP
// end ;
40104: LD_VAR 0 1
40108: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40109: LD_INT 0
40111: PPUSH
40112: PPUSH
40113: PPUSH
40114: PPUSH
40115: PPUSH
40116: PPUSH
40117: PPUSH
40118: PPUSH
40119: PPUSH
40120: PPUSH
40121: PPUSH
// if not mc_bases then
40122: LD_EXP 94
40126: NOT
40127: IFFALSE 40131
// exit ;
40129: GO 40933
// for i = 1 to mc_bases do
40131: LD_ADDR_VAR 0 2
40135: PUSH
40136: DOUBLE
40137: LD_INT 1
40139: DEC
40140: ST_TO_ADDR
40141: LD_EXP 94
40145: PUSH
40146: FOR_TO
40147: IFFALSE 40931
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40149: LD_EXP 122
40153: PUSH
40154: LD_VAR 0 2
40158: ARRAY
40159: NOT
40160: PUSH
40161: LD_EXP 97
40165: PUSH
40166: LD_VAR 0 2
40170: ARRAY
40171: PUSH
40172: LD_INT 1
40174: ARRAY
40175: OR
40176: PUSH
40177: LD_EXP 97
40181: PUSH
40182: LD_VAR 0 2
40186: ARRAY
40187: PUSH
40188: LD_INT 2
40190: ARRAY
40191: OR
40192: PUSH
40193: LD_EXP 120
40197: PUSH
40198: LD_VAR 0 2
40202: ARRAY
40203: PPUSH
40204: LD_INT 1
40206: PPUSH
40207: CALL_OW 325
40211: NOT
40212: OR
40213: PUSH
40214: LD_EXP 117
40218: PUSH
40219: LD_VAR 0 2
40223: ARRAY
40224: OR
40225: IFFALSE 40229
// continue ;
40227: GO 40146
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40229: LD_ADDR_VAR 0 8
40233: PUSH
40234: LD_EXP 94
40238: PUSH
40239: LD_VAR 0 2
40243: ARRAY
40244: PPUSH
40245: LD_INT 25
40247: PUSH
40248: LD_INT 4
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 50
40257: PUSH
40258: EMPTY
40259: LIST
40260: PUSH
40261: LD_INT 3
40263: PUSH
40264: LD_INT 60
40266: PUSH
40267: EMPTY
40268: LIST
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: LIST
40278: PPUSH
40279: CALL_OW 72
40283: PUSH
40284: LD_EXP 98
40288: PUSH
40289: LD_VAR 0 2
40293: ARRAY
40294: DIFF
40295: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40296: LD_ADDR_VAR 0 9
40300: PUSH
40301: LD_EXP 94
40305: PUSH
40306: LD_VAR 0 2
40310: ARRAY
40311: PPUSH
40312: LD_INT 2
40314: PUSH
40315: LD_INT 30
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 30
40327: PUSH
40328: LD_INT 1
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: LIST
40339: PPUSH
40340: CALL_OW 72
40344: ST_TO_ADDR
// if not tmp or not dep then
40345: LD_VAR 0 8
40349: NOT
40350: PUSH
40351: LD_VAR 0 9
40355: NOT
40356: OR
40357: IFFALSE 40361
// continue ;
40359: GO 40146
// side := GetSide ( tmp [ 1 ] ) ;
40361: LD_ADDR_VAR 0 11
40365: PUSH
40366: LD_VAR 0 8
40370: PUSH
40371: LD_INT 1
40373: ARRAY
40374: PPUSH
40375: CALL_OW 255
40379: ST_TO_ADDR
// dep := dep [ 1 ] ;
40380: LD_ADDR_VAR 0 9
40384: PUSH
40385: LD_VAR 0 9
40389: PUSH
40390: LD_INT 1
40392: ARRAY
40393: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40394: LD_ADDR_VAR 0 7
40398: PUSH
40399: LD_EXP 122
40403: PUSH
40404: LD_VAR 0 2
40408: ARRAY
40409: PPUSH
40410: LD_INT 22
40412: PUSH
40413: LD_INT 0
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 25
40422: PUSH
40423: LD_INT 12
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PPUSH
40434: CALL_OW 70
40438: PUSH
40439: LD_INT 22
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 25
40451: PUSH
40452: LD_INT 12
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 91
40461: PUSH
40462: LD_VAR 0 9
40466: PUSH
40467: LD_INT 20
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: PPUSH
40480: CALL_OW 69
40484: UNION
40485: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40486: LD_ADDR_VAR 0 10
40490: PUSH
40491: LD_EXP 122
40495: PUSH
40496: LD_VAR 0 2
40500: ARRAY
40501: PPUSH
40502: LD_INT 81
40504: PUSH
40505: LD_VAR 0 11
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 70
40518: ST_TO_ADDR
// if not apes or danger_at_area then
40519: LD_VAR 0 7
40523: NOT
40524: PUSH
40525: LD_VAR 0 10
40529: OR
40530: IFFALSE 40580
// begin if mc_taming [ i ] then
40532: LD_EXP 125
40536: PUSH
40537: LD_VAR 0 2
40541: ARRAY
40542: IFFALSE 40578
// begin MC_Reset ( i , 121 ) ;
40544: LD_VAR 0 2
40548: PPUSH
40549: LD_INT 121
40551: PPUSH
40552: CALL 25566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40556: LD_ADDR_EXP 125
40560: PUSH
40561: LD_EXP 125
40565: PPUSH
40566: LD_VAR 0 2
40570: PPUSH
40571: EMPTY
40572: PPUSH
40573: CALL_OW 1
40577: ST_TO_ADDR
// end ; continue ;
40578: GO 40146
// end ; for j in tmp do
40580: LD_ADDR_VAR 0 3
40584: PUSH
40585: LD_VAR 0 8
40589: PUSH
40590: FOR_IN
40591: IFFALSE 40927
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40593: LD_VAR 0 3
40597: PUSH
40598: LD_EXP 125
40602: PUSH
40603: LD_VAR 0 2
40607: ARRAY
40608: IN
40609: NOT
40610: PUSH
40611: LD_EXP 125
40615: PUSH
40616: LD_VAR 0 2
40620: ARRAY
40621: PUSH
40622: LD_INT 3
40624: LESS
40625: AND
40626: IFFALSE 40684
// begin SetTag ( j , 121 ) ;
40628: LD_VAR 0 3
40632: PPUSH
40633: LD_INT 121
40635: PPUSH
40636: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40640: LD_ADDR_EXP 125
40644: PUSH
40645: LD_EXP 125
40649: PPUSH
40650: LD_VAR 0 2
40654: PUSH
40655: LD_EXP 125
40659: PUSH
40660: LD_VAR 0 2
40664: ARRAY
40665: PUSH
40666: LD_INT 1
40668: PLUS
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PPUSH
40674: LD_VAR 0 3
40678: PPUSH
40679: CALL 57177 0 3
40683: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40684: LD_VAR 0 3
40688: PUSH
40689: LD_EXP 125
40693: PUSH
40694: LD_VAR 0 2
40698: ARRAY
40699: IN
40700: IFFALSE 40925
// begin if GetClass ( j ) <> 4 then
40702: LD_VAR 0 3
40706: PPUSH
40707: CALL_OW 257
40711: PUSH
40712: LD_INT 4
40714: NONEQUAL
40715: IFFALSE 40768
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40717: LD_ADDR_EXP 125
40721: PUSH
40722: LD_EXP 125
40726: PPUSH
40727: LD_VAR 0 2
40731: PPUSH
40732: LD_EXP 125
40736: PUSH
40737: LD_VAR 0 2
40741: ARRAY
40742: PUSH
40743: LD_VAR 0 3
40747: DIFF
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40754: LD_VAR 0 3
40758: PPUSH
40759: LD_INT 0
40761: PPUSH
40762: CALL_OW 109
// continue ;
40766: GO 40590
// end ; if IsInUnit ( j ) then
40768: LD_VAR 0 3
40772: PPUSH
40773: CALL_OW 310
40777: IFFALSE 40788
// ComExitBuilding ( j ) ;
40779: LD_VAR 0 3
40783: PPUSH
40784: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40788: LD_ADDR_VAR 0 6
40792: PUSH
40793: LD_VAR 0 7
40797: PPUSH
40798: LD_VAR 0 3
40802: PPUSH
40803: CALL_OW 74
40807: ST_TO_ADDR
// if not ape then
40808: LD_VAR 0 6
40812: NOT
40813: IFFALSE 40817
// break ;
40815: GO 40927
// x := GetX ( ape ) ;
40817: LD_ADDR_VAR 0 4
40821: PUSH
40822: LD_VAR 0 6
40826: PPUSH
40827: CALL_OW 250
40831: ST_TO_ADDR
// y := GetY ( ape ) ;
40832: LD_ADDR_VAR 0 5
40836: PUSH
40837: LD_VAR 0 6
40841: PPUSH
40842: CALL_OW 251
40846: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40847: LD_VAR 0 4
40851: PPUSH
40852: LD_VAR 0 5
40856: PPUSH
40857: CALL_OW 488
40861: NOT
40862: PUSH
40863: LD_VAR 0 11
40867: PPUSH
40868: LD_VAR 0 4
40872: PPUSH
40873: LD_VAR 0 5
40877: PPUSH
40878: LD_INT 20
40880: PPUSH
40881: CALL 58073 0 4
40885: PUSH
40886: LD_INT 4
40888: ARRAY
40889: OR
40890: IFFALSE 40894
// break ;
40892: GO 40927
// if not HasTask ( j ) then
40894: LD_VAR 0 3
40898: PPUSH
40899: CALL_OW 314
40903: NOT
40904: IFFALSE 40925
// ComTameXY ( j , x , y ) ;
40906: LD_VAR 0 3
40910: PPUSH
40911: LD_VAR 0 4
40915: PPUSH
40916: LD_VAR 0 5
40920: PPUSH
40921: CALL_OW 131
// end ; end ;
40925: GO 40590
40927: POP
40928: POP
// end ;
40929: GO 40146
40931: POP
40932: POP
// end ;
40933: LD_VAR 0 1
40937: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40938: LD_INT 0
40940: PPUSH
40941: PPUSH
40942: PPUSH
40943: PPUSH
40944: PPUSH
40945: PPUSH
40946: PPUSH
40947: PPUSH
// if not mc_bases then
40948: LD_EXP 94
40952: NOT
40953: IFFALSE 40957
// exit ;
40955: GO 41583
// for i = 1 to mc_bases do
40957: LD_ADDR_VAR 0 2
40961: PUSH
40962: DOUBLE
40963: LD_INT 1
40965: DEC
40966: ST_TO_ADDR
40967: LD_EXP 94
40971: PUSH
40972: FOR_TO
40973: IFFALSE 41581
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40975: LD_EXP 123
40979: PUSH
40980: LD_VAR 0 2
40984: ARRAY
40985: NOT
40986: PUSH
40987: LD_EXP 123
40991: PUSH
40992: LD_VAR 0 2
40996: ARRAY
40997: PPUSH
40998: LD_INT 25
41000: PUSH
41001: LD_INT 12
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PPUSH
41008: CALL_OW 72
41012: NOT
41013: OR
41014: IFFALSE 41018
// continue ;
41016: GO 40972
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41018: LD_ADDR_VAR 0 5
41022: PUSH
41023: LD_EXP 123
41027: PUSH
41028: LD_VAR 0 2
41032: ARRAY
41033: PUSH
41034: LD_INT 1
41036: ARRAY
41037: PPUSH
41038: CALL_OW 255
41042: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41043: LD_VAR 0 5
41047: PPUSH
41048: LD_INT 2
41050: PPUSH
41051: CALL_OW 325
41055: IFFALSE 41308
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41057: LD_ADDR_VAR 0 4
41061: PUSH
41062: LD_EXP 123
41066: PUSH
41067: LD_VAR 0 2
41071: ARRAY
41072: PPUSH
41073: LD_INT 25
41075: PUSH
41076: LD_INT 16
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PPUSH
41083: CALL_OW 72
41087: ST_TO_ADDR
// if tmp < 6 then
41088: LD_VAR 0 4
41092: PUSH
41093: LD_INT 6
41095: LESS
41096: IFFALSE 41308
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41098: LD_ADDR_VAR 0 6
41102: PUSH
41103: LD_EXP 94
41107: PUSH
41108: LD_VAR 0 2
41112: ARRAY
41113: PPUSH
41114: LD_INT 2
41116: PUSH
41117: LD_INT 30
41119: PUSH
41120: LD_INT 0
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 30
41129: PUSH
41130: LD_INT 1
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: LIST
41141: PPUSH
41142: CALL_OW 72
41146: ST_TO_ADDR
// if depot then
41147: LD_VAR 0 6
41151: IFFALSE 41308
// begin selected := 0 ;
41153: LD_ADDR_VAR 0 7
41157: PUSH
41158: LD_INT 0
41160: ST_TO_ADDR
// for j in depot do
41161: LD_ADDR_VAR 0 3
41165: PUSH
41166: LD_VAR 0 6
41170: PUSH
41171: FOR_IN
41172: IFFALSE 41203
// begin if UnitsInside ( j ) < 6 then
41174: LD_VAR 0 3
41178: PPUSH
41179: CALL_OW 313
41183: PUSH
41184: LD_INT 6
41186: LESS
41187: IFFALSE 41201
// begin selected := j ;
41189: LD_ADDR_VAR 0 7
41193: PUSH
41194: LD_VAR 0 3
41198: ST_TO_ADDR
// break ;
41199: GO 41203
// end ; end ;
41201: GO 41171
41203: POP
41204: POP
// if selected then
41205: LD_VAR 0 7
41209: IFFALSE 41308
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41211: LD_ADDR_VAR 0 3
41215: PUSH
41216: LD_EXP 123
41220: PUSH
41221: LD_VAR 0 2
41225: ARRAY
41226: PPUSH
41227: LD_INT 25
41229: PUSH
41230: LD_INT 12
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PPUSH
41237: CALL_OW 72
41241: PUSH
41242: FOR_IN
41243: IFFALSE 41306
// if not HasTask ( j ) then
41245: LD_VAR 0 3
41249: PPUSH
41250: CALL_OW 314
41254: NOT
41255: IFFALSE 41304
// begin if not IsInUnit ( j ) then
41257: LD_VAR 0 3
41261: PPUSH
41262: CALL_OW 310
41266: NOT
41267: IFFALSE 41283
// ComEnterUnit ( j , selected ) ;
41269: LD_VAR 0 3
41273: PPUSH
41274: LD_VAR 0 7
41278: PPUSH
41279: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41283: LD_VAR 0 3
41287: PPUSH
41288: LD_INT 16
41290: PPUSH
41291: CALL_OW 183
// AddComExitBuilding ( j ) ;
41295: LD_VAR 0 3
41299: PPUSH
41300: CALL_OW 182
// end ;
41304: GO 41242
41306: POP
41307: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41308: LD_VAR 0 5
41312: PPUSH
41313: LD_INT 11
41315: PPUSH
41316: CALL_OW 325
41320: IFFALSE 41579
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41322: LD_ADDR_VAR 0 4
41326: PUSH
41327: LD_EXP 123
41331: PUSH
41332: LD_VAR 0 2
41336: ARRAY
41337: PPUSH
41338: LD_INT 25
41340: PUSH
41341: LD_INT 16
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PPUSH
41348: CALL_OW 72
41352: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41353: LD_VAR 0 4
41357: PUSH
41358: LD_INT 6
41360: GREATEREQUAL
41361: PUSH
41362: LD_VAR 0 5
41366: PPUSH
41367: LD_INT 2
41369: PPUSH
41370: CALL_OW 325
41374: NOT
41375: OR
41376: IFFALSE 41579
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41378: LD_ADDR_VAR 0 8
41382: PUSH
41383: LD_EXP 94
41387: PUSH
41388: LD_VAR 0 2
41392: ARRAY
41393: PPUSH
41394: LD_INT 2
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 4
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 5
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL_OW 72
41426: ST_TO_ADDR
// if barracks then
41427: LD_VAR 0 8
41431: IFFALSE 41579
// begin selected := 0 ;
41433: LD_ADDR_VAR 0 7
41437: PUSH
41438: LD_INT 0
41440: ST_TO_ADDR
// for j in barracks do
41441: LD_ADDR_VAR 0 3
41445: PUSH
41446: LD_VAR 0 8
41450: PUSH
41451: FOR_IN
41452: IFFALSE 41483
// begin if UnitsInside ( j ) < 6 then
41454: LD_VAR 0 3
41458: PPUSH
41459: CALL_OW 313
41463: PUSH
41464: LD_INT 6
41466: LESS
41467: IFFALSE 41481
// begin selected := j ;
41469: LD_ADDR_VAR 0 7
41473: PUSH
41474: LD_VAR 0 3
41478: ST_TO_ADDR
// break ;
41479: GO 41483
// end ; end ;
41481: GO 41451
41483: POP
41484: POP
// if selected then
41485: LD_VAR 0 7
41489: IFFALSE 41579
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41491: LD_ADDR_VAR 0 3
41495: PUSH
41496: LD_EXP 123
41500: PUSH
41501: LD_VAR 0 2
41505: ARRAY
41506: PPUSH
41507: LD_INT 25
41509: PUSH
41510: LD_INT 12
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PPUSH
41517: CALL_OW 72
41521: PUSH
41522: FOR_IN
41523: IFFALSE 41577
// if not IsInUnit ( j ) and not HasTask ( j ) then
41525: LD_VAR 0 3
41529: PPUSH
41530: CALL_OW 310
41534: NOT
41535: PUSH
41536: LD_VAR 0 3
41540: PPUSH
41541: CALL_OW 314
41545: NOT
41546: AND
41547: IFFALSE 41575
// begin ComEnterUnit ( j , selected ) ;
41549: LD_VAR 0 3
41553: PPUSH
41554: LD_VAR 0 7
41558: PPUSH
41559: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41563: LD_VAR 0 3
41567: PPUSH
41568: LD_INT 15
41570: PPUSH
41571: CALL_OW 183
// end ;
41575: GO 41522
41577: POP
41578: POP
// end ; end ; end ; end ; end ;
41579: GO 40972
41581: POP
41582: POP
// end ;
41583: LD_VAR 0 1
41587: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41588: LD_INT 0
41590: PPUSH
41591: PPUSH
41592: PPUSH
41593: PPUSH
// if not mc_bases then
41594: LD_EXP 94
41598: NOT
41599: IFFALSE 41603
// exit ;
41601: GO 41781
// for i = 1 to mc_bases do
41603: LD_ADDR_VAR 0 2
41607: PUSH
41608: DOUBLE
41609: LD_INT 1
41611: DEC
41612: ST_TO_ADDR
41613: LD_EXP 94
41617: PUSH
41618: FOR_TO
41619: IFFALSE 41779
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41621: LD_ADDR_VAR 0 4
41625: PUSH
41626: LD_EXP 94
41630: PUSH
41631: LD_VAR 0 2
41635: ARRAY
41636: PPUSH
41637: LD_INT 25
41639: PUSH
41640: LD_INT 9
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PPUSH
41647: CALL_OW 72
41651: ST_TO_ADDR
// if not tmp then
41652: LD_VAR 0 4
41656: NOT
41657: IFFALSE 41661
// continue ;
41659: GO 41618
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41661: LD_EXP 120
41665: PUSH
41666: LD_VAR 0 2
41670: ARRAY
41671: PPUSH
41672: LD_INT 29
41674: PPUSH
41675: CALL_OW 325
41679: NOT
41680: PUSH
41681: LD_EXP 120
41685: PUSH
41686: LD_VAR 0 2
41690: ARRAY
41691: PPUSH
41692: LD_INT 28
41694: PPUSH
41695: CALL_OW 325
41699: NOT
41700: AND
41701: IFFALSE 41705
// continue ;
41703: GO 41618
// for j in tmp do
41705: LD_ADDR_VAR 0 3
41709: PUSH
41710: LD_VAR 0 4
41714: PUSH
41715: FOR_IN
41716: IFFALSE 41775
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41718: LD_VAR 0 3
41722: PUSH
41723: LD_EXP 97
41727: PUSH
41728: LD_VAR 0 2
41732: ARRAY
41733: PUSH
41734: LD_INT 1
41736: ARRAY
41737: IN
41738: NOT
41739: PUSH
41740: LD_VAR 0 3
41744: PUSH
41745: LD_EXP 97
41749: PUSH
41750: LD_VAR 0 2
41754: ARRAY
41755: PUSH
41756: LD_INT 2
41758: ARRAY
41759: IN
41760: NOT
41761: AND
41762: IFFALSE 41773
// ComSpaceTimeShoot ( j ) ;
41764: LD_VAR 0 3
41768: PPUSH
41769: CALL 52985 0 1
41773: GO 41715
41775: POP
41776: POP
// end ;
41777: GO 41618
41779: POP
41780: POP
// end ;
41781: LD_VAR 0 1
41785: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41786: LD_INT 0
41788: PPUSH
41789: PPUSH
41790: PPUSH
41791: PPUSH
41792: PPUSH
41793: PPUSH
41794: PPUSH
41795: PPUSH
41796: PPUSH
// if not mc_bases then
41797: LD_EXP 94
41801: NOT
41802: IFFALSE 41806
// exit ;
41804: GO 42428
// for i = 1 to mc_bases do
41806: LD_ADDR_VAR 0 2
41810: PUSH
41811: DOUBLE
41812: LD_INT 1
41814: DEC
41815: ST_TO_ADDR
41816: LD_EXP 94
41820: PUSH
41821: FOR_TO
41822: IFFALSE 42426
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41824: LD_EXP 129
41828: PUSH
41829: LD_VAR 0 2
41833: ARRAY
41834: NOT
41835: PUSH
41836: LD_INT 38
41838: PPUSH
41839: LD_EXP 120
41843: PUSH
41844: LD_VAR 0 2
41848: ARRAY
41849: PPUSH
41850: CALL_OW 321
41854: PUSH
41855: LD_INT 2
41857: NONEQUAL
41858: OR
41859: IFFALSE 41863
// continue ;
41861: GO 41821
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41863: LD_ADDR_VAR 0 8
41867: PUSH
41868: LD_EXP 94
41872: PUSH
41873: LD_VAR 0 2
41877: ARRAY
41878: PPUSH
41879: LD_INT 30
41881: PUSH
41882: LD_INT 34
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PPUSH
41889: CALL_OW 72
41893: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41894: LD_ADDR_VAR 0 9
41898: PUSH
41899: LD_EXP 94
41903: PUSH
41904: LD_VAR 0 2
41908: ARRAY
41909: PPUSH
41910: LD_INT 25
41912: PUSH
41913: LD_INT 4
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PPUSH
41920: CALL_OW 72
41924: PPUSH
41925: LD_INT 0
41927: PPUSH
41928: CALL 87013 0 2
41932: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41933: LD_VAR 0 9
41937: NOT
41938: PUSH
41939: LD_VAR 0 8
41943: NOT
41944: OR
41945: PUSH
41946: LD_EXP 94
41950: PUSH
41951: LD_VAR 0 2
41955: ARRAY
41956: PPUSH
41957: LD_INT 124
41959: PPUSH
41960: CALL 87013 0 2
41964: OR
41965: IFFALSE 41969
// continue ;
41967: GO 41821
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41969: LD_EXP 130
41973: PUSH
41974: LD_VAR 0 2
41978: ARRAY
41979: PUSH
41980: LD_EXP 129
41984: PUSH
41985: LD_VAR 0 2
41989: ARRAY
41990: LESS
41991: PUSH
41992: LD_EXP 130
41996: PUSH
41997: LD_VAR 0 2
42001: ARRAY
42002: PUSH
42003: LD_VAR 0 8
42007: LESS
42008: AND
42009: IFFALSE 42424
// begin tmp := sci [ 1 ] ;
42011: LD_ADDR_VAR 0 7
42015: PUSH
42016: LD_VAR 0 9
42020: PUSH
42021: LD_INT 1
42023: ARRAY
42024: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42025: LD_VAR 0 7
42029: PPUSH
42030: LD_INT 124
42032: PPUSH
42033: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42037: LD_ADDR_VAR 0 3
42041: PUSH
42042: DOUBLE
42043: LD_EXP 129
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: INC
42054: ST_TO_ADDR
42055: LD_EXP 129
42059: PUSH
42060: LD_VAR 0 2
42064: ARRAY
42065: PUSH
42066: FOR_DOWNTO
42067: IFFALSE 42410
// begin if IsInUnit ( tmp ) then
42069: LD_VAR 0 7
42073: PPUSH
42074: CALL_OW 310
42078: IFFALSE 42089
// ComExitBuilding ( tmp ) ;
42080: LD_VAR 0 7
42084: PPUSH
42085: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42089: LD_INT 35
42091: PPUSH
42092: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42096: LD_VAR 0 7
42100: PPUSH
42101: CALL_OW 310
42105: NOT
42106: PUSH
42107: LD_VAR 0 7
42111: PPUSH
42112: CALL_OW 314
42116: NOT
42117: AND
42118: IFFALSE 42089
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42120: LD_ADDR_VAR 0 6
42124: PUSH
42125: LD_VAR 0 7
42129: PPUSH
42130: CALL_OW 250
42134: PUSH
42135: LD_VAR 0 7
42139: PPUSH
42140: CALL_OW 251
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42149: LD_INT 35
42151: PPUSH
42152: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42156: LD_ADDR_VAR 0 4
42160: PUSH
42161: LD_EXP 129
42165: PUSH
42166: LD_VAR 0 2
42170: ARRAY
42171: PUSH
42172: LD_VAR 0 3
42176: ARRAY
42177: PUSH
42178: LD_INT 1
42180: ARRAY
42181: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42182: LD_ADDR_VAR 0 5
42186: PUSH
42187: LD_EXP 129
42191: PUSH
42192: LD_VAR 0 2
42196: ARRAY
42197: PUSH
42198: LD_VAR 0 3
42202: ARRAY
42203: PUSH
42204: LD_INT 2
42206: ARRAY
42207: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42208: LD_VAR 0 7
42212: PPUSH
42213: LD_INT 10
42215: PPUSH
42216: CALL 59776 0 2
42220: PUSH
42221: LD_INT 4
42223: ARRAY
42224: IFFALSE 42262
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42226: LD_VAR 0 7
42230: PPUSH
42231: LD_VAR 0 6
42235: PUSH
42236: LD_INT 1
42238: ARRAY
42239: PPUSH
42240: LD_VAR 0 6
42244: PUSH
42245: LD_INT 2
42247: ARRAY
42248: PPUSH
42249: CALL_OW 111
// wait ( 0 0$10 ) ;
42253: LD_INT 350
42255: PPUSH
42256: CALL_OW 67
// end else
42260: GO 42288
// begin ComMoveXY ( tmp , x , y ) ;
42262: LD_VAR 0 7
42266: PPUSH
42267: LD_VAR 0 4
42271: PPUSH
42272: LD_VAR 0 5
42276: PPUSH
42277: CALL_OW 111
// wait ( 0 0$3 ) ;
42281: LD_INT 105
42283: PPUSH
42284: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42288: LD_VAR 0 7
42292: PPUSH
42293: LD_VAR 0 4
42297: PPUSH
42298: LD_VAR 0 5
42302: PPUSH
42303: CALL_OW 307
42307: IFFALSE 42149
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42309: LD_VAR 0 7
42313: PPUSH
42314: LD_VAR 0 4
42318: PPUSH
42319: LD_VAR 0 5
42323: PPUSH
42324: LD_VAR 0 8
42328: PUSH
42329: LD_VAR 0 3
42333: ARRAY
42334: PPUSH
42335: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42339: LD_INT 35
42341: PPUSH
42342: CALL_OW 67
// until not HasTask ( tmp ) ;
42346: LD_VAR 0 7
42350: PPUSH
42351: CALL_OW 314
42355: NOT
42356: IFFALSE 42339
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42358: LD_ADDR_EXP 130
42362: PUSH
42363: LD_EXP 130
42367: PPUSH
42368: LD_VAR 0 2
42372: PUSH
42373: LD_EXP 130
42377: PUSH
42378: LD_VAR 0 2
42382: ARRAY
42383: PUSH
42384: LD_INT 1
42386: PLUS
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PPUSH
42392: LD_VAR 0 8
42396: PUSH
42397: LD_VAR 0 3
42401: ARRAY
42402: PPUSH
42403: CALL 57177 0 3
42407: ST_TO_ADDR
// end ;
42408: GO 42066
42410: POP
42411: POP
// MC_Reset ( i , 124 ) ;
42412: LD_VAR 0 2
42416: PPUSH
42417: LD_INT 124
42419: PPUSH
42420: CALL 25566 0 2
// end ; end ;
42424: GO 41821
42426: POP
42427: POP
// end ;
42428: LD_VAR 0 1
42432: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42433: LD_INT 0
42435: PPUSH
42436: PPUSH
42437: PPUSH
// if not mc_bases then
42438: LD_EXP 94
42442: NOT
42443: IFFALSE 42447
// exit ;
42445: GO 43053
// for i = 1 to mc_bases do
42447: LD_ADDR_VAR 0 2
42451: PUSH
42452: DOUBLE
42453: LD_INT 1
42455: DEC
42456: ST_TO_ADDR
42457: LD_EXP 94
42461: PUSH
42462: FOR_TO
42463: IFFALSE 43051
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42465: LD_ADDR_VAR 0 3
42469: PUSH
42470: LD_EXP 94
42474: PUSH
42475: LD_VAR 0 2
42479: ARRAY
42480: PPUSH
42481: LD_INT 25
42483: PUSH
42484: LD_INT 4
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PPUSH
42491: CALL_OW 72
42495: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42496: LD_VAR 0 3
42500: NOT
42501: PUSH
42502: LD_EXP 131
42506: PUSH
42507: LD_VAR 0 2
42511: ARRAY
42512: NOT
42513: OR
42514: PUSH
42515: LD_EXP 94
42519: PUSH
42520: LD_VAR 0 2
42524: ARRAY
42525: PPUSH
42526: LD_INT 2
42528: PUSH
42529: LD_INT 30
42531: PUSH
42532: LD_INT 0
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 30
42541: PUSH
42542: LD_INT 1
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: LIST
42553: PPUSH
42554: CALL_OW 72
42558: NOT
42559: OR
42560: IFFALSE 42610
// begin if mc_deposits_finder [ i ] then
42562: LD_EXP 132
42566: PUSH
42567: LD_VAR 0 2
42571: ARRAY
42572: IFFALSE 42608
// begin MC_Reset ( i , 125 ) ;
42574: LD_VAR 0 2
42578: PPUSH
42579: LD_INT 125
42581: PPUSH
42582: CALL 25566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42586: LD_ADDR_EXP 132
42590: PUSH
42591: LD_EXP 132
42595: PPUSH
42596: LD_VAR 0 2
42600: PPUSH
42601: EMPTY
42602: PPUSH
42603: CALL_OW 1
42607: ST_TO_ADDR
// end ; continue ;
42608: GO 42462
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42610: LD_EXP 131
42614: PUSH
42615: LD_VAR 0 2
42619: ARRAY
42620: PUSH
42621: LD_INT 1
42623: ARRAY
42624: PUSH
42625: LD_INT 3
42627: ARRAY
42628: PUSH
42629: LD_INT 1
42631: EQUAL
42632: PUSH
42633: LD_INT 20
42635: PPUSH
42636: LD_EXP 120
42640: PUSH
42641: LD_VAR 0 2
42645: ARRAY
42646: PPUSH
42647: CALL_OW 321
42651: PUSH
42652: LD_INT 2
42654: NONEQUAL
42655: AND
42656: IFFALSE 42706
// begin if mc_deposits_finder [ i ] then
42658: LD_EXP 132
42662: PUSH
42663: LD_VAR 0 2
42667: ARRAY
42668: IFFALSE 42704
// begin MC_Reset ( i , 125 ) ;
42670: LD_VAR 0 2
42674: PPUSH
42675: LD_INT 125
42677: PPUSH
42678: CALL 25566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42682: LD_ADDR_EXP 132
42686: PUSH
42687: LD_EXP 132
42691: PPUSH
42692: LD_VAR 0 2
42696: PPUSH
42697: EMPTY
42698: PPUSH
42699: CALL_OW 1
42703: ST_TO_ADDR
// end ; continue ;
42704: GO 42462
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42706: LD_EXP 131
42710: PUSH
42711: LD_VAR 0 2
42715: ARRAY
42716: PUSH
42717: LD_INT 1
42719: ARRAY
42720: PUSH
42721: LD_INT 1
42723: ARRAY
42724: PPUSH
42725: LD_EXP 131
42729: PUSH
42730: LD_VAR 0 2
42734: ARRAY
42735: PUSH
42736: LD_INT 1
42738: ARRAY
42739: PUSH
42740: LD_INT 2
42742: ARRAY
42743: PPUSH
42744: LD_EXP 120
42748: PUSH
42749: LD_VAR 0 2
42753: ARRAY
42754: PPUSH
42755: CALL_OW 440
42759: IFFALSE 42802
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42761: LD_ADDR_EXP 131
42765: PUSH
42766: LD_EXP 131
42770: PPUSH
42771: LD_VAR 0 2
42775: PPUSH
42776: LD_EXP 131
42780: PUSH
42781: LD_VAR 0 2
42785: ARRAY
42786: PPUSH
42787: LD_INT 1
42789: PPUSH
42790: CALL_OW 3
42794: PPUSH
42795: CALL_OW 1
42799: ST_TO_ADDR
42800: GO 43049
// begin if not mc_deposits_finder [ i ] then
42802: LD_EXP 132
42806: PUSH
42807: LD_VAR 0 2
42811: ARRAY
42812: NOT
42813: IFFALSE 42865
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42815: LD_ADDR_EXP 132
42819: PUSH
42820: LD_EXP 132
42824: PPUSH
42825: LD_VAR 0 2
42829: PPUSH
42830: LD_VAR 0 3
42834: PUSH
42835: LD_INT 1
42837: ARRAY
42838: PUSH
42839: EMPTY
42840: LIST
42841: PPUSH
42842: CALL_OW 1
42846: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42847: LD_VAR 0 3
42851: PUSH
42852: LD_INT 1
42854: ARRAY
42855: PPUSH
42856: LD_INT 125
42858: PPUSH
42859: CALL_OW 109
// end else
42863: GO 43049
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42865: LD_EXP 132
42869: PUSH
42870: LD_VAR 0 2
42874: ARRAY
42875: PUSH
42876: LD_INT 1
42878: ARRAY
42879: PPUSH
42880: CALL_OW 310
42884: IFFALSE 42907
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42886: LD_EXP 132
42890: PUSH
42891: LD_VAR 0 2
42895: ARRAY
42896: PUSH
42897: LD_INT 1
42899: ARRAY
42900: PPUSH
42901: CALL_OW 122
42905: GO 43049
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42907: LD_EXP 132
42911: PUSH
42912: LD_VAR 0 2
42916: ARRAY
42917: PUSH
42918: LD_INT 1
42920: ARRAY
42921: PPUSH
42922: CALL_OW 314
42926: NOT
42927: PUSH
42928: LD_EXP 132
42932: PUSH
42933: LD_VAR 0 2
42937: ARRAY
42938: PUSH
42939: LD_INT 1
42941: ARRAY
42942: PPUSH
42943: LD_EXP 131
42947: PUSH
42948: LD_VAR 0 2
42952: ARRAY
42953: PUSH
42954: LD_INT 1
42956: ARRAY
42957: PUSH
42958: LD_INT 1
42960: ARRAY
42961: PPUSH
42962: LD_EXP 131
42966: PUSH
42967: LD_VAR 0 2
42971: ARRAY
42972: PUSH
42973: LD_INT 1
42975: ARRAY
42976: PUSH
42977: LD_INT 2
42979: ARRAY
42980: PPUSH
42981: CALL_OW 297
42985: PUSH
42986: LD_INT 6
42988: GREATER
42989: AND
42990: IFFALSE 43049
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42992: LD_EXP 132
42996: PUSH
42997: LD_VAR 0 2
43001: ARRAY
43002: PUSH
43003: LD_INT 1
43005: ARRAY
43006: PPUSH
43007: LD_EXP 131
43011: PUSH
43012: LD_VAR 0 2
43016: ARRAY
43017: PUSH
43018: LD_INT 1
43020: ARRAY
43021: PUSH
43022: LD_INT 1
43024: ARRAY
43025: PPUSH
43026: LD_EXP 131
43030: PUSH
43031: LD_VAR 0 2
43035: ARRAY
43036: PUSH
43037: LD_INT 1
43039: ARRAY
43040: PUSH
43041: LD_INT 2
43043: ARRAY
43044: PPUSH
43045: CALL_OW 111
// end ; end ; end ;
43049: GO 42462
43051: POP
43052: POP
// end ;
43053: LD_VAR 0 1
43057: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43058: LD_INT 0
43060: PPUSH
43061: PPUSH
43062: PPUSH
43063: PPUSH
43064: PPUSH
43065: PPUSH
43066: PPUSH
43067: PPUSH
43068: PPUSH
43069: PPUSH
43070: PPUSH
// if not mc_bases then
43071: LD_EXP 94
43075: NOT
43076: IFFALSE 43080
// exit ;
43078: GO 44020
// for i = 1 to mc_bases do
43080: LD_ADDR_VAR 0 2
43084: PUSH
43085: DOUBLE
43086: LD_INT 1
43088: DEC
43089: ST_TO_ADDR
43090: LD_EXP 94
43094: PUSH
43095: FOR_TO
43096: IFFALSE 44018
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43098: LD_EXP 94
43102: PUSH
43103: LD_VAR 0 2
43107: ARRAY
43108: NOT
43109: PUSH
43110: LD_EXP 117
43114: PUSH
43115: LD_VAR 0 2
43119: ARRAY
43120: OR
43121: IFFALSE 43125
// continue ;
43123: GO 43095
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43125: LD_ADDR_VAR 0 7
43129: PUSH
43130: LD_EXP 94
43134: PUSH
43135: LD_VAR 0 2
43139: ARRAY
43140: PUSH
43141: LD_INT 1
43143: ARRAY
43144: PPUSH
43145: CALL_OW 248
43149: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43150: LD_VAR 0 7
43154: PUSH
43155: LD_INT 3
43157: EQUAL
43158: PUSH
43159: LD_EXP 113
43163: PUSH
43164: LD_VAR 0 2
43168: ARRAY
43169: PUSH
43170: LD_EXP 116
43174: PUSH
43175: LD_VAR 0 2
43179: ARRAY
43180: UNION
43181: PPUSH
43182: LD_INT 33
43184: PUSH
43185: LD_INT 2
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PPUSH
43192: CALL_OW 72
43196: NOT
43197: OR
43198: IFFALSE 43202
// continue ;
43200: GO 43095
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43202: LD_ADDR_VAR 0 9
43206: PUSH
43207: LD_EXP 94
43211: PUSH
43212: LD_VAR 0 2
43216: ARRAY
43217: PPUSH
43218: LD_INT 30
43220: PUSH
43221: LD_INT 36
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PPUSH
43228: CALL_OW 72
43232: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43233: LD_ADDR_VAR 0 10
43237: PUSH
43238: LD_EXP 113
43242: PUSH
43243: LD_VAR 0 2
43247: ARRAY
43248: PPUSH
43249: LD_INT 34
43251: PUSH
43252: LD_INT 31
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PPUSH
43259: CALL_OW 72
43263: ST_TO_ADDR
// if not cts and not mcts then
43264: LD_VAR 0 9
43268: NOT
43269: PUSH
43270: LD_VAR 0 10
43274: NOT
43275: AND
43276: IFFALSE 43280
// continue ;
43278: GO 43095
// x := cts ;
43280: LD_ADDR_VAR 0 11
43284: PUSH
43285: LD_VAR 0 9
43289: ST_TO_ADDR
// if not x then
43290: LD_VAR 0 11
43294: NOT
43295: IFFALSE 43307
// x := mcts ;
43297: LD_ADDR_VAR 0 11
43301: PUSH
43302: LD_VAR 0 10
43306: ST_TO_ADDR
// if not x then
43307: LD_VAR 0 11
43311: NOT
43312: IFFALSE 43316
// continue ;
43314: GO 43095
// if mc_remote_driver [ i ] then
43316: LD_EXP 134
43320: PUSH
43321: LD_VAR 0 2
43325: ARRAY
43326: IFFALSE 43713
// for j in mc_remote_driver [ i ] do
43328: LD_ADDR_VAR 0 3
43332: PUSH
43333: LD_EXP 134
43337: PUSH
43338: LD_VAR 0 2
43342: ARRAY
43343: PUSH
43344: FOR_IN
43345: IFFALSE 43711
// begin if GetClass ( j ) <> 3 then
43347: LD_VAR 0 3
43351: PPUSH
43352: CALL_OW 257
43356: PUSH
43357: LD_INT 3
43359: NONEQUAL
43360: IFFALSE 43413
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43362: LD_ADDR_EXP 134
43366: PUSH
43367: LD_EXP 134
43371: PPUSH
43372: LD_VAR 0 2
43376: PPUSH
43377: LD_EXP 134
43381: PUSH
43382: LD_VAR 0 2
43386: ARRAY
43387: PUSH
43388: LD_VAR 0 3
43392: DIFF
43393: PPUSH
43394: CALL_OW 1
43398: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43399: LD_VAR 0 3
43403: PPUSH
43404: LD_INT 0
43406: PPUSH
43407: CALL_OW 109
// continue ;
43411: GO 43344
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43413: LD_EXP 113
43417: PUSH
43418: LD_VAR 0 2
43422: ARRAY
43423: PPUSH
43424: LD_INT 34
43426: PUSH
43427: LD_INT 31
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 58
43436: PUSH
43437: EMPTY
43438: LIST
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PPUSH
43444: CALL_OW 72
43448: PUSH
43449: LD_VAR 0 3
43453: PPUSH
43454: CALL 87048 0 1
43458: NOT
43459: AND
43460: IFFALSE 43531
// begin if IsInUnit ( j ) then
43462: LD_VAR 0 3
43466: PPUSH
43467: CALL_OW 310
43471: IFFALSE 43482
// ComExitBuilding ( j ) ;
43473: LD_VAR 0 3
43477: PPUSH
43478: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43482: LD_VAR 0 3
43486: PPUSH
43487: LD_EXP 113
43491: PUSH
43492: LD_VAR 0 2
43496: ARRAY
43497: PPUSH
43498: LD_INT 34
43500: PUSH
43501: LD_INT 31
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 58
43510: PUSH
43511: EMPTY
43512: LIST
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PPUSH
43518: CALL_OW 72
43522: PUSH
43523: LD_INT 1
43525: ARRAY
43526: PPUSH
43527: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43531: LD_VAR 0 3
43535: PPUSH
43536: CALL_OW 310
43540: NOT
43541: PUSH
43542: LD_VAR 0 3
43546: PPUSH
43547: CALL_OW 310
43551: PPUSH
43552: CALL_OW 266
43556: PUSH
43557: LD_INT 36
43559: NONEQUAL
43560: PUSH
43561: LD_VAR 0 3
43565: PPUSH
43566: CALL 87048 0 1
43570: NOT
43571: AND
43572: OR
43573: IFFALSE 43709
// begin if IsInUnit ( j ) then
43575: LD_VAR 0 3
43579: PPUSH
43580: CALL_OW 310
43584: IFFALSE 43595
// ComExitBuilding ( j ) ;
43586: LD_VAR 0 3
43590: PPUSH
43591: CALL_OW 122
// ct := 0 ;
43595: LD_ADDR_VAR 0 8
43599: PUSH
43600: LD_INT 0
43602: ST_TO_ADDR
// for k in x do
43603: LD_ADDR_VAR 0 4
43607: PUSH
43608: LD_VAR 0 11
43612: PUSH
43613: FOR_IN
43614: IFFALSE 43687
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43616: LD_VAR 0 4
43620: PPUSH
43621: CALL_OW 264
43625: PUSH
43626: LD_INT 31
43628: EQUAL
43629: PUSH
43630: LD_VAR 0 4
43634: PPUSH
43635: CALL_OW 311
43639: NOT
43640: AND
43641: PUSH
43642: LD_VAR 0 4
43646: PPUSH
43647: CALL_OW 266
43651: PUSH
43652: LD_INT 36
43654: EQUAL
43655: PUSH
43656: LD_VAR 0 4
43660: PPUSH
43661: CALL_OW 313
43665: PUSH
43666: LD_INT 3
43668: LESS
43669: AND
43670: OR
43671: IFFALSE 43685
// begin ct := k ;
43673: LD_ADDR_VAR 0 8
43677: PUSH
43678: LD_VAR 0 4
43682: ST_TO_ADDR
// break ;
43683: GO 43687
// end ;
43685: GO 43613
43687: POP
43688: POP
// if ct then
43689: LD_VAR 0 8
43693: IFFALSE 43709
// ComEnterUnit ( j , ct ) ;
43695: LD_VAR 0 3
43699: PPUSH
43700: LD_VAR 0 8
43704: PPUSH
43705: CALL_OW 120
// end ; end ;
43709: GO 43344
43711: POP
43712: POP
// places := 0 ;
43713: LD_ADDR_VAR 0 5
43717: PUSH
43718: LD_INT 0
43720: ST_TO_ADDR
// for j = 1 to x do
43721: LD_ADDR_VAR 0 3
43725: PUSH
43726: DOUBLE
43727: LD_INT 1
43729: DEC
43730: ST_TO_ADDR
43731: LD_VAR 0 11
43735: PUSH
43736: FOR_TO
43737: IFFALSE 43813
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43739: LD_VAR 0 11
43743: PUSH
43744: LD_VAR 0 3
43748: ARRAY
43749: PPUSH
43750: CALL_OW 264
43754: PUSH
43755: LD_INT 31
43757: EQUAL
43758: IFFALSE 43776
// places := places + 1 else
43760: LD_ADDR_VAR 0 5
43764: PUSH
43765: LD_VAR 0 5
43769: PUSH
43770: LD_INT 1
43772: PLUS
43773: ST_TO_ADDR
43774: GO 43811
// if GetBType ( x [ j ] ) = b_control_tower then
43776: LD_VAR 0 11
43780: PUSH
43781: LD_VAR 0 3
43785: ARRAY
43786: PPUSH
43787: CALL_OW 266
43791: PUSH
43792: LD_INT 36
43794: EQUAL
43795: IFFALSE 43811
// places := places + 3 ;
43797: LD_ADDR_VAR 0 5
43801: PUSH
43802: LD_VAR 0 5
43806: PUSH
43807: LD_INT 3
43809: PLUS
43810: ST_TO_ADDR
43811: GO 43736
43813: POP
43814: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43815: LD_VAR 0 5
43819: PUSH
43820: LD_INT 0
43822: EQUAL
43823: PUSH
43824: LD_VAR 0 5
43828: PUSH
43829: LD_EXP 134
43833: PUSH
43834: LD_VAR 0 2
43838: ARRAY
43839: LESSEQUAL
43840: OR
43841: IFFALSE 43845
// continue ;
43843: GO 43095
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43845: LD_ADDR_VAR 0 6
43849: PUSH
43850: LD_EXP 94
43854: PUSH
43855: LD_VAR 0 2
43859: ARRAY
43860: PPUSH
43861: LD_INT 25
43863: PUSH
43864: LD_INT 3
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PPUSH
43871: CALL_OW 72
43875: PUSH
43876: LD_EXP 134
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: DIFF
43887: PPUSH
43888: LD_INT 3
43890: PPUSH
43891: CALL 87948 0 2
43895: ST_TO_ADDR
// for j in tmp do
43896: LD_ADDR_VAR 0 3
43900: PUSH
43901: LD_VAR 0 6
43905: PUSH
43906: FOR_IN
43907: IFFALSE 43942
// if GetTag ( j ) > 0 then
43909: LD_VAR 0 3
43913: PPUSH
43914: CALL_OW 110
43918: PUSH
43919: LD_INT 0
43921: GREATER
43922: IFFALSE 43940
// tmp := tmp diff j ;
43924: LD_ADDR_VAR 0 6
43928: PUSH
43929: LD_VAR 0 6
43933: PUSH
43934: LD_VAR 0 3
43938: DIFF
43939: ST_TO_ADDR
43940: GO 43906
43942: POP
43943: POP
// if not tmp then
43944: LD_VAR 0 6
43948: NOT
43949: IFFALSE 43953
// continue ;
43951: GO 43095
// if places then
43953: LD_VAR 0 5
43957: IFFALSE 44016
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43959: LD_ADDR_EXP 134
43963: PUSH
43964: LD_EXP 134
43968: PPUSH
43969: LD_VAR 0 2
43973: PPUSH
43974: LD_EXP 134
43978: PUSH
43979: LD_VAR 0 2
43983: ARRAY
43984: PUSH
43985: LD_VAR 0 6
43989: PUSH
43990: LD_INT 1
43992: ARRAY
43993: UNION
43994: PPUSH
43995: CALL_OW 1
43999: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44000: LD_VAR 0 6
44004: PUSH
44005: LD_INT 1
44007: ARRAY
44008: PPUSH
44009: LD_INT 126
44011: PPUSH
44012: CALL_OW 109
// end ; end ;
44016: GO 43095
44018: POP
44019: POP
// end ;
44020: LD_VAR 0 1
44024: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44025: LD_INT 0
44027: PPUSH
44028: PPUSH
44029: PPUSH
44030: PPUSH
44031: PPUSH
44032: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44033: LD_VAR 0 1
44037: NOT
44038: PUSH
44039: LD_VAR 0 2
44043: NOT
44044: OR
44045: PUSH
44046: LD_VAR 0 3
44050: NOT
44051: OR
44052: PUSH
44053: LD_VAR 0 4
44057: PUSH
44058: LD_INT 1
44060: PUSH
44061: LD_INT 2
44063: PUSH
44064: LD_INT 3
44066: PUSH
44067: LD_INT 4
44069: PUSH
44070: LD_INT 5
44072: PUSH
44073: LD_INT 8
44075: PUSH
44076: LD_INT 9
44078: PUSH
44079: LD_INT 15
44081: PUSH
44082: LD_INT 16
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: IN
44096: NOT
44097: OR
44098: IFFALSE 44102
// exit ;
44100: GO 45002
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44102: LD_ADDR_VAR 0 2
44106: PUSH
44107: LD_VAR 0 2
44111: PPUSH
44112: LD_INT 21
44114: PUSH
44115: LD_INT 3
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 24
44124: PUSH
44125: LD_INT 250
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PPUSH
44136: CALL_OW 72
44140: ST_TO_ADDR
// case class of 1 , 15 :
44141: LD_VAR 0 4
44145: PUSH
44146: LD_INT 1
44148: DOUBLE
44149: EQUAL
44150: IFTRUE 44160
44152: LD_INT 15
44154: DOUBLE
44155: EQUAL
44156: IFTRUE 44160
44158: GO 44245
44160: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44161: LD_ADDR_VAR 0 8
44165: PUSH
44166: LD_VAR 0 2
44170: PPUSH
44171: LD_INT 2
44173: PUSH
44174: LD_INT 30
44176: PUSH
44177: LD_INT 32
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_INT 30
44186: PUSH
44187: LD_INT 31
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: PPUSH
44199: CALL_OW 72
44203: PUSH
44204: LD_VAR 0 2
44208: PPUSH
44209: LD_INT 2
44211: PUSH
44212: LD_INT 30
44214: PUSH
44215: LD_INT 4
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 30
44224: PUSH
44225: LD_INT 5
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: LIST
44236: PPUSH
44237: CALL_OW 72
44241: ADD
44242: ST_TO_ADDR
44243: GO 44491
44245: LD_INT 2
44247: DOUBLE
44248: EQUAL
44249: IFTRUE 44259
44251: LD_INT 16
44253: DOUBLE
44254: EQUAL
44255: IFTRUE 44259
44257: GO 44305
44259: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44260: LD_ADDR_VAR 0 8
44264: PUSH
44265: LD_VAR 0 2
44269: PPUSH
44270: LD_INT 2
44272: PUSH
44273: LD_INT 30
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 1
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: LIST
44297: PPUSH
44298: CALL_OW 72
44302: ST_TO_ADDR
44303: GO 44491
44305: LD_INT 3
44307: DOUBLE
44308: EQUAL
44309: IFTRUE 44313
44311: GO 44359
44313: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44314: LD_ADDR_VAR 0 8
44318: PUSH
44319: LD_VAR 0 2
44323: PPUSH
44324: LD_INT 2
44326: PUSH
44327: LD_INT 30
44329: PUSH
44330: LD_INT 2
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 30
44339: PUSH
44340: LD_INT 3
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: LIST
44351: PPUSH
44352: CALL_OW 72
44356: ST_TO_ADDR
44357: GO 44491
44359: LD_INT 4
44361: DOUBLE
44362: EQUAL
44363: IFTRUE 44367
44365: GO 44424
44367: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44368: LD_ADDR_VAR 0 8
44372: PUSH
44373: LD_VAR 0 2
44377: PPUSH
44378: LD_INT 2
44380: PUSH
44381: LD_INT 30
44383: PUSH
44384: LD_INT 6
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 30
44393: PUSH
44394: LD_INT 7
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 30
44403: PUSH
44404: LD_INT 8
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: PPUSH
44417: CALL_OW 72
44421: ST_TO_ADDR
44422: GO 44491
44424: LD_INT 5
44426: DOUBLE
44427: EQUAL
44428: IFTRUE 44444
44430: LD_INT 8
44432: DOUBLE
44433: EQUAL
44434: IFTRUE 44444
44436: LD_INT 9
44438: DOUBLE
44439: EQUAL
44440: IFTRUE 44444
44442: GO 44490
44444: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44445: LD_ADDR_VAR 0 8
44449: PUSH
44450: LD_VAR 0 2
44454: PPUSH
44455: LD_INT 2
44457: PUSH
44458: LD_INT 30
44460: PUSH
44461: LD_INT 4
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 30
44470: PUSH
44471: LD_INT 5
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: LIST
44482: PPUSH
44483: CALL_OW 72
44487: ST_TO_ADDR
44488: GO 44491
44490: POP
// if not tmp then
44491: LD_VAR 0 8
44495: NOT
44496: IFFALSE 44500
// exit ;
44498: GO 45002
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44500: LD_VAR 0 4
44504: PUSH
44505: LD_INT 1
44507: PUSH
44508: LD_INT 15
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: IN
44515: PUSH
44516: LD_EXP 103
44520: PUSH
44521: LD_VAR 0 1
44525: ARRAY
44526: AND
44527: IFFALSE 44683
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44529: LD_ADDR_VAR 0 9
44533: PUSH
44534: LD_EXP 103
44538: PUSH
44539: LD_VAR 0 1
44543: ARRAY
44544: PUSH
44545: LD_INT 1
44547: ARRAY
44548: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44549: LD_VAR 0 9
44553: PUSH
44554: LD_EXP 104
44558: PUSH
44559: LD_VAR 0 1
44563: ARRAY
44564: IN
44565: NOT
44566: IFFALSE 44681
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44568: LD_ADDR_EXP 104
44572: PUSH
44573: LD_EXP 104
44577: PPUSH
44578: LD_VAR 0 1
44582: PUSH
44583: LD_EXP 104
44587: PUSH
44588: LD_VAR 0 1
44592: ARRAY
44593: PUSH
44594: LD_INT 1
44596: PLUS
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PPUSH
44602: LD_VAR 0 9
44606: PPUSH
44607: CALL 57177 0 3
44611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44612: LD_ADDR_EXP 103
44616: PUSH
44617: LD_EXP 103
44621: PPUSH
44622: LD_VAR 0 1
44626: PPUSH
44627: LD_EXP 103
44631: PUSH
44632: LD_VAR 0 1
44636: ARRAY
44637: PUSH
44638: LD_VAR 0 9
44642: DIFF
44643: PPUSH
44644: CALL_OW 1
44648: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44649: LD_VAR 0 3
44653: PPUSH
44654: LD_EXP 104
44658: PUSH
44659: LD_VAR 0 1
44663: ARRAY
44664: PUSH
44665: LD_EXP 104
44669: PUSH
44670: LD_VAR 0 1
44674: ARRAY
44675: ARRAY
44676: PPUSH
44677: CALL_OW 120
// end ; exit ;
44681: GO 45002
// end ; if tmp > 1 then
44683: LD_VAR 0 8
44687: PUSH
44688: LD_INT 1
44690: GREATER
44691: IFFALSE 44795
// for i = 2 to tmp do
44693: LD_ADDR_VAR 0 6
44697: PUSH
44698: DOUBLE
44699: LD_INT 2
44701: DEC
44702: ST_TO_ADDR
44703: LD_VAR 0 8
44707: PUSH
44708: FOR_TO
44709: IFFALSE 44793
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44711: LD_VAR 0 8
44715: PUSH
44716: LD_VAR 0 6
44720: ARRAY
44721: PPUSH
44722: CALL_OW 461
44726: PUSH
44727: LD_INT 6
44729: EQUAL
44730: IFFALSE 44791
// begin x := tmp [ i ] ;
44732: LD_ADDR_VAR 0 9
44736: PUSH
44737: LD_VAR 0 8
44741: PUSH
44742: LD_VAR 0 6
44746: ARRAY
44747: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44748: LD_ADDR_VAR 0 8
44752: PUSH
44753: LD_VAR 0 8
44757: PPUSH
44758: LD_VAR 0 6
44762: PPUSH
44763: CALL_OW 3
44767: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44768: LD_ADDR_VAR 0 8
44772: PUSH
44773: LD_VAR 0 8
44777: PPUSH
44778: LD_INT 1
44780: PPUSH
44781: LD_VAR 0 9
44785: PPUSH
44786: CALL_OW 2
44790: ST_TO_ADDR
// end ;
44791: GO 44708
44793: POP
44794: POP
// for i in tmp do
44795: LD_ADDR_VAR 0 6
44799: PUSH
44800: LD_VAR 0 8
44804: PUSH
44805: FOR_IN
44806: IFFALSE 44875
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44808: LD_VAR 0 6
44812: PPUSH
44813: CALL_OW 313
44817: PUSH
44818: LD_INT 6
44820: LESS
44821: PUSH
44822: LD_VAR 0 6
44826: PPUSH
44827: CALL_OW 266
44831: PUSH
44832: LD_INT 31
44834: PUSH
44835: LD_INT 32
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: IN
44842: NOT
44843: AND
44844: PUSH
44845: LD_VAR 0 6
44849: PPUSH
44850: CALL_OW 313
44854: PUSH
44855: LD_INT 0
44857: EQUAL
44858: OR
44859: IFFALSE 44873
// begin j := i ;
44861: LD_ADDR_VAR 0 7
44865: PUSH
44866: LD_VAR 0 6
44870: ST_TO_ADDR
// break ;
44871: GO 44875
// end ; end ;
44873: GO 44805
44875: POP
44876: POP
// if j then
44877: LD_VAR 0 7
44881: IFFALSE 44899
// ComEnterUnit ( unit , j ) else
44883: LD_VAR 0 3
44887: PPUSH
44888: LD_VAR 0 7
44892: PPUSH
44893: CALL_OW 120
44897: GO 45002
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44899: LD_ADDR_VAR 0 10
44903: PUSH
44904: LD_VAR 0 2
44908: PPUSH
44909: LD_INT 2
44911: PUSH
44912: LD_INT 30
44914: PUSH
44915: LD_INT 0
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 30
44924: PUSH
44925: LD_INT 1
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: LIST
44936: PPUSH
44937: CALL_OW 72
44941: ST_TO_ADDR
// if depot then
44942: LD_VAR 0 10
44946: IFFALSE 45002
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44948: LD_ADDR_VAR 0 10
44952: PUSH
44953: LD_VAR 0 10
44957: PPUSH
44958: LD_VAR 0 3
44962: PPUSH
44963: CALL_OW 74
44967: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44968: LD_VAR 0 3
44972: PPUSH
44973: LD_VAR 0 10
44977: PPUSH
44978: CALL_OW 296
44982: PUSH
44983: LD_INT 10
44985: GREATER
44986: IFFALSE 45002
// ComStandNearbyBuilding ( unit , depot ) ;
44988: LD_VAR 0 3
44992: PPUSH
44993: LD_VAR 0 10
44997: PPUSH
44998: CALL 53602 0 2
// end ; end ; end ;
45002: LD_VAR 0 5
45006: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45007: LD_INT 0
45009: PPUSH
45010: PPUSH
45011: PPUSH
45012: PPUSH
// if not mc_bases then
45013: LD_EXP 94
45017: NOT
45018: IFFALSE 45022
// exit ;
45020: GO 45261
// for i = 1 to mc_bases do
45022: LD_ADDR_VAR 0 2
45026: PUSH
45027: DOUBLE
45028: LD_INT 1
45030: DEC
45031: ST_TO_ADDR
45032: LD_EXP 94
45036: PUSH
45037: FOR_TO
45038: IFFALSE 45259
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45040: LD_ADDR_VAR 0 4
45044: PUSH
45045: LD_EXP 94
45049: PUSH
45050: LD_VAR 0 2
45054: ARRAY
45055: PPUSH
45056: LD_INT 21
45058: PUSH
45059: LD_INT 1
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PPUSH
45066: CALL_OW 72
45070: PUSH
45071: LD_EXP 123
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: UNION
45082: ST_TO_ADDR
// if not tmp then
45083: LD_VAR 0 4
45087: NOT
45088: IFFALSE 45092
// continue ;
45090: GO 45037
// for j in tmp do
45092: LD_ADDR_VAR 0 3
45096: PUSH
45097: LD_VAR 0 4
45101: PUSH
45102: FOR_IN
45103: IFFALSE 45255
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45105: LD_VAR 0 3
45109: PPUSH
45110: CALL_OW 110
45114: NOT
45115: PUSH
45116: LD_VAR 0 3
45120: PPUSH
45121: CALL_OW 314
45125: NOT
45126: AND
45127: PUSH
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 311
45137: NOT
45138: AND
45139: PUSH
45140: LD_VAR 0 3
45144: PPUSH
45145: CALL_OW 310
45149: NOT
45150: AND
45151: PUSH
45152: LD_VAR 0 3
45156: PUSH
45157: LD_EXP 97
45161: PUSH
45162: LD_VAR 0 2
45166: ARRAY
45167: PUSH
45168: LD_INT 1
45170: ARRAY
45171: IN
45172: NOT
45173: AND
45174: PUSH
45175: LD_VAR 0 3
45179: PUSH
45180: LD_EXP 97
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: PUSH
45191: LD_INT 2
45193: ARRAY
45194: IN
45195: NOT
45196: AND
45197: PUSH
45198: LD_VAR 0 3
45202: PUSH
45203: LD_EXP 106
45207: PUSH
45208: LD_VAR 0 2
45212: ARRAY
45213: IN
45214: NOT
45215: AND
45216: IFFALSE 45253
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45218: LD_VAR 0 2
45222: PPUSH
45223: LD_EXP 94
45227: PUSH
45228: LD_VAR 0 2
45232: ARRAY
45233: PPUSH
45234: LD_VAR 0 3
45238: PPUSH
45239: LD_VAR 0 3
45243: PPUSH
45244: CALL_OW 257
45248: PPUSH
45249: CALL 44025 0 4
// end ;
45253: GO 45102
45255: POP
45256: POP
// end ;
45257: GO 45037
45259: POP
45260: POP
// end ;
45261: LD_VAR 0 1
45265: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45266: LD_INT 0
45268: PPUSH
45269: PPUSH
45270: PPUSH
45271: PPUSH
45272: PPUSH
45273: PPUSH
// if not mc_bases [ base ] then
45274: LD_EXP 94
45278: PUSH
45279: LD_VAR 0 1
45283: ARRAY
45284: NOT
45285: IFFALSE 45289
// exit ;
45287: GO 45471
// tmp := [ ] ;
45289: LD_ADDR_VAR 0 6
45293: PUSH
45294: EMPTY
45295: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45296: LD_ADDR_VAR 0 7
45300: PUSH
45301: LD_VAR 0 3
45305: PPUSH
45306: LD_INT 0
45308: PPUSH
45309: CALL_OW 517
45313: ST_TO_ADDR
// if not list then
45314: LD_VAR 0 7
45318: NOT
45319: IFFALSE 45323
// exit ;
45321: GO 45471
// for i = 1 to amount do
45323: LD_ADDR_VAR 0 5
45327: PUSH
45328: DOUBLE
45329: LD_INT 1
45331: DEC
45332: ST_TO_ADDR
45333: LD_VAR 0 2
45337: PUSH
45338: FOR_TO
45339: IFFALSE 45419
// begin x := rand ( 1 , list [ 1 ] ) ;
45341: LD_ADDR_VAR 0 8
45345: PUSH
45346: LD_INT 1
45348: PPUSH
45349: LD_VAR 0 7
45353: PUSH
45354: LD_INT 1
45356: ARRAY
45357: PPUSH
45358: CALL_OW 12
45362: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45363: LD_ADDR_VAR 0 6
45367: PUSH
45368: LD_VAR 0 6
45372: PPUSH
45373: LD_VAR 0 5
45377: PPUSH
45378: LD_VAR 0 7
45382: PUSH
45383: LD_INT 1
45385: ARRAY
45386: PUSH
45387: LD_VAR 0 8
45391: ARRAY
45392: PUSH
45393: LD_VAR 0 7
45397: PUSH
45398: LD_INT 2
45400: ARRAY
45401: PUSH
45402: LD_VAR 0 8
45406: ARRAY
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PPUSH
45412: CALL_OW 1
45416: ST_TO_ADDR
// end ;
45417: GO 45338
45419: POP
45420: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45421: LD_ADDR_EXP 107
45425: PUSH
45426: LD_EXP 107
45430: PPUSH
45431: LD_VAR 0 1
45435: PPUSH
45436: LD_VAR 0 6
45440: PPUSH
45441: CALL_OW 1
45445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45446: LD_ADDR_EXP 109
45450: PUSH
45451: LD_EXP 109
45455: PPUSH
45456: LD_VAR 0 1
45460: PPUSH
45461: LD_VAR 0 3
45465: PPUSH
45466: CALL_OW 1
45470: ST_TO_ADDR
// end ;
45471: LD_VAR 0 4
45475: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45476: LD_INT 0
45478: PPUSH
// if not mc_bases [ base ] then
45479: LD_EXP 94
45483: PUSH
45484: LD_VAR 0 1
45488: ARRAY
45489: NOT
45490: IFFALSE 45494
// exit ;
45492: GO 45519
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45494: LD_ADDR_EXP 99
45498: PUSH
45499: LD_EXP 99
45503: PPUSH
45504: LD_VAR 0 1
45508: PPUSH
45509: LD_VAR 0 2
45513: PPUSH
45514: CALL_OW 1
45518: ST_TO_ADDR
// end ;
45519: LD_VAR 0 3
45523: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45524: LD_INT 0
45526: PPUSH
// if not mc_bases [ base ] then
45527: LD_EXP 94
45531: PUSH
45532: LD_VAR 0 1
45536: ARRAY
45537: NOT
45538: IFFALSE 45542
// exit ;
45540: GO 45579
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45542: LD_ADDR_EXP 99
45546: PUSH
45547: LD_EXP 99
45551: PPUSH
45552: LD_VAR 0 1
45556: PPUSH
45557: LD_EXP 99
45561: PUSH
45562: LD_VAR 0 1
45566: ARRAY
45567: PUSH
45568: LD_VAR 0 2
45572: UNION
45573: PPUSH
45574: CALL_OW 1
45578: ST_TO_ADDR
// end ;
45579: LD_VAR 0 3
45583: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45584: LD_INT 0
45586: PPUSH
// if not mc_bases [ base ] then
45587: LD_EXP 94
45591: PUSH
45592: LD_VAR 0 1
45596: ARRAY
45597: NOT
45598: IFFALSE 45602
// exit ;
45600: GO 45627
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45602: LD_ADDR_EXP 115
45606: PUSH
45607: LD_EXP 115
45611: PPUSH
45612: LD_VAR 0 1
45616: PPUSH
45617: LD_VAR 0 2
45621: PPUSH
45622: CALL_OW 1
45626: ST_TO_ADDR
// end ;
45627: LD_VAR 0 3
45631: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45632: LD_INT 0
45634: PPUSH
// if not mc_bases [ base ] then
45635: LD_EXP 94
45639: PUSH
45640: LD_VAR 0 1
45644: ARRAY
45645: NOT
45646: IFFALSE 45650
// exit ;
45648: GO 45687
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45650: LD_ADDR_EXP 115
45654: PUSH
45655: LD_EXP 115
45659: PPUSH
45660: LD_VAR 0 1
45664: PPUSH
45665: LD_EXP 115
45669: PUSH
45670: LD_VAR 0 1
45674: ARRAY
45675: PUSH
45676: LD_VAR 0 2
45680: ADD
45681: PPUSH
45682: CALL_OW 1
45686: ST_TO_ADDR
// end ;
45687: LD_VAR 0 3
45691: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45692: LD_INT 0
45694: PPUSH
// if not mc_bases [ base ] then
45695: LD_EXP 94
45699: PUSH
45700: LD_VAR 0 1
45704: ARRAY
45705: NOT
45706: IFFALSE 45710
// exit ;
45708: GO 45764
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45710: LD_ADDR_EXP 116
45714: PUSH
45715: LD_EXP 116
45719: PPUSH
45720: LD_VAR 0 1
45724: PPUSH
45725: LD_VAR 0 2
45729: PPUSH
45730: CALL_OW 1
45734: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45735: LD_ADDR_EXP 105
45739: PUSH
45740: LD_EXP 105
45744: PPUSH
45745: LD_VAR 0 1
45749: PPUSH
45750: LD_VAR 0 2
45754: PUSH
45755: LD_INT 0
45757: PLUS
45758: PPUSH
45759: CALL_OW 1
45763: ST_TO_ADDR
// end ;
45764: LD_VAR 0 3
45768: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45769: LD_INT 0
45771: PPUSH
// if not mc_bases [ base ] then
45772: LD_EXP 94
45776: PUSH
45777: LD_VAR 0 1
45781: ARRAY
45782: NOT
45783: IFFALSE 45787
// exit ;
45785: GO 45812
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45787: LD_ADDR_EXP 105
45791: PUSH
45792: LD_EXP 105
45796: PPUSH
45797: LD_VAR 0 1
45801: PPUSH
45802: LD_VAR 0 2
45806: PPUSH
45807: CALL_OW 1
45811: ST_TO_ADDR
// end ;
45812: LD_VAR 0 3
45816: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45817: LD_INT 0
45819: PPUSH
45820: PPUSH
45821: PPUSH
45822: PPUSH
// if not mc_bases [ base ] then
45823: LD_EXP 94
45827: PUSH
45828: LD_VAR 0 1
45832: ARRAY
45833: NOT
45834: IFFALSE 45838
// exit ;
45836: GO 45903
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45838: LD_ADDR_EXP 114
45842: PUSH
45843: LD_EXP 114
45847: PPUSH
45848: LD_VAR 0 1
45852: PUSH
45853: LD_EXP 114
45857: PUSH
45858: LD_VAR 0 1
45862: ARRAY
45863: PUSH
45864: LD_INT 1
45866: PLUS
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PPUSH
45872: LD_VAR 0 1
45876: PUSH
45877: LD_VAR 0 2
45881: PUSH
45882: LD_VAR 0 3
45886: PUSH
45887: LD_VAR 0 4
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: PPUSH
45898: CALL 57177 0 3
45902: ST_TO_ADDR
// end ;
45903: LD_VAR 0 5
45907: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45908: LD_INT 0
45910: PPUSH
// if not mc_bases [ base ] then
45911: LD_EXP 94
45915: PUSH
45916: LD_VAR 0 1
45920: ARRAY
45921: NOT
45922: IFFALSE 45926
// exit ;
45924: GO 45951
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45926: LD_ADDR_EXP 131
45930: PUSH
45931: LD_EXP 131
45935: PPUSH
45936: LD_VAR 0 1
45940: PPUSH
45941: LD_VAR 0 2
45945: PPUSH
45946: CALL_OW 1
45950: ST_TO_ADDR
// end ;
45951: LD_VAR 0 3
45955: RET
// export function MC_GetMinesField ( base ) ; begin
45956: LD_INT 0
45958: PPUSH
// result := mc_mines [ base ] ;
45959: LD_ADDR_VAR 0 2
45963: PUSH
45964: LD_EXP 107
45968: PUSH
45969: LD_VAR 0 1
45973: ARRAY
45974: ST_TO_ADDR
// end ;
45975: LD_VAR 0 2
45979: RET
// export function MC_GetProduceList ( base ) ; begin
45980: LD_INT 0
45982: PPUSH
// result := mc_produce [ base ] ;
45983: LD_ADDR_VAR 0 2
45987: PUSH
45988: LD_EXP 115
45992: PUSH
45993: LD_VAR 0 1
45997: ARRAY
45998: ST_TO_ADDR
// end ;
45999: LD_VAR 0 2
46003: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46004: LD_INT 0
46006: PPUSH
46007: PPUSH
// if not mc_bases then
46008: LD_EXP 94
46012: NOT
46013: IFFALSE 46017
// exit ;
46015: GO 46082
// if mc_bases [ base ] then
46017: LD_EXP 94
46021: PUSH
46022: LD_VAR 0 1
46026: ARRAY
46027: IFFALSE 46082
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46029: LD_ADDR_VAR 0 3
46033: PUSH
46034: LD_EXP 94
46038: PUSH
46039: LD_VAR 0 1
46043: ARRAY
46044: PPUSH
46045: LD_INT 30
46047: PUSH
46048: LD_VAR 0 2
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PPUSH
46057: CALL_OW 72
46061: ST_TO_ADDR
// if result then
46062: LD_VAR 0 3
46066: IFFALSE 46082
// result := result [ 1 ] ;
46068: LD_ADDR_VAR 0 3
46072: PUSH
46073: LD_VAR 0 3
46077: PUSH
46078: LD_INT 1
46080: ARRAY
46081: ST_TO_ADDR
// end ; end ;
46082: LD_VAR 0 3
46086: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46087: LD_INT 0
46089: PPUSH
46090: PPUSH
// if not mc_bases then
46091: LD_EXP 94
46095: NOT
46096: IFFALSE 46100
// exit ;
46098: GO 46145
// if mc_bases [ base ] then
46100: LD_EXP 94
46104: PUSH
46105: LD_VAR 0 1
46109: ARRAY
46110: IFFALSE 46145
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46112: LD_ADDR_VAR 0 3
46116: PUSH
46117: LD_EXP 94
46121: PUSH
46122: LD_VAR 0 1
46126: ARRAY
46127: PPUSH
46128: LD_INT 30
46130: PUSH
46131: LD_VAR 0 2
46135: PUSH
46136: EMPTY
46137: LIST
46138: LIST
46139: PPUSH
46140: CALL_OW 72
46144: ST_TO_ADDR
// end ;
46145: LD_VAR 0 3
46149: RET
// export function MC_SetTame ( base , area ) ; begin
46150: LD_INT 0
46152: PPUSH
// if not mc_bases or not base then
46153: LD_EXP 94
46157: NOT
46158: PUSH
46159: LD_VAR 0 1
46163: NOT
46164: OR
46165: IFFALSE 46169
// exit ;
46167: GO 46194
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46169: LD_ADDR_EXP 122
46173: PUSH
46174: LD_EXP 122
46178: PPUSH
46179: LD_VAR 0 1
46183: PPUSH
46184: LD_VAR 0 2
46188: PPUSH
46189: CALL_OW 1
46193: ST_TO_ADDR
// end ;
46194: LD_VAR 0 3
46198: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46199: LD_INT 0
46201: PPUSH
46202: PPUSH
// if not mc_bases or not base then
46203: LD_EXP 94
46207: NOT
46208: PUSH
46209: LD_VAR 0 1
46213: NOT
46214: OR
46215: IFFALSE 46219
// exit ;
46217: GO 46321
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46219: LD_ADDR_VAR 0 4
46223: PUSH
46224: LD_EXP 94
46228: PUSH
46229: LD_VAR 0 1
46233: ARRAY
46234: PPUSH
46235: LD_INT 30
46237: PUSH
46238: LD_VAR 0 2
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PPUSH
46247: CALL_OW 72
46251: ST_TO_ADDR
// if not tmp then
46252: LD_VAR 0 4
46256: NOT
46257: IFFALSE 46261
// exit ;
46259: GO 46321
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46261: LD_ADDR_EXP 126
46265: PUSH
46266: LD_EXP 126
46270: PPUSH
46271: LD_VAR 0 1
46275: PPUSH
46276: LD_EXP 126
46280: PUSH
46281: LD_VAR 0 1
46285: ARRAY
46286: PPUSH
46287: LD_EXP 126
46291: PUSH
46292: LD_VAR 0 1
46296: ARRAY
46297: PUSH
46298: LD_INT 1
46300: PLUS
46301: PPUSH
46302: LD_VAR 0 4
46306: PUSH
46307: LD_INT 1
46309: ARRAY
46310: PPUSH
46311: CALL_OW 2
46315: PPUSH
46316: CALL_OW 1
46320: ST_TO_ADDR
// end ;
46321: LD_VAR 0 3
46325: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46326: LD_INT 0
46328: PPUSH
46329: PPUSH
// if not mc_bases or not base or not kinds then
46330: LD_EXP 94
46334: NOT
46335: PUSH
46336: LD_VAR 0 1
46340: NOT
46341: OR
46342: PUSH
46343: LD_VAR 0 2
46347: NOT
46348: OR
46349: IFFALSE 46353
// exit ;
46351: GO 46414
// for i in kinds do
46353: LD_ADDR_VAR 0 4
46357: PUSH
46358: LD_VAR 0 2
46362: PUSH
46363: FOR_IN
46364: IFFALSE 46412
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46366: LD_ADDR_EXP 128
46370: PUSH
46371: LD_EXP 128
46375: PPUSH
46376: LD_VAR 0 1
46380: PUSH
46381: LD_EXP 128
46385: PUSH
46386: LD_VAR 0 1
46390: ARRAY
46391: PUSH
46392: LD_INT 1
46394: PLUS
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PPUSH
46400: LD_VAR 0 4
46404: PPUSH
46405: CALL 57177 0 3
46409: ST_TO_ADDR
46410: GO 46363
46412: POP
46413: POP
// end ;
46414: LD_VAR 0 3
46418: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46419: LD_INT 0
46421: PPUSH
// if not mc_bases or not base or not areas then
46422: LD_EXP 94
46426: NOT
46427: PUSH
46428: LD_VAR 0 1
46432: NOT
46433: OR
46434: PUSH
46435: LD_VAR 0 2
46439: NOT
46440: OR
46441: IFFALSE 46445
// exit ;
46443: GO 46470
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46445: LD_ADDR_EXP 112
46449: PUSH
46450: LD_EXP 112
46454: PPUSH
46455: LD_VAR 0 1
46459: PPUSH
46460: LD_VAR 0 2
46464: PPUSH
46465: CALL_OW 1
46469: ST_TO_ADDR
// end ;
46470: LD_VAR 0 3
46474: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46475: LD_INT 0
46477: PPUSH
// if not mc_bases or not base or not teleports_exit then
46478: LD_EXP 94
46482: NOT
46483: PUSH
46484: LD_VAR 0 1
46488: NOT
46489: OR
46490: PUSH
46491: LD_VAR 0 2
46495: NOT
46496: OR
46497: IFFALSE 46501
// exit ;
46499: GO 46526
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46501: LD_ADDR_EXP 129
46505: PUSH
46506: LD_EXP 129
46510: PPUSH
46511: LD_VAR 0 1
46515: PPUSH
46516: LD_VAR 0 2
46520: PPUSH
46521: CALL_OW 1
46525: ST_TO_ADDR
// end ;
46526: LD_VAR 0 3
46530: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46531: LD_INT 0
46533: PPUSH
46534: PPUSH
46535: PPUSH
// if not mc_bases or not base or not ext_list then
46536: LD_EXP 94
46540: NOT
46541: PUSH
46542: LD_VAR 0 1
46546: NOT
46547: OR
46548: PUSH
46549: LD_VAR 0 5
46553: NOT
46554: OR
46555: IFFALSE 46559
// exit ;
46557: GO 46732
// tmp := GetFacExtXYD ( x , y , d ) ;
46559: LD_ADDR_VAR 0 8
46563: PUSH
46564: LD_VAR 0 2
46568: PPUSH
46569: LD_VAR 0 3
46573: PPUSH
46574: LD_VAR 0 4
46578: PPUSH
46579: CALL 87078 0 3
46583: ST_TO_ADDR
// if not tmp then
46584: LD_VAR 0 8
46588: NOT
46589: IFFALSE 46593
// exit ;
46591: GO 46732
// for i in tmp do
46593: LD_ADDR_VAR 0 7
46597: PUSH
46598: LD_VAR 0 8
46602: PUSH
46603: FOR_IN
46604: IFFALSE 46730
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46606: LD_ADDR_EXP 99
46610: PUSH
46611: LD_EXP 99
46615: PPUSH
46616: LD_VAR 0 1
46620: PPUSH
46621: LD_EXP 99
46625: PUSH
46626: LD_VAR 0 1
46630: ARRAY
46631: PPUSH
46632: LD_EXP 99
46636: PUSH
46637: LD_VAR 0 1
46641: ARRAY
46642: PUSH
46643: LD_INT 1
46645: PLUS
46646: PPUSH
46647: LD_VAR 0 5
46651: PUSH
46652: LD_INT 1
46654: ARRAY
46655: PUSH
46656: LD_VAR 0 7
46660: PUSH
46661: LD_INT 1
46663: ARRAY
46664: PUSH
46665: LD_VAR 0 7
46669: PUSH
46670: LD_INT 2
46672: ARRAY
46673: PUSH
46674: LD_VAR 0 7
46678: PUSH
46679: LD_INT 3
46681: ARRAY
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: PPUSH
46689: CALL_OW 2
46693: PPUSH
46694: CALL_OW 1
46698: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46699: LD_ADDR_VAR 0 5
46703: PUSH
46704: LD_VAR 0 5
46708: PPUSH
46709: LD_INT 1
46711: PPUSH
46712: CALL_OW 3
46716: ST_TO_ADDR
// if not ext_list then
46717: LD_VAR 0 5
46721: NOT
46722: IFFALSE 46728
// exit ;
46724: POP
46725: POP
46726: GO 46732
// end ;
46728: GO 46603
46730: POP
46731: POP
// end ;
46732: LD_VAR 0 6
46736: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46737: LD_INT 0
46739: PPUSH
// if not mc_bases or not base or not weapon_list then
46740: LD_EXP 94
46744: NOT
46745: PUSH
46746: LD_VAR 0 1
46750: NOT
46751: OR
46752: PUSH
46753: LD_VAR 0 2
46757: NOT
46758: OR
46759: IFFALSE 46763
// exit ;
46761: GO 46788
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46763: LD_ADDR_EXP 133
46767: PUSH
46768: LD_EXP 133
46772: PPUSH
46773: LD_VAR 0 1
46777: PPUSH
46778: LD_VAR 0 2
46782: PPUSH
46783: CALL_OW 1
46787: ST_TO_ADDR
// end ;
46788: LD_VAR 0 3
46792: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46793: LD_INT 0
46795: PPUSH
// if not mc_bases or not base or not tech_list then
46796: LD_EXP 94
46800: NOT
46801: PUSH
46802: LD_VAR 0 1
46806: NOT
46807: OR
46808: PUSH
46809: LD_VAR 0 2
46813: NOT
46814: OR
46815: IFFALSE 46819
// exit ;
46817: GO 46844
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46819: LD_ADDR_EXP 121
46823: PUSH
46824: LD_EXP 121
46828: PPUSH
46829: LD_VAR 0 1
46833: PPUSH
46834: LD_VAR 0 2
46838: PPUSH
46839: CALL_OW 1
46843: ST_TO_ADDR
// end ;
46844: LD_VAR 0 3
46848: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46849: LD_INT 0
46851: PPUSH
// if not mc_bases or not parking_area or not base then
46852: LD_EXP 94
46856: NOT
46857: PUSH
46858: LD_VAR 0 2
46862: NOT
46863: OR
46864: PUSH
46865: LD_VAR 0 1
46869: NOT
46870: OR
46871: IFFALSE 46875
// exit ;
46873: GO 46900
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46875: LD_ADDR_EXP 118
46879: PUSH
46880: LD_EXP 118
46884: PPUSH
46885: LD_VAR 0 1
46889: PPUSH
46890: LD_VAR 0 2
46894: PPUSH
46895: CALL_OW 1
46899: ST_TO_ADDR
// end ;
46900: LD_VAR 0 3
46904: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46905: LD_INT 0
46907: PPUSH
// if not mc_bases or not base or not scan_area then
46908: LD_EXP 94
46912: NOT
46913: PUSH
46914: LD_VAR 0 1
46918: NOT
46919: OR
46920: PUSH
46921: LD_VAR 0 2
46925: NOT
46926: OR
46927: IFFALSE 46931
// exit ;
46929: GO 46956
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46931: LD_ADDR_EXP 119
46935: PUSH
46936: LD_EXP 119
46940: PPUSH
46941: LD_VAR 0 1
46945: PPUSH
46946: LD_VAR 0 2
46950: PPUSH
46951: CALL_OW 1
46955: ST_TO_ADDR
// end ;
46956: LD_VAR 0 3
46960: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46961: LD_INT 0
46963: PPUSH
46964: PPUSH
// if not mc_bases or not base then
46965: LD_EXP 94
46969: NOT
46970: PUSH
46971: LD_VAR 0 1
46975: NOT
46976: OR
46977: IFFALSE 46981
// exit ;
46979: GO 47045
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46981: LD_ADDR_VAR 0 3
46985: PUSH
46986: LD_INT 1
46988: PUSH
46989: LD_INT 2
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: LD_INT 4
46997: PUSH
46998: LD_INT 11
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47008: LD_ADDR_EXP 121
47012: PUSH
47013: LD_EXP 121
47017: PPUSH
47018: LD_VAR 0 1
47022: PPUSH
47023: LD_EXP 121
47027: PUSH
47028: LD_VAR 0 1
47032: ARRAY
47033: PUSH
47034: LD_VAR 0 3
47038: DIFF
47039: PPUSH
47040: CALL_OW 1
47044: ST_TO_ADDR
// end ;
47045: LD_VAR 0 2
47049: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47050: LD_INT 0
47052: PPUSH
// result := mc_vehicles [ base ] ;
47053: LD_ADDR_VAR 0 3
47057: PUSH
47058: LD_EXP 113
47062: PUSH
47063: LD_VAR 0 1
47067: ARRAY
47068: ST_TO_ADDR
// if onlyCombat then
47069: LD_VAR 0 2
47073: IFFALSE 47251
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47075: LD_ADDR_VAR 0 3
47079: PUSH
47080: LD_VAR 0 3
47084: PUSH
47085: LD_VAR 0 3
47089: PPUSH
47090: LD_INT 2
47092: PUSH
47093: LD_INT 34
47095: PUSH
47096: LD_INT 12
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 34
47105: PUSH
47106: LD_INT 51
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 34
47115: PUSH
47116: LD_EXP 75
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 34
47127: PUSH
47128: LD_INT 32
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 34
47137: PUSH
47138: LD_INT 13
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 34
47147: PUSH
47148: LD_INT 52
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 34
47157: PUSH
47158: LD_EXP 80
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 34
47169: PUSH
47170: LD_INT 14
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 34
47179: PUSH
47180: LD_INT 53
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PUSH
47187: LD_INT 34
47189: PUSH
47190: LD_EXP 74
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 34
47201: PUSH
47202: LD_INT 31
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 34
47211: PUSH
47212: LD_INT 48
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: LD_INT 34
47221: PUSH
47222: LD_INT 8
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: LIST
47243: LIST
47244: PPUSH
47245: CALL_OW 72
47249: DIFF
47250: ST_TO_ADDR
// end ; end_of_file
47251: LD_VAR 0 3
47255: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47256: LD_INT 0
47258: PPUSH
47259: PPUSH
47260: PPUSH
// if not mc_bases or not skirmish then
47261: LD_EXP 94
47265: NOT
47266: PUSH
47267: LD_EXP 92
47271: NOT
47272: OR
47273: IFFALSE 47277
// exit ;
47275: GO 47442
// for i = 1 to mc_bases do
47277: LD_ADDR_VAR 0 4
47281: PUSH
47282: DOUBLE
47283: LD_INT 1
47285: DEC
47286: ST_TO_ADDR
47287: LD_EXP 94
47291: PUSH
47292: FOR_TO
47293: IFFALSE 47440
// begin if sci in mc_bases [ i ] then
47295: LD_VAR 0 2
47299: PUSH
47300: LD_EXP 94
47304: PUSH
47305: LD_VAR 0 4
47309: ARRAY
47310: IN
47311: IFFALSE 47438
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47313: LD_ADDR_EXP 123
47317: PUSH
47318: LD_EXP 123
47322: PPUSH
47323: LD_VAR 0 4
47327: PUSH
47328: LD_EXP 123
47332: PUSH
47333: LD_VAR 0 4
47337: ARRAY
47338: PUSH
47339: LD_INT 1
47341: PLUS
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PPUSH
47347: LD_VAR 0 1
47351: PPUSH
47352: CALL 57177 0 3
47356: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47357: LD_ADDR_VAR 0 5
47361: PUSH
47362: LD_EXP 94
47366: PUSH
47367: LD_VAR 0 4
47371: ARRAY
47372: PPUSH
47373: LD_INT 2
47375: PUSH
47376: LD_INT 30
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: LD_INT 30
47388: PUSH
47389: LD_INT 1
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: LIST
47400: PPUSH
47401: CALL_OW 72
47405: PPUSH
47406: LD_VAR 0 1
47410: PPUSH
47411: CALL_OW 74
47415: ST_TO_ADDR
// if tmp then
47416: LD_VAR 0 5
47420: IFFALSE 47436
// ComStandNearbyBuilding ( ape , tmp ) ;
47422: LD_VAR 0 1
47426: PPUSH
47427: LD_VAR 0 5
47431: PPUSH
47432: CALL 53602 0 2
// break ;
47436: GO 47440
// end ; end ;
47438: GO 47292
47440: POP
47441: POP
// end ;
47442: LD_VAR 0 3
47446: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47447: LD_INT 0
47449: PPUSH
47450: PPUSH
47451: PPUSH
// if not mc_bases or not skirmish then
47452: LD_EXP 94
47456: NOT
47457: PUSH
47458: LD_EXP 92
47462: NOT
47463: OR
47464: IFFALSE 47468
// exit ;
47466: GO 47557
// for i = 1 to mc_bases do
47468: LD_ADDR_VAR 0 4
47472: PUSH
47473: DOUBLE
47474: LD_INT 1
47476: DEC
47477: ST_TO_ADDR
47478: LD_EXP 94
47482: PUSH
47483: FOR_TO
47484: IFFALSE 47555
// begin if building in mc_busy_turret_list [ i ] then
47486: LD_VAR 0 1
47490: PUSH
47491: LD_EXP 104
47495: PUSH
47496: LD_VAR 0 4
47500: ARRAY
47501: IN
47502: IFFALSE 47553
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47504: LD_ADDR_VAR 0 5
47508: PUSH
47509: LD_EXP 104
47513: PUSH
47514: LD_VAR 0 4
47518: ARRAY
47519: PUSH
47520: LD_VAR 0 1
47524: DIFF
47525: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47526: LD_ADDR_EXP 104
47530: PUSH
47531: LD_EXP 104
47535: PPUSH
47536: LD_VAR 0 4
47540: PPUSH
47541: LD_VAR 0 5
47545: PPUSH
47546: CALL_OW 1
47550: ST_TO_ADDR
// break ;
47551: GO 47555
// end ; end ;
47553: GO 47483
47555: POP
47556: POP
// end ;
47557: LD_VAR 0 3
47561: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47562: LD_INT 0
47564: PPUSH
47565: PPUSH
47566: PPUSH
// if not mc_bases or not skirmish then
47567: LD_EXP 94
47571: NOT
47572: PUSH
47573: LD_EXP 92
47577: NOT
47578: OR
47579: IFFALSE 47583
// exit ;
47581: GO 47782
// for i = 1 to mc_bases do
47583: LD_ADDR_VAR 0 5
47587: PUSH
47588: DOUBLE
47589: LD_INT 1
47591: DEC
47592: ST_TO_ADDR
47593: LD_EXP 94
47597: PUSH
47598: FOR_TO
47599: IFFALSE 47780
// if building in mc_bases [ i ] then
47601: LD_VAR 0 1
47605: PUSH
47606: LD_EXP 94
47610: PUSH
47611: LD_VAR 0 5
47615: ARRAY
47616: IN
47617: IFFALSE 47778
// begin tmp := mc_bases [ i ] diff building ;
47619: LD_ADDR_VAR 0 6
47623: PUSH
47624: LD_EXP 94
47628: PUSH
47629: LD_VAR 0 5
47633: ARRAY
47634: PUSH
47635: LD_VAR 0 1
47639: DIFF
47640: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47641: LD_ADDR_EXP 94
47645: PUSH
47646: LD_EXP 94
47650: PPUSH
47651: LD_VAR 0 5
47655: PPUSH
47656: LD_VAR 0 6
47660: PPUSH
47661: CALL_OW 1
47665: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47666: LD_VAR 0 1
47670: PUSH
47671: LD_EXP 102
47675: PUSH
47676: LD_VAR 0 5
47680: ARRAY
47681: IN
47682: IFFALSE 47721
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47684: LD_ADDR_EXP 102
47688: PUSH
47689: LD_EXP 102
47693: PPUSH
47694: LD_VAR 0 5
47698: PPUSH
47699: LD_EXP 102
47703: PUSH
47704: LD_VAR 0 5
47708: ARRAY
47709: PUSH
47710: LD_VAR 0 1
47714: DIFF
47715: PPUSH
47716: CALL_OW 1
47720: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47721: LD_VAR 0 1
47725: PUSH
47726: LD_EXP 103
47730: PUSH
47731: LD_VAR 0 5
47735: ARRAY
47736: IN
47737: IFFALSE 47776
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47739: LD_ADDR_EXP 103
47743: PUSH
47744: LD_EXP 103
47748: PPUSH
47749: LD_VAR 0 5
47753: PPUSH
47754: LD_EXP 103
47758: PUSH
47759: LD_VAR 0 5
47763: ARRAY
47764: PUSH
47765: LD_VAR 0 1
47769: DIFF
47770: PPUSH
47771: CALL_OW 1
47775: ST_TO_ADDR
// break ;
47776: GO 47780
// end ;
47778: GO 47598
47780: POP
47781: POP
// end ;
47782: LD_VAR 0 4
47786: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47787: LD_INT 0
47789: PPUSH
47790: PPUSH
47791: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47792: LD_EXP 94
47796: NOT
47797: PUSH
47798: LD_EXP 92
47802: NOT
47803: OR
47804: PUSH
47805: LD_VAR 0 3
47809: PUSH
47810: LD_EXP 120
47814: IN
47815: NOT
47816: OR
47817: IFFALSE 47821
// exit ;
47819: GO 47944
// for i = 1 to mc_vehicles do
47821: LD_ADDR_VAR 0 6
47825: PUSH
47826: DOUBLE
47827: LD_INT 1
47829: DEC
47830: ST_TO_ADDR
47831: LD_EXP 113
47835: PUSH
47836: FOR_TO
47837: IFFALSE 47942
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47839: LD_VAR 0 2
47843: PUSH
47844: LD_EXP 113
47848: PUSH
47849: LD_VAR 0 6
47853: ARRAY
47854: IN
47855: PUSH
47856: LD_VAR 0 1
47860: PUSH
47861: LD_EXP 113
47865: PUSH
47866: LD_VAR 0 6
47870: ARRAY
47871: IN
47872: OR
47873: IFFALSE 47940
// begin tmp := mc_vehicles [ i ] diff old ;
47875: LD_ADDR_VAR 0 7
47879: PUSH
47880: LD_EXP 113
47884: PUSH
47885: LD_VAR 0 6
47889: ARRAY
47890: PUSH
47891: LD_VAR 0 2
47895: DIFF
47896: ST_TO_ADDR
// tmp := tmp diff new ;
47897: LD_ADDR_VAR 0 7
47901: PUSH
47902: LD_VAR 0 7
47906: PUSH
47907: LD_VAR 0 1
47911: DIFF
47912: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47913: LD_ADDR_EXP 113
47917: PUSH
47918: LD_EXP 113
47922: PPUSH
47923: LD_VAR 0 6
47927: PPUSH
47928: LD_VAR 0 7
47932: PPUSH
47933: CALL_OW 1
47937: ST_TO_ADDR
// break ;
47938: GO 47942
// end ;
47940: GO 47836
47942: POP
47943: POP
// end ;
47944: LD_VAR 0 5
47948: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47949: LD_INT 0
47951: PPUSH
47952: PPUSH
47953: PPUSH
47954: PPUSH
// if not mc_bases or not skirmish then
47955: LD_EXP 94
47959: NOT
47960: PUSH
47961: LD_EXP 92
47965: NOT
47966: OR
47967: IFFALSE 47971
// exit ;
47969: GO 48363
// side := GetSide ( vehicle ) ;
47971: LD_ADDR_VAR 0 5
47975: PUSH
47976: LD_VAR 0 1
47980: PPUSH
47981: CALL_OW 255
47985: ST_TO_ADDR
// for i = 1 to mc_bases do
47986: LD_ADDR_VAR 0 4
47990: PUSH
47991: DOUBLE
47992: LD_INT 1
47994: DEC
47995: ST_TO_ADDR
47996: LD_EXP 94
48000: PUSH
48001: FOR_TO
48002: IFFALSE 48361
// begin if factory in mc_bases [ i ] then
48004: LD_VAR 0 2
48008: PUSH
48009: LD_EXP 94
48013: PUSH
48014: LD_VAR 0 4
48018: ARRAY
48019: IN
48020: IFFALSE 48359
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48022: LD_EXP 116
48026: PUSH
48027: LD_VAR 0 4
48031: ARRAY
48032: PUSH
48033: LD_EXP 105
48037: PUSH
48038: LD_VAR 0 4
48042: ARRAY
48043: LESS
48044: PUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 264
48054: PUSH
48055: LD_INT 31
48057: PUSH
48058: LD_INT 32
48060: PUSH
48061: LD_INT 51
48063: PUSH
48064: LD_EXP 75
48068: PUSH
48069: LD_INT 12
48071: PUSH
48072: LD_INT 30
48074: PUSH
48075: LD_EXP 74
48079: PUSH
48080: LD_INT 11
48082: PUSH
48083: LD_INT 53
48085: PUSH
48086: LD_INT 14
48088: PUSH
48089: LD_EXP 78
48093: PUSH
48094: LD_INT 29
48096: PUSH
48097: LD_EXP 76
48101: PUSH
48102: LD_INT 13
48104: PUSH
48105: LD_INT 52
48107: PUSH
48108: LD_EXP 80
48112: PUSH
48113: LD_INT 48
48115: PUSH
48116: LD_INT 8
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: IN
48139: NOT
48140: AND
48141: IFFALSE 48189
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48143: LD_ADDR_EXP 116
48147: PUSH
48148: LD_EXP 116
48152: PPUSH
48153: LD_VAR 0 4
48157: PUSH
48158: LD_EXP 116
48162: PUSH
48163: LD_VAR 0 4
48167: ARRAY
48168: PUSH
48169: LD_INT 1
48171: PLUS
48172: PUSH
48173: EMPTY
48174: LIST
48175: LIST
48176: PPUSH
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL 57177 0 3
48186: ST_TO_ADDR
48187: GO 48233
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48189: LD_ADDR_EXP 113
48193: PUSH
48194: LD_EXP 113
48198: PPUSH
48199: LD_VAR 0 4
48203: PUSH
48204: LD_EXP 113
48208: PUSH
48209: LD_VAR 0 4
48213: ARRAY
48214: PUSH
48215: LD_INT 1
48217: PLUS
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PPUSH
48223: LD_VAR 0 1
48227: PPUSH
48228: CALL 57177 0 3
48232: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48233: LD_VAR 0 1
48237: PPUSH
48238: CALL_OW 263
48242: PUSH
48243: LD_INT 2
48245: EQUAL
48246: IFFALSE 48275
// begin repeat wait ( 0 0$3 ) ;
48248: LD_INT 105
48250: PPUSH
48251: CALL_OW 67
// Connect ( vehicle ) ;
48255: LD_VAR 0 1
48259: PPUSH
48260: CALL 60148 0 1
// until IsControledBy ( vehicle ) ;
48264: LD_VAR 0 1
48268: PPUSH
48269: CALL_OW 312
48273: IFFALSE 48248
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48275: LD_VAR 0 1
48279: PPUSH
48280: LD_EXP 118
48284: PUSH
48285: LD_VAR 0 4
48289: ARRAY
48290: PPUSH
48291: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48295: LD_VAR 0 1
48299: PPUSH
48300: CALL_OW 263
48304: PUSH
48305: LD_INT 1
48307: NONEQUAL
48308: IFFALSE 48312
// break ;
48310: GO 48361
// repeat wait ( 0 0$1 ) ;
48312: LD_INT 35
48314: PPUSH
48315: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48319: LD_VAR 0 1
48323: PPUSH
48324: LD_EXP 118
48328: PUSH
48329: LD_VAR 0 4
48333: ARRAY
48334: PPUSH
48335: CALL_OW 308
48339: IFFALSE 48312
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48341: LD_VAR 0 1
48345: PPUSH
48346: CALL_OW 311
48350: PPUSH
48351: CALL_OW 121
// exit ;
48355: POP
48356: POP
48357: GO 48363
// end ; end ;
48359: GO 48001
48361: POP
48362: POP
// end ;
48363: LD_VAR 0 3
48367: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48368: LD_INT 0
48370: PPUSH
48371: PPUSH
48372: PPUSH
48373: PPUSH
// if not mc_bases or not skirmish then
48374: LD_EXP 94
48378: NOT
48379: PUSH
48380: LD_EXP 92
48384: NOT
48385: OR
48386: IFFALSE 48390
// exit ;
48388: GO 48743
// repeat wait ( 0 0$1 ) ;
48390: LD_INT 35
48392: PPUSH
48393: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48397: LD_VAR 0 2
48401: PPUSH
48402: LD_VAR 0 3
48406: PPUSH
48407: CALL_OW 284
48411: IFFALSE 48390
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48413: LD_VAR 0 2
48417: PPUSH
48418: LD_VAR 0 3
48422: PPUSH
48423: CALL_OW 283
48427: PUSH
48428: LD_INT 4
48430: EQUAL
48431: IFFALSE 48435
// exit ;
48433: GO 48743
// for i = 1 to mc_bases do
48435: LD_ADDR_VAR 0 7
48439: PUSH
48440: DOUBLE
48441: LD_INT 1
48443: DEC
48444: ST_TO_ADDR
48445: LD_EXP 94
48449: PUSH
48450: FOR_TO
48451: IFFALSE 48741
// begin if mc_crates_area [ i ] then
48453: LD_EXP 112
48457: PUSH
48458: LD_VAR 0 7
48462: ARRAY
48463: IFFALSE 48574
// for j in mc_crates_area [ i ] do
48465: LD_ADDR_VAR 0 8
48469: PUSH
48470: LD_EXP 112
48474: PUSH
48475: LD_VAR 0 7
48479: ARRAY
48480: PUSH
48481: FOR_IN
48482: IFFALSE 48572
// if InArea ( x , y , j ) then
48484: LD_VAR 0 2
48488: PPUSH
48489: LD_VAR 0 3
48493: PPUSH
48494: LD_VAR 0 8
48498: PPUSH
48499: CALL_OW 309
48503: IFFALSE 48570
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48505: LD_ADDR_EXP 110
48509: PUSH
48510: LD_EXP 110
48514: PPUSH
48515: LD_VAR 0 7
48519: PUSH
48520: LD_EXP 110
48524: PUSH
48525: LD_VAR 0 7
48529: ARRAY
48530: PUSH
48531: LD_INT 1
48533: PLUS
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PPUSH
48539: LD_VAR 0 4
48543: PUSH
48544: LD_VAR 0 2
48548: PUSH
48549: LD_VAR 0 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: LIST
48558: PPUSH
48559: CALL 57177 0 3
48563: ST_TO_ADDR
// exit ;
48564: POP
48565: POP
48566: POP
48567: POP
48568: GO 48743
// end ;
48570: GO 48481
48572: POP
48573: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48574: LD_ADDR_VAR 0 9
48578: PUSH
48579: LD_EXP 94
48583: PUSH
48584: LD_VAR 0 7
48588: ARRAY
48589: PPUSH
48590: LD_INT 2
48592: PUSH
48593: LD_INT 30
48595: PUSH
48596: LD_INT 0
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 30
48605: PUSH
48606: LD_INT 1
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: EMPTY
48614: LIST
48615: LIST
48616: LIST
48617: PPUSH
48618: CALL_OW 72
48622: ST_TO_ADDR
// if not depot then
48623: LD_VAR 0 9
48627: NOT
48628: IFFALSE 48632
// continue ;
48630: GO 48450
// for j in depot do
48632: LD_ADDR_VAR 0 8
48636: PUSH
48637: LD_VAR 0 9
48641: PUSH
48642: FOR_IN
48643: IFFALSE 48737
// if GetDistUnitXY ( j , x , y ) < 30 then
48645: LD_VAR 0 8
48649: PPUSH
48650: LD_VAR 0 2
48654: PPUSH
48655: LD_VAR 0 3
48659: PPUSH
48660: CALL_OW 297
48664: PUSH
48665: LD_INT 30
48667: LESS
48668: IFFALSE 48735
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48670: LD_ADDR_EXP 110
48674: PUSH
48675: LD_EXP 110
48679: PPUSH
48680: LD_VAR 0 7
48684: PUSH
48685: LD_EXP 110
48689: PUSH
48690: LD_VAR 0 7
48694: ARRAY
48695: PUSH
48696: LD_INT 1
48698: PLUS
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PPUSH
48704: LD_VAR 0 4
48708: PUSH
48709: LD_VAR 0 2
48713: PUSH
48714: LD_VAR 0 3
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: LIST
48723: PPUSH
48724: CALL 57177 0 3
48728: ST_TO_ADDR
// exit ;
48729: POP
48730: POP
48731: POP
48732: POP
48733: GO 48743
// end ;
48735: GO 48642
48737: POP
48738: POP
// end ;
48739: GO 48450
48741: POP
48742: POP
// end ;
48743: LD_VAR 0 6
48747: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48748: LD_INT 0
48750: PPUSH
48751: PPUSH
48752: PPUSH
48753: PPUSH
// if not mc_bases or not skirmish then
48754: LD_EXP 94
48758: NOT
48759: PUSH
48760: LD_EXP 92
48764: NOT
48765: OR
48766: IFFALSE 48770
// exit ;
48768: GO 49047
// side := GetSide ( lab ) ;
48770: LD_ADDR_VAR 0 4
48774: PUSH
48775: LD_VAR 0 2
48779: PPUSH
48780: CALL_OW 255
48784: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48785: LD_VAR 0 4
48789: PUSH
48790: LD_EXP 120
48794: IN
48795: NOT
48796: PUSH
48797: LD_EXP 121
48801: NOT
48802: OR
48803: PUSH
48804: LD_EXP 94
48808: NOT
48809: OR
48810: IFFALSE 48814
// exit ;
48812: GO 49047
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48814: LD_ADDR_EXP 121
48818: PUSH
48819: LD_EXP 121
48823: PPUSH
48824: LD_VAR 0 4
48828: PPUSH
48829: LD_EXP 121
48833: PUSH
48834: LD_VAR 0 4
48838: ARRAY
48839: PUSH
48840: LD_VAR 0 1
48844: DIFF
48845: PPUSH
48846: CALL_OW 1
48850: ST_TO_ADDR
// for i = 1 to mc_bases do
48851: LD_ADDR_VAR 0 5
48855: PUSH
48856: DOUBLE
48857: LD_INT 1
48859: DEC
48860: ST_TO_ADDR
48861: LD_EXP 94
48865: PUSH
48866: FOR_TO
48867: IFFALSE 49045
// begin if lab in mc_bases [ i ] then
48869: LD_VAR 0 2
48873: PUSH
48874: LD_EXP 94
48878: PUSH
48879: LD_VAR 0 5
48883: ARRAY
48884: IN
48885: IFFALSE 49043
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 11
48894: PUSH
48895: LD_INT 4
48897: PUSH
48898: LD_INT 3
48900: PUSH
48901: LD_INT 2
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: IN
48910: PUSH
48911: LD_EXP 124
48915: PUSH
48916: LD_VAR 0 5
48920: ARRAY
48921: AND
48922: IFFALSE 49043
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48924: LD_ADDR_VAR 0 6
48928: PUSH
48929: LD_EXP 124
48933: PUSH
48934: LD_VAR 0 5
48938: ARRAY
48939: PUSH
48940: LD_INT 1
48942: ARRAY
48943: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48944: LD_ADDR_EXP 124
48948: PUSH
48949: LD_EXP 124
48953: PPUSH
48954: LD_VAR 0 5
48958: PPUSH
48959: EMPTY
48960: PPUSH
48961: CALL_OW 1
48965: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48966: LD_VAR 0 6
48970: PPUSH
48971: LD_INT 0
48973: PPUSH
48974: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48978: LD_VAR 0 6
48982: PPUSH
48983: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48987: LD_ADDR_EXP 123
48991: PUSH
48992: LD_EXP 123
48996: PPUSH
48997: LD_VAR 0 5
49001: PPUSH
49002: LD_EXP 123
49006: PUSH
49007: LD_VAR 0 5
49011: ARRAY
49012: PPUSH
49013: LD_INT 1
49015: PPUSH
49016: LD_VAR 0 6
49020: PPUSH
49021: CALL_OW 2
49025: PPUSH
49026: CALL_OW 1
49030: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49031: LD_VAR 0 5
49035: PPUSH
49036: LD_INT 112
49038: PPUSH
49039: CALL 25566 0 2
// end ; end ; end ;
49043: GO 48866
49045: POP
49046: POP
// end ;
49047: LD_VAR 0 3
49051: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49052: LD_INT 0
49054: PPUSH
49055: PPUSH
49056: PPUSH
49057: PPUSH
49058: PPUSH
49059: PPUSH
49060: PPUSH
49061: PPUSH
// if not mc_bases or not skirmish then
49062: LD_EXP 94
49066: NOT
49067: PUSH
49068: LD_EXP 92
49072: NOT
49073: OR
49074: IFFALSE 49078
// exit ;
49076: GO 50449
// for i = 1 to mc_bases do
49078: LD_ADDR_VAR 0 3
49082: PUSH
49083: DOUBLE
49084: LD_INT 1
49086: DEC
49087: ST_TO_ADDR
49088: LD_EXP 94
49092: PUSH
49093: FOR_TO
49094: IFFALSE 50447
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49096: LD_VAR 0 1
49100: PUSH
49101: LD_EXP 94
49105: PUSH
49106: LD_VAR 0 3
49110: ARRAY
49111: IN
49112: PUSH
49113: LD_VAR 0 1
49117: PUSH
49118: LD_EXP 101
49122: PUSH
49123: LD_VAR 0 3
49127: ARRAY
49128: IN
49129: OR
49130: PUSH
49131: LD_VAR 0 1
49135: PUSH
49136: LD_EXP 116
49140: PUSH
49141: LD_VAR 0 3
49145: ARRAY
49146: IN
49147: OR
49148: PUSH
49149: LD_VAR 0 1
49153: PUSH
49154: LD_EXP 113
49158: PUSH
49159: LD_VAR 0 3
49163: ARRAY
49164: IN
49165: OR
49166: PUSH
49167: LD_VAR 0 1
49171: PUSH
49172: LD_EXP 123
49176: PUSH
49177: LD_VAR 0 3
49181: ARRAY
49182: IN
49183: OR
49184: PUSH
49185: LD_VAR 0 1
49189: PUSH
49190: LD_EXP 124
49194: PUSH
49195: LD_VAR 0 3
49199: ARRAY
49200: IN
49201: OR
49202: IFFALSE 50445
// begin if un in mc_ape [ i ] then
49204: LD_VAR 0 1
49208: PUSH
49209: LD_EXP 123
49213: PUSH
49214: LD_VAR 0 3
49218: ARRAY
49219: IN
49220: IFFALSE 49259
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49222: LD_ADDR_EXP 123
49226: PUSH
49227: LD_EXP 123
49231: PPUSH
49232: LD_VAR 0 3
49236: PPUSH
49237: LD_EXP 123
49241: PUSH
49242: LD_VAR 0 3
49246: ARRAY
49247: PUSH
49248: LD_VAR 0 1
49252: DIFF
49253: PPUSH
49254: CALL_OW 1
49258: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49259: LD_VAR 0 1
49263: PUSH
49264: LD_EXP 124
49268: PUSH
49269: LD_VAR 0 3
49273: ARRAY
49274: IN
49275: IFFALSE 49299
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49277: LD_ADDR_EXP 124
49281: PUSH
49282: LD_EXP 124
49286: PPUSH
49287: LD_VAR 0 3
49291: PPUSH
49292: EMPTY
49293: PPUSH
49294: CALL_OW 1
49298: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49299: LD_VAR 0 1
49303: PPUSH
49304: CALL_OW 247
49308: PUSH
49309: LD_INT 2
49311: EQUAL
49312: PUSH
49313: LD_VAR 0 1
49317: PPUSH
49318: CALL_OW 110
49322: PUSH
49323: LD_INT 20
49325: EQUAL
49326: PUSH
49327: LD_VAR 0 1
49331: PUSH
49332: LD_EXP 116
49336: PUSH
49337: LD_VAR 0 3
49341: ARRAY
49342: IN
49343: OR
49344: PUSH
49345: LD_VAR 0 1
49349: PPUSH
49350: CALL_OW 264
49354: PUSH
49355: LD_INT 12
49357: PUSH
49358: LD_INT 51
49360: PUSH
49361: LD_EXP 75
49365: PUSH
49366: LD_INT 32
49368: PUSH
49369: LD_INT 13
49371: PUSH
49372: LD_INT 52
49374: PUSH
49375: LD_INT 31
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: IN
49387: OR
49388: AND
49389: IFFALSE 49697
// begin if un in mc_defender [ i ] then
49391: LD_VAR 0 1
49395: PUSH
49396: LD_EXP 116
49400: PUSH
49401: LD_VAR 0 3
49405: ARRAY
49406: IN
49407: IFFALSE 49446
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49409: LD_ADDR_EXP 116
49413: PUSH
49414: LD_EXP 116
49418: PPUSH
49419: LD_VAR 0 3
49423: PPUSH
49424: LD_EXP 116
49428: PUSH
49429: LD_VAR 0 3
49433: ARRAY
49434: PUSH
49435: LD_VAR 0 1
49439: DIFF
49440: PPUSH
49441: CALL_OW 1
49445: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49446: LD_ADDR_VAR 0 8
49450: PUSH
49451: LD_VAR 0 3
49455: PPUSH
49456: LD_INT 3
49458: PPUSH
49459: CALL 46087 0 2
49463: ST_TO_ADDR
// if fac then
49464: LD_VAR 0 8
49468: IFFALSE 49697
// begin for j in fac do
49470: LD_ADDR_VAR 0 4
49474: PUSH
49475: LD_VAR 0 8
49479: PUSH
49480: FOR_IN
49481: IFFALSE 49695
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49483: LD_ADDR_VAR 0 9
49487: PUSH
49488: LD_VAR 0 8
49492: PPUSH
49493: LD_VAR 0 1
49497: PPUSH
49498: CALL_OW 265
49502: PPUSH
49503: LD_VAR 0 1
49507: PPUSH
49508: CALL_OW 262
49512: PPUSH
49513: LD_VAR 0 1
49517: PPUSH
49518: CALL_OW 263
49522: PPUSH
49523: LD_VAR 0 1
49527: PPUSH
49528: CALL_OW 264
49532: PPUSH
49533: CALL 54673 0 5
49537: ST_TO_ADDR
// if components then
49538: LD_VAR 0 9
49542: IFFALSE 49693
// begin if GetWeapon ( un ) = ar_control_tower then
49544: LD_VAR 0 1
49548: PPUSH
49549: CALL_OW 264
49553: PUSH
49554: LD_INT 31
49556: EQUAL
49557: IFFALSE 49674
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49559: LD_VAR 0 1
49563: PPUSH
49564: CALL_OW 311
49568: PPUSH
49569: LD_INT 0
49571: PPUSH
49572: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49576: LD_ADDR_EXP 134
49580: PUSH
49581: LD_EXP 134
49585: PPUSH
49586: LD_VAR 0 3
49590: PPUSH
49591: LD_EXP 134
49595: PUSH
49596: LD_VAR 0 3
49600: ARRAY
49601: PUSH
49602: LD_VAR 0 1
49606: PPUSH
49607: CALL_OW 311
49611: DIFF
49612: PPUSH
49613: CALL_OW 1
49617: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49618: LD_ADDR_VAR 0 7
49622: PUSH
49623: LD_EXP 115
49627: PUSH
49628: LD_VAR 0 3
49632: ARRAY
49633: PPUSH
49634: LD_INT 1
49636: PPUSH
49637: LD_VAR 0 9
49641: PPUSH
49642: CALL_OW 2
49646: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49647: LD_ADDR_EXP 115
49651: PUSH
49652: LD_EXP 115
49656: PPUSH
49657: LD_VAR 0 3
49661: PPUSH
49662: LD_VAR 0 7
49666: PPUSH
49667: CALL_OW 1
49671: ST_TO_ADDR
// end else
49672: GO 49691
// MC_InsertProduceList ( i , [ components ] ) ;
49674: LD_VAR 0 3
49678: PPUSH
49679: LD_VAR 0 9
49683: PUSH
49684: EMPTY
49685: LIST
49686: PPUSH
49687: CALL 45632 0 2
// break ;
49691: GO 49695
// end ; end ;
49693: GO 49480
49695: POP
49696: POP
// end ; end ; if GetType ( un ) = unit_building then
49697: LD_VAR 0 1
49701: PPUSH
49702: CALL_OW 247
49706: PUSH
49707: LD_INT 3
49709: EQUAL
49710: IFFALSE 50113
// begin btype := GetBType ( un ) ;
49712: LD_ADDR_VAR 0 5
49716: PUSH
49717: LD_VAR 0 1
49721: PPUSH
49722: CALL_OW 266
49726: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49727: LD_VAR 0 5
49731: PUSH
49732: LD_INT 29
49734: PUSH
49735: LD_INT 30
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: IN
49742: IFFALSE 49815
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49744: LD_VAR 0 1
49748: PPUSH
49749: CALL_OW 250
49753: PPUSH
49754: LD_VAR 0 1
49758: PPUSH
49759: CALL_OW 251
49763: PPUSH
49764: LD_VAR 0 1
49768: PPUSH
49769: CALL_OW 255
49773: PPUSH
49774: CALL_OW 440
49778: NOT
49779: IFFALSE 49815
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49781: LD_VAR 0 1
49785: PPUSH
49786: CALL_OW 250
49790: PPUSH
49791: LD_VAR 0 1
49795: PPUSH
49796: CALL_OW 251
49800: PPUSH
49801: LD_VAR 0 1
49805: PPUSH
49806: CALL_OW 255
49810: PPUSH
49811: CALL_OW 441
// end ; if btype = b_warehouse then
49815: LD_VAR 0 5
49819: PUSH
49820: LD_INT 1
49822: EQUAL
49823: IFFALSE 49841
// begin btype := b_depot ;
49825: LD_ADDR_VAR 0 5
49829: PUSH
49830: LD_INT 0
49832: ST_TO_ADDR
// pos := 1 ;
49833: LD_ADDR_VAR 0 6
49837: PUSH
49838: LD_INT 1
49840: ST_TO_ADDR
// end ; if btype = b_factory then
49841: LD_VAR 0 5
49845: PUSH
49846: LD_INT 3
49848: EQUAL
49849: IFFALSE 49867
// begin btype := b_workshop ;
49851: LD_ADDR_VAR 0 5
49855: PUSH
49856: LD_INT 2
49858: ST_TO_ADDR
// pos := 1 ;
49859: LD_ADDR_VAR 0 6
49863: PUSH
49864: LD_INT 1
49866: ST_TO_ADDR
// end ; if btype = b_barracks then
49867: LD_VAR 0 5
49871: PUSH
49872: LD_INT 5
49874: EQUAL
49875: IFFALSE 49885
// btype := b_armoury ;
49877: LD_ADDR_VAR 0 5
49881: PUSH
49882: LD_INT 4
49884: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49885: LD_VAR 0 5
49889: PUSH
49890: LD_INT 7
49892: PUSH
49893: LD_INT 8
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: IN
49900: IFFALSE 49910
// btype := b_lab ;
49902: LD_ADDR_VAR 0 5
49906: PUSH
49907: LD_INT 6
49909: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49910: LD_ADDR_EXP 99
49914: PUSH
49915: LD_EXP 99
49919: PPUSH
49920: LD_VAR 0 3
49924: PUSH
49925: LD_EXP 99
49929: PUSH
49930: LD_VAR 0 3
49934: ARRAY
49935: PUSH
49936: LD_INT 1
49938: PLUS
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PPUSH
49944: LD_VAR 0 5
49948: PUSH
49949: LD_VAR 0 1
49953: PPUSH
49954: CALL_OW 250
49958: PUSH
49959: LD_VAR 0 1
49963: PPUSH
49964: CALL_OW 251
49968: PUSH
49969: LD_VAR 0 1
49973: PPUSH
49974: CALL_OW 254
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: PPUSH
49985: CALL 57177 0 3
49989: ST_TO_ADDR
// if pos = 1 then
49990: LD_VAR 0 6
49994: PUSH
49995: LD_INT 1
49997: EQUAL
49998: IFFALSE 50113
// begin tmp := mc_build_list [ i ] ;
50000: LD_ADDR_VAR 0 7
50004: PUSH
50005: LD_EXP 99
50009: PUSH
50010: LD_VAR 0 3
50014: ARRAY
50015: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50016: LD_VAR 0 7
50020: PPUSH
50021: LD_INT 2
50023: PUSH
50024: LD_INT 30
50026: PUSH
50027: LD_INT 0
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: LD_INT 30
50036: PUSH
50037: LD_INT 1
50039: PUSH
50040: EMPTY
50041: LIST
50042: LIST
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: LIST
50048: PPUSH
50049: CALL_OW 72
50053: IFFALSE 50063
// pos := 2 ;
50055: LD_ADDR_VAR 0 6
50059: PUSH
50060: LD_INT 2
50062: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50063: LD_ADDR_VAR 0 7
50067: PUSH
50068: LD_VAR 0 7
50072: PPUSH
50073: LD_VAR 0 6
50077: PPUSH
50078: LD_VAR 0 7
50082: PPUSH
50083: CALL 57503 0 3
50087: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50088: LD_ADDR_EXP 99
50092: PUSH
50093: LD_EXP 99
50097: PPUSH
50098: LD_VAR 0 3
50102: PPUSH
50103: LD_VAR 0 7
50107: PPUSH
50108: CALL_OW 1
50112: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50113: LD_VAR 0 1
50117: PUSH
50118: LD_EXP 94
50122: PUSH
50123: LD_VAR 0 3
50127: ARRAY
50128: IN
50129: IFFALSE 50168
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50131: LD_ADDR_EXP 94
50135: PUSH
50136: LD_EXP 94
50140: PPUSH
50141: LD_VAR 0 3
50145: PPUSH
50146: LD_EXP 94
50150: PUSH
50151: LD_VAR 0 3
50155: ARRAY
50156: PUSH
50157: LD_VAR 0 1
50161: DIFF
50162: PPUSH
50163: CALL_OW 1
50167: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50168: LD_VAR 0 1
50172: PUSH
50173: LD_EXP 101
50177: PUSH
50178: LD_VAR 0 3
50182: ARRAY
50183: IN
50184: IFFALSE 50223
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50186: LD_ADDR_EXP 101
50190: PUSH
50191: LD_EXP 101
50195: PPUSH
50196: LD_VAR 0 3
50200: PPUSH
50201: LD_EXP 101
50205: PUSH
50206: LD_VAR 0 3
50210: ARRAY
50211: PUSH
50212: LD_VAR 0 1
50216: DIFF
50217: PPUSH
50218: CALL_OW 1
50222: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50223: LD_VAR 0 1
50227: PUSH
50228: LD_EXP 113
50232: PUSH
50233: LD_VAR 0 3
50237: ARRAY
50238: IN
50239: IFFALSE 50278
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50241: LD_ADDR_EXP 113
50245: PUSH
50246: LD_EXP 113
50250: PPUSH
50251: LD_VAR 0 3
50255: PPUSH
50256: LD_EXP 113
50260: PUSH
50261: LD_VAR 0 3
50265: ARRAY
50266: PUSH
50267: LD_VAR 0 1
50271: DIFF
50272: PPUSH
50273: CALL_OW 1
50277: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50278: LD_VAR 0 1
50282: PUSH
50283: LD_EXP 116
50287: PUSH
50288: LD_VAR 0 3
50292: ARRAY
50293: IN
50294: IFFALSE 50333
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50296: LD_ADDR_EXP 116
50300: PUSH
50301: LD_EXP 116
50305: PPUSH
50306: LD_VAR 0 3
50310: PPUSH
50311: LD_EXP 116
50315: PUSH
50316: LD_VAR 0 3
50320: ARRAY
50321: PUSH
50322: LD_VAR 0 1
50326: DIFF
50327: PPUSH
50328: CALL_OW 1
50332: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50333: LD_VAR 0 1
50337: PUSH
50338: LD_EXP 103
50342: PUSH
50343: LD_VAR 0 3
50347: ARRAY
50348: IN
50349: IFFALSE 50388
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50351: LD_ADDR_EXP 103
50355: PUSH
50356: LD_EXP 103
50360: PPUSH
50361: LD_VAR 0 3
50365: PPUSH
50366: LD_EXP 103
50370: PUSH
50371: LD_VAR 0 3
50375: ARRAY
50376: PUSH
50377: LD_VAR 0 1
50381: DIFF
50382: PPUSH
50383: CALL_OW 1
50387: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50388: LD_VAR 0 1
50392: PUSH
50393: LD_EXP 102
50397: PUSH
50398: LD_VAR 0 3
50402: ARRAY
50403: IN
50404: IFFALSE 50443
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50406: LD_ADDR_EXP 102
50410: PUSH
50411: LD_EXP 102
50415: PPUSH
50416: LD_VAR 0 3
50420: PPUSH
50421: LD_EXP 102
50425: PUSH
50426: LD_VAR 0 3
50430: ARRAY
50431: PUSH
50432: LD_VAR 0 1
50436: DIFF
50437: PPUSH
50438: CALL_OW 1
50442: ST_TO_ADDR
// end ; break ;
50443: GO 50447
// end ;
50445: GO 49093
50447: POP
50448: POP
// end ;
50449: LD_VAR 0 2
50453: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50454: LD_INT 0
50456: PPUSH
50457: PPUSH
50458: PPUSH
// if not mc_bases or not skirmish then
50459: LD_EXP 94
50463: NOT
50464: PUSH
50465: LD_EXP 92
50469: NOT
50470: OR
50471: IFFALSE 50475
// exit ;
50473: GO 50690
// for i = 1 to mc_bases do
50475: LD_ADDR_VAR 0 3
50479: PUSH
50480: DOUBLE
50481: LD_INT 1
50483: DEC
50484: ST_TO_ADDR
50485: LD_EXP 94
50489: PUSH
50490: FOR_TO
50491: IFFALSE 50688
// begin if building in mc_construct_list [ i ] then
50493: LD_VAR 0 1
50497: PUSH
50498: LD_EXP 101
50502: PUSH
50503: LD_VAR 0 3
50507: ARRAY
50508: IN
50509: IFFALSE 50686
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50511: LD_ADDR_EXP 101
50515: PUSH
50516: LD_EXP 101
50520: PPUSH
50521: LD_VAR 0 3
50525: PPUSH
50526: LD_EXP 101
50530: PUSH
50531: LD_VAR 0 3
50535: ARRAY
50536: PUSH
50537: LD_VAR 0 1
50541: DIFF
50542: PPUSH
50543: CALL_OW 1
50547: ST_TO_ADDR
// if building in mc_lab [ i ] then
50548: LD_VAR 0 1
50552: PUSH
50553: LD_EXP 127
50557: PUSH
50558: LD_VAR 0 3
50562: ARRAY
50563: IN
50564: IFFALSE 50619
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50566: LD_ADDR_EXP 128
50570: PUSH
50571: LD_EXP 128
50575: PPUSH
50576: LD_VAR 0 3
50580: PPUSH
50581: LD_EXP 128
50585: PUSH
50586: LD_VAR 0 3
50590: ARRAY
50591: PPUSH
50592: LD_INT 1
50594: PPUSH
50595: LD_EXP 128
50599: PUSH
50600: LD_VAR 0 3
50604: ARRAY
50605: PPUSH
50606: LD_INT 0
50608: PPUSH
50609: CALL 56595 0 4
50613: PPUSH
50614: CALL_OW 1
50618: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50619: LD_VAR 0 1
50623: PUSH
50624: LD_EXP 94
50628: PUSH
50629: LD_VAR 0 3
50633: ARRAY
50634: IN
50635: NOT
50636: IFFALSE 50682
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50638: LD_ADDR_EXP 94
50642: PUSH
50643: LD_EXP 94
50647: PPUSH
50648: LD_VAR 0 3
50652: PUSH
50653: LD_EXP 94
50657: PUSH
50658: LD_VAR 0 3
50662: ARRAY
50663: PUSH
50664: LD_INT 1
50666: PLUS
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: PPUSH
50672: LD_VAR 0 1
50676: PPUSH
50677: CALL 57177 0 3
50681: ST_TO_ADDR
// exit ;
50682: POP
50683: POP
50684: GO 50690
// end ; end ;
50686: GO 50490
50688: POP
50689: POP
// end ;
50690: LD_VAR 0 2
50694: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50695: LD_INT 0
50697: PPUSH
50698: PPUSH
50699: PPUSH
50700: PPUSH
50701: PPUSH
50702: PPUSH
50703: PPUSH
// if not mc_bases or not skirmish then
50704: LD_EXP 94
50708: NOT
50709: PUSH
50710: LD_EXP 92
50714: NOT
50715: OR
50716: IFFALSE 50720
// exit ;
50718: GO 51381
// for i = 1 to mc_bases do
50720: LD_ADDR_VAR 0 3
50724: PUSH
50725: DOUBLE
50726: LD_INT 1
50728: DEC
50729: ST_TO_ADDR
50730: LD_EXP 94
50734: PUSH
50735: FOR_TO
50736: IFFALSE 51379
// begin if building in mc_construct_list [ i ] then
50738: LD_VAR 0 1
50742: PUSH
50743: LD_EXP 101
50747: PUSH
50748: LD_VAR 0 3
50752: ARRAY
50753: IN
50754: IFFALSE 51377
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50756: LD_ADDR_EXP 101
50760: PUSH
50761: LD_EXP 101
50765: PPUSH
50766: LD_VAR 0 3
50770: PPUSH
50771: LD_EXP 101
50775: PUSH
50776: LD_VAR 0 3
50780: ARRAY
50781: PUSH
50782: LD_VAR 0 1
50786: DIFF
50787: PPUSH
50788: CALL_OW 1
50792: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50793: LD_ADDR_EXP 94
50797: PUSH
50798: LD_EXP 94
50802: PPUSH
50803: LD_VAR 0 3
50807: PUSH
50808: LD_EXP 94
50812: PUSH
50813: LD_VAR 0 3
50817: ARRAY
50818: PUSH
50819: LD_INT 1
50821: PLUS
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PPUSH
50827: LD_VAR 0 1
50831: PPUSH
50832: CALL 57177 0 3
50836: ST_TO_ADDR
// btype := GetBType ( building ) ;
50837: LD_ADDR_VAR 0 5
50841: PUSH
50842: LD_VAR 0 1
50846: PPUSH
50847: CALL_OW 266
50851: ST_TO_ADDR
// side := GetSide ( building ) ;
50852: LD_ADDR_VAR 0 8
50856: PUSH
50857: LD_VAR 0 1
50861: PPUSH
50862: CALL_OW 255
50866: ST_TO_ADDR
// if btype = b_lab then
50867: LD_VAR 0 5
50871: PUSH
50872: LD_INT 6
50874: EQUAL
50875: IFFALSE 50925
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50877: LD_ADDR_EXP 127
50881: PUSH
50882: LD_EXP 127
50886: PPUSH
50887: LD_VAR 0 3
50891: PUSH
50892: LD_EXP 127
50896: PUSH
50897: LD_VAR 0 3
50901: ARRAY
50902: PUSH
50903: LD_INT 1
50905: PLUS
50906: PUSH
50907: EMPTY
50908: LIST
50909: LIST
50910: PPUSH
50911: LD_VAR 0 1
50915: PPUSH
50916: CALL 57177 0 3
50920: ST_TO_ADDR
// exit ;
50921: POP
50922: POP
50923: GO 51381
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50925: LD_VAR 0 5
50929: PUSH
50930: LD_INT 0
50932: PUSH
50933: LD_INT 2
50935: PUSH
50936: LD_INT 4
50938: PUSH
50939: EMPTY
50940: LIST
50941: LIST
50942: LIST
50943: IN
50944: IFFALSE 51068
// begin if btype = b_armoury then
50946: LD_VAR 0 5
50950: PUSH
50951: LD_INT 4
50953: EQUAL
50954: IFFALSE 50964
// btype := b_barracks ;
50956: LD_ADDR_VAR 0 5
50960: PUSH
50961: LD_INT 5
50963: ST_TO_ADDR
// if btype = b_depot then
50964: LD_VAR 0 5
50968: PUSH
50969: LD_INT 0
50971: EQUAL
50972: IFFALSE 50982
// btype := b_warehouse ;
50974: LD_ADDR_VAR 0 5
50978: PUSH
50979: LD_INT 1
50981: ST_TO_ADDR
// if btype = b_workshop then
50982: LD_VAR 0 5
50986: PUSH
50987: LD_INT 2
50989: EQUAL
50990: IFFALSE 51000
// btype := b_factory ;
50992: LD_ADDR_VAR 0 5
50996: PUSH
50997: LD_INT 3
50999: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51000: LD_VAR 0 5
51004: PPUSH
51005: LD_VAR 0 8
51009: PPUSH
51010: CALL_OW 323
51014: PUSH
51015: LD_INT 1
51017: EQUAL
51018: IFFALSE 51064
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51020: LD_ADDR_EXP 126
51024: PUSH
51025: LD_EXP 126
51029: PPUSH
51030: LD_VAR 0 3
51034: PUSH
51035: LD_EXP 126
51039: PUSH
51040: LD_VAR 0 3
51044: ARRAY
51045: PUSH
51046: LD_INT 1
51048: PLUS
51049: PUSH
51050: EMPTY
51051: LIST
51052: LIST
51053: PPUSH
51054: LD_VAR 0 1
51058: PPUSH
51059: CALL 57177 0 3
51063: ST_TO_ADDR
// exit ;
51064: POP
51065: POP
51066: GO 51381
// end ; if btype in [ b_bunker , b_turret ] then
51068: LD_VAR 0 5
51072: PUSH
51073: LD_INT 32
51075: PUSH
51076: LD_INT 33
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: IN
51083: IFFALSE 51373
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51085: LD_ADDR_EXP 102
51089: PUSH
51090: LD_EXP 102
51094: PPUSH
51095: LD_VAR 0 3
51099: PUSH
51100: LD_EXP 102
51104: PUSH
51105: LD_VAR 0 3
51109: ARRAY
51110: PUSH
51111: LD_INT 1
51113: PLUS
51114: PUSH
51115: EMPTY
51116: LIST
51117: LIST
51118: PPUSH
51119: LD_VAR 0 1
51123: PPUSH
51124: CALL 57177 0 3
51128: ST_TO_ADDR
// if btype = b_bunker then
51129: LD_VAR 0 5
51133: PUSH
51134: LD_INT 32
51136: EQUAL
51137: IFFALSE 51373
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51139: LD_ADDR_EXP 103
51143: PUSH
51144: LD_EXP 103
51148: PPUSH
51149: LD_VAR 0 3
51153: PUSH
51154: LD_EXP 103
51158: PUSH
51159: LD_VAR 0 3
51163: ARRAY
51164: PUSH
51165: LD_INT 1
51167: PLUS
51168: PUSH
51169: EMPTY
51170: LIST
51171: LIST
51172: PPUSH
51173: LD_VAR 0 1
51177: PPUSH
51178: CALL 57177 0 3
51182: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51183: LD_ADDR_VAR 0 6
51187: PUSH
51188: LD_EXP 94
51192: PUSH
51193: LD_VAR 0 3
51197: ARRAY
51198: PPUSH
51199: LD_INT 25
51201: PUSH
51202: LD_INT 1
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: LD_INT 3
51211: PUSH
51212: LD_INT 54
51214: PUSH
51215: EMPTY
51216: LIST
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PUSH
51222: EMPTY
51223: LIST
51224: LIST
51225: PPUSH
51226: CALL_OW 72
51230: ST_TO_ADDR
// if tmp then
51231: LD_VAR 0 6
51235: IFFALSE 51241
// exit ;
51237: POP
51238: POP
51239: GO 51381
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51241: LD_ADDR_VAR 0 6
51245: PUSH
51246: LD_EXP 94
51250: PUSH
51251: LD_VAR 0 3
51255: ARRAY
51256: PPUSH
51257: LD_INT 2
51259: PUSH
51260: LD_INT 30
51262: PUSH
51263: LD_INT 4
51265: PUSH
51266: EMPTY
51267: LIST
51268: LIST
51269: PUSH
51270: LD_INT 30
51272: PUSH
51273: LD_INT 5
51275: PUSH
51276: EMPTY
51277: LIST
51278: LIST
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: LIST
51284: PPUSH
51285: CALL_OW 72
51289: ST_TO_ADDR
// if not tmp then
51290: LD_VAR 0 6
51294: NOT
51295: IFFALSE 51301
// exit ;
51297: POP
51298: POP
51299: GO 51381
// for j in tmp do
51301: LD_ADDR_VAR 0 4
51305: PUSH
51306: LD_VAR 0 6
51310: PUSH
51311: FOR_IN
51312: IFFALSE 51371
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51314: LD_ADDR_VAR 0 7
51318: PUSH
51319: LD_VAR 0 4
51323: PPUSH
51324: CALL_OW 313
51328: PPUSH
51329: LD_INT 25
51331: PUSH
51332: LD_INT 1
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: PPUSH
51339: CALL_OW 72
51343: ST_TO_ADDR
// if units then
51344: LD_VAR 0 7
51348: IFFALSE 51369
// begin ComExitBuilding ( units [ 1 ] ) ;
51350: LD_VAR 0 7
51354: PUSH
51355: LD_INT 1
51357: ARRAY
51358: PPUSH
51359: CALL_OW 122
// exit ;
51363: POP
51364: POP
51365: POP
51366: POP
51367: GO 51381
// end ; end ;
51369: GO 51311
51371: POP
51372: POP
// end ; end ; exit ;
51373: POP
51374: POP
51375: GO 51381
// end ; end ;
51377: GO 50735
51379: POP
51380: POP
// end ;
51381: LD_VAR 0 2
51385: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51386: LD_INT 0
51388: PPUSH
51389: PPUSH
51390: PPUSH
51391: PPUSH
51392: PPUSH
51393: PPUSH
51394: PPUSH
// if not mc_bases or not skirmish then
51395: LD_EXP 94
51399: NOT
51400: PUSH
51401: LD_EXP 92
51405: NOT
51406: OR
51407: IFFALSE 51411
// exit ;
51409: GO 51676
// btype := GetBType ( building ) ;
51411: LD_ADDR_VAR 0 6
51415: PUSH
51416: LD_VAR 0 1
51420: PPUSH
51421: CALL_OW 266
51425: ST_TO_ADDR
// x := GetX ( building ) ;
51426: LD_ADDR_VAR 0 7
51430: PUSH
51431: LD_VAR 0 1
51435: PPUSH
51436: CALL_OW 250
51440: ST_TO_ADDR
// y := GetY ( building ) ;
51441: LD_ADDR_VAR 0 8
51445: PUSH
51446: LD_VAR 0 1
51450: PPUSH
51451: CALL_OW 251
51455: ST_TO_ADDR
// d := GetDir ( building ) ;
51456: LD_ADDR_VAR 0 9
51460: PUSH
51461: LD_VAR 0 1
51465: PPUSH
51466: CALL_OW 254
51470: ST_TO_ADDR
// for i = 1 to mc_bases do
51471: LD_ADDR_VAR 0 4
51475: PUSH
51476: DOUBLE
51477: LD_INT 1
51479: DEC
51480: ST_TO_ADDR
51481: LD_EXP 94
51485: PUSH
51486: FOR_TO
51487: IFFALSE 51674
// begin if not mc_build_list [ i ] then
51489: LD_EXP 99
51493: PUSH
51494: LD_VAR 0 4
51498: ARRAY
51499: NOT
51500: IFFALSE 51504
// continue ;
51502: GO 51486
// for j := 1 to mc_build_list [ i ] do
51504: LD_ADDR_VAR 0 5
51508: PUSH
51509: DOUBLE
51510: LD_INT 1
51512: DEC
51513: ST_TO_ADDR
51514: LD_EXP 99
51518: PUSH
51519: LD_VAR 0 4
51523: ARRAY
51524: PUSH
51525: FOR_TO
51526: IFFALSE 51670
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51528: LD_VAR 0 6
51532: PUSH
51533: LD_VAR 0 7
51537: PUSH
51538: LD_VAR 0 8
51542: PUSH
51543: LD_VAR 0 9
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: LIST
51552: LIST
51553: PPUSH
51554: LD_EXP 99
51558: PUSH
51559: LD_VAR 0 4
51563: ARRAY
51564: PUSH
51565: LD_VAR 0 5
51569: ARRAY
51570: PPUSH
51571: CALL 63359 0 2
51575: IFFALSE 51668
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51577: LD_ADDR_EXP 99
51581: PUSH
51582: LD_EXP 99
51586: PPUSH
51587: LD_VAR 0 4
51591: PPUSH
51592: LD_EXP 99
51596: PUSH
51597: LD_VAR 0 4
51601: ARRAY
51602: PPUSH
51603: LD_VAR 0 5
51607: PPUSH
51608: CALL_OW 3
51612: PPUSH
51613: CALL_OW 1
51617: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51618: LD_ADDR_EXP 101
51622: PUSH
51623: LD_EXP 101
51627: PPUSH
51628: LD_VAR 0 4
51632: PUSH
51633: LD_EXP 101
51637: PUSH
51638: LD_VAR 0 4
51642: ARRAY
51643: PUSH
51644: LD_INT 1
51646: PLUS
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PPUSH
51652: LD_VAR 0 1
51656: PPUSH
51657: CALL 57177 0 3
51661: ST_TO_ADDR
// exit ;
51662: POP
51663: POP
51664: POP
51665: POP
51666: GO 51676
// end ;
51668: GO 51525
51670: POP
51671: POP
// end ;
51672: GO 51486
51674: POP
51675: POP
// end ;
51676: LD_VAR 0 3
51680: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51681: LD_INT 0
51683: PPUSH
51684: PPUSH
51685: PPUSH
// if not mc_bases or not skirmish then
51686: LD_EXP 94
51690: NOT
51691: PUSH
51692: LD_EXP 92
51696: NOT
51697: OR
51698: IFFALSE 51702
// exit ;
51700: GO 51892
// for i = 1 to mc_bases do
51702: LD_ADDR_VAR 0 4
51706: PUSH
51707: DOUBLE
51708: LD_INT 1
51710: DEC
51711: ST_TO_ADDR
51712: LD_EXP 94
51716: PUSH
51717: FOR_TO
51718: IFFALSE 51805
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51720: LD_VAR 0 1
51724: PUSH
51725: LD_EXP 102
51729: PUSH
51730: LD_VAR 0 4
51734: ARRAY
51735: IN
51736: PUSH
51737: LD_VAR 0 1
51741: PUSH
51742: LD_EXP 103
51746: PUSH
51747: LD_VAR 0 4
51751: ARRAY
51752: IN
51753: NOT
51754: AND
51755: IFFALSE 51803
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51757: LD_ADDR_EXP 103
51761: PUSH
51762: LD_EXP 103
51766: PPUSH
51767: LD_VAR 0 4
51771: PUSH
51772: LD_EXP 103
51776: PUSH
51777: LD_VAR 0 4
51781: ARRAY
51782: PUSH
51783: LD_INT 1
51785: PLUS
51786: PUSH
51787: EMPTY
51788: LIST
51789: LIST
51790: PPUSH
51791: LD_VAR 0 1
51795: PPUSH
51796: CALL 57177 0 3
51800: ST_TO_ADDR
// break ;
51801: GO 51805
// end ; end ;
51803: GO 51717
51805: POP
51806: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51807: LD_VAR 0 1
51811: PPUSH
51812: CALL_OW 257
51816: PUSH
51817: LD_EXP 120
51821: IN
51822: PUSH
51823: LD_VAR 0 1
51827: PPUSH
51828: CALL_OW 266
51832: PUSH
51833: LD_INT 5
51835: EQUAL
51836: AND
51837: PUSH
51838: LD_VAR 0 2
51842: PPUSH
51843: CALL_OW 110
51847: PUSH
51848: LD_INT 18
51850: NONEQUAL
51851: AND
51852: IFFALSE 51892
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51854: LD_VAR 0 2
51858: PPUSH
51859: CALL_OW 257
51863: PUSH
51864: LD_INT 5
51866: PUSH
51867: LD_INT 8
51869: PUSH
51870: LD_INT 9
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: LIST
51877: IN
51878: IFFALSE 51892
// SetClass ( unit , 1 ) ;
51880: LD_VAR 0 2
51884: PPUSH
51885: LD_INT 1
51887: PPUSH
51888: CALL_OW 336
// end ;
51892: LD_VAR 0 3
51896: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51897: LD_INT 0
51899: PPUSH
51900: PPUSH
// if not mc_bases or not skirmish then
51901: LD_EXP 94
51905: NOT
51906: PUSH
51907: LD_EXP 92
51911: NOT
51912: OR
51913: IFFALSE 51917
// exit ;
51915: GO 52033
// if GetLives ( abandoned_vehicle ) > 250 then
51917: LD_VAR 0 2
51921: PPUSH
51922: CALL_OW 256
51926: PUSH
51927: LD_INT 250
51929: GREATER
51930: IFFALSE 51934
// exit ;
51932: GO 52033
// for i = 1 to mc_bases do
51934: LD_ADDR_VAR 0 6
51938: PUSH
51939: DOUBLE
51940: LD_INT 1
51942: DEC
51943: ST_TO_ADDR
51944: LD_EXP 94
51948: PUSH
51949: FOR_TO
51950: IFFALSE 52031
// begin if driver in mc_bases [ i ] then
51952: LD_VAR 0 1
51956: PUSH
51957: LD_EXP 94
51961: PUSH
51962: LD_VAR 0 6
51966: ARRAY
51967: IN
51968: IFFALSE 52029
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51970: LD_VAR 0 1
51974: PPUSH
51975: LD_EXP 94
51979: PUSH
51980: LD_VAR 0 6
51984: ARRAY
51985: PPUSH
51986: LD_INT 2
51988: PUSH
51989: LD_INT 30
51991: PUSH
51992: LD_INT 0
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PUSH
51999: LD_INT 30
52001: PUSH
52002: LD_INT 1
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: LIST
52013: PPUSH
52014: CALL_OW 72
52018: PUSH
52019: LD_INT 1
52021: ARRAY
52022: PPUSH
52023: CALL 90316 0 2
// break ;
52027: GO 52031
// end ; end ;
52029: GO 51949
52031: POP
52032: POP
// end ; end_of_file
52033: LD_VAR 0 5
52037: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52038: LD_INT 0
52040: PPUSH
52041: PPUSH
// if exist_mode then
52042: LD_VAR 0 2
52046: IFFALSE 52071
// unit := CreateCharacter ( prefix & ident ) else
52048: LD_ADDR_VAR 0 5
52052: PUSH
52053: LD_VAR 0 3
52057: PUSH
52058: LD_VAR 0 1
52062: STR
52063: PPUSH
52064: CALL_OW 34
52068: ST_TO_ADDR
52069: GO 52086
// unit := NewCharacter ( ident ) ;
52071: LD_ADDR_VAR 0 5
52075: PUSH
52076: LD_VAR 0 1
52080: PPUSH
52081: CALL_OW 25
52085: ST_TO_ADDR
// result := unit ;
52086: LD_ADDR_VAR 0 4
52090: PUSH
52091: LD_VAR 0 5
52095: ST_TO_ADDR
// end ;
52096: LD_VAR 0 4
52100: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52101: LD_INT 0
52103: PPUSH
52104: PPUSH
// if not side or not nation then
52105: LD_VAR 0 1
52109: NOT
52110: PUSH
52111: LD_VAR 0 2
52115: NOT
52116: OR
52117: IFFALSE 52121
// exit ;
52119: GO 52889
// case nation of nation_american :
52121: LD_VAR 0 2
52125: PUSH
52126: LD_INT 1
52128: DOUBLE
52129: EQUAL
52130: IFTRUE 52134
52132: GO 52348
52134: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52135: LD_ADDR_VAR 0 4
52139: PUSH
52140: LD_INT 35
52142: PUSH
52143: LD_INT 45
52145: PUSH
52146: LD_INT 46
52148: PUSH
52149: LD_INT 47
52151: PUSH
52152: LD_INT 82
52154: PUSH
52155: LD_INT 83
52157: PUSH
52158: LD_INT 84
52160: PUSH
52161: LD_INT 85
52163: PUSH
52164: LD_INT 86
52166: PUSH
52167: LD_INT 1
52169: PUSH
52170: LD_INT 2
52172: PUSH
52173: LD_INT 6
52175: PUSH
52176: LD_INT 15
52178: PUSH
52179: LD_INT 16
52181: PUSH
52182: LD_INT 7
52184: PUSH
52185: LD_INT 12
52187: PUSH
52188: LD_INT 13
52190: PUSH
52191: LD_INT 10
52193: PUSH
52194: LD_INT 14
52196: PUSH
52197: LD_INT 20
52199: PUSH
52200: LD_INT 21
52202: PUSH
52203: LD_INT 22
52205: PUSH
52206: LD_INT 25
52208: PUSH
52209: LD_INT 32
52211: PUSH
52212: LD_INT 27
52214: PUSH
52215: LD_INT 36
52217: PUSH
52218: LD_INT 69
52220: PUSH
52221: LD_INT 39
52223: PUSH
52224: LD_INT 34
52226: PUSH
52227: LD_INT 40
52229: PUSH
52230: LD_INT 48
52232: PUSH
52233: LD_INT 49
52235: PUSH
52236: LD_INT 50
52238: PUSH
52239: LD_INT 51
52241: PUSH
52242: LD_INT 52
52244: PUSH
52245: LD_INT 53
52247: PUSH
52248: LD_INT 54
52250: PUSH
52251: LD_INT 55
52253: PUSH
52254: LD_INT 56
52256: PUSH
52257: LD_INT 57
52259: PUSH
52260: LD_INT 58
52262: PUSH
52263: LD_INT 59
52265: PUSH
52266: LD_INT 60
52268: PUSH
52269: LD_INT 61
52271: PUSH
52272: LD_INT 62
52274: PUSH
52275: LD_INT 80
52277: PUSH
52278: LD_INT 82
52280: PUSH
52281: LD_INT 83
52283: PUSH
52284: LD_INT 84
52286: PUSH
52287: LD_INT 85
52289: PUSH
52290: LD_INT 86
52292: PUSH
52293: EMPTY
52294: LIST
52295: LIST
52296: LIST
52297: LIST
52298: LIST
52299: LIST
52300: LIST
52301: LIST
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: LIST
52345: ST_TO_ADDR
52346: GO 52813
52348: LD_INT 2
52350: DOUBLE
52351: EQUAL
52352: IFTRUE 52356
52354: GO 52582
52356: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52357: LD_ADDR_VAR 0 4
52361: PUSH
52362: LD_INT 35
52364: PUSH
52365: LD_INT 45
52367: PUSH
52368: LD_INT 46
52370: PUSH
52371: LD_INT 47
52373: PUSH
52374: LD_INT 82
52376: PUSH
52377: LD_INT 83
52379: PUSH
52380: LD_INT 84
52382: PUSH
52383: LD_INT 85
52385: PUSH
52386: LD_INT 87
52388: PUSH
52389: LD_INT 70
52391: PUSH
52392: LD_INT 1
52394: PUSH
52395: LD_INT 11
52397: PUSH
52398: LD_INT 3
52400: PUSH
52401: LD_INT 4
52403: PUSH
52404: LD_INT 5
52406: PUSH
52407: LD_INT 6
52409: PUSH
52410: LD_INT 15
52412: PUSH
52413: LD_INT 18
52415: PUSH
52416: LD_INT 7
52418: PUSH
52419: LD_INT 17
52421: PUSH
52422: LD_INT 8
52424: PUSH
52425: LD_INT 20
52427: PUSH
52428: LD_INT 21
52430: PUSH
52431: LD_INT 22
52433: PUSH
52434: LD_INT 72
52436: PUSH
52437: LD_INT 26
52439: PUSH
52440: LD_INT 69
52442: PUSH
52443: LD_INT 39
52445: PUSH
52446: LD_INT 40
52448: PUSH
52449: LD_INT 41
52451: PUSH
52452: LD_INT 42
52454: PUSH
52455: LD_INT 43
52457: PUSH
52458: LD_INT 48
52460: PUSH
52461: LD_INT 49
52463: PUSH
52464: LD_INT 50
52466: PUSH
52467: LD_INT 51
52469: PUSH
52470: LD_INT 52
52472: PUSH
52473: LD_INT 53
52475: PUSH
52476: LD_INT 54
52478: PUSH
52479: LD_INT 55
52481: PUSH
52482: LD_INT 56
52484: PUSH
52485: LD_INT 60
52487: PUSH
52488: LD_INT 61
52490: PUSH
52491: LD_INT 62
52493: PUSH
52494: LD_INT 66
52496: PUSH
52497: LD_INT 67
52499: PUSH
52500: LD_INT 68
52502: PUSH
52503: LD_INT 81
52505: PUSH
52506: LD_INT 82
52508: PUSH
52509: LD_INT 83
52511: PUSH
52512: LD_INT 84
52514: PUSH
52515: LD_INT 85
52517: PUSH
52518: LD_INT 87
52520: PUSH
52521: LD_INT 88
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: LIST
52540: LIST
52541: LIST
52542: LIST
52543: LIST
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: LIST
52578: LIST
52579: ST_TO_ADDR
52580: GO 52813
52582: LD_INT 3
52584: DOUBLE
52585: EQUAL
52586: IFTRUE 52590
52588: GO 52812
52590: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: LD_INT 46
52598: PUSH
52599: LD_INT 47
52601: PUSH
52602: LD_INT 1
52604: PUSH
52605: LD_INT 2
52607: PUSH
52608: LD_INT 82
52610: PUSH
52611: LD_INT 83
52613: PUSH
52614: LD_INT 84
52616: PUSH
52617: LD_INT 85
52619: PUSH
52620: LD_INT 86
52622: PUSH
52623: LD_INT 11
52625: PUSH
52626: LD_INT 9
52628: PUSH
52629: LD_INT 20
52631: PUSH
52632: LD_INT 19
52634: PUSH
52635: LD_INT 21
52637: PUSH
52638: LD_INT 24
52640: PUSH
52641: LD_INT 22
52643: PUSH
52644: LD_INT 25
52646: PUSH
52647: LD_INT 28
52649: PUSH
52650: LD_INT 29
52652: PUSH
52653: LD_INT 30
52655: PUSH
52656: LD_INT 31
52658: PUSH
52659: LD_INT 37
52661: PUSH
52662: LD_INT 38
52664: PUSH
52665: LD_INT 32
52667: PUSH
52668: LD_INT 27
52670: PUSH
52671: LD_INT 33
52673: PUSH
52674: LD_INT 69
52676: PUSH
52677: LD_INT 39
52679: PUSH
52680: LD_INT 34
52682: PUSH
52683: LD_INT 40
52685: PUSH
52686: LD_INT 71
52688: PUSH
52689: LD_INT 23
52691: PUSH
52692: LD_INT 44
52694: PUSH
52695: LD_INT 48
52697: PUSH
52698: LD_INT 49
52700: PUSH
52701: LD_INT 50
52703: PUSH
52704: LD_INT 51
52706: PUSH
52707: LD_INT 52
52709: PUSH
52710: LD_INT 53
52712: PUSH
52713: LD_INT 54
52715: PUSH
52716: LD_INT 55
52718: PUSH
52719: LD_INT 56
52721: PUSH
52722: LD_INT 57
52724: PUSH
52725: LD_INT 58
52727: PUSH
52728: LD_INT 59
52730: PUSH
52731: LD_INT 63
52733: PUSH
52734: LD_INT 64
52736: PUSH
52737: LD_INT 65
52739: PUSH
52740: LD_INT 82
52742: PUSH
52743: LD_INT 83
52745: PUSH
52746: LD_INT 84
52748: PUSH
52749: LD_INT 85
52751: PUSH
52752: LD_INT 86
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: LIST
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: LIST
52802: LIST
52803: LIST
52804: LIST
52805: LIST
52806: LIST
52807: LIST
52808: LIST
52809: ST_TO_ADDR
52810: GO 52813
52812: POP
// if state > - 1 and state < 3 then
52813: LD_VAR 0 3
52817: PUSH
52818: LD_INT 1
52820: NEG
52821: GREATER
52822: PUSH
52823: LD_VAR 0 3
52827: PUSH
52828: LD_INT 3
52830: LESS
52831: AND
52832: IFFALSE 52889
// for i in result do
52834: LD_ADDR_VAR 0 5
52838: PUSH
52839: LD_VAR 0 4
52843: PUSH
52844: FOR_IN
52845: IFFALSE 52887
// if GetTech ( i , side ) <> state then
52847: LD_VAR 0 5
52851: PPUSH
52852: LD_VAR 0 1
52856: PPUSH
52857: CALL_OW 321
52861: PUSH
52862: LD_VAR 0 3
52866: NONEQUAL
52867: IFFALSE 52885
// result := result diff i ;
52869: LD_ADDR_VAR 0 4
52873: PUSH
52874: LD_VAR 0 4
52878: PUSH
52879: LD_VAR 0 5
52883: DIFF
52884: ST_TO_ADDR
52885: GO 52844
52887: POP
52888: POP
// end ;
52889: LD_VAR 0 4
52893: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52894: LD_INT 0
52896: PPUSH
52897: PPUSH
52898: PPUSH
// result := true ;
52899: LD_ADDR_VAR 0 3
52903: PUSH
52904: LD_INT 1
52906: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52907: LD_ADDR_VAR 0 5
52911: PUSH
52912: LD_VAR 0 2
52916: PPUSH
52917: CALL_OW 480
52921: ST_TO_ADDR
// if not tmp then
52922: LD_VAR 0 5
52926: NOT
52927: IFFALSE 52931
// exit ;
52929: GO 52980
// for i in tmp do
52931: LD_ADDR_VAR 0 4
52935: PUSH
52936: LD_VAR 0 5
52940: PUSH
52941: FOR_IN
52942: IFFALSE 52978
// if GetTech ( i , side ) <> state_researched then
52944: LD_VAR 0 4
52948: PPUSH
52949: LD_VAR 0 1
52953: PPUSH
52954: CALL_OW 321
52958: PUSH
52959: LD_INT 2
52961: NONEQUAL
52962: IFFALSE 52976
// begin result := false ;
52964: LD_ADDR_VAR 0 3
52968: PUSH
52969: LD_INT 0
52971: ST_TO_ADDR
// exit ;
52972: POP
52973: POP
52974: GO 52980
// end ;
52976: GO 52941
52978: POP
52979: POP
// end ;
52980: LD_VAR 0 3
52984: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52985: LD_INT 0
52987: PPUSH
52988: PPUSH
52989: PPUSH
52990: PPUSH
52991: PPUSH
52992: PPUSH
52993: PPUSH
52994: PPUSH
52995: PPUSH
52996: PPUSH
52997: PPUSH
52998: PPUSH
52999: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53000: LD_VAR 0 1
53004: NOT
53005: PUSH
53006: LD_VAR 0 1
53010: PPUSH
53011: CALL_OW 257
53015: PUSH
53016: LD_INT 9
53018: NONEQUAL
53019: OR
53020: IFFALSE 53024
// exit ;
53022: GO 53597
// side := GetSide ( unit ) ;
53024: LD_ADDR_VAR 0 9
53028: PUSH
53029: LD_VAR 0 1
53033: PPUSH
53034: CALL_OW 255
53038: ST_TO_ADDR
// tech_space := tech_spacanom ;
53039: LD_ADDR_VAR 0 12
53043: PUSH
53044: LD_INT 29
53046: ST_TO_ADDR
// tech_time := tech_taurad ;
53047: LD_ADDR_VAR 0 13
53051: PUSH
53052: LD_INT 28
53054: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53055: LD_ADDR_VAR 0 11
53059: PUSH
53060: LD_VAR 0 1
53064: PPUSH
53065: CALL_OW 310
53069: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53070: LD_VAR 0 11
53074: PPUSH
53075: CALL_OW 247
53079: PUSH
53080: LD_INT 2
53082: EQUAL
53083: IFFALSE 53087
// exit ;
53085: GO 53597
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53087: LD_ADDR_VAR 0 8
53091: PUSH
53092: LD_INT 81
53094: PUSH
53095: LD_VAR 0 9
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: PUSH
53104: LD_INT 3
53106: PUSH
53107: LD_INT 21
53109: PUSH
53110: LD_INT 3
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PPUSH
53125: CALL_OW 69
53129: ST_TO_ADDR
// if not tmp then
53130: LD_VAR 0 8
53134: NOT
53135: IFFALSE 53139
// exit ;
53137: GO 53597
// if in_unit then
53139: LD_VAR 0 11
53143: IFFALSE 53167
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53145: LD_ADDR_VAR 0 10
53149: PUSH
53150: LD_VAR 0 8
53154: PPUSH
53155: LD_VAR 0 11
53159: PPUSH
53160: CALL_OW 74
53164: ST_TO_ADDR
53165: GO 53187
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53167: LD_ADDR_VAR 0 10
53171: PUSH
53172: LD_VAR 0 8
53176: PPUSH
53177: LD_VAR 0 1
53181: PPUSH
53182: CALL_OW 74
53186: ST_TO_ADDR
// if not enemy then
53187: LD_VAR 0 10
53191: NOT
53192: IFFALSE 53196
// exit ;
53194: GO 53597
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53196: LD_VAR 0 11
53200: PUSH
53201: LD_VAR 0 11
53205: PPUSH
53206: LD_VAR 0 10
53210: PPUSH
53211: CALL_OW 296
53215: PUSH
53216: LD_INT 13
53218: GREATER
53219: AND
53220: PUSH
53221: LD_VAR 0 1
53225: PPUSH
53226: LD_VAR 0 10
53230: PPUSH
53231: CALL_OW 296
53235: PUSH
53236: LD_INT 12
53238: GREATER
53239: OR
53240: IFFALSE 53244
// exit ;
53242: GO 53597
// missile := [ 1 ] ;
53244: LD_ADDR_VAR 0 14
53248: PUSH
53249: LD_INT 1
53251: PUSH
53252: EMPTY
53253: LIST
53254: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53255: LD_VAR 0 9
53259: PPUSH
53260: LD_VAR 0 12
53264: PPUSH
53265: CALL_OW 325
53269: IFFALSE 53298
// missile := Replace ( missile , missile + 1 , 2 ) ;
53271: LD_ADDR_VAR 0 14
53275: PUSH
53276: LD_VAR 0 14
53280: PPUSH
53281: LD_VAR 0 14
53285: PUSH
53286: LD_INT 1
53288: PLUS
53289: PPUSH
53290: LD_INT 2
53292: PPUSH
53293: CALL_OW 1
53297: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53298: LD_VAR 0 9
53302: PPUSH
53303: LD_VAR 0 13
53307: PPUSH
53308: CALL_OW 325
53312: PUSH
53313: LD_VAR 0 10
53317: PPUSH
53318: CALL_OW 255
53322: PPUSH
53323: LD_VAR 0 13
53327: PPUSH
53328: CALL_OW 325
53332: NOT
53333: AND
53334: IFFALSE 53363
// missile := Replace ( missile , missile + 1 , 3 ) ;
53336: LD_ADDR_VAR 0 14
53340: PUSH
53341: LD_VAR 0 14
53345: PPUSH
53346: LD_VAR 0 14
53350: PUSH
53351: LD_INT 1
53353: PLUS
53354: PPUSH
53355: LD_INT 3
53357: PPUSH
53358: CALL_OW 1
53362: ST_TO_ADDR
// if missile < 2 then
53363: LD_VAR 0 14
53367: PUSH
53368: LD_INT 2
53370: LESS
53371: IFFALSE 53375
// exit ;
53373: GO 53597
// x := GetX ( enemy ) ;
53375: LD_ADDR_VAR 0 4
53379: PUSH
53380: LD_VAR 0 10
53384: PPUSH
53385: CALL_OW 250
53389: ST_TO_ADDR
// y := GetY ( enemy ) ;
53390: LD_ADDR_VAR 0 5
53394: PUSH
53395: LD_VAR 0 10
53399: PPUSH
53400: CALL_OW 251
53404: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53405: LD_ADDR_VAR 0 6
53409: PUSH
53410: LD_VAR 0 4
53414: PUSH
53415: LD_INT 1
53417: NEG
53418: PPUSH
53419: LD_INT 1
53421: PPUSH
53422: CALL_OW 12
53426: PLUS
53427: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53428: LD_ADDR_VAR 0 7
53432: PUSH
53433: LD_VAR 0 5
53437: PUSH
53438: LD_INT 1
53440: NEG
53441: PPUSH
53442: LD_INT 1
53444: PPUSH
53445: CALL_OW 12
53449: PLUS
53450: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53451: LD_VAR 0 6
53455: PPUSH
53456: LD_VAR 0 7
53460: PPUSH
53461: CALL_OW 488
53465: NOT
53466: IFFALSE 53488
// begin _x := x ;
53468: LD_ADDR_VAR 0 6
53472: PUSH
53473: LD_VAR 0 4
53477: ST_TO_ADDR
// _y := y ;
53478: LD_ADDR_VAR 0 7
53482: PUSH
53483: LD_VAR 0 5
53487: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 1
53495: PPUSH
53496: LD_VAR 0 14
53500: PPUSH
53501: CALL_OW 12
53505: ST_TO_ADDR
// case i of 1 :
53506: LD_VAR 0 3
53510: PUSH
53511: LD_INT 1
53513: DOUBLE
53514: EQUAL
53515: IFTRUE 53519
53517: GO 53536
53519: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53520: LD_VAR 0 1
53524: PPUSH
53525: LD_VAR 0 10
53529: PPUSH
53530: CALL_OW 115
53534: GO 53597
53536: LD_INT 2
53538: DOUBLE
53539: EQUAL
53540: IFTRUE 53544
53542: GO 53566
53544: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53545: LD_VAR 0 1
53549: PPUSH
53550: LD_VAR 0 6
53554: PPUSH
53555: LD_VAR 0 7
53559: PPUSH
53560: CALL_OW 153
53564: GO 53597
53566: LD_INT 3
53568: DOUBLE
53569: EQUAL
53570: IFTRUE 53574
53572: GO 53596
53574: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53575: LD_VAR 0 1
53579: PPUSH
53580: LD_VAR 0 6
53584: PPUSH
53585: LD_VAR 0 7
53589: PPUSH
53590: CALL_OW 154
53594: GO 53597
53596: POP
// end ;
53597: LD_VAR 0 2
53601: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53602: LD_INT 0
53604: PPUSH
53605: PPUSH
53606: PPUSH
53607: PPUSH
53608: PPUSH
53609: PPUSH
// if not unit or not building then
53610: LD_VAR 0 1
53614: NOT
53615: PUSH
53616: LD_VAR 0 2
53620: NOT
53621: OR
53622: IFFALSE 53626
// exit ;
53624: GO 53784
// x := GetX ( building ) ;
53626: LD_ADDR_VAR 0 5
53630: PUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: CALL_OW 250
53640: ST_TO_ADDR
// y := GetY ( building ) ;
53641: LD_ADDR_VAR 0 6
53645: PUSH
53646: LD_VAR 0 2
53650: PPUSH
53651: CALL_OW 251
53655: ST_TO_ADDR
// for i = 0 to 5 do
53656: LD_ADDR_VAR 0 4
53660: PUSH
53661: DOUBLE
53662: LD_INT 0
53664: DEC
53665: ST_TO_ADDR
53666: LD_INT 5
53668: PUSH
53669: FOR_TO
53670: IFFALSE 53782
// begin _x := ShiftX ( x , i , 3 ) ;
53672: LD_ADDR_VAR 0 7
53676: PUSH
53677: LD_VAR 0 5
53681: PPUSH
53682: LD_VAR 0 4
53686: PPUSH
53687: LD_INT 3
53689: PPUSH
53690: CALL_OW 272
53694: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53695: LD_ADDR_VAR 0 8
53699: PUSH
53700: LD_VAR 0 6
53704: PPUSH
53705: LD_VAR 0 4
53709: PPUSH
53710: LD_INT 3
53712: PPUSH
53713: CALL_OW 273
53717: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53718: LD_VAR 0 7
53722: PPUSH
53723: LD_VAR 0 8
53727: PPUSH
53728: CALL_OW 488
53732: NOT
53733: IFFALSE 53737
// continue ;
53735: GO 53669
// if HexInfo ( _x , _y ) = 0 then
53737: LD_VAR 0 7
53741: PPUSH
53742: LD_VAR 0 8
53746: PPUSH
53747: CALL_OW 428
53751: PUSH
53752: LD_INT 0
53754: EQUAL
53755: IFFALSE 53780
// begin ComMoveXY ( unit , _x , _y ) ;
53757: LD_VAR 0 1
53761: PPUSH
53762: LD_VAR 0 7
53766: PPUSH
53767: LD_VAR 0 8
53771: PPUSH
53772: CALL_OW 111
// exit ;
53776: POP
53777: POP
53778: GO 53784
// end ; end ;
53780: GO 53669
53782: POP
53783: POP
// end ;
53784: LD_VAR 0 3
53788: RET
// export function ScanBase ( side , base_area ) ; begin
53789: LD_INT 0
53791: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53792: LD_ADDR_VAR 0 3
53796: PUSH
53797: LD_VAR 0 2
53801: PPUSH
53802: LD_INT 81
53804: PUSH
53805: LD_VAR 0 1
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PPUSH
53814: CALL_OW 70
53818: ST_TO_ADDR
// end ;
53819: LD_VAR 0 3
53823: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53824: LD_INT 0
53826: PPUSH
53827: PPUSH
53828: PPUSH
53829: PPUSH
// result := false ;
53830: LD_ADDR_VAR 0 2
53834: PUSH
53835: LD_INT 0
53837: ST_TO_ADDR
// side := GetSide ( unit ) ;
53838: LD_ADDR_VAR 0 3
53842: PUSH
53843: LD_VAR 0 1
53847: PPUSH
53848: CALL_OW 255
53852: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53853: LD_ADDR_VAR 0 4
53857: PUSH
53858: LD_VAR 0 1
53862: PPUSH
53863: CALL_OW 248
53867: ST_TO_ADDR
// case nat of 1 :
53868: LD_VAR 0 4
53872: PUSH
53873: LD_INT 1
53875: DOUBLE
53876: EQUAL
53877: IFTRUE 53881
53879: GO 53892
53881: POP
// tech := tech_lassight ; 2 :
53882: LD_ADDR_VAR 0 5
53886: PUSH
53887: LD_INT 12
53889: ST_TO_ADDR
53890: GO 53931
53892: LD_INT 2
53894: DOUBLE
53895: EQUAL
53896: IFTRUE 53900
53898: GO 53911
53900: POP
// tech := tech_mortar ; 3 :
53901: LD_ADDR_VAR 0 5
53905: PUSH
53906: LD_INT 41
53908: ST_TO_ADDR
53909: GO 53931
53911: LD_INT 3
53913: DOUBLE
53914: EQUAL
53915: IFTRUE 53919
53917: GO 53930
53919: POP
// tech := tech_bazooka ; end ;
53920: LD_ADDR_VAR 0 5
53924: PUSH
53925: LD_INT 44
53927: ST_TO_ADDR
53928: GO 53931
53930: POP
// if Researched ( side , tech ) then
53931: LD_VAR 0 3
53935: PPUSH
53936: LD_VAR 0 5
53940: PPUSH
53941: CALL_OW 325
53945: IFFALSE 53972
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53947: LD_ADDR_VAR 0 2
53951: PUSH
53952: LD_INT 5
53954: PUSH
53955: LD_INT 8
53957: PUSH
53958: LD_INT 9
53960: PUSH
53961: EMPTY
53962: LIST
53963: LIST
53964: LIST
53965: PUSH
53966: LD_VAR 0 4
53970: ARRAY
53971: ST_TO_ADDR
// end ;
53972: LD_VAR 0 2
53976: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53977: LD_INT 0
53979: PPUSH
53980: PPUSH
53981: PPUSH
// if not mines then
53982: LD_VAR 0 2
53986: NOT
53987: IFFALSE 53991
// exit ;
53989: GO 54135
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53991: LD_ADDR_VAR 0 5
53995: PUSH
53996: LD_INT 81
53998: PUSH
53999: LD_VAR 0 1
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: PUSH
54008: LD_INT 3
54010: PUSH
54011: LD_INT 21
54013: PUSH
54014: LD_INT 3
54016: PUSH
54017: EMPTY
54018: LIST
54019: LIST
54020: PUSH
54021: EMPTY
54022: LIST
54023: LIST
54024: PUSH
54025: EMPTY
54026: LIST
54027: LIST
54028: PPUSH
54029: CALL_OW 69
54033: ST_TO_ADDR
// for i in mines do
54034: LD_ADDR_VAR 0 4
54038: PUSH
54039: LD_VAR 0 2
54043: PUSH
54044: FOR_IN
54045: IFFALSE 54133
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54047: LD_VAR 0 4
54051: PUSH
54052: LD_INT 1
54054: ARRAY
54055: PPUSH
54056: LD_VAR 0 4
54060: PUSH
54061: LD_INT 2
54063: ARRAY
54064: PPUSH
54065: CALL_OW 458
54069: NOT
54070: IFFALSE 54074
// continue ;
54072: GO 54044
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54074: LD_VAR 0 4
54078: PUSH
54079: LD_INT 1
54081: ARRAY
54082: PPUSH
54083: LD_VAR 0 4
54087: PUSH
54088: LD_INT 2
54090: ARRAY
54091: PPUSH
54092: CALL_OW 428
54096: PUSH
54097: LD_VAR 0 5
54101: IN
54102: IFFALSE 54131
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54104: LD_VAR 0 4
54108: PUSH
54109: LD_INT 1
54111: ARRAY
54112: PPUSH
54113: LD_VAR 0 4
54117: PUSH
54118: LD_INT 2
54120: ARRAY
54121: PPUSH
54122: LD_VAR 0 1
54126: PPUSH
54127: CALL_OW 456
// end ;
54131: GO 54044
54133: POP
54134: POP
// end ;
54135: LD_VAR 0 3
54139: RET
// export function Count ( array ) ; var i ; begin
54140: LD_INT 0
54142: PPUSH
54143: PPUSH
// result := 0 ;
54144: LD_ADDR_VAR 0 2
54148: PUSH
54149: LD_INT 0
54151: ST_TO_ADDR
// for i in array do
54152: LD_ADDR_VAR 0 3
54156: PUSH
54157: LD_VAR 0 1
54161: PUSH
54162: FOR_IN
54163: IFFALSE 54187
// if i then
54165: LD_VAR 0 3
54169: IFFALSE 54185
// result := result + 1 ;
54171: LD_ADDR_VAR 0 2
54175: PUSH
54176: LD_VAR 0 2
54180: PUSH
54181: LD_INT 1
54183: PLUS
54184: ST_TO_ADDR
54185: GO 54162
54187: POP
54188: POP
// end ;
54189: LD_VAR 0 2
54193: RET
// export function IsEmpty ( building ) ; begin
54194: LD_INT 0
54196: PPUSH
// if not building then
54197: LD_VAR 0 1
54201: NOT
54202: IFFALSE 54206
// exit ;
54204: GO 54249
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54206: LD_ADDR_VAR 0 2
54210: PUSH
54211: LD_VAR 0 1
54215: PUSH
54216: LD_INT 22
54218: PUSH
54219: LD_VAR 0 1
54223: PPUSH
54224: CALL_OW 255
54228: PUSH
54229: EMPTY
54230: LIST
54231: LIST
54232: PUSH
54233: LD_INT 58
54235: PUSH
54236: EMPTY
54237: LIST
54238: PUSH
54239: EMPTY
54240: LIST
54241: LIST
54242: PPUSH
54243: CALL_OW 69
54247: IN
54248: ST_TO_ADDR
// end ;
54249: LD_VAR 0 2
54253: RET
// export function IsNotFull ( building ) ; var places ; begin
54254: LD_INT 0
54256: PPUSH
54257: PPUSH
// if not building then
54258: LD_VAR 0 1
54262: NOT
54263: IFFALSE 54267
// exit ;
54265: GO 54438
// result := false ;
54267: LD_ADDR_VAR 0 2
54271: PUSH
54272: LD_INT 0
54274: ST_TO_ADDR
// places := 0 ;
54275: LD_ADDR_VAR 0 3
54279: PUSH
54280: LD_INT 0
54282: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54283: LD_VAR 0 1
54287: PPUSH
54288: CALL_OW 266
54292: PUSH
54293: LD_INT 0
54295: DOUBLE
54296: EQUAL
54297: IFTRUE 54355
54299: LD_INT 1
54301: DOUBLE
54302: EQUAL
54303: IFTRUE 54355
54305: LD_INT 6
54307: DOUBLE
54308: EQUAL
54309: IFTRUE 54355
54311: LD_INT 7
54313: DOUBLE
54314: EQUAL
54315: IFTRUE 54355
54317: LD_INT 8
54319: DOUBLE
54320: EQUAL
54321: IFTRUE 54355
54323: LD_INT 4
54325: DOUBLE
54326: EQUAL
54327: IFTRUE 54355
54329: LD_INT 5
54331: DOUBLE
54332: EQUAL
54333: IFTRUE 54355
54335: LD_INT 2
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54355
54341: LD_INT 3
54343: DOUBLE
54344: EQUAL
54345: IFTRUE 54355
54347: LD_INT 35
54349: DOUBLE
54350: EQUAL
54351: IFTRUE 54355
54353: GO 54366
54355: POP
// places := 6 ; b_bunker , b_breastwork :
54356: LD_ADDR_VAR 0 3
54360: PUSH
54361: LD_INT 6
54363: ST_TO_ADDR
54364: GO 54411
54366: LD_INT 32
54368: DOUBLE
54369: EQUAL
54370: IFTRUE 54380
54372: LD_INT 31
54374: DOUBLE
54375: EQUAL
54376: IFTRUE 54380
54378: GO 54391
54380: POP
// places := 1 ; b_control_tower :
54381: LD_ADDR_VAR 0 3
54385: PUSH
54386: LD_INT 1
54388: ST_TO_ADDR
54389: GO 54411
54391: LD_INT 36
54393: DOUBLE
54394: EQUAL
54395: IFTRUE 54399
54397: GO 54410
54399: POP
// places := 3 ; end ;
54400: LD_ADDR_VAR 0 3
54404: PUSH
54405: LD_INT 3
54407: ST_TO_ADDR
54408: GO 54411
54410: POP
// if places then
54411: LD_VAR 0 3
54415: IFFALSE 54438
// result := UnitsInside ( building ) < places ;
54417: LD_ADDR_VAR 0 2
54421: PUSH
54422: LD_VAR 0 1
54426: PPUSH
54427: CALL_OW 313
54431: PUSH
54432: LD_VAR 0 3
54436: LESS
54437: ST_TO_ADDR
// end ;
54438: LD_VAR 0 2
54442: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54443: LD_INT 0
54445: PPUSH
54446: PPUSH
54447: PPUSH
54448: PPUSH
// tmp := [ ] ;
54449: LD_ADDR_VAR 0 3
54453: PUSH
54454: EMPTY
54455: ST_TO_ADDR
// list := [ ] ;
54456: LD_ADDR_VAR 0 5
54460: PUSH
54461: EMPTY
54462: ST_TO_ADDR
// for i = 16 to 25 do
54463: LD_ADDR_VAR 0 4
54467: PUSH
54468: DOUBLE
54469: LD_INT 16
54471: DEC
54472: ST_TO_ADDR
54473: LD_INT 25
54475: PUSH
54476: FOR_TO
54477: IFFALSE 54550
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54479: LD_ADDR_VAR 0 3
54483: PUSH
54484: LD_VAR 0 3
54488: PUSH
54489: LD_INT 22
54491: PUSH
54492: LD_VAR 0 1
54496: PPUSH
54497: CALL_OW 255
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: PUSH
54506: LD_INT 91
54508: PUSH
54509: LD_VAR 0 1
54513: PUSH
54514: LD_INT 6
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: LIST
54521: PUSH
54522: LD_INT 30
54524: PUSH
54525: LD_VAR 0 4
54529: PUSH
54530: EMPTY
54531: LIST
54532: LIST
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: LIST
54538: PUSH
54539: EMPTY
54540: LIST
54541: PPUSH
54542: CALL_OW 69
54546: ADD
54547: ST_TO_ADDR
54548: GO 54476
54550: POP
54551: POP
// for i = 1 to tmp do
54552: LD_ADDR_VAR 0 4
54556: PUSH
54557: DOUBLE
54558: LD_INT 1
54560: DEC
54561: ST_TO_ADDR
54562: LD_VAR 0 3
54566: PUSH
54567: FOR_TO
54568: IFFALSE 54656
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54570: LD_ADDR_VAR 0 5
54574: PUSH
54575: LD_VAR 0 5
54579: PUSH
54580: LD_VAR 0 3
54584: PUSH
54585: LD_VAR 0 4
54589: ARRAY
54590: PPUSH
54591: CALL_OW 266
54595: PUSH
54596: LD_VAR 0 3
54600: PUSH
54601: LD_VAR 0 4
54605: ARRAY
54606: PPUSH
54607: CALL_OW 250
54611: PUSH
54612: LD_VAR 0 3
54616: PUSH
54617: LD_VAR 0 4
54621: ARRAY
54622: PPUSH
54623: CALL_OW 251
54627: PUSH
54628: LD_VAR 0 3
54632: PUSH
54633: LD_VAR 0 4
54637: ARRAY
54638: PPUSH
54639: CALL_OW 254
54643: PUSH
54644: EMPTY
54645: LIST
54646: LIST
54647: LIST
54648: LIST
54649: PUSH
54650: EMPTY
54651: LIST
54652: ADD
54653: ST_TO_ADDR
54654: GO 54567
54656: POP
54657: POP
// result := list ;
54658: LD_ADDR_VAR 0 2
54662: PUSH
54663: LD_VAR 0 5
54667: ST_TO_ADDR
// end ;
54668: LD_VAR 0 2
54672: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54673: LD_INT 0
54675: PPUSH
54676: PPUSH
54677: PPUSH
54678: PPUSH
54679: PPUSH
54680: PPUSH
54681: PPUSH
// if not factory then
54682: LD_VAR 0 1
54686: NOT
54687: IFFALSE 54691
// exit ;
54689: GO 55284
// if control = control_apeman then
54691: LD_VAR 0 4
54695: PUSH
54696: LD_INT 5
54698: EQUAL
54699: IFFALSE 54808
// begin tmp := UnitsInside ( factory ) ;
54701: LD_ADDR_VAR 0 8
54705: PUSH
54706: LD_VAR 0 1
54710: PPUSH
54711: CALL_OW 313
54715: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54716: LD_VAR 0 8
54720: PPUSH
54721: LD_INT 25
54723: PUSH
54724: LD_INT 12
54726: PUSH
54727: EMPTY
54728: LIST
54729: LIST
54730: PPUSH
54731: CALL_OW 72
54735: NOT
54736: IFFALSE 54746
// control := control_manual ;
54738: LD_ADDR_VAR 0 4
54742: PUSH
54743: LD_INT 1
54745: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54746: LD_ADDR_VAR 0 8
54750: PUSH
54751: LD_VAR 0 1
54755: PPUSH
54756: CALL 54443 0 1
54760: ST_TO_ADDR
// if tmp then
54761: LD_VAR 0 8
54765: IFFALSE 54808
// begin for i in tmp do
54767: LD_ADDR_VAR 0 7
54771: PUSH
54772: LD_VAR 0 8
54776: PUSH
54777: FOR_IN
54778: IFFALSE 54806
// if i [ 1 ] = b_ext_radio then
54780: LD_VAR 0 7
54784: PUSH
54785: LD_INT 1
54787: ARRAY
54788: PUSH
54789: LD_INT 22
54791: EQUAL
54792: IFFALSE 54804
// begin control := control_remote ;
54794: LD_ADDR_VAR 0 4
54798: PUSH
54799: LD_INT 2
54801: ST_TO_ADDR
// break ;
54802: GO 54806
// end ;
54804: GO 54777
54806: POP
54807: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54808: LD_VAR 0 1
54812: PPUSH
54813: LD_VAR 0 2
54817: PPUSH
54818: LD_VAR 0 3
54822: PPUSH
54823: LD_VAR 0 4
54827: PPUSH
54828: LD_VAR 0 5
54832: PPUSH
54833: CALL_OW 448
54837: IFFALSE 54872
// begin result := [ chassis , engine , control , weapon ] ;
54839: LD_ADDR_VAR 0 6
54843: PUSH
54844: LD_VAR 0 2
54848: PUSH
54849: LD_VAR 0 3
54853: PUSH
54854: LD_VAR 0 4
54858: PUSH
54859: LD_VAR 0 5
54863: PUSH
54864: EMPTY
54865: LIST
54866: LIST
54867: LIST
54868: LIST
54869: ST_TO_ADDR
// exit ;
54870: GO 55284
// end ; _chassis := AvailableChassisList ( factory ) ;
54872: LD_ADDR_VAR 0 9
54876: PUSH
54877: LD_VAR 0 1
54881: PPUSH
54882: CALL_OW 475
54886: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54887: LD_ADDR_VAR 0 11
54891: PUSH
54892: LD_VAR 0 1
54896: PPUSH
54897: CALL_OW 476
54901: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54902: LD_ADDR_VAR 0 12
54906: PUSH
54907: LD_VAR 0 1
54911: PPUSH
54912: CALL_OW 477
54916: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54917: LD_ADDR_VAR 0 10
54921: PUSH
54922: LD_VAR 0 1
54926: PPUSH
54927: CALL_OW 478
54931: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54932: LD_VAR 0 9
54936: NOT
54937: PUSH
54938: LD_VAR 0 11
54942: NOT
54943: OR
54944: PUSH
54945: LD_VAR 0 12
54949: NOT
54950: OR
54951: PUSH
54952: LD_VAR 0 10
54956: NOT
54957: OR
54958: IFFALSE 54993
// begin result := [ chassis , engine , control , weapon ] ;
54960: LD_ADDR_VAR 0 6
54964: PUSH
54965: LD_VAR 0 2
54969: PUSH
54970: LD_VAR 0 3
54974: PUSH
54975: LD_VAR 0 4
54979: PUSH
54980: LD_VAR 0 5
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: LIST
54989: LIST
54990: ST_TO_ADDR
// exit ;
54991: GO 55284
// end ; if not chassis in _chassis then
54993: LD_VAR 0 2
54997: PUSH
54998: LD_VAR 0 9
55002: IN
55003: NOT
55004: IFFALSE 55030
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55006: LD_ADDR_VAR 0 2
55010: PUSH
55011: LD_VAR 0 9
55015: PUSH
55016: LD_INT 1
55018: PPUSH
55019: LD_VAR 0 9
55023: PPUSH
55024: CALL_OW 12
55028: ARRAY
55029: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55030: LD_VAR 0 2
55034: PPUSH
55035: LD_VAR 0 3
55039: PPUSH
55040: CALL 55289 0 2
55044: NOT
55045: IFFALSE 55104
// repeat engine := _engine [ 1 ] ;
55047: LD_ADDR_VAR 0 3
55051: PUSH
55052: LD_VAR 0 11
55056: PUSH
55057: LD_INT 1
55059: ARRAY
55060: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55061: LD_ADDR_VAR 0 11
55065: PUSH
55066: LD_VAR 0 11
55070: PPUSH
55071: LD_INT 1
55073: PPUSH
55074: CALL_OW 3
55078: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55079: LD_VAR 0 2
55083: PPUSH
55084: LD_VAR 0 3
55088: PPUSH
55089: CALL 55289 0 2
55093: PUSH
55094: LD_VAR 0 11
55098: PUSH
55099: EMPTY
55100: EQUAL
55101: OR
55102: IFFALSE 55047
// if not control in _control then
55104: LD_VAR 0 4
55108: PUSH
55109: LD_VAR 0 12
55113: IN
55114: NOT
55115: IFFALSE 55141
// control := _control [ rand ( 1 , _control ) ] ;
55117: LD_ADDR_VAR 0 4
55121: PUSH
55122: LD_VAR 0 12
55126: PUSH
55127: LD_INT 1
55129: PPUSH
55130: LD_VAR 0 12
55134: PPUSH
55135: CALL_OW 12
55139: ARRAY
55140: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55141: LD_VAR 0 2
55145: PPUSH
55146: LD_VAR 0 5
55150: PPUSH
55151: CALL 55509 0 2
55155: NOT
55156: IFFALSE 55215
// repeat weapon := _weapon [ 1 ] ;
55158: LD_ADDR_VAR 0 5
55162: PUSH
55163: LD_VAR 0 10
55167: PUSH
55168: LD_INT 1
55170: ARRAY
55171: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55172: LD_ADDR_VAR 0 10
55176: PUSH
55177: LD_VAR 0 10
55181: PPUSH
55182: LD_INT 1
55184: PPUSH
55185: CALL_OW 3
55189: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55190: LD_VAR 0 2
55194: PPUSH
55195: LD_VAR 0 5
55199: PPUSH
55200: CALL 55509 0 2
55204: PUSH
55205: LD_VAR 0 10
55209: PUSH
55210: EMPTY
55211: EQUAL
55212: OR
55213: IFFALSE 55158
// result := [ ] ;
55215: LD_ADDR_VAR 0 6
55219: PUSH
55220: EMPTY
55221: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55222: LD_VAR 0 1
55226: PPUSH
55227: LD_VAR 0 2
55231: PPUSH
55232: LD_VAR 0 3
55236: PPUSH
55237: LD_VAR 0 4
55241: PPUSH
55242: LD_VAR 0 5
55246: PPUSH
55247: CALL_OW 448
55251: IFFALSE 55284
// result := [ chassis , engine , control , weapon ] ;
55253: LD_ADDR_VAR 0 6
55257: PUSH
55258: LD_VAR 0 2
55262: PUSH
55263: LD_VAR 0 3
55267: PUSH
55268: LD_VAR 0 4
55272: PUSH
55273: LD_VAR 0 5
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: LIST
55282: LIST
55283: ST_TO_ADDR
// end ;
55284: LD_VAR 0 6
55288: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55289: LD_INT 0
55291: PPUSH
// if not chassis or not engine then
55292: LD_VAR 0 1
55296: NOT
55297: PUSH
55298: LD_VAR 0 2
55302: NOT
55303: OR
55304: IFFALSE 55308
// exit ;
55306: GO 55504
// case engine of engine_solar :
55308: LD_VAR 0 2
55312: PUSH
55313: LD_INT 2
55315: DOUBLE
55316: EQUAL
55317: IFTRUE 55321
55319: GO 55359
55321: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55322: LD_ADDR_VAR 0 3
55326: PUSH
55327: LD_INT 11
55329: PUSH
55330: LD_INT 12
55332: PUSH
55333: LD_INT 13
55335: PUSH
55336: LD_INT 14
55338: PUSH
55339: LD_INT 1
55341: PUSH
55342: LD_INT 2
55344: PUSH
55345: LD_INT 3
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: LIST
55352: LIST
55353: LIST
55354: LIST
55355: LIST
55356: ST_TO_ADDR
55357: GO 55488
55359: LD_INT 1
55361: DOUBLE
55362: EQUAL
55363: IFTRUE 55367
55365: GO 55429
55367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55368: LD_ADDR_VAR 0 3
55372: PUSH
55373: LD_INT 11
55375: PUSH
55376: LD_INT 12
55378: PUSH
55379: LD_INT 13
55381: PUSH
55382: LD_INT 14
55384: PUSH
55385: LD_INT 1
55387: PUSH
55388: LD_INT 2
55390: PUSH
55391: LD_INT 3
55393: PUSH
55394: LD_INT 4
55396: PUSH
55397: LD_INT 5
55399: PUSH
55400: LD_INT 21
55402: PUSH
55403: LD_INT 23
55405: PUSH
55406: LD_INT 22
55408: PUSH
55409: LD_INT 24
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: LIST
55416: LIST
55417: LIST
55418: LIST
55419: LIST
55420: LIST
55421: LIST
55422: LIST
55423: LIST
55424: LIST
55425: LIST
55426: ST_TO_ADDR
55427: GO 55488
55429: LD_INT 3
55431: DOUBLE
55432: EQUAL
55433: IFTRUE 55437
55435: GO 55487
55437: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55438: LD_ADDR_VAR 0 3
55442: PUSH
55443: LD_INT 13
55445: PUSH
55446: LD_INT 14
55448: PUSH
55449: LD_INT 2
55451: PUSH
55452: LD_INT 3
55454: PUSH
55455: LD_INT 4
55457: PUSH
55458: LD_INT 5
55460: PUSH
55461: LD_INT 21
55463: PUSH
55464: LD_INT 22
55466: PUSH
55467: LD_INT 23
55469: PUSH
55470: LD_INT 24
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: LIST
55481: LIST
55482: LIST
55483: LIST
55484: ST_TO_ADDR
55485: GO 55488
55487: POP
// result := ( chassis in result ) ;
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_VAR 0 1
55497: PUSH
55498: LD_VAR 0 3
55502: IN
55503: ST_TO_ADDR
// end ;
55504: LD_VAR 0 3
55508: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55509: LD_INT 0
55511: PPUSH
// if not chassis or not weapon then
55512: LD_VAR 0 1
55516: NOT
55517: PUSH
55518: LD_VAR 0 2
55522: NOT
55523: OR
55524: IFFALSE 55528
// exit ;
55526: GO 56590
// case weapon of us_machine_gun :
55528: LD_VAR 0 2
55532: PUSH
55533: LD_INT 2
55535: DOUBLE
55536: EQUAL
55537: IFTRUE 55541
55539: GO 55571
55541: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55542: LD_ADDR_VAR 0 3
55546: PUSH
55547: LD_INT 1
55549: PUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 3
55555: PUSH
55556: LD_INT 4
55558: PUSH
55559: LD_INT 5
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: LIST
55566: LIST
55567: LIST
55568: ST_TO_ADDR
55569: GO 56574
55571: LD_INT 3
55573: DOUBLE
55574: EQUAL
55575: IFTRUE 55579
55577: GO 55609
55579: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55580: LD_ADDR_VAR 0 3
55584: PUSH
55585: LD_INT 1
55587: PUSH
55588: LD_INT 2
55590: PUSH
55591: LD_INT 3
55593: PUSH
55594: LD_INT 4
55596: PUSH
55597: LD_INT 5
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: LIST
55604: LIST
55605: LIST
55606: ST_TO_ADDR
55607: GO 56574
55609: LD_INT 11
55611: DOUBLE
55612: EQUAL
55613: IFTRUE 55617
55615: GO 55647
55617: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55618: LD_ADDR_VAR 0 3
55622: PUSH
55623: LD_INT 1
55625: PUSH
55626: LD_INT 2
55628: PUSH
55629: LD_INT 3
55631: PUSH
55632: LD_INT 4
55634: PUSH
55635: LD_INT 5
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: LIST
55642: LIST
55643: LIST
55644: ST_TO_ADDR
55645: GO 56574
55647: LD_INT 4
55649: DOUBLE
55650: EQUAL
55651: IFTRUE 55655
55653: GO 55681
55655: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55656: LD_ADDR_VAR 0 3
55660: PUSH
55661: LD_INT 2
55663: PUSH
55664: LD_INT 3
55666: PUSH
55667: LD_INT 4
55669: PUSH
55670: LD_INT 5
55672: PUSH
55673: EMPTY
55674: LIST
55675: LIST
55676: LIST
55677: LIST
55678: ST_TO_ADDR
55679: GO 56574
55681: LD_INT 5
55683: DOUBLE
55684: EQUAL
55685: IFTRUE 55689
55687: GO 55715
55689: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55690: LD_ADDR_VAR 0 3
55694: PUSH
55695: LD_INT 2
55697: PUSH
55698: LD_INT 3
55700: PUSH
55701: LD_INT 4
55703: PUSH
55704: LD_INT 5
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
55713: GO 56574
55715: LD_INT 9
55717: DOUBLE
55718: EQUAL
55719: IFTRUE 55723
55721: GO 55749
55723: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55724: LD_ADDR_VAR 0 3
55728: PUSH
55729: LD_INT 2
55731: PUSH
55732: LD_INT 3
55734: PUSH
55735: LD_INT 4
55737: PUSH
55738: LD_INT 5
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: LIST
55745: LIST
55746: ST_TO_ADDR
55747: GO 56574
55749: LD_INT 7
55751: DOUBLE
55752: EQUAL
55753: IFTRUE 55757
55755: GO 55783
55757: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55758: LD_ADDR_VAR 0 3
55762: PUSH
55763: LD_INT 2
55765: PUSH
55766: LD_INT 3
55768: PUSH
55769: LD_INT 4
55771: PUSH
55772: LD_INT 5
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: LIST
55779: LIST
55780: ST_TO_ADDR
55781: GO 56574
55783: LD_INT 12
55785: DOUBLE
55786: EQUAL
55787: IFTRUE 55791
55789: GO 55817
55791: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55792: LD_ADDR_VAR 0 3
55796: PUSH
55797: LD_INT 2
55799: PUSH
55800: LD_INT 3
55802: PUSH
55803: LD_INT 4
55805: PUSH
55806: LD_INT 5
55808: PUSH
55809: EMPTY
55810: LIST
55811: LIST
55812: LIST
55813: LIST
55814: ST_TO_ADDR
55815: GO 56574
55817: LD_INT 13
55819: DOUBLE
55820: EQUAL
55821: IFTRUE 55825
55823: GO 55851
55825: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55826: LD_ADDR_VAR 0 3
55830: PUSH
55831: LD_INT 2
55833: PUSH
55834: LD_INT 3
55836: PUSH
55837: LD_INT 4
55839: PUSH
55840: LD_INT 5
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: LIST
55848: ST_TO_ADDR
55849: GO 56574
55851: LD_INT 14
55853: DOUBLE
55854: EQUAL
55855: IFTRUE 55859
55857: GO 55877
55859: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55860: LD_ADDR_VAR 0 3
55864: PUSH
55865: LD_INT 4
55867: PUSH
55868: LD_INT 5
55870: PUSH
55871: EMPTY
55872: LIST
55873: LIST
55874: ST_TO_ADDR
55875: GO 56574
55877: LD_INT 6
55879: DOUBLE
55880: EQUAL
55881: IFTRUE 55885
55883: GO 55903
55885: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55886: LD_ADDR_VAR 0 3
55890: PUSH
55891: LD_INT 4
55893: PUSH
55894: LD_INT 5
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: ST_TO_ADDR
55901: GO 56574
55903: LD_INT 10
55905: DOUBLE
55906: EQUAL
55907: IFTRUE 55911
55909: GO 55929
55911: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55912: LD_ADDR_VAR 0 3
55916: PUSH
55917: LD_INT 4
55919: PUSH
55920: LD_INT 5
55922: PUSH
55923: EMPTY
55924: LIST
55925: LIST
55926: ST_TO_ADDR
55927: GO 56574
55929: LD_INT 22
55931: DOUBLE
55932: EQUAL
55933: IFTRUE 55937
55935: GO 55963
55937: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55938: LD_ADDR_VAR 0 3
55942: PUSH
55943: LD_INT 11
55945: PUSH
55946: LD_INT 12
55948: PUSH
55949: LD_INT 13
55951: PUSH
55952: LD_INT 14
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: LIST
55959: LIST
55960: ST_TO_ADDR
55961: GO 56574
55963: LD_INT 23
55965: DOUBLE
55966: EQUAL
55967: IFTRUE 55971
55969: GO 55997
55971: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55972: LD_ADDR_VAR 0 3
55976: PUSH
55977: LD_INT 11
55979: PUSH
55980: LD_INT 12
55982: PUSH
55983: LD_INT 13
55985: PUSH
55986: LD_INT 14
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: LIST
55993: LIST
55994: ST_TO_ADDR
55995: GO 56574
55997: LD_INT 24
55999: DOUBLE
56000: EQUAL
56001: IFTRUE 56005
56003: GO 56031
56005: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56006: LD_ADDR_VAR 0 3
56010: PUSH
56011: LD_INT 11
56013: PUSH
56014: LD_INT 12
56016: PUSH
56017: LD_INT 13
56019: PUSH
56020: LD_INT 14
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: LIST
56027: LIST
56028: ST_TO_ADDR
56029: GO 56574
56031: LD_INT 30
56033: DOUBLE
56034: EQUAL
56035: IFTRUE 56039
56037: GO 56065
56039: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56040: LD_ADDR_VAR 0 3
56044: PUSH
56045: LD_INT 11
56047: PUSH
56048: LD_INT 12
56050: PUSH
56051: LD_INT 13
56053: PUSH
56054: LD_INT 14
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: ST_TO_ADDR
56063: GO 56574
56065: LD_INT 25
56067: DOUBLE
56068: EQUAL
56069: IFTRUE 56073
56071: GO 56091
56073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56074: LD_ADDR_VAR 0 3
56078: PUSH
56079: LD_INT 13
56081: PUSH
56082: LD_INT 14
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: ST_TO_ADDR
56089: GO 56574
56091: LD_INT 27
56093: DOUBLE
56094: EQUAL
56095: IFTRUE 56099
56097: GO 56117
56099: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56100: LD_ADDR_VAR 0 3
56104: PUSH
56105: LD_INT 13
56107: PUSH
56108: LD_INT 14
56110: PUSH
56111: EMPTY
56112: LIST
56113: LIST
56114: ST_TO_ADDR
56115: GO 56574
56117: LD_EXP 79
56121: DOUBLE
56122: EQUAL
56123: IFTRUE 56127
56125: GO 56153
56127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56128: LD_ADDR_VAR 0 3
56132: PUSH
56133: LD_INT 11
56135: PUSH
56136: LD_INT 12
56138: PUSH
56139: LD_INT 13
56141: PUSH
56142: LD_INT 14
56144: PUSH
56145: EMPTY
56146: LIST
56147: LIST
56148: LIST
56149: LIST
56150: ST_TO_ADDR
56151: GO 56574
56153: LD_INT 28
56155: DOUBLE
56156: EQUAL
56157: IFTRUE 56161
56159: GO 56179
56161: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56162: LD_ADDR_VAR 0 3
56166: PUSH
56167: LD_INT 13
56169: PUSH
56170: LD_INT 14
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: ST_TO_ADDR
56177: GO 56574
56179: LD_INT 29
56181: DOUBLE
56182: EQUAL
56183: IFTRUE 56187
56185: GO 56205
56187: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56188: LD_ADDR_VAR 0 3
56192: PUSH
56193: LD_INT 13
56195: PUSH
56196: LD_INT 14
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: ST_TO_ADDR
56203: GO 56574
56205: LD_INT 31
56207: DOUBLE
56208: EQUAL
56209: IFTRUE 56213
56211: GO 56231
56213: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56214: LD_ADDR_VAR 0 3
56218: PUSH
56219: LD_INT 13
56221: PUSH
56222: LD_INT 14
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: ST_TO_ADDR
56229: GO 56574
56231: LD_INT 26
56233: DOUBLE
56234: EQUAL
56235: IFTRUE 56239
56237: GO 56257
56239: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56240: LD_ADDR_VAR 0 3
56244: PUSH
56245: LD_INT 13
56247: PUSH
56248: LD_INT 14
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: ST_TO_ADDR
56255: GO 56574
56257: LD_INT 42
56259: DOUBLE
56260: EQUAL
56261: IFTRUE 56265
56263: GO 56291
56265: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56266: LD_ADDR_VAR 0 3
56270: PUSH
56271: LD_INT 21
56273: PUSH
56274: LD_INT 22
56276: PUSH
56277: LD_INT 23
56279: PUSH
56280: LD_INT 24
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: LIST
56287: LIST
56288: ST_TO_ADDR
56289: GO 56574
56291: LD_INT 43
56293: DOUBLE
56294: EQUAL
56295: IFTRUE 56299
56297: GO 56325
56299: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56300: LD_ADDR_VAR 0 3
56304: PUSH
56305: LD_INT 21
56307: PUSH
56308: LD_INT 22
56310: PUSH
56311: LD_INT 23
56313: PUSH
56314: LD_INT 24
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: LIST
56321: LIST
56322: ST_TO_ADDR
56323: GO 56574
56325: LD_INT 44
56327: DOUBLE
56328: EQUAL
56329: IFTRUE 56333
56331: GO 56359
56333: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56334: LD_ADDR_VAR 0 3
56338: PUSH
56339: LD_INT 21
56341: PUSH
56342: LD_INT 22
56344: PUSH
56345: LD_INT 23
56347: PUSH
56348: LD_INT 24
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: LIST
56355: LIST
56356: ST_TO_ADDR
56357: GO 56574
56359: LD_INT 45
56361: DOUBLE
56362: EQUAL
56363: IFTRUE 56367
56365: GO 56393
56367: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56368: LD_ADDR_VAR 0 3
56372: PUSH
56373: LD_INT 21
56375: PUSH
56376: LD_INT 22
56378: PUSH
56379: LD_INT 23
56381: PUSH
56382: LD_INT 24
56384: PUSH
56385: EMPTY
56386: LIST
56387: LIST
56388: LIST
56389: LIST
56390: ST_TO_ADDR
56391: GO 56574
56393: LD_INT 49
56395: DOUBLE
56396: EQUAL
56397: IFTRUE 56401
56399: GO 56427
56401: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56402: LD_ADDR_VAR 0 3
56406: PUSH
56407: LD_INT 21
56409: PUSH
56410: LD_INT 22
56412: PUSH
56413: LD_INT 23
56415: PUSH
56416: LD_INT 24
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: LIST
56423: LIST
56424: ST_TO_ADDR
56425: GO 56574
56427: LD_INT 51
56429: DOUBLE
56430: EQUAL
56431: IFTRUE 56435
56433: GO 56461
56435: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56436: LD_ADDR_VAR 0 3
56440: PUSH
56441: LD_INT 21
56443: PUSH
56444: LD_INT 22
56446: PUSH
56447: LD_INT 23
56449: PUSH
56450: LD_INT 24
56452: PUSH
56453: EMPTY
56454: LIST
56455: LIST
56456: LIST
56457: LIST
56458: ST_TO_ADDR
56459: GO 56574
56461: LD_INT 52
56463: DOUBLE
56464: EQUAL
56465: IFTRUE 56469
56467: GO 56495
56469: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56470: LD_ADDR_VAR 0 3
56474: PUSH
56475: LD_INT 21
56477: PUSH
56478: LD_INT 22
56480: PUSH
56481: LD_INT 23
56483: PUSH
56484: LD_INT 24
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: LIST
56491: LIST
56492: ST_TO_ADDR
56493: GO 56574
56495: LD_INT 53
56497: DOUBLE
56498: EQUAL
56499: IFTRUE 56503
56501: GO 56521
56503: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56504: LD_ADDR_VAR 0 3
56508: PUSH
56509: LD_INT 23
56511: PUSH
56512: LD_INT 24
56514: PUSH
56515: EMPTY
56516: LIST
56517: LIST
56518: ST_TO_ADDR
56519: GO 56574
56521: LD_INT 46
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56529
56527: GO 56547
56529: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56530: LD_ADDR_VAR 0 3
56534: PUSH
56535: LD_INT 23
56537: PUSH
56538: LD_INT 24
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: ST_TO_ADDR
56545: GO 56574
56547: LD_INT 47
56549: DOUBLE
56550: EQUAL
56551: IFTRUE 56555
56553: GO 56573
56555: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56556: LD_ADDR_VAR 0 3
56560: PUSH
56561: LD_INT 23
56563: PUSH
56564: LD_INT 24
56566: PUSH
56567: EMPTY
56568: LIST
56569: LIST
56570: ST_TO_ADDR
56571: GO 56574
56573: POP
// result := ( chassis in result ) ;
56574: LD_ADDR_VAR 0 3
56578: PUSH
56579: LD_VAR 0 1
56583: PUSH
56584: LD_VAR 0 3
56588: IN
56589: ST_TO_ADDR
// end ;
56590: LD_VAR 0 3
56594: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56595: LD_INT 0
56597: PPUSH
56598: PPUSH
56599: PPUSH
56600: PPUSH
56601: PPUSH
56602: PPUSH
56603: PPUSH
// result := array ;
56604: LD_ADDR_VAR 0 5
56608: PUSH
56609: LD_VAR 0 1
56613: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56614: LD_VAR 0 1
56618: NOT
56619: PUSH
56620: LD_VAR 0 2
56624: NOT
56625: OR
56626: PUSH
56627: LD_VAR 0 3
56631: NOT
56632: OR
56633: PUSH
56634: LD_VAR 0 2
56638: PUSH
56639: LD_VAR 0 1
56643: GREATER
56644: OR
56645: PUSH
56646: LD_VAR 0 3
56650: PUSH
56651: LD_VAR 0 1
56655: GREATER
56656: OR
56657: IFFALSE 56661
// exit ;
56659: GO 56957
// if direction then
56661: LD_VAR 0 4
56665: IFFALSE 56729
// begin d := 1 ;
56667: LD_ADDR_VAR 0 9
56671: PUSH
56672: LD_INT 1
56674: ST_TO_ADDR
// if i_from > i_to then
56675: LD_VAR 0 2
56679: PUSH
56680: LD_VAR 0 3
56684: GREATER
56685: IFFALSE 56711
// length := ( array - i_from ) + i_to else
56687: LD_ADDR_VAR 0 11
56691: PUSH
56692: LD_VAR 0 1
56696: PUSH
56697: LD_VAR 0 2
56701: MINUS
56702: PUSH
56703: LD_VAR 0 3
56707: PLUS
56708: ST_TO_ADDR
56709: GO 56727
// length := i_to - i_from ;
56711: LD_ADDR_VAR 0 11
56715: PUSH
56716: LD_VAR 0 3
56720: PUSH
56721: LD_VAR 0 2
56725: MINUS
56726: ST_TO_ADDR
// end else
56727: GO 56790
// begin d := - 1 ;
56729: LD_ADDR_VAR 0 9
56733: PUSH
56734: LD_INT 1
56736: NEG
56737: ST_TO_ADDR
// if i_from > i_to then
56738: LD_VAR 0 2
56742: PUSH
56743: LD_VAR 0 3
56747: GREATER
56748: IFFALSE 56768
// length := i_from - i_to else
56750: LD_ADDR_VAR 0 11
56754: PUSH
56755: LD_VAR 0 2
56759: PUSH
56760: LD_VAR 0 3
56764: MINUS
56765: ST_TO_ADDR
56766: GO 56790
// length := ( array - i_to ) + i_from ;
56768: LD_ADDR_VAR 0 11
56772: PUSH
56773: LD_VAR 0 1
56777: PUSH
56778: LD_VAR 0 3
56782: MINUS
56783: PUSH
56784: LD_VAR 0 2
56788: PLUS
56789: ST_TO_ADDR
// end ; if not length then
56790: LD_VAR 0 11
56794: NOT
56795: IFFALSE 56799
// exit ;
56797: GO 56957
// tmp := array ;
56799: LD_ADDR_VAR 0 10
56803: PUSH
56804: LD_VAR 0 1
56808: ST_TO_ADDR
// for i = 1 to length do
56809: LD_ADDR_VAR 0 6
56813: PUSH
56814: DOUBLE
56815: LD_INT 1
56817: DEC
56818: ST_TO_ADDR
56819: LD_VAR 0 11
56823: PUSH
56824: FOR_TO
56825: IFFALSE 56945
// begin for j = 1 to array do
56827: LD_ADDR_VAR 0 7
56831: PUSH
56832: DOUBLE
56833: LD_INT 1
56835: DEC
56836: ST_TO_ADDR
56837: LD_VAR 0 1
56841: PUSH
56842: FOR_TO
56843: IFFALSE 56931
// begin k := j + d ;
56845: LD_ADDR_VAR 0 8
56849: PUSH
56850: LD_VAR 0 7
56854: PUSH
56855: LD_VAR 0 9
56859: PLUS
56860: ST_TO_ADDR
// if k > array then
56861: LD_VAR 0 8
56865: PUSH
56866: LD_VAR 0 1
56870: GREATER
56871: IFFALSE 56881
// k := 1 ;
56873: LD_ADDR_VAR 0 8
56877: PUSH
56878: LD_INT 1
56880: ST_TO_ADDR
// if not k then
56881: LD_VAR 0 8
56885: NOT
56886: IFFALSE 56898
// k := array ;
56888: LD_ADDR_VAR 0 8
56892: PUSH
56893: LD_VAR 0 1
56897: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56898: LD_ADDR_VAR 0 10
56902: PUSH
56903: LD_VAR 0 10
56907: PPUSH
56908: LD_VAR 0 8
56912: PPUSH
56913: LD_VAR 0 1
56917: PUSH
56918: LD_VAR 0 7
56922: ARRAY
56923: PPUSH
56924: CALL_OW 1
56928: ST_TO_ADDR
// end ;
56929: GO 56842
56931: POP
56932: POP
// array := tmp ;
56933: LD_ADDR_VAR 0 1
56937: PUSH
56938: LD_VAR 0 10
56942: ST_TO_ADDR
// end ;
56943: GO 56824
56945: POP
56946: POP
// result := array ;
56947: LD_ADDR_VAR 0 5
56951: PUSH
56952: LD_VAR 0 1
56956: ST_TO_ADDR
// end ;
56957: LD_VAR 0 5
56961: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56962: LD_INT 0
56964: PPUSH
56965: PPUSH
// result := 0 ;
56966: LD_ADDR_VAR 0 3
56970: PUSH
56971: LD_INT 0
56973: ST_TO_ADDR
// if not array or not value in array then
56974: LD_VAR 0 1
56978: NOT
56979: PUSH
56980: LD_VAR 0 2
56984: PUSH
56985: LD_VAR 0 1
56989: IN
56990: NOT
56991: OR
56992: IFFALSE 56996
// exit ;
56994: GO 57050
// for i = 1 to array do
56996: LD_ADDR_VAR 0 4
57000: PUSH
57001: DOUBLE
57002: LD_INT 1
57004: DEC
57005: ST_TO_ADDR
57006: LD_VAR 0 1
57010: PUSH
57011: FOR_TO
57012: IFFALSE 57048
// if value = array [ i ] then
57014: LD_VAR 0 2
57018: PUSH
57019: LD_VAR 0 1
57023: PUSH
57024: LD_VAR 0 4
57028: ARRAY
57029: EQUAL
57030: IFFALSE 57046
// begin result := i ;
57032: LD_ADDR_VAR 0 3
57036: PUSH
57037: LD_VAR 0 4
57041: ST_TO_ADDR
// exit ;
57042: POP
57043: POP
57044: GO 57050
// end ;
57046: GO 57011
57048: POP
57049: POP
// end ;
57050: LD_VAR 0 3
57054: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57055: LD_INT 0
57057: PPUSH
// vc_chassis := chassis ;
57058: LD_ADDR_OWVAR 37
57062: PUSH
57063: LD_VAR 0 1
57067: ST_TO_ADDR
// vc_engine := engine ;
57068: LD_ADDR_OWVAR 39
57072: PUSH
57073: LD_VAR 0 2
57077: ST_TO_ADDR
// vc_control := control ;
57078: LD_ADDR_OWVAR 38
57082: PUSH
57083: LD_VAR 0 3
57087: ST_TO_ADDR
// vc_weapon := weapon ;
57088: LD_ADDR_OWVAR 40
57092: PUSH
57093: LD_VAR 0 4
57097: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57098: LD_ADDR_OWVAR 41
57102: PUSH
57103: LD_VAR 0 5
57107: ST_TO_ADDR
// end ;
57108: LD_VAR 0 6
57112: RET
// export function WantPlant ( unit ) ; var task ; begin
57113: LD_INT 0
57115: PPUSH
57116: PPUSH
// result := false ;
57117: LD_ADDR_VAR 0 2
57121: PUSH
57122: LD_INT 0
57124: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57125: LD_ADDR_VAR 0 3
57129: PUSH
57130: LD_VAR 0 1
57134: PPUSH
57135: CALL_OW 437
57139: ST_TO_ADDR
// if task then
57140: LD_VAR 0 3
57144: IFFALSE 57172
// if task [ 1 ] [ 1 ] = p then
57146: LD_VAR 0 3
57150: PUSH
57151: LD_INT 1
57153: ARRAY
57154: PUSH
57155: LD_INT 1
57157: ARRAY
57158: PUSH
57159: LD_STRING p
57161: EQUAL
57162: IFFALSE 57172
// result := true ;
57164: LD_ADDR_VAR 0 2
57168: PUSH
57169: LD_INT 1
57171: ST_TO_ADDR
// end ;
57172: LD_VAR 0 2
57176: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57177: LD_INT 0
57179: PPUSH
57180: PPUSH
57181: PPUSH
57182: PPUSH
// if pos < 1 then
57183: LD_VAR 0 2
57187: PUSH
57188: LD_INT 1
57190: LESS
57191: IFFALSE 57195
// exit ;
57193: GO 57498
// if pos = 1 then
57195: LD_VAR 0 2
57199: PUSH
57200: LD_INT 1
57202: EQUAL
57203: IFFALSE 57236
// result := Replace ( arr , pos [ 1 ] , value ) else
57205: LD_ADDR_VAR 0 4
57209: PUSH
57210: LD_VAR 0 1
57214: PPUSH
57215: LD_VAR 0 2
57219: PUSH
57220: LD_INT 1
57222: ARRAY
57223: PPUSH
57224: LD_VAR 0 3
57228: PPUSH
57229: CALL_OW 1
57233: ST_TO_ADDR
57234: GO 57498
// begin tmp := arr ;
57236: LD_ADDR_VAR 0 6
57240: PUSH
57241: LD_VAR 0 1
57245: ST_TO_ADDR
// s_arr := [ tmp ] ;
57246: LD_ADDR_VAR 0 7
57250: PUSH
57251: LD_VAR 0 6
57255: PUSH
57256: EMPTY
57257: LIST
57258: ST_TO_ADDR
// for i = 1 to pos - 1 do
57259: LD_ADDR_VAR 0 5
57263: PUSH
57264: DOUBLE
57265: LD_INT 1
57267: DEC
57268: ST_TO_ADDR
57269: LD_VAR 0 2
57273: PUSH
57274: LD_INT 1
57276: MINUS
57277: PUSH
57278: FOR_TO
57279: IFFALSE 57324
// begin tmp := tmp [ pos [ i ] ] ;
57281: LD_ADDR_VAR 0 6
57285: PUSH
57286: LD_VAR 0 6
57290: PUSH
57291: LD_VAR 0 2
57295: PUSH
57296: LD_VAR 0 5
57300: ARRAY
57301: ARRAY
57302: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57303: LD_ADDR_VAR 0 7
57307: PUSH
57308: LD_VAR 0 7
57312: PUSH
57313: LD_VAR 0 6
57317: PUSH
57318: EMPTY
57319: LIST
57320: ADD
57321: ST_TO_ADDR
// end ;
57322: GO 57278
57324: POP
57325: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57326: LD_ADDR_VAR 0 6
57330: PUSH
57331: LD_VAR 0 6
57335: PPUSH
57336: LD_VAR 0 2
57340: PUSH
57341: LD_VAR 0 2
57345: ARRAY
57346: PPUSH
57347: LD_VAR 0 3
57351: PPUSH
57352: CALL_OW 1
57356: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57357: LD_ADDR_VAR 0 7
57361: PUSH
57362: LD_VAR 0 7
57366: PPUSH
57367: LD_VAR 0 7
57371: PPUSH
57372: LD_VAR 0 6
57376: PPUSH
57377: CALL_OW 1
57381: ST_TO_ADDR
// for i = s_arr downto 2 do
57382: LD_ADDR_VAR 0 5
57386: PUSH
57387: DOUBLE
57388: LD_VAR 0 7
57392: INC
57393: ST_TO_ADDR
57394: LD_INT 2
57396: PUSH
57397: FOR_DOWNTO
57398: IFFALSE 57482
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57400: LD_ADDR_VAR 0 6
57404: PUSH
57405: LD_VAR 0 7
57409: PUSH
57410: LD_VAR 0 5
57414: PUSH
57415: LD_INT 1
57417: MINUS
57418: ARRAY
57419: PPUSH
57420: LD_VAR 0 2
57424: PUSH
57425: LD_VAR 0 5
57429: PUSH
57430: LD_INT 1
57432: MINUS
57433: ARRAY
57434: PPUSH
57435: LD_VAR 0 7
57439: PUSH
57440: LD_VAR 0 5
57444: ARRAY
57445: PPUSH
57446: CALL_OW 1
57450: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57451: LD_ADDR_VAR 0 7
57455: PUSH
57456: LD_VAR 0 7
57460: PPUSH
57461: LD_VAR 0 5
57465: PUSH
57466: LD_INT 1
57468: MINUS
57469: PPUSH
57470: LD_VAR 0 6
57474: PPUSH
57475: CALL_OW 1
57479: ST_TO_ADDR
// end ;
57480: GO 57397
57482: POP
57483: POP
// result := s_arr [ 1 ] ;
57484: LD_ADDR_VAR 0 4
57488: PUSH
57489: LD_VAR 0 7
57493: PUSH
57494: LD_INT 1
57496: ARRAY
57497: ST_TO_ADDR
// end ; end ;
57498: LD_VAR 0 4
57502: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57503: LD_INT 0
57505: PPUSH
57506: PPUSH
// if not list then
57507: LD_VAR 0 1
57511: NOT
57512: IFFALSE 57516
// exit ;
57514: GO 57607
// i := list [ pos1 ] ;
57516: LD_ADDR_VAR 0 5
57520: PUSH
57521: LD_VAR 0 1
57525: PUSH
57526: LD_VAR 0 2
57530: ARRAY
57531: ST_TO_ADDR
// if not i then
57532: LD_VAR 0 5
57536: NOT
57537: IFFALSE 57541
// exit ;
57539: GO 57607
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57541: LD_ADDR_VAR 0 1
57545: PUSH
57546: LD_VAR 0 1
57550: PPUSH
57551: LD_VAR 0 2
57555: PPUSH
57556: LD_VAR 0 1
57560: PUSH
57561: LD_VAR 0 3
57565: ARRAY
57566: PPUSH
57567: CALL_OW 1
57571: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57572: LD_ADDR_VAR 0 1
57576: PUSH
57577: LD_VAR 0 1
57581: PPUSH
57582: LD_VAR 0 3
57586: PPUSH
57587: LD_VAR 0 5
57591: PPUSH
57592: CALL_OW 1
57596: ST_TO_ADDR
// result := list ;
57597: LD_ADDR_VAR 0 4
57601: PUSH
57602: LD_VAR 0 1
57606: ST_TO_ADDR
// end ;
57607: LD_VAR 0 4
57611: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57612: LD_INT 0
57614: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57615: LD_ADDR_VAR 0 5
57619: PUSH
57620: LD_VAR 0 1
57624: PPUSH
57625: CALL_OW 250
57629: PPUSH
57630: LD_VAR 0 1
57634: PPUSH
57635: CALL_OW 251
57639: PPUSH
57640: LD_VAR 0 2
57644: PPUSH
57645: LD_VAR 0 3
57649: PPUSH
57650: LD_VAR 0 4
57654: PPUSH
57655: CALL 57665 0 5
57659: ST_TO_ADDR
// end ;
57660: LD_VAR 0 5
57664: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57665: LD_INT 0
57667: PPUSH
57668: PPUSH
57669: PPUSH
57670: PPUSH
// if not list then
57671: LD_VAR 0 3
57675: NOT
57676: IFFALSE 57680
// exit ;
57678: GO 58068
// result := [ ] ;
57680: LD_ADDR_VAR 0 6
57684: PUSH
57685: EMPTY
57686: ST_TO_ADDR
// for i in list do
57687: LD_ADDR_VAR 0 7
57691: PUSH
57692: LD_VAR 0 3
57696: PUSH
57697: FOR_IN
57698: IFFALSE 57900
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57700: LD_ADDR_VAR 0 9
57704: PUSH
57705: LD_VAR 0 7
57709: PPUSH
57710: LD_VAR 0 1
57714: PPUSH
57715: LD_VAR 0 2
57719: PPUSH
57720: CALL_OW 297
57724: ST_TO_ADDR
// if not result then
57725: LD_VAR 0 6
57729: NOT
57730: IFFALSE 57756
// result := [ [ i , tmp ] ] else
57732: LD_ADDR_VAR 0 6
57736: PUSH
57737: LD_VAR 0 7
57741: PUSH
57742: LD_VAR 0 9
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: EMPTY
57752: LIST
57753: ST_TO_ADDR
57754: GO 57898
// begin if result [ result ] [ 2 ] < tmp then
57756: LD_VAR 0 6
57760: PUSH
57761: LD_VAR 0 6
57765: ARRAY
57766: PUSH
57767: LD_INT 2
57769: ARRAY
57770: PUSH
57771: LD_VAR 0 9
57775: LESS
57776: IFFALSE 57818
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57778: LD_ADDR_VAR 0 6
57782: PUSH
57783: LD_VAR 0 6
57787: PPUSH
57788: LD_VAR 0 6
57792: PUSH
57793: LD_INT 1
57795: PLUS
57796: PPUSH
57797: LD_VAR 0 7
57801: PUSH
57802: LD_VAR 0 9
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PPUSH
57811: CALL_OW 2
57815: ST_TO_ADDR
57816: GO 57898
// for j = 1 to result do
57818: LD_ADDR_VAR 0 8
57822: PUSH
57823: DOUBLE
57824: LD_INT 1
57826: DEC
57827: ST_TO_ADDR
57828: LD_VAR 0 6
57832: PUSH
57833: FOR_TO
57834: IFFALSE 57896
// begin if tmp < result [ j ] [ 2 ] then
57836: LD_VAR 0 9
57840: PUSH
57841: LD_VAR 0 6
57845: PUSH
57846: LD_VAR 0 8
57850: ARRAY
57851: PUSH
57852: LD_INT 2
57854: ARRAY
57855: LESS
57856: IFFALSE 57894
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57858: LD_ADDR_VAR 0 6
57862: PUSH
57863: LD_VAR 0 6
57867: PPUSH
57868: LD_VAR 0 8
57872: PPUSH
57873: LD_VAR 0 7
57877: PUSH
57878: LD_VAR 0 9
57882: PUSH
57883: EMPTY
57884: LIST
57885: LIST
57886: PPUSH
57887: CALL_OW 2
57891: ST_TO_ADDR
// break ;
57892: GO 57896
// end ; end ;
57894: GO 57833
57896: POP
57897: POP
// end ; end ;
57898: GO 57697
57900: POP
57901: POP
// if result and not asc then
57902: LD_VAR 0 6
57906: PUSH
57907: LD_VAR 0 4
57911: NOT
57912: AND
57913: IFFALSE 57988
// begin tmp := result ;
57915: LD_ADDR_VAR 0 9
57919: PUSH
57920: LD_VAR 0 6
57924: ST_TO_ADDR
// for i = tmp downto 1 do
57925: LD_ADDR_VAR 0 7
57929: PUSH
57930: DOUBLE
57931: LD_VAR 0 9
57935: INC
57936: ST_TO_ADDR
57937: LD_INT 1
57939: PUSH
57940: FOR_DOWNTO
57941: IFFALSE 57986
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57943: LD_ADDR_VAR 0 6
57947: PUSH
57948: LD_VAR 0 6
57952: PPUSH
57953: LD_VAR 0 9
57957: PUSH
57958: LD_VAR 0 7
57962: MINUS
57963: PUSH
57964: LD_INT 1
57966: PLUS
57967: PPUSH
57968: LD_VAR 0 9
57972: PUSH
57973: LD_VAR 0 7
57977: ARRAY
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
57984: GO 57940
57986: POP
57987: POP
// end ; tmp := [ ] ;
57988: LD_ADDR_VAR 0 9
57992: PUSH
57993: EMPTY
57994: ST_TO_ADDR
// if mode then
57995: LD_VAR 0 5
57999: IFFALSE 58068
// begin for i = 1 to result do
58001: LD_ADDR_VAR 0 7
58005: PUSH
58006: DOUBLE
58007: LD_INT 1
58009: DEC
58010: ST_TO_ADDR
58011: LD_VAR 0 6
58015: PUSH
58016: FOR_TO
58017: IFFALSE 58056
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58019: LD_ADDR_VAR 0 9
58023: PUSH
58024: LD_VAR 0 9
58028: PPUSH
58029: LD_VAR 0 7
58033: PPUSH
58034: LD_VAR 0 6
58038: PUSH
58039: LD_VAR 0 7
58043: ARRAY
58044: PUSH
58045: LD_INT 1
58047: ARRAY
58048: PPUSH
58049: CALL_OW 1
58053: ST_TO_ADDR
58054: GO 58016
58056: POP
58057: POP
// result := tmp ;
58058: LD_ADDR_VAR 0 6
58062: PUSH
58063: LD_VAR 0 9
58067: ST_TO_ADDR
// end ; end ;
58068: LD_VAR 0 6
58072: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58073: LD_INT 0
58075: PPUSH
58076: PPUSH
58077: PPUSH
58078: PPUSH
58079: PPUSH
58080: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58081: LD_ADDR_VAR 0 5
58085: PUSH
58086: LD_INT 0
58088: PUSH
58089: LD_INT 0
58091: PUSH
58092: LD_INT 0
58094: PUSH
58095: EMPTY
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: LIST
58101: LIST
58102: ST_TO_ADDR
// if not x or not y then
58103: LD_VAR 0 2
58107: NOT
58108: PUSH
58109: LD_VAR 0 3
58113: NOT
58114: OR
58115: IFFALSE 58119
// exit ;
58117: GO 59771
// if not range then
58119: LD_VAR 0 4
58123: NOT
58124: IFFALSE 58134
// range := 10 ;
58126: LD_ADDR_VAR 0 4
58130: PUSH
58131: LD_INT 10
58133: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58134: LD_ADDR_VAR 0 8
58138: PUSH
58139: LD_INT 81
58141: PUSH
58142: LD_VAR 0 1
58146: PUSH
58147: EMPTY
58148: LIST
58149: LIST
58150: PUSH
58151: LD_INT 92
58153: PUSH
58154: LD_VAR 0 2
58158: PUSH
58159: LD_VAR 0 3
58163: PUSH
58164: LD_VAR 0 4
58168: PUSH
58169: EMPTY
58170: LIST
58171: LIST
58172: LIST
58173: LIST
58174: PUSH
58175: LD_INT 3
58177: PUSH
58178: LD_INT 21
58180: PUSH
58181: LD_INT 3
58183: PUSH
58184: EMPTY
58185: LIST
58186: LIST
58187: PUSH
58188: EMPTY
58189: LIST
58190: LIST
58191: PUSH
58192: EMPTY
58193: LIST
58194: LIST
58195: LIST
58196: PPUSH
58197: CALL_OW 69
58201: ST_TO_ADDR
// if not tmp then
58202: LD_VAR 0 8
58206: NOT
58207: IFFALSE 58211
// exit ;
58209: GO 59771
// for i in tmp do
58211: LD_ADDR_VAR 0 6
58215: PUSH
58216: LD_VAR 0 8
58220: PUSH
58221: FOR_IN
58222: IFFALSE 59746
// begin points := [ 0 , 0 , 0 ] ;
58224: LD_ADDR_VAR 0 9
58228: PUSH
58229: LD_INT 0
58231: PUSH
58232: LD_INT 0
58234: PUSH
58235: LD_INT 0
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: LIST
58242: ST_TO_ADDR
// bpoints := 1 ;
58243: LD_ADDR_VAR 0 10
58247: PUSH
58248: LD_INT 1
58250: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58251: LD_VAR 0 6
58255: PPUSH
58256: CALL_OW 247
58260: PUSH
58261: LD_INT 1
58263: DOUBLE
58264: EQUAL
58265: IFTRUE 58269
58267: GO 58847
58269: POP
// begin if GetClass ( i ) = 1 then
58270: LD_VAR 0 6
58274: PPUSH
58275: CALL_OW 257
58279: PUSH
58280: LD_INT 1
58282: EQUAL
58283: IFFALSE 58304
// points := [ 10 , 5 , 3 ] ;
58285: LD_ADDR_VAR 0 9
58289: PUSH
58290: LD_INT 10
58292: PUSH
58293: LD_INT 5
58295: PUSH
58296: LD_INT 3
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: LIST
58303: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58304: LD_VAR 0 6
58308: PPUSH
58309: CALL_OW 257
58313: PUSH
58314: LD_INT 2
58316: PUSH
58317: LD_INT 3
58319: PUSH
58320: LD_INT 4
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: LIST
58327: IN
58328: IFFALSE 58349
// points := [ 3 , 2 , 1 ] ;
58330: LD_ADDR_VAR 0 9
58334: PUSH
58335: LD_INT 3
58337: PUSH
58338: LD_INT 2
58340: PUSH
58341: LD_INT 1
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: LIST
58348: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58349: LD_VAR 0 6
58353: PPUSH
58354: CALL_OW 257
58358: PUSH
58359: LD_INT 5
58361: EQUAL
58362: IFFALSE 58383
// points := [ 130 , 5 , 2 ] ;
58364: LD_ADDR_VAR 0 9
58368: PUSH
58369: LD_INT 130
58371: PUSH
58372: LD_INT 5
58374: PUSH
58375: LD_INT 2
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: LIST
58382: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58383: LD_VAR 0 6
58387: PPUSH
58388: CALL_OW 257
58392: PUSH
58393: LD_INT 8
58395: EQUAL
58396: IFFALSE 58417
// points := [ 35 , 35 , 30 ] ;
58398: LD_ADDR_VAR 0 9
58402: PUSH
58403: LD_INT 35
58405: PUSH
58406: LD_INT 35
58408: PUSH
58409: LD_INT 30
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: LIST
58416: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58417: LD_VAR 0 6
58421: PPUSH
58422: CALL_OW 257
58426: PUSH
58427: LD_INT 9
58429: EQUAL
58430: IFFALSE 58451
// points := [ 20 , 55 , 40 ] ;
58432: LD_ADDR_VAR 0 9
58436: PUSH
58437: LD_INT 20
58439: PUSH
58440: LD_INT 55
58442: PUSH
58443: LD_INT 40
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: LIST
58450: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58451: LD_VAR 0 6
58455: PPUSH
58456: CALL_OW 257
58460: PUSH
58461: LD_INT 12
58463: PUSH
58464: LD_INT 16
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: IN
58471: IFFALSE 58492
// points := [ 5 , 3 , 2 ] ;
58473: LD_ADDR_VAR 0 9
58477: PUSH
58478: LD_INT 5
58480: PUSH
58481: LD_INT 3
58483: PUSH
58484: LD_INT 2
58486: PUSH
58487: EMPTY
58488: LIST
58489: LIST
58490: LIST
58491: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58492: LD_VAR 0 6
58496: PPUSH
58497: CALL_OW 257
58501: PUSH
58502: LD_INT 17
58504: EQUAL
58505: IFFALSE 58526
// points := [ 100 , 50 , 75 ] ;
58507: LD_ADDR_VAR 0 9
58511: PUSH
58512: LD_INT 100
58514: PUSH
58515: LD_INT 50
58517: PUSH
58518: LD_INT 75
58520: PUSH
58521: EMPTY
58522: LIST
58523: LIST
58524: LIST
58525: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58526: LD_VAR 0 6
58530: PPUSH
58531: CALL_OW 257
58535: PUSH
58536: LD_INT 15
58538: EQUAL
58539: IFFALSE 58560
// points := [ 10 , 5 , 3 ] ;
58541: LD_ADDR_VAR 0 9
58545: PUSH
58546: LD_INT 10
58548: PUSH
58549: LD_INT 5
58551: PUSH
58552: LD_INT 3
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: LIST
58559: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58560: LD_VAR 0 6
58564: PPUSH
58565: CALL_OW 257
58569: PUSH
58570: LD_INT 14
58572: EQUAL
58573: IFFALSE 58594
// points := [ 10 , 0 , 0 ] ;
58575: LD_ADDR_VAR 0 9
58579: PUSH
58580: LD_INT 10
58582: PUSH
58583: LD_INT 0
58585: PUSH
58586: LD_INT 0
58588: PUSH
58589: EMPTY
58590: LIST
58591: LIST
58592: LIST
58593: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58594: LD_VAR 0 6
58598: PPUSH
58599: CALL_OW 257
58603: PUSH
58604: LD_INT 11
58606: EQUAL
58607: IFFALSE 58628
// points := [ 30 , 10 , 5 ] ;
58609: LD_ADDR_VAR 0 9
58613: PUSH
58614: LD_INT 30
58616: PUSH
58617: LD_INT 10
58619: PUSH
58620: LD_INT 5
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: LIST
58627: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58628: LD_VAR 0 1
58632: PPUSH
58633: LD_INT 5
58635: PPUSH
58636: CALL_OW 321
58640: PUSH
58641: LD_INT 2
58643: EQUAL
58644: IFFALSE 58661
// bpoints := bpoints * 1.8 ;
58646: LD_ADDR_VAR 0 10
58650: PUSH
58651: LD_VAR 0 10
58655: PUSH
58656: LD_REAL  1.80000000000000E+0000
58659: MUL
58660: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58661: LD_VAR 0 6
58665: PPUSH
58666: CALL_OW 257
58670: PUSH
58671: LD_INT 1
58673: PUSH
58674: LD_INT 2
58676: PUSH
58677: LD_INT 3
58679: PUSH
58680: LD_INT 4
58682: PUSH
58683: EMPTY
58684: LIST
58685: LIST
58686: LIST
58687: LIST
58688: IN
58689: PUSH
58690: LD_VAR 0 1
58694: PPUSH
58695: LD_INT 51
58697: PPUSH
58698: CALL_OW 321
58702: PUSH
58703: LD_INT 2
58705: EQUAL
58706: AND
58707: IFFALSE 58724
// bpoints := bpoints * 1.2 ;
58709: LD_ADDR_VAR 0 10
58713: PUSH
58714: LD_VAR 0 10
58718: PUSH
58719: LD_REAL  1.20000000000000E+0000
58722: MUL
58723: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58724: LD_VAR 0 6
58728: PPUSH
58729: CALL_OW 257
58733: PUSH
58734: LD_INT 5
58736: PUSH
58737: LD_INT 7
58739: PUSH
58740: LD_INT 9
58742: PUSH
58743: EMPTY
58744: LIST
58745: LIST
58746: LIST
58747: IN
58748: PUSH
58749: LD_VAR 0 1
58753: PPUSH
58754: LD_INT 52
58756: PPUSH
58757: CALL_OW 321
58761: PUSH
58762: LD_INT 2
58764: EQUAL
58765: AND
58766: IFFALSE 58783
// bpoints := bpoints * 1.5 ;
58768: LD_ADDR_VAR 0 10
58772: PUSH
58773: LD_VAR 0 10
58777: PUSH
58778: LD_REAL  1.50000000000000E+0000
58781: MUL
58782: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58783: LD_VAR 0 1
58787: PPUSH
58788: LD_INT 66
58790: PPUSH
58791: CALL_OW 321
58795: PUSH
58796: LD_INT 2
58798: EQUAL
58799: IFFALSE 58816
// bpoints := bpoints * 1.1 ;
58801: LD_ADDR_VAR 0 10
58805: PUSH
58806: LD_VAR 0 10
58810: PUSH
58811: LD_REAL  1.10000000000000E+0000
58814: MUL
58815: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58816: LD_ADDR_VAR 0 10
58820: PUSH
58821: LD_VAR 0 10
58825: PUSH
58826: LD_VAR 0 6
58830: PPUSH
58831: LD_INT 1
58833: PPUSH
58834: CALL_OW 259
58838: PUSH
58839: LD_REAL  1.15000000000000E+0000
58842: MUL
58843: MUL
58844: ST_TO_ADDR
// end ; unit_vehicle :
58845: GO 59675
58847: LD_INT 2
58849: DOUBLE
58850: EQUAL
58851: IFTRUE 58855
58853: GO 59663
58855: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58856: LD_VAR 0 6
58860: PPUSH
58861: CALL_OW 264
58865: PUSH
58866: LD_INT 2
58868: PUSH
58869: LD_INT 42
58871: PUSH
58872: LD_INT 24
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: LIST
58879: IN
58880: IFFALSE 58901
// points := [ 25 , 5 , 3 ] ;
58882: LD_ADDR_VAR 0 9
58886: PUSH
58887: LD_INT 25
58889: PUSH
58890: LD_INT 5
58892: PUSH
58893: LD_INT 3
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: LIST
58900: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58901: LD_VAR 0 6
58905: PPUSH
58906: CALL_OW 264
58910: PUSH
58911: LD_INT 4
58913: PUSH
58914: LD_INT 43
58916: PUSH
58917: LD_INT 25
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: LIST
58924: IN
58925: IFFALSE 58946
// points := [ 40 , 15 , 5 ] ;
58927: LD_ADDR_VAR 0 9
58931: PUSH
58932: LD_INT 40
58934: PUSH
58935: LD_INT 15
58937: PUSH
58938: LD_INT 5
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: LIST
58945: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58946: LD_VAR 0 6
58950: PPUSH
58951: CALL_OW 264
58955: PUSH
58956: LD_INT 3
58958: PUSH
58959: LD_INT 23
58961: PUSH
58962: EMPTY
58963: LIST
58964: LIST
58965: IN
58966: IFFALSE 58987
// points := [ 7 , 25 , 8 ] ;
58968: LD_ADDR_VAR 0 9
58972: PUSH
58973: LD_INT 7
58975: PUSH
58976: LD_INT 25
58978: PUSH
58979: LD_INT 8
58981: PUSH
58982: EMPTY
58983: LIST
58984: LIST
58985: LIST
58986: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58987: LD_VAR 0 6
58991: PPUSH
58992: CALL_OW 264
58996: PUSH
58997: LD_INT 5
58999: PUSH
59000: LD_INT 27
59002: PUSH
59003: LD_INT 44
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: LIST
59010: IN
59011: IFFALSE 59032
// points := [ 14 , 50 , 16 ] ;
59013: LD_ADDR_VAR 0 9
59017: PUSH
59018: LD_INT 14
59020: PUSH
59021: LD_INT 50
59023: PUSH
59024: LD_INT 16
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: LIST
59031: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59032: LD_VAR 0 6
59036: PPUSH
59037: CALL_OW 264
59041: PUSH
59042: LD_INT 6
59044: PUSH
59045: LD_INT 46
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: IN
59052: IFFALSE 59073
// points := [ 32 , 120 , 70 ] ;
59054: LD_ADDR_VAR 0 9
59058: PUSH
59059: LD_INT 32
59061: PUSH
59062: LD_INT 120
59064: PUSH
59065: LD_INT 70
59067: PUSH
59068: EMPTY
59069: LIST
59070: LIST
59071: LIST
59072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59073: LD_VAR 0 6
59077: PPUSH
59078: CALL_OW 264
59082: PUSH
59083: LD_INT 7
59085: PUSH
59086: LD_INT 28
59088: PUSH
59089: LD_INT 45
59091: PUSH
59092: LD_EXP 79
59096: PUSH
59097: EMPTY
59098: LIST
59099: LIST
59100: LIST
59101: LIST
59102: IN
59103: IFFALSE 59124
// points := [ 35 , 20 , 45 ] ;
59105: LD_ADDR_VAR 0 9
59109: PUSH
59110: LD_INT 35
59112: PUSH
59113: LD_INT 20
59115: PUSH
59116: LD_INT 45
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: LIST
59123: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59124: LD_VAR 0 6
59128: PPUSH
59129: CALL_OW 264
59133: PUSH
59134: LD_INT 47
59136: PUSH
59137: EMPTY
59138: LIST
59139: IN
59140: IFFALSE 59161
// points := [ 67 , 45 , 75 ] ;
59142: LD_ADDR_VAR 0 9
59146: PUSH
59147: LD_INT 67
59149: PUSH
59150: LD_INT 45
59152: PUSH
59153: LD_INT 75
59155: PUSH
59156: EMPTY
59157: LIST
59158: LIST
59159: LIST
59160: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59161: LD_VAR 0 6
59165: PPUSH
59166: CALL_OW 264
59170: PUSH
59171: LD_INT 26
59173: PUSH
59174: EMPTY
59175: LIST
59176: IN
59177: IFFALSE 59198
// points := [ 120 , 30 , 80 ] ;
59179: LD_ADDR_VAR 0 9
59183: PUSH
59184: LD_INT 120
59186: PUSH
59187: LD_INT 30
59189: PUSH
59190: LD_INT 80
59192: PUSH
59193: EMPTY
59194: LIST
59195: LIST
59196: LIST
59197: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59198: LD_VAR 0 6
59202: PPUSH
59203: CALL_OW 264
59207: PUSH
59208: LD_INT 22
59210: PUSH
59211: EMPTY
59212: LIST
59213: IN
59214: IFFALSE 59235
// points := [ 40 , 1 , 1 ] ;
59216: LD_ADDR_VAR 0 9
59220: PUSH
59221: LD_INT 40
59223: PUSH
59224: LD_INT 1
59226: PUSH
59227: LD_INT 1
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: LIST
59234: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59235: LD_VAR 0 6
59239: PPUSH
59240: CALL_OW 264
59244: PUSH
59245: LD_INT 29
59247: PUSH
59248: EMPTY
59249: LIST
59250: IN
59251: IFFALSE 59272
// points := [ 70 , 200 , 400 ] ;
59253: LD_ADDR_VAR 0 9
59257: PUSH
59258: LD_INT 70
59260: PUSH
59261: LD_INT 200
59263: PUSH
59264: LD_INT 400
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: LIST
59271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59272: LD_VAR 0 6
59276: PPUSH
59277: CALL_OW 264
59281: PUSH
59282: LD_INT 14
59284: PUSH
59285: LD_INT 53
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: IN
59292: IFFALSE 59313
// points := [ 40 , 10 , 20 ] ;
59294: LD_ADDR_VAR 0 9
59298: PUSH
59299: LD_INT 40
59301: PUSH
59302: LD_INT 10
59304: PUSH
59305: LD_INT 20
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: LIST
59312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59313: LD_VAR 0 6
59317: PPUSH
59318: CALL_OW 264
59322: PUSH
59323: LD_INT 9
59325: PUSH
59326: EMPTY
59327: LIST
59328: IN
59329: IFFALSE 59350
// points := [ 5 , 70 , 20 ] ;
59331: LD_ADDR_VAR 0 9
59335: PUSH
59336: LD_INT 5
59338: PUSH
59339: LD_INT 70
59341: PUSH
59342: LD_INT 20
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: LIST
59349: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59350: LD_VAR 0 6
59354: PPUSH
59355: CALL_OW 264
59359: PUSH
59360: LD_INT 10
59362: PUSH
59363: EMPTY
59364: LIST
59365: IN
59366: IFFALSE 59387
// points := [ 35 , 110 , 70 ] ;
59368: LD_ADDR_VAR 0 9
59372: PUSH
59373: LD_INT 35
59375: PUSH
59376: LD_INT 110
59378: PUSH
59379: LD_INT 70
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: LIST
59386: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59387: LD_VAR 0 6
59391: PPUSH
59392: CALL_OW 265
59396: PUSH
59397: LD_INT 25
59399: EQUAL
59400: IFFALSE 59421
// points := [ 80 , 65 , 100 ] ;
59402: LD_ADDR_VAR 0 9
59406: PUSH
59407: LD_INT 80
59409: PUSH
59410: LD_INT 65
59412: PUSH
59413: LD_INT 100
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: LIST
59420: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59421: LD_VAR 0 6
59425: PPUSH
59426: CALL_OW 263
59430: PUSH
59431: LD_INT 1
59433: EQUAL
59434: IFFALSE 59469
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59436: LD_ADDR_VAR 0 10
59440: PUSH
59441: LD_VAR 0 10
59445: PUSH
59446: LD_VAR 0 6
59450: PPUSH
59451: CALL_OW 311
59455: PPUSH
59456: LD_INT 3
59458: PPUSH
59459: CALL_OW 259
59463: PUSH
59464: LD_INT 4
59466: MUL
59467: MUL
59468: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59469: LD_VAR 0 6
59473: PPUSH
59474: CALL_OW 263
59478: PUSH
59479: LD_INT 2
59481: EQUAL
59482: IFFALSE 59533
// begin j := IsControledBy ( i ) ;
59484: LD_ADDR_VAR 0 7
59488: PUSH
59489: LD_VAR 0 6
59493: PPUSH
59494: CALL_OW 312
59498: ST_TO_ADDR
// if j then
59499: LD_VAR 0 7
59503: IFFALSE 59533
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59505: LD_ADDR_VAR 0 10
59509: PUSH
59510: LD_VAR 0 10
59514: PUSH
59515: LD_VAR 0 7
59519: PPUSH
59520: LD_INT 3
59522: PPUSH
59523: CALL_OW 259
59527: PUSH
59528: LD_INT 3
59530: MUL
59531: MUL
59532: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59533: LD_VAR 0 6
59537: PPUSH
59538: CALL_OW 264
59542: PUSH
59543: LD_INT 5
59545: PUSH
59546: LD_INT 6
59548: PUSH
59549: LD_INT 46
59551: PUSH
59552: LD_INT 44
59554: PUSH
59555: LD_INT 47
59557: PUSH
59558: LD_INT 45
59560: PUSH
59561: LD_INT 28
59563: PUSH
59564: LD_INT 7
59566: PUSH
59567: LD_INT 27
59569: PUSH
59570: LD_INT 29
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: LIST
59577: LIST
59578: LIST
59579: LIST
59580: LIST
59581: LIST
59582: LIST
59583: LIST
59584: IN
59585: PUSH
59586: LD_VAR 0 1
59590: PPUSH
59591: LD_INT 52
59593: PPUSH
59594: CALL_OW 321
59598: PUSH
59599: LD_INT 2
59601: EQUAL
59602: AND
59603: IFFALSE 59620
// bpoints := bpoints * 1.2 ;
59605: LD_ADDR_VAR 0 10
59609: PUSH
59610: LD_VAR 0 10
59614: PUSH
59615: LD_REAL  1.20000000000000E+0000
59618: MUL
59619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59620: LD_VAR 0 6
59624: PPUSH
59625: CALL_OW 264
59629: PUSH
59630: LD_INT 6
59632: PUSH
59633: LD_INT 46
59635: PUSH
59636: LD_INT 47
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: LIST
59643: IN
59644: IFFALSE 59661
// bpoints := bpoints * 1.2 ;
59646: LD_ADDR_VAR 0 10
59650: PUSH
59651: LD_VAR 0 10
59655: PUSH
59656: LD_REAL  1.20000000000000E+0000
59659: MUL
59660: ST_TO_ADDR
// end ; unit_building :
59661: GO 59675
59663: LD_INT 3
59665: DOUBLE
59666: EQUAL
59667: IFTRUE 59671
59669: GO 59674
59671: POP
// ; end ;
59672: GO 59675
59674: POP
// for j = 1 to 3 do
59675: LD_ADDR_VAR 0 7
59679: PUSH
59680: DOUBLE
59681: LD_INT 1
59683: DEC
59684: ST_TO_ADDR
59685: LD_INT 3
59687: PUSH
59688: FOR_TO
59689: IFFALSE 59742
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59691: LD_ADDR_VAR 0 5
59695: PUSH
59696: LD_VAR 0 5
59700: PPUSH
59701: LD_VAR 0 7
59705: PPUSH
59706: LD_VAR 0 5
59710: PUSH
59711: LD_VAR 0 7
59715: ARRAY
59716: PUSH
59717: LD_VAR 0 9
59721: PUSH
59722: LD_VAR 0 7
59726: ARRAY
59727: PUSH
59728: LD_VAR 0 10
59732: MUL
59733: PLUS
59734: PPUSH
59735: CALL_OW 1
59739: ST_TO_ADDR
59740: GO 59688
59742: POP
59743: POP
// end ;
59744: GO 58221
59746: POP
59747: POP
// result := Replace ( result , 4 , tmp ) ;
59748: LD_ADDR_VAR 0 5
59752: PUSH
59753: LD_VAR 0 5
59757: PPUSH
59758: LD_INT 4
59760: PPUSH
59761: LD_VAR 0 8
59765: PPUSH
59766: CALL_OW 1
59770: ST_TO_ADDR
// end ;
59771: LD_VAR 0 5
59775: RET
// export function DangerAtRange ( unit , range ) ; begin
59776: LD_INT 0
59778: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59779: LD_ADDR_VAR 0 3
59783: PUSH
59784: LD_VAR 0 1
59788: PPUSH
59789: CALL_OW 255
59793: PPUSH
59794: LD_VAR 0 1
59798: PPUSH
59799: CALL_OW 250
59803: PPUSH
59804: LD_VAR 0 1
59808: PPUSH
59809: CALL_OW 251
59813: PPUSH
59814: LD_VAR 0 2
59818: PPUSH
59819: CALL 58073 0 4
59823: ST_TO_ADDR
// end ;
59824: LD_VAR 0 3
59828: RET
// export function DangerInArea ( side , area ) ; begin
59829: LD_INT 0
59831: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59832: LD_ADDR_VAR 0 3
59836: PUSH
59837: LD_VAR 0 2
59841: PPUSH
59842: LD_INT 81
59844: PUSH
59845: LD_VAR 0 1
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PPUSH
59854: CALL_OW 70
59858: ST_TO_ADDR
// end ;
59859: LD_VAR 0 3
59863: RET
// export function IsExtension ( b ) ; begin
59864: LD_INT 0
59866: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59867: LD_ADDR_VAR 0 2
59871: PUSH
59872: LD_VAR 0 1
59876: PUSH
59877: LD_INT 23
59879: PUSH
59880: LD_INT 20
59882: PUSH
59883: LD_INT 22
59885: PUSH
59886: LD_INT 17
59888: PUSH
59889: LD_INT 24
59891: PUSH
59892: LD_INT 21
59894: PUSH
59895: LD_INT 19
59897: PUSH
59898: LD_INT 16
59900: PUSH
59901: LD_INT 25
59903: PUSH
59904: LD_INT 18
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: LIST
59911: LIST
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: LIST
59917: LIST
59918: IN
59919: ST_TO_ADDR
// end ;
59920: LD_VAR 0 2
59924: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59925: LD_INT 0
59927: PPUSH
59928: PPUSH
59929: PPUSH
// result := [ ] ;
59930: LD_ADDR_VAR 0 4
59934: PUSH
59935: EMPTY
59936: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59937: LD_ADDR_VAR 0 5
59941: PUSH
59942: LD_VAR 0 2
59946: PPUSH
59947: LD_INT 21
59949: PUSH
59950: LD_INT 3
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PPUSH
59957: CALL_OW 70
59961: ST_TO_ADDR
// if not tmp then
59962: LD_VAR 0 5
59966: NOT
59967: IFFALSE 59971
// exit ;
59969: GO 60035
// if checkLink then
59971: LD_VAR 0 3
59975: IFFALSE 60025
// begin for i in tmp do
59977: LD_ADDR_VAR 0 6
59981: PUSH
59982: LD_VAR 0 5
59986: PUSH
59987: FOR_IN
59988: IFFALSE 60023
// if GetBase ( i ) <> base then
59990: LD_VAR 0 6
59994: PPUSH
59995: CALL_OW 274
59999: PUSH
60000: LD_VAR 0 1
60004: NONEQUAL
60005: IFFALSE 60021
// ComLinkToBase ( base , i ) ;
60007: LD_VAR 0 1
60011: PPUSH
60012: LD_VAR 0 6
60016: PPUSH
60017: CALL_OW 169
60021: GO 59987
60023: POP
60024: POP
// end ; result := tmp ;
60025: LD_ADDR_VAR 0 4
60029: PUSH
60030: LD_VAR 0 5
60034: ST_TO_ADDR
// end ;
60035: LD_VAR 0 4
60039: RET
// export function ComComplete ( units , b ) ; var i ; begin
60040: LD_INT 0
60042: PPUSH
60043: PPUSH
// if not units then
60044: LD_VAR 0 1
60048: NOT
60049: IFFALSE 60053
// exit ;
60051: GO 60143
// for i in units do
60053: LD_ADDR_VAR 0 4
60057: PUSH
60058: LD_VAR 0 1
60062: PUSH
60063: FOR_IN
60064: IFFALSE 60141
// if BuildingStatus ( b ) = bs_build then
60066: LD_VAR 0 2
60070: PPUSH
60071: CALL_OW 461
60075: PUSH
60076: LD_INT 1
60078: EQUAL
60079: IFFALSE 60139
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60081: LD_VAR 0 4
60085: PPUSH
60086: LD_STRING h
60088: PUSH
60089: LD_VAR 0 2
60093: PPUSH
60094: CALL_OW 250
60098: PUSH
60099: LD_VAR 0 2
60103: PPUSH
60104: CALL_OW 251
60108: PUSH
60109: LD_VAR 0 2
60113: PUSH
60114: LD_INT 0
60116: PUSH
60117: LD_INT 0
60119: PUSH
60120: LD_INT 0
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: LIST
60127: LIST
60128: LIST
60129: LIST
60130: LIST
60131: PUSH
60132: EMPTY
60133: LIST
60134: PPUSH
60135: CALL_OW 446
60139: GO 60063
60141: POP
60142: POP
// end ;
60143: LD_VAR 0 3
60147: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60148: LD_INT 0
60150: PPUSH
60151: PPUSH
60152: PPUSH
60153: PPUSH
60154: PPUSH
60155: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60156: LD_VAR 0 1
60160: NOT
60161: PUSH
60162: LD_VAR 0 1
60166: PPUSH
60167: CALL_OW 263
60171: PUSH
60172: LD_INT 2
60174: NONEQUAL
60175: OR
60176: IFFALSE 60180
// exit ;
60178: GO 60496
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60180: LD_ADDR_VAR 0 6
60184: PUSH
60185: LD_INT 22
60187: PUSH
60188: LD_VAR 0 1
60192: PPUSH
60193: CALL_OW 255
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 2
60204: PUSH
60205: LD_INT 30
60207: PUSH
60208: LD_INT 36
60210: PUSH
60211: EMPTY
60212: LIST
60213: LIST
60214: PUSH
60215: LD_INT 34
60217: PUSH
60218: LD_INT 31
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: EMPTY
60226: LIST
60227: LIST
60228: LIST
60229: PUSH
60230: EMPTY
60231: LIST
60232: LIST
60233: PPUSH
60234: CALL_OW 69
60238: ST_TO_ADDR
// if not tmp then
60239: LD_VAR 0 6
60243: NOT
60244: IFFALSE 60248
// exit ;
60246: GO 60496
// result := [ ] ;
60248: LD_ADDR_VAR 0 2
60252: PUSH
60253: EMPTY
60254: ST_TO_ADDR
// for i in tmp do
60255: LD_ADDR_VAR 0 3
60259: PUSH
60260: LD_VAR 0 6
60264: PUSH
60265: FOR_IN
60266: IFFALSE 60337
// begin t := UnitsInside ( i ) ;
60268: LD_ADDR_VAR 0 4
60272: PUSH
60273: LD_VAR 0 3
60277: PPUSH
60278: CALL_OW 313
60282: ST_TO_ADDR
// if t then
60283: LD_VAR 0 4
60287: IFFALSE 60335
// for j in t do
60289: LD_ADDR_VAR 0 7
60293: PUSH
60294: LD_VAR 0 4
60298: PUSH
60299: FOR_IN
60300: IFFALSE 60333
// result := Replace ( result , result + 1 , j ) ;
60302: LD_ADDR_VAR 0 2
60306: PUSH
60307: LD_VAR 0 2
60311: PPUSH
60312: LD_VAR 0 2
60316: PUSH
60317: LD_INT 1
60319: PLUS
60320: PPUSH
60321: LD_VAR 0 7
60325: PPUSH
60326: CALL_OW 1
60330: ST_TO_ADDR
60331: GO 60299
60333: POP
60334: POP
// end ;
60335: GO 60265
60337: POP
60338: POP
// if not result then
60339: LD_VAR 0 2
60343: NOT
60344: IFFALSE 60348
// exit ;
60346: GO 60496
// mech := result [ 1 ] ;
60348: LD_ADDR_VAR 0 5
60352: PUSH
60353: LD_VAR 0 2
60357: PUSH
60358: LD_INT 1
60360: ARRAY
60361: ST_TO_ADDR
// if result > 1 then
60362: LD_VAR 0 2
60366: PUSH
60367: LD_INT 1
60369: GREATER
60370: IFFALSE 60482
// begin for i = 2 to result do
60372: LD_ADDR_VAR 0 3
60376: PUSH
60377: DOUBLE
60378: LD_INT 2
60380: DEC
60381: ST_TO_ADDR
60382: LD_VAR 0 2
60386: PUSH
60387: FOR_TO
60388: IFFALSE 60480
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60390: LD_ADDR_VAR 0 4
60394: PUSH
60395: LD_VAR 0 2
60399: PUSH
60400: LD_VAR 0 3
60404: ARRAY
60405: PPUSH
60406: LD_INT 3
60408: PPUSH
60409: CALL_OW 259
60413: PUSH
60414: LD_VAR 0 2
60418: PUSH
60419: LD_VAR 0 3
60423: ARRAY
60424: PPUSH
60425: CALL_OW 432
60429: MINUS
60430: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60431: LD_VAR 0 4
60435: PUSH
60436: LD_VAR 0 5
60440: PPUSH
60441: LD_INT 3
60443: PPUSH
60444: CALL_OW 259
60448: PUSH
60449: LD_VAR 0 5
60453: PPUSH
60454: CALL_OW 432
60458: MINUS
60459: GREATEREQUAL
60460: IFFALSE 60478
// mech := result [ i ] ;
60462: LD_ADDR_VAR 0 5
60466: PUSH
60467: LD_VAR 0 2
60471: PUSH
60472: LD_VAR 0 3
60476: ARRAY
60477: ST_TO_ADDR
// end ;
60478: GO 60387
60480: POP
60481: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60482: LD_VAR 0 1
60486: PPUSH
60487: LD_VAR 0 5
60491: PPUSH
60492: CALL_OW 135
// end ;
60496: LD_VAR 0 2
60500: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60501: LD_INT 0
60503: PPUSH
60504: PPUSH
60505: PPUSH
60506: PPUSH
60507: PPUSH
60508: PPUSH
60509: PPUSH
60510: PPUSH
60511: PPUSH
60512: PPUSH
60513: PPUSH
60514: PPUSH
60515: PPUSH
// result := [ ] ;
60516: LD_ADDR_VAR 0 7
60520: PUSH
60521: EMPTY
60522: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60523: LD_VAR 0 1
60527: PPUSH
60528: CALL_OW 266
60532: PUSH
60533: LD_INT 0
60535: PUSH
60536: LD_INT 1
60538: PUSH
60539: EMPTY
60540: LIST
60541: LIST
60542: IN
60543: NOT
60544: IFFALSE 60548
// exit ;
60546: GO 62182
// if name then
60548: LD_VAR 0 3
60552: IFFALSE 60568
// SetBName ( base_dep , name ) ;
60554: LD_VAR 0 1
60558: PPUSH
60559: LD_VAR 0 3
60563: PPUSH
60564: CALL_OW 500
// base := GetBase ( base_dep ) ;
60568: LD_ADDR_VAR 0 15
60572: PUSH
60573: LD_VAR 0 1
60577: PPUSH
60578: CALL_OW 274
60582: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60583: LD_ADDR_VAR 0 16
60587: PUSH
60588: LD_VAR 0 1
60592: PPUSH
60593: CALL_OW 255
60597: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60598: LD_ADDR_VAR 0 17
60602: PUSH
60603: LD_VAR 0 1
60607: PPUSH
60608: CALL_OW 248
60612: ST_TO_ADDR
// if sources then
60613: LD_VAR 0 5
60617: IFFALSE 60664
// for i = 1 to 3 do
60619: LD_ADDR_VAR 0 8
60623: PUSH
60624: DOUBLE
60625: LD_INT 1
60627: DEC
60628: ST_TO_ADDR
60629: LD_INT 3
60631: PUSH
60632: FOR_TO
60633: IFFALSE 60662
// AddResourceType ( base , i , sources [ i ] ) ;
60635: LD_VAR 0 15
60639: PPUSH
60640: LD_VAR 0 8
60644: PPUSH
60645: LD_VAR 0 5
60649: PUSH
60650: LD_VAR 0 8
60654: ARRAY
60655: PPUSH
60656: CALL_OW 276
60660: GO 60632
60662: POP
60663: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60664: LD_ADDR_VAR 0 18
60668: PUSH
60669: LD_VAR 0 15
60673: PPUSH
60674: LD_VAR 0 2
60678: PPUSH
60679: LD_INT 1
60681: PPUSH
60682: CALL 59925 0 3
60686: ST_TO_ADDR
// InitHc ;
60687: CALL_OW 19
// InitUc ;
60691: CALL_OW 18
// uc_side := side ;
60695: LD_ADDR_OWVAR 20
60699: PUSH
60700: LD_VAR 0 16
60704: ST_TO_ADDR
// uc_nation := nation ;
60705: LD_ADDR_OWVAR 21
60709: PUSH
60710: LD_VAR 0 17
60714: ST_TO_ADDR
// if buildings then
60715: LD_VAR 0 18
60719: IFFALSE 62041
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60721: LD_ADDR_VAR 0 19
60725: PUSH
60726: LD_VAR 0 18
60730: PPUSH
60731: LD_INT 2
60733: PUSH
60734: LD_INT 30
60736: PUSH
60737: LD_INT 29
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 30
60746: PUSH
60747: LD_INT 30
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: PPUSH
60759: CALL_OW 72
60763: ST_TO_ADDR
// if tmp then
60764: LD_VAR 0 19
60768: IFFALSE 60816
// for i in tmp do
60770: LD_ADDR_VAR 0 8
60774: PUSH
60775: LD_VAR 0 19
60779: PUSH
60780: FOR_IN
60781: IFFALSE 60814
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60783: LD_VAR 0 8
60787: PPUSH
60788: CALL_OW 250
60792: PPUSH
60793: LD_VAR 0 8
60797: PPUSH
60798: CALL_OW 251
60802: PPUSH
60803: LD_VAR 0 16
60807: PPUSH
60808: CALL_OW 441
60812: GO 60780
60814: POP
60815: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60816: LD_VAR 0 18
60820: PPUSH
60821: LD_INT 2
60823: PUSH
60824: LD_INT 30
60826: PUSH
60827: LD_INT 32
60829: PUSH
60830: EMPTY
60831: LIST
60832: LIST
60833: PUSH
60834: LD_INT 30
60836: PUSH
60837: LD_INT 33
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: LIST
60848: PPUSH
60849: CALL_OW 72
60853: IFFALSE 60941
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60855: LD_ADDR_VAR 0 8
60859: PUSH
60860: LD_VAR 0 18
60864: PPUSH
60865: LD_INT 2
60867: PUSH
60868: LD_INT 30
60870: PUSH
60871: LD_INT 32
60873: PUSH
60874: EMPTY
60875: LIST
60876: LIST
60877: PUSH
60878: LD_INT 30
60880: PUSH
60881: LD_INT 33
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: LIST
60892: PPUSH
60893: CALL_OW 72
60897: PUSH
60898: FOR_IN
60899: IFFALSE 60939
// begin if not GetBWeapon ( i ) then
60901: LD_VAR 0 8
60905: PPUSH
60906: CALL_OW 269
60910: NOT
60911: IFFALSE 60937
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60913: LD_VAR 0 8
60917: PPUSH
60918: LD_VAR 0 8
60922: PPUSH
60923: LD_VAR 0 2
60927: PPUSH
60928: CALL 62187 0 2
60932: PPUSH
60933: CALL_OW 431
// end ;
60937: GO 60898
60939: POP
60940: POP
// end ; for i = 1 to personel do
60941: LD_ADDR_VAR 0 8
60945: PUSH
60946: DOUBLE
60947: LD_INT 1
60949: DEC
60950: ST_TO_ADDR
60951: LD_VAR 0 6
60955: PUSH
60956: FOR_TO
60957: IFFALSE 62021
// begin if i > 4 then
60959: LD_VAR 0 8
60963: PUSH
60964: LD_INT 4
60966: GREATER
60967: IFFALSE 60971
// break ;
60969: GO 62021
// case i of 1 :
60971: LD_VAR 0 8
60975: PUSH
60976: LD_INT 1
60978: DOUBLE
60979: EQUAL
60980: IFTRUE 60984
60982: GO 61064
60984: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60985: LD_ADDR_VAR 0 12
60989: PUSH
60990: LD_VAR 0 18
60994: PPUSH
60995: LD_INT 22
60997: PUSH
60998: LD_VAR 0 16
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 58
61009: PUSH
61010: EMPTY
61011: LIST
61012: PUSH
61013: LD_INT 2
61015: PUSH
61016: LD_INT 30
61018: PUSH
61019: LD_INT 32
61021: PUSH
61022: EMPTY
61023: LIST
61024: LIST
61025: PUSH
61026: LD_INT 30
61028: PUSH
61029: LD_INT 4
61031: PUSH
61032: EMPTY
61033: LIST
61034: LIST
61035: PUSH
61036: LD_INT 30
61038: PUSH
61039: LD_INT 5
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: EMPTY
61047: LIST
61048: LIST
61049: LIST
61050: LIST
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: LIST
61056: PPUSH
61057: CALL_OW 72
61061: ST_TO_ADDR
61062: GO 61286
61064: LD_INT 2
61066: DOUBLE
61067: EQUAL
61068: IFTRUE 61072
61070: GO 61134
61072: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61073: LD_ADDR_VAR 0 12
61077: PUSH
61078: LD_VAR 0 18
61082: PPUSH
61083: LD_INT 22
61085: PUSH
61086: LD_VAR 0 16
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: PUSH
61095: LD_INT 2
61097: PUSH
61098: LD_INT 30
61100: PUSH
61101: LD_INT 0
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PUSH
61108: LD_INT 30
61110: PUSH
61111: LD_INT 1
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: LIST
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PPUSH
61127: CALL_OW 72
61131: ST_TO_ADDR
61132: GO 61286
61134: LD_INT 3
61136: DOUBLE
61137: EQUAL
61138: IFTRUE 61142
61140: GO 61204
61142: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61143: LD_ADDR_VAR 0 12
61147: PUSH
61148: LD_VAR 0 18
61152: PPUSH
61153: LD_INT 22
61155: PUSH
61156: LD_VAR 0 16
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: PUSH
61165: LD_INT 2
61167: PUSH
61168: LD_INT 30
61170: PUSH
61171: LD_INT 2
61173: PUSH
61174: EMPTY
61175: LIST
61176: LIST
61177: PUSH
61178: LD_INT 30
61180: PUSH
61181: LD_INT 3
61183: PUSH
61184: EMPTY
61185: LIST
61186: LIST
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: LIST
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: PPUSH
61197: CALL_OW 72
61201: ST_TO_ADDR
61202: GO 61286
61204: LD_INT 4
61206: DOUBLE
61207: EQUAL
61208: IFTRUE 61212
61210: GO 61285
61212: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61213: LD_ADDR_VAR 0 12
61217: PUSH
61218: LD_VAR 0 18
61222: PPUSH
61223: LD_INT 22
61225: PUSH
61226: LD_VAR 0 16
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: PUSH
61235: LD_INT 2
61237: PUSH
61238: LD_INT 30
61240: PUSH
61241: LD_INT 6
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PUSH
61248: LD_INT 30
61250: PUSH
61251: LD_INT 7
61253: PUSH
61254: EMPTY
61255: LIST
61256: LIST
61257: PUSH
61258: LD_INT 30
61260: PUSH
61261: LD_INT 8
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: LIST
61272: LIST
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PPUSH
61278: CALL_OW 72
61282: ST_TO_ADDR
61283: GO 61286
61285: POP
// if i = 1 then
61286: LD_VAR 0 8
61290: PUSH
61291: LD_INT 1
61293: EQUAL
61294: IFFALSE 61405
// begin tmp := [ ] ;
61296: LD_ADDR_VAR 0 19
61300: PUSH
61301: EMPTY
61302: ST_TO_ADDR
// for j in f do
61303: LD_ADDR_VAR 0 9
61307: PUSH
61308: LD_VAR 0 12
61312: PUSH
61313: FOR_IN
61314: IFFALSE 61387
// if GetBType ( j ) = b_bunker then
61316: LD_VAR 0 9
61320: PPUSH
61321: CALL_OW 266
61325: PUSH
61326: LD_INT 32
61328: EQUAL
61329: IFFALSE 61356
// tmp := Insert ( tmp , 1 , j ) else
61331: LD_ADDR_VAR 0 19
61335: PUSH
61336: LD_VAR 0 19
61340: PPUSH
61341: LD_INT 1
61343: PPUSH
61344: LD_VAR 0 9
61348: PPUSH
61349: CALL_OW 2
61353: ST_TO_ADDR
61354: GO 61385
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61356: LD_ADDR_VAR 0 19
61360: PUSH
61361: LD_VAR 0 19
61365: PPUSH
61366: LD_VAR 0 19
61370: PUSH
61371: LD_INT 1
61373: PLUS
61374: PPUSH
61375: LD_VAR 0 9
61379: PPUSH
61380: CALL_OW 2
61384: ST_TO_ADDR
61385: GO 61313
61387: POP
61388: POP
// if tmp then
61389: LD_VAR 0 19
61393: IFFALSE 61405
// f := tmp ;
61395: LD_ADDR_VAR 0 12
61399: PUSH
61400: LD_VAR 0 19
61404: ST_TO_ADDR
// end ; x := personel [ i ] ;
61405: LD_ADDR_VAR 0 13
61409: PUSH
61410: LD_VAR 0 6
61414: PUSH
61415: LD_VAR 0 8
61419: ARRAY
61420: ST_TO_ADDR
// if x = - 1 then
61421: LD_VAR 0 13
61425: PUSH
61426: LD_INT 1
61428: NEG
61429: EQUAL
61430: IFFALSE 61639
// begin for j in f do
61432: LD_ADDR_VAR 0 9
61436: PUSH
61437: LD_VAR 0 12
61441: PUSH
61442: FOR_IN
61443: IFFALSE 61635
// repeat InitHc ;
61445: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61449: LD_VAR 0 9
61453: PPUSH
61454: CALL_OW 266
61458: PUSH
61459: LD_INT 5
61461: EQUAL
61462: IFFALSE 61532
// begin if UnitsInside ( j ) < 3 then
61464: LD_VAR 0 9
61468: PPUSH
61469: CALL_OW 313
61473: PUSH
61474: LD_INT 3
61476: LESS
61477: IFFALSE 61513
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61479: LD_INT 0
61481: PPUSH
61482: LD_INT 5
61484: PUSH
61485: LD_INT 8
61487: PUSH
61488: LD_INT 9
61490: PUSH
61491: EMPTY
61492: LIST
61493: LIST
61494: LIST
61495: PUSH
61496: LD_VAR 0 17
61500: ARRAY
61501: PPUSH
61502: LD_VAR 0 4
61506: PPUSH
61507: CALL_OW 380
61511: GO 61530
// PrepareHuman ( false , i , skill ) ;
61513: LD_INT 0
61515: PPUSH
61516: LD_VAR 0 8
61520: PPUSH
61521: LD_VAR 0 4
61525: PPUSH
61526: CALL_OW 380
// end else
61530: GO 61549
// PrepareHuman ( false , i , skill ) ;
61532: LD_INT 0
61534: PPUSH
61535: LD_VAR 0 8
61539: PPUSH
61540: LD_VAR 0 4
61544: PPUSH
61545: CALL_OW 380
// un := CreateHuman ;
61549: LD_ADDR_VAR 0 14
61553: PUSH
61554: CALL_OW 44
61558: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61559: LD_ADDR_VAR 0 7
61563: PUSH
61564: LD_VAR 0 7
61568: PPUSH
61569: LD_INT 1
61571: PPUSH
61572: LD_VAR 0 14
61576: PPUSH
61577: CALL_OW 2
61581: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61582: LD_VAR 0 14
61586: PPUSH
61587: LD_VAR 0 9
61591: PPUSH
61592: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61596: LD_VAR 0 9
61600: PPUSH
61601: CALL_OW 313
61605: PUSH
61606: LD_INT 6
61608: EQUAL
61609: PUSH
61610: LD_VAR 0 9
61614: PPUSH
61615: CALL_OW 266
61619: PUSH
61620: LD_INT 32
61622: PUSH
61623: LD_INT 31
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: IN
61630: OR
61631: IFFALSE 61445
61633: GO 61442
61635: POP
61636: POP
// end else
61637: GO 62019
// for j = 1 to x do
61639: LD_ADDR_VAR 0 9
61643: PUSH
61644: DOUBLE
61645: LD_INT 1
61647: DEC
61648: ST_TO_ADDR
61649: LD_VAR 0 13
61653: PUSH
61654: FOR_TO
61655: IFFALSE 62017
// begin InitHc ;
61657: CALL_OW 19
// if not f then
61661: LD_VAR 0 12
61665: NOT
61666: IFFALSE 61755
// begin PrepareHuman ( false , i , skill ) ;
61668: LD_INT 0
61670: PPUSH
61671: LD_VAR 0 8
61675: PPUSH
61676: LD_VAR 0 4
61680: PPUSH
61681: CALL_OW 380
// un := CreateHuman ;
61685: LD_ADDR_VAR 0 14
61689: PUSH
61690: CALL_OW 44
61694: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61695: LD_ADDR_VAR 0 7
61699: PUSH
61700: LD_VAR 0 7
61704: PPUSH
61705: LD_INT 1
61707: PPUSH
61708: LD_VAR 0 14
61712: PPUSH
61713: CALL_OW 2
61717: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61718: LD_VAR 0 14
61722: PPUSH
61723: LD_VAR 0 1
61727: PPUSH
61728: CALL_OW 250
61732: PPUSH
61733: LD_VAR 0 1
61737: PPUSH
61738: CALL_OW 251
61742: PPUSH
61743: LD_INT 10
61745: PPUSH
61746: LD_INT 0
61748: PPUSH
61749: CALL_OW 50
// continue ;
61753: GO 61654
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61755: LD_VAR 0 12
61759: PUSH
61760: LD_INT 1
61762: ARRAY
61763: PPUSH
61764: CALL_OW 313
61768: PUSH
61769: LD_VAR 0 12
61773: PUSH
61774: LD_INT 1
61776: ARRAY
61777: PPUSH
61778: CALL_OW 266
61782: PUSH
61783: LD_INT 32
61785: PUSH
61786: LD_INT 31
61788: PUSH
61789: EMPTY
61790: LIST
61791: LIST
61792: IN
61793: AND
61794: PUSH
61795: LD_VAR 0 12
61799: PUSH
61800: LD_INT 1
61802: ARRAY
61803: PPUSH
61804: CALL_OW 313
61808: PUSH
61809: LD_INT 6
61811: EQUAL
61812: OR
61813: IFFALSE 61833
// f := Delete ( f , 1 ) ;
61815: LD_ADDR_VAR 0 12
61819: PUSH
61820: LD_VAR 0 12
61824: PPUSH
61825: LD_INT 1
61827: PPUSH
61828: CALL_OW 3
61832: ST_TO_ADDR
// if not f then
61833: LD_VAR 0 12
61837: NOT
61838: IFFALSE 61856
// begin x := x + 2 ;
61840: LD_ADDR_VAR 0 13
61844: PUSH
61845: LD_VAR 0 13
61849: PUSH
61850: LD_INT 2
61852: PLUS
61853: ST_TO_ADDR
// continue ;
61854: GO 61654
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61856: LD_VAR 0 12
61860: PUSH
61861: LD_INT 1
61863: ARRAY
61864: PPUSH
61865: CALL_OW 266
61869: PUSH
61870: LD_INT 5
61872: EQUAL
61873: IFFALSE 61947
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61875: LD_VAR 0 12
61879: PUSH
61880: LD_INT 1
61882: ARRAY
61883: PPUSH
61884: CALL_OW 313
61888: PUSH
61889: LD_INT 3
61891: LESS
61892: IFFALSE 61928
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61894: LD_INT 0
61896: PPUSH
61897: LD_INT 5
61899: PUSH
61900: LD_INT 8
61902: PUSH
61903: LD_INT 9
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: LIST
61910: PUSH
61911: LD_VAR 0 17
61915: ARRAY
61916: PPUSH
61917: LD_VAR 0 4
61921: PPUSH
61922: CALL_OW 380
61926: GO 61945
// PrepareHuman ( false , i , skill ) ;
61928: LD_INT 0
61930: PPUSH
61931: LD_VAR 0 8
61935: PPUSH
61936: LD_VAR 0 4
61940: PPUSH
61941: CALL_OW 380
// end else
61945: GO 61964
// PrepareHuman ( false , i , skill ) ;
61947: LD_INT 0
61949: PPUSH
61950: LD_VAR 0 8
61954: PPUSH
61955: LD_VAR 0 4
61959: PPUSH
61960: CALL_OW 380
// un := CreateHuman ;
61964: LD_ADDR_VAR 0 14
61968: PUSH
61969: CALL_OW 44
61973: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61974: LD_ADDR_VAR 0 7
61978: PUSH
61979: LD_VAR 0 7
61983: PPUSH
61984: LD_INT 1
61986: PPUSH
61987: LD_VAR 0 14
61991: PPUSH
61992: CALL_OW 2
61996: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61997: LD_VAR 0 14
62001: PPUSH
62002: LD_VAR 0 12
62006: PUSH
62007: LD_INT 1
62009: ARRAY
62010: PPUSH
62011: CALL_OW 52
// end ;
62015: GO 61654
62017: POP
62018: POP
// end ;
62019: GO 60956
62021: POP
62022: POP
// result := result ^ buildings ;
62023: LD_ADDR_VAR 0 7
62027: PUSH
62028: LD_VAR 0 7
62032: PUSH
62033: LD_VAR 0 18
62037: ADD
62038: ST_TO_ADDR
// end else
62039: GO 62182
// begin for i = 1 to personel do
62041: LD_ADDR_VAR 0 8
62045: PUSH
62046: DOUBLE
62047: LD_INT 1
62049: DEC
62050: ST_TO_ADDR
62051: LD_VAR 0 6
62055: PUSH
62056: FOR_TO
62057: IFFALSE 62180
// begin if i > 4 then
62059: LD_VAR 0 8
62063: PUSH
62064: LD_INT 4
62066: GREATER
62067: IFFALSE 62071
// break ;
62069: GO 62180
// x := personel [ i ] ;
62071: LD_ADDR_VAR 0 13
62075: PUSH
62076: LD_VAR 0 6
62080: PUSH
62081: LD_VAR 0 8
62085: ARRAY
62086: ST_TO_ADDR
// if x = - 1 then
62087: LD_VAR 0 13
62091: PUSH
62092: LD_INT 1
62094: NEG
62095: EQUAL
62096: IFFALSE 62100
// continue ;
62098: GO 62056
// PrepareHuman ( false , i , skill ) ;
62100: LD_INT 0
62102: PPUSH
62103: LD_VAR 0 8
62107: PPUSH
62108: LD_VAR 0 4
62112: PPUSH
62113: CALL_OW 380
// un := CreateHuman ;
62117: LD_ADDR_VAR 0 14
62121: PUSH
62122: CALL_OW 44
62126: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62127: LD_VAR 0 14
62131: PPUSH
62132: LD_VAR 0 1
62136: PPUSH
62137: CALL_OW 250
62141: PPUSH
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 251
62151: PPUSH
62152: LD_INT 10
62154: PPUSH
62155: LD_INT 0
62157: PPUSH
62158: CALL_OW 50
// result := result ^ un ;
62162: LD_ADDR_VAR 0 7
62166: PUSH
62167: LD_VAR 0 7
62171: PUSH
62172: LD_VAR 0 14
62176: ADD
62177: ST_TO_ADDR
// end ;
62178: GO 62056
62180: POP
62181: POP
// end ; end ;
62182: LD_VAR 0 7
62186: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62187: LD_INT 0
62189: PPUSH
62190: PPUSH
62191: PPUSH
62192: PPUSH
62193: PPUSH
62194: PPUSH
62195: PPUSH
62196: PPUSH
62197: PPUSH
62198: PPUSH
62199: PPUSH
62200: PPUSH
62201: PPUSH
62202: PPUSH
62203: PPUSH
62204: PPUSH
// result := false ;
62205: LD_ADDR_VAR 0 3
62209: PUSH
62210: LD_INT 0
62212: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62213: LD_VAR 0 1
62217: NOT
62218: PUSH
62219: LD_VAR 0 1
62223: PPUSH
62224: CALL_OW 266
62228: PUSH
62229: LD_INT 32
62231: PUSH
62232: LD_INT 33
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: IN
62239: NOT
62240: OR
62241: IFFALSE 62245
// exit ;
62243: GO 63354
// nat := GetNation ( tower ) ;
62245: LD_ADDR_VAR 0 12
62249: PUSH
62250: LD_VAR 0 1
62254: PPUSH
62255: CALL_OW 248
62259: ST_TO_ADDR
// side := GetSide ( tower ) ;
62260: LD_ADDR_VAR 0 16
62264: PUSH
62265: LD_VAR 0 1
62269: PPUSH
62270: CALL_OW 255
62274: ST_TO_ADDR
// x := GetX ( tower ) ;
62275: LD_ADDR_VAR 0 10
62279: PUSH
62280: LD_VAR 0 1
62284: PPUSH
62285: CALL_OW 250
62289: ST_TO_ADDR
// y := GetY ( tower ) ;
62290: LD_ADDR_VAR 0 11
62294: PUSH
62295: LD_VAR 0 1
62299: PPUSH
62300: CALL_OW 251
62304: ST_TO_ADDR
// if not x or not y then
62305: LD_VAR 0 10
62309: NOT
62310: PUSH
62311: LD_VAR 0 11
62315: NOT
62316: OR
62317: IFFALSE 62321
// exit ;
62319: GO 63354
// weapon := 0 ;
62321: LD_ADDR_VAR 0 18
62325: PUSH
62326: LD_INT 0
62328: ST_TO_ADDR
// fac_list := [ ] ;
62329: LD_ADDR_VAR 0 17
62333: PUSH
62334: EMPTY
62335: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62336: LD_ADDR_VAR 0 6
62340: PUSH
62341: LD_VAR 0 1
62345: PPUSH
62346: CALL_OW 274
62350: PPUSH
62351: LD_VAR 0 2
62355: PPUSH
62356: LD_INT 0
62358: PPUSH
62359: CALL 59925 0 3
62363: PPUSH
62364: LD_INT 30
62366: PUSH
62367: LD_INT 3
62369: PUSH
62370: EMPTY
62371: LIST
62372: LIST
62373: PPUSH
62374: CALL_OW 72
62378: ST_TO_ADDR
// if not factories then
62379: LD_VAR 0 6
62383: NOT
62384: IFFALSE 62388
// exit ;
62386: GO 63354
// for i in factories do
62388: LD_ADDR_VAR 0 8
62392: PUSH
62393: LD_VAR 0 6
62397: PUSH
62398: FOR_IN
62399: IFFALSE 62424
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62401: LD_ADDR_VAR 0 17
62405: PUSH
62406: LD_VAR 0 17
62410: PUSH
62411: LD_VAR 0 8
62415: PPUSH
62416: CALL_OW 478
62420: UNION
62421: ST_TO_ADDR
62422: GO 62398
62424: POP
62425: POP
// if not fac_list then
62426: LD_VAR 0 17
62430: NOT
62431: IFFALSE 62435
// exit ;
62433: GO 63354
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62435: LD_ADDR_VAR 0 5
62439: PUSH
62440: LD_INT 4
62442: PUSH
62443: LD_INT 5
62445: PUSH
62446: LD_INT 9
62448: PUSH
62449: LD_INT 10
62451: PUSH
62452: LD_INT 6
62454: PUSH
62455: LD_INT 7
62457: PUSH
62458: LD_INT 11
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: PUSH
62470: LD_INT 27
62472: PUSH
62473: LD_INT 28
62475: PUSH
62476: LD_INT 26
62478: PUSH
62479: LD_INT 30
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 43
62490: PUSH
62491: LD_INT 44
62493: PUSH
62494: LD_INT 46
62496: PUSH
62497: LD_INT 45
62499: PUSH
62500: LD_INT 47
62502: PUSH
62503: LD_INT 49
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: LIST
62510: LIST
62511: LIST
62512: LIST
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: LIST
62518: PUSH
62519: LD_VAR 0 12
62523: ARRAY
62524: ST_TO_ADDR
// list := list isect fac_list ;
62525: LD_ADDR_VAR 0 5
62529: PUSH
62530: LD_VAR 0 5
62534: PUSH
62535: LD_VAR 0 17
62539: ISECT
62540: ST_TO_ADDR
// if not list then
62541: LD_VAR 0 5
62545: NOT
62546: IFFALSE 62550
// exit ;
62548: GO 63354
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62550: LD_VAR 0 12
62554: PUSH
62555: LD_INT 3
62557: EQUAL
62558: PUSH
62559: LD_INT 49
62561: PUSH
62562: LD_VAR 0 5
62566: IN
62567: AND
62568: PUSH
62569: LD_INT 31
62571: PPUSH
62572: LD_VAR 0 16
62576: PPUSH
62577: CALL_OW 321
62581: PUSH
62582: LD_INT 2
62584: EQUAL
62585: AND
62586: IFFALSE 62646
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62588: LD_INT 22
62590: PUSH
62591: LD_VAR 0 16
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PUSH
62600: LD_INT 35
62602: PUSH
62603: LD_INT 49
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: PUSH
62610: LD_INT 91
62612: PUSH
62613: LD_VAR 0 1
62617: PUSH
62618: LD_INT 10
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: LIST
62625: PUSH
62626: EMPTY
62627: LIST
62628: LIST
62629: LIST
62630: PPUSH
62631: CALL_OW 69
62635: NOT
62636: IFFALSE 62646
// weapon := ru_time_lapser ;
62638: LD_ADDR_VAR 0 18
62642: PUSH
62643: LD_INT 49
62645: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62646: LD_VAR 0 12
62650: PUSH
62651: LD_INT 1
62653: PUSH
62654: LD_INT 2
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: IN
62661: PUSH
62662: LD_INT 11
62664: PUSH
62665: LD_VAR 0 5
62669: IN
62670: PUSH
62671: LD_INT 30
62673: PUSH
62674: LD_VAR 0 5
62678: IN
62679: OR
62680: AND
62681: PUSH
62682: LD_INT 6
62684: PPUSH
62685: LD_VAR 0 16
62689: PPUSH
62690: CALL_OW 321
62694: PUSH
62695: LD_INT 2
62697: EQUAL
62698: AND
62699: IFFALSE 62864
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62701: LD_INT 22
62703: PUSH
62704: LD_VAR 0 16
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: LD_INT 2
62715: PUSH
62716: LD_INT 35
62718: PUSH
62719: LD_INT 11
62721: PUSH
62722: EMPTY
62723: LIST
62724: LIST
62725: PUSH
62726: LD_INT 35
62728: PUSH
62729: LD_INT 30
62731: PUSH
62732: EMPTY
62733: LIST
62734: LIST
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: LIST
62740: PUSH
62741: LD_INT 91
62743: PUSH
62744: LD_VAR 0 1
62748: PUSH
62749: LD_INT 18
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: LIST
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: LIST
62761: PPUSH
62762: CALL_OW 69
62766: NOT
62767: PUSH
62768: LD_INT 22
62770: PUSH
62771: LD_VAR 0 16
62775: PUSH
62776: EMPTY
62777: LIST
62778: LIST
62779: PUSH
62780: LD_INT 2
62782: PUSH
62783: LD_INT 30
62785: PUSH
62786: LD_INT 32
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PUSH
62793: LD_INT 30
62795: PUSH
62796: LD_INT 33
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: PUSH
62803: EMPTY
62804: LIST
62805: LIST
62806: LIST
62807: PUSH
62808: LD_INT 91
62810: PUSH
62811: LD_VAR 0 1
62815: PUSH
62816: LD_INT 12
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: LIST
62823: PUSH
62824: EMPTY
62825: LIST
62826: LIST
62827: LIST
62828: PUSH
62829: EMPTY
62830: LIST
62831: PPUSH
62832: CALL_OW 69
62836: PUSH
62837: LD_INT 2
62839: GREATER
62840: AND
62841: IFFALSE 62864
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62843: LD_ADDR_VAR 0 18
62847: PUSH
62848: LD_INT 11
62850: PUSH
62851: LD_INT 30
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: LD_VAR 0 12
62862: ARRAY
62863: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62864: LD_VAR 0 18
62868: NOT
62869: PUSH
62870: LD_INT 40
62872: PPUSH
62873: LD_VAR 0 16
62877: PPUSH
62878: CALL_OW 321
62882: PUSH
62883: LD_INT 2
62885: EQUAL
62886: AND
62887: PUSH
62888: LD_INT 7
62890: PUSH
62891: LD_VAR 0 5
62895: IN
62896: PUSH
62897: LD_INT 28
62899: PUSH
62900: LD_VAR 0 5
62904: IN
62905: OR
62906: PUSH
62907: LD_INT 45
62909: PUSH
62910: LD_VAR 0 5
62914: IN
62915: OR
62916: AND
62917: IFFALSE 63171
// begin hex := GetHexInfo ( x , y ) ;
62919: LD_ADDR_VAR 0 4
62923: PUSH
62924: LD_VAR 0 10
62928: PPUSH
62929: LD_VAR 0 11
62933: PPUSH
62934: CALL_OW 546
62938: ST_TO_ADDR
// if hex [ 1 ] then
62939: LD_VAR 0 4
62943: PUSH
62944: LD_INT 1
62946: ARRAY
62947: IFFALSE 62951
// exit ;
62949: GO 63354
// height := hex [ 2 ] ;
62951: LD_ADDR_VAR 0 15
62955: PUSH
62956: LD_VAR 0 4
62960: PUSH
62961: LD_INT 2
62963: ARRAY
62964: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62965: LD_ADDR_VAR 0 14
62969: PUSH
62970: LD_INT 0
62972: PUSH
62973: LD_INT 2
62975: PUSH
62976: LD_INT 3
62978: PUSH
62979: LD_INT 5
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: LIST
62986: LIST
62987: ST_TO_ADDR
// for i in tmp do
62988: LD_ADDR_VAR 0 8
62992: PUSH
62993: LD_VAR 0 14
62997: PUSH
62998: FOR_IN
62999: IFFALSE 63169
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63001: LD_ADDR_VAR 0 9
63005: PUSH
63006: LD_VAR 0 10
63010: PPUSH
63011: LD_VAR 0 8
63015: PPUSH
63016: LD_INT 5
63018: PPUSH
63019: CALL_OW 272
63023: PUSH
63024: LD_VAR 0 11
63028: PPUSH
63029: LD_VAR 0 8
63033: PPUSH
63034: LD_INT 5
63036: PPUSH
63037: CALL_OW 273
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63046: LD_VAR 0 9
63050: PUSH
63051: LD_INT 1
63053: ARRAY
63054: PPUSH
63055: LD_VAR 0 9
63059: PUSH
63060: LD_INT 2
63062: ARRAY
63063: PPUSH
63064: CALL_OW 488
63068: IFFALSE 63167
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63070: LD_ADDR_VAR 0 4
63074: PUSH
63075: LD_VAR 0 9
63079: PUSH
63080: LD_INT 1
63082: ARRAY
63083: PPUSH
63084: LD_VAR 0 9
63088: PUSH
63089: LD_INT 2
63091: ARRAY
63092: PPUSH
63093: CALL_OW 546
63097: ST_TO_ADDR
// if hex [ 1 ] then
63098: LD_VAR 0 4
63102: PUSH
63103: LD_INT 1
63105: ARRAY
63106: IFFALSE 63110
// continue ;
63108: GO 62998
// h := hex [ 2 ] ;
63110: LD_ADDR_VAR 0 13
63114: PUSH
63115: LD_VAR 0 4
63119: PUSH
63120: LD_INT 2
63122: ARRAY
63123: ST_TO_ADDR
// if h + 7 < height then
63124: LD_VAR 0 13
63128: PUSH
63129: LD_INT 7
63131: PLUS
63132: PUSH
63133: LD_VAR 0 15
63137: LESS
63138: IFFALSE 63167
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63140: LD_ADDR_VAR 0 18
63144: PUSH
63145: LD_INT 7
63147: PUSH
63148: LD_INT 28
63150: PUSH
63151: LD_INT 45
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: LIST
63158: PUSH
63159: LD_VAR 0 12
63163: ARRAY
63164: ST_TO_ADDR
// break ;
63165: GO 63169
// end ; end ; end ;
63167: GO 62998
63169: POP
63170: POP
// end ; if not weapon then
63171: LD_VAR 0 18
63175: NOT
63176: IFFALSE 63236
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63178: LD_ADDR_VAR 0 5
63182: PUSH
63183: LD_VAR 0 5
63187: PUSH
63188: LD_INT 11
63190: PUSH
63191: LD_INT 30
63193: PUSH
63194: LD_INT 49
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: LIST
63201: DIFF
63202: ST_TO_ADDR
// if not list then
63203: LD_VAR 0 5
63207: NOT
63208: IFFALSE 63212
// exit ;
63210: GO 63354
// weapon := list [ rand ( 1 , list ) ] ;
63212: LD_ADDR_VAR 0 18
63216: PUSH
63217: LD_VAR 0 5
63221: PUSH
63222: LD_INT 1
63224: PPUSH
63225: LD_VAR 0 5
63229: PPUSH
63230: CALL_OW 12
63234: ARRAY
63235: ST_TO_ADDR
// end ; if weapon then
63236: LD_VAR 0 18
63240: IFFALSE 63354
// begin tmp := CostOfWeapon ( weapon ) ;
63242: LD_ADDR_VAR 0 14
63246: PUSH
63247: LD_VAR 0 18
63251: PPUSH
63252: CALL_OW 451
63256: ST_TO_ADDR
// j := GetBase ( tower ) ;
63257: LD_ADDR_VAR 0 9
63261: PUSH
63262: LD_VAR 0 1
63266: PPUSH
63267: CALL_OW 274
63271: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63272: LD_VAR 0 9
63276: PPUSH
63277: LD_INT 1
63279: PPUSH
63280: CALL_OW 275
63284: PUSH
63285: LD_VAR 0 14
63289: PUSH
63290: LD_INT 1
63292: ARRAY
63293: GREATEREQUAL
63294: PUSH
63295: LD_VAR 0 9
63299: PPUSH
63300: LD_INT 2
63302: PPUSH
63303: CALL_OW 275
63307: PUSH
63308: LD_VAR 0 14
63312: PUSH
63313: LD_INT 2
63315: ARRAY
63316: GREATEREQUAL
63317: AND
63318: PUSH
63319: LD_VAR 0 9
63323: PPUSH
63324: LD_INT 3
63326: PPUSH
63327: CALL_OW 275
63331: PUSH
63332: LD_VAR 0 14
63336: PUSH
63337: LD_INT 3
63339: ARRAY
63340: GREATEREQUAL
63341: AND
63342: IFFALSE 63354
// result := weapon ;
63344: LD_ADDR_VAR 0 3
63348: PUSH
63349: LD_VAR 0 18
63353: ST_TO_ADDR
// end ; end ;
63354: LD_VAR 0 3
63358: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63359: LD_INT 0
63361: PPUSH
63362: PPUSH
// result := true ;
63363: LD_ADDR_VAR 0 3
63367: PUSH
63368: LD_INT 1
63370: ST_TO_ADDR
// if array1 = array2 then
63371: LD_VAR 0 1
63375: PUSH
63376: LD_VAR 0 2
63380: EQUAL
63381: IFFALSE 63441
// begin for i = 1 to array1 do
63383: LD_ADDR_VAR 0 4
63387: PUSH
63388: DOUBLE
63389: LD_INT 1
63391: DEC
63392: ST_TO_ADDR
63393: LD_VAR 0 1
63397: PUSH
63398: FOR_TO
63399: IFFALSE 63437
// if array1 [ i ] <> array2 [ i ] then
63401: LD_VAR 0 1
63405: PUSH
63406: LD_VAR 0 4
63410: ARRAY
63411: PUSH
63412: LD_VAR 0 2
63416: PUSH
63417: LD_VAR 0 4
63421: ARRAY
63422: NONEQUAL
63423: IFFALSE 63435
// begin result := false ;
63425: LD_ADDR_VAR 0 3
63429: PUSH
63430: LD_INT 0
63432: ST_TO_ADDR
// break ;
63433: GO 63437
// end ;
63435: GO 63398
63437: POP
63438: POP
// end else
63439: GO 63449
// result := false ;
63441: LD_ADDR_VAR 0 3
63445: PUSH
63446: LD_INT 0
63448: ST_TO_ADDR
// end ;
63449: LD_VAR 0 3
63453: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63454: LD_INT 0
63456: PPUSH
63457: PPUSH
// if not array1 or not array2 then
63458: LD_VAR 0 1
63462: NOT
63463: PUSH
63464: LD_VAR 0 2
63468: NOT
63469: OR
63470: IFFALSE 63474
// exit ;
63472: GO 63538
// result := true ;
63474: LD_ADDR_VAR 0 3
63478: PUSH
63479: LD_INT 1
63481: ST_TO_ADDR
// for i = 1 to array1 do
63482: LD_ADDR_VAR 0 4
63486: PUSH
63487: DOUBLE
63488: LD_INT 1
63490: DEC
63491: ST_TO_ADDR
63492: LD_VAR 0 1
63496: PUSH
63497: FOR_TO
63498: IFFALSE 63536
// if array1 [ i ] <> array2 [ i ] then
63500: LD_VAR 0 1
63504: PUSH
63505: LD_VAR 0 4
63509: ARRAY
63510: PUSH
63511: LD_VAR 0 2
63515: PUSH
63516: LD_VAR 0 4
63520: ARRAY
63521: NONEQUAL
63522: IFFALSE 63534
// begin result := false ;
63524: LD_ADDR_VAR 0 3
63528: PUSH
63529: LD_INT 0
63531: ST_TO_ADDR
// break ;
63532: GO 63536
// end ;
63534: GO 63497
63536: POP
63537: POP
// end ;
63538: LD_VAR 0 3
63542: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63543: LD_INT 0
63545: PPUSH
63546: PPUSH
63547: PPUSH
// pom := GetBase ( fac ) ;
63548: LD_ADDR_VAR 0 5
63552: PUSH
63553: LD_VAR 0 1
63557: PPUSH
63558: CALL_OW 274
63562: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63563: LD_ADDR_VAR 0 4
63567: PUSH
63568: LD_VAR 0 2
63572: PUSH
63573: LD_INT 1
63575: ARRAY
63576: PPUSH
63577: LD_VAR 0 2
63581: PUSH
63582: LD_INT 2
63584: ARRAY
63585: PPUSH
63586: LD_VAR 0 2
63590: PUSH
63591: LD_INT 3
63593: ARRAY
63594: PPUSH
63595: LD_VAR 0 2
63599: PUSH
63600: LD_INT 4
63602: ARRAY
63603: PPUSH
63604: CALL_OW 449
63608: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63609: LD_ADDR_VAR 0 3
63613: PUSH
63614: LD_VAR 0 5
63618: PPUSH
63619: LD_INT 1
63621: PPUSH
63622: CALL_OW 275
63626: PUSH
63627: LD_VAR 0 4
63631: PUSH
63632: LD_INT 1
63634: ARRAY
63635: GREATEREQUAL
63636: PUSH
63637: LD_VAR 0 5
63641: PPUSH
63642: LD_INT 2
63644: PPUSH
63645: CALL_OW 275
63649: PUSH
63650: LD_VAR 0 4
63654: PUSH
63655: LD_INT 2
63657: ARRAY
63658: GREATEREQUAL
63659: AND
63660: PUSH
63661: LD_VAR 0 5
63665: PPUSH
63666: LD_INT 3
63668: PPUSH
63669: CALL_OW 275
63673: PUSH
63674: LD_VAR 0 4
63678: PUSH
63679: LD_INT 3
63681: ARRAY
63682: GREATEREQUAL
63683: AND
63684: ST_TO_ADDR
// end ;
63685: LD_VAR 0 3
63689: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63690: LD_INT 0
63692: PPUSH
63693: PPUSH
63694: PPUSH
63695: PPUSH
// pom := GetBase ( building ) ;
63696: LD_ADDR_VAR 0 3
63700: PUSH
63701: LD_VAR 0 1
63705: PPUSH
63706: CALL_OW 274
63710: ST_TO_ADDR
// if not pom then
63711: LD_VAR 0 3
63715: NOT
63716: IFFALSE 63720
// exit ;
63718: GO 63890
// btype := GetBType ( building ) ;
63720: LD_ADDR_VAR 0 5
63724: PUSH
63725: LD_VAR 0 1
63729: PPUSH
63730: CALL_OW 266
63734: ST_TO_ADDR
// if btype = b_armoury then
63735: LD_VAR 0 5
63739: PUSH
63740: LD_INT 4
63742: EQUAL
63743: IFFALSE 63753
// btype := b_barracks ;
63745: LD_ADDR_VAR 0 5
63749: PUSH
63750: LD_INT 5
63752: ST_TO_ADDR
// if btype = b_depot then
63753: LD_VAR 0 5
63757: PUSH
63758: LD_INT 0
63760: EQUAL
63761: IFFALSE 63771
// btype := b_warehouse ;
63763: LD_ADDR_VAR 0 5
63767: PUSH
63768: LD_INT 1
63770: ST_TO_ADDR
// if btype = b_workshop then
63771: LD_VAR 0 5
63775: PUSH
63776: LD_INT 2
63778: EQUAL
63779: IFFALSE 63789
// btype := b_factory ;
63781: LD_ADDR_VAR 0 5
63785: PUSH
63786: LD_INT 3
63788: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63789: LD_ADDR_VAR 0 4
63793: PUSH
63794: LD_VAR 0 5
63798: PPUSH
63799: LD_VAR 0 1
63803: PPUSH
63804: CALL_OW 248
63808: PPUSH
63809: CALL_OW 450
63813: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63814: LD_ADDR_VAR 0 2
63818: PUSH
63819: LD_VAR 0 3
63823: PPUSH
63824: LD_INT 1
63826: PPUSH
63827: CALL_OW 275
63831: PUSH
63832: LD_VAR 0 4
63836: PUSH
63837: LD_INT 1
63839: ARRAY
63840: GREATEREQUAL
63841: PUSH
63842: LD_VAR 0 3
63846: PPUSH
63847: LD_INT 2
63849: PPUSH
63850: CALL_OW 275
63854: PUSH
63855: LD_VAR 0 4
63859: PUSH
63860: LD_INT 2
63862: ARRAY
63863: GREATEREQUAL
63864: AND
63865: PUSH
63866: LD_VAR 0 3
63870: PPUSH
63871: LD_INT 3
63873: PPUSH
63874: CALL_OW 275
63878: PUSH
63879: LD_VAR 0 4
63883: PUSH
63884: LD_INT 3
63886: ARRAY
63887: GREATEREQUAL
63888: AND
63889: ST_TO_ADDR
// end ;
63890: LD_VAR 0 2
63894: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63895: LD_INT 0
63897: PPUSH
63898: PPUSH
63899: PPUSH
// pom := GetBase ( building ) ;
63900: LD_ADDR_VAR 0 4
63904: PUSH
63905: LD_VAR 0 1
63909: PPUSH
63910: CALL_OW 274
63914: ST_TO_ADDR
// if not pom then
63915: LD_VAR 0 4
63919: NOT
63920: IFFALSE 63924
// exit ;
63922: GO 64025
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63924: LD_ADDR_VAR 0 5
63928: PUSH
63929: LD_VAR 0 2
63933: PPUSH
63934: LD_VAR 0 1
63938: PPUSH
63939: CALL_OW 248
63943: PPUSH
63944: CALL_OW 450
63948: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63949: LD_ADDR_VAR 0 3
63953: PUSH
63954: LD_VAR 0 4
63958: PPUSH
63959: LD_INT 1
63961: PPUSH
63962: CALL_OW 275
63966: PUSH
63967: LD_VAR 0 5
63971: PUSH
63972: LD_INT 1
63974: ARRAY
63975: GREATEREQUAL
63976: PUSH
63977: LD_VAR 0 4
63981: PPUSH
63982: LD_INT 2
63984: PPUSH
63985: CALL_OW 275
63989: PUSH
63990: LD_VAR 0 5
63994: PUSH
63995: LD_INT 2
63997: ARRAY
63998: GREATEREQUAL
63999: AND
64000: PUSH
64001: LD_VAR 0 4
64005: PPUSH
64006: LD_INT 3
64008: PPUSH
64009: CALL_OW 275
64013: PUSH
64014: LD_VAR 0 5
64018: PUSH
64019: LD_INT 3
64021: ARRAY
64022: GREATEREQUAL
64023: AND
64024: ST_TO_ADDR
// end ;
64025: LD_VAR 0 3
64029: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64030: LD_INT 0
64032: PPUSH
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
64037: PPUSH
64038: PPUSH
64039: PPUSH
64040: PPUSH
64041: PPUSH
64042: PPUSH
// result := false ;
64043: LD_ADDR_VAR 0 8
64047: PUSH
64048: LD_INT 0
64050: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64051: LD_VAR 0 5
64055: NOT
64056: PUSH
64057: LD_VAR 0 1
64061: NOT
64062: OR
64063: PUSH
64064: LD_VAR 0 2
64068: NOT
64069: OR
64070: PUSH
64071: LD_VAR 0 3
64075: NOT
64076: OR
64077: IFFALSE 64081
// exit ;
64079: GO 64895
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64081: LD_ADDR_VAR 0 14
64085: PUSH
64086: LD_VAR 0 1
64090: PPUSH
64091: LD_VAR 0 2
64095: PPUSH
64096: LD_VAR 0 3
64100: PPUSH
64101: LD_VAR 0 4
64105: PPUSH
64106: LD_VAR 0 5
64110: PUSH
64111: LD_INT 1
64113: ARRAY
64114: PPUSH
64115: CALL_OW 248
64119: PPUSH
64120: LD_INT 0
64122: PPUSH
64123: CALL 66132 0 6
64127: ST_TO_ADDR
// if not hexes then
64128: LD_VAR 0 14
64132: NOT
64133: IFFALSE 64137
// exit ;
64135: GO 64895
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64137: LD_ADDR_VAR 0 17
64141: PUSH
64142: LD_VAR 0 5
64146: PPUSH
64147: LD_INT 22
64149: PUSH
64150: LD_VAR 0 13
64154: PPUSH
64155: CALL_OW 255
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 2
64166: PUSH
64167: LD_INT 30
64169: PUSH
64170: LD_INT 0
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 30
64179: PUSH
64180: LD_INT 1
64182: PUSH
64183: EMPTY
64184: LIST
64185: LIST
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: LIST
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PPUSH
64196: CALL_OW 72
64200: ST_TO_ADDR
// for i = 1 to hexes do
64201: LD_ADDR_VAR 0 9
64205: PUSH
64206: DOUBLE
64207: LD_INT 1
64209: DEC
64210: ST_TO_ADDR
64211: LD_VAR 0 14
64215: PUSH
64216: FOR_TO
64217: IFFALSE 64893
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64219: LD_ADDR_VAR 0 13
64223: PUSH
64224: LD_VAR 0 14
64228: PUSH
64229: LD_VAR 0 9
64233: ARRAY
64234: PUSH
64235: LD_INT 1
64237: ARRAY
64238: PPUSH
64239: LD_VAR 0 14
64243: PUSH
64244: LD_VAR 0 9
64248: ARRAY
64249: PUSH
64250: LD_INT 2
64252: ARRAY
64253: PPUSH
64254: CALL_OW 428
64258: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64259: LD_VAR 0 14
64263: PUSH
64264: LD_VAR 0 9
64268: ARRAY
64269: PUSH
64270: LD_INT 1
64272: ARRAY
64273: PPUSH
64274: LD_VAR 0 14
64278: PUSH
64279: LD_VAR 0 9
64283: ARRAY
64284: PUSH
64285: LD_INT 2
64287: ARRAY
64288: PPUSH
64289: CALL_OW 351
64293: PUSH
64294: LD_VAR 0 14
64298: PUSH
64299: LD_VAR 0 9
64303: ARRAY
64304: PUSH
64305: LD_INT 1
64307: ARRAY
64308: PPUSH
64309: LD_VAR 0 14
64313: PUSH
64314: LD_VAR 0 9
64318: ARRAY
64319: PUSH
64320: LD_INT 2
64322: ARRAY
64323: PPUSH
64324: CALL_OW 488
64328: NOT
64329: OR
64330: PUSH
64331: LD_VAR 0 13
64335: PPUSH
64336: CALL_OW 247
64340: PUSH
64341: LD_INT 3
64343: EQUAL
64344: OR
64345: IFFALSE 64351
// exit ;
64347: POP
64348: POP
64349: GO 64895
// if not tmp then
64351: LD_VAR 0 13
64355: NOT
64356: IFFALSE 64360
// continue ;
64358: GO 64216
// result := true ;
64360: LD_ADDR_VAR 0 8
64364: PUSH
64365: LD_INT 1
64367: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64368: LD_VAR 0 6
64372: PUSH
64373: LD_VAR 0 13
64377: PPUSH
64378: CALL_OW 247
64382: PUSH
64383: LD_INT 2
64385: EQUAL
64386: AND
64387: PUSH
64388: LD_VAR 0 13
64392: PPUSH
64393: CALL_OW 263
64397: PUSH
64398: LD_INT 1
64400: EQUAL
64401: AND
64402: IFFALSE 64566
// begin if IsDrivenBy ( tmp ) then
64404: LD_VAR 0 13
64408: PPUSH
64409: CALL_OW 311
64413: IFFALSE 64417
// continue ;
64415: GO 64216
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64417: LD_VAR 0 6
64421: PPUSH
64422: LD_INT 3
64424: PUSH
64425: LD_INT 60
64427: PUSH
64428: EMPTY
64429: LIST
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 3
64437: PUSH
64438: LD_INT 55
64440: PUSH
64441: EMPTY
64442: LIST
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PPUSH
64452: CALL_OW 72
64456: IFFALSE 64564
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64458: LD_ADDR_VAR 0 18
64462: PUSH
64463: LD_VAR 0 6
64467: PPUSH
64468: LD_INT 3
64470: PUSH
64471: LD_INT 60
64473: PUSH
64474: EMPTY
64475: LIST
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 3
64483: PUSH
64484: LD_INT 55
64486: PUSH
64487: EMPTY
64488: LIST
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PPUSH
64498: CALL_OW 72
64502: PUSH
64503: LD_INT 1
64505: ARRAY
64506: ST_TO_ADDR
// if IsInUnit ( driver ) then
64507: LD_VAR 0 18
64511: PPUSH
64512: CALL_OW 310
64516: IFFALSE 64527
// ComExit ( driver ) ;
64518: LD_VAR 0 18
64522: PPUSH
64523: CALL 89837 0 1
// AddComEnterUnit ( driver , tmp ) ;
64527: LD_VAR 0 18
64531: PPUSH
64532: LD_VAR 0 13
64536: PPUSH
64537: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64541: LD_VAR 0 18
64545: PPUSH
64546: LD_VAR 0 7
64550: PPUSH
64551: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64555: LD_VAR 0 18
64559: PPUSH
64560: CALL_OW 181
// end ; continue ;
64564: GO 64216
// end ; if not cleaners or not tmp in cleaners then
64566: LD_VAR 0 6
64570: NOT
64571: PUSH
64572: LD_VAR 0 13
64576: PUSH
64577: LD_VAR 0 6
64581: IN
64582: NOT
64583: OR
64584: IFFALSE 64891
// begin if dep then
64586: LD_VAR 0 17
64590: IFFALSE 64726
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64592: LD_ADDR_VAR 0 16
64596: PUSH
64597: LD_VAR 0 17
64601: PUSH
64602: LD_INT 1
64604: ARRAY
64605: PPUSH
64606: CALL_OW 250
64610: PPUSH
64611: LD_VAR 0 17
64615: PUSH
64616: LD_INT 1
64618: ARRAY
64619: PPUSH
64620: CALL_OW 254
64624: PPUSH
64625: LD_INT 5
64627: PPUSH
64628: CALL_OW 272
64632: PUSH
64633: LD_VAR 0 17
64637: PUSH
64638: LD_INT 1
64640: ARRAY
64641: PPUSH
64642: CALL_OW 251
64646: PPUSH
64647: LD_VAR 0 17
64651: PUSH
64652: LD_INT 1
64654: ARRAY
64655: PPUSH
64656: CALL_OW 254
64660: PPUSH
64661: LD_INT 5
64663: PPUSH
64664: CALL_OW 273
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64673: LD_VAR 0 16
64677: PUSH
64678: LD_INT 1
64680: ARRAY
64681: PPUSH
64682: LD_VAR 0 16
64686: PUSH
64687: LD_INT 2
64689: ARRAY
64690: PPUSH
64691: CALL_OW 488
64695: IFFALSE 64726
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64697: LD_VAR 0 13
64701: PPUSH
64702: LD_VAR 0 16
64706: PUSH
64707: LD_INT 1
64709: ARRAY
64710: PPUSH
64711: LD_VAR 0 16
64715: PUSH
64716: LD_INT 2
64718: ARRAY
64719: PPUSH
64720: CALL_OW 111
// continue ;
64724: GO 64216
// end ; end ; r := GetDir ( tmp ) ;
64726: LD_ADDR_VAR 0 15
64730: PUSH
64731: LD_VAR 0 13
64735: PPUSH
64736: CALL_OW 254
64740: ST_TO_ADDR
// if r = 5 then
64741: LD_VAR 0 15
64745: PUSH
64746: LD_INT 5
64748: EQUAL
64749: IFFALSE 64759
// r := 0 ;
64751: LD_ADDR_VAR 0 15
64755: PUSH
64756: LD_INT 0
64758: ST_TO_ADDR
// for j = r to 5 do
64759: LD_ADDR_VAR 0 10
64763: PUSH
64764: DOUBLE
64765: LD_VAR 0 15
64769: DEC
64770: ST_TO_ADDR
64771: LD_INT 5
64773: PUSH
64774: FOR_TO
64775: IFFALSE 64889
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64777: LD_ADDR_VAR 0 11
64781: PUSH
64782: LD_VAR 0 13
64786: PPUSH
64787: CALL_OW 250
64791: PPUSH
64792: LD_VAR 0 10
64796: PPUSH
64797: LD_INT 2
64799: PPUSH
64800: CALL_OW 272
64804: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64805: LD_ADDR_VAR 0 12
64809: PUSH
64810: LD_VAR 0 13
64814: PPUSH
64815: CALL_OW 251
64819: PPUSH
64820: LD_VAR 0 10
64824: PPUSH
64825: LD_INT 2
64827: PPUSH
64828: CALL_OW 273
64832: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64833: LD_VAR 0 11
64837: PPUSH
64838: LD_VAR 0 12
64842: PPUSH
64843: CALL_OW 488
64847: PUSH
64848: LD_VAR 0 11
64852: PPUSH
64853: LD_VAR 0 12
64857: PPUSH
64858: CALL_OW 428
64862: NOT
64863: AND
64864: IFFALSE 64887
// begin ComMoveXY ( tmp , _x , _y ) ;
64866: LD_VAR 0 13
64870: PPUSH
64871: LD_VAR 0 11
64875: PPUSH
64876: LD_VAR 0 12
64880: PPUSH
64881: CALL_OW 111
// break ;
64885: GO 64889
// end ; end ;
64887: GO 64774
64889: POP
64890: POP
// end ; end ;
64891: GO 64216
64893: POP
64894: POP
// end ;
64895: LD_VAR 0 8
64899: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64900: LD_INT 0
64902: PPUSH
// result := true ;
64903: LD_ADDR_VAR 0 3
64907: PUSH
64908: LD_INT 1
64910: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64911: LD_VAR 0 2
64915: PUSH
64916: LD_INT 24
64918: DOUBLE
64919: EQUAL
64920: IFTRUE 64930
64922: LD_INT 33
64924: DOUBLE
64925: EQUAL
64926: IFTRUE 64930
64928: GO 64955
64930: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64931: LD_ADDR_VAR 0 3
64935: PUSH
64936: LD_INT 32
64938: PPUSH
64939: LD_VAR 0 1
64943: PPUSH
64944: CALL_OW 321
64948: PUSH
64949: LD_INT 2
64951: EQUAL
64952: ST_TO_ADDR
64953: GO 65275
64955: LD_INT 20
64957: DOUBLE
64958: EQUAL
64959: IFTRUE 64963
64961: GO 64988
64963: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64964: LD_ADDR_VAR 0 3
64968: PUSH
64969: LD_INT 6
64971: PPUSH
64972: LD_VAR 0 1
64976: PPUSH
64977: CALL_OW 321
64981: PUSH
64982: LD_INT 2
64984: EQUAL
64985: ST_TO_ADDR
64986: GO 65275
64988: LD_INT 22
64990: DOUBLE
64991: EQUAL
64992: IFTRUE 65002
64994: LD_INT 36
64996: DOUBLE
64997: EQUAL
64998: IFTRUE 65002
65000: GO 65027
65002: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65003: LD_ADDR_VAR 0 3
65007: PUSH
65008: LD_INT 15
65010: PPUSH
65011: LD_VAR 0 1
65015: PPUSH
65016: CALL_OW 321
65020: PUSH
65021: LD_INT 2
65023: EQUAL
65024: ST_TO_ADDR
65025: GO 65275
65027: LD_INT 30
65029: DOUBLE
65030: EQUAL
65031: IFTRUE 65035
65033: GO 65060
65035: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65036: LD_ADDR_VAR 0 3
65040: PUSH
65041: LD_INT 20
65043: PPUSH
65044: LD_VAR 0 1
65048: PPUSH
65049: CALL_OW 321
65053: PUSH
65054: LD_INT 2
65056: EQUAL
65057: ST_TO_ADDR
65058: GO 65275
65060: LD_INT 28
65062: DOUBLE
65063: EQUAL
65064: IFTRUE 65074
65066: LD_INT 21
65068: DOUBLE
65069: EQUAL
65070: IFTRUE 65074
65072: GO 65099
65074: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65075: LD_ADDR_VAR 0 3
65079: PUSH
65080: LD_INT 21
65082: PPUSH
65083: LD_VAR 0 1
65087: PPUSH
65088: CALL_OW 321
65092: PUSH
65093: LD_INT 2
65095: EQUAL
65096: ST_TO_ADDR
65097: GO 65275
65099: LD_INT 16
65101: DOUBLE
65102: EQUAL
65103: IFTRUE 65107
65105: GO 65134
65107: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65108: LD_ADDR_VAR 0 3
65112: PUSH
65113: LD_EXP 87
65117: PPUSH
65118: LD_VAR 0 1
65122: PPUSH
65123: CALL_OW 321
65127: PUSH
65128: LD_INT 2
65130: EQUAL
65131: ST_TO_ADDR
65132: GO 65275
65134: LD_INT 19
65136: DOUBLE
65137: EQUAL
65138: IFTRUE 65148
65140: LD_INT 23
65142: DOUBLE
65143: EQUAL
65144: IFTRUE 65148
65146: GO 65175
65148: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65149: LD_ADDR_VAR 0 3
65153: PUSH
65154: LD_EXP 86
65158: PPUSH
65159: LD_VAR 0 1
65163: PPUSH
65164: CALL_OW 321
65168: PUSH
65169: LD_INT 2
65171: EQUAL
65172: ST_TO_ADDR
65173: GO 65275
65175: LD_INT 17
65177: DOUBLE
65178: EQUAL
65179: IFTRUE 65183
65181: GO 65208
65183: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65184: LD_ADDR_VAR 0 3
65188: PUSH
65189: LD_INT 39
65191: PPUSH
65192: LD_VAR 0 1
65196: PPUSH
65197: CALL_OW 321
65201: PUSH
65202: LD_INT 2
65204: EQUAL
65205: ST_TO_ADDR
65206: GO 65275
65208: LD_INT 18
65210: DOUBLE
65211: EQUAL
65212: IFTRUE 65216
65214: GO 65241
65216: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65217: LD_ADDR_VAR 0 3
65221: PUSH
65222: LD_INT 40
65224: PPUSH
65225: LD_VAR 0 1
65229: PPUSH
65230: CALL_OW 321
65234: PUSH
65235: LD_INT 2
65237: EQUAL
65238: ST_TO_ADDR
65239: GO 65275
65241: LD_INT 27
65243: DOUBLE
65244: EQUAL
65245: IFTRUE 65249
65247: GO 65274
65249: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65250: LD_ADDR_VAR 0 3
65254: PUSH
65255: LD_INT 35
65257: PPUSH
65258: LD_VAR 0 1
65262: PPUSH
65263: CALL_OW 321
65267: PUSH
65268: LD_INT 2
65270: EQUAL
65271: ST_TO_ADDR
65272: GO 65275
65274: POP
// end ;
65275: LD_VAR 0 3
65279: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65280: LD_INT 0
65282: PPUSH
65283: PPUSH
65284: PPUSH
65285: PPUSH
65286: PPUSH
65287: PPUSH
65288: PPUSH
65289: PPUSH
65290: PPUSH
65291: PPUSH
65292: PPUSH
// result := false ;
65293: LD_ADDR_VAR 0 6
65297: PUSH
65298: LD_INT 0
65300: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65301: LD_VAR 0 1
65305: NOT
65306: PUSH
65307: LD_VAR 0 1
65311: PPUSH
65312: CALL_OW 266
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: LD_INT 1
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: IN
65327: NOT
65328: OR
65329: PUSH
65330: LD_VAR 0 2
65334: NOT
65335: OR
65336: PUSH
65337: LD_VAR 0 5
65341: PUSH
65342: LD_INT 0
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: LD_INT 2
65350: PUSH
65351: LD_INT 3
65353: PUSH
65354: LD_INT 4
65356: PUSH
65357: LD_INT 5
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: IN
65368: NOT
65369: OR
65370: PUSH
65371: LD_VAR 0 3
65375: PPUSH
65376: LD_VAR 0 4
65380: PPUSH
65381: CALL_OW 488
65385: NOT
65386: OR
65387: IFFALSE 65391
// exit ;
65389: GO 66127
// side := GetSide ( depot ) ;
65391: LD_ADDR_VAR 0 9
65395: PUSH
65396: LD_VAR 0 1
65400: PPUSH
65401: CALL_OW 255
65405: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65406: LD_VAR 0 9
65410: PPUSH
65411: LD_VAR 0 2
65415: PPUSH
65416: CALL 64900 0 2
65420: NOT
65421: IFFALSE 65425
// exit ;
65423: GO 66127
// pom := GetBase ( depot ) ;
65425: LD_ADDR_VAR 0 10
65429: PUSH
65430: LD_VAR 0 1
65434: PPUSH
65435: CALL_OW 274
65439: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65440: LD_ADDR_VAR 0 11
65444: PUSH
65445: LD_VAR 0 2
65449: PPUSH
65450: LD_VAR 0 1
65454: PPUSH
65455: CALL_OW 248
65459: PPUSH
65460: CALL_OW 450
65464: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65465: LD_VAR 0 10
65469: PPUSH
65470: LD_INT 1
65472: PPUSH
65473: CALL_OW 275
65477: PUSH
65478: LD_VAR 0 11
65482: PUSH
65483: LD_INT 1
65485: ARRAY
65486: GREATEREQUAL
65487: PUSH
65488: LD_VAR 0 10
65492: PPUSH
65493: LD_INT 2
65495: PPUSH
65496: CALL_OW 275
65500: PUSH
65501: LD_VAR 0 11
65505: PUSH
65506: LD_INT 2
65508: ARRAY
65509: GREATEREQUAL
65510: AND
65511: PUSH
65512: LD_VAR 0 10
65516: PPUSH
65517: LD_INT 3
65519: PPUSH
65520: CALL_OW 275
65524: PUSH
65525: LD_VAR 0 11
65529: PUSH
65530: LD_INT 3
65532: ARRAY
65533: GREATEREQUAL
65534: AND
65535: NOT
65536: IFFALSE 65540
// exit ;
65538: GO 66127
// if GetBType ( depot ) = b_depot then
65540: LD_VAR 0 1
65544: PPUSH
65545: CALL_OW 266
65549: PUSH
65550: LD_INT 0
65552: EQUAL
65553: IFFALSE 65565
// dist := 28 else
65555: LD_ADDR_VAR 0 14
65559: PUSH
65560: LD_INT 28
65562: ST_TO_ADDR
65563: GO 65573
// dist := 36 ;
65565: LD_ADDR_VAR 0 14
65569: PUSH
65570: LD_INT 36
65572: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65573: LD_VAR 0 1
65577: PPUSH
65578: LD_VAR 0 3
65582: PPUSH
65583: LD_VAR 0 4
65587: PPUSH
65588: CALL_OW 297
65592: PUSH
65593: LD_VAR 0 14
65597: GREATER
65598: IFFALSE 65602
// exit ;
65600: GO 66127
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65602: LD_ADDR_VAR 0 12
65606: PUSH
65607: LD_VAR 0 2
65611: PPUSH
65612: LD_VAR 0 3
65616: PPUSH
65617: LD_VAR 0 4
65621: PPUSH
65622: LD_VAR 0 5
65626: PPUSH
65627: LD_VAR 0 1
65631: PPUSH
65632: CALL_OW 248
65636: PPUSH
65637: LD_INT 0
65639: PPUSH
65640: CALL 66132 0 6
65644: ST_TO_ADDR
// if not hexes then
65645: LD_VAR 0 12
65649: NOT
65650: IFFALSE 65654
// exit ;
65652: GO 66127
// hex := GetHexInfo ( x , y ) ;
65654: LD_ADDR_VAR 0 15
65658: PUSH
65659: LD_VAR 0 3
65663: PPUSH
65664: LD_VAR 0 4
65668: PPUSH
65669: CALL_OW 546
65673: ST_TO_ADDR
// if hex [ 1 ] then
65674: LD_VAR 0 15
65678: PUSH
65679: LD_INT 1
65681: ARRAY
65682: IFFALSE 65686
// exit ;
65684: GO 66127
// height := hex [ 2 ] ;
65686: LD_ADDR_VAR 0 13
65690: PUSH
65691: LD_VAR 0 15
65695: PUSH
65696: LD_INT 2
65698: ARRAY
65699: ST_TO_ADDR
// for i = 1 to hexes do
65700: LD_ADDR_VAR 0 7
65704: PUSH
65705: DOUBLE
65706: LD_INT 1
65708: DEC
65709: ST_TO_ADDR
65710: LD_VAR 0 12
65714: PUSH
65715: FOR_TO
65716: IFFALSE 66046
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65718: LD_VAR 0 12
65722: PUSH
65723: LD_VAR 0 7
65727: ARRAY
65728: PUSH
65729: LD_INT 1
65731: ARRAY
65732: PPUSH
65733: LD_VAR 0 12
65737: PUSH
65738: LD_VAR 0 7
65742: ARRAY
65743: PUSH
65744: LD_INT 2
65746: ARRAY
65747: PPUSH
65748: CALL_OW 488
65752: NOT
65753: PUSH
65754: LD_VAR 0 12
65758: PUSH
65759: LD_VAR 0 7
65763: ARRAY
65764: PUSH
65765: LD_INT 1
65767: ARRAY
65768: PPUSH
65769: LD_VAR 0 12
65773: PUSH
65774: LD_VAR 0 7
65778: ARRAY
65779: PUSH
65780: LD_INT 2
65782: ARRAY
65783: PPUSH
65784: CALL_OW 428
65788: PUSH
65789: LD_INT 0
65791: GREATER
65792: OR
65793: PUSH
65794: LD_VAR 0 12
65798: PUSH
65799: LD_VAR 0 7
65803: ARRAY
65804: PUSH
65805: LD_INT 1
65807: ARRAY
65808: PPUSH
65809: LD_VAR 0 12
65813: PUSH
65814: LD_VAR 0 7
65818: ARRAY
65819: PUSH
65820: LD_INT 2
65822: ARRAY
65823: PPUSH
65824: CALL_OW 351
65828: OR
65829: IFFALSE 65835
// exit ;
65831: POP
65832: POP
65833: GO 66127
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65835: LD_ADDR_VAR 0 8
65839: PUSH
65840: LD_VAR 0 12
65844: PUSH
65845: LD_VAR 0 7
65849: ARRAY
65850: PUSH
65851: LD_INT 1
65853: ARRAY
65854: PPUSH
65855: LD_VAR 0 12
65859: PUSH
65860: LD_VAR 0 7
65864: ARRAY
65865: PUSH
65866: LD_INT 2
65868: ARRAY
65869: PPUSH
65870: CALL_OW 546
65874: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65875: LD_VAR 0 8
65879: PUSH
65880: LD_INT 1
65882: ARRAY
65883: PUSH
65884: LD_VAR 0 8
65888: PUSH
65889: LD_INT 2
65891: ARRAY
65892: PUSH
65893: LD_VAR 0 13
65897: PUSH
65898: LD_INT 2
65900: PLUS
65901: GREATER
65902: OR
65903: PUSH
65904: LD_VAR 0 8
65908: PUSH
65909: LD_INT 2
65911: ARRAY
65912: PUSH
65913: LD_VAR 0 13
65917: PUSH
65918: LD_INT 2
65920: MINUS
65921: LESS
65922: OR
65923: PUSH
65924: LD_VAR 0 8
65928: PUSH
65929: LD_INT 3
65931: ARRAY
65932: PUSH
65933: LD_INT 0
65935: PUSH
65936: LD_INT 8
65938: PUSH
65939: LD_INT 9
65941: PUSH
65942: LD_INT 10
65944: PUSH
65945: LD_INT 11
65947: PUSH
65948: LD_INT 12
65950: PUSH
65951: LD_INT 13
65953: PUSH
65954: LD_INT 16
65956: PUSH
65957: LD_INT 17
65959: PUSH
65960: LD_INT 18
65962: PUSH
65963: LD_INT 19
65965: PUSH
65966: LD_INT 20
65968: PUSH
65969: LD_INT 21
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: IN
65987: NOT
65988: OR
65989: PUSH
65990: LD_VAR 0 8
65994: PUSH
65995: LD_INT 5
65997: ARRAY
65998: NOT
65999: OR
66000: PUSH
66001: LD_VAR 0 8
66005: PUSH
66006: LD_INT 6
66008: ARRAY
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 2
66015: PUSH
66016: LD_INT 7
66018: PUSH
66019: LD_INT 9
66021: PUSH
66022: LD_INT 10
66024: PUSH
66025: LD_INT 11
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: LIST
66034: LIST
66035: IN
66036: NOT
66037: OR
66038: IFFALSE 66044
// exit ;
66040: POP
66041: POP
66042: GO 66127
// end ;
66044: GO 65715
66046: POP
66047: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66048: LD_VAR 0 9
66052: PPUSH
66053: LD_VAR 0 3
66057: PPUSH
66058: LD_VAR 0 4
66062: PPUSH
66063: LD_INT 20
66065: PPUSH
66066: CALL 58073 0 4
66070: PUSH
66071: LD_INT 4
66073: ARRAY
66074: IFFALSE 66078
// exit ;
66076: GO 66127
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66078: LD_VAR 0 2
66082: PUSH
66083: LD_INT 29
66085: PUSH
66086: LD_INT 30
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: IN
66093: PUSH
66094: LD_VAR 0 3
66098: PPUSH
66099: LD_VAR 0 4
66103: PPUSH
66104: LD_VAR 0 9
66108: PPUSH
66109: CALL_OW 440
66113: NOT
66114: AND
66115: IFFALSE 66119
// exit ;
66117: GO 66127
// result := true ;
66119: LD_ADDR_VAR 0 6
66123: PUSH
66124: LD_INT 1
66126: ST_TO_ADDR
// end ;
66127: LD_VAR 0 6
66131: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66132: LD_INT 0
66134: PPUSH
66135: PPUSH
66136: PPUSH
66137: PPUSH
66138: PPUSH
66139: PPUSH
66140: PPUSH
66141: PPUSH
66142: PPUSH
66143: PPUSH
66144: PPUSH
66145: PPUSH
66146: PPUSH
66147: PPUSH
66148: PPUSH
66149: PPUSH
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
66178: PPUSH
66179: PPUSH
66180: PPUSH
66181: PPUSH
66182: PPUSH
66183: PPUSH
66184: PPUSH
66185: PPUSH
66186: PPUSH
66187: PPUSH
66188: PPUSH
66189: PPUSH
66190: PPUSH
66191: PPUSH
// result = [ ] ;
66192: LD_ADDR_VAR 0 7
66196: PUSH
66197: EMPTY
66198: ST_TO_ADDR
// temp_list = [ ] ;
66199: LD_ADDR_VAR 0 9
66203: PUSH
66204: EMPTY
66205: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66206: LD_VAR 0 4
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 2
66219: PUSH
66220: LD_INT 3
66222: PUSH
66223: LD_INT 4
66225: PUSH
66226: LD_INT 5
66228: PUSH
66229: EMPTY
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: IN
66237: NOT
66238: PUSH
66239: LD_VAR 0 1
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: IN
66254: PUSH
66255: LD_VAR 0 5
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: LD_INT 2
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: LIST
66273: IN
66274: NOT
66275: AND
66276: OR
66277: IFFALSE 66281
// exit ;
66279: GO 84672
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66281: LD_VAR 0 1
66285: PUSH
66286: LD_INT 6
66288: PUSH
66289: LD_INT 7
66291: PUSH
66292: LD_INT 8
66294: PUSH
66295: LD_INT 13
66297: PUSH
66298: LD_INT 12
66300: PUSH
66301: LD_INT 15
66303: PUSH
66304: LD_INT 11
66306: PUSH
66307: LD_INT 14
66309: PUSH
66310: LD_INT 10
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: IN
66324: IFFALSE 66334
// btype = b_lab ;
66326: LD_ADDR_VAR 0 1
66330: PUSH
66331: LD_INT 6
66333: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66334: LD_VAR 0 6
66338: PUSH
66339: LD_INT 0
66341: PUSH
66342: LD_INT 1
66344: PUSH
66345: LD_INT 2
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: LIST
66352: IN
66353: NOT
66354: PUSH
66355: LD_VAR 0 1
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: LD_INT 1
66365: PUSH
66366: LD_INT 2
66368: PUSH
66369: LD_INT 3
66371: PUSH
66372: LD_INT 6
66374: PUSH
66375: LD_INT 36
66377: PUSH
66378: LD_INT 4
66380: PUSH
66381: LD_INT 5
66383: PUSH
66384: LD_INT 31
66386: PUSH
66387: LD_INT 32
66389: PUSH
66390: LD_INT 33
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: IN
66406: NOT
66407: PUSH
66408: LD_VAR 0 6
66412: PUSH
66413: LD_INT 1
66415: EQUAL
66416: AND
66417: OR
66418: PUSH
66419: LD_VAR 0 1
66423: PUSH
66424: LD_INT 2
66426: PUSH
66427: LD_INT 3
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: IN
66434: NOT
66435: PUSH
66436: LD_VAR 0 6
66440: PUSH
66441: LD_INT 2
66443: EQUAL
66444: AND
66445: OR
66446: IFFALSE 66456
// mode = 0 ;
66448: LD_ADDR_VAR 0 6
66452: PUSH
66453: LD_INT 0
66455: ST_TO_ADDR
// case mode of 0 :
66456: LD_VAR 0 6
66460: PUSH
66461: LD_INT 0
66463: DOUBLE
66464: EQUAL
66465: IFTRUE 66469
66467: GO 77922
66469: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66470: LD_ADDR_VAR 0 11
66474: PUSH
66475: LD_INT 0
66477: PUSH
66478: LD_INT 0
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 0
66487: PUSH
66488: LD_INT 1
66490: NEG
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: PUSH
66499: LD_INT 0
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 1
66508: PUSH
66509: LD_INT 1
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: LD_INT 1
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 1
66528: NEG
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 1
66539: NEG
66540: PUSH
66541: LD_INT 1
66543: NEG
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 1
66551: NEG
66552: PUSH
66553: LD_INT 2
66555: NEG
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 0
66563: PUSH
66564: LD_INT 2
66566: NEG
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 1
66574: PUSH
66575: LD_INT 1
66577: NEG
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 1
66585: PUSH
66586: LD_INT 2
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 0
66595: PUSH
66596: LD_INT 2
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 1
66605: NEG
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 1
66616: PUSH
66617: LD_INT 3
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 0
66626: PUSH
66627: LD_INT 3
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: LD_INT 2
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66663: LD_ADDR_VAR 0 12
66667: PUSH
66668: LD_INT 0
66670: PUSH
66671: LD_INT 0
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: LD_INT 0
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 1
66701: PUSH
66702: LD_INT 1
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: LD_INT 1
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 1
66721: NEG
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: NEG
66733: PUSH
66734: LD_INT 1
66736: NEG
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 1
66744: PUSH
66745: LD_INT 1
66747: NEG
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 2
66755: PUSH
66756: LD_INT 0
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 2
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: LD_INT 1
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 2
66786: NEG
66787: PUSH
66788: LD_INT 0
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: NEG
66798: PUSH
66799: LD_INT 1
66801: NEG
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: LD_INT 2
66809: NEG
66810: PUSH
66811: LD_INT 1
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 3
66820: NEG
66821: PUSH
66822: LD_INT 0
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 3
66831: NEG
66832: PUSH
66833: LD_INT 1
66835: NEG
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66859: LD_ADDR_VAR 0 13
66863: PUSH
66864: LD_INT 0
66866: PUSH
66867: LD_INT 0
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: LD_INT 0
66876: PUSH
66877: LD_INT 1
66879: NEG
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 1
66887: PUSH
66888: LD_INT 0
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: LD_INT 1
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 0
66907: PUSH
66908: LD_INT 1
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 1
66917: NEG
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 1
66928: NEG
66929: PUSH
66930: LD_INT 1
66932: NEG
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 1
66940: NEG
66941: PUSH
66942: LD_INT 2
66944: NEG
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 2
66952: PUSH
66953: LD_INT 1
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 2
66962: PUSH
66963: LD_INT 2
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 1
66972: PUSH
66973: LD_INT 2
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 2
66982: NEG
66983: PUSH
66984: LD_INT 1
66986: NEG
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 2
66994: NEG
66995: PUSH
66996: LD_INT 2
66998: NEG
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 2
67006: NEG
67007: PUSH
67008: LD_INT 3
67010: NEG
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 3
67018: NEG
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 3
67030: NEG
67031: PUSH
67032: LD_INT 3
67034: NEG
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67058: LD_ADDR_VAR 0 14
67062: PUSH
67063: LD_INT 0
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: PUSH
67073: LD_INT 0
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: LD_INT 1
67086: PUSH
67087: LD_INT 0
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 1
67096: PUSH
67097: LD_INT 1
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: LD_INT 1
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PUSH
67118: LD_INT 0
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 1
67139: NEG
67140: PUSH
67141: LD_INT 2
67143: NEG
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: LD_INT 2
67154: NEG
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: PUSH
67163: LD_INT 1
67165: NEG
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: PUSH
67174: LD_INT 2
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 0
67183: PUSH
67184: LD_INT 2
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 1
67193: NEG
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: LD_INT 3
67208: NEG
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: LD_INT 3
67219: NEG
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: LD_INT 1
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67254: LD_ADDR_VAR 0 15
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: LD_INT 0
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 1
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: LD_INT 1
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: NEG
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 1
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 1
67338: NEG
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: LD_INT 0
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: LD_INT 1
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 2
67377: NEG
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: LD_INT 1
67392: NEG
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 2
67400: PUSH
67401: LD_INT 1
67403: NEG
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 3
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 3
67421: PUSH
67422: LD_INT 1
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67447: LD_ADDR_VAR 0 16
67451: PUSH
67452: LD_INT 0
67454: PUSH
67455: LD_INT 0
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 0
67464: PUSH
67465: LD_INT 1
67467: NEG
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 1
67475: PUSH
67476: LD_INT 0
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 1
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 0
67495: PUSH
67496: LD_INT 1
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 1
67505: NEG
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 1
67516: NEG
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: LD_INT 2
67532: NEG
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 2
67540: PUSH
67541: LD_INT 1
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 2
67550: PUSH
67551: LD_INT 2
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 1
67560: PUSH
67561: LD_INT 2
67563: PUSH
67564: EMPTY
67565: LIST
67566: LIST
67567: PUSH
67568: LD_INT 2
67570: NEG
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 2
67582: NEG
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 3
67594: PUSH
67595: LD_INT 2
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: PUSH
67602: LD_INT 3
67604: PUSH
67605: LD_INT 3
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 2
67614: PUSH
67615: LD_INT 3
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67640: LD_ADDR_VAR 0 17
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: LD_INT 0
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: LD_INT 1
67660: NEG
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 1
67668: PUSH
67669: LD_INT 0
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: LD_INT 1
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 0
67688: PUSH
67689: LD_INT 1
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 1
67698: NEG
67699: PUSH
67700: LD_INT 0
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: LD_INT 1
67713: NEG
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 1
67721: NEG
67722: PUSH
67723: LD_INT 2
67725: NEG
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: LD_INT 2
67736: NEG
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PUSH
67742: LD_INT 1
67744: PUSH
67745: LD_INT 1
67747: NEG
67748: PUSH
67749: EMPTY
67750: LIST
67751: LIST
67752: PUSH
67753: LD_INT 2
67755: PUSH
67756: LD_INT 0
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 2
67765: PUSH
67766: LD_INT 1
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: LD_INT 2
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 2
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: NEG
67817: PUSH
67818: LD_INT 0
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 2
67827: NEG
67828: PUSH
67829: LD_INT 1
67831: NEG
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: PUSH
67837: LD_INT 2
67839: NEG
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67870: LD_ADDR_VAR 0 18
67874: PUSH
67875: LD_INT 0
67877: PUSH
67878: LD_INT 0
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: LD_INT 1
67890: NEG
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: LD_INT 0
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: LD_INT 1
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 0
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 1
67928: NEG
67929: PUSH
67930: LD_INT 0
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 1
67939: NEG
67940: PUSH
67941: LD_INT 1
67943: NEG
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 1
67951: NEG
67952: PUSH
67953: LD_INT 2
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: LD_INT 2
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 1
67974: PUSH
67975: LD_INT 1
67977: NEG
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 2
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: LD_INT 1
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: LD_INT 2
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 2
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 1
68035: NEG
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: LD_INT 1
68061: NEG
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 2
68069: NEG
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68100: LD_ADDR_VAR 0 19
68104: PUSH
68105: LD_INT 0
68107: PUSH
68108: LD_INT 0
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 1
68128: PUSH
68129: LD_INT 0
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 1
68138: PUSH
68139: LD_INT 1
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 1
68158: NEG
68159: PUSH
68160: LD_INT 0
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: LD_INT 1
68169: NEG
68170: PUSH
68171: LD_INT 1
68173: NEG
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PUSH
68179: LD_INT 1
68181: NEG
68182: PUSH
68183: LD_INT 2
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 0
68193: PUSH
68194: LD_INT 2
68196: NEG
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: LD_INT 1
68204: PUSH
68205: LD_INT 1
68207: NEG
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 2
68215: PUSH
68216: LD_INT 0
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: LD_INT 1
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: LD_INT 2
68235: PUSH
68236: LD_INT 2
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 1
68245: PUSH
68246: LD_INT 2
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 2
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 2
68276: NEG
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 2
68287: NEG
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: LD_INT 2
68299: NEG
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68330: LD_ADDR_VAR 0 20
68334: PUSH
68335: LD_INT 0
68337: PUSH
68338: LD_INT 0
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 0
68347: PUSH
68348: LD_INT 1
68350: NEG
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: LD_INT 0
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 1
68368: PUSH
68369: LD_INT 1
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 0
68378: PUSH
68379: LD_INT 1
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: LD_INT 0
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: PUSH
68397: LD_INT 1
68399: NEG
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PUSH
68409: LD_INT 1
68411: NEG
68412: PUSH
68413: LD_INT 2
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 0
68423: PUSH
68424: LD_INT 2
68426: NEG
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 1
68434: PUSH
68435: LD_INT 1
68437: NEG
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 2
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 2
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 2
68465: PUSH
68466: LD_INT 2
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 1
68475: PUSH
68476: LD_INT 2
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 2
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 2
68506: NEG
68507: PUSH
68508: LD_INT 0
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 2
68517: NEG
68518: PUSH
68519: LD_INT 1
68521: NEG
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 2
68529: NEG
68530: PUSH
68531: LD_INT 2
68533: NEG
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68560: LD_ADDR_VAR 0 21
68564: PUSH
68565: LD_INT 0
68567: PUSH
68568: LD_INT 0
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 0
68577: PUSH
68578: LD_INT 1
68580: NEG
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 1
68588: PUSH
68589: LD_INT 0
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 1
68598: PUSH
68599: LD_INT 1
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 0
68608: PUSH
68609: LD_INT 1
68611: PUSH
68612: EMPTY
68613: LIST
68614: LIST
68615: PUSH
68616: LD_INT 1
68618: NEG
68619: PUSH
68620: LD_INT 0
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 1
68629: NEG
68630: PUSH
68631: LD_INT 1
68633: NEG
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: LD_INT 2
68645: NEG
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 0
68653: PUSH
68654: LD_INT 2
68656: NEG
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 1
68664: PUSH
68665: LD_INT 1
68667: NEG
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 2
68675: PUSH
68676: LD_INT 0
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 2
68685: PUSH
68686: LD_INT 1
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 2
68695: PUSH
68696: LD_INT 2
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 1
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: LD_INT 2
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 1
68725: NEG
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: NEG
68737: PUSH
68738: LD_INT 0
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 2
68747: NEG
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 2
68759: NEG
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68790: LD_ADDR_VAR 0 22
68794: PUSH
68795: LD_INT 0
68797: PUSH
68798: LD_INT 0
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 0
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 1
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 1
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 0
68838: PUSH
68839: LD_INT 1
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 1
68848: NEG
68849: PUSH
68850: LD_INT 0
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 1
68859: NEG
68860: PUSH
68861: LD_INT 1
68863: NEG
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 1
68871: NEG
68872: PUSH
68873: LD_INT 2
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 0
68883: PUSH
68884: LD_INT 2
68886: NEG
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 1
68894: PUSH
68895: LD_INT 1
68897: NEG
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 2
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 2
68915: PUSH
68916: LD_INT 1
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 2
68925: PUSH
68926: LD_INT 2
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: LD_INT 2
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: LD_INT 2
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: LD_INT 1
68955: NEG
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 2
68966: NEG
68967: PUSH
68968: LD_INT 0
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 2
68977: NEG
68978: PUSH
68979: LD_INT 1
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 2
68989: NEG
68990: PUSH
68991: LD_INT 2
68993: NEG
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69020: LD_ADDR_VAR 0 23
69024: PUSH
69025: LD_INT 0
69027: PUSH
69028: LD_INT 0
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 0
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 1
69048: PUSH
69049: LD_INT 0
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: LD_INT 1
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: LD_INT 0
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: NEG
69090: PUSH
69091: LD_INT 1
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: LD_INT 2
69105: NEG
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 2
69135: PUSH
69136: LD_INT 0
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 2
69145: PUSH
69146: LD_INT 1
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 2
69155: PUSH
69156: LD_INT 2
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: PUSH
69166: LD_INT 2
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 0
69175: PUSH
69176: LD_INT 2
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 1
69185: NEG
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 2
69196: NEG
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 2
69207: NEG
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 2
69219: NEG
69220: PUSH
69221: LD_INT 2
69223: NEG
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 2
69231: NEG
69232: PUSH
69233: LD_INT 3
69235: NEG
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 3
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: PUSH
69256: LD_INT 2
69258: NEG
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 2
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69300: LD_ADDR_VAR 0 24
69304: PUSH
69305: LD_INT 0
69307: PUSH
69308: LD_INT 0
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 1
69320: NEG
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 1
69328: PUSH
69329: LD_INT 0
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: LD_INT 1
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 0
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 1
69358: NEG
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: LD_INT 1
69373: NEG
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: LD_INT 2
69385: NEG
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 0
69393: PUSH
69394: LD_INT 2
69396: NEG
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: LD_INT 1
69407: NEG
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 2
69415: PUSH
69416: LD_INT 0
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 1
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 2
69435: PUSH
69436: LD_INT 2
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: LD_INT 2
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 0
69455: PUSH
69456: LD_INT 2
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: NEG
69466: PUSH
69467: LD_INT 1
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 2
69476: NEG
69477: PUSH
69478: LD_INT 0
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 2
69487: NEG
69488: PUSH
69489: LD_INT 1
69491: NEG
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 2
69499: NEG
69500: PUSH
69501: LD_INT 2
69503: NEG
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 1
69511: PUSH
69512: LD_INT 2
69514: NEG
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 2
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 3
69533: PUSH
69534: LD_INT 1
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 3
69543: PUSH
69544: LD_INT 2
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69576: LD_ADDR_VAR 0 25
69580: PUSH
69581: LD_INT 0
69583: PUSH
69584: LD_INT 0
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 0
69593: PUSH
69594: LD_INT 1
69596: NEG
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 1
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: LD_INT 1
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: LD_INT 0
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 1
69634: NEG
69635: PUSH
69636: LD_INT 0
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 1
69645: NEG
69646: PUSH
69647: LD_INT 1
69649: NEG
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 1
69657: NEG
69658: PUSH
69659: LD_INT 2
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: LD_INT 2
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 1
69680: PUSH
69681: LD_INT 1
69683: NEG
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 2
69691: PUSH
69692: LD_INT 0
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 2
69701: PUSH
69702: LD_INT 1
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 2
69711: PUSH
69712: LD_INT 2
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 1
69721: PUSH
69722: LD_INT 2
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 0
69731: PUSH
69732: LD_INT 2
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 1
69741: NEG
69742: PUSH
69743: LD_INT 1
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PUSH
69750: LD_INT 2
69752: NEG
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 2
69763: NEG
69764: PUSH
69765: LD_INT 1
69767: NEG
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: LD_INT 2
69779: NEG
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 3
69787: PUSH
69788: LD_INT 1
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 3
69797: PUSH
69798: LD_INT 2
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 2
69807: PUSH
69808: LD_INT 3
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: PUSH
69818: LD_INT 3
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69850: LD_ADDR_VAR 0 26
69854: PUSH
69855: LD_INT 0
69857: PUSH
69858: LD_INT 0
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 0
69867: PUSH
69868: LD_INT 1
69870: NEG
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 1
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 1
69888: PUSH
69889: LD_INT 1
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 0
69898: PUSH
69899: LD_INT 1
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 1
69908: NEG
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 1
69931: NEG
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 0
69943: PUSH
69944: LD_INT 2
69946: NEG
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 1
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 2
69965: PUSH
69966: LD_INT 0
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 2
69975: PUSH
69976: LD_INT 1
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: LD_INT 2
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: PUSH
69996: LD_INT 2
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: LD_INT 2
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 1
70015: NEG
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 2
70026: NEG
70027: PUSH
70028: LD_INT 0
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 2
70037: NEG
70038: PUSH
70039: LD_INT 1
70041: NEG
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 2
70049: NEG
70050: PUSH
70051: LD_INT 2
70053: NEG
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 2
70061: PUSH
70062: LD_INT 3
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 1
70071: PUSH
70072: LD_INT 3
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 1
70081: NEG
70082: PUSH
70083: LD_INT 2
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 2
70092: NEG
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70126: LD_ADDR_VAR 0 27
70130: PUSH
70131: LD_INT 0
70133: PUSH
70134: LD_INT 0
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 0
70143: PUSH
70144: LD_INT 1
70146: NEG
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 1
70154: PUSH
70155: LD_INT 0
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: LD_INT 1
70164: PUSH
70165: LD_INT 1
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: LD_INT 1
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: LD_INT 1
70184: NEG
70185: PUSH
70186: LD_INT 0
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 1
70195: NEG
70196: PUSH
70197: LD_INT 1
70199: NEG
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 1
70207: NEG
70208: PUSH
70209: LD_INT 2
70211: NEG
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 0
70219: PUSH
70220: LD_INT 2
70222: NEG
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 1
70230: PUSH
70231: LD_INT 1
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 2
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 2
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 2
70261: PUSH
70262: LD_INT 2
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: LD_INT 2
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: LD_INT 2
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: LD_INT 1
70291: NEG
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 2
70302: NEG
70303: PUSH
70304: LD_INT 0
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: PUSH
70311: LD_INT 2
70313: NEG
70314: PUSH
70315: LD_INT 1
70317: NEG
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 2
70325: NEG
70326: PUSH
70327: LD_INT 2
70329: NEG
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: LD_INT 2
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 2
70348: NEG
70349: PUSH
70350: LD_INT 1
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 3
70359: NEG
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 3
70371: NEG
70372: PUSH
70373: LD_INT 2
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70406: LD_ADDR_VAR 0 28
70410: PUSH
70411: LD_INT 0
70413: PUSH
70414: LD_INT 0
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 0
70423: PUSH
70424: LD_INT 1
70426: NEG
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 1
70434: PUSH
70435: LD_INT 0
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 1
70444: PUSH
70445: LD_INT 1
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: LD_INT 1
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 1
70475: NEG
70476: PUSH
70477: LD_INT 1
70479: NEG
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: LD_INT 2
70491: NEG
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 0
70499: PUSH
70500: LD_INT 2
70502: NEG
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 1
70510: PUSH
70511: LD_INT 1
70513: NEG
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: PUSH
70519: LD_INT 2
70521: PUSH
70522: LD_INT 0
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: LD_INT 2
70531: PUSH
70532: LD_INT 1
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 2
70541: PUSH
70542: LD_INT 2
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: LD_INT 2
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 0
70561: PUSH
70562: LD_INT 2
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 1
70571: NEG
70572: PUSH
70573: LD_INT 1
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 2
70582: NEG
70583: PUSH
70584: LD_INT 0
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 2
70593: NEG
70594: PUSH
70595: LD_INT 1
70597: NEG
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 2
70605: NEG
70606: PUSH
70607: LD_INT 2
70609: NEG
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: LD_INT 3
70621: NEG
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: NEG
70630: PUSH
70631: LD_INT 3
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 3
70641: NEG
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 3
70653: NEG
70654: PUSH
70655: LD_INT 2
70657: NEG
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70688: LD_ADDR_VAR 0 29
70692: PUSH
70693: LD_INT 0
70695: PUSH
70696: LD_INT 0
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: LD_INT 1
70708: NEG
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 1
70716: PUSH
70717: LD_INT 0
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: LD_INT 1
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: LD_INT 0
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 1
70757: NEG
70758: PUSH
70759: LD_INT 1
70761: NEG
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: LD_INT 2
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 2
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 2
70803: PUSH
70804: LD_INT 0
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: LD_INT 1
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 1
70823: PUSH
70824: LD_INT 2
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 0
70833: PUSH
70834: LD_INT 2
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 1
70843: NEG
70844: PUSH
70845: LD_INT 1
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 2
70854: NEG
70855: PUSH
70856: LD_INT 1
70858: NEG
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 2
70866: NEG
70867: PUSH
70868: LD_INT 2
70870: NEG
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 2
70878: NEG
70879: PUSH
70880: LD_INT 3
70882: NEG
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 2
70890: PUSH
70891: LD_INT 1
70893: NEG
70894: PUSH
70895: EMPTY
70896: LIST
70897: LIST
70898: PUSH
70899: LD_INT 3
70901: PUSH
70902: LD_INT 1
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 1
70911: PUSH
70912: LD_INT 3
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 1
70921: NEG
70922: PUSH
70923: LD_INT 2
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 3
70932: NEG
70933: PUSH
70934: LD_INT 2
70936: NEG
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: LIST
70957: LIST
70958: LIST
70959: LIST
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: LIST
70966: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70967: LD_ADDR_VAR 0 30
70971: PUSH
70972: LD_INT 0
70974: PUSH
70975: LD_INT 0
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 0
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: LD_INT 0
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 1
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: LD_INT 0
71015: PUSH
71016: LD_INT 1
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 1
71025: NEG
71026: PUSH
71027: LD_INT 0
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 1
71036: NEG
71037: PUSH
71038: LD_INT 1
71040: NEG
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 1
71048: NEG
71049: PUSH
71050: LD_INT 2
71052: NEG
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 0
71060: PUSH
71061: LD_INT 2
71063: NEG
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 1
71071: PUSH
71072: LD_INT 1
71074: NEG
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 2
71082: PUSH
71083: LD_INT 0
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 2
71092: PUSH
71093: LD_INT 1
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 2
71102: PUSH
71103: LD_INT 2
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: PUSH
71113: LD_INT 2
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: LD_INT 1
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 2
71133: NEG
71134: PUSH
71135: LD_INT 0
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 2
71144: NEG
71145: PUSH
71146: LD_INT 1
71148: NEG
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 1
71156: NEG
71157: PUSH
71158: LD_INT 3
71160: NEG
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 1
71168: PUSH
71169: LD_INT 2
71171: NEG
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 3
71179: PUSH
71180: LD_INT 2
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: LD_INT 3
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: LD_INT 1
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 3
71210: NEG
71211: PUSH
71212: LD_INT 1
71214: NEG
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: LIST
71231: LIST
71232: LIST
71233: LIST
71234: LIST
71235: LIST
71236: LIST
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71245: LD_ADDR_VAR 0 31
71249: PUSH
71250: LD_INT 0
71252: PUSH
71253: LD_INT 0
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: LD_INT 1
71265: NEG
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 1
71273: PUSH
71274: LD_INT 0
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 1
71283: PUSH
71284: LD_INT 1
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 0
71293: PUSH
71294: LD_INT 1
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: LD_INT 0
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 1
71314: NEG
71315: PUSH
71316: LD_INT 1
71318: NEG
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 1
71326: NEG
71327: PUSH
71328: LD_INT 2
71330: NEG
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: PUSH
71336: LD_INT 1
71338: PUSH
71339: LD_INT 1
71341: NEG
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 2
71349: PUSH
71350: LD_INT 0
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 2
71359: PUSH
71360: LD_INT 1
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: LD_INT 2
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: LD_INT 2
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 1
71399: NEG
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 2
71410: NEG
71411: PUSH
71412: LD_INT 1
71414: NEG
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 2
71422: NEG
71423: PUSH
71424: LD_INT 2
71426: NEG
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 2
71434: NEG
71435: PUSH
71436: LD_INT 3
71438: NEG
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: LD_INT 1
71449: NEG
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 3
71457: PUSH
71458: LD_INT 1
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: LD_INT 3
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: PUSH
71475: LD_INT 1
71477: NEG
71478: PUSH
71479: LD_INT 2
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 3
71488: NEG
71489: PUSH
71490: LD_INT 2
71492: NEG
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: LIST
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71523: LD_ADDR_VAR 0 32
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 0
71540: PUSH
71541: LD_INT 1
71543: NEG
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 1
71551: PUSH
71552: LD_INT 0
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 1
71561: PUSH
71562: LD_INT 1
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 0
71571: PUSH
71572: LD_INT 1
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 1
71581: NEG
71582: PUSH
71583: LD_INT 0
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 1
71592: NEG
71593: PUSH
71594: LD_INT 1
71596: NEG
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 1
71604: NEG
71605: PUSH
71606: LD_INT 2
71608: NEG
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 0
71616: PUSH
71617: LD_INT 2
71619: NEG
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 1
71627: PUSH
71628: LD_INT 1
71630: NEG
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 2
71638: PUSH
71639: LD_INT 1
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 2
71648: PUSH
71649: LD_INT 2
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 1
71658: PUSH
71659: LD_INT 2
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: LD_INT 2
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: LD_INT 1
71678: NEG
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 2
71689: NEG
71690: PUSH
71691: LD_INT 0
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 2
71700: NEG
71701: PUSH
71702: LD_INT 1
71704: NEG
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: LD_INT 3
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: PUSH
71725: LD_INT 2
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 3
71735: PUSH
71736: LD_INT 2
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 2
71745: PUSH
71746: LD_INT 3
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 2
71755: NEG
71756: PUSH
71757: LD_INT 1
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PUSH
71764: LD_INT 3
71766: NEG
71767: PUSH
71768: LD_INT 1
71770: NEG
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71801: LD_ADDR_VAR 0 33
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 0
71818: PUSH
71819: LD_INT 1
71821: NEG
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: LD_INT 0
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 1
71839: PUSH
71840: LD_INT 1
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: LD_INT 0
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: NEG
71883: PUSH
71884: LD_INT 2
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: PUSH
71895: LD_INT 1
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: LD_INT 0
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: LD_INT 1
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 0
71935: PUSH
71936: LD_INT 2
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 2
71956: NEG
71957: PUSH
71958: LD_INT 0
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: LD_INT 1
71971: NEG
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 2
71979: NEG
71980: PUSH
71981: LD_INT 2
71983: NEG
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 2
71991: NEG
71992: PUSH
71993: LD_INT 3
71995: NEG
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 2
72003: PUSH
72004: LD_INT 1
72006: NEG
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 3
72014: PUSH
72015: LD_INT 1
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 1
72024: PUSH
72025: LD_INT 3
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 1
72034: NEG
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 3
72045: NEG
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72080: LD_ADDR_VAR 0 34
72084: PUSH
72085: LD_INT 0
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 0
72097: PUSH
72098: LD_INT 1
72100: NEG
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 1
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: LD_INT 1
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 1
72138: NEG
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: LD_INT 2
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: LD_INT 2
72176: NEG
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: LD_INT 1
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 2
72205: PUSH
72206: LD_INT 2
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 1
72215: PUSH
72216: LD_INT 2
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 1
72225: NEG
72226: PUSH
72227: LD_INT 1
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 2
72236: NEG
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 2
72247: NEG
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 2
72259: NEG
72260: PUSH
72261: LD_INT 2
72263: NEG
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 1
72271: NEG
72272: PUSH
72273: LD_INT 3
72275: NEG
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: PUSH
72284: LD_INT 2
72286: NEG
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 3
72294: PUSH
72295: LD_INT 2
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 2
72304: PUSH
72305: LD_INT 3
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 2
72314: NEG
72315: PUSH
72316: LD_INT 1
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 3
72325: NEG
72326: PUSH
72327: LD_INT 1
72329: NEG
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72360: LD_ADDR_VAR 0 35
72364: PUSH
72365: LD_INT 0
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 0
72377: PUSH
72378: LD_INT 1
72380: NEG
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 1
72398: PUSH
72399: LD_INT 1
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: LD_INT 1
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 1
72418: NEG
72419: PUSH
72420: LD_INT 0
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: LD_INT 1
72433: NEG
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 2
72441: PUSH
72442: LD_INT 1
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 2
72451: NEG
72452: PUSH
72453: LD_INT 1
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72472: LD_ADDR_VAR 0 36
72476: PUSH
72477: LD_INT 0
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: LD_INT 1
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 1
72545: NEG
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: LD_INT 1
72553: NEG
72554: PUSH
72555: LD_INT 2
72557: NEG
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: LD_INT 2
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: LIST
72577: LIST
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72584: LD_ADDR_VAR 0 37
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: LD_INT 0
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: LD_INT 0
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: PUSH
72613: LD_INT 0
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 1
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 0
72632: PUSH
72633: LD_INT 1
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 1
72642: NEG
72643: PUSH
72644: LD_INT 0
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PUSH
72651: LD_INT 1
72653: NEG
72654: PUSH
72655: LD_INT 1
72657: NEG
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: LD_INT 1
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 1
72676: NEG
72677: PUSH
72678: LD_INT 1
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: LIST
72695: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72696: LD_ADDR_VAR 0 38
72700: PUSH
72701: LD_INT 0
72703: PUSH
72704: LD_INT 0
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: LD_INT 1
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: LD_INT 1
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 1
72754: NEG
72755: PUSH
72756: LD_INT 0
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: LD_INT 1
72769: NEG
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 2
72777: PUSH
72778: LD_INT 1
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 2
72787: NEG
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: LIST
72806: LIST
72807: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72808: LD_ADDR_VAR 0 39
72812: PUSH
72813: LD_INT 0
72815: PUSH
72816: LD_INT 0
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 0
72825: PUSH
72826: LD_INT 1
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: LD_INT 1
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: LD_INT 1
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 1
72866: NEG
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 1
72877: NEG
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: NEG
72890: PUSH
72891: LD_INT 2
72893: NEG
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: LD_INT 2
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72920: LD_ADDR_VAR 0 40
72924: PUSH
72925: LD_INT 0
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 0
72937: PUSH
72938: LD_INT 1
72940: NEG
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: PUSH
72949: LD_INT 0
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 1
72958: PUSH
72959: LD_INT 1
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 0
72968: PUSH
72969: LD_INT 1
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 1
72978: NEG
72979: PUSH
72980: LD_INT 0
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 1
72989: NEG
72990: PUSH
72991: LD_INT 1
72993: NEG
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: PUSH
73002: LD_INT 1
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 1
73012: NEG
73013: PUSH
73014: LD_INT 1
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: LIST
73029: LIST
73030: LIST
73031: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73032: LD_ADDR_VAR 0 41
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: LD_INT 0
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 0
73049: PUSH
73050: LD_INT 1
73052: NEG
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 1
73060: PUSH
73061: LD_INT 0
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: LD_INT 1
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 1
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: LD_INT 0
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 1
73101: NEG
73102: PUSH
73103: LD_INT 1
73105: NEG
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 1
73113: NEG
73114: PUSH
73115: LD_INT 2
73117: NEG
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: LD_INT 1
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 2
73136: PUSH
73137: LD_INT 0
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 2
73146: PUSH
73147: LD_INT 1
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 2
73156: PUSH
73157: LD_INT 2
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 1
73166: PUSH
73167: LD_INT 2
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 2
73187: NEG
73188: PUSH
73189: LD_INT 0
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 2
73198: NEG
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 2
73210: NEG
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 2
73222: NEG
73223: PUSH
73224: LD_INT 3
73226: NEG
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 2
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 3
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 3
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 3
73265: PUSH
73266: LD_INT 2
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 3
73275: PUSH
73276: LD_INT 3
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 2
73285: PUSH
73286: LD_INT 3
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: LD_INT 2
73295: NEG
73296: PUSH
73297: LD_INT 1
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: PUSH
73304: LD_INT 3
73306: NEG
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: PUSH
73315: LD_INT 3
73317: NEG
73318: PUSH
73319: LD_INT 1
73321: NEG
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 3
73329: NEG
73330: PUSH
73331: LD_INT 2
73333: NEG
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 3
73341: NEG
73342: PUSH
73343: LD_INT 3
73345: NEG
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73382: LD_ADDR_VAR 0 42
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 0
73399: PUSH
73400: LD_INT 1
73402: NEG
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 1
73410: PUSH
73411: LD_INT 0
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 1
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 0
73430: PUSH
73431: LD_INT 1
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 1
73440: NEG
73441: PUSH
73442: LD_INT 0
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 1
73451: NEG
73452: PUSH
73453: LD_INT 1
73455: NEG
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 1
73463: NEG
73464: PUSH
73465: LD_INT 2
73467: NEG
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: LD_INT 2
73478: NEG
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 1
73486: PUSH
73487: LD_INT 1
73489: NEG
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 2
73497: PUSH
73498: LD_INT 1
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 2
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 1
73537: NEG
73538: PUSH
73539: LD_INT 1
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 2
73548: NEG
73549: PUSH
73550: LD_INT 1
73552: NEG
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 2
73560: NEG
73561: PUSH
73562: LD_INT 2
73564: NEG
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 2
73572: NEG
73573: PUSH
73574: LD_INT 3
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: LD_INT 3
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 0
73596: PUSH
73597: LD_INT 3
73599: NEG
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: PUSH
73608: LD_INT 2
73610: NEG
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 3
73618: PUSH
73619: LD_INT 2
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 3
73628: PUSH
73629: LD_INT 3
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 2
73638: PUSH
73639: LD_INT 3
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 1
73648: PUSH
73649: LD_INT 3
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 0
73658: PUSH
73659: LD_INT 3
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: NEG
73669: PUSH
73670: LD_INT 2
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 3
73679: NEG
73680: PUSH
73681: LD_INT 2
73683: NEG
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 3
73691: NEG
73692: PUSH
73693: LD_INT 3
73695: NEG
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73732: LD_ADDR_VAR 0 43
73736: PUSH
73737: LD_INT 0
73739: PUSH
73740: LD_INT 0
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 0
73749: PUSH
73750: LD_INT 1
73752: NEG
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 1
73770: PUSH
73771: LD_INT 1
73773: PUSH
73774: EMPTY
73775: LIST
73776: LIST
73777: PUSH
73778: LD_INT 0
73780: PUSH
73781: LD_INT 1
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 1
73790: NEG
73791: PUSH
73792: LD_INT 0
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 1
73801: NEG
73802: PUSH
73803: LD_INT 1
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 1
73813: NEG
73814: PUSH
73815: LD_INT 2
73817: NEG
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 0
73825: PUSH
73826: LD_INT 2
73828: NEG
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 1
73836: PUSH
73837: LD_INT 1
73839: NEG
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: LD_INT 2
73847: PUSH
73848: LD_INT 0
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 2
73857: PUSH
73858: LD_INT 1
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: LD_INT 1
73867: PUSH
73868: LD_INT 2
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: LD_INT 2
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: LD_INT 1
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 2
73898: NEG
73899: PUSH
73900: LD_INT 0
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 2
73909: NEG
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 1
73921: NEG
73922: PUSH
73923: LD_INT 3
73925: NEG
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: LD_INT 3
73936: NEG
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 1
73944: PUSH
73945: LD_INT 2
73947: NEG
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 1
73958: NEG
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 3
73966: PUSH
73967: LD_INT 0
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 3
73976: PUSH
73977: LD_INT 1
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 1
73986: PUSH
73987: LD_INT 3
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 0
73996: PUSH
73997: LD_INT 3
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 1
74006: NEG
74007: PUSH
74008: LD_INT 2
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 2
74017: NEG
74018: PUSH
74019: LD_INT 1
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: LD_INT 3
74028: NEG
74029: PUSH
74030: LD_INT 0
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 3
74039: NEG
74040: PUSH
74041: LD_INT 1
74043: NEG
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74080: LD_ADDR_VAR 0 44
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: LD_INT 0
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 0
74097: PUSH
74098: LD_INT 1
74100: NEG
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: LD_INT 1
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 0
74128: PUSH
74129: LD_INT 1
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 1
74138: NEG
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 1
74149: NEG
74150: PUSH
74151: LD_INT 1
74153: NEG
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 1
74161: NEG
74162: PUSH
74163: LD_INT 2
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 1
74173: PUSH
74174: LD_INT 1
74176: NEG
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 2
74184: PUSH
74185: LD_INT 0
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 2
74194: PUSH
74195: LD_INT 1
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 2
74204: PUSH
74205: LD_INT 2
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 1
74214: PUSH
74215: LD_INT 2
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: NEG
74225: PUSH
74226: LD_INT 1
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 2
74235: NEG
74236: PUSH
74237: LD_INT 0
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 2
74246: NEG
74247: PUSH
74248: LD_INT 1
74250: NEG
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 2
74258: NEG
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 2
74270: NEG
74271: PUSH
74272: LD_INT 3
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 2
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 3
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 3
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 3
74313: PUSH
74314: LD_INT 2
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 3
74323: PUSH
74324: LD_INT 3
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: PUSH
74334: LD_INT 3
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 2
74343: NEG
74344: PUSH
74345: LD_INT 1
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 3
74354: NEG
74355: PUSH
74356: LD_INT 0
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: LD_INT 3
74365: NEG
74366: PUSH
74367: LD_INT 1
74369: NEG
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 3
74377: NEG
74378: PUSH
74379: LD_INT 2
74381: NEG
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 3
74389: NEG
74390: PUSH
74391: LD_INT 3
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74430: LD_ADDR_VAR 0 45
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 0
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 0
74447: PUSH
74448: LD_INT 1
74450: NEG
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 1
74458: PUSH
74459: LD_INT 0
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 1
74468: PUSH
74469: LD_INT 1
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 0
74478: PUSH
74479: LD_INT 1
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 1
74488: NEG
74489: PUSH
74490: LD_INT 0
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 1
74499: NEG
74500: PUSH
74501: LD_INT 1
74503: NEG
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 1
74511: NEG
74512: PUSH
74513: LD_INT 2
74515: NEG
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PUSH
74521: LD_INT 0
74523: PUSH
74524: LD_INT 2
74526: NEG
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 1
74534: PUSH
74535: LD_INT 1
74537: NEG
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: LD_INT 2
74545: PUSH
74546: LD_INT 1
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 2
74555: PUSH
74556: LD_INT 2
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 1
74565: PUSH
74566: LD_INT 2
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 0
74575: PUSH
74576: LD_INT 2
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: PUSH
74587: LD_INT 1
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 2
74596: NEG
74597: PUSH
74598: LD_INT 1
74600: NEG
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 2
74608: NEG
74609: PUSH
74610: LD_INT 2
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 2
74620: NEG
74621: PUSH
74622: LD_INT 3
74624: NEG
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 1
74632: NEG
74633: PUSH
74634: LD_INT 3
74636: NEG
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: LD_INT 3
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 1
74655: PUSH
74656: LD_INT 2
74658: NEG
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 3
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 2
74686: PUSH
74687: LD_INT 3
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: PUSH
74697: LD_INT 3
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 0
74706: PUSH
74707: LD_INT 3
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 1
74716: NEG
74717: PUSH
74718: LD_INT 2
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 3
74727: NEG
74728: PUSH
74729: LD_INT 2
74731: NEG
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 3
74739: NEG
74740: PUSH
74741: LD_INT 3
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74780: LD_ADDR_VAR 0 46
74784: PUSH
74785: LD_INT 0
74787: PUSH
74788: LD_INT 0
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: LD_INT 0
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 1
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: LD_INT 1
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: LD_INT 1
74838: NEG
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 1
74849: NEG
74850: PUSH
74851: LD_INT 1
74853: NEG
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 1
74861: NEG
74862: PUSH
74863: LD_INT 2
74865: NEG
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: LD_INT 2
74876: NEG
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 1
74884: PUSH
74885: LD_INT 1
74887: NEG
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 2
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: PUSH
74906: LD_INT 1
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 1
74915: PUSH
74916: LD_INT 2
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 0
74925: PUSH
74926: LD_INT 2
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 1
74935: NEG
74936: PUSH
74937: LD_INT 1
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 2
74946: NEG
74947: PUSH
74948: LD_INT 0
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 2
74957: NEG
74958: PUSH
74959: LD_INT 1
74961: NEG
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 1
74969: NEG
74970: PUSH
74971: LD_INT 3
74973: NEG
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: LD_INT 3
74984: NEG
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: LD_INT 2
74995: NEG
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 2
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 3
75014: PUSH
75015: LD_INT 0
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 3
75024: PUSH
75025: LD_INT 1
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 1
75034: PUSH
75035: LD_INT 3
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 0
75044: PUSH
75045: LD_INT 3
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: NEG
75055: PUSH
75056: LD_INT 2
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 2
75065: NEG
75066: PUSH
75067: LD_INT 1
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 3
75076: NEG
75077: PUSH
75078: LD_INT 0
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 3
75087: NEG
75088: PUSH
75089: LD_INT 1
75091: NEG
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: LIST
75127: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75128: LD_ADDR_VAR 0 47
75132: PUSH
75133: LD_INT 0
75135: PUSH
75136: LD_INT 0
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: LD_INT 1
75148: NEG
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: LD_INT 1
75156: PUSH
75157: LD_INT 0
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 1
75166: PUSH
75167: LD_INT 1
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: LD_INT 1
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: NEG
75187: PUSH
75188: LD_INT 0
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 1
75197: NEG
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 1
75209: NEG
75210: PUSH
75211: LD_INT 2
75213: NEG
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: LD_INT 2
75224: NEG
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 2
75243: NEG
75244: PUSH
75245: LD_INT 1
75247: NEG
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 2
75255: NEG
75256: PUSH
75257: LD_INT 2
75259: NEG
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75279: LD_ADDR_VAR 0 48
75283: PUSH
75284: LD_INT 0
75286: PUSH
75287: LD_INT 0
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 0
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: LD_INT 0
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: LD_INT 1
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: NEG
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 1
75348: NEG
75349: PUSH
75350: LD_INT 1
75352: NEG
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: LD_INT 1
75360: NEG
75361: PUSH
75362: LD_INT 2
75364: NEG
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 0
75372: PUSH
75373: LD_INT 2
75375: NEG
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: LD_INT 1
75386: NEG
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 2
75394: PUSH
75395: LD_INT 0
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 2
75404: PUSH
75405: LD_INT 1
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75426: LD_ADDR_VAR 0 49
75430: PUSH
75431: LD_INT 0
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 0
75443: PUSH
75444: LD_INT 1
75446: NEG
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 0
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 1
75464: PUSH
75465: LD_INT 1
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 0
75474: PUSH
75475: LD_INT 1
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 1
75484: NEG
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 1
75495: NEG
75496: PUSH
75497: LD_INT 1
75499: NEG
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: LD_INT 1
75510: NEG
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: EMPTY
75523: LIST
75524: LIST
75525: PUSH
75526: LD_INT 2
75528: PUSH
75529: LD_INT 1
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 2
75538: PUSH
75539: LD_INT 2
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 1
75548: PUSH
75549: LD_INT 2
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75570: LD_ADDR_VAR 0 50
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: LD_INT 0
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 1
75590: NEG
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: LD_INT 0
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 1
75608: PUSH
75609: LD_INT 1
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 0
75618: PUSH
75619: LD_INT 1
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 1
75628: NEG
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 1
75639: NEG
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 2
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 2
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 1
75671: PUSH
75672: LD_INT 2
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 0
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: NEG
75692: PUSH
75693: LD_INT 1
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75714: LD_ADDR_VAR 0 51
75718: PUSH
75719: LD_INT 0
75721: PUSH
75722: LD_INT 0
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: LD_INT 1
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: PUSH
75743: LD_INT 0
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 1
75752: PUSH
75753: LD_INT 1
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: LD_INT 1
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 1
75772: NEG
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 1
75783: NEG
75784: PUSH
75785: LD_INT 1
75787: NEG
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 1
75795: PUSH
75796: LD_INT 2
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 0
75805: PUSH
75806: LD_INT 2
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: LD_INT 1
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 2
75826: NEG
75827: PUSH
75828: LD_INT 0
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: PUSH
75835: LD_INT 2
75837: NEG
75838: PUSH
75839: LD_INT 1
75841: NEG
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: LIST
75858: LIST
75859: LIST
75860: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75861: LD_ADDR_VAR 0 52
75865: PUSH
75866: LD_INT 0
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 0
75878: PUSH
75879: LD_INT 1
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 1
75889: PUSH
75890: LD_INT 0
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 1
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 0
75909: PUSH
75910: LD_INT 1
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 1
75919: NEG
75920: PUSH
75921: LD_INT 0
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PUSH
75928: LD_INT 1
75930: NEG
75931: PUSH
75932: LD_INT 1
75934: NEG
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 1
75942: NEG
75943: PUSH
75944: LD_INT 2
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 1
75954: NEG
75955: PUSH
75956: LD_INT 1
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 2
75965: NEG
75966: PUSH
75967: LD_INT 0
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: LD_INT 2
75976: NEG
75977: PUSH
75978: LD_INT 1
75980: NEG
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 2
75988: NEG
75989: PUSH
75990: LD_INT 2
75992: NEG
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76012: LD_ADDR_VAR 0 53
76016: PUSH
76017: LD_INT 0
76019: PUSH
76020: LD_INT 0
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: LD_INT 1
76032: NEG
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: LD_INT 0
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PUSH
76048: LD_INT 1
76050: PUSH
76051: LD_INT 1
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 0
76060: PUSH
76061: LD_INT 1
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 1
76070: NEG
76071: PUSH
76072: LD_INT 0
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 1
76081: NEG
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 1
76093: NEG
76094: PUSH
76095: LD_INT 2
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: LD_INT 2
76108: NEG
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 1
76116: PUSH
76117: LD_INT 1
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 2
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: LD_INT 1
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 2
76147: PUSH
76148: LD_INT 2
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 1
76157: PUSH
76158: LD_INT 2
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 0
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 1
76177: NEG
76178: PUSH
76179: LD_INT 1
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 2
76188: NEG
76189: PUSH
76190: LD_INT 0
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 2
76199: NEG
76200: PUSH
76201: LD_INT 1
76203: NEG
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 2
76211: NEG
76212: PUSH
76213: LD_INT 2
76215: NEG
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: LIST
76231: LIST
76232: LIST
76233: LIST
76234: LIST
76235: LIST
76236: LIST
76237: LIST
76238: LIST
76239: LIST
76240: LIST
76241: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76242: LD_ADDR_VAR 0 54
76246: PUSH
76247: LD_INT 0
76249: PUSH
76250: LD_INT 0
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: LD_INT 1
76262: NEG
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: LD_INT 0
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: LD_INT 1
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 0
76290: PUSH
76291: LD_INT 1
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 1
76300: NEG
76301: PUSH
76302: LD_INT 0
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 1
76311: NEG
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 1
76323: NEG
76324: PUSH
76325: LD_INT 2
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 2
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 1
76346: PUSH
76347: LD_INT 1
76349: NEG
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 2
76357: PUSH
76358: LD_INT 0
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: LD_INT 1
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: LD_INT 2
76377: PUSH
76378: LD_INT 2
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 1
76387: PUSH
76388: LD_INT 2
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 2
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 1
76407: NEG
76408: PUSH
76409: LD_INT 1
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 2
76418: NEG
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: LD_INT 1
76433: NEG
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PUSH
76439: LD_INT 2
76441: NEG
76442: PUSH
76443: LD_INT 2
76445: NEG
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: LIST
76460: LIST
76461: LIST
76462: LIST
76463: LIST
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76472: LD_ADDR_VAR 0 55
76476: PUSH
76477: LD_INT 0
76479: PUSH
76480: LD_INT 0
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 0
76489: PUSH
76490: LD_INT 1
76492: NEG
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 1
76500: PUSH
76501: LD_INT 0
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: LD_INT 1
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 0
76520: PUSH
76521: LD_INT 1
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 1
76530: NEG
76531: PUSH
76532: LD_INT 0
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 1
76541: NEG
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 1
76553: NEG
76554: PUSH
76555: LD_INT 2
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: LD_INT 2
76568: NEG
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 1
76576: PUSH
76577: LD_INT 1
76579: NEG
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 2
76587: PUSH
76588: LD_INT 0
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 2
76597: PUSH
76598: LD_INT 1
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: LD_INT 2
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 1
76617: PUSH
76618: LD_INT 2
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 0
76627: PUSH
76628: LD_INT 2
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 1
76637: NEG
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 2
76648: NEG
76649: PUSH
76650: LD_INT 0
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 2
76659: NEG
76660: PUSH
76661: LD_INT 1
76663: NEG
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: LD_INT 2
76671: NEG
76672: PUSH
76673: LD_INT 2
76675: NEG
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: LIST
76696: LIST
76697: LIST
76698: LIST
76699: LIST
76700: LIST
76701: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76702: LD_ADDR_VAR 0 56
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: LD_INT 0
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 0
76719: PUSH
76720: LD_INT 1
76722: NEG
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 1
76730: PUSH
76731: LD_INT 0
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 1
76740: PUSH
76741: LD_INT 1
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 0
76750: PUSH
76751: LD_INT 1
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 1
76760: NEG
76761: PUSH
76762: LD_INT 0
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 1
76771: NEG
76772: PUSH
76773: LD_INT 1
76775: NEG
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 1
76783: NEG
76784: PUSH
76785: LD_INT 2
76787: NEG
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: LD_INT 2
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 1
76806: PUSH
76807: LD_INT 1
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 2
76817: PUSH
76818: LD_INT 0
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 2
76827: PUSH
76828: LD_INT 1
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 2
76837: PUSH
76838: LD_INT 2
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 1
76847: PUSH
76848: LD_INT 2
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: LD_INT 2
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 1
76867: NEG
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 2
76889: NEG
76890: PUSH
76891: LD_INT 1
76893: NEG
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: PUSH
76899: LD_INT 2
76901: NEG
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: LIST
76926: LIST
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76932: LD_ADDR_VAR 0 57
76936: PUSH
76937: LD_INT 0
76939: PUSH
76940: LD_INT 0
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 0
76949: PUSH
76950: LD_INT 1
76952: NEG
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 1
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 1
76970: PUSH
76971: LD_INT 1
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 0
76980: PUSH
76981: LD_INT 1
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 1
76990: NEG
76991: PUSH
76992: LD_INT 0
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 1
77001: NEG
77002: PUSH
77003: LD_INT 1
77005: NEG
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 1
77013: NEG
77014: PUSH
77015: LD_INT 2
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 0
77025: PUSH
77026: LD_INT 2
77028: NEG
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 1
77036: PUSH
77037: LD_INT 1
77039: NEG
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: PUSH
77045: LD_INT 2
77047: PUSH
77048: LD_INT 0
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 2
77057: PUSH
77058: LD_INT 1
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 2
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 1
77077: PUSH
77078: LD_INT 2
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: LD_INT 2
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 2
77108: NEG
77109: PUSH
77110: LD_INT 0
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 2
77119: NEG
77120: PUSH
77121: LD_INT 1
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 2
77131: NEG
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: LIST
77158: LIST
77159: LIST
77160: LIST
77161: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77162: LD_ADDR_VAR 0 58
77166: PUSH
77167: LD_INT 0
77169: PUSH
77170: LD_INT 0
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: LD_INT 1
77182: NEG
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 1
77190: PUSH
77191: LD_INT 0
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 1
77200: PUSH
77201: LD_INT 1
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: LD_INT 0
77210: PUSH
77211: LD_INT 1
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 1
77220: NEG
77221: PUSH
77222: LD_INT 0
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PUSH
77229: LD_INT 1
77231: NEG
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 1
77243: NEG
77244: PUSH
77245: LD_INT 2
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 0
77255: PUSH
77256: LD_INT 2
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 1
77266: PUSH
77267: LD_INT 1
77269: NEG
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 2
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 2
77287: PUSH
77288: LD_INT 1
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 2
77297: PUSH
77298: LD_INT 2
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 1
77307: PUSH
77308: LD_INT 2
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 0
77317: PUSH
77318: LD_INT 2
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 2
77338: NEG
77339: PUSH
77340: LD_INT 0
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 2
77349: NEG
77350: PUSH
77351: LD_INT 1
77353: NEG
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 2
77361: NEG
77362: PUSH
77363: LD_INT 2
77365: NEG
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: LIST
77385: LIST
77386: LIST
77387: LIST
77388: LIST
77389: LIST
77390: LIST
77391: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77392: LD_ADDR_VAR 0 59
77396: PUSH
77397: LD_INT 0
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 0
77409: PUSH
77410: LD_INT 1
77412: NEG
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 1
77420: PUSH
77421: LD_INT 0
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 1
77430: PUSH
77431: LD_INT 1
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: LD_INT 1
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 1
77450: NEG
77451: PUSH
77452: LD_INT 0
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 1
77461: NEG
77462: PUSH
77463: LD_INT 1
77465: NEG
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77480: LD_ADDR_VAR 0 60
77484: PUSH
77485: LD_INT 0
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: LD_INT 1
77500: NEG
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 1
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 1
77518: PUSH
77519: LD_INT 1
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: LD_INT 1
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 1
77538: NEG
77539: PUSH
77540: LD_INT 0
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 1
77549: NEG
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77568: LD_ADDR_VAR 0 61
77572: PUSH
77573: LD_INT 0
77575: PUSH
77576: LD_INT 0
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: LD_INT 1
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: PUSH
77597: LD_INT 0
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: LD_INT 1
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 0
77616: PUSH
77617: LD_INT 1
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: LD_INT 1
77626: NEG
77627: PUSH
77628: LD_INT 0
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 1
77637: NEG
77638: PUSH
77639: LD_INT 1
77641: NEG
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77656: LD_ADDR_VAR 0 62
77660: PUSH
77661: LD_INT 0
77663: PUSH
77664: LD_INT 0
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 0
77673: PUSH
77674: LD_INT 1
77676: NEG
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 1
77684: PUSH
77685: LD_INT 0
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: PUSH
77692: LD_INT 1
77694: PUSH
77695: LD_INT 1
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 1
77714: NEG
77715: PUSH
77716: LD_INT 0
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: LD_INT 1
77729: NEG
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77744: LD_ADDR_VAR 0 63
77748: PUSH
77749: LD_INT 0
77751: PUSH
77752: LD_INT 0
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 0
77761: PUSH
77762: LD_INT 1
77764: NEG
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: LD_INT 0
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 1
77782: PUSH
77783: LD_INT 1
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 0
77792: PUSH
77793: LD_INT 1
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 1
77802: NEG
77803: PUSH
77804: LD_INT 0
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 1
77813: NEG
77814: PUSH
77815: LD_INT 1
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77832: LD_ADDR_VAR 0 64
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 0
77849: PUSH
77850: LD_INT 1
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: LD_INT 0
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 1
77870: PUSH
77871: LD_INT 1
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 0
77880: PUSH
77881: LD_INT 1
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 1
77890: NEG
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 1
77901: NEG
77902: PUSH
77903: LD_INT 1
77905: NEG
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: ST_TO_ADDR
// end ; 1 :
77920: GO 83817
77922: LD_INT 1
77924: DOUBLE
77925: EQUAL
77926: IFTRUE 77930
77928: GO 80553
77930: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77931: LD_ADDR_VAR 0 11
77935: PUSH
77936: LD_INT 1
77938: NEG
77939: PUSH
77940: LD_INT 3
77942: NEG
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 0
77950: PUSH
77951: LD_INT 3
77953: NEG
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 1
77961: PUSH
77962: LD_INT 2
77964: NEG
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: LIST
77974: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77975: LD_ADDR_VAR 0 12
77979: PUSH
77980: LD_INT 2
77982: PUSH
77983: LD_INT 1
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 3
77993: PUSH
77994: LD_INT 0
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 3
78003: PUSH
78004: LD_INT 1
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78016: LD_ADDR_VAR 0 13
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: LD_INT 2
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 3
78033: PUSH
78034: LD_INT 3
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 2
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: LIST
78055: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78056: LD_ADDR_VAR 0 14
78060: PUSH
78061: LD_INT 1
78063: PUSH
78064: LD_INT 3
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: LD_INT 3
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 1
78083: NEG
78084: PUSH
78085: LD_INT 2
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: LIST
78096: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78097: LD_ADDR_VAR 0 15
78101: PUSH
78102: LD_INT 2
78104: NEG
78105: PUSH
78106: LD_INT 1
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 3
78115: NEG
78116: PUSH
78117: LD_INT 0
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: LD_INT 1
78130: NEG
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: LIST
78140: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78141: LD_ADDR_VAR 0 16
78145: PUSH
78146: LD_INT 2
78148: NEG
78149: PUSH
78150: LD_INT 3
78152: NEG
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 3
78160: NEG
78161: PUSH
78162: LD_INT 2
78164: NEG
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 3
78172: NEG
78173: PUSH
78174: LD_INT 3
78176: NEG
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: LIST
78186: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78187: LD_ADDR_VAR 0 17
78191: PUSH
78192: LD_INT 1
78194: NEG
78195: PUSH
78196: LD_INT 3
78198: NEG
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 0
78206: PUSH
78207: LD_INT 3
78209: NEG
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 1
78217: PUSH
78218: LD_INT 2
78220: NEG
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: LIST
78230: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78231: LD_ADDR_VAR 0 18
78235: PUSH
78236: LD_INT 2
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 3
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 3
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: LIST
78271: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78272: LD_ADDR_VAR 0 19
78276: PUSH
78277: LD_INT 3
78279: PUSH
78280: LD_INT 2
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 3
78289: PUSH
78290: LD_INT 3
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 2
78299: PUSH
78300: LD_INT 3
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: LIST
78311: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78312: LD_ADDR_VAR 0 20
78316: PUSH
78317: LD_INT 1
78319: PUSH
78320: LD_INT 3
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 0
78329: PUSH
78330: LD_INT 3
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 1
78339: NEG
78340: PUSH
78341: LD_INT 2
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: LIST
78352: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78353: LD_ADDR_VAR 0 21
78357: PUSH
78358: LD_INT 2
78360: NEG
78361: PUSH
78362: LD_INT 1
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 3
78371: NEG
78372: PUSH
78373: LD_INT 0
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 3
78382: NEG
78383: PUSH
78384: LD_INT 1
78386: NEG
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: LIST
78396: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78397: LD_ADDR_VAR 0 22
78401: PUSH
78402: LD_INT 2
78404: NEG
78405: PUSH
78406: LD_INT 3
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 3
78416: NEG
78417: PUSH
78418: LD_INT 2
78420: NEG
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: NEG
78429: PUSH
78430: LD_INT 3
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: LIST
78442: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78443: LD_ADDR_VAR 0 23
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: LD_INT 3
78453: NEG
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: PUSH
78459: LD_INT 1
78461: NEG
78462: PUSH
78463: LD_INT 4
78465: NEG
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 1
78473: PUSH
78474: LD_INT 3
78476: NEG
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: LIST
78486: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78487: LD_ADDR_VAR 0 24
78491: PUSH
78492: LD_INT 3
78494: PUSH
78495: LD_INT 0
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 3
78504: PUSH
78505: LD_INT 1
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 4
78515: PUSH
78516: LD_INT 1
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: LIST
78527: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78528: LD_ADDR_VAR 0 25
78532: PUSH
78533: LD_INT 3
78535: PUSH
78536: LD_INT 3
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 4
78545: PUSH
78546: LD_INT 3
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 3
78555: PUSH
78556: LD_INT 4
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: LIST
78567: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78568: LD_ADDR_VAR 0 26
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: LD_INT 3
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: PUSH
78586: LD_INT 4
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 1
78595: NEG
78596: PUSH
78597: LD_INT 3
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: LIST
78608: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78609: LD_ADDR_VAR 0 27
78613: PUSH
78614: LD_INT 3
78616: NEG
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 3
78627: NEG
78628: PUSH
78629: LD_INT 1
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 4
78638: NEG
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: LIST
78652: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78653: LD_ADDR_VAR 0 28
78657: PUSH
78658: LD_INT 3
78660: NEG
78661: PUSH
78662: LD_INT 3
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 3
78672: NEG
78673: PUSH
78674: LD_INT 4
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 4
78684: NEG
78685: PUSH
78686: LD_INT 3
78688: NEG
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: LIST
78698: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78699: LD_ADDR_VAR 0 29
78703: PUSH
78704: LD_INT 1
78706: NEG
78707: PUSH
78708: LD_INT 3
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 0
78718: PUSH
78719: LD_INT 3
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 1
78729: PUSH
78730: LD_INT 2
78732: NEG
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 1
78740: NEG
78741: PUSH
78742: LD_INT 4
78744: NEG
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 4
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: LD_INT 3
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 1
78774: NEG
78775: PUSH
78776: LD_INT 5
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 0
78786: PUSH
78787: LD_INT 5
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 1
78797: PUSH
78798: LD_INT 4
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: LD_INT 6
78812: NEG
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: LD_INT 6
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 1
78831: PUSH
78832: LD_INT 5
78834: NEG
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78854: LD_ADDR_VAR 0 30
78858: PUSH
78859: LD_INT 2
78861: PUSH
78862: LD_INT 1
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 3
78872: PUSH
78873: LD_INT 0
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 3
78882: PUSH
78883: LD_INT 1
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 3
78892: PUSH
78893: LD_INT 1
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 4
78903: PUSH
78904: LD_INT 0
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 4
78913: PUSH
78914: LD_INT 1
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 4
78923: PUSH
78924: LD_INT 1
78926: NEG
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 5
78934: PUSH
78935: LD_INT 0
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 5
78944: PUSH
78945: LD_INT 1
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 5
78954: PUSH
78955: LD_INT 1
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 6
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 6
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78997: LD_ADDR_VAR 0 31
79001: PUSH
79002: LD_INT 3
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 3
79014: PUSH
79015: LD_INT 3
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 2
79024: PUSH
79025: LD_INT 3
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 4
79034: PUSH
79035: LD_INT 3
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 4
79044: PUSH
79045: LD_INT 4
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 3
79054: PUSH
79055: LD_INT 4
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 5
79064: PUSH
79065: LD_INT 4
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 5
79074: PUSH
79075: LD_INT 5
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 4
79084: PUSH
79085: LD_INT 5
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 6
79094: PUSH
79095: LD_INT 5
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 6
79104: PUSH
79105: LD_INT 6
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 5
79114: PUSH
79115: LD_INT 6
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79136: LD_ADDR_VAR 0 32
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: LD_INT 3
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 0
79153: PUSH
79154: LD_INT 3
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 1
79163: NEG
79164: PUSH
79165: LD_INT 2
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 1
79174: PUSH
79175: LD_INT 4
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 0
79184: PUSH
79185: LD_INT 4
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 1
79194: NEG
79195: PUSH
79196: LD_INT 3
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: PUSH
79206: LD_INT 5
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 0
79215: PUSH
79216: LD_INT 5
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 1
79225: NEG
79226: PUSH
79227: LD_INT 4
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 1
79236: PUSH
79237: LD_INT 6
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 0
79246: PUSH
79247: LD_INT 6
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 1
79256: NEG
79257: PUSH
79258: LD_INT 5
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79279: LD_ADDR_VAR 0 33
79283: PUSH
79284: LD_INT 2
79286: NEG
79287: PUSH
79288: LD_INT 1
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 3
79297: NEG
79298: PUSH
79299: LD_INT 0
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 3
79308: NEG
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 3
79320: NEG
79321: PUSH
79322: LD_INT 1
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 4
79331: NEG
79332: PUSH
79333: LD_INT 0
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 4
79342: NEG
79343: PUSH
79344: LD_INT 1
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 4
79354: NEG
79355: PUSH
79356: LD_INT 1
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 5
79365: NEG
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 5
79376: NEG
79377: PUSH
79378: LD_INT 1
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 5
79388: NEG
79389: PUSH
79390: LD_INT 1
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 6
79399: NEG
79400: PUSH
79401: LD_INT 0
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 6
79410: NEG
79411: PUSH
79412: LD_INT 1
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79434: LD_ADDR_VAR 0 34
79438: PUSH
79439: LD_INT 2
79441: NEG
79442: PUSH
79443: LD_INT 3
79445: NEG
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 3
79453: NEG
79454: PUSH
79455: LD_INT 2
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 3
79465: NEG
79466: PUSH
79467: LD_INT 3
79469: NEG
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 3
79477: NEG
79478: PUSH
79479: LD_INT 4
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 4
79489: NEG
79490: PUSH
79491: LD_INT 3
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 4
79501: NEG
79502: PUSH
79503: LD_INT 4
79505: NEG
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 4
79513: NEG
79514: PUSH
79515: LD_INT 5
79517: NEG
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 5
79525: NEG
79526: PUSH
79527: LD_INT 4
79529: NEG
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 5
79537: NEG
79538: PUSH
79539: LD_INT 5
79541: NEG
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 5
79549: NEG
79550: PUSH
79551: LD_INT 6
79553: NEG
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 6
79561: NEG
79562: PUSH
79563: LD_INT 5
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 6
79573: NEG
79574: PUSH
79575: LD_INT 6
79577: NEG
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79597: LD_ADDR_VAR 0 41
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: LD_INT 2
79607: NEG
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 1
79615: NEG
79616: PUSH
79617: LD_INT 3
79619: NEG
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 1
79627: PUSH
79628: LD_INT 2
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: LIST
79640: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79641: LD_ADDR_VAR 0 42
79645: PUSH
79646: LD_INT 2
79648: PUSH
79649: LD_INT 0
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 2
79658: PUSH
79659: LD_INT 1
79661: NEG
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 3
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: LIST
79681: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79682: LD_ADDR_VAR 0 43
79686: PUSH
79687: LD_INT 2
79689: PUSH
79690: LD_INT 2
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 3
79699: PUSH
79700: LD_INT 2
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 2
79709: PUSH
79710: LD_INT 3
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: LIST
79721: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79722: LD_ADDR_VAR 0 44
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: LD_INT 2
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 1
79739: PUSH
79740: LD_INT 3
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 1
79749: NEG
79750: PUSH
79751: LD_INT 2
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: LIST
79762: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79763: LD_ADDR_VAR 0 45
79767: PUSH
79768: LD_INT 2
79770: NEG
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 2
79781: NEG
79782: PUSH
79783: LD_INT 1
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 3
79792: NEG
79793: PUSH
79794: LD_INT 1
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: LIST
79806: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79807: LD_ADDR_VAR 0 46
79811: PUSH
79812: LD_INT 2
79814: NEG
79815: PUSH
79816: LD_INT 2
79818: NEG
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 2
79826: NEG
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 3
79838: NEG
79839: PUSH
79840: LD_INT 2
79842: NEG
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: LIST
79852: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79853: LD_ADDR_VAR 0 47
79857: PUSH
79858: LD_INT 2
79860: NEG
79861: PUSH
79862: LD_INT 3
79864: NEG
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 1
79872: NEG
79873: PUSH
79874: LD_INT 3
79876: NEG
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79886: LD_ADDR_VAR 0 48
79890: PUSH
79891: LD_INT 1
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 2
79904: PUSH
79905: LD_INT 1
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79917: LD_ADDR_VAR 0 49
79921: PUSH
79922: LD_INT 3
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 3
79934: PUSH
79935: LD_INT 2
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79946: LD_ADDR_VAR 0 50
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: LD_INT 3
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 1
79963: PUSH
79964: LD_INT 3
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79975: LD_ADDR_VAR 0 51
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 2
79993: NEG
79994: PUSH
79995: LD_INT 1
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80006: LD_ADDR_VAR 0 52
80010: PUSH
80011: LD_INT 3
80013: NEG
80014: PUSH
80015: LD_INT 1
80017: NEG
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 3
80025: NEG
80026: PUSH
80027: LD_INT 2
80029: NEG
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80039: LD_ADDR_VAR 0 53
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: LD_INT 3
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: LD_INT 3
80061: NEG
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 2
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: LIST
80082: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80083: LD_ADDR_VAR 0 54
80087: PUSH
80088: LD_INT 2
80090: PUSH
80091: LD_INT 1
80093: NEG
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: PUSH
80099: LD_INT 3
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 3
80111: PUSH
80112: LD_INT 1
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: LIST
80123: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80124: LD_ADDR_VAR 0 55
80128: PUSH
80129: LD_INT 3
80131: PUSH
80132: LD_INT 2
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 3
80141: PUSH
80142: LD_INT 3
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 2
80151: PUSH
80152: LD_INT 3
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: LIST
80163: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80164: LD_ADDR_VAR 0 56
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: LD_INT 3
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: LD_INT 3
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 1
80191: NEG
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: LIST
80204: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80205: LD_ADDR_VAR 0 57
80209: PUSH
80210: LD_INT 2
80212: NEG
80213: PUSH
80214: LD_INT 1
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 3
80223: NEG
80224: PUSH
80225: LD_INT 0
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 3
80234: NEG
80235: PUSH
80236: LD_INT 1
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: LIST
80248: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80249: LD_ADDR_VAR 0 58
80253: PUSH
80254: LD_INT 2
80256: NEG
80257: PUSH
80258: LD_INT 3
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 3
80268: NEG
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 3
80280: NEG
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: LIST
80294: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80295: LD_ADDR_VAR 0 59
80299: PUSH
80300: LD_INT 1
80302: NEG
80303: PUSH
80304: LD_INT 2
80306: NEG
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 0
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 1
80328: NEG
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: LIST
80338: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80339: LD_ADDR_VAR 0 60
80343: PUSH
80344: LD_INT 1
80346: PUSH
80347: LD_INT 1
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 2
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: LD_INT 2
80367: PUSH
80368: LD_INT 1
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: LIST
80379: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80380: LD_ADDR_VAR 0 61
80384: PUSH
80385: LD_INT 2
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 2
80397: PUSH
80398: LD_INT 2
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: LD_INT 2
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: LIST
80419: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80420: LD_ADDR_VAR 0 62
80424: PUSH
80425: LD_INT 1
80427: PUSH
80428: LD_INT 2
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 0
80437: PUSH
80438: LD_INT 2
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 1
80447: NEG
80448: PUSH
80449: LD_INT 1
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: LIST
80460: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80461: LD_ADDR_VAR 0 63
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: LD_INT 1
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 2
80490: NEG
80491: PUSH
80492: LD_INT 1
80494: NEG
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: LIST
80504: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80505: LD_ADDR_VAR 0 64
80509: PUSH
80510: LD_INT 1
80512: NEG
80513: PUSH
80514: LD_INT 2
80516: NEG
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 2
80524: NEG
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 2
80536: NEG
80537: PUSH
80538: LD_INT 2
80540: NEG
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: LIST
80550: ST_TO_ADDR
// end ; 2 :
80551: GO 83817
80553: LD_INT 2
80555: DOUBLE
80556: EQUAL
80557: IFTRUE 80561
80559: GO 83816
80561: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80562: LD_ADDR_VAR 0 29
80566: PUSH
80567: LD_INT 4
80569: PUSH
80570: LD_INT 0
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 4
80579: PUSH
80580: LD_INT 1
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 5
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 5
80600: PUSH
80601: LD_INT 1
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 4
80610: PUSH
80611: LD_INT 1
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 3
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 3
80630: PUSH
80631: LD_INT 1
80633: NEG
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 3
80641: PUSH
80642: LD_INT 2
80644: NEG
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 5
80652: PUSH
80653: LD_INT 2
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 3
80662: PUSH
80663: LD_INT 3
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 3
80672: PUSH
80673: LD_INT 2
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 4
80682: PUSH
80683: LD_INT 3
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 4
80692: PUSH
80693: LD_INT 4
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 3
80702: PUSH
80703: LD_INT 4
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 2
80712: PUSH
80713: LD_INT 3
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 2
80722: PUSH
80723: LD_INT 2
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 4
80732: PUSH
80733: LD_INT 2
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 2
80742: PUSH
80743: LD_INT 4
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 0
80752: PUSH
80753: LD_INT 4
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: LD_INT 3
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 1
80772: PUSH
80773: LD_INT 4
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 5
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: LD_INT 5
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: LD_INT 4
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: LD_INT 3
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: LD_INT 5
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 2
80834: NEG
80835: PUSH
80836: LD_INT 3
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 3
80845: NEG
80846: PUSH
80847: LD_INT 0
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 3
80856: NEG
80857: PUSH
80858: LD_INT 1
80860: NEG
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 2
80879: NEG
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 3
80890: NEG
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 4
80901: NEG
80902: PUSH
80903: LD_INT 0
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 4
80912: NEG
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 4
80924: NEG
80925: PUSH
80926: LD_INT 2
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 2
80936: NEG
80937: PUSH
80938: LD_INT 2
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 4
80947: NEG
80948: PUSH
80949: LD_INT 4
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 4
80959: NEG
80960: PUSH
80961: LD_INT 5
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: NEG
80972: PUSH
80973: LD_INT 4
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 3
80983: NEG
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 4
80995: NEG
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 5
81007: NEG
81008: PUSH
81009: LD_INT 4
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 5
81019: NEG
81020: PUSH
81021: LD_INT 5
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 3
81031: NEG
81032: PUSH
81033: LD_INT 5
81035: NEG
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 5
81043: NEG
81044: PUSH
81045: LD_INT 3
81047: NEG
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81100: LD_ADDR_VAR 0 30
81104: PUSH
81105: LD_INT 4
81107: PUSH
81108: LD_INT 4
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 4
81117: PUSH
81118: LD_INT 3
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 5
81127: PUSH
81128: LD_INT 4
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 5
81137: PUSH
81138: LD_INT 5
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 4
81147: PUSH
81148: LD_INT 5
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 3
81157: PUSH
81158: LD_INT 4
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 3
81167: PUSH
81168: LD_INT 3
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 5
81177: PUSH
81178: LD_INT 3
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 3
81187: PUSH
81188: LD_INT 5
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 0
81197: PUSH
81198: LD_INT 3
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 2
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: PUSH
81218: LD_INT 3
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: PUSH
81228: LD_INT 4
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 0
81237: PUSH
81238: LD_INT 4
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 1
81247: NEG
81248: PUSH
81249: LD_INT 3
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: LD_INT 2
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 2
81269: PUSH
81270: LD_INT 4
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 2
81279: NEG
81280: PUSH
81281: LD_INT 2
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 4
81290: NEG
81291: PUSH
81292: LD_INT 0
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 4
81301: NEG
81302: PUSH
81303: LD_INT 1
81305: NEG
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 3
81313: NEG
81314: PUSH
81315: LD_INT 0
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 3
81324: NEG
81325: PUSH
81326: LD_INT 1
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 4
81335: NEG
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 5
81346: NEG
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 5
81357: NEG
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 5
81369: NEG
81370: PUSH
81371: LD_INT 2
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 3
81381: NEG
81382: PUSH
81383: LD_INT 2
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 3
81392: NEG
81393: PUSH
81394: LD_INT 3
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 3
81404: NEG
81405: PUSH
81406: LD_INT 4
81408: NEG
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 2
81416: NEG
81417: PUSH
81418: LD_INT 3
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 2
81428: NEG
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 3
81440: NEG
81441: PUSH
81442: LD_INT 2
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 4
81452: NEG
81453: PUSH
81454: LD_INT 3
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 4
81464: NEG
81465: PUSH
81466: LD_INT 4
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: NEG
81477: PUSH
81478: LD_INT 4
81480: NEG
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 4
81488: NEG
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 0
81500: PUSH
81501: LD_INT 4
81503: NEG
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 5
81514: NEG
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: PUSH
81523: LD_INT 4
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 3
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: LD_INT 3
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: NEG
81556: PUSH
81557: LD_INT 4
81559: NEG
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 1
81567: NEG
81568: PUSH
81569: LD_INT 5
81571: NEG
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: PUSH
81580: LD_INT 3
81582: NEG
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 2
81590: NEG
81591: PUSH
81592: LD_INT 5
81594: NEG
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81647: LD_ADDR_VAR 0 31
81651: PUSH
81652: LD_INT 0
81654: PUSH
81655: LD_INT 4
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: LD_INT 3
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 1
81674: PUSH
81675: LD_INT 4
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 1
81684: PUSH
81685: LD_INT 5
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 0
81694: PUSH
81695: LD_INT 5
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 1
81704: NEG
81705: PUSH
81706: LD_INT 4
81708: PUSH
81709: EMPTY
81710: LIST
81711: LIST
81712: PUSH
81713: LD_INT 1
81715: NEG
81716: PUSH
81717: LD_INT 3
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: LD_INT 2
81726: PUSH
81727: LD_INT 5
81729: PUSH
81730: EMPTY
81731: LIST
81732: LIST
81733: PUSH
81734: LD_INT 2
81736: NEG
81737: PUSH
81738: LD_INT 3
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 3
81747: NEG
81748: PUSH
81749: LD_INT 0
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 3
81758: NEG
81759: PUSH
81760: LD_INT 1
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 2
81770: NEG
81771: PUSH
81772: LD_INT 0
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 2
81781: NEG
81782: PUSH
81783: LD_INT 1
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 3
81792: NEG
81793: PUSH
81794: LD_INT 1
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 4
81803: NEG
81804: PUSH
81805: LD_INT 0
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 4
81814: NEG
81815: PUSH
81816: LD_INT 1
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 4
81826: NEG
81827: PUSH
81828: LD_INT 2
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 2
81838: NEG
81839: PUSH
81840: LD_INT 2
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 4
81849: NEG
81850: PUSH
81851: LD_INT 4
81853: NEG
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 4
81861: NEG
81862: PUSH
81863: LD_INT 5
81865: NEG
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 3
81873: NEG
81874: PUSH
81875: LD_INT 4
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 3
81885: NEG
81886: PUSH
81887: LD_INT 3
81889: NEG
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 4
81897: NEG
81898: PUSH
81899: LD_INT 3
81901: NEG
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 5
81909: NEG
81910: PUSH
81911: LD_INT 4
81913: NEG
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 5
81921: NEG
81922: PUSH
81923: LD_INT 5
81925: NEG
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 3
81933: NEG
81934: PUSH
81935: LD_INT 5
81937: NEG
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 5
81945: NEG
81946: PUSH
81947: LD_INT 3
81949: NEG
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 0
81957: PUSH
81958: LD_INT 3
81960: NEG
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 0
81968: PUSH
81969: LD_INT 4
81971: NEG
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 1
81979: PUSH
81980: LD_INT 3
81982: NEG
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: LD_INT 2
82004: NEG
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: LD_INT 3
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 1
82024: NEG
82025: PUSH
82026: LD_INT 4
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 2
82036: PUSH
82037: LD_INT 2
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 2
82047: NEG
82048: PUSH
82049: LD_INT 4
82051: NEG
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 4
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 4
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 5
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 5
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 4
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 3
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 3
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 3
82131: PUSH
82132: LD_INT 2
82134: NEG
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 5
82142: PUSH
82143: LD_INT 2
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82197: LD_ADDR_VAR 0 32
82201: PUSH
82202: LD_INT 4
82204: NEG
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 4
82215: NEG
82216: PUSH
82217: LD_INT 1
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 3
82227: NEG
82228: PUSH
82229: LD_INT 0
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 3
82238: NEG
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 4
82249: NEG
82250: PUSH
82251: LD_INT 1
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 5
82260: NEG
82261: PUSH
82262: LD_INT 0
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 5
82271: NEG
82272: PUSH
82273: LD_INT 1
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 5
82283: NEG
82284: PUSH
82285: LD_INT 2
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 3
82295: NEG
82296: PUSH
82297: LD_INT 2
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 3
82306: NEG
82307: PUSH
82308: LD_INT 3
82310: NEG
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 3
82318: NEG
82319: PUSH
82320: LD_INT 4
82322: NEG
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 2
82330: NEG
82331: PUSH
82332: LD_INT 3
82334: NEG
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 2
82342: NEG
82343: PUSH
82344: LD_INT 2
82346: NEG
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 3
82354: NEG
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 4
82366: NEG
82367: PUSH
82368: LD_INT 3
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 4
82378: NEG
82379: PUSH
82380: LD_INT 4
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 2
82390: NEG
82391: PUSH
82392: LD_INT 4
82394: NEG
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 4
82402: NEG
82403: PUSH
82404: LD_INT 2
82406: NEG
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 0
82414: PUSH
82415: LD_INT 4
82417: NEG
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: LD_INT 5
82428: NEG
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 4
82439: NEG
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 1
82447: PUSH
82448: LD_INT 3
82450: NEG
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 0
82458: PUSH
82459: LD_INT 3
82461: NEG
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 1
82469: NEG
82470: PUSH
82471: LD_INT 4
82473: NEG
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 1
82481: NEG
82482: PUSH
82483: LD_INT 5
82485: NEG
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 2
82493: PUSH
82494: LD_INT 3
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 2
82504: NEG
82505: PUSH
82506: LD_INT 5
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 3
82516: PUSH
82517: LD_INT 0
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 3
82526: PUSH
82527: LD_INT 1
82529: NEG
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 4
82537: PUSH
82538: LD_INT 0
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 4
82547: PUSH
82548: LD_INT 1
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 3
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: PUSH
82568: LD_INT 0
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 2
82588: PUSH
82589: LD_INT 2
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 4
82599: PUSH
82600: LD_INT 2
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 4
82609: PUSH
82610: LD_INT 4
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 4
82619: PUSH
82620: LD_INT 3
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 5
82629: PUSH
82630: LD_INT 4
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 5
82639: PUSH
82640: LD_INT 5
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 4
82649: PUSH
82650: LD_INT 5
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 3
82659: PUSH
82660: LD_INT 4
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 3
82669: PUSH
82670: LD_INT 3
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 5
82679: PUSH
82680: LD_INT 3
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 3
82689: PUSH
82690: LD_INT 5
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82744: LD_ADDR_VAR 0 33
82748: PUSH
82749: LD_INT 4
82751: NEG
82752: PUSH
82753: LD_INT 4
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 4
82763: NEG
82764: PUSH
82765: LD_INT 5
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 3
82775: NEG
82776: PUSH
82777: LD_INT 4
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 3
82787: NEG
82788: PUSH
82789: LD_INT 3
82791: NEG
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 4
82799: NEG
82800: PUSH
82801: LD_INT 3
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 5
82811: NEG
82812: PUSH
82813: LD_INT 4
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 5
82823: NEG
82824: PUSH
82825: LD_INT 5
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 3
82835: NEG
82836: PUSH
82837: LD_INT 5
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 5
82847: NEG
82848: PUSH
82849: LD_INT 3
82851: NEG
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 0
82859: PUSH
82860: LD_INT 3
82862: NEG
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 0
82870: PUSH
82871: LD_INT 4
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: PUSH
82882: LD_INT 3
82884: NEG
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 1
82892: PUSH
82893: LD_INT 2
82895: NEG
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: LD_INT 2
82906: NEG
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 1
82914: NEG
82915: PUSH
82916: LD_INT 3
82918: NEG
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 1
82926: NEG
82927: PUSH
82928: LD_INT 4
82930: NEG
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 2
82938: PUSH
82939: LD_INT 2
82941: NEG
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 2
82949: NEG
82950: PUSH
82951: LD_INT 4
82953: NEG
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 4
82961: PUSH
82962: LD_INT 0
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 4
82971: PUSH
82972: LD_INT 1
82974: NEG
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 5
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 5
82992: PUSH
82993: LD_INT 1
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 4
83002: PUSH
83003: LD_INT 1
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 3
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 3
83022: PUSH
83023: LD_INT 1
83025: NEG
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 3
83033: PUSH
83034: LD_INT 2
83036: NEG
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 5
83044: PUSH
83045: LD_INT 2
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 3
83054: PUSH
83055: LD_INT 3
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 3
83064: PUSH
83065: LD_INT 2
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 4
83074: PUSH
83075: LD_INT 3
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 4
83084: PUSH
83085: LD_INT 4
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: PUSH
83095: LD_INT 4
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 2
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: LD_INT 2
83114: PUSH
83115: LD_INT 2
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 4
83124: PUSH
83125: LD_INT 2
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: LD_INT 4
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: PUSH
83142: LD_INT 0
83144: PUSH
83145: LD_INT 4
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 0
83154: PUSH
83155: LD_INT 3
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: LD_INT 4
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 1
83174: PUSH
83175: LD_INT 5
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 0
83184: PUSH
83185: LD_INT 5
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 1
83194: NEG
83195: PUSH
83196: LD_INT 4
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: LD_INT 3
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: LD_INT 5
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 2
83226: NEG
83227: PUSH
83228: LD_INT 3
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83282: LD_ADDR_VAR 0 34
83286: PUSH
83287: LD_INT 0
83289: PUSH
83290: LD_INT 4
83292: NEG
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: LD_INT 5
83303: NEG
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 1
83311: PUSH
83312: LD_INT 4
83314: NEG
83315: PUSH
83316: EMPTY
83317: LIST
83318: LIST
83319: PUSH
83320: LD_INT 1
83322: PUSH
83323: LD_INT 3
83325: NEG
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 0
83333: PUSH
83334: LD_INT 3
83336: NEG
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: LD_INT 4
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: LD_INT 5
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 3
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 2
83379: NEG
83380: PUSH
83381: LD_INT 5
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 3
83391: PUSH
83392: LD_INT 0
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 3
83401: PUSH
83402: LD_INT 1
83404: NEG
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 4
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 4
83422: PUSH
83423: LD_INT 1
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 3
83432: PUSH
83433: LD_INT 1
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 2
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 2
83452: PUSH
83453: LD_INT 1
83455: NEG
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 2
83463: PUSH
83464: LD_INT 2
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 4
83474: PUSH
83475: LD_INT 2
83477: PUSH
83478: EMPTY
83479: LIST
83480: LIST
83481: PUSH
83482: LD_INT 4
83484: PUSH
83485: LD_INT 4
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 4
83494: PUSH
83495: LD_INT 3
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 5
83504: PUSH
83505: LD_INT 4
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 5
83514: PUSH
83515: LD_INT 5
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 4
83524: PUSH
83525: LD_INT 5
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 3
83534: PUSH
83535: LD_INT 4
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 3
83544: PUSH
83545: LD_INT 3
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 5
83554: PUSH
83555: LD_INT 3
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 3
83564: PUSH
83565: LD_INT 5
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: LD_INT 3
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: LD_INT 2
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 1
83594: PUSH
83595: LD_INT 3
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: LD_INT 4
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 0
83614: PUSH
83615: LD_INT 4
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 1
83624: NEG
83625: PUSH
83626: LD_INT 3
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: LD_INT 1
83635: NEG
83636: PUSH
83637: LD_INT 2
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 2
83646: PUSH
83647: LD_INT 4
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 2
83656: NEG
83657: PUSH
83658: LD_INT 2
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 4
83667: NEG
83668: PUSH
83669: LD_INT 0
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 4
83678: NEG
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 3
83690: NEG
83691: PUSH
83692: LD_INT 0
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 3
83701: NEG
83702: PUSH
83703: LD_INT 1
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 4
83712: NEG
83713: PUSH
83714: LD_INT 1
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 5
83723: NEG
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 5
83734: NEG
83735: PUSH
83736: LD_INT 1
83738: NEG
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: LD_INT 5
83746: NEG
83747: PUSH
83748: LD_INT 2
83750: NEG
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 3
83758: NEG
83759: PUSH
83760: LD_INT 2
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: ST_TO_ADDR
// end ; end ;
83814: GO 83817
83816: POP
// case btype of b_depot , b_warehouse :
83817: LD_VAR 0 1
83821: PUSH
83822: LD_INT 0
83824: DOUBLE
83825: EQUAL
83826: IFTRUE 83836
83828: LD_INT 1
83830: DOUBLE
83831: EQUAL
83832: IFTRUE 83836
83834: GO 84037
83836: POP
// case nation of nation_american :
83837: LD_VAR 0 5
83841: PUSH
83842: LD_INT 1
83844: DOUBLE
83845: EQUAL
83846: IFTRUE 83850
83848: GO 83906
83850: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83851: LD_ADDR_VAR 0 9
83855: PUSH
83856: LD_VAR 0 11
83860: PUSH
83861: LD_VAR 0 12
83865: PUSH
83866: LD_VAR 0 13
83870: PUSH
83871: LD_VAR 0 14
83875: PUSH
83876: LD_VAR 0 15
83880: PUSH
83881: LD_VAR 0 16
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: PUSH
83894: LD_VAR 0 4
83898: PUSH
83899: LD_INT 1
83901: PLUS
83902: ARRAY
83903: ST_TO_ADDR
83904: GO 84035
83906: LD_INT 2
83908: DOUBLE
83909: EQUAL
83910: IFTRUE 83914
83912: GO 83970
83914: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83915: LD_ADDR_VAR 0 9
83919: PUSH
83920: LD_VAR 0 17
83924: PUSH
83925: LD_VAR 0 18
83929: PUSH
83930: LD_VAR 0 19
83934: PUSH
83935: LD_VAR 0 20
83939: PUSH
83940: LD_VAR 0 21
83944: PUSH
83945: LD_VAR 0 22
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: PUSH
83958: LD_VAR 0 4
83962: PUSH
83963: LD_INT 1
83965: PLUS
83966: ARRAY
83967: ST_TO_ADDR
83968: GO 84035
83970: LD_INT 3
83972: DOUBLE
83973: EQUAL
83974: IFTRUE 83978
83976: GO 84034
83978: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83979: LD_ADDR_VAR 0 9
83983: PUSH
83984: LD_VAR 0 23
83988: PUSH
83989: LD_VAR 0 24
83993: PUSH
83994: LD_VAR 0 25
83998: PUSH
83999: LD_VAR 0 26
84003: PUSH
84004: LD_VAR 0 27
84008: PUSH
84009: LD_VAR 0 28
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: PUSH
84022: LD_VAR 0 4
84026: PUSH
84027: LD_INT 1
84029: PLUS
84030: ARRAY
84031: ST_TO_ADDR
84032: GO 84035
84034: POP
84035: GO 84590
84037: LD_INT 2
84039: DOUBLE
84040: EQUAL
84041: IFTRUE 84051
84043: LD_INT 3
84045: DOUBLE
84046: EQUAL
84047: IFTRUE 84051
84049: GO 84107
84051: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84052: LD_ADDR_VAR 0 9
84056: PUSH
84057: LD_VAR 0 29
84061: PUSH
84062: LD_VAR 0 30
84066: PUSH
84067: LD_VAR 0 31
84071: PUSH
84072: LD_VAR 0 32
84076: PUSH
84077: LD_VAR 0 33
84081: PUSH
84082: LD_VAR 0 34
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: PUSH
84095: LD_VAR 0 4
84099: PUSH
84100: LD_INT 1
84102: PLUS
84103: ARRAY
84104: ST_TO_ADDR
84105: GO 84590
84107: LD_INT 16
84109: DOUBLE
84110: EQUAL
84111: IFTRUE 84169
84113: LD_INT 17
84115: DOUBLE
84116: EQUAL
84117: IFTRUE 84169
84119: LD_INT 18
84121: DOUBLE
84122: EQUAL
84123: IFTRUE 84169
84125: LD_INT 19
84127: DOUBLE
84128: EQUAL
84129: IFTRUE 84169
84131: LD_INT 22
84133: DOUBLE
84134: EQUAL
84135: IFTRUE 84169
84137: LD_INT 20
84139: DOUBLE
84140: EQUAL
84141: IFTRUE 84169
84143: LD_INT 21
84145: DOUBLE
84146: EQUAL
84147: IFTRUE 84169
84149: LD_INT 23
84151: DOUBLE
84152: EQUAL
84153: IFTRUE 84169
84155: LD_INT 24
84157: DOUBLE
84158: EQUAL
84159: IFTRUE 84169
84161: LD_INT 25
84163: DOUBLE
84164: EQUAL
84165: IFTRUE 84169
84167: GO 84225
84169: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84170: LD_ADDR_VAR 0 9
84174: PUSH
84175: LD_VAR 0 35
84179: PUSH
84180: LD_VAR 0 36
84184: PUSH
84185: LD_VAR 0 37
84189: PUSH
84190: LD_VAR 0 38
84194: PUSH
84195: LD_VAR 0 39
84199: PUSH
84200: LD_VAR 0 40
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: PUSH
84213: LD_VAR 0 4
84217: PUSH
84218: LD_INT 1
84220: PLUS
84221: ARRAY
84222: ST_TO_ADDR
84223: GO 84590
84225: LD_INT 6
84227: DOUBLE
84228: EQUAL
84229: IFTRUE 84281
84231: LD_INT 7
84233: DOUBLE
84234: EQUAL
84235: IFTRUE 84281
84237: LD_INT 8
84239: DOUBLE
84240: EQUAL
84241: IFTRUE 84281
84243: LD_INT 13
84245: DOUBLE
84246: EQUAL
84247: IFTRUE 84281
84249: LD_INT 12
84251: DOUBLE
84252: EQUAL
84253: IFTRUE 84281
84255: LD_INT 15
84257: DOUBLE
84258: EQUAL
84259: IFTRUE 84281
84261: LD_INT 11
84263: DOUBLE
84264: EQUAL
84265: IFTRUE 84281
84267: LD_INT 14
84269: DOUBLE
84270: EQUAL
84271: IFTRUE 84281
84273: LD_INT 10
84275: DOUBLE
84276: EQUAL
84277: IFTRUE 84281
84279: GO 84337
84281: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84282: LD_ADDR_VAR 0 9
84286: PUSH
84287: LD_VAR 0 41
84291: PUSH
84292: LD_VAR 0 42
84296: PUSH
84297: LD_VAR 0 43
84301: PUSH
84302: LD_VAR 0 44
84306: PUSH
84307: LD_VAR 0 45
84311: PUSH
84312: LD_VAR 0 46
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: PUSH
84325: LD_VAR 0 4
84329: PUSH
84330: LD_INT 1
84332: PLUS
84333: ARRAY
84334: ST_TO_ADDR
84335: GO 84590
84337: LD_INT 36
84339: DOUBLE
84340: EQUAL
84341: IFTRUE 84345
84343: GO 84401
84345: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84346: LD_ADDR_VAR 0 9
84350: PUSH
84351: LD_VAR 0 47
84355: PUSH
84356: LD_VAR 0 48
84360: PUSH
84361: LD_VAR 0 49
84365: PUSH
84366: LD_VAR 0 50
84370: PUSH
84371: LD_VAR 0 51
84375: PUSH
84376: LD_VAR 0 52
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: PUSH
84389: LD_VAR 0 4
84393: PUSH
84394: LD_INT 1
84396: PLUS
84397: ARRAY
84398: ST_TO_ADDR
84399: GO 84590
84401: LD_INT 4
84403: DOUBLE
84404: EQUAL
84405: IFTRUE 84427
84407: LD_INT 5
84409: DOUBLE
84410: EQUAL
84411: IFTRUE 84427
84413: LD_INT 34
84415: DOUBLE
84416: EQUAL
84417: IFTRUE 84427
84419: LD_INT 37
84421: DOUBLE
84422: EQUAL
84423: IFTRUE 84427
84425: GO 84483
84427: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84428: LD_ADDR_VAR 0 9
84432: PUSH
84433: LD_VAR 0 53
84437: PUSH
84438: LD_VAR 0 54
84442: PUSH
84443: LD_VAR 0 55
84447: PUSH
84448: LD_VAR 0 56
84452: PUSH
84453: LD_VAR 0 57
84457: PUSH
84458: LD_VAR 0 58
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: PUSH
84471: LD_VAR 0 4
84475: PUSH
84476: LD_INT 1
84478: PLUS
84479: ARRAY
84480: ST_TO_ADDR
84481: GO 84590
84483: LD_INT 31
84485: DOUBLE
84486: EQUAL
84487: IFTRUE 84533
84489: LD_INT 32
84491: DOUBLE
84492: EQUAL
84493: IFTRUE 84533
84495: LD_INT 33
84497: DOUBLE
84498: EQUAL
84499: IFTRUE 84533
84501: LD_INT 27
84503: DOUBLE
84504: EQUAL
84505: IFTRUE 84533
84507: LD_INT 26
84509: DOUBLE
84510: EQUAL
84511: IFTRUE 84533
84513: LD_INT 28
84515: DOUBLE
84516: EQUAL
84517: IFTRUE 84533
84519: LD_INT 29
84521: DOUBLE
84522: EQUAL
84523: IFTRUE 84533
84525: LD_INT 30
84527: DOUBLE
84528: EQUAL
84529: IFTRUE 84533
84531: GO 84589
84533: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84534: LD_ADDR_VAR 0 9
84538: PUSH
84539: LD_VAR 0 59
84543: PUSH
84544: LD_VAR 0 60
84548: PUSH
84549: LD_VAR 0 61
84553: PUSH
84554: LD_VAR 0 62
84558: PUSH
84559: LD_VAR 0 63
84563: PUSH
84564: LD_VAR 0 64
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: PUSH
84577: LD_VAR 0 4
84581: PUSH
84582: LD_INT 1
84584: PLUS
84585: ARRAY
84586: ST_TO_ADDR
84587: GO 84590
84589: POP
// temp_list2 = [ ] ;
84590: LD_ADDR_VAR 0 10
84594: PUSH
84595: EMPTY
84596: ST_TO_ADDR
// for i in temp_list do
84597: LD_ADDR_VAR 0 8
84601: PUSH
84602: LD_VAR 0 9
84606: PUSH
84607: FOR_IN
84608: IFFALSE 84660
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84610: LD_ADDR_VAR 0 10
84614: PUSH
84615: LD_VAR 0 10
84619: PUSH
84620: LD_VAR 0 8
84624: PUSH
84625: LD_INT 1
84627: ARRAY
84628: PUSH
84629: LD_VAR 0 2
84633: PLUS
84634: PUSH
84635: LD_VAR 0 8
84639: PUSH
84640: LD_INT 2
84642: ARRAY
84643: PUSH
84644: LD_VAR 0 3
84648: PLUS
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: EMPTY
84655: LIST
84656: ADD
84657: ST_TO_ADDR
84658: GO 84607
84660: POP
84661: POP
// result = temp_list2 ;
84662: LD_ADDR_VAR 0 7
84666: PUSH
84667: LD_VAR 0 10
84671: ST_TO_ADDR
// end ;
84672: LD_VAR 0 7
84676: RET
// export function EnemyInRange ( unit , dist ) ; begin
84677: LD_INT 0
84679: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84680: LD_ADDR_VAR 0 3
84684: PUSH
84685: LD_VAR 0 1
84689: PPUSH
84690: CALL_OW 255
84694: PPUSH
84695: LD_VAR 0 1
84699: PPUSH
84700: CALL_OW 250
84704: PPUSH
84705: LD_VAR 0 1
84709: PPUSH
84710: CALL_OW 251
84714: PPUSH
84715: LD_VAR 0 2
84719: PPUSH
84720: CALL 58073 0 4
84724: PUSH
84725: LD_INT 4
84727: ARRAY
84728: ST_TO_ADDR
// end ;
84729: LD_VAR 0 3
84733: RET
// export function PlayerSeeMe ( unit ) ; begin
84734: LD_INT 0
84736: PPUSH
// result := See ( your_side , unit ) ;
84737: LD_ADDR_VAR 0 2
84741: PUSH
84742: LD_OWVAR 2
84746: PPUSH
84747: LD_VAR 0 1
84751: PPUSH
84752: CALL_OW 292
84756: ST_TO_ADDR
// end ;
84757: LD_VAR 0 2
84761: RET
// export function ReverseDir ( unit ) ; begin
84762: LD_INT 0
84764: PPUSH
// if not unit then
84765: LD_VAR 0 1
84769: NOT
84770: IFFALSE 84774
// exit ;
84772: GO 84797
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84774: LD_ADDR_VAR 0 2
84778: PUSH
84779: LD_VAR 0 1
84783: PPUSH
84784: CALL_OW 254
84788: PUSH
84789: LD_INT 3
84791: PLUS
84792: PUSH
84793: LD_INT 6
84795: MOD
84796: ST_TO_ADDR
// end ;
84797: LD_VAR 0 2
84801: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84802: LD_INT 0
84804: PPUSH
84805: PPUSH
84806: PPUSH
84807: PPUSH
84808: PPUSH
// if not hexes then
84809: LD_VAR 0 2
84813: NOT
84814: IFFALSE 84818
// exit ;
84816: GO 84966
// dist := 9999 ;
84818: LD_ADDR_VAR 0 5
84822: PUSH
84823: LD_INT 9999
84825: ST_TO_ADDR
// for i = 1 to hexes do
84826: LD_ADDR_VAR 0 4
84830: PUSH
84831: DOUBLE
84832: LD_INT 1
84834: DEC
84835: ST_TO_ADDR
84836: LD_VAR 0 2
84840: PUSH
84841: FOR_TO
84842: IFFALSE 84954
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84844: LD_VAR 0 1
84848: PPUSH
84849: LD_VAR 0 2
84853: PUSH
84854: LD_VAR 0 4
84858: ARRAY
84859: PUSH
84860: LD_INT 1
84862: ARRAY
84863: PPUSH
84864: LD_VAR 0 2
84868: PUSH
84869: LD_VAR 0 4
84873: ARRAY
84874: PUSH
84875: LD_INT 2
84877: ARRAY
84878: PPUSH
84879: CALL_OW 297
84883: PUSH
84884: LD_VAR 0 5
84888: LESS
84889: IFFALSE 84952
// begin hex := hexes [ i ] ;
84891: LD_ADDR_VAR 0 7
84895: PUSH
84896: LD_VAR 0 2
84900: PUSH
84901: LD_VAR 0 4
84905: ARRAY
84906: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84907: LD_ADDR_VAR 0 5
84911: PUSH
84912: LD_VAR 0 1
84916: PPUSH
84917: LD_VAR 0 2
84921: PUSH
84922: LD_VAR 0 4
84926: ARRAY
84927: PUSH
84928: LD_INT 1
84930: ARRAY
84931: PPUSH
84932: LD_VAR 0 2
84936: PUSH
84937: LD_VAR 0 4
84941: ARRAY
84942: PUSH
84943: LD_INT 2
84945: ARRAY
84946: PPUSH
84947: CALL_OW 297
84951: ST_TO_ADDR
// end ; end ;
84952: GO 84841
84954: POP
84955: POP
// result := hex ;
84956: LD_ADDR_VAR 0 3
84960: PUSH
84961: LD_VAR 0 7
84965: ST_TO_ADDR
// end ;
84966: LD_VAR 0 3
84970: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84971: LD_INT 0
84973: PPUSH
84974: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84975: LD_VAR 0 1
84979: NOT
84980: PUSH
84981: LD_VAR 0 1
84985: PUSH
84986: LD_INT 21
84988: PUSH
84989: LD_INT 2
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 23
84998: PUSH
84999: LD_INT 2
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PPUSH
85010: CALL_OW 69
85014: IN
85015: NOT
85016: OR
85017: IFFALSE 85021
// exit ;
85019: GO 85068
// for i = 1 to 3 do
85021: LD_ADDR_VAR 0 3
85025: PUSH
85026: DOUBLE
85027: LD_INT 1
85029: DEC
85030: ST_TO_ADDR
85031: LD_INT 3
85033: PUSH
85034: FOR_TO
85035: IFFALSE 85066
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85037: LD_VAR 0 1
85041: PPUSH
85042: CALL_OW 250
85046: PPUSH
85047: LD_VAR 0 1
85051: PPUSH
85052: CALL_OW 251
85056: PPUSH
85057: LD_INT 1
85059: PPUSH
85060: CALL_OW 453
85064: GO 85034
85066: POP
85067: POP
// end ;
85068: LD_VAR 0 2
85072: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85073: LD_INT 0
85075: PPUSH
85076: PPUSH
85077: PPUSH
85078: PPUSH
85079: PPUSH
85080: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85081: LD_VAR 0 1
85085: NOT
85086: PUSH
85087: LD_VAR 0 2
85091: NOT
85092: OR
85093: PUSH
85094: LD_VAR 0 1
85098: PPUSH
85099: CALL_OW 314
85103: OR
85104: IFFALSE 85108
// exit ;
85106: GO 85549
// x := GetX ( enemy_unit ) ;
85108: LD_ADDR_VAR 0 7
85112: PUSH
85113: LD_VAR 0 2
85117: PPUSH
85118: CALL_OW 250
85122: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85123: LD_ADDR_VAR 0 8
85127: PUSH
85128: LD_VAR 0 2
85132: PPUSH
85133: CALL_OW 251
85137: ST_TO_ADDR
// if not x or not y then
85138: LD_VAR 0 7
85142: NOT
85143: PUSH
85144: LD_VAR 0 8
85148: NOT
85149: OR
85150: IFFALSE 85154
// exit ;
85152: GO 85549
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85154: LD_ADDR_VAR 0 6
85158: PUSH
85159: LD_VAR 0 7
85163: PPUSH
85164: LD_INT 0
85166: PPUSH
85167: LD_INT 4
85169: PPUSH
85170: CALL_OW 272
85174: PUSH
85175: LD_VAR 0 8
85179: PPUSH
85180: LD_INT 0
85182: PPUSH
85183: LD_INT 4
85185: PPUSH
85186: CALL_OW 273
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_VAR 0 7
85199: PPUSH
85200: LD_INT 1
85202: PPUSH
85203: LD_INT 4
85205: PPUSH
85206: CALL_OW 272
85210: PUSH
85211: LD_VAR 0 8
85215: PPUSH
85216: LD_INT 1
85218: PPUSH
85219: LD_INT 4
85221: PPUSH
85222: CALL_OW 273
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_VAR 0 7
85235: PPUSH
85236: LD_INT 2
85238: PPUSH
85239: LD_INT 4
85241: PPUSH
85242: CALL_OW 272
85246: PUSH
85247: LD_VAR 0 8
85251: PPUSH
85252: LD_INT 2
85254: PPUSH
85255: LD_INT 4
85257: PPUSH
85258: CALL_OW 273
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_VAR 0 7
85271: PPUSH
85272: LD_INT 3
85274: PPUSH
85275: LD_INT 4
85277: PPUSH
85278: CALL_OW 272
85282: PUSH
85283: LD_VAR 0 8
85287: PPUSH
85288: LD_INT 3
85290: PPUSH
85291: LD_INT 4
85293: PPUSH
85294: CALL_OW 273
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_VAR 0 7
85307: PPUSH
85308: LD_INT 4
85310: PPUSH
85311: LD_INT 4
85313: PPUSH
85314: CALL_OW 272
85318: PUSH
85319: LD_VAR 0 8
85323: PPUSH
85324: LD_INT 4
85326: PPUSH
85327: LD_INT 4
85329: PPUSH
85330: CALL_OW 273
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_VAR 0 7
85343: PPUSH
85344: LD_INT 5
85346: PPUSH
85347: LD_INT 4
85349: PPUSH
85350: CALL_OW 272
85354: PUSH
85355: LD_VAR 0 8
85359: PPUSH
85360: LD_INT 5
85362: PPUSH
85363: LD_INT 4
85365: PPUSH
85366: CALL_OW 273
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: ST_TO_ADDR
// for i = tmp downto 1 do
85383: LD_ADDR_VAR 0 4
85387: PUSH
85388: DOUBLE
85389: LD_VAR 0 6
85393: INC
85394: ST_TO_ADDR
85395: LD_INT 1
85397: PUSH
85398: FOR_DOWNTO
85399: IFFALSE 85500
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85401: LD_VAR 0 6
85405: PUSH
85406: LD_VAR 0 4
85410: ARRAY
85411: PUSH
85412: LD_INT 1
85414: ARRAY
85415: PPUSH
85416: LD_VAR 0 6
85420: PUSH
85421: LD_VAR 0 4
85425: ARRAY
85426: PUSH
85427: LD_INT 2
85429: ARRAY
85430: PPUSH
85431: CALL_OW 488
85435: NOT
85436: PUSH
85437: LD_VAR 0 6
85441: PUSH
85442: LD_VAR 0 4
85446: ARRAY
85447: PUSH
85448: LD_INT 1
85450: ARRAY
85451: PPUSH
85452: LD_VAR 0 6
85456: PUSH
85457: LD_VAR 0 4
85461: ARRAY
85462: PUSH
85463: LD_INT 2
85465: ARRAY
85466: PPUSH
85467: CALL_OW 428
85471: PUSH
85472: LD_INT 0
85474: NONEQUAL
85475: OR
85476: IFFALSE 85498
// tmp := Delete ( tmp , i ) ;
85478: LD_ADDR_VAR 0 6
85482: PUSH
85483: LD_VAR 0 6
85487: PPUSH
85488: LD_VAR 0 4
85492: PPUSH
85493: CALL_OW 3
85497: ST_TO_ADDR
85498: GO 85398
85500: POP
85501: POP
// j := GetClosestHex ( unit , tmp ) ;
85502: LD_ADDR_VAR 0 5
85506: PUSH
85507: LD_VAR 0 1
85511: PPUSH
85512: LD_VAR 0 6
85516: PPUSH
85517: CALL 84802 0 2
85521: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85522: LD_VAR 0 1
85526: PPUSH
85527: LD_VAR 0 5
85531: PUSH
85532: LD_INT 1
85534: ARRAY
85535: PPUSH
85536: LD_VAR 0 5
85540: PUSH
85541: LD_INT 2
85543: ARRAY
85544: PPUSH
85545: CALL_OW 111
// end ;
85549: LD_VAR 0 3
85553: RET
// export function PrepareApemanSoldier ( ) ; begin
85554: LD_INT 0
85556: PPUSH
// uc_nation := 0 ;
85557: LD_ADDR_OWVAR 21
85561: PUSH
85562: LD_INT 0
85564: ST_TO_ADDR
// hc_sex := sex_male ;
85565: LD_ADDR_OWVAR 27
85569: PUSH
85570: LD_INT 1
85572: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85573: LD_ADDR_OWVAR 28
85577: PUSH
85578: LD_INT 15
85580: ST_TO_ADDR
// hc_gallery :=  ;
85581: LD_ADDR_OWVAR 33
85585: PUSH
85586: LD_STRING 
85588: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85589: LD_ADDR_OWVAR 31
85593: PUSH
85594: LD_INT 0
85596: PPUSH
85597: LD_INT 3
85599: PPUSH
85600: CALL_OW 12
85604: PUSH
85605: LD_INT 0
85607: PPUSH
85608: LD_INT 3
85610: PPUSH
85611: CALL_OW 12
85615: PUSH
85616: LD_INT 0
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: ST_TO_ADDR
// end ;
85628: LD_VAR 0 1
85632: RET
// export function PrepareApemanEngineer ( ) ; begin
85633: LD_INT 0
85635: PPUSH
// uc_nation := 0 ;
85636: LD_ADDR_OWVAR 21
85640: PUSH
85641: LD_INT 0
85643: ST_TO_ADDR
// hc_sex := sex_male ;
85644: LD_ADDR_OWVAR 27
85648: PUSH
85649: LD_INT 1
85651: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85652: LD_ADDR_OWVAR 28
85656: PUSH
85657: LD_INT 16
85659: ST_TO_ADDR
// hc_gallery :=  ;
85660: LD_ADDR_OWVAR 33
85664: PUSH
85665: LD_STRING 
85667: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85668: LD_ADDR_OWVAR 31
85672: PUSH
85673: LD_INT 0
85675: PPUSH
85676: LD_INT 3
85678: PPUSH
85679: CALL_OW 12
85683: PUSH
85684: LD_INT 0
85686: PPUSH
85687: LD_INT 3
85689: PPUSH
85690: CALL_OW 12
85694: PUSH
85695: LD_INT 0
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: ST_TO_ADDR
// end ;
85707: LD_VAR 0 1
85711: RET
// export function PrepareApeman ( agressivity ) ; begin
85712: LD_INT 0
85714: PPUSH
// uc_side := 0 ;
85715: LD_ADDR_OWVAR 20
85719: PUSH
85720: LD_INT 0
85722: ST_TO_ADDR
// uc_nation := 0 ;
85723: LD_ADDR_OWVAR 21
85727: PUSH
85728: LD_INT 0
85730: ST_TO_ADDR
// hc_sex := sex_male ;
85731: LD_ADDR_OWVAR 27
85735: PUSH
85736: LD_INT 1
85738: ST_TO_ADDR
// hc_class := class_apeman ;
85739: LD_ADDR_OWVAR 28
85743: PUSH
85744: LD_INT 12
85746: ST_TO_ADDR
// hc_gallery :=  ;
85747: LD_ADDR_OWVAR 33
85751: PUSH
85752: LD_STRING 
85754: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85755: LD_ADDR_OWVAR 35
85759: PUSH
85760: LD_VAR 0 1
85764: NEG
85765: PPUSH
85766: LD_VAR 0 1
85770: PPUSH
85771: CALL_OW 12
85775: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85776: LD_ADDR_OWVAR 31
85780: PUSH
85781: LD_INT 0
85783: PPUSH
85784: LD_INT 3
85786: PPUSH
85787: CALL_OW 12
85791: PUSH
85792: LD_INT 0
85794: PPUSH
85795: LD_INT 3
85797: PPUSH
85798: CALL_OW 12
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: LD_INT 0
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: ST_TO_ADDR
// end ;
85815: LD_VAR 0 2
85819: RET
// export function PrepareTiger ( agressivity ) ; begin
85820: LD_INT 0
85822: PPUSH
// uc_side := 0 ;
85823: LD_ADDR_OWVAR 20
85827: PUSH
85828: LD_INT 0
85830: ST_TO_ADDR
// uc_nation := 0 ;
85831: LD_ADDR_OWVAR 21
85835: PUSH
85836: LD_INT 0
85838: ST_TO_ADDR
// hc_class := class_tiger ;
85839: LD_ADDR_OWVAR 28
85843: PUSH
85844: LD_INT 14
85846: ST_TO_ADDR
// hc_gallery :=  ;
85847: LD_ADDR_OWVAR 33
85851: PUSH
85852: LD_STRING 
85854: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85855: LD_ADDR_OWVAR 35
85859: PUSH
85860: LD_VAR 0 1
85864: NEG
85865: PPUSH
85866: LD_VAR 0 1
85870: PPUSH
85871: CALL_OW 12
85875: ST_TO_ADDR
// end ;
85876: LD_VAR 0 2
85880: RET
// export function PrepareEnchidna ( ) ; begin
85881: LD_INT 0
85883: PPUSH
// uc_side := 0 ;
85884: LD_ADDR_OWVAR 20
85888: PUSH
85889: LD_INT 0
85891: ST_TO_ADDR
// uc_nation := 0 ;
85892: LD_ADDR_OWVAR 21
85896: PUSH
85897: LD_INT 0
85899: ST_TO_ADDR
// hc_class := class_baggie ;
85900: LD_ADDR_OWVAR 28
85904: PUSH
85905: LD_INT 13
85907: ST_TO_ADDR
// hc_gallery :=  ;
85908: LD_ADDR_OWVAR 33
85912: PUSH
85913: LD_STRING 
85915: ST_TO_ADDR
// end ;
85916: LD_VAR 0 1
85920: RET
// export function PrepareFrog ( ) ; begin
85921: LD_INT 0
85923: PPUSH
// uc_side := 0 ;
85924: LD_ADDR_OWVAR 20
85928: PUSH
85929: LD_INT 0
85931: ST_TO_ADDR
// uc_nation := 0 ;
85932: LD_ADDR_OWVAR 21
85936: PUSH
85937: LD_INT 0
85939: ST_TO_ADDR
// hc_class := class_frog ;
85940: LD_ADDR_OWVAR 28
85944: PUSH
85945: LD_INT 19
85947: ST_TO_ADDR
// hc_gallery :=  ;
85948: LD_ADDR_OWVAR 33
85952: PUSH
85953: LD_STRING 
85955: ST_TO_ADDR
// end ;
85956: LD_VAR 0 1
85960: RET
// export function PrepareFish ( ) ; begin
85961: LD_INT 0
85963: PPUSH
// uc_side := 0 ;
85964: LD_ADDR_OWVAR 20
85968: PUSH
85969: LD_INT 0
85971: ST_TO_ADDR
// uc_nation := 0 ;
85972: LD_ADDR_OWVAR 21
85976: PUSH
85977: LD_INT 0
85979: ST_TO_ADDR
// hc_class := class_fish ;
85980: LD_ADDR_OWVAR 28
85984: PUSH
85985: LD_INT 20
85987: ST_TO_ADDR
// hc_gallery :=  ;
85988: LD_ADDR_OWVAR 33
85992: PUSH
85993: LD_STRING 
85995: ST_TO_ADDR
// end ;
85996: LD_VAR 0 1
86000: RET
// export function PrepareBird ( ) ; begin
86001: LD_INT 0
86003: PPUSH
// uc_side := 0 ;
86004: LD_ADDR_OWVAR 20
86008: PUSH
86009: LD_INT 0
86011: ST_TO_ADDR
// uc_nation := 0 ;
86012: LD_ADDR_OWVAR 21
86016: PUSH
86017: LD_INT 0
86019: ST_TO_ADDR
// hc_class := class_phororhacos ;
86020: LD_ADDR_OWVAR 28
86024: PUSH
86025: LD_INT 18
86027: ST_TO_ADDR
// hc_gallery :=  ;
86028: LD_ADDR_OWVAR 33
86032: PUSH
86033: LD_STRING 
86035: ST_TO_ADDR
// end ;
86036: LD_VAR 0 1
86040: RET
// export function PrepareHorse ( ) ; begin
86041: LD_INT 0
86043: PPUSH
// uc_side := 0 ;
86044: LD_ADDR_OWVAR 20
86048: PUSH
86049: LD_INT 0
86051: ST_TO_ADDR
// uc_nation := 0 ;
86052: LD_ADDR_OWVAR 21
86056: PUSH
86057: LD_INT 0
86059: ST_TO_ADDR
// hc_class := class_horse ;
86060: LD_ADDR_OWVAR 28
86064: PUSH
86065: LD_INT 21
86067: ST_TO_ADDR
// hc_gallery :=  ;
86068: LD_ADDR_OWVAR 33
86072: PUSH
86073: LD_STRING 
86075: ST_TO_ADDR
// end ;
86076: LD_VAR 0 1
86080: RET
// export function PrepareMastodont ( ) ; begin
86081: LD_INT 0
86083: PPUSH
// uc_side := 0 ;
86084: LD_ADDR_OWVAR 20
86088: PUSH
86089: LD_INT 0
86091: ST_TO_ADDR
// uc_nation := 0 ;
86092: LD_ADDR_OWVAR 21
86096: PUSH
86097: LD_INT 0
86099: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86100: LD_ADDR_OWVAR 37
86104: PUSH
86105: LD_INT 31
86107: ST_TO_ADDR
// vc_control := control_rider ;
86108: LD_ADDR_OWVAR 38
86112: PUSH
86113: LD_INT 4
86115: ST_TO_ADDR
// end ;
86116: LD_VAR 0 1
86120: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86121: LD_INT 0
86123: PPUSH
86124: PPUSH
86125: PPUSH
// uc_side = 0 ;
86126: LD_ADDR_OWVAR 20
86130: PUSH
86131: LD_INT 0
86133: ST_TO_ADDR
// uc_nation = 0 ;
86134: LD_ADDR_OWVAR 21
86138: PUSH
86139: LD_INT 0
86141: ST_TO_ADDR
// InitHc_All ( ) ;
86142: CALL_OW 584
// InitVc ;
86146: CALL_OW 20
// if mastodonts then
86150: LD_VAR 0 6
86154: IFFALSE 86221
// for i = 1 to mastodonts do
86156: LD_ADDR_VAR 0 11
86160: PUSH
86161: DOUBLE
86162: LD_INT 1
86164: DEC
86165: ST_TO_ADDR
86166: LD_VAR 0 6
86170: PUSH
86171: FOR_TO
86172: IFFALSE 86219
// begin vc_chassis := 31 ;
86174: LD_ADDR_OWVAR 37
86178: PUSH
86179: LD_INT 31
86181: ST_TO_ADDR
// vc_control := control_rider ;
86182: LD_ADDR_OWVAR 38
86186: PUSH
86187: LD_INT 4
86189: ST_TO_ADDR
// animal := CreateVehicle ;
86190: LD_ADDR_VAR 0 12
86194: PUSH
86195: CALL_OW 45
86199: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86200: LD_VAR 0 12
86204: PPUSH
86205: LD_VAR 0 8
86209: PPUSH
86210: LD_INT 0
86212: PPUSH
86213: CALL 88356 0 3
// end ;
86217: GO 86171
86219: POP
86220: POP
// if horses then
86221: LD_VAR 0 5
86225: IFFALSE 86292
// for i = 1 to horses do
86227: LD_ADDR_VAR 0 11
86231: PUSH
86232: DOUBLE
86233: LD_INT 1
86235: DEC
86236: ST_TO_ADDR
86237: LD_VAR 0 5
86241: PUSH
86242: FOR_TO
86243: IFFALSE 86290
// begin hc_class := 21 ;
86245: LD_ADDR_OWVAR 28
86249: PUSH
86250: LD_INT 21
86252: ST_TO_ADDR
// hc_gallery :=  ;
86253: LD_ADDR_OWVAR 33
86257: PUSH
86258: LD_STRING 
86260: ST_TO_ADDR
// animal := CreateHuman ;
86261: LD_ADDR_VAR 0 12
86265: PUSH
86266: CALL_OW 44
86270: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86271: LD_VAR 0 12
86275: PPUSH
86276: LD_VAR 0 8
86280: PPUSH
86281: LD_INT 0
86283: PPUSH
86284: CALL 88356 0 3
// end ;
86288: GO 86242
86290: POP
86291: POP
// if birds then
86292: LD_VAR 0 1
86296: IFFALSE 86363
// for i = 1 to birds do
86298: LD_ADDR_VAR 0 11
86302: PUSH
86303: DOUBLE
86304: LD_INT 1
86306: DEC
86307: ST_TO_ADDR
86308: LD_VAR 0 1
86312: PUSH
86313: FOR_TO
86314: IFFALSE 86361
// begin hc_class = 18 ;
86316: LD_ADDR_OWVAR 28
86320: PUSH
86321: LD_INT 18
86323: ST_TO_ADDR
// hc_gallery =  ;
86324: LD_ADDR_OWVAR 33
86328: PUSH
86329: LD_STRING 
86331: ST_TO_ADDR
// animal := CreateHuman ;
86332: LD_ADDR_VAR 0 12
86336: PUSH
86337: CALL_OW 44
86341: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86342: LD_VAR 0 12
86346: PPUSH
86347: LD_VAR 0 8
86351: PPUSH
86352: LD_INT 0
86354: PPUSH
86355: CALL 88356 0 3
// end ;
86359: GO 86313
86361: POP
86362: POP
// if tigers then
86363: LD_VAR 0 2
86367: IFFALSE 86451
// for i = 1 to tigers do
86369: LD_ADDR_VAR 0 11
86373: PUSH
86374: DOUBLE
86375: LD_INT 1
86377: DEC
86378: ST_TO_ADDR
86379: LD_VAR 0 2
86383: PUSH
86384: FOR_TO
86385: IFFALSE 86449
// begin hc_class = class_tiger ;
86387: LD_ADDR_OWVAR 28
86391: PUSH
86392: LD_INT 14
86394: ST_TO_ADDR
// hc_gallery =  ;
86395: LD_ADDR_OWVAR 33
86399: PUSH
86400: LD_STRING 
86402: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86403: LD_ADDR_OWVAR 35
86407: PUSH
86408: LD_INT 7
86410: NEG
86411: PPUSH
86412: LD_INT 7
86414: PPUSH
86415: CALL_OW 12
86419: ST_TO_ADDR
// animal := CreateHuman ;
86420: LD_ADDR_VAR 0 12
86424: PUSH
86425: CALL_OW 44
86429: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86430: LD_VAR 0 12
86434: PPUSH
86435: LD_VAR 0 8
86439: PPUSH
86440: LD_INT 0
86442: PPUSH
86443: CALL 88356 0 3
// end ;
86447: GO 86384
86449: POP
86450: POP
// if apemans then
86451: LD_VAR 0 3
86455: IFFALSE 86578
// for i = 1 to apemans do
86457: LD_ADDR_VAR 0 11
86461: PUSH
86462: DOUBLE
86463: LD_INT 1
86465: DEC
86466: ST_TO_ADDR
86467: LD_VAR 0 3
86471: PUSH
86472: FOR_TO
86473: IFFALSE 86576
// begin hc_class = class_apeman ;
86475: LD_ADDR_OWVAR 28
86479: PUSH
86480: LD_INT 12
86482: ST_TO_ADDR
// hc_gallery =  ;
86483: LD_ADDR_OWVAR 33
86487: PUSH
86488: LD_STRING 
86490: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86491: LD_ADDR_OWVAR 35
86495: PUSH
86496: LD_INT 2
86498: NEG
86499: PPUSH
86500: LD_INT 2
86502: PPUSH
86503: CALL_OW 12
86507: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86508: LD_ADDR_OWVAR 31
86512: PUSH
86513: LD_INT 1
86515: PPUSH
86516: LD_INT 3
86518: PPUSH
86519: CALL_OW 12
86523: PUSH
86524: LD_INT 1
86526: PPUSH
86527: LD_INT 3
86529: PPUSH
86530: CALL_OW 12
86534: PUSH
86535: LD_INT 0
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: ST_TO_ADDR
// animal := CreateHuman ;
86547: LD_ADDR_VAR 0 12
86551: PUSH
86552: CALL_OW 44
86556: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86557: LD_VAR 0 12
86561: PPUSH
86562: LD_VAR 0 8
86566: PPUSH
86567: LD_INT 0
86569: PPUSH
86570: CALL 88356 0 3
// end ;
86574: GO 86472
86576: POP
86577: POP
// if enchidnas then
86578: LD_VAR 0 4
86582: IFFALSE 86649
// for i = 1 to enchidnas do
86584: LD_ADDR_VAR 0 11
86588: PUSH
86589: DOUBLE
86590: LD_INT 1
86592: DEC
86593: ST_TO_ADDR
86594: LD_VAR 0 4
86598: PUSH
86599: FOR_TO
86600: IFFALSE 86647
// begin hc_class = 13 ;
86602: LD_ADDR_OWVAR 28
86606: PUSH
86607: LD_INT 13
86609: ST_TO_ADDR
// hc_gallery =  ;
86610: LD_ADDR_OWVAR 33
86614: PUSH
86615: LD_STRING 
86617: ST_TO_ADDR
// animal := CreateHuman ;
86618: LD_ADDR_VAR 0 12
86622: PUSH
86623: CALL_OW 44
86627: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86628: LD_VAR 0 12
86632: PPUSH
86633: LD_VAR 0 8
86637: PPUSH
86638: LD_INT 0
86640: PPUSH
86641: CALL 88356 0 3
// end ;
86645: GO 86599
86647: POP
86648: POP
// if fishes then
86649: LD_VAR 0 7
86653: IFFALSE 86720
// for i = 1 to fishes do
86655: LD_ADDR_VAR 0 11
86659: PUSH
86660: DOUBLE
86661: LD_INT 1
86663: DEC
86664: ST_TO_ADDR
86665: LD_VAR 0 7
86669: PUSH
86670: FOR_TO
86671: IFFALSE 86718
// begin hc_class = 20 ;
86673: LD_ADDR_OWVAR 28
86677: PUSH
86678: LD_INT 20
86680: ST_TO_ADDR
// hc_gallery =  ;
86681: LD_ADDR_OWVAR 33
86685: PUSH
86686: LD_STRING 
86688: ST_TO_ADDR
// animal := CreateHuman ;
86689: LD_ADDR_VAR 0 12
86693: PUSH
86694: CALL_OW 44
86698: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86699: LD_VAR 0 12
86703: PPUSH
86704: LD_VAR 0 9
86708: PPUSH
86709: LD_INT 0
86711: PPUSH
86712: CALL 88356 0 3
// end ;
86716: GO 86670
86718: POP
86719: POP
// end ;
86720: LD_VAR 0 10
86724: RET
// export function WantHeal ( sci , unit ) ; begin
86725: LD_INT 0
86727: PPUSH
// if GetTaskList ( sci ) > 0 then
86728: LD_VAR 0 1
86732: PPUSH
86733: CALL_OW 437
86737: PUSH
86738: LD_INT 0
86740: GREATER
86741: IFFALSE 86811
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86743: LD_VAR 0 1
86747: PPUSH
86748: CALL_OW 437
86752: PUSH
86753: LD_INT 1
86755: ARRAY
86756: PUSH
86757: LD_INT 1
86759: ARRAY
86760: PUSH
86761: LD_STRING l
86763: EQUAL
86764: PUSH
86765: LD_VAR 0 1
86769: PPUSH
86770: CALL_OW 437
86774: PUSH
86775: LD_INT 1
86777: ARRAY
86778: PUSH
86779: LD_INT 4
86781: ARRAY
86782: PUSH
86783: LD_VAR 0 2
86787: EQUAL
86788: AND
86789: IFFALSE 86801
// result := true else
86791: LD_ADDR_VAR 0 3
86795: PUSH
86796: LD_INT 1
86798: ST_TO_ADDR
86799: GO 86809
// result := false ;
86801: LD_ADDR_VAR 0 3
86805: PUSH
86806: LD_INT 0
86808: ST_TO_ADDR
// end else
86809: GO 86819
// result := false ;
86811: LD_ADDR_VAR 0 3
86815: PUSH
86816: LD_INT 0
86818: ST_TO_ADDR
// end ;
86819: LD_VAR 0 3
86823: RET
// export function HealTarget ( sci ) ; begin
86824: LD_INT 0
86826: PPUSH
// if not sci then
86827: LD_VAR 0 1
86831: NOT
86832: IFFALSE 86836
// exit ;
86834: GO 86901
// result := 0 ;
86836: LD_ADDR_VAR 0 2
86840: PUSH
86841: LD_INT 0
86843: ST_TO_ADDR
// if GetTaskList ( sci ) then
86844: LD_VAR 0 1
86848: PPUSH
86849: CALL_OW 437
86853: IFFALSE 86901
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86855: LD_VAR 0 1
86859: PPUSH
86860: CALL_OW 437
86864: PUSH
86865: LD_INT 1
86867: ARRAY
86868: PUSH
86869: LD_INT 1
86871: ARRAY
86872: PUSH
86873: LD_STRING l
86875: EQUAL
86876: IFFALSE 86901
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86878: LD_ADDR_VAR 0 2
86882: PUSH
86883: LD_VAR 0 1
86887: PPUSH
86888: CALL_OW 437
86892: PUSH
86893: LD_INT 1
86895: ARRAY
86896: PUSH
86897: LD_INT 4
86899: ARRAY
86900: ST_TO_ADDR
// end ;
86901: LD_VAR 0 2
86905: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86906: LD_INT 0
86908: PPUSH
86909: PPUSH
86910: PPUSH
86911: PPUSH
// if not base_units then
86912: LD_VAR 0 1
86916: NOT
86917: IFFALSE 86921
// exit ;
86919: GO 87008
// result := false ;
86921: LD_ADDR_VAR 0 2
86925: PUSH
86926: LD_INT 0
86928: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86929: LD_ADDR_VAR 0 5
86933: PUSH
86934: LD_VAR 0 1
86938: PPUSH
86939: LD_INT 21
86941: PUSH
86942: LD_INT 3
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PPUSH
86949: CALL_OW 72
86953: ST_TO_ADDR
// if not tmp then
86954: LD_VAR 0 5
86958: NOT
86959: IFFALSE 86963
// exit ;
86961: GO 87008
// for i in tmp do
86963: LD_ADDR_VAR 0 3
86967: PUSH
86968: LD_VAR 0 5
86972: PUSH
86973: FOR_IN
86974: IFFALSE 87006
// begin result := EnemyInRange ( i , 22 ) ;
86976: LD_ADDR_VAR 0 2
86980: PUSH
86981: LD_VAR 0 3
86985: PPUSH
86986: LD_INT 22
86988: PPUSH
86989: CALL 84677 0 2
86993: ST_TO_ADDR
// if result then
86994: LD_VAR 0 2
86998: IFFALSE 87004
// exit ;
87000: POP
87001: POP
87002: GO 87008
// end ;
87004: GO 86973
87006: POP
87007: POP
// end ;
87008: LD_VAR 0 2
87012: RET
// export function FilterByTag ( units , tag ) ; begin
87013: LD_INT 0
87015: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87016: LD_ADDR_VAR 0 3
87020: PUSH
87021: LD_VAR 0 1
87025: PPUSH
87026: LD_INT 120
87028: PUSH
87029: LD_VAR 0 2
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PPUSH
87038: CALL_OW 72
87042: ST_TO_ADDR
// end ;
87043: LD_VAR 0 3
87047: RET
// export function IsDriver ( un ) ; begin
87048: LD_INT 0
87050: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87051: LD_ADDR_VAR 0 2
87055: PUSH
87056: LD_VAR 0 1
87060: PUSH
87061: LD_INT 55
87063: PUSH
87064: EMPTY
87065: LIST
87066: PPUSH
87067: CALL_OW 69
87071: IN
87072: ST_TO_ADDR
// end ;
87073: LD_VAR 0 2
87077: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87078: LD_INT 0
87080: PPUSH
87081: PPUSH
// list := [ ] ;
87082: LD_ADDR_VAR 0 5
87086: PUSH
87087: EMPTY
87088: ST_TO_ADDR
// case d of 0 :
87089: LD_VAR 0 3
87093: PUSH
87094: LD_INT 0
87096: DOUBLE
87097: EQUAL
87098: IFTRUE 87102
87100: GO 87235
87102: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87103: LD_ADDR_VAR 0 5
87107: PUSH
87108: LD_VAR 0 1
87112: PUSH
87113: LD_INT 4
87115: MINUS
87116: PUSH
87117: LD_VAR 0 2
87121: PUSH
87122: LD_INT 4
87124: MINUS
87125: PUSH
87126: LD_INT 2
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: LIST
87133: PUSH
87134: LD_VAR 0 1
87138: PUSH
87139: LD_INT 3
87141: MINUS
87142: PUSH
87143: LD_VAR 0 2
87147: PUSH
87148: LD_INT 1
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: LIST
87155: PUSH
87156: LD_VAR 0 1
87160: PUSH
87161: LD_INT 4
87163: PLUS
87164: PUSH
87165: LD_VAR 0 2
87169: PUSH
87170: LD_INT 4
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: LIST
87177: PUSH
87178: LD_VAR 0 1
87182: PUSH
87183: LD_INT 3
87185: PLUS
87186: PUSH
87187: LD_VAR 0 2
87191: PUSH
87192: LD_INT 3
87194: PLUS
87195: PUSH
87196: LD_INT 5
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: LIST
87203: PUSH
87204: LD_VAR 0 1
87208: PUSH
87209: LD_VAR 0 2
87213: PUSH
87214: LD_INT 4
87216: PLUS
87217: PUSH
87218: LD_INT 0
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: LIST
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: ST_TO_ADDR
// end ; 1 :
87233: GO 87933
87235: LD_INT 1
87237: DOUBLE
87238: EQUAL
87239: IFTRUE 87243
87241: GO 87376
87243: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87244: LD_ADDR_VAR 0 5
87248: PUSH
87249: LD_VAR 0 1
87253: PUSH
87254: LD_VAR 0 2
87258: PUSH
87259: LD_INT 4
87261: MINUS
87262: PUSH
87263: LD_INT 3
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: LIST
87270: PUSH
87271: LD_VAR 0 1
87275: PUSH
87276: LD_INT 3
87278: MINUS
87279: PUSH
87280: LD_VAR 0 2
87284: PUSH
87285: LD_INT 3
87287: MINUS
87288: PUSH
87289: LD_INT 2
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: LIST
87296: PUSH
87297: LD_VAR 0 1
87301: PUSH
87302: LD_INT 4
87304: MINUS
87305: PUSH
87306: LD_VAR 0 2
87310: PUSH
87311: LD_INT 1
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: LIST
87318: PUSH
87319: LD_VAR 0 1
87323: PUSH
87324: LD_VAR 0 2
87328: PUSH
87329: LD_INT 3
87331: PLUS
87332: PUSH
87333: LD_INT 0
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: LIST
87340: PUSH
87341: LD_VAR 0 1
87345: PUSH
87346: LD_INT 4
87348: PLUS
87349: PUSH
87350: LD_VAR 0 2
87354: PUSH
87355: LD_INT 4
87357: PLUS
87358: PUSH
87359: LD_INT 5
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: ST_TO_ADDR
// end ; 2 :
87374: GO 87933
87376: LD_INT 2
87378: DOUBLE
87379: EQUAL
87380: IFTRUE 87384
87382: GO 87513
87384: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87385: LD_ADDR_VAR 0 5
87389: PUSH
87390: LD_VAR 0 1
87394: PUSH
87395: LD_VAR 0 2
87399: PUSH
87400: LD_INT 3
87402: MINUS
87403: PUSH
87404: LD_INT 3
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: LIST
87411: PUSH
87412: LD_VAR 0 1
87416: PUSH
87417: LD_INT 4
87419: PLUS
87420: PUSH
87421: LD_VAR 0 2
87425: PUSH
87426: LD_INT 4
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: LIST
87433: PUSH
87434: LD_VAR 0 1
87438: PUSH
87439: LD_VAR 0 2
87443: PUSH
87444: LD_INT 4
87446: PLUS
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: LIST
87455: PUSH
87456: LD_VAR 0 1
87460: PUSH
87461: LD_INT 3
87463: MINUS
87464: PUSH
87465: LD_VAR 0 2
87469: PUSH
87470: LD_INT 1
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: LIST
87477: PUSH
87478: LD_VAR 0 1
87482: PUSH
87483: LD_INT 4
87485: MINUS
87486: PUSH
87487: LD_VAR 0 2
87491: PUSH
87492: LD_INT 4
87494: MINUS
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: LIST
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: ST_TO_ADDR
// end ; 3 :
87511: GO 87933
87513: LD_INT 3
87515: DOUBLE
87516: EQUAL
87517: IFTRUE 87521
87519: GO 87654
87521: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87522: LD_ADDR_VAR 0 5
87526: PUSH
87527: LD_VAR 0 1
87531: PUSH
87532: LD_INT 3
87534: PLUS
87535: PUSH
87536: LD_VAR 0 2
87540: PUSH
87541: LD_INT 4
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: LIST
87548: PUSH
87549: LD_VAR 0 1
87553: PUSH
87554: LD_INT 4
87556: PLUS
87557: PUSH
87558: LD_VAR 0 2
87562: PUSH
87563: LD_INT 4
87565: PLUS
87566: PUSH
87567: LD_INT 5
87569: PUSH
87570: EMPTY
87571: LIST
87572: LIST
87573: LIST
87574: PUSH
87575: LD_VAR 0 1
87579: PUSH
87580: LD_INT 4
87582: MINUS
87583: PUSH
87584: LD_VAR 0 2
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: LIST
87596: PUSH
87597: LD_VAR 0 1
87601: PUSH
87602: LD_VAR 0 2
87606: PUSH
87607: LD_INT 4
87609: MINUS
87610: PUSH
87611: LD_INT 3
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: LIST
87618: PUSH
87619: LD_VAR 0 1
87623: PUSH
87624: LD_INT 3
87626: MINUS
87627: PUSH
87628: LD_VAR 0 2
87632: PUSH
87633: LD_INT 3
87635: MINUS
87636: PUSH
87637: LD_INT 2
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: LIST
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: LIST
87649: LIST
87650: LIST
87651: ST_TO_ADDR
// end ; 4 :
87652: GO 87933
87654: LD_INT 4
87656: DOUBLE
87657: EQUAL
87658: IFTRUE 87662
87660: GO 87795
87662: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87663: LD_ADDR_VAR 0 5
87667: PUSH
87668: LD_VAR 0 1
87672: PUSH
87673: LD_VAR 0 2
87677: PUSH
87678: LD_INT 4
87680: PLUS
87681: PUSH
87682: LD_INT 0
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: LIST
87689: PUSH
87690: LD_VAR 0 1
87694: PUSH
87695: LD_INT 3
87697: PLUS
87698: PUSH
87699: LD_VAR 0 2
87703: PUSH
87704: LD_INT 3
87706: PLUS
87707: PUSH
87708: LD_INT 5
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: LIST
87715: PUSH
87716: LD_VAR 0 1
87720: PUSH
87721: LD_INT 4
87723: PLUS
87724: PUSH
87725: LD_VAR 0 2
87729: PUSH
87730: LD_INT 4
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: LIST
87737: PUSH
87738: LD_VAR 0 1
87742: PUSH
87743: LD_VAR 0 2
87747: PUSH
87748: LD_INT 3
87750: MINUS
87751: PUSH
87752: LD_INT 3
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: LIST
87759: PUSH
87760: LD_VAR 0 1
87764: PUSH
87765: LD_INT 4
87767: MINUS
87768: PUSH
87769: LD_VAR 0 2
87773: PUSH
87774: LD_INT 4
87776: MINUS
87777: PUSH
87778: LD_INT 2
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: LIST
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: ST_TO_ADDR
// end ; 5 :
87793: GO 87933
87795: LD_INT 5
87797: DOUBLE
87798: EQUAL
87799: IFTRUE 87803
87801: GO 87932
87803: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87804: LD_ADDR_VAR 0 5
87808: PUSH
87809: LD_VAR 0 1
87813: PUSH
87814: LD_INT 4
87816: MINUS
87817: PUSH
87818: LD_VAR 0 2
87822: PUSH
87823: LD_INT 1
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: LIST
87830: PUSH
87831: LD_VAR 0 1
87835: PUSH
87836: LD_VAR 0 2
87840: PUSH
87841: LD_INT 4
87843: MINUS
87844: PUSH
87845: LD_INT 3
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: LIST
87852: PUSH
87853: LD_VAR 0 1
87857: PUSH
87858: LD_INT 4
87860: PLUS
87861: PUSH
87862: LD_VAR 0 2
87866: PUSH
87867: LD_INT 4
87869: PLUS
87870: PUSH
87871: LD_INT 5
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: LIST
87878: PUSH
87879: LD_VAR 0 1
87883: PUSH
87884: LD_INT 3
87886: PLUS
87887: PUSH
87888: LD_VAR 0 2
87892: PUSH
87893: LD_INT 4
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: LIST
87900: PUSH
87901: LD_VAR 0 1
87905: PUSH
87906: LD_VAR 0 2
87910: PUSH
87911: LD_INT 3
87913: PLUS
87914: PUSH
87915: LD_INT 0
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: LIST
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: ST_TO_ADDR
// end ; end ;
87930: GO 87933
87932: POP
// result := list ;
87933: LD_ADDR_VAR 0 4
87937: PUSH
87938: LD_VAR 0 5
87942: ST_TO_ADDR
// end ;
87943: LD_VAR 0 4
87947: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87948: LD_INT 0
87950: PPUSH
87951: PPUSH
87952: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87953: LD_VAR 0 1
87957: NOT
87958: PUSH
87959: LD_VAR 0 2
87963: PUSH
87964: LD_INT 1
87966: PUSH
87967: LD_INT 2
87969: PUSH
87970: LD_INT 3
87972: PUSH
87973: LD_INT 4
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: IN
87982: NOT
87983: OR
87984: IFFALSE 87988
// exit ;
87986: GO 88080
// tmp := [ ] ;
87988: LD_ADDR_VAR 0 5
87992: PUSH
87993: EMPTY
87994: ST_TO_ADDR
// for i in units do
87995: LD_ADDR_VAR 0 4
87999: PUSH
88000: LD_VAR 0 1
88004: PUSH
88005: FOR_IN
88006: IFFALSE 88049
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88008: LD_ADDR_VAR 0 5
88012: PUSH
88013: LD_VAR 0 5
88017: PPUSH
88018: LD_VAR 0 5
88022: PUSH
88023: LD_INT 1
88025: PLUS
88026: PPUSH
88027: LD_VAR 0 4
88031: PPUSH
88032: LD_VAR 0 2
88036: PPUSH
88037: CALL_OW 259
88041: PPUSH
88042: CALL_OW 2
88046: ST_TO_ADDR
88047: GO 88005
88049: POP
88050: POP
// if not tmp then
88051: LD_VAR 0 5
88055: NOT
88056: IFFALSE 88060
// exit ;
88058: GO 88080
// result := SortListByListDesc ( units , tmp ) ;
88060: LD_ADDR_VAR 0 3
88064: PUSH
88065: LD_VAR 0 1
88069: PPUSH
88070: LD_VAR 0 5
88074: PPUSH
88075: CALL_OW 77
88079: ST_TO_ADDR
// end ;
88080: LD_VAR 0 3
88084: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88085: LD_INT 0
88087: PPUSH
88088: PPUSH
88089: PPUSH
// result := false ;
88090: LD_ADDR_VAR 0 3
88094: PUSH
88095: LD_INT 0
88097: ST_TO_ADDR
// x := GetX ( building ) ;
88098: LD_ADDR_VAR 0 4
88102: PUSH
88103: LD_VAR 0 2
88107: PPUSH
88108: CALL_OW 250
88112: ST_TO_ADDR
// y := GetY ( building ) ;
88113: LD_ADDR_VAR 0 5
88117: PUSH
88118: LD_VAR 0 2
88122: PPUSH
88123: CALL_OW 251
88127: ST_TO_ADDR
// if not building or not x or not y then
88128: LD_VAR 0 2
88132: NOT
88133: PUSH
88134: LD_VAR 0 4
88138: NOT
88139: OR
88140: PUSH
88141: LD_VAR 0 5
88145: NOT
88146: OR
88147: IFFALSE 88151
// exit ;
88149: GO 88243
// if GetTaskList ( unit ) then
88151: LD_VAR 0 1
88155: PPUSH
88156: CALL_OW 437
88160: IFFALSE 88243
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88162: LD_STRING e
88164: PUSH
88165: LD_VAR 0 1
88169: PPUSH
88170: CALL_OW 437
88174: PUSH
88175: LD_INT 1
88177: ARRAY
88178: PUSH
88179: LD_INT 1
88181: ARRAY
88182: EQUAL
88183: PUSH
88184: LD_VAR 0 4
88188: PUSH
88189: LD_VAR 0 1
88193: PPUSH
88194: CALL_OW 437
88198: PUSH
88199: LD_INT 1
88201: ARRAY
88202: PUSH
88203: LD_INT 2
88205: ARRAY
88206: EQUAL
88207: AND
88208: PUSH
88209: LD_VAR 0 5
88213: PUSH
88214: LD_VAR 0 1
88218: PPUSH
88219: CALL_OW 437
88223: PUSH
88224: LD_INT 1
88226: ARRAY
88227: PUSH
88228: LD_INT 3
88230: ARRAY
88231: EQUAL
88232: AND
88233: IFFALSE 88243
// result := true end ;
88235: LD_ADDR_VAR 0 3
88239: PUSH
88240: LD_INT 1
88242: ST_TO_ADDR
// end ;
88243: LD_VAR 0 3
88247: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88248: LD_INT 0
88250: PPUSH
// result := false ;
88251: LD_ADDR_VAR 0 4
88255: PUSH
88256: LD_INT 0
88258: ST_TO_ADDR
// if GetTaskList ( unit ) then
88259: LD_VAR 0 1
88263: PPUSH
88264: CALL_OW 437
88268: IFFALSE 88351
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88270: LD_STRING M
88272: PUSH
88273: LD_VAR 0 1
88277: PPUSH
88278: CALL_OW 437
88282: PUSH
88283: LD_INT 1
88285: ARRAY
88286: PUSH
88287: LD_INT 1
88289: ARRAY
88290: EQUAL
88291: PUSH
88292: LD_VAR 0 2
88296: PUSH
88297: LD_VAR 0 1
88301: PPUSH
88302: CALL_OW 437
88306: PUSH
88307: LD_INT 1
88309: ARRAY
88310: PUSH
88311: LD_INT 2
88313: ARRAY
88314: EQUAL
88315: AND
88316: PUSH
88317: LD_VAR 0 3
88321: PUSH
88322: LD_VAR 0 1
88326: PPUSH
88327: CALL_OW 437
88331: PUSH
88332: LD_INT 1
88334: ARRAY
88335: PUSH
88336: LD_INT 3
88338: ARRAY
88339: EQUAL
88340: AND
88341: IFFALSE 88351
// result := true ;
88343: LD_ADDR_VAR 0 4
88347: PUSH
88348: LD_INT 1
88350: ST_TO_ADDR
// end ; end ;
88351: LD_VAR 0 4
88355: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88356: LD_INT 0
88358: PPUSH
88359: PPUSH
88360: PPUSH
88361: PPUSH
// if not unit or not area then
88362: LD_VAR 0 1
88366: NOT
88367: PUSH
88368: LD_VAR 0 2
88372: NOT
88373: OR
88374: IFFALSE 88378
// exit ;
88376: GO 88542
// tmp := AreaToList ( area , i ) ;
88378: LD_ADDR_VAR 0 6
88382: PUSH
88383: LD_VAR 0 2
88387: PPUSH
88388: LD_VAR 0 5
88392: PPUSH
88393: CALL_OW 517
88397: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88398: LD_ADDR_VAR 0 5
88402: PUSH
88403: DOUBLE
88404: LD_INT 1
88406: DEC
88407: ST_TO_ADDR
88408: LD_VAR 0 6
88412: PUSH
88413: LD_INT 1
88415: ARRAY
88416: PUSH
88417: FOR_TO
88418: IFFALSE 88540
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88420: LD_ADDR_VAR 0 7
88424: PUSH
88425: LD_VAR 0 6
88429: PUSH
88430: LD_INT 1
88432: ARRAY
88433: PUSH
88434: LD_VAR 0 5
88438: ARRAY
88439: PUSH
88440: LD_VAR 0 6
88444: PUSH
88445: LD_INT 2
88447: ARRAY
88448: PUSH
88449: LD_VAR 0 5
88453: ARRAY
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88459: LD_VAR 0 7
88463: PUSH
88464: LD_INT 1
88466: ARRAY
88467: PPUSH
88468: LD_VAR 0 7
88472: PUSH
88473: LD_INT 2
88475: ARRAY
88476: PPUSH
88477: CALL_OW 428
88481: PUSH
88482: LD_INT 0
88484: EQUAL
88485: IFFALSE 88538
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88487: LD_VAR 0 1
88491: PPUSH
88492: LD_VAR 0 7
88496: PUSH
88497: LD_INT 1
88499: ARRAY
88500: PPUSH
88501: LD_VAR 0 7
88505: PUSH
88506: LD_INT 2
88508: ARRAY
88509: PPUSH
88510: LD_VAR 0 3
88514: PPUSH
88515: CALL_OW 48
// result := IsPlaced ( unit ) ;
88519: LD_ADDR_VAR 0 4
88523: PUSH
88524: LD_VAR 0 1
88528: PPUSH
88529: CALL_OW 305
88533: ST_TO_ADDR
// exit ;
88534: POP
88535: POP
88536: GO 88542
// end ; end ;
88538: GO 88417
88540: POP
88541: POP
// end ;
88542: LD_VAR 0 4
88546: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88547: LD_INT 0
88549: PPUSH
88550: PPUSH
88551: PPUSH
// if not side or side > 8 then
88552: LD_VAR 0 1
88556: NOT
88557: PUSH
88558: LD_VAR 0 1
88562: PUSH
88563: LD_INT 8
88565: GREATER
88566: OR
88567: IFFALSE 88571
// exit ;
88569: GO 88758
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88571: LD_ADDR_VAR 0 4
88575: PUSH
88576: LD_INT 22
88578: PUSH
88579: LD_VAR 0 1
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 21
88590: PUSH
88591: LD_INT 3
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: PPUSH
88602: CALL_OW 69
88606: ST_TO_ADDR
// if not tmp then
88607: LD_VAR 0 4
88611: NOT
88612: IFFALSE 88616
// exit ;
88614: GO 88758
// enable_addtolog := true ;
88616: LD_ADDR_OWVAR 81
88620: PUSH
88621: LD_INT 1
88623: ST_TO_ADDR
// AddToLog ( [ ) ;
88624: LD_STRING [
88626: PPUSH
88627: CALL_OW 561
// for i in tmp do
88631: LD_ADDR_VAR 0 3
88635: PUSH
88636: LD_VAR 0 4
88640: PUSH
88641: FOR_IN
88642: IFFALSE 88749
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88644: LD_STRING [
88646: PUSH
88647: LD_VAR 0 3
88651: PPUSH
88652: CALL_OW 266
88656: STR
88657: PUSH
88658: LD_STRING , 
88660: STR
88661: PUSH
88662: LD_VAR 0 3
88666: PPUSH
88667: CALL_OW 250
88671: STR
88672: PUSH
88673: LD_STRING , 
88675: STR
88676: PUSH
88677: LD_VAR 0 3
88681: PPUSH
88682: CALL_OW 251
88686: STR
88687: PUSH
88688: LD_STRING , 
88690: STR
88691: PUSH
88692: LD_VAR 0 3
88696: PPUSH
88697: CALL_OW 254
88701: STR
88702: PUSH
88703: LD_STRING , 
88705: STR
88706: PUSH
88707: LD_VAR 0 3
88711: PPUSH
88712: LD_INT 1
88714: PPUSH
88715: CALL_OW 268
88719: STR
88720: PUSH
88721: LD_STRING , 
88723: STR
88724: PUSH
88725: LD_VAR 0 3
88729: PPUSH
88730: LD_INT 2
88732: PPUSH
88733: CALL_OW 268
88737: STR
88738: PUSH
88739: LD_STRING ],
88741: STR
88742: PPUSH
88743: CALL_OW 561
// end ;
88747: GO 88641
88749: POP
88750: POP
// AddToLog ( ]; ) ;
88751: LD_STRING ];
88753: PPUSH
88754: CALL_OW 561
// end ;
88758: LD_VAR 0 2
88762: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88763: LD_INT 0
88765: PPUSH
88766: PPUSH
88767: PPUSH
88768: PPUSH
88769: PPUSH
// if not area or not rate or not max then
88770: LD_VAR 0 1
88774: NOT
88775: PUSH
88776: LD_VAR 0 2
88780: NOT
88781: OR
88782: PUSH
88783: LD_VAR 0 4
88787: NOT
88788: OR
88789: IFFALSE 88793
// exit ;
88791: GO 88982
// while 1 do
88793: LD_INT 1
88795: IFFALSE 88982
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88797: LD_ADDR_VAR 0 9
88801: PUSH
88802: LD_VAR 0 1
88806: PPUSH
88807: LD_INT 1
88809: PPUSH
88810: CALL_OW 287
88814: PUSH
88815: LD_INT 10
88817: MUL
88818: ST_TO_ADDR
// r := rate / 10 ;
88819: LD_ADDR_VAR 0 7
88823: PUSH
88824: LD_VAR 0 2
88828: PUSH
88829: LD_INT 10
88831: DIVREAL
88832: ST_TO_ADDR
// time := 1 1$00 ;
88833: LD_ADDR_VAR 0 8
88837: PUSH
88838: LD_INT 2100
88840: ST_TO_ADDR
// if amount < min then
88841: LD_VAR 0 9
88845: PUSH
88846: LD_VAR 0 3
88850: LESS
88851: IFFALSE 88869
// r := r * 2 else
88853: LD_ADDR_VAR 0 7
88857: PUSH
88858: LD_VAR 0 7
88862: PUSH
88863: LD_INT 2
88865: MUL
88866: ST_TO_ADDR
88867: GO 88895
// if amount > max then
88869: LD_VAR 0 9
88873: PUSH
88874: LD_VAR 0 4
88878: GREATER
88879: IFFALSE 88895
// r := r / 2 ;
88881: LD_ADDR_VAR 0 7
88885: PUSH
88886: LD_VAR 0 7
88890: PUSH
88891: LD_INT 2
88893: DIVREAL
88894: ST_TO_ADDR
// time := time / r ;
88895: LD_ADDR_VAR 0 8
88899: PUSH
88900: LD_VAR 0 8
88904: PUSH
88905: LD_VAR 0 7
88909: DIVREAL
88910: ST_TO_ADDR
// if time < 0 then
88911: LD_VAR 0 8
88915: PUSH
88916: LD_INT 0
88918: LESS
88919: IFFALSE 88936
// time := time * - 1 ;
88921: LD_ADDR_VAR 0 8
88925: PUSH
88926: LD_VAR 0 8
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: MUL
88935: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88936: LD_VAR 0 8
88940: PUSH
88941: LD_INT 35
88943: PPUSH
88944: LD_INT 875
88946: PPUSH
88947: CALL_OW 12
88951: PLUS
88952: PPUSH
88953: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88957: LD_INT 1
88959: PPUSH
88960: LD_INT 5
88962: PPUSH
88963: CALL_OW 12
88967: PPUSH
88968: LD_VAR 0 1
88972: PPUSH
88973: LD_INT 1
88975: PPUSH
88976: CALL_OW 55
// end ;
88980: GO 88793
// end ;
88982: LD_VAR 0 5
88986: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88987: LD_INT 0
88989: PPUSH
88990: PPUSH
88991: PPUSH
88992: PPUSH
88993: PPUSH
88994: PPUSH
88995: PPUSH
88996: PPUSH
// if not turrets or not factories then
88997: LD_VAR 0 1
89001: NOT
89002: PUSH
89003: LD_VAR 0 2
89007: NOT
89008: OR
89009: IFFALSE 89013
// exit ;
89011: GO 89320
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89013: LD_ADDR_VAR 0 10
89017: PUSH
89018: LD_INT 5
89020: PUSH
89021: LD_INT 6
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 2
89030: PUSH
89031: LD_INT 4
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 3
89040: PUSH
89041: LD_INT 5
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 24
89055: PUSH
89056: LD_INT 25
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 23
89065: PUSH
89066: LD_INT 27
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 42
89079: PUSH
89080: LD_INT 43
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 44
89089: PUSH
89090: LD_INT 46
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: PUSH
89097: LD_INT 45
89099: PUSH
89100: LD_INT 47
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: LIST
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: LIST
89116: ST_TO_ADDR
// result := [ ] ;
89117: LD_ADDR_VAR 0 3
89121: PUSH
89122: EMPTY
89123: ST_TO_ADDR
// for i in turrets do
89124: LD_ADDR_VAR 0 4
89128: PUSH
89129: LD_VAR 0 1
89133: PUSH
89134: FOR_IN
89135: IFFALSE 89318
// begin nat := GetNation ( i ) ;
89137: LD_ADDR_VAR 0 7
89141: PUSH
89142: LD_VAR 0 4
89146: PPUSH
89147: CALL_OW 248
89151: ST_TO_ADDR
// weapon := 0 ;
89152: LD_ADDR_VAR 0 8
89156: PUSH
89157: LD_INT 0
89159: ST_TO_ADDR
// if not nat then
89160: LD_VAR 0 7
89164: NOT
89165: IFFALSE 89169
// continue ;
89167: GO 89134
// for j in list [ nat ] do
89169: LD_ADDR_VAR 0 5
89173: PUSH
89174: LD_VAR 0 10
89178: PUSH
89179: LD_VAR 0 7
89183: ARRAY
89184: PUSH
89185: FOR_IN
89186: IFFALSE 89227
// if GetBWeapon ( i ) = j [ 1 ] then
89188: LD_VAR 0 4
89192: PPUSH
89193: CALL_OW 269
89197: PUSH
89198: LD_VAR 0 5
89202: PUSH
89203: LD_INT 1
89205: ARRAY
89206: EQUAL
89207: IFFALSE 89225
// begin weapon := j [ 2 ] ;
89209: LD_ADDR_VAR 0 8
89213: PUSH
89214: LD_VAR 0 5
89218: PUSH
89219: LD_INT 2
89221: ARRAY
89222: ST_TO_ADDR
// break ;
89223: GO 89227
// end ;
89225: GO 89185
89227: POP
89228: POP
// if not weapon then
89229: LD_VAR 0 8
89233: NOT
89234: IFFALSE 89238
// continue ;
89236: GO 89134
// for k in factories do
89238: LD_ADDR_VAR 0 6
89242: PUSH
89243: LD_VAR 0 2
89247: PUSH
89248: FOR_IN
89249: IFFALSE 89314
// begin weapons := AvailableWeaponList ( k ) ;
89251: LD_ADDR_VAR 0 9
89255: PUSH
89256: LD_VAR 0 6
89260: PPUSH
89261: CALL_OW 478
89265: ST_TO_ADDR
// if not weapons then
89266: LD_VAR 0 9
89270: NOT
89271: IFFALSE 89275
// continue ;
89273: GO 89248
// if weapon in weapons then
89275: LD_VAR 0 8
89279: PUSH
89280: LD_VAR 0 9
89284: IN
89285: IFFALSE 89312
// begin result := [ i , weapon ] ;
89287: LD_ADDR_VAR 0 3
89291: PUSH
89292: LD_VAR 0 4
89296: PUSH
89297: LD_VAR 0 8
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: ST_TO_ADDR
// exit ;
89306: POP
89307: POP
89308: POP
89309: POP
89310: GO 89320
// end ; end ;
89312: GO 89248
89314: POP
89315: POP
// end ;
89316: GO 89134
89318: POP
89319: POP
// end ;
89320: LD_VAR 0 3
89324: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89325: LD_INT 0
89327: PPUSH
// if not side or side > 8 then
89328: LD_VAR 0 3
89332: NOT
89333: PUSH
89334: LD_VAR 0 3
89338: PUSH
89339: LD_INT 8
89341: GREATER
89342: OR
89343: IFFALSE 89347
// exit ;
89345: GO 89406
// if not range then
89347: LD_VAR 0 4
89351: NOT
89352: IFFALSE 89363
// range := - 12 ;
89354: LD_ADDR_VAR 0 4
89358: PUSH
89359: LD_INT 12
89361: NEG
89362: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89363: LD_VAR 0 1
89367: PPUSH
89368: LD_VAR 0 2
89372: PPUSH
89373: LD_VAR 0 3
89377: PPUSH
89378: LD_VAR 0 4
89382: PPUSH
89383: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89387: LD_VAR 0 1
89391: PPUSH
89392: LD_VAR 0 2
89396: PPUSH
89397: LD_VAR 0 3
89401: PPUSH
89402: CALL_OW 331
// end ;
89406: LD_VAR 0 5
89410: RET
// export function Video ( mode ) ; begin
89411: LD_INT 0
89413: PPUSH
// ingame_video = mode ;
89414: LD_ADDR_OWVAR 52
89418: PUSH
89419: LD_VAR 0 1
89423: ST_TO_ADDR
// interface_hidden = mode ;
89424: LD_ADDR_OWVAR 54
89428: PUSH
89429: LD_VAR 0 1
89433: ST_TO_ADDR
// end ;
89434: LD_VAR 0 2
89438: RET
// export function Join ( array , element ) ; begin
89439: LD_INT 0
89441: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89442: LD_ADDR_VAR 0 3
89446: PUSH
89447: LD_VAR 0 1
89451: PPUSH
89452: LD_VAR 0 1
89456: PUSH
89457: LD_INT 1
89459: PLUS
89460: PPUSH
89461: LD_VAR 0 2
89465: PPUSH
89466: CALL_OW 1
89470: ST_TO_ADDR
// end ;
89471: LD_VAR 0 3
89475: RET
// export function JoinUnion ( array , element ) ; begin
89476: LD_INT 0
89478: PPUSH
// result := array union element ;
89479: LD_ADDR_VAR 0 3
89483: PUSH
89484: LD_VAR 0 1
89488: PUSH
89489: LD_VAR 0 2
89493: UNION
89494: ST_TO_ADDR
// end ;
89495: LD_VAR 0 3
89499: RET
// export function GetBehemoths ( side ) ; begin
89500: LD_INT 0
89502: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89503: LD_ADDR_VAR 0 2
89507: PUSH
89508: LD_INT 22
89510: PUSH
89511: LD_VAR 0 1
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 31
89522: PUSH
89523: LD_INT 25
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: PPUSH
89534: CALL_OW 69
89538: ST_TO_ADDR
// end ;
89539: LD_VAR 0 2
89543: RET
// export function Shuffle ( array ) ; var i , index ; begin
89544: LD_INT 0
89546: PPUSH
89547: PPUSH
89548: PPUSH
// result := [ ] ;
89549: LD_ADDR_VAR 0 2
89553: PUSH
89554: EMPTY
89555: ST_TO_ADDR
// if not array then
89556: LD_VAR 0 1
89560: NOT
89561: IFFALSE 89565
// exit ;
89563: GO 89664
// Randomize ;
89565: CALL_OW 10
// for i = array downto 1 do
89569: LD_ADDR_VAR 0 3
89573: PUSH
89574: DOUBLE
89575: LD_VAR 0 1
89579: INC
89580: ST_TO_ADDR
89581: LD_INT 1
89583: PUSH
89584: FOR_DOWNTO
89585: IFFALSE 89662
// begin index := rand ( 1 , array ) ;
89587: LD_ADDR_VAR 0 4
89591: PUSH
89592: LD_INT 1
89594: PPUSH
89595: LD_VAR 0 1
89599: PPUSH
89600: CALL_OW 12
89604: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89605: LD_ADDR_VAR 0 2
89609: PUSH
89610: LD_VAR 0 2
89614: PPUSH
89615: LD_VAR 0 2
89619: PUSH
89620: LD_INT 1
89622: PLUS
89623: PPUSH
89624: LD_VAR 0 1
89628: PUSH
89629: LD_VAR 0 4
89633: ARRAY
89634: PPUSH
89635: CALL_OW 2
89639: ST_TO_ADDR
// array := Delete ( array , index ) ;
89640: LD_ADDR_VAR 0 1
89644: PUSH
89645: LD_VAR 0 1
89649: PPUSH
89650: LD_VAR 0 4
89654: PPUSH
89655: CALL_OW 3
89659: ST_TO_ADDR
// end ;
89660: GO 89584
89662: POP
89663: POP
// end ;
89664: LD_VAR 0 2
89668: RET
// export function GetBaseMaterials ( base ) ; begin
89669: LD_INT 0
89671: PPUSH
// result := [ 0 , 0 , 0 ] ;
89672: LD_ADDR_VAR 0 2
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: LD_INT 0
89682: PUSH
89683: LD_INT 0
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: LIST
89690: ST_TO_ADDR
// if not base then
89691: LD_VAR 0 1
89695: NOT
89696: IFFALSE 89700
// exit ;
89698: GO 89749
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89700: LD_ADDR_VAR 0 2
89704: PUSH
89705: LD_VAR 0 1
89709: PPUSH
89710: LD_INT 1
89712: PPUSH
89713: CALL_OW 275
89717: PUSH
89718: LD_VAR 0 1
89722: PPUSH
89723: LD_INT 2
89725: PPUSH
89726: CALL_OW 275
89730: PUSH
89731: LD_VAR 0 1
89735: PPUSH
89736: LD_INT 3
89738: PPUSH
89739: CALL_OW 275
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: ST_TO_ADDR
// end ;
89749: LD_VAR 0 2
89753: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89754: LD_INT 0
89756: PPUSH
89757: PPUSH
// result := array ;
89758: LD_ADDR_VAR 0 3
89762: PUSH
89763: LD_VAR 0 1
89767: ST_TO_ADDR
// if size >= result then
89768: LD_VAR 0 2
89772: PUSH
89773: LD_VAR 0 3
89777: GREATEREQUAL
89778: IFFALSE 89782
// exit ;
89780: GO 89832
// if size then
89782: LD_VAR 0 2
89786: IFFALSE 89832
// for i := array downto size do
89788: LD_ADDR_VAR 0 4
89792: PUSH
89793: DOUBLE
89794: LD_VAR 0 1
89798: INC
89799: ST_TO_ADDR
89800: LD_VAR 0 2
89804: PUSH
89805: FOR_DOWNTO
89806: IFFALSE 89830
// result := Delete ( result , result ) ;
89808: LD_ADDR_VAR 0 3
89812: PUSH
89813: LD_VAR 0 3
89817: PPUSH
89818: LD_VAR 0 3
89822: PPUSH
89823: CALL_OW 3
89827: ST_TO_ADDR
89828: GO 89805
89830: POP
89831: POP
// end ;
89832: LD_VAR 0 3
89836: RET
// export function ComExit ( unit ) ; var tmp ; begin
89837: LD_INT 0
89839: PPUSH
89840: PPUSH
// if not IsInUnit ( unit ) then
89841: LD_VAR 0 1
89845: PPUSH
89846: CALL_OW 310
89850: NOT
89851: IFFALSE 89855
// exit ;
89853: GO 89915
// tmp := IsInUnit ( unit ) ;
89855: LD_ADDR_VAR 0 3
89859: PUSH
89860: LD_VAR 0 1
89864: PPUSH
89865: CALL_OW 310
89869: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89870: LD_VAR 0 3
89874: PPUSH
89875: CALL_OW 247
89879: PUSH
89880: LD_INT 2
89882: EQUAL
89883: IFFALSE 89896
// ComExitVehicle ( unit ) else
89885: LD_VAR 0 1
89889: PPUSH
89890: CALL_OW 121
89894: GO 89905
// ComExitBuilding ( unit ) ;
89896: LD_VAR 0 1
89900: PPUSH
89901: CALL_OW 122
// result := tmp ;
89905: LD_ADDR_VAR 0 2
89909: PUSH
89910: LD_VAR 0 3
89914: ST_TO_ADDR
// end ;
89915: LD_VAR 0 2
89919: RET
// export function ComExitAll ( units ) ; var i ; begin
89920: LD_INT 0
89922: PPUSH
89923: PPUSH
// if not units then
89924: LD_VAR 0 1
89928: NOT
89929: IFFALSE 89933
// exit ;
89931: GO 89959
// for i in units do
89933: LD_ADDR_VAR 0 3
89937: PUSH
89938: LD_VAR 0 1
89942: PUSH
89943: FOR_IN
89944: IFFALSE 89957
// ComExit ( i ) ;
89946: LD_VAR 0 3
89950: PPUSH
89951: CALL 89837 0 1
89955: GO 89943
89957: POP
89958: POP
// end ;
89959: LD_VAR 0 2
89963: RET
// export function ResetHc ; begin
89964: LD_INT 0
89966: PPUSH
// InitHc ;
89967: CALL_OW 19
// hc_importance := 0 ;
89971: LD_ADDR_OWVAR 32
89975: PUSH
89976: LD_INT 0
89978: ST_TO_ADDR
// end ;
89979: LD_VAR 0 1
89983: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89984: LD_INT 0
89986: PPUSH
89987: PPUSH
89988: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89989: LD_ADDR_VAR 0 6
89993: PUSH
89994: LD_VAR 0 1
89998: PUSH
89999: LD_VAR 0 3
90003: PLUS
90004: PUSH
90005: LD_INT 2
90007: DIV
90008: ST_TO_ADDR
// if _x < 0 then
90009: LD_VAR 0 6
90013: PUSH
90014: LD_INT 0
90016: LESS
90017: IFFALSE 90034
// _x := _x * - 1 ;
90019: LD_ADDR_VAR 0 6
90023: PUSH
90024: LD_VAR 0 6
90028: PUSH
90029: LD_INT 1
90031: NEG
90032: MUL
90033: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90034: LD_ADDR_VAR 0 7
90038: PUSH
90039: LD_VAR 0 2
90043: PUSH
90044: LD_VAR 0 4
90048: PLUS
90049: PUSH
90050: LD_INT 2
90052: DIV
90053: ST_TO_ADDR
// if _y < 0 then
90054: LD_VAR 0 7
90058: PUSH
90059: LD_INT 0
90061: LESS
90062: IFFALSE 90079
// _y := _y * - 1 ;
90064: LD_ADDR_VAR 0 7
90068: PUSH
90069: LD_VAR 0 7
90073: PUSH
90074: LD_INT 1
90076: NEG
90077: MUL
90078: ST_TO_ADDR
// result := [ _x , _y ] ;
90079: LD_ADDR_VAR 0 5
90083: PUSH
90084: LD_VAR 0 6
90088: PUSH
90089: LD_VAR 0 7
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: ST_TO_ADDR
// end ;
90098: LD_VAR 0 5
90102: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90103: LD_INT 0
90105: PPUSH
90106: PPUSH
90107: PPUSH
90108: PPUSH
// task := GetTaskList ( unit ) ;
90109: LD_ADDR_VAR 0 7
90113: PUSH
90114: LD_VAR 0 1
90118: PPUSH
90119: CALL_OW 437
90123: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90124: LD_VAR 0 7
90128: NOT
90129: PUSH
90130: LD_VAR 0 1
90134: PPUSH
90135: LD_VAR 0 2
90139: PPUSH
90140: CALL_OW 308
90144: NOT
90145: AND
90146: IFFALSE 90150
// exit ;
90148: GO 90268
// if IsInArea ( unit , area ) then
90150: LD_VAR 0 1
90154: PPUSH
90155: LD_VAR 0 2
90159: PPUSH
90160: CALL_OW 308
90164: IFFALSE 90182
// begin ComMoveToArea ( unit , goAway ) ;
90166: LD_VAR 0 1
90170: PPUSH
90171: LD_VAR 0 3
90175: PPUSH
90176: CALL_OW 113
// exit ;
90180: GO 90268
// end ; if task [ 1 ] [ 1 ] <> M then
90182: LD_VAR 0 7
90186: PUSH
90187: LD_INT 1
90189: ARRAY
90190: PUSH
90191: LD_INT 1
90193: ARRAY
90194: PUSH
90195: LD_STRING M
90197: NONEQUAL
90198: IFFALSE 90202
// exit ;
90200: GO 90268
// x := task [ 1 ] [ 2 ] ;
90202: LD_ADDR_VAR 0 5
90206: PUSH
90207: LD_VAR 0 7
90211: PUSH
90212: LD_INT 1
90214: ARRAY
90215: PUSH
90216: LD_INT 2
90218: ARRAY
90219: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90220: LD_ADDR_VAR 0 6
90224: PUSH
90225: LD_VAR 0 7
90229: PUSH
90230: LD_INT 1
90232: ARRAY
90233: PUSH
90234: LD_INT 3
90236: ARRAY
90237: ST_TO_ADDR
// if InArea ( x , y , area ) then
90238: LD_VAR 0 5
90242: PPUSH
90243: LD_VAR 0 6
90247: PPUSH
90248: LD_VAR 0 2
90252: PPUSH
90253: CALL_OW 309
90257: IFFALSE 90268
// ComStop ( unit ) ;
90259: LD_VAR 0 1
90263: PPUSH
90264: CALL_OW 141
// end ;
90268: LD_VAR 0 4
90272: RET
// export function Abs ( value ) ; begin
90273: LD_INT 0
90275: PPUSH
// result := value ;
90276: LD_ADDR_VAR 0 2
90280: PUSH
90281: LD_VAR 0 1
90285: ST_TO_ADDR
// if value < 0 then
90286: LD_VAR 0 1
90290: PUSH
90291: LD_INT 0
90293: LESS
90294: IFFALSE 90311
// result := value * - 1 ;
90296: LD_ADDR_VAR 0 2
90300: PUSH
90301: LD_VAR 0 1
90305: PUSH
90306: LD_INT 1
90308: NEG
90309: MUL
90310: ST_TO_ADDR
// end ;
90311: LD_VAR 0 2
90315: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90316: LD_INT 0
90318: PPUSH
90319: PPUSH
90320: PPUSH
90321: PPUSH
90322: PPUSH
90323: PPUSH
90324: PPUSH
90325: PPUSH
// if not unit or not building then
90326: LD_VAR 0 1
90330: NOT
90331: PUSH
90332: LD_VAR 0 2
90336: NOT
90337: OR
90338: IFFALSE 90342
// exit ;
90340: GO 90568
// x := GetX ( building ) ;
90342: LD_ADDR_VAR 0 4
90346: PUSH
90347: LD_VAR 0 2
90351: PPUSH
90352: CALL_OW 250
90356: ST_TO_ADDR
// y := GetY ( building ) ;
90357: LD_ADDR_VAR 0 6
90361: PUSH
90362: LD_VAR 0 2
90366: PPUSH
90367: CALL_OW 251
90371: ST_TO_ADDR
// d := GetDir ( building ) ;
90372: LD_ADDR_VAR 0 8
90376: PUSH
90377: LD_VAR 0 2
90381: PPUSH
90382: CALL_OW 254
90386: ST_TO_ADDR
// r := 4 ;
90387: LD_ADDR_VAR 0 9
90391: PUSH
90392: LD_INT 4
90394: ST_TO_ADDR
// for i := 1 to 5 do
90395: LD_ADDR_VAR 0 10
90399: PUSH
90400: DOUBLE
90401: LD_INT 1
90403: DEC
90404: ST_TO_ADDR
90405: LD_INT 5
90407: PUSH
90408: FOR_TO
90409: IFFALSE 90566
// begin _x := ShiftX ( x , d , r + i ) ;
90411: LD_ADDR_VAR 0 5
90415: PUSH
90416: LD_VAR 0 4
90420: PPUSH
90421: LD_VAR 0 8
90425: PPUSH
90426: LD_VAR 0 9
90430: PUSH
90431: LD_VAR 0 10
90435: PLUS
90436: PPUSH
90437: CALL_OW 272
90441: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90442: LD_ADDR_VAR 0 7
90446: PUSH
90447: LD_VAR 0 6
90451: PPUSH
90452: LD_VAR 0 8
90456: PPUSH
90457: LD_VAR 0 9
90461: PUSH
90462: LD_VAR 0 10
90466: PLUS
90467: PPUSH
90468: CALL_OW 273
90472: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90473: LD_VAR 0 5
90477: PPUSH
90478: LD_VAR 0 7
90482: PPUSH
90483: CALL_OW 488
90487: PUSH
90488: LD_VAR 0 5
90492: PPUSH
90493: LD_VAR 0 7
90497: PPUSH
90498: CALL_OW 428
90502: PPUSH
90503: CALL_OW 247
90507: PUSH
90508: LD_INT 3
90510: PUSH
90511: LD_INT 2
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: IN
90518: NOT
90519: AND
90520: IFFALSE 90564
// begin ComMoveXY ( unit , _x , _y ) ;
90522: LD_VAR 0 1
90526: PPUSH
90527: LD_VAR 0 5
90531: PPUSH
90532: LD_VAR 0 7
90536: PPUSH
90537: CALL_OW 111
// result := [ _x , _y ] ;
90541: LD_ADDR_VAR 0 3
90545: PUSH
90546: LD_VAR 0 5
90550: PUSH
90551: LD_VAR 0 7
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: ST_TO_ADDR
// exit ;
90560: POP
90561: POP
90562: GO 90568
// end ; end ;
90564: GO 90408
90566: POP
90567: POP
// end ;
90568: LD_VAR 0 3
90572: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90573: LD_INT 0
90575: PPUSH
90576: PPUSH
90577: PPUSH
// result := 0 ;
90578: LD_ADDR_VAR 0 3
90582: PUSH
90583: LD_INT 0
90585: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90586: LD_VAR 0 1
90590: PUSH
90591: LD_INT 0
90593: LESS
90594: PUSH
90595: LD_VAR 0 1
90599: PUSH
90600: LD_INT 8
90602: GREATER
90603: OR
90604: PUSH
90605: LD_VAR 0 2
90609: PUSH
90610: LD_INT 0
90612: LESS
90613: OR
90614: PUSH
90615: LD_VAR 0 2
90619: PUSH
90620: LD_INT 8
90622: GREATER
90623: OR
90624: IFFALSE 90628
// exit ;
90626: GO 90703
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90628: LD_ADDR_VAR 0 4
90632: PUSH
90633: LD_INT 22
90635: PUSH
90636: LD_VAR 0 2
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PPUSH
90645: CALL_OW 69
90649: PUSH
90650: FOR_IN
90651: IFFALSE 90701
// begin un := UnitShoot ( i ) ;
90653: LD_ADDR_VAR 0 5
90657: PUSH
90658: LD_VAR 0 4
90662: PPUSH
90663: CALL_OW 504
90667: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90668: LD_VAR 0 5
90672: PPUSH
90673: CALL_OW 255
90677: PUSH
90678: LD_VAR 0 1
90682: EQUAL
90683: IFFALSE 90699
// begin result := un ;
90685: LD_ADDR_VAR 0 3
90689: PUSH
90690: LD_VAR 0 5
90694: ST_TO_ADDR
// exit ;
90695: POP
90696: POP
90697: GO 90703
// end ; end ;
90699: GO 90650
90701: POP
90702: POP
// end ;
90703: LD_VAR 0 3
90707: RET
// export function GetCargoBay ( units ) ; begin
90708: LD_INT 0
90710: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90711: LD_ADDR_VAR 0 2
90715: PUSH
90716: LD_VAR 0 1
90720: PPUSH
90721: LD_INT 2
90723: PUSH
90724: LD_INT 34
90726: PUSH
90727: LD_INT 12
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 34
90736: PUSH
90737: LD_INT 51
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 34
90746: PUSH
90747: LD_INT 32
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 34
90756: PUSH
90757: LD_EXP 75
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: PPUSH
90773: CALL_OW 72
90777: ST_TO_ADDR
// end ;
90778: LD_VAR 0 2
90782: RET
// export function Negate ( value ) ; begin
90783: LD_INT 0
90785: PPUSH
// result := not value ;
90786: LD_ADDR_VAR 0 2
90790: PUSH
90791: LD_VAR 0 1
90795: NOT
90796: ST_TO_ADDR
// end ;
90797: LD_VAR 0 2
90801: RET
// export function Inc ( value ) ; begin
90802: LD_INT 0
90804: PPUSH
// result := value + 1 ;
90805: LD_ADDR_VAR 0 2
90809: PUSH
90810: LD_VAR 0 1
90814: PUSH
90815: LD_INT 1
90817: PLUS
90818: ST_TO_ADDR
// end ;
90819: LD_VAR 0 2
90823: RET
// export function Dec ( value ) ; begin
90824: LD_INT 0
90826: PPUSH
// result := value - 1 ;
90827: LD_ADDR_VAR 0 2
90831: PUSH
90832: LD_VAR 0 1
90836: PUSH
90837: LD_INT 1
90839: MINUS
90840: ST_TO_ADDR
// end ;
90841: LD_VAR 0 2
90845: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90846: LD_INT 0
90848: PPUSH
90849: PPUSH
90850: PPUSH
90851: PPUSH
90852: PPUSH
90853: PPUSH
90854: PPUSH
90855: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90856: LD_VAR 0 1
90860: PPUSH
90861: LD_VAR 0 2
90865: PPUSH
90866: CALL_OW 488
90870: NOT
90871: PUSH
90872: LD_VAR 0 3
90876: PPUSH
90877: LD_VAR 0 4
90881: PPUSH
90882: CALL_OW 488
90886: NOT
90887: OR
90888: IFFALSE 90901
// begin result := - 1 ;
90890: LD_ADDR_VAR 0 5
90894: PUSH
90895: LD_INT 1
90897: NEG
90898: ST_TO_ADDR
// exit ;
90899: GO 91136
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90901: LD_ADDR_VAR 0 12
90905: PUSH
90906: LD_VAR 0 1
90910: PPUSH
90911: LD_VAR 0 2
90915: PPUSH
90916: LD_VAR 0 3
90920: PPUSH
90921: LD_VAR 0 4
90925: PPUSH
90926: CALL 89984 0 4
90930: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90931: LD_ADDR_VAR 0 11
90935: PUSH
90936: LD_VAR 0 1
90940: PPUSH
90941: LD_VAR 0 2
90945: PPUSH
90946: LD_VAR 0 12
90950: PUSH
90951: LD_INT 1
90953: ARRAY
90954: PPUSH
90955: LD_VAR 0 12
90959: PUSH
90960: LD_INT 2
90962: ARRAY
90963: PPUSH
90964: CALL_OW 298
90968: ST_TO_ADDR
// distance := 9999 ;
90969: LD_ADDR_VAR 0 10
90973: PUSH
90974: LD_INT 9999
90976: ST_TO_ADDR
// for i := 0 to 5 do
90977: LD_ADDR_VAR 0 6
90981: PUSH
90982: DOUBLE
90983: LD_INT 0
90985: DEC
90986: ST_TO_ADDR
90987: LD_INT 5
90989: PUSH
90990: FOR_TO
90991: IFFALSE 91134
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90993: LD_ADDR_VAR 0 7
90997: PUSH
90998: LD_VAR 0 1
91002: PPUSH
91003: LD_VAR 0 6
91007: PPUSH
91008: LD_VAR 0 11
91012: PPUSH
91013: CALL_OW 272
91017: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91018: LD_ADDR_VAR 0 8
91022: PUSH
91023: LD_VAR 0 2
91027: PPUSH
91028: LD_VAR 0 6
91032: PPUSH
91033: LD_VAR 0 11
91037: PPUSH
91038: CALL_OW 273
91042: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91043: LD_VAR 0 7
91047: PPUSH
91048: LD_VAR 0 8
91052: PPUSH
91053: CALL_OW 488
91057: NOT
91058: IFFALSE 91062
// continue ;
91060: GO 90990
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91062: LD_ADDR_VAR 0 9
91066: PUSH
91067: LD_VAR 0 12
91071: PUSH
91072: LD_INT 1
91074: ARRAY
91075: PPUSH
91076: LD_VAR 0 12
91080: PUSH
91081: LD_INT 2
91083: ARRAY
91084: PPUSH
91085: LD_VAR 0 7
91089: PPUSH
91090: LD_VAR 0 8
91094: PPUSH
91095: CALL_OW 298
91099: ST_TO_ADDR
// if tmp < distance then
91100: LD_VAR 0 9
91104: PUSH
91105: LD_VAR 0 10
91109: LESS
91110: IFFALSE 91132
// begin result := i ;
91112: LD_ADDR_VAR 0 5
91116: PUSH
91117: LD_VAR 0 6
91121: ST_TO_ADDR
// distance := tmp ;
91122: LD_ADDR_VAR 0 10
91126: PUSH
91127: LD_VAR 0 9
91131: ST_TO_ADDR
// end ; end ;
91132: GO 90990
91134: POP
91135: POP
// end ;
91136: LD_VAR 0 5
91140: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91141: LD_INT 0
91143: PPUSH
91144: PPUSH
// if not driver or not IsInUnit ( driver ) then
91145: LD_VAR 0 1
91149: NOT
91150: PUSH
91151: LD_VAR 0 1
91155: PPUSH
91156: CALL_OW 310
91160: NOT
91161: OR
91162: IFFALSE 91166
// exit ;
91164: GO 91256
// vehicle := IsInUnit ( driver ) ;
91166: LD_ADDR_VAR 0 3
91170: PUSH
91171: LD_VAR 0 1
91175: PPUSH
91176: CALL_OW 310
91180: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91181: LD_VAR 0 1
91185: PPUSH
91186: LD_STRING \
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: LD_INT 0
91200: PUSH
91201: LD_INT 0
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: PUSH
91216: LD_STRING E
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 0
91224: PUSH
91225: LD_VAR 0 3
91229: PUSH
91230: LD_INT 0
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: LD_INT 0
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PPUSH
91252: CALL_OW 446
// end ;
91256: LD_VAR 0 2
91260: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91261: LD_INT 0
91263: PPUSH
91264: PPUSH
// if not driver or not IsInUnit ( driver ) then
91265: LD_VAR 0 1
91269: NOT
91270: PUSH
91271: LD_VAR 0 1
91275: PPUSH
91276: CALL_OW 310
91280: NOT
91281: OR
91282: IFFALSE 91286
// exit ;
91284: GO 91376
// vehicle := IsInUnit ( driver ) ;
91286: LD_ADDR_VAR 0 3
91290: PUSH
91291: LD_VAR 0 1
91295: PPUSH
91296: CALL_OW 310
91300: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91301: LD_VAR 0 1
91305: PPUSH
91306: LD_STRING \
91308: PUSH
91309: LD_INT 0
91311: PUSH
91312: LD_INT 0
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: LD_INT 0
91320: PUSH
91321: LD_INT 0
91323: PUSH
91324: LD_INT 0
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: PUSH
91336: LD_STRING E
91338: PUSH
91339: LD_INT 0
91341: PUSH
91342: LD_INT 0
91344: PUSH
91345: LD_VAR 0 3
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: LD_INT 0
91355: PUSH
91356: LD_INT 0
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PPUSH
91372: CALL_OW 447
// end ;
91376: LD_VAR 0 2
91380: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91381: LD_INT 0
91383: PPUSH
91384: PPUSH
91385: PPUSH
// tmp := [ ] ;
91386: LD_ADDR_VAR 0 5
91390: PUSH
91391: EMPTY
91392: ST_TO_ADDR
// for i in units do
91393: LD_ADDR_VAR 0 4
91397: PUSH
91398: LD_VAR 0 1
91402: PUSH
91403: FOR_IN
91404: IFFALSE 91442
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91406: LD_ADDR_VAR 0 5
91410: PUSH
91411: LD_VAR 0 5
91415: PPUSH
91416: LD_VAR 0 5
91420: PUSH
91421: LD_INT 1
91423: PLUS
91424: PPUSH
91425: LD_VAR 0 4
91429: PPUSH
91430: CALL_OW 256
91434: PPUSH
91435: CALL_OW 2
91439: ST_TO_ADDR
91440: GO 91403
91442: POP
91443: POP
// if not tmp then
91444: LD_VAR 0 5
91448: NOT
91449: IFFALSE 91453
// exit ;
91451: GO 91501
// if asc then
91453: LD_VAR 0 2
91457: IFFALSE 91481
// result := SortListByListAsc ( units , tmp ) else
91459: LD_ADDR_VAR 0 3
91463: PUSH
91464: LD_VAR 0 1
91468: PPUSH
91469: LD_VAR 0 5
91473: PPUSH
91474: CALL_OW 76
91478: ST_TO_ADDR
91479: GO 91501
// result := SortListByListDesc ( units , tmp ) ;
91481: LD_ADDR_VAR 0 3
91485: PUSH
91486: LD_VAR 0 1
91490: PPUSH
91491: LD_VAR 0 5
91495: PPUSH
91496: CALL_OW 77
91500: ST_TO_ADDR
// end ;
91501: LD_VAR 0 3
91505: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91506: LD_INT 0
91508: PPUSH
91509: PPUSH
// task := GetTaskList ( mech ) ;
91510: LD_ADDR_VAR 0 4
91514: PUSH
91515: LD_VAR 0 1
91519: PPUSH
91520: CALL_OW 437
91524: ST_TO_ADDR
// if not task then
91525: LD_VAR 0 4
91529: NOT
91530: IFFALSE 91534
// exit ;
91532: GO 91576
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91534: LD_ADDR_VAR 0 3
91538: PUSH
91539: LD_VAR 0 4
91543: PUSH
91544: LD_INT 1
91546: ARRAY
91547: PUSH
91548: LD_INT 1
91550: ARRAY
91551: PUSH
91552: LD_STRING r
91554: EQUAL
91555: PUSH
91556: LD_VAR 0 4
91560: PUSH
91561: LD_INT 1
91563: ARRAY
91564: PUSH
91565: LD_INT 4
91567: ARRAY
91568: PUSH
91569: LD_VAR 0 2
91573: EQUAL
91574: AND
91575: ST_TO_ADDR
// end ;
91576: LD_VAR 0 3
91580: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91581: LD_INT 0
91583: PPUSH
// SetDir ( unit , d ) ;
91584: LD_VAR 0 1
91588: PPUSH
91589: LD_VAR 0 4
91593: PPUSH
91594: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91598: LD_VAR 0 1
91602: PPUSH
91603: LD_VAR 0 2
91607: PPUSH
91608: LD_VAR 0 3
91612: PPUSH
91613: LD_VAR 0 5
91617: PPUSH
91618: CALL_OW 48
// end ;
91622: LD_VAR 0 6
91626: RET
// export function ToNaturalNumber ( number ) ; begin
91627: LD_INT 0
91629: PPUSH
// result := number div 1 ;
91630: LD_ADDR_VAR 0 2
91634: PUSH
91635: LD_VAR 0 1
91639: PUSH
91640: LD_INT 1
91642: DIV
91643: ST_TO_ADDR
// if number < 0 then
91644: LD_VAR 0 1
91648: PUSH
91649: LD_INT 0
91651: LESS
91652: IFFALSE 91662
// result := 0 ;
91654: LD_ADDR_VAR 0 2
91658: PUSH
91659: LD_INT 0
91661: ST_TO_ADDR
// end ;
91662: LD_VAR 0 2
91666: RET
// export function SortByClass ( units , class ) ; var un ; begin
91667: LD_INT 0
91669: PPUSH
91670: PPUSH
// if not units or not class then
91671: LD_VAR 0 1
91675: NOT
91676: PUSH
91677: LD_VAR 0 2
91681: NOT
91682: OR
91683: IFFALSE 91687
// exit ;
91685: GO 91782
// result := [ ] ;
91687: LD_ADDR_VAR 0 3
91691: PUSH
91692: EMPTY
91693: ST_TO_ADDR
// for un in units do
91694: LD_ADDR_VAR 0 4
91698: PUSH
91699: LD_VAR 0 1
91703: PUSH
91704: FOR_IN
91705: IFFALSE 91780
// if GetClass ( un ) = class then
91707: LD_VAR 0 4
91711: PPUSH
91712: CALL_OW 257
91716: PUSH
91717: LD_VAR 0 2
91721: EQUAL
91722: IFFALSE 91749
// result := Insert ( result , 1 , un ) else
91724: LD_ADDR_VAR 0 3
91728: PUSH
91729: LD_VAR 0 3
91733: PPUSH
91734: LD_INT 1
91736: PPUSH
91737: LD_VAR 0 4
91741: PPUSH
91742: CALL_OW 2
91746: ST_TO_ADDR
91747: GO 91778
// result := Replace ( result , result + 1 , un ) ;
91749: LD_ADDR_VAR 0 3
91753: PUSH
91754: LD_VAR 0 3
91758: PPUSH
91759: LD_VAR 0 3
91763: PUSH
91764: LD_INT 1
91766: PLUS
91767: PPUSH
91768: LD_VAR 0 4
91772: PPUSH
91773: CALL_OW 1
91777: ST_TO_ADDR
91778: GO 91704
91780: POP
91781: POP
// end ;
91782: LD_VAR 0 3
91786: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91787: LD_INT 0
91789: PPUSH
91790: PPUSH
91791: PPUSH
91792: PPUSH
91793: PPUSH
91794: PPUSH
91795: PPUSH
// result := [ ] ;
91796: LD_ADDR_VAR 0 4
91800: PUSH
91801: EMPTY
91802: ST_TO_ADDR
// if x - r < 0 then
91803: LD_VAR 0 1
91807: PUSH
91808: LD_VAR 0 3
91812: MINUS
91813: PUSH
91814: LD_INT 0
91816: LESS
91817: IFFALSE 91829
// min_x := 0 else
91819: LD_ADDR_VAR 0 8
91823: PUSH
91824: LD_INT 0
91826: ST_TO_ADDR
91827: GO 91845
// min_x := x - r ;
91829: LD_ADDR_VAR 0 8
91833: PUSH
91834: LD_VAR 0 1
91838: PUSH
91839: LD_VAR 0 3
91843: MINUS
91844: ST_TO_ADDR
// if y - r < 0 then
91845: LD_VAR 0 2
91849: PUSH
91850: LD_VAR 0 3
91854: MINUS
91855: PUSH
91856: LD_INT 0
91858: LESS
91859: IFFALSE 91871
// min_y := 0 else
91861: LD_ADDR_VAR 0 7
91865: PUSH
91866: LD_INT 0
91868: ST_TO_ADDR
91869: GO 91887
// min_y := y - r ;
91871: LD_ADDR_VAR 0 7
91875: PUSH
91876: LD_VAR 0 2
91880: PUSH
91881: LD_VAR 0 3
91885: MINUS
91886: ST_TO_ADDR
// max_x := x + r ;
91887: LD_ADDR_VAR 0 9
91891: PUSH
91892: LD_VAR 0 1
91896: PUSH
91897: LD_VAR 0 3
91901: PLUS
91902: ST_TO_ADDR
// max_y := y + r ;
91903: LD_ADDR_VAR 0 10
91907: PUSH
91908: LD_VAR 0 2
91912: PUSH
91913: LD_VAR 0 3
91917: PLUS
91918: ST_TO_ADDR
// for _x = min_x to max_x do
91919: LD_ADDR_VAR 0 5
91923: PUSH
91924: DOUBLE
91925: LD_VAR 0 8
91929: DEC
91930: ST_TO_ADDR
91931: LD_VAR 0 9
91935: PUSH
91936: FOR_TO
91937: IFFALSE 92038
// for _y = min_y to max_y do
91939: LD_ADDR_VAR 0 6
91943: PUSH
91944: DOUBLE
91945: LD_VAR 0 7
91949: DEC
91950: ST_TO_ADDR
91951: LD_VAR 0 10
91955: PUSH
91956: FOR_TO
91957: IFFALSE 92034
// begin if not ValidHex ( _x , _y ) then
91959: LD_VAR 0 5
91963: PPUSH
91964: LD_VAR 0 6
91968: PPUSH
91969: CALL_OW 488
91973: NOT
91974: IFFALSE 91978
// continue ;
91976: GO 91956
// if GetResourceTypeXY ( _x , _y ) then
91978: LD_VAR 0 5
91982: PPUSH
91983: LD_VAR 0 6
91987: PPUSH
91988: CALL_OW 283
91992: IFFALSE 92032
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91994: LD_ADDR_VAR 0 4
91998: PUSH
91999: LD_VAR 0 4
92003: PPUSH
92004: LD_VAR 0 4
92008: PUSH
92009: LD_INT 1
92011: PLUS
92012: PPUSH
92013: LD_VAR 0 5
92017: PUSH
92018: LD_VAR 0 6
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PPUSH
92027: CALL_OW 1
92031: ST_TO_ADDR
// end ;
92032: GO 91956
92034: POP
92035: POP
92036: GO 91936
92038: POP
92039: POP
// end ;
92040: LD_VAR 0 4
92044: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92045: LD_INT 0
92047: PPUSH
92048: PPUSH
92049: PPUSH
92050: PPUSH
92051: PPUSH
92052: PPUSH
92053: PPUSH
92054: PPUSH
// if not units then
92055: LD_VAR 0 1
92059: NOT
92060: IFFALSE 92064
// exit ;
92062: GO 92590
// result := UnitFilter ( units , [ f_ok ] ) ;
92064: LD_ADDR_VAR 0 3
92068: PUSH
92069: LD_VAR 0 1
92073: PPUSH
92074: LD_INT 50
92076: PUSH
92077: EMPTY
92078: LIST
92079: PPUSH
92080: CALL_OW 72
92084: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92085: LD_ADDR_VAR 0 8
92089: PUSH
92090: LD_VAR 0 1
92094: PUSH
92095: LD_INT 1
92097: ARRAY
92098: PPUSH
92099: CALL_OW 255
92103: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92104: LD_ADDR_VAR 0 10
92108: PUSH
92109: LD_INT 29
92111: PUSH
92112: LD_EXP 78
92116: PUSH
92117: LD_INT 49
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: ST_TO_ADDR
// if not result then
92125: LD_VAR 0 3
92129: NOT
92130: IFFALSE 92134
// exit ;
92132: GO 92590
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92134: LD_ADDR_VAR 0 5
92138: PUSH
92139: LD_INT 81
92141: PUSH
92142: LD_VAR 0 8
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PPUSH
92151: CALL_OW 69
92155: ST_TO_ADDR
// for i in result do
92156: LD_ADDR_VAR 0 4
92160: PUSH
92161: LD_VAR 0 3
92165: PUSH
92166: FOR_IN
92167: IFFALSE 92588
// begin tag := GetTag ( i ) + 1 ;
92169: LD_ADDR_VAR 0 9
92173: PUSH
92174: LD_VAR 0 4
92178: PPUSH
92179: CALL_OW 110
92183: PUSH
92184: LD_INT 1
92186: PLUS
92187: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92188: LD_ADDR_VAR 0 7
92192: PUSH
92193: LD_VAR 0 4
92197: PPUSH
92198: CALL_OW 250
92202: PPUSH
92203: LD_VAR 0 4
92207: PPUSH
92208: CALL_OW 251
92212: PPUSH
92213: LD_INT 6
92215: PPUSH
92216: CALL 91787 0 3
92220: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92221: LD_VAR 0 4
92225: PPUSH
92226: CALL_OW 247
92230: PUSH
92231: LD_INT 2
92233: EQUAL
92234: PUSH
92235: LD_VAR 0 7
92239: AND
92240: PUSH
92241: LD_VAR 0 4
92245: PPUSH
92246: CALL_OW 264
92250: PUSH
92251: LD_VAR 0 10
92255: IN
92256: NOT
92257: AND
92258: IFFALSE 92297
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92260: LD_VAR 0 4
92264: PPUSH
92265: LD_VAR 0 7
92269: PUSH
92270: LD_INT 1
92272: ARRAY
92273: PUSH
92274: LD_INT 1
92276: ARRAY
92277: PPUSH
92278: LD_VAR 0 7
92282: PUSH
92283: LD_INT 1
92285: ARRAY
92286: PUSH
92287: LD_INT 2
92289: ARRAY
92290: PPUSH
92291: CALL_OW 116
92295: GO 92586
// if path > tag then
92297: LD_VAR 0 2
92301: PUSH
92302: LD_VAR 0 9
92306: GREATER
92307: IFFALSE 92515
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92309: LD_ADDR_VAR 0 6
92313: PUSH
92314: LD_VAR 0 5
92318: PPUSH
92319: LD_INT 91
92321: PUSH
92322: LD_VAR 0 4
92326: PUSH
92327: LD_INT 8
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: LIST
92334: PPUSH
92335: CALL_OW 72
92339: ST_TO_ADDR
// if nearEnemy then
92340: LD_VAR 0 6
92344: IFFALSE 92413
// begin if GetWeapon ( i ) = ru_time_lapser then
92346: LD_VAR 0 4
92350: PPUSH
92351: CALL_OW 264
92355: PUSH
92356: LD_INT 49
92358: EQUAL
92359: IFFALSE 92387
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92361: LD_VAR 0 4
92365: PPUSH
92366: LD_VAR 0 6
92370: PPUSH
92371: LD_VAR 0 4
92375: PPUSH
92376: CALL_OW 74
92380: PPUSH
92381: CALL_OW 112
92385: GO 92411
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92387: LD_VAR 0 4
92391: PPUSH
92392: LD_VAR 0 6
92396: PPUSH
92397: LD_VAR 0 4
92401: PPUSH
92402: CALL_OW 74
92406: PPUSH
92407: CALL_OW 115
// end else
92411: GO 92513
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92413: LD_VAR 0 4
92417: PPUSH
92418: LD_VAR 0 2
92422: PUSH
92423: LD_VAR 0 9
92427: ARRAY
92428: PUSH
92429: LD_INT 1
92431: ARRAY
92432: PPUSH
92433: LD_VAR 0 2
92437: PUSH
92438: LD_VAR 0 9
92442: ARRAY
92443: PUSH
92444: LD_INT 2
92446: ARRAY
92447: PPUSH
92448: CALL_OW 297
92452: PUSH
92453: LD_INT 6
92455: GREATER
92456: IFFALSE 92499
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92458: LD_VAR 0 4
92462: PPUSH
92463: LD_VAR 0 2
92467: PUSH
92468: LD_VAR 0 9
92472: ARRAY
92473: PUSH
92474: LD_INT 1
92476: ARRAY
92477: PPUSH
92478: LD_VAR 0 2
92482: PUSH
92483: LD_VAR 0 9
92487: ARRAY
92488: PUSH
92489: LD_INT 2
92491: ARRAY
92492: PPUSH
92493: CALL_OW 114
92497: GO 92513
// SetTag ( i , tag ) ;
92499: LD_VAR 0 4
92503: PPUSH
92504: LD_VAR 0 9
92508: PPUSH
92509: CALL_OW 109
// end else
92513: GO 92586
// if enemy then
92515: LD_VAR 0 5
92519: IFFALSE 92586
// begin if GetWeapon ( i ) = ru_time_lapser then
92521: LD_VAR 0 4
92525: PPUSH
92526: CALL_OW 264
92530: PUSH
92531: LD_INT 49
92533: EQUAL
92534: IFFALSE 92562
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92536: LD_VAR 0 4
92540: PPUSH
92541: LD_VAR 0 5
92545: PPUSH
92546: LD_VAR 0 4
92550: PPUSH
92551: CALL_OW 74
92555: PPUSH
92556: CALL_OW 112
92560: GO 92586
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92562: LD_VAR 0 4
92566: PPUSH
92567: LD_VAR 0 5
92571: PPUSH
92572: LD_VAR 0 4
92576: PPUSH
92577: CALL_OW 74
92581: PPUSH
92582: CALL_OW 115
// end ; end ;
92586: GO 92166
92588: POP
92589: POP
// end ;
92590: LD_VAR 0 3
92594: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92595: LD_INT 0
92597: PPUSH
92598: PPUSH
92599: PPUSH
// if not unit or IsInUnit ( unit ) then
92600: LD_VAR 0 1
92604: NOT
92605: PUSH
92606: LD_VAR 0 1
92610: PPUSH
92611: CALL_OW 310
92615: OR
92616: IFFALSE 92620
// exit ;
92618: GO 92711
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92620: LD_ADDR_VAR 0 4
92624: PUSH
92625: LD_VAR 0 1
92629: PPUSH
92630: CALL_OW 250
92634: PPUSH
92635: LD_VAR 0 2
92639: PPUSH
92640: LD_INT 1
92642: PPUSH
92643: CALL_OW 272
92647: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92648: LD_ADDR_VAR 0 5
92652: PUSH
92653: LD_VAR 0 1
92657: PPUSH
92658: CALL_OW 251
92662: PPUSH
92663: LD_VAR 0 2
92667: PPUSH
92668: LD_INT 1
92670: PPUSH
92671: CALL_OW 273
92675: ST_TO_ADDR
// if ValidHex ( x , y ) then
92676: LD_VAR 0 4
92680: PPUSH
92681: LD_VAR 0 5
92685: PPUSH
92686: CALL_OW 488
92690: IFFALSE 92711
// ComTurnXY ( unit , x , y ) ;
92692: LD_VAR 0 1
92696: PPUSH
92697: LD_VAR 0 4
92701: PPUSH
92702: LD_VAR 0 5
92706: PPUSH
92707: CALL_OW 118
// end ;
92711: LD_VAR 0 3
92715: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92716: LD_INT 0
92718: PPUSH
92719: PPUSH
// result := false ;
92720: LD_ADDR_VAR 0 3
92724: PUSH
92725: LD_INT 0
92727: ST_TO_ADDR
// if not units then
92728: LD_VAR 0 2
92732: NOT
92733: IFFALSE 92737
// exit ;
92735: GO 92782
// for i in units do
92737: LD_ADDR_VAR 0 4
92741: PUSH
92742: LD_VAR 0 2
92746: PUSH
92747: FOR_IN
92748: IFFALSE 92780
// if See ( side , i ) then
92750: LD_VAR 0 1
92754: PPUSH
92755: LD_VAR 0 4
92759: PPUSH
92760: CALL_OW 292
92764: IFFALSE 92778
// begin result := true ;
92766: LD_ADDR_VAR 0 3
92770: PUSH
92771: LD_INT 1
92773: ST_TO_ADDR
// exit ;
92774: POP
92775: POP
92776: GO 92782
// end ;
92778: GO 92747
92780: POP
92781: POP
// end ;
92782: LD_VAR 0 3
92786: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92787: LD_INT 0
92789: PPUSH
92790: PPUSH
92791: PPUSH
92792: PPUSH
// if not unit or not points then
92793: LD_VAR 0 1
92797: NOT
92798: PUSH
92799: LD_VAR 0 2
92803: NOT
92804: OR
92805: IFFALSE 92809
// exit ;
92807: GO 92899
// dist := 99999 ;
92809: LD_ADDR_VAR 0 5
92813: PUSH
92814: LD_INT 99999
92816: ST_TO_ADDR
// for i in points do
92817: LD_ADDR_VAR 0 4
92821: PUSH
92822: LD_VAR 0 2
92826: PUSH
92827: FOR_IN
92828: IFFALSE 92897
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92830: LD_ADDR_VAR 0 6
92834: PUSH
92835: LD_VAR 0 1
92839: PPUSH
92840: LD_VAR 0 4
92844: PUSH
92845: LD_INT 1
92847: ARRAY
92848: PPUSH
92849: LD_VAR 0 4
92853: PUSH
92854: LD_INT 2
92856: ARRAY
92857: PPUSH
92858: CALL_OW 297
92862: ST_TO_ADDR
// if tmpDist < dist then
92863: LD_VAR 0 6
92867: PUSH
92868: LD_VAR 0 5
92872: LESS
92873: IFFALSE 92895
// begin result := i ;
92875: LD_ADDR_VAR 0 3
92879: PUSH
92880: LD_VAR 0 4
92884: ST_TO_ADDR
// dist := tmpDist ;
92885: LD_ADDR_VAR 0 5
92889: PUSH
92890: LD_VAR 0 6
92894: ST_TO_ADDR
// end ; end ;
92895: GO 92827
92897: POP
92898: POP
// end ;
92899: LD_VAR 0 3
92903: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92904: LD_INT 0
92906: PPUSH
// uc_side := side ;
92907: LD_ADDR_OWVAR 20
92911: PUSH
92912: LD_VAR 0 1
92916: ST_TO_ADDR
// uc_nation := 3 ;
92917: LD_ADDR_OWVAR 21
92921: PUSH
92922: LD_INT 3
92924: ST_TO_ADDR
// vc_chassis := 25 ;
92925: LD_ADDR_OWVAR 37
92929: PUSH
92930: LD_INT 25
92932: ST_TO_ADDR
// vc_engine := engine_siberite ;
92933: LD_ADDR_OWVAR 39
92937: PUSH
92938: LD_INT 3
92940: ST_TO_ADDR
// vc_control := control_computer ;
92941: LD_ADDR_OWVAR 38
92945: PUSH
92946: LD_INT 3
92948: ST_TO_ADDR
// vc_weapon := 59 ;
92949: LD_ADDR_OWVAR 40
92953: PUSH
92954: LD_INT 59
92956: ST_TO_ADDR
// result := CreateVehicle ;
92957: LD_ADDR_VAR 0 5
92961: PUSH
92962: CALL_OW 45
92966: ST_TO_ADDR
// SetDir ( result , d ) ;
92967: LD_VAR 0 5
92971: PPUSH
92972: LD_VAR 0 4
92976: PPUSH
92977: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
92981: LD_VAR 0 5
92985: PPUSH
92986: LD_VAR 0 2
92990: PPUSH
92991: LD_VAR 0 3
92995: PPUSH
92996: LD_INT 0
92998: PPUSH
92999: CALL_OW 48
// end ;
93003: LD_VAR 0 5
93007: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93008: LD_INT 0
93010: PPUSH
93011: PPUSH
93012: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93013: LD_ADDR_VAR 0 2
93017: PUSH
93018: LD_INT 0
93020: PUSH
93021: LD_INT 0
93023: PUSH
93024: LD_INT 0
93026: PUSH
93027: LD_INT 0
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93036: LD_VAR 0 1
93040: NOT
93041: PUSH
93042: LD_VAR 0 1
93046: PPUSH
93047: CALL_OW 264
93051: PUSH
93052: LD_INT 12
93054: PUSH
93055: LD_INT 51
93057: PUSH
93058: LD_INT 32
93060: PUSH
93061: LD_EXP 75
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: IN
93072: NOT
93073: OR
93074: IFFALSE 93078
// exit ;
93076: GO 93176
// for i := 1 to 3 do
93078: LD_ADDR_VAR 0 3
93082: PUSH
93083: DOUBLE
93084: LD_INT 1
93086: DEC
93087: ST_TO_ADDR
93088: LD_INT 3
93090: PUSH
93091: FOR_TO
93092: IFFALSE 93174
// begin tmp := GetCargo ( cargo , i ) ;
93094: LD_ADDR_VAR 0 4
93098: PUSH
93099: LD_VAR 0 1
93103: PPUSH
93104: LD_VAR 0 3
93108: PPUSH
93109: CALL_OW 289
93113: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93114: LD_ADDR_VAR 0 2
93118: PUSH
93119: LD_VAR 0 2
93123: PPUSH
93124: LD_VAR 0 3
93128: PPUSH
93129: LD_VAR 0 4
93133: PPUSH
93134: CALL_OW 1
93138: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93139: LD_ADDR_VAR 0 2
93143: PUSH
93144: LD_VAR 0 2
93148: PPUSH
93149: LD_INT 4
93151: PPUSH
93152: LD_VAR 0 2
93156: PUSH
93157: LD_INT 4
93159: ARRAY
93160: PUSH
93161: LD_VAR 0 4
93165: PLUS
93166: PPUSH
93167: CALL_OW 1
93171: ST_TO_ADDR
// end ;
93172: GO 93091
93174: POP
93175: POP
// end ;
93176: LD_VAR 0 2
93180: RET
// export function Length ( array ) ; begin
93181: LD_INT 0
93183: PPUSH
// result := array + 0 ;
93184: LD_ADDR_VAR 0 2
93188: PUSH
93189: LD_VAR 0 1
93193: PUSH
93194: LD_INT 0
93196: PLUS
93197: ST_TO_ADDR
// end ;
93198: LD_VAR 0 2
93202: RET
// export function PrepareArray ( array ) ; begin
93203: LD_INT 0
93205: PPUSH
// result := array diff 0 ;
93206: LD_ADDR_VAR 0 2
93210: PUSH
93211: LD_VAR 0 1
93215: PUSH
93216: LD_INT 0
93218: DIFF
93219: ST_TO_ADDR
// if not result [ 1 ] then
93220: LD_VAR 0 2
93224: PUSH
93225: LD_INT 1
93227: ARRAY
93228: NOT
93229: IFFALSE 93249
// result := Delete ( result , 1 ) ;
93231: LD_ADDR_VAR 0 2
93235: PUSH
93236: LD_VAR 0 2
93240: PPUSH
93241: LD_INT 1
93243: PPUSH
93244: CALL_OW 3
93248: ST_TO_ADDR
// end ; end_of_file end_of_file
93249: LD_VAR 0 2
93253: RET
// every 0 0$1 do
93254: GO 93256
93256: DISABLE
// begin enable ;
93257: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93258: LD_STRING updateTimer(
93260: PUSH
93261: LD_OWVAR 1
93265: STR
93266: PUSH
93267: LD_STRING );
93269: STR
93270: PPUSH
93271: CALL_OW 559
// end ;
93275: END
// export function SOS_MapStart ( ) ; begin
93276: LD_INT 0
93278: PPUSH
// if streamModeActive then
93279: LD_EXP 138
93283: IFFALSE 93292
// DefineStreamItems ( true ) ;
93285: LD_INT 1
93287: PPUSH
93288: CALL 94946 0 1
// UpdateFactoryWaypoints ( ) ;
93292: CALL 107807 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93296: CALL 108064 0 0
// end ;
93300: LD_VAR 0 1
93304: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93305: LD_INT 0
93307: PPUSH
// if p2 = 100 then
93308: LD_VAR 0 2
93312: PUSH
93313: LD_INT 100
93315: EQUAL
93316: IFFALSE 94319
// begin if not StreamModeActive then
93318: LD_EXP 138
93322: NOT
93323: IFFALSE 93333
// StreamModeActive := true ;
93325: LD_ADDR_EXP 138
93329: PUSH
93330: LD_INT 1
93332: ST_TO_ADDR
// if p3 = 0 then
93333: LD_VAR 0 3
93337: PUSH
93338: LD_INT 0
93340: EQUAL
93341: IFFALSE 93347
// InitStreamMode ;
93343: CALL 94482 0 0
// if p3 = 1 then
93347: LD_VAR 0 3
93351: PUSH
93352: LD_INT 1
93354: EQUAL
93355: IFFALSE 93365
// sRocket := true ;
93357: LD_ADDR_EXP 143
93361: PUSH
93362: LD_INT 1
93364: ST_TO_ADDR
// if p3 = 2 then
93365: LD_VAR 0 3
93369: PUSH
93370: LD_INT 2
93372: EQUAL
93373: IFFALSE 93383
// sSpeed := true ;
93375: LD_ADDR_EXP 142
93379: PUSH
93380: LD_INT 1
93382: ST_TO_ADDR
// if p3 = 3 then
93383: LD_VAR 0 3
93387: PUSH
93388: LD_INT 3
93390: EQUAL
93391: IFFALSE 93401
// sEngine := true ;
93393: LD_ADDR_EXP 144
93397: PUSH
93398: LD_INT 1
93400: ST_TO_ADDR
// if p3 = 4 then
93401: LD_VAR 0 3
93405: PUSH
93406: LD_INT 4
93408: EQUAL
93409: IFFALSE 93419
// sSpec := true ;
93411: LD_ADDR_EXP 141
93415: PUSH
93416: LD_INT 1
93418: ST_TO_ADDR
// if p3 = 5 then
93419: LD_VAR 0 3
93423: PUSH
93424: LD_INT 5
93426: EQUAL
93427: IFFALSE 93437
// sLevel := true ;
93429: LD_ADDR_EXP 145
93433: PUSH
93434: LD_INT 1
93436: ST_TO_ADDR
// if p3 = 6 then
93437: LD_VAR 0 3
93441: PUSH
93442: LD_INT 6
93444: EQUAL
93445: IFFALSE 93455
// sArmoury := true ;
93447: LD_ADDR_EXP 146
93451: PUSH
93452: LD_INT 1
93454: ST_TO_ADDR
// if p3 = 7 then
93455: LD_VAR 0 3
93459: PUSH
93460: LD_INT 7
93462: EQUAL
93463: IFFALSE 93473
// sRadar := true ;
93465: LD_ADDR_EXP 147
93469: PUSH
93470: LD_INT 1
93472: ST_TO_ADDR
// if p3 = 8 then
93473: LD_VAR 0 3
93477: PUSH
93478: LD_INT 8
93480: EQUAL
93481: IFFALSE 93491
// sBunker := true ;
93483: LD_ADDR_EXP 148
93487: PUSH
93488: LD_INT 1
93490: ST_TO_ADDR
// if p3 = 9 then
93491: LD_VAR 0 3
93495: PUSH
93496: LD_INT 9
93498: EQUAL
93499: IFFALSE 93509
// sHack := true ;
93501: LD_ADDR_EXP 149
93505: PUSH
93506: LD_INT 1
93508: ST_TO_ADDR
// if p3 = 10 then
93509: LD_VAR 0 3
93513: PUSH
93514: LD_INT 10
93516: EQUAL
93517: IFFALSE 93527
// sFire := true ;
93519: LD_ADDR_EXP 150
93523: PUSH
93524: LD_INT 1
93526: ST_TO_ADDR
// if p3 = 11 then
93527: LD_VAR 0 3
93531: PUSH
93532: LD_INT 11
93534: EQUAL
93535: IFFALSE 93545
// sRefresh := true ;
93537: LD_ADDR_EXP 151
93541: PUSH
93542: LD_INT 1
93544: ST_TO_ADDR
// if p3 = 12 then
93545: LD_VAR 0 3
93549: PUSH
93550: LD_INT 12
93552: EQUAL
93553: IFFALSE 93563
// sExp := true ;
93555: LD_ADDR_EXP 152
93559: PUSH
93560: LD_INT 1
93562: ST_TO_ADDR
// if p3 = 13 then
93563: LD_VAR 0 3
93567: PUSH
93568: LD_INT 13
93570: EQUAL
93571: IFFALSE 93581
// sDepot := true ;
93573: LD_ADDR_EXP 153
93577: PUSH
93578: LD_INT 1
93580: ST_TO_ADDR
// if p3 = 14 then
93581: LD_VAR 0 3
93585: PUSH
93586: LD_INT 14
93588: EQUAL
93589: IFFALSE 93599
// sFlag := true ;
93591: LD_ADDR_EXP 154
93595: PUSH
93596: LD_INT 1
93598: ST_TO_ADDR
// if p3 = 15 then
93599: LD_VAR 0 3
93603: PUSH
93604: LD_INT 15
93606: EQUAL
93607: IFFALSE 93617
// sKamikadze := true ;
93609: LD_ADDR_EXP 162
93613: PUSH
93614: LD_INT 1
93616: ST_TO_ADDR
// if p3 = 16 then
93617: LD_VAR 0 3
93621: PUSH
93622: LD_INT 16
93624: EQUAL
93625: IFFALSE 93635
// sTroll := true ;
93627: LD_ADDR_EXP 163
93631: PUSH
93632: LD_INT 1
93634: ST_TO_ADDR
// if p3 = 17 then
93635: LD_VAR 0 3
93639: PUSH
93640: LD_INT 17
93642: EQUAL
93643: IFFALSE 93653
// sSlow := true ;
93645: LD_ADDR_EXP 164
93649: PUSH
93650: LD_INT 1
93652: ST_TO_ADDR
// if p3 = 18 then
93653: LD_VAR 0 3
93657: PUSH
93658: LD_INT 18
93660: EQUAL
93661: IFFALSE 93671
// sLack := true ;
93663: LD_ADDR_EXP 165
93667: PUSH
93668: LD_INT 1
93670: ST_TO_ADDR
// if p3 = 19 then
93671: LD_VAR 0 3
93675: PUSH
93676: LD_INT 19
93678: EQUAL
93679: IFFALSE 93689
// sTank := true ;
93681: LD_ADDR_EXP 167
93685: PUSH
93686: LD_INT 1
93688: ST_TO_ADDR
// if p3 = 20 then
93689: LD_VAR 0 3
93693: PUSH
93694: LD_INT 20
93696: EQUAL
93697: IFFALSE 93707
// sRemote := true ;
93699: LD_ADDR_EXP 168
93703: PUSH
93704: LD_INT 1
93706: ST_TO_ADDR
// if p3 = 21 then
93707: LD_VAR 0 3
93711: PUSH
93712: LD_INT 21
93714: EQUAL
93715: IFFALSE 93725
// sPowell := true ;
93717: LD_ADDR_EXP 169
93721: PUSH
93722: LD_INT 1
93724: ST_TO_ADDR
// if p3 = 22 then
93725: LD_VAR 0 3
93729: PUSH
93730: LD_INT 22
93732: EQUAL
93733: IFFALSE 93743
// sTeleport := true ;
93735: LD_ADDR_EXP 172
93739: PUSH
93740: LD_INT 1
93742: ST_TO_ADDR
// if p3 = 23 then
93743: LD_VAR 0 3
93747: PUSH
93748: LD_INT 23
93750: EQUAL
93751: IFFALSE 93761
// sOilTower := true ;
93753: LD_ADDR_EXP 174
93757: PUSH
93758: LD_INT 1
93760: ST_TO_ADDR
// if p3 = 24 then
93761: LD_VAR 0 3
93765: PUSH
93766: LD_INT 24
93768: EQUAL
93769: IFFALSE 93779
// sShovel := true ;
93771: LD_ADDR_EXP 175
93775: PUSH
93776: LD_INT 1
93778: ST_TO_ADDR
// if p3 = 25 then
93779: LD_VAR 0 3
93783: PUSH
93784: LD_INT 25
93786: EQUAL
93787: IFFALSE 93797
// sSheik := true ;
93789: LD_ADDR_EXP 176
93793: PUSH
93794: LD_INT 1
93796: ST_TO_ADDR
// if p3 = 26 then
93797: LD_VAR 0 3
93801: PUSH
93802: LD_INT 26
93804: EQUAL
93805: IFFALSE 93815
// sEarthquake := true ;
93807: LD_ADDR_EXP 178
93811: PUSH
93812: LD_INT 1
93814: ST_TO_ADDR
// if p3 = 27 then
93815: LD_VAR 0 3
93819: PUSH
93820: LD_INT 27
93822: EQUAL
93823: IFFALSE 93833
// sAI := true ;
93825: LD_ADDR_EXP 179
93829: PUSH
93830: LD_INT 1
93832: ST_TO_ADDR
// if p3 = 28 then
93833: LD_VAR 0 3
93837: PUSH
93838: LD_INT 28
93840: EQUAL
93841: IFFALSE 93851
// sCargo := true ;
93843: LD_ADDR_EXP 182
93847: PUSH
93848: LD_INT 1
93850: ST_TO_ADDR
// if p3 = 29 then
93851: LD_VAR 0 3
93855: PUSH
93856: LD_INT 29
93858: EQUAL
93859: IFFALSE 93869
// sDLaser := true ;
93861: LD_ADDR_EXP 183
93865: PUSH
93866: LD_INT 1
93868: ST_TO_ADDR
// if p3 = 30 then
93869: LD_VAR 0 3
93873: PUSH
93874: LD_INT 30
93876: EQUAL
93877: IFFALSE 93887
// sExchange := true ;
93879: LD_ADDR_EXP 184
93883: PUSH
93884: LD_INT 1
93886: ST_TO_ADDR
// if p3 = 31 then
93887: LD_VAR 0 3
93891: PUSH
93892: LD_INT 31
93894: EQUAL
93895: IFFALSE 93905
// sFac := true ;
93897: LD_ADDR_EXP 185
93901: PUSH
93902: LD_INT 1
93904: ST_TO_ADDR
// if p3 = 32 then
93905: LD_VAR 0 3
93909: PUSH
93910: LD_INT 32
93912: EQUAL
93913: IFFALSE 93923
// sPower := true ;
93915: LD_ADDR_EXP 186
93919: PUSH
93920: LD_INT 1
93922: ST_TO_ADDR
// if p3 = 33 then
93923: LD_VAR 0 3
93927: PUSH
93928: LD_INT 33
93930: EQUAL
93931: IFFALSE 93941
// sRandom := true ;
93933: LD_ADDR_EXP 187
93937: PUSH
93938: LD_INT 1
93940: ST_TO_ADDR
// if p3 = 34 then
93941: LD_VAR 0 3
93945: PUSH
93946: LD_INT 34
93948: EQUAL
93949: IFFALSE 93959
// sShield := true ;
93951: LD_ADDR_EXP 188
93955: PUSH
93956: LD_INT 1
93958: ST_TO_ADDR
// if p3 = 35 then
93959: LD_VAR 0 3
93963: PUSH
93964: LD_INT 35
93966: EQUAL
93967: IFFALSE 93977
// sTime := true ;
93969: LD_ADDR_EXP 189
93973: PUSH
93974: LD_INT 1
93976: ST_TO_ADDR
// if p3 = 36 then
93977: LD_VAR 0 3
93981: PUSH
93982: LD_INT 36
93984: EQUAL
93985: IFFALSE 93995
// sTools := true ;
93987: LD_ADDR_EXP 190
93991: PUSH
93992: LD_INT 1
93994: ST_TO_ADDR
// if p3 = 101 then
93995: LD_VAR 0 3
93999: PUSH
94000: LD_INT 101
94002: EQUAL
94003: IFFALSE 94013
// sSold := true ;
94005: LD_ADDR_EXP 155
94009: PUSH
94010: LD_INT 1
94012: ST_TO_ADDR
// if p3 = 102 then
94013: LD_VAR 0 3
94017: PUSH
94018: LD_INT 102
94020: EQUAL
94021: IFFALSE 94031
// sDiff := true ;
94023: LD_ADDR_EXP 156
94027: PUSH
94028: LD_INT 1
94030: ST_TO_ADDR
// if p3 = 103 then
94031: LD_VAR 0 3
94035: PUSH
94036: LD_INT 103
94038: EQUAL
94039: IFFALSE 94049
// sFog := true ;
94041: LD_ADDR_EXP 159
94045: PUSH
94046: LD_INT 1
94048: ST_TO_ADDR
// if p3 = 104 then
94049: LD_VAR 0 3
94053: PUSH
94054: LD_INT 104
94056: EQUAL
94057: IFFALSE 94067
// sReset := true ;
94059: LD_ADDR_EXP 160
94063: PUSH
94064: LD_INT 1
94066: ST_TO_ADDR
// if p3 = 105 then
94067: LD_VAR 0 3
94071: PUSH
94072: LD_INT 105
94074: EQUAL
94075: IFFALSE 94085
// sSun := true ;
94077: LD_ADDR_EXP 161
94081: PUSH
94082: LD_INT 1
94084: ST_TO_ADDR
// if p3 = 106 then
94085: LD_VAR 0 3
94089: PUSH
94090: LD_INT 106
94092: EQUAL
94093: IFFALSE 94103
// sTiger := true ;
94095: LD_ADDR_EXP 157
94099: PUSH
94100: LD_INT 1
94102: ST_TO_ADDR
// if p3 = 107 then
94103: LD_VAR 0 3
94107: PUSH
94108: LD_INT 107
94110: EQUAL
94111: IFFALSE 94121
// sBomb := true ;
94113: LD_ADDR_EXP 158
94117: PUSH
94118: LD_INT 1
94120: ST_TO_ADDR
// if p3 = 108 then
94121: LD_VAR 0 3
94125: PUSH
94126: LD_INT 108
94128: EQUAL
94129: IFFALSE 94139
// sWound := true ;
94131: LD_ADDR_EXP 166
94135: PUSH
94136: LD_INT 1
94138: ST_TO_ADDR
// if p3 = 109 then
94139: LD_VAR 0 3
94143: PUSH
94144: LD_INT 109
94146: EQUAL
94147: IFFALSE 94157
// sBetray := true ;
94149: LD_ADDR_EXP 170
94153: PUSH
94154: LD_INT 1
94156: ST_TO_ADDR
// if p3 = 110 then
94157: LD_VAR 0 3
94161: PUSH
94162: LD_INT 110
94164: EQUAL
94165: IFFALSE 94175
// sContamin := true ;
94167: LD_ADDR_EXP 171
94171: PUSH
94172: LD_INT 1
94174: ST_TO_ADDR
// if p3 = 111 then
94175: LD_VAR 0 3
94179: PUSH
94180: LD_INT 111
94182: EQUAL
94183: IFFALSE 94193
// sOil := true ;
94185: LD_ADDR_EXP 173
94189: PUSH
94190: LD_INT 1
94192: ST_TO_ADDR
// if p3 = 112 then
94193: LD_VAR 0 3
94197: PUSH
94198: LD_INT 112
94200: EQUAL
94201: IFFALSE 94211
// sStu := true ;
94203: LD_ADDR_EXP 177
94207: PUSH
94208: LD_INT 1
94210: ST_TO_ADDR
// if p3 = 113 then
94211: LD_VAR 0 3
94215: PUSH
94216: LD_INT 113
94218: EQUAL
94219: IFFALSE 94229
// sBazooka := true ;
94221: LD_ADDR_EXP 180
94225: PUSH
94226: LD_INT 1
94228: ST_TO_ADDR
// if p3 = 114 then
94229: LD_VAR 0 3
94233: PUSH
94234: LD_INT 114
94236: EQUAL
94237: IFFALSE 94247
// sMortar := true ;
94239: LD_ADDR_EXP 181
94243: PUSH
94244: LD_INT 1
94246: ST_TO_ADDR
// if p3 = 115 then
94247: LD_VAR 0 3
94251: PUSH
94252: LD_INT 115
94254: EQUAL
94255: IFFALSE 94265
// sRanger := true ;
94257: LD_ADDR_EXP 191
94261: PUSH
94262: LD_INT 1
94264: ST_TO_ADDR
// if p3 = 116 then
94265: LD_VAR 0 3
94269: PUSH
94270: LD_INT 116
94272: EQUAL
94273: IFFALSE 94283
// sComputer := true ;
94275: LD_ADDR_EXP 192
94279: PUSH
94280: LD_INT 1
94282: ST_TO_ADDR
// if p3 = 117 then
94283: LD_VAR 0 3
94287: PUSH
94288: LD_INT 117
94290: EQUAL
94291: IFFALSE 94301
// s30 := true ;
94293: LD_ADDR_EXP 193
94297: PUSH
94298: LD_INT 1
94300: ST_TO_ADDR
// if p3 = 118 then
94301: LD_VAR 0 3
94305: PUSH
94306: LD_INT 118
94308: EQUAL
94309: IFFALSE 94319
// s60 := true ;
94311: LD_ADDR_EXP 194
94315: PUSH
94316: LD_INT 1
94318: ST_TO_ADDR
// end ; if p2 = 101 then
94319: LD_VAR 0 2
94323: PUSH
94324: LD_INT 101
94326: EQUAL
94327: IFFALSE 94455
// begin case p3 of 1 :
94329: LD_VAR 0 3
94333: PUSH
94334: LD_INT 1
94336: DOUBLE
94337: EQUAL
94338: IFTRUE 94342
94340: GO 94349
94342: POP
// hHackUnlimitedResources ; 2 :
94343: CALL 106553 0 0
94347: GO 94455
94349: LD_INT 2
94351: DOUBLE
94352: EQUAL
94353: IFTRUE 94357
94355: GO 94364
94357: POP
// hHackSetLevel10 ; 3 :
94358: CALL 106686 0 0
94362: GO 94455
94364: LD_INT 3
94366: DOUBLE
94367: EQUAL
94368: IFTRUE 94372
94370: GO 94379
94372: POP
// hHackSetLevel10YourUnits ; 4 :
94373: CALL 106771 0 0
94377: GO 94455
94379: LD_INT 4
94381: DOUBLE
94382: EQUAL
94383: IFTRUE 94387
94385: GO 94394
94387: POP
// hHackInvincible ; 5 :
94388: CALL 107219 0 0
94392: GO 94455
94394: LD_INT 5
94396: DOUBLE
94397: EQUAL
94398: IFTRUE 94402
94400: GO 94409
94402: POP
// hHackInvisible ; 6 :
94403: CALL 107330 0 0
94407: GO 94455
94409: LD_INT 6
94411: DOUBLE
94412: EQUAL
94413: IFTRUE 94417
94415: GO 94424
94417: POP
// hHackChangeYourSide ; 7 :
94418: CALL 107387 0 0
94422: GO 94455
94424: LD_INT 7
94426: DOUBLE
94427: EQUAL
94428: IFTRUE 94432
94430: GO 94439
94432: POP
// hHackChangeUnitSide ; 8 :
94433: CALL 107429 0 0
94437: GO 94455
94439: LD_INT 8
94441: DOUBLE
94442: EQUAL
94443: IFTRUE 94447
94445: GO 94454
94447: POP
// hHackFog ; end ;
94448: CALL 107530 0 0
94452: GO 94455
94454: POP
// end ; end ;
94455: LD_VAR 0 7
94459: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94460: GO 94462
94462: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94463: LD_STRING initStreamRollete();
94465: PPUSH
94466: CALL_OW 559
// InitStreamMode ;
94470: CALL 94482 0 0
// DefineStreamItems ( false ) ;
94474: LD_INT 0
94476: PPUSH
94477: CALL 94946 0 1
// end ;
94481: END
// function InitStreamMode ; begin
94482: LD_INT 0
94484: PPUSH
// streamModeActive := false ;
94485: LD_ADDR_EXP 138
94489: PUSH
94490: LD_INT 0
94492: ST_TO_ADDR
// normalCounter := 36 ;
94493: LD_ADDR_EXP 139
94497: PUSH
94498: LD_INT 36
94500: ST_TO_ADDR
// hardcoreCounter := 18 ;
94501: LD_ADDR_EXP 140
94505: PUSH
94506: LD_INT 18
94508: ST_TO_ADDR
// sRocket := false ;
94509: LD_ADDR_EXP 143
94513: PUSH
94514: LD_INT 0
94516: ST_TO_ADDR
// sSpeed := false ;
94517: LD_ADDR_EXP 142
94521: PUSH
94522: LD_INT 0
94524: ST_TO_ADDR
// sEngine := false ;
94525: LD_ADDR_EXP 144
94529: PUSH
94530: LD_INT 0
94532: ST_TO_ADDR
// sSpec := false ;
94533: LD_ADDR_EXP 141
94537: PUSH
94538: LD_INT 0
94540: ST_TO_ADDR
// sLevel := false ;
94541: LD_ADDR_EXP 145
94545: PUSH
94546: LD_INT 0
94548: ST_TO_ADDR
// sArmoury := false ;
94549: LD_ADDR_EXP 146
94553: PUSH
94554: LD_INT 0
94556: ST_TO_ADDR
// sRadar := false ;
94557: LD_ADDR_EXP 147
94561: PUSH
94562: LD_INT 0
94564: ST_TO_ADDR
// sBunker := false ;
94565: LD_ADDR_EXP 148
94569: PUSH
94570: LD_INT 0
94572: ST_TO_ADDR
// sHack := false ;
94573: LD_ADDR_EXP 149
94577: PUSH
94578: LD_INT 0
94580: ST_TO_ADDR
// sFire := false ;
94581: LD_ADDR_EXP 150
94585: PUSH
94586: LD_INT 0
94588: ST_TO_ADDR
// sRefresh := false ;
94589: LD_ADDR_EXP 151
94593: PUSH
94594: LD_INT 0
94596: ST_TO_ADDR
// sExp := false ;
94597: LD_ADDR_EXP 152
94601: PUSH
94602: LD_INT 0
94604: ST_TO_ADDR
// sDepot := false ;
94605: LD_ADDR_EXP 153
94609: PUSH
94610: LD_INT 0
94612: ST_TO_ADDR
// sFlag := false ;
94613: LD_ADDR_EXP 154
94617: PUSH
94618: LD_INT 0
94620: ST_TO_ADDR
// sKamikadze := false ;
94621: LD_ADDR_EXP 162
94625: PUSH
94626: LD_INT 0
94628: ST_TO_ADDR
// sTroll := false ;
94629: LD_ADDR_EXP 163
94633: PUSH
94634: LD_INT 0
94636: ST_TO_ADDR
// sSlow := false ;
94637: LD_ADDR_EXP 164
94641: PUSH
94642: LD_INT 0
94644: ST_TO_ADDR
// sLack := false ;
94645: LD_ADDR_EXP 165
94649: PUSH
94650: LD_INT 0
94652: ST_TO_ADDR
// sTank := false ;
94653: LD_ADDR_EXP 167
94657: PUSH
94658: LD_INT 0
94660: ST_TO_ADDR
// sRemote := false ;
94661: LD_ADDR_EXP 168
94665: PUSH
94666: LD_INT 0
94668: ST_TO_ADDR
// sPowell := false ;
94669: LD_ADDR_EXP 169
94673: PUSH
94674: LD_INT 0
94676: ST_TO_ADDR
// sTeleport := false ;
94677: LD_ADDR_EXP 172
94681: PUSH
94682: LD_INT 0
94684: ST_TO_ADDR
// sOilTower := false ;
94685: LD_ADDR_EXP 174
94689: PUSH
94690: LD_INT 0
94692: ST_TO_ADDR
// sShovel := false ;
94693: LD_ADDR_EXP 175
94697: PUSH
94698: LD_INT 0
94700: ST_TO_ADDR
// sSheik := false ;
94701: LD_ADDR_EXP 176
94705: PUSH
94706: LD_INT 0
94708: ST_TO_ADDR
// sEarthquake := false ;
94709: LD_ADDR_EXP 178
94713: PUSH
94714: LD_INT 0
94716: ST_TO_ADDR
// sAI := false ;
94717: LD_ADDR_EXP 179
94721: PUSH
94722: LD_INT 0
94724: ST_TO_ADDR
// sCargo := false ;
94725: LD_ADDR_EXP 182
94729: PUSH
94730: LD_INT 0
94732: ST_TO_ADDR
// sDLaser := false ;
94733: LD_ADDR_EXP 183
94737: PUSH
94738: LD_INT 0
94740: ST_TO_ADDR
// sExchange := false ;
94741: LD_ADDR_EXP 184
94745: PUSH
94746: LD_INT 0
94748: ST_TO_ADDR
// sFac := false ;
94749: LD_ADDR_EXP 185
94753: PUSH
94754: LD_INT 0
94756: ST_TO_ADDR
// sPower := false ;
94757: LD_ADDR_EXP 186
94761: PUSH
94762: LD_INT 0
94764: ST_TO_ADDR
// sRandom := false ;
94765: LD_ADDR_EXP 187
94769: PUSH
94770: LD_INT 0
94772: ST_TO_ADDR
// sShield := false ;
94773: LD_ADDR_EXP 188
94777: PUSH
94778: LD_INT 0
94780: ST_TO_ADDR
// sTime := false ;
94781: LD_ADDR_EXP 189
94785: PUSH
94786: LD_INT 0
94788: ST_TO_ADDR
// sTools := false ;
94789: LD_ADDR_EXP 190
94793: PUSH
94794: LD_INT 0
94796: ST_TO_ADDR
// sSold := false ;
94797: LD_ADDR_EXP 155
94801: PUSH
94802: LD_INT 0
94804: ST_TO_ADDR
// sDiff := false ;
94805: LD_ADDR_EXP 156
94809: PUSH
94810: LD_INT 0
94812: ST_TO_ADDR
// sFog := false ;
94813: LD_ADDR_EXP 159
94817: PUSH
94818: LD_INT 0
94820: ST_TO_ADDR
// sReset := false ;
94821: LD_ADDR_EXP 160
94825: PUSH
94826: LD_INT 0
94828: ST_TO_ADDR
// sSun := false ;
94829: LD_ADDR_EXP 161
94833: PUSH
94834: LD_INT 0
94836: ST_TO_ADDR
// sTiger := false ;
94837: LD_ADDR_EXP 157
94841: PUSH
94842: LD_INT 0
94844: ST_TO_ADDR
// sBomb := false ;
94845: LD_ADDR_EXP 158
94849: PUSH
94850: LD_INT 0
94852: ST_TO_ADDR
// sWound := false ;
94853: LD_ADDR_EXP 166
94857: PUSH
94858: LD_INT 0
94860: ST_TO_ADDR
// sBetray := false ;
94861: LD_ADDR_EXP 170
94865: PUSH
94866: LD_INT 0
94868: ST_TO_ADDR
// sContamin := false ;
94869: LD_ADDR_EXP 171
94873: PUSH
94874: LD_INT 0
94876: ST_TO_ADDR
// sOil := false ;
94877: LD_ADDR_EXP 173
94881: PUSH
94882: LD_INT 0
94884: ST_TO_ADDR
// sStu := false ;
94885: LD_ADDR_EXP 177
94889: PUSH
94890: LD_INT 0
94892: ST_TO_ADDR
// sBazooka := false ;
94893: LD_ADDR_EXP 180
94897: PUSH
94898: LD_INT 0
94900: ST_TO_ADDR
// sMortar := false ;
94901: LD_ADDR_EXP 181
94905: PUSH
94906: LD_INT 0
94908: ST_TO_ADDR
// sRanger := false ;
94909: LD_ADDR_EXP 191
94913: PUSH
94914: LD_INT 0
94916: ST_TO_ADDR
// sComputer := false ;
94917: LD_ADDR_EXP 192
94921: PUSH
94922: LD_INT 0
94924: ST_TO_ADDR
// s30 := false ;
94925: LD_ADDR_EXP 193
94929: PUSH
94930: LD_INT 0
94932: ST_TO_ADDR
// s60 := false ;
94933: LD_ADDR_EXP 194
94937: PUSH
94938: LD_INT 0
94940: ST_TO_ADDR
// end ;
94941: LD_VAR 0 1
94945: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
94946: LD_INT 0
94948: PPUSH
94949: PPUSH
94950: PPUSH
94951: PPUSH
94952: PPUSH
94953: PPUSH
94954: PPUSH
// result := [ ] ;
94955: LD_ADDR_VAR 0 2
94959: PUSH
94960: EMPTY
94961: ST_TO_ADDR
// if campaign_id = 1 then
94962: LD_OWVAR 69
94966: PUSH
94967: LD_INT 1
94969: EQUAL
94970: IFFALSE 98136
// begin case mission_number of 1 :
94972: LD_OWVAR 70
94976: PUSH
94977: LD_INT 1
94979: DOUBLE
94980: EQUAL
94981: IFTRUE 94985
94983: GO 95061
94985: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94986: LD_ADDR_VAR 0 2
94990: PUSH
94991: LD_INT 2
94993: PUSH
94994: LD_INT 4
94996: PUSH
94997: LD_INT 11
94999: PUSH
95000: LD_INT 12
95002: PUSH
95003: LD_INT 15
95005: PUSH
95006: LD_INT 16
95008: PUSH
95009: LD_INT 22
95011: PUSH
95012: LD_INT 23
95014: PUSH
95015: LD_INT 26
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 101
95031: PUSH
95032: LD_INT 102
95034: PUSH
95035: LD_INT 106
95037: PUSH
95038: LD_INT 116
95040: PUSH
95041: LD_INT 117
95043: PUSH
95044: LD_INT 118
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: ST_TO_ADDR
95059: GO 98134
95061: LD_INT 2
95063: DOUBLE
95064: EQUAL
95065: IFTRUE 95069
95067: GO 95153
95069: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95070: LD_ADDR_VAR 0 2
95074: PUSH
95075: LD_INT 2
95077: PUSH
95078: LD_INT 4
95080: PUSH
95081: LD_INT 11
95083: PUSH
95084: LD_INT 12
95086: PUSH
95087: LD_INT 15
95089: PUSH
95090: LD_INT 16
95092: PUSH
95093: LD_INT 22
95095: PUSH
95096: LD_INT 23
95098: PUSH
95099: LD_INT 26
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 101
95115: PUSH
95116: LD_INT 102
95118: PUSH
95119: LD_INT 105
95121: PUSH
95122: LD_INT 106
95124: PUSH
95125: LD_INT 108
95127: PUSH
95128: LD_INT 116
95130: PUSH
95131: LD_INT 117
95133: PUSH
95134: LD_INT 118
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: ST_TO_ADDR
95151: GO 98134
95153: LD_INT 3
95155: DOUBLE
95156: EQUAL
95157: IFTRUE 95161
95159: GO 95249
95161: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95162: LD_ADDR_VAR 0 2
95166: PUSH
95167: LD_INT 2
95169: PUSH
95170: LD_INT 4
95172: PUSH
95173: LD_INT 5
95175: PUSH
95176: LD_INT 11
95178: PUSH
95179: LD_INT 12
95181: PUSH
95182: LD_INT 15
95184: PUSH
95185: LD_INT 16
95187: PUSH
95188: LD_INT 22
95190: PUSH
95191: LD_INT 26
95193: PUSH
95194: LD_INT 36
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 101
95211: PUSH
95212: LD_INT 102
95214: PUSH
95215: LD_INT 105
95217: PUSH
95218: LD_INT 106
95220: PUSH
95221: LD_INT 108
95223: PUSH
95224: LD_INT 116
95226: PUSH
95227: LD_INT 117
95229: PUSH
95230: LD_INT 118
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: ST_TO_ADDR
95247: GO 98134
95249: LD_INT 4
95251: DOUBLE
95252: EQUAL
95253: IFTRUE 95257
95255: GO 95353
95257: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95258: LD_ADDR_VAR 0 2
95262: PUSH
95263: LD_INT 2
95265: PUSH
95266: LD_INT 4
95268: PUSH
95269: LD_INT 5
95271: PUSH
95272: LD_INT 8
95274: PUSH
95275: LD_INT 11
95277: PUSH
95278: LD_INT 12
95280: PUSH
95281: LD_INT 15
95283: PUSH
95284: LD_INT 16
95286: PUSH
95287: LD_INT 22
95289: PUSH
95290: LD_INT 23
95292: PUSH
95293: LD_INT 26
95295: PUSH
95296: LD_INT 36
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 101
95315: PUSH
95316: LD_INT 102
95318: PUSH
95319: LD_INT 105
95321: PUSH
95322: LD_INT 106
95324: PUSH
95325: LD_INT 108
95327: PUSH
95328: LD_INT 116
95330: PUSH
95331: LD_INT 117
95333: PUSH
95334: LD_INT 118
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: ST_TO_ADDR
95351: GO 98134
95353: LD_INT 5
95355: DOUBLE
95356: EQUAL
95357: IFTRUE 95361
95359: GO 95473
95361: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95362: LD_ADDR_VAR 0 2
95366: PUSH
95367: LD_INT 2
95369: PUSH
95370: LD_INT 4
95372: PUSH
95373: LD_INT 5
95375: PUSH
95376: LD_INT 6
95378: PUSH
95379: LD_INT 8
95381: PUSH
95382: LD_INT 11
95384: PUSH
95385: LD_INT 12
95387: PUSH
95388: LD_INT 15
95390: PUSH
95391: LD_INT 16
95393: PUSH
95394: LD_INT 22
95396: PUSH
95397: LD_INT 23
95399: PUSH
95400: LD_INT 25
95402: PUSH
95403: LD_INT 26
95405: PUSH
95406: LD_INT 36
95408: PUSH
95409: EMPTY
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 101
95427: PUSH
95428: LD_INT 102
95430: PUSH
95431: LD_INT 105
95433: PUSH
95434: LD_INT 106
95436: PUSH
95437: LD_INT 108
95439: PUSH
95440: LD_INT 109
95442: PUSH
95443: LD_INT 112
95445: PUSH
95446: LD_INT 116
95448: PUSH
95449: LD_INT 117
95451: PUSH
95452: LD_INT 118
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: ST_TO_ADDR
95471: GO 98134
95473: LD_INT 6
95475: DOUBLE
95476: EQUAL
95477: IFTRUE 95481
95479: GO 95613
95481: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95482: LD_ADDR_VAR 0 2
95486: PUSH
95487: LD_INT 2
95489: PUSH
95490: LD_INT 4
95492: PUSH
95493: LD_INT 5
95495: PUSH
95496: LD_INT 6
95498: PUSH
95499: LD_INT 8
95501: PUSH
95502: LD_INT 11
95504: PUSH
95505: LD_INT 12
95507: PUSH
95508: LD_INT 15
95510: PUSH
95511: LD_INT 16
95513: PUSH
95514: LD_INT 20
95516: PUSH
95517: LD_INT 21
95519: PUSH
95520: LD_INT 22
95522: PUSH
95523: LD_INT 23
95525: PUSH
95526: LD_INT 25
95528: PUSH
95529: LD_INT 26
95531: PUSH
95532: LD_INT 30
95534: PUSH
95535: LD_INT 31
95537: PUSH
95538: LD_INT 32
95540: PUSH
95541: LD_INT 36
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 101
95567: PUSH
95568: LD_INT 102
95570: PUSH
95571: LD_INT 105
95573: PUSH
95574: LD_INT 106
95576: PUSH
95577: LD_INT 108
95579: PUSH
95580: LD_INT 109
95582: PUSH
95583: LD_INT 112
95585: PUSH
95586: LD_INT 116
95588: PUSH
95589: LD_INT 117
95591: PUSH
95592: LD_INT 118
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: PUSH
95607: EMPTY
95608: LIST
95609: LIST
95610: ST_TO_ADDR
95611: GO 98134
95613: LD_INT 7
95615: DOUBLE
95616: EQUAL
95617: IFTRUE 95621
95619: GO 95733
95621: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95622: LD_ADDR_VAR 0 2
95626: PUSH
95627: LD_INT 2
95629: PUSH
95630: LD_INT 4
95632: PUSH
95633: LD_INT 5
95635: PUSH
95636: LD_INT 7
95638: PUSH
95639: LD_INT 11
95641: PUSH
95642: LD_INT 12
95644: PUSH
95645: LD_INT 15
95647: PUSH
95648: LD_INT 16
95650: PUSH
95651: LD_INT 20
95653: PUSH
95654: LD_INT 21
95656: PUSH
95657: LD_INT 22
95659: PUSH
95660: LD_INT 23
95662: PUSH
95663: LD_INT 25
95665: PUSH
95666: LD_INT 26
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 101
95687: PUSH
95688: LD_INT 102
95690: PUSH
95691: LD_INT 103
95693: PUSH
95694: LD_INT 105
95696: PUSH
95697: LD_INT 106
95699: PUSH
95700: LD_INT 108
95702: PUSH
95703: LD_INT 112
95705: PUSH
95706: LD_INT 116
95708: PUSH
95709: LD_INT 117
95711: PUSH
95712: LD_INT 118
95714: PUSH
95715: EMPTY
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: ST_TO_ADDR
95731: GO 98134
95733: LD_INT 8
95735: DOUBLE
95736: EQUAL
95737: IFTRUE 95741
95739: GO 95881
95741: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95742: LD_ADDR_VAR 0 2
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: LD_INT 4
95752: PUSH
95753: LD_INT 5
95755: PUSH
95756: LD_INT 6
95758: PUSH
95759: LD_INT 7
95761: PUSH
95762: LD_INT 8
95764: PUSH
95765: LD_INT 11
95767: PUSH
95768: LD_INT 12
95770: PUSH
95771: LD_INT 15
95773: PUSH
95774: LD_INT 16
95776: PUSH
95777: LD_INT 20
95779: PUSH
95780: LD_INT 21
95782: PUSH
95783: LD_INT 22
95785: PUSH
95786: LD_INT 23
95788: PUSH
95789: LD_INT 25
95791: PUSH
95792: LD_INT 26
95794: PUSH
95795: LD_INT 30
95797: PUSH
95798: LD_INT 31
95800: PUSH
95801: LD_INT 32
95803: PUSH
95804: LD_INT 36
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: PUSH
95829: LD_INT 101
95831: PUSH
95832: LD_INT 102
95834: PUSH
95835: LD_INT 103
95837: PUSH
95838: LD_INT 105
95840: PUSH
95841: LD_INT 106
95843: PUSH
95844: LD_INT 108
95846: PUSH
95847: LD_INT 109
95849: PUSH
95850: LD_INT 112
95852: PUSH
95853: LD_INT 116
95855: PUSH
95856: LD_INT 117
95858: PUSH
95859: LD_INT 118
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: ST_TO_ADDR
95879: GO 98134
95881: LD_INT 9
95883: DOUBLE
95884: EQUAL
95885: IFTRUE 95889
95887: GO 96037
95889: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95890: LD_ADDR_VAR 0 2
95894: PUSH
95895: LD_INT 2
95897: PUSH
95898: LD_INT 4
95900: PUSH
95901: LD_INT 5
95903: PUSH
95904: LD_INT 6
95906: PUSH
95907: LD_INT 7
95909: PUSH
95910: LD_INT 8
95912: PUSH
95913: LD_INT 11
95915: PUSH
95916: LD_INT 12
95918: PUSH
95919: LD_INT 15
95921: PUSH
95922: LD_INT 16
95924: PUSH
95925: LD_INT 20
95927: PUSH
95928: LD_INT 21
95930: PUSH
95931: LD_INT 22
95933: PUSH
95934: LD_INT 23
95936: PUSH
95937: LD_INT 25
95939: PUSH
95940: LD_INT 26
95942: PUSH
95943: LD_INT 28
95945: PUSH
95946: LD_INT 30
95948: PUSH
95949: LD_INT 31
95951: PUSH
95952: LD_INT 32
95954: PUSH
95955: LD_INT 36
95957: PUSH
95958: EMPTY
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 101
95983: PUSH
95984: LD_INT 102
95986: PUSH
95987: LD_INT 103
95989: PUSH
95990: LD_INT 105
95992: PUSH
95993: LD_INT 106
95995: PUSH
95996: LD_INT 108
95998: PUSH
95999: LD_INT 109
96001: PUSH
96002: LD_INT 112
96004: PUSH
96005: LD_INT 114
96007: PUSH
96008: LD_INT 116
96010: PUSH
96011: LD_INT 117
96013: PUSH
96014: LD_INT 118
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: PUSH
96031: EMPTY
96032: LIST
96033: LIST
96034: ST_TO_ADDR
96035: GO 98134
96037: LD_INT 10
96039: DOUBLE
96040: EQUAL
96041: IFTRUE 96045
96043: GO 96241
96045: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96046: LD_ADDR_VAR 0 2
96050: PUSH
96051: LD_INT 2
96053: PUSH
96054: LD_INT 4
96056: PUSH
96057: LD_INT 5
96059: PUSH
96060: LD_INT 6
96062: PUSH
96063: LD_INT 7
96065: PUSH
96066: LD_INT 8
96068: PUSH
96069: LD_INT 9
96071: PUSH
96072: LD_INT 10
96074: PUSH
96075: LD_INT 11
96077: PUSH
96078: LD_INT 12
96080: PUSH
96081: LD_INT 13
96083: PUSH
96084: LD_INT 14
96086: PUSH
96087: LD_INT 15
96089: PUSH
96090: LD_INT 16
96092: PUSH
96093: LD_INT 17
96095: PUSH
96096: LD_INT 18
96098: PUSH
96099: LD_INT 19
96101: PUSH
96102: LD_INT 20
96104: PUSH
96105: LD_INT 21
96107: PUSH
96108: LD_INT 22
96110: PUSH
96111: LD_INT 23
96113: PUSH
96114: LD_INT 24
96116: PUSH
96117: LD_INT 25
96119: PUSH
96120: LD_INT 26
96122: PUSH
96123: LD_INT 28
96125: PUSH
96126: LD_INT 30
96128: PUSH
96129: LD_INT 31
96131: PUSH
96132: LD_INT 32
96134: PUSH
96135: LD_INT 36
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 101
96171: PUSH
96172: LD_INT 102
96174: PUSH
96175: LD_INT 103
96177: PUSH
96178: LD_INT 104
96180: PUSH
96181: LD_INT 105
96183: PUSH
96184: LD_INT 106
96186: PUSH
96187: LD_INT 107
96189: PUSH
96190: LD_INT 108
96192: PUSH
96193: LD_INT 109
96195: PUSH
96196: LD_INT 110
96198: PUSH
96199: LD_INT 111
96201: PUSH
96202: LD_INT 112
96204: PUSH
96205: LD_INT 114
96207: PUSH
96208: LD_INT 116
96210: PUSH
96211: LD_INT 117
96213: PUSH
96214: LD_INT 118
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: ST_TO_ADDR
96239: GO 98134
96241: LD_INT 11
96243: DOUBLE
96244: EQUAL
96245: IFTRUE 96249
96247: GO 96453
96249: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96250: LD_ADDR_VAR 0 2
96254: PUSH
96255: LD_INT 2
96257: PUSH
96258: LD_INT 3
96260: PUSH
96261: LD_INT 4
96263: PUSH
96264: LD_INT 5
96266: PUSH
96267: LD_INT 6
96269: PUSH
96270: LD_INT 7
96272: PUSH
96273: LD_INT 8
96275: PUSH
96276: LD_INT 9
96278: PUSH
96279: LD_INT 10
96281: PUSH
96282: LD_INT 11
96284: PUSH
96285: LD_INT 12
96287: PUSH
96288: LD_INT 13
96290: PUSH
96291: LD_INT 14
96293: PUSH
96294: LD_INT 15
96296: PUSH
96297: LD_INT 16
96299: PUSH
96300: LD_INT 17
96302: PUSH
96303: LD_INT 18
96305: PUSH
96306: LD_INT 19
96308: PUSH
96309: LD_INT 20
96311: PUSH
96312: LD_INT 21
96314: PUSH
96315: LD_INT 22
96317: PUSH
96318: LD_INT 23
96320: PUSH
96321: LD_INT 24
96323: PUSH
96324: LD_INT 25
96326: PUSH
96327: LD_INT 26
96329: PUSH
96330: LD_INT 28
96332: PUSH
96333: LD_INT 30
96335: PUSH
96336: LD_INT 31
96338: PUSH
96339: LD_INT 32
96341: PUSH
96342: LD_INT 34
96344: PUSH
96345: LD_INT 36
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 101
96383: PUSH
96384: LD_INT 102
96386: PUSH
96387: LD_INT 103
96389: PUSH
96390: LD_INT 104
96392: PUSH
96393: LD_INT 105
96395: PUSH
96396: LD_INT 106
96398: PUSH
96399: LD_INT 107
96401: PUSH
96402: LD_INT 108
96404: PUSH
96405: LD_INT 109
96407: PUSH
96408: LD_INT 110
96410: PUSH
96411: LD_INT 111
96413: PUSH
96414: LD_INT 112
96416: PUSH
96417: LD_INT 114
96419: PUSH
96420: LD_INT 116
96422: PUSH
96423: LD_INT 117
96425: PUSH
96426: LD_INT 118
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: ST_TO_ADDR
96451: GO 98134
96453: LD_INT 12
96455: DOUBLE
96456: EQUAL
96457: IFTRUE 96461
96459: GO 96681
96461: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96462: LD_ADDR_VAR 0 2
96466: PUSH
96467: LD_INT 1
96469: PUSH
96470: LD_INT 2
96472: PUSH
96473: LD_INT 3
96475: PUSH
96476: LD_INT 4
96478: PUSH
96479: LD_INT 5
96481: PUSH
96482: LD_INT 6
96484: PUSH
96485: LD_INT 7
96487: PUSH
96488: LD_INT 8
96490: PUSH
96491: LD_INT 9
96493: PUSH
96494: LD_INT 10
96496: PUSH
96497: LD_INT 11
96499: PUSH
96500: LD_INT 12
96502: PUSH
96503: LD_INT 13
96505: PUSH
96506: LD_INT 14
96508: PUSH
96509: LD_INT 15
96511: PUSH
96512: LD_INT 16
96514: PUSH
96515: LD_INT 17
96517: PUSH
96518: LD_INT 18
96520: PUSH
96521: LD_INT 19
96523: PUSH
96524: LD_INT 20
96526: PUSH
96527: LD_INT 21
96529: PUSH
96530: LD_INT 22
96532: PUSH
96533: LD_INT 23
96535: PUSH
96536: LD_INT 24
96538: PUSH
96539: LD_INT 25
96541: PUSH
96542: LD_INT 26
96544: PUSH
96545: LD_INT 27
96547: PUSH
96548: LD_INT 28
96550: PUSH
96551: LD_INT 30
96553: PUSH
96554: LD_INT 31
96556: PUSH
96557: LD_INT 32
96559: PUSH
96560: LD_INT 33
96562: PUSH
96563: LD_INT 34
96565: PUSH
96566: LD_INT 36
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 101
96607: PUSH
96608: LD_INT 102
96610: PUSH
96611: LD_INT 103
96613: PUSH
96614: LD_INT 104
96616: PUSH
96617: LD_INT 105
96619: PUSH
96620: LD_INT 106
96622: PUSH
96623: LD_INT 107
96625: PUSH
96626: LD_INT 108
96628: PUSH
96629: LD_INT 109
96631: PUSH
96632: LD_INT 110
96634: PUSH
96635: LD_INT 111
96637: PUSH
96638: LD_INT 112
96640: PUSH
96641: LD_INT 113
96643: PUSH
96644: LD_INT 114
96646: PUSH
96647: LD_INT 116
96649: PUSH
96650: LD_INT 117
96652: PUSH
96653: LD_INT 118
96655: PUSH
96656: EMPTY
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: ST_TO_ADDR
96679: GO 98134
96681: LD_INT 13
96683: DOUBLE
96684: EQUAL
96685: IFTRUE 96689
96687: GO 96897
96689: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96690: LD_ADDR_VAR 0 2
96694: PUSH
96695: LD_INT 1
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: LD_INT 3
96703: PUSH
96704: LD_INT 4
96706: PUSH
96707: LD_INT 5
96709: PUSH
96710: LD_INT 8
96712: PUSH
96713: LD_INT 9
96715: PUSH
96716: LD_INT 10
96718: PUSH
96719: LD_INT 11
96721: PUSH
96722: LD_INT 12
96724: PUSH
96725: LD_INT 14
96727: PUSH
96728: LD_INT 15
96730: PUSH
96731: LD_INT 16
96733: PUSH
96734: LD_INT 17
96736: PUSH
96737: LD_INT 18
96739: PUSH
96740: LD_INT 19
96742: PUSH
96743: LD_INT 20
96745: PUSH
96746: LD_INT 21
96748: PUSH
96749: LD_INT 22
96751: PUSH
96752: LD_INT 23
96754: PUSH
96755: LD_INT 24
96757: PUSH
96758: LD_INT 25
96760: PUSH
96761: LD_INT 26
96763: PUSH
96764: LD_INT 27
96766: PUSH
96767: LD_INT 28
96769: PUSH
96770: LD_INT 30
96772: PUSH
96773: LD_INT 31
96775: PUSH
96776: LD_INT 32
96778: PUSH
96779: LD_INT 33
96781: PUSH
96782: LD_INT 34
96784: PUSH
96785: LD_INT 36
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 101
96823: PUSH
96824: LD_INT 102
96826: PUSH
96827: LD_INT 103
96829: PUSH
96830: LD_INT 104
96832: PUSH
96833: LD_INT 105
96835: PUSH
96836: LD_INT 106
96838: PUSH
96839: LD_INT 107
96841: PUSH
96842: LD_INT 108
96844: PUSH
96845: LD_INT 109
96847: PUSH
96848: LD_INT 110
96850: PUSH
96851: LD_INT 111
96853: PUSH
96854: LD_INT 112
96856: PUSH
96857: LD_INT 113
96859: PUSH
96860: LD_INT 114
96862: PUSH
96863: LD_INT 116
96865: PUSH
96866: LD_INT 117
96868: PUSH
96869: LD_INT 118
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: ST_TO_ADDR
96895: GO 98134
96897: LD_INT 14
96899: DOUBLE
96900: EQUAL
96901: IFTRUE 96905
96903: GO 97129
96905: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96906: LD_ADDR_VAR 0 2
96910: PUSH
96911: LD_INT 1
96913: PUSH
96914: LD_INT 2
96916: PUSH
96917: LD_INT 3
96919: PUSH
96920: LD_INT 4
96922: PUSH
96923: LD_INT 5
96925: PUSH
96926: LD_INT 6
96928: PUSH
96929: LD_INT 7
96931: PUSH
96932: LD_INT 8
96934: PUSH
96935: LD_INT 9
96937: PUSH
96938: LD_INT 10
96940: PUSH
96941: LD_INT 11
96943: PUSH
96944: LD_INT 12
96946: PUSH
96947: LD_INT 13
96949: PUSH
96950: LD_INT 14
96952: PUSH
96953: LD_INT 15
96955: PUSH
96956: LD_INT 16
96958: PUSH
96959: LD_INT 17
96961: PUSH
96962: LD_INT 18
96964: PUSH
96965: LD_INT 19
96967: PUSH
96968: LD_INT 20
96970: PUSH
96971: LD_INT 21
96973: PUSH
96974: LD_INT 22
96976: PUSH
96977: LD_INT 23
96979: PUSH
96980: LD_INT 24
96982: PUSH
96983: LD_INT 25
96985: PUSH
96986: LD_INT 26
96988: PUSH
96989: LD_INT 27
96991: PUSH
96992: LD_INT 28
96994: PUSH
96995: LD_INT 29
96997: PUSH
96998: LD_INT 30
97000: PUSH
97001: LD_INT 31
97003: PUSH
97004: LD_INT 32
97006: PUSH
97007: LD_INT 33
97009: PUSH
97010: LD_INT 34
97012: PUSH
97013: LD_INT 36
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: PUSH
97053: LD_INT 101
97055: PUSH
97056: LD_INT 102
97058: PUSH
97059: LD_INT 103
97061: PUSH
97062: LD_INT 104
97064: PUSH
97065: LD_INT 105
97067: PUSH
97068: LD_INT 106
97070: PUSH
97071: LD_INT 107
97073: PUSH
97074: LD_INT 108
97076: PUSH
97077: LD_INT 109
97079: PUSH
97080: LD_INT 110
97082: PUSH
97083: LD_INT 111
97085: PUSH
97086: LD_INT 112
97088: PUSH
97089: LD_INT 113
97091: PUSH
97092: LD_INT 114
97094: PUSH
97095: LD_INT 116
97097: PUSH
97098: LD_INT 117
97100: PUSH
97101: LD_INT 118
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: ST_TO_ADDR
97127: GO 98134
97129: LD_INT 15
97131: DOUBLE
97132: EQUAL
97133: IFTRUE 97137
97135: GO 97361
97137: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97138: LD_ADDR_VAR 0 2
97142: PUSH
97143: LD_INT 1
97145: PUSH
97146: LD_INT 2
97148: PUSH
97149: LD_INT 3
97151: PUSH
97152: LD_INT 4
97154: PUSH
97155: LD_INT 5
97157: PUSH
97158: LD_INT 6
97160: PUSH
97161: LD_INT 7
97163: PUSH
97164: LD_INT 8
97166: PUSH
97167: LD_INT 9
97169: PUSH
97170: LD_INT 10
97172: PUSH
97173: LD_INT 11
97175: PUSH
97176: LD_INT 12
97178: PUSH
97179: LD_INT 13
97181: PUSH
97182: LD_INT 14
97184: PUSH
97185: LD_INT 15
97187: PUSH
97188: LD_INT 16
97190: PUSH
97191: LD_INT 17
97193: PUSH
97194: LD_INT 18
97196: PUSH
97197: LD_INT 19
97199: PUSH
97200: LD_INT 20
97202: PUSH
97203: LD_INT 21
97205: PUSH
97206: LD_INT 22
97208: PUSH
97209: LD_INT 23
97211: PUSH
97212: LD_INT 24
97214: PUSH
97215: LD_INT 25
97217: PUSH
97218: LD_INT 26
97220: PUSH
97221: LD_INT 27
97223: PUSH
97224: LD_INT 28
97226: PUSH
97227: LD_INT 29
97229: PUSH
97230: LD_INT 30
97232: PUSH
97233: LD_INT 31
97235: PUSH
97236: LD_INT 32
97238: PUSH
97239: LD_INT 33
97241: PUSH
97242: LD_INT 34
97244: PUSH
97245: LD_INT 36
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 101
97287: PUSH
97288: LD_INT 102
97290: PUSH
97291: LD_INT 103
97293: PUSH
97294: LD_INT 104
97296: PUSH
97297: LD_INT 105
97299: PUSH
97300: LD_INT 106
97302: PUSH
97303: LD_INT 107
97305: PUSH
97306: LD_INT 108
97308: PUSH
97309: LD_INT 109
97311: PUSH
97312: LD_INT 110
97314: PUSH
97315: LD_INT 111
97317: PUSH
97318: LD_INT 112
97320: PUSH
97321: LD_INT 113
97323: PUSH
97324: LD_INT 114
97326: PUSH
97327: LD_INT 116
97329: PUSH
97330: LD_INT 117
97332: PUSH
97333: LD_INT 118
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: ST_TO_ADDR
97359: GO 98134
97361: LD_INT 16
97363: DOUBLE
97364: EQUAL
97365: IFTRUE 97369
97367: GO 97505
97369: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97370: LD_ADDR_VAR 0 2
97374: PUSH
97375: LD_INT 2
97377: PUSH
97378: LD_INT 4
97380: PUSH
97381: LD_INT 5
97383: PUSH
97384: LD_INT 7
97386: PUSH
97387: LD_INT 11
97389: PUSH
97390: LD_INT 12
97392: PUSH
97393: LD_INT 15
97395: PUSH
97396: LD_INT 16
97398: PUSH
97399: LD_INT 20
97401: PUSH
97402: LD_INT 21
97404: PUSH
97405: LD_INT 22
97407: PUSH
97408: LD_INT 23
97410: PUSH
97411: LD_INT 25
97413: PUSH
97414: LD_INT 26
97416: PUSH
97417: LD_INT 30
97419: PUSH
97420: LD_INT 31
97422: PUSH
97423: LD_INT 32
97425: PUSH
97426: LD_INT 33
97428: PUSH
97429: LD_INT 34
97431: PUSH
97432: EMPTY
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: PUSH
97453: LD_INT 101
97455: PUSH
97456: LD_INT 102
97458: PUSH
97459: LD_INT 103
97461: PUSH
97462: LD_INT 106
97464: PUSH
97465: LD_INT 108
97467: PUSH
97468: LD_INT 112
97470: PUSH
97471: LD_INT 113
97473: PUSH
97474: LD_INT 114
97476: PUSH
97477: LD_INT 116
97479: PUSH
97480: LD_INT 117
97482: PUSH
97483: LD_INT 118
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: PUSH
97499: EMPTY
97500: LIST
97501: LIST
97502: ST_TO_ADDR
97503: GO 98134
97505: LD_INT 17
97507: DOUBLE
97508: EQUAL
97509: IFTRUE 97513
97511: GO 97737
97513: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97514: LD_ADDR_VAR 0 2
97518: PUSH
97519: LD_INT 1
97521: PUSH
97522: LD_INT 2
97524: PUSH
97525: LD_INT 3
97527: PUSH
97528: LD_INT 4
97530: PUSH
97531: LD_INT 5
97533: PUSH
97534: LD_INT 6
97536: PUSH
97537: LD_INT 7
97539: PUSH
97540: LD_INT 8
97542: PUSH
97543: LD_INT 9
97545: PUSH
97546: LD_INT 10
97548: PUSH
97549: LD_INT 11
97551: PUSH
97552: LD_INT 12
97554: PUSH
97555: LD_INT 13
97557: PUSH
97558: LD_INT 14
97560: PUSH
97561: LD_INT 15
97563: PUSH
97564: LD_INT 16
97566: PUSH
97567: LD_INT 17
97569: PUSH
97570: LD_INT 18
97572: PUSH
97573: LD_INT 19
97575: PUSH
97576: LD_INT 20
97578: PUSH
97579: LD_INT 21
97581: PUSH
97582: LD_INT 22
97584: PUSH
97585: LD_INT 23
97587: PUSH
97588: LD_INT 24
97590: PUSH
97591: LD_INT 25
97593: PUSH
97594: LD_INT 26
97596: PUSH
97597: LD_INT 27
97599: PUSH
97600: LD_INT 28
97602: PUSH
97603: LD_INT 29
97605: PUSH
97606: LD_INT 30
97608: PUSH
97609: LD_INT 31
97611: PUSH
97612: LD_INT 32
97614: PUSH
97615: LD_INT 33
97617: PUSH
97618: LD_INT 34
97620: PUSH
97621: LD_INT 36
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 101
97663: PUSH
97664: LD_INT 102
97666: PUSH
97667: LD_INT 103
97669: PUSH
97670: LD_INT 104
97672: PUSH
97673: LD_INT 105
97675: PUSH
97676: LD_INT 106
97678: PUSH
97679: LD_INT 107
97681: PUSH
97682: LD_INT 108
97684: PUSH
97685: LD_INT 109
97687: PUSH
97688: LD_INT 110
97690: PUSH
97691: LD_INT 111
97693: PUSH
97694: LD_INT 112
97696: PUSH
97697: LD_INT 113
97699: PUSH
97700: LD_INT 114
97702: PUSH
97703: LD_INT 116
97705: PUSH
97706: LD_INT 117
97708: PUSH
97709: LD_INT 118
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: ST_TO_ADDR
97735: GO 98134
97737: LD_INT 18
97739: DOUBLE
97740: EQUAL
97741: IFTRUE 97745
97743: GO 97893
97745: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97746: LD_ADDR_VAR 0 2
97750: PUSH
97751: LD_INT 2
97753: PUSH
97754: LD_INT 4
97756: PUSH
97757: LD_INT 5
97759: PUSH
97760: LD_INT 7
97762: PUSH
97763: LD_INT 11
97765: PUSH
97766: LD_INT 12
97768: PUSH
97769: LD_INT 15
97771: PUSH
97772: LD_INT 16
97774: PUSH
97775: LD_INT 20
97777: PUSH
97778: LD_INT 21
97780: PUSH
97781: LD_INT 22
97783: PUSH
97784: LD_INT 23
97786: PUSH
97787: LD_INT 25
97789: PUSH
97790: LD_INT 26
97792: PUSH
97793: LD_INT 30
97795: PUSH
97796: LD_INT 31
97798: PUSH
97799: LD_INT 32
97801: PUSH
97802: LD_INT 33
97804: PUSH
97805: LD_INT 34
97807: PUSH
97808: LD_INT 35
97810: PUSH
97811: LD_INT 36
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: PUSH
97837: LD_INT 101
97839: PUSH
97840: LD_INT 102
97842: PUSH
97843: LD_INT 103
97845: PUSH
97846: LD_INT 106
97848: PUSH
97849: LD_INT 108
97851: PUSH
97852: LD_INT 112
97854: PUSH
97855: LD_INT 113
97857: PUSH
97858: LD_INT 114
97860: PUSH
97861: LD_INT 115
97863: PUSH
97864: LD_INT 116
97866: PUSH
97867: LD_INT 117
97869: PUSH
97870: LD_INT 118
97872: PUSH
97873: EMPTY
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: PUSH
97887: EMPTY
97888: LIST
97889: LIST
97890: ST_TO_ADDR
97891: GO 98134
97893: LD_INT 19
97895: DOUBLE
97896: EQUAL
97897: IFTRUE 97901
97899: GO 98133
97901: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97902: LD_ADDR_VAR 0 2
97906: PUSH
97907: LD_INT 1
97909: PUSH
97910: LD_INT 2
97912: PUSH
97913: LD_INT 3
97915: PUSH
97916: LD_INT 4
97918: PUSH
97919: LD_INT 5
97921: PUSH
97922: LD_INT 6
97924: PUSH
97925: LD_INT 7
97927: PUSH
97928: LD_INT 8
97930: PUSH
97931: LD_INT 9
97933: PUSH
97934: LD_INT 10
97936: PUSH
97937: LD_INT 11
97939: PUSH
97940: LD_INT 12
97942: PUSH
97943: LD_INT 13
97945: PUSH
97946: LD_INT 14
97948: PUSH
97949: LD_INT 15
97951: PUSH
97952: LD_INT 16
97954: PUSH
97955: LD_INT 17
97957: PUSH
97958: LD_INT 18
97960: PUSH
97961: LD_INT 19
97963: PUSH
97964: LD_INT 20
97966: PUSH
97967: LD_INT 21
97969: PUSH
97970: LD_INT 22
97972: PUSH
97973: LD_INT 23
97975: PUSH
97976: LD_INT 24
97978: PUSH
97979: LD_INT 25
97981: PUSH
97982: LD_INT 26
97984: PUSH
97985: LD_INT 27
97987: PUSH
97988: LD_INT 28
97990: PUSH
97991: LD_INT 29
97993: PUSH
97994: LD_INT 30
97996: PUSH
97997: LD_INT 31
97999: PUSH
98000: LD_INT 32
98002: PUSH
98003: LD_INT 33
98005: PUSH
98006: LD_INT 34
98008: PUSH
98009: LD_INT 35
98011: PUSH
98012: LD_INT 36
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: PUSH
98053: LD_INT 101
98055: PUSH
98056: LD_INT 102
98058: PUSH
98059: LD_INT 103
98061: PUSH
98062: LD_INT 104
98064: PUSH
98065: LD_INT 105
98067: PUSH
98068: LD_INT 106
98070: PUSH
98071: LD_INT 107
98073: PUSH
98074: LD_INT 108
98076: PUSH
98077: LD_INT 109
98079: PUSH
98080: LD_INT 110
98082: PUSH
98083: LD_INT 111
98085: PUSH
98086: LD_INT 112
98088: PUSH
98089: LD_INT 113
98091: PUSH
98092: LD_INT 114
98094: PUSH
98095: LD_INT 115
98097: PUSH
98098: LD_INT 116
98100: PUSH
98101: LD_INT 117
98103: PUSH
98104: LD_INT 118
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: PUSH
98127: EMPTY
98128: LIST
98129: LIST
98130: ST_TO_ADDR
98131: GO 98134
98133: POP
// end else
98134: GO 98365
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98136: LD_ADDR_VAR 0 2
98140: PUSH
98141: LD_INT 1
98143: PUSH
98144: LD_INT 2
98146: PUSH
98147: LD_INT 3
98149: PUSH
98150: LD_INT 4
98152: PUSH
98153: LD_INT 5
98155: PUSH
98156: LD_INT 6
98158: PUSH
98159: LD_INT 7
98161: PUSH
98162: LD_INT 8
98164: PUSH
98165: LD_INT 9
98167: PUSH
98168: LD_INT 10
98170: PUSH
98171: LD_INT 11
98173: PUSH
98174: LD_INT 12
98176: PUSH
98177: LD_INT 13
98179: PUSH
98180: LD_INT 14
98182: PUSH
98183: LD_INT 15
98185: PUSH
98186: LD_INT 16
98188: PUSH
98189: LD_INT 17
98191: PUSH
98192: LD_INT 18
98194: PUSH
98195: LD_INT 19
98197: PUSH
98198: LD_INT 20
98200: PUSH
98201: LD_INT 21
98203: PUSH
98204: LD_INT 22
98206: PUSH
98207: LD_INT 23
98209: PUSH
98210: LD_INT 24
98212: PUSH
98213: LD_INT 25
98215: PUSH
98216: LD_INT 26
98218: PUSH
98219: LD_INT 27
98221: PUSH
98222: LD_INT 28
98224: PUSH
98225: LD_INT 29
98227: PUSH
98228: LD_INT 30
98230: PUSH
98231: LD_INT 31
98233: PUSH
98234: LD_INT 32
98236: PUSH
98237: LD_INT 33
98239: PUSH
98240: LD_INT 34
98242: PUSH
98243: LD_INT 35
98245: PUSH
98246: LD_INT 36
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 101
98289: PUSH
98290: LD_INT 102
98292: PUSH
98293: LD_INT 103
98295: PUSH
98296: LD_INT 104
98298: PUSH
98299: LD_INT 105
98301: PUSH
98302: LD_INT 106
98304: PUSH
98305: LD_INT 107
98307: PUSH
98308: LD_INT 108
98310: PUSH
98311: LD_INT 109
98313: PUSH
98314: LD_INT 110
98316: PUSH
98317: LD_INT 111
98319: PUSH
98320: LD_INT 112
98322: PUSH
98323: LD_INT 113
98325: PUSH
98326: LD_INT 114
98328: PUSH
98329: LD_INT 115
98331: PUSH
98332: LD_INT 116
98334: PUSH
98335: LD_INT 117
98337: PUSH
98338: LD_INT 118
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: ST_TO_ADDR
// if result then
98365: LD_VAR 0 2
98369: IFFALSE 99155
// begin normal :=  ;
98371: LD_ADDR_VAR 0 5
98375: PUSH
98376: LD_STRING 
98378: ST_TO_ADDR
// hardcore :=  ;
98379: LD_ADDR_VAR 0 6
98383: PUSH
98384: LD_STRING 
98386: ST_TO_ADDR
// active :=  ;
98387: LD_ADDR_VAR 0 7
98391: PUSH
98392: LD_STRING 
98394: ST_TO_ADDR
// for i = 1 to normalCounter do
98395: LD_ADDR_VAR 0 8
98399: PUSH
98400: DOUBLE
98401: LD_INT 1
98403: DEC
98404: ST_TO_ADDR
98405: LD_EXP 139
98409: PUSH
98410: FOR_TO
98411: IFFALSE 98512
// begin tmp := 0 ;
98413: LD_ADDR_VAR 0 3
98417: PUSH
98418: LD_STRING 0
98420: ST_TO_ADDR
// if result [ 1 ] then
98421: LD_VAR 0 2
98425: PUSH
98426: LD_INT 1
98428: ARRAY
98429: IFFALSE 98494
// if result [ 1 ] [ 1 ] = i then
98431: LD_VAR 0 2
98435: PUSH
98436: LD_INT 1
98438: ARRAY
98439: PUSH
98440: LD_INT 1
98442: ARRAY
98443: PUSH
98444: LD_VAR 0 8
98448: EQUAL
98449: IFFALSE 98494
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98451: LD_ADDR_VAR 0 2
98455: PUSH
98456: LD_VAR 0 2
98460: PPUSH
98461: LD_INT 1
98463: PPUSH
98464: LD_VAR 0 2
98468: PUSH
98469: LD_INT 1
98471: ARRAY
98472: PPUSH
98473: LD_INT 1
98475: PPUSH
98476: CALL_OW 3
98480: PPUSH
98481: CALL_OW 1
98485: ST_TO_ADDR
// tmp := 1 ;
98486: LD_ADDR_VAR 0 3
98490: PUSH
98491: LD_STRING 1
98493: ST_TO_ADDR
// end ; normal := normal & tmp ;
98494: LD_ADDR_VAR 0 5
98498: PUSH
98499: LD_VAR 0 5
98503: PUSH
98504: LD_VAR 0 3
98508: STR
98509: ST_TO_ADDR
// end ;
98510: GO 98410
98512: POP
98513: POP
// for i = 1 to hardcoreCounter do
98514: LD_ADDR_VAR 0 8
98518: PUSH
98519: DOUBLE
98520: LD_INT 1
98522: DEC
98523: ST_TO_ADDR
98524: LD_EXP 140
98528: PUSH
98529: FOR_TO
98530: IFFALSE 98635
// begin tmp := 0 ;
98532: LD_ADDR_VAR 0 3
98536: PUSH
98537: LD_STRING 0
98539: ST_TO_ADDR
// if result [ 2 ] then
98540: LD_VAR 0 2
98544: PUSH
98545: LD_INT 2
98547: ARRAY
98548: IFFALSE 98617
// if result [ 2 ] [ 1 ] = 100 + i then
98550: LD_VAR 0 2
98554: PUSH
98555: LD_INT 2
98557: ARRAY
98558: PUSH
98559: LD_INT 1
98561: ARRAY
98562: PUSH
98563: LD_INT 100
98565: PUSH
98566: LD_VAR 0 8
98570: PLUS
98571: EQUAL
98572: IFFALSE 98617
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98574: LD_ADDR_VAR 0 2
98578: PUSH
98579: LD_VAR 0 2
98583: PPUSH
98584: LD_INT 2
98586: PPUSH
98587: LD_VAR 0 2
98591: PUSH
98592: LD_INT 2
98594: ARRAY
98595: PPUSH
98596: LD_INT 1
98598: PPUSH
98599: CALL_OW 3
98603: PPUSH
98604: CALL_OW 1
98608: ST_TO_ADDR
// tmp := 1 ;
98609: LD_ADDR_VAR 0 3
98613: PUSH
98614: LD_STRING 1
98616: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98617: LD_ADDR_VAR 0 6
98621: PUSH
98622: LD_VAR 0 6
98626: PUSH
98627: LD_VAR 0 3
98631: STR
98632: ST_TO_ADDR
// end ;
98633: GO 98529
98635: POP
98636: POP
// if isGameLoad then
98637: LD_VAR 0 1
98641: IFFALSE 99116
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98643: LD_ADDR_VAR 0 4
98647: PUSH
98648: LD_EXP 143
98652: PUSH
98653: LD_EXP 142
98657: PUSH
98658: LD_EXP 144
98662: PUSH
98663: LD_EXP 141
98667: PUSH
98668: LD_EXP 145
98672: PUSH
98673: LD_EXP 146
98677: PUSH
98678: LD_EXP 147
98682: PUSH
98683: LD_EXP 148
98687: PUSH
98688: LD_EXP 149
98692: PUSH
98693: LD_EXP 150
98697: PUSH
98698: LD_EXP 151
98702: PUSH
98703: LD_EXP 152
98707: PUSH
98708: LD_EXP 153
98712: PUSH
98713: LD_EXP 154
98717: PUSH
98718: LD_EXP 162
98722: PUSH
98723: LD_EXP 163
98727: PUSH
98728: LD_EXP 164
98732: PUSH
98733: LD_EXP 165
98737: PUSH
98738: LD_EXP 167
98742: PUSH
98743: LD_EXP 168
98747: PUSH
98748: LD_EXP 169
98752: PUSH
98753: LD_EXP 172
98757: PUSH
98758: LD_EXP 174
98762: PUSH
98763: LD_EXP 175
98767: PUSH
98768: LD_EXP 176
98772: PUSH
98773: LD_EXP 178
98777: PUSH
98778: LD_EXP 179
98782: PUSH
98783: LD_EXP 182
98787: PUSH
98788: LD_EXP 183
98792: PUSH
98793: LD_EXP 184
98797: PUSH
98798: LD_EXP 185
98802: PUSH
98803: LD_EXP 186
98807: PUSH
98808: LD_EXP 187
98812: PUSH
98813: LD_EXP 188
98817: PUSH
98818: LD_EXP 189
98822: PUSH
98823: LD_EXP 190
98827: PUSH
98828: LD_EXP 155
98832: PUSH
98833: LD_EXP 156
98837: PUSH
98838: LD_EXP 159
98842: PUSH
98843: LD_EXP 160
98847: PUSH
98848: LD_EXP 161
98852: PUSH
98853: LD_EXP 157
98857: PUSH
98858: LD_EXP 158
98862: PUSH
98863: LD_EXP 166
98867: PUSH
98868: LD_EXP 170
98872: PUSH
98873: LD_EXP 171
98877: PUSH
98878: LD_EXP 173
98882: PUSH
98883: LD_EXP 177
98887: PUSH
98888: LD_EXP 180
98892: PUSH
98893: LD_EXP 181
98897: PUSH
98898: LD_EXP 191
98902: PUSH
98903: LD_EXP 192
98907: PUSH
98908: LD_EXP 193
98912: PUSH
98913: LD_EXP 194
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: ST_TO_ADDR
// tmp :=  ;
98974: LD_ADDR_VAR 0 3
98978: PUSH
98979: LD_STRING 
98981: ST_TO_ADDR
// for i = 1 to normalCounter do
98982: LD_ADDR_VAR 0 8
98986: PUSH
98987: DOUBLE
98988: LD_INT 1
98990: DEC
98991: ST_TO_ADDR
98992: LD_EXP 139
98996: PUSH
98997: FOR_TO
98998: IFFALSE 99034
// begin if flags [ i ] then
99000: LD_VAR 0 4
99004: PUSH
99005: LD_VAR 0 8
99009: ARRAY
99010: IFFALSE 99032
// tmp := tmp & i & ; ;
99012: LD_ADDR_VAR 0 3
99016: PUSH
99017: LD_VAR 0 3
99021: PUSH
99022: LD_VAR 0 8
99026: STR
99027: PUSH
99028: LD_STRING ;
99030: STR
99031: ST_TO_ADDR
// end ;
99032: GO 98997
99034: POP
99035: POP
// for i = 1 to hardcoreCounter do
99036: LD_ADDR_VAR 0 8
99040: PUSH
99041: DOUBLE
99042: LD_INT 1
99044: DEC
99045: ST_TO_ADDR
99046: LD_EXP 140
99050: PUSH
99051: FOR_TO
99052: IFFALSE 99098
// begin if flags [ normalCounter + i ] then
99054: LD_VAR 0 4
99058: PUSH
99059: LD_EXP 139
99063: PUSH
99064: LD_VAR 0 8
99068: PLUS
99069: ARRAY
99070: IFFALSE 99096
// tmp := tmp & ( 100 + i ) & ; ;
99072: LD_ADDR_VAR 0 3
99076: PUSH
99077: LD_VAR 0 3
99081: PUSH
99082: LD_INT 100
99084: PUSH
99085: LD_VAR 0 8
99089: PLUS
99090: STR
99091: PUSH
99092: LD_STRING ;
99094: STR
99095: ST_TO_ADDR
// end ;
99096: GO 99051
99098: POP
99099: POP
// if tmp then
99100: LD_VAR 0 3
99104: IFFALSE 99116
// active := tmp ;
99106: LD_ADDR_VAR 0 7
99110: PUSH
99111: LD_VAR 0 3
99115: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99116: LD_STRING getStreamItemsFromMission("
99118: PUSH
99119: LD_VAR 0 5
99123: STR
99124: PUSH
99125: LD_STRING ","
99127: STR
99128: PUSH
99129: LD_VAR 0 6
99133: STR
99134: PUSH
99135: LD_STRING ","
99137: STR
99138: PUSH
99139: LD_VAR 0 7
99143: STR
99144: PUSH
99145: LD_STRING ")
99147: STR
99148: PPUSH
99149: CALL_OW 559
// end else
99153: GO 99162
// ToLua ( getStreamItemsFromMission("","","") ) ;
99155: LD_STRING getStreamItemsFromMission("","","")
99157: PPUSH
99158: CALL_OW 559
// end ;
99162: LD_VAR 0 2
99166: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99167: LD_EXP 138
99171: PUSH
99172: LD_EXP 143
99176: AND
99177: IFFALSE 99301
99179: GO 99181
99181: DISABLE
99182: LD_INT 0
99184: PPUSH
99185: PPUSH
// begin enable ;
99186: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99187: LD_ADDR_VAR 0 2
99191: PUSH
99192: LD_INT 22
99194: PUSH
99195: LD_OWVAR 2
99199: PUSH
99200: EMPTY
99201: LIST
99202: LIST
99203: PUSH
99204: LD_INT 2
99206: PUSH
99207: LD_INT 34
99209: PUSH
99210: LD_INT 7
99212: PUSH
99213: EMPTY
99214: LIST
99215: LIST
99216: PUSH
99217: LD_INT 34
99219: PUSH
99220: LD_INT 45
99222: PUSH
99223: EMPTY
99224: LIST
99225: LIST
99226: PUSH
99227: LD_INT 34
99229: PUSH
99230: LD_INT 28
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: PUSH
99237: LD_INT 34
99239: PUSH
99240: LD_INT 47
99242: PUSH
99243: EMPTY
99244: LIST
99245: LIST
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: PUSH
99254: EMPTY
99255: LIST
99256: LIST
99257: PPUSH
99258: CALL_OW 69
99262: ST_TO_ADDR
// if not tmp then
99263: LD_VAR 0 2
99267: NOT
99268: IFFALSE 99272
// exit ;
99270: GO 99301
// for i in tmp do
99272: LD_ADDR_VAR 0 1
99276: PUSH
99277: LD_VAR 0 2
99281: PUSH
99282: FOR_IN
99283: IFFALSE 99299
// begin SetLives ( i , 0 ) ;
99285: LD_VAR 0 1
99289: PPUSH
99290: LD_INT 0
99292: PPUSH
99293: CALL_OW 234
// end ;
99297: GO 99282
99299: POP
99300: POP
// end ;
99301: PPOPN 2
99303: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99304: LD_EXP 138
99308: PUSH
99309: LD_EXP 144
99313: AND
99314: IFFALSE 99398
99316: GO 99318
99318: DISABLE
99319: LD_INT 0
99321: PPUSH
99322: PPUSH
// begin enable ;
99323: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99324: LD_ADDR_VAR 0 2
99328: PUSH
99329: LD_INT 22
99331: PUSH
99332: LD_OWVAR 2
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: PUSH
99341: LD_INT 32
99343: PUSH
99344: LD_INT 3
99346: PUSH
99347: EMPTY
99348: LIST
99349: LIST
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PPUSH
99355: CALL_OW 69
99359: ST_TO_ADDR
// if not tmp then
99360: LD_VAR 0 2
99364: NOT
99365: IFFALSE 99369
// exit ;
99367: GO 99398
// for i in tmp do
99369: LD_ADDR_VAR 0 1
99373: PUSH
99374: LD_VAR 0 2
99378: PUSH
99379: FOR_IN
99380: IFFALSE 99396
// begin SetLives ( i , 0 ) ;
99382: LD_VAR 0 1
99386: PPUSH
99387: LD_INT 0
99389: PPUSH
99390: CALL_OW 234
// end ;
99394: GO 99379
99396: POP
99397: POP
// end ;
99398: PPOPN 2
99400: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99401: LD_EXP 138
99405: PUSH
99406: LD_EXP 141
99410: AND
99411: IFFALSE 99504
99413: GO 99415
99415: DISABLE
99416: LD_INT 0
99418: PPUSH
// begin enable ;
99419: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99420: LD_ADDR_VAR 0 1
99424: PUSH
99425: LD_INT 22
99427: PUSH
99428: LD_OWVAR 2
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: LD_INT 2
99439: PUSH
99440: LD_INT 25
99442: PUSH
99443: LD_INT 5
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: LD_INT 25
99452: PUSH
99453: LD_INT 9
99455: PUSH
99456: EMPTY
99457: LIST
99458: LIST
99459: PUSH
99460: LD_INT 25
99462: PUSH
99463: LD_INT 8
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: LIST
99474: LIST
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PPUSH
99480: CALL_OW 69
99484: PUSH
99485: FOR_IN
99486: IFFALSE 99502
// begin SetClass ( i , 1 ) ;
99488: LD_VAR 0 1
99492: PPUSH
99493: LD_INT 1
99495: PPUSH
99496: CALL_OW 336
// end ;
99500: GO 99485
99502: POP
99503: POP
// end ;
99504: PPOPN 1
99506: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99507: LD_EXP 138
99511: PUSH
99512: LD_EXP 142
99516: AND
99517: PUSH
99518: LD_OWVAR 65
99522: PUSH
99523: LD_INT 7
99525: LESS
99526: AND
99527: IFFALSE 99541
99529: GO 99531
99531: DISABLE
// begin enable ;
99532: ENABLE
// game_speed := 7 ;
99533: LD_ADDR_OWVAR 65
99537: PUSH
99538: LD_INT 7
99540: ST_TO_ADDR
// end ;
99541: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99542: LD_EXP 138
99546: PUSH
99547: LD_EXP 145
99551: AND
99552: IFFALSE 99754
99554: GO 99556
99556: DISABLE
99557: LD_INT 0
99559: PPUSH
99560: PPUSH
99561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99562: LD_ADDR_VAR 0 3
99566: PUSH
99567: LD_INT 81
99569: PUSH
99570: LD_OWVAR 2
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: PUSH
99579: LD_INT 21
99581: PUSH
99582: LD_INT 1
99584: PUSH
99585: EMPTY
99586: LIST
99587: LIST
99588: PUSH
99589: EMPTY
99590: LIST
99591: LIST
99592: PPUSH
99593: CALL_OW 69
99597: ST_TO_ADDR
// if not tmp then
99598: LD_VAR 0 3
99602: NOT
99603: IFFALSE 99607
// exit ;
99605: GO 99754
// if tmp > 5 then
99607: LD_VAR 0 3
99611: PUSH
99612: LD_INT 5
99614: GREATER
99615: IFFALSE 99627
// k := 5 else
99617: LD_ADDR_VAR 0 2
99621: PUSH
99622: LD_INT 5
99624: ST_TO_ADDR
99625: GO 99637
// k := tmp ;
99627: LD_ADDR_VAR 0 2
99631: PUSH
99632: LD_VAR 0 3
99636: ST_TO_ADDR
// for i := 1 to k do
99637: LD_ADDR_VAR 0 1
99641: PUSH
99642: DOUBLE
99643: LD_INT 1
99645: DEC
99646: ST_TO_ADDR
99647: LD_VAR 0 2
99651: PUSH
99652: FOR_TO
99653: IFFALSE 99752
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99655: LD_VAR 0 3
99659: PUSH
99660: LD_VAR 0 1
99664: ARRAY
99665: PPUSH
99666: LD_VAR 0 1
99670: PUSH
99671: LD_INT 4
99673: MOD
99674: PUSH
99675: LD_INT 1
99677: PLUS
99678: PPUSH
99679: CALL_OW 259
99683: PUSH
99684: LD_INT 10
99686: LESS
99687: IFFALSE 99750
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99689: LD_VAR 0 3
99693: PUSH
99694: LD_VAR 0 1
99698: ARRAY
99699: PPUSH
99700: LD_VAR 0 1
99704: PUSH
99705: LD_INT 4
99707: MOD
99708: PUSH
99709: LD_INT 1
99711: PLUS
99712: PPUSH
99713: LD_VAR 0 3
99717: PUSH
99718: LD_VAR 0 1
99722: ARRAY
99723: PPUSH
99724: LD_VAR 0 1
99728: PUSH
99729: LD_INT 4
99731: MOD
99732: PUSH
99733: LD_INT 1
99735: PLUS
99736: PPUSH
99737: CALL_OW 259
99741: PUSH
99742: LD_INT 1
99744: PLUS
99745: PPUSH
99746: CALL_OW 237
99750: GO 99652
99752: POP
99753: POP
// end ;
99754: PPOPN 3
99756: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99757: LD_EXP 138
99761: PUSH
99762: LD_EXP 146
99766: AND
99767: IFFALSE 99787
99769: GO 99771
99771: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99772: LD_INT 4
99774: PPUSH
99775: LD_OWVAR 2
99779: PPUSH
99780: LD_INT 0
99782: PPUSH
99783: CALL_OW 324
99787: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99788: LD_EXP 138
99792: PUSH
99793: LD_EXP 175
99797: AND
99798: IFFALSE 99818
99800: GO 99802
99802: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99803: LD_INT 19
99805: PPUSH
99806: LD_OWVAR 2
99810: PPUSH
99811: LD_INT 0
99813: PPUSH
99814: CALL_OW 324
99818: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99819: LD_EXP 138
99823: PUSH
99824: LD_EXP 147
99828: AND
99829: IFFALSE 99931
99831: GO 99833
99833: DISABLE
99834: LD_INT 0
99836: PPUSH
99837: PPUSH
// begin enable ;
99838: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99839: LD_ADDR_VAR 0 2
99843: PUSH
99844: LD_INT 22
99846: PUSH
99847: LD_OWVAR 2
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: PUSH
99856: LD_INT 2
99858: PUSH
99859: LD_INT 34
99861: PUSH
99862: LD_INT 11
99864: PUSH
99865: EMPTY
99866: LIST
99867: LIST
99868: PUSH
99869: LD_INT 34
99871: PUSH
99872: LD_INT 30
99874: PUSH
99875: EMPTY
99876: LIST
99877: LIST
99878: PUSH
99879: EMPTY
99880: LIST
99881: LIST
99882: LIST
99883: PUSH
99884: EMPTY
99885: LIST
99886: LIST
99887: PPUSH
99888: CALL_OW 69
99892: ST_TO_ADDR
// if not tmp then
99893: LD_VAR 0 2
99897: NOT
99898: IFFALSE 99902
// exit ;
99900: GO 99931
// for i in tmp do
99902: LD_ADDR_VAR 0 1
99906: PUSH
99907: LD_VAR 0 2
99911: PUSH
99912: FOR_IN
99913: IFFALSE 99929
// begin SetLives ( i , 0 ) ;
99915: LD_VAR 0 1
99919: PPUSH
99920: LD_INT 0
99922: PPUSH
99923: CALL_OW 234
// end ;
99927: GO 99912
99929: POP
99930: POP
// end ;
99931: PPOPN 2
99933: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99934: LD_EXP 138
99938: PUSH
99939: LD_EXP 148
99943: AND
99944: IFFALSE 99964
99946: GO 99948
99948: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99949: LD_INT 32
99951: PPUSH
99952: LD_OWVAR 2
99956: PPUSH
99957: LD_INT 0
99959: PPUSH
99960: CALL_OW 324
99964: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99965: LD_EXP 138
99969: PUSH
99970: LD_EXP 149
99974: AND
99975: IFFALSE 100156
99977: GO 99979
99979: DISABLE
99980: LD_INT 0
99982: PPUSH
99983: PPUSH
99984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99985: LD_ADDR_VAR 0 2
99989: PUSH
99990: LD_INT 22
99992: PUSH
99993: LD_OWVAR 2
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PUSH
100002: LD_INT 33
100004: PUSH
100005: LD_INT 3
100007: PUSH
100008: EMPTY
100009: LIST
100010: LIST
100011: PUSH
100012: EMPTY
100013: LIST
100014: LIST
100015: PPUSH
100016: CALL_OW 69
100020: ST_TO_ADDR
// if not tmp then
100021: LD_VAR 0 2
100025: NOT
100026: IFFALSE 100030
// exit ;
100028: GO 100156
// side := 0 ;
100030: LD_ADDR_VAR 0 3
100034: PUSH
100035: LD_INT 0
100037: ST_TO_ADDR
// for i := 1 to 8 do
100038: LD_ADDR_VAR 0 1
100042: PUSH
100043: DOUBLE
100044: LD_INT 1
100046: DEC
100047: ST_TO_ADDR
100048: LD_INT 8
100050: PUSH
100051: FOR_TO
100052: IFFALSE 100100
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100054: LD_OWVAR 2
100058: PUSH
100059: LD_VAR 0 1
100063: NONEQUAL
100064: PUSH
100065: LD_OWVAR 2
100069: PPUSH
100070: LD_VAR 0 1
100074: PPUSH
100075: CALL_OW 81
100079: PUSH
100080: LD_INT 2
100082: EQUAL
100083: AND
100084: IFFALSE 100098
// begin side := i ;
100086: LD_ADDR_VAR 0 3
100090: PUSH
100091: LD_VAR 0 1
100095: ST_TO_ADDR
// break ;
100096: GO 100100
// end ;
100098: GO 100051
100100: POP
100101: POP
// if not side then
100102: LD_VAR 0 3
100106: NOT
100107: IFFALSE 100111
// exit ;
100109: GO 100156
// for i := 1 to tmp do
100111: LD_ADDR_VAR 0 1
100115: PUSH
100116: DOUBLE
100117: LD_INT 1
100119: DEC
100120: ST_TO_ADDR
100121: LD_VAR 0 2
100125: PUSH
100126: FOR_TO
100127: IFFALSE 100154
// if Prob ( 60 ) then
100129: LD_INT 60
100131: PPUSH
100132: CALL_OW 13
100136: IFFALSE 100152
// SetSide ( i , side ) ;
100138: LD_VAR 0 1
100142: PPUSH
100143: LD_VAR 0 3
100147: PPUSH
100148: CALL_OW 235
100152: GO 100126
100154: POP
100155: POP
// end ;
100156: PPOPN 3
100158: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100159: LD_EXP 138
100163: PUSH
100164: LD_EXP 151
100168: AND
100169: IFFALSE 100288
100171: GO 100173
100173: DISABLE
100174: LD_INT 0
100176: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100177: LD_ADDR_VAR 0 1
100181: PUSH
100182: LD_INT 22
100184: PUSH
100185: LD_OWVAR 2
100189: PUSH
100190: EMPTY
100191: LIST
100192: LIST
100193: PUSH
100194: LD_INT 21
100196: PUSH
100197: LD_INT 1
100199: PUSH
100200: EMPTY
100201: LIST
100202: LIST
100203: PUSH
100204: LD_INT 3
100206: PUSH
100207: LD_INT 23
100209: PUSH
100210: LD_INT 0
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: PUSH
100217: EMPTY
100218: LIST
100219: LIST
100220: PUSH
100221: EMPTY
100222: LIST
100223: LIST
100224: LIST
100225: PPUSH
100226: CALL_OW 69
100230: PUSH
100231: FOR_IN
100232: IFFALSE 100286
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100234: LD_VAR 0 1
100238: PPUSH
100239: CALL_OW 257
100243: PUSH
100244: LD_INT 1
100246: PUSH
100247: LD_INT 2
100249: PUSH
100250: LD_INT 3
100252: PUSH
100253: LD_INT 4
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: LIST
100260: LIST
100261: IN
100262: IFFALSE 100284
// SetClass ( un , rand ( 1 , 4 ) ) ;
100264: LD_VAR 0 1
100268: PPUSH
100269: LD_INT 1
100271: PPUSH
100272: LD_INT 4
100274: PPUSH
100275: CALL_OW 12
100279: PPUSH
100280: CALL_OW 336
100284: GO 100231
100286: POP
100287: POP
// end ;
100288: PPOPN 1
100290: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100291: LD_EXP 138
100295: PUSH
100296: LD_EXP 150
100300: AND
100301: IFFALSE 100380
100303: GO 100305
100305: DISABLE
100306: LD_INT 0
100308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100309: LD_ADDR_VAR 0 1
100313: PUSH
100314: LD_INT 22
100316: PUSH
100317: LD_OWVAR 2
100321: PUSH
100322: EMPTY
100323: LIST
100324: LIST
100325: PUSH
100326: LD_INT 21
100328: PUSH
100329: LD_INT 3
100331: PUSH
100332: EMPTY
100333: LIST
100334: LIST
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PPUSH
100340: CALL_OW 69
100344: ST_TO_ADDR
// if not tmp then
100345: LD_VAR 0 1
100349: NOT
100350: IFFALSE 100354
// exit ;
100352: GO 100380
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100354: LD_VAR 0 1
100358: PUSH
100359: LD_INT 1
100361: PPUSH
100362: LD_VAR 0 1
100366: PPUSH
100367: CALL_OW 12
100371: ARRAY
100372: PPUSH
100373: LD_INT 100
100375: PPUSH
100376: CALL_OW 234
// end ;
100380: PPOPN 1
100382: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100383: LD_EXP 138
100387: PUSH
100388: LD_EXP 152
100392: AND
100393: IFFALSE 100491
100395: GO 100397
100397: DISABLE
100398: LD_INT 0
100400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100401: LD_ADDR_VAR 0 1
100405: PUSH
100406: LD_INT 22
100408: PUSH
100409: LD_OWVAR 2
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: LD_INT 21
100420: PUSH
100421: LD_INT 1
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: PUSH
100428: EMPTY
100429: LIST
100430: LIST
100431: PPUSH
100432: CALL_OW 69
100436: ST_TO_ADDR
// if not tmp then
100437: LD_VAR 0 1
100441: NOT
100442: IFFALSE 100446
// exit ;
100444: GO 100491
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100446: LD_VAR 0 1
100450: PUSH
100451: LD_INT 1
100453: PPUSH
100454: LD_VAR 0 1
100458: PPUSH
100459: CALL_OW 12
100463: ARRAY
100464: PPUSH
100465: LD_INT 1
100467: PPUSH
100468: LD_INT 4
100470: PPUSH
100471: CALL_OW 12
100475: PPUSH
100476: LD_INT 3000
100478: PPUSH
100479: LD_INT 9000
100481: PPUSH
100482: CALL_OW 12
100486: PPUSH
100487: CALL_OW 492
// end ;
100491: PPOPN 1
100493: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100494: LD_EXP 138
100498: PUSH
100499: LD_EXP 153
100503: AND
100504: IFFALSE 100524
100506: GO 100508
100508: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100509: LD_INT 1
100511: PPUSH
100512: LD_OWVAR 2
100516: PPUSH
100517: LD_INT 0
100519: PPUSH
100520: CALL_OW 324
100524: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100525: LD_EXP 138
100529: PUSH
100530: LD_EXP 154
100534: AND
100535: IFFALSE 100618
100537: GO 100539
100539: DISABLE
100540: LD_INT 0
100542: PPUSH
100543: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100544: LD_ADDR_VAR 0 2
100548: PUSH
100549: LD_INT 22
100551: PUSH
100552: LD_OWVAR 2
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: PUSH
100561: LD_INT 21
100563: PUSH
100564: LD_INT 3
100566: PUSH
100567: EMPTY
100568: LIST
100569: LIST
100570: PUSH
100571: EMPTY
100572: LIST
100573: LIST
100574: PPUSH
100575: CALL_OW 69
100579: ST_TO_ADDR
// if not tmp then
100580: LD_VAR 0 2
100584: NOT
100585: IFFALSE 100589
// exit ;
100587: GO 100618
// for i in tmp do
100589: LD_ADDR_VAR 0 1
100593: PUSH
100594: LD_VAR 0 2
100598: PUSH
100599: FOR_IN
100600: IFFALSE 100616
// SetBLevel ( i , 10 ) ;
100602: LD_VAR 0 1
100606: PPUSH
100607: LD_INT 10
100609: PPUSH
100610: CALL_OW 241
100614: GO 100599
100616: POP
100617: POP
// end ;
100618: PPOPN 2
100620: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100621: LD_EXP 138
100625: PUSH
100626: LD_EXP 155
100630: AND
100631: IFFALSE 100742
100633: GO 100635
100635: DISABLE
100636: LD_INT 0
100638: PPUSH
100639: PPUSH
100640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100641: LD_ADDR_VAR 0 3
100645: PUSH
100646: LD_INT 22
100648: PUSH
100649: LD_OWVAR 2
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PUSH
100658: LD_INT 25
100660: PUSH
100661: LD_INT 1
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: PUSH
100668: EMPTY
100669: LIST
100670: LIST
100671: PPUSH
100672: CALL_OW 69
100676: ST_TO_ADDR
// if not tmp then
100677: LD_VAR 0 3
100681: NOT
100682: IFFALSE 100686
// exit ;
100684: GO 100742
// un := tmp [ rand ( 1 , tmp ) ] ;
100686: LD_ADDR_VAR 0 2
100690: PUSH
100691: LD_VAR 0 3
100695: PUSH
100696: LD_INT 1
100698: PPUSH
100699: LD_VAR 0 3
100703: PPUSH
100704: CALL_OW 12
100708: ARRAY
100709: ST_TO_ADDR
// if Crawls ( un ) then
100710: LD_VAR 0 2
100714: PPUSH
100715: CALL_OW 318
100719: IFFALSE 100730
// ComWalk ( un ) ;
100721: LD_VAR 0 2
100725: PPUSH
100726: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100730: LD_VAR 0 2
100734: PPUSH
100735: LD_INT 5
100737: PPUSH
100738: CALL_OW 336
// end ;
100742: PPOPN 3
100744: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100745: LD_EXP 138
100749: PUSH
100750: LD_EXP 156
100754: AND
100755: PUSH
100756: LD_OWVAR 67
100760: PUSH
100761: LD_INT 4
100763: LESS
100764: AND
100765: IFFALSE 100784
100767: GO 100769
100769: DISABLE
// begin Difficulty := Difficulty + 1 ;
100770: LD_ADDR_OWVAR 67
100774: PUSH
100775: LD_OWVAR 67
100779: PUSH
100780: LD_INT 1
100782: PLUS
100783: ST_TO_ADDR
// end ;
100784: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100785: LD_EXP 138
100789: PUSH
100790: LD_EXP 157
100794: AND
100795: IFFALSE 100898
100797: GO 100799
100799: DISABLE
100800: LD_INT 0
100802: PPUSH
// begin for i := 1 to 5 do
100803: LD_ADDR_VAR 0 1
100807: PUSH
100808: DOUBLE
100809: LD_INT 1
100811: DEC
100812: ST_TO_ADDR
100813: LD_INT 5
100815: PUSH
100816: FOR_TO
100817: IFFALSE 100896
// begin uc_nation := nation_nature ;
100819: LD_ADDR_OWVAR 21
100823: PUSH
100824: LD_INT 0
100826: ST_TO_ADDR
// uc_side := 0 ;
100827: LD_ADDR_OWVAR 20
100831: PUSH
100832: LD_INT 0
100834: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100835: LD_ADDR_OWVAR 29
100839: PUSH
100840: LD_INT 12
100842: PUSH
100843: LD_INT 12
100845: PUSH
100846: EMPTY
100847: LIST
100848: LIST
100849: ST_TO_ADDR
// hc_agressivity := 20 ;
100850: LD_ADDR_OWVAR 35
100854: PUSH
100855: LD_INT 20
100857: ST_TO_ADDR
// hc_class := class_tiger ;
100858: LD_ADDR_OWVAR 28
100862: PUSH
100863: LD_INT 14
100865: ST_TO_ADDR
// hc_gallery :=  ;
100866: LD_ADDR_OWVAR 33
100870: PUSH
100871: LD_STRING 
100873: ST_TO_ADDR
// hc_name :=  ;
100874: LD_ADDR_OWVAR 26
100878: PUSH
100879: LD_STRING 
100881: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100882: CALL_OW 44
100886: PPUSH
100887: LD_INT 0
100889: PPUSH
100890: CALL_OW 51
// end ;
100894: GO 100816
100896: POP
100897: POP
// end ;
100898: PPOPN 1
100900: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100901: LD_EXP 138
100905: PUSH
100906: LD_EXP 158
100910: AND
100911: IFFALSE 100920
100913: GO 100915
100915: DISABLE
// StreamSibBomb ;
100916: CALL 100921 0 0
100920: END
// export function StreamSibBomb ; var i , x , y ; begin
100921: LD_INT 0
100923: PPUSH
100924: PPUSH
100925: PPUSH
100926: PPUSH
// result := false ;
100927: LD_ADDR_VAR 0 1
100931: PUSH
100932: LD_INT 0
100934: ST_TO_ADDR
// for i := 1 to 16 do
100935: LD_ADDR_VAR 0 2
100939: PUSH
100940: DOUBLE
100941: LD_INT 1
100943: DEC
100944: ST_TO_ADDR
100945: LD_INT 16
100947: PUSH
100948: FOR_TO
100949: IFFALSE 101148
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100951: LD_ADDR_VAR 0 3
100955: PUSH
100956: LD_INT 10
100958: PUSH
100959: LD_INT 20
100961: PUSH
100962: LD_INT 30
100964: PUSH
100965: LD_INT 40
100967: PUSH
100968: LD_INT 50
100970: PUSH
100971: LD_INT 60
100973: PUSH
100974: LD_INT 70
100976: PUSH
100977: LD_INT 80
100979: PUSH
100980: LD_INT 90
100982: PUSH
100983: LD_INT 100
100985: PUSH
100986: LD_INT 110
100988: PUSH
100989: LD_INT 120
100991: PUSH
100992: LD_INT 130
100994: PUSH
100995: LD_INT 140
100997: PUSH
100998: LD_INT 150
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: PUSH
101018: LD_INT 1
101020: PPUSH
101021: LD_INT 15
101023: PPUSH
101024: CALL_OW 12
101028: ARRAY
101029: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101030: LD_ADDR_VAR 0 4
101034: PUSH
101035: LD_INT 10
101037: PUSH
101038: LD_INT 20
101040: PUSH
101041: LD_INT 30
101043: PUSH
101044: LD_INT 40
101046: PUSH
101047: LD_INT 50
101049: PUSH
101050: LD_INT 60
101052: PUSH
101053: LD_INT 70
101055: PUSH
101056: LD_INT 80
101058: PUSH
101059: LD_INT 90
101061: PUSH
101062: LD_INT 100
101064: PUSH
101065: LD_INT 110
101067: PUSH
101068: LD_INT 120
101070: PUSH
101071: LD_INT 130
101073: PUSH
101074: LD_INT 140
101076: PUSH
101077: LD_INT 150
101079: PUSH
101080: EMPTY
101081: LIST
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: PUSH
101097: LD_INT 1
101099: PPUSH
101100: LD_INT 15
101102: PPUSH
101103: CALL_OW 12
101107: ARRAY
101108: ST_TO_ADDR
// if ValidHex ( x , y ) then
101109: LD_VAR 0 3
101113: PPUSH
101114: LD_VAR 0 4
101118: PPUSH
101119: CALL_OW 488
101123: IFFALSE 101146
// begin result := [ x , y ] ;
101125: LD_ADDR_VAR 0 1
101129: PUSH
101130: LD_VAR 0 3
101134: PUSH
101135: LD_VAR 0 4
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: ST_TO_ADDR
// break ;
101144: GO 101148
// end ; end ;
101146: GO 100948
101148: POP
101149: POP
// if result then
101150: LD_VAR 0 1
101154: IFFALSE 101214
// begin ToLua ( playSibBomb() ) ;
101156: LD_STRING playSibBomb()
101158: PPUSH
101159: CALL_OW 559
// wait ( 0 0$14 ) ;
101163: LD_INT 490
101165: PPUSH
101166: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101170: LD_VAR 0 1
101174: PUSH
101175: LD_INT 1
101177: ARRAY
101178: PPUSH
101179: LD_VAR 0 1
101183: PUSH
101184: LD_INT 2
101186: ARRAY
101187: PPUSH
101188: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101192: LD_VAR 0 1
101196: PUSH
101197: LD_INT 1
101199: ARRAY
101200: PPUSH
101201: LD_VAR 0 1
101205: PUSH
101206: LD_INT 2
101208: ARRAY
101209: PPUSH
101210: CALL_OW 429
// end ; end ;
101214: LD_VAR 0 1
101218: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101219: LD_EXP 138
101223: PUSH
101224: LD_EXP 160
101228: AND
101229: IFFALSE 101241
101231: GO 101233
101233: DISABLE
// YouLost (  ) ;
101234: LD_STRING 
101236: PPUSH
101237: CALL_OW 104
101241: END
// every 0 0$1 trigger StreamModeActive and sFog do
101242: LD_EXP 138
101246: PUSH
101247: LD_EXP 159
101251: AND
101252: IFFALSE 101266
101254: GO 101256
101256: DISABLE
// FogOff ( your_side ) ;
101257: LD_OWVAR 2
101261: PPUSH
101262: CALL_OW 344
101266: END
// every 0 0$1 trigger StreamModeActive and sSun do
101267: LD_EXP 138
101271: PUSH
101272: LD_EXP 161
101276: AND
101277: IFFALSE 101305
101279: GO 101281
101281: DISABLE
// begin solar_recharge_percent := 0 ;
101282: LD_ADDR_OWVAR 79
101286: PUSH
101287: LD_INT 0
101289: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101290: LD_INT 10500
101292: PPUSH
101293: CALL_OW 67
// solar_recharge_percent := 100 ;
101297: LD_ADDR_OWVAR 79
101301: PUSH
101302: LD_INT 100
101304: ST_TO_ADDR
// end ;
101305: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101306: LD_EXP 138
101310: PUSH
101311: LD_EXP 162
101315: AND
101316: IFFALSE 101555
101318: GO 101320
101320: DISABLE
101321: LD_INT 0
101323: PPUSH
101324: PPUSH
101325: PPUSH
// begin tmp := [ ] ;
101326: LD_ADDR_VAR 0 3
101330: PUSH
101331: EMPTY
101332: ST_TO_ADDR
// for i := 1 to 6 do
101333: LD_ADDR_VAR 0 1
101337: PUSH
101338: DOUBLE
101339: LD_INT 1
101341: DEC
101342: ST_TO_ADDR
101343: LD_INT 6
101345: PUSH
101346: FOR_TO
101347: IFFALSE 101452
// begin uc_nation := nation_nature ;
101349: LD_ADDR_OWVAR 21
101353: PUSH
101354: LD_INT 0
101356: ST_TO_ADDR
// uc_side := 0 ;
101357: LD_ADDR_OWVAR 20
101361: PUSH
101362: LD_INT 0
101364: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101365: LD_ADDR_OWVAR 29
101369: PUSH
101370: LD_INT 12
101372: PUSH
101373: LD_INT 12
101375: PUSH
101376: EMPTY
101377: LIST
101378: LIST
101379: ST_TO_ADDR
// hc_agressivity := 20 ;
101380: LD_ADDR_OWVAR 35
101384: PUSH
101385: LD_INT 20
101387: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101388: LD_ADDR_OWVAR 28
101392: PUSH
101393: LD_INT 17
101395: ST_TO_ADDR
// hc_gallery :=  ;
101396: LD_ADDR_OWVAR 33
101400: PUSH
101401: LD_STRING 
101403: ST_TO_ADDR
// hc_name :=  ;
101404: LD_ADDR_OWVAR 26
101408: PUSH
101409: LD_STRING 
101411: ST_TO_ADDR
// un := CreateHuman ;
101412: LD_ADDR_VAR 0 2
101416: PUSH
101417: CALL_OW 44
101421: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101422: LD_VAR 0 2
101426: PPUSH
101427: LD_INT 1
101429: PPUSH
101430: CALL_OW 51
// tmp := tmp ^ un ;
101434: LD_ADDR_VAR 0 3
101438: PUSH
101439: LD_VAR 0 3
101443: PUSH
101444: LD_VAR 0 2
101448: ADD
101449: ST_TO_ADDR
// end ;
101450: GO 101346
101452: POP
101453: POP
// repeat wait ( 0 0$1 ) ;
101454: LD_INT 35
101456: PPUSH
101457: CALL_OW 67
// for un in tmp do
101461: LD_ADDR_VAR 0 2
101465: PUSH
101466: LD_VAR 0 3
101470: PUSH
101471: FOR_IN
101472: IFFALSE 101546
// begin if IsDead ( un ) then
101474: LD_VAR 0 2
101478: PPUSH
101479: CALL_OW 301
101483: IFFALSE 101503
// begin tmp := tmp diff un ;
101485: LD_ADDR_VAR 0 3
101489: PUSH
101490: LD_VAR 0 3
101494: PUSH
101495: LD_VAR 0 2
101499: DIFF
101500: ST_TO_ADDR
// continue ;
101501: GO 101471
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101503: LD_VAR 0 2
101507: PPUSH
101508: LD_INT 3
101510: PUSH
101511: LD_INT 22
101513: PUSH
101514: LD_INT 0
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL_OW 69
101529: PPUSH
101530: LD_VAR 0 2
101534: PPUSH
101535: CALL_OW 74
101539: PPUSH
101540: CALL_OW 115
// end ;
101544: GO 101471
101546: POP
101547: POP
// until not tmp ;
101548: LD_VAR 0 3
101552: NOT
101553: IFFALSE 101454
// end ;
101555: PPOPN 3
101557: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101558: LD_EXP 138
101562: PUSH
101563: LD_EXP 163
101567: AND
101568: IFFALSE 101622
101570: GO 101572
101572: DISABLE
// begin ToLua ( displayTroll(); ) ;
101573: LD_STRING displayTroll();
101575: PPUSH
101576: CALL_OW 559
// wait ( 3 3$00 ) ;
101580: LD_INT 6300
101582: PPUSH
101583: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101587: LD_STRING hideTroll();
101589: PPUSH
101590: CALL_OW 559
// wait ( 1 1$00 ) ;
101594: LD_INT 2100
101596: PPUSH
101597: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101601: LD_STRING displayTroll();
101603: PPUSH
101604: CALL_OW 559
// wait ( 1 1$00 ) ;
101608: LD_INT 2100
101610: PPUSH
101611: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101615: LD_STRING hideTroll();
101617: PPUSH
101618: CALL_OW 559
// end ;
101622: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101623: LD_EXP 138
101627: PUSH
101628: LD_EXP 164
101632: AND
101633: IFFALSE 101696
101635: GO 101637
101637: DISABLE
101638: LD_INT 0
101640: PPUSH
// begin p := 0 ;
101641: LD_ADDR_VAR 0 1
101645: PUSH
101646: LD_INT 0
101648: ST_TO_ADDR
// repeat game_speed := 1 ;
101649: LD_ADDR_OWVAR 65
101653: PUSH
101654: LD_INT 1
101656: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101657: LD_INT 35
101659: PPUSH
101660: CALL_OW 67
// p := p + 1 ;
101664: LD_ADDR_VAR 0 1
101668: PUSH
101669: LD_VAR 0 1
101673: PUSH
101674: LD_INT 1
101676: PLUS
101677: ST_TO_ADDR
// until p >= 60 ;
101678: LD_VAR 0 1
101682: PUSH
101683: LD_INT 60
101685: GREATEREQUAL
101686: IFFALSE 101649
// game_speed := 4 ;
101688: LD_ADDR_OWVAR 65
101692: PUSH
101693: LD_INT 4
101695: ST_TO_ADDR
// end ;
101696: PPOPN 1
101698: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101699: LD_EXP 138
101703: PUSH
101704: LD_EXP 165
101708: AND
101709: IFFALSE 101855
101711: GO 101713
101713: DISABLE
101714: LD_INT 0
101716: PPUSH
101717: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101718: LD_ADDR_VAR 0 1
101722: PUSH
101723: LD_INT 22
101725: PUSH
101726: LD_OWVAR 2
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: LD_INT 2
101737: PUSH
101738: LD_INT 30
101740: PUSH
101741: LD_INT 0
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: PUSH
101748: LD_INT 30
101750: PUSH
101751: LD_INT 1
101753: PUSH
101754: EMPTY
101755: LIST
101756: LIST
101757: PUSH
101758: EMPTY
101759: LIST
101760: LIST
101761: LIST
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PPUSH
101767: CALL_OW 69
101771: ST_TO_ADDR
// if not depot then
101772: LD_VAR 0 1
101776: NOT
101777: IFFALSE 101781
// exit ;
101779: GO 101855
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101781: LD_ADDR_VAR 0 2
101785: PUSH
101786: LD_VAR 0 1
101790: PUSH
101791: LD_INT 1
101793: PPUSH
101794: LD_VAR 0 1
101798: PPUSH
101799: CALL_OW 12
101803: ARRAY
101804: PPUSH
101805: CALL_OW 274
101809: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101810: LD_VAR 0 2
101814: PPUSH
101815: LD_INT 1
101817: PPUSH
101818: LD_INT 0
101820: PPUSH
101821: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101825: LD_VAR 0 2
101829: PPUSH
101830: LD_INT 2
101832: PPUSH
101833: LD_INT 0
101835: PPUSH
101836: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101840: LD_VAR 0 2
101844: PPUSH
101845: LD_INT 3
101847: PPUSH
101848: LD_INT 0
101850: PPUSH
101851: CALL_OW 277
// end ;
101855: PPOPN 2
101857: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101858: LD_EXP 138
101862: PUSH
101863: LD_EXP 166
101867: AND
101868: IFFALSE 101965
101870: GO 101872
101872: DISABLE
101873: LD_INT 0
101875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101876: LD_ADDR_VAR 0 1
101880: PUSH
101881: LD_INT 22
101883: PUSH
101884: LD_OWVAR 2
101888: PUSH
101889: EMPTY
101890: LIST
101891: LIST
101892: PUSH
101893: LD_INT 21
101895: PUSH
101896: LD_INT 1
101898: PUSH
101899: EMPTY
101900: LIST
101901: LIST
101902: PUSH
101903: LD_INT 3
101905: PUSH
101906: LD_INT 23
101908: PUSH
101909: LD_INT 0
101911: PUSH
101912: EMPTY
101913: LIST
101914: LIST
101915: PUSH
101916: EMPTY
101917: LIST
101918: LIST
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: LIST
101924: PPUSH
101925: CALL_OW 69
101929: ST_TO_ADDR
// if not tmp then
101930: LD_VAR 0 1
101934: NOT
101935: IFFALSE 101939
// exit ;
101937: GO 101965
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101939: LD_VAR 0 1
101943: PUSH
101944: LD_INT 1
101946: PPUSH
101947: LD_VAR 0 1
101951: PPUSH
101952: CALL_OW 12
101956: ARRAY
101957: PPUSH
101958: LD_INT 200
101960: PPUSH
101961: CALL_OW 234
// end ;
101965: PPOPN 1
101967: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101968: LD_EXP 138
101972: PUSH
101973: LD_EXP 167
101977: AND
101978: IFFALSE 102057
101980: GO 101982
101982: DISABLE
101983: LD_INT 0
101985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101986: LD_ADDR_VAR 0 1
101990: PUSH
101991: LD_INT 22
101993: PUSH
101994: LD_OWVAR 2
101998: PUSH
101999: EMPTY
102000: LIST
102001: LIST
102002: PUSH
102003: LD_INT 21
102005: PUSH
102006: LD_INT 2
102008: PUSH
102009: EMPTY
102010: LIST
102011: LIST
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PPUSH
102017: CALL_OW 69
102021: ST_TO_ADDR
// if not tmp then
102022: LD_VAR 0 1
102026: NOT
102027: IFFALSE 102031
// exit ;
102029: GO 102057
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102031: LD_VAR 0 1
102035: PUSH
102036: LD_INT 1
102038: PPUSH
102039: LD_VAR 0 1
102043: PPUSH
102044: CALL_OW 12
102048: ARRAY
102049: PPUSH
102050: LD_INT 60
102052: PPUSH
102053: CALL_OW 234
// end ;
102057: PPOPN 1
102059: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102060: LD_EXP 138
102064: PUSH
102065: LD_EXP 168
102069: AND
102070: IFFALSE 102169
102072: GO 102074
102074: DISABLE
102075: LD_INT 0
102077: PPUSH
102078: PPUSH
// begin enable ;
102079: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102080: LD_ADDR_VAR 0 1
102084: PUSH
102085: LD_INT 22
102087: PUSH
102088: LD_OWVAR 2
102092: PUSH
102093: EMPTY
102094: LIST
102095: LIST
102096: PUSH
102097: LD_INT 61
102099: PUSH
102100: EMPTY
102101: LIST
102102: PUSH
102103: LD_INT 33
102105: PUSH
102106: LD_INT 2
102108: PUSH
102109: EMPTY
102110: LIST
102111: LIST
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: LIST
102117: PPUSH
102118: CALL_OW 69
102122: ST_TO_ADDR
// if not tmp then
102123: LD_VAR 0 1
102127: NOT
102128: IFFALSE 102132
// exit ;
102130: GO 102169
// for i in tmp do
102132: LD_ADDR_VAR 0 2
102136: PUSH
102137: LD_VAR 0 1
102141: PUSH
102142: FOR_IN
102143: IFFALSE 102167
// if IsControledBy ( i ) then
102145: LD_VAR 0 2
102149: PPUSH
102150: CALL_OW 312
102154: IFFALSE 102165
// ComUnlink ( i ) ;
102156: LD_VAR 0 2
102160: PPUSH
102161: CALL_OW 136
102165: GO 102142
102167: POP
102168: POP
// end ;
102169: PPOPN 2
102171: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102172: LD_EXP 138
102176: PUSH
102177: LD_EXP 169
102181: AND
102182: IFFALSE 102322
102184: GO 102186
102186: DISABLE
102187: LD_INT 0
102189: PPUSH
102190: PPUSH
// begin ToLua ( displayPowell(); ) ;
102191: LD_STRING displayPowell();
102193: PPUSH
102194: CALL_OW 559
// uc_side := 0 ;
102198: LD_ADDR_OWVAR 20
102202: PUSH
102203: LD_INT 0
102205: ST_TO_ADDR
// uc_nation := 2 ;
102206: LD_ADDR_OWVAR 21
102210: PUSH
102211: LD_INT 2
102213: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102214: LD_ADDR_OWVAR 37
102218: PUSH
102219: LD_INT 14
102221: ST_TO_ADDR
// vc_engine := engine_siberite ;
102222: LD_ADDR_OWVAR 39
102226: PUSH
102227: LD_INT 3
102229: ST_TO_ADDR
// vc_control := control_apeman ;
102230: LD_ADDR_OWVAR 38
102234: PUSH
102235: LD_INT 5
102237: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102238: LD_ADDR_OWVAR 40
102242: PUSH
102243: LD_INT 29
102245: ST_TO_ADDR
// un := CreateVehicle ;
102246: LD_ADDR_VAR 0 2
102250: PUSH
102251: CALL_OW 45
102255: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102256: LD_VAR 0 2
102260: PPUSH
102261: LD_INT 1
102263: PPUSH
102264: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102268: LD_INT 35
102270: PPUSH
102271: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102275: LD_VAR 0 2
102279: PPUSH
102280: LD_INT 22
102282: PUSH
102283: LD_OWVAR 2
102287: PUSH
102288: EMPTY
102289: LIST
102290: LIST
102291: PPUSH
102292: CALL_OW 69
102296: PPUSH
102297: LD_VAR 0 2
102301: PPUSH
102302: CALL_OW 74
102306: PPUSH
102307: CALL_OW 115
// until IsDead ( un ) ;
102311: LD_VAR 0 2
102315: PPUSH
102316: CALL_OW 301
102320: IFFALSE 102268
// end ;
102322: PPOPN 2
102324: END
// every 0 0$1 trigger StreamModeActive and sStu do
102325: LD_EXP 138
102329: PUSH
102330: LD_EXP 177
102334: AND
102335: IFFALSE 102351
102337: GO 102339
102339: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102340: LD_STRING displayStucuk();
102342: PPUSH
102343: CALL_OW 559
// ResetFog ;
102347: CALL_OW 335
// end ;
102351: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102352: LD_EXP 138
102356: PUSH
102357: LD_EXP 170
102361: AND
102362: IFFALSE 102503
102364: GO 102366
102366: DISABLE
102367: LD_INT 0
102369: PPUSH
102370: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102371: LD_ADDR_VAR 0 2
102375: PUSH
102376: LD_INT 22
102378: PUSH
102379: LD_OWVAR 2
102383: PUSH
102384: EMPTY
102385: LIST
102386: LIST
102387: PUSH
102388: LD_INT 21
102390: PUSH
102391: LD_INT 1
102393: PUSH
102394: EMPTY
102395: LIST
102396: LIST
102397: PUSH
102398: EMPTY
102399: LIST
102400: LIST
102401: PPUSH
102402: CALL_OW 69
102406: ST_TO_ADDR
// if not tmp then
102407: LD_VAR 0 2
102411: NOT
102412: IFFALSE 102416
// exit ;
102414: GO 102503
// un := tmp [ rand ( 1 , tmp ) ] ;
102416: LD_ADDR_VAR 0 1
102420: PUSH
102421: LD_VAR 0 2
102425: PUSH
102426: LD_INT 1
102428: PPUSH
102429: LD_VAR 0 2
102433: PPUSH
102434: CALL_OW 12
102438: ARRAY
102439: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102440: LD_VAR 0 1
102444: PPUSH
102445: LD_INT 0
102447: PPUSH
102448: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102452: LD_VAR 0 1
102456: PPUSH
102457: LD_OWVAR 3
102461: PUSH
102462: LD_VAR 0 1
102466: DIFF
102467: PPUSH
102468: LD_VAR 0 1
102472: PPUSH
102473: CALL_OW 74
102477: PPUSH
102478: CALL_OW 115
// wait ( 0 0$20 ) ;
102482: LD_INT 700
102484: PPUSH
102485: CALL_OW 67
// SetSide ( un , your_side ) ;
102489: LD_VAR 0 1
102493: PPUSH
102494: LD_OWVAR 2
102498: PPUSH
102499: CALL_OW 235
// end ;
102503: PPOPN 2
102505: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102506: LD_EXP 138
102510: PUSH
102511: LD_EXP 171
102515: AND
102516: IFFALSE 102622
102518: GO 102520
102520: DISABLE
102521: LD_INT 0
102523: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102524: LD_ADDR_VAR 0 1
102528: PUSH
102529: LD_INT 22
102531: PUSH
102532: LD_OWVAR 2
102536: PUSH
102537: EMPTY
102538: LIST
102539: LIST
102540: PUSH
102541: LD_INT 2
102543: PUSH
102544: LD_INT 30
102546: PUSH
102547: LD_INT 0
102549: PUSH
102550: EMPTY
102551: LIST
102552: LIST
102553: PUSH
102554: LD_INT 30
102556: PUSH
102557: LD_INT 1
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: PUSH
102564: EMPTY
102565: LIST
102566: LIST
102567: LIST
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: PPUSH
102573: CALL_OW 69
102577: ST_TO_ADDR
// if not depot then
102578: LD_VAR 0 1
102582: NOT
102583: IFFALSE 102587
// exit ;
102585: GO 102622
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102587: LD_VAR 0 1
102591: PUSH
102592: LD_INT 1
102594: ARRAY
102595: PPUSH
102596: CALL_OW 250
102600: PPUSH
102601: LD_VAR 0 1
102605: PUSH
102606: LD_INT 1
102608: ARRAY
102609: PPUSH
102610: CALL_OW 251
102614: PPUSH
102615: LD_INT 70
102617: PPUSH
102618: CALL_OW 495
// end ;
102622: PPOPN 1
102624: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102625: LD_EXP 138
102629: PUSH
102630: LD_EXP 172
102634: AND
102635: IFFALSE 102846
102637: GO 102639
102639: DISABLE
102640: LD_INT 0
102642: PPUSH
102643: PPUSH
102644: PPUSH
102645: PPUSH
102646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102647: LD_ADDR_VAR 0 5
102651: PUSH
102652: LD_INT 22
102654: PUSH
102655: LD_OWVAR 2
102659: PUSH
102660: EMPTY
102661: LIST
102662: LIST
102663: PUSH
102664: LD_INT 21
102666: PUSH
102667: LD_INT 1
102669: PUSH
102670: EMPTY
102671: LIST
102672: LIST
102673: PUSH
102674: EMPTY
102675: LIST
102676: LIST
102677: PPUSH
102678: CALL_OW 69
102682: ST_TO_ADDR
// if not tmp then
102683: LD_VAR 0 5
102687: NOT
102688: IFFALSE 102692
// exit ;
102690: GO 102846
// for i in tmp do
102692: LD_ADDR_VAR 0 1
102696: PUSH
102697: LD_VAR 0 5
102701: PUSH
102702: FOR_IN
102703: IFFALSE 102844
// begin d := rand ( 0 , 5 ) ;
102705: LD_ADDR_VAR 0 4
102709: PUSH
102710: LD_INT 0
102712: PPUSH
102713: LD_INT 5
102715: PPUSH
102716: CALL_OW 12
102720: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102721: LD_ADDR_VAR 0 2
102725: PUSH
102726: LD_VAR 0 1
102730: PPUSH
102731: CALL_OW 250
102735: PPUSH
102736: LD_VAR 0 4
102740: PPUSH
102741: LD_INT 3
102743: PPUSH
102744: LD_INT 12
102746: PPUSH
102747: CALL_OW 12
102751: PPUSH
102752: CALL_OW 272
102756: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102757: LD_ADDR_VAR 0 3
102761: PUSH
102762: LD_VAR 0 1
102766: PPUSH
102767: CALL_OW 251
102771: PPUSH
102772: LD_VAR 0 4
102776: PPUSH
102777: LD_INT 3
102779: PPUSH
102780: LD_INT 12
102782: PPUSH
102783: CALL_OW 12
102787: PPUSH
102788: CALL_OW 273
102792: ST_TO_ADDR
// if ValidHex ( x , y ) then
102793: LD_VAR 0 2
102797: PPUSH
102798: LD_VAR 0 3
102802: PPUSH
102803: CALL_OW 488
102807: IFFALSE 102842
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102809: LD_VAR 0 1
102813: PPUSH
102814: LD_VAR 0 2
102818: PPUSH
102819: LD_VAR 0 3
102823: PPUSH
102824: LD_INT 3
102826: PPUSH
102827: LD_INT 6
102829: PPUSH
102830: CALL_OW 12
102834: PPUSH
102835: LD_INT 1
102837: PPUSH
102838: CALL_OW 483
// end ;
102842: GO 102702
102844: POP
102845: POP
// end ;
102846: PPOPN 5
102848: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102849: LD_EXP 138
102853: PUSH
102854: LD_EXP 173
102858: AND
102859: IFFALSE 102953
102861: GO 102863
102863: DISABLE
102864: LD_INT 0
102866: PPUSH
102867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102868: LD_ADDR_VAR 0 2
102872: PUSH
102873: LD_INT 22
102875: PUSH
102876: LD_OWVAR 2
102880: PUSH
102881: EMPTY
102882: LIST
102883: LIST
102884: PUSH
102885: LD_INT 32
102887: PUSH
102888: LD_INT 1
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: PUSH
102895: LD_INT 21
102897: PUSH
102898: LD_INT 2
102900: PUSH
102901: EMPTY
102902: LIST
102903: LIST
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: LIST
102909: PPUSH
102910: CALL_OW 69
102914: ST_TO_ADDR
// if not tmp then
102915: LD_VAR 0 2
102919: NOT
102920: IFFALSE 102924
// exit ;
102922: GO 102953
// for i in tmp do
102924: LD_ADDR_VAR 0 1
102928: PUSH
102929: LD_VAR 0 2
102933: PUSH
102934: FOR_IN
102935: IFFALSE 102951
// SetFuel ( i , 0 ) ;
102937: LD_VAR 0 1
102941: PPUSH
102942: LD_INT 0
102944: PPUSH
102945: CALL_OW 240
102949: GO 102934
102951: POP
102952: POP
// end ;
102953: PPOPN 2
102955: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102956: LD_EXP 138
102960: PUSH
102961: LD_EXP 174
102965: AND
102966: IFFALSE 103032
102968: GO 102970
102970: DISABLE
102971: LD_INT 0
102973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102974: LD_ADDR_VAR 0 1
102978: PUSH
102979: LD_INT 22
102981: PUSH
102982: LD_OWVAR 2
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: PUSH
102991: LD_INT 30
102993: PUSH
102994: LD_INT 29
102996: PUSH
102997: EMPTY
102998: LIST
102999: LIST
103000: PUSH
103001: EMPTY
103002: LIST
103003: LIST
103004: PPUSH
103005: CALL_OW 69
103009: ST_TO_ADDR
// if not tmp then
103010: LD_VAR 0 1
103014: NOT
103015: IFFALSE 103019
// exit ;
103017: GO 103032
// DestroyUnit ( tmp [ 1 ] ) ;
103019: LD_VAR 0 1
103023: PUSH
103024: LD_INT 1
103026: ARRAY
103027: PPUSH
103028: CALL_OW 65
// end ;
103032: PPOPN 1
103034: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103035: LD_EXP 138
103039: PUSH
103040: LD_EXP 176
103044: AND
103045: IFFALSE 103174
103047: GO 103049
103049: DISABLE
103050: LD_INT 0
103052: PPUSH
// begin uc_side := 0 ;
103053: LD_ADDR_OWVAR 20
103057: PUSH
103058: LD_INT 0
103060: ST_TO_ADDR
// uc_nation := nation_arabian ;
103061: LD_ADDR_OWVAR 21
103065: PUSH
103066: LD_INT 2
103068: ST_TO_ADDR
// hc_gallery :=  ;
103069: LD_ADDR_OWVAR 33
103073: PUSH
103074: LD_STRING 
103076: ST_TO_ADDR
// hc_name :=  ;
103077: LD_ADDR_OWVAR 26
103081: PUSH
103082: LD_STRING 
103084: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103085: LD_INT 1
103087: PPUSH
103088: LD_INT 11
103090: PPUSH
103091: LD_INT 10
103093: PPUSH
103094: CALL_OW 380
// un := CreateHuman ;
103098: LD_ADDR_VAR 0 1
103102: PUSH
103103: CALL_OW 44
103107: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103108: LD_VAR 0 1
103112: PPUSH
103113: LD_INT 1
103115: PPUSH
103116: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103120: LD_INT 35
103122: PPUSH
103123: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103127: LD_VAR 0 1
103131: PPUSH
103132: LD_INT 22
103134: PUSH
103135: LD_OWVAR 2
103139: PUSH
103140: EMPTY
103141: LIST
103142: LIST
103143: PPUSH
103144: CALL_OW 69
103148: PPUSH
103149: LD_VAR 0 1
103153: PPUSH
103154: CALL_OW 74
103158: PPUSH
103159: CALL_OW 115
// until IsDead ( un ) ;
103163: LD_VAR 0 1
103167: PPUSH
103168: CALL_OW 301
103172: IFFALSE 103120
// end ;
103174: PPOPN 1
103176: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103177: LD_EXP 138
103181: PUSH
103182: LD_EXP 178
103186: AND
103187: IFFALSE 103199
103189: GO 103191
103191: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103192: LD_STRING earthquake(getX(game), 0, 32)
103194: PPUSH
103195: CALL_OW 559
103199: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103200: LD_EXP 138
103204: PUSH
103205: LD_EXP 179
103209: AND
103210: IFFALSE 103301
103212: GO 103214
103214: DISABLE
103215: LD_INT 0
103217: PPUSH
// begin enable ;
103218: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103219: LD_ADDR_VAR 0 1
103223: PUSH
103224: LD_INT 22
103226: PUSH
103227: LD_OWVAR 2
103231: PUSH
103232: EMPTY
103233: LIST
103234: LIST
103235: PUSH
103236: LD_INT 21
103238: PUSH
103239: LD_INT 2
103241: PUSH
103242: EMPTY
103243: LIST
103244: LIST
103245: PUSH
103246: LD_INT 33
103248: PUSH
103249: LD_INT 3
103251: PUSH
103252: EMPTY
103253: LIST
103254: LIST
103255: PUSH
103256: EMPTY
103257: LIST
103258: LIST
103259: LIST
103260: PPUSH
103261: CALL_OW 69
103265: ST_TO_ADDR
// if not tmp then
103266: LD_VAR 0 1
103270: NOT
103271: IFFALSE 103275
// exit ;
103273: GO 103301
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103275: LD_VAR 0 1
103279: PUSH
103280: LD_INT 1
103282: PPUSH
103283: LD_VAR 0 1
103287: PPUSH
103288: CALL_OW 12
103292: ARRAY
103293: PPUSH
103294: LD_INT 1
103296: PPUSH
103297: CALL_OW 234
// end ;
103301: PPOPN 1
103303: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103304: LD_EXP 138
103308: PUSH
103309: LD_EXP 180
103313: AND
103314: IFFALSE 103455
103316: GO 103318
103318: DISABLE
103319: LD_INT 0
103321: PPUSH
103322: PPUSH
103323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103324: LD_ADDR_VAR 0 3
103328: PUSH
103329: LD_INT 22
103331: PUSH
103332: LD_OWVAR 2
103336: PUSH
103337: EMPTY
103338: LIST
103339: LIST
103340: PUSH
103341: LD_INT 25
103343: PUSH
103344: LD_INT 1
103346: PUSH
103347: EMPTY
103348: LIST
103349: LIST
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: PPUSH
103355: CALL_OW 69
103359: ST_TO_ADDR
// if not tmp then
103360: LD_VAR 0 3
103364: NOT
103365: IFFALSE 103369
// exit ;
103367: GO 103455
// un := tmp [ rand ( 1 , tmp ) ] ;
103369: LD_ADDR_VAR 0 2
103373: PUSH
103374: LD_VAR 0 3
103378: PUSH
103379: LD_INT 1
103381: PPUSH
103382: LD_VAR 0 3
103386: PPUSH
103387: CALL_OW 12
103391: ARRAY
103392: ST_TO_ADDR
// if Crawls ( un ) then
103393: LD_VAR 0 2
103397: PPUSH
103398: CALL_OW 318
103402: IFFALSE 103413
// ComWalk ( un ) ;
103404: LD_VAR 0 2
103408: PPUSH
103409: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103413: LD_VAR 0 2
103417: PPUSH
103418: LD_INT 9
103420: PPUSH
103421: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103425: LD_INT 28
103427: PPUSH
103428: LD_OWVAR 2
103432: PPUSH
103433: LD_INT 2
103435: PPUSH
103436: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103440: LD_INT 29
103442: PPUSH
103443: LD_OWVAR 2
103447: PPUSH
103448: LD_INT 2
103450: PPUSH
103451: CALL_OW 322
// end ;
103455: PPOPN 3
103457: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103458: LD_EXP 138
103462: PUSH
103463: LD_EXP 181
103467: AND
103468: IFFALSE 103579
103470: GO 103472
103472: DISABLE
103473: LD_INT 0
103475: PPUSH
103476: PPUSH
103477: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103478: LD_ADDR_VAR 0 3
103482: PUSH
103483: LD_INT 22
103485: PUSH
103486: LD_OWVAR 2
103490: PUSH
103491: EMPTY
103492: LIST
103493: LIST
103494: PUSH
103495: LD_INT 25
103497: PUSH
103498: LD_INT 1
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PUSH
103505: EMPTY
103506: LIST
103507: LIST
103508: PPUSH
103509: CALL_OW 69
103513: ST_TO_ADDR
// if not tmp then
103514: LD_VAR 0 3
103518: NOT
103519: IFFALSE 103523
// exit ;
103521: GO 103579
// un := tmp [ rand ( 1 , tmp ) ] ;
103523: LD_ADDR_VAR 0 2
103527: PUSH
103528: LD_VAR 0 3
103532: PUSH
103533: LD_INT 1
103535: PPUSH
103536: LD_VAR 0 3
103540: PPUSH
103541: CALL_OW 12
103545: ARRAY
103546: ST_TO_ADDR
// if Crawls ( un ) then
103547: LD_VAR 0 2
103551: PPUSH
103552: CALL_OW 318
103556: IFFALSE 103567
// ComWalk ( un ) ;
103558: LD_VAR 0 2
103562: PPUSH
103563: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103567: LD_VAR 0 2
103571: PPUSH
103572: LD_INT 8
103574: PPUSH
103575: CALL_OW 336
// end ;
103579: PPOPN 3
103581: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103582: LD_EXP 138
103586: PUSH
103587: LD_EXP 182
103591: AND
103592: IFFALSE 103736
103594: GO 103596
103596: DISABLE
103597: LD_INT 0
103599: PPUSH
103600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103601: LD_ADDR_VAR 0 2
103605: PUSH
103606: LD_INT 22
103608: PUSH
103609: LD_OWVAR 2
103613: PUSH
103614: EMPTY
103615: LIST
103616: LIST
103617: PUSH
103618: LD_INT 21
103620: PUSH
103621: LD_INT 2
103623: PUSH
103624: EMPTY
103625: LIST
103626: LIST
103627: PUSH
103628: LD_INT 2
103630: PUSH
103631: LD_INT 34
103633: PUSH
103634: LD_INT 12
103636: PUSH
103637: EMPTY
103638: LIST
103639: LIST
103640: PUSH
103641: LD_INT 34
103643: PUSH
103644: LD_INT 51
103646: PUSH
103647: EMPTY
103648: LIST
103649: LIST
103650: PUSH
103651: LD_INT 34
103653: PUSH
103654: LD_INT 32
103656: PUSH
103657: EMPTY
103658: LIST
103659: LIST
103660: PUSH
103661: EMPTY
103662: LIST
103663: LIST
103664: LIST
103665: LIST
103666: PUSH
103667: EMPTY
103668: LIST
103669: LIST
103670: LIST
103671: PPUSH
103672: CALL_OW 69
103676: ST_TO_ADDR
// if not tmp then
103677: LD_VAR 0 2
103681: NOT
103682: IFFALSE 103686
// exit ;
103684: GO 103736
// for i in tmp do
103686: LD_ADDR_VAR 0 1
103690: PUSH
103691: LD_VAR 0 2
103695: PUSH
103696: FOR_IN
103697: IFFALSE 103734
// if GetCargo ( i , mat_artifact ) = 0 then
103699: LD_VAR 0 1
103703: PPUSH
103704: LD_INT 4
103706: PPUSH
103707: CALL_OW 289
103711: PUSH
103712: LD_INT 0
103714: EQUAL
103715: IFFALSE 103732
// SetCargo ( i , mat_siberit , 100 ) ;
103717: LD_VAR 0 1
103721: PPUSH
103722: LD_INT 3
103724: PPUSH
103725: LD_INT 100
103727: PPUSH
103728: CALL_OW 290
103732: GO 103696
103734: POP
103735: POP
// end ;
103736: PPOPN 2
103738: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103739: LD_EXP 138
103743: PUSH
103744: LD_EXP 183
103748: AND
103749: IFFALSE 103932
103751: GO 103753
103753: DISABLE
103754: LD_INT 0
103756: PPUSH
103757: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103758: LD_ADDR_VAR 0 2
103762: PUSH
103763: LD_INT 22
103765: PUSH
103766: LD_OWVAR 2
103770: PUSH
103771: EMPTY
103772: LIST
103773: LIST
103774: PPUSH
103775: CALL_OW 69
103779: ST_TO_ADDR
// if not tmp then
103780: LD_VAR 0 2
103784: NOT
103785: IFFALSE 103789
// exit ;
103787: GO 103932
// for i := 1 to 2 do
103789: LD_ADDR_VAR 0 1
103793: PUSH
103794: DOUBLE
103795: LD_INT 1
103797: DEC
103798: ST_TO_ADDR
103799: LD_INT 2
103801: PUSH
103802: FOR_TO
103803: IFFALSE 103930
// begin uc_side := your_side ;
103805: LD_ADDR_OWVAR 20
103809: PUSH
103810: LD_OWVAR 2
103814: ST_TO_ADDR
// uc_nation := nation_american ;
103815: LD_ADDR_OWVAR 21
103819: PUSH
103820: LD_INT 1
103822: ST_TO_ADDR
// vc_chassis := us_morphling ;
103823: LD_ADDR_OWVAR 37
103827: PUSH
103828: LD_INT 5
103830: ST_TO_ADDR
// vc_engine := engine_siberite ;
103831: LD_ADDR_OWVAR 39
103835: PUSH
103836: LD_INT 3
103838: ST_TO_ADDR
// vc_control := control_computer ;
103839: LD_ADDR_OWVAR 38
103843: PUSH
103844: LD_INT 3
103846: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103847: LD_ADDR_OWVAR 40
103851: PUSH
103852: LD_INT 10
103854: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103855: LD_VAR 0 2
103859: PUSH
103860: LD_INT 1
103862: ARRAY
103863: PPUSH
103864: CALL_OW 310
103868: NOT
103869: IFFALSE 103916
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103871: CALL_OW 45
103875: PPUSH
103876: LD_VAR 0 2
103880: PUSH
103881: LD_INT 1
103883: ARRAY
103884: PPUSH
103885: CALL_OW 250
103889: PPUSH
103890: LD_VAR 0 2
103894: PUSH
103895: LD_INT 1
103897: ARRAY
103898: PPUSH
103899: CALL_OW 251
103903: PPUSH
103904: LD_INT 12
103906: PPUSH
103907: LD_INT 1
103909: PPUSH
103910: CALL_OW 50
103914: GO 103928
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103916: CALL_OW 45
103920: PPUSH
103921: LD_INT 1
103923: PPUSH
103924: CALL_OW 51
// end ;
103928: GO 103802
103930: POP
103931: POP
// end ;
103932: PPOPN 2
103934: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103935: LD_EXP 138
103939: PUSH
103940: LD_EXP 184
103944: AND
103945: IFFALSE 104167
103947: GO 103949
103949: DISABLE
103950: LD_INT 0
103952: PPUSH
103953: PPUSH
103954: PPUSH
103955: PPUSH
103956: PPUSH
103957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103958: LD_ADDR_VAR 0 6
103962: PUSH
103963: LD_INT 22
103965: PUSH
103966: LD_OWVAR 2
103970: PUSH
103971: EMPTY
103972: LIST
103973: LIST
103974: PUSH
103975: LD_INT 21
103977: PUSH
103978: LD_INT 1
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: PUSH
103985: LD_INT 3
103987: PUSH
103988: LD_INT 23
103990: PUSH
103991: LD_INT 0
103993: PUSH
103994: EMPTY
103995: LIST
103996: LIST
103997: PUSH
103998: EMPTY
103999: LIST
104000: LIST
104001: PUSH
104002: EMPTY
104003: LIST
104004: LIST
104005: LIST
104006: PPUSH
104007: CALL_OW 69
104011: ST_TO_ADDR
// if not tmp then
104012: LD_VAR 0 6
104016: NOT
104017: IFFALSE 104021
// exit ;
104019: GO 104167
// s1 := rand ( 1 , 4 ) ;
104021: LD_ADDR_VAR 0 2
104025: PUSH
104026: LD_INT 1
104028: PPUSH
104029: LD_INT 4
104031: PPUSH
104032: CALL_OW 12
104036: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104037: LD_ADDR_VAR 0 4
104041: PUSH
104042: LD_VAR 0 6
104046: PUSH
104047: LD_INT 1
104049: ARRAY
104050: PPUSH
104051: LD_VAR 0 2
104055: PPUSH
104056: CALL_OW 259
104060: ST_TO_ADDR
// if s1 = 1 then
104061: LD_VAR 0 2
104065: PUSH
104066: LD_INT 1
104068: EQUAL
104069: IFFALSE 104089
// s2 := rand ( 2 , 4 ) else
104071: LD_ADDR_VAR 0 3
104075: PUSH
104076: LD_INT 2
104078: PPUSH
104079: LD_INT 4
104081: PPUSH
104082: CALL_OW 12
104086: ST_TO_ADDR
104087: GO 104097
// s2 := 1 ;
104089: LD_ADDR_VAR 0 3
104093: PUSH
104094: LD_INT 1
104096: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104097: LD_ADDR_VAR 0 5
104101: PUSH
104102: LD_VAR 0 6
104106: PUSH
104107: LD_INT 1
104109: ARRAY
104110: PPUSH
104111: LD_VAR 0 3
104115: PPUSH
104116: CALL_OW 259
104120: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104121: LD_VAR 0 6
104125: PUSH
104126: LD_INT 1
104128: ARRAY
104129: PPUSH
104130: LD_VAR 0 2
104134: PPUSH
104135: LD_VAR 0 5
104139: PPUSH
104140: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104144: LD_VAR 0 6
104148: PUSH
104149: LD_INT 1
104151: ARRAY
104152: PPUSH
104153: LD_VAR 0 3
104157: PPUSH
104158: LD_VAR 0 4
104162: PPUSH
104163: CALL_OW 237
// end ;
104167: PPOPN 6
104169: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104170: LD_EXP 138
104174: PUSH
104175: LD_EXP 185
104179: AND
104180: IFFALSE 104259
104182: GO 104184
104184: DISABLE
104185: LD_INT 0
104187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104188: LD_ADDR_VAR 0 1
104192: PUSH
104193: LD_INT 22
104195: PUSH
104196: LD_OWVAR 2
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PUSH
104205: LD_INT 30
104207: PUSH
104208: LD_INT 3
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: PUSH
104215: EMPTY
104216: LIST
104217: LIST
104218: PPUSH
104219: CALL_OW 69
104223: ST_TO_ADDR
// if not tmp then
104224: LD_VAR 0 1
104228: NOT
104229: IFFALSE 104233
// exit ;
104231: GO 104259
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104233: LD_VAR 0 1
104237: PUSH
104238: LD_INT 1
104240: PPUSH
104241: LD_VAR 0 1
104245: PPUSH
104246: CALL_OW 12
104250: ARRAY
104251: PPUSH
104252: LD_INT 1
104254: PPUSH
104255: CALL_OW 234
// end ;
104259: PPOPN 1
104261: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104262: LD_EXP 138
104266: PUSH
104267: LD_EXP 186
104271: AND
104272: IFFALSE 104384
104274: GO 104276
104276: DISABLE
104277: LD_INT 0
104279: PPUSH
104280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104281: LD_ADDR_VAR 0 2
104285: PUSH
104286: LD_INT 22
104288: PUSH
104289: LD_OWVAR 2
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: PUSH
104298: LD_INT 2
104300: PUSH
104301: LD_INT 30
104303: PUSH
104304: LD_INT 27
104306: PUSH
104307: EMPTY
104308: LIST
104309: LIST
104310: PUSH
104311: LD_INT 30
104313: PUSH
104314: LD_INT 26
104316: PUSH
104317: EMPTY
104318: LIST
104319: LIST
104320: PUSH
104321: LD_INT 30
104323: PUSH
104324: LD_INT 28
104326: PUSH
104327: EMPTY
104328: LIST
104329: LIST
104330: PUSH
104331: EMPTY
104332: LIST
104333: LIST
104334: LIST
104335: LIST
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: PPUSH
104341: CALL_OW 69
104345: ST_TO_ADDR
// if not tmp then
104346: LD_VAR 0 2
104350: NOT
104351: IFFALSE 104355
// exit ;
104353: GO 104384
// for i in tmp do
104355: LD_ADDR_VAR 0 1
104359: PUSH
104360: LD_VAR 0 2
104364: PUSH
104365: FOR_IN
104366: IFFALSE 104382
// SetLives ( i , 1 ) ;
104368: LD_VAR 0 1
104372: PPUSH
104373: LD_INT 1
104375: PPUSH
104376: CALL_OW 234
104380: GO 104365
104382: POP
104383: POP
// end ;
104384: PPOPN 2
104386: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104387: LD_EXP 138
104391: PUSH
104392: LD_EXP 187
104396: AND
104397: IFFALSE 104684
104399: GO 104401
104401: DISABLE
104402: LD_INT 0
104404: PPUSH
104405: PPUSH
104406: PPUSH
// begin i := rand ( 1 , 7 ) ;
104407: LD_ADDR_VAR 0 1
104411: PUSH
104412: LD_INT 1
104414: PPUSH
104415: LD_INT 7
104417: PPUSH
104418: CALL_OW 12
104422: ST_TO_ADDR
// case i of 1 :
104423: LD_VAR 0 1
104427: PUSH
104428: LD_INT 1
104430: DOUBLE
104431: EQUAL
104432: IFTRUE 104436
104434: GO 104446
104436: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104437: LD_STRING earthquake(getX(game), 0, 32)
104439: PPUSH
104440: CALL_OW 559
104444: GO 104684
104446: LD_INT 2
104448: DOUBLE
104449: EQUAL
104450: IFTRUE 104454
104452: GO 104468
104454: POP
// begin ToLua ( displayStucuk(); ) ;
104455: LD_STRING displayStucuk();
104457: PPUSH
104458: CALL_OW 559
// ResetFog ;
104462: CALL_OW 335
// end ; 3 :
104466: GO 104684
104468: LD_INT 3
104470: DOUBLE
104471: EQUAL
104472: IFTRUE 104476
104474: GO 104580
104476: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104477: LD_ADDR_VAR 0 2
104481: PUSH
104482: LD_INT 22
104484: PUSH
104485: LD_OWVAR 2
104489: PUSH
104490: EMPTY
104491: LIST
104492: LIST
104493: PUSH
104494: LD_INT 25
104496: PUSH
104497: LD_INT 1
104499: PUSH
104500: EMPTY
104501: LIST
104502: LIST
104503: PUSH
104504: EMPTY
104505: LIST
104506: LIST
104507: PPUSH
104508: CALL_OW 69
104512: ST_TO_ADDR
// if not tmp then
104513: LD_VAR 0 2
104517: NOT
104518: IFFALSE 104522
// exit ;
104520: GO 104684
// un := tmp [ rand ( 1 , tmp ) ] ;
104522: LD_ADDR_VAR 0 3
104526: PUSH
104527: LD_VAR 0 2
104531: PUSH
104532: LD_INT 1
104534: PPUSH
104535: LD_VAR 0 2
104539: PPUSH
104540: CALL_OW 12
104544: ARRAY
104545: ST_TO_ADDR
// if Crawls ( un ) then
104546: LD_VAR 0 3
104550: PPUSH
104551: CALL_OW 318
104555: IFFALSE 104566
// ComWalk ( un ) ;
104557: LD_VAR 0 3
104561: PPUSH
104562: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104566: LD_VAR 0 3
104570: PPUSH
104571: LD_INT 8
104573: PPUSH
104574: CALL_OW 336
// end ; 4 :
104578: GO 104684
104580: LD_INT 4
104582: DOUBLE
104583: EQUAL
104584: IFTRUE 104588
104586: GO 104662
104588: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104589: LD_ADDR_VAR 0 2
104593: PUSH
104594: LD_INT 22
104596: PUSH
104597: LD_OWVAR 2
104601: PUSH
104602: EMPTY
104603: LIST
104604: LIST
104605: PUSH
104606: LD_INT 30
104608: PUSH
104609: LD_INT 29
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: PUSH
104616: EMPTY
104617: LIST
104618: LIST
104619: PPUSH
104620: CALL_OW 69
104624: ST_TO_ADDR
// if not tmp then
104625: LD_VAR 0 2
104629: NOT
104630: IFFALSE 104634
// exit ;
104632: GO 104684
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104634: LD_VAR 0 2
104638: PUSH
104639: LD_INT 1
104641: ARRAY
104642: PPUSH
104643: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104647: LD_VAR 0 2
104651: PUSH
104652: LD_INT 1
104654: ARRAY
104655: PPUSH
104656: CALL_OW 65
// end ; 5 .. 7 :
104660: GO 104684
104662: LD_INT 5
104664: DOUBLE
104665: GREATEREQUAL
104666: IFFALSE 104674
104668: LD_INT 7
104670: DOUBLE
104671: LESSEQUAL
104672: IFTRUE 104676
104674: GO 104683
104676: POP
// StreamSibBomb ; end ;
104677: CALL 100921 0 0
104681: GO 104684
104683: POP
// end ;
104684: PPOPN 3
104686: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104687: LD_EXP 138
104691: PUSH
104692: LD_EXP 188
104696: AND
104697: IFFALSE 104853
104699: GO 104701
104701: DISABLE
104702: LD_INT 0
104704: PPUSH
104705: PPUSH
104706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104707: LD_ADDR_VAR 0 2
104711: PUSH
104712: LD_INT 81
104714: PUSH
104715: LD_OWVAR 2
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: PUSH
104724: LD_INT 2
104726: PUSH
104727: LD_INT 21
104729: PUSH
104730: LD_INT 1
104732: PUSH
104733: EMPTY
104734: LIST
104735: LIST
104736: PUSH
104737: LD_INT 21
104739: PUSH
104740: LD_INT 2
104742: PUSH
104743: EMPTY
104744: LIST
104745: LIST
104746: PUSH
104747: EMPTY
104748: LIST
104749: LIST
104750: LIST
104751: PUSH
104752: EMPTY
104753: LIST
104754: LIST
104755: PPUSH
104756: CALL_OW 69
104760: ST_TO_ADDR
// if not tmp then
104761: LD_VAR 0 2
104765: NOT
104766: IFFALSE 104770
// exit ;
104768: GO 104853
// p := 0 ;
104770: LD_ADDR_VAR 0 3
104774: PUSH
104775: LD_INT 0
104777: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104778: LD_INT 35
104780: PPUSH
104781: CALL_OW 67
// p := p + 1 ;
104785: LD_ADDR_VAR 0 3
104789: PUSH
104790: LD_VAR 0 3
104794: PUSH
104795: LD_INT 1
104797: PLUS
104798: ST_TO_ADDR
// for i in tmp do
104799: LD_ADDR_VAR 0 1
104803: PUSH
104804: LD_VAR 0 2
104808: PUSH
104809: FOR_IN
104810: IFFALSE 104841
// if GetLives ( i ) < 1000 then
104812: LD_VAR 0 1
104816: PPUSH
104817: CALL_OW 256
104821: PUSH
104822: LD_INT 1000
104824: LESS
104825: IFFALSE 104839
// SetLives ( i , 1000 ) ;
104827: LD_VAR 0 1
104831: PPUSH
104832: LD_INT 1000
104834: PPUSH
104835: CALL_OW 234
104839: GO 104809
104841: POP
104842: POP
// until p > 20 ;
104843: LD_VAR 0 3
104847: PUSH
104848: LD_INT 20
104850: GREATER
104851: IFFALSE 104778
// end ;
104853: PPOPN 3
104855: END
// every 0 0$1 trigger StreamModeActive and sTime do
104856: LD_EXP 138
104860: PUSH
104861: LD_EXP 189
104865: AND
104866: IFFALSE 104901
104868: GO 104870
104870: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104871: LD_INT 28
104873: PPUSH
104874: LD_OWVAR 2
104878: PPUSH
104879: LD_INT 2
104881: PPUSH
104882: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104886: LD_INT 30
104888: PPUSH
104889: LD_OWVAR 2
104893: PPUSH
104894: LD_INT 2
104896: PPUSH
104897: CALL_OW 322
// end ;
104901: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104902: LD_EXP 138
104906: PUSH
104907: LD_EXP 190
104911: AND
104912: IFFALSE 105033
104914: GO 104916
104916: DISABLE
104917: LD_INT 0
104919: PPUSH
104920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104921: LD_ADDR_VAR 0 2
104925: PUSH
104926: LD_INT 22
104928: PUSH
104929: LD_OWVAR 2
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: PUSH
104938: LD_INT 21
104940: PUSH
104941: LD_INT 1
104943: PUSH
104944: EMPTY
104945: LIST
104946: LIST
104947: PUSH
104948: LD_INT 3
104950: PUSH
104951: LD_INT 23
104953: PUSH
104954: LD_INT 0
104956: PUSH
104957: EMPTY
104958: LIST
104959: LIST
104960: PUSH
104961: EMPTY
104962: LIST
104963: LIST
104964: PUSH
104965: EMPTY
104966: LIST
104967: LIST
104968: LIST
104969: PPUSH
104970: CALL_OW 69
104974: ST_TO_ADDR
// if not tmp then
104975: LD_VAR 0 2
104979: NOT
104980: IFFALSE 104984
// exit ;
104982: GO 105033
// for i in tmp do
104984: LD_ADDR_VAR 0 1
104988: PUSH
104989: LD_VAR 0 2
104993: PUSH
104994: FOR_IN
104995: IFFALSE 105031
// begin if Crawls ( i ) then
104997: LD_VAR 0 1
105001: PPUSH
105002: CALL_OW 318
105006: IFFALSE 105017
// ComWalk ( i ) ;
105008: LD_VAR 0 1
105012: PPUSH
105013: CALL_OW 138
// SetClass ( i , 2 ) ;
105017: LD_VAR 0 1
105021: PPUSH
105022: LD_INT 2
105024: PPUSH
105025: CALL_OW 336
// end ;
105029: GO 104994
105031: POP
105032: POP
// end ;
105033: PPOPN 2
105035: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105036: LD_EXP 138
105040: PUSH
105041: LD_EXP 191
105045: AND
105046: IFFALSE 105334
105048: GO 105050
105050: DISABLE
105051: LD_INT 0
105053: PPUSH
105054: PPUSH
105055: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105056: LD_OWVAR 2
105060: PPUSH
105061: LD_INT 9
105063: PPUSH
105064: LD_INT 1
105066: PPUSH
105067: LD_INT 1
105069: PPUSH
105070: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105074: LD_INT 9
105076: PPUSH
105077: LD_OWVAR 2
105081: PPUSH
105082: CALL_OW 343
// uc_side := 9 ;
105086: LD_ADDR_OWVAR 20
105090: PUSH
105091: LD_INT 9
105093: ST_TO_ADDR
// uc_nation := 2 ;
105094: LD_ADDR_OWVAR 21
105098: PUSH
105099: LD_INT 2
105101: ST_TO_ADDR
// hc_name := Dark Warrior ;
105102: LD_ADDR_OWVAR 26
105106: PUSH
105107: LD_STRING Dark Warrior
105109: ST_TO_ADDR
// hc_gallery :=  ;
105110: LD_ADDR_OWVAR 33
105114: PUSH
105115: LD_STRING 
105117: ST_TO_ADDR
// hc_noskilllimit := true ;
105118: LD_ADDR_OWVAR 76
105122: PUSH
105123: LD_INT 1
105125: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105126: LD_ADDR_OWVAR 31
105130: PUSH
105131: LD_INT 30
105133: PUSH
105134: LD_INT 30
105136: PUSH
105137: LD_INT 30
105139: PUSH
105140: LD_INT 30
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: LIST
105147: LIST
105148: ST_TO_ADDR
// un := CreateHuman ;
105149: LD_ADDR_VAR 0 3
105153: PUSH
105154: CALL_OW 44
105158: ST_TO_ADDR
// hc_noskilllimit := false ;
105159: LD_ADDR_OWVAR 76
105163: PUSH
105164: LD_INT 0
105166: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105167: LD_VAR 0 3
105171: PPUSH
105172: LD_INT 1
105174: PPUSH
105175: CALL_OW 51
// ToLua ( playRanger() ) ;
105179: LD_STRING playRanger()
105181: PPUSH
105182: CALL_OW 559
// p := 0 ;
105186: LD_ADDR_VAR 0 2
105190: PUSH
105191: LD_INT 0
105193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105194: LD_INT 35
105196: PPUSH
105197: CALL_OW 67
// p := p + 1 ;
105201: LD_ADDR_VAR 0 2
105205: PUSH
105206: LD_VAR 0 2
105210: PUSH
105211: LD_INT 1
105213: PLUS
105214: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105215: LD_VAR 0 3
105219: PPUSH
105220: CALL_OW 256
105224: PUSH
105225: LD_INT 1000
105227: LESS
105228: IFFALSE 105242
// SetLives ( un , 1000 ) ;
105230: LD_VAR 0 3
105234: PPUSH
105235: LD_INT 1000
105237: PPUSH
105238: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105242: LD_VAR 0 3
105246: PPUSH
105247: LD_INT 81
105249: PUSH
105250: LD_OWVAR 2
105254: PUSH
105255: EMPTY
105256: LIST
105257: LIST
105258: PUSH
105259: LD_INT 91
105261: PUSH
105262: LD_VAR 0 3
105266: PUSH
105267: LD_INT 30
105269: PUSH
105270: EMPTY
105271: LIST
105272: LIST
105273: LIST
105274: PUSH
105275: EMPTY
105276: LIST
105277: LIST
105278: PPUSH
105279: CALL_OW 69
105283: PPUSH
105284: LD_VAR 0 3
105288: PPUSH
105289: CALL_OW 74
105293: PPUSH
105294: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105298: LD_VAR 0 2
105302: PUSH
105303: LD_INT 80
105305: GREATER
105306: PUSH
105307: LD_VAR 0 3
105311: PPUSH
105312: CALL_OW 301
105316: OR
105317: IFFALSE 105194
// if un then
105319: LD_VAR 0 3
105323: IFFALSE 105334
// RemoveUnit ( un ) ;
105325: LD_VAR 0 3
105329: PPUSH
105330: CALL_OW 64
// end ;
105334: PPOPN 3
105336: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105337: LD_EXP 192
105341: IFFALSE 105457
105343: GO 105345
105345: DISABLE
105346: LD_INT 0
105348: PPUSH
105349: PPUSH
105350: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105351: LD_ADDR_VAR 0 2
105355: PUSH
105356: LD_INT 81
105358: PUSH
105359: LD_OWVAR 2
105363: PUSH
105364: EMPTY
105365: LIST
105366: LIST
105367: PUSH
105368: LD_INT 21
105370: PUSH
105371: LD_INT 1
105373: PUSH
105374: EMPTY
105375: LIST
105376: LIST
105377: PUSH
105378: EMPTY
105379: LIST
105380: LIST
105381: PPUSH
105382: CALL_OW 69
105386: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105387: LD_STRING playComputer()
105389: PPUSH
105390: CALL_OW 559
// if not tmp then
105394: LD_VAR 0 2
105398: NOT
105399: IFFALSE 105403
// exit ;
105401: GO 105457
// for i in tmp do
105403: LD_ADDR_VAR 0 1
105407: PUSH
105408: LD_VAR 0 2
105412: PUSH
105413: FOR_IN
105414: IFFALSE 105455
// for j := 1 to 4 do
105416: LD_ADDR_VAR 0 3
105420: PUSH
105421: DOUBLE
105422: LD_INT 1
105424: DEC
105425: ST_TO_ADDR
105426: LD_INT 4
105428: PUSH
105429: FOR_TO
105430: IFFALSE 105451
// SetSkill ( i , j , 10 ) ;
105432: LD_VAR 0 1
105436: PPUSH
105437: LD_VAR 0 3
105441: PPUSH
105442: LD_INT 10
105444: PPUSH
105445: CALL_OW 237
105449: GO 105429
105451: POP
105452: POP
105453: GO 105413
105455: POP
105456: POP
// end ;
105457: PPOPN 3
105459: END
// every 0 0$1 trigger s30 do var i , tmp ;
105460: LD_EXP 193
105464: IFFALSE 105533
105466: GO 105468
105468: DISABLE
105469: LD_INT 0
105471: PPUSH
105472: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105473: LD_ADDR_VAR 0 2
105477: PUSH
105478: LD_INT 22
105480: PUSH
105481: LD_OWVAR 2
105485: PUSH
105486: EMPTY
105487: LIST
105488: LIST
105489: PPUSH
105490: CALL_OW 69
105494: ST_TO_ADDR
// if not tmp then
105495: LD_VAR 0 2
105499: NOT
105500: IFFALSE 105504
// exit ;
105502: GO 105533
// for i in tmp do
105504: LD_ADDR_VAR 0 1
105508: PUSH
105509: LD_VAR 0 2
105513: PUSH
105514: FOR_IN
105515: IFFALSE 105531
// SetLives ( i , 300 ) ;
105517: LD_VAR 0 1
105521: PPUSH
105522: LD_INT 300
105524: PPUSH
105525: CALL_OW 234
105529: GO 105514
105531: POP
105532: POP
// end ;
105533: PPOPN 2
105535: END
// every 0 0$1 trigger s60 do var i , tmp ;
105536: LD_EXP 194
105540: IFFALSE 105609
105542: GO 105544
105544: DISABLE
105545: LD_INT 0
105547: PPUSH
105548: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105549: LD_ADDR_VAR 0 2
105553: PUSH
105554: LD_INT 22
105556: PUSH
105557: LD_OWVAR 2
105561: PUSH
105562: EMPTY
105563: LIST
105564: LIST
105565: PPUSH
105566: CALL_OW 69
105570: ST_TO_ADDR
// if not tmp then
105571: LD_VAR 0 2
105575: NOT
105576: IFFALSE 105580
// exit ;
105578: GO 105609
// for i in tmp do
105580: LD_ADDR_VAR 0 1
105584: PUSH
105585: LD_VAR 0 2
105589: PUSH
105590: FOR_IN
105591: IFFALSE 105607
// SetLives ( i , 600 ) ;
105593: LD_VAR 0 1
105597: PPUSH
105598: LD_INT 600
105600: PPUSH
105601: CALL_OW 234
105605: GO 105590
105607: POP
105608: POP
// end ;
105609: PPOPN 2
105611: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105612: LD_INT 0
105614: PPUSH
// case cmd of 301 :
105615: LD_VAR 0 1
105619: PUSH
105620: LD_INT 301
105622: DOUBLE
105623: EQUAL
105624: IFTRUE 105628
105626: GO 105660
105628: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105629: LD_VAR 0 6
105633: PPUSH
105634: LD_VAR 0 7
105638: PPUSH
105639: LD_VAR 0 8
105643: PPUSH
105644: LD_VAR 0 4
105648: PPUSH
105649: LD_VAR 0 5
105653: PPUSH
105654: CALL 106861 0 5
105658: GO 105781
105660: LD_INT 302
105662: DOUBLE
105663: EQUAL
105664: IFTRUE 105668
105666: GO 105705
105668: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105669: LD_VAR 0 6
105673: PPUSH
105674: LD_VAR 0 7
105678: PPUSH
105679: LD_VAR 0 8
105683: PPUSH
105684: LD_VAR 0 9
105688: PPUSH
105689: LD_VAR 0 4
105693: PPUSH
105694: LD_VAR 0 5
105698: PPUSH
105699: CALL 106952 0 6
105703: GO 105781
105705: LD_INT 303
105707: DOUBLE
105708: EQUAL
105709: IFTRUE 105713
105711: GO 105750
105713: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105714: LD_VAR 0 6
105718: PPUSH
105719: LD_VAR 0 7
105723: PPUSH
105724: LD_VAR 0 8
105728: PPUSH
105729: LD_VAR 0 9
105733: PPUSH
105734: LD_VAR 0 4
105738: PPUSH
105739: LD_VAR 0 5
105743: PPUSH
105744: CALL 105786 0 6
105748: GO 105781
105750: LD_INT 304
105752: DOUBLE
105753: EQUAL
105754: IFTRUE 105758
105756: GO 105780
105758: POP
// hHackTeleport ( unit , x , y ) ; end ;
105759: LD_VAR 0 2
105763: PPUSH
105764: LD_VAR 0 4
105768: PPUSH
105769: LD_VAR 0 5
105773: PPUSH
105774: CALL 107545 0 3
105778: GO 105781
105780: POP
// end ;
105781: LD_VAR 0 12
105785: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105786: LD_INT 0
105788: PPUSH
105789: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105790: LD_VAR 0 1
105794: PUSH
105795: LD_INT 1
105797: LESS
105798: PUSH
105799: LD_VAR 0 1
105803: PUSH
105804: LD_INT 3
105806: GREATER
105807: OR
105808: PUSH
105809: LD_VAR 0 5
105813: PPUSH
105814: LD_VAR 0 6
105818: PPUSH
105819: CALL_OW 428
105823: OR
105824: IFFALSE 105828
// exit ;
105826: GO 106548
// uc_side := your_side ;
105828: LD_ADDR_OWVAR 20
105832: PUSH
105833: LD_OWVAR 2
105837: ST_TO_ADDR
// uc_nation := nation ;
105838: LD_ADDR_OWVAR 21
105842: PUSH
105843: LD_VAR 0 1
105847: ST_TO_ADDR
// bc_level = 1 ;
105848: LD_ADDR_OWVAR 43
105852: PUSH
105853: LD_INT 1
105855: ST_TO_ADDR
// case btype of 1 :
105856: LD_VAR 0 2
105860: PUSH
105861: LD_INT 1
105863: DOUBLE
105864: EQUAL
105865: IFTRUE 105869
105867: GO 105880
105869: POP
// bc_type := b_depot ; 2 :
105870: LD_ADDR_OWVAR 42
105874: PUSH
105875: LD_INT 0
105877: ST_TO_ADDR
105878: GO 106492
105880: LD_INT 2
105882: DOUBLE
105883: EQUAL
105884: IFTRUE 105888
105886: GO 105899
105888: POP
// bc_type := b_warehouse ; 3 :
105889: LD_ADDR_OWVAR 42
105893: PUSH
105894: LD_INT 1
105896: ST_TO_ADDR
105897: GO 106492
105899: LD_INT 3
105901: DOUBLE
105902: EQUAL
105903: IFTRUE 105907
105905: GO 105918
105907: POP
// bc_type := b_lab ; 4 .. 9 :
105908: LD_ADDR_OWVAR 42
105912: PUSH
105913: LD_INT 6
105915: ST_TO_ADDR
105916: GO 106492
105918: LD_INT 4
105920: DOUBLE
105921: GREATEREQUAL
105922: IFFALSE 105930
105924: LD_INT 9
105926: DOUBLE
105927: LESSEQUAL
105928: IFTRUE 105932
105930: GO 105984
105932: POP
// begin bc_type := b_lab_half ;
105933: LD_ADDR_OWVAR 42
105937: PUSH
105938: LD_INT 7
105940: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105941: LD_ADDR_OWVAR 44
105945: PUSH
105946: LD_INT 10
105948: PUSH
105949: LD_INT 11
105951: PUSH
105952: LD_INT 12
105954: PUSH
105955: LD_INT 15
105957: PUSH
105958: LD_INT 14
105960: PUSH
105961: LD_INT 13
105963: PUSH
105964: EMPTY
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: LIST
105971: PUSH
105972: LD_VAR 0 2
105976: PUSH
105977: LD_INT 3
105979: MINUS
105980: ARRAY
105981: ST_TO_ADDR
// end ; 10 .. 13 :
105982: GO 106492
105984: LD_INT 10
105986: DOUBLE
105987: GREATEREQUAL
105988: IFFALSE 105996
105990: LD_INT 13
105992: DOUBLE
105993: LESSEQUAL
105994: IFTRUE 105998
105996: GO 106075
105998: POP
// begin bc_type := b_lab_full ;
105999: LD_ADDR_OWVAR 42
106003: PUSH
106004: LD_INT 8
106006: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106007: LD_ADDR_OWVAR 44
106011: PUSH
106012: LD_INT 10
106014: PUSH
106015: LD_INT 12
106017: PUSH
106018: LD_INT 14
106020: PUSH
106021: LD_INT 13
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: LIST
106028: LIST
106029: PUSH
106030: LD_VAR 0 2
106034: PUSH
106035: LD_INT 9
106037: MINUS
106038: ARRAY
106039: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106040: LD_ADDR_OWVAR 45
106044: PUSH
106045: LD_INT 11
106047: PUSH
106048: LD_INT 15
106050: PUSH
106051: LD_INT 12
106053: PUSH
106054: LD_INT 15
106056: PUSH
106057: EMPTY
106058: LIST
106059: LIST
106060: LIST
106061: LIST
106062: PUSH
106063: LD_VAR 0 2
106067: PUSH
106068: LD_INT 9
106070: MINUS
106071: ARRAY
106072: ST_TO_ADDR
// end ; 14 :
106073: GO 106492
106075: LD_INT 14
106077: DOUBLE
106078: EQUAL
106079: IFTRUE 106083
106081: GO 106094
106083: POP
// bc_type := b_workshop ; 15 :
106084: LD_ADDR_OWVAR 42
106088: PUSH
106089: LD_INT 2
106091: ST_TO_ADDR
106092: GO 106492
106094: LD_INT 15
106096: DOUBLE
106097: EQUAL
106098: IFTRUE 106102
106100: GO 106113
106102: POP
// bc_type := b_factory ; 16 :
106103: LD_ADDR_OWVAR 42
106107: PUSH
106108: LD_INT 3
106110: ST_TO_ADDR
106111: GO 106492
106113: LD_INT 16
106115: DOUBLE
106116: EQUAL
106117: IFTRUE 106121
106119: GO 106132
106121: POP
// bc_type := b_ext_gun ; 17 :
106122: LD_ADDR_OWVAR 42
106126: PUSH
106127: LD_INT 17
106129: ST_TO_ADDR
106130: GO 106492
106132: LD_INT 17
106134: DOUBLE
106135: EQUAL
106136: IFTRUE 106140
106138: GO 106168
106140: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106141: LD_ADDR_OWVAR 42
106145: PUSH
106146: LD_INT 19
106148: PUSH
106149: LD_INT 23
106151: PUSH
106152: LD_INT 19
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: LIST
106159: PUSH
106160: LD_VAR 0 1
106164: ARRAY
106165: ST_TO_ADDR
106166: GO 106492
106168: LD_INT 18
106170: DOUBLE
106171: EQUAL
106172: IFTRUE 106176
106174: GO 106187
106176: POP
// bc_type := b_ext_radar ; 19 :
106177: LD_ADDR_OWVAR 42
106181: PUSH
106182: LD_INT 20
106184: ST_TO_ADDR
106185: GO 106492
106187: LD_INT 19
106189: DOUBLE
106190: EQUAL
106191: IFTRUE 106195
106193: GO 106206
106195: POP
// bc_type := b_ext_radio ; 20 :
106196: LD_ADDR_OWVAR 42
106200: PUSH
106201: LD_INT 22
106203: ST_TO_ADDR
106204: GO 106492
106206: LD_INT 20
106208: DOUBLE
106209: EQUAL
106210: IFTRUE 106214
106212: GO 106225
106214: POP
// bc_type := b_ext_siberium ; 21 :
106215: LD_ADDR_OWVAR 42
106219: PUSH
106220: LD_INT 21
106222: ST_TO_ADDR
106223: GO 106492
106225: LD_INT 21
106227: DOUBLE
106228: EQUAL
106229: IFTRUE 106233
106231: GO 106244
106233: POP
// bc_type := b_ext_computer ; 22 :
106234: LD_ADDR_OWVAR 42
106238: PUSH
106239: LD_INT 24
106241: ST_TO_ADDR
106242: GO 106492
106244: LD_INT 22
106246: DOUBLE
106247: EQUAL
106248: IFTRUE 106252
106250: GO 106263
106252: POP
// bc_type := b_ext_track ; 23 :
106253: LD_ADDR_OWVAR 42
106257: PUSH
106258: LD_INT 16
106260: ST_TO_ADDR
106261: GO 106492
106263: LD_INT 23
106265: DOUBLE
106266: EQUAL
106267: IFTRUE 106271
106269: GO 106282
106271: POP
// bc_type := b_ext_laser ; 24 :
106272: LD_ADDR_OWVAR 42
106276: PUSH
106277: LD_INT 25
106279: ST_TO_ADDR
106280: GO 106492
106282: LD_INT 24
106284: DOUBLE
106285: EQUAL
106286: IFTRUE 106290
106288: GO 106301
106290: POP
// bc_type := b_control_tower ; 25 :
106291: LD_ADDR_OWVAR 42
106295: PUSH
106296: LD_INT 36
106298: ST_TO_ADDR
106299: GO 106492
106301: LD_INT 25
106303: DOUBLE
106304: EQUAL
106305: IFTRUE 106309
106307: GO 106320
106309: POP
// bc_type := b_breastwork ; 26 :
106310: LD_ADDR_OWVAR 42
106314: PUSH
106315: LD_INT 31
106317: ST_TO_ADDR
106318: GO 106492
106320: LD_INT 26
106322: DOUBLE
106323: EQUAL
106324: IFTRUE 106328
106326: GO 106339
106328: POP
// bc_type := b_bunker ; 27 :
106329: LD_ADDR_OWVAR 42
106333: PUSH
106334: LD_INT 32
106336: ST_TO_ADDR
106337: GO 106492
106339: LD_INT 27
106341: DOUBLE
106342: EQUAL
106343: IFTRUE 106347
106345: GO 106358
106347: POP
// bc_type := b_turret ; 28 :
106348: LD_ADDR_OWVAR 42
106352: PUSH
106353: LD_INT 33
106355: ST_TO_ADDR
106356: GO 106492
106358: LD_INT 28
106360: DOUBLE
106361: EQUAL
106362: IFTRUE 106366
106364: GO 106377
106366: POP
// bc_type := b_armoury ; 29 :
106367: LD_ADDR_OWVAR 42
106371: PUSH
106372: LD_INT 4
106374: ST_TO_ADDR
106375: GO 106492
106377: LD_INT 29
106379: DOUBLE
106380: EQUAL
106381: IFTRUE 106385
106383: GO 106396
106385: POP
// bc_type := b_barracks ; 30 :
106386: LD_ADDR_OWVAR 42
106390: PUSH
106391: LD_INT 5
106393: ST_TO_ADDR
106394: GO 106492
106396: LD_INT 30
106398: DOUBLE
106399: EQUAL
106400: IFTRUE 106404
106402: GO 106415
106404: POP
// bc_type := b_solar_power ; 31 :
106405: LD_ADDR_OWVAR 42
106409: PUSH
106410: LD_INT 27
106412: ST_TO_ADDR
106413: GO 106492
106415: LD_INT 31
106417: DOUBLE
106418: EQUAL
106419: IFTRUE 106423
106421: GO 106434
106423: POP
// bc_type := b_oil_power ; 32 :
106424: LD_ADDR_OWVAR 42
106428: PUSH
106429: LD_INT 26
106431: ST_TO_ADDR
106432: GO 106492
106434: LD_INT 32
106436: DOUBLE
106437: EQUAL
106438: IFTRUE 106442
106440: GO 106453
106442: POP
// bc_type := b_siberite_power ; 33 :
106443: LD_ADDR_OWVAR 42
106447: PUSH
106448: LD_INT 28
106450: ST_TO_ADDR
106451: GO 106492
106453: LD_INT 33
106455: DOUBLE
106456: EQUAL
106457: IFTRUE 106461
106459: GO 106472
106461: POP
// bc_type := b_oil_mine ; 34 :
106462: LD_ADDR_OWVAR 42
106466: PUSH
106467: LD_INT 29
106469: ST_TO_ADDR
106470: GO 106492
106472: LD_INT 34
106474: DOUBLE
106475: EQUAL
106476: IFTRUE 106480
106478: GO 106491
106480: POP
// bc_type := b_siberite_mine ; end ;
106481: LD_ADDR_OWVAR 42
106485: PUSH
106486: LD_INT 30
106488: ST_TO_ADDR
106489: GO 106492
106491: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106492: LD_ADDR_VAR 0 8
106496: PUSH
106497: LD_VAR 0 5
106501: PPUSH
106502: LD_VAR 0 6
106506: PPUSH
106507: LD_VAR 0 3
106511: PPUSH
106512: CALL_OW 47
106516: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106517: LD_OWVAR 42
106521: PUSH
106522: LD_INT 32
106524: PUSH
106525: LD_INT 33
106527: PUSH
106528: EMPTY
106529: LIST
106530: LIST
106531: IN
106532: IFFALSE 106548
// PlaceWeaponTurret ( b , weapon ) ;
106534: LD_VAR 0 8
106538: PPUSH
106539: LD_VAR 0 4
106543: PPUSH
106544: CALL_OW 431
// end ;
106548: LD_VAR 0 7
106552: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106553: LD_INT 0
106555: PPUSH
106556: PPUSH
106557: PPUSH
106558: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106559: LD_ADDR_VAR 0 4
106563: PUSH
106564: LD_INT 22
106566: PUSH
106567: LD_OWVAR 2
106571: PUSH
106572: EMPTY
106573: LIST
106574: LIST
106575: PUSH
106576: LD_INT 2
106578: PUSH
106579: LD_INT 30
106581: PUSH
106582: LD_INT 0
106584: PUSH
106585: EMPTY
106586: LIST
106587: LIST
106588: PUSH
106589: LD_INT 30
106591: PUSH
106592: LD_INT 1
106594: PUSH
106595: EMPTY
106596: LIST
106597: LIST
106598: PUSH
106599: EMPTY
106600: LIST
106601: LIST
106602: LIST
106603: PUSH
106604: EMPTY
106605: LIST
106606: LIST
106607: PPUSH
106608: CALL_OW 69
106612: ST_TO_ADDR
// if not tmp then
106613: LD_VAR 0 4
106617: NOT
106618: IFFALSE 106622
// exit ;
106620: GO 106681
// for i in tmp do
106622: LD_ADDR_VAR 0 2
106626: PUSH
106627: LD_VAR 0 4
106631: PUSH
106632: FOR_IN
106633: IFFALSE 106679
// for j = 1 to 3 do
106635: LD_ADDR_VAR 0 3
106639: PUSH
106640: DOUBLE
106641: LD_INT 1
106643: DEC
106644: ST_TO_ADDR
106645: LD_INT 3
106647: PUSH
106648: FOR_TO
106649: IFFALSE 106675
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106651: LD_VAR 0 2
106655: PPUSH
106656: CALL_OW 274
106660: PPUSH
106661: LD_VAR 0 3
106665: PPUSH
106666: LD_INT 99999
106668: PPUSH
106669: CALL_OW 277
106673: GO 106648
106675: POP
106676: POP
106677: GO 106632
106679: POP
106680: POP
// end ;
106681: LD_VAR 0 1
106685: RET
// export function hHackSetLevel10 ; var i , j ; begin
106686: LD_INT 0
106688: PPUSH
106689: PPUSH
106690: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106691: LD_ADDR_VAR 0 2
106695: PUSH
106696: LD_INT 21
106698: PUSH
106699: LD_INT 1
106701: PUSH
106702: EMPTY
106703: LIST
106704: LIST
106705: PPUSH
106706: CALL_OW 69
106710: PUSH
106711: FOR_IN
106712: IFFALSE 106764
// if IsSelected ( i ) then
106714: LD_VAR 0 2
106718: PPUSH
106719: CALL_OW 306
106723: IFFALSE 106762
// begin for j := 1 to 4 do
106725: LD_ADDR_VAR 0 3
106729: PUSH
106730: DOUBLE
106731: LD_INT 1
106733: DEC
106734: ST_TO_ADDR
106735: LD_INT 4
106737: PUSH
106738: FOR_TO
106739: IFFALSE 106760
// SetSkill ( i , j , 10 ) ;
106741: LD_VAR 0 2
106745: PPUSH
106746: LD_VAR 0 3
106750: PPUSH
106751: LD_INT 10
106753: PPUSH
106754: CALL_OW 237
106758: GO 106738
106760: POP
106761: POP
// end ;
106762: GO 106711
106764: POP
106765: POP
// end ;
106766: LD_VAR 0 1
106770: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106771: LD_INT 0
106773: PPUSH
106774: PPUSH
106775: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106776: LD_ADDR_VAR 0 2
106780: PUSH
106781: LD_INT 22
106783: PUSH
106784: LD_OWVAR 2
106788: PUSH
106789: EMPTY
106790: LIST
106791: LIST
106792: PUSH
106793: LD_INT 21
106795: PUSH
106796: LD_INT 1
106798: PUSH
106799: EMPTY
106800: LIST
106801: LIST
106802: PUSH
106803: EMPTY
106804: LIST
106805: LIST
106806: PPUSH
106807: CALL_OW 69
106811: PUSH
106812: FOR_IN
106813: IFFALSE 106854
// begin for j := 1 to 4 do
106815: LD_ADDR_VAR 0 3
106819: PUSH
106820: DOUBLE
106821: LD_INT 1
106823: DEC
106824: ST_TO_ADDR
106825: LD_INT 4
106827: PUSH
106828: FOR_TO
106829: IFFALSE 106850
// SetSkill ( i , j , 10 ) ;
106831: LD_VAR 0 2
106835: PPUSH
106836: LD_VAR 0 3
106840: PPUSH
106841: LD_INT 10
106843: PPUSH
106844: CALL_OW 237
106848: GO 106828
106850: POP
106851: POP
// end ;
106852: GO 106812
106854: POP
106855: POP
// end ;
106856: LD_VAR 0 1
106860: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106861: LD_INT 0
106863: PPUSH
// uc_side := your_side ;
106864: LD_ADDR_OWVAR 20
106868: PUSH
106869: LD_OWVAR 2
106873: ST_TO_ADDR
// uc_nation := nation ;
106874: LD_ADDR_OWVAR 21
106878: PUSH
106879: LD_VAR 0 1
106883: ST_TO_ADDR
// InitHc ;
106884: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106888: LD_INT 0
106890: PPUSH
106891: LD_VAR 0 2
106895: PPUSH
106896: LD_VAR 0 3
106900: PPUSH
106901: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106905: LD_VAR 0 4
106909: PPUSH
106910: LD_VAR 0 5
106914: PPUSH
106915: CALL_OW 428
106919: PUSH
106920: LD_INT 0
106922: EQUAL
106923: IFFALSE 106947
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106925: CALL_OW 44
106929: PPUSH
106930: LD_VAR 0 4
106934: PPUSH
106935: LD_VAR 0 5
106939: PPUSH
106940: LD_INT 1
106942: PPUSH
106943: CALL_OW 48
// end ;
106947: LD_VAR 0 6
106951: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106952: LD_INT 0
106954: PPUSH
106955: PPUSH
// uc_side := your_side ;
106956: LD_ADDR_OWVAR 20
106960: PUSH
106961: LD_OWVAR 2
106965: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106966: LD_VAR 0 1
106970: PUSH
106971: LD_INT 1
106973: PUSH
106974: LD_INT 2
106976: PUSH
106977: LD_INT 3
106979: PUSH
106980: LD_INT 4
106982: PUSH
106983: LD_INT 5
106985: PUSH
106986: EMPTY
106987: LIST
106988: LIST
106989: LIST
106990: LIST
106991: LIST
106992: IN
106993: IFFALSE 107005
// uc_nation := nation_american else
106995: LD_ADDR_OWVAR 21
106999: PUSH
107000: LD_INT 1
107002: ST_TO_ADDR
107003: GO 107048
// if chassis in [ 11 , 12 , 13 , 14 ] then
107005: LD_VAR 0 1
107009: PUSH
107010: LD_INT 11
107012: PUSH
107013: LD_INT 12
107015: PUSH
107016: LD_INT 13
107018: PUSH
107019: LD_INT 14
107021: PUSH
107022: EMPTY
107023: LIST
107024: LIST
107025: LIST
107026: LIST
107027: IN
107028: IFFALSE 107040
// uc_nation := nation_arabian else
107030: LD_ADDR_OWVAR 21
107034: PUSH
107035: LD_INT 2
107037: ST_TO_ADDR
107038: GO 107048
// uc_nation := nation_russian ;
107040: LD_ADDR_OWVAR 21
107044: PUSH
107045: LD_INT 3
107047: ST_TO_ADDR
// vc_chassis := chassis ;
107048: LD_ADDR_OWVAR 37
107052: PUSH
107053: LD_VAR 0 1
107057: ST_TO_ADDR
// vc_engine := engine ;
107058: LD_ADDR_OWVAR 39
107062: PUSH
107063: LD_VAR 0 2
107067: ST_TO_ADDR
// vc_control := control ;
107068: LD_ADDR_OWVAR 38
107072: PUSH
107073: LD_VAR 0 3
107077: ST_TO_ADDR
// vc_weapon := weapon ;
107078: LD_ADDR_OWVAR 40
107082: PUSH
107083: LD_VAR 0 4
107087: ST_TO_ADDR
// un := CreateVehicle ;
107088: LD_ADDR_VAR 0 8
107092: PUSH
107093: CALL_OW 45
107097: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107098: LD_VAR 0 8
107102: PPUSH
107103: LD_INT 0
107105: PPUSH
107106: LD_INT 5
107108: PPUSH
107109: CALL_OW 12
107113: PPUSH
107114: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107118: LD_VAR 0 8
107122: PPUSH
107123: LD_VAR 0 5
107127: PPUSH
107128: LD_VAR 0 6
107132: PPUSH
107133: LD_INT 1
107135: PPUSH
107136: CALL_OW 48
// end ;
107140: LD_VAR 0 7
107144: RET
// export hInvincible ; every 1 do
107145: GO 107147
107147: DISABLE
// hInvincible := [ ] ;
107148: LD_ADDR_EXP 195
107152: PUSH
107153: EMPTY
107154: ST_TO_ADDR
107155: END
// every 10 do var i ;
107156: GO 107158
107158: DISABLE
107159: LD_INT 0
107161: PPUSH
// begin enable ;
107162: ENABLE
// if not hInvincible then
107163: LD_EXP 195
107167: NOT
107168: IFFALSE 107172
// exit ;
107170: GO 107216
// for i in hInvincible do
107172: LD_ADDR_VAR 0 1
107176: PUSH
107177: LD_EXP 195
107181: PUSH
107182: FOR_IN
107183: IFFALSE 107214
// if GetLives ( i ) < 1000 then
107185: LD_VAR 0 1
107189: PPUSH
107190: CALL_OW 256
107194: PUSH
107195: LD_INT 1000
107197: LESS
107198: IFFALSE 107212
// SetLives ( i , 1000 ) ;
107200: LD_VAR 0 1
107204: PPUSH
107205: LD_INT 1000
107207: PPUSH
107208: CALL_OW 234
107212: GO 107182
107214: POP
107215: POP
// end ;
107216: PPOPN 1
107218: END
// export function hHackInvincible ; var i ; begin
107219: LD_INT 0
107221: PPUSH
107222: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107223: LD_ADDR_VAR 0 2
107227: PUSH
107228: LD_INT 2
107230: PUSH
107231: LD_INT 21
107233: PUSH
107234: LD_INT 1
107236: PUSH
107237: EMPTY
107238: LIST
107239: LIST
107240: PUSH
107241: LD_INT 21
107243: PUSH
107244: LD_INT 2
107246: PUSH
107247: EMPTY
107248: LIST
107249: LIST
107250: PUSH
107251: EMPTY
107252: LIST
107253: LIST
107254: LIST
107255: PPUSH
107256: CALL_OW 69
107260: PUSH
107261: FOR_IN
107262: IFFALSE 107323
// if IsSelected ( i ) then
107264: LD_VAR 0 2
107268: PPUSH
107269: CALL_OW 306
107273: IFFALSE 107321
// begin if i in hInvincible then
107275: LD_VAR 0 2
107279: PUSH
107280: LD_EXP 195
107284: IN
107285: IFFALSE 107305
// hInvincible := hInvincible diff i else
107287: LD_ADDR_EXP 195
107291: PUSH
107292: LD_EXP 195
107296: PUSH
107297: LD_VAR 0 2
107301: DIFF
107302: ST_TO_ADDR
107303: GO 107321
// hInvincible := hInvincible union i ;
107305: LD_ADDR_EXP 195
107309: PUSH
107310: LD_EXP 195
107314: PUSH
107315: LD_VAR 0 2
107319: UNION
107320: ST_TO_ADDR
// end ;
107321: GO 107261
107323: POP
107324: POP
// end ;
107325: LD_VAR 0 1
107329: RET
// export function hHackInvisible ; var i , j ; begin
107330: LD_INT 0
107332: PPUSH
107333: PPUSH
107334: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107335: LD_ADDR_VAR 0 2
107339: PUSH
107340: LD_INT 21
107342: PUSH
107343: LD_INT 1
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: PPUSH
107350: CALL_OW 69
107354: PUSH
107355: FOR_IN
107356: IFFALSE 107380
// if IsSelected ( i ) then
107358: LD_VAR 0 2
107362: PPUSH
107363: CALL_OW 306
107367: IFFALSE 107378
// ComForceInvisible ( i ) ;
107369: LD_VAR 0 2
107373: PPUSH
107374: CALL_OW 496
107378: GO 107355
107380: POP
107381: POP
// end ;
107382: LD_VAR 0 1
107386: RET
// export function hHackChangeYourSide ; begin
107387: LD_INT 0
107389: PPUSH
// if your_side = 8 then
107390: LD_OWVAR 2
107394: PUSH
107395: LD_INT 8
107397: EQUAL
107398: IFFALSE 107410
// your_side := 0 else
107400: LD_ADDR_OWVAR 2
107404: PUSH
107405: LD_INT 0
107407: ST_TO_ADDR
107408: GO 107424
// your_side := your_side + 1 ;
107410: LD_ADDR_OWVAR 2
107414: PUSH
107415: LD_OWVAR 2
107419: PUSH
107420: LD_INT 1
107422: PLUS
107423: ST_TO_ADDR
// end ;
107424: LD_VAR 0 1
107428: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107429: LD_INT 0
107431: PPUSH
107432: PPUSH
107433: PPUSH
// for i in all_units do
107434: LD_ADDR_VAR 0 2
107438: PUSH
107439: LD_OWVAR 3
107443: PUSH
107444: FOR_IN
107445: IFFALSE 107523
// if IsSelected ( i ) then
107447: LD_VAR 0 2
107451: PPUSH
107452: CALL_OW 306
107456: IFFALSE 107521
// begin j := GetSide ( i ) ;
107458: LD_ADDR_VAR 0 3
107462: PUSH
107463: LD_VAR 0 2
107467: PPUSH
107468: CALL_OW 255
107472: ST_TO_ADDR
// if j = 8 then
107473: LD_VAR 0 3
107477: PUSH
107478: LD_INT 8
107480: EQUAL
107481: IFFALSE 107493
// j := 0 else
107483: LD_ADDR_VAR 0 3
107487: PUSH
107488: LD_INT 0
107490: ST_TO_ADDR
107491: GO 107507
// j := j + 1 ;
107493: LD_ADDR_VAR 0 3
107497: PUSH
107498: LD_VAR 0 3
107502: PUSH
107503: LD_INT 1
107505: PLUS
107506: ST_TO_ADDR
// SetSide ( i , j ) ;
107507: LD_VAR 0 2
107511: PPUSH
107512: LD_VAR 0 3
107516: PPUSH
107517: CALL_OW 235
// end ;
107521: GO 107444
107523: POP
107524: POP
// end ;
107525: LD_VAR 0 1
107529: RET
// export function hHackFog ; begin
107530: LD_INT 0
107532: PPUSH
// FogOff ( true ) ;
107533: LD_INT 1
107535: PPUSH
107536: CALL_OW 344
// end ;
107540: LD_VAR 0 1
107544: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107545: LD_INT 0
107547: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107548: LD_VAR 0 1
107552: PPUSH
107553: LD_VAR 0 2
107557: PPUSH
107558: LD_VAR 0 3
107562: PPUSH
107563: LD_INT 1
107565: PPUSH
107566: LD_INT 1
107568: PPUSH
107569: CALL_OW 483
// CenterOnXY ( x , y ) ;
107573: LD_VAR 0 2
107577: PPUSH
107578: LD_VAR 0 3
107582: PPUSH
107583: CALL_OW 84
// end ;
107587: LD_VAR 0 4
107591: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107592: LD_INT 0
107594: PPUSH
107595: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107596: LD_VAR 0 1
107600: NOT
107601: PUSH
107602: LD_VAR 0 2
107606: PPUSH
107607: LD_VAR 0 3
107611: PPUSH
107612: CALL_OW 488
107616: NOT
107617: OR
107618: PUSH
107619: LD_VAR 0 1
107623: PPUSH
107624: CALL_OW 266
107628: PUSH
107629: LD_INT 3
107631: NONEQUAL
107632: PUSH
107633: LD_VAR 0 1
107637: PPUSH
107638: CALL_OW 247
107642: PUSH
107643: LD_INT 1
107645: EQUAL
107646: NOT
107647: AND
107648: OR
107649: IFFALSE 107653
// exit ;
107651: GO 107802
// if GetType ( factory ) = unit_human then
107653: LD_VAR 0 1
107657: PPUSH
107658: CALL_OW 247
107662: PUSH
107663: LD_INT 1
107665: EQUAL
107666: IFFALSE 107683
// factory := IsInUnit ( factory ) ;
107668: LD_ADDR_VAR 0 1
107672: PUSH
107673: LD_VAR 0 1
107677: PPUSH
107678: CALL_OW 310
107682: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107683: LD_VAR 0 1
107687: PPUSH
107688: CALL_OW 266
107692: PUSH
107693: LD_INT 3
107695: NONEQUAL
107696: IFFALSE 107700
// exit ;
107698: GO 107802
// if HexInfo ( x , y ) = factory then
107700: LD_VAR 0 2
107704: PPUSH
107705: LD_VAR 0 3
107709: PPUSH
107710: CALL_OW 428
107714: PUSH
107715: LD_VAR 0 1
107719: EQUAL
107720: IFFALSE 107747
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107722: LD_ADDR_EXP 196
107726: PUSH
107727: LD_EXP 196
107731: PPUSH
107732: LD_VAR 0 1
107736: PPUSH
107737: LD_INT 0
107739: PPUSH
107740: CALL_OW 1
107744: ST_TO_ADDR
107745: GO 107798
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107747: LD_ADDR_EXP 196
107751: PUSH
107752: LD_EXP 196
107756: PPUSH
107757: LD_VAR 0 1
107761: PPUSH
107762: LD_VAR 0 1
107766: PPUSH
107767: CALL_OW 255
107771: PUSH
107772: LD_VAR 0 1
107776: PUSH
107777: LD_VAR 0 2
107781: PUSH
107782: LD_VAR 0 3
107786: PUSH
107787: EMPTY
107788: LIST
107789: LIST
107790: LIST
107791: LIST
107792: PPUSH
107793: CALL_OW 1
107797: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107798: CALL 107807 0 0
// end ;
107802: LD_VAR 0 4
107806: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107807: LD_INT 0
107809: PPUSH
107810: PPUSH
107811: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107812: LD_STRING resetFactoryWaypoint();
107814: PPUSH
107815: CALL_OW 559
// if factoryWaypoints then
107819: LD_EXP 196
107823: IFFALSE 107949
// begin list := PrepareArray ( factoryWaypoints ) ;
107825: LD_ADDR_VAR 0 3
107829: PUSH
107830: LD_EXP 196
107834: PPUSH
107835: CALL 93203 0 1
107839: ST_TO_ADDR
// for i := 1 to list do
107840: LD_ADDR_VAR 0 2
107844: PUSH
107845: DOUBLE
107846: LD_INT 1
107848: DEC
107849: ST_TO_ADDR
107850: LD_VAR 0 3
107854: PUSH
107855: FOR_TO
107856: IFFALSE 107947
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107858: LD_STRING setFactoryWaypointXY(
107860: PUSH
107861: LD_VAR 0 3
107865: PUSH
107866: LD_VAR 0 2
107870: ARRAY
107871: PUSH
107872: LD_INT 1
107874: ARRAY
107875: STR
107876: PUSH
107877: LD_STRING ,
107879: STR
107880: PUSH
107881: LD_VAR 0 3
107885: PUSH
107886: LD_VAR 0 2
107890: ARRAY
107891: PUSH
107892: LD_INT 2
107894: ARRAY
107895: STR
107896: PUSH
107897: LD_STRING ,
107899: STR
107900: PUSH
107901: LD_VAR 0 3
107905: PUSH
107906: LD_VAR 0 2
107910: ARRAY
107911: PUSH
107912: LD_INT 3
107914: ARRAY
107915: STR
107916: PUSH
107917: LD_STRING ,
107919: STR
107920: PUSH
107921: LD_VAR 0 3
107925: PUSH
107926: LD_VAR 0 2
107930: ARRAY
107931: PUSH
107932: LD_INT 4
107934: ARRAY
107935: STR
107936: PUSH
107937: LD_STRING )
107939: STR
107940: PPUSH
107941: CALL_OW 559
107945: GO 107855
107947: POP
107948: POP
// end ; end ;
107949: LD_VAR 0 1
107953: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107954: LD_INT 0
107956: PPUSH
// if HexInfo ( x , y ) = warehouse then
107957: LD_VAR 0 2
107961: PPUSH
107962: LD_VAR 0 3
107966: PPUSH
107967: CALL_OW 428
107971: PUSH
107972: LD_VAR 0 1
107976: EQUAL
107977: IFFALSE 108004
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107979: LD_ADDR_EXP 197
107983: PUSH
107984: LD_EXP 197
107988: PPUSH
107989: LD_VAR 0 1
107993: PPUSH
107994: LD_INT 0
107996: PPUSH
107997: CALL_OW 1
108001: ST_TO_ADDR
108002: GO 108055
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108004: LD_ADDR_EXP 197
108008: PUSH
108009: LD_EXP 197
108013: PPUSH
108014: LD_VAR 0 1
108018: PPUSH
108019: LD_VAR 0 1
108023: PPUSH
108024: CALL_OW 255
108028: PUSH
108029: LD_VAR 0 1
108033: PUSH
108034: LD_VAR 0 2
108038: PUSH
108039: LD_VAR 0 3
108043: PUSH
108044: EMPTY
108045: LIST
108046: LIST
108047: LIST
108048: LIST
108049: PPUSH
108050: CALL_OW 1
108054: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108055: CALL 108064 0 0
// end ;
108059: LD_VAR 0 4
108063: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108064: LD_INT 0
108066: PPUSH
108067: PPUSH
108068: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108069: LD_STRING resetWarehouseGatheringPoints();
108071: PPUSH
108072: CALL_OW 559
// if warehouseGatheringPoints then
108076: LD_EXP 197
108080: IFFALSE 108206
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108082: LD_ADDR_VAR 0 3
108086: PUSH
108087: LD_EXP 197
108091: PPUSH
108092: CALL 93203 0 1
108096: ST_TO_ADDR
// for i := 1 to list do
108097: LD_ADDR_VAR 0 2
108101: PUSH
108102: DOUBLE
108103: LD_INT 1
108105: DEC
108106: ST_TO_ADDR
108107: LD_VAR 0 3
108111: PUSH
108112: FOR_TO
108113: IFFALSE 108204
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108115: LD_STRING setWarehouseGatheringPointXY(
108117: PUSH
108118: LD_VAR 0 3
108122: PUSH
108123: LD_VAR 0 2
108127: ARRAY
108128: PUSH
108129: LD_INT 1
108131: ARRAY
108132: STR
108133: PUSH
108134: LD_STRING ,
108136: STR
108137: PUSH
108138: LD_VAR 0 3
108142: PUSH
108143: LD_VAR 0 2
108147: ARRAY
108148: PUSH
108149: LD_INT 2
108151: ARRAY
108152: STR
108153: PUSH
108154: LD_STRING ,
108156: STR
108157: PUSH
108158: LD_VAR 0 3
108162: PUSH
108163: LD_VAR 0 2
108167: ARRAY
108168: PUSH
108169: LD_INT 3
108171: ARRAY
108172: STR
108173: PUSH
108174: LD_STRING ,
108176: STR
108177: PUSH
108178: LD_VAR 0 3
108182: PUSH
108183: LD_VAR 0 2
108187: ARRAY
108188: PUSH
108189: LD_INT 4
108191: ARRAY
108192: STR
108193: PUSH
108194: LD_STRING )
108196: STR
108197: PPUSH
108198: CALL_OW 559
108202: GO 108112
108204: POP
108205: POP
// end ; end ;
108206: LD_VAR 0 1
108210: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108211: LD_EXP 197
108215: IFFALSE 108902
108217: GO 108219
108219: DISABLE
108220: LD_INT 0
108222: PPUSH
108223: PPUSH
108224: PPUSH
108225: PPUSH
108226: PPUSH
108227: PPUSH
108228: PPUSH
108229: PPUSH
108230: PPUSH
// begin enable ;
108231: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108232: LD_ADDR_VAR 0 3
108236: PUSH
108237: LD_EXP 197
108241: PPUSH
108242: CALL 93203 0 1
108246: ST_TO_ADDR
// if not list then
108247: LD_VAR 0 3
108251: NOT
108252: IFFALSE 108256
// exit ;
108254: GO 108902
// for i := 1 to list do
108256: LD_ADDR_VAR 0 1
108260: PUSH
108261: DOUBLE
108262: LD_INT 1
108264: DEC
108265: ST_TO_ADDR
108266: LD_VAR 0 3
108270: PUSH
108271: FOR_TO
108272: IFFALSE 108900
// begin depot := list [ i ] [ 2 ] ;
108274: LD_ADDR_VAR 0 8
108278: PUSH
108279: LD_VAR 0 3
108283: PUSH
108284: LD_VAR 0 1
108288: ARRAY
108289: PUSH
108290: LD_INT 2
108292: ARRAY
108293: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108294: LD_ADDR_VAR 0 5
108298: PUSH
108299: LD_VAR 0 3
108303: PUSH
108304: LD_VAR 0 1
108308: ARRAY
108309: PUSH
108310: LD_INT 1
108312: ARRAY
108313: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108314: LD_VAR 0 8
108318: PPUSH
108319: CALL_OW 301
108323: PUSH
108324: LD_VAR 0 5
108328: PUSH
108329: LD_VAR 0 8
108333: PPUSH
108334: CALL_OW 255
108338: NONEQUAL
108339: OR
108340: IFFALSE 108369
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108342: LD_ADDR_EXP 197
108346: PUSH
108347: LD_EXP 197
108351: PPUSH
108352: LD_VAR 0 8
108356: PPUSH
108357: LD_INT 0
108359: PPUSH
108360: CALL_OW 1
108364: ST_TO_ADDR
// exit ;
108365: POP
108366: POP
108367: GO 108902
// end ; x := list [ i ] [ 3 ] ;
108369: LD_ADDR_VAR 0 6
108373: PUSH
108374: LD_VAR 0 3
108378: PUSH
108379: LD_VAR 0 1
108383: ARRAY
108384: PUSH
108385: LD_INT 3
108387: ARRAY
108388: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108389: LD_ADDR_VAR 0 7
108393: PUSH
108394: LD_VAR 0 3
108398: PUSH
108399: LD_VAR 0 1
108403: ARRAY
108404: PUSH
108405: LD_INT 4
108407: ARRAY
108408: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108409: LD_ADDR_VAR 0 9
108413: PUSH
108414: LD_VAR 0 6
108418: PPUSH
108419: LD_VAR 0 7
108423: PPUSH
108424: LD_INT 16
108426: PPUSH
108427: CALL 91787 0 3
108431: ST_TO_ADDR
// if not cratesNearbyPoint then
108432: LD_VAR 0 9
108436: NOT
108437: IFFALSE 108443
// exit ;
108439: POP
108440: POP
108441: GO 108902
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108443: LD_ADDR_VAR 0 4
108447: PUSH
108448: LD_INT 22
108450: PUSH
108451: LD_VAR 0 5
108455: PUSH
108456: EMPTY
108457: LIST
108458: LIST
108459: PUSH
108460: LD_INT 3
108462: PUSH
108463: LD_INT 60
108465: PUSH
108466: EMPTY
108467: LIST
108468: PUSH
108469: EMPTY
108470: LIST
108471: LIST
108472: PUSH
108473: LD_INT 91
108475: PUSH
108476: LD_VAR 0 8
108480: PUSH
108481: LD_INT 6
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: LIST
108488: PUSH
108489: LD_INT 2
108491: PUSH
108492: LD_INT 25
108494: PUSH
108495: LD_INT 2
108497: PUSH
108498: EMPTY
108499: LIST
108500: LIST
108501: PUSH
108502: LD_INT 25
108504: PUSH
108505: LD_INT 16
108507: PUSH
108508: EMPTY
108509: LIST
108510: LIST
108511: PUSH
108512: EMPTY
108513: LIST
108514: LIST
108515: LIST
108516: PUSH
108517: EMPTY
108518: LIST
108519: LIST
108520: LIST
108521: LIST
108522: PPUSH
108523: CALL_OW 69
108527: PUSH
108528: LD_VAR 0 8
108532: PPUSH
108533: CALL_OW 313
108537: PPUSH
108538: LD_INT 3
108540: PUSH
108541: LD_INT 60
108543: PUSH
108544: EMPTY
108545: LIST
108546: PUSH
108547: EMPTY
108548: LIST
108549: LIST
108550: PUSH
108551: LD_INT 2
108553: PUSH
108554: LD_INT 25
108556: PUSH
108557: LD_INT 2
108559: PUSH
108560: EMPTY
108561: LIST
108562: LIST
108563: PUSH
108564: LD_INT 25
108566: PUSH
108567: LD_INT 16
108569: PUSH
108570: EMPTY
108571: LIST
108572: LIST
108573: PUSH
108574: EMPTY
108575: LIST
108576: LIST
108577: LIST
108578: PUSH
108579: EMPTY
108580: LIST
108581: LIST
108582: PPUSH
108583: CALL_OW 72
108587: UNION
108588: ST_TO_ADDR
// if tmp then
108589: LD_VAR 0 4
108593: IFFALSE 108673
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108595: LD_ADDR_VAR 0 4
108599: PUSH
108600: LD_VAR 0 4
108604: PPUSH
108605: LD_INT 3
108607: PPUSH
108608: CALL 89754 0 2
108612: ST_TO_ADDR
// for j in tmp do
108613: LD_ADDR_VAR 0 2
108617: PUSH
108618: LD_VAR 0 4
108622: PUSH
108623: FOR_IN
108624: IFFALSE 108667
// begin if IsInUnit ( j ) then
108626: LD_VAR 0 2
108630: PPUSH
108631: CALL_OW 310
108635: IFFALSE 108646
// ComExit ( j ) ;
108637: LD_VAR 0 2
108641: PPUSH
108642: CALL 89837 0 1
// AddComCollect ( j , x , y ) ;
108646: LD_VAR 0 2
108650: PPUSH
108651: LD_VAR 0 6
108655: PPUSH
108656: LD_VAR 0 7
108660: PPUSH
108661: CALL_OW 177
// end ;
108665: GO 108623
108667: POP
108668: POP
// exit ;
108669: POP
108670: POP
108671: GO 108902
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108673: LD_ADDR_VAR 0 4
108677: PUSH
108678: LD_INT 22
108680: PUSH
108681: LD_VAR 0 5
108685: PUSH
108686: EMPTY
108687: LIST
108688: LIST
108689: PUSH
108690: LD_INT 91
108692: PUSH
108693: LD_VAR 0 8
108697: PUSH
108698: LD_INT 8
108700: PUSH
108701: EMPTY
108702: LIST
108703: LIST
108704: LIST
108705: PUSH
108706: LD_INT 2
108708: PUSH
108709: LD_INT 34
108711: PUSH
108712: LD_INT 12
108714: PUSH
108715: EMPTY
108716: LIST
108717: LIST
108718: PUSH
108719: LD_INT 34
108721: PUSH
108722: LD_INT 51
108724: PUSH
108725: EMPTY
108726: LIST
108727: LIST
108728: PUSH
108729: LD_INT 34
108731: PUSH
108732: LD_INT 32
108734: PUSH
108735: EMPTY
108736: LIST
108737: LIST
108738: PUSH
108739: LD_INT 34
108741: PUSH
108742: LD_EXP 75
108746: PUSH
108747: EMPTY
108748: LIST
108749: LIST
108750: PUSH
108751: EMPTY
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: LIST
108757: PUSH
108758: EMPTY
108759: LIST
108760: LIST
108761: LIST
108762: PPUSH
108763: CALL_OW 69
108767: ST_TO_ADDR
// if tmp then
108768: LD_VAR 0 4
108772: IFFALSE 108898
// begin for j in tmp do
108774: LD_ADDR_VAR 0 2
108778: PUSH
108779: LD_VAR 0 4
108783: PUSH
108784: FOR_IN
108785: IFFALSE 108896
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
108787: LD_VAR 0 2
108791: PPUSH
108792: CALL_OW 262
108796: PUSH
108797: LD_INT 3
108799: EQUAL
108800: PUSH
108801: LD_VAR 0 2
108805: PPUSH
108806: CALL_OW 261
108810: PUSH
108811: LD_INT 20
108813: GREATER
108814: OR
108815: PUSH
108816: LD_VAR 0 2
108820: PPUSH
108821: CALL_OW 314
108825: NOT
108826: AND
108827: PUSH
108828: LD_VAR 0 2
108832: PPUSH
108833: CALL_OW 263
108837: PUSH
108838: LD_INT 1
108840: NONEQUAL
108841: PUSH
108842: LD_VAR 0 2
108846: PPUSH
108847: CALL_OW 311
108851: OR
108852: AND
108853: IFFALSE 108894
// begin ComCollect ( j , x , y ) ;
108855: LD_VAR 0 2
108859: PPUSH
108860: LD_VAR 0 6
108864: PPUSH
108865: LD_VAR 0 7
108869: PPUSH
108870: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108874: LD_VAR 0 2
108878: PPUSH
108879: LD_VAR 0 8
108883: PPUSH
108884: CALL_OW 172
// exit ;
108888: POP
108889: POP
108890: POP
108891: POP
108892: GO 108902
// end ;
108894: GO 108784
108896: POP
108897: POP
// end ; end ;
108898: GO 108271
108900: POP
108901: POP
// end ; end_of_file
108902: PPOPN 9
108904: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
108905: LD_INT 0
108907: PPUSH
108908: PPUSH
108909: PPUSH
108910: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
108911: LD_VAR 0 1
108915: PPUSH
108916: CALL_OW 264
108920: PUSH
108921: LD_EXP 78
108925: EQUAL
108926: IFFALSE 108998
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108928: LD_INT 68
108930: PPUSH
108931: LD_VAR 0 1
108935: PPUSH
108936: CALL_OW 255
108940: PPUSH
108941: CALL_OW 321
108945: PUSH
108946: LD_INT 2
108948: EQUAL
108949: IFFALSE 108961
// eff := 70 else
108951: LD_ADDR_VAR 0 4
108955: PUSH
108956: LD_INT 70
108958: ST_TO_ADDR
108959: GO 108969
// eff := 30 ;
108961: LD_ADDR_VAR 0 4
108965: PUSH
108966: LD_INT 30
108968: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108969: LD_VAR 0 1
108973: PPUSH
108974: CALL_OW 250
108978: PPUSH
108979: LD_VAR 0 1
108983: PPUSH
108984: CALL_OW 251
108988: PPUSH
108989: LD_VAR 0 4
108993: PPUSH
108994: CALL_OW 495
// end ; end ;
108998: LD_VAR 0 2
109002: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109003: LD_INT 0
109005: PPUSH
// end ;
109006: LD_VAR 0 4
109010: RET
// export function SOS_Command ( cmd ) ; begin
109011: LD_INT 0
109013: PPUSH
// end ;
109014: LD_VAR 0 2
109018: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109019: LD_INT 0
109021: PPUSH
// end ;
109022: LD_VAR 0 6
109026: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
109027: LD_INT 0
109029: PPUSH
109030: PPUSH
// if not vehicle or not factory then
109031: LD_VAR 0 1
109035: NOT
109036: PUSH
109037: LD_VAR 0 2
109041: NOT
109042: OR
109043: IFFALSE 109047
// exit ;
109045: GO 109278
// if factoryWaypoints >= factory then
109047: LD_EXP 196
109051: PUSH
109052: LD_VAR 0 2
109056: GREATEREQUAL
109057: IFFALSE 109278
// if factoryWaypoints [ factory ] then
109059: LD_EXP 196
109063: PUSH
109064: LD_VAR 0 2
109068: ARRAY
109069: IFFALSE 109278
// begin if GetControl ( vehicle ) = control_manual then
109071: LD_VAR 0 1
109075: PPUSH
109076: CALL_OW 263
109080: PUSH
109081: LD_INT 1
109083: EQUAL
109084: IFFALSE 109165
// begin driver := IsDrivenBy ( vehicle ) ;
109086: LD_ADDR_VAR 0 4
109090: PUSH
109091: LD_VAR 0 1
109095: PPUSH
109096: CALL_OW 311
109100: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109101: LD_VAR 0 4
109105: PPUSH
109106: LD_EXP 196
109110: PUSH
109111: LD_VAR 0 2
109115: ARRAY
109116: PUSH
109117: LD_INT 3
109119: ARRAY
109120: PPUSH
109121: LD_EXP 196
109125: PUSH
109126: LD_VAR 0 2
109130: ARRAY
109131: PUSH
109132: LD_INT 4
109134: ARRAY
109135: PPUSH
109136: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109140: LD_VAR 0 4
109144: PPUSH
109145: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109149: LD_VAR 0 4
109153: PPUSH
109154: LD_VAR 0 2
109158: PPUSH
109159: CALL_OW 180
// end else
109163: GO 109278
// if GetControl ( vehicle ) = control_remote then
109165: LD_VAR 0 1
109169: PPUSH
109170: CALL_OW 263
109174: PUSH
109175: LD_INT 2
109177: EQUAL
109178: IFFALSE 109239
// begin wait ( 0 0$2 ) ;
109180: LD_INT 70
109182: PPUSH
109183: CALL_OW 67
// if Connect ( vehicle ) then
109187: LD_VAR 0 1
109191: PPUSH
109192: CALL 60148 0 1
109196: IFFALSE 109237
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109198: LD_VAR 0 1
109202: PPUSH
109203: LD_EXP 196
109207: PUSH
109208: LD_VAR 0 2
109212: ARRAY
109213: PUSH
109214: LD_INT 3
109216: ARRAY
109217: PPUSH
109218: LD_EXP 196
109222: PUSH
109223: LD_VAR 0 2
109227: ARRAY
109228: PUSH
109229: LD_INT 4
109231: ARRAY
109232: PPUSH
109233: CALL_OW 171
// end else
109237: GO 109278
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109239: LD_VAR 0 1
109243: PPUSH
109244: LD_EXP 196
109248: PUSH
109249: LD_VAR 0 2
109253: ARRAY
109254: PUSH
109255: LD_INT 3
109257: ARRAY
109258: PPUSH
109259: LD_EXP 196
109263: PUSH
109264: LD_VAR 0 2
109268: ARRAY
109269: PUSH
109270: LD_INT 4
109272: ARRAY
109273: PPUSH
109274: CALL_OW 171
// end ; end ;
109278: LD_VAR 0 3
109282: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109283: LD_INT 0
109285: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109286: LD_VAR 0 1
109290: PUSH
109291: LD_INT 250
109293: EQUAL
109294: PUSH
109295: LD_VAR 0 2
109299: PPUSH
109300: CALL_OW 264
109304: PUSH
109305: LD_EXP 81
109309: EQUAL
109310: AND
109311: IFFALSE 109332
// MinerPlaceMine ( unit , x , y ) ;
109313: LD_VAR 0 2
109317: PPUSH
109318: LD_VAR 0 4
109322: PPUSH
109323: LD_VAR 0 5
109327: PPUSH
109328: CALL 111731 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109332: LD_VAR 0 1
109336: PUSH
109337: LD_INT 251
109339: EQUAL
109340: PUSH
109341: LD_VAR 0 2
109345: PPUSH
109346: CALL_OW 264
109350: PUSH
109351: LD_EXP 81
109355: EQUAL
109356: AND
109357: IFFALSE 109378
// MinerDetonateMine ( unit , x , y ) ;
109359: LD_VAR 0 2
109363: PPUSH
109364: LD_VAR 0 4
109368: PPUSH
109369: LD_VAR 0 5
109373: PPUSH
109374: CALL 112008 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109378: LD_VAR 0 1
109382: PUSH
109383: LD_INT 252
109385: EQUAL
109386: PUSH
109387: LD_VAR 0 2
109391: PPUSH
109392: CALL_OW 264
109396: PUSH
109397: LD_EXP 81
109401: EQUAL
109402: AND
109403: IFFALSE 109424
// MinerCreateMinefield ( unit , x , y ) ;
109405: LD_VAR 0 2
109409: PPUSH
109410: LD_VAR 0 4
109414: PPUSH
109415: LD_VAR 0 5
109419: PPUSH
109420: CALL 112425 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109424: LD_VAR 0 1
109428: PUSH
109429: LD_INT 253
109431: EQUAL
109432: PUSH
109433: LD_VAR 0 2
109437: PPUSH
109438: CALL_OW 257
109442: PUSH
109443: LD_INT 5
109445: EQUAL
109446: AND
109447: IFFALSE 109468
// ComBinocular ( unit , x , y ) ;
109449: LD_VAR 0 2
109453: PPUSH
109454: LD_VAR 0 4
109458: PPUSH
109459: LD_VAR 0 5
109463: PPUSH
109464: CALL 112796 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109468: LD_VAR 0 1
109472: PUSH
109473: LD_INT 254
109475: EQUAL
109476: PUSH
109477: LD_VAR 0 2
109481: PPUSH
109482: CALL_OW 264
109486: PUSH
109487: LD_EXP 76
109491: EQUAL
109492: AND
109493: PUSH
109494: LD_VAR 0 3
109498: PPUSH
109499: CALL_OW 263
109503: PUSH
109504: LD_INT 3
109506: EQUAL
109507: AND
109508: IFFALSE 109524
// HackDestroyVehicle ( unit , selectedUnit ) ;
109510: LD_VAR 0 2
109514: PPUSH
109515: LD_VAR 0 3
109519: PPUSH
109520: CALL 111091 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109524: LD_VAR 0 1
109528: PUSH
109529: LD_INT 255
109531: EQUAL
109532: PUSH
109533: LD_VAR 0 2
109537: PPUSH
109538: CALL_OW 264
109542: PUSH
109543: LD_INT 14
109545: PUSH
109546: LD_INT 53
109548: PUSH
109549: EMPTY
109550: LIST
109551: LIST
109552: IN
109553: AND
109554: PUSH
109555: LD_VAR 0 4
109559: PPUSH
109560: LD_VAR 0 5
109564: PPUSH
109565: CALL_OW 488
109569: AND
109570: IFFALSE 109594
// CutTreeXYR ( unit , x , y , 12 ) ;
109572: LD_VAR 0 2
109576: PPUSH
109577: LD_VAR 0 4
109581: PPUSH
109582: LD_VAR 0 5
109586: PPUSH
109587: LD_INT 12
109589: PPUSH
109590: CALL 109657 0 4
// if cmd = 256 then
109594: LD_VAR 0 1
109598: PUSH
109599: LD_INT 256
109601: EQUAL
109602: IFFALSE 109623
// SetFactoryWaypoint ( unit , x , y ) ;
109604: LD_VAR 0 2
109608: PPUSH
109609: LD_VAR 0 4
109613: PPUSH
109614: LD_VAR 0 5
109618: PPUSH
109619: CALL 107592 0 3
// if cmd = 257 then
109623: LD_VAR 0 1
109627: PUSH
109628: LD_INT 257
109630: EQUAL
109631: IFFALSE 109652
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109633: LD_VAR 0 2
109637: PPUSH
109638: LD_VAR 0 4
109642: PPUSH
109643: LD_VAR 0 5
109647: PPUSH
109648: CALL 107954 0 3
// end ;
109652: LD_VAR 0 6
109656: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109657: LD_INT 0
109659: PPUSH
109660: PPUSH
109661: PPUSH
109662: PPUSH
109663: PPUSH
109664: PPUSH
109665: PPUSH
109666: PPUSH
109667: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
109668: LD_VAR 0 1
109672: NOT
109673: PUSH
109674: LD_VAR 0 2
109678: PPUSH
109679: LD_VAR 0 3
109683: PPUSH
109684: CALL_OW 488
109688: NOT
109689: OR
109690: PUSH
109691: LD_VAR 0 4
109695: NOT
109696: OR
109697: IFFALSE 109701
// exit ;
109699: GO 110041
// list := [ ] ;
109701: LD_ADDR_VAR 0 13
109705: PUSH
109706: EMPTY
109707: ST_TO_ADDR
// if x - r < 0 then
109708: LD_VAR 0 2
109712: PUSH
109713: LD_VAR 0 4
109717: MINUS
109718: PUSH
109719: LD_INT 0
109721: LESS
109722: IFFALSE 109734
// min_x := 0 else
109724: LD_ADDR_VAR 0 7
109728: PUSH
109729: LD_INT 0
109731: ST_TO_ADDR
109732: GO 109750
// min_x := x - r ;
109734: LD_ADDR_VAR 0 7
109738: PUSH
109739: LD_VAR 0 2
109743: PUSH
109744: LD_VAR 0 4
109748: MINUS
109749: ST_TO_ADDR
// if y - r < 0 then
109750: LD_VAR 0 3
109754: PUSH
109755: LD_VAR 0 4
109759: MINUS
109760: PUSH
109761: LD_INT 0
109763: LESS
109764: IFFALSE 109776
// min_y := 0 else
109766: LD_ADDR_VAR 0 8
109770: PUSH
109771: LD_INT 0
109773: ST_TO_ADDR
109774: GO 109792
// min_y := y - r ;
109776: LD_ADDR_VAR 0 8
109780: PUSH
109781: LD_VAR 0 3
109785: PUSH
109786: LD_VAR 0 4
109790: MINUS
109791: ST_TO_ADDR
// max_x := x + r ;
109792: LD_ADDR_VAR 0 9
109796: PUSH
109797: LD_VAR 0 2
109801: PUSH
109802: LD_VAR 0 4
109806: PLUS
109807: ST_TO_ADDR
// max_y := y + r ;
109808: LD_ADDR_VAR 0 10
109812: PUSH
109813: LD_VAR 0 3
109817: PUSH
109818: LD_VAR 0 4
109822: PLUS
109823: ST_TO_ADDR
// for _x = min_x to max_x do
109824: LD_ADDR_VAR 0 11
109828: PUSH
109829: DOUBLE
109830: LD_VAR 0 7
109834: DEC
109835: ST_TO_ADDR
109836: LD_VAR 0 9
109840: PUSH
109841: FOR_TO
109842: IFFALSE 109959
// for _y = min_y to max_y do
109844: LD_ADDR_VAR 0 12
109848: PUSH
109849: DOUBLE
109850: LD_VAR 0 8
109854: DEC
109855: ST_TO_ADDR
109856: LD_VAR 0 10
109860: PUSH
109861: FOR_TO
109862: IFFALSE 109955
// begin if not ValidHex ( _x , _y ) then
109864: LD_VAR 0 11
109868: PPUSH
109869: LD_VAR 0 12
109873: PPUSH
109874: CALL_OW 488
109878: NOT
109879: IFFALSE 109883
// continue ;
109881: GO 109861
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109883: LD_VAR 0 11
109887: PPUSH
109888: LD_VAR 0 12
109892: PPUSH
109893: CALL_OW 351
109897: PUSH
109898: LD_VAR 0 11
109902: PPUSH
109903: LD_VAR 0 12
109907: PPUSH
109908: CALL_OW 554
109912: AND
109913: IFFALSE 109953
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109915: LD_ADDR_VAR 0 13
109919: PUSH
109920: LD_VAR 0 13
109924: PPUSH
109925: LD_VAR 0 13
109929: PUSH
109930: LD_INT 1
109932: PLUS
109933: PPUSH
109934: LD_VAR 0 11
109938: PUSH
109939: LD_VAR 0 12
109943: PUSH
109944: EMPTY
109945: LIST
109946: LIST
109947: PPUSH
109948: CALL_OW 2
109952: ST_TO_ADDR
// end ;
109953: GO 109861
109955: POP
109956: POP
109957: GO 109841
109959: POP
109960: POP
// if not list then
109961: LD_VAR 0 13
109965: NOT
109966: IFFALSE 109970
// exit ;
109968: GO 110041
// for i in list do
109970: LD_ADDR_VAR 0 6
109974: PUSH
109975: LD_VAR 0 13
109979: PUSH
109980: FOR_IN
109981: IFFALSE 110039
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109983: LD_VAR 0 1
109987: PPUSH
109988: LD_STRING M
109990: PUSH
109991: LD_VAR 0 6
109995: PUSH
109996: LD_INT 1
109998: ARRAY
109999: PUSH
110000: LD_VAR 0 6
110004: PUSH
110005: LD_INT 2
110007: ARRAY
110008: PUSH
110009: LD_INT 0
110011: PUSH
110012: LD_INT 0
110014: PUSH
110015: LD_INT 0
110017: PUSH
110018: LD_INT 0
110020: PUSH
110021: EMPTY
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: PUSH
110030: EMPTY
110031: LIST
110032: PPUSH
110033: CALL_OW 447
110037: GO 109980
110039: POP
110040: POP
// end ;
110041: LD_VAR 0 5
110045: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110046: LD_EXP 199
110050: NOT
110051: IFFALSE 110101
110053: GO 110055
110055: DISABLE
// begin initHack := true ;
110056: LD_ADDR_EXP 199
110060: PUSH
110061: LD_INT 1
110063: ST_TO_ADDR
// hackTanks := [ ] ;
110064: LD_ADDR_EXP 200
110068: PUSH
110069: EMPTY
110070: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110071: LD_ADDR_EXP 201
110075: PUSH
110076: EMPTY
110077: ST_TO_ADDR
// hackLimit := 3 ;
110078: LD_ADDR_EXP 202
110082: PUSH
110083: LD_INT 3
110085: ST_TO_ADDR
// hackDist := 12 ;
110086: LD_ADDR_EXP 203
110090: PUSH
110091: LD_INT 12
110093: ST_TO_ADDR
// hackCounter := [ ] ;
110094: LD_ADDR_EXP 204
110098: PUSH
110099: EMPTY
110100: ST_TO_ADDR
// end ;
110101: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110102: LD_EXP 199
110106: PUSH
110107: LD_INT 34
110109: PUSH
110110: LD_EXP 76
110114: PUSH
110115: EMPTY
110116: LIST
110117: LIST
110118: PPUSH
110119: CALL_OW 69
110123: AND
110124: IFFALSE 110379
110126: GO 110128
110128: DISABLE
110129: LD_INT 0
110131: PPUSH
110132: PPUSH
// begin enable ;
110133: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110134: LD_ADDR_VAR 0 1
110138: PUSH
110139: LD_INT 34
110141: PUSH
110142: LD_EXP 76
110146: PUSH
110147: EMPTY
110148: LIST
110149: LIST
110150: PPUSH
110151: CALL_OW 69
110155: PUSH
110156: FOR_IN
110157: IFFALSE 110377
// begin if not i in hackTanks then
110159: LD_VAR 0 1
110163: PUSH
110164: LD_EXP 200
110168: IN
110169: NOT
110170: IFFALSE 110253
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110172: LD_ADDR_EXP 200
110176: PUSH
110177: LD_EXP 200
110181: PPUSH
110182: LD_EXP 200
110186: PUSH
110187: LD_INT 1
110189: PLUS
110190: PPUSH
110191: LD_VAR 0 1
110195: PPUSH
110196: CALL_OW 1
110200: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110201: LD_ADDR_EXP 201
110205: PUSH
110206: LD_EXP 201
110210: PPUSH
110211: LD_EXP 201
110215: PUSH
110216: LD_INT 1
110218: PLUS
110219: PPUSH
110220: EMPTY
110221: PPUSH
110222: CALL_OW 1
110226: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110227: LD_ADDR_EXP 204
110231: PUSH
110232: LD_EXP 204
110236: PPUSH
110237: LD_EXP 204
110241: PUSH
110242: LD_INT 1
110244: PLUS
110245: PPUSH
110246: EMPTY
110247: PPUSH
110248: CALL_OW 1
110252: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110253: LD_VAR 0 1
110257: PPUSH
110258: CALL_OW 302
110262: NOT
110263: IFFALSE 110276
// begin HackUnlinkAll ( i ) ;
110265: LD_VAR 0 1
110269: PPUSH
110270: CALL 110382 0 1
// continue ;
110274: GO 110156
// end ; HackCheckCapturedStatus ( i ) ;
110276: LD_VAR 0 1
110280: PPUSH
110281: CALL 110825 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110285: LD_ADDR_VAR 0 2
110289: PUSH
110290: LD_INT 81
110292: PUSH
110293: LD_VAR 0 1
110297: PPUSH
110298: CALL_OW 255
110302: PUSH
110303: EMPTY
110304: LIST
110305: LIST
110306: PUSH
110307: LD_INT 33
110309: PUSH
110310: LD_INT 3
110312: PUSH
110313: EMPTY
110314: LIST
110315: LIST
110316: PUSH
110317: LD_INT 91
110319: PUSH
110320: LD_VAR 0 1
110324: PUSH
110325: LD_EXP 203
110329: PUSH
110330: EMPTY
110331: LIST
110332: LIST
110333: LIST
110334: PUSH
110335: LD_INT 50
110337: PUSH
110338: EMPTY
110339: LIST
110340: PUSH
110341: EMPTY
110342: LIST
110343: LIST
110344: LIST
110345: LIST
110346: PPUSH
110347: CALL_OW 69
110351: ST_TO_ADDR
// if not tmp then
110352: LD_VAR 0 2
110356: NOT
110357: IFFALSE 110361
// continue ;
110359: GO 110156
// HackLink ( i , tmp ) ;
110361: LD_VAR 0 1
110365: PPUSH
110366: LD_VAR 0 2
110370: PPUSH
110371: CALL 110518 0 2
// end ;
110375: GO 110156
110377: POP
110378: POP
// end ;
110379: PPOPN 2
110381: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110382: LD_INT 0
110384: PPUSH
110385: PPUSH
110386: PPUSH
// if not hack in hackTanks then
110387: LD_VAR 0 1
110391: PUSH
110392: LD_EXP 200
110396: IN
110397: NOT
110398: IFFALSE 110402
// exit ;
110400: GO 110513
// index := GetElementIndex ( hackTanks , hack ) ;
110402: LD_ADDR_VAR 0 4
110406: PUSH
110407: LD_EXP 200
110411: PPUSH
110412: LD_VAR 0 1
110416: PPUSH
110417: CALL 56962 0 2
110421: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110422: LD_EXP 201
110426: PUSH
110427: LD_VAR 0 4
110431: ARRAY
110432: IFFALSE 110513
// begin for i in hackTanksCaptured [ index ] do
110434: LD_ADDR_VAR 0 3
110438: PUSH
110439: LD_EXP 201
110443: PUSH
110444: LD_VAR 0 4
110448: ARRAY
110449: PUSH
110450: FOR_IN
110451: IFFALSE 110477
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110453: LD_VAR 0 3
110457: PUSH
110458: LD_INT 1
110460: ARRAY
110461: PPUSH
110462: LD_VAR 0 3
110466: PUSH
110467: LD_INT 2
110469: ARRAY
110470: PPUSH
110471: CALL_OW 235
110475: GO 110450
110477: POP
110478: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110479: LD_ADDR_EXP 201
110483: PUSH
110484: LD_EXP 201
110488: PPUSH
110489: LD_VAR 0 4
110493: PPUSH
110494: EMPTY
110495: PPUSH
110496: CALL_OW 1
110500: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110501: LD_VAR 0 1
110505: PPUSH
110506: LD_INT 0
110508: PPUSH
110509: CALL_OW 505
// end ; end ;
110513: LD_VAR 0 2
110517: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110518: LD_INT 0
110520: PPUSH
110521: PPUSH
110522: PPUSH
// if not hack in hackTanks or not vehicles then
110523: LD_VAR 0 1
110527: PUSH
110528: LD_EXP 200
110532: IN
110533: NOT
110534: PUSH
110535: LD_VAR 0 2
110539: NOT
110540: OR
110541: IFFALSE 110545
// exit ;
110543: GO 110820
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110545: LD_ADDR_VAR 0 2
110549: PUSH
110550: LD_VAR 0 1
110554: PPUSH
110555: LD_VAR 0 2
110559: PPUSH
110560: LD_INT 1
110562: PPUSH
110563: LD_INT 1
110565: PPUSH
110566: CALL 57612 0 4
110570: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110571: LD_ADDR_VAR 0 5
110575: PUSH
110576: LD_EXP 200
110580: PPUSH
110581: LD_VAR 0 1
110585: PPUSH
110586: CALL 56962 0 2
110590: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110591: LD_EXP 201
110595: PUSH
110596: LD_VAR 0 5
110600: ARRAY
110601: PUSH
110602: LD_EXP 202
110606: LESS
110607: IFFALSE 110796
// begin for i := 1 to vehicles do
110609: LD_ADDR_VAR 0 4
110613: PUSH
110614: DOUBLE
110615: LD_INT 1
110617: DEC
110618: ST_TO_ADDR
110619: LD_VAR 0 2
110623: PUSH
110624: FOR_TO
110625: IFFALSE 110794
// begin if hackTanksCaptured [ index ] = hackLimit then
110627: LD_EXP 201
110631: PUSH
110632: LD_VAR 0 5
110636: ARRAY
110637: PUSH
110638: LD_EXP 202
110642: EQUAL
110643: IFFALSE 110647
// break ;
110645: GO 110794
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110647: LD_ADDR_EXP 204
110651: PUSH
110652: LD_EXP 204
110656: PPUSH
110657: LD_VAR 0 5
110661: PPUSH
110662: LD_EXP 204
110666: PUSH
110667: LD_VAR 0 5
110671: ARRAY
110672: PUSH
110673: LD_INT 1
110675: PLUS
110676: PPUSH
110677: CALL_OW 1
110681: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110682: LD_ADDR_EXP 201
110686: PUSH
110687: LD_EXP 201
110691: PPUSH
110692: LD_VAR 0 5
110696: PUSH
110697: LD_EXP 201
110701: PUSH
110702: LD_VAR 0 5
110706: ARRAY
110707: PUSH
110708: LD_INT 1
110710: PLUS
110711: PUSH
110712: EMPTY
110713: LIST
110714: LIST
110715: PPUSH
110716: LD_VAR 0 2
110720: PUSH
110721: LD_VAR 0 4
110725: ARRAY
110726: PUSH
110727: LD_VAR 0 2
110731: PUSH
110732: LD_VAR 0 4
110736: ARRAY
110737: PPUSH
110738: CALL_OW 255
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: PPUSH
110747: CALL 57177 0 3
110751: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110752: LD_VAR 0 2
110756: PUSH
110757: LD_VAR 0 4
110761: ARRAY
110762: PPUSH
110763: LD_VAR 0 1
110767: PPUSH
110768: CALL_OW 255
110772: PPUSH
110773: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110777: LD_VAR 0 2
110781: PUSH
110782: LD_VAR 0 4
110786: ARRAY
110787: PPUSH
110788: CALL_OW 141
// end ;
110792: GO 110624
110794: POP
110795: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110796: LD_VAR 0 1
110800: PPUSH
110801: LD_EXP 201
110805: PUSH
110806: LD_VAR 0 5
110810: ARRAY
110811: PUSH
110812: LD_INT 0
110814: PLUS
110815: PPUSH
110816: CALL_OW 505
// end ;
110820: LD_VAR 0 3
110824: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110825: LD_INT 0
110827: PPUSH
110828: PPUSH
110829: PPUSH
110830: PPUSH
// if not hack in hackTanks then
110831: LD_VAR 0 1
110835: PUSH
110836: LD_EXP 200
110840: IN
110841: NOT
110842: IFFALSE 110846
// exit ;
110844: GO 111086
// index := GetElementIndex ( hackTanks , hack ) ;
110846: LD_ADDR_VAR 0 4
110850: PUSH
110851: LD_EXP 200
110855: PPUSH
110856: LD_VAR 0 1
110860: PPUSH
110861: CALL 56962 0 2
110865: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110866: LD_ADDR_VAR 0 3
110870: PUSH
110871: DOUBLE
110872: LD_EXP 201
110876: PUSH
110877: LD_VAR 0 4
110881: ARRAY
110882: INC
110883: ST_TO_ADDR
110884: LD_INT 1
110886: PUSH
110887: FOR_DOWNTO
110888: IFFALSE 111060
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110890: LD_ADDR_VAR 0 5
110894: PUSH
110895: LD_EXP 201
110899: PUSH
110900: LD_VAR 0 4
110904: ARRAY
110905: PUSH
110906: LD_VAR 0 3
110910: ARRAY
110911: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110912: LD_VAR 0 5
110916: PUSH
110917: LD_INT 1
110919: ARRAY
110920: PPUSH
110921: CALL_OW 302
110925: NOT
110926: PUSH
110927: LD_VAR 0 5
110931: PUSH
110932: LD_INT 1
110934: ARRAY
110935: PPUSH
110936: CALL_OW 255
110940: PUSH
110941: LD_VAR 0 1
110945: PPUSH
110946: CALL_OW 255
110950: NONEQUAL
110951: OR
110952: IFFALSE 111058
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110954: LD_VAR 0 5
110958: PUSH
110959: LD_INT 1
110961: ARRAY
110962: PPUSH
110963: CALL_OW 305
110967: PUSH
110968: LD_VAR 0 5
110972: PUSH
110973: LD_INT 1
110975: ARRAY
110976: PPUSH
110977: CALL_OW 255
110981: PUSH
110982: LD_VAR 0 1
110986: PPUSH
110987: CALL_OW 255
110991: EQUAL
110992: AND
110993: IFFALSE 111017
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110995: LD_VAR 0 5
110999: PUSH
111000: LD_INT 1
111002: ARRAY
111003: PPUSH
111004: LD_VAR 0 5
111008: PUSH
111009: LD_INT 2
111011: ARRAY
111012: PPUSH
111013: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111017: LD_ADDR_EXP 201
111021: PUSH
111022: LD_EXP 201
111026: PPUSH
111027: LD_VAR 0 4
111031: PPUSH
111032: LD_EXP 201
111036: PUSH
111037: LD_VAR 0 4
111041: ARRAY
111042: PPUSH
111043: LD_VAR 0 3
111047: PPUSH
111048: CALL_OW 3
111052: PPUSH
111053: CALL_OW 1
111057: ST_TO_ADDR
// end ; end ;
111058: GO 110887
111060: POP
111061: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111062: LD_VAR 0 1
111066: PPUSH
111067: LD_EXP 201
111071: PUSH
111072: LD_VAR 0 4
111076: ARRAY
111077: PUSH
111078: LD_INT 0
111080: PLUS
111081: PPUSH
111082: CALL_OW 505
// end ;
111086: LD_VAR 0 2
111090: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111091: LD_INT 0
111093: PPUSH
111094: PPUSH
111095: PPUSH
111096: PPUSH
// if not hack in hackTanks then
111097: LD_VAR 0 1
111101: PUSH
111102: LD_EXP 200
111106: IN
111107: NOT
111108: IFFALSE 111112
// exit ;
111110: GO 111197
// index := GetElementIndex ( hackTanks , hack ) ;
111112: LD_ADDR_VAR 0 5
111116: PUSH
111117: LD_EXP 200
111121: PPUSH
111122: LD_VAR 0 1
111126: PPUSH
111127: CALL 56962 0 2
111131: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111132: LD_ADDR_VAR 0 4
111136: PUSH
111137: DOUBLE
111138: LD_INT 1
111140: DEC
111141: ST_TO_ADDR
111142: LD_EXP 201
111146: PUSH
111147: LD_VAR 0 5
111151: ARRAY
111152: PUSH
111153: FOR_TO
111154: IFFALSE 111195
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111156: LD_EXP 201
111160: PUSH
111161: LD_VAR 0 5
111165: ARRAY
111166: PUSH
111167: LD_VAR 0 4
111171: ARRAY
111172: PUSH
111173: LD_INT 1
111175: ARRAY
111176: PUSH
111177: LD_VAR 0 2
111181: EQUAL
111182: IFFALSE 111193
// KillUnit ( vehicle ) ;
111184: LD_VAR 0 2
111188: PPUSH
111189: CALL_OW 66
111193: GO 111153
111195: POP
111196: POP
// end ;
111197: LD_VAR 0 3
111201: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111202: LD_EXP 205
111206: NOT
111207: IFFALSE 111242
111209: GO 111211
111211: DISABLE
// begin initMiner := true ;
111212: LD_ADDR_EXP 205
111216: PUSH
111217: LD_INT 1
111219: ST_TO_ADDR
// minersList := [ ] ;
111220: LD_ADDR_EXP 206
111224: PUSH
111225: EMPTY
111226: ST_TO_ADDR
// minerMinesList := [ ] ;
111227: LD_ADDR_EXP 207
111231: PUSH
111232: EMPTY
111233: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111234: LD_ADDR_EXP 208
111238: PUSH
111239: LD_INT 5
111241: ST_TO_ADDR
// end ;
111242: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111243: LD_EXP 205
111247: PUSH
111248: LD_INT 34
111250: PUSH
111251: LD_EXP 81
111255: PUSH
111256: EMPTY
111257: LIST
111258: LIST
111259: PPUSH
111260: CALL_OW 69
111264: AND
111265: IFFALSE 111728
111267: GO 111269
111269: DISABLE
111270: LD_INT 0
111272: PPUSH
111273: PPUSH
111274: PPUSH
111275: PPUSH
// begin enable ;
111276: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111277: LD_ADDR_VAR 0 1
111281: PUSH
111282: LD_INT 34
111284: PUSH
111285: LD_EXP 81
111289: PUSH
111290: EMPTY
111291: LIST
111292: LIST
111293: PPUSH
111294: CALL_OW 69
111298: PUSH
111299: FOR_IN
111300: IFFALSE 111372
// begin if not i in minersList then
111302: LD_VAR 0 1
111306: PUSH
111307: LD_EXP 206
111311: IN
111312: NOT
111313: IFFALSE 111370
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111315: LD_ADDR_EXP 206
111319: PUSH
111320: LD_EXP 206
111324: PPUSH
111325: LD_EXP 206
111329: PUSH
111330: LD_INT 1
111332: PLUS
111333: PPUSH
111334: LD_VAR 0 1
111338: PPUSH
111339: CALL_OW 1
111343: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111344: LD_ADDR_EXP 207
111348: PUSH
111349: LD_EXP 207
111353: PPUSH
111354: LD_EXP 207
111358: PUSH
111359: LD_INT 1
111361: PLUS
111362: PPUSH
111363: EMPTY
111364: PPUSH
111365: CALL_OW 1
111369: ST_TO_ADDR
// end end ;
111370: GO 111299
111372: POP
111373: POP
// for i := minerMinesList downto 1 do
111374: LD_ADDR_VAR 0 1
111378: PUSH
111379: DOUBLE
111380: LD_EXP 207
111384: INC
111385: ST_TO_ADDR
111386: LD_INT 1
111388: PUSH
111389: FOR_DOWNTO
111390: IFFALSE 111726
// begin if IsLive ( minersList [ i ] ) then
111392: LD_EXP 206
111396: PUSH
111397: LD_VAR 0 1
111401: ARRAY
111402: PPUSH
111403: CALL_OW 300
111407: IFFALSE 111435
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111409: LD_EXP 206
111413: PUSH
111414: LD_VAR 0 1
111418: ARRAY
111419: PPUSH
111420: LD_EXP 207
111424: PUSH
111425: LD_VAR 0 1
111429: ARRAY
111430: PPUSH
111431: CALL_OW 505
// if not minerMinesList [ i ] then
111435: LD_EXP 207
111439: PUSH
111440: LD_VAR 0 1
111444: ARRAY
111445: NOT
111446: IFFALSE 111450
// continue ;
111448: GO 111389
// for j := minerMinesList [ i ] downto 1 do
111450: LD_ADDR_VAR 0 2
111454: PUSH
111455: DOUBLE
111456: LD_EXP 207
111460: PUSH
111461: LD_VAR 0 1
111465: ARRAY
111466: INC
111467: ST_TO_ADDR
111468: LD_INT 1
111470: PUSH
111471: FOR_DOWNTO
111472: IFFALSE 111722
// begin side := GetSide ( minersList [ i ] ) ;
111474: LD_ADDR_VAR 0 3
111478: PUSH
111479: LD_EXP 206
111483: PUSH
111484: LD_VAR 0 1
111488: ARRAY
111489: PPUSH
111490: CALL_OW 255
111494: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111495: LD_ADDR_VAR 0 4
111499: PUSH
111500: LD_EXP 207
111504: PUSH
111505: LD_VAR 0 1
111509: ARRAY
111510: PUSH
111511: LD_VAR 0 2
111515: ARRAY
111516: PUSH
111517: LD_INT 1
111519: ARRAY
111520: PPUSH
111521: LD_EXP 207
111525: PUSH
111526: LD_VAR 0 1
111530: ARRAY
111531: PUSH
111532: LD_VAR 0 2
111536: ARRAY
111537: PUSH
111538: LD_INT 2
111540: ARRAY
111541: PPUSH
111542: CALL_OW 428
111546: ST_TO_ADDR
// if not tmp then
111547: LD_VAR 0 4
111551: NOT
111552: IFFALSE 111556
// continue ;
111554: GO 111471
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111556: LD_VAR 0 4
111560: PUSH
111561: LD_INT 81
111563: PUSH
111564: LD_VAR 0 3
111568: PUSH
111569: EMPTY
111570: LIST
111571: LIST
111572: PPUSH
111573: CALL_OW 69
111577: IN
111578: PUSH
111579: LD_EXP 207
111583: PUSH
111584: LD_VAR 0 1
111588: ARRAY
111589: PUSH
111590: LD_VAR 0 2
111594: ARRAY
111595: PUSH
111596: LD_INT 1
111598: ARRAY
111599: PPUSH
111600: LD_EXP 207
111604: PUSH
111605: LD_VAR 0 1
111609: ARRAY
111610: PUSH
111611: LD_VAR 0 2
111615: ARRAY
111616: PUSH
111617: LD_INT 2
111619: ARRAY
111620: PPUSH
111621: CALL_OW 458
111625: AND
111626: IFFALSE 111720
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111628: LD_EXP 207
111632: PUSH
111633: LD_VAR 0 1
111637: ARRAY
111638: PUSH
111639: LD_VAR 0 2
111643: ARRAY
111644: PUSH
111645: LD_INT 1
111647: ARRAY
111648: PPUSH
111649: LD_EXP 207
111653: PUSH
111654: LD_VAR 0 1
111658: ARRAY
111659: PUSH
111660: LD_VAR 0 2
111664: ARRAY
111665: PUSH
111666: LD_INT 2
111668: ARRAY
111669: PPUSH
111670: LD_VAR 0 3
111674: PPUSH
111675: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111679: LD_ADDR_EXP 207
111683: PUSH
111684: LD_EXP 207
111688: PPUSH
111689: LD_VAR 0 1
111693: PPUSH
111694: LD_EXP 207
111698: PUSH
111699: LD_VAR 0 1
111703: ARRAY
111704: PPUSH
111705: LD_VAR 0 2
111709: PPUSH
111710: CALL_OW 3
111714: PPUSH
111715: CALL_OW 1
111719: ST_TO_ADDR
// end ; end ;
111720: GO 111471
111722: POP
111723: POP
// end ;
111724: GO 111389
111726: POP
111727: POP
// end ;
111728: PPOPN 4
111730: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111731: LD_INT 0
111733: PPUSH
111734: PPUSH
// result := false ;
111735: LD_ADDR_VAR 0 4
111739: PUSH
111740: LD_INT 0
111742: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111743: LD_VAR 0 1
111747: PPUSH
111748: CALL_OW 264
111752: PUSH
111753: LD_EXP 81
111757: EQUAL
111758: NOT
111759: IFFALSE 111763
// exit ;
111761: GO 112003
// index := GetElementIndex ( minersList , unit ) ;
111763: LD_ADDR_VAR 0 5
111767: PUSH
111768: LD_EXP 206
111772: PPUSH
111773: LD_VAR 0 1
111777: PPUSH
111778: CALL 56962 0 2
111782: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111783: LD_EXP 207
111787: PUSH
111788: LD_VAR 0 5
111792: ARRAY
111793: PUSH
111794: LD_EXP 208
111798: GREATEREQUAL
111799: IFFALSE 111803
// exit ;
111801: GO 112003
// ComMoveXY ( unit , x , y ) ;
111803: LD_VAR 0 1
111807: PPUSH
111808: LD_VAR 0 2
111812: PPUSH
111813: LD_VAR 0 3
111817: PPUSH
111818: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111822: LD_INT 35
111824: PPUSH
111825: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111829: LD_VAR 0 1
111833: PPUSH
111834: LD_VAR 0 2
111838: PPUSH
111839: LD_VAR 0 3
111843: PPUSH
111844: CALL 88248 0 3
111848: NOT
111849: PUSH
111850: LD_VAR 0 1
111854: PPUSH
111855: CALL_OW 314
111859: AND
111860: IFFALSE 111864
// exit ;
111862: GO 112003
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111864: LD_VAR 0 2
111868: PPUSH
111869: LD_VAR 0 3
111873: PPUSH
111874: CALL_OW 428
111878: PUSH
111879: LD_VAR 0 1
111883: EQUAL
111884: PUSH
111885: LD_VAR 0 1
111889: PPUSH
111890: CALL_OW 314
111894: NOT
111895: AND
111896: IFFALSE 111822
// PlaySoundXY ( x , y , PlantMine ) ;
111898: LD_VAR 0 2
111902: PPUSH
111903: LD_VAR 0 3
111907: PPUSH
111908: LD_STRING PlantMine
111910: PPUSH
111911: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111915: LD_VAR 0 2
111919: PPUSH
111920: LD_VAR 0 3
111924: PPUSH
111925: LD_VAR 0 1
111929: PPUSH
111930: CALL_OW 255
111934: PPUSH
111935: LD_INT 0
111937: PPUSH
111938: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111942: LD_ADDR_EXP 207
111946: PUSH
111947: LD_EXP 207
111951: PPUSH
111952: LD_VAR 0 5
111956: PUSH
111957: LD_EXP 207
111961: PUSH
111962: LD_VAR 0 5
111966: ARRAY
111967: PUSH
111968: LD_INT 1
111970: PLUS
111971: PUSH
111972: EMPTY
111973: LIST
111974: LIST
111975: PPUSH
111976: LD_VAR 0 2
111980: PUSH
111981: LD_VAR 0 3
111985: PUSH
111986: EMPTY
111987: LIST
111988: LIST
111989: PPUSH
111990: CALL 57177 0 3
111994: ST_TO_ADDR
// result := true ;
111995: LD_ADDR_VAR 0 4
111999: PUSH
112000: LD_INT 1
112002: ST_TO_ADDR
// end ;
112003: LD_VAR 0 4
112007: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112008: LD_INT 0
112010: PPUSH
112011: PPUSH
112012: PPUSH
// if not unit in minersList then
112013: LD_VAR 0 1
112017: PUSH
112018: LD_EXP 206
112022: IN
112023: NOT
112024: IFFALSE 112028
// exit ;
112026: GO 112420
// index := GetElementIndex ( minersList , unit ) ;
112028: LD_ADDR_VAR 0 6
112032: PUSH
112033: LD_EXP 206
112037: PPUSH
112038: LD_VAR 0 1
112042: PPUSH
112043: CALL 56962 0 2
112047: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112048: LD_ADDR_VAR 0 5
112052: PUSH
112053: DOUBLE
112054: LD_EXP 207
112058: PUSH
112059: LD_VAR 0 6
112063: ARRAY
112064: INC
112065: ST_TO_ADDR
112066: LD_INT 1
112068: PUSH
112069: FOR_DOWNTO
112070: IFFALSE 112231
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112072: LD_EXP 207
112076: PUSH
112077: LD_VAR 0 6
112081: ARRAY
112082: PUSH
112083: LD_VAR 0 5
112087: ARRAY
112088: PUSH
112089: LD_INT 1
112091: ARRAY
112092: PUSH
112093: LD_VAR 0 2
112097: EQUAL
112098: PUSH
112099: LD_EXP 207
112103: PUSH
112104: LD_VAR 0 6
112108: ARRAY
112109: PUSH
112110: LD_VAR 0 5
112114: ARRAY
112115: PUSH
112116: LD_INT 2
112118: ARRAY
112119: PUSH
112120: LD_VAR 0 3
112124: EQUAL
112125: AND
112126: IFFALSE 112229
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112128: LD_EXP 207
112132: PUSH
112133: LD_VAR 0 6
112137: ARRAY
112138: PUSH
112139: LD_VAR 0 5
112143: ARRAY
112144: PUSH
112145: LD_INT 1
112147: ARRAY
112148: PPUSH
112149: LD_EXP 207
112153: PUSH
112154: LD_VAR 0 6
112158: ARRAY
112159: PUSH
112160: LD_VAR 0 5
112164: ARRAY
112165: PUSH
112166: LD_INT 2
112168: ARRAY
112169: PPUSH
112170: LD_VAR 0 1
112174: PPUSH
112175: CALL_OW 255
112179: PPUSH
112180: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112184: LD_ADDR_EXP 207
112188: PUSH
112189: LD_EXP 207
112193: PPUSH
112194: LD_VAR 0 6
112198: PPUSH
112199: LD_EXP 207
112203: PUSH
112204: LD_VAR 0 6
112208: ARRAY
112209: PPUSH
112210: LD_VAR 0 5
112214: PPUSH
112215: CALL_OW 3
112219: PPUSH
112220: CALL_OW 1
112224: ST_TO_ADDR
// exit ;
112225: POP
112226: POP
112227: GO 112420
// end ; end ;
112229: GO 112069
112231: POP
112232: POP
// for i := minerMinesList [ index ] downto 1 do
112233: LD_ADDR_VAR 0 5
112237: PUSH
112238: DOUBLE
112239: LD_EXP 207
112243: PUSH
112244: LD_VAR 0 6
112248: ARRAY
112249: INC
112250: ST_TO_ADDR
112251: LD_INT 1
112253: PUSH
112254: FOR_DOWNTO
112255: IFFALSE 112418
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112257: LD_EXP 207
112261: PUSH
112262: LD_VAR 0 6
112266: ARRAY
112267: PUSH
112268: LD_VAR 0 5
112272: ARRAY
112273: PUSH
112274: LD_INT 1
112276: ARRAY
112277: PPUSH
112278: LD_EXP 207
112282: PUSH
112283: LD_VAR 0 6
112287: ARRAY
112288: PUSH
112289: LD_VAR 0 5
112293: ARRAY
112294: PUSH
112295: LD_INT 2
112297: ARRAY
112298: PPUSH
112299: LD_VAR 0 2
112303: PPUSH
112304: LD_VAR 0 3
112308: PPUSH
112309: CALL_OW 298
112313: PUSH
112314: LD_INT 6
112316: LESS
112317: IFFALSE 112416
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112319: LD_EXP 207
112323: PUSH
112324: LD_VAR 0 6
112328: ARRAY
112329: PUSH
112330: LD_VAR 0 5
112334: ARRAY
112335: PUSH
112336: LD_INT 1
112338: ARRAY
112339: PPUSH
112340: LD_EXP 207
112344: PUSH
112345: LD_VAR 0 6
112349: ARRAY
112350: PUSH
112351: LD_VAR 0 5
112355: ARRAY
112356: PUSH
112357: LD_INT 2
112359: ARRAY
112360: PPUSH
112361: LD_VAR 0 1
112365: PPUSH
112366: CALL_OW 255
112370: PPUSH
112371: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112375: LD_ADDR_EXP 207
112379: PUSH
112380: LD_EXP 207
112384: PPUSH
112385: LD_VAR 0 6
112389: PPUSH
112390: LD_EXP 207
112394: PUSH
112395: LD_VAR 0 6
112399: ARRAY
112400: PPUSH
112401: LD_VAR 0 5
112405: PPUSH
112406: CALL_OW 3
112410: PPUSH
112411: CALL_OW 1
112415: ST_TO_ADDR
// end ; end ;
112416: GO 112254
112418: POP
112419: POP
// end ;
112420: LD_VAR 0 4
112424: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112425: LD_INT 0
112427: PPUSH
112428: PPUSH
112429: PPUSH
112430: PPUSH
112431: PPUSH
112432: PPUSH
112433: PPUSH
112434: PPUSH
112435: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112436: LD_VAR 0 1
112440: PPUSH
112441: CALL_OW 264
112445: PUSH
112446: LD_EXP 81
112450: EQUAL
112451: NOT
112452: PUSH
112453: LD_VAR 0 1
112457: PUSH
112458: LD_EXP 206
112462: IN
112463: NOT
112464: OR
112465: IFFALSE 112469
// exit ;
112467: GO 112791
// index := GetElementIndex ( minersList , unit ) ;
112469: LD_ADDR_VAR 0 6
112473: PUSH
112474: LD_EXP 206
112478: PPUSH
112479: LD_VAR 0 1
112483: PPUSH
112484: CALL 56962 0 2
112488: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112489: LD_ADDR_VAR 0 8
112493: PUSH
112494: LD_EXP 208
112498: PUSH
112499: LD_EXP 207
112503: PUSH
112504: LD_VAR 0 6
112508: ARRAY
112509: MINUS
112510: ST_TO_ADDR
// if not minesFreeAmount then
112511: LD_VAR 0 8
112515: NOT
112516: IFFALSE 112520
// exit ;
112518: GO 112791
// tmp := [ ] ;
112520: LD_ADDR_VAR 0 7
112524: PUSH
112525: EMPTY
112526: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112527: LD_ADDR_VAR 0 5
112531: PUSH
112532: DOUBLE
112533: LD_INT 1
112535: DEC
112536: ST_TO_ADDR
112537: LD_VAR 0 8
112541: PUSH
112542: FOR_TO
112543: IFFALSE 112738
// begin _d := rand ( 0 , 5 ) ;
112545: LD_ADDR_VAR 0 11
112549: PUSH
112550: LD_INT 0
112552: PPUSH
112553: LD_INT 5
112555: PPUSH
112556: CALL_OW 12
112560: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112561: LD_ADDR_VAR 0 12
112565: PUSH
112566: LD_INT 2
112568: PPUSH
112569: LD_INT 6
112571: PPUSH
112572: CALL_OW 12
112576: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112577: LD_ADDR_VAR 0 9
112581: PUSH
112582: LD_VAR 0 2
112586: PPUSH
112587: LD_VAR 0 11
112591: PPUSH
112592: LD_VAR 0 12
112596: PPUSH
112597: CALL_OW 272
112601: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112602: LD_ADDR_VAR 0 10
112606: PUSH
112607: LD_VAR 0 3
112611: PPUSH
112612: LD_VAR 0 11
112616: PPUSH
112617: LD_VAR 0 12
112621: PPUSH
112622: CALL_OW 273
112626: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112627: LD_VAR 0 9
112631: PPUSH
112632: LD_VAR 0 10
112636: PPUSH
112637: CALL_OW 488
112641: PUSH
112642: LD_VAR 0 9
112646: PUSH
112647: LD_VAR 0 10
112651: PUSH
112652: EMPTY
112653: LIST
112654: LIST
112655: PUSH
112656: LD_VAR 0 7
112660: IN
112661: NOT
112662: AND
112663: PUSH
112664: LD_VAR 0 9
112668: PPUSH
112669: LD_VAR 0 10
112673: PPUSH
112674: CALL_OW 458
112678: NOT
112679: AND
112680: IFFALSE 112722
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112682: LD_ADDR_VAR 0 7
112686: PUSH
112687: LD_VAR 0 7
112691: PPUSH
112692: LD_VAR 0 7
112696: PUSH
112697: LD_INT 1
112699: PLUS
112700: PPUSH
112701: LD_VAR 0 9
112705: PUSH
112706: LD_VAR 0 10
112710: PUSH
112711: EMPTY
112712: LIST
112713: LIST
112714: PPUSH
112715: CALL_OW 1
112719: ST_TO_ADDR
112720: GO 112736
// i := i - 1 ;
112722: LD_ADDR_VAR 0 5
112726: PUSH
112727: LD_VAR 0 5
112731: PUSH
112732: LD_INT 1
112734: MINUS
112735: ST_TO_ADDR
// end ;
112736: GO 112542
112738: POP
112739: POP
// for i in tmp do
112740: LD_ADDR_VAR 0 5
112744: PUSH
112745: LD_VAR 0 7
112749: PUSH
112750: FOR_IN
112751: IFFALSE 112789
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112753: LD_VAR 0 1
112757: PPUSH
112758: LD_VAR 0 5
112762: PUSH
112763: LD_INT 1
112765: ARRAY
112766: PPUSH
112767: LD_VAR 0 5
112771: PUSH
112772: LD_INT 2
112774: ARRAY
112775: PPUSH
112776: CALL 111731 0 3
112780: NOT
112781: IFFALSE 112787
// exit ;
112783: POP
112784: POP
112785: GO 112791
112787: GO 112750
112789: POP
112790: POP
// end ;
112791: LD_VAR 0 4
112795: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112796: LD_INT 0
112798: PPUSH
112799: PPUSH
112800: PPUSH
112801: PPUSH
112802: PPUSH
112803: PPUSH
112804: PPUSH
// if not GetClass ( unit ) = class_sniper then
112805: LD_VAR 0 1
112809: PPUSH
112810: CALL_OW 257
112814: PUSH
112815: LD_INT 5
112817: EQUAL
112818: NOT
112819: IFFALSE 112823
// exit ;
112821: GO 113211
// dist := 8 ;
112823: LD_ADDR_VAR 0 5
112827: PUSH
112828: LD_INT 8
112830: ST_TO_ADDR
// viewRange := 12 ;
112831: LD_ADDR_VAR 0 7
112835: PUSH
112836: LD_INT 12
112838: ST_TO_ADDR
// side := GetSide ( unit ) ;
112839: LD_ADDR_VAR 0 6
112843: PUSH
112844: LD_VAR 0 1
112848: PPUSH
112849: CALL_OW 255
112853: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112854: LD_INT 61
112856: PPUSH
112857: LD_VAR 0 6
112861: PPUSH
112862: CALL_OW 321
112866: PUSH
112867: LD_INT 2
112869: EQUAL
112870: IFFALSE 112880
// viewRange := 16 ;
112872: LD_ADDR_VAR 0 7
112876: PUSH
112877: LD_INT 16
112879: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112880: LD_VAR 0 1
112884: PPUSH
112885: LD_VAR 0 2
112889: PPUSH
112890: LD_VAR 0 3
112894: PPUSH
112895: CALL_OW 297
112899: PUSH
112900: LD_VAR 0 5
112904: GREATER
112905: IFFALSE 112984
// begin ComMoveXY ( unit , x , y ) ;
112907: LD_VAR 0 1
112911: PPUSH
112912: LD_VAR 0 2
112916: PPUSH
112917: LD_VAR 0 3
112921: PPUSH
112922: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112926: LD_INT 35
112928: PPUSH
112929: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112933: LD_VAR 0 1
112937: PPUSH
112938: LD_VAR 0 2
112942: PPUSH
112943: LD_VAR 0 3
112947: PPUSH
112948: CALL 88248 0 3
112952: NOT
112953: IFFALSE 112957
// exit ;
112955: GO 113211
// until GetDistUnitXY ( unit , x , y ) < dist ;
112957: LD_VAR 0 1
112961: PPUSH
112962: LD_VAR 0 2
112966: PPUSH
112967: LD_VAR 0 3
112971: PPUSH
112972: CALL_OW 297
112976: PUSH
112977: LD_VAR 0 5
112981: LESS
112982: IFFALSE 112926
// end ; ComTurnXY ( unit , x , y ) ;
112984: LD_VAR 0 1
112988: PPUSH
112989: LD_VAR 0 2
112993: PPUSH
112994: LD_VAR 0 3
112998: PPUSH
112999: CALL_OW 118
// wait ( 5 ) ;
113003: LD_INT 5
113005: PPUSH
113006: CALL_OW 67
// _d := GetDir ( unit ) ;
113010: LD_ADDR_VAR 0 10
113014: PUSH
113015: LD_VAR 0 1
113019: PPUSH
113020: CALL_OW 254
113024: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
113025: LD_ADDR_VAR 0 8
113029: PUSH
113030: LD_VAR 0 1
113034: PPUSH
113035: CALL_OW 250
113039: PPUSH
113040: LD_VAR 0 10
113044: PPUSH
113045: LD_VAR 0 5
113049: PPUSH
113050: CALL_OW 272
113054: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
113055: LD_ADDR_VAR 0 9
113059: PUSH
113060: LD_VAR 0 1
113064: PPUSH
113065: CALL_OW 251
113069: PPUSH
113070: LD_VAR 0 10
113074: PPUSH
113075: LD_VAR 0 5
113079: PPUSH
113080: CALL_OW 273
113084: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113085: LD_VAR 0 8
113089: PPUSH
113090: LD_VAR 0 9
113094: PPUSH
113095: CALL_OW 488
113099: NOT
113100: IFFALSE 113104
// exit ;
113102: GO 113211
// ComAnimCustom ( unit , 1 ) ;
113104: LD_VAR 0 1
113108: PPUSH
113109: LD_INT 1
113111: PPUSH
113112: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113116: LD_VAR 0 8
113120: PPUSH
113121: LD_VAR 0 9
113125: PPUSH
113126: LD_VAR 0 6
113130: PPUSH
113131: LD_VAR 0 7
113135: PPUSH
113136: CALL_OW 330
// repeat wait ( 1 ) ;
113140: LD_INT 1
113142: PPUSH
113143: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113147: LD_VAR 0 1
113151: PPUSH
113152: CALL_OW 316
113156: PUSH
113157: LD_VAR 0 1
113161: PPUSH
113162: CALL_OW 314
113166: OR
113167: PUSH
113168: LD_VAR 0 1
113172: PPUSH
113173: CALL_OW 302
113177: NOT
113178: OR
113179: PUSH
113180: LD_VAR 0 1
113184: PPUSH
113185: CALL_OW 301
113189: OR
113190: IFFALSE 113140
// RemoveSeeing ( _x , _y , side ) ;
113192: LD_VAR 0 8
113196: PPUSH
113197: LD_VAR 0 9
113201: PPUSH
113202: LD_VAR 0 6
113206: PPUSH
113207: CALL_OW 331
// end ; end_of_file
113211: LD_VAR 0 4
113215: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113216: LD_INT 0
113218: PPUSH
113219: PPUSH
113220: PPUSH
113221: PPUSH
113222: PPUSH
113223: PPUSH
113224: PPUSH
113225: PPUSH
113226: PPUSH
113227: PPUSH
113228: PPUSH
113229: PPUSH
113230: PPUSH
113231: PPUSH
113232: PPUSH
113233: PPUSH
113234: PPUSH
113235: PPUSH
113236: PPUSH
113237: PPUSH
113238: PPUSH
113239: PPUSH
113240: PPUSH
113241: PPUSH
113242: PPUSH
113243: PPUSH
113244: PPUSH
113245: PPUSH
113246: PPUSH
113247: PPUSH
113248: PPUSH
113249: PPUSH
113250: PPUSH
113251: PPUSH
// if not list then
113252: LD_VAR 0 1
113256: NOT
113257: IFFALSE 113261
// exit ;
113259: GO 117920
// base := list [ 1 ] ;
113261: LD_ADDR_VAR 0 3
113265: PUSH
113266: LD_VAR 0 1
113270: PUSH
113271: LD_INT 1
113273: ARRAY
113274: ST_TO_ADDR
// group := list [ 2 ] ;
113275: LD_ADDR_VAR 0 4
113279: PUSH
113280: LD_VAR 0 1
113284: PUSH
113285: LD_INT 2
113287: ARRAY
113288: ST_TO_ADDR
// path := list [ 3 ] ;
113289: LD_ADDR_VAR 0 5
113293: PUSH
113294: LD_VAR 0 1
113298: PUSH
113299: LD_INT 3
113301: ARRAY
113302: ST_TO_ADDR
// flags := list [ 4 ] ;
113303: LD_ADDR_VAR 0 6
113307: PUSH
113308: LD_VAR 0 1
113312: PUSH
113313: LD_INT 4
113315: ARRAY
113316: ST_TO_ADDR
// mined := [ ] ;
113317: LD_ADDR_VAR 0 27
113321: PUSH
113322: EMPTY
113323: ST_TO_ADDR
// bombed := [ ] ;
113324: LD_ADDR_VAR 0 28
113328: PUSH
113329: EMPTY
113330: ST_TO_ADDR
// healers := [ ] ;
113331: LD_ADDR_VAR 0 31
113335: PUSH
113336: EMPTY
113337: ST_TO_ADDR
// to_heal := [ ] ;
113338: LD_ADDR_VAR 0 30
113342: PUSH
113343: EMPTY
113344: ST_TO_ADDR
// repairs := [ ] ;
113345: LD_ADDR_VAR 0 33
113349: PUSH
113350: EMPTY
113351: ST_TO_ADDR
// to_repair := [ ] ;
113352: LD_ADDR_VAR 0 32
113356: PUSH
113357: EMPTY
113358: ST_TO_ADDR
// if not group or not path then
113359: LD_VAR 0 4
113363: NOT
113364: PUSH
113365: LD_VAR 0 5
113369: NOT
113370: OR
113371: IFFALSE 113375
// exit ;
113373: GO 117920
// side := GetSide ( group [ 1 ] ) ;
113375: LD_ADDR_VAR 0 35
113379: PUSH
113380: LD_VAR 0 4
113384: PUSH
113385: LD_INT 1
113387: ARRAY
113388: PPUSH
113389: CALL_OW 255
113393: ST_TO_ADDR
// if flags then
113394: LD_VAR 0 6
113398: IFFALSE 113542
// begin f_ignore_area := flags [ 1 ] ;
113400: LD_ADDR_VAR 0 17
113404: PUSH
113405: LD_VAR 0 6
113409: PUSH
113410: LD_INT 1
113412: ARRAY
113413: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113414: LD_ADDR_VAR 0 18
113418: PUSH
113419: LD_VAR 0 6
113423: PUSH
113424: LD_INT 2
113426: ARRAY
113427: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113428: LD_ADDR_VAR 0 19
113432: PUSH
113433: LD_VAR 0 6
113437: PUSH
113438: LD_INT 3
113440: ARRAY
113441: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113442: LD_ADDR_VAR 0 20
113446: PUSH
113447: LD_VAR 0 6
113451: PUSH
113452: LD_INT 4
113454: ARRAY
113455: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113456: LD_ADDR_VAR 0 21
113460: PUSH
113461: LD_VAR 0 6
113465: PUSH
113466: LD_INT 5
113468: ARRAY
113469: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113470: LD_ADDR_VAR 0 22
113474: PUSH
113475: LD_VAR 0 6
113479: PUSH
113480: LD_INT 6
113482: ARRAY
113483: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113484: LD_ADDR_VAR 0 23
113488: PUSH
113489: LD_VAR 0 6
113493: PUSH
113494: LD_INT 7
113496: ARRAY
113497: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113498: LD_ADDR_VAR 0 24
113502: PUSH
113503: LD_VAR 0 6
113507: PUSH
113508: LD_INT 8
113510: ARRAY
113511: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113512: LD_ADDR_VAR 0 25
113516: PUSH
113517: LD_VAR 0 6
113521: PUSH
113522: LD_INT 9
113524: ARRAY
113525: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113526: LD_ADDR_VAR 0 26
113530: PUSH
113531: LD_VAR 0 6
113535: PUSH
113536: LD_INT 10
113538: ARRAY
113539: ST_TO_ADDR
// end else
113540: GO 113622
// begin f_ignore_area := false ;
113542: LD_ADDR_VAR 0 17
113546: PUSH
113547: LD_INT 0
113549: ST_TO_ADDR
// f_capture := false ;
113550: LD_ADDR_VAR 0 18
113554: PUSH
113555: LD_INT 0
113557: ST_TO_ADDR
// f_ignore_civ := false ;
113558: LD_ADDR_VAR 0 19
113562: PUSH
113563: LD_INT 0
113565: ST_TO_ADDR
// f_murder := false ;
113566: LD_ADDR_VAR 0 20
113570: PUSH
113571: LD_INT 0
113573: ST_TO_ADDR
// f_mines := false ;
113574: LD_ADDR_VAR 0 21
113578: PUSH
113579: LD_INT 0
113581: ST_TO_ADDR
// f_repair := false ;
113582: LD_ADDR_VAR 0 22
113586: PUSH
113587: LD_INT 0
113589: ST_TO_ADDR
// f_heal := false ;
113590: LD_ADDR_VAR 0 23
113594: PUSH
113595: LD_INT 0
113597: ST_TO_ADDR
// f_spacetime := false ;
113598: LD_ADDR_VAR 0 24
113602: PUSH
113603: LD_INT 0
113605: ST_TO_ADDR
// f_attack_depot := false ;
113606: LD_ADDR_VAR 0 25
113610: PUSH
113611: LD_INT 0
113613: ST_TO_ADDR
// f_crawl := false ;
113614: LD_ADDR_VAR 0 26
113618: PUSH
113619: LD_INT 0
113621: ST_TO_ADDR
// end ; if f_heal then
113622: LD_VAR 0 23
113626: IFFALSE 113653
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113628: LD_ADDR_VAR 0 31
113632: PUSH
113633: LD_VAR 0 4
113637: PPUSH
113638: LD_INT 25
113640: PUSH
113641: LD_INT 4
113643: PUSH
113644: EMPTY
113645: LIST
113646: LIST
113647: PPUSH
113648: CALL_OW 72
113652: ST_TO_ADDR
// if f_repair then
113653: LD_VAR 0 22
113657: IFFALSE 113684
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113659: LD_ADDR_VAR 0 33
113663: PUSH
113664: LD_VAR 0 4
113668: PPUSH
113669: LD_INT 25
113671: PUSH
113672: LD_INT 3
113674: PUSH
113675: EMPTY
113676: LIST
113677: LIST
113678: PPUSH
113679: CALL_OW 72
113683: ST_TO_ADDR
// units_path := [ ] ;
113684: LD_ADDR_VAR 0 16
113688: PUSH
113689: EMPTY
113690: ST_TO_ADDR
// for i = 1 to group do
113691: LD_ADDR_VAR 0 7
113695: PUSH
113696: DOUBLE
113697: LD_INT 1
113699: DEC
113700: ST_TO_ADDR
113701: LD_VAR 0 4
113705: PUSH
113706: FOR_TO
113707: IFFALSE 113736
// units_path := Replace ( units_path , i , path ) ;
113709: LD_ADDR_VAR 0 16
113713: PUSH
113714: LD_VAR 0 16
113718: PPUSH
113719: LD_VAR 0 7
113723: PPUSH
113724: LD_VAR 0 5
113728: PPUSH
113729: CALL_OW 1
113733: ST_TO_ADDR
113734: GO 113706
113736: POP
113737: POP
// repeat for i = group downto 1 do
113738: LD_ADDR_VAR 0 7
113742: PUSH
113743: DOUBLE
113744: LD_VAR 0 4
113748: INC
113749: ST_TO_ADDR
113750: LD_INT 1
113752: PUSH
113753: FOR_DOWNTO
113754: IFFALSE 117876
// begin wait ( 5 ) ;
113756: LD_INT 5
113758: PPUSH
113759: CALL_OW 67
// tmp := [ ] ;
113763: LD_ADDR_VAR 0 14
113767: PUSH
113768: EMPTY
113769: ST_TO_ADDR
// attacking := false ;
113770: LD_ADDR_VAR 0 29
113774: PUSH
113775: LD_INT 0
113777: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113778: LD_VAR 0 4
113782: PUSH
113783: LD_VAR 0 7
113787: ARRAY
113788: PPUSH
113789: CALL_OW 301
113793: PUSH
113794: LD_VAR 0 4
113798: PUSH
113799: LD_VAR 0 7
113803: ARRAY
113804: NOT
113805: OR
113806: IFFALSE 113915
// begin if GetType ( group [ i ] ) = unit_human then
113808: LD_VAR 0 4
113812: PUSH
113813: LD_VAR 0 7
113817: ARRAY
113818: PPUSH
113819: CALL_OW 247
113823: PUSH
113824: LD_INT 1
113826: EQUAL
113827: IFFALSE 113873
// begin to_heal := to_heal diff group [ i ] ;
113829: LD_ADDR_VAR 0 30
113833: PUSH
113834: LD_VAR 0 30
113838: PUSH
113839: LD_VAR 0 4
113843: PUSH
113844: LD_VAR 0 7
113848: ARRAY
113849: DIFF
113850: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113851: LD_ADDR_VAR 0 31
113855: PUSH
113856: LD_VAR 0 31
113860: PUSH
113861: LD_VAR 0 4
113865: PUSH
113866: LD_VAR 0 7
113870: ARRAY
113871: DIFF
113872: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113873: LD_ADDR_VAR 0 4
113877: PUSH
113878: LD_VAR 0 4
113882: PPUSH
113883: LD_VAR 0 7
113887: PPUSH
113888: CALL_OW 3
113892: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113893: LD_ADDR_VAR 0 16
113897: PUSH
113898: LD_VAR 0 16
113902: PPUSH
113903: LD_VAR 0 7
113907: PPUSH
113908: CALL_OW 3
113912: ST_TO_ADDR
// continue ;
113913: GO 113753
// end ; if f_repair then
113915: LD_VAR 0 22
113919: IFFALSE 114408
// begin if GetType ( group [ i ] ) = unit_vehicle then
113921: LD_VAR 0 4
113925: PUSH
113926: LD_VAR 0 7
113930: ARRAY
113931: PPUSH
113932: CALL_OW 247
113936: PUSH
113937: LD_INT 2
113939: EQUAL
113940: IFFALSE 114130
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113942: LD_VAR 0 4
113946: PUSH
113947: LD_VAR 0 7
113951: ARRAY
113952: PPUSH
113953: CALL_OW 256
113957: PUSH
113958: LD_INT 700
113960: LESS
113961: PUSH
113962: LD_VAR 0 4
113966: PUSH
113967: LD_VAR 0 7
113971: ARRAY
113972: PUSH
113973: LD_VAR 0 32
113977: IN
113978: NOT
113979: AND
113980: IFFALSE 114004
// to_repair := to_repair union group [ i ] ;
113982: LD_ADDR_VAR 0 32
113986: PUSH
113987: LD_VAR 0 32
113991: PUSH
113992: LD_VAR 0 4
113996: PUSH
113997: LD_VAR 0 7
114001: ARRAY
114002: UNION
114003: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114004: LD_VAR 0 4
114008: PUSH
114009: LD_VAR 0 7
114013: ARRAY
114014: PPUSH
114015: CALL_OW 256
114019: PUSH
114020: LD_INT 1000
114022: EQUAL
114023: PUSH
114024: LD_VAR 0 4
114028: PUSH
114029: LD_VAR 0 7
114033: ARRAY
114034: PUSH
114035: LD_VAR 0 32
114039: IN
114040: AND
114041: IFFALSE 114065
// to_repair := to_repair diff group [ i ] ;
114043: LD_ADDR_VAR 0 32
114047: PUSH
114048: LD_VAR 0 32
114052: PUSH
114053: LD_VAR 0 4
114057: PUSH
114058: LD_VAR 0 7
114062: ARRAY
114063: DIFF
114064: ST_TO_ADDR
// if group [ i ] in to_repair then
114065: LD_VAR 0 4
114069: PUSH
114070: LD_VAR 0 7
114074: ARRAY
114075: PUSH
114076: LD_VAR 0 32
114080: IN
114081: IFFALSE 114128
// begin if not IsInArea ( group [ i ] , f_repair ) then
114083: LD_VAR 0 4
114087: PUSH
114088: LD_VAR 0 7
114092: ARRAY
114093: PPUSH
114094: LD_VAR 0 22
114098: PPUSH
114099: CALL_OW 308
114103: NOT
114104: IFFALSE 114126
// ComMoveToArea ( group [ i ] , f_repair ) ;
114106: LD_VAR 0 4
114110: PUSH
114111: LD_VAR 0 7
114115: ARRAY
114116: PPUSH
114117: LD_VAR 0 22
114121: PPUSH
114122: CALL_OW 113
// continue ;
114126: GO 113753
// end ; end else
114128: GO 114408
// if group [ i ] in repairs then
114130: LD_VAR 0 4
114134: PUSH
114135: LD_VAR 0 7
114139: ARRAY
114140: PUSH
114141: LD_VAR 0 33
114145: IN
114146: IFFALSE 114408
// begin if IsInUnit ( group [ i ] ) then
114148: LD_VAR 0 4
114152: PUSH
114153: LD_VAR 0 7
114157: ARRAY
114158: PPUSH
114159: CALL_OW 310
114163: IFFALSE 114231
// begin z := IsInUnit ( group [ i ] ) ;
114165: LD_ADDR_VAR 0 13
114169: PUSH
114170: LD_VAR 0 4
114174: PUSH
114175: LD_VAR 0 7
114179: ARRAY
114180: PPUSH
114181: CALL_OW 310
114185: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114186: LD_VAR 0 13
114190: PUSH
114191: LD_VAR 0 32
114195: IN
114196: PUSH
114197: LD_VAR 0 13
114201: PPUSH
114202: LD_VAR 0 22
114206: PPUSH
114207: CALL_OW 308
114211: AND
114212: IFFALSE 114229
// ComExitVehicle ( group [ i ] ) ;
114214: LD_VAR 0 4
114218: PUSH
114219: LD_VAR 0 7
114223: ARRAY
114224: PPUSH
114225: CALL_OW 121
// end else
114229: GO 114408
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114231: LD_ADDR_VAR 0 13
114235: PUSH
114236: LD_VAR 0 4
114240: PPUSH
114241: LD_INT 95
114243: PUSH
114244: LD_VAR 0 22
114248: PUSH
114249: EMPTY
114250: LIST
114251: LIST
114252: PUSH
114253: LD_INT 58
114255: PUSH
114256: EMPTY
114257: LIST
114258: PUSH
114259: EMPTY
114260: LIST
114261: LIST
114262: PPUSH
114263: CALL_OW 72
114267: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114268: LD_VAR 0 4
114272: PUSH
114273: LD_VAR 0 7
114277: ARRAY
114278: PPUSH
114279: CALL_OW 314
114283: NOT
114284: IFFALSE 114406
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114286: LD_ADDR_VAR 0 10
114290: PUSH
114291: LD_VAR 0 13
114295: PPUSH
114296: LD_VAR 0 4
114300: PUSH
114301: LD_VAR 0 7
114305: ARRAY
114306: PPUSH
114307: CALL_OW 74
114311: ST_TO_ADDR
// if not x then
114312: LD_VAR 0 10
114316: NOT
114317: IFFALSE 114321
// continue ;
114319: GO 113753
// if GetLives ( x ) < 1000 then
114321: LD_VAR 0 10
114325: PPUSH
114326: CALL_OW 256
114330: PUSH
114331: LD_INT 1000
114333: LESS
114334: IFFALSE 114358
// ComRepairVehicle ( group [ i ] , x ) else
114336: LD_VAR 0 4
114340: PUSH
114341: LD_VAR 0 7
114345: ARRAY
114346: PPUSH
114347: LD_VAR 0 10
114351: PPUSH
114352: CALL_OW 129
114356: GO 114406
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114358: LD_VAR 0 23
114362: PUSH
114363: LD_VAR 0 4
114367: PUSH
114368: LD_VAR 0 7
114372: ARRAY
114373: PPUSH
114374: CALL_OW 256
114378: PUSH
114379: LD_INT 1000
114381: LESS
114382: AND
114383: NOT
114384: IFFALSE 114406
// ComEnterUnit ( group [ i ] , x ) ;
114386: LD_VAR 0 4
114390: PUSH
114391: LD_VAR 0 7
114395: ARRAY
114396: PPUSH
114397: LD_VAR 0 10
114401: PPUSH
114402: CALL_OW 120
// end ; continue ;
114406: GO 113753
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114408: LD_VAR 0 23
114412: PUSH
114413: LD_VAR 0 4
114417: PUSH
114418: LD_VAR 0 7
114422: ARRAY
114423: PPUSH
114424: CALL_OW 247
114428: PUSH
114429: LD_INT 1
114431: EQUAL
114432: AND
114433: IFFALSE 114911
// begin if group [ i ] in healers then
114435: LD_VAR 0 4
114439: PUSH
114440: LD_VAR 0 7
114444: ARRAY
114445: PUSH
114446: LD_VAR 0 31
114450: IN
114451: IFFALSE 114724
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114453: LD_VAR 0 4
114457: PUSH
114458: LD_VAR 0 7
114462: ARRAY
114463: PPUSH
114464: LD_VAR 0 23
114468: PPUSH
114469: CALL_OW 308
114473: NOT
114474: PUSH
114475: LD_VAR 0 4
114479: PUSH
114480: LD_VAR 0 7
114484: ARRAY
114485: PPUSH
114486: CALL_OW 314
114490: NOT
114491: AND
114492: IFFALSE 114516
// ComMoveToArea ( group [ i ] , f_heal ) else
114494: LD_VAR 0 4
114498: PUSH
114499: LD_VAR 0 7
114503: ARRAY
114504: PPUSH
114505: LD_VAR 0 23
114509: PPUSH
114510: CALL_OW 113
114514: GO 114722
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114516: LD_VAR 0 4
114520: PUSH
114521: LD_VAR 0 7
114525: ARRAY
114526: PPUSH
114527: CALL 86824 0 1
114531: PPUSH
114532: CALL_OW 256
114536: PUSH
114537: LD_INT 1000
114539: EQUAL
114540: IFFALSE 114559
// ComStop ( group [ i ] ) else
114542: LD_VAR 0 4
114546: PUSH
114547: LD_VAR 0 7
114551: ARRAY
114552: PPUSH
114553: CALL_OW 141
114557: GO 114722
// if not HasTask ( group [ i ] ) and to_heal then
114559: LD_VAR 0 4
114563: PUSH
114564: LD_VAR 0 7
114568: ARRAY
114569: PPUSH
114570: CALL_OW 314
114574: NOT
114575: PUSH
114576: LD_VAR 0 30
114580: AND
114581: IFFALSE 114722
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114583: LD_ADDR_VAR 0 13
114587: PUSH
114588: LD_VAR 0 30
114592: PPUSH
114593: LD_INT 3
114595: PUSH
114596: LD_INT 54
114598: PUSH
114599: EMPTY
114600: LIST
114601: PUSH
114602: EMPTY
114603: LIST
114604: LIST
114605: PPUSH
114606: CALL_OW 72
114610: PPUSH
114611: LD_VAR 0 4
114615: PUSH
114616: LD_VAR 0 7
114620: ARRAY
114621: PPUSH
114622: CALL_OW 74
114626: ST_TO_ADDR
// if z then
114627: LD_VAR 0 13
114631: IFFALSE 114722
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114633: LD_INT 91
114635: PUSH
114636: LD_VAR 0 13
114640: PUSH
114641: LD_INT 10
114643: PUSH
114644: EMPTY
114645: LIST
114646: LIST
114647: LIST
114648: PUSH
114649: LD_INT 81
114651: PUSH
114652: LD_VAR 0 13
114656: PPUSH
114657: CALL_OW 255
114661: PUSH
114662: EMPTY
114663: LIST
114664: LIST
114665: PUSH
114666: EMPTY
114667: LIST
114668: LIST
114669: PPUSH
114670: CALL_OW 69
114674: PUSH
114675: LD_INT 0
114677: EQUAL
114678: IFFALSE 114702
// ComHeal ( group [ i ] , z ) else
114680: LD_VAR 0 4
114684: PUSH
114685: LD_VAR 0 7
114689: ARRAY
114690: PPUSH
114691: LD_VAR 0 13
114695: PPUSH
114696: CALL_OW 128
114700: GO 114722
// ComMoveToArea ( group [ i ] , f_heal ) ;
114702: LD_VAR 0 4
114706: PUSH
114707: LD_VAR 0 7
114711: ARRAY
114712: PPUSH
114713: LD_VAR 0 23
114717: PPUSH
114718: CALL_OW 113
// end ; continue ;
114722: GO 113753
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114724: LD_VAR 0 4
114728: PUSH
114729: LD_VAR 0 7
114733: ARRAY
114734: PPUSH
114735: CALL_OW 256
114739: PUSH
114740: LD_INT 700
114742: LESS
114743: PUSH
114744: LD_VAR 0 4
114748: PUSH
114749: LD_VAR 0 7
114753: ARRAY
114754: PUSH
114755: LD_VAR 0 30
114759: IN
114760: NOT
114761: AND
114762: IFFALSE 114786
// to_heal := to_heal union group [ i ] ;
114764: LD_ADDR_VAR 0 30
114768: PUSH
114769: LD_VAR 0 30
114773: PUSH
114774: LD_VAR 0 4
114778: PUSH
114779: LD_VAR 0 7
114783: ARRAY
114784: UNION
114785: ST_TO_ADDR
// if group [ i ] in to_heal then
114786: LD_VAR 0 4
114790: PUSH
114791: LD_VAR 0 7
114795: ARRAY
114796: PUSH
114797: LD_VAR 0 30
114801: IN
114802: IFFALSE 114911
// begin if GetLives ( group [ i ] ) = 1000 then
114804: LD_VAR 0 4
114808: PUSH
114809: LD_VAR 0 7
114813: ARRAY
114814: PPUSH
114815: CALL_OW 256
114819: PUSH
114820: LD_INT 1000
114822: EQUAL
114823: IFFALSE 114849
// to_heal := to_heal diff group [ i ] else
114825: LD_ADDR_VAR 0 30
114829: PUSH
114830: LD_VAR 0 30
114834: PUSH
114835: LD_VAR 0 4
114839: PUSH
114840: LD_VAR 0 7
114844: ARRAY
114845: DIFF
114846: ST_TO_ADDR
114847: GO 114911
// begin if not IsInArea ( group [ i ] , to_heal ) then
114849: LD_VAR 0 4
114853: PUSH
114854: LD_VAR 0 7
114858: ARRAY
114859: PPUSH
114860: LD_VAR 0 30
114864: PPUSH
114865: CALL_OW 308
114869: NOT
114870: IFFALSE 114894
// ComMoveToArea ( group [ i ] , f_heal ) else
114872: LD_VAR 0 4
114876: PUSH
114877: LD_VAR 0 7
114881: ARRAY
114882: PPUSH
114883: LD_VAR 0 23
114887: PPUSH
114888: CALL_OW 113
114892: GO 114909
// ComHold ( group [ i ] ) ;
114894: LD_VAR 0 4
114898: PUSH
114899: LD_VAR 0 7
114903: ARRAY
114904: PPUSH
114905: CALL_OW 140
// continue ;
114909: GO 113753
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114911: LD_VAR 0 4
114915: PUSH
114916: LD_VAR 0 7
114920: ARRAY
114921: PPUSH
114922: LD_INT 10
114924: PPUSH
114925: CALL 84677 0 2
114929: NOT
114930: PUSH
114931: LD_VAR 0 16
114935: PUSH
114936: LD_VAR 0 7
114940: ARRAY
114941: PUSH
114942: EMPTY
114943: EQUAL
114944: NOT
114945: AND
114946: IFFALSE 115212
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114948: LD_VAR 0 4
114952: PUSH
114953: LD_VAR 0 7
114957: ARRAY
114958: PPUSH
114959: CALL_OW 262
114963: PUSH
114964: LD_INT 1
114966: PUSH
114967: LD_INT 2
114969: PUSH
114970: EMPTY
114971: LIST
114972: LIST
114973: IN
114974: IFFALSE 115015
// if GetFuel ( group [ i ] ) < 10 then
114976: LD_VAR 0 4
114980: PUSH
114981: LD_VAR 0 7
114985: ARRAY
114986: PPUSH
114987: CALL_OW 261
114991: PUSH
114992: LD_INT 10
114994: LESS
114995: IFFALSE 115015
// SetFuel ( group [ i ] , 12 ) ;
114997: LD_VAR 0 4
115001: PUSH
115002: LD_VAR 0 7
115006: ARRAY
115007: PPUSH
115008: LD_INT 12
115010: PPUSH
115011: CALL_OW 240
// if units_path [ i ] then
115015: LD_VAR 0 16
115019: PUSH
115020: LD_VAR 0 7
115024: ARRAY
115025: IFFALSE 115210
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115027: LD_VAR 0 4
115031: PUSH
115032: LD_VAR 0 7
115036: ARRAY
115037: PPUSH
115038: LD_VAR 0 16
115042: PUSH
115043: LD_VAR 0 7
115047: ARRAY
115048: PUSH
115049: LD_INT 1
115051: ARRAY
115052: PUSH
115053: LD_INT 1
115055: ARRAY
115056: PPUSH
115057: LD_VAR 0 16
115061: PUSH
115062: LD_VAR 0 7
115066: ARRAY
115067: PUSH
115068: LD_INT 1
115070: ARRAY
115071: PUSH
115072: LD_INT 2
115074: ARRAY
115075: PPUSH
115076: CALL_OW 297
115080: PUSH
115081: LD_INT 6
115083: GREATER
115084: IFFALSE 115159
// begin if not HasTask ( group [ i ] ) then
115086: LD_VAR 0 4
115090: PUSH
115091: LD_VAR 0 7
115095: ARRAY
115096: PPUSH
115097: CALL_OW 314
115101: NOT
115102: IFFALSE 115157
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115104: LD_VAR 0 4
115108: PUSH
115109: LD_VAR 0 7
115113: ARRAY
115114: PPUSH
115115: LD_VAR 0 16
115119: PUSH
115120: LD_VAR 0 7
115124: ARRAY
115125: PUSH
115126: LD_INT 1
115128: ARRAY
115129: PUSH
115130: LD_INT 1
115132: ARRAY
115133: PPUSH
115134: LD_VAR 0 16
115138: PUSH
115139: LD_VAR 0 7
115143: ARRAY
115144: PUSH
115145: LD_INT 1
115147: ARRAY
115148: PUSH
115149: LD_INT 2
115151: ARRAY
115152: PPUSH
115153: CALL_OW 114
// end else
115157: GO 115210
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115159: LD_ADDR_VAR 0 15
115163: PUSH
115164: LD_VAR 0 16
115168: PUSH
115169: LD_VAR 0 7
115173: ARRAY
115174: PPUSH
115175: LD_INT 1
115177: PPUSH
115178: CALL_OW 3
115182: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115183: LD_ADDR_VAR 0 16
115187: PUSH
115188: LD_VAR 0 16
115192: PPUSH
115193: LD_VAR 0 7
115197: PPUSH
115198: LD_VAR 0 15
115202: PPUSH
115203: CALL_OW 1
115207: ST_TO_ADDR
// continue ;
115208: GO 113753
// end ; end ; end else
115210: GO 117874
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115212: LD_ADDR_VAR 0 14
115216: PUSH
115217: LD_INT 81
115219: PUSH
115220: LD_VAR 0 4
115224: PUSH
115225: LD_VAR 0 7
115229: ARRAY
115230: PPUSH
115231: CALL_OW 255
115235: PUSH
115236: EMPTY
115237: LIST
115238: LIST
115239: PPUSH
115240: CALL_OW 69
115244: ST_TO_ADDR
// if not tmp then
115245: LD_VAR 0 14
115249: NOT
115250: IFFALSE 115254
// continue ;
115252: GO 113753
// if f_ignore_area then
115254: LD_VAR 0 17
115258: IFFALSE 115346
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115260: LD_ADDR_VAR 0 15
115264: PUSH
115265: LD_VAR 0 14
115269: PPUSH
115270: LD_INT 3
115272: PUSH
115273: LD_INT 92
115275: PUSH
115276: LD_VAR 0 17
115280: PUSH
115281: LD_INT 1
115283: ARRAY
115284: PUSH
115285: LD_VAR 0 17
115289: PUSH
115290: LD_INT 2
115292: ARRAY
115293: PUSH
115294: LD_VAR 0 17
115298: PUSH
115299: LD_INT 3
115301: ARRAY
115302: PUSH
115303: EMPTY
115304: LIST
115305: LIST
115306: LIST
115307: LIST
115308: PUSH
115309: EMPTY
115310: LIST
115311: LIST
115312: PPUSH
115313: CALL_OW 72
115317: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115318: LD_VAR 0 14
115322: PUSH
115323: LD_VAR 0 15
115327: DIFF
115328: IFFALSE 115346
// tmp := tmp diff tmp2 ;
115330: LD_ADDR_VAR 0 14
115334: PUSH
115335: LD_VAR 0 14
115339: PUSH
115340: LD_VAR 0 15
115344: DIFF
115345: ST_TO_ADDR
// end ; if not f_murder then
115346: LD_VAR 0 20
115350: NOT
115351: IFFALSE 115409
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115353: LD_ADDR_VAR 0 15
115357: PUSH
115358: LD_VAR 0 14
115362: PPUSH
115363: LD_INT 3
115365: PUSH
115366: LD_INT 50
115368: PUSH
115369: EMPTY
115370: LIST
115371: PUSH
115372: EMPTY
115373: LIST
115374: LIST
115375: PPUSH
115376: CALL_OW 72
115380: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115381: LD_VAR 0 14
115385: PUSH
115386: LD_VAR 0 15
115390: DIFF
115391: IFFALSE 115409
// tmp := tmp diff tmp2 ;
115393: LD_ADDR_VAR 0 14
115397: PUSH
115398: LD_VAR 0 14
115402: PUSH
115403: LD_VAR 0 15
115407: DIFF
115408: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115409: LD_ADDR_VAR 0 14
115413: PUSH
115414: LD_VAR 0 4
115418: PUSH
115419: LD_VAR 0 7
115423: ARRAY
115424: PPUSH
115425: LD_VAR 0 14
115429: PPUSH
115430: LD_INT 1
115432: PPUSH
115433: LD_INT 1
115435: PPUSH
115436: CALL 57612 0 4
115440: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115441: LD_VAR 0 4
115445: PUSH
115446: LD_VAR 0 7
115450: ARRAY
115451: PPUSH
115452: CALL_OW 257
115456: PUSH
115457: LD_INT 1
115459: EQUAL
115460: IFFALSE 115908
// begin if WantPlant ( group [ i ] ) then
115462: LD_VAR 0 4
115466: PUSH
115467: LD_VAR 0 7
115471: ARRAY
115472: PPUSH
115473: CALL 57113 0 1
115477: IFFALSE 115481
// continue ;
115479: GO 113753
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115481: LD_VAR 0 18
115485: PUSH
115486: LD_VAR 0 4
115490: PUSH
115491: LD_VAR 0 7
115495: ARRAY
115496: PPUSH
115497: CALL_OW 310
115501: NOT
115502: AND
115503: PUSH
115504: LD_VAR 0 14
115508: PUSH
115509: LD_INT 1
115511: ARRAY
115512: PUSH
115513: LD_VAR 0 14
115517: PPUSH
115518: LD_INT 21
115520: PUSH
115521: LD_INT 2
115523: PUSH
115524: EMPTY
115525: LIST
115526: LIST
115527: PUSH
115528: LD_INT 58
115530: PUSH
115531: EMPTY
115532: LIST
115533: PUSH
115534: EMPTY
115535: LIST
115536: LIST
115537: PPUSH
115538: CALL_OW 72
115542: IN
115543: AND
115544: IFFALSE 115580
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115546: LD_VAR 0 4
115550: PUSH
115551: LD_VAR 0 7
115555: ARRAY
115556: PPUSH
115557: LD_VAR 0 14
115561: PUSH
115562: LD_INT 1
115564: ARRAY
115565: PPUSH
115566: CALL_OW 120
// attacking := true ;
115570: LD_ADDR_VAR 0 29
115574: PUSH
115575: LD_INT 1
115577: ST_TO_ADDR
// continue ;
115578: GO 113753
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115580: LD_VAR 0 26
115584: PUSH
115585: LD_VAR 0 4
115589: PUSH
115590: LD_VAR 0 7
115594: ARRAY
115595: PPUSH
115596: CALL_OW 257
115600: PUSH
115601: LD_INT 1
115603: EQUAL
115604: AND
115605: PUSH
115606: LD_VAR 0 4
115610: PUSH
115611: LD_VAR 0 7
115615: ARRAY
115616: PPUSH
115617: CALL_OW 256
115621: PUSH
115622: LD_INT 800
115624: LESS
115625: AND
115626: PUSH
115627: LD_VAR 0 4
115631: PUSH
115632: LD_VAR 0 7
115636: ARRAY
115637: PPUSH
115638: CALL_OW 318
115642: NOT
115643: AND
115644: IFFALSE 115661
// ComCrawl ( group [ i ] ) ;
115646: LD_VAR 0 4
115650: PUSH
115651: LD_VAR 0 7
115655: ARRAY
115656: PPUSH
115657: CALL_OW 137
// if f_mines then
115661: LD_VAR 0 21
115665: IFFALSE 115908
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115667: LD_VAR 0 14
115671: PUSH
115672: LD_INT 1
115674: ARRAY
115675: PPUSH
115676: CALL_OW 247
115680: PUSH
115681: LD_INT 3
115683: EQUAL
115684: PUSH
115685: LD_VAR 0 14
115689: PUSH
115690: LD_INT 1
115692: ARRAY
115693: PUSH
115694: LD_VAR 0 27
115698: IN
115699: NOT
115700: AND
115701: IFFALSE 115908
// begin x := GetX ( tmp [ 1 ] ) ;
115703: LD_ADDR_VAR 0 10
115707: PUSH
115708: LD_VAR 0 14
115712: PUSH
115713: LD_INT 1
115715: ARRAY
115716: PPUSH
115717: CALL_OW 250
115721: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115722: LD_ADDR_VAR 0 11
115726: PUSH
115727: LD_VAR 0 14
115731: PUSH
115732: LD_INT 1
115734: ARRAY
115735: PPUSH
115736: CALL_OW 251
115740: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115741: LD_ADDR_VAR 0 12
115745: PUSH
115746: LD_VAR 0 4
115750: PUSH
115751: LD_VAR 0 7
115755: ARRAY
115756: PPUSH
115757: CALL 84762 0 1
115761: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115762: LD_VAR 0 4
115766: PUSH
115767: LD_VAR 0 7
115771: ARRAY
115772: PPUSH
115773: LD_VAR 0 10
115777: PPUSH
115778: LD_VAR 0 11
115782: PPUSH
115783: LD_VAR 0 14
115787: PUSH
115788: LD_INT 1
115790: ARRAY
115791: PPUSH
115792: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115796: LD_VAR 0 4
115800: PUSH
115801: LD_VAR 0 7
115805: ARRAY
115806: PPUSH
115807: LD_VAR 0 10
115811: PPUSH
115812: LD_VAR 0 12
115816: PPUSH
115817: LD_INT 7
115819: PPUSH
115820: CALL_OW 272
115824: PPUSH
115825: LD_VAR 0 11
115829: PPUSH
115830: LD_VAR 0 12
115834: PPUSH
115835: LD_INT 7
115837: PPUSH
115838: CALL_OW 273
115842: PPUSH
115843: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115847: LD_VAR 0 4
115851: PUSH
115852: LD_VAR 0 7
115856: ARRAY
115857: PPUSH
115858: LD_INT 71
115860: PPUSH
115861: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115865: LD_ADDR_VAR 0 27
115869: PUSH
115870: LD_VAR 0 27
115874: PPUSH
115875: LD_VAR 0 27
115879: PUSH
115880: LD_INT 1
115882: PLUS
115883: PPUSH
115884: LD_VAR 0 14
115888: PUSH
115889: LD_INT 1
115891: ARRAY
115892: PPUSH
115893: CALL_OW 1
115897: ST_TO_ADDR
// attacking := true ;
115898: LD_ADDR_VAR 0 29
115902: PUSH
115903: LD_INT 1
115905: ST_TO_ADDR
// continue ;
115906: GO 113753
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115908: LD_VAR 0 4
115912: PUSH
115913: LD_VAR 0 7
115917: ARRAY
115918: PPUSH
115919: CALL_OW 257
115923: PUSH
115924: LD_INT 17
115926: EQUAL
115927: PUSH
115928: LD_VAR 0 4
115932: PUSH
115933: LD_VAR 0 7
115937: ARRAY
115938: PPUSH
115939: CALL_OW 110
115943: PUSH
115944: LD_INT 71
115946: EQUAL
115947: NOT
115948: AND
115949: IFFALSE 116095
// begin attacking := false ;
115951: LD_ADDR_VAR 0 29
115955: PUSH
115956: LD_INT 0
115958: ST_TO_ADDR
// k := 5 ;
115959: LD_ADDR_VAR 0 9
115963: PUSH
115964: LD_INT 5
115966: ST_TO_ADDR
// if tmp < k then
115967: LD_VAR 0 14
115971: PUSH
115972: LD_VAR 0 9
115976: LESS
115977: IFFALSE 115989
// k := tmp ;
115979: LD_ADDR_VAR 0 9
115983: PUSH
115984: LD_VAR 0 14
115988: ST_TO_ADDR
// for j = 1 to k do
115989: LD_ADDR_VAR 0 8
115993: PUSH
115994: DOUBLE
115995: LD_INT 1
115997: DEC
115998: ST_TO_ADDR
115999: LD_VAR 0 9
116003: PUSH
116004: FOR_TO
116005: IFFALSE 116093
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116007: LD_VAR 0 14
116011: PUSH
116012: LD_VAR 0 8
116016: ARRAY
116017: PUSH
116018: LD_VAR 0 14
116022: PPUSH
116023: LD_INT 58
116025: PUSH
116026: EMPTY
116027: LIST
116028: PPUSH
116029: CALL_OW 72
116033: IN
116034: NOT
116035: IFFALSE 116091
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116037: LD_VAR 0 4
116041: PUSH
116042: LD_VAR 0 7
116046: ARRAY
116047: PPUSH
116048: LD_VAR 0 14
116052: PUSH
116053: LD_VAR 0 8
116057: ARRAY
116058: PPUSH
116059: CALL_OW 115
// attacking := true ;
116063: LD_ADDR_VAR 0 29
116067: PUSH
116068: LD_INT 1
116070: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116071: LD_VAR 0 4
116075: PUSH
116076: LD_VAR 0 7
116080: ARRAY
116081: PPUSH
116082: LD_INT 71
116084: PPUSH
116085: CALL_OW 109
// continue ;
116089: GO 116004
// end ; end ;
116091: GO 116004
116093: POP
116094: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116095: LD_VAR 0 4
116099: PUSH
116100: LD_VAR 0 7
116104: ARRAY
116105: PPUSH
116106: CALL_OW 257
116110: PUSH
116111: LD_INT 8
116113: EQUAL
116114: PUSH
116115: LD_VAR 0 4
116119: PUSH
116120: LD_VAR 0 7
116124: ARRAY
116125: PPUSH
116126: CALL_OW 264
116130: PUSH
116131: LD_INT 28
116133: PUSH
116134: LD_INT 45
116136: PUSH
116137: LD_INT 7
116139: PUSH
116140: LD_INT 47
116142: PUSH
116143: EMPTY
116144: LIST
116145: LIST
116146: LIST
116147: LIST
116148: IN
116149: OR
116150: IFFALSE 116406
// begin attacking := false ;
116152: LD_ADDR_VAR 0 29
116156: PUSH
116157: LD_INT 0
116159: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116160: LD_VAR 0 14
116164: PUSH
116165: LD_INT 1
116167: ARRAY
116168: PPUSH
116169: CALL_OW 266
116173: PUSH
116174: LD_INT 32
116176: PUSH
116177: LD_INT 31
116179: PUSH
116180: LD_INT 33
116182: PUSH
116183: LD_INT 4
116185: PUSH
116186: LD_INT 5
116188: PUSH
116189: EMPTY
116190: LIST
116191: LIST
116192: LIST
116193: LIST
116194: LIST
116195: IN
116196: IFFALSE 116382
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116198: LD_ADDR_VAR 0 9
116202: PUSH
116203: LD_VAR 0 14
116207: PUSH
116208: LD_INT 1
116210: ARRAY
116211: PPUSH
116212: CALL_OW 266
116216: PPUSH
116217: LD_VAR 0 14
116221: PUSH
116222: LD_INT 1
116224: ARRAY
116225: PPUSH
116226: CALL_OW 250
116230: PPUSH
116231: LD_VAR 0 14
116235: PUSH
116236: LD_INT 1
116238: ARRAY
116239: PPUSH
116240: CALL_OW 251
116244: PPUSH
116245: LD_VAR 0 14
116249: PUSH
116250: LD_INT 1
116252: ARRAY
116253: PPUSH
116254: CALL_OW 254
116258: PPUSH
116259: LD_VAR 0 14
116263: PUSH
116264: LD_INT 1
116266: ARRAY
116267: PPUSH
116268: CALL_OW 248
116272: PPUSH
116273: LD_INT 0
116275: PPUSH
116276: CALL 66132 0 6
116280: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116281: LD_ADDR_VAR 0 8
116285: PUSH
116286: LD_VAR 0 4
116290: PUSH
116291: LD_VAR 0 7
116295: ARRAY
116296: PPUSH
116297: LD_VAR 0 9
116301: PPUSH
116302: CALL 84802 0 2
116306: ST_TO_ADDR
// if j then
116307: LD_VAR 0 8
116311: IFFALSE 116380
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116313: LD_VAR 0 8
116317: PUSH
116318: LD_INT 1
116320: ARRAY
116321: PPUSH
116322: LD_VAR 0 8
116326: PUSH
116327: LD_INT 2
116329: ARRAY
116330: PPUSH
116331: CALL_OW 488
116335: IFFALSE 116380
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116337: LD_VAR 0 4
116341: PUSH
116342: LD_VAR 0 7
116346: ARRAY
116347: PPUSH
116348: LD_VAR 0 8
116352: PUSH
116353: LD_INT 1
116355: ARRAY
116356: PPUSH
116357: LD_VAR 0 8
116361: PUSH
116362: LD_INT 2
116364: ARRAY
116365: PPUSH
116366: CALL_OW 116
// attacking := true ;
116370: LD_ADDR_VAR 0 29
116374: PUSH
116375: LD_INT 1
116377: ST_TO_ADDR
// continue ;
116378: GO 113753
// end ; end else
116380: GO 116406
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116382: LD_VAR 0 4
116386: PUSH
116387: LD_VAR 0 7
116391: ARRAY
116392: PPUSH
116393: LD_VAR 0 14
116397: PUSH
116398: LD_INT 1
116400: ARRAY
116401: PPUSH
116402: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116406: LD_VAR 0 4
116410: PUSH
116411: LD_VAR 0 7
116415: ARRAY
116416: PPUSH
116417: CALL_OW 265
116421: PUSH
116422: LD_INT 11
116424: EQUAL
116425: IFFALSE 116703
// begin k := 10 ;
116427: LD_ADDR_VAR 0 9
116431: PUSH
116432: LD_INT 10
116434: ST_TO_ADDR
// x := 0 ;
116435: LD_ADDR_VAR 0 10
116439: PUSH
116440: LD_INT 0
116442: ST_TO_ADDR
// if tmp < k then
116443: LD_VAR 0 14
116447: PUSH
116448: LD_VAR 0 9
116452: LESS
116453: IFFALSE 116465
// k := tmp ;
116455: LD_ADDR_VAR 0 9
116459: PUSH
116460: LD_VAR 0 14
116464: ST_TO_ADDR
// for j = k downto 1 do
116465: LD_ADDR_VAR 0 8
116469: PUSH
116470: DOUBLE
116471: LD_VAR 0 9
116475: INC
116476: ST_TO_ADDR
116477: LD_INT 1
116479: PUSH
116480: FOR_DOWNTO
116481: IFFALSE 116556
// begin if GetType ( tmp [ j ] ) = unit_human then
116483: LD_VAR 0 14
116487: PUSH
116488: LD_VAR 0 8
116492: ARRAY
116493: PPUSH
116494: CALL_OW 247
116498: PUSH
116499: LD_INT 1
116501: EQUAL
116502: IFFALSE 116554
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116504: LD_VAR 0 4
116508: PUSH
116509: LD_VAR 0 7
116513: ARRAY
116514: PPUSH
116515: LD_VAR 0 14
116519: PUSH
116520: LD_VAR 0 8
116524: ARRAY
116525: PPUSH
116526: CALL 85073 0 2
// x := tmp [ j ] ;
116530: LD_ADDR_VAR 0 10
116534: PUSH
116535: LD_VAR 0 14
116539: PUSH
116540: LD_VAR 0 8
116544: ARRAY
116545: ST_TO_ADDR
// attacking := true ;
116546: LD_ADDR_VAR 0 29
116550: PUSH
116551: LD_INT 1
116553: ST_TO_ADDR
// end ; end ;
116554: GO 116480
116556: POP
116557: POP
// if not x then
116558: LD_VAR 0 10
116562: NOT
116563: IFFALSE 116703
// begin attacking := true ;
116565: LD_ADDR_VAR 0 29
116569: PUSH
116570: LD_INT 1
116572: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116573: LD_VAR 0 4
116577: PUSH
116578: LD_VAR 0 7
116582: ARRAY
116583: PPUSH
116584: CALL_OW 250
116588: PPUSH
116589: LD_VAR 0 4
116593: PUSH
116594: LD_VAR 0 7
116598: ARRAY
116599: PPUSH
116600: CALL_OW 251
116604: PPUSH
116605: CALL_OW 546
116609: PUSH
116610: LD_INT 2
116612: ARRAY
116613: PUSH
116614: LD_VAR 0 14
116618: PUSH
116619: LD_INT 1
116621: ARRAY
116622: PPUSH
116623: CALL_OW 250
116627: PPUSH
116628: LD_VAR 0 14
116632: PUSH
116633: LD_INT 1
116635: ARRAY
116636: PPUSH
116637: CALL_OW 251
116641: PPUSH
116642: CALL_OW 546
116646: PUSH
116647: LD_INT 2
116649: ARRAY
116650: EQUAL
116651: IFFALSE 116679
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116653: LD_VAR 0 4
116657: PUSH
116658: LD_VAR 0 7
116662: ARRAY
116663: PPUSH
116664: LD_VAR 0 14
116668: PUSH
116669: LD_INT 1
116671: ARRAY
116672: PPUSH
116673: CALL 85073 0 2
116677: GO 116703
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116679: LD_VAR 0 4
116683: PUSH
116684: LD_VAR 0 7
116688: ARRAY
116689: PPUSH
116690: LD_VAR 0 14
116694: PUSH
116695: LD_INT 1
116697: ARRAY
116698: PPUSH
116699: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116703: LD_VAR 0 4
116707: PUSH
116708: LD_VAR 0 7
116712: ARRAY
116713: PPUSH
116714: CALL_OW 264
116718: PUSH
116719: LD_INT 29
116721: EQUAL
116722: IFFALSE 117088
// begin if WantsToAttack ( group [ i ] ) in bombed then
116724: LD_VAR 0 4
116728: PUSH
116729: LD_VAR 0 7
116733: ARRAY
116734: PPUSH
116735: CALL_OW 319
116739: PUSH
116740: LD_VAR 0 28
116744: IN
116745: IFFALSE 116749
// continue ;
116747: GO 113753
// k := 8 ;
116749: LD_ADDR_VAR 0 9
116753: PUSH
116754: LD_INT 8
116756: ST_TO_ADDR
// x := 0 ;
116757: LD_ADDR_VAR 0 10
116761: PUSH
116762: LD_INT 0
116764: ST_TO_ADDR
// if tmp < k then
116765: LD_VAR 0 14
116769: PUSH
116770: LD_VAR 0 9
116774: LESS
116775: IFFALSE 116787
// k := tmp ;
116777: LD_ADDR_VAR 0 9
116781: PUSH
116782: LD_VAR 0 14
116786: ST_TO_ADDR
// for j = 1 to k do
116787: LD_ADDR_VAR 0 8
116791: PUSH
116792: DOUBLE
116793: LD_INT 1
116795: DEC
116796: ST_TO_ADDR
116797: LD_VAR 0 9
116801: PUSH
116802: FOR_TO
116803: IFFALSE 116935
// begin if GetType ( tmp [ j ] ) = unit_building then
116805: LD_VAR 0 14
116809: PUSH
116810: LD_VAR 0 8
116814: ARRAY
116815: PPUSH
116816: CALL_OW 247
116820: PUSH
116821: LD_INT 3
116823: EQUAL
116824: IFFALSE 116933
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116826: LD_VAR 0 14
116830: PUSH
116831: LD_VAR 0 8
116835: ARRAY
116836: PUSH
116837: LD_VAR 0 28
116841: IN
116842: NOT
116843: PUSH
116844: LD_VAR 0 14
116848: PUSH
116849: LD_VAR 0 8
116853: ARRAY
116854: PPUSH
116855: CALL_OW 313
116859: AND
116860: IFFALSE 116933
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116862: LD_VAR 0 4
116866: PUSH
116867: LD_VAR 0 7
116871: ARRAY
116872: PPUSH
116873: LD_VAR 0 14
116877: PUSH
116878: LD_VAR 0 8
116882: ARRAY
116883: PPUSH
116884: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116888: LD_ADDR_VAR 0 28
116892: PUSH
116893: LD_VAR 0 28
116897: PPUSH
116898: LD_VAR 0 28
116902: PUSH
116903: LD_INT 1
116905: PLUS
116906: PPUSH
116907: LD_VAR 0 14
116911: PUSH
116912: LD_VAR 0 8
116916: ARRAY
116917: PPUSH
116918: CALL_OW 1
116922: ST_TO_ADDR
// attacking := true ;
116923: LD_ADDR_VAR 0 29
116927: PUSH
116928: LD_INT 1
116930: ST_TO_ADDR
// break ;
116931: GO 116935
// end ; end ;
116933: GO 116802
116935: POP
116936: POP
// if not attacking and f_attack_depot then
116937: LD_VAR 0 29
116941: NOT
116942: PUSH
116943: LD_VAR 0 25
116947: AND
116948: IFFALSE 117043
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116950: LD_ADDR_VAR 0 13
116954: PUSH
116955: LD_VAR 0 14
116959: PPUSH
116960: LD_INT 2
116962: PUSH
116963: LD_INT 30
116965: PUSH
116966: LD_INT 0
116968: PUSH
116969: EMPTY
116970: LIST
116971: LIST
116972: PUSH
116973: LD_INT 30
116975: PUSH
116976: LD_INT 1
116978: PUSH
116979: EMPTY
116980: LIST
116981: LIST
116982: PUSH
116983: EMPTY
116984: LIST
116985: LIST
116986: LIST
116987: PPUSH
116988: CALL_OW 72
116992: ST_TO_ADDR
// if z then
116993: LD_VAR 0 13
116997: IFFALSE 117043
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116999: LD_VAR 0 4
117003: PUSH
117004: LD_VAR 0 7
117008: ARRAY
117009: PPUSH
117010: LD_VAR 0 13
117014: PPUSH
117015: LD_VAR 0 4
117019: PUSH
117020: LD_VAR 0 7
117024: ARRAY
117025: PPUSH
117026: CALL_OW 74
117030: PPUSH
117031: CALL_OW 115
// attacking := true ;
117035: LD_ADDR_VAR 0 29
117039: PUSH
117040: LD_INT 1
117042: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117043: LD_VAR 0 4
117047: PUSH
117048: LD_VAR 0 7
117052: ARRAY
117053: PPUSH
117054: CALL_OW 256
117058: PUSH
117059: LD_INT 500
117061: LESS
117062: IFFALSE 117088
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117064: LD_VAR 0 4
117068: PUSH
117069: LD_VAR 0 7
117073: ARRAY
117074: PPUSH
117075: LD_VAR 0 14
117079: PUSH
117080: LD_INT 1
117082: ARRAY
117083: PPUSH
117084: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117088: LD_VAR 0 4
117092: PUSH
117093: LD_VAR 0 7
117097: ARRAY
117098: PPUSH
117099: CALL_OW 264
117103: PUSH
117104: LD_INT 49
117106: EQUAL
117107: IFFALSE 117228
// begin if not HasTask ( group [ i ] ) then
117109: LD_VAR 0 4
117113: PUSH
117114: LD_VAR 0 7
117118: ARRAY
117119: PPUSH
117120: CALL_OW 314
117124: NOT
117125: IFFALSE 117228
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117127: LD_ADDR_VAR 0 9
117131: PUSH
117132: LD_INT 81
117134: PUSH
117135: LD_VAR 0 4
117139: PUSH
117140: LD_VAR 0 7
117144: ARRAY
117145: PPUSH
117146: CALL_OW 255
117150: PUSH
117151: EMPTY
117152: LIST
117153: LIST
117154: PPUSH
117155: CALL_OW 69
117159: PPUSH
117160: LD_VAR 0 4
117164: PUSH
117165: LD_VAR 0 7
117169: ARRAY
117170: PPUSH
117171: CALL_OW 74
117175: ST_TO_ADDR
// if k then
117176: LD_VAR 0 9
117180: IFFALSE 117228
// if GetDistUnits ( group [ i ] , k ) > 10 then
117182: LD_VAR 0 4
117186: PUSH
117187: LD_VAR 0 7
117191: ARRAY
117192: PPUSH
117193: LD_VAR 0 9
117197: PPUSH
117198: CALL_OW 296
117202: PUSH
117203: LD_INT 10
117205: GREATER
117206: IFFALSE 117228
// ComMoveUnit ( group [ i ] , k ) ;
117208: LD_VAR 0 4
117212: PUSH
117213: LD_VAR 0 7
117217: ARRAY
117218: PPUSH
117219: LD_VAR 0 9
117223: PPUSH
117224: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117228: LD_VAR 0 4
117232: PUSH
117233: LD_VAR 0 7
117237: ARRAY
117238: PPUSH
117239: CALL_OW 256
117243: PUSH
117244: LD_INT 250
117246: LESS
117247: PUSH
117248: LD_VAR 0 4
117252: PUSH
117253: LD_VAR 0 7
117257: ARRAY
117258: PUSH
117259: LD_INT 21
117261: PUSH
117262: LD_INT 2
117264: PUSH
117265: EMPTY
117266: LIST
117267: LIST
117268: PUSH
117269: LD_INT 23
117271: PUSH
117272: LD_INT 2
117274: PUSH
117275: EMPTY
117276: LIST
117277: LIST
117278: PUSH
117279: EMPTY
117280: LIST
117281: LIST
117282: PPUSH
117283: CALL_OW 69
117287: IN
117288: AND
117289: IFFALSE 117414
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117291: LD_ADDR_VAR 0 9
117295: PUSH
117296: LD_OWVAR 3
117300: PUSH
117301: LD_VAR 0 4
117305: PUSH
117306: LD_VAR 0 7
117310: ARRAY
117311: DIFF
117312: PPUSH
117313: LD_VAR 0 4
117317: PUSH
117318: LD_VAR 0 7
117322: ARRAY
117323: PPUSH
117324: CALL_OW 74
117328: ST_TO_ADDR
// if not k then
117329: LD_VAR 0 9
117333: NOT
117334: IFFALSE 117338
// continue ;
117336: GO 113753
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117338: LD_VAR 0 9
117342: PUSH
117343: LD_INT 81
117345: PUSH
117346: LD_VAR 0 4
117350: PUSH
117351: LD_VAR 0 7
117355: ARRAY
117356: PPUSH
117357: CALL_OW 255
117361: PUSH
117362: EMPTY
117363: LIST
117364: LIST
117365: PPUSH
117366: CALL_OW 69
117370: IN
117371: PUSH
117372: LD_VAR 0 9
117376: PPUSH
117377: LD_VAR 0 4
117381: PUSH
117382: LD_VAR 0 7
117386: ARRAY
117387: PPUSH
117388: CALL_OW 296
117392: PUSH
117393: LD_INT 5
117395: LESS
117396: AND
117397: IFFALSE 117414
// ComAutodestruct ( group [ i ] ) ;
117399: LD_VAR 0 4
117403: PUSH
117404: LD_VAR 0 7
117408: ARRAY
117409: PPUSH
117410: CALL 84971 0 1
// end ; if f_attack_depot then
117414: LD_VAR 0 25
117418: IFFALSE 117530
// begin k := 6 ;
117420: LD_ADDR_VAR 0 9
117424: PUSH
117425: LD_INT 6
117427: ST_TO_ADDR
// if tmp < k then
117428: LD_VAR 0 14
117432: PUSH
117433: LD_VAR 0 9
117437: LESS
117438: IFFALSE 117450
// k := tmp ;
117440: LD_ADDR_VAR 0 9
117444: PUSH
117445: LD_VAR 0 14
117449: ST_TO_ADDR
// for j = 1 to k do
117450: LD_ADDR_VAR 0 8
117454: PUSH
117455: DOUBLE
117456: LD_INT 1
117458: DEC
117459: ST_TO_ADDR
117460: LD_VAR 0 9
117464: PUSH
117465: FOR_TO
117466: IFFALSE 117528
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117468: LD_VAR 0 8
117472: PPUSH
117473: CALL_OW 266
117477: PUSH
117478: LD_INT 0
117480: PUSH
117481: LD_INT 1
117483: PUSH
117484: EMPTY
117485: LIST
117486: LIST
117487: IN
117488: IFFALSE 117526
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117490: LD_VAR 0 4
117494: PUSH
117495: LD_VAR 0 7
117499: ARRAY
117500: PPUSH
117501: LD_VAR 0 14
117505: PUSH
117506: LD_VAR 0 8
117510: ARRAY
117511: PPUSH
117512: CALL_OW 115
// attacking := true ;
117516: LD_ADDR_VAR 0 29
117520: PUSH
117521: LD_INT 1
117523: ST_TO_ADDR
// break ;
117524: GO 117528
// end ;
117526: GO 117465
117528: POP
117529: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117530: LD_VAR 0 4
117534: PUSH
117535: LD_VAR 0 7
117539: ARRAY
117540: PPUSH
117541: CALL_OW 302
117545: PUSH
117546: LD_VAR 0 29
117550: NOT
117551: AND
117552: IFFALSE 117874
// begin if GetTag ( group [ i ] ) = 71 then
117554: LD_VAR 0 4
117558: PUSH
117559: LD_VAR 0 7
117563: ARRAY
117564: PPUSH
117565: CALL_OW 110
117569: PUSH
117570: LD_INT 71
117572: EQUAL
117573: IFFALSE 117614
// begin if HasTask ( group [ i ] ) then
117575: LD_VAR 0 4
117579: PUSH
117580: LD_VAR 0 7
117584: ARRAY
117585: PPUSH
117586: CALL_OW 314
117590: IFFALSE 117596
// continue else
117592: GO 113753
117594: GO 117614
// SetTag ( group [ i ] , 0 ) ;
117596: LD_VAR 0 4
117600: PUSH
117601: LD_VAR 0 7
117605: ARRAY
117606: PPUSH
117607: LD_INT 0
117609: PPUSH
117610: CALL_OW 109
// end ; k := 8 ;
117614: LD_ADDR_VAR 0 9
117618: PUSH
117619: LD_INT 8
117621: ST_TO_ADDR
// x := 0 ;
117622: LD_ADDR_VAR 0 10
117626: PUSH
117627: LD_INT 0
117629: ST_TO_ADDR
// if tmp < k then
117630: LD_VAR 0 14
117634: PUSH
117635: LD_VAR 0 9
117639: LESS
117640: IFFALSE 117652
// k := tmp ;
117642: LD_ADDR_VAR 0 9
117646: PUSH
117647: LD_VAR 0 14
117651: ST_TO_ADDR
// for j = 1 to k do
117652: LD_ADDR_VAR 0 8
117656: PUSH
117657: DOUBLE
117658: LD_INT 1
117660: DEC
117661: ST_TO_ADDR
117662: LD_VAR 0 9
117666: PUSH
117667: FOR_TO
117668: IFFALSE 117766
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117670: LD_VAR 0 14
117674: PUSH
117675: LD_VAR 0 8
117679: ARRAY
117680: PPUSH
117681: CALL_OW 247
117685: PUSH
117686: LD_INT 1
117688: EQUAL
117689: PUSH
117690: LD_VAR 0 14
117694: PUSH
117695: LD_VAR 0 8
117699: ARRAY
117700: PPUSH
117701: CALL_OW 256
117705: PUSH
117706: LD_INT 250
117708: LESS
117709: PUSH
117710: LD_VAR 0 20
117714: AND
117715: PUSH
117716: LD_VAR 0 20
117720: NOT
117721: PUSH
117722: LD_VAR 0 14
117726: PUSH
117727: LD_VAR 0 8
117731: ARRAY
117732: PPUSH
117733: CALL_OW 256
117737: PUSH
117738: LD_INT 250
117740: GREATEREQUAL
117741: AND
117742: OR
117743: AND
117744: IFFALSE 117764
// begin x := tmp [ j ] ;
117746: LD_ADDR_VAR 0 10
117750: PUSH
117751: LD_VAR 0 14
117755: PUSH
117756: LD_VAR 0 8
117760: ARRAY
117761: ST_TO_ADDR
// break ;
117762: GO 117766
// end ;
117764: GO 117667
117766: POP
117767: POP
// if x then
117768: LD_VAR 0 10
117772: IFFALSE 117796
// ComAttackUnit ( group [ i ] , x ) else
117774: LD_VAR 0 4
117778: PUSH
117779: LD_VAR 0 7
117783: ARRAY
117784: PPUSH
117785: LD_VAR 0 10
117789: PPUSH
117790: CALL_OW 115
117794: GO 117820
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117796: LD_VAR 0 4
117800: PUSH
117801: LD_VAR 0 7
117805: ARRAY
117806: PPUSH
117807: LD_VAR 0 14
117811: PUSH
117812: LD_INT 1
117814: ARRAY
117815: PPUSH
117816: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117820: LD_VAR 0 4
117824: PUSH
117825: LD_VAR 0 7
117829: ARRAY
117830: PPUSH
117831: CALL_OW 314
117835: NOT
117836: IFFALSE 117874
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117838: LD_VAR 0 4
117842: PUSH
117843: LD_VAR 0 7
117847: ARRAY
117848: PPUSH
117849: LD_VAR 0 14
117853: PPUSH
117854: LD_VAR 0 4
117858: PUSH
117859: LD_VAR 0 7
117863: ARRAY
117864: PPUSH
117865: CALL_OW 74
117869: PPUSH
117870: CALL_OW 115
// end ; end ; end ;
117874: GO 113753
117876: POP
117877: POP
// wait ( 0 0$2 ) ;
117878: LD_INT 70
117880: PPUSH
117881: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117885: LD_VAR 0 4
117889: NOT
117890: PUSH
117891: LD_VAR 0 4
117895: PUSH
117896: EMPTY
117897: EQUAL
117898: OR
117899: PUSH
117900: LD_INT 81
117902: PUSH
117903: LD_VAR 0 35
117907: PUSH
117908: EMPTY
117909: LIST
117910: LIST
117911: PPUSH
117912: CALL_OW 69
117916: NOT
117917: OR
117918: IFFALSE 113738
// end ;
117920: LD_VAR 0 2
117924: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117925: LD_INT 0
117927: PPUSH
117928: PPUSH
117929: PPUSH
117930: PPUSH
117931: PPUSH
117932: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117933: LD_VAR 0 1
117937: NOT
117938: PUSH
117939: LD_EXP 94
117943: PUSH
117944: LD_VAR 0 1
117948: ARRAY
117949: NOT
117950: OR
117951: PUSH
117952: LD_VAR 0 2
117956: NOT
117957: OR
117958: IFFALSE 117962
// exit ;
117960: GO 118516
// side := mc_sides [ base ] ;
117962: LD_ADDR_VAR 0 6
117966: PUSH
117967: LD_EXP 120
117971: PUSH
117972: LD_VAR 0 1
117976: ARRAY
117977: ST_TO_ADDR
// if not side then
117978: LD_VAR 0 6
117982: NOT
117983: IFFALSE 117987
// exit ;
117985: GO 118516
// for i in solds do
117987: LD_ADDR_VAR 0 7
117991: PUSH
117992: LD_VAR 0 2
117996: PUSH
117997: FOR_IN
117998: IFFALSE 118059
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118000: LD_VAR 0 7
118004: PPUSH
118005: CALL_OW 310
118009: PPUSH
118010: CALL_OW 266
118014: PUSH
118015: LD_INT 32
118017: PUSH
118018: LD_INT 31
118020: PUSH
118021: EMPTY
118022: LIST
118023: LIST
118024: IN
118025: IFFALSE 118045
// solds := solds diff i else
118027: LD_ADDR_VAR 0 2
118031: PUSH
118032: LD_VAR 0 2
118036: PUSH
118037: LD_VAR 0 7
118041: DIFF
118042: ST_TO_ADDR
118043: GO 118057
// SetTag ( i , 18 ) ;
118045: LD_VAR 0 7
118049: PPUSH
118050: LD_INT 18
118052: PPUSH
118053: CALL_OW 109
118057: GO 117997
118059: POP
118060: POP
// if not solds then
118061: LD_VAR 0 2
118065: NOT
118066: IFFALSE 118070
// exit ;
118068: GO 118516
// repeat wait ( 0 0$2 ) ;
118070: LD_INT 70
118072: PPUSH
118073: CALL_OW 67
// enemy := mc_scan [ base ] ;
118077: LD_ADDR_VAR 0 4
118081: PUSH
118082: LD_EXP 117
118086: PUSH
118087: LD_VAR 0 1
118091: ARRAY
118092: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118093: LD_EXP 94
118097: PUSH
118098: LD_VAR 0 1
118102: ARRAY
118103: NOT
118104: PUSH
118105: LD_EXP 94
118109: PUSH
118110: LD_VAR 0 1
118114: ARRAY
118115: PUSH
118116: EMPTY
118117: EQUAL
118118: OR
118119: IFFALSE 118156
// begin for i in solds do
118121: LD_ADDR_VAR 0 7
118125: PUSH
118126: LD_VAR 0 2
118130: PUSH
118131: FOR_IN
118132: IFFALSE 118145
// ComStop ( i ) ;
118134: LD_VAR 0 7
118138: PPUSH
118139: CALL_OW 141
118143: GO 118131
118145: POP
118146: POP
// solds := [ ] ;
118147: LD_ADDR_VAR 0 2
118151: PUSH
118152: EMPTY
118153: ST_TO_ADDR
// exit ;
118154: GO 118516
// end ; for i in solds do
118156: LD_ADDR_VAR 0 7
118160: PUSH
118161: LD_VAR 0 2
118165: PUSH
118166: FOR_IN
118167: IFFALSE 118488
// begin if IsInUnit ( i ) then
118169: LD_VAR 0 7
118173: PPUSH
118174: CALL_OW 310
118178: IFFALSE 118189
// ComExitBuilding ( i ) ;
118180: LD_VAR 0 7
118184: PPUSH
118185: CALL_OW 122
// if GetLives ( i ) > 500 then
118189: LD_VAR 0 7
118193: PPUSH
118194: CALL_OW 256
118198: PUSH
118199: LD_INT 500
118201: GREATER
118202: IFFALSE 118255
// begin e := NearestUnitToUnit ( enemy , i ) ;
118204: LD_ADDR_VAR 0 5
118208: PUSH
118209: LD_VAR 0 4
118213: PPUSH
118214: LD_VAR 0 7
118218: PPUSH
118219: CALL_OW 74
118223: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118224: LD_VAR 0 7
118228: PPUSH
118229: LD_VAR 0 5
118233: PPUSH
118234: CALL_OW 250
118238: PPUSH
118239: LD_VAR 0 5
118243: PPUSH
118244: CALL_OW 251
118248: PPUSH
118249: CALL_OW 114
// end else
118253: GO 118486
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118255: LD_VAR 0 7
118259: PPUSH
118260: LD_EXP 94
118264: PUSH
118265: LD_VAR 0 1
118269: ARRAY
118270: PPUSH
118271: LD_INT 2
118273: PUSH
118274: LD_INT 30
118276: PUSH
118277: LD_INT 0
118279: PUSH
118280: EMPTY
118281: LIST
118282: LIST
118283: PUSH
118284: LD_INT 30
118286: PUSH
118287: LD_INT 1
118289: PUSH
118290: EMPTY
118291: LIST
118292: LIST
118293: PUSH
118294: LD_INT 30
118296: PUSH
118297: LD_INT 6
118299: PUSH
118300: EMPTY
118301: LIST
118302: LIST
118303: PUSH
118304: EMPTY
118305: LIST
118306: LIST
118307: LIST
118308: LIST
118309: PPUSH
118310: CALL_OW 72
118314: PPUSH
118315: LD_VAR 0 7
118319: PPUSH
118320: CALL_OW 74
118324: PPUSH
118325: CALL_OW 296
118329: PUSH
118330: LD_INT 10
118332: GREATER
118333: IFFALSE 118486
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118335: LD_ADDR_VAR 0 8
118339: PUSH
118340: LD_EXP 94
118344: PUSH
118345: LD_VAR 0 1
118349: ARRAY
118350: PPUSH
118351: LD_INT 2
118353: PUSH
118354: LD_INT 30
118356: PUSH
118357: LD_INT 0
118359: PUSH
118360: EMPTY
118361: LIST
118362: LIST
118363: PUSH
118364: LD_INT 30
118366: PUSH
118367: LD_INT 1
118369: PUSH
118370: EMPTY
118371: LIST
118372: LIST
118373: PUSH
118374: LD_INT 30
118376: PUSH
118377: LD_INT 6
118379: PUSH
118380: EMPTY
118381: LIST
118382: LIST
118383: PUSH
118384: EMPTY
118385: LIST
118386: LIST
118387: LIST
118388: LIST
118389: PPUSH
118390: CALL_OW 72
118394: PPUSH
118395: LD_VAR 0 7
118399: PPUSH
118400: CALL_OW 74
118404: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118405: LD_VAR 0 7
118409: PPUSH
118410: LD_VAR 0 8
118414: PPUSH
118415: CALL_OW 250
118419: PPUSH
118420: LD_INT 3
118422: PPUSH
118423: LD_INT 5
118425: PPUSH
118426: CALL_OW 272
118430: PPUSH
118431: LD_VAR 0 8
118435: PPUSH
118436: CALL_OW 251
118440: PPUSH
118441: LD_INT 3
118443: PPUSH
118444: LD_INT 5
118446: PPUSH
118447: CALL_OW 273
118451: PPUSH
118452: CALL_OW 111
// SetTag ( i , 0 ) ;
118456: LD_VAR 0 7
118460: PPUSH
118461: LD_INT 0
118463: PPUSH
118464: CALL_OW 109
// solds := solds diff i ;
118468: LD_ADDR_VAR 0 2
118472: PUSH
118473: LD_VAR 0 2
118477: PUSH
118478: LD_VAR 0 7
118482: DIFF
118483: ST_TO_ADDR
// continue ;
118484: GO 118166
// end ; end ;
118486: GO 118166
118488: POP
118489: POP
// until not solds or not enemy ;
118490: LD_VAR 0 2
118494: NOT
118495: PUSH
118496: LD_VAR 0 4
118500: NOT
118501: OR
118502: IFFALSE 118070
// MC_Reset ( base , 18 ) ;
118504: LD_VAR 0 1
118508: PPUSH
118509: LD_INT 18
118511: PPUSH
118512: CALL 25566 0 2
// end ;
118516: LD_VAR 0 3
118520: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118521: LD_INT 0
118523: PPUSH
118524: PPUSH
118525: PPUSH
118526: PPUSH
118527: PPUSH
118528: PPUSH
118529: PPUSH
118530: PPUSH
118531: PPUSH
118532: PPUSH
118533: PPUSH
118534: PPUSH
118535: PPUSH
118536: PPUSH
118537: PPUSH
118538: PPUSH
118539: PPUSH
118540: PPUSH
118541: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118542: LD_ADDR_VAR 0 12
118546: PUSH
118547: LD_EXP 94
118551: PUSH
118552: LD_VAR 0 1
118556: ARRAY
118557: PPUSH
118558: LD_INT 25
118560: PUSH
118561: LD_INT 3
118563: PUSH
118564: EMPTY
118565: LIST
118566: LIST
118567: PPUSH
118568: CALL_OW 72
118572: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118573: LD_EXP 134
118577: PUSH
118578: LD_VAR 0 1
118582: ARRAY
118583: IFFALSE 118607
// mechs := mechs diff mc_remote_driver [ base ] ;
118585: LD_ADDR_VAR 0 12
118589: PUSH
118590: LD_VAR 0 12
118594: PUSH
118595: LD_EXP 134
118599: PUSH
118600: LD_VAR 0 1
118604: ARRAY
118605: DIFF
118606: ST_TO_ADDR
// for i in mechs do
118607: LD_ADDR_VAR 0 4
118611: PUSH
118612: LD_VAR 0 12
118616: PUSH
118617: FOR_IN
118618: IFFALSE 118653
// if GetTag ( i ) > 0 then
118620: LD_VAR 0 4
118624: PPUSH
118625: CALL_OW 110
118629: PUSH
118630: LD_INT 0
118632: GREATER
118633: IFFALSE 118651
// mechs := mechs diff i ;
118635: LD_ADDR_VAR 0 12
118639: PUSH
118640: LD_VAR 0 12
118644: PUSH
118645: LD_VAR 0 4
118649: DIFF
118650: ST_TO_ADDR
118651: GO 118617
118653: POP
118654: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118655: LD_ADDR_VAR 0 8
118659: PUSH
118660: LD_EXP 94
118664: PUSH
118665: LD_VAR 0 1
118669: ARRAY
118670: PPUSH
118671: LD_INT 2
118673: PUSH
118674: LD_INT 25
118676: PUSH
118677: LD_INT 1
118679: PUSH
118680: EMPTY
118681: LIST
118682: LIST
118683: PUSH
118684: LD_INT 25
118686: PUSH
118687: LD_INT 5
118689: PUSH
118690: EMPTY
118691: LIST
118692: LIST
118693: PUSH
118694: LD_INT 25
118696: PUSH
118697: LD_INT 8
118699: PUSH
118700: EMPTY
118701: LIST
118702: LIST
118703: PUSH
118704: LD_INT 25
118706: PUSH
118707: LD_INT 9
118709: PUSH
118710: EMPTY
118711: LIST
118712: LIST
118713: PUSH
118714: EMPTY
118715: LIST
118716: LIST
118717: LIST
118718: LIST
118719: LIST
118720: PPUSH
118721: CALL_OW 72
118725: ST_TO_ADDR
// if not defenders and not solds then
118726: LD_VAR 0 2
118730: NOT
118731: PUSH
118732: LD_VAR 0 8
118736: NOT
118737: AND
118738: IFFALSE 118742
// exit ;
118740: GO 120512
// depot_under_attack := false ;
118742: LD_ADDR_VAR 0 16
118746: PUSH
118747: LD_INT 0
118749: ST_TO_ADDR
// sold_defenders := [ ] ;
118750: LD_ADDR_VAR 0 17
118754: PUSH
118755: EMPTY
118756: ST_TO_ADDR
// if mechs then
118757: LD_VAR 0 12
118761: IFFALSE 118914
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118763: LD_ADDR_VAR 0 4
118767: PUSH
118768: LD_VAR 0 2
118772: PPUSH
118773: LD_INT 21
118775: PUSH
118776: LD_INT 2
118778: PUSH
118779: EMPTY
118780: LIST
118781: LIST
118782: PPUSH
118783: CALL_OW 72
118787: PUSH
118788: FOR_IN
118789: IFFALSE 118912
// begin if GetTag ( i ) <> 20 then
118791: LD_VAR 0 4
118795: PPUSH
118796: CALL_OW 110
118800: PUSH
118801: LD_INT 20
118803: NONEQUAL
118804: IFFALSE 118818
// SetTag ( i , 20 ) ;
118806: LD_VAR 0 4
118810: PPUSH
118811: LD_INT 20
118813: PPUSH
118814: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118818: LD_VAR 0 4
118822: PPUSH
118823: CALL_OW 263
118827: PUSH
118828: LD_INT 1
118830: EQUAL
118831: PUSH
118832: LD_VAR 0 4
118836: PPUSH
118837: CALL_OW 311
118841: NOT
118842: AND
118843: IFFALSE 118910
// begin un := mechs [ 1 ] ;
118845: LD_ADDR_VAR 0 10
118849: PUSH
118850: LD_VAR 0 12
118854: PUSH
118855: LD_INT 1
118857: ARRAY
118858: ST_TO_ADDR
// ComExit ( un ) ;
118859: LD_VAR 0 10
118863: PPUSH
118864: CALL 89837 0 1
// AddComEnterUnit ( un , i ) ;
118868: LD_VAR 0 10
118872: PPUSH
118873: LD_VAR 0 4
118877: PPUSH
118878: CALL_OW 180
// SetTag ( un , 19 ) ;
118882: LD_VAR 0 10
118886: PPUSH
118887: LD_INT 19
118889: PPUSH
118890: CALL_OW 109
// mechs := mechs diff un ;
118894: LD_ADDR_VAR 0 12
118898: PUSH
118899: LD_VAR 0 12
118903: PUSH
118904: LD_VAR 0 10
118908: DIFF
118909: ST_TO_ADDR
// end ; end ;
118910: GO 118788
118912: POP
118913: POP
// if solds then
118914: LD_VAR 0 8
118918: IFFALSE 118977
// for i in solds do
118920: LD_ADDR_VAR 0 4
118924: PUSH
118925: LD_VAR 0 8
118929: PUSH
118930: FOR_IN
118931: IFFALSE 118975
// if not GetTag ( i ) then
118933: LD_VAR 0 4
118937: PPUSH
118938: CALL_OW 110
118942: NOT
118943: IFFALSE 118973
// begin defenders := defenders union i ;
118945: LD_ADDR_VAR 0 2
118949: PUSH
118950: LD_VAR 0 2
118954: PUSH
118955: LD_VAR 0 4
118959: UNION
118960: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118961: LD_VAR 0 4
118965: PPUSH
118966: LD_INT 18
118968: PPUSH
118969: CALL_OW 109
// end ;
118973: GO 118930
118975: POP
118976: POP
// repeat wait ( 0 0$2 ) ;
118977: LD_INT 70
118979: PPUSH
118980: CALL_OW 67
// enemy := mc_scan [ base ] ;
118984: LD_ADDR_VAR 0 21
118988: PUSH
118989: LD_EXP 117
118993: PUSH
118994: LD_VAR 0 1
118998: ARRAY
118999: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119000: LD_EXP 94
119004: PUSH
119005: LD_VAR 0 1
119009: ARRAY
119010: NOT
119011: PUSH
119012: LD_EXP 94
119016: PUSH
119017: LD_VAR 0 1
119021: ARRAY
119022: PUSH
119023: EMPTY
119024: EQUAL
119025: OR
119026: IFFALSE 119063
// begin for i in defenders do
119028: LD_ADDR_VAR 0 4
119032: PUSH
119033: LD_VAR 0 2
119037: PUSH
119038: FOR_IN
119039: IFFALSE 119052
// ComStop ( i ) ;
119041: LD_VAR 0 4
119045: PPUSH
119046: CALL_OW 141
119050: GO 119038
119052: POP
119053: POP
// defenders := [ ] ;
119054: LD_ADDR_VAR 0 2
119058: PUSH
119059: EMPTY
119060: ST_TO_ADDR
// exit ;
119061: GO 120512
// end ; for i in defenders do
119063: LD_ADDR_VAR 0 4
119067: PUSH
119068: LD_VAR 0 2
119072: PUSH
119073: FOR_IN
119074: IFFALSE 119972
// begin e := NearestUnitToUnit ( enemy , i ) ;
119076: LD_ADDR_VAR 0 13
119080: PUSH
119081: LD_VAR 0 21
119085: PPUSH
119086: LD_VAR 0 4
119090: PPUSH
119091: CALL_OW 74
119095: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119096: LD_ADDR_VAR 0 7
119100: PUSH
119101: LD_EXP 94
119105: PUSH
119106: LD_VAR 0 1
119110: ARRAY
119111: PPUSH
119112: LD_INT 2
119114: PUSH
119115: LD_INT 30
119117: PUSH
119118: LD_INT 0
119120: PUSH
119121: EMPTY
119122: LIST
119123: LIST
119124: PUSH
119125: LD_INT 30
119127: PUSH
119128: LD_INT 1
119130: PUSH
119131: EMPTY
119132: LIST
119133: LIST
119134: PUSH
119135: EMPTY
119136: LIST
119137: LIST
119138: LIST
119139: PPUSH
119140: CALL_OW 72
119144: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119145: LD_ADDR_VAR 0 16
119149: PUSH
119150: LD_VAR 0 7
119154: NOT
119155: PUSH
119156: LD_VAR 0 7
119160: PPUSH
119161: LD_INT 3
119163: PUSH
119164: LD_INT 24
119166: PUSH
119167: LD_INT 600
119169: PUSH
119170: EMPTY
119171: LIST
119172: LIST
119173: PUSH
119174: EMPTY
119175: LIST
119176: LIST
119177: PPUSH
119178: CALL_OW 72
119182: OR
119183: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119184: LD_VAR 0 4
119188: PPUSH
119189: CALL_OW 247
119193: PUSH
119194: LD_INT 2
119196: DOUBLE
119197: EQUAL
119198: IFTRUE 119202
119200: GO 119598
119202: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119203: LD_VAR 0 4
119207: PPUSH
119208: CALL_OW 256
119212: PUSH
119213: LD_INT 1000
119215: EQUAL
119216: PUSH
119217: LD_VAR 0 4
119221: PPUSH
119222: LD_VAR 0 13
119226: PPUSH
119227: CALL_OW 296
119231: PUSH
119232: LD_INT 40
119234: LESS
119235: PUSH
119236: LD_VAR 0 13
119240: PPUSH
119241: LD_EXP 119
119245: PUSH
119246: LD_VAR 0 1
119250: ARRAY
119251: PPUSH
119252: CALL_OW 308
119256: OR
119257: AND
119258: IFFALSE 119380
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119260: LD_VAR 0 4
119264: PPUSH
119265: CALL_OW 262
119269: PUSH
119270: LD_INT 1
119272: EQUAL
119273: PUSH
119274: LD_VAR 0 4
119278: PPUSH
119279: CALL_OW 261
119283: PUSH
119284: LD_INT 30
119286: LESS
119287: AND
119288: PUSH
119289: LD_VAR 0 7
119293: AND
119294: IFFALSE 119364
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119296: LD_VAR 0 4
119300: PPUSH
119301: LD_VAR 0 7
119305: PPUSH
119306: LD_VAR 0 4
119310: PPUSH
119311: CALL_OW 74
119315: PPUSH
119316: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119320: LD_VAR 0 4
119324: PPUSH
119325: LD_VAR 0 7
119329: PPUSH
119330: LD_VAR 0 4
119334: PPUSH
119335: CALL_OW 74
119339: PPUSH
119340: CALL_OW 296
119344: PUSH
119345: LD_INT 6
119347: LESS
119348: IFFALSE 119362
// SetFuel ( i , 100 ) ;
119350: LD_VAR 0 4
119354: PPUSH
119355: LD_INT 100
119357: PPUSH
119358: CALL_OW 240
// end else
119362: GO 119378
// ComAttackUnit ( i , e ) ;
119364: LD_VAR 0 4
119368: PPUSH
119369: LD_VAR 0 13
119373: PPUSH
119374: CALL_OW 115
// end else
119378: GO 119481
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119380: LD_VAR 0 13
119384: PPUSH
119385: LD_EXP 119
119389: PUSH
119390: LD_VAR 0 1
119394: ARRAY
119395: PPUSH
119396: CALL_OW 308
119400: NOT
119401: PUSH
119402: LD_VAR 0 4
119406: PPUSH
119407: LD_VAR 0 13
119411: PPUSH
119412: CALL_OW 296
119416: PUSH
119417: LD_INT 40
119419: GREATEREQUAL
119420: AND
119421: PUSH
119422: LD_VAR 0 4
119426: PPUSH
119427: CALL_OW 256
119431: PUSH
119432: LD_INT 650
119434: LESSEQUAL
119435: OR
119436: PUSH
119437: LD_VAR 0 4
119441: PPUSH
119442: LD_EXP 118
119446: PUSH
119447: LD_VAR 0 1
119451: ARRAY
119452: PPUSH
119453: CALL_OW 308
119457: NOT
119458: AND
119459: IFFALSE 119481
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119461: LD_VAR 0 4
119465: PPUSH
119466: LD_EXP 118
119470: PUSH
119471: LD_VAR 0 1
119475: ARRAY
119476: PPUSH
119477: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119481: LD_VAR 0 4
119485: PPUSH
119486: CALL_OW 256
119490: PUSH
119491: LD_INT 1000
119493: LESS
119494: PUSH
119495: LD_VAR 0 4
119499: PPUSH
119500: CALL_OW 263
119504: PUSH
119505: LD_INT 1
119507: EQUAL
119508: AND
119509: PUSH
119510: LD_VAR 0 4
119514: PPUSH
119515: CALL_OW 311
119519: AND
119520: PUSH
119521: LD_VAR 0 4
119525: PPUSH
119526: LD_EXP 118
119530: PUSH
119531: LD_VAR 0 1
119535: ARRAY
119536: PPUSH
119537: CALL_OW 308
119541: AND
119542: IFFALSE 119596
// begin mech := IsDrivenBy ( i ) ;
119544: LD_ADDR_VAR 0 9
119548: PUSH
119549: LD_VAR 0 4
119553: PPUSH
119554: CALL_OW 311
119558: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119559: LD_VAR 0 9
119563: PPUSH
119564: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119568: LD_VAR 0 9
119572: PPUSH
119573: LD_VAR 0 4
119577: PPUSH
119578: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119582: LD_VAR 0 9
119586: PPUSH
119587: LD_VAR 0 4
119591: PPUSH
119592: CALL_OW 180
// end ; end ; unit_human :
119596: GO 119943
119598: LD_INT 1
119600: DOUBLE
119601: EQUAL
119602: IFTRUE 119606
119604: GO 119942
119606: POP
// begin b := IsInUnit ( i ) ;
119607: LD_ADDR_VAR 0 18
119611: PUSH
119612: LD_VAR 0 4
119616: PPUSH
119617: CALL_OW 310
119621: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119622: LD_ADDR_VAR 0 19
119626: PUSH
119627: LD_VAR 0 18
119631: NOT
119632: PUSH
119633: LD_VAR 0 18
119637: PPUSH
119638: CALL_OW 266
119642: PUSH
119643: LD_INT 32
119645: PUSH
119646: LD_INT 31
119648: PUSH
119649: EMPTY
119650: LIST
119651: LIST
119652: IN
119653: OR
119654: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119655: LD_VAR 0 18
119659: PPUSH
119660: CALL_OW 266
119664: PUSH
119665: LD_INT 5
119667: EQUAL
119668: PUSH
119669: LD_VAR 0 4
119673: PPUSH
119674: CALL_OW 257
119678: PUSH
119679: LD_INT 1
119681: PUSH
119682: LD_INT 2
119684: PUSH
119685: LD_INT 3
119687: PUSH
119688: LD_INT 4
119690: PUSH
119691: EMPTY
119692: LIST
119693: LIST
119694: LIST
119695: LIST
119696: IN
119697: AND
119698: IFFALSE 119735
// begin class := AllowSpecClass ( i ) ;
119700: LD_ADDR_VAR 0 20
119704: PUSH
119705: LD_VAR 0 4
119709: PPUSH
119710: CALL 53824 0 1
119714: ST_TO_ADDR
// if class then
119715: LD_VAR 0 20
119719: IFFALSE 119735
// ComChangeProfession ( i , class ) ;
119721: LD_VAR 0 4
119725: PPUSH
119726: LD_VAR 0 20
119730: PPUSH
119731: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119735: LD_VAR 0 16
119739: PUSH
119740: LD_VAR 0 2
119744: PPUSH
119745: LD_INT 21
119747: PUSH
119748: LD_INT 2
119750: PUSH
119751: EMPTY
119752: LIST
119753: LIST
119754: PPUSH
119755: CALL_OW 72
119759: PUSH
119760: LD_INT 1
119762: LESSEQUAL
119763: OR
119764: PUSH
119765: LD_VAR 0 19
119769: AND
119770: PUSH
119771: LD_VAR 0 4
119775: PUSH
119776: LD_VAR 0 17
119780: IN
119781: NOT
119782: AND
119783: IFFALSE 119876
// begin if b then
119785: LD_VAR 0 18
119789: IFFALSE 119838
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119791: LD_VAR 0 18
119795: PPUSH
119796: LD_VAR 0 21
119800: PPUSH
119801: LD_VAR 0 18
119805: PPUSH
119806: CALL_OW 74
119810: PPUSH
119811: CALL_OW 296
119815: PUSH
119816: LD_INT 10
119818: LESS
119819: PUSH
119820: LD_VAR 0 18
119824: PPUSH
119825: CALL_OW 461
119829: PUSH
119830: LD_INT 7
119832: NONEQUAL
119833: AND
119834: IFFALSE 119838
// continue ;
119836: GO 119073
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119838: LD_ADDR_VAR 0 17
119842: PUSH
119843: LD_VAR 0 17
119847: PPUSH
119848: LD_VAR 0 17
119852: PUSH
119853: LD_INT 1
119855: PLUS
119856: PPUSH
119857: LD_VAR 0 4
119861: PPUSH
119862: CALL_OW 1
119866: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119867: LD_VAR 0 4
119871: PPUSH
119872: CALL_OW 122
// end ; if sold_defenders then
119876: LD_VAR 0 17
119880: IFFALSE 119940
// if i in sold_defenders then
119882: LD_VAR 0 4
119886: PUSH
119887: LD_VAR 0 17
119891: IN
119892: IFFALSE 119940
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119894: LD_VAR 0 4
119898: PPUSH
119899: CALL_OW 314
119903: NOT
119904: PUSH
119905: LD_VAR 0 4
119909: PPUSH
119910: LD_VAR 0 13
119914: PPUSH
119915: CALL_OW 296
119919: PUSH
119920: LD_INT 30
119922: LESS
119923: AND
119924: IFFALSE 119940
// ComAttackUnit ( i , e ) ;
119926: LD_VAR 0 4
119930: PPUSH
119931: LD_VAR 0 13
119935: PPUSH
119936: CALL_OW 115
// end ; end ; end ;
119940: GO 119943
119942: POP
// if IsDead ( i ) then
119943: LD_VAR 0 4
119947: PPUSH
119948: CALL_OW 301
119952: IFFALSE 119970
// defenders := defenders diff i ;
119954: LD_ADDR_VAR 0 2
119958: PUSH
119959: LD_VAR 0 2
119963: PUSH
119964: LD_VAR 0 4
119968: DIFF
119969: ST_TO_ADDR
// end ;
119970: GO 119073
119972: POP
119973: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119974: LD_VAR 0 21
119978: NOT
119979: PUSH
119980: LD_VAR 0 2
119984: NOT
119985: OR
119986: PUSH
119987: LD_EXP 94
119991: PUSH
119992: LD_VAR 0 1
119996: ARRAY
119997: NOT
119998: OR
119999: IFFALSE 118977
// MC_Reset ( base , 18 ) ;
120001: LD_VAR 0 1
120005: PPUSH
120006: LD_INT 18
120008: PPUSH
120009: CALL 25566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120013: LD_ADDR_VAR 0 2
120017: PUSH
120018: LD_VAR 0 2
120022: PUSH
120023: LD_VAR 0 2
120027: PPUSH
120028: LD_INT 2
120030: PUSH
120031: LD_INT 25
120033: PUSH
120034: LD_INT 1
120036: PUSH
120037: EMPTY
120038: LIST
120039: LIST
120040: PUSH
120041: LD_INT 25
120043: PUSH
120044: LD_INT 5
120046: PUSH
120047: EMPTY
120048: LIST
120049: LIST
120050: PUSH
120051: LD_INT 25
120053: PUSH
120054: LD_INT 8
120056: PUSH
120057: EMPTY
120058: LIST
120059: LIST
120060: PUSH
120061: LD_INT 25
120063: PUSH
120064: LD_INT 9
120066: PUSH
120067: EMPTY
120068: LIST
120069: LIST
120070: PUSH
120071: EMPTY
120072: LIST
120073: LIST
120074: LIST
120075: LIST
120076: LIST
120077: PPUSH
120078: CALL_OW 72
120082: DIFF
120083: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120084: LD_VAR 0 21
120088: NOT
120089: PUSH
120090: LD_VAR 0 2
120094: PPUSH
120095: LD_INT 21
120097: PUSH
120098: LD_INT 2
120100: PUSH
120101: EMPTY
120102: LIST
120103: LIST
120104: PPUSH
120105: CALL_OW 72
120109: AND
120110: IFFALSE 120448
// begin tmp := FilterByTag ( defenders , 19 ) ;
120112: LD_ADDR_VAR 0 11
120116: PUSH
120117: LD_VAR 0 2
120121: PPUSH
120122: LD_INT 19
120124: PPUSH
120125: CALL 87013 0 2
120129: ST_TO_ADDR
// if tmp then
120130: LD_VAR 0 11
120134: IFFALSE 120204
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120136: LD_ADDR_VAR 0 11
120140: PUSH
120141: LD_VAR 0 11
120145: PPUSH
120146: LD_INT 25
120148: PUSH
120149: LD_INT 3
120151: PUSH
120152: EMPTY
120153: LIST
120154: LIST
120155: PPUSH
120156: CALL_OW 72
120160: ST_TO_ADDR
// if tmp then
120161: LD_VAR 0 11
120165: IFFALSE 120204
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120167: LD_ADDR_EXP 106
120171: PUSH
120172: LD_EXP 106
120176: PPUSH
120177: LD_VAR 0 1
120181: PPUSH
120182: LD_EXP 106
120186: PUSH
120187: LD_VAR 0 1
120191: ARRAY
120192: PUSH
120193: LD_VAR 0 11
120197: UNION
120198: PPUSH
120199: CALL_OW 1
120203: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120204: LD_VAR 0 1
120208: PPUSH
120209: LD_INT 19
120211: PPUSH
120212: CALL 25566 0 2
// repeat wait ( 0 0$1 ) ;
120216: LD_INT 35
120218: PPUSH
120219: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120223: LD_EXP 94
120227: PUSH
120228: LD_VAR 0 1
120232: ARRAY
120233: NOT
120234: PUSH
120235: LD_EXP 94
120239: PUSH
120240: LD_VAR 0 1
120244: ARRAY
120245: PUSH
120246: EMPTY
120247: EQUAL
120248: OR
120249: IFFALSE 120286
// begin for i in defenders do
120251: LD_ADDR_VAR 0 4
120255: PUSH
120256: LD_VAR 0 2
120260: PUSH
120261: FOR_IN
120262: IFFALSE 120275
// ComStop ( i ) ;
120264: LD_VAR 0 4
120268: PPUSH
120269: CALL_OW 141
120273: GO 120261
120275: POP
120276: POP
// defenders := [ ] ;
120277: LD_ADDR_VAR 0 2
120281: PUSH
120282: EMPTY
120283: ST_TO_ADDR
// exit ;
120284: GO 120512
// end ; for i in defenders do
120286: LD_ADDR_VAR 0 4
120290: PUSH
120291: LD_VAR 0 2
120295: PUSH
120296: FOR_IN
120297: IFFALSE 120386
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120299: LD_VAR 0 4
120303: PPUSH
120304: LD_EXP 118
120308: PUSH
120309: LD_VAR 0 1
120313: ARRAY
120314: PPUSH
120315: CALL_OW 308
120319: NOT
120320: IFFALSE 120344
// ComMoveToArea ( i , mc_parking [ base ] ) else
120322: LD_VAR 0 4
120326: PPUSH
120327: LD_EXP 118
120331: PUSH
120332: LD_VAR 0 1
120336: ARRAY
120337: PPUSH
120338: CALL_OW 113
120342: GO 120384
// if GetControl ( i ) = control_manual then
120344: LD_VAR 0 4
120348: PPUSH
120349: CALL_OW 263
120353: PUSH
120354: LD_INT 1
120356: EQUAL
120357: IFFALSE 120384
// if IsDrivenBy ( i ) then
120359: LD_VAR 0 4
120363: PPUSH
120364: CALL_OW 311
120368: IFFALSE 120384
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120370: LD_VAR 0 4
120374: PPUSH
120375: CALL_OW 311
120379: PPUSH
120380: CALL_OW 121
// end ;
120384: GO 120296
120386: POP
120387: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120388: LD_VAR 0 2
120392: PPUSH
120393: LD_INT 95
120395: PUSH
120396: LD_EXP 118
120400: PUSH
120401: LD_VAR 0 1
120405: ARRAY
120406: PUSH
120407: EMPTY
120408: LIST
120409: LIST
120410: PPUSH
120411: CALL_OW 72
120415: PUSH
120416: LD_VAR 0 2
120420: EQUAL
120421: PUSH
120422: LD_EXP 117
120426: PUSH
120427: LD_VAR 0 1
120431: ARRAY
120432: OR
120433: PUSH
120434: LD_EXP 94
120438: PUSH
120439: LD_VAR 0 1
120443: ARRAY
120444: NOT
120445: OR
120446: IFFALSE 120216
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120448: LD_ADDR_EXP 116
120452: PUSH
120453: LD_EXP 116
120457: PPUSH
120458: LD_VAR 0 1
120462: PPUSH
120463: LD_VAR 0 2
120467: PPUSH
120468: LD_INT 21
120470: PUSH
120471: LD_INT 2
120473: PUSH
120474: EMPTY
120475: LIST
120476: LIST
120477: PPUSH
120478: CALL_OW 72
120482: PPUSH
120483: CALL_OW 1
120487: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120488: LD_VAR 0 1
120492: PPUSH
120493: LD_INT 19
120495: PPUSH
120496: CALL 25566 0 2
// MC_Reset ( base , 20 ) ;
120500: LD_VAR 0 1
120504: PPUSH
120505: LD_INT 20
120507: PPUSH
120508: CALL 25566 0 2
// end ; end_of_file
120512: LD_VAR 0 3
120516: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120517: LD_VAR 0 1
120521: PUSH
120522: LD_INT 200
120524: DOUBLE
120525: GREATEREQUAL
120526: IFFALSE 120534
120528: LD_INT 299
120530: DOUBLE
120531: LESSEQUAL
120532: IFTRUE 120536
120534: GO 120568
120536: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120537: LD_VAR 0 1
120541: PPUSH
120542: LD_VAR 0 2
120546: PPUSH
120547: LD_VAR 0 3
120551: PPUSH
120552: LD_VAR 0 4
120556: PPUSH
120557: LD_VAR 0 5
120561: PPUSH
120562: CALL 109283 0 5
120566: GO 120645
120568: LD_INT 300
120570: DOUBLE
120571: GREATEREQUAL
120572: IFFALSE 120580
120574: LD_INT 399
120576: DOUBLE
120577: LESSEQUAL
120578: IFTRUE 120582
120580: GO 120644
120582: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120583: LD_VAR 0 1
120587: PPUSH
120588: LD_VAR 0 2
120592: PPUSH
120593: LD_VAR 0 3
120597: PPUSH
120598: LD_VAR 0 4
120602: PPUSH
120603: LD_VAR 0 5
120607: PPUSH
120608: LD_VAR 0 6
120612: PPUSH
120613: LD_VAR 0 7
120617: PPUSH
120618: LD_VAR 0 8
120622: PPUSH
120623: LD_VAR 0 9
120627: PPUSH
120628: LD_VAR 0 10
120632: PPUSH
120633: LD_VAR 0 11
120637: PPUSH
120638: CALL 105612 0 11
120642: GO 120645
120644: POP
// end ;
120645: PPOPN 11
120647: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120648: LD_VAR 0 1
120652: PPUSH
120653: LD_VAR 0 2
120657: PPUSH
120658: LD_VAR 0 3
120662: PPUSH
120663: LD_VAR 0 4
120667: PPUSH
120668: LD_VAR 0 5
120672: PPUSH
120673: CALL 109019 0 5
// end ; end_of_file
120677: PPOPN 5
120679: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120680: LD_VAR 0 1
120684: PPUSH
120685: LD_VAR 0 2
120689: PPUSH
120690: LD_VAR 0 3
120694: PPUSH
120695: LD_VAR 0 4
120699: PPUSH
120700: LD_VAR 0 5
120704: PPUSH
120705: LD_VAR 0 6
120709: PPUSH
120710: CALL 93305 0 6
// end ;
120714: PPOPN 6
120716: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120717: LD_INT 0
120719: PPUSH
// begin if not units then
120720: LD_VAR 0 1
120724: NOT
120725: IFFALSE 120729
// exit ;
120727: GO 120729
// end ;
120729: PPOPN 7
120731: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120732: CALL 93276 0 0
// end ;
120736: PPOPN 1
120738: END
