// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22118 0 0
// InitNature ;
  19: CALL 18784 0 0
// InitArtifact ;
  23: CALL 19401 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6905 0 0
// PrepareRussian ;
  52: CALL 9025 0 0
// PrepareLegion ;
  56: CALL 7402 0 0
// Action ;
  60: CALL 11849 0 0
// MC_Start ( ) ;
  64: CALL 24298 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46001 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47080 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47173 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46338 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46523 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47080 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47173 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46338 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46523 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46953 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46001 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47080 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47173 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46338 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46523 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47080 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47173 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47491 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47285 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46338 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46523 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46904 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52812 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52812 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52812 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52812 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52812 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52812 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52812 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52812 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52812 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52812 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52812 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52812 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52812 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52812 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52812 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52812 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52812 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52812 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52812 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52812 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52812 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52812 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52812 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52812 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52812 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52812 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52812 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52812 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52812 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52812 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52812 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52812 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52812 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52812 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52812 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57652 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57652 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57652 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57652 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57652 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57652 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57652 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57652 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57652 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57652 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57652 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57652 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57652 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57652 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57652 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57652 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57652 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57652 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
// InitHc ;
5114: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5118: LD_INT 387
5120: PPUSH
5121: LD_STRING sigma
5123: PPUSH
5124: CALL_OW 500
// uc_side := 1 ;
5128: LD_ADDR_OWVAR 20
5132: PUSH
5133: LD_INT 1
5135: ST_TO_ADDR
// uc_nation := 1 ;
5136: LD_ADDR_OWVAR 21
5140: PUSH
5141: LD_INT 1
5143: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5144: LD_ADDR_VAR 0 2
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 21
5161: PUSH
5162: LD_INT 3
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PPUSH
5173: CALL_OW 69
5177: PUSH
5178: FOR_IN
5179: IFFALSE 5195
// SetBLevel ( i , 10 ) ;
5181: LD_VAR 0 2
5185: PPUSH
5186: LD_INT 10
5188: PPUSH
5189: CALL_OW 241
5193: GO 5178
5195: POP
5196: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5197: LD_INT 387
5199: PPUSH
5200: CALL_OW 274
5204: PPUSH
5205: LD_INT 1
5207: PPUSH
5208: LD_INT 7500
5210: PPUSH
5211: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5215: LD_INT 387
5217: PPUSH
5218: CALL_OW 274
5222: PPUSH
5223: LD_INT 2
5225: PPUSH
5226: LD_INT 4000
5228: PPUSH
5229: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5233: LD_INT 387
5235: PPUSH
5236: CALL_OW 274
5240: PPUSH
5241: LD_INT 3
5243: PPUSH
5244: LD_INT 50
5246: PPUSH
5247: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5251: LD_INT 476
5253: PPUSH
5254: CALL_OW 274
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: LD_INT 5500
5264: PPUSH
5265: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5269: LD_INT 476
5271: PPUSH
5272: CALL_OW 274
5276: PPUSH
5277: LD_INT 2
5279: PPUSH
5280: LD_INT 4000
5282: PPUSH
5283: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5287: LD_INT 476
5289: PPUSH
5290: CALL_OW 274
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 10
5300: PPUSH
5301: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5305: LD_ADDR_EXP 55
5309: PUSH
5310: LD_STRING Powell
5312: PPUSH
5313: CALL_OW 25
5317: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5318: LD_EXP 55
5322: PPUSH
5323: LD_INT 387
5325: PPUSH
5326: CALL_OW 52
// tmp := [ ] ;
5330: LD_ADDR_VAR 0 6
5334: PUSH
5335: EMPTY
5336: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5337: LD_ADDR_EXP 21
5341: PUSH
5342: LD_STRING Lisa
5344: PPUSH
5345: LD_EXP 1
5349: NOT
5350: PPUSH
5351: LD_STRING 12p_
5353: PPUSH
5354: CALL 52812 0 3
5358: ST_TO_ADDR
// if Lisa then
5359: LD_EXP 21
5363: IFFALSE 5381
// tmp := tmp ^ Lisa ;
5365: LD_ADDR_VAR 0 6
5369: PUSH
5370: LD_VAR 0 6
5374: PUSH
5375: LD_EXP 21
5379: ADD
5380: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5381: LD_ADDR_EXP 22
5385: PUSH
5386: LD_STRING Donaldson
5388: PPUSH
5389: LD_EXP 1
5393: NOT
5394: PPUSH
5395: LD_STRING 12p_
5397: PPUSH
5398: CALL 52812 0 3
5402: ST_TO_ADDR
// if Donaldson then
5403: LD_EXP 22
5407: IFFALSE 5425
// tmp := tmp ^ Donaldson ;
5409: LD_ADDR_VAR 0 6
5413: PUSH
5414: LD_VAR 0 6
5418: PUSH
5419: LD_EXP 22
5423: ADD
5424: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5425: LD_ADDR_EXP 23
5429: PUSH
5430: LD_STRING Bobby
5432: PPUSH
5433: LD_EXP 1
5437: NOT
5438: PPUSH
5439: LD_STRING 12p_
5441: PPUSH
5442: CALL 52812 0 3
5446: ST_TO_ADDR
// if Bobby then
5447: LD_EXP 23
5451: IFFALSE 5469
// tmp := tmp ^ Bobby ;
5453: LD_ADDR_VAR 0 6
5457: PUSH
5458: LD_VAR 0 6
5462: PUSH
5463: LD_EXP 23
5467: ADD
5468: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5469: LD_ADDR_EXP 24
5473: PUSH
5474: LD_STRING Cyrus
5476: PPUSH
5477: LD_EXP 1
5481: NOT
5482: PPUSH
5483: LD_STRING 12p_
5485: PPUSH
5486: CALL 52812 0 3
5490: ST_TO_ADDR
// if Cyrus then
5491: LD_EXP 24
5495: IFFALSE 5513
// tmp := tmp ^ Cyrus ;
5497: LD_ADDR_VAR 0 6
5501: PUSH
5502: LD_VAR 0 6
5506: PUSH
5507: LD_EXP 24
5511: ADD
5512: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5513: LD_ADDR_EXP 26
5517: PUSH
5518: LD_STRING Brown
5520: PPUSH
5521: LD_EXP 1
5525: NOT
5526: PPUSH
5527: LD_STRING 12p_
5529: PPUSH
5530: CALL 52812 0 3
5534: ST_TO_ADDR
// if Brown then
5535: LD_EXP 26
5539: IFFALSE 5557
// tmp := tmp ^ Brown ;
5541: LD_ADDR_VAR 0 6
5545: PUSH
5546: LD_VAR 0 6
5550: PUSH
5551: LD_EXP 26
5555: ADD
5556: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5557: LD_ADDR_EXP 27
5561: PUSH
5562: LD_STRING Gladstone
5564: PPUSH
5565: LD_EXP 1
5569: NOT
5570: PPUSH
5571: LD_STRING 12p_
5573: PPUSH
5574: CALL 52812 0 3
5578: ST_TO_ADDR
// if Gladstone then
5579: LD_EXP 27
5583: IFFALSE 5601
// tmp := tmp ^ Gladstone ;
5585: LD_ADDR_VAR 0 6
5589: PUSH
5590: LD_VAR 0 6
5594: PUSH
5595: LD_EXP 27
5599: ADD
5600: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5601: LD_ADDR_EXP 28
5605: PUSH
5606: LD_STRING Houten
5608: PPUSH
5609: LD_EXP 1
5613: NOT
5614: PPUSH
5615: LD_STRING 12p_
5617: PPUSH
5618: CALL 52812 0 3
5622: ST_TO_ADDR
// if Houten then
5623: LD_EXP 28
5627: IFFALSE 5645
// tmp := tmp ^ Houten ;
5629: LD_ADDR_VAR 0 6
5633: PUSH
5634: LD_VAR 0 6
5638: PUSH
5639: LD_EXP 28
5643: ADD
5644: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5645: LD_ADDR_EXP 29
5649: PUSH
5650: LD_STRING Cornel
5652: PPUSH
5653: LD_EXP 1
5657: NOT
5658: PPUSH
5659: LD_STRING 12p_
5661: PPUSH
5662: CALL 52812 0 3
5666: ST_TO_ADDR
// if Cornel then
5667: LD_EXP 29
5671: IFFALSE 5689
// tmp := tmp ^ Cornel ;
5673: LD_ADDR_VAR 0 6
5677: PUSH
5678: LD_VAR 0 6
5682: PUSH
5683: LD_EXP 29
5687: ADD
5688: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5689: LD_ADDR_EXP 30
5693: PUSH
5694: LD_STRING Gary
5696: PPUSH
5697: LD_EXP 1
5701: NOT
5702: PPUSH
5703: LD_STRING 12p_
5705: PPUSH
5706: CALL 52812 0 3
5710: ST_TO_ADDR
// if Gary then
5711: LD_EXP 30
5715: IFFALSE 5733
// tmp := tmp ^ Gary ;
5717: LD_ADDR_VAR 0 6
5721: PUSH
5722: LD_VAR 0 6
5726: PUSH
5727: LD_EXP 30
5731: ADD
5732: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5733: LD_ADDR_EXP 32
5737: PUSH
5738: LD_STRING Kikuchi
5740: PPUSH
5741: LD_EXP 1
5745: NOT
5746: PPUSH
5747: LD_STRING 12p_
5749: PPUSH
5750: CALL 52812 0 3
5754: ST_TO_ADDR
// if Kikuchi then
5755: LD_EXP 32
5759: IFFALSE 5777
// tmp := tmp ^ Kikuchi ;
5761: LD_ADDR_VAR 0 6
5765: PUSH
5766: LD_VAR 0 6
5770: PUSH
5771: LD_EXP 32
5775: ADD
5776: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5777: LD_ADDR_VAR 0 6
5781: PUSH
5782: LD_VAR 0 6
5786: PUSH
5787: LD_STRING 12p_others
5789: PPUSH
5790: CALL_OW 31
5794: UNION
5795: ST_TO_ADDR
// if tmp < 36 then
5796: LD_VAR 0 6
5800: PUSH
5801: LD_INT 36
5803: LESS
5804: IFFALSE 5871
// for i = 1 to 36 - tmp do
5806: LD_ADDR_VAR 0 2
5810: PUSH
5811: DOUBLE
5812: LD_INT 1
5814: DEC
5815: ST_TO_ADDR
5816: LD_INT 36
5818: PUSH
5819: LD_VAR 0 6
5823: MINUS
5824: PUSH
5825: FOR_TO
5826: IFFALSE 5869
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5828: LD_INT 1
5830: PPUSH
5831: LD_VAR 0 2
5835: PUSH
5836: LD_INT 4
5838: MOD
5839: PUSH
5840: LD_INT 1
5842: PLUS
5843: PPUSH
5844: LD_INT 10
5846: PPUSH
5847: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5851: LD_ADDR_VAR 0 6
5855: PUSH
5856: LD_VAR 0 6
5860: PUSH
5861: CALL_OW 44
5865: ADD
5866: ST_TO_ADDR
// end ;
5867: GO 5825
5869: POP
5870: POP
// for i in tmp do
5871: LD_ADDR_VAR 0 2
5875: PUSH
5876: LD_VAR 0 6
5880: PUSH
5881: FOR_IN
5882: IFFALSE 5907
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5884: LD_VAR 0 2
5888: PPUSH
5889: LD_INT 62
5891: PPUSH
5892: LD_INT 93
5894: PPUSH
5895: LD_INT 9
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 50
5905: GO 5881
5907: POP
5908: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5909: LD_ADDR_EXP 78
5913: PUSH
5914: LD_EXP 78
5918: PPUSH
5919: LD_INT 4
5921: PPUSH
5922: LD_INT 22
5924: PUSH
5925: LD_INT 1
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 69
5936: PUSH
5937: LD_EXP 55
5941: DIFF
5942: PPUSH
5943: CALL_OW 1
5947: ST_TO_ADDR
// uc_side := 0 ;
5948: LD_ADDR_OWVAR 20
5952: PUSH
5953: LD_INT 0
5955: ST_TO_ADDR
// uc_nation := 0 ;
5956: LD_ADDR_OWVAR 21
5960: PUSH
5961: LD_INT 0
5963: ST_TO_ADDR
// for i = 1 to 4 do
5964: LD_ADDR_VAR 0 2
5968: PUSH
5969: DOUBLE
5970: LD_INT 1
5972: DEC
5973: ST_TO_ADDR
5974: LD_INT 4
5976: PUSH
5977: FOR_TO
5978: IFFALSE 6009
// begin InitHc ;
5980: CALL_OW 19
// hc_class := class_apeman ;
5984: LD_ADDR_OWVAR 28
5988: PUSH
5989: LD_INT 12
5991: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5992: CALL_OW 44
5996: PPUSH
5997: LD_INT 11
5999: PPUSH
6000: LD_INT 0
6002: PPUSH
6003: CALL_OW 49
// end ;
6007: GO 5977
6009: POP
6010: POP
// end ;
6011: LD_VAR 0 1
6015: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6016: LD_EXP 4
6020: NOT
6021: IFFALSE 6827
6023: GO 6025
6025: DISABLE
6026: LD_INT 0
6028: PPUSH
6029: PPUSH
6030: PPUSH
6031: PPUSH
// begin enable ;
6032: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6033: LD_INT 22
6035: PUSH
6036: LD_INT 1
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 23
6045: PUSH
6046: LD_INT 1
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: LD_INT 30
6055: PUSH
6056: LD_INT 3
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 69
6072: NOT
6073: IFFALSE 6077
// exit ;
6075: GO 6827
// if Prob ( 40 ) then
6077: LD_INT 40
6079: PPUSH
6080: CALL_OW 13
6084: IFFALSE 6211
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6086: LD_INT 4
6088: PPUSH
6089: LD_INT 5
6091: PUSH
6092: LD_INT 1
6094: PUSH
6095: LD_INT 2
6097: PUSH
6098: LD_INT 7
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 5
6109: PUSH
6110: LD_INT 1
6112: PUSH
6113: LD_INT 2
6115: PUSH
6116: LD_INT 7
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 5
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 7
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: LD_INT 6
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: PUSH
6161: LD_INT 5
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 6
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 6
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: LIST
6204: PPUSH
6205: CALL 46386 0 2
// end else
6209: GO 6334
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6211: LD_INT 4
6213: PPUSH
6214: LD_INT 5
6216: PUSH
6217: LD_INT 1
6219: PUSH
6220: LD_INT 2
6222: PUSH
6223: LD_INT 7
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: LIST
6230: LIST
6231: PUSH
6232: LD_INT 5
6234: PUSH
6235: LD_INT 1
6237: PUSH
6238: LD_INT 2
6240: PUSH
6241: LD_INT 9
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: LIST
6249: PUSH
6250: LD_INT 5
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: LD_INT 2
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PUSH
6268: LD_INT 5
6270: PUSH
6271: LD_INT 1
6273: PUSH
6274: LD_INT 2
6276: PUSH
6277: LD_INT 6
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 6
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 5
6306: PUSH
6307: LD_INT 1
6309: PUSH
6310: LD_INT 2
6312: PUSH
6313: LD_INT 6
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: PPUSH
6330: CALL 46386 0 2
// end ; p := 0 ;
6334: LD_ADDR_VAR 0 4
6338: PUSH
6339: LD_INT 0
6341: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6342: LD_INT 35
6344: PPUSH
6345: CALL_OW 67
// p := Inc ( p ) ;
6349: LD_ADDR_VAR 0 4
6353: PUSH
6354: LD_VAR 0 4
6358: PPUSH
6359: CALL 91465 0 1
6363: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 1
6369: PPUSH
6370: CALL 47804 0 2
6374: PUSH
6375: LD_INT 6
6377: GREATEREQUAL
6378: PUSH
6379: LD_VAR 0 4
6383: PUSH
6384: LD_INT 100
6386: GREATER
6387: OR
6388: IFFALSE 6342
// wait ( 0 0$30 ) ;
6390: LD_INT 1050
6392: PPUSH
6393: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6397: LD_ADDR_VAR 0 2
6401: PUSH
6402: LD_INT 4
6404: PPUSH
6405: LD_INT 1
6407: PPUSH
6408: CALL 47804 0 2
6412: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6413: LD_ADDR_EXP 97
6417: PUSH
6418: LD_EXP 97
6422: PPUSH
6423: LD_INT 4
6425: PPUSH
6426: LD_EXP 97
6430: PUSH
6431: LD_INT 4
6433: ARRAY
6434: PUSH
6435: LD_VAR 0 2
6439: DIFF
6440: PPUSH
6441: CALL_OW 1
6445: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6446: LD_ADDR_VAR 0 3
6450: PUSH
6451: LD_INT 0
6453: PPUSH
6454: LD_INT 2
6456: PPUSH
6457: CALL_OW 12
6461: ST_TO_ADDR
// if target then
6462: LD_VAR 0 3
6466: IFFALSE 6594
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: LD_VAR 0 2
6477: PPUSH
6478: LD_INT 24
6480: PUSH
6481: LD_INT 250
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: PPUSH
6488: CALL_OW 72
6492: ST_TO_ADDR
// for i in tmp do
6493: LD_ADDR_VAR 0 1
6497: PUSH
6498: LD_VAR 0 2
6502: PUSH
6503: FOR_IN
6504: IFFALSE 6544
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6506: LD_VAR 0 1
6510: PPUSH
6511: LD_INT 114
6513: PPUSH
6514: LD_INT 108
6516: PPUSH
6517: CALL_OW 297
6521: PUSH
6522: LD_INT 9
6524: GREATER
6525: IFFALSE 6542
// ComMoveXY ( i , 114 , 108 ) ;
6527: LD_VAR 0 1
6531: PPUSH
6532: LD_INT 114
6534: PPUSH
6535: LD_INT 108
6537: PPUSH
6538: CALL_OW 111
6542: GO 6503
6544: POP
6545: POP
// wait ( 0 0$1 ) ;
6546: LD_INT 35
6548: PPUSH
6549: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6553: LD_VAR 0 2
6557: PPUSH
6558: LD_INT 92
6560: PUSH
6561: LD_INT 114
6563: PUSH
6564: LD_INT 108
6566: PUSH
6567: LD_INT 9
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PPUSH
6576: CALL_OW 72
6580: PUSH
6581: LD_VAR 0 2
6585: PUSH
6586: LD_INT 1
6588: MINUS
6589: GREATEREQUAL
6590: IFFALSE 6468
// end else
6592: GO 6718
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6594: LD_ADDR_VAR 0 2
6598: PUSH
6599: LD_VAR 0 2
6603: PPUSH
6604: LD_INT 24
6606: PUSH
6607: LD_INT 250
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PPUSH
6614: CALL_OW 72
6618: ST_TO_ADDR
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 2
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6670
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6632: LD_VAR 0 1
6636: PPUSH
6637: LD_INT 129
6639: PPUSH
6640: LD_INT 139
6642: PPUSH
6643: CALL_OW 297
6647: PUSH
6648: LD_INT 9
6650: GREATER
6651: IFFALSE 6668
// ComMoveXY ( i , 129 , 139 ) ;
6653: LD_VAR 0 1
6657: PPUSH
6658: LD_INT 129
6660: PPUSH
6661: LD_INT 139
6663: PPUSH
6664: CALL_OW 111
6668: GO 6629
6670: POP
6671: POP
// wait ( 0 0$1 ) ;
6672: LD_INT 35
6674: PPUSH
6675: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6679: LD_VAR 0 2
6683: PPUSH
6684: LD_INT 92
6686: PUSH
6687: LD_INT 129
6689: PUSH
6690: LD_INT 139
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 72
6706: PUSH
6707: LD_VAR 0 2
6711: PUSH
6712: LD_INT 1
6714: MINUS
6715: GREATEREQUAL
6716: IFFALSE 6594
// end ; repeat wait ( 0 0$1 ) ;
6718: LD_INT 35
6720: PPUSH
6721: CALL_OW 67
// for i in tmp do
6725: LD_ADDR_VAR 0 1
6729: PUSH
6730: LD_VAR 0 2
6734: PUSH
6735: FOR_IN
6736: IFFALSE 6818
// begin if GetLives ( i ) > 251 then
6738: LD_VAR 0 1
6742: PPUSH
6743: CALL_OW 256
6747: PUSH
6748: LD_INT 251
6750: GREATER
6751: IFFALSE 6789
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6753: LD_VAR 0 1
6757: PPUSH
6758: LD_INT 81
6760: PUSH
6761: LD_INT 1
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PPUSH
6768: CALL_OW 69
6772: PPUSH
6773: LD_VAR 0 1
6777: PPUSH
6778: CALL_OW 74
6782: PPUSH
6783: CALL_OW 115
6787: GO 6816
// if IsDead ( i ) then
6789: LD_VAR 0 1
6793: PPUSH
6794: CALL_OW 301
6798: IFFALSE 6816
// tmp := tmp diff i ;
6800: LD_ADDR_VAR 0 2
6804: PUSH
6805: LD_VAR 0 2
6809: PUSH
6810: LD_VAR 0 1
6814: DIFF
6815: ST_TO_ADDR
// end ;
6816: GO 6735
6818: POP
6819: POP
// until not tmp ;
6820: LD_VAR 0 2
6824: NOT
6825: IFFALSE 6718
// end ;
6827: PPOPN 4
6829: END
// every 30 30$00 trigger not americanDestroyed do
6830: LD_EXP 4
6834: NOT
6835: IFFALSE 6904
6837: GO 6839
6839: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6840: LD_INT 63000
6842: PUSH
6843: LD_INT 42000
6845: PUSH
6846: LD_INT 31500
6848: PUSH
6849: LD_INT 21000
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: LIST
6856: LIST
6857: PUSH
6858: LD_OWVAR 67
6862: ARRAY
6863: PPUSH
6864: CALL_OW 67
// if americanDestroyed then
6868: LD_EXP 4
6872: IFFALSE 6876
// exit ;
6874: GO 6904
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6876: LD_INT 4
6878: PPUSH
6879: LD_INT 5
6881: PUSH
6882: LD_INT 3
6884: PUSH
6885: LD_INT 1
6887: PUSH
6888: LD_INT 8
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: LIST
6896: PUSH
6897: EMPTY
6898: LIST
6899: PPUSH
6900: CALL 46386 0 2
// end ; end_of_file
6904: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6905: LD_INT 0
6907: PPUSH
6908: PPUSH
6909: PPUSH
6910: PPUSH
6911: PPUSH
// side := 2 ;
6912: LD_ADDR_VAR 0 5
6916: PUSH
6917: LD_INT 2
6919: ST_TO_ADDR
// InitHc ;
6920: CALL_OW 19
// uc_side := side ;
6924: LD_ADDR_OWVAR 20
6928: PUSH
6929: LD_VAR 0 5
6933: ST_TO_ADDR
// uc_nation := 2 ;
6934: LD_ADDR_OWVAR 21
6938: PUSH
6939: LD_INT 2
6941: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6942: LD_ADDR_VAR 0 2
6946: PUSH
6947: LD_INT 22
6949: PUSH
6950: LD_INT 2
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 21
6959: PUSH
6960: LD_INT 3
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PPUSH
6971: CALL_OW 69
6975: PUSH
6976: FOR_IN
6977: IFFALSE 6993
// SetBLevel ( i , 10 ) ;
6979: LD_VAR 0 2
6983: PPUSH
6984: LD_INT 10
6986: PPUSH
6987: CALL_OW 241
6991: GO 6976
6993: POP
6994: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6995: LD_ADDR_VAR 0 4
6999: PUSH
7000: LD_INT 22
7002: PUSH
7003: LD_VAR 0 5
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 30
7014: PUSH
7015: LD_INT 32
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PUSH
7022: LD_INT 58
7024: PUSH
7025: EMPTY
7026: LIST
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: PPUSH
7033: CALL_OW 69
7037: ST_TO_ADDR
// for i = 1 to 10 do
7038: LD_ADDR_VAR 0 2
7042: PUSH
7043: DOUBLE
7044: LD_INT 1
7046: DEC
7047: ST_TO_ADDR
7048: LD_INT 10
7050: PUSH
7051: FOR_TO
7052: IFFALSE 7124
// begin uc_nation := nation_nature ;
7054: LD_ADDR_OWVAR 21
7058: PUSH
7059: LD_INT 0
7061: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7062: LD_ADDR_OWVAR 28
7066: PUSH
7067: LD_INT 15
7069: ST_TO_ADDR
// hc_gallery :=  ;
7070: LD_ADDR_OWVAR 33
7074: PUSH
7075: LD_STRING 
7077: ST_TO_ADDR
// hc_name :=  ;
7078: LD_ADDR_OWVAR 26
7082: PUSH
7083: LD_STRING 
7085: ST_TO_ADDR
// un := CreateHuman ;
7086: LD_ADDR_VAR 0 3
7090: PUSH
7091: CALL_OW 44
7095: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7096: LD_VAR 0 3
7100: PPUSH
7101: LD_VAR 0 4
7105: PUSH
7106: LD_VAR 0 4
7110: PUSH
7111: LD_VAR 0 2
7115: MINUS
7116: ARRAY
7117: PPUSH
7118: CALL_OW 52
// end ;
7122: GO 7051
7124: POP
7125: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7126: LD_INT 503
7128: PPUSH
7129: LD_INT 27
7131: PPUSH
7132: LD_STRING 
7134: PPUSH
7135: LD_INT 8
7137: PUSH
7138: LD_INT 9
7140: PUSH
7141: LD_INT 10
7143: PUSH
7144: LD_INT 10
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: LIST
7151: LIST
7152: PUSH
7153: LD_OWVAR 67
7157: ARRAY
7158: PPUSH
7159: LD_INT 3000
7161: PUSH
7162: LD_INT 500
7164: PUSH
7165: LD_INT 150
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: PPUSH
7173: LD_INT 16
7175: PUSH
7176: LD_INT 6
7178: PUSH
7179: LD_INT 6
7181: PUSH
7182: LD_INT 6
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PPUSH
7191: CALL 61096 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7195: LD_ADDR_EXP 78
7199: PUSH
7200: LD_EXP 78
7204: PPUSH
7205: LD_INT 1
7207: PPUSH
7208: LD_INT 22
7210: PUSH
7211: LD_VAR 0 5
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 23
7222: PUSH
7223: LD_INT 2
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 21
7235: PUSH
7236: LD_INT 2
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: LIST
7251: PPUSH
7252: CALL_OW 69
7256: PPUSH
7257: CALL_OW 1
7261: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7262: LD_INT 216
7264: PPUSH
7265: LD_INT 228
7267: PPUSH
7268: LD_INT 2
7270: PPUSH
7271: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7275: LD_INT 223
7277: PPUSH
7278: LD_INT 241
7280: PPUSH
7281: LD_INT 2
7283: PPUSH
7284: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7288: LD_INT 216
7290: PPUSH
7291: LD_INT 217
7293: PPUSH
7294: LD_INT 2
7296: PPUSH
7297: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7301: LD_INT 233
7303: PPUSH
7304: LD_INT 257
7306: PPUSH
7307: LD_INT 2
7309: PPUSH
7310: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7314: LD_INT 230
7316: PPUSH
7317: LD_INT 199
7319: PPUSH
7320: LD_INT 2
7322: PPUSH
7323: CALL_OW 244
// end ;
7327: LD_VAR 0 1
7331: RET
// export Omar ; export function PrepareOmarAli ; begin
7332: LD_INT 0
7334: PPUSH
// uc_side := 5 ;
7335: LD_ADDR_OWVAR 20
7339: PUSH
7340: LD_INT 5
7342: ST_TO_ADDR
// uc_nation := 2 ;
7343: LD_ADDR_OWVAR 21
7347: PUSH
7348: LD_INT 2
7350: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7351: LD_ADDR_EXP 56
7355: PUSH
7356: LD_STRING Omar
7358: PPUSH
7359: CALL_OW 25
7363: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7364: LD_EXP 56
7368: PPUSH
7369: LD_INT 330
7371: PPUSH
7372: LD_INT 244
7374: PPUSH
7375: LD_INT 0
7377: PPUSH
7378: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7382: LD_EXP 56
7386: PPUSH
7387: LD_INT 252
7389: PPUSH
7390: LD_INT 220
7392: PPUSH
7393: CALL_OW 111
// end ; end_of_file
7397: LD_VAR 0 1
7401: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7402: LD_INT 0
7404: PPUSH
7405: PPUSH
7406: PPUSH
7407: PPUSH
7408: PPUSH
// side := 8 ;
7409: LD_ADDR_VAR 0 3
7413: PUSH
7414: LD_INT 8
7416: ST_TO_ADDR
// InitHc ;
7417: CALL_OW 19
// uc_side := side ;
7421: LD_ADDR_OWVAR 20
7425: PUSH
7426: LD_VAR 0 3
7430: ST_TO_ADDR
// uc_nation := 2 ;
7431: LD_ADDR_OWVAR 21
7435: PUSH
7436: LD_INT 2
7438: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7439: LD_ADDR_VAR 0 2
7443: PUSH
7444: LD_INT 22
7446: PUSH
7447: LD_VAR 0 3
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 21
7458: PUSH
7459: LD_INT 3
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: FOR_IN
7476: IFFALSE 7492
// SetBLevel ( i , 10 ) ;
7478: LD_VAR 0 2
7482: PPUSH
7483: LD_INT 10
7485: PPUSH
7486: CALL_OW 241
7490: GO 7475
7492: POP
7493: POP
// Schulz := NewCharacter ( Schulz ) ;
7494: LD_ADDR_EXP 57
7498: PUSH
7499: LD_STRING Schulz
7501: PPUSH
7502: CALL_OW 25
7506: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7507: LD_ADDR_EXP 59
7511: PUSH
7512: LD_STRING Kaia
7514: PPUSH
7515: CALL_OW 25
7519: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7520: LD_EXP 59
7524: PPUSH
7525: LD_INT 324
7527: PPUSH
7528: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7532: LD_ADDR_EXP 58
7536: PUSH
7537: LD_STRING Kozlov
7539: PPUSH
7540: LD_INT 0
7542: PPUSH
7543: LD_STRING 
7545: PPUSH
7546: CALL 52812 0 3
7550: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7551: LD_EXP 58
7555: PPUSH
7556: LD_INT 22
7558: PUSH
7559: LD_INT 8
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: LD_INT 23
7568: PUSH
7569: LD_INT 3
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: PUSH
7576: LD_INT 30
7578: PUSH
7579: LD_INT 8
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: LIST
7590: PPUSH
7591: CALL_OW 69
7595: PUSH
7596: LD_INT 1
7598: ARRAY
7599: PPUSH
7600: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7604: LD_EXP 58
7608: PPUSH
7609: LD_INT 3
7611: PPUSH
7612: LD_INT 10
7614: PPUSH
7615: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7619: LD_ADDR_VAR 0 5
7623: PUSH
7624: LD_INT 22
7626: PUSH
7627: LD_VAR 0 3
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PUSH
7636: LD_INT 30
7638: PUSH
7639: LD_INT 32
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: LD_INT 58
7648: PUSH
7649: EMPTY
7650: LIST
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PPUSH
7657: CALL_OW 69
7661: ST_TO_ADDR
// for i = 1 to 10 do
7662: LD_ADDR_VAR 0 2
7666: PUSH
7667: DOUBLE
7668: LD_INT 1
7670: DEC
7671: ST_TO_ADDR
7672: LD_INT 10
7674: PUSH
7675: FOR_TO
7676: IFFALSE 7748
// begin uc_nation := nation_nature ;
7678: LD_ADDR_OWVAR 21
7682: PUSH
7683: LD_INT 0
7685: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7686: LD_ADDR_OWVAR 28
7690: PUSH
7691: LD_INT 15
7693: ST_TO_ADDR
// hc_gallery :=  ;
7694: LD_ADDR_OWVAR 33
7698: PUSH
7699: LD_STRING 
7701: ST_TO_ADDR
// hc_name :=  ;
7702: LD_ADDR_OWVAR 26
7706: PUSH
7707: LD_STRING 
7709: ST_TO_ADDR
// un := CreateHuman ;
7710: LD_ADDR_VAR 0 4
7714: PUSH
7715: CALL_OW 44
7719: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7720: LD_VAR 0 4
7724: PPUSH
7725: LD_VAR 0 5
7729: PUSH
7730: LD_VAR 0 5
7734: PUSH
7735: LD_VAR 0 2
7739: MINUS
7740: ARRAY
7741: PPUSH
7742: CALL_OW 52
// end ;
7746: GO 7675
7748: POP
7749: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7750: LD_INT 324
7752: PPUSH
7753: LD_INT 3
7755: PPUSH
7756: LD_STRING 
7758: PPUSH
7759: LD_INT 8
7761: PUSH
7762: LD_INT 9
7764: PUSH
7765: LD_INT 10
7767: PUSH
7768: LD_INT 10
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: LIST
7775: LIST
7776: PUSH
7777: LD_OWVAR 67
7781: ARRAY
7782: PPUSH
7783: LD_INT 3000
7785: PUSH
7786: LD_INT 500
7788: PUSH
7789: LD_INT 150
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: PPUSH
7797: LD_INT 16
7799: PUSH
7800: LD_INT 6
7802: PUSH
7803: LD_INT 6
7805: PUSH
7806: LD_INT 8
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: PPUSH
7815: CALL 61096 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7819: LD_ADDR_EXP 78
7823: PUSH
7824: LD_EXP 78
7828: PPUSH
7829: LD_INT 3
7831: PPUSH
7832: LD_INT 22
7834: PUSH
7835: LD_VAR 0 3
7839: PUSH
7840: EMPTY
7841: LIST
7842: LIST
7843: PUSH
7844: LD_INT 23
7846: PUSH
7847: LD_INT 2
7849: PUSH
7850: EMPTY
7851: LIST
7852: LIST
7853: PUSH
7854: LD_INT 3
7856: PUSH
7857: LD_INT 21
7859: PUSH
7860: LD_INT 2
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: LIST
7875: PPUSH
7876: CALL_OW 69
7880: PUSH
7881: LD_EXP 57
7885: DIFF
7886: PPUSH
7887: CALL_OW 1
7891: ST_TO_ADDR
// end ;
7892: LD_VAR 0 1
7896: RET
// export function BuildKozlovBomb ; begin
7897: LD_INT 0
7899: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7900: LD_INT 332
7902: PPUSH
7903: CALL_OW 302
7907: NOT
7908: PUSH
7909: LD_INT 336
7911: PPUSH
7912: CALL_OW 302
7916: NOT
7917: OR
7918: IFFALSE 7922
// exit ;
7920: GO 8019
// ComChangeProfession ( Kozlov , 4 ) ;
7922: LD_EXP 58
7926: PPUSH
7927: LD_INT 4
7929: PPUSH
7930: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7934: LD_INT 336
7936: PPUSH
7937: LD_INT 25
7939: PPUSH
7940: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7944: LD_INT 35
7946: PPUSH
7947: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7951: LD_INT 25
7953: PPUSH
7954: LD_INT 8
7956: PPUSH
7957: CALL_OW 321
7961: PUSH
7962: LD_INT 2
7964: EQUAL
7965: IFFALSE 7944
// ComExitBuilding ( Kozlov ) ;
7967: LD_EXP 58
7971: PPUSH
7972: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7976: LD_EXP 58
7980: PPUSH
7981: LD_INT 332
7983: PPUSH
7984: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7988: LD_EXP 58
7992: PPUSH
7993: LD_INT 3
7995: PPUSH
7996: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8000: LD_INT 332
8002: PPUSH
8003: LD_INT 23
8005: PPUSH
8006: LD_INT 3
8008: PPUSH
8009: LD_INT 1
8011: PPUSH
8012: LD_INT 48
8014: PPUSH
8015: CALL_OW 125
// end ;
8019: LD_VAR 0 1
8023: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8024: LD_EXP 3
8028: NOT
8029: IFFALSE 8919
8031: GO 8033
8033: DISABLE
8034: LD_INT 0
8036: PPUSH
8037: PPUSH
8038: PPUSH
8039: PPUSH
// begin enable ;
8040: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8041: LD_INT 22
8043: PUSH
8044: LD_INT 8
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: LD_INT 23
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: LD_INT 30
8063: PUSH
8064: LD_INT 3
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: NOT
8081: IFFALSE 8085
// exit ;
8083: GO 8919
// if Prob ( 40 ) then
8085: LD_INT 40
8087: PPUSH
8088: CALL_OW 13
8092: IFFALSE 8219
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8094: LD_INT 3
8096: PPUSH
8097: LD_INT 14
8099: PUSH
8100: LD_INT 1
8102: PUSH
8103: LD_INT 2
8105: PUSH
8106: LD_INT 28
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: LIST
8113: LIST
8114: PUSH
8115: LD_INT 14
8117: PUSH
8118: LD_INT 1
8120: PUSH
8121: LD_INT 2
8123: PUSH
8124: LD_INT 28
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_INT 14
8135: PUSH
8136: LD_INT 1
8138: PUSH
8139: LD_INT 2
8141: PUSH
8142: LD_INT 28
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 14
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: LD_INT 2
8159: PUSH
8160: LD_INT 28
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 14
8171: PUSH
8172: LD_INT 1
8174: PUSH
8175: LD_INT 2
8177: PUSH
8178: LD_INT 28
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 14
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 26
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL 46386 0 2
// end else
8217: GO 8426
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8219: LD_INT 3
8221: PPUSH
8222: LD_INT 14
8224: PUSH
8225: LD_INT 1
8227: PUSH
8228: LD_INT 2
8230: PUSH
8231: LD_INT 27
8233: PUSH
8234: LD_INT 26
8236: PUSH
8237: LD_INT 26
8239: PUSH
8240: LD_INT 28
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: PUSH
8249: LD_OWVAR 67
8253: ARRAY
8254: PUSH
8255: EMPTY
8256: LIST
8257: LIST
8258: LIST
8259: LIST
8260: PUSH
8261: LD_INT 14
8263: PUSH
8264: LD_INT 1
8266: PUSH
8267: LD_INT 2
8269: PUSH
8270: LD_INT 27
8272: PUSH
8273: LD_INT 26
8275: PUSH
8276: LD_INT 26
8278: PUSH
8279: LD_INT 26
8281: PUSH
8282: EMPTY
8283: LIST
8284: LIST
8285: LIST
8286: LIST
8287: PUSH
8288: LD_OWVAR 67
8292: ARRAY
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: LIST
8299: PUSH
8300: LD_INT 14
8302: PUSH
8303: LD_INT 1
8305: PUSH
8306: LD_INT 2
8308: PUSH
8309: LD_INT 26
8311: PUSH
8312: LD_INT 26
8314: PUSH
8315: LD_INT 29
8317: PUSH
8318: LD_INT 29
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: PUSH
8327: LD_OWVAR 67
8331: ARRAY
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_INT 13
8341: PUSH
8342: LD_INT 1
8344: PUSH
8345: LD_INT 2
8347: PUSH
8348: LD_INT 26
8350: PUSH
8351: LD_INT 29
8353: PUSH
8354: LD_INT 29
8356: PUSH
8357: LD_INT 29
8359: PUSH
8360: EMPTY
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: PUSH
8366: LD_OWVAR 67
8370: ARRAY
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: PUSH
8378: LD_INT 13
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: LD_INT 2
8386: PUSH
8387: LD_INT 29
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 14
8398: PUSH
8399: LD_INT 1
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_INT 26
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: LIST
8418: LIST
8419: LIST
8420: LIST
8421: PPUSH
8422: CALL 46386 0 2
// end ; p := 0 ;
8426: LD_ADDR_VAR 0 4
8430: PUSH
8431: LD_INT 0
8433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8434: LD_INT 35
8436: PPUSH
8437: CALL_OW 67
// p := Inc ( p ) ;
8441: LD_ADDR_VAR 0 4
8445: PUSH
8446: LD_VAR 0 4
8450: PPUSH
8451: CALL 91465 0 1
8455: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8456: LD_INT 3
8458: PPUSH
8459: LD_INT 1
8461: PPUSH
8462: CALL 47804 0 2
8466: PUSH
8467: LD_INT 6
8469: GREATEREQUAL
8470: PUSH
8471: LD_VAR 0 4
8475: PUSH
8476: LD_INT 100
8478: GREATER
8479: OR
8480: IFFALSE 8434
// wait ( 0 0$30 ) ;
8482: LD_INT 1050
8484: PPUSH
8485: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_INT 3
8496: PPUSH
8497: LD_INT 1
8499: PPUSH
8500: CALL 47804 0 2
8504: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8505: LD_ADDR_EXP 97
8509: PUSH
8510: LD_EXP 97
8514: PPUSH
8515: LD_INT 3
8517: PPUSH
8518: LD_EXP 97
8522: PUSH
8523: LD_INT 3
8525: ARRAY
8526: PUSH
8527: LD_VAR 0 2
8531: DIFF
8532: PPUSH
8533: CALL_OW 1
8537: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8538: LD_ADDR_VAR 0 3
8542: PUSH
8543: LD_INT 0
8545: PPUSH
8546: LD_INT 2
8548: PPUSH
8549: CALL_OW 12
8553: ST_TO_ADDR
// if target then
8554: LD_VAR 0 3
8558: IFFALSE 8686
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8560: LD_ADDR_VAR 0 2
8564: PUSH
8565: LD_VAR 0 2
8569: PPUSH
8570: LD_INT 24
8572: PUSH
8573: LD_INT 250
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PPUSH
8580: CALL_OW 72
8584: ST_TO_ADDR
// for i in tmp do
8585: LD_ADDR_VAR 0 1
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: FOR_IN
8596: IFFALSE 8636
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 89
8605: PPUSH
8606: LD_INT 71
8608: PPUSH
8609: CALL_OW 297
8613: PUSH
8614: LD_INT 9
8616: GREATER
8617: IFFALSE 8634
// ComMoveXY ( i , 89 , 71 ) ;
8619: LD_VAR 0 1
8623: PPUSH
8624: LD_INT 89
8626: PPUSH
8627: LD_INT 71
8629: PPUSH
8630: CALL_OW 111
8634: GO 8595
8636: POP
8637: POP
// wait ( 0 0$1 ) ;
8638: LD_INT 35
8640: PPUSH
8641: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8645: LD_VAR 0 2
8649: PPUSH
8650: LD_INT 92
8652: PUSH
8653: LD_INT 89
8655: PUSH
8656: LD_INT 71
8658: PUSH
8659: LD_INT 9
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: LIST
8666: LIST
8667: PPUSH
8668: CALL_OW 72
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: LD_INT 1
8680: MINUS
8681: GREATEREQUAL
8682: IFFALSE 8560
// end else
8684: GO 8810
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8686: LD_ADDR_VAR 0 2
8690: PUSH
8691: LD_VAR 0 2
8695: PPUSH
8696: LD_INT 24
8698: PUSH
8699: LD_INT 250
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: PPUSH
8706: CALL_OW 72
8710: ST_TO_ADDR
// for i in tmp do
8711: LD_ADDR_VAR 0 1
8715: PUSH
8716: LD_VAR 0 2
8720: PUSH
8721: FOR_IN
8722: IFFALSE 8762
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8724: LD_VAR 0 1
8728: PPUSH
8729: LD_INT 147
8731: PPUSH
8732: LD_INT 4
8734: PPUSH
8735: CALL_OW 297
8739: PUSH
8740: LD_INT 9
8742: GREATER
8743: IFFALSE 8760
// ComMoveXY ( i , 147 , 4 ) ;
8745: LD_VAR 0 1
8749: PPUSH
8750: LD_INT 147
8752: PPUSH
8753: LD_INT 4
8755: PPUSH
8756: CALL_OW 111
8760: GO 8721
8762: POP
8763: POP
// wait ( 0 0$1 ) ;
8764: LD_INT 35
8766: PPUSH
8767: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8771: LD_VAR 0 2
8775: PPUSH
8776: LD_INT 92
8778: PUSH
8779: LD_INT 147
8781: PUSH
8782: LD_INT 4
8784: PUSH
8785: LD_INT 9
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: LIST
8792: LIST
8793: PPUSH
8794: CALL_OW 72
8798: PUSH
8799: LD_VAR 0 2
8803: PUSH
8804: LD_INT 1
8806: MINUS
8807: GREATEREQUAL
8808: IFFALSE 8686
// end ; repeat wait ( 0 0$1 ) ;
8810: LD_INT 35
8812: PPUSH
8813: CALL_OW 67
// for i in tmp do
8817: LD_ADDR_VAR 0 1
8821: PUSH
8822: LD_VAR 0 2
8826: PUSH
8827: FOR_IN
8828: IFFALSE 8910
// begin if GetLives ( i ) > 251 then
8830: LD_VAR 0 1
8834: PPUSH
8835: CALL_OW 256
8839: PUSH
8840: LD_INT 251
8842: GREATER
8843: IFFALSE 8881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8845: LD_VAR 0 1
8849: PPUSH
8850: LD_INT 81
8852: PUSH
8853: LD_INT 8
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: PPUSH
8860: CALL_OW 69
8864: PPUSH
8865: LD_VAR 0 1
8869: PPUSH
8870: CALL_OW 74
8874: PPUSH
8875: CALL_OW 115
8879: GO 8908
// if IsDead ( i ) then
8881: LD_VAR 0 1
8885: PPUSH
8886: CALL_OW 301
8890: IFFALSE 8908
// tmp := tmp diff i ;
8892: LD_ADDR_VAR 0 2
8896: PUSH
8897: LD_VAR 0 2
8901: PUSH
8902: LD_VAR 0 1
8906: DIFF
8907: ST_TO_ADDR
// end ;
8908: GO 8827
8910: POP
8911: POP
// until not tmp ;
8912: LD_VAR 0 2
8916: NOT
8917: IFFALSE 8810
// end ;
8919: PPOPN 4
8921: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8922: LD_EXP 58
8926: PPUSH
8927: CALL_OW 302
8931: PUSH
8932: LD_EXP 3
8936: NOT
8937: AND
8938: IFFALSE 8947
8940: GO 8942
8942: DISABLE
// BuildKozlovBomb ;
8943: CALL 7897 0 0
8947: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8948: LD_INT 22
8950: PUSH
8951: LD_INT 8
8953: PUSH
8954: EMPTY
8955: LIST
8956: LIST
8957: PUSH
8958: LD_INT 34
8960: PUSH
8961: LD_INT 48
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: EMPTY
8969: LIST
8970: LIST
8971: PPUSH
8972: CALL_OW 69
8976: IFFALSE 9024
8978: GO 8980
8980: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8981: LD_INT 22
8983: PUSH
8984: LD_INT 8
8986: PUSH
8987: EMPTY
8988: LIST
8989: LIST
8990: PUSH
8991: LD_INT 34
8993: PUSH
8994: LD_INT 48
8996: PUSH
8997: EMPTY
8998: LIST
8999: LIST
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: PPUSH
9005: CALL_OW 69
9009: PUSH
9010: LD_INT 1
9012: ARRAY
9013: PPUSH
9014: LD_INT 173
9016: PPUSH
9017: LD_INT 96
9019: PPUSH
9020: CALL_OW 116
// end ; end_of_file
9024: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9025: LD_INT 0
9027: PPUSH
9028: PPUSH
9029: PPUSH
9030: PPUSH
9031: PPUSH
9032: PPUSH
9033: PPUSH
9034: PPUSH
9035: PPUSH
9036: PPUSH
// side := 3 ;
9037: LD_ADDR_VAR 0 6
9041: PUSH
9042: LD_INT 3
9044: ST_TO_ADDR
// InitHc ;
9045: CALL_OW 19
// uc_side := side ;
9049: LD_ADDR_OWVAR 20
9053: PUSH
9054: LD_VAR 0 6
9058: ST_TO_ADDR
// uc_nation := 3 ;
9059: LD_ADDR_OWVAR 21
9063: PUSH
9064: LD_INT 3
9066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9067: LD_ADDR_VAR 0 2
9071: PUSH
9072: LD_INT 22
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: EMPTY
9081: LIST
9082: LIST
9083: PUSH
9084: LD_INT 21
9086: PUSH
9087: LD_INT 3
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PPUSH
9098: CALL_OW 69
9102: PUSH
9103: FOR_IN
9104: IFFALSE 9120
// SetBLevel ( i , 10 ) ;
9106: LD_VAR 0 2
9110: PPUSH
9111: LD_INT 10
9113: PPUSH
9114: CALL_OW 241
9118: GO 9103
9120: POP
9121: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9122: LD_ADDR_VAR 0 10
9126: PUSH
9127: LD_INT 22
9129: PUSH
9130: LD_VAR 0 6
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PUSH
9139: LD_INT 30
9141: PUSH
9142: LD_INT 34
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PUSH
9149: EMPTY
9150: LIST
9151: LIST
9152: PPUSH
9153: CALL_OW 69
9157: ST_TO_ADDR
// if teleport then
9158: LD_VAR 0 10
9162: IFFALSE 9183
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9164: LD_VAR 0 10
9168: PUSH
9169: LD_INT 1
9171: ARRAY
9172: PPUSH
9173: LD_INT 123
9175: PPUSH
9176: LD_INT 122
9178: PPUSH
9179: CALL_OW 243
// hc_importance := 0 ;
9183: LD_ADDR_OWVAR 32
9187: PUSH
9188: LD_INT 0
9190: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9191: LD_ADDR_EXP 60
9195: PUSH
9196: LD_STRING Platonov
9198: PPUSH
9199: CALL_OW 25
9203: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9204: LD_ADDR_EXP 61
9208: PUSH
9209: LD_STRING Yakotich
9211: PPUSH
9212: LD_EXP 1
9216: NOT
9217: PPUSH
9218: LD_STRING 09_
9220: PPUSH
9221: CALL 52812 0 3
9225: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9226: LD_ADDR_EXP 62
9230: PUSH
9231: LD_STRING Gleb
9233: PPUSH
9234: CALL_OW 25
9238: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9239: LD_STRING 03_Cornel
9241: PPUSH
9242: CALL_OW 28
9246: IFFALSE 9294
// begin Bierezov := NewCharacter ( Mikhail ) ;
9248: LD_ADDR_EXP 63
9252: PUSH
9253: LD_STRING Mikhail
9255: PPUSH
9256: CALL_OW 25
9260: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9261: LD_EXP 63
9265: PPUSH
9266: LD_INT 197
9268: PPUSH
9269: LD_INT 111
9271: PPUSH
9272: LD_INT 9
9274: PPUSH
9275: LD_INT 0
9277: PPUSH
9278: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9282: LD_EXP 63
9286: PPUSH
9287: LD_INT 3
9289: PPUSH
9290: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9294: LD_EXP 60
9298: PPUSH
9299: LD_INT 126
9301: PPUSH
9302: CALL_OW 52
// if Yakotich then
9306: LD_EXP 61
9310: IFFALSE 9333
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9312: LD_EXP 61
9316: PPUSH
9317: LD_INT 197
9319: PPUSH
9320: LD_INT 111
9322: PPUSH
9323: LD_INT 9
9325: PPUSH
9326: LD_INT 0
9328: PPUSH
9329: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9333: LD_EXP 62
9337: PPUSH
9338: LD_INT 197
9340: PPUSH
9341: LD_INT 111
9343: PPUSH
9344: LD_INT 9
9346: PPUSH
9347: LD_INT 0
9349: PPUSH
9350: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: LD_INT 126
9361: PPUSH
9362: LD_INT 2
9364: PPUSH
9365: LD_STRING zhukov
9367: PPUSH
9368: LD_INT 9
9370: PUSH
9371: LD_INT 10
9373: PUSH
9374: LD_INT 10
9376: PUSH
9377: LD_INT 10
9379: PUSH
9380: EMPTY
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_OWVAR 67
9390: ARRAY
9391: PPUSH
9392: LD_INT 9000
9394: PUSH
9395: LD_INT 1000
9397: PUSH
9398: LD_INT 300
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PPUSH
9406: LD_INT 21
9408: PUSH
9409: LD_INT 8
9411: PUSH
9412: LD_INT 13
9414: PUSH
9415: LD_INT 8
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: LIST
9422: LIST
9423: PPUSH
9424: CALL 61096 0 6
9428: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9429: LD_ADDR_EXP 78
9433: PUSH
9434: LD_EXP 78
9438: PPUSH
9439: LD_INT 2
9441: PPUSH
9442: LD_VAR 0 5
9446: PUSH
9447: LD_EXP 61
9451: PUSH
9452: LD_EXP 62
9456: PUSH
9457: LD_EXP 63
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: LIST
9466: UNION
9467: PPUSH
9468: CALL_OW 1
9472: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9473: LD_ADDR_VAR 0 4
9477: PUSH
9478: LD_INT 267
9480: PPUSH
9481: CALL_OW 274
9485: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9486: LD_VAR 0 4
9490: PPUSH
9491: LD_INT 1
9493: PPUSH
9494: LD_INT 5000
9496: PPUSH
9497: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9501: LD_VAR 0 4
9505: PPUSH
9506: LD_INT 2
9508: PPUSH
9509: LD_INT 200
9511: PPUSH
9512: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9516: LD_VAR 0 4
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: LD_INT 200
9526: PPUSH
9527: CALL_OW 277
// for i := 1 to 6 do
9531: LD_ADDR_VAR 0 2
9535: PUSH
9536: DOUBLE
9537: LD_INT 1
9539: DEC
9540: ST_TO_ADDR
9541: LD_INT 6
9543: PUSH
9544: FOR_TO
9545: IFFALSE 9628
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9547: LD_INT 0
9549: PPUSH
9550: LD_INT 8
9552: PUSH
9553: LD_INT 9
9555: PUSH
9556: LD_INT 10
9558: PUSH
9559: LD_INT 10
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_OWVAR 67
9572: ARRAY
9573: PPUSH
9574: CALL_OW 381
// un := CreateHuman ;
9578: LD_ADDR_VAR 0 8
9582: PUSH
9583: CALL_OW 44
9587: ST_TO_ADDR
// if i mod 2 = 0 then
9588: LD_VAR 0 2
9592: PUSH
9593: LD_INT 2
9595: MOD
9596: PUSH
9597: LD_INT 0
9599: EQUAL
9600: IFFALSE 9614
// SetClass ( un , class_bazooker ) ;
9602: LD_VAR 0 8
9606: PPUSH
9607: LD_INT 9
9609: PPUSH
9610: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9614: LD_VAR 0 8
9618: PPUSH
9619: LD_INT 674
9621: PPUSH
9622: CALL_OW 52
// end ;
9626: GO 9544
9628: POP
9629: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9630: LD_INT 21
9632: PPUSH
9633: LD_INT 3
9635: PPUSH
9636: LD_INT 3
9638: PPUSH
9639: LD_INT 52
9641: PPUSH
9642: LD_INT 100
9644: PPUSH
9645: CALL 57652 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9649: CALL_OW 45
9653: PPUSH
9654: LD_INT 259
9656: PPUSH
9657: LD_INT 145
9659: PPUSH
9660: LD_INT 3
9662: PPUSH
9663: LD_INT 0
9665: PPUSH
9666: CALL 92244 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9670: CALL_OW 45
9674: PPUSH
9675: LD_INT 245
9677: PPUSH
9678: LD_INT 139
9680: PPUSH
9681: LD_INT 3
9683: PPUSH
9684: LD_INT 0
9686: PPUSH
9687: CALL 92244 0 5
// behemoths := [ ] ;
9691: LD_ADDR_EXP 64
9695: PUSH
9696: EMPTY
9697: ST_TO_ADDR
// behemothBuilders := [ ] ;
9698: LD_ADDR_EXP 65
9702: PUSH
9703: EMPTY
9704: ST_TO_ADDR
// j := 3 ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_INT 3
9712: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9713: LD_ADDR_VAR 0 2
9717: PUSH
9718: LD_INT 22
9720: PUSH
9721: LD_INT 3
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: LD_INT 25
9730: PUSH
9731: LD_INT 3
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: PPUSH
9742: CALL_OW 69
9746: PUSH
9747: FOR_IN
9748: IFFALSE 9798
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9750: LD_ADDR_EXP 65
9754: PUSH
9755: LD_EXP 65
9759: PPUSH
9760: LD_VAR 0 2
9764: PPUSH
9765: CALL 90104 0 2
9769: ST_TO_ADDR
// j := j - 1 ;
9770: LD_ADDR_VAR 0 3
9774: PUSH
9775: LD_VAR 0 3
9779: PUSH
9780: LD_INT 1
9782: MINUS
9783: ST_TO_ADDR
// if j = 0 then
9784: LD_VAR 0 3
9788: PUSH
9789: LD_INT 0
9791: EQUAL
9792: IFFALSE 9796
// break ;
9794: GO 9798
// end ;
9796: GO 9747
9798: POP
9799: POP
// end ;
9800: LD_VAR 0 1
9804: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9805: LD_INT 0
9807: PPUSH
9808: PPUSH
9809: PPUSH
9810: PPUSH
9811: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9812: LD_ADDR_VAR 0 4
9816: PUSH
9817: LD_INT 209
9819: PUSH
9820: LD_INT 149
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: PUSH
9827: LD_INT 219
9829: PUSH
9830: LD_INT 154
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: PUSH
9837: LD_INT 223
9839: PUSH
9840: LD_INT 149
9842: PUSH
9843: EMPTY
9844: LIST
9845: LIST
9846: PUSH
9847: LD_INT 232
9849: PUSH
9850: LD_INT 155
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: ST_TO_ADDR
// if not behemothBuilders then
9863: LD_EXP 65
9867: NOT
9868: IFFALSE 9872
// exit ;
9870: GO 9976
// j := 1 ;
9872: LD_ADDR_VAR 0 3
9876: PUSH
9877: LD_INT 1
9879: ST_TO_ADDR
// for i in behemothBuilders do
9880: LD_ADDR_VAR 0 2
9884: PUSH
9885: LD_EXP 65
9889: PUSH
9890: FOR_IN
9891: IFFALSE 9974
// begin if IsInUnit ( i ) then
9893: LD_VAR 0 2
9897: PPUSH
9898: CALL_OW 310
9902: IFFALSE 9913
// ComExitBuilding ( i ) ;
9904: LD_VAR 0 2
9908: PPUSH
9909: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9913: LD_VAR 0 2
9917: PPUSH
9918: LD_INT 37
9920: PPUSH
9921: LD_VAR 0 4
9925: PUSH
9926: LD_VAR 0 3
9930: ARRAY
9931: PUSH
9932: LD_INT 1
9934: ARRAY
9935: PPUSH
9936: LD_VAR 0 4
9940: PUSH
9941: LD_VAR 0 3
9945: ARRAY
9946: PUSH
9947: LD_INT 2
9949: ARRAY
9950: PPUSH
9951: LD_INT 0
9953: PPUSH
9954: CALL_OW 230
// j := j + 1 ;
9958: LD_ADDR_VAR 0 3
9962: PUSH
9963: LD_VAR 0 3
9967: PUSH
9968: LD_INT 1
9970: PLUS
9971: ST_TO_ADDR
// end ;
9972: GO 9890
9974: POP
9975: POP
// end ;
9976: LD_VAR 0 1
9980: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9981: LD_INT 3
9983: PPUSH
9984: CALL 90165 0 1
9988: PUSH
9989: LD_INT 22
9991: PUSH
9992: LD_INT 3
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PUSH
9999: LD_INT 30
10001: PUSH
10002: LD_INT 37
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PUSH
10009: EMPTY
10010: LIST
10011: LIST
10012: PPUSH
10013: CALL_OW 69
10017: NOT
10018: AND
10019: IFFALSE 10205
10021: GO 10023
10023: DISABLE
10024: LD_INT 0
10026: PPUSH
10027: PPUSH
// begin enable ;
10028: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10029: LD_ADDR_VAR 0 2
10033: PUSH
10034: LD_INT 3
10036: PPUSH
10037: CALL 90165 0 1
10041: ST_TO_ADDR
// for i in tmp do
10042: LD_ADDR_VAR 0 1
10046: PUSH
10047: LD_VAR 0 2
10051: PUSH
10052: FOR_IN
10053: IFFALSE 10203
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10055: LD_VAR 0 1
10059: PPUSH
10060: LD_INT 7
10062: PPUSH
10063: CALL_OW 308
10067: PUSH
10068: LD_VAR 0 1
10072: PPUSH
10073: CALL_OW 110
10077: PUSH
10078: LD_INT 2
10080: EQUAL
10081: NOT
10082: AND
10083: IFFALSE 10097
// SetTag ( i , 2 ) ;
10085: LD_VAR 0 1
10089: PPUSH
10090: LD_INT 2
10092: PPUSH
10093: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10097: LD_INT 81
10099: PUSH
10100: LD_INT 3
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: PUSH
10107: LD_INT 91
10109: PUSH
10110: LD_VAR 0 1
10114: PUSH
10115: LD_INT 12
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: LIST
10122: PUSH
10123: EMPTY
10124: LIST
10125: LIST
10126: PPUSH
10127: CALL_OW 69
10131: NOT
10132: PUSH
10133: LD_VAR 0 1
10137: PPUSH
10138: CALL_OW 110
10142: PUSH
10143: LD_INT 2
10145: EQUAL
10146: NOT
10147: AND
10148: IFFALSE 10167
// ComAgressiveMove ( i , 64 , 93 ) else
10150: LD_VAR 0 1
10154: PPUSH
10155: LD_INT 64
10157: PPUSH
10158: LD_INT 93
10160: PPUSH
10161: CALL_OW 114
10165: GO 10201
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10167: LD_VAR 0 1
10171: PPUSH
10172: LD_INT 81
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL_OW 69
10186: PPUSH
10187: LD_VAR 0 1
10191: PPUSH
10192: CALL_OW 74
10196: PPUSH
10197: CALL_OW 115
// end ;
10201: GO 10052
10203: POP
10204: POP
// end ;
10205: PPOPN 2
10207: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10208: LD_EXP 2
10212: NOT
10213: IFFALSE 11171
10215: GO 10217
10217: DISABLE
10218: LD_INT 0
10220: PPUSH
10221: PPUSH
10222: PPUSH
10223: PPUSH
10224: PPUSH
// begin enable ;
10225: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10226: LD_INT 22
10228: PUSH
10229: LD_INT 3
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 30
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: NOT
10255: IFFALSE 10259
// exit ;
10257: GO 11171
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10259: LD_ADDR_VAR 0 4
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PUSH
10274: LD_INT 30
10276: PUSH
10277: LD_INT 34
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: PPUSH
10288: CALL_OW 69
10292: ST_TO_ADDR
// if Prob ( 40 ) then
10293: LD_INT 40
10295: PPUSH
10296: CALL_OW 13
10300: IFFALSE 10427
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10302: LD_INT 2
10304: PPUSH
10305: LD_INT 22
10307: PUSH
10308: LD_INT 3
10310: PUSH
10311: LD_INT 3
10313: PUSH
10314: LD_INT 49
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: PUSH
10323: LD_INT 22
10325: PUSH
10326: LD_INT 3
10328: PUSH
10329: LD_INT 3
10331: PUSH
10332: LD_INT 49
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: PUSH
10341: LD_INT 22
10343: PUSH
10344: LD_INT 3
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 49
10352: PUSH
10353: EMPTY
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: PUSH
10359: LD_INT 24
10361: PUSH
10362: LD_INT 3
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 46
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 24
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 46
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 24
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 46
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: PPUSH
10421: CALL 46386 0 2
// end else
10425: GO 10550
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10427: LD_INT 2
10429: PPUSH
10430: LD_INT 24
10432: PUSH
10433: LD_INT 3
10435: PUSH
10436: LD_INT 3
10438: PUSH
10439: LD_INT 47
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: LIST
10447: PUSH
10448: LD_INT 24
10450: PUSH
10451: LD_INT 3
10453: PUSH
10454: LD_INT 3
10456: PUSH
10457: LD_INT 47
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: PUSH
10466: LD_INT 24
10468: PUSH
10469: LD_INT 3
10471: PUSH
10472: LD_INT 3
10474: PUSH
10475: LD_INT 47
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 24
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 46
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 24
10504: PUSH
10505: LD_INT 3
10507: PUSH
10508: LD_INT 3
10510: PUSH
10511: LD_INT 46
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 24
10522: PUSH
10523: LD_INT 3
10525: PUSH
10526: LD_INT 3
10528: PUSH
10529: LD_INT 46
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: EMPTY
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: PPUSH
10546: CALL 46386 0 2
// end ; if Difficulty > 1 then
10550: LD_OWVAR 67
10554: PUSH
10555: LD_INT 1
10557: GREATER
10558: IFFALSE 10588
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10560: LD_INT 2
10562: PPUSH
10563: LD_INT 24
10565: PUSH
10566: LD_INT 3
10568: PUSH
10569: LD_INT 3
10571: PUSH
10572: LD_INT 47
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: PUSH
10581: EMPTY
10582: LIST
10583: PPUSH
10584: CALL 46386 0 2
// p := 0 ;
10588: LD_ADDR_VAR 0 5
10592: PUSH
10593: LD_INT 0
10595: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10596: LD_INT 35
10598: PPUSH
10599: CALL_OW 67
// p := Inc ( p ) ;
10603: LD_ADDR_VAR 0 5
10607: PUSH
10608: LD_VAR 0 5
10612: PPUSH
10613: CALL 91465 0 1
10617: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 100 ;
10618: LD_INT 2
10620: PPUSH
10621: LD_INT 1
10623: PPUSH
10624: CALL 47804 0 2
10628: PUSH
10629: LD_INT 6
10631: PUSH
10632: LD_INT 7
10634: PUSH
10635: LD_INT 7
10637: PUSH
10638: LD_INT 7
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: LIST
10645: LIST
10646: PUSH
10647: LD_OWVAR 67
10651: ARRAY
10652: GREATEREQUAL
10653: PUSH
10654: LD_VAR 0 5
10658: PUSH
10659: LD_INT 100
10661: GREATER
10662: OR
10663: IFFALSE 10596
// wait ( 0 0$30 ) ;
10665: LD_INT 1050
10667: PPUSH
10668: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10672: LD_ADDR_VAR 0 2
10676: PUSH
10677: LD_INT 2
10679: PPUSH
10680: LD_INT 1
10682: PPUSH
10683: CALL 47804 0 2
10687: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10688: LD_ADDR_EXP 97
10692: PUSH
10693: LD_EXP 97
10697: PPUSH
10698: LD_INT 2
10700: PPUSH
10701: LD_EXP 97
10705: PUSH
10706: LD_INT 2
10708: ARRAY
10709: PUSH
10710: LD_VAR 0 2
10714: DIFF
10715: PPUSH
10716: CALL_OW 1
10720: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10721: LD_ADDR_VAR 0 3
10725: PUSH
10726: LD_INT 0
10728: PPUSH
10729: LD_INT 1
10731: PPUSH
10732: CALL_OW 12
10736: ST_TO_ADDR
// if target then
10737: LD_VAR 0 3
10741: IFFALSE 10869
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10743: LD_ADDR_VAR 0 2
10747: PUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_INT 24
10755: PUSH
10756: LD_INT 250
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 72
10767: ST_TO_ADDR
// for i in tmp do
10768: LD_ADDR_VAR 0 1
10772: PUSH
10773: LD_VAR 0 2
10777: PUSH
10778: FOR_IN
10779: IFFALSE 10819
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10781: LD_VAR 0 1
10785: PPUSH
10786: LD_INT 139
10788: PPUSH
10789: LD_INT 89
10791: PPUSH
10792: CALL_OW 297
10796: PUSH
10797: LD_INT 9
10799: GREATER
10800: IFFALSE 10817
// ComMoveXY ( i , 139 , 89 ) ;
10802: LD_VAR 0 1
10806: PPUSH
10807: LD_INT 139
10809: PPUSH
10810: LD_INT 89
10812: PPUSH
10813: CALL_OW 111
10817: GO 10778
10819: POP
10820: POP
// wait ( 0 0$1 ) ;
10821: LD_INT 35
10823: PPUSH
10824: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_INT 92
10835: PUSH
10836: LD_INT 139
10838: PUSH
10839: LD_INT 89
10841: PUSH
10842: LD_INT 9
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: PPUSH
10851: CALL_OW 72
10855: PUSH
10856: LD_VAR 0 2
10860: PUSH
10861: LD_INT 1
10863: MINUS
10864: GREATEREQUAL
10865: IFFALSE 10743
// end else
10867: GO 11011
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10869: LD_VAR 0 2
10873: PPUSH
10874: LD_VAR 0 4
10878: PUSH
10879: LD_INT 1
10881: ARRAY
10882: PPUSH
10883: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10887: LD_ADDR_VAR 0 2
10891: PUSH
10892: LD_VAR 0 2
10896: PPUSH
10897: LD_INT 24
10899: PUSH
10900: LD_INT 250
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: PPUSH
10907: CALL_OW 72
10911: ST_TO_ADDR
// for i in tmp do
10912: LD_ADDR_VAR 0 1
10916: PUSH
10917: LD_VAR 0 2
10921: PUSH
10922: FOR_IN
10923: IFFALSE 10963
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10925: LD_VAR 0 1
10929: PPUSH
10930: LD_INT 124
10932: PPUSH
10933: LD_INT 139
10935: PPUSH
10936: CALL_OW 297
10940: PUSH
10941: LD_INT 9
10943: GREATER
10944: IFFALSE 10961
// ComMoveXY ( i , 124 , 139 ) ;
10946: LD_VAR 0 1
10950: PPUSH
10951: LD_INT 124
10953: PPUSH
10954: LD_INT 139
10956: PPUSH
10957: CALL_OW 111
10961: GO 10922
10963: POP
10964: POP
// wait ( 0 0$1 ) ;
10965: LD_INT 35
10967: PPUSH
10968: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10972: LD_VAR 0 2
10976: PPUSH
10977: LD_INT 92
10979: PUSH
10980: LD_INT 124
10982: PUSH
10983: LD_INT 139
10985: PUSH
10986: LD_INT 9
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 72
10999: PUSH
11000: LD_VAR 0 2
11004: PUSH
11005: LD_INT 1
11007: MINUS
11008: GREATEREQUAL
11009: IFFALSE 10887
// end ; repeat wait ( 0 0$1 ) ;
11011: LD_INT 35
11013: PPUSH
11014: CALL_OW 67
// for i in tmp do
11018: LD_ADDR_VAR 0 1
11022: PUSH
11023: LD_VAR 0 2
11027: PUSH
11028: FOR_IN
11029: IFFALSE 11162
// begin if GetLives ( i ) > 251 then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 256
11040: PUSH
11041: LD_INT 251
11043: GREATER
11044: IFFALSE 11133
// begin if GetWeapon ( i ) = ru_time_lapser then
11046: LD_VAR 0 1
11050: PPUSH
11051: CALL_OW 264
11055: PUSH
11056: LD_INT 49
11058: EQUAL
11059: IFFALSE 11097
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11061: LD_VAR 0 1
11065: PPUSH
11066: LD_INT 81
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 69
11080: PPUSH
11081: LD_VAR 0 1
11085: PPUSH
11086: CALL_OW 74
11090: PPUSH
11091: CALL_OW 112
11095: GO 11131
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11097: LD_VAR 0 1
11101: PPUSH
11102: LD_INT 81
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PPUSH
11112: CALL_OW 69
11116: PPUSH
11117: LD_VAR 0 1
11121: PPUSH
11122: CALL_OW 74
11126: PPUSH
11127: CALL_OW 115
// end else
11131: GO 11160
// if IsDead ( i ) then
11133: LD_VAR 0 1
11137: PPUSH
11138: CALL_OW 301
11142: IFFALSE 11160
// tmp := tmp diff i ;
11144: LD_ADDR_VAR 0 2
11148: PUSH
11149: LD_VAR 0 2
11153: PUSH
11154: LD_VAR 0 1
11158: DIFF
11159: ST_TO_ADDR
// end ;
11160: GO 11028
11162: POP
11163: POP
// until not tmp ;
11164: LD_VAR 0 2
11168: NOT
11169: IFFALSE 11011
// end ;
11171: PPOPN 5
11173: END
// every 30 30$00 trigger not russianDestroyed do
11174: LD_EXP 2
11178: NOT
11179: IFFALSE 11248
11181: GO 11183
11183: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11184: LD_INT 105000
11186: PUSH
11187: LD_INT 84000
11189: PUSH
11190: LD_INT 63000
11192: PUSH
11193: LD_INT 52500
11195: PUSH
11196: EMPTY
11197: LIST
11198: LIST
11199: LIST
11200: LIST
11201: PUSH
11202: LD_OWVAR 67
11206: ARRAY
11207: PPUSH
11208: CALL_OW 67
// if russianDestroyed then
11212: LD_EXP 2
11216: IFFALSE 11220
// exit ;
11218: GO 11248
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11220: LD_INT 2
11222: PPUSH
11223: LD_INT 23
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 1
11231: PUSH
11232: LD_INT 48
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: PUSH
11241: EMPTY
11242: LIST
11243: PPUSH
11244: CALL 46386 0 2
// end ; end_of_file
11248: END
// export function CustomEvent ( event ) ; begin
11249: LD_INT 0
11251: PPUSH
// end ;
11252: LD_VAR 0 2
11256: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11257: LD_VAR 0 2
11261: PPUSH
11262: LD_VAR 0 3
11266: PPUSH
11267: LD_INT 15
11269: PPUSH
11270: CALL_OW 309
11274: IFFALSE 11283
// YouLost ( MothContaminate ) ;
11276: LD_STRING MothContaminate
11278: PPUSH
11279: CALL_OW 104
// end ;
11283: PPOPN 3
11285: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_VAR 0 3
11295: PPUSH
11296: LD_INT 15
11298: PPUSH
11299: CALL_OW 309
11303: IFFALSE 11319
// begin wait ( 0 0$6 ) ;
11305: LD_INT 210
11307: PPUSH
11308: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11312: LD_STRING MothContaminateBomb
11314: PPUSH
11315: CALL_OW 104
// end ; end ;
11319: PPOPN 3
11321: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11322: LD_VAR 0 1
11326: PPUSH
11327: CALL 109978 0 1
// if un = JMM then
11331: LD_VAR 0 1
11335: PUSH
11336: LD_EXP 19
11340: EQUAL
11341: IFFALSE 11352
// begin YouLost ( JMM ) ;
11343: LD_STRING JMM
11345: PPUSH
11346: CALL_OW 104
// exit ;
11350: GO 11481
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11352: LD_VAR 0 1
11356: PPUSH
11357: CALL_OW 255
11361: PUSH
11362: LD_INT 2
11364: EQUAL
11365: PUSH
11366: LD_EXP 18
11370: NOT
11371: AND
11372: IFFALSE 11382
// arabianAttacked := true ;
11374: LD_ADDR_EXP 18
11378: PUSH
11379: LD_INT 1
11381: ST_TO_ADDR
// if un = Powell then
11382: LD_VAR 0 1
11386: PUSH
11387: LD_EXP 55
11391: EQUAL
11392: IFFALSE 11402
// americanDestroyed := true ;
11394: LD_ADDR_EXP 4
11398: PUSH
11399: LD_INT 1
11401: ST_TO_ADDR
// if un = Platonov then
11402: LD_VAR 0 1
11406: PUSH
11407: LD_EXP 60
11411: EQUAL
11412: IFFALSE 11422
// russianDestroyed := true ;
11414: LD_ADDR_EXP 2
11418: PUSH
11419: LD_INT 1
11421: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 22
11429: PUSH
11430: LD_INT 7
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 21
11439: PUSH
11440: LD_INT 2
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PPUSH
11451: CALL_OW 69
11455: IN
11456: IFFALSE 11472
// vehicleLostCounter := vehicleLostCounter + 1 ;
11458: LD_ADDR_EXP 15
11462: PUSH
11463: LD_EXP 15
11467: PUSH
11468: LD_INT 1
11470: PLUS
11471: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11472: LD_VAR 0 1
11476: PPUSH
11477: CALL 49828 0 1
// end ;
11481: PPOPN 1
11483: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11484: LD_VAR 0 1
11488: PPUSH
11489: LD_VAR 0 2
11493: PPUSH
11494: CALL 52160 0 2
// end ;
11498: PPOPN 2
11500: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11501: LD_VAR 0 1
11505: PPUSH
11506: CALL 51228 0 1
// end ;
11510: PPOPN 1
11512: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 22
11520: PUSH
11521: LD_INT 8
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: PUSH
11528: LD_INT 30
11530: PUSH
11531: LD_INT 2
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: PUSH
11538: LD_INT 23
11540: PUSH
11541: LD_INT 3
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: LIST
11552: PPUSH
11553: CALL_OW 69
11557: IN
11558: IFFALSE 11585
// begin ComUpgrade ( building ) ;
11560: LD_VAR 0 1
11564: PPUSH
11565: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11569: LD_EXP 58
11573: PPUSH
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL 60635 0 2
// exit ;
11583: GO 11594
// end ; MCE_BuildingComplete ( building ) ;
11585: LD_VAR 0 1
11589: PPUSH
11590: CALL 51469 0 1
// end ;
11594: PPOPN 1
11596: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11597: LD_VAR 0 1
11601: PPUSH
11602: LD_VAR 0 2
11606: PPUSH
11607: CALL 49524 0 2
// end ;
11611: PPOPN 2
11613: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11614: LD_VAR 0 1
11618: PPUSH
11619: LD_VAR 0 2
11623: PPUSH
11624: LD_VAR 0 3
11628: PPUSH
11629: LD_VAR 0 4
11633: PPUSH
11634: LD_VAR 0 5
11638: PPUSH
11639: CALL 49144 0 5
// end ;
11643: PPOPN 5
11645: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11646: LD_VAR 0 1
11650: PPUSH
11651: LD_VAR 0 2
11655: PPUSH
11656: CALL 110098 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11660: LD_VAR 0 1
11664: PPUSH
11665: LD_VAR 0 2
11669: PPUSH
11670: CALL 48697 0 2
// end ;
11674: PPOPN 2
11676: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11677: LD_VAR 0 1
11681: PPUSH
11682: LD_VAR 0 2
11686: PPUSH
11687: LD_VAR 0 3
11691: PPUSH
11692: LD_VAR 0 4
11696: PPUSH
11697: CALL 48535 0 4
// end ;
11701: PPOPN 4
11703: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11704: LD_VAR 0 1
11708: PPUSH
11709: LD_VAR 0 2
11713: PPUSH
11714: LD_VAR 0 3
11718: PPUSH
11719: CALL 48310 0 3
// end ;
11723: PPOPN 3
11725: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11726: LD_VAR 0 1
11730: PPUSH
11731: LD_VAR 0 2
11735: PPUSH
11736: CALL 48195 0 2
// end ;
11740: PPOPN 2
11742: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11743: LD_VAR 0 1
11747: PPUSH
11748: LD_VAR 0 2
11752: PPUSH
11753: CALL 52455 0 2
// end ;
11757: PPOPN 2
11759: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11760: LD_VAR 0 1
11764: PUSH
11765: LD_INT 674
11767: EQUAL
11768: IFFALSE 11790
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11770: LD_VAR 0 2
11774: PPUSH
11775: LD_INT 227
11777: PPUSH
11778: LD_INT 136
11780: PPUSH
11781: CALL_OW 428
11785: PPUSH
11786: CALL_OW 120
// end ;
11790: PPOPN 2
11792: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11793: LD_VAR 0 1
11797: PPUSH
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_VAR 0 3
11807: PPUSH
11808: LD_VAR 0 4
11812: PPUSH
11813: CALL 52671 0 4
// end ;
11817: PPOPN 4
11819: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11820: LD_VAR 0 1
11824: PPUSH
11825: LD_VAR 0 2
11829: PPUSH
11830: CALL 48004 0 2
// end ;
11834: PPOPN 2
11836: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11837: LD_VAR 0 1
11841: PPUSH
11842: CALL 110082 0 1
// end ; end_of_file
11846: PPOPN 1
11848: END
// export function Action ; begin
11849: LD_INT 0
11851: PPUSH
// InGameOn ;
11852: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11856: LD_INT 206
11858: PPUSH
11859: LD_INT 11
11861: PPUSH
11862: CALL_OW 86
// wait ( 0 0$1 ) ;
11866: LD_INT 35
11868: PPUSH
11869: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11873: LD_EXP 19
11877: PPUSH
11878: LD_STRING DStart-JMM-JMM-1
11880: PPUSH
11881: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11885: LD_EXP 52
11889: PPUSH
11890: LD_STRING DStart-JMM-Bur-1
11892: PPUSH
11893: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11897: LD_EXP 19
11901: PPUSH
11902: LD_STRING DStart-JMM-JMM-2
11904: PPUSH
11905: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11909: LD_EXP 52
11913: PPUSH
11914: LD_STRING DStart-JMM-Bur-2
11916: PPUSH
11917: CALL_OW 88
// InGameOff ;
11921: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11925: LD_STRING MStart
11927: PPUSH
11928: CALL_OW 337
// SaveForQuickRestart ;
11932: CALL_OW 22
// end ;
11936: LD_VAR 0 1
11940: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11941: LD_INT 7
11943: PPUSH
11944: LD_INT 255
11946: PPUSH
11947: LD_INT 219
11949: PPUSH
11950: CALL_OW 293
11954: IFFALSE 12563
11956: GO 11958
11958: DISABLE
11959: LD_INT 0
11961: PPUSH
// begin wait ( 0 0$3 ) ;
11962: LD_INT 105
11964: PPUSH
11965: CALL_OW 67
// alienSpotted := true ;
11969: LD_ADDR_EXP 10
11973: PUSH
11974: LD_INT 1
11976: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11977: LD_ADDR_VAR 0 1
11981: PUSH
11982: LD_INT 22
11984: PUSH
11985: LD_INT 7
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 23
11994: PUSH
11995: LD_INT 3
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: LD_INT 21
12004: PUSH
12005: LD_INT 1
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 26
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: PPUSH
12028: CALL_OW 69
12032: PUSH
12033: LD_EXP 52
12037: PUSH
12038: LD_EXP 40
12042: PUSH
12043: LD_EXP 42
12047: PUSH
12048: LD_EXP 43
12052: PUSH
12053: LD_EXP 50
12057: PUSH
12058: LD_EXP 49
12062: PUSH
12063: LD_EXP 44
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: LIST
12072: LIST
12073: LIST
12074: LIST
12075: LIST
12076: DIFF
12077: ST_TO_ADDR
// DialogueOn ;
12078: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12082: LD_INT 255
12084: PPUSH
12085: LD_INT 219
12087: PPUSH
12088: LD_INT 7
12090: PPUSH
12091: LD_INT 20
12093: NEG
12094: PPUSH
12095: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12099: LD_INT 255
12101: PPUSH
12102: LD_INT 219
12104: PPUSH
12105: CALL_OW 86
// if speaker then
12109: LD_VAR 0 1
12113: IFFALSE 12131
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12115: LD_VAR 0 1
12119: PUSH
12120: LD_INT 1
12122: ARRAY
12123: PPUSH
12124: LD_STRING DAlienBase-RSol1-1
12126: PPUSH
12127: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12131: LD_EXP 19
12135: PPUSH
12136: LD_STRING DAlienBase-JMM-1
12138: PPUSH
12139: CALL_OW 88
// if IsOk ( Burlak ) then
12143: LD_EXP 52
12147: PPUSH
12148: CALL_OW 302
12152: IFFALSE 12173
// begin dwait ( 0 0$1 ) ;
12154: LD_INT 35
12156: PPUSH
12157: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12161: LD_EXP 52
12165: PPUSH
12166: LD_STRING DAlienBase-Bur-1
12168: PPUSH
12169: CALL_OW 88
// end ; if IsOk ( Roth ) then
12173: LD_EXP 20
12177: PPUSH
12178: CALL_OW 302
12182: IFFALSE 12196
// Say ( Roth , DAlienBase-Roth-1 ) ;
12184: LD_EXP 20
12188: PPUSH
12189: LD_STRING DAlienBase-Roth-1
12191: PPUSH
12192: CALL_OW 88
// if IsOk ( Gossudarov ) then
12196: LD_EXP 38
12200: PPUSH
12201: CALL_OW 302
12205: IFFALSE 12221
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12207: LD_EXP 38
12211: PPUSH
12212: LD_STRING DAlienBase-Gos-1
12214: PPUSH
12215: CALL_OW 88
12219: GO 12338
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12221: LD_ADDR_VAR 0 1
12225: PUSH
12226: LD_INT 22
12228: PUSH
12229: LD_INT 7
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 25
12238: PUSH
12239: LD_INT 4
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 21
12248: PUSH
12249: LD_INT 1
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 26
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: EMPTY
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: PPUSH
12272: CALL_OW 69
12276: PUSH
12277: LD_EXP 20
12281: PUSH
12282: LD_EXP 19
12286: PUSH
12287: LD_EXP 52
12291: PUSH
12292: LD_EXP 40
12296: PUSH
12297: LD_EXP 50
12301: PUSH
12302: LD_EXP 49
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: DIFF
12315: ST_TO_ADDR
// if speaker then
12316: LD_VAR 0 1
12320: IFFALSE 12338
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12322: LD_VAR 0 1
12326: PUSH
12327: LD_INT 1
12329: ARRAY
12330: PPUSH
12331: LD_STRING DAlienBase-Sci1-1
12333: PPUSH
12334: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12338: LD_INT 255
12340: PPUSH
12341: LD_INT 219
12343: PPUSH
12344: LD_INT 7
12346: PPUSH
12347: CALL_OW 331
// DialogueOff ;
12351: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12355: LD_INT 35
12357: PPUSH
12358: CALL_OW 67
// until IsSelected ( alien ) ;
12362: LD_INT 1
12364: PPUSH
12365: CALL_OW 306
12369: IFFALSE 12355
// if not artifactIResearched or not artifactIIResearched then
12371: LD_EXP 12
12375: NOT
12376: PUSH
12377: LD_EXP 13
12381: NOT
12382: OR
12383: IFFALSE 12563
// begin if IsOk ( Roth ) then
12385: LD_EXP 20
12389: PPUSH
12390: CALL_OW 302
12394: IFFALSE 12410
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12396: LD_EXP 20
12400: PPUSH
12401: LD_STRING DAlieBaseNotReady-Roth-1
12403: PPUSH
12404: CALL_OW 88
12408: GO 12563
// if IsOk ( Gossudarov ) then
12410: LD_EXP 38
12414: PPUSH
12415: CALL_OW 302
12419: IFFALSE 12435
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12421: LD_EXP 38
12425: PPUSH
12426: LD_STRING DAlieBaseNotReady-Gos-1
12428: PPUSH
12429: CALL_OW 88
12433: GO 12563
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: LD_INT 22
12442: PUSH
12443: LD_INT 7
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 23
12452: PUSH
12453: LD_INT 3
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 25
12462: PUSH
12463: LD_INT 4
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 21
12472: PUSH
12473: LD_INT 1
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 26
12482: PUSH
12483: LD_INT 1
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: PPUSH
12497: CALL_OW 69
12501: PUSH
12502: LD_EXP 20
12506: PUSH
12507: LD_EXP 19
12511: PUSH
12512: LD_EXP 52
12516: PUSH
12517: LD_EXP 40
12521: PUSH
12522: LD_EXP 50
12526: PUSH
12527: LD_EXP 49
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: DIFF
12540: ST_TO_ADDR
// if speaker then
12541: LD_VAR 0 1
12545: IFFALSE 12563
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12547: LD_VAR 0 1
12551: PUSH
12552: LD_INT 1
12554: ARRAY
12555: PPUSH
12556: LD_STRING DAlieBaseNotReady-RSci1-1
12558: PPUSH
12559: CALL_OW 88
// end ; end ; end ;
12563: PPOPN 1
12565: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12566: LD_INT 24
12568: PPUSH
12569: LD_INT 7
12571: PPUSH
12572: CALL_OW 321
12576: PUSH
12577: LD_INT 2
12579: EQUAL
12580: IFFALSE 13271
12582: GO 12584
12584: DISABLE
12585: LD_INT 0
12587: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12588: LD_ADDR_VAR 0 1
12592: PUSH
12593: LD_INT 22
12595: PUSH
12596: LD_INT 7
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: PUSH
12603: LD_INT 23
12605: PUSH
12606: LD_INT 3
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 25
12615: PUSH
12616: LD_INT 4
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: PUSH
12623: LD_INT 21
12625: PUSH
12626: LD_INT 1
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: PUSH
12633: LD_INT 26
12635: PUSH
12636: LD_INT 1
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: PUSH
12643: EMPTY
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: PPUSH
12650: CALL_OW 69
12654: PUSH
12655: LD_EXP 20
12659: PUSH
12660: LD_EXP 19
12664: PUSH
12665: LD_EXP 52
12669: PUSH
12670: LD_EXP 40
12674: PUSH
12675: LD_EXP 50
12679: PUSH
12680: LD_EXP 49
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: LIST
12689: LIST
12690: LIST
12691: LIST
12692: DIFF
12693: ST_TO_ADDR
// if not speaker then
12694: LD_VAR 0 1
12698: NOT
12699: IFFALSE 12703
// exit ;
12701: GO 13271
// DialogueOn ;
12703: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12707: LD_VAR 0 1
12711: PUSH
12712: LD_INT 1
12714: ARRAY
12715: PPUSH
12716: LD_STRING DArtefTechnology-RSci1-1
12718: PPUSH
12719: CALL_OW 88
// if IsOk ( Burlak ) then
12723: LD_EXP 52
12727: PPUSH
12728: CALL_OW 302
12732: IFFALSE 12746
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12734: LD_EXP 52
12738: PPUSH
12739: LD_STRING DArtefTechnology-Bur-1
12741: PPUSH
12742: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12746: LD_VAR 0 1
12750: PUSH
12751: LD_INT 1
12753: ARRAY
12754: PPUSH
12755: LD_STRING DArtefTechnology-RSci1-2
12757: PPUSH
12758: CALL_OW 88
// if Denis then
12762: LD_EXP 25
12766: IFFALSE 12783
// speaker := [ Denis ] else
12768: LD_ADDR_VAR 0 1
12772: PUSH
12773: LD_EXP 25
12777: PUSH
12778: EMPTY
12779: LIST
12780: ST_TO_ADDR
12781: GO 12889
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12783: LD_ADDR_VAR 0 1
12787: PUSH
12788: LD_INT 22
12790: PUSH
12791: LD_INT 7
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: LD_INT 23
12800: PUSH
12801: LD_INT 1
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 25
12810: PUSH
12811: LD_INT 4
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 21
12820: PUSH
12821: LD_INT 1
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: PUSH
12828: LD_INT 26
12830: PUSH
12831: LD_INT 1
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: PPUSH
12845: CALL_OW 69
12849: PUSH
12850: LD_EXP 20
12854: PUSH
12855: LD_EXP 19
12859: PUSH
12860: LD_EXP 52
12864: PUSH
12865: LD_EXP 40
12869: PUSH
12870: LD_EXP 50
12874: PUSH
12875: LD_EXP 49
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: DIFF
12888: ST_TO_ADDR
// if speaker then
12889: LD_VAR 0 1
12893: IFFALSE 12911
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12895: LD_VAR 0 1
12899: PUSH
12900: LD_INT 1
12902: ARRAY
12903: PPUSH
12904: LD_STRING DArtefTechnology-Sci1-2
12906: PPUSH
12907: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_INT 7
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 23
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 25
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 26
12958: PUSH
12959: LD_INT 1
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_EXP 20
12982: PUSH
12983: LD_EXP 19
12987: PUSH
12988: LD_EXP 52
12992: PUSH
12993: LD_EXP 40
12997: PUSH
12998: LD_EXP 50
13002: PUSH
13003: LD_EXP 49
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: DIFF
13016: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13017: LD_VAR 0 1
13021: PUSH
13022: LD_EXP 9
13026: PUSH
13027: LD_EXP 5
13031: OR
13032: AND
13033: IFFALSE 13267
// begin if arabianDestroyed and IsOk ( Burlak ) then
13035: LD_EXP 5
13039: PUSH
13040: LD_EXP 52
13044: PPUSH
13045: CALL_OW 302
13049: AND
13050: IFFALSE 13066
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13052: LD_EXP 52
13056: PPUSH
13057: LD_STRING DArtefTechnology-Bur-2
13059: PPUSH
13060: CALL_OW 88
13064: GO 13078
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13066: LD_EXP 19
13070: PPUSH
13071: LD_STRING DArtefTechnology-JMM-2
13073: PPUSH
13074: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13078: LD_VAR 0 1
13082: PUSH
13083: LD_INT 1
13085: ARRAY
13086: PPUSH
13087: LD_STRING DArtefTechnology-RSci1-3
13089: PPUSH
13090: CALL_OW 88
// if Denis then
13094: LD_EXP 25
13098: IFFALSE 13115
// speaker := [ Denis ] else
13100: LD_ADDR_VAR 0 1
13104: PUSH
13105: LD_EXP 25
13109: PUSH
13110: EMPTY
13111: LIST
13112: ST_TO_ADDR
13113: GO 13221
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13115: LD_ADDR_VAR 0 1
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 7
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: PUSH
13130: LD_INT 23
13132: PUSH
13133: LD_INT 1
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: PUSH
13140: LD_INT 25
13142: PUSH
13143: LD_INT 4
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: PUSH
13150: LD_INT 21
13152: PUSH
13153: LD_INT 1
13155: PUSH
13156: EMPTY
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 26
13162: PUSH
13163: LD_INT 1
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: PPUSH
13177: CALL_OW 69
13181: PUSH
13182: LD_EXP 20
13186: PUSH
13187: LD_EXP 19
13191: PUSH
13192: LD_EXP 52
13196: PUSH
13197: LD_EXP 40
13201: PUSH
13202: LD_EXP 50
13206: PUSH
13207: LD_EXP 49
13211: PUSH
13212: EMPTY
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: DIFF
13220: ST_TO_ADDR
// if speaker then
13221: LD_VAR 0 1
13225: IFFALSE 13267
// if alienSpotted then
13227: LD_EXP 10
13231: IFFALSE 13251
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13233: LD_VAR 0 1
13237: PUSH
13238: LD_INT 1
13240: ARRAY
13241: PPUSH
13242: LD_STRING DArtefTechnology-Sci1-3
13244: PPUSH
13245: CALL_OW 88
13249: GO 13267
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13251: LD_VAR 0 1
13255: PUSH
13256: LD_INT 1
13258: ARRAY
13259: PPUSH
13260: LD_STRING DArtefTechnology-Sci1-3a
13262: PPUSH
13263: CALL_OW 88
// end ; DialogueOff ;
13267: CALL_OW 7
// end ;
13271: PPOPN 1
13273: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13274: LD_EXP 12
13278: IFFALSE 13481
13280: GO 13282
13282: DISABLE
13283: LD_INT 0
13285: PPUSH
// begin if Denis then
13286: LD_EXP 25
13290: IFFALSE 13307
// speaker := [ Denis ] else
13292: LD_ADDR_VAR 0 1
13296: PUSH
13297: LD_EXP 25
13301: PUSH
13302: EMPTY
13303: LIST
13304: ST_TO_ADDR
13305: GO 13413
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13307: LD_ADDR_VAR 0 1
13311: PUSH
13312: LD_INT 22
13314: PUSH
13315: LD_INT 7
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 23
13324: PUSH
13325: LD_INT 1
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: LD_INT 25
13334: PUSH
13335: LD_INT 4
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PUSH
13342: LD_INT 21
13344: PUSH
13345: LD_INT 1
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: PUSH
13352: LD_INT 26
13354: PUSH
13355: LD_INT 1
13357: PUSH
13358: EMPTY
13359: LIST
13360: LIST
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: PPUSH
13369: CALL_OW 69
13373: PUSH
13374: LD_EXP 20
13378: PUSH
13379: LD_EXP 19
13383: PUSH
13384: LD_EXP 52
13388: PUSH
13389: LD_EXP 40
13393: PUSH
13394: LD_EXP 50
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: DIFF
13412: ST_TO_ADDR
// if not speaker then
13413: LD_VAR 0 1
13417: NOT
13418: IFFALSE 13422
// exit ;
13420: GO 13481
// DialogueOn ;
13422: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13426: LD_VAR 0 1
13430: PUSH
13431: LD_INT 1
13433: ARRAY
13434: PPUSH
13435: LD_STRING DArtefTechnologyAm-Sci1-1
13437: PPUSH
13438: CALL_OW 88
// if IsOk ( Burlak ) then
13442: LD_EXP 52
13446: PPUSH
13447: CALL_OW 302
13451: IFFALSE 13465
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13453: LD_EXP 52
13457: PPUSH
13458: LD_STRING DArtefTechnologyAm-Bur-1
13460: PPUSH
13461: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13465: LD_EXP 19
13469: PPUSH
13470: LD_STRING DArtefTechnologyAm-JMM-1
13472: PPUSH
13473: CALL_OW 88
// DialogueOff ;
13477: CALL_OW 7
// end ;
13481: PPOPN 1
13483: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13484: LD_EXP 13
13488: IFFALSE 13690
13490: GO 13492
13492: DISABLE
13493: LD_INT 0
13495: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13496: LD_ADDR_VAR 0 1
13500: PUSH
13501: LD_INT 22
13503: PUSH
13504: LD_INT 7
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 23
13513: PUSH
13514: LD_INT 3
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PUSH
13521: LD_INT 25
13523: PUSH
13524: LD_INT 4
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: LD_INT 21
13533: PUSH
13534: LD_INT 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 26
13543: PUSH
13544: LD_INT 1
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: PPUSH
13558: CALL_OW 69
13562: PUSH
13563: LD_EXP 20
13567: PUSH
13568: LD_EXP 19
13572: PUSH
13573: LD_EXP 52
13577: PUSH
13578: LD_EXP 40
13582: PUSH
13583: LD_EXP 50
13587: PUSH
13588: LD_EXP 49
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: DIFF
13601: ST_TO_ADDR
// if not speaker then
13602: LD_VAR 0 1
13606: NOT
13607: IFFALSE 13611
// exit ;
13609: GO 13690
// DialogueOn ;
13611: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13615: LD_VAR 0 1
13619: PUSH
13620: LD_VAR 0 1
13624: ARRAY
13625: PPUSH
13626: LD_STRING DArtefTechnologyRu-RSci1-1
13628: PPUSH
13629: CALL_OW 88
// if IsOk ( Burlak ) then
13633: LD_EXP 52
13637: PPUSH
13638: CALL_OW 302
13642: IFFALSE 13656
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13644: LD_EXP 52
13648: PPUSH
13649: LD_STRING DArtefTechnologyRu-Bur-1
13651: PPUSH
13652: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13656: LD_VAR 0 1
13660: PUSH
13661: LD_VAR 0 1
13665: ARRAY
13666: PPUSH
13667: LD_STRING DArtefTechnologyRu-RSci1-2
13669: PPUSH
13670: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13674: LD_EXP 19
13678: PPUSH
13679: LD_STRING DArtefTechnologyRu-JMM-1
13681: PPUSH
13682: CALL_OW 88
// DialogueOff ;
13686: CALL_OW 7
// end ;
13690: PPOPN 1
13692: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13693: LD_INT 24
13695: PPUSH
13696: LD_INT 7
13698: PPUSH
13699: CALL_OW 321
13703: PUSH
13704: LD_INT 2
13706: EQUAL
13707: PUSH
13708: LD_INT 1
13710: PPUSH
13711: CALL_OW 255
13715: PUSH
13716: LD_INT 7
13718: EQUAL
13719: AND
13720: IFFALSE 13888
13722: GO 13724
13724: DISABLE
13725: LD_INT 0
13727: PPUSH
// begin if Denis then
13728: LD_EXP 25
13732: IFFALSE 13749
// speaker := [ Denis ] else
13734: LD_ADDR_VAR 0 1
13738: PUSH
13739: LD_EXP 25
13743: PUSH
13744: EMPTY
13745: LIST
13746: ST_TO_ADDR
13747: GO 13855
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13749: LD_ADDR_VAR 0 1
13753: PUSH
13754: LD_INT 22
13756: PUSH
13757: LD_INT 7
13759: PUSH
13760: EMPTY
13761: LIST
13762: LIST
13763: PUSH
13764: LD_INT 23
13766: PUSH
13767: LD_INT 1
13769: PUSH
13770: EMPTY
13771: LIST
13772: LIST
13773: PUSH
13774: LD_INT 25
13776: PUSH
13777: LD_INT 4
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PUSH
13784: LD_INT 21
13786: PUSH
13787: LD_INT 1
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: PUSH
13794: LD_INT 26
13796: PUSH
13797: LD_INT 1
13799: PUSH
13800: EMPTY
13801: LIST
13802: LIST
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: PPUSH
13811: CALL_OW 69
13815: PUSH
13816: LD_EXP 20
13820: PUSH
13821: LD_EXP 19
13825: PUSH
13826: LD_EXP 52
13830: PUSH
13831: LD_EXP 40
13835: PUSH
13836: LD_EXP 50
13840: PUSH
13841: LD_EXP 49
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: DIFF
13854: ST_TO_ADDR
// if not speaker then
13855: LD_VAR 0 1
13859: NOT
13860: IFFALSE 13864
// exit ;
13862: GO 13888
// DialogueOn ;
13864: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13868: LD_VAR 0 1
13872: PUSH
13873: LD_INT 1
13875: ARRAY
13876: PPUSH
13877: LD_STRING DArtefTechnologyArStart-Sci1-1
13879: PPUSH
13880: CALL_OW 88
// DialogueOff ;
13884: CALL_OW 7
// end ;
13888: PPOPN 1
13890: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13891: LD_EXP 14
13895: IFFALSE 14176
13897: GO 13899
13899: DISABLE
13900: LD_INT 0
13902: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13903: LD_ADDR_VAR 0 1
13907: PUSH
13908: LD_INT 22
13910: PUSH
13911: LD_INT 7
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: PUSH
13918: LD_INT 23
13920: PUSH
13921: LD_INT 3
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 25
13930: PUSH
13931: LD_INT 4
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: PUSH
13938: LD_INT 21
13940: PUSH
13941: LD_INT 1
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PUSH
13948: LD_INT 26
13950: PUSH
13951: LD_INT 1
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: PPUSH
13965: CALL_OW 69
13969: PUSH
13970: LD_EXP 20
13974: PUSH
13975: LD_EXP 19
13979: PUSH
13980: LD_EXP 52
13984: PUSH
13985: LD_EXP 40
13989: PUSH
13990: LD_EXP 50
13994: PUSH
13995: LD_EXP 49
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: DIFF
14008: ST_TO_ADDR
// if not speaker then
14009: LD_VAR 0 1
14013: NOT
14014: IFFALSE 14018
// exit ;
14016: GO 14176
// DialogueOn ;
14018: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14022: LD_VAR 0 1
14026: PUSH
14027: LD_INT 1
14029: ARRAY
14030: PPUSH
14031: LD_STRING DArtefTechnologyAr-RSci1-1
14033: PPUSH
14034: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14038: LD_EXP 19
14042: PPUSH
14043: LD_STRING DArtefTechnologyAr-JMM-1
14045: PPUSH
14046: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14050: LD_VAR 0 1
14054: PUSH
14055: LD_INT 1
14057: ARRAY
14058: PPUSH
14059: LD_STRING DArtefTechnologyAr-RSci1-2
14061: PPUSH
14062: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14066: LD_EXP 19
14070: PPUSH
14071: LD_STRING DArtefTechnologyAr-JMM-2
14073: PPUSH
14074: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14078: LD_VAR 0 1
14082: PUSH
14083: LD_INT 1
14085: ARRAY
14086: PPUSH
14087: LD_STRING DArtefTechnologyAr-RSci1-3
14089: PPUSH
14090: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14094: LD_EXP 19
14098: PPUSH
14099: LD_STRING DArtefTechnologyAr-JMM-3
14101: PPUSH
14102: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14106: LD_VAR 0 1
14110: PUSH
14111: LD_INT 1
14113: ARRAY
14114: PPUSH
14115: LD_STRING DArtefTechnologyAr-RSci1-4
14117: PPUSH
14118: CALL_OW 88
// if IsOk ( Burlak ) then
14122: LD_EXP 52
14126: PPUSH
14127: CALL_OW 302
14131: IFFALSE 14145
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14133: LD_EXP 52
14137: PPUSH
14138: LD_STRING DArtefTechnologyAr-Bur-4
14140: PPUSH
14141: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14145: LD_EXP 19
14149: PPUSH
14150: LD_STRING DArtefTechnologyAr-JMM-4
14152: PPUSH
14153: CALL_OW 88
// DialogueOff ;
14157: CALL_OW 7
// wait ( 0 0$45 ) ;
14161: LD_INT 1575
14163: PPUSH
14164: CALL_OW 67
// spawnOmar := true ;
14168: LD_ADDR_EXP 11
14172: PUSH
14173: LD_INT 1
14175: ST_TO_ADDR
// end ;
14176: PPOPN 1
14178: END
// every 0 0$1 trigger spawnOmar do
14179: LD_EXP 11
14183: IFFALSE 14563
14185: GO 14187
14187: DISABLE
// begin PrepareOmarAli ;
14188: CALL 7332 0 0
// if not HasTask ( Omar ) then
14192: LD_EXP 56
14196: PPUSH
14197: CALL_OW 314
14201: NOT
14202: IFFALSE 14219
// ComMoveXY ( Omar , 252 , 220 ) ;
14204: LD_EXP 56
14208: PPUSH
14209: LD_INT 252
14211: PPUSH
14212: LD_INT 220
14214: PPUSH
14215: CALL_OW 111
// if not Omar then
14219: LD_EXP 56
14223: NOT
14224: IFFALSE 14228
// exit ;
14226: GO 14563
// repeat wait ( 0 0$1 ) ;
14228: LD_INT 35
14230: PPUSH
14231: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14235: LD_EXP 56
14239: PPUSH
14240: CALL_OW 314
14244: NOT
14245: PUSH
14246: LD_EXP 56
14250: PPUSH
14251: LD_INT 252
14253: PPUSH
14254: LD_INT 220
14256: PPUSH
14257: CALL_OW 297
14261: PUSH
14262: LD_INT 6
14264: GREATER
14265: AND
14266: IFFALSE 14283
// ComMoveXY ( Omar , 252 , 220 ) ;
14268: LD_EXP 56
14272: PPUSH
14273: LD_INT 252
14275: PPUSH
14276: LD_INT 220
14278: PPUSH
14279: CALL_OW 111
// until See ( 7 , Omar ) ;
14283: LD_INT 7
14285: PPUSH
14286: LD_EXP 56
14290: PPUSH
14291: CALL_OW 292
14295: IFFALSE 14228
// CenterNowOnUnits ( Omar ) ;
14297: LD_EXP 56
14301: PPUSH
14302: CALL_OW 87
// DialogueOn ;
14306: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14310: LD_EXP 56
14314: PPUSH
14315: LD_STRING DOmar-Omar-1
14317: PPUSH
14318: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14322: LD_EXP 19
14326: PPUSH
14327: LD_STRING DOmar-JMM-1
14329: PPUSH
14330: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14334: LD_EXP 56
14338: PPUSH
14339: LD_STRING DOmar-Omar-2
14341: PPUSH
14342: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14346: LD_EXP 19
14350: PPUSH
14351: LD_STRING DOmar-JMM-2
14353: PPUSH
14354: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14358: LD_EXP 56
14362: PPUSH
14363: LD_STRING DOmar-Omar-3
14365: PPUSH
14366: CALL_OW 88
// if IsOk ( Burlak ) then
14370: LD_EXP 52
14374: PPUSH
14375: CALL_OW 302
14379: IFFALSE 14395
// Say ( Burlak , DOmar-Bur-3 ) else
14381: LD_EXP 52
14385: PPUSH
14386: LD_STRING DOmar-Bur-3
14388: PPUSH
14389: CALL_OW 88
14393: GO 14407
// Say ( JMM , DOmar-JMM-3 ) ;
14395: LD_EXP 19
14399: PPUSH
14400: LD_STRING DOmar-JMM-3
14402: PPUSH
14403: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14407: LD_EXP 56
14411: PPUSH
14412: LD_STRING DOmar-Omar-4
14414: PPUSH
14415: CALL_OW 88
// case Query ( QAccept ) of 1 :
14419: LD_STRING QAccept
14421: PPUSH
14422: CALL_OW 97
14426: PUSH
14427: LD_INT 1
14429: DOUBLE
14430: EQUAL
14431: IFTRUE 14435
14433: GO 14471
14435: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14436: LD_EXP 19
14440: PPUSH
14441: LD_STRING DQrAccept#1-JMM-1
14443: PPUSH
14444: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14448: LD_EXP 56
14452: PPUSH
14453: LD_INT 7
14455: PPUSH
14456: CALL_OW 235
// ComStop ( Omar ) ;
14460: LD_EXP 56
14464: PPUSH
14465: CALL_OW 141
// end ; 2 :
14469: GO 14520
14471: LD_INT 2
14473: DOUBLE
14474: EQUAL
14475: IFTRUE 14479
14477: GO 14519
14479: POP
// begin if IsOk ( Burlak ) then
14480: LD_EXP 52
14484: PPUSH
14485: CALL_OW 302
14489: IFFALSE 14505
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14491: LD_EXP 52
14495: PPUSH
14496: LD_STRING DQrAccept#2-Bur-1
14498: PPUSH
14499: CALL_OW 88
14503: GO 14517
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14505: LD_EXP 19
14509: PPUSH
14510: LD_STRING DQrAccept#2-JMM-1
14512: PPUSH
14513: CALL_OW 88
// end ; end ;
14517: GO 14520
14519: POP
// DialogueOff ;
14520: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14524: LD_EXP 56
14528: PPUSH
14529: CALL_OW 255
14533: PUSH
14534: LD_INT 7
14536: EQUAL
14537: IFFALSE 14548
// begin SetAchievement ( ACH_OMAR ) ;
14539: LD_STRING ACH_OMAR
14541: PPUSH
14542: CALL_OW 543
// exit ;
14546: GO 14563
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14548: LD_EXP 56
14552: PPUSH
14553: LD_INT 202
14555: PPUSH
14556: LD_INT 115
14558: PPUSH
14559: CALL_OW 111
// end ;
14563: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed do var i ;
14564: LD_EXP 56
14568: PPUSH
14569: CALL_OW 302
14573: PUSH
14574: LD_EXP 2
14578: AND
14579: IFFALSE 15064
14581: GO 14583
14583: DISABLE
14584: LD_INT 0
14586: PPUSH
// begin SetSide ( Omar , 5 ) ;
14587: LD_EXP 56
14591: PPUSH
14592: LD_INT 5
14594: PPUSH
14595: CALL_OW 235
// if IsInUnit ( Omar ) then
14599: LD_EXP 56
14603: PPUSH
14604: CALL_OW 310
14608: IFFALSE 14619
// ComExitVehicle ( Omar ) ;
14610: LD_EXP 56
14614: PPUSH
14615: CALL_OW 121
// if IsInUnit ( Omar ) then
14619: LD_EXP 56
14623: PPUSH
14624: CALL_OW 310
14628: IFFALSE 14639
// ComExitBuilding ( Omar ) ;
14630: LD_EXP 56
14634: PPUSH
14635: CALL_OW 122
// wait ( 0 0$1 ) ;
14639: LD_INT 35
14641: PPUSH
14642: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14646: LD_EXP 56
14650: PPUSH
14651: LD_INT 203
14653: PPUSH
14654: LD_INT 120
14656: PPUSH
14657: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14661: LD_INT 35
14663: PPUSH
14664: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
14668: LD_EXP 56
14672: PPUSH
14673: CALL_OW 306
14677: PUSH
14678: LD_EXP 56
14682: PPUSH
14683: LD_INT 203
14685: PPUSH
14686: LD_INT 120
14688: PPUSH
14689: CALL_OW 297
14693: PUSH
14694: LD_INT 20
14696: LESS
14697: OR
14698: IFFALSE 14661
// DialogueOn ;
14700: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
14704: LD_EXP 56
14708: PPUSH
14709: CALL_OW 250
14713: PPUSH
14714: LD_EXP 56
14718: PPUSH
14719: CALL_OW 251
14723: PPUSH
14724: LD_INT 7
14726: PPUSH
14727: LD_INT 6
14729: NEG
14730: PPUSH
14731: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
14735: LD_EXP 56
14739: PPUSH
14740: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
14744: LD_EXP 19
14748: PPUSH
14749: LD_STRING DOmarContam-JMM-1
14751: PPUSH
14752: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14756: LD_EXP 56
14760: PPUSH
14761: LD_STRING DOmarContam-Omar-1
14763: PPUSH
14764: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14768: LD_EXP 19
14772: PPUSH
14773: LD_STRING DOmarContam-JMM-2
14775: PPUSH
14776: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
14780: LD_EXP 56
14784: PPUSH
14785: CALL_OW 250
14789: PPUSH
14790: LD_EXP 56
14794: PPUSH
14795: CALL_OW 251
14799: PPUSH
14800: LD_INT 7
14802: PPUSH
14803: CALL_OW 331
// DialogueOff ;
14807: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14811: LD_INT 5
14813: PPUSH
14814: LD_INT 7
14816: PPUSH
14817: LD_INT 2
14819: PPUSH
14820: LD_INT 1
14822: PPUSH
14823: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14827: LD_INT 105
14829: PPUSH
14830: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14834: LD_EXP 56
14838: PPUSH
14839: LD_INT 203
14841: PPUSH
14842: LD_INT 120
14844: PPUSH
14845: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
14849: LD_EXP 56
14853: PPUSH
14854: LD_INT 203
14856: PPUSH
14857: LD_INT 120
14859: PPUSH
14860: CALL_OW 307
14864: IFFALSE 14827
// ComHold ( Omar ) ;
14866: LD_EXP 56
14870: PPUSH
14871: CALL_OW 140
// InGameOn ;
14875: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
14879: LD_INT 203
14881: PPUSH
14882: LD_INT 120
14884: PPUSH
14885: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
14889: LD_INT 203
14891: PPUSH
14892: LD_INT 120
14894: PPUSH
14895: LD_INT 7
14897: PPUSH
14898: LD_INT 30
14900: NEG
14901: PPUSH
14902: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
14906: LD_ADDR_VAR 0 1
14910: PUSH
14911: LD_INT 203
14913: PUSH
14914: LD_INT 120
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PUSH
14921: LD_INT 202
14923: PUSH
14924: LD_INT 125
14926: PUSH
14927: EMPTY
14928: LIST
14929: LIST
14930: PUSH
14931: LD_INT 195
14933: PUSH
14934: LD_INT 117
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PUSH
14941: LD_INT 216
14943: PUSH
14944: LD_INT 123
14946: PUSH
14947: EMPTY
14948: LIST
14949: LIST
14950: PUSH
14951: LD_INT 224
14953: PUSH
14954: LD_INT 131
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: LD_INT 212
14963: PUSH
14964: LD_INT 133
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: LIST
14978: PUSH
14979: FOR_IN
14980: IFFALSE 15016
// begin wait ( 0 0$0.5 ) ;
14982: LD_INT 18
14984: PPUSH
14985: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
14989: LD_VAR 0 1
14993: PUSH
14994: LD_INT 1
14996: ARRAY
14997: PPUSH
14998: LD_VAR 0 1
15002: PUSH
15003: LD_INT 2
15005: ARRAY
15006: PPUSH
15007: LD_INT 5
15009: PPUSH
15010: CALL_OW 495
// end ;
15014: GO 14979
15016: POP
15017: POP
// KillUnit ( Omar ) ;
15018: LD_EXP 56
15022: PPUSH
15023: CALL_OW 66
// wait ( 0 0$3 ) ;
15027: LD_INT 105
15029: PPUSH
15030: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15034: LD_EXP 19
15038: PPUSH
15039: LD_STRING D16b-JMM-1
15041: PPUSH
15042: CALL_OW 91
// wait ( 0 0$2 ) ;
15046: LD_INT 70
15048: PPUSH
15049: CALL_OW 67
// InGameOff ;
15053: CALL_OW 9
// YouLost ( MothContaminate ) ;
15057: LD_STRING MothContaminate
15059: PPUSH
15060: CALL_OW 104
// end ;
15064: PPOPN 1
15066: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15067: LD_EXP 4
15071: NOT
15072: PUSH
15073: LD_INT 22
15075: PUSH
15076: LD_INT 1
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 8
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: PPUSH
15097: CALL_OW 69
15101: AND
15102: IFFALSE 15221
15104: GO 15106
15106: DISABLE
// begin wait ( 0 0$10 ) ;
15107: LD_INT 350
15109: PPUSH
15110: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15114: LD_EXP 55
15118: PPUSH
15119: CALL_OW 302
15123: NOT
15124: PUSH
15125: LD_INT 22
15127: PUSH
15128: LD_INT 1
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 34
15137: PUSH
15138: LD_INT 8
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: NOT
15154: OR
15155: IFFALSE 15159
// exit ;
15157: GO 15221
// DialogueOn ;
15159: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15163: LD_EXP 55
15167: PPUSH
15168: LD_STRING DWinAmericans-Pow-1
15170: PPUSH
15171: CALL_OW 94
// if IsOk ( Burlak ) then
15175: LD_EXP 52
15179: PPUSH
15180: CALL_OW 302
15184: IFFALSE 15198
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15186: LD_EXP 52
15190: PPUSH
15191: LD_STRING DWinAmericans-Bur-1
15193: PPUSH
15194: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15198: LD_EXP 19
15202: PPUSH
15203: LD_STRING DWinAmericans-JMM-1
15205: PPUSH
15206: CALL_OW 88
// DialogueOff ;
15210: CALL_OW 7
// YouLost ( AmBomb ) ;
15214: LD_STRING AmBomb
15216: PPUSH
15217: CALL_OW 104
// end ;
15221: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15222: LD_EXP 2
15226: NOT
15227: PUSH
15228: LD_INT 22
15230: PUSH
15231: LD_INT 3
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: PUSH
15238: LD_INT 34
15240: PUSH
15241: LD_INT 48
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: PPUSH
15252: CALL_OW 69
15256: AND
15257: IFFALSE 15376
15259: GO 15261
15261: DISABLE
// begin wait ( 0 0$10 ) ;
15262: LD_INT 350
15264: PPUSH
15265: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15269: LD_EXP 60
15273: PPUSH
15274: CALL_OW 302
15278: NOT
15279: PUSH
15280: LD_INT 22
15282: PUSH
15283: LD_INT 3
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PUSH
15290: LD_INT 34
15292: PUSH
15293: LD_INT 48
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PPUSH
15304: CALL_OW 69
15308: NOT
15309: OR
15310: IFFALSE 15314
// exit ;
15312: GO 15376
// DialogueOn ;
15314: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15318: LD_EXP 60
15322: PPUSH
15323: LD_STRING DWinRussians-Pla-1
15325: PPUSH
15326: CALL_OW 94
// if IsOk ( Burlak ) then
15330: LD_EXP 52
15334: PPUSH
15335: CALL_OW 302
15339: IFFALSE 15353
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15341: LD_EXP 52
15345: PPUSH
15346: LD_STRING DWinRussians-Bur-1
15348: PPUSH
15349: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15353: LD_EXP 19
15357: PPUSH
15358: LD_STRING DWinRussians-JMM-1
15360: PPUSH
15361: CALL_OW 88
// DialogueOff ;
15365: CALL_OW 7
// YouLost ( RuBomb ) ;
15369: LD_STRING RuBomb
15371: PPUSH
15372: CALL_OW 104
// end ;
15376: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15377: LD_INT 7
15379: PPUSH
15380: LD_INT 22
15382: PUSH
15383: LD_INT 7
15385: PUSH
15386: EMPTY
15387: LIST
15388: LIST
15389: PPUSH
15390: CALL_OW 70
15394: PUSH
15395: LD_EXP 4
15399: NOT
15400: AND
15401: IFFALSE 15430
15403: GO 15405
15405: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15406: LD_EXP 55
15410: PPUSH
15411: LD_STRING DSurrenderAmericans-Pow-1
15413: PPUSH
15414: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15418: LD_EXP 19
15422: PPUSH
15423: LD_STRING DSurrenderAmericans-JMM-1
15425: PPUSH
15426: CALL_OW 88
// end ;
15430: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15431: LD_INT 2
15433: PPUSH
15434: LD_INT 22
15436: PUSH
15437: LD_INT 7
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL_OW 70
15448: PUSH
15449: LD_EXP 2
15453: NOT
15454: AND
15455: PUSH
15456: LD_EXP 52
15460: AND
15461: IFFALSE 15490
15463: GO 15465
15465: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15466: LD_EXP 60
15470: PPUSH
15471: LD_STRING DSurrenderRussians-Pla-1
15473: PPUSH
15474: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15478: LD_EXP 52
15482: PPUSH
15483: LD_STRING DSurrenderRussians-Bur-1
15485: PPUSH
15486: CALL_OW 88
// end ;
15490: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15491: LD_EXP 4
15495: IFFALSE 15927
15497: GO 15499
15499: DISABLE
15500: LD_INT 0
15502: PPUSH
15503: PPUSH
15504: PPUSH
// begin MC_Kill ( 4 ) ;
15505: LD_INT 4
15507: PPUSH
15508: CALL 22375 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15512: LD_INT 1
15514: PPUSH
15515: LD_INT 7
15517: PPUSH
15518: LD_INT 1
15520: PPUSH
15521: LD_INT 1
15523: PPUSH
15524: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15528: LD_ADDR_VAR 0 3
15532: PUSH
15533: LD_INT 22
15535: PUSH
15536: LD_INT 1
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: PUSH
15543: LD_INT 26
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: EMPTY
15550: LIST
15551: LIST
15552: PUSH
15553: LD_INT 23
15555: PUSH
15556: LD_INT 1
15558: PUSH
15559: EMPTY
15560: LIST
15561: LIST
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: LIST
15567: PPUSH
15568: CALL_OW 69
15572: PUSH
15573: LD_EXP 55
15577: PUSH
15578: LD_EXP 27
15582: PUSH
15583: LD_EXP 24
15587: PUSH
15588: LD_EXP 23
15592: PUSH
15593: LD_EXP 30
15597: PUSH
15598: LD_EXP 28
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: DIFF
15611: ST_TO_ADDR
// if not speaker then
15612: LD_VAR 0 3
15616: NOT
15617: IFFALSE 15657
// begin uc_side := 1 ;
15619: LD_ADDR_OWVAR 20
15623: PUSH
15624: LD_INT 1
15626: ST_TO_ADDR
// uc_nation := 1 ;
15627: LD_ADDR_OWVAR 21
15631: PUSH
15632: LD_INT 1
15634: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
15635: LD_INT 1
15637: PPUSH
15638: LD_INT 0
15640: PPUSH
15641: CALL_OW 381
// speaker := CreateHuman ;
15645: LD_ADDR_VAR 0 3
15649: PUSH
15650: CALL_OW 44
15654: ST_TO_ADDR
// end else
15655: GO 15671
// speaker := speaker [ 1 ] ;
15657: LD_ADDR_VAR 0 3
15661: PUSH
15662: LD_VAR 0 3
15666: PUSH
15667: LD_INT 1
15669: ARRAY
15670: ST_TO_ADDR
// DialogueOn ;
15671: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
15675: LD_VAR 0 3
15679: PPUSH
15680: LD_STRING DSurrenderAmericans-Sol1-1a
15682: PPUSH
15683: CALL_OW 94
// DialogueOff ;
15687: CALL_OW 7
// americanCapitulated := true ;
15691: LD_ADDR_EXP 6
15695: PUSH
15696: LD_INT 1
15698: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15699: LD_ADDR_VAR 0 2
15703: PUSH
15704: LD_INT 22
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: LD_INT 21
15716: PUSH
15717: LD_INT 1
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: EMPTY
15725: LIST
15726: LIST
15727: PPUSH
15728: CALL_OW 69
15732: PUSH
15733: LD_INT 22
15735: PUSH
15736: LD_INT 1
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: LD_INT 21
15745: PUSH
15746: LD_INT 2
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 1
15755: PUSH
15756: EMPTY
15757: LIST
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: LIST
15763: PPUSH
15764: CALL_OW 69
15768: ADD
15769: ST_TO_ADDR
// if tmp then
15770: LD_VAR 0 2
15774: IFFALSE 15927
// repeat wait ( 0 0$1 ) ;
15776: LD_INT 35
15778: PPUSH
15779: CALL_OW 67
// for i in tmp do
15783: LD_ADDR_VAR 0 1
15787: PUSH
15788: LD_VAR 0 2
15792: PUSH
15793: FOR_IN
15794: IFFALSE 15876
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15796: LD_VAR 0 1
15800: PPUSH
15801: CALL_OW 310
15805: PUSH
15806: LD_VAR 0 1
15810: PPUSH
15811: CALL_OW 310
15815: PPUSH
15816: CALL_OW 247
15820: PUSH
15821: LD_INT 3
15823: EQUAL
15824: AND
15825: IFFALSE 15836
// ComExitBuilding ( i ) ;
15827: LD_VAR 0 1
15831: PPUSH
15832: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15836: LD_VAR 0 1
15840: PPUSH
15841: LD_INT 122
15843: PPUSH
15844: LD_INT 242
15846: PPUSH
15847: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15851: LD_VAR 0 1
15855: PPUSH
15856: LD_INT 35
15858: PPUSH
15859: CALL_OW 308
15863: IFFALSE 15874
// RemoveUnit ( i ) ;
15865: LD_VAR 0 1
15869: PPUSH
15870: CALL_OW 64
// end ;
15874: GO 15793
15876: POP
15877: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15878: LD_INT 22
15880: PUSH
15881: LD_INT 1
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: PUSH
15888: LD_INT 2
15890: PUSH
15891: LD_INT 21
15893: PUSH
15894: LD_INT 1
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: LD_INT 33
15903: PUSH
15904: LD_INT 1
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: EMPTY
15912: LIST
15913: LIST
15914: LIST
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: PPUSH
15920: CALL_OW 69
15924: NOT
15925: IFFALSE 15776
// end ;
15927: PPOPN 3
15929: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15930: LD_EXP 2
15934: IFFALSE 16376
15936: GO 15938
15938: DISABLE
15939: LD_INT 0
15941: PPUSH
15942: PPUSH
15943: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15944: LD_INT 35
15946: PPUSH
15947: CALL_OW 67
// until IsDead ( Yakotich ) ;
15951: LD_EXP 61
15955: PPUSH
15956: CALL_OW 301
15960: IFFALSE 15944
// MC_Kill ( 2 ) ;
15962: LD_INT 2
15964: PPUSH
15965: CALL 22375 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15969: LD_INT 3
15971: PPUSH
15972: LD_INT 7
15974: PPUSH
15975: LD_INT 1
15977: PPUSH
15978: LD_INT 1
15980: PPUSH
15981: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
15985: LD_ADDR_VAR 0 3
15989: PUSH
15990: LD_INT 22
15992: PUSH
15993: LD_INT 3
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PUSH
16000: LD_INT 26
16002: PUSH
16003: LD_INT 1
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PUSH
16010: LD_INT 23
16012: PUSH
16013: LD_INT 3
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: LIST
16024: PPUSH
16025: CALL_OW 69
16029: PUSH
16030: LD_EXP 60
16034: DIFF
16035: ST_TO_ADDR
// if not speaker then
16036: LD_VAR 0 3
16040: NOT
16041: IFFALSE 16081
// begin uc_side := 3 ;
16043: LD_ADDR_OWVAR 20
16047: PUSH
16048: LD_INT 3
16050: ST_TO_ADDR
// uc_nation := 3 ;
16051: LD_ADDR_OWVAR 21
16055: PUSH
16056: LD_INT 3
16058: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16059: LD_INT 1
16061: PPUSH
16062: LD_INT 0
16064: PPUSH
16065: CALL_OW 381
// speaker := CreateHuman ;
16069: LD_ADDR_VAR 0 3
16073: PUSH
16074: CALL_OW 44
16078: ST_TO_ADDR
// end else
16079: GO 16095
// speaker := speaker [ 1 ] ;
16081: LD_ADDR_VAR 0 3
16085: PUSH
16086: LD_VAR 0 3
16090: PUSH
16091: LD_INT 1
16093: ARRAY
16094: ST_TO_ADDR
// DialogueOn ;
16095: CALL_OW 6
// if IsOK ( Burlak ) then
16099: LD_EXP 52
16103: PPUSH
16104: CALL_OW 302
16108: IFFALSE 16124
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16110: LD_VAR 0 3
16114: PPUSH
16115: LD_STRING DSurrenderRussians-RSol1-1
16117: PPUSH
16118: CALL_OW 94
16122: GO 16136
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16124: LD_VAR 0 3
16128: PPUSH
16129: LD_STRING DSurrenderRussians-RSol1-1a
16131: PPUSH
16132: CALL_OW 94
// DialogueOff ;
16136: CALL_OW 7
// russianCapitulated := true ;
16140: LD_ADDR_EXP 7
16144: PUSH
16145: LD_INT 1
16147: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_INT 22
16155: PUSH
16156: LD_INT 3
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: PUSH
16163: LD_INT 21
16165: PUSH
16166: LD_INT 1
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PPUSH
16177: CALL_OW 69
16181: PUSH
16182: LD_INT 22
16184: PUSH
16185: LD_INT 3
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PUSH
16192: LD_INT 21
16194: PUSH
16195: LD_INT 2
16197: PUSH
16198: EMPTY
16199: LIST
16200: LIST
16201: PUSH
16202: LD_INT 1
16204: PUSH
16205: EMPTY
16206: LIST
16207: PUSH
16208: EMPTY
16209: LIST
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 69
16217: ADD
16218: ST_TO_ADDR
// if tmp then
16219: LD_VAR 0 2
16223: IFFALSE 16376
// repeat wait ( 0 0$1 ) ;
16225: LD_INT 35
16227: PPUSH
16228: CALL_OW 67
// for i in tmp do
16232: LD_ADDR_VAR 0 1
16236: PUSH
16237: LD_VAR 0 2
16241: PUSH
16242: FOR_IN
16243: IFFALSE 16325
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16245: LD_VAR 0 1
16249: PPUSH
16250: CALL_OW 310
16254: PUSH
16255: LD_VAR 0 1
16259: PPUSH
16260: CALL_OW 310
16264: PPUSH
16265: CALL_OW 247
16269: PUSH
16270: LD_INT 3
16272: EQUAL
16273: AND
16274: IFFALSE 16285
// ComExitBuilding ( i ) ;
16276: LD_VAR 0 1
16280: PPUSH
16281: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16285: LD_VAR 0 1
16289: PPUSH
16290: LD_INT 154
16292: PPUSH
16293: LD_INT 1
16295: PPUSH
16296: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16300: LD_VAR 0 1
16304: PPUSH
16305: LD_INT 36
16307: PPUSH
16308: CALL_OW 308
16312: IFFALSE 16323
// RemoveUnit ( i ) ;
16314: LD_VAR 0 1
16318: PPUSH
16319: CALL_OW 64
// end ;
16323: GO 16242
16325: POP
16326: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16327: LD_INT 22
16329: PUSH
16330: LD_INT 3
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: LD_INT 2
16339: PUSH
16340: LD_INT 21
16342: PUSH
16343: LD_INT 1
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: PUSH
16350: LD_INT 33
16352: PUSH
16353: LD_INT 1
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: LIST
16364: PUSH
16365: EMPTY
16366: LIST
16367: LIST
16368: PPUSH
16369: CALL_OW 69
16373: NOT
16374: IFFALSE 16225
// end ;
16376: PPOPN 3
16378: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16379: LD_INT 22
16381: PUSH
16382: LD_INT 8
16384: PUSH
16385: EMPTY
16386: LIST
16387: LIST
16388: PUSH
16389: LD_INT 21
16391: PUSH
16392: LD_INT 1
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: LD_INT 23
16401: PUSH
16402: LD_INT 2
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: LIST
16413: PPUSH
16414: CALL_OW 69
16418: PUSH
16419: LD_INT 18
16421: LESS
16422: PUSH
16423: LD_EXP 58
16427: PPUSH
16428: CALL_OW 301
16432: OR
16433: PUSH
16434: LD_INT 324
16436: PPUSH
16437: CALL_OW 255
16441: PUSH
16442: LD_INT 7
16444: EQUAL
16445: OR
16446: IFFALSE 16459
16448: GO 16450
16450: DISABLE
// legionDestroyed := true ;
16451: LD_ADDR_EXP 3
16455: PUSH
16456: LD_INT 1
16458: ST_TO_ADDR
16459: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16460: LD_INT 22
16462: PUSH
16463: LD_INT 2
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PUSH
16470: LD_INT 21
16472: PUSH
16473: LD_INT 1
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PUSH
16480: LD_INT 23
16482: PUSH
16483: LD_INT 2
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: LIST
16494: PPUSH
16495: CALL_OW 69
16499: PUSH
16500: LD_INT 9
16502: LESS
16503: PUSH
16504: LD_INT 503
16506: PPUSH
16507: CALL_OW 301
16511: OR
16512: PUSH
16513: LD_INT 503
16515: PPUSH
16516: CALL_OW 255
16520: PUSH
16521: LD_INT 7
16523: EQUAL
16524: OR
16525: IFFALSE 16538
16527: GO 16529
16529: DISABLE
// arabianDestroyed := true ;
16530: LD_ADDR_EXP 5
16534: PUSH
16535: LD_INT 1
16537: ST_TO_ADDR
16538: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16539: LD_EXP 5
16543: IFFALSE 16787
16545: GO 16547
16547: DISABLE
16548: LD_INT 0
16550: PPUSH
16551: PPUSH
// begin MC_Kill ( 1 ) ;
16552: LD_INT 1
16554: PPUSH
16555: CALL 22375 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16559: LD_ADDR_VAR 0 2
16563: PUSH
16564: LD_INT 22
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: PUSH
16574: LD_INT 21
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: PUSH
16593: LD_INT 22
16595: PUSH
16596: LD_INT 2
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: LD_INT 21
16605: PUSH
16606: LD_INT 2
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: EMPTY
16617: LIST
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 69
16628: ADD
16629: ST_TO_ADDR
// if tmp then
16630: LD_VAR 0 2
16634: IFFALSE 16787
// repeat wait ( 0 0$1 ) ;
16636: LD_INT 35
16638: PPUSH
16639: CALL_OW 67
// for i in tmp do
16643: LD_ADDR_VAR 0 1
16647: PUSH
16648: LD_VAR 0 2
16652: PUSH
16653: FOR_IN
16654: IFFALSE 16736
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16656: LD_VAR 0 1
16660: PPUSH
16661: CALL_OW 310
16665: PUSH
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 310
16675: PPUSH
16676: CALL_OW 247
16680: PUSH
16681: LD_INT 3
16683: EQUAL
16684: AND
16685: IFFALSE 16696
// ComExitBuilding ( i ) ;
16687: LD_VAR 0 1
16691: PPUSH
16692: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16696: LD_VAR 0 1
16700: PPUSH
16701: LD_INT 254
16703: PPUSH
16704: LD_INT 268
16706: PPUSH
16707: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16711: LD_VAR 0 1
16715: PPUSH
16716: LD_INT 34
16718: PPUSH
16719: CALL_OW 308
16723: IFFALSE 16734
// RemoveUnit ( i ) ;
16725: LD_VAR 0 1
16729: PPUSH
16730: CALL_OW 64
// end ;
16734: GO 16653
16736: POP
16737: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16738: LD_INT 22
16740: PUSH
16741: LD_INT 2
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 2
16750: PUSH
16751: LD_INT 21
16753: PUSH
16754: LD_INT 1
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: PUSH
16761: LD_INT 33
16763: PUSH
16764: LD_INT 1
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: LIST
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PPUSH
16780: CALL_OW 69
16784: NOT
16785: IFFALSE 16636
// end ;
16787: PPOPN 2
16789: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16790: LD_EXP 3
16794: IFFALSE 17146
16796: GO 16798
16798: DISABLE
16799: LD_INT 0
16801: PPUSH
16802: PPUSH
// begin MC_Kill ( 3 ) ;
16803: LD_INT 3
16805: PPUSH
16806: CALL 22375 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16810: LD_INT 8
16812: PPUSH
16813: LD_INT 7
16815: PPUSH
16816: LD_INT 1
16818: PPUSH
16819: LD_INT 1
16821: PPUSH
16822: CALL_OW 80
// DialogueOn ;
16826: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16830: LD_EXP 57
16834: PPUSH
16835: LD_STRING D15-Szulc-1
16837: PPUSH
16838: CALL_OW 94
// DialogueOff ;
16842: CALL_OW 7
// legionCapitulated := true ;
16846: LD_ADDR_EXP 8
16850: PUSH
16851: LD_INT 1
16853: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16854: LD_ADDR_VAR 0 1
16858: PUSH
16859: LD_INT 22
16861: PUSH
16862: LD_INT 8
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: PUSH
16869: LD_INT 21
16871: PUSH
16872: LD_INT 3
16874: PUSH
16875: EMPTY
16876: LIST
16877: LIST
16878: PUSH
16879: LD_INT 23
16881: PUSH
16882: LD_INT 3
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: PUSH
16889: EMPTY
16890: LIST
16891: LIST
16892: LIST
16893: PPUSH
16894: CALL_OW 69
16898: PUSH
16899: FOR_IN
16900: IFFALSE 16916
// SetLives ( i , 3 ) ;
16902: LD_VAR 0 1
16906: PPUSH
16907: LD_INT 3
16909: PPUSH
16910: CALL_OW 234
16914: GO 16899
16916: POP
16917: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16918: LD_ADDR_VAR 0 2
16922: PUSH
16923: LD_INT 22
16925: PUSH
16926: LD_INT 8
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PUSH
16933: LD_INT 21
16935: PUSH
16936: LD_INT 1
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: PPUSH
16947: CALL_OW 69
16951: PUSH
16952: LD_INT 22
16954: PUSH
16955: LD_INT 8
16957: PUSH
16958: EMPTY
16959: LIST
16960: LIST
16961: PUSH
16962: LD_INT 21
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: PUSH
16978: EMPTY
16979: LIST
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 69
16987: ADD
16988: ST_TO_ADDR
// if tmp then
16989: LD_VAR 0 2
16993: IFFALSE 17146
// repeat wait ( 0 0$1 ) ;
16995: LD_INT 35
16997: PPUSH
16998: CALL_OW 67
// for i in tmp do
17002: LD_ADDR_VAR 0 1
17006: PUSH
17007: LD_VAR 0 2
17011: PUSH
17012: FOR_IN
17013: IFFALSE 17095
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17015: LD_VAR 0 1
17019: PPUSH
17020: CALL_OW 310
17024: PUSH
17025: LD_VAR 0 1
17029: PPUSH
17030: CALL_OW 310
17034: PPUSH
17035: CALL_OW 247
17039: PUSH
17040: LD_INT 3
17042: EQUAL
17043: AND
17044: IFFALSE 17055
// ComExitBuilding ( i ) ;
17046: LD_VAR 0 1
17050: PPUSH
17051: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17055: LD_VAR 0 1
17059: PPUSH
17060: LD_INT 10
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17070: LD_VAR 0 1
17074: PPUSH
17075: LD_INT 32
17077: PPUSH
17078: CALL_OW 308
17082: IFFALSE 17093
// RemoveUnit ( i ) ;
17084: LD_VAR 0 1
17088: PPUSH
17089: CALL_OW 64
// end ;
17093: GO 17012
17095: POP
17096: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17097: LD_INT 22
17099: PUSH
17100: LD_INT 8
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: PUSH
17107: LD_INT 2
17109: PUSH
17110: LD_INT 21
17112: PUSH
17113: LD_INT 1
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: PUSH
17120: LD_INT 33
17122: PUSH
17123: LD_INT 1
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: PPUSH
17139: CALL_OW 69
17143: NOT
17144: IFFALSE 16995
// end ;
17146: PPOPN 2
17148: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17149: LD_EXP 5
17153: NOT
17154: PUSH
17155: LD_OWVAR 1
17159: PUSH
17160: LD_INT 63000
17162: GREATEREQUAL
17163: AND
17164: PUSH
17165: LD_OWVAR 67
17169: PUSH
17170: LD_INT 3
17172: LESS
17173: AND
17174: IFFALSE 17183
17176: GO 17178
17178: DISABLE
// AllianceSupport ;
17179: CALL 4677 0 0
17183: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17184: LD_EXP 4
17188: PUSH
17189: LD_EXP 2
17193: AND
17194: PUSH
17195: LD_EXP 3
17199: AND
17200: PUSH
17201: LD_EXP 5
17205: AND
17206: PUSH
17207: LD_EXP 6
17211: AND
17212: PUSH
17213: LD_EXP 7
17217: AND
17218: PUSH
17219: LD_EXP 8
17223: AND
17224: PUSH
17225: LD_EXP 56
17229: PPUSH
17230: CALL_OW 255
17234: PUSH
17235: LD_INT 5
17237: NONEQUAL
17238: PUSH
17239: LD_EXP 56
17243: PPUSH
17244: CALL_OW 301
17248: OR
17249: PUSH
17250: LD_EXP 56
17254: PPUSH
17255: CALL_OW 305
17259: NOT
17260: OR
17261: AND
17262: IFFALSE 18781
17264: GO 17266
17266: DISABLE
17267: LD_INT 0
17269: PPUSH
17270: PPUSH
// begin wait ( 0 0$5 ) ;
17271: LD_INT 175
17273: PPUSH
17274: CALL_OW 67
// music_class := 5 ;
17278: LD_ADDR_OWVAR 72
17282: PUSH
17283: LD_INT 5
17285: ST_TO_ADDR
// music_nat := 5 ;
17286: LD_ADDR_OWVAR 71
17290: PUSH
17291: LD_INT 5
17293: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17294: LD_EXP 15
17298: PUSH
17299: LD_INT 3
17301: LESS
17302: IFFALSE 17311
// SetAchievement ( ACH_ECONOMY ) ;
17304: LD_STRING ACH_ECONOMY
17306: PPUSH
17307: CALL_OW 543
// if tick < 60 60$00 then
17311: LD_OWVAR 1
17315: PUSH
17316: LD_INT 126000
17318: LESS
17319: IFFALSE 17335
// begin wait ( 3 ) ;
17321: LD_INT 3
17323: PPUSH
17324: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17328: LD_STRING ACH_ASPEED_19
17330: PPUSH
17331: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17335: LD_EXP 19
17339: PPUSH
17340: CALL_OW 87
// InGameOn ;
17344: CALL_OW 8
// DialogueOn ;
17348: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17352: LD_EXP 19
17356: PPUSH
17357: LD_STRING DEnd-JMM-JMM-1
17359: PPUSH
17360: CALL_OW 88
// if Joan then
17364: LD_EXP 34
17368: IFFALSE 17384
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17370: LD_EXP 34
17374: PPUSH
17375: LD_STRING DEnd-JMM-Joan-1
17377: PPUSH
17378: CALL_OW 88
17382: GO 17428
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17384: LD_EXP 21
17388: PUSH
17389: LD_EXP 21
17393: PPUSH
17394: CALL_OW 255
17398: PUSH
17399: LD_INT 7
17401: EQUAL
17402: AND
17403: PUSH
17404: LD_EXP 21
17408: PPUSH
17409: CALL_OW 305
17413: AND
17414: IFFALSE 17428
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17416: LD_EXP 21
17420: PPUSH
17421: LD_STRING DEnd-JMM-Lisa-1
17423: PPUSH
17424: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17428: LD_EXP 31
17432: PUSH
17433: LD_EXP 31
17437: PPUSH
17438: CALL_OW 305
17442: AND
17443: IFFALSE 17457
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17445: LD_EXP 31
17449: PPUSH
17450: LD_STRING DEnd-JMM-Frank-1
17452: PPUSH
17453: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17457: LD_EXP 24
17461: PUSH
17462: LD_EXP 24
17466: PPUSH
17467: CALL_OW 255
17471: PUSH
17472: LD_INT 7
17474: EQUAL
17475: AND
17476: PUSH
17477: LD_EXP 24
17481: PPUSH
17482: CALL_OW 305
17486: AND
17487: IFFALSE 17501
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17489: LD_EXP 24
17493: PPUSH
17494: LD_STRING DEnd-JMM-Cyrus-1
17496: PPUSH
17497: CALL_OW 88
// if Burlak then
17501: LD_EXP 52
17505: IFFALSE 17519
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17507: LD_EXP 52
17511: PPUSH
17512: LD_STRING DEnd-JMM-Bur-1
17514: PPUSH
17515: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17519: LD_EXP 34
17523: PUSH
17524: LD_EXP 21
17528: AND
17529: PUSH
17530: LD_EXP 21
17534: PPUSH
17535: CALL_OW 255
17539: PUSH
17540: LD_INT 7
17542: EQUAL
17543: AND
17544: PUSH
17545: LD_EXP 21
17549: PPUSH
17550: CALL_OW 305
17554: AND
17555: PUSH
17556: LD_EXP 52
17560: PPUSH
17561: CALL_OW 302
17565: AND
17566: IFFALSE 17580
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17568: LD_EXP 21
17572: PPUSH
17573: LD_STRING DEnd-Burlak-Lisa-1
17575: PPUSH
17576: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17580: LD_EXP 53
17584: PUSH
17585: LD_EXP 53
17589: PPUSH
17590: CALL_OW 305
17594: AND
17595: IFFALSE 17609
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17597: LD_EXP 53
17601: PPUSH
17602: LD_STRING DEnd-JMM-Bel-1
17604: PPUSH
17605: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17609: LD_EXP 54
17613: PUSH
17614: LD_EXP 54
17618: PPUSH
17619: CALL_OW 305
17623: AND
17624: IFFALSE 17638
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17626: LD_EXP 54
17630: PPUSH
17631: LD_STRING DEnd-JMM-Gny-1
17633: PPUSH
17634: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17638: LD_EXP 29
17642: PUSH
17643: LD_EXP 29
17647: PPUSH
17648: CALL_OW 255
17652: PUSH
17653: LD_INT 7
17655: EQUAL
17656: AND
17657: PUSH
17658: LD_EXP 29
17662: PPUSH
17663: CALL_OW 305
17667: AND
17668: IFFALSE 17682
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17670: LD_EXP 29
17674: PPUSH
17675: LD_STRING DEnd-JMM-Corn-1
17677: PPUSH
17678: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17682: LD_EXP 22
17686: PUSH
17687: LD_EXP 22
17691: PPUSH
17692: CALL_OW 255
17696: PUSH
17697: LD_INT 7
17699: EQUAL
17700: AND
17701: PUSH
17702: LD_EXP 22
17706: PPUSH
17707: CALL_OW 305
17711: AND
17712: IFFALSE 17726
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17714: LD_EXP 22
17718: PPUSH
17719: LD_STRING DEnd-JMM-Don-1
17721: PPUSH
17722: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17726: LD_EXP 23
17730: PUSH
17731: LD_EXP 23
17735: PPUSH
17736: CALL_OW 255
17740: PUSH
17741: LD_INT 7
17743: EQUAL
17744: AND
17745: PUSH
17746: LD_EXP 23
17750: PPUSH
17751: CALL_OW 305
17755: AND
17756: IFFALSE 17770
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17758: LD_EXP 23
17762: PPUSH
17763: LD_STRING DEnd-JMM-Bobby-1
17765: PPUSH
17766: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17770: LD_EXP 25
17774: PUSH
17775: LD_EXP 25
17779: PPUSH
17780: CALL_OW 255
17784: PUSH
17785: LD_INT 7
17787: EQUAL
17788: AND
17789: PUSH
17790: LD_EXP 25
17794: PPUSH
17795: CALL_OW 305
17799: AND
17800: IFFALSE 17814
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17802: LD_EXP 25
17806: PPUSH
17807: LD_STRING DEnd-JMM-Den-1
17809: PPUSH
17810: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17814: LD_EXP 27
17818: PUSH
17819: LD_EXP 27
17823: PPUSH
17824: CALL_OW 255
17828: PUSH
17829: LD_INT 7
17831: EQUAL
17832: AND
17833: PUSH
17834: LD_EXP 27
17838: PPUSH
17839: CALL_OW 305
17843: AND
17844: IFFALSE 17858
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17846: LD_EXP 27
17850: PPUSH
17851: LD_STRING DEnd-JMM-Glad-1
17853: PPUSH
17854: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17858: LD_EXP 32
17862: PUSH
17863: LD_EXP 32
17867: PPUSH
17868: CALL_OW 255
17872: PUSH
17873: LD_INT 7
17875: EQUAL
17876: AND
17877: PUSH
17878: LD_EXP 32
17882: PPUSH
17883: CALL_OW 305
17887: AND
17888: IFFALSE 17902
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17890: LD_EXP 32
17894: PPUSH
17895: LD_STRING DEnd-JMM-Yam-1
17897: PPUSH
17898: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17902: LD_EXP 26
17906: PUSH
17907: LD_EXP 26
17911: PPUSH
17912: CALL_OW 255
17916: PUSH
17917: LD_INT 7
17919: EQUAL
17920: AND
17921: PUSH
17922: LD_EXP 26
17926: PPUSH
17927: CALL_OW 305
17931: AND
17932: IFFALSE 17946
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17934: LD_EXP 26
17938: PPUSH
17939: LD_STRING DEnd-JMM-Brown-1
17941: PPUSH
17942: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17946: LD_EXP 36
17950: PUSH
17951: LD_EXP 36
17955: PPUSH
17956: CALL_OW 255
17960: PUSH
17961: LD_INT 7
17963: EQUAL
17964: AND
17965: PUSH
17966: LD_EXP 36
17970: PPUSH
17971: CALL_OW 305
17975: AND
17976: IFFALSE 17990
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17978: LD_EXP 36
17982: PPUSH
17983: LD_STRING DEnd-JMM-Con-1
17985: PPUSH
17986: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17990: LD_EXP 30
17994: PUSH
17995: LD_EXP 30
17999: PPUSH
18000: CALL_OW 255
18004: PUSH
18005: LD_INT 7
18007: EQUAL
18008: AND
18009: PUSH
18010: LD_EXP 30
18014: PPUSH
18015: CALL_OW 305
18019: AND
18020: IFFALSE 18034
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18022: LD_EXP 30
18026: PPUSH
18027: LD_STRING DEnd-JMM-Gary-1
18029: PPUSH
18030: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18034: LD_EXP 20
18038: PUSH
18039: LD_EXP 20
18043: PPUSH
18044: CALL_OW 305
18048: AND
18049: IFFALSE 18063
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18051: LD_EXP 20
18055: PPUSH
18056: LD_STRING DEnd-JMM-Roth-1
18058: PPUSH
18059: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18063: LD_EXP 33
18067: PUSH
18068: LD_EXP 20
18072: AND
18073: PUSH
18074: LD_EXP 33
18078: PPUSH
18079: CALL_OW 305
18083: AND
18084: IFFALSE 18098
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18086: LD_EXP 33
18090: PPUSH
18091: LD_STRING DEnd-JMM-Sim-1
18093: PPUSH
18094: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18098: LD_EXP 28
18102: PUSH
18103: LD_EXP 28
18107: PPUSH
18108: CALL_OW 255
18112: PUSH
18113: LD_INT 7
18115: EQUAL
18116: AND
18117: PUSH
18118: LD_EXP 28
18122: PPUSH
18123: CALL_OW 305
18127: AND
18128: IFFALSE 18142
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18130: LD_EXP 28
18134: PPUSH
18135: LD_STRING DEnd-JMM-VanH-1
18137: PPUSH
18138: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18142: LD_EXP 42
18146: PUSH
18147: LD_EXP 42
18151: PPUSH
18152: CALL_OW 305
18156: AND
18157: IFFALSE 18171
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18159: LD_EXP 42
18163: PPUSH
18164: LD_STRING DEnd-JMM-Dol-1
18166: PPUSH
18167: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18171: LD_EXP 32
18175: PUSH
18176: LD_EXP 32
18180: PPUSH
18181: CALL_OW 255
18185: PUSH
18186: LD_INT 7
18188: EQUAL
18189: AND
18190: PUSH
18191: LD_EXP 32
18195: PPUSH
18196: CALL_OW 305
18200: AND
18201: IFFALSE 18215
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18203: LD_EXP 32
18207: PPUSH
18208: LD_STRING DEnd-JMM-Yam-1
18210: PPUSH
18211: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18215: LD_EXP 46
18219: PUSH
18220: LD_EXP 46
18224: PPUSH
18225: CALL_OW 305
18229: AND
18230: IFFALSE 18244
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18232: LD_EXP 46
18236: PPUSH
18237: LD_STRING DEnd-JMM-Kap-1
18239: PPUSH
18240: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18244: LD_EXP 49
18248: PUSH
18249: LD_EXP 49
18253: PPUSH
18254: CALL_OW 305
18258: AND
18259: IFFALSE 18273
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18261: LD_EXP 49
18265: PPUSH
18266: LD_STRING DEnd-JMM-Kov-1
18268: PPUSH
18269: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18273: LD_EXP 44
18277: PUSH
18278: LD_EXP 44
18282: PPUSH
18283: CALL_OW 305
18287: AND
18288: IFFALSE 18302
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18290: LD_EXP 44
18294: PPUSH
18295: LD_STRING DEnd-JMM-Sch-1
18297: PPUSH
18298: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18302: LD_EXP 40
18306: PUSH
18307: LD_EXP 40
18311: PPUSH
18312: CALL_OW 305
18316: AND
18317: PUSH
18318: LD_EXP 52
18322: PPUSH
18323: CALL_OW 302
18327: AND
18328: IFFALSE 18342
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18330: LD_EXP 40
18334: PPUSH
18335: LD_STRING DEnd-JMM-Tit-1
18337: PPUSH
18338: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18342: LD_EXP 45
18346: PUSH
18347: LD_EXP 45
18351: PPUSH
18352: CALL_OW 305
18356: AND
18357: IFFALSE 18371
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18359: LD_EXP 45
18363: PPUSH
18364: LD_STRING DEnd-JMM-Obl-1
18366: PPUSH
18367: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18371: LD_EXP 47
18375: PUSH
18376: LD_EXP 47
18380: PPUSH
18381: CALL_OW 305
18385: AND
18386: IFFALSE 18400
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18388: LD_EXP 47
18392: PPUSH
18393: LD_STRING DEnd-JMM-Lip-1
18395: PPUSH
18396: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18400: LD_EXP 41
18404: PUSH
18405: LD_EXP 41
18409: PPUSH
18410: CALL_OW 305
18414: AND
18415: PUSH
18416: LD_EXP 52
18420: PPUSH
18421: CALL_OW 302
18425: AND
18426: IFFALSE 18440
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18428: LD_EXP 41
18432: PPUSH
18433: LD_STRING DEnd-Burlak-Fad-1
18435: PPUSH
18436: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18440: LD_EXP 48
18444: PUSH
18445: LD_EXP 48
18449: PPUSH
18450: CALL_OW 305
18454: AND
18455: IFFALSE 18469
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18457: LD_EXP 48
18461: PPUSH
18462: LD_STRING DEnd-Burlak-Ptr-1
18464: PPUSH
18465: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18469: LD_EXP 50
18473: PUSH
18474: LD_EXP 50
18478: PPUSH
18479: CALL_OW 305
18483: AND
18484: IFFALSE 18498
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18486: LD_EXP 50
18490: PPUSH
18491: LD_STRING DEnd-Burlak-Kuz-1
18493: PPUSH
18494: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18498: LD_EXP 39
18502: PUSH
18503: LD_EXP 39
18507: PPUSH
18508: CALL_OW 305
18512: AND
18513: PUSH
18514: LD_EXP 52
18518: PPUSH
18519: CALL_OW 302
18523: AND
18524: IFFALSE 18538
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18526: LD_EXP 39
18530: PPUSH
18531: LD_STRING DEnd-Burlak-Kir-1
18533: PPUSH
18534: CALL_OW 88
// if Joan then
18538: LD_EXP 34
18542: IFFALSE 18556
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18544: LD_EXP 34
18548: PPUSH
18549: LD_STRING DEnd-Burlak-Joan-1
18551: PPUSH
18552: CALL_OW 88
// if IsOk ( Burlak ) then
18556: LD_EXP 52
18560: PPUSH
18561: CALL_OW 302
18565: IFFALSE 18579
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18567: LD_EXP 19
18571: PPUSH
18572: LD_STRING DEnd-Burlak-JMM-1
18574: PPUSH
18575: CALL_OW 88
// dwait ( 0 0$2 ) ;
18579: LD_INT 70
18581: PPUSH
18582: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
18586: LD_EXP 57
18590: PPUSH
18591: LD_STRING DEnd-Szulc
18593: PPUSH
18594: CALL_OW 94
// dwait ( 0 0$1 ) ;
18598: LD_INT 35
18600: PPUSH
18601: CALL_OW 68
// if IsLive ( Burlak ) then
18605: LD_EXP 52
18609: PPUSH
18610: CALL_OW 300
18614: IFFALSE 18626
// med1 := 1 else
18616: LD_ADDR_VAR 0 1
18620: PUSH
18621: LD_INT 1
18623: ST_TO_ADDR
18624: GO 18635
// med1 := - 1 ;
18626: LD_ADDR_VAR 0 1
18630: PUSH
18631: LD_INT 1
18633: NEG
18634: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18635: LD_EXP 12
18639: PUSH
18640: LD_EXP 13
18644: AND
18645: PUSH
18646: LD_EXP 14
18650: AND
18651: IFFALSE 18663
// med2 := 1 else
18653: LD_ADDR_VAR 0 2
18657: PUSH
18658: LD_INT 1
18660: ST_TO_ADDR
18661: GO 18672
// med2 := - 1 ;
18663: LD_ADDR_VAR 0 2
18667: PUSH
18668: LD_INT 1
18670: NEG
18671: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18672: LD_STRING Hero
18674: PPUSH
18675: LD_INT 1
18677: PPUSH
18678: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18682: LD_STRING Artefact
18684: PPUSH
18685: LD_VAR 0 2
18689: PPUSH
18690: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18694: LD_STRING ReconcileBurlak
18696: PPUSH
18697: LD_VAR 0 1
18701: PPUSH
18702: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18706: LD_OWVAR 67
18710: PUSH
18711: LD_INT 3
18713: GREATEREQUAL
18714: PUSH
18715: LD_VAR 0 1
18719: PUSH
18720: LD_INT 1
18722: EQUAL
18723: AND
18724: PUSH
18725: LD_VAR 0 2
18729: PUSH
18730: LD_INT 1
18732: EQUAL
18733: AND
18734: IFFALSE 18746
// SetAchievementEX ( ACH_AMER , 19 ) ;
18736: LD_STRING ACH_AMER
18738: PPUSH
18739: LD_INT 19
18741: PPUSH
18742: CALL_OW 564
// GiveMedals ( MAIN ) ;
18746: LD_STRING MAIN
18748: PPUSH
18749: CALL_OW 102
// InGameOff ;
18753: CALL_OW 9
// DialogueOff ;
18757: CALL_OW 7
// music_nat := 1 ;
18761: LD_ADDR_OWVAR 71
18765: PUSH
18766: LD_INT 1
18768: ST_TO_ADDR
// music_class := 4 ;
18769: LD_ADDR_OWVAR 72
18773: PUSH
18774: LD_INT 4
18776: ST_TO_ADDR
// YouWin ;
18777: CALL_OW 103
// end ; end_of_file
18781: PPOPN 2
18783: END
// export function InitNature ; begin
18784: LD_INT 0
18786: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18787: LD_INT 3
18789: PPUSH
18790: LD_INT 3
18792: PPUSH
18793: LD_INT 2
18795: PPUSH
18796: LD_INT 1
18798: PPUSH
18799: LD_INT 1
18801: PPUSH
18802: LD_INT 0
18804: PPUSH
18805: LD_INT 0
18807: PPUSH
18808: LD_INT 17
18810: PPUSH
18811: LD_INT 0
18813: PPUSH
18814: CALL 86794 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18818: LD_INT 2
18820: PPUSH
18821: LD_INT 1
18823: PPUSH
18824: LD_INT 1
18826: PPUSH
18827: LD_INT 1
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: LD_INT 0
18835: PPUSH
18836: LD_INT 0
18838: PPUSH
18839: LD_INT 18
18841: PPUSH
18842: LD_INT 0
18844: PPUSH
18845: CALL 86794 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18849: LD_INT 4
18851: PPUSH
18852: LD_INT 1
18854: PPUSH
18855: LD_INT 2
18857: PPUSH
18858: LD_INT 4
18860: PPUSH
18861: LD_INT 2
18863: PPUSH
18864: LD_INT 1
18866: PPUSH
18867: LD_INT 0
18869: PPUSH
18870: LD_INT 19
18872: PPUSH
18873: LD_INT 0
18875: PPUSH
18876: CALL 86794 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18880: LD_INT 0
18882: PPUSH
18883: LD_INT 0
18885: PPUSH
18886: LD_INT 0
18888: PPUSH
18889: LD_INT 0
18891: PPUSH
18892: LD_INT 0
18894: PPUSH
18895: LD_INT 0
18897: PPUSH
18898: LD_INT 9
18900: PPUSH
18901: LD_INT 0
18903: PPUSH
18904: LD_INT 20
18906: PPUSH
18907: CALL 86794 0 9
// end ; end_of_file
18911: LD_VAR 0 1
18915: RET
// every 0 0$30 do var time ;
18916: GO 18918
18918: DISABLE
18919: LD_INT 0
18921: PPUSH
// begin time := 0 0$30 ;
18922: LD_ADDR_VAR 0 1
18926: PUSH
18927: LD_INT 1050
18929: ST_TO_ADDR
// repeat wait ( time ) ;
18930: LD_VAR 0 1
18934: PPUSH
18935: CALL_OW 67
// if Prob ( 50 ) then
18939: LD_INT 50
18941: PPUSH
18942: CALL_OW 13
18946: IFFALSE 18975
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18948: LD_INT 1
18950: PPUSH
18951: LD_INT 5
18953: PPUSH
18954: CALL_OW 12
18958: PPUSH
18959: LD_INT 106
18961: PPUSH
18962: LD_INT 89
18964: PPUSH
18965: LD_INT 45
18967: PPUSH
18968: LD_INT 1
18970: PPUSH
18971: CALL_OW 56
// time := time + 0 0$3 ;
18975: LD_ADDR_VAR 0 1
18979: PUSH
18980: LD_VAR 0 1
18984: PUSH
18985: LD_INT 105
18987: PLUS
18988: ST_TO_ADDR
// if Prob ( 30 ) then
18989: LD_INT 30
18991: PPUSH
18992: CALL_OW 13
18996: IFFALSE 19042
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18998: LD_INT 525
19000: PPUSH
19001: LD_INT 735
19003: PPUSH
19004: CALL_OW 12
19008: PPUSH
19009: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19013: LD_INT 1
19015: PPUSH
19016: LD_INT 5
19018: PPUSH
19019: CALL_OW 12
19023: PPUSH
19024: LD_INT 21
19026: PPUSH
19027: LD_INT 26
19029: PPUSH
19030: LD_INT 12
19032: PPUSH
19033: LD_INT 1
19035: PPUSH
19036: CALL_OW 56
// end else
19040: GO 19078
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19042: LD_INT 700
19044: PPUSH
19045: LD_INT 1225
19047: PPUSH
19048: CALL_OW 12
19052: PPUSH
19053: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19057: LD_INT 1
19059: PPUSH
19060: LD_INT 5
19062: PPUSH
19063: CALL_OW 12
19067: PPUSH
19068: LD_INT 14
19070: PPUSH
19071: LD_INT 1
19073: PPUSH
19074: CALL_OW 55
// end ; if Prob ( 50 ) then
19078: LD_INT 50
19080: PPUSH
19081: CALL_OW 13
19085: IFFALSE 19131
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19087: LD_INT 700
19089: PPUSH
19090: LD_INT 1050
19092: PPUSH
19093: CALL_OW 12
19097: PPUSH
19098: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19102: LD_INT 1
19104: PPUSH
19105: LD_INT 5
19107: PPUSH
19108: CALL_OW 12
19112: PPUSH
19113: LD_INT 181
19115: PPUSH
19116: LD_INT 218
19118: PPUSH
19119: LD_INT 16
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: CALL_OW 56
// end else
19129: GO 19203
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19131: LD_INT 350
19133: PPUSH
19134: LD_INT 525
19136: PPUSH
19137: CALL_OW 12
19141: PPUSH
19142: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19146: LD_INT 1
19148: PPUSH
19149: LD_INT 5
19151: PPUSH
19152: CALL_OW 12
19156: PPUSH
19157: LD_INT 13
19159: PPUSH
19160: LD_INT 1
19162: PPUSH
19163: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19167: LD_INT 350
19169: PPUSH
19170: LD_INT 700
19172: PPUSH
19173: CALL_OW 12
19177: PPUSH
19178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19182: LD_INT 1
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 33
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19203: LD_INT 65
19205: PUSH
19206: LD_INT 62
19208: PUSH
19209: LD_INT 55
19211: PUSH
19212: LD_INT 50
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: LIST
19219: LIST
19220: PUSH
19221: LD_OWVAR 67
19225: ARRAY
19226: PPUSH
19227: CALL_OW 13
19231: IFFALSE 19277
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19233: LD_INT 525
19235: PPUSH
19236: LD_INT 875
19238: PPUSH
19239: CALL_OW 12
19243: PPUSH
19244: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19248: LD_INT 1
19250: PPUSH
19251: LD_INT 5
19253: PPUSH
19254: CALL_OW 12
19258: PPUSH
19259: LD_INT 294
19261: PPUSH
19262: LD_INT 211
19264: PPUSH
19265: LD_INT 30
19267: PPUSH
19268: LD_INT 1
19270: PPUSH
19271: CALL_OW 56
// end else
19275: GO 19319
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19277: LD_INT 420
19279: PPUSH
19280: LD_INT 770
19282: PPUSH
19283: CALL_OW 12
19287: PPUSH
19288: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19292: LD_INT 1
19294: PPUSH
19295: LD_INT 5
19297: PPUSH
19298: CALL_OW 12
19302: PPUSH
19303: LD_INT 294
19305: PPUSH
19306: LD_INT 211
19308: PPUSH
19309: LD_INT 30
19311: PPUSH
19312: LD_INT 1
19314: PPUSH
19315: CALL_OW 56
// end ; if time > 2 2$20 then
19319: LD_VAR 0 1
19323: PUSH
19324: LD_INT 4900
19326: GREATER
19327: IFFALSE 19337
// time := 0 0$50 ;
19329: LD_ADDR_VAR 0 1
19333: PUSH
19334: LD_INT 1750
19336: ST_TO_ADDR
// until false ;
19337: LD_INT 0
19339: IFFALSE 18930
// end ;
19341: PPOPN 1
19343: END
// every 0 0$45 trigger tick < 10 10$00 do
19344: LD_OWVAR 1
19348: PUSH
19349: LD_INT 21000
19351: LESS
19352: IFFALSE 19400
19354: GO 19356
19356: DISABLE
// begin enable ;
19357: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19358: LD_INT 350
19360: PPUSH
19361: LD_INT 700
19363: PPUSH
19364: CALL_OW 12
19368: PPUSH
19369: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19373: LD_INT 3
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: CALL_OW 12
19383: PPUSH
19384: LD_INT 181
19386: PPUSH
19387: LD_INT 13
19389: PPUSH
19390: LD_INT 20
19392: PPUSH
19393: LD_INT 1
19395: PPUSH
19396: CALL_OW 56
// end ; end_of_file
19400: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19401: LD_INT 0
19403: PPUSH
// SetArtifactRes ( 7 , true ) ;
19404: LD_INT 7
19406: PPUSH
19407: LD_INT 1
19409: PPUSH
19410: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19414: LD_ADDR_EXP 66
19418: PUSH
19419: EMPTY
19420: PUSH
19421: EMPTY
19422: PUSH
19423: EMPTY
19424: PUSH
19425: EMPTY
19426: LIST
19427: LIST
19428: LIST
19429: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19430: LD_ADDR_EXP 67
19434: PUSH
19435: LD_INT 1050
19437: PUSH
19438: LD_OWVAR 67
19442: MUL
19443: PUSH
19444: LD_INT 2800
19446: PUSH
19447: LD_OWVAR 67
19451: MUL
19452: PUSH
19453: LD_INT 1
19455: NEG
19456: PUSH
19457: EMPTY
19458: LIST
19459: LIST
19460: LIST
19461: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19462: LD_ADDR_EXP 68
19466: PUSH
19467: LD_INT 10
19469: PUSH
19470: LD_INT 35
19472: PUSH
19473: LD_INT 100
19475: PUSH
19476: EMPTY
19477: LIST
19478: LIST
19479: LIST
19480: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19481: LD_ADDR_EXP 69
19485: PUSH
19486: LD_INT 0
19488: PUSH
19489: LD_INT 0
19491: PUSH
19492: LD_INT 0
19494: PUSH
19495: EMPTY
19496: LIST
19497: LIST
19498: LIST
19499: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19500: LD_ADDR_EXP 71
19504: PUSH
19505: LD_INT 300
19507: PUSH
19508: LD_INT 500
19510: PUSH
19511: LD_INT 800
19513: PUSH
19514: EMPTY
19515: LIST
19516: LIST
19517: LIST
19518: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19519: LD_ADDR_EXP 72
19523: PUSH
19524: LD_INT 0
19526: PUSH
19527: LD_INT 0
19529: PUSH
19530: LD_INT 0
19532: PUSH
19533: EMPTY
19534: LIST
19535: LIST
19536: LIST
19537: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19538: LD_ADDR_EXP 73
19542: PUSH
19543: LD_INT 0
19545: PUSH
19546: LD_INT 0
19548: PUSH
19549: LD_INT 0
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: LIST
19556: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19557: LD_ADDR_EXP 70
19561: PUSH
19562: LD_INT 0
19564: PUSH
19565: LD_INT 0
19567: PUSH
19568: LD_INT 0
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: LIST
19575: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
19576: LD_ADDR_EXP 74
19580: PUSH
19581: LD_INT 4
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 1
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: LIST
19594: PUSH
19595: LD_INT 5
19597: PUSH
19598: LD_INT 4
19600: PUSH
19601: LD_INT 2
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: LIST
19608: PUSH
19609: LD_INT 6
19611: PUSH
19612: LD_INT 3
19614: PUSH
19615: LD_INT 3
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: LIST
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19628: LD_ADDR_EXP 75
19632: PUSH
19633: LD_INT 0
19635: PUSH
19636: LD_INT 0
19638: PUSH
19639: LD_INT 0
19641: PUSH
19642: EMPTY
19643: LIST
19644: LIST
19645: LIST
19646: ST_TO_ADDR
// end ;
19647: LD_VAR 0 1
19651: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19652: LD_INT 24
19654: PPUSH
19655: LD_INT 7
19657: PPUSH
19658: CALL_OW 321
19662: PUSH
19663: LD_INT 2
19665: EQUAL
19666: IFFALSE 20592
19668: GO 19670
19670: DISABLE
19671: LD_INT 0
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
// begin enable ;
19678: ENABLE
// for i = 1 to 3 do
19679: LD_ADDR_VAR 0 1
19683: PUSH
19684: DOUBLE
19685: LD_INT 1
19687: DEC
19688: ST_TO_ADDR
19689: LD_INT 3
19691: PUSH
19692: FOR_TO
19693: IFFALSE 20590
// begin pos := FindArtifact ( i + 2 ) ;
19695: LD_ADDR_VAR 0 2
19699: PUSH
19700: LD_VAR 0 1
19704: PUSH
19705: LD_INT 2
19707: PLUS
19708: PPUSH
19709: CALL_OW 469
19713: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19714: LD_ADDR_EXP 66
19718: PUSH
19719: LD_EXP 66
19723: PPUSH
19724: LD_VAR 0 1
19728: PPUSH
19729: LD_VAR 0 2
19733: PPUSH
19734: CALL_OW 1
19738: ST_TO_ADDR
// if pos then
19739: LD_VAR 0 2
19743: IFFALSE 20451
// begin case i of 1 :
19745: LD_VAR 0 1
19749: PUSH
19750: LD_INT 1
19752: DOUBLE
19753: EQUAL
19754: IFTRUE 19758
19756: GO 19835
19758: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19759: LD_ADDR_VAR 0 4
19763: PUSH
19764: LD_INT 22
19766: PUSH
19767: LD_INT 7
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: PUSH
19774: LD_INT 23
19776: PUSH
19777: LD_INT 1
19779: PUSH
19780: EMPTY
19781: LIST
19782: LIST
19783: PUSH
19784: LD_INT 2
19786: PUSH
19787: LD_INT 30
19789: PUSH
19790: LD_INT 8
19792: PUSH
19793: EMPTY
19794: LIST
19795: LIST
19796: PUSH
19797: LD_INT 30
19799: PUSH
19800: LD_INT 7
19802: PUSH
19803: EMPTY
19804: LIST
19805: LIST
19806: PUSH
19807: LD_INT 30
19809: PUSH
19810: LD_INT 11
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: LIST
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: LIST
19827: PPUSH
19828: CALL_OW 69
19832: ST_TO_ADDR
19833: GO 19943
19835: LD_INT 2
19837: DOUBLE
19838: EQUAL
19839: IFTRUE 19843
19841: GO 19920
19843: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19844: LD_ADDR_VAR 0 4
19848: PUSH
19849: LD_INT 22
19851: PUSH
19852: LD_INT 7
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: LD_INT 23
19861: PUSH
19862: LD_INT 3
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: LD_INT 2
19871: PUSH
19872: LD_INT 30
19874: PUSH
19875: LD_INT 8
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: PUSH
19882: LD_INT 30
19884: PUSH
19885: LD_INT 7
19887: PUSH
19888: EMPTY
19889: LIST
19890: LIST
19891: PUSH
19892: LD_INT 30
19894: PUSH
19895: LD_INT 11
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL_OW 69
19917: ST_TO_ADDR
19918: GO 19943
19920: LD_INT 3
19922: DOUBLE
19923: EQUAL
19924: IFTRUE 19928
19926: GO 19942
19928: POP
// labs := [ alien ] ; end ;
19929: LD_ADDR_VAR 0 4
19933: PUSH
19934: LD_INT 1
19936: PUSH
19937: EMPTY
19938: LIST
19939: ST_TO_ADDR
19940: GO 19943
19942: POP
// if not labs then
19943: LD_VAR 0 4
19947: NOT
19948: IFFALSE 19952
// continue ;
19950: GO 19692
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19952: LD_ADDR_VAR 0 5
19956: PUSH
19957: LD_VAR 0 4
19961: PPUSH
19962: LD_EXP 66
19966: PUSH
19967: LD_VAR 0 1
19971: ARRAY
19972: PUSH
19973: LD_INT 1
19975: ARRAY
19976: PPUSH
19977: LD_EXP 66
19981: PUSH
19982: LD_VAR 0 1
19986: ARRAY
19987: PUSH
19988: LD_INT 2
19990: ARRAY
19991: PPUSH
19992: CALL_OW 73
19996: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19997: LD_VAR 0 5
20001: NOT
20002: PUSH
20003: LD_VAR 0 5
20007: PUSH
20008: LD_EXP 73
20012: PUSH
20013: LD_VAR 0 1
20017: ARRAY
20018: NONEQUAL
20019: OR
20020: IFFALSE 20125
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20022: LD_INT 7
20024: PPUSH
20025: LD_EXP 74
20029: PUSH
20030: LD_VAR 0 1
20034: ARRAY
20035: PUSH
20036: LD_INT 3
20038: ARRAY
20039: PPUSH
20040: LD_INT 0
20042: PPUSH
20043: LD_EXP 73
20047: PUSH
20048: LD_VAR 0 1
20052: ARRAY
20053: PPUSH
20054: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20058: LD_INT 7
20060: PPUSH
20061: LD_EXP 74
20065: PUSH
20066: LD_VAR 0 1
20070: ARRAY
20071: PUSH
20072: LD_INT 1
20074: ARRAY
20075: PPUSH
20076: LD_INT 0
20078: PPUSH
20079: LD_EXP 73
20083: PUSH
20084: LD_VAR 0 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 468
// if nearestLab then
20094: LD_VAR 0 5
20098: IFFALSE 20125
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20100: LD_ADDR_EXP 73
20104: PUSH
20105: LD_EXP 73
20109: PPUSH
20110: LD_VAR 0 1
20114: PPUSH
20115: LD_VAR 0 5
20119: PPUSH
20120: CALL_OW 1
20124: ST_TO_ADDR
// end ; if not nearestLab then
20125: LD_VAR 0 5
20129: NOT
20130: IFFALSE 20134
// continue ;
20132: GO 19692
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20134: LD_VAR 0 5
20138: PPUSH
20139: LD_EXP 66
20143: PUSH
20144: LD_VAR 0 1
20148: ARRAY
20149: PUSH
20150: LD_INT 1
20152: ARRAY
20153: PPUSH
20154: LD_EXP 66
20158: PUSH
20159: LD_VAR 0 1
20163: ARRAY
20164: PUSH
20165: LD_INT 2
20167: ARRAY
20168: PPUSH
20169: CALL_OW 297
20173: PUSH
20174: LD_INT 8
20176: LESS
20177: IFFALSE 20374
// begin if not artifactsResearched [ i ] then
20179: LD_EXP 69
20183: PUSH
20184: LD_VAR 0 1
20188: ARRAY
20189: NOT
20190: IFFALSE 20271
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20192: LD_VAR 0 5
20196: PPUSH
20197: CALL_OW 461
20201: PUSH
20202: LD_INT 2
20204: EQUAL
20205: IFFALSE 20239
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20207: LD_INT 7
20209: PPUSH
20210: LD_EXP 74
20214: PUSH
20215: LD_VAR 0 1
20219: ARRAY
20220: PUSH
20221: LD_INT 3
20223: ARRAY
20224: PPUSH
20225: LD_INT 2
20227: PPUSH
20228: LD_VAR 0 5
20232: PPUSH
20233: CALL_OW 468
20237: GO 20269
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20239: LD_INT 7
20241: PPUSH
20242: LD_EXP 74
20246: PUSH
20247: LD_VAR 0 1
20251: ARRAY
20252: PUSH
20253: LD_INT 3
20255: ARRAY
20256: PPUSH
20257: LD_INT 1
20259: PPUSH
20260: LD_VAR 0 5
20264: PPUSH
20265: CALL_OW 468
// end else
20269: GO 20372
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20271: LD_VAR 0 5
20275: PPUSH
20276: CALL_OW 461
20280: PUSH
20281: LD_INT 2
20283: EQUAL
20284: PUSH
20285: LD_EXP 75
20289: PUSH
20290: LD_VAR 0 1
20294: ARRAY
20295: AND
20296: IFFALSE 20342
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20298: LD_INT 7
20300: PPUSH
20301: LD_EXP 74
20305: PUSH
20306: LD_VAR 0 1
20310: ARRAY
20311: PUSH
20312: LD_INT 1
20314: ARRAY
20315: PPUSH
20316: LD_EXP 74
20320: PUSH
20321: LD_VAR 0 1
20325: ARRAY
20326: PUSH
20327: LD_INT 2
20329: ARRAY
20330: PPUSH
20331: LD_VAR 0 5
20335: PPUSH
20336: CALL_OW 468
20340: GO 20372
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20342: LD_INT 7
20344: PPUSH
20345: LD_EXP 74
20349: PUSH
20350: LD_VAR 0 1
20354: ARRAY
20355: PUSH
20356: LD_INT 1
20358: ARRAY
20359: PPUSH
20360: LD_INT 1
20362: PPUSH
20363: LD_VAR 0 5
20367: PPUSH
20368: CALL_OW 468
// end else
20372: GO 20449
// begin if not artifactsResearched [ i ] then
20374: LD_EXP 69
20378: PUSH
20379: LD_VAR 0 1
20383: ARRAY
20384: NOT
20385: IFFALSE 20419
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20387: LD_INT 7
20389: PPUSH
20390: LD_EXP 74
20394: PUSH
20395: LD_VAR 0 1
20399: ARRAY
20400: PUSH
20401: LD_INT 3
20403: ARRAY
20404: PPUSH
20405: LD_INT 0
20407: PPUSH
20408: LD_VAR 0 5
20412: PPUSH
20413: CALL_OW 468
20417: GO 20449
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20419: LD_INT 7
20421: PPUSH
20422: LD_EXP 74
20426: PUSH
20427: LD_VAR 0 1
20431: ARRAY
20432: PUSH
20433: LD_INT 1
20435: ARRAY
20436: PPUSH
20437: LD_INT 0
20439: PPUSH
20440: LD_VAR 0 5
20444: PPUSH
20445: CALL_OW 468
// end ; end else
20449: GO 20588
// begin if not artifactsLabs [ i ] then
20451: LD_EXP 73
20455: PUSH
20456: LD_VAR 0 1
20460: ARRAY
20461: NOT
20462: IFFALSE 20466
// continue ;
20464: GO 19692
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20466: LD_INT 7
20468: PPUSH
20469: LD_EXP 74
20473: PUSH
20474: LD_VAR 0 1
20478: ARRAY
20479: PUSH
20480: LD_INT 3
20482: ARRAY
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_EXP 73
20491: PUSH
20492: LD_VAR 0 1
20496: ARRAY
20497: PPUSH
20498: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20502: LD_INT 7
20504: PPUSH
20505: LD_EXP 74
20509: PUSH
20510: LD_VAR 0 1
20514: ARRAY
20515: PUSH
20516: LD_INT 1
20518: ARRAY
20519: PPUSH
20520: LD_INT 0
20522: PPUSH
20523: LD_EXP 73
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PPUSH
20534: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20538: LD_EXP 70
20542: PUSH
20543: LD_VAR 0 1
20547: ARRAY
20548: IFFALSE 20588
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20550: LD_ADDR_EXP 70
20554: PUSH
20555: LD_EXP 70
20559: PPUSH
20560: LD_VAR 0 1
20564: PPUSH
20565: LD_INT 0
20567: PPUSH
20568: CALL_OW 1
20572: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
20573: LD_EXP 73
20577: PUSH
20578: LD_VAR 0 1
20582: ARRAY
20583: PPUSH
20584: CALL_OW 127
// end ; end ; end ;
20588: GO 19692
20590: POP
20591: POP
// end ;
20592: PPOPN 5
20594: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
20595: LD_INT 0
20597: PPUSH
20598: PPUSH
20599: PPUSH
20600: PPUSH
20601: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20602: LD_VAR 0 2
20606: PUSH
20607: LD_EXP 74
20611: PUSH
20612: LD_INT 1
20614: ARRAY
20615: PUSH
20616: LD_INT 3
20618: ARRAY
20619: EQUAL
20620: IFFALSE 20743
// begin lab := artifactsLabs [ 1 ] ;
20622: LD_ADDR_VAR 0 6
20626: PUSH
20627: LD_EXP 73
20631: PUSH
20632: LD_INT 1
20634: ARRAY
20635: ST_TO_ADDR
// if not lab then
20636: LD_VAR 0 6
20640: NOT
20641: IFFALSE 20645
// exit ;
20643: GO 21723
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20645: LD_VAR 0 6
20649: PPUSH
20650: LD_EXP 71
20654: PUSH
20655: LD_INT 1
20657: ARRAY
20658: PPUSH
20659: LD_INT 1
20661: PPUSH
20662: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20666: LD_EXP 72
20670: PUSH
20671: LD_INT 1
20673: ARRAY
20674: IFFALSE 20694
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20676: LD_VAR 0 6
20680: PPUSH
20681: LD_EXP 72
20685: PUSH
20686: LD_INT 1
20688: ARRAY
20689: PPUSH
20690: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20694: LD_ADDR_EXP 70
20698: PUSH
20699: LD_EXP 70
20703: PPUSH
20704: LD_INT 1
20706: PPUSH
20707: LD_INT 1
20709: PPUSH
20710: CALL_OW 1
20714: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20715: LD_INT 7
20717: PPUSH
20718: LD_EXP 74
20722: PUSH
20723: LD_INT 1
20725: ARRAY
20726: PUSH
20727: LD_INT 3
20729: ARRAY
20730: PPUSH
20731: LD_INT 0
20733: PPUSH
20734: LD_VAR 0 6
20738: PPUSH
20739: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20743: LD_VAR 0 2
20747: PUSH
20748: LD_EXP 74
20752: PUSH
20753: LD_INT 2
20755: ARRAY
20756: PUSH
20757: LD_INT 3
20759: ARRAY
20760: EQUAL
20761: IFFALSE 20884
// begin lab := artifactsLabs [ 2 ] ;
20763: LD_ADDR_VAR 0 6
20767: PUSH
20768: LD_EXP 73
20772: PUSH
20773: LD_INT 2
20775: ARRAY
20776: ST_TO_ADDR
// if not lab then
20777: LD_VAR 0 6
20781: NOT
20782: IFFALSE 20786
// exit ;
20784: GO 21723
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20786: LD_VAR 0 6
20790: PPUSH
20791: LD_EXP 71
20795: PUSH
20796: LD_INT 2
20798: ARRAY
20799: PPUSH
20800: LD_INT 1
20802: PPUSH
20803: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20807: LD_EXP 72
20811: PUSH
20812: LD_INT 2
20814: ARRAY
20815: IFFALSE 20835
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20817: LD_VAR 0 6
20821: PPUSH
20822: LD_EXP 72
20826: PUSH
20827: LD_INT 2
20829: ARRAY
20830: PPUSH
20831: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20835: LD_ADDR_EXP 70
20839: PUSH
20840: LD_EXP 70
20844: PPUSH
20845: LD_INT 2
20847: PPUSH
20848: LD_INT 1
20850: PPUSH
20851: CALL_OW 1
20855: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20856: LD_INT 7
20858: PPUSH
20859: LD_EXP 74
20863: PUSH
20864: LD_INT 2
20866: ARRAY
20867: PUSH
20868: LD_INT 3
20870: ARRAY
20871: PPUSH
20872: LD_INT 0
20874: PPUSH
20875: LD_VAR 0 6
20879: PPUSH
20880: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20884: LD_VAR 0 2
20888: PUSH
20889: LD_EXP 74
20893: PUSH
20894: LD_INT 3
20896: ARRAY
20897: PUSH
20898: LD_INT 3
20900: ARRAY
20901: EQUAL
20902: IFFALSE 21025
// begin lab := artifactsLabs [ 3 ] ;
20904: LD_ADDR_VAR 0 6
20908: PUSH
20909: LD_EXP 73
20913: PUSH
20914: LD_INT 3
20916: ARRAY
20917: ST_TO_ADDR
// if not lab then
20918: LD_VAR 0 6
20922: NOT
20923: IFFALSE 20927
// exit ;
20925: GO 21723
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20927: LD_VAR 0 6
20931: PPUSH
20932: LD_EXP 71
20936: PUSH
20937: LD_INT 3
20939: ARRAY
20940: PPUSH
20941: LD_INT 1
20943: PPUSH
20944: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20948: LD_EXP 72
20952: PUSH
20953: LD_INT 3
20955: ARRAY
20956: IFFALSE 20976
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20958: LD_VAR 0 6
20962: PPUSH
20963: LD_EXP 72
20967: PUSH
20968: LD_INT 3
20970: ARRAY
20971: PPUSH
20972: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20976: LD_ADDR_EXP 70
20980: PUSH
20981: LD_EXP 70
20985: PPUSH
20986: LD_INT 3
20988: PPUSH
20989: LD_INT 1
20991: PPUSH
20992: CALL_OW 1
20996: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20997: LD_INT 7
20999: PPUSH
21000: LD_EXP 74
21004: PUSH
21005: LD_INT 3
21007: ARRAY
21008: PUSH
21009: LD_INT 3
21011: ARRAY
21012: PPUSH
21013: LD_INT 0
21015: PPUSH
21016: LD_VAR 0 6
21020: PPUSH
21021: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21025: LD_VAR 0 2
21029: PUSH
21030: LD_EXP 74
21034: PUSH
21035: LD_INT 1
21037: ARRAY
21038: PUSH
21039: LD_INT 1
21041: ARRAY
21042: EQUAL
21043: IFFALSE 21201
// begin lab := artifactsLabs [ 1 ] ;
21045: LD_ADDR_VAR 0 6
21049: PUSH
21050: LD_EXP 73
21054: PUSH
21055: LD_INT 1
21057: ARRAY
21058: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21059: LD_VAR 0 6
21063: PPUSH
21064: CALL_OW 274
21068: PPUSH
21069: CALL 90334 0 1
21073: PUSH
21074: LD_INT 3
21076: ARRAY
21077: PUSH
21078: LD_EXP 68
21082: PUSH
21083: LD_INT 1
21085: ARRAY
21086: LESS
21087: IFFALSE 21101
// begin HintSpec ( ArtifactCost , 2 ) ;
21089: LD_STRING ArtifactCost
21091: PPUSH
21092: LD_INT 2
21094: PPUSH
21095: CALL_OW 338
// exit ;
21099: GO 21723
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21101: LD_ADDR_EXP 75
21105: PUSH
21106: LD_EXP 75
21110: PPUSH
21111: LD_INT 1
21113: PPUSH
21114: LD_INT 0
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21122: LD_VAR 0 3
21126: PPUSH
21127: LD_VAR 0 4
21131: PPUSH
21132: LD_INT 7
21134: PPUSH
21135: LD_INT 12
21137: NEG
21138: PPUSH
21139: CALL_OW 330
// wait ( 0 0$30 ) ;
21143: LD_INT 1050
21145: PPUSH
21146: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21150: LD_VAR 0 3
21154: PPUSH
21155: LD_VAR 0 4
21159: PPUSH
21160: LD_INT 7
21162: PPUSH
21163: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21167: LD_EXP 67
21171: PUSH
21172: LD_INT 1
21174: ARRAY
21175: PPUSH
21176: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21180: LD_ADDR_EXP 75
21184: PUSH
21185: LD_EXP 75
21189: PPUSH
21190: LD_INT 1
21192: PPUSH
21193: LD_INT 1
21195: PPUSH
21196: CALL_OW 1
21200: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21201: LD_VAR 0 2
21205: PUSH
21206: LD_EXP 74
21210: PUSH
21211: LD_INT 2
21213: ARRAY
21214: PUSH
21215: LD_INT 1
21217: ARRAY
21218: EQUAL
21219: IFFALSE 21456
// begin lab := artifactsLabs [ 2 ] ;
21221: LD_ADDR_VAR 0 6
21225: PUSH
21226: LD_EXP 73
21230: PUSH
21231: LD_INT 2
21233: ARRAY
21234: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21235: LD_VAR 0 3
21239: PUSH
21240: LD_INT 81
21242: PUSH
21243: LD_INT 7
21245: PUSH
21246: EMPTY
21247: LIST
21248: LIST
21249: PUSH
21250: LD_INT 2
21252: PUSH
21253: LD_INT 32
21255: PUSH
21256: LD_INT 3
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PUSH
21263: LD_INT 30
21265: PUSH
21266: LD_INT 28
21268: PUSH
21269: EMPTY
21270: LIST
21271: LIST
21272: PUSH
21273: LD_INT 30
21275: PUSH
21276: LD_INT 30
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 35
21285: PUSH
21286: LD_INT 49
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 34
21295: PUSH
21296: LD_INT 49
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: PUSH
21303: LD_INT 30
21305: PUSH
21306: LD_INT 21
21308: PUSH
21309: EMPTY
21310: LIST
21311: LIST
21312: PUSH
21313: EMPTY
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: PPUSH
21326: CALL_OW 69
21330: IN
21331: NOT
21332: IFFALSE 21336
// exit ;
21334: GO 21723
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21336: LD_VAR 0 6
21340: PPUSH
21341: CALL_OW 274
21345: PPUSH
21346: CALL 90334 0 1
21350: PUSH
21351: LD_INT 3
21353: ARRAY
21354: PUSH
21355: LD_EXP 68
21359: PUSH
21360: LD_INT 2
21362: ARRAY
21363: LESS
21364: IFFALSE 21378
// begin HintSpec ( ArtifactCost , 2 ) ;
21366: LD_STRING ArtifactCost
21368: PPUSH
21369: LD_INT 2
21371: PPUSH
21372: CALL_OW 338
// exit ;
21376: GO 21723
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21378: LD_ADDR_EXP 75
21382: PUSH
21383: LD_EXP 75
21387: PPUSH
21388: LD_INT 2
21390: PPUSH
21391: LD_INT 0
21393: PPUSH
21394: CALL_OW 1
21398: ST_TO_ADDR
// KillUnit ( x ) ;
21399: LD_VAR 0 3
21403: PPUSH
21404: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21408: LD_ADDR_EXP 16
21412: PUSH
21413: LD_EXP 16
21417: PUSH
21418: LD_INT 1
21420: PLUS
21421: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21422: LD_EXP 67
21426: PUSH
21427: LD_INT 2
21429: ARRAY
21430: PPUSH
21431: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21435: LD_ADDR_EXP 75
21439: PUSH
21440: LD_EXP 75
21444: PPUSH
21445: LD_INT 2
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: CALL_OW 1
21455: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21456: LD_VAR 0 2
21460: PUSH
21461: LD_EXP 74
21465: PUSH
21466: LD_INT 3
21468: ARRAY
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: EQUAL
21474: IFFALSE 21723
// begin lab := artifactsLabs [ 3 ] ;
21476: LD_ADDR_VAR 0 6
21480: PUSH
21481: LD_EXP 73
21485: PUSH
21486: LD_INT 3
21488: ARRAY
21489: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21490: LD_VAR 0 6
21494: PPUSH
21495: CALL_OW 274
21499: PPUSH
21500: CALL 90334 0 1
21504: PUSH
21505: LD_INT 3
21507: ARRAY
21508: PUSH
21509: LD_EXP 68
21513: PUSH
21514: LD_INT 3
21516: ARRAY
21517: LESS
21518: IFFALSE 21532
// begin HintSpec ( ArtifactCost , 2 ) ;
21520: LD_STRING ArtifactCost
21522: PPUSH
21523: LD_INT 2
21525: PPUSH
21526: CALL_OW 338
// exit ;
21530: GO 21723
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21532: LD_INT 37
21534: PPUSH
21535: LD_INT 1
21537: PPUSH
21538: CALL_OW 424
// time := 0 0$30 ;
21542: LD_ADDR_VAR 0 7
21546: PUSH
21547: LD_INT 1050
21549: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21550: LD_ADDR_EXP 75
21554: PUSH
21555: LD_EXP 75
21559: PPUSH
21560: LD_INT 3
21562: PPUSH
21563: LD_INT 0
21565: PPUSH
21566: CALL_OW 1
21570: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
21571: LD_ADDR_OWVAR 47
21575: PUSH
21576: LD_STRING #Am15a-1
21578: PUSH
21579: LD_VAR 0 7
21583: PUSH
21584: EMPTY
21585: LIST
21586: LIST
21587: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21588: LD_INT 35
21590: PPUSH
21591: CALL_OW 67
// time := time - 0 0$1 ;
21595: LD_ADDR_VAR 0 7
21599: PUSH
21600: LD_VAR 0 7
21604: PUSH
21605: LD_INT 35
21607: MINUS
21608: ST_TO_ADDR
// until time = 0 0$00 ;
21609: LD_VAR 0 7
21613: PUSH
21614: LD_INT 0
21616: EQUAL
21617: IFFALSE 21571
// display_strings :=  ;
21619: LD_ADDR_OWVAR 47
21623: PUSH
21624: LD_STRING 
21626: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21627: LD_INT 37
21629: PPUSH
21630: LD_INT 0
21632: PPUSH
21633: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21637: LD_ADDR_VAR 0 8
21641: PUSH
21642: LD_INT 37
21644: PPUSH
21645: LD_INT 3
21647: PUSH
21648: LD_INT 21
21650: PUSH
21651: LD_INT 3
21653: PUSH
21654: EMPTY
21655: LIST
21656: LIST
21657: PUSH
21658: EMPTY
21659: LIST
21660: LIST
21661: PPUSH
21662: CALL_OW 70
21666: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21667: LD_VAR 0 3
21671: PPUSH
21672: LD_VAR 0 4
21676: PPUSH
21677: CALL_OW 84
// for un in list do
21681: LD_ADDR_VAR 0 9
21685: PUSH
21686: LD_VAR 0 8
21690: PUSH
21691: FOR_IN
21692: IFFALSE 21721
// TeleportUnit ( un , x , y , 12 , true ) ;
21694: LD_VAR 0 9
21698: PPUSH
21699: LD_VAR 0 3
21703: PPUSH
21704: LD_VAR 0 4
21708: PPUSH
21709: LD_INT 12
21711: PPUSH
21712: LD_INT 1
21714: PPUSH
21715: CALL_OW 483
21719: GO 21691
21721: POP
21722: POP
// end ; end ;
21723: PPOPN 9
21725: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21726: LD_INT 0
21728: PPUSH
21729: PPUSH
// begin labNum := 0 ;
21730: LD_ADDR_VAR 0 4
21734: PUSH
21735: LD_INT 0
21737: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21738: LD_ADDR_VAR 0 3
21742: PUSH
21743: DOUBLE
21744: LD_INT 1
21746: DEC
21747: ST_TO_ADDR
21748: LD_EXP 73
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21788
// if artifactsLabs [ i ] = lab then
21756: LD_EXP 73
21760: PUSH
21761: LD_VAR 0 3
21765: ARRAY
21766: PUSH
21767: LD_VAR 0 1
21771: EQUAL
21772: IFFALSE 21786
// begin labNum := i ;
21774: LD_ADDR_VAR 0 4
21778: PUSH
21779: LD_VAR 0 3
21783: ST_TO_ADDR
// break ;
21784: GO 21788
// end ;
21786: GO 21753
21788: POP
21789: POP
// if not labNum then
21790: LD_VAR 0 4
21794: NOT
21795: IFFALSE 21799
// exit ;
21797: GO 21877
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21799: LD_INT 7
21801: PPUSH
21802: LD_EXP 74
21806: PUSH
21807: LD_VAR 0 4
21811: ARRAY
21812: PUSH
21813: LD_INT 3
21815: ARRAY
21816: PPUSH
21817: LD_INT 2
21819: PPUSH
21820: LD_VAR 0 1
21824: PPUSH
21825: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21829: LD_ADDR_EXP 72
21833: PUSH
21834: LD_EXP 72
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: LD_VAR 0 2
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21854: LD_ADDR_EXP 70
21858: PUSH
21859: LD_EXP 70
21863: PPUSH
21864: LD_VAR 0 4
21868: PPUSH
21869: LD_INT 0
21871: PPUSH
21872: CALL_OW 1
21876: ST_TO_ADDR
// end ;
21877: PPOPN 4
21879: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21880: LD_INT 0
21882: PPUSH
21883: PPUSH
// begin labNum := 0 ;
21884: LD_ADDR_VAR 0 3
21888: PUSH
21889: LD_INT 0
21891: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21892: LD_ADDR_VAR 0 2
21896: PUSH
21897: DOUBLE
21898: LD_INT 1
21900: DEC
21901: ST_TO_ADDR
21902: LD_EXP 73
21906: PUSH
21907: FOR_TO
21908: IFFALSE 21942
// if artifactsLabs [ i ] = lab then
21910: LD_EXP 73
21914: PUSH
21915: LD_VAR 0 2
21919: ARRAY
21920: PUSH
21921: LD_VAR 0 1
21925: EQUAL
21926: IFFALSE 21940
// begin labNum := i ;
21928: LD_ADDR_VAR 0 3
21932: PUSH
21933: LD_VAR 0 2
21937: ST_TO_ADDR
// break ;
21938: GO 21942
// end ;
21940: GO 21907
21942: POP
21943: POP
// if not labNum then
21944: LD_VAR 0 3
21948: NOT
21949: IFFALSE 21953
// exit ;
21951: GO 22115
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21953: LD_INT 7
21955: PPUSH
21956: LD_EXP 74
21960: PUSH
21961: LD_VAR 0 3
21965: ARRAY
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PPUSH
21971: LD_INT 0
21973: PPUSH
21974: LD_VAR 0 1
21978: PPUSH
21979: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21983: LD_ADDR_EXP 69
21987: PUSH
21988: LD_EXP 69
21992: PPUSH
21993: LD_VAR 0 3
21997: PPUSH
21998: LD_INT 1
22000: PPUSH
22001: CALL_OW 1
22005: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22006: LD_ADDR_EXP 75
22010: PUSH
22011: LD_EXP 75
22015: PPUSH
22016: LD_VAR 0 3
22020: PPUSH
22021: LD_INT 1
22023: PPUSH
22024: CALL_OW 1
22028: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22029: LD_ADDR_EXP 70
22033: PUSH
22034: LD_EXP 70
22038: PPUSH
22039: LD_VAR 0 3
22043: PPUSH
22044: LD_INT 0
22046: PPUSH
22047: CALL_OW 1
22051: ST_TO_ADDR
// case labNum of 1 :
22052: LD_VAR 0 3
22056: PUSH
22057: LD_INT 1
22059: DOUBLE
22060: EQUAL
22061: IFTRUE 22065
22063: GO 22076
22065: POP
// artifactIResearched := true ; 2 :
22066: LD_ADDR_EXP 12
22070: PUSH
22071: LD_INT 1
22073: ST_TO_ADDR
22074: GO 22115
22076: LD_INT 2
22078: DOUBLE
22079: EQUAL
22080: IFTRUE 22084
22082: GO 22095
22084: POP
// artifactIIResearched := true ; 3 :
22085: LD_ADDR_EXP 13
22089: PUSH
22090: LD_INT 1
22092: ST_TO_ADDR
22093: GO 22115
22095: LD_INT 3
22097: DOUBLE
22098: EQUAL
22099: IFTRUE 22103
22101: GO 22114
22103: POP
// artifactIIIResearched := true ; end ;
22104: LD_ADDR_EXP 14
22108: PUSH
22109: LD_INT 1
22111: ST_TO_ADDR
22112: GO 22115
22114: POP
// end ; end_of_file
22115: PPOPN 3
22117: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22118: LD_INT 0
22120: PPUSH
22121: PPUSH
// skirmish := false ;
22122: LD_ADDR_EXP 76
22126: PUSH
22127: LD_INT 0
22129: ST_TO_ADDR
// debug_mc := false ;
22130: LD_ADDR_EXP 77
22134: PUSH
22135: LD_INT 0
22137: ST_TO_ADDR
// mc_bases := [ ] ;
22138: LD_ADDR_EXP 78
22142: PUSH
22143: EMPTY
22144: ST_TO_ADDR
// mc_sides := [ ] ;
22145: LD_ADDR_EXP 104
22149: PUSH
22150: EMPTY
22151: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22152: LD_ADDR_EXP 79
22156: PUSH
22157: EMPTY
22158: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22159: LD_ADDR_EXP 80
22163: PUSH
22164: EMPTY
22165: ST_TO_ADDR
// mc_need_heal := [ ] ;
22166: LD_ADDR_EXP 81
22170: PUSH
22171: EMPTY
22172: ST_TO_ADDR
// mc_healers := [ ] ;
22173: LD_ADDR_EXP 82
22177: PUSH
22178: EMPTY
22179: ST_TO_ADDR
// mc_build_list := [ ] ;
22180: LD_ADDR_EXP 83
22184: PUSH
22185: EMPTY
22186: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22187: LD_ADDR_EXP 110
22191: PUSH
22192: EMPTY
22193: ST_TO_ADDR
// mc_builders := [ ] ;
22194: LD_ADDR_EXP 84
22198: PUSH
22199: EMPTY
22200: ST_TO_ADDR
// mc_construct_list := [ ] ;
22201: LD_ADDR_EXP 85
22205: PUSH
22206: EMPTY
22207: ST_TO_ADDR
// mc_turret_list := [ ] ;
22208: LD_ADDR_EXP 86
22212: PUSH
22213: EMPTY
22214: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22215: LD_ADDR_EXP 87
22219: PUSH
22220: EMPTY
22221: ST_TO_ADDR
// mc_miners := [ ] ;
22222: LD_ADDR_EXP 92
22226: PUSH
22227: EMPTY
22228: ST_TO_ADDR
// mc_mines := [ ] ;
22229: LD_ADDR_EXP 91
22233: PUSH
22234: EMPTY
22235: ST_TO_ADDR
// mc_minefields := [ ] ;
22236: LD_ADDR_EXP 93
22240: PUSH
22241: EMPTY
22242: ST_TO_ADDR
// mc_crates := [ ] ;
22243: LD_ADDR_EXP 94
22247: PUSH
22248: EMPTY
22249: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22250: LD_ADDR_EXP 95
22254: PUSH
22255: EMPTY
22256: ST_TO_ADDR
// mc_crates_area := [ ] ;
22257: LD_ADDR_EXP 96
22261: PUSH
22262: EMPTY
22263: ST_TO_ADDR
// mc_vehicles := [ ] ;
22264: LD_ADDR_EXP 97
22268: PUSH
22269: EMPTY
22270: ST_TO_ADDR
// mc_attack := [ ] ;
22271: LD_ADDR_EXP 98
22275: PUSH
22276: EMPTY
22277: ST_TO_ADDR
// mc_produce := [ ] ;
22278: LD_ADDR_EXP 99
22282: PUSH
22283: EMPTY
22284: ST_TO_ADDR
// mc_defender := [ ] ;
22285: LD_ADDR_EXP 100
22289: PUSH
22290: EMPTY
22291: ST_TO_ADDR
// mc_parking := [ ] ;
22292: LD_ADDR_EXP 102
22296: PUSH
22297: EMPTY
22298: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22299: LD_ADDR_EXP 88
22303: PUSH
22304: EMPTY
22305: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22306: LD_ADDR_EXP 90
22310: PUSH
22311: EMPTY
22312: ST_TO_ADDR
// mc_scan := [ ] ;
22313: LD_ADDR_EXP 101
22317: PUSH
22318: EMPTY
22319: ST_TO_ADDR
// mc_scan_area := [ ] ;
22320: LD_ADDR_EXP 103
22324: PUSH
22325: EMPTY
22326: ST_TO_ADDR
// mc_tech := [ ] ;
22327: LD_ADDR_EXP 105
22331: PUSH
22332: EMPTY
22333: ST_TO_ADDR
// mc_class := [ ] ;
22334: LD_ADDR_EXP 119
22338: PUSH
22339: EMPTY
22340: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22341: LD_ADDR_EXP 120
22345: PUSH
22346: EMPTY
22347: ST_TO_ADDR
// mc_is_defending := [ ] ;
22348: LD_ADDR_EXP 121
22352: PUSH
22353: EMPTY
22354: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22355: LD_ADDR_EXP 112
22359: PUSH
22360: EMPTY
22361: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22362: LD_ADDR_EXP 122
22366: PUSH
22367: LD_INT 0
22369: ST_TO_ADDR
// end ;
22370: LD_VAR 0 1
22374: RET
// export function MC_Kill ( base ) ; begin
22375: LD_INT 0
22377: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22378: LD_ADDR_EXP 78
22382: PUSH
22383: LD_EXP 78
22387: PPUSH
22388: LD_VAR 0 1
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22400: LD_ADDR_EXP 79
22404: PUSH
22405: LD_EXP 79
22409: PPUSH
22410: LD_VAR 0 1
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22422: LD_ADDR_EXP 80
22426: PUSH
22427: LD_EXP 80
22431: PPUSH
22432: LD_VAR 0 1
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22444: LD_ADDR_EXP 81
22448: PUSH
22449: LD_EXP 81
22453: PPUSH
22454: LD_VAR 0 1
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22466: LD_ADDR_EXP 82
22470: PUSH
22471: LD_EXP 82
22475: PPUSH
22476: LD_VAR 0 1
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22488: LD_ADDR_EXP 83
22492: PUSH
22493: LD_EXP 83
22497: PPUSH
22498: LD_VAR 0 1
22502: PPUSH
22503: EMPTY
22504: PPUSH
22505: CALL_OW 1
22509: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22510: LD_ADDR_EXP 84
22514: PUSH
22515: LD_EXP 84
22519: PPUSH
22520: LD_VAR 0 1
22524: PPUSH
22525: EMPTY
22526: PPUSH
22527: CALL_OW 1
22531: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22532: LD_ADDR_EXP 85
22536: PUSH
22537: LD_EXP 85
22541: PPUSH
22542: LD_VAR 0 1
22546: PPUSH
22547: EMPTY
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22554: LD_ADDR_EXP 86
22558: PUSH
22559: LD_EXP 86
22563: PPUSH
22564: LD_VAR 0 1
22568: PPUSH
22569: EMPTY
22570: PPUSH
22571: CALL_OW 1
22575: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22576: LD_ADDR_EXP 87
22580: PUSH
22581: LD_EXP 87
22585: PPUSH
22586: LD_VAR 0 1
22590: PPUSH
22591: EMPTY
22592: PPUSH
22593: CALL_OW 1
22597: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22598: LD_ADDR_EXP 88
22602: PUSH
22603: LD_EXP 88
22607: PPUSH
22608: LD_VAR 0 1
22612: PPUSH
22613: EMPTY
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22620: LD_ADDR_EXP 89
22624: PUSH
22625: LD_EXP 89
22629: PPUSH
22630: LD_VAR 0 1
22634: PPUSH
22635: LD_INT 0
22637: PPUSH
22638: CALL_OW 1
22642: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22643: LD_ADDR_EXP 90
22647: PUSH
22648: LD_EXP 90
22652: PPUSH
22653: LD_VAR 0 1
22657: PPUSH
22658: EMPTY
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22665: LD_ADDR_EXP 91
22669: PUSH
22670: LD_EXP 91
22674: PPUSH
22675: LD_VAR 0 1
22679: PPUSH
22680: EMPTY
22681: PPUSH
22682: CALL_OW 1
22686: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22687: LD_ADDR_EXP 92
22691: PUSH
22692: LD_EXP 92
22696: PPUSH
22697: LD_VAR 0 1
22701: PPUSH
22702: EMPTY
22703: PPUSH
22704: CALL_OW 1
22708: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22709: LD_ADDR_EXP 93
22713: PUSH
22714: LD_EXP 93
22718: PPUSH
22719: LD_VAR 0 1
22723: PPUSH
22724: EMPTY
22725: PPUSH
22726: CALL_OW 1
22730: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22731: LD_ADDR_EXP 94
22735: PUSH
22736: LD_EXP 94
22740: PPUSH
22741: LD_VAR 0 1
22745: PPUSH
22746: EMPTY
22747: PPUSH
22748: CALL_OW 1
22752: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22753: LD_ADDR_EXP 95
22757: PUSH
22758: LD_EXP 95
22762: PPUSH
22763: LD_VAR 0 1
22767: PPUSH
22768: EMPTY
22769: PPUSH
22770: CALL_OW 1
22774: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22775: LD_ADDR_EXP 96
22779: PUSH
22780: LD_EXP 96
22784: PPUSH
22785: LD_VAR 0 1
22789: PPUSH
22790: EMPTY
22791: PPUSH
22792: CALL_OW 1
22796: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22797: LD_ADDR_EXP 97
22801: PUSH
22802: LD_EXP 97
22806: PPUSH
22807: LD_VAR 0 1
22811: PPUSH
22812: EMPTY
22813: PPUSH
22814: CALL_OW 1
22818: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22819: LD_ADDR_EXP 98
22823: PUSH
22824: LD_EXP 98
22828: PPUSH
22829: LD_VAR 0 1
22833: PPUSH
22834: EMPTY
22835: PPUSH
22836: CALL_OW 1
22840: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22841: LD_ADDR_EXP 99
22845: PUSH
22846: LD_EXP 99
22850: PPUSH
22851: LD_VAR 0 1
22855: PPUSH
22856: EMPTY
22857: PPUSH
22858: CALL_OW 1
22862: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22863: LD_ADDR_EXP 100
22867: PUSH
22868: LD_EXP 100
22872: PPUSH
22873: LD_VAR 0 1
22877: PPUSH
22878: EMPTY
22879: PPUSH
22880: CALL_OW 1
22884: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22885: LD_ADDR_EXP 101
22889: PUSH
22890: LD_EXP 101
22894: PPUSH
22895: LD_VAR 0 1
22899: PPUSH
22900: EMPTY
22901: PPUSH
22902: CALL_OW 1
22906: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22907: LD_ADDR_EXP 102
22911: PUSH
22912: LD_EXP 102
22916: PPUSH
22917: LD_VAR 0 1
22921: PPUSH
22922: EMPTY
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22929: LD_ADDR_EXP 103
22933: PUSH
22934: LD_EXP 103
22938: PPUSH
22939: LD_VAR 0 1
22943: PPUSH
22944: EMPTY
22945: PPUSH
22946: CALL_OW 1
22950: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22951: LD_ADDR_EXP 105
22955: PUSH
22956: LD_EXP 105
22960: PPUSH
22961: LD_VAR 0 1
22965: PPUSH
22966: EMPTY
22967: PPUSH
22968: CALL_OW 1
22972: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22973: LD_ADDR_EXP 107
22977: PUSH
22978: LD_EXP 107
22982: PPUSH
22983: LD_VAR 0 1
22987: PPUSH
22988: EMPTY
22989: PPUSH
22990: CALL_OW 1
22994: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22995: LD_ADDR_EXP 108
22999: PUSH
23000: LD_EXP 108
23004: PPUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: EMPTY
23011: PPUSH
23012: CALL_OW 1
23016: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23017: LD_ADDR_EXP 109
23021: PUSH
23022: LD_EXP 109
23026: PPUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: EMPTY
23033: PPUSH
23034: CALL_OW 1
23038: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23039: LD_ADDR_EXP 110
23043: PUSH
23044: LD_EXP 110
23048: PPUSH
23049: LD_VAR 0 1
23053: PPUSH
23054: EMPTY
23055: PPUSH
23056: CALL_OW 1
23060: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23061: LD_ADDR_EXP 111
23065: PUSH
23066: LD_EXP 111
23070: PPUSH
23071: LD_VAR 0 1
23075: PPUSH
23076: EMPTY
23077: PPUSH
23078: CALL_OW 1
23082: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23083: LD_ADDR_EXP 112
23087: PUSH
23088: LD_EXP 112
23092: PPUSH
23093: LD_VAR 0 1
23097: PPUSH
23098: EMPTY
23099: PPUSH
23100: CALL_OW 1
23104: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23105: LD_ADDR_EXP 113
23109: PUSH
23110: LD_EXP 113
23114: PPUSH
23115: LD_VAR 0 1
23119: PPUSH
23120: EMPTY
23121: PPUSH
23122: CALL_OW 1
23126: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23127: LD_ADDR_EXP 114
23131: PUSH
23132: LD_EXP 114
23136: PPUSH
23137: LD_VAR 0 1
23141: PPUSH
23142: EMPTY
23143: PPUSH
23144: CALL_OW 1
23148: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23149: LD_ADDR_EXP 115
23153: PUSH
23154: LD_EXP 115
23158: PPUSH
23159: LD_VAR 0 1
23163: PPUSH
23164: EMPTY
23165: PPUSH
23166: CALL_OW 1
23170: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23171: LD_ADDR_EXP 116
23175: PUSH
23176: LD_EXP 116
23180: PPUSH
23181: LD_VAR 0 1
23185: PPUSH
23186: EMPTY
23187: PPUSH
23188: CALL_OW 1
23192: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23193: LD_ADDR_EXP 117
23197: PUSH
23198: LD_EXP 117
23202: PPUSH
23203: LD_VAR 0 1
23207: PPUSH
23208: EMPTY
23209: PPUSH
23210: CALL_OW 1
23214: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23215: LD_ADDR_EXP 118
23219: PUSH
23220: LD_EXP 118
23224: PPUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: EMPTY
23231: PPUSH
23232: CALL_OW 1
23236: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23237: LD_ADDR_EXP 119
23241: PUSH
23242: LD_EXP 119
23246: PPUSH
23247: LD_VAR 0 1
23251: PPUSH
23252: EMPTY
23253: PPUSH
23254: CALL_OW 1
23258: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23259: LD_ADDR_EXP 120
23263: PUSH
23264: LD_EXP 120
23268: PPUSH
23269: LD_VAR 0 1
23273: PPUSH
23274: LD_INT 0
23276: PPUSH
23277: CALL_OW 1
23281: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23282: LD_ADDR_EXP 121
23286: PUSH
23287: LD_EXP 121
23291: PPUSH
23292: LD_VAR 0 1
23296: PPUSH
23297: LD_INT 0
23299: PPUSH
23300: CALL_OW 1
23304: ST_TO_ADDR
// end ;
23305: LD_VAR 0 2
23309: RET
// export function MC_Add ( side , units ) ; var base ; begin
23310: LD_INT 0
23312: PPUSH
23313: PPUSH
// base := mc_bases + 1 ;
23314: LD_ADDR_VAR 0 4
23318: PUSH
23319: LD_EXP 78
23323: PUSH
23324: LD_INT 1
23326: PLUS
23327: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23328: LD_ADDR_EXP 104
23332: PUSH
23333: LD_EXP 104
23337: PPUSH
23338: LD_VAR 0 4
23342: PPUSH
23343: LD_VAR 0 1
23347: PPUSH
23348: CALL_OW 1
23352: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23353: LD_ADDR_EXP 78
23357: PUSH
23358: LD_EXP 78
23362: PPUSH
23363: LD_VAR 0 4
23367: PPUSH
23368: LD_VAR 0 2
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23378: LD_ADDR_EXP 79
23382: PUSH
23383: LD_EXP 79
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: EMPTY
23394: PPUSH
23395: CALL_OW 1
23399: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23400: LD_ADDR_EXP 80
23404: PUSH
23405: LD_EXP 80
23409: PPUSH
23410: LD_VAR 0 4
23414: PPUSH
23415: EMPTY
23416: PPUSH
23417: CALL_OW 1
23421: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23422: LD_ADDR_EXP 81
23426: PUSH
23427: LD_EXP 81
23431: PPUSH
23432: LD_VAR 0 4
23436: PPUSH
23437: EMPTY
23438: PPUSH
23439: CALL_OW 1
23443: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23444: LD_ADDR_EXP 82
23448: PUSH
23449: LD_EXP 82
23453: PPUSH
23454: LD_VAR 0 4
23458: PPUSH
23459: EMPTY
23460: PPUSH
23461: CALL_OW 1
23465: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23466: LD_ADDR_EXP 83
23470: PUSH
23471: LD_EXP 83
23475: PPUSH
23476: LD_VAR 0 4
23480: PPUSH
23481: EMPTY
23482: PPUSH
23483: CALL_OW 1
23487: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23488: LD_ADDR_EXP 84
23492: PUSH
23493: LD_EXP 84
23497: PPUSH
23498: LD_VAR 0 4
23502: PPUSH
23503: EMPTY
23504: PPUSH
23505: CALL_OW 1
23509: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23510: LD_ADDR_EXP 85
23514: PUSH
23515: LD_EXP 85
23519: PPUSH
23520: LD_VAR 0 4
23524: PPUSH
23525: EMPTY
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23532: LD_ADDR_EXP 86
23536: PUSH
23537: LD_EXP 86
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: EMPTY
23548: PPUSH
23549: CALL_OW 1
23553: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23554: LD_ADDR_EXP 87
23558: PUSH
23559: LD_EXP 87
23563: PPUSH
23564: LD_VAR 0 4
23568: PPUSH
23569: EMPTY
23570: PPUSH
23571: CALL_OW 1
23575: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23576: LD_ADDR_EXP 88
23580: PUSH
23581: LD_EXP 88
23585: PPUSH
23586: LD_VAR 0 4
23590: PPUSH
23591: EMPTY
23592: PPUSH
23593: CALL_OW 1
23597: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23598: LD_ADDR_EXP 89
23602: PUSH
23603: LD_EXP 89
23607: PPUSH
23608: LD_VAR 0 4
23612: PPUSH
23613: LD_INT 0
23615: PPUSH
23616: CALL_OW 1
23620: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23621: LD_ADDR_EXP 90
23625: PUSH
23626: LD_EXP 90
23630: PPUSH
23631: LD_VAR 0 4
23635: PPUSH
23636: EMPTY
23637: PPUSH
23638: CALL_OW 1
23642: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23643: LD_ADDR_EXP 91
23647: PUSH
23648: LD_EXP 91
23652: PPUSH
23653: LD_VAR 0 4
23657: PPUSH
23658: EMPTY
23659: PPUSH
23660: CALL_OW 1
23664: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23665: LD_ADDR_EXP 92
23669: PUSH
23670: LD_EXP 92
23674: PPUSH
23675: LD_VAR 0 4
23679: PPUSH
23680: EMPTY
23681: PPUSH
23682: CALL_OW 1
23686: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23687: LD_ADDR_EXP 93
23691: PUSH
23692: LD_EXP 93
23696: PPUSH
23697: LD_VAR 0 4
23701: PPUSH
23702: EMPTY
23703: PPUSH
23704: CALL_OW 1
23708: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23709: LD_ADDR_EXP 94
23713: PUSH
23714: LD_EXP 94
23718: PPUSH
23719: LD_VAR 0 4
23723: PPUSH
23724: EMPTY
23725: PPUSH
23726: CALL_OW 1
23730: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23731: LD_ADDR_EXP 95
23735: PUSH
23736: LD_EXP 95
23740: PPUSH
23741: LD_VAR 0 4
23745: PPUSH
23746: EMPTY
23747: PPUSH
23748: CALL_OW 1
23752: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23753: LD_ADDR_EXP 96
23757: PUSH
23758: LD_EXP 96
23762: PPUSH
23763: LD_VAR 0 4
23767: PPUSH
23768: EMPTY
23769: PPUSH
23770: CALL_OW 1
23774: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23775: LD_ADDR_EXP 97
23779: PUSH
23780: LD_EXP 97
23784: PPUSH
23785: LD_VAR 0 4
23789: PPUSH
23790: EMPTY
23791: PPUSH
23792: CALL_OW 1
23796: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23797: LD_ADDR_EXP 98
23801: PUSH
23802: LD_EXP 98
23806: PPUSH
23807: LD_VAR 0 4
23811: PPUSH
23812: EMPTY
23813: PPUSH
23814: CALL_OW 1
23818: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23819: LD_ADDR_EXP 99
23823: PUSH
23824: LD_EXP 99
23828: PPUSH
23829: LD_VAR 0 4
23833: PPUSH
23834: EMPTY
23835: PPUSH
23836: CALL_OW 1
23840: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23841: LD_ADDR_EXP 100
23845: PUSH
23846: LD_EXP 100
23850: PPUSH
23851: LD_VAR 0 4
23855: PPUSH
23856: EMPTY
23857: PPUSH
23858: CALL_OW 1
23862: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23863: LD_ADDR_EXP 101
23867: PUSH
23868: LD_EXP 101
23872: PPUSH
23873: LD_VAR 0 4
23877: PPUSH
23878: EMPTY
23879: PPUSH
23880: CALL_OW 1
23884: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23885: LD_ADDR_EXP 102
23889: PUSH
23890: LD_EXP 102
23894: PPUSH
23895: LD_VAR 0 4
23899: PPUSH
23900: EMPTY
23901: PPUSH
23902: CALL_OW 1
23906: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23907: LD_ADDR_EXP 103
23911: PUSH
23912: LD_EXP 103
23916: PPUSH
23917: LD_VAR 0 4
23921: PPUSH
23922: EMPTY
23923: PPUSH
23924: CALL_OW 1
23928: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23929: LD_ADDR_EXP 105
23933: PUSH
23934: LD_EXP 105
23938: PPUSH
23939: LD_VAR 0 4
23943: PPUSH
23944: EMPTY
23945: PPUSH
23946: CALL_OW 1
23950: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23951: LD_ADDR_EXP 107
23955: PUSH
23956: LD_EXP 107
23960: PPUSH
23961: LD_VAR 0 4
23965: PPUSH
23966: EMPTY
23967: PPUSH
23968: CALL_OW 1
23972: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23973: LD_ADDR_EXP 108
23977: PUSH
23978: LD_EXP 108
23982: PPUSH
23983: LD_VAR 0 4
23987: PPUSH
23988: EMPTY
23989: PPUSH
23990: CALL_OW 1
23994: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23995: LD_ADDR_EXP 109
23999: PUSH
24000: LD_EXP 109
24004: PPUSH
24005: LD_VAR 0 4
24009: PPUSH
24010: EMPTY
24011: PPUSH
24012: CALL_OW 1
24016: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24017: LD_ADDR_EXP 110
24021: PUSH
24022: LD_EXP 110
24026: PPUSH
24027: LD_VAR 0 4
24031: PPUSH
24032: EMPTY
24033: PPUSH
24034: CALL_OW 1
24038: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24039: LD_ADDR_EXP 111
24043: PUSH
24044: LD_EXP 111
24048: PPUSH
24049: LD_VAR 0 4
24053: PPUSH
24054: EMPTY
24055: PPUSH
24056: CALL_OW 1
24060: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24061: LD_ADDR_EXP 112
24065: PUSH
24066: LD_EXP 112
24070: PPUSH
24071: LD_VAR 0 4
24075: PPUSH
24076: EMPTY
24077: PPUSH
24078: CALL_OW 1
24082: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24083: LD_ADDR_EXP 113
24087: PUSH
24088: LD_EXP 113
24092: PPUSH
24093: LD_VAR 0 4
24097: PPUSH
24098: EMPTY
24099: PPUSH
24100: CALL_OW 1
24104: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24105: LD_ADDR_EXP 114
24109: PUSH
24110: LD_EXP 114
24114: PPUSH
24115: LD_VAR 0 4
24119: PPUSH
24120: EMPTY
24121: PPUSH
24122: CALL_OW 1
24126: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24127: LD_ADDR_EXP 115
24131: PUSH
24132: LD_EXP 115
24136: PPUSH
24137: LD_VAR 0 4
24141: PPUSH
24142: EMPTY
24143: PPUSH
24144: CALL_OW 1
24148: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24149: LD_ADDR_EXP 116
24153: PUSH
24154: LD_EXP 116
24158: PPUSH
24159: LD_VAR 0 4
24163: PPUSH
24164: EMPTY
24165: PPUSH
24166: CALL_OW 1
24170: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24171: LD_ADDR_EXP 117
24175: PUSH
24176: LD_EXP 117
24180: PPUSH
24181: LD_VAR 0 4
24185: PPUSH
24186: EMPTY
24187: PPUSH
24188: CALL_OW 1
24192: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24193: LD_ADDR_EXP 118
24197: PUSH
24198: LD_EXP 118
24202: PPUSH
24203: LD_VAR 0 4
24207: PPUSH
24208: EMPTY
24209: PPUSH
24210: CALL_OW 1
24214: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24215: LD_ADDR_EXP 119
24219: PUSH
24220: LD_EXP 119
24224: PPUSH
24225: LD_VAR 0 4
24229: PPUSH
24230: EMPTY
24231: PPUSH
24232: CALL_OW 1
24236: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24237: LD_ADDR_EXP 120
24241: PUSH
24242: LD_EXP 120
24246: PPUSH
24247: LD_VAR 0 4
24251: PPUSH
24252: LD_INT 0
24254: PPUSH
24255: CALL_OW 1
24259: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24260: LD_ADDR_EXP 121
24264: PUSH
24265: LD_EXP 121
24269: PPUSH
24270: LD_VAR 0 4
24274: PPUSH
24275: LD_INT 0
24277: PPUSH
24278: CALL_OW 1
24282: ST_TO_ADDR
// result := base ;
24283: LD_ADDR_VAR 0 3
24287: PUSH
24288: LD_VAR 0 4
24292: ST_TO_ADDR
// end ;
24293: LD_VAR 0 3
24297: RET
// export function MC_Start ( ) ; var i ; begin
24298: LD_INT 0
24300: PPUSH
24301: PPUSH
// for i = 1 to mc_bases do
24302: LD_ADDR_VAR 0 2
24306: PUSH
24307: DOUBLE
24308: LD_INT 1
24310: DEC
24311: ST_TO_ADDR
24312: LD_EXP 78
24316: PUSH
24317: FOR_TO
24318: IFFALSE 25418
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24320: LD_ADDR_EXP 78
24324: PUSH
24325: LD_EXP 78
24329: PPUSH
24330: LD_VAR 0 2
24334: PPUSH
24335: LD_EXP 78
24339: PUSH
24340: LD_VAR 0 2
24344: ARRAY
24345: PUSH
24346: LD_INT 0
24348: DIFF
24349: PPUSH
24350: CALL_OW 1
24354: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24355: LD_ADDR_EXP 79
24359: PUSH
24360: LD_EXP 79
24364: PPUSH
24365: LD_VAR 0 2
24369: PPUSH
24370: EMPTY
24371: PPUSH
24372: CALL_OW 1
24376: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24377: LD_ADDR_EXP 80
24381: PUSH
24382: LD_EXP 80
24386: PPUSH
24387: LD_VAR 0 2
24391: PPUSH
24392: EMPTY
24393: PPUSH
24394: CALL_OW 1
24398: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24399: LD_ADDR_EXP 81
24403: PUSH
24404: LD_EXP 81
24408: PPUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: EMPTY
24415: PPUSH
24416: CALL_OW 1
24420: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24421: LD_ADDR_EXP 82
24425: PUSH
24426: LD_EXP 82
24430: PPUSH
24431: LD_VAR 0 2
24435: PPUSH
24436: EMPTY
24437: PUSH
24438: EMPTY
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24449: LD_ADDR_EXP 83
24453: PUSH
24454: LD_EXP 83
24458: PPUSH
24459: LD_VAR 0 2
24463: PPUSH
24464: EMPTY
24465: PPUSH
24466: CALL_OW 1
24470: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24471: LD_ADDR_EXP 110
24475: PUSH
24476: LD_EXP 110
24480: PPUSH
24481: LD_VAR 0 2
24485: PPUSH
24486: EMPTY
24487: PPUSH
24488: CALL_OW 1
24492: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24493: LD_ADDR_EXP 84
24497: PUSH
24498: LD_EXP 84
24502: PPUSH
24503: LD_VAR 0 2
24507: PPUSH
24508: EMPTY
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24515: LD_ADDR_EXP 85
24519: PUSH
24520: LD_EXP 85
24524: PPUSH
24525: LD_VAR 0 2
24529: PPUSH
24530: EMPTY
24531: PPUSH
24532: CALL_OW 1
24536: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24537: LD_ADDR_EXP 86
24541: PUSH
24542: LD_EXP 86
24546: PPUSH
24547: LD_VAR 0 2
24551: PPUSH
24552: LD_EXP 78
24556: PUSH
24557: LD_VAR 0 2
24561: ARRAY
24562: PPUSH
24563: LD_INT 2
24565: PUSH
24566: LD_INT 30
24568: PUSH
24569: LD_INT 32
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 30
24578: PUSH
24579: LD_INT 33
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: LIST
24590: PPUSH
24591: CALL_OW 72
24595: PPUSH
24596: CALL_OW 1
24600: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24601: LD_ADDR_EXP 87
24605: PUSH
24606: LD_EXP 87
24610: PPUSH
24611: LD_VAR 0 2
24615: PPUSH
24616: LD_EXP 78
24620: PUSH
24621: LD_VAR 0 2
24625: ARRAY
24626: PPUSH
24627: LD_INT 2
24629: PUSH
24630: LD_INT 30
24632: PUSH
24633: LD_INT 32
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 30
24642: PUSH
24643: LD_INT 31
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: LIST
24654: PUSH
24655: LD_INT 58
24657: PUSH
24658: EMPTY
24659: LIST
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PPUSH
24665: CALL_OW 72
24669: PPUSH
24670: CALL_OW 1
24674: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24675: LD_ADDR_EXP 88
24679: PUSH
24680: LD_EXP 88
24684: PPUSH
24685: LD_VAR 0 2
24689: PPUSH
24690: EMPTY
24691: PPUSH
24692: CALL_OW 1
24696: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24697: LD_ADDR_EXP 92
24701: PUSH
24702: LD_EXP 92
24706: PPUSH
24707: LD_VAR 0 2
24711: PPUSH
24712: EMPTY
24713: PPUSH
24714: CALL_OW 1
24718: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24719: LD_ADDR_EXP 91
24723: PUSH
24724: LD_EXP 91
24728: PPUSH
24729: LD_VAR 0 2
24733: PPUSH
24734: EMPTY
24735: PPUSH
24736: CALL_OW 1
24740: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24741: LD_ADDR_EXP 93
24745: PUSH
24746: LD_EXP 93
24750: PPUSH
24751: LD_VAR 0 2
24755: PPUSH
24756: EMPTY
24757: PPUSH
24758: CALL_OW 1
24762: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24763: LD_ADDR_EXP 94
24767: PUSH
24768: LD_EXP 94
24772: PPUSH
24773: LD_VAR 0 2
24777: PPUSH
24778: EMPTY
24779: PPUSH
24780: CALL_OW 1
24784: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24785: LD_ADDR_EXP 95
24789: PUSH
24790: LD_EXP 95
24794: PPUSH
24795: LD_VAR 0 2
24799: PPUSH
24800: EMPTY
24801: PPUSH
24802: CALL_OW 1
24806: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24807: LD_ADDR_EXP 96
24811: PUSH
24812: LD_EXP 96
24816: PPUSH
24817: LD_VAR 0 2
24821: PPUSH
24822: EMPTY
24823: PPUSH
24824: CALL_OW 1
24828: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24829: LD_ADDR_EXP 97
24833: PUSH
24834: LD_EXP 97
24838: PPUSH
24839: LD_VAR 0 2
24843: PPUSH
24844: EMPTY
24845: PPUSH
24846: CALL_OW 1
24850: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24851: LD_ADDR_EXP 98
24855: PUSH
24856: LD_EXP 98
24860: PPUSH
24861: LD_VAR 0 2
24865: PPUSH
24866: EMPTY
24867: PPUSH
24868: CALL_OW 1
24872: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24873: LD_ADDR_EXP 99
24877: PUSH
24878: LD_EXP 99
24882: PPUSH
24883: LD_VAR 0 2
24887: PPUSH
24888: EMPTY
24889: PPUSH
24890: CALL_OW 1
24894: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24895: LD_ADDR_EXP 100
24899: PUSH
24900: LD_EXP 100
24904: PPUSH
24905: LD_VAR 0 2
24909: PPUSH
24910: EMPTY
24911: PPUSH
24912: CALL_OW 1
24916: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24917: LD_ADDR_EXP 89
24921: PUSH
24922: LD_EXP 89
24926: PPUSH
24927: LD_VAR 0 2
24931: PPUSH
24932: LD_INT 0
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24940: LD_ADDR_EXP 102
24944: PUSH
24945: LD_EXP 102
24949: PPUSH
24950: LD_VAR 0 2
24954: PPUSH
24955: LD_INT 0
24957: PPUSH
24958: CALL_OW 1
24962: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24963: LD_ADDR_EXP 90
24967: PUSH
24968: LD_EXP 90
24972: PPUSH
24973: LD_VAR 0 2
24977: PPUSH
24978: EMPTY
24979: PPUSH
24980: CALL_OW 1
24984: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24985: LD_ADDR_EXP 101
24989: PUSH
24990: LD_EXP 101
24994: PPUSH
24995: LD_VAR 0 2
24999: PPUSH
25000: LD_INT 0
25002: PPUSH
25003: CALL_OW 1
25007: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25008: LD_ADDR_EXP 103
25012: PUSH
25013: LD_EXP 103
25017: PPUSH
25018: LD_VAR 0 2
25022: PPUSH
25023: EMPTY
25024: PPUSH
25025: CALL_OW 1
25029: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25030: LD_ADDR_EXP 106
25034: PUSH
25035: LD_EXP 106
25039: PPUSH
25040: LD_VAR 0 2
25044: PPUSH
25045: LD_INT 0
25047: PPUSH
25048: CALL_OW 1
25052: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25053: LD_ADDR_EXP 107
25057: PUSH
25058: LD_EXP 107
25062: PPUSH
25063: LD_VAR 0 2
25067: PPUSH
25068: EMPTY
25069: PPUSH
25070: CALL_OW 1
25074: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25075: LD_ADDR_EXP 108
25079: PUSH
25080: LD_EXP 108
25084: PPUSH
25085: LD_VAR 0 2
25089: PPUSH
25090: EMPTY
25091: PPUSH
25092: CALL_OW 1
25096: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25097: LD_ADDR_EXP 109
25101: PUSH
25102: LD_EXP 109
25106: PPUSH
25107: LD_VAR 0 2
25111: PPUSH
25112: EMPTY
25113: PPUSH
25114: CALL_OW 1
25118: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25119: LD_ADDR_EXP 111
25123: PUSH
25124: LD_EXP 111
25128: PPUSH
25129: LD_VAR 0 2
25133: PPUSH
25134: LD_EXP 78
25138: PUSH
25139: LD_VAR 0 2
25143: ARRAY
25144: PPUSH
25145: LD_INT 2
25147: PUSH
25148: LD_INT 30
25150: PUSH
25151: LD_INT 6
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 30
25160: PUSH
25161: LD_INT 7
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 30
25170: PUSH
25171: LD_INT 8
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: PPUSH
25184: CALL_OW 72
25188: PPUSH
25189: CALL_OW 1
25193: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25194: LD_ADDR_EXP 112
25198: PUSH
25199: LD_EXP 112
25203: PPUSH
25204: LD_VAR 0 2
25208: PPUSH
25209: EMPTY
25210: PPUSH
25211: CALL_OW 1
25215: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25216: LD_ADDR_EXP 113
25220: PUSH
25221: LD_EXP 113
25225: PPUSH
25226: LD_VAR 0 2
25230: PPUSH
25231: EMPTY
25232: PPUSH
25233: CALL_OW 1
25237: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25238: LD_ADDR_EXP 114
25242: PUSH
25243: LD_EXP 114
25247: PPUSH
25248: LD_VAR 0 2
25252: PPUSH
25253: EMPTY
25254: PPUSH
25255: CALL_OW 1
25259: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25260: LD_ADDR_EXP 115
25264: PUSH
25265: LD_EXP 115
25269: PPUSH
25270: LD_VAR 0 2
25274: PPUSH
25275: EMPTY
25276: PPUSH
25277: CALL_OW 1
25281: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25282: LD_ADDR_EXP 116
25286: PUSH
25287: LD_EXP 116
25291: PPUSH
25292: LD_VAR 0 2
25296: PPUSH
25297: EMPTY
25298: PPUSH
25299: CALL_OW 1
25303: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25304: LD_ADDR_EXP 117
25308: PUSH
25309: LD_EXP 117
25313: PPUSH
25314: LD_VAR 0 2
25318: PPUSH
25319: EMPTY
25320: PPUSH
25321: CALL_OW 1
25325: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25326: LD_ADDR_EXP 118
25330: PUSH
25331: LD_EXP 118
25335: PPUSH
25336: LD_VAR 0 2
25340: PPUSH
25341: EMPTY
25342: PPUSH
25343: CALL_OW 1
25347: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25348: LD_ADDR_EXP 119
25352: PUSH
25353: LD_EXP 119
25357: PPUSH
25358: LD_VAR 0 2
25362: PPUSH
25363: EMPTY
25364: PPUSH
25365: CALL_OW 1
25369: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25370: LD_ADDR_EXP 120
25374: PUSH
25375: LD_EXP 120
25379: PPUSH
25380: LD_VAR 0 2
25384: PPUSH
25385: LD_INT 0
25387: PPUSH
25388: CALL_OW 1
25392: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25393: LD_ADDR_EXP 121
25397: PUSH
25398: LD_EXP 121
25402: PPUSH
25403: LD_VAR 0 2
25407: PPUSH
25408: LD_INT 0
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// end ;
25416: GO 24317
25418: POP
25419: POP
// MC_InitSides ( ) ;
25420: CALL 25706 0 0
// MC_InitResearch ( ) ;
25424: CALL 25445 0 0
// CustomInitMacro ( ) ;
25428: CALL 228 0 0
// skirmish := true ;
25432: LD_ADDR_EXP 76
25436: PUSH
25437: LD_INT 1
25439: ST_TO_ADDR
// end ;
25440: LD_VAR 0 1
25444: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25445: LD_INT 0
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
// if not mc_bases then
25453: LD_EXP 78
25457: NOT
25458: IFFALSE 25462
// exit ;
25460: GO 25701
// for i = 1 to 8 do
25462: LD_ADDR_VAR 0 2
25466: PUSH
25467: DOUBLE
25468: LD_INT 1
25470: DEC
25471: ST_TO_ADDR
25472: LD_INT 8
25474: PUSH
25475: FOR_TO
25476: IFFALSE 25502
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25478: LD_ADDR_EXP 105
25482: PUSH
25483: LD_EXP 105
25487: PPUSH
25488: LD_VAR 0 2
25492: PPUSH
25493: EMPTY
25494: PPUSH
25495: CALL_OW 1
25499: ST_TO_ADDR
25500: GO 25475
25502: POP
25503: POP
// tmp := [ ] ;
25504: LD_ADDR_VAR 0 5
25508: PUSH
25509: EMPTY
25510: ST_TO_ADDR
// for i = 1 to mc_sides do
25511: LD_ADDR_VAR 0 2
25515: PUSH
25516: DOUBLE
25517: LD_INT 1
25519: DEC
25520: ST_TO_ADDR
25521: LD_EXP 104
25525: PUSH
25526: FOR_TO
25527: IFFALSE 25585
// if not mc_sides [ i ] in tmp then
25529: LD_EXP 104
25533: PUSH
25534: LD_VAR 0 2
25538: ARRAY
25539: PUSH
25540: LD_VAR 0 5
25544: IN
25545: NOT
25546: IFFALSE 25583
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25548: LD_ADDR_VAR 0 5
25552: PUSH
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_VAR 0 5
25562: PUSH
25563: LD_INT 1
25565: PLUS
25566: PPUSH
25567: LD_EXP 104
25571: PUSH
25572: LD_VAR 0 2
25576: ARRAY
25577: PPUSH
25578: CALL_OW 2
25582: ST_TO_ADDR
25583: GO 25526
25585: POP
25586: POP
// if not tmp then
25587: LD_VAR 0 5
25591: NOT
25592: IFFALSE 25596
// exit ;
25594: GO 25701
// for j in tmp do
25596: LD_ADDR_VAR 0 3
25600: PUSH
25601: LD_VAR 0 5
25605: PUSH
25606: FOR_IN
25607: IFFALSE 25699
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25609: LD_ADDR_VAR 0 6
25613: PUSH
25614: LD_INT 22
25616: PUSH
25617: LD_VAR 0 3
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: PPUSH
25626: CALL_OW 69
25630: ST_TO_ADDR
// if not un then
25631: LD_VAR 0 6
25635: NOT
25636: IFFALSE 25640
// continue ;
25638: GO 25606
// nation := GetNation ( un [ 1 ] ) ;
25640: LD_ADDR_VAR 0 4
25644: PUSH
25645: LD_VAR 0 6
25649: PUSH
25650: LD_INT 1
25652: ARRAY
25653: PPUSH
25654: CALL_OW 248
25658: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25659: LD_ADDR_EXP 105
25663: PUSH
25664: LD_EXP 105
25668: PPUSH
25669: LD_VAR 0 3
25673: PPUSH
25674: LD_VAR 0 3
25678: PPUSH
25679: LD_VAR 0 4
25683: PPUSH
25684: LD_INT 1
25686: PPUSH
25687: CALL 52875 0 3
25691: PPUSH
25692: CALL_OW 1
25696: ST_TO_ADDR
// end ;
25697: GO 25606
25699: POP
25700: POP
// end ;
25701: LD_VAR 0 1
25705: RET
// export function MC_InitSides ( ) ; var i ; begin
25706: LD_INT 0
25708: PPUSH
25709: PPUSH
// if not mc_bases then
25710: LD_EXP 78
25714: NOT
25715: IFFALSE 25719
// exit ;
25717: GO 25793
// for i = 1 to mc_bases do
25719: LD_ADDR_VAR 0 2
25723: PUSH
25724: DOUBLE
25725: LD_INT 1
25727: DEC
25728: ST_TO_ADDR
25729: LD_EXP 78
25733: PUSH
25734: FOR_TO
25735: IFFALSE 25791
// if mc_bases [ i ] then
25737: LD_EXP 78
25741: PUSH
25742: LD_VAR 0 2
25746: ARRAY
25747: IFFALSE 25789
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25749: LD_ADDR_EXP 104
25753: PUSH
25754: LD_EXP 104
25758: PPUSH
25759: LD_VAR 0 2
25763: PPUSH
25764: LD_EXP 78
25768: PUSH
25769: LD_VAR 0 2
25773: ARRAY
25774: PUSH
25775: LD_INT 1
25777: ARRAY
25778: PPUSH
25779: CALL_OW 255
25783: PPUSH
25784: CALL_OW 1
25788: ST_TO_ADDR
25789: GO 25734
25791: POP
25792: POP
// end ;
25793: LD_VAR 0 1
25797: RET
// every 0 0$03 trigger skirmish do
25798: LD_EXP 76
25802: IFFALSE 25956
25804: GO 25806
25806: DISABLE
// begin enable ;
25807: ENABLE
// MC_CheckBuildings ( ) ;
25808: CALL 30454 0 0
// MC_CheckPeopleLife ( ) ;
25812: CALL 30615 0 0
// RaiseSailEvent ( 100 ) ;
25816: LD_INT 100
25818: PPUSH
25819: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25823: LD_INT 103
25825: PPUSH
25826: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25830: LD_INT 104
25832: PPUSH
25833: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25837: LD_INT 105
25839: PPUSH
25840: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25844: LD_INT 106
25846: PPUSH
25847: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25851: LD_INT 107
25853: PPUSH
25854: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25858: LD_INT 108
25860: PPUSH
25861: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25865: LD_INT 109
25867: PPUSH
25868: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25872: LD_INT 110
25874: PPUSH
25875: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25879: LD_INT 111
25881: PPUSH
25882: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25886: LD_INT 112
25888: PPUSH
25889: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25893: LD_INT 113
25895: PPUSH
25896: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25900: LD_INT 120
25902: PPUSH
25903: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25907: LD_INT 121
25909: PPUSH
25910: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25914: LD_INT 122
25916: PPUSH
25917: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25921: LD_INT 123
25923: PPUSH
25924: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25928: LD_INT 124
25930: PPUSH
25931: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25935: LD_INT 125
25937: PPUSH
25938: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25942: LD_INT 126
25944: PPUSH
25945: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25949: LD_INT 200
25951: PPUSH
25952: CALL_OW 427
// end ;
25956: END
// on SailEvent ( event ) do begin if event < 100 then
25957: LD_VAR 0 1
25961: PUSH
25962: LD_INT 100
25964: LESS
25965: IFFALSE 25976
// CustomEvent ( event ) ;
25967: LD_VAR 0 1
25971: PPUSH
25972: CALL 11249 0 1
// if event = 100 then
25976: LD_VAR 0 1
25980: PUSH
25981: LD_INT 100
25983: EQUAL
25984: IFFALSE 25990
// MC_ClassManager ( ) ;
25986: CALL 26382 0 0
// if event = 101 then
25990: LD_VAR 0 1
25994: PUSH
25995: LD_INT 101
25997: EQUAL
25998: IFFALSE 26004
// MC_RepairBuildings ( ) ;
26000: CALL 31200 0 0
// if event = 102 then
26004: LD_VAR 0 1
26008: PUSH
26009: LD_INT 102
26011: EQUAL
26012: IFFALSE 26018
// MC_Heal ( ) ;
26014: CALL 32135 0 0
// if event = 103 then
26018: LD_VAR 0 1
26022: PUSH
26023: LD_INT 103
26025: EQUAL
26026: IFFALSE 26032
// MC_Build ( ) ;
26028: CALL 32557 0 0
// if event = 104 then
26032: LD_VAR 0 1
26036: PUSH
26037: LD_INT 104
26039: EQUAL
26040: IFFALSE 26046
// MC_TurretWeapon ( ) ;
26042: CALL 34191 0 0
// if event = 105 then
26046: LD_VAR 0 1
26050: PUSH
26051: LD_INT 105
26053: EQUAL
26054: IFFALSE 26060
// MC_BuildUpgrade ( ) ;
26056: CALL 33742 0 0
// if event = 106 then
26060: LD_VAR 0 1
26064: PUSH
26065: LD_INT 106
26067: EQUAL
26068: IFFALSE 26074
// MC_PlantMines ( ) ;
26070: CALL 34621 0 0
// if event = 107 then
26074: LD_VAR 0 1
26078: PUSH
26079: LD_INT 107
26081: EQUAL
26082: IFFALSE 26088
// MC_CollectCrates ( ) ;
26084: CALL 35419 0 0
// if event = 108 then
26088: LD_VAR 0 1
26092: PUSH
26093: LD_INT 108
26095: EQUAL
26096: IFFALSE 26102
// MC_LinkRemoteControl ( ) ;
26098: CALL 37269 0 0
// if event = 109 then
26102: LD_VAR 0 1
26106: PUSH
26107: LD_INT 109
26109: EQUAL
26110: IFFALSE 26116
// MC_ProduceVehicle ( ) ;
26112: CALL 37450 0 0
// if event = 110 then
26116: LD_VAR 0 1
26120: PUSH
26121: LD_INT 110
26123: EQUAL
26124: IFFALSE 26130
// MC_SendAttack ( ) ;
26126: CALL 37916 0 0
// if event = 111 then
26130: LD_VAR 0 1
26134: PUSH
26135: LD_INT 111
26137: EQUAL
26138: IFFALSE 26144
// MC_Defend ( ) ;
26140: CALL 38024 0 0
// if event = 112 then
26144: LD_VAR 0 1
26148: PUSH
26149: LD_INT 112
26151: EQUAL
26152: IFFALSE 26158
// MC_Research ( ) ;
26154: CALL 38904 0 0
// if event = 113 then
26158: LD_VAR 0 1
26162: PUSH
26163: LD_INT 113
26165: EQUAL
26166: IFFALSE 26172
// MC_MinesTrigger ( ) ;
26168: CALL 40018 0 0
// if event = 120 then
26172: LD_VAR 0 1
26176: PUSH
26177: LD_INT 120
26179: EQUAL
26180: IFFALSE 26186
// MC_RepairVehicle ( ) ;
26182: CALL 40117 0 0
// if event = 121 then
26186: LD_VAR 0 1
26190: PUSH
26191: LD_INT 121
26193: EQUAL
26194: IFFALSE 26200
// MC_TameApe ( ) ;
26196: CALL 40886 0 0
// if event = 122 then
26200: LD_VAR 0 1
26204: PUSH
26205: LD_INT 122
26207: EQUAL
26208: IFFALSE 26214
// MC_ChangeApeClass ( ) ;
26210: CALL 41715 0 0
// if event = 123 then
26214: LD_VAR 0 1
26218: PUSH
26219: LD_INT 123
26221: EQUAL
26222: IFFALSE 26228
// MC_Bazooka ( ) ;
26224: CALL 42365 0 0
// if event = 124 then
26228: LD_VAR 0 1
26232: PUSH
26233: LD_INT 124
26235: EQUAL
26236: IFFALSE 26242
// MC_TeleportExit ( ) ;
26238: CALL 42563 0 0
// if event = 125 then
26242: LD_VAR 0 1
26246: PUSH
26247: LD_INT 125
26249: EQUAL
26250: IFFALSE 26256
// MC_Deposits ( ) ;
26252: CALL 43210 0 0
// if event = 126 then
26256: LD_VAR 0 1
26260: PUSH
26261: LD_INT 126
26263: EQUAL
26264: IFFALSE 26270
// MC_RemoteDriver ( ) ;
26266: CALL 43835 0 0
// if event = 200 then
26270: LD_VAR 0 1
26274: PUSH
26275: LD_INT 200
26277: EQUAL
26278: IFFALSE 26284
// MC_Idle ( ) ;
26280: CALL 45742 0 0
// end ;
26284: PPOPN 1
26286: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26287: LD_INT 0
26289: PPUSH
26290: PPUSH
// if not mc_bases [ base ] or not tag then
26291: LD_EXP 78
26295: PUSH
26296: LD_VAR 0 1
26300: ARRAY
26301: NOT
26302: PUSH
26303: LD_VAR 0 2
26307: NOT
26308: OR
26309: IFFALSE 26313
// exit ;
26311: GO 26377
// for i in mc_bases [ base ] union mc_ape [ base ] do
26313: LD_ADDR_VAR 0 4
26317: PUSH
26318: LD_EXP 78
26322: PUSH
26323: LD_VAR 0 1
26327: ARRAY
26328: PUSH
26329: LD_EXP 107
26333: PUSH
26334: LD_VAR 0 1
26338: ARRAY
26339: UNION
26340: PUSH
26341: FOR_IN
26342: IFFALSE 26375
// if GetTag ( i ) = tag then
26344: LD_VAR 0 4
26348: PPUSH
26349: CALL_OW 110
26353: PUSH
26354: LD_VAR 0 2
26358: EQUAL
26359: IFFALSE 26373
// SetTag ( i , 0 ) ;
26361: LD_VAR 0 4
26365: PPUSH
26366: LD_INT 0
26368: PPUSH
26369: CALL_OW 109
26373: GO 26341
26375: POP
26376: POP
// end ;
26377: LD_VAR 0 3
26381: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26382: LD_INT 0
26384: PPUSH
26385: PPUSH
26386: PPUSH
26387: PPUSH
26388: PPUSH
26389: PPUSH
26390: PPUSH
26391: PPUSH
// if not mc_bases then
26392: LD_EXP 78
26396: NOT
26397: IFFALSE 26401
// exit ;
26399: GO 26859
// for i = 1 to mc_bases do
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: DOUBLE
26407: LD_INT 1
26409: DEC
26410: ST_TO_ADDR
26411: LD_EXP 78
26415: PUSH
26416: FOR_TO
26417: IFFALSE 26857
// begin tmp := MC_ClassCheckReq ( i ) ;
26419: LD_ADDR_VAR 0 4
26423: PUSH
26424: LD_VAR 0 2
26428: PPUSH
26429: CALL 26864 0 1
26433: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26434: LD_ADDR_EXP 119
26438: PUSH
26439: LD_EXP 119
26443: PPUSH
26444: LD_VAR 0 2
26448: PPUSH
26449: LD_VAR 0 4
26453: PPUSH
26454: CALL_OW 1
26458: ST_TO_ADDR
// if not tmp then
26459: LD_VAR 0 4
26463: NOT
26464: IFFALSE 26468
// continue ;
26466: GO 26416
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26468: LD_ADDR_VAR 0 6
26472: PUSH
26473: LD_EXP 78
26477: PUSH
26478: LD_VAR 0 2
26482: ARRAY
26483: PPUSH
26484: LD_INT 2
26486: PUSH
26487: LD_INT 30
26489: PUSH
26490: LD_INT 4
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 5
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: LIST
26511: PPUSH
26512: CALL_OW 72
26516: PUSH
26517: LD_EXP 78
26521: PUSH
26522: LD_VAR 0 2
26526: ARRAY
26527: PPUSH
26528: LD_INT 2
26530: PUSH
26531: LD_INT 30
26533: PUSH
26534: LD_INT 0
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 30
26543: PUSH
26544: LD_INT 1
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL_OW 72
26560: PUSH
26561: LD_EXP 78
26565: PUSH
26566: LD_VAR 0 2
26570: ARRAY
26571: PPUSH
26572: LD_INT 30
26574: PUSH
26575: LD_INT 3
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 72
26586: PUSH
26587: LD_EXP 78
26591: PUSH
26592: LD_VAR 0 2
26596: ARRAY
26597: PPUSH
26598: LD_INT 2
26600: PUSH
26601: LD_INT 30
26603: PUSH
26604: LD_INT 6
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: LD_INT 30
26613: PUSH
26614: LD_INT 7
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 30
26623: PUSH
26624: LD_INT 8
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: PPUSH
26637: CALL_OW 72
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: ST_TO_ADDR
// for j = 1 to 4 do
26648: LD_ADDR_VAR 0 3
26652: PUSH
26653: DOUBLE
26654: LD_INT 1
26656: DEC
26657: ST_TO_ADDR
26658: LD_INT 4
26660: PUSH
26661: FOR_TO
26662: IFFALSE 26853
// begin if not tmp [ j ] then
26664: LD_VAR 0 4
26668: PUSH
26669: LD_VAR 0 3
26673: ARRAY
26674: NOT
26675: IFFALSE 26679
// continue ;
26677: GO 26661
// for p in tmp [ j ] do
26679: LD_ADDR_VAR 0 5
26683: PUSH
26684: LD_VAR 0 4
26688: PUSH
26689: LD_VAR 0 3
26693: ARRAY
26694: PUSH
26695: FOR_IN
26696: IFFALSE 26849
// begin if not b [ j ] then
26698: LD_VAR 0 6
26702: PUSH
26703: LD_VAR 0 3
26707: ARRAY
26708: NOT
26709: IFFALSE 26713
// break ;
26711: GO 26849
// e := 0 ;
26713: LD_ADDR_VAR 0 7
26717: PUSH
26718: LD_INT 0
26720: ST_TO_ADDR
// for k in b [ j ] do
26721: LD_ADDR_VAR 0 8
26725: PUSH
26726: LD_VAR 0 6
26730: PUSH
26731: LD_VAR 0 3
26735: ARRAY
26736: PUSH
26737: FOR_IN
26738: IFFALSE 26765
// if IsNotFull ( k ) then
26740: LD_VAR 0 8
26744: PPUSH
26745: CALL 54996 0 1
26749: IFFALSE 26763
// begin e := k ;
26751: LD_ADDR_VAR 0 7
26755: PUSH
26756: LD_VAR 0 8
26760: ST_TO_ADDR
// break ;
26761: GO 26765
// end ;
26763: GO 26737
26765: POP
26766: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26767: LD_VAR 0 7
26771: PUSH
26772: LD_VAR 0 5
26776: PPUSH
26777: LD_VAR 0 7
26781: PPUSH
26782: CALL 88749 0 2
26786: NOT
26787: AND
26788: IFFALSE 26847
// begin if IsInUnit ( p ) then
26790: LD_VAR 0 5
26794: PPUSH
26795: CALL_OW 310
26799: IFFALSE 26810
// ComExitBuilding ( p ) ;
26801: LD_VAR 0 5
26805: PPUSH
26806: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26810: LD_VAR 0 5
26814: PPUSH
26815: LD_VAR 0 7
26819: PPUSH
26820: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26824: LD_VAR 0 5
26828: PPUSH
26829: LD_VAR 0 3
26833: PPUSH
26834: CALL_OW 183
// AddComExitBuilding ( p ) ;
26838: LD_VAR 0 5
26842: PPUSH
26843: CALL_OW 182
// end ; end ;
26847: GO 26695
26849: POP
26850: POP
// end ;
26851: GO 26661
26853: POP
26854: POP
// end ;
26855: GO 26416
26857: POP
26858: POP
// end ;
26859: LD_VAR 0 1
26863: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26864: LD_INT 0
26866: PPUSH
26867: PPUSH
26868: PPUSH
26869: PPUSH
26870: PPUSH
26871: PPUSH
26872: PPUSH
26873: PPUSH
26874: PPUSH
26875: PPUSH
26876: PPUSH
26877: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26878: LD_VAR 0 1
26882: NOT
26883: PUSH
26884: LD_EXP 78
26888: PUSH
26889: LD_VAR 0 1
26893: ARRAY
26894: NOT
26895: OR
26896: PUSH
26897: LD_EXP 78
26901: PUSH
26902: LD_VAR 0 1
26906: ARRAY
26907: PPUSH
26908: LD_INT 2
26910: PUSH
26911: LD_INT 30
26913: PUSH
26914: LD_INT 0
26916: PUSH
26917: EMPTY
26918: LIST
26919: LIST
26920: PUSH
26921: LD_INT 30
26923: PUSH
26924: LD_INT 1
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: LIST
26935: PPUSH
26936: CALL_OW 72
26940: NOT
26941: OR
26942: IFFALSE 26946
// exit ;
26944: GO 30449
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26946: LD_ADDR_VAR 0 4
26950: PUSH
26951: LD_EXP 78
26955: PUSH
26956: LD_VAR 0 1
26960: ARRAY
26961: PPUSH
26962: LD_INT 2
26964: PUSH
26965: LD_INT 25
26967: PUSH
26968: LD_INT 1
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 25
26977: PUSH
26978: LD_INT 2
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 25
26987: PUSH
26988: LD_INT 3
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 25
26997: PUSH
26998: LD_INT 4
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PUSH
27005: LD_INT 25
27007: PUSH
27008: LD_INT 5
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 25
27017: PUSH
27018: LD_INT 8
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: LD_INT 25
27027: PUSH
27028: LD_INT 9
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: LIST
27039: LIST
27040: LIST
27041: LIST
27042: LIST
27043: LIST
27044: PPUSH
27045: CALL_OW 72
27049: ST_TO_ADDR
// if not tmp then
27050: LD_VAR 0 4
27054: NOT
27055: IFFALSE 27059
// exit ;
27057: GO 30449
// for i in tmp do
27059: LD_ADDR_VAR 0 3
27063: PUSH
27064: LD_VAR 0 4
27068: PUSH
27069: FOR_IN
27070: IFFALSE 27101
// if GetTag ( i ) then
27072: LD_VAR 0 3
27076: PPUSH
27077: CALL_OW 110
27081: IFFALSE 27099
// tmp := tmp diff i ;
27083: LD_ADDR_VAR 0 4
27087: PUSH
27088: LD_VAR 0 4
27092: PUSH
27093: LD_VAR 0 3
27097: DIFF
27098: ST_TO_ADDR
27099: GO 27069
27101: POP
27102: POP
// if not tmp then
27103: LD_VAR 0 4
27107: NOT
27108: IFFALSE 27112
// exit ;
27110: GO 30449
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27112: LD_ADDR_VAR 0 5
27116: PUSH
27117: LD_EXP 78
27121: PUSH
27122: LD_VAR 0 1
27126: ARRAY
27127: PPUSH
27128: LD_INT 2
27130: PUSH
27131: LD_INT 25
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 25
27143: PUSH
27144: LD_INT 5
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 25
27153: PUSH
27154: LD_INT 8
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 25
27163: PUSH
27164: LD_INT 9
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: LIST
27175: LIST
27176: LIST
27177: PPUSH
27178: CALL_OW 72
27182: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27183: LD_ADDR_VAR 0 6
27187: PUSH
27188: LD_EXP 78
27192: PUSH
27193: LD_VAR 0 1
27197: ARRAY
27198: PPUSH
27199: LD_INT 25
27201: PUSH
27202: LD_INT 2
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PPUSH
27209: CALL_OW 72
27213: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27214: LD_ADDR_VAR 0 7
27218: PUSH
27219: LD_EXP 78
27223: PUSH
27224: LD_VAR 0 1
27228: ARRAY
27229: PPUSH
27230: LD_INT 25
27232: PUSH
27233: LD_INT 3
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PPUSH
27240: CALL_OW 72
27244: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27245: LD_ADDR_VAR 0 8
27249: PUSH
27250: LD_EXP 78
27254: PUSH
27255: LD_VAR 0 1
27259: ARRAY
27260: PPUSH
27261: LD_INT 25
27263: PUSH
27264: LD_INT 4
27266: PUSH
27267: EMPTY
27268: LIST
27269: LIST
27270: PUSH
27271: LD_INT 24
27273: PUSH
27274: LD_INT 251
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: EMPTY
27282: LIST
27283: LIST
27284: PPUSH
27285: CALL_OW 72
27289: ST_TO_ADDR
// if mc_is_defending [ base ] then
27290: LD_EXP 121
27294: PUSH
27295: LD_VAR 0 1
27299: ARRAY
27300: IFFALSE 27761
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27302: LD_ADDR_EXP 120
27306: PUSH
27307: LD_EXP 120
27311: PPUSH
27312: LD_VAR 0 1
27316: PPUSH
27317: LD_INT 4
27319: PPUSH
27320: CALL_OW 1
27324: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27325: LD_ADDR_VAR 0 12
27329: PUSH
27330: LD_EXP 78
27334: PUSH
27335: LD_VAR 0 1
27339: ARRAY
27340: PPUSH
27341: LD_INT 2
27343: PUSH
27344: LD_INT 30
27346: PUSH
27347: LD_INT 4
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 30
27356: PUSH
27357: LD_INT 5
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: LIST
27368: PPUSH
27369: CALL_OW 72
27373: ST_TO_ADDR
// if not b then
27374: LD_VAR 0 12
27378: NOT
27379: IFFALSE 27383
// exit ;
27381: GO 30449
// p := [ ] ;
27383: LD_ADDR_VAR 0 11
27387: PUSH
27388: EMPTY
27389: ST_TO_ADDR
// if sci >= 2 then
27390: LD_VAR 0 8
27394: PUSH
27395: LD_INT 2
27397: GREATEREQUAL
27398: IFFALSE 27429
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27400: LD_ADDR_VAR 0 8
27404: PUSH
27405: LD_VAR 0 8
27409: PUSH
27410: LD_INT 1
27412: ARRAY
27413: PUSH
27414: LD_VAR 0 8
27418: PUSH
27419: LD_INT 2
27421: ARRAY
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: ST_TO_ADDR
27427: GO 27490
// if sci = 1 then
27429: LD_VAR 0 8
27433: PUSH
27434: LD_INT 1
27436: EQUAL
27437: IFFALSE 27458
// sci := [ sci [ 1 ] ] else
27439: LD_ADDR_VAR 0 8
27443: PUSH
27444: LD_VAR 0 8
27448: PUSH
27449: LD_INT 1
27451: ARRAY
27452: PUSH
27453: EMPTY
27454: LIST
27455: ST_TO_ADDR
27456: GO 27490
// if sci = 0 then
27458: LD_VAR 0 8
27462: PUSH
27463: LD_INT 0
27465: EQUAL
27466: IFFALSE 27490
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27468: LD_ADDR_VAR 0 11
27472: PUSH
27473: LD_VAR 0 4
27477: PPUSH
27478: LD_INT 4
27480: PPUSH
27481: CALL 88621 0 2
27485: PUSH
27486: LD_INT 1
27488: ARRAY
27489: ST_TO_ADDR
// if eng > 4 then
27490: LD_VAR 0 6
27494: PUSH
27495: LD_INT 4
27497: GREATER
27498: IFFALSE 27544
// for i = eng downto 4 do
27500: LD_ADDR_VAR 0 3
27504: PUSH
27505: DOUBLE
27506: LD_VAR 0 6
27510: INC
27511: ST_TO_ADDR
27512: LD_INT 4
27514: PUSH
27515: FOR_DOWNTO
27516: IFFALSE 27542
// eng := eng diff eng [ i ] ;
27518: LD_ADDR_VAR 0 6
27522: PUSH
27523: LD_VAR 0 6
27527: PUSH
27528: LD_VAR 0 6
27532: PUSH
27533: LD_VAR 0 3
27537: ARRAY
27538: DIFF
27539: ST_TO_ADDR
27540: GO 27515
27542: POP
27543: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27544: LD_ADDR_VAR 0 4
27548: PUSH
27549: LD_VAR 0 4
27553: PUSH
27554: LD_VAR 0 5
27558: PUSH
27559: LD_VAR 0 6
27563: UNION
27564: PUSH
27565: LD_VAR 0 7
27569: UNION
27570: PUSH
27571: LD_VAR 0 8
27575: UNION
27576: DIFF
27577: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
27578: LD_ADDR_VAR 0 13
27582: PUSH
27583: LD_EXP 78
27587: PUSH
27588: LD_VAR 0 1
27592: ARRAY
27593: PPUSH
27594: LD_INT 2
27596: PUSH
27597: LD_INT 30
27599: PUSH
27600: LD_INT 32
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PUSH
27607: LD_INT 30
27609: PUSH
27610: LD_INT 31
27612: PUSH
27613: EMPTY
27614: LIST
27615: LIST
27616: PUSH
27617: EMPTY
27618: LIST
27619: LIST
27620: LIST
27621: PPUSH
27622: CALL_OW 72
27626: PUSH
27627: LD_EXP 78
27631: PUSH
27632: LD_VAR 0 1
27636: ARRAY
27637: PPUSH
27638: LD_INT 2
27640: PUSH
27641: LD_INT 30
27643: PUSH
27644: LD_INT 4
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 30
27653: PUSH
27654: LD_INT 5
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: LIST
27665: PPUSH
27666: CALL_OW 72
27670: PUSH
27671: LD_INT 6
27673: MUL
27674: PLUS
27675: ST_TO_ADDR
// if bcount < tmp then
27676: LD_VAR 0 13
27680: PUSH
27681: LD_VAR 0 4
27685: LESS
27686: IFFALSE 27732
// for i = tmp downto bcount do
27688: LD_ADDR_VAR 0 3
27692: PUSH
27693: DOUBLE
27694: LD_VAR 0 4
27698: INC
27699: ST_TO_ADDR
27700: LD_VAR 0 13
27704: PUSH
27705: FOR_DOWNTO
27706: IFFALSE 27730
// tmp := Delete ( tmp , tmp ) ;
27708: LD_ADDR_VAR 0 4
27712: PUSH
27713: LD_VAR 0 4
27717: PPUSH
27718: LD_VAR 0 4
27722: PPUSH
27723: CALL_OW 3
27727: ST_TO_ADDR
27728: GO 27705
27730: POP
27731: POP
// result := [ tmp , 0 , 0 , p ] ;
27732: LD_ADDR_VAR 0 2
27736: PUSH
27737: LD_VAR 0 4
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: LD_INT 0
27747: PUSH
27748: LD_VAR 0 11
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: ST_TO_ADDR
// exit ;
27759: GO 30449
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27761: LD_EXP 78
27765: PUSH
27766: LD_VAR 0 1
27770: ARRAY
27771: PPUSH
27772: LD_INT 2
27774: PUSH
27775: LD_INT 30
27777: PUSH
27778: LD_INT 6
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: PUSH
27785: LD_INT 30
27787: PUSH
27788: LD_INT 7
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 30
27797: PUSH
27798: LD_INT 8
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PUSH
27805: EMPTY
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: PPUSH
27811: CALL_OW 72
27815: NOT
27816: PUSH
27817: LD_EXP 78
27821: PUSH
27822: LD_VAR 0 1
27826: ARRAY
27827: PPUSH
27828: LD_INT 30
27830: PUSH
27831: LD_INT 3
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PPUSH
27838: CALL_OW 72
27842: NOT
27843: AND
27844: IFFALSE 27916
// begin if eng = tmp then
27846: LD_VAR 0 6
27850: PUSH
27851: LD_VAR 0 4
27855: EQUAL
27856: IFFALSE 27860
// exit ;
27858: GO 30449
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27860: LD_ADDR_EXP 120
27864: PUSH
27865: LD_EXP 120
27869: PPUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: LD_INT 1
27877: PPUSH
27878: CALL_OW 1
27882: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27883: LD_ADDR_VAR 0 2
27887: PUSH
27888: LD_INT 0
27890: PUSH
27891: LD_VAR 0 4
27895: PUSH
27896: LD_VAR 0 6
27900: DIFF
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: LD_INT 0
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: ST_TO_ADDR
// exit ;
27914: GO 30449
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27916: LD_EXP 105
27920: PUSH
27921: LD_EXP 104
27925: PUSH
27926: LD_VAR 0 1
27930: ARRAY
27931: ARRAY
27932: PUSH
27933: LD_EXP 78
27937: PUSH
27938: LD_VAR 0 1
27942: ARRAY
27943: PPUSH
27944: LD_INT 2
27946: PUSH
27947: LD_INT 30
27949: PUSH
27950: LD_INT 6
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PUSH
27957: LD_INT 30
27959: PUSH
27960: LD_INT 7
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 30
27969: PUSH
27970: LD_INT 8
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: LIST
27981: LIST
27982: PPUSH
27983: CALL_OW 72
27987: AND
27988: PUSH
27989: LD_EXP 78
27993: PUSH
27994: LD_VAR 0 1
27998: ARRAY
27999: PPUSH
28000: LD_INT 30
28002: PUSH
28003: LD_INT 3
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PPUSH
28010: CALL_OW 72
28014: NOT
28015: AND
28016: IFFALSE 28230
// begin if sci >= 6 then
28018: LD_VAR 0 8
28022: PUSH
28023: LD_INT 6
28025: GREATEREQUAL
28026: IFFALSE 28030
// exit ;
28028: GO 30449
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28030: LD_ADDR_EXP 120
28034: PUSH
28035: LD_EXP 120
28039: PPUSH
28040: LD_VAR 0 1
28044: PPUSH
28045: LD_INT 2
28047: PPUSH
28048: CALL_OW 1
28052: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28053: LD_ADDR_VAR 0 9
28057: PUSH
28058: LD_VAR 0 4
28062: PUSH
28063: LD_VAR 0 8
28067: DIFF
28068: PPUSH
28069: LD_INT 4
28071: PPUSH
28072: CALL 88621 0 2
28076: ST_TO_ADDR
// p := [ ] ;
28077: LD_ADDR_VAR 0 11
28081: PUSH
28082: EMPTY
28083: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28084: LD_VAR 0 8
28088: PUSH
28089: LD_INT 6
28091: LESS
28092: PUSH
28093: LD_VAR 0 9
28097: PUSH
28098: LD_INT 6
28100: GREATER
28101: AND
28102: IFFALSE 28183
// begin for i = 1 to 6 - sci do
28104: LD_ADDR_VAR 0 3
28108: PUSH
28109: DOUBLE
28110: LD_INT 1
28112: DEC
28113: ST_TO_ADDR
28114: LD_INT 6
28116: PUSH
28117: LD_VAR 0 8
28121: MINUS
28122: PUSH
28123: FOR_TO
28124: IFFALSE 28179
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28126: LD_ADDR_VAR 0 11
28130: PUSH
28131: LD_VAR 0 11
28135: PPUSH
28136: LD_VAR 0 11
28140: PUSH
28141: LD_INT 1
28143: PLUS
28144: PPUSH
28145: LD_VAR 0 9
28149: PUSH
28150: LD_INT 1
28152: ARRAY
28153: PPUSH
28154: CALL_OW 2
28158: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28159: LD_ADDR_VAR 0 9
28163: PUSH
28164: LD_VAR 0 9
28168: PPUSH
28169: LD_INT 1
28171: PPUSH
28172: CALL_OW 3
28176: ST_TO_ADDR
// end ;
28177: GO 28123
28179: POP
28180: POP
// end else
28181: GO 28203
// if sort then
28183: LD_VAR 0 9
28187: IFFALSE 28203
// p := sort [ 1 ] ;
28189: LD_ADDR_VAR 0 11
28193: PUSH
28194: LD_VAR 0 9
28198: PUSH
28199: LD_INT 1
28201: ARRAY
28202: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28203: LD_ADDR_VAR 0 2
28207: PUSH
28208: LD_INT 0
28210: PUSH
28211: LD_INT 0
28213: PUSH
28214: LD_INT 0
28216: PUSH
28217: LD_VAR 0 11
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: ST_TO_ADDR
// exit ;
28228: GO 30449
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28230: LD_EXP 105
28234: PUSH
28235: LD_EXP 104
28239: PUSH
28240: LD_VAR 0 1
28244: ARRAY
28245: ARRAY
28246: PUSH
28247: LD_EXP 78
28251: PUSH
28252: LD_VAR 0 1
28256: ARRAY
28257: PPUSH
28258: LD_INT 2
28260: PUSH
28261: LD_INT 30
28263: PUSH
28264: LD_INT 6
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 7
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 30
28283: PUSH
28284: LD_INT 8
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: PPUSH
28297: CALL_OW 72
28301: AND
28302: PUSH
28303: LD_EXP 78
28307: PUSH
28308: LD_VAR 0 1
28312: ARRAY
28313: PPUSH
28314: LD_INT 30
28316: PUSH
28317: LD_INT 3
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PPUSH
28324: CALL_OW 72
28328: AND
28329: IFFALSE 29063
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28331: LD_ADDR_EXP 120
28335: PUSH
28336: LD_EXP 120
28340: PPUSH
28341: LD_VAR 0 1
28345: PPUSH
28346: LD_INT 3
28348: PPUSH
28349: CALL_OW 1
28353: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28354: LD_ADDR_VAR 0 2
28358: PUSH
28359: LD_INT 0
28361: PUSH
28362: LD_INT 0
28364: PUSH
28365: LD_INT 0
28367: PUSH
28368: LD_INT 0
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: ST_TO_ADDR
// if not eng then
28377: LD_VAR 0 6
28381: NOT
28382: IFFALSE 28445
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28384: LD_ADDR_VAR 0 11
28388: PUSH
28389: LD_VAR 0 4
28393: PPUSH
28394: LD_INT 2
28396: PPUSH
28397: CALL 88621 0 2
28401: PUSH
28402: LD_INT 1
28404: ARRAY
28405: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28406: LD_ADDR_VAR 0 2
28410: PUSH
28411: LD_VAR 0 2
28415: PPUSH
28416: LD_INT 2
28418: PPUSH
28419: LD_VAR 0 11
28423: PPUSH
28424: CALL_OW 1
28428: ST_TO_ADDR
// tmp := tmp diff p ;
28429: LD_ADDR_VAR 0 4
28433: PUSH
28434: LD_VAR 0 4
28438: PUSH
28439: LD_VAR 0 11
28443: DIFF
28444: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28445: LD_VAR 0 4
28449: PUSH
28450: LD_VAR 0 8
28454: PUSH
28455: LD_INT 6
28457: LESS
28458: AND
28459: IFFALSE 28647
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28461: LD_ADDR_VAR 0 9
28465: PUSH
28466: LD_VAR 0 4
28470: PUSH
28471: LD_VAR 0 8
28475: PUSH
28476: LD_VAR 0 7
28480: UNION
28481: DIFF
28482: PPUSH
28483: LD_INT 4
28485: PPUSH
28486: CALL 88621 0 2
28490: ST_TO_ADDR
// p := [ ] ;
28491: LD_ADDR_VAR 0 11
28495: PUSH
28496: EMPTY
28497: ST_TO_ADDR
// if sort then
28498: LD_VAR 0 9
28502: IFFALSE 28618
// for i = 1 to 6 - sci do
28504: LD_ADDR_VAR 0 3
28508: PUSH
28509: DOUBLE
28510: LD_INT 1
28512: DEC
28513: ST_TO_ADDR
28514: LD_INT 6
28516: PUSH
28517: LD_VAR 0 8
28521: MINUS
28522: PUSH
28523: FOR_TO
28524: IFFALSE 28616
// begin if i = sort then
28526: LD_VAR 0 3
28530: PUSH
28531: LD_VAR 0 9
28535: EQUAL
28536: IFFALSE 28540
// break ;
28538: GO 28616
// if GetClass ( i ) = 4 then
28540: LD_VAR 0 3
28544: PPUSH
28545: CALL_OW 257
28549: PUSH
28550: LD_INT 4
28552: EQUAL
28553: IFFALSE 28557
// continue ;
28555: GO 28523
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28557: LD_ADDR_VAR 0 11
28561: PUSH
28562: LD_VAR 0 11
28566: PPUSH
28567: LD_VAR 0 11
28571: PUSH
28572: LD_INT 1
28574: PLUS
28575: PPUSH
28576: LD_VAR 0 9
28580: PUSH
28581: LD_VAR 0 3
28585: ARRAY
28586: PPUSH
28587: CALL_OW 2
28591: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28592: LD_ADDR_VAR 0 4
28596: PUSH
28597: LD_VAR 0 4
28601: PUSH
28602: LD_VAR 0 9
28606: PUSH
28607: LD_VAR 0 3
28611: ARRAY
28612: DIFF
28613: ST_TO_ADDR
// end ;
28614: GO 28523
28616: POP
28617: POP
// if p then
28618: LD_VAR 0 11
28622: IFFALSE 28647
// result := Replace ( result , 4 , p ) ;
28624: LD_ADDR_VAR 0 2
28628: PUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: LD_INT 4
28636: PPUSH
28637: LD_VAR 0 11
28641: PPUSH
28642: CALL_OW 1
28646: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28647: LD_VAR 0 4
28651: PUSH
28652: LD_VAR 0 7
28656: PUSH
28657: LD_INT 6
28659: LESS
28660: AND
28661: IFFALSE 28849
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28663: LD_ADDR_VAR 0 9
28667: PUSH
28668: LD_VAR 0 4
28672: PUSH
28673: LD_VAR 0 8
28677: PUSH
28678: LD_VAR 0 7
28682: UNION
28683: DIFF
28684: PPUSH
28685: LD_INT 3
28687: PPUSH
28688: CALL 88621 0 2
28692: ST_TO_ADDR
// p := [ ] ;
28693: LD_ADDR_VAR 0 11
28697: PUSH
28698: EMPTY
28699: ST_TO_ADDR
// if sort then
28700: LD_VAR 0 9
28704: IFFALSE 28820
// for i = 1 to 6 - mech do
28706: LD_ADDR_VAR 0 3
28710: PUSH
28711: DOUBLE
28712: LD_INT 1
28714: DEC
28715: ST_TO_ADDR
28716: LD_INT 6
28718: PUSH
28719: LD_VAR 0 7
28723: MINUS
28724: PUSH
28725: FOR_TO
28726: IFFALSE 28818
// begin if i = sort then
28728: LD_VAR 0 3
28732: PUSH
28733: LD_VAR 0 9
28737: EQUAL
28738: IFFALSE 28742
// break ;
28740: GO 28818
// if GetClass ( i ) = 3 then
28742: LD_VAR 0 3
28746: PPUSH
28747: CALL_OW 257
28751: PUSH
28752: LD_INT 3
28754: EQUAL
28755: IFFALSE 28759
// continue ;
28757: GO 28725
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28759: LD_ADDR_VAR 0 11
28763: PUSH
28764: LD_VAR 0 11
28768: PPUSH
28769: LD_VAR 0 11
28773: PUSH
28774: LD_INT 1
28776: PLUS
28777: PPUSH
28778: LD_VAR 0 9
28782: PUSH
28783: LD_VAR 0 3
28787: ARRAY
28788: PPUSH
28789: CALL_OW 2
28793: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28794: LD_ADDR_VAR 0 4
28798: PUSH
28799: LD_VAR 0 4
28803: PUSH
28804: LD_VAR 0 9
28808: PUSH
28809: LD_VAR 0 3
28813: ARRAY
28814: DIFF
28815: ST_TO_ADDR
// end ;
28816: GO 28725
28818: POP
28819: POP
// if p then
28820: LD_VAR 0 11
28824: IFFALSE 28849
// result := Replace ( result , 3 , p ) ;
28826: LD_ADDR_VAR 0 2
28830: PUSH
28831: LD_VAR 0 2
28835: PPUSH
28836: LD_INT 3
28838: PPUSH
28839: LD_VAR 0 11
28843: PPUSH
28844: CALL_OW 1
28848: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28849: LD_VAR 0 4
28853: PUSH
28854: LD_INT 6
28856: GREATER
28857: PUSH
28858: LD_VAR 0 6
28862: PUSH
28863: LD_INT 6
28865: LESS
28866: AND
28867: IFFALSE 29061
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28869: LD_ADDR_VAR 0 9
28873: PUSH
28874: LD_VAR 0 4
28878: PUSH
28879: LD_VAR 0 8
28883: PUSH
28884: LD_VAR 0 7
28888: UNION
28889: PUSH
28890: LD_VAR 0 6
28894: UNION
28895: DIFF
28896: PPUSH
28897: LD_INT 2
28899: PPUSH
28900: CALL 88621 0 2
28904: ST_TO_ADDR
// p := [ ] ;
28905: LD_ADDR_VAR 0 11
28909: PUSH
28910: EMPTY
28911: ST_TO_ADDR
// if sort then
28912: LD_VAR 0 9
28916: IFFALSE 29032
// for i = 1 to 6 - eng do
28918: LD_ADDR_VAR 0 3
28922: PUSH
28923: DOUBLE
28924: LD_INT 1
28926: DEC
28927: ST_TO_ADDR
28928: LD_INT 6
28930: PUSH
28931: LD_VAR 0 6
28935: MINUS
28936: PUSH
28937: FOR_TO
28938: IFFALSE 29030
// begin if i = sort then
28940: LD_VAR 0 3
28944: PUSH
28945: LD_VAR 0 9
28949: EQUAL
28950: IFFALSE 28954
// break ;
28952: GO 29030
// if GetClass ( i ) = 2 then
28954: LD_VAR 0 3
28958: PPUSH
28959: CALL_OW 257
28963: PUSH
28964: LD_INT 2
28966: EQUAL
28967: IFFALSE 28971
// continue ;
28969: GO 28937
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28971: LD_ADDR_VAR 0 11
28975: PUSH
28976: LD_VAR 0 11
28980: PPUSH
28981: LD_VAR 0 11
28985: PUSH
28986: LD_INT 1
28988: PLUS
28989: PPUSH
28990: LD_VAR 0 9
28994: PUSH
28995: LD_VAR 0 3
28999: ARRAY
29000: PPUSH
29001: CALL_OW 2
29005: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29006: LD_ADDR_VAR 0 4
29010: PUSH
29011: LD_VAR 0 4
29015: PUSH
29016: LD_VAR 0 9
29020: PUSH
29021: LD_VAR 0 3
29025: ARRAY
29026: DIFF
29027: ST_TO_ADDR
// end ;
29028: GO 28937
29030: POP
29031: POP
// if p then
29032: LD_VAR 0 11
29036: IFFALSE 29061
// result := Replace ( result , 2 , p ) ;
29038: LD_ADDR_VAR 0 2
29042: PUSH
29043: LD_VAR 0 2
29047: PPUSH
29048: LD_INT 2
29050: PPUSH
29051: LD_VAR 0 11
29055: PPUSH
29056: CALL_OW 1
29060: ST_TO_ADDR
// end ; exit ;
29061: GO 30449
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29063: LD_EXP 105
29067: PUSH
29068: LD_EXP 104
29072: PUSH
29073: LD_VAR 0 1
29077: ARRAY
29078: ARRAY
29079: NOT
29080: PUSH
29081: LD_EXP 78
29085: PUSH
29086: LD_VAR 0 1
29090: ARRAY
29091: PPUSH
29092: LD_INT 30
29094: PUSH
29095: LD_INT 3
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PPUSH
29102: CALL_OW 72
29106: AND
29107: PUSH
29108: LD_EXP 83
29112: PUSH
29113: LD_VAR 0 1
29117: ARRAY
29118: AND
29119: IFFALSE 29727
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29121: LD_ADDR_EXP 120
29125: PUSH
29126: LD_EXP 120
29130: PPUSH
29131: LD_VAR 0 1
29135: PPUSH
29136: LD_INT 5
29138: PPUSH
29139: CALL_OW 1
29143: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29144: LD_ADDR_VAR 0 2
29148: PUSH
29149: LD_INT 0
29151: PUSH
29152: LD_INT 0
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: LD_INT 0
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: ST_TO_ADDR
// if sci > 1 then
29167: LD_VAR 0 8
29171: PUSH
29172: LD_INT 1
29174: GREATER
29175: IFFALSE 29203
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29177: LD_ADDR_VAR 0 4
29181: PUSH
29182: LD_VAR 0 4
29186: PUSH
29187: LD_VAR 0 8
29191: PUSH
29192: LD_VAR 0 8
29196: PUSH
29197: LD_INT 1
29199: ARRAY
29200: DIFF
29201: DIFF
29202: ST_TO_ADDR
// if tmp and not sci then
29203: LD_VAR 0 4
29207: PUSH
29208: LD_VAR 0 8
29212: NOT
29213: AND
29214: IFFALSE 29283
// begin sort := SortBySkill ( tmp , 4 ) ;
29216: LD_ADDR_VAR 0 9
29220: PUSH
29221: LD_VAR 0 4
29225: PPUSH
29226: LD_INT 4
29228: PPUSH
29229: CALL 88621 0 2
29233: ST_TO_ADDR
// if sort then
29234: LD_VAR 0 9
29238: IFFALSE 29254
// p := sort [ 1 ] ;
29240: LD_ADDR_VAR 0 11
29244: PUSH
29245: LD_VAR 0 9
29249: PUSH
29250: LD_INT 1
29252: ARRAY
29253: ST_TO_ADDR
// if p then
29254: LD_VAR 0 11
29258: IFFALSE 29283
// result := Replace ( result , 4 , p ) ;
29260: LD_ADDR_VAR 0 2
29264: PUSH
29265: LD_VAR 0 2
29269: PPUSH
29270: LD_INT 4
29272: PPUSH
29273: LD_VAR 0 11
29277: PPUSH
29278: CALL_OW 1
29282: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29283: LD_ADDR_VAR 0 4
29287: PUSH
29288: LD_VAR 0 4
29292: PUSH
29293: LD_VAR 0 7
29297: DIFF
29298: ST_TO_ADDR
// if tmp and mech < 6 then
29299: LD_VAR 0 4
29303: PUSH
29304: LD_VAR 0 7
29308: PUSH
29309: LD_INT 6
29311: LESS
29312: AND
29313: IFFALSE 29501
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29315: LD_ADDR_VAR 0 9
29319: PUSH
29320: LD_VAR 0 4
29324: PUSH
29325: LD_VAR 0 8
29329: PUSH
29330: LD_VAR 0 7
29334: UNION
29335: DIFF
29336: PPUSH
29337: LD_INT 3
29339: PPUSH
29340: CALL 88621 0 2
29344: ST_TO_ADDR
// p := [ ] ;
29345: LD_ADDR_VAR 0 11
29349: PUSH
29350: EMPTY
29351: ST_TO_ADDR
// if sort then
29352: LD_VAR 0 9
29356: IFFALSE 29472
// for i = 1 to 6 - mech do
29358: LD_ADDR_VAR 0 3
29362: PUSH
29363: DOUBLE
29364: LD_INT 1
29366: DEC
29367: ST_TO_ADDR
29368: LD_INT 6
29370: PUSH
29371: LD_VAR 0 7
29375: MINUS
29376: PUSH
29377: FOR_TO
29378: IFFALSE 29470
// begin if i = sort then
29380: LD_VAR 0 3
29384: PUSH
29385: LD_VAR 0 9
29389: EQUAL
29390: IFFALSE 29394
// break ;
29392: GO 29470
// if GetClass ( i ) = 3 then
29394: LD_VAR 0 3
29398: PPUSH
29399: CALL_OW 257
29403: PUSH
29404: LD_INT 3
29406: EQUAL
29407: IFFALSE 29411
// continue ;
29409: GO 29377
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29411: LD_ADDR_VAR 0 11
29415: PUSH
29416: LD_VAR 0 11
29420: PPUSH
29421: LD_VAR 0 11
29425: PUSH
29426: LD_INT 1
29428: PLUS
29429: PPUSH
29430: LD_VAR 0 9
29434: PUSH
29435: LD_VAR 0 3
29439: ARRAY
29440: PPUSH
29441: CALL_OW 2
29445: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29446: LD_ADDR_VAR 0 4
29450: PUSH
29451: LD_VAR 0 4
29455: PUSH
29456: LD_VAR 0 9
29460: PUSH
29461: LD_VAR 0 3
29465: ARRAY
29466: DIFF
29467: ST_TO_ADDR
// end ;
29468: GO 29377
29470: POP
29471: POP
// if p then
29472: LD_VAR 0 11
29476: IFFALSE 29501
// result := Replace ( result , 3 , p ) ;
29478: LD_ADDR_VAR 0 2
29482: PUSH
29483: LD_VAR 0 2
29487: PPUSH
29488: LD_INT 3
29490: PPUSH
29491: LD_VAR 0 11
29495: PPUSH
29496: CALL_OW 1
29500: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29501: LD_ADDR_VAR 0 4
29505: PUSH
29506: LD_VAR 0 4
29510: PUSH
29511: LD_VAR 0 6
29515: DIFF
29516: ST_TO_ADDR
// if tmp and eng < 6 then
29517: LD_VAR 0 4
29521: PUSH
29522: LD_VAR 0 6
29526: PUSH
29527: LD_INT 6
29529: LESS
29530: AND
29531: IFFALSE 29725
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29533: LD_ADDR_VAR 0 9
29537: PUSH
29538: LD_VAR 0 4
29542: PUSH
29543: LD_VAR 0 8
29547: PUSH
29548: LD_VAR 0 7
29552: UNION
29553: PUSH
29554: LD_VAR 0 6
29558: UNION
29559: DIFF
29560: PPUSH
29561: LD_INT 2
29563: PPUSH
29564: CALL 88621 0 2
29568: ST_TO_ADDR
// p := [ ] ;
29569: LD_ADDR_VAR 0 11
29573: PUSH
29574: EMPTY
29575: ST_TO_ADDR
// if sort then
29576: LD_VAR 0 9
29580: IFFALSE 29696
// for i = 1 to 6 - eng do
29582: LD_ADDR_VAR 0 3
29586: PUSH
29587: DOUBLE
29588: LD_INT 1
29590: DEC
29591: ST_TO_ADDR
29592: LD_INT 6
29594: PUSH
29595: LD_VAR 0 6
29599: MINUS
29600: PUSH
29601: FOR_TO
29602: IFFALSE 29694
// begin if i = sort then
29604: LD_VAR 0 3
29608: PUSH
29609: LD_VAR 0 9
29613: EQUAL
29614: IFFALSE 29618
// break ;
29616: GO 29694
// if GetClass ( i ) = 2 then
29618: LD_VAR 0 3
29622: PPUSH
29623: CALL_OW 257
29627: PUSH
29628: LD_INT 2
29630: EQUAL
29631: IFFALSE 29635
// continue ;
29633: GO 29601
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29635: LD_ADDR_VAR 0 11
29639: PUSH
29640: LD_VAR 0 11
29644: PPUSH
29645: LD_VAR 0 11
29649: PUSH
29650: LD_INT 1
29652: PLUS
29653: PPUSH
29654: LD_VAR 0 9
29658: PUSH
29659: LD_VAR 0 3
29663: ARRAY
29664: PPUSH
29665: CALL_OW 2
29669: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29670: LD_ADDR_VAR 0 4
29674: PUSH
29675: LD_VAR 0 4
29679: PUSH
29680: LD_VAR 0 9
29684: PUSH
29685: LD_VAR 0 3
29689: ARRAY
29690: DIFF
29691: ST_TO_ADDR
// end ;
29692: GO 29601
29694: POP
29695: POP
// if p then
29696: LD_VAR 0 11
29700: IFFALSE 29725
// result := Replace ( result , 2 , p ) ;
29702: LD_ADDR_VAR 0 2
29706: PUSH
29707: LD_VAR 0 2
29711: PPUSH
29712: LD_INT 2
29714: PPUSH
29715: LD_VAR 0 11
29719: PPUSH
29720: CALL_OW 1
29724: ST_TO_ADDR
// end ; exit ;
29725: GO 30449
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29727: LD_EXP 105
29731: PUSH
29732: LD_EXP 104
29736: PUSH
29737: LD_VAR 0 1
29741: ARRAY
29742: ARRAY
29743: NOT
29744: PUSH
29745: LD_EXP 78
29749: PUSH
29750: LD_VAR 0 1
29754: ARRAY
29755: PPUSH
29756: LD_INT 30
29758: PUSH
29759: LD_INT 3
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PPUSH
29766: CALL_OW 72
29770: AND
29771: PUSH
29772: LD_EXP 83
29776: PUSH
29777: LD_VAR 0 1
29781: ARRAY
29782: NOT
29783: AND
29784: IFFALSE 30449
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29786: LD_ADDR_EXP 120
29790: PUSH
29791: LD_EXP 120
29795: PPUSH
29796: LD_VAR 0 1
29800: PPUSH
29801: LD_INT 6
29803: PPUSH
29804: CALL_OW 1
29808: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29809: LD_ADDR_VAR 0 2
29813: PUSH
29814: LD_INT 0
29816: PUSH
29817: LD_INT 0
29819: PUSH
29820: LD_INT 0
29822: PUSH
29823: LD_INT 0
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: LIST
29830: LIST
29831: ST_TO_ADDR
// if sci >= 1 then
29832: LD_VAR 0 8
29836: PUSH
29837: LD_INT 1
29839: GREATEREQUAL
29840: IFFALSE 29862
// tmp := tmp diff sci [ 1 ] ;
29842: LD_ADDR_VAR 0 4
29846: PUSH
29847: LD_VAR 0 4
29851: PUSH
29852: LD_VAR 0 8
29856: PUSH
29857: LD_INT 1
29859: ARRAY
29860: DIFF
29861: ST_TO_ADDR
// if tmp and not sci then
29862: LD_VAR 0 4
29866: PUSH
29867: LD_VAR 0 8
29871: NOT
29872: AND
29873: IFFALSE 29942
// begin sort := SortBySkill ( tmp , 4 ) ;
29875: LD_ADDR_VAR 0 9
29879: PUSH
29880: LD_VAR 0 4
29884: PPUSH
29885: LD_INT 4
29887: PPUSH
29888: CALL 88621 0 2
29892: ST_TO_ADDR
// if sort then
29893: LD_VAR 0 9
29897: IFFALSE 29913
// p := sort [ 1 ] ;
29899: LD_ADDR_VAR 0 11
29903: PUSH
29904: LD_VAR 0 9
29908: PUSH
29909: LD_INT 1
29911: ARRAY
29912: ST_TO_ADDR
// if p then
29913: LD_VAR 0 11
29917: IFFALSE 29942
// result := Replace ( result , 4 , p ) ;
29919: LD_ADDR_VAR 0 2
29923: PUSH
29924: LD_VAR 0 2
29928: PPUSH
29929: LD_INT 4
29931: PPUSH
29932: LD_VAR 0 11
29936: PPUSH
29937: CALL_OW 1
29941: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29942: LD_ADDR_VAR 0 4
29946: PUSH
29947: LD_VAR 0 4
29951: PUSH
29952: LD_VAR 0 7
29956: DIFF
29957: ST_TO_ADDR
// if tmp and mech < 6 then
29958: LD_VAR 0 4
29962: PUSH
29963: LD_VAR 0 7
29967: PUSH
29968: LD_INT 6
29970: LESS
29971: AND
29972: IFFALSE 30154
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29974: LD_ADDR_VAR 0 9
29978: PUSH
29979: LD_VAR 0 4
29983: PUSH
29984: LD_VAR 0 7
29988: DIFF
29989: PPUSH
29990: LD_INT 3
29992: PPUSH
29993: CALL 88621 0 2
29997: ST_TO_ADDR
// p := [ ] ;
29998: LD_ADDR_VAR 0 11
30002: PUSH
30003: EMPTY
30004: ST_TO_ADDR
// if sort then
30005: LD_VAR 0 9
30009: IFFALSE 30125
// for i = 1 to 6 - mech do
30011: LD_ADDR_VAR 0 3
30015: PUSH
30016: DOUBLE
30017: LD_INT 1
30019: DEC
30020: ST_TO_ADDR
30021: LD_INT 6
30023: PUSH
30024: LD_VAR 0 7
30028: MINUS
30029: PUSH
30030: FOR_TO
30031: IFFALSE 30123
// begin if i = sort then
30033: LD_VAR 0 3
30037: PUSH
30038: LD_VAR 0 9
30042: EQUAL
30043: IFFALSE 30047
// break ;
30045: GO 30123
// if GetClass ( i ) = 3 then
30047: LD_VAR 0 3
30051: PPUSH
30052: CALL_OW 257
30056: PUSH
30057: LD_INT 3
30059: EQUAL
30060: IFFALSE 30064
// continue ;
30062: GO 30030
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30064: LD_ADDR_VAR 0 11
30068: PUSH
30069: LD_VAR 0 11
30073: PPUSH
30074: LD_VAR 0 11
30078: PUSH
30079: LD_INT 1
30081: PLUS
30082: PPUSH
30083: LD_VAR 0 9
30087: PUSH
30088: LD_VAR 0 3
30092: ARRAY
30093: PPUSH
30094: CALL_OW 2
30098: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30099: LD_ADDR_VAR 0 4
30103: PUSH
30104: LD_VAR 0 4
30108: PUSH
30109: LD_VAR 0 9
30113: PUSH
30114: LD_VAR 0 3
30118: ARRAY
30119: DIFF
30120: ST_TO_ADDR
// end ;
30121: GO 30030
30123: POP
30124: POP
// if p then
30125: LD_VAR 0 11
30129: IFFALSE 30154
// result := Replace ( result , 3 , p ) ;
30131: LD_ADDR_VAR 0 2
30135: PUSH
30136: LD_VAR 0 2
30140: PPUSH
30141: LD_INT 3
30143: PPUSH
30144: LD_VAR 0 11
30148: PPUSH
30149: CALL_OW 1
30153: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30154: LD_ADDR_VAR 0 4
30158: PUSH
30159: LD_VAR 0 4
30163: PUSH
30164: LD_VAR 0 6
30168: DIFF
30169: ST_TO_ADDR
// if tmp and eng < 4 then
30170: LD_VAR 0 4
30174: PUSH
30175: LD_VAR 0 6
30179: PUSH
30180: LD_INT 4
30182: LESS
30183: AND
30184: IFFALSE 30374
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30186: LD_ADDR_VAR 0 9
30190: PUSH
30191: LD_VAR 0 4
30195: PUSH
30196: LD_VAR 0 7
30200: PUSH
30201: LD_VAR 0 6
30205: UNION
30206: DIFF
30207: PPUSH
30208: LD_INT 2
30210: PPUSH
30211: CALL 88621 0 2
30215: ST_TO_ADDR
// p := [ ] ;
30216: LD_ADDR_VAR 0 11
30220: PUSH
30221: EMPTY
30222: ST_TO_ADDR
// if sort then
30223: LD_VAR 0 9
30227: IFFALSE 30343
// for i = 1 to 4 - eng do
30229: LD_ADDR_VAR 0 3
30233: PUSH
30234: DOUBLE
30235: LD_INT 1
30237: DEC
30238: ST_TO_ADDR
30239: LD_INT 4
30241: PUSH
30242: LD_VAR 0 6
30246: MINUS
30247: PUSH
30248: FOR_TO
30249: IFFALSE 30341
// begin if i = sort then
30251: LD_VAR 0 3
30255: PUSH
30256: LD_VAR 0 9
30260: EQUAL
30261: IFFALSE 30265
// break ;
30263: GO 30341
// if GetClass ( i ) = 2 then
30265: LD_VAR 0 3
30269: PPUSH
30270: CALL_OW 257
30274: PUSH
30275: LD_INT 2
30277: EQUAL
30278: IFFALSE 30282
// continue ;
30280: GO 30248
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30282: LD_ADDR_VAR 0 11
30286: PUSH
30287: LD_VAR 0 11
30291: PPUSH
30292: LD_VAR 0 11
30296: PUSH
30297: LD_INT 1
30299: PLUS
30300: PPUSH
30301: LD_VAR 0 9
30305: PUSH
30306: LD_VAR 0 3
30310: ARRAY
30311: PPUSH
30312: CALL_OW 2
30316: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30317: LD_ADDR_VAR 0 4
30321: PUSH
30322: LD_VAR 0 4
30326: PUSH
30327: LD_VAR 0 9
30331: PUSH
30332: LD_VAR 0 3
30336: ARRAY
30337: DIFF
30338: ST_TO_ADDR
// end ;
30339: GO 30248
30341: POP
30342: POP
// if p then
30343: LD_VAR 0 11
30347: IFFALSE 30372
// result := Replace ( result , 2 , p ) ;
30349: LD_ADDR_VAR 0 2
30353: PUSH
30354: LD_VAR 0 2
30358: PPUSH
30359: LD_INT 2
30361: PPUSH
30362: LD_VAR 0 11
30366: PPUSH
30367: CALL_OW 1
30371: ST_TO_ADDR
// end else
30372: GO 30418
// for i = eng downto 5 do
30374: LD_ADDR_VAR 0 3
30378: PUSH
30379: DOUBLE
30380: LD_VAR 0 6
30384: INC
30385: ST_TO_ADDR
30386: LD_INT 5
30388: PUSH
30389: FOR_DOWNTO
30390: IFFALSE 30416
// tmp := tmp union eng [ i ] ;
30392: LD_ADDR_VAR 0 4
30396: PUSH
30397: LD_VAR 0 4
30401: PUSH
30402: LD_VAR 0 6
30406: PUSH
30407: LD_VAR 0 3
30411: ARRAY
30412: UNION
30413: ST_TO_ADDR
30414: GO 30389
30416: POP
30417: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30418: LD_ADDR_VAR 0 2
30422: PUSH
30423: LD_VAR 0 2
30427: PPUSH
30428: LD_INT 1
30430: PPUSH
30431: LD_VAR 0 4
30435: PUSH
30436: LD_VAR 0 5
30440: DIFF
30441: PPUSH
30442: CALL_OW 1
30446: ST_TO_ADDR
// exit ;
30447: GO 30449
// end ; end ;
30449: LD_VAR 0 2
30453: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30454: LD_INT 0
30456: PPUSH
30457: PPUSH
30458: PPUSH
// if not mc_bases then
30459: LD_EXP 78
30463: NOT
30464: IFFALSE 30468
// exit ;
30466: GO 30610
// for i = 1 to mc_bases do
30468: LD_ADDR_VAR 0 2
30472: PUSH
30473: DOUBLE
30474: LD_INT 1
30476: DEC
30477: ST_TO_ADDR
30478: LD_EXP 78
30482: PUSH
30483: FOR_TO
30484: IFFALSE 30601
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30486: LD_ADDR_VAR 0 3
30490: PUSH
30491: LD_EXP 78
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: PPUSH
30502: LD_INT 21
30504: PUSH
30505: LD_INT 3
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 3
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: LD_INT 30
30520: PUSH
30521: LD_INT 29
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 30
30530: PUSH
30531: LD_INT 30
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: LIST
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 3
30549: PUSH
30550: LD_INT 24
30552: PUSH
30553: LD_INT 1000
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: LIST
30568: PPUSH
30569: CALL_OW 72
30573: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
30574: LD_ADDR_EXP 79
30578: PUSH
30579: LD_EXP 79
30583: PPUSH
30584: LD_VAR 0 2
30588: PPUSH
30589: LD_VAR 0 3
30593: PPUSH
30594: CALL_OW 1
30598: ST_TO_ADDR
// end ;
30599: GO 30483
30601: POP
30602: POP
// RaiseSailEvent ( 101 ) ;
30603: LD_INT 101
30605: PPUSH
30606: CALL_OW 427
// end ;
30610: LD_VAR 0 1
30614: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30615: LD_INT 0
30617: PPUSH
30618: PPUSH
30619: PPUSH
30620: PPUSH
30621: PPUSH
30622: PPUSH
30623: PPUSH
// if not mc_bases then
30624: LD_EXP 78
30628: NOT
30629: IFFALSE 30633
// exit ;
30631: GO 31195
// for i = 1 to mc_bases do
30633: LD_ADDR_VAR 0 2
30637: PUSH
30638: DOUBLE
30639: LD_INT 1
30641: DEC
30642: ST_TO_ADDR
30643: LD_EXP 78
30647: PUSH
30648: FOR_TO
30649: IFFALSE 31186
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30651: LD_ADDR_VAR 0 5
30655: PUSH
30656: LD_EXP 78
30660: PUSH
30661: LD_VAR 0 2
30665: ARRAY
30666: PUSH
30667: LD_EXP 107
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: UNION
30678: PPUSH
30679: LD_INT 21
30681: PUSH
30682: LD_INT 1
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: LD_INT 3
30694: PUSH
30695: LD_INT 54
30697: PUSH
30698: EMPTY
30699: LIST
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 3
30707: PUSH
30708: LD_INT 24
30710: PUSH
30711: LD_INT 1000
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 72
30735: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30736: LD_ADDR_VAR 0 6
30740: PUSH
30741: LD_EXP 78
30745: PUSH
30746: LD_VAR 0 2
30750: ARRAY
30751: PPUSH
30752: LD_INT 21
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 1
30764: PUSH
30765: LD_INT 3
30767: PUSH
30768: LD_INT 54
30770: PUSH
30771: EMPTY
30772: LIST
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 3
30780: PUSH
30781: LD_INT 24
30783: PUSH
30784: LD_INT 250
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PPUSH
30804: CALL_OW 72
30808: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30809: LD_ADDR_VAR 0 7
30813: PUSH
30814: LD_VAR 0 5
30818: PUSH
30819: LD_VAR 0 6
30823: DIFF
30824: ST_TO_ADDR
// if not need_heal_1 then
30825: LD_VAR 0 6
30829: NOT
30830: IFFALSE 30863
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30832: LD_ADDR_EXP 81
30836: PUSH
30837: LD_EXP 81
30841: PPUSH
30842: LD_VAR 0 2
30846: PUSH
30847: LD_INT 1
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PPUSH
30854: EMPTY
30855: PPUSH
30856: CALL 57774 0 3
30860: ST_TO_ADDR
30861: GO 30933
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30863: LD_ADDR_EXP 81
30867: PUSH
30868: LD_EXP 81
30872: PPUSH
30873: LD_VAR 0 2
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PPUSH
30885: LD_EXP 81
30889: PUSH
30890: LD_VAR 0 2
30894: ARRAY
30895: PUSH
30896: LD_INT 1
30898: ARRAY
30899: PPUSH
30900: LD_INT 3
30902: PUSH
30903: LD_INT 24
30905: PUSH
30906: LD_INT 1000
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PPUSH
30917: CALL_OW 72
30921: PUSH
30922: LD_VAR 0 6
30926: UNION
30927: PPUSH
30928: CALL 57774 0 3
30932: ST_TO_ADDR
// if not need_heal_2 then
30933: LD_VAR 0 7
30937: NOT
30938: IFFALSE 30971
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30940: LD_ADDR_EXP 81
30944: PUSH
30945: LD_EXP 81
30949: PPUSH
30950: LD_VAR 0 2
30954: PUSH
30955: LD_INT 2
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PPUSH
30962: EMPTY
30963: PPUSH
30964: CALL 57774 0 3
30968: ST_TO_ADDR
30969: GO 31003
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30971: LD_ADDR_EXP 81
30975: PUSH
30976: LD_EXP 81
30980: PPUSH
30981: LD_VAR 0 2
30985: PUSH
30986: LD_INT 2
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PPUSH
30993: LD_VAR 0 7
30997: PPUSH
30998: CALL 57774 0 3
31002: ST_TO_ADDR
// if need_heal_2 then
31003: LD_VAR 0 7
31007: IFFALSE 31168
// for j in need_heal_2 do
31009: LD_ADDR_VAR 0 3
31013: PUSH
31014: LD_VAR 0 7
31018: PUSH
31019: FOR_IN
31020: IFFALSE 31166
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31022: LD_ADDR_VAR 0 5
31026: PUSH
31027: LD_EXP 78
31031: PUSH
31032: LD_VAR 0 2
31036: ARRAY
31037: PPUSH
31038: LD_INT 2
31040: PUSH
31041: LD_INT 30
31043: PUSH
31044: LD_INT 6
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 30
31053: PUSH
31054: LD_INT 7
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 30
31063: PUSH
31064: LD_INT 8
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 30
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 30
31083: PUSH
31084: LD_INT 1
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: PPUSH
31099: CALL_OW 72
31103: ST_TO_ADDR
// if tmp then
31104: LD_VAR 0 5
31108: IFFALSE 31164
// begin k := NearestUnitToUnit ( tmp , j ) ;
31110: LD_ADDR_VAR 0 4
31114: PUSH
31115: LD_VAR 0 5
31119: PPUSH
31120: LD_VAR 0 3
31124: PPUSH
31125: CALL_OW 74
31129: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31130: LD_VAR 0 3
31134: PPUSH
31135: LD_VAR 0 4
31139: PPUSH
31140: CALL_OW 296
31144: PUSH
31145: LD_INT 5
31147: GREATER
31148: IFFALSE 31164
// ComMoveToNearbyEntrance ( j , k ) ;
31150: LD_VAR 0 3
31154: PPUSH
31155: LD_VAR 0 4
31159: PPUSH
31160: CALL 90981 0 2
// end ; end ;
31164: GO 31019
31166: POP
31167: POP
// if not need_heal_1 and not need_heal_2 then
31168: LD_VAR 0 6
31172: NOT
31173: PUSH
31174: LD_VAR 0 7
31178: NOT
31179: AND
31180: IFFALSE 31184
// continue ;
31182: GO 30648
// end ;
31184: GO 30648
31186: POP
31187: POP
// RaiseSailEvent ( 102 ) ;
31188: LD_INT 102
31190: PPUSH
31191: CALL_OW 427
// end ;
31195: LD_VAR 0 1
31199: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31200: LD_INT 0
31202: PPUSH
31203: PPUSH
31204: PPUSH
31205: PPUSH
31206: PPUSH
31207: PPUSH
31208: PPUSH
31209: PPUSH
// if not mc_bases then
31210: LD_EXP 78
31214: NOT
31215: IFFALSE 31219
// exit ;
31217: GO 32130
// for i = 1 to mc_bases do
31219: LD_ADDR_VAR 0 2
31223: PUSH
31224: DOUBLE
31225: LD_INT 1
31227: DEC
31228: ST_TO_ADDR
31229: LD_EXP 78
31233: PUSH
31234: FOR_TO
31235: IFFALSE 32128
// begin if not mc_building_need_repair [ i ] then
31237: LD_EXP 79
31241: PUSH
31242: LD_VAR 0 2
31246: ARRAY
31247: NOT
31248: IFFALSE 31433
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31250: LD_ADDR_VAR 0 6
31254: PUSH
31255: LD_EXP 97
31259: PUSH
31260: LD_VAR 0 2
31264: ARRAY
31265: PPUSH
31266: LD_INT 3
31268: PUSH
31269: LD_INT 24
31271: PUSH
31272: LD_INT 1000
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 2
31285: PUSH
31286: LD_INT 34
31288: PUSH
31289: LD_INT 13
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 34
31298: PUSH
31299: LD_INT 52
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 34
31308: PUSH
31309: LD_INT 88
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PPUSH
31326: CALL_OW 72
31330: ST_TO_ADDR
// if cranes then
31331: LD_VAR 0 6
31335: IFFALSE 31397
// for j in cranes do
31337: LD_ADDR_VAR 0 3
31341: PUSH
31342: LD_VAR 0 6
31346: PUSH
31347: FOR_IN
31348: IFFALSE 31395
// if not IsInArea ( j , mc_parking [ i ] ) then
31350: LD_VAR 0 3
31354: PPUSH
31355: LD_EXP 102
31359: PUSH
31360: LD_VAR 0 2
31364: ARRAY
31365: PPUSH
31366: CALL_OW 308
31370: NOT
31371: IFFALSE 31393
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31373: LD_VAR 0 3
31377: PPUSH
31378: LD_EXP 102
31382: PUSH
31383: LD_VAR 0 2
31387: ARRAY
31388: PPUSH
31389: CALL_OW 113
31393: GO 31347
31395: POP
31396: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31397: LD_ADDR_EXP 80
31401: PUSH
31402: LD_EXP 80
31406: PPUSH
31407: LD_VAR 0 2
31411: PPUSH
31412: EMPTY
31413: PPUSH
31414: CALL_OW 1
31418: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31419: LD_VAR 0 2
31423: PPUSH
31424: LD_INT 101
31426: PPUSH
31427: CALL 26287 0 2
// continue ;
31431: GO 31234
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31433: LD_ADDR_EXP 84
31437: PUSH
31438: LD_EXP 84
31442: PPUSH
31443: LD_VAR 0 2
31447: PPUSH
31448: EMPTY
31449: PPUSH
31450: CALL_OW 1
31454: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31455: LD_VAR 0 2
31459: PPUSH
31460: LD_INT 103
31462: PPUSH
31463: CALL 26287 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31467: LD_ADDR_VAR 0 5
31471: PUSH
31472: LD_EXP 78
31476: PUSH
31477: LD_VAR 0 2
31481: ARRAY
31482: PUSH
31483: LD_EXP 107
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: UNION
31494: PPUSH
31495: LD_INT 2
31497: PUSH
31498: LD_INT 25
31500: PUSH
31501: LD_INT 2
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 25
31510: PUSH
31511: LD_INT 16
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: PPUSH
31526: CALL_OW 72
31530: ST_TO_ADDR
// if mc_need_heal [ i ] then
31531: LD_EXP 81
31535: PUSH
31536: LD_VAR 0 2
31540: ARRAY
31541: IFFALSE 31585
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31543: LD_ADDR_VAR 0 5
31547: PUSH
31548: LD_VAR 0 5
31552: PUSH
31553: LD_EXP 81
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PUSH
31564: LD_INT 1
31566: ARRAY
31567: PUSH
31568: LD_EXP 81
31572: PUSH
31573: LD_VAR 0 2
31577: ARRAY
31578: PUSH
31579: LD_INT 2
31581: ARRAY
31582: UNION
31583: DIFF
31584: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
31585: LD_ADDR_VAR 0 6
31589: PUSH
31590: LD_EXP 97
31594: PUSH
31595: LD_VAR 0 2
31599: ARRAY
31600: PPUSH
31601: LD_INT 2
31603: PUSH
31604: LD_INT 34
31606: PUSH
31607: LD_INT 13
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 34
31616: PUSH
31617: LD_INT 52
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 34
31626: PUSH
31627: LD_INT 88
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: PPUSH
31640: CALL_OW 72
31644: ST_TO_ADDR
// if cranes then
31645: LD_VAR 0 6
31649: IFFALSE 31817
// begin for j in cranes do
31651: LD_ADDR_VAR 0 3
31655: PUSH
31656: LD_VAR 0 6
31660: PUSH
31661: FOR_IN
31662: IFFALSE 31815
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31664: LD_VAR 0 3
31668: PPUSH
31669: CALL_OW 256
31673: PUSH
31674: LD_INT 1000
31676: EQUAL
31677: PUSH
31678: LD_VAR 0 3
31682: PPUSH
31683: CALL_OW 314
31687: NOT
31688: AND
31689: IFFALSE 31755
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31691: LD_ADDR_VAR 0 8
31695: PUSH
31696: LD_EXP 79
31700: PUSH
31701: LD_VAR 0 2
31705: ARRAY
31706: PPUSH
31707: LD_VAR 0 3
31711: PPUSH
31712: CALL_OW 74
31716: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31717: LD_VAR 0 8
31721: PPUSH
31722: LD_INT 16
31724: PPUSH
31725: CALL 60371 0 2
31729: PUSH
31730: LD_INT 4
31732: ARRAY
31733: PUSH
31734: LD_INT 10
31736: LESS
31737: IFFALSE 31753
// ComRepairBuilding ( j , to_repair ) ;
31739: LD_VAR 0 3
31743: PPUSH
31744: LD_VAR 0 8
31748: PPUSH
31749: CALL_OW 130
// end else
31753: GO 31813
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31755: LD_VAR 0 3
31759: PPUSH
31760: CALL_OW 256
31764: PUSH
31765: LD_INT 500
31767: LESS
31768: PUSH
31769: LD_VAR 0 3
31773: PPUSH
31774: LD_EXP 102
31778: PUSH
31779: LD_VAR 0 2
31783: ARRAY
31784: PPUSH
31785: CALL_OW 308
31789: NOT
31790: AND
31791: IFFALSE 31813
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31793: LD_VAR 0 3
31797: PPUSH
31798: LD_EXP 102
31802: PUSH
31803: LD_VAR 0 2
31807: ARRAY
31808: PPUSH
31809: CALL_OW 113
// end ;
31813: GO 31661
31815: POP
31816: POP
// end ; if tmp > 3 then
31817: LD_VAR 0 5
31821: PUSH
31822: LD_INT 3
31824: GREATER
31825: IFFALSE 31845
// tmp := ShrinkArray ( tmp , 4 ) ;
31827: LD_ADDR_VAR 0 5
31831: PUSH
31832: LD_VAR 0 5
31836: PPUSH
31837: LD_INT 4
31839: PPUSH
31840: CALL 90419 0 2
31844: ST_TO_ADDR
// if not tmp then
31845: LD_VAR 0 5
31849: NOT
31850: IFFALSE 31854
// continue ;
31852: GO 31234
// for j in tmp do
31854: LD_ADDR_VAR 0 3
31858: PUSH
31859: LD_VAR 0 5
31863: PUSH
31864: FOR_IN
31865: IFFALSE 32124
// begin if IsInUnit ( j ) then
31867: LD_VAR 0 3
31871: PPUSH
31872: CALL_OW 310
31876: IFFALSE 31887
// ComExitBuilding ( j ) ;
31878: LD_VAR 0 3
31882: PPUSH
31883: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31887: LD_VAR 0 3
31891: PUSH
31892: LD_EXP 80
31896: PUSH
31897: LD_VAR 0 2
31901: ARRAY
31902: IN
31903: NOT
31904: IFFALSE 31962
// begin SetTag ( j , 101 ) ;
31906: LD_VAR 0 3
31910: PPUSH
31911: LD_INT 101
31913: PPUSH
31914: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31918: LD_ADDR_EXP 80
31922: PUSH
31923: LD_EXP 80
31927: PPUSH
31928: LD_VAR 0 2
31932: PUSH
31933: LD_EXP 80
31937: PUSH
31938: LD_VAR 0 2
31942: ARRAY
31943: PUSH
31944: LD_INT 1
31946: PLUS
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PPUSH
31952: LD_VAR 0 3
31956: PPUSH
31957: CALL 57774 0 3
31961: ST_TO_ADDR
// end ; wait ( 1 ) ;
31962: LD_INT 1
31964: PPUSH
31965: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31969: LD_ADDR_VAR 0 7
31973: PUSH
31974: LD_EXP 79
31978: PUSH
31979: LD_VAR 0 2
31983: ARRAY
31984: ST_TO_ADDR
// if mc_scan [ i ] then
31985: LD_EXP 101
31989: PUSH
31990: LD_VAR 0 2
31994: ARRAY
31995: IFFALSE 32057
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31997: LD_ADDR_VAR 0 7
32001: PUSH
32002: LD_EXP 79
32006: PUSH
32007: LD_VAR 0 2
32011: ARRAY
32012: PPUSH
32013: LD_INT 3
32015: PUSH
32016: LD_INT 30
32018: PUSH
32019: LD_INT 32
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 30
32028: PUSH
32029: LD_INT 33
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: PUSH
32036: LD_INT 30
32038: PUSH
32039: LD_INT 31
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: PPUSH
32052: CALL_OW 72
32056: ST_TO_ADDR
// if not to_repair_tmp then
32057: LD_VAR 0 7
32061: NOT
32062: IFFALSE 32066
// continue ;
32064: GO 31864
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32066: LD_ADDR_VAR 0 8
32070: PUSH
32071: LD_VAR 0 7
32075: PPUSH
32076: LD_VAR 0 3
32080: PPUSH
32081: CALL_OW 74
32085: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32086: LD_VAR 0 8
32090: PPUSH
32091: LD_INT 16
32093: PPUSH
32094: CALL 60371 0 2
32098: PUSH
32099: LD_INT 4
32101: ARRAY
32102: PUSH
32103: LD_INT 14
32105: LESS
32106: IFFALSE 32122
// ComRepairBuilding ( j , to_repair ) ;
32108: LD_VAR 0 3
32112: PPUSH
32113: LD_VAR 0 8
32117: PPUSH
32118: CALL_OW 130
// end ;
32122: GO 31864
32124: POP
32125: POP
// end ;
32126: GO 31234
32128: POP
32129: POP
// end ;
32130: LD_VAR 0 1
32134: RET
// export function MC_Heal ; var i , j , tmp ; begin
32135: LD_INT 0
32137: PPUSH
32138: PPUSH
32139: PPUSH
32140: PPUSH
// if not mc_bases then
32141: LD_EXP 78
32145: NOT
32146: IFFALSE 32150
// exit ;
32148: GO 32552
// for i = 1 to mc_bases do
32150: LD_ADDR_VAR 0 2
32154: PUSH
32155: DOUBLE
32156: LD_INT 1
32158: DEC
32159: ST_TO_ADDR
32160: LD_EXP 78
32164: PUSH
32165: FOR_TO
32166: IFFALSE 32550
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32168: LD_EXP 81
32172: PUSH
32173: LD_VAR 0 2
32177: ARRAY
32178: PUSH
32179: LD_INT 1
32181: ARRAY
32182: NOT
32183: PUSH
32184: LD_EXP 81
32188: PUSH
32189: LD_VAR 0 2
32193: ARRAY
32194: PUSH
32195: LD_INT 2
32197: ARRAY
32198: NOT
32199: AND
32200: IFFALSE 32238
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32202: LD_ADDR_EXP 82
32206: PUSH
32207: LD_EXP 82
32211: PPUSH
32212: LD_VAR 0 2
32216: PPUSH
32217: EMPTY
32218: PPUSH
32219: CALL_OW 1
32223: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32224: LD_VAR 0 2
32228: PPUSH
32229: LD_INT 102
32231: PPUSH
32232: CALL 26287 0 2
// continue ;
32236: GO 32165
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32238: LD_ADDR_VAR 0 4
32242: PUSH
32243: LD_EXP 78
32247: PUSH
32248: LD_VAR 0 2
32252: ARRAY
32253: PPUSH
32254: LD_INT 25
32256: PUSH
32257: LD_INT 4
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PPUSH
32264: CALL_OW 72
32268: ST_TO_ADDR
// if not tmp then
32269: LD_VAR 0 4
32273: NOT
32274: IFFALSE 32278
// continue ;
32276: GO 32165
// if mc_taming [ i ] then
32278: LD_EXP 109
32282: PUSH
32283: LD_VAR 0 2
32287: ARRAY
32288: IFFALSE 32312
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32290: LD_ADDR_EXP 109
32294: PUSH
32295: LD_EXP 109
32299: PPUSH
32300: LD_VAR 0 2
32304: PPUSH
32305: EMPTY
32306: PPUSH
32307: CALL_OW 1
32311: ST_TO_ADDR
// for j in tmp do
32312: LD_ADDR_VAR 0 3
32316: PUSH
32317: LD_VAR 0 4
32321: PUSH
32322: FOR_IN
32323: IFFALSE 32546
// begin if IsInUnit ( j ) then
32325: LD_VAR 0 3
32329: PPUSH
32330: CALL_OW 310
32334: IFFALSE 32345
// ComExitBuilding ( j ) ;
32336: LD_VAR 0 3
32340: PPUSH
32341: CALL_OW 122
// if not j in mc_healers [ i ] then
32345: LD_VAR 0 3
32349: PUSH
32350: LD_EXP 82
32354: PUSH
32355: LD_VAR 0 2
32359: ARRAY
32360: IN
32361: NOT
32362: IFFALSE 32408
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32364: LD_ADDR_EXP 82
32368: PUSH
32369: LD_EXP 82
32373: PPUSH
32374: LD_VAR 0 2
32378: PUSH
32379: LD_EXP 82
32383: PUSH
32384: LD_VAR 0 2
32388: ARRAY
32389: PUSH
32390: LD_INT 1
32392: PLUS
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PPUSH
32398: LD_VAR 0 3
32402: PPUSH
32403: CALL 57774 0 3
32407: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32408: LD_VAR 0 3
32412: PPUSH
32413: CALL_OW 110
32417: PUSH
32418: LD_INT 102
32420: NONEQUAL
32421: IFFALSE 32435
// SetTag ( j , 102 ) ;
32423: LD_VAR 0 3
32427: PPUSH
32428: LD_INT 102
32430: PPUSH
32431: CALL_OW 109
// Wait ( 3 ) ;
32435: LD_INT 3
32437: PPUSH
32438: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32442: LD_EXP 81
32446: PUSH
32447: LD_VAR 0 2
32451: ARRAY
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: IFFALSE 32488
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32458: LD_VAR 0 3
32462: PPUSH
32463: LD_EXP 81
32467: PUSH
32468: LD_VAR 0 2
32472: ARRAY
32473: PUSH
32474: LD_INT 1
32476: ARRAY
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PPUSH
32482: CALL_OW 128
32486: GO 32544
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32488: LD_VAR 0 3
32492: PPUSH
32493: CALL_OW 314
32497: NOT
32498: PUSH
32499: LD_EXP 81
32503: PUSH
32504: LD_VAR 0 2
32508: ARRAY
32509: PUSH
32510: LD_INT 2
32512: ARRAY
32513: AND
32514: IFFALSE 32544
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32516: LD_VAR 0 3
32520: PPUSH
32521: LD_EXP 81
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PUSH
32532: LD_INT 2
32534: ARRAY
32535: PUSH
32536: LD_INT 1
32538: ARRAY
32539: PPUSH
32540: CALL_OW 128
// end ;
32544: GO 32322
32546: POP
32547: POP
// end ;
32548: GO 32165
32550: POP
32551: POP
// end ;
32552: LD_VAR 0 1
32556: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
32557: LD_INT 0
32559: PPUSH
32560: PPUSH
32561: PPUSH
32562: PPUSH
32563: PPUSH
32564: PPUSH
// if not mc_bases then
32565: LD_EXP 78
32569: NOT
32570: IFFALSE 32574
// exit ;
32572: GO 33737
// for i = 1 to mc_bases do
32574: LD_ADDR_VAR 0 2
32578: PUSH
32579: DOUBLE
32580: LD_INT 1
32582: DEC
32583: ST_TO_ADDR
32584: LD_EXP 78
32588: PUSH
32589: FOR_TO
32590: IFFALSE 33735
// begin if mc_scan [ i ] then
32592: LD_EXP 101
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: IFFALSE 32606
// continue ;
32604: GO 32589
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32606: LD_EXP 83
32610: PUSH
32611: LD_VAR 0 2
32615: ARRAY
32616: NOT
32617: PUSH
32618: LD_EXP 85
32622: PUSH
32623: LD_VAR 0 2
32627: ARRAY
32628: NOT
32629: AND
32630: PUSH
32631: LD_EXP 84
32635: PUSH
32636: LD_VAR 0 2
32640: ARRAY
32641: AND
32642: IFFALSE 32680
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32644: LD_ADDR_EXP 84
32648: PUSH
32649: LD_EXP 84
32653: PPUSH
32654: LD_VAR 0 2
32658: PPUSH
32659: EMPTY
32660: PPUSH
32661: CALL_OW 1
32665: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32666: LD_VAR 0 2
32670: PPUSH
32671: LD_INT 103
32673: PPUSH
32674: CALL 26287 0 2
// continue ;
32678: GO 32589
// end ; if mc_construct_list [ i ] then
32680: LD_EXP 85
32684: PUSH
32685: LD_VAR 0 2
32689: ARRAY
32690: IFFALSE 32910
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32692: LD_ADDR_VAR 0 5
32696: PUSH
32697: LD_EXP 78
32701: PUSH
32702: LD_VAR 0 2
32706: ARRAY
32707: PPUSH
32708: LD_INT 25
32710: PUSH
32711: LD_INT 2
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PPUSH
32718: CALL_OW 72
32722: PUSH
32723: LD_EXP 80
32727: PUSH
32728: LD_VAR 0 2
32732: ARRAY
32733: DIFF
32734: ST_TO_ADDR
// if not tmp then
32735: LD_VAR 0 5
32739: NOT
32740: IFFALSE 32744
// continue ;
32742: GO 32589
// for j in tmp do
32744: LD_ADDR_VAR 0 3
32748: PUSH
32749: LD_VAR 0 5
32753: PUSH
32754: FOR_IN
32755: IFFALSE 32906
// begin if not mc_builders [ i ] then
32757: LD_EXP 84
32761: PUSH
32762: LD_VAR 0 2
32766: ARRAY
32767: NOT
32768: IFFALSE 32826
// begin SetTag ( j , 103 ) ;
32770: LD_VAR 0 3
32774: PPUSH
32775: LD_INT 103
32777: PPUSH
32778: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32782: LD_ADDR_EXP 84
32786: PUSH
32787: LD_EXP 84
32791: PPUSH
32792: LD_VAR 0 2
32796: PUSH
32797: LD_EXP 84
32801: PUSH
32802: LD_VAR 0 2
32806: ARRAY
32807: PUSH
32808: LD_INT 1
32810: PLUS
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PPUSH
32816: LD_VAR 0 3
32820: PPUSH
32821: CALL 57774 0 3
32825: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32826: LD_VAR 0 3
32830: PPUSH
32831: CALL_OW 310
32835: IFFALSE 32846
// ComExitBuilding ( j ) ;
32837: LD_VAR 0 3
32841: PPUSH
32842: CALL_OW 122
// wait ( 3 ) ;
32846: LD_INT 3
32848: PPUSH
32849: CALL_OW 67
// if not mc_construct_list [ i ] then
32853: LD_EXP 85
32857: PUSH
32858: LD_VAR 0 2
32862: ARRAY
32863: NOT
32864: IFFALSE 32868
// break ;
32866: GO 32906
// if not HasTask ( j ) then
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL_OW 314
32877: NOT
32878: IFFALSE 32904
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32880: LD_VAR 0 3
32884: PPUSH
32885: LD_EXP 85
32889: PUSH
32890: LD_VAR 0 2
32894: ARRAY
32895: PUSH
32896: LD_INT 1
32898: ARRAY
32899: PPUSH
32900: CALL 60635 0 2
// end ;
32904: GO 32754
32906: POP
32907: POP
// end else
32908: GO 33733
// if mc_build_list [ i ] then
32910: LD_EXP 83
32914: PUSH
32915: LD_VAR 0 2
32919: ARRAY
32920: IFFALSE 33733
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32922: LD_EXP 83
32926: PUSH
32927: LD_VAR 0 2
32931: ARRAY
32932: PUSH
32933: LD_INT 1
32935: ARRAY
32936: PUSH
32937: LD_INT 1
32939: ARRAY
32940: PPUSH
32941: CALL 60459 0 1
32945: PUSH
32946: LD_EXP 78
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: PPUSH
32957: LD_INT 2
32959: PUSH
32960: LD_INT 30
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 30
32972: PUSH
32973: LD_INT 3
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: LIST
32984: PPUSH
32985: CALL_OW 72
32989: NOT
32990: AND
32991: IFFALSE 33096
// begin for j = 1 to mc_build_list [ i ] do
32993: LD_ADDR_VAR 0 3
32997: PUSH
32998: DOUBLE
32999: LD_INT 1
33001: DEC
33002: ST_TO_ADDR
33003: LD_EXP 83
33007: PUSH
33008: LD_VAR 0 2
33012: ARRAY
33013: PUSH
33014: FOR_TO
33015: IFFALSE 33094
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33017: LD_EXP 83
33021: PUSH
33022: LD_VAR 0 2
33026: ARRAY
33027: PUSH
33028: LD_VAR 0 3
33032: ARRAY
33033: PUSH
33034: LD_INT 1
33036: ARRAY
33037: PUSH
33038: LD_INT 2
33040: EQUAL
33041: IFFALSE 33092
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33043: LD_ADDR_EXP 83
33047: PUSH
33048: LD_EXP 83
33052: PPUSH
33053: LD_VAR 0 2
33057: PPUSH
33058: LD_EXP 83
33062: PUSH
33063: LD_VAR 0 2
33067: ARRAY
33068: PPUSH
33069: LD_VAR 0 3
33073: PPUSH
33074: LD_INT 1
33076: PPUSH
33077: LD_INT 0
33079: PPUSH
33080: CALL 57192 0 4
33084: PPUSH
33085: CALL_OW 1
33089: ST_TO_ADDR
// break ;
33090: GO 33094
// end ;
33092: GO 33014
33094: POP
33095: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33096: LD_ADDR_VAR 0 6
33100: PUSH
33101: LD_EXP 78
33105: PUSH
33106: LD_VAR 0 2
33110: ARRAY
33111: PPUSH
33112: LD_INT 2
33114: PUSH
33115: LD_INT 30
33117: PUSH
33118: LD_INT 0
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 30
33127: PUSH
33128: LD_INT 1
33130: PUSH
33131: EMPTY
33132: LIST
33133: LIST
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: LIST
33139: PPUSH
33140: CALL_OW 72
33144: ST_TO_ADDR
// for k := 1 to depot do
33145: LD_ADDR_VAR 0 4
33149: PUSH
33150: DOUBLE
33151: LD_INT 1
33153: DEC
33154: ST_TO_ADDR
33155: LD_VAR 0 6
33159: PUSH
33160: FOR_TO
33161: IFFALSE 33731
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33163: LD_EXP 83
33167: PUSH
33168: LD_VAR 0 2
33172: ARRAY
33173: PUSH
33174: LD_INT 1
33176: ARRAY
33177: PUSH
33178: LD_INT 1
33180: ARRAY
33181: PUSH
33182: LD_INT 0
33184: EQUAL
33185: PUSH
33186: LD_VAR 0 6
33190: PUSH
33191: LD_VAR 0 4
33195: ARRAY
33196: PPUSH
33197: LD_EXP 83
33201: PUSH
33202: LD_VAR 0 2
33206: ARRAY
33207: PUSH
33208: LD_INT 1
33210: ARRAY
33211: PUSH
33212: LD_INT 1
33214: ARRAY
33215: PPUSH
33216: LD_EXP 83
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: PUSH
33227: LD_INT 1
33229: ARRAY
33230: PUSH
33231: LD_INT 2
33233: ARRAY
33234: PPUSH
33235: LD_EXP 83
33239: PUSH
33240: LD_VAR 0 2
33244: ARRAY
33245: PUSH
33246: LD_INT 1
33248: ARRAY
33249: PUSH
33250: LD_INT 3
33252: ARRAY
33253: PPUSH
33254: LD_EXP 83
33258: PUSH
33259: LD_VAR 0 2
33263: ARRAY
33264: PUSH
33265: LD_INT 1
33267: ARRAY
33268: PUSH
33269: LD_INT 4
33271: ARRAY
33272: PPUSH
33273: CALL 65871 0 5
33277: OR
33278: IFFALSE 33559
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33280: LD_ADDR_VAR 0 5
33284: PUSH
33285: LD_EXP 78
33289: PUSH
33290: LD_VAR 0 2
33294: ARRAY
33295: PPUSH
33296: LD_INT 25
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PPUSH
33306: CALL_OW 72
33310: PUSH
33311: LD_EXP 80
33315: PUSH
33316: LD_VAR 0 2
33320: ARRAY
33321: DIFF
33322: ST_TO_ADDR
// if not tmp then
33323: LD_VAR 0 5
33327: NOT
33328: IFFALSE 33332
// continue ;
33330: GO 33160
// for j in tmp do
33332: LD_ADDR_VAR 0 3
33336: PUSH
33337: LD_VAR 0 5
33341: PUSH
33342: FOR_IN
33343: IFFALSE 33555
// begin if not mc_builders [ i ] then
33345: LD_EXP 84
33349: PUSH
33350: LD_VAR 0 2
33354: ARRAY
33355: NOT
33356: IFFALSE 33414
// begin SetTag ( j , 103 ) ;
33358: LD_VAR 0 3
33362: PPUSH
33363: LD_INT 103
33365: PPUSH
33366: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33370: LD_ADDR_EXP 84
33374: PUSH
33375: LD_EXP 84
33379: PPUSH
33380: LD_VAR 0 2
33384: PUSH
33385: LD_EXP 84
33389: PUSH
33390: LD_VAR 0 2
33394: ARRAY
33395: PUSH
33396: LD_INT 1
33398: PLUS
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: PPUSH
33404: LD_VAR 0 3
33408: PPUSH
33409: CALL 57774 0 3
33413: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33414: LD_VAR 0 3
33418: PPUSH
33419: CALL_OW 310
33423: IFFALSE 33434
// ComExitBuilding ( j ) ;
33425: LD_VAR 0 3
33429: PPUSH
33430: CALL_OW 122
// wait ( 3 ) ;
33434: LD_INT 3
33436: PPUSH
33437: CALL_OW 67
// if not mc_build_list [ i ] then
33441: LD_EXP 83
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: NOT
33452: IFFALSE 33456
// break ;
33454: GO 33555
// if not HasTask ( j ) then
33456: LD_VAR 0 3
33460: PPUSH
33461: CALL_OW 314
33465: NOT
33466: IFFALSE 33553
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33468: LD_VAR 0 3
33472: PPUSH
33473: LD_EXP 83
33477: PUSH
33478: LD_VAR 0 2
33482: ARRAY
33483: PUSH
33484: LD_INT 1
33486: ARRAY
33487: PUSH
33488: LD_INT 1
33490: ARRAY
33491: PPUSH
33492: LD_EXP 83
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: PUSH
33503: LD_INT 1
33505: ARRAY
33506: PUSH
33507: LD_INT 2
33509: ARRAY
33510: PPUSH
33511: LD_EXP 83
33515: PUSH
33516: LD_VAR 0 2
33520: ARRAY
33521: PUSH
33522: LD_INT 1
33524: ARRAY
33525: PUSH
33526: LD_INT 3
33528: ARRAY
33529: PPUSH
33530: LD_EXP 83
33534: PUSH
33535: LD_VAR 0 2
33539: ARRAY
33540: PUSH
33541: LD_INT 1
33543: ARRAY
33544: PUSH
33545: LD_INT 4
33547: ARRAY
33548: PPUSH
33549: CALL_OW 145
// end ;
33553: GO 33342
33555: POP
33556: POP
// end else
33557: GO 33729
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
33559: LD_EXP 78
33563: PUSH
33564: LD_VAR 0 2
33568: ARRAY
33569: PPUSH
33570: LD_EXP 83
33574: PUSH
33575: LD_VAR 0 2
33579: ARRAY
33580: PUSH
33581: LD_INT 1
33583: ARRAY
33584: PUSH
33585: LD_INT 1
33587: ARRAY
33588: PPUSH
33589: LD_EXP 83
33593: PUSH
33594: LD_VAR 0 2
33598: ARRAY
33599: PUSH
33600: LD_INT 1
33602: ARRAY
33603: PUSH
33604: LD_INT 2
33606: ARRAY
33607: PPUSH
33608: LD_EXP 83
33612: PUSH
33613: LD_VAR 0 2
33617: ARRAY
33618: PUSH
33619: LD_INT 1
33621: ARRAY
33622: PUSH
33623: LD_INT 3
33625: ARRAY
33626: PPUSH
33627: LD_EXP 83
33631: PUSH
33632: LD_VAR 0 2
33636: ARRAY
33637: PUSH
33638: LD_INT 1
33640: ARRAY
33641: PUSH
33642: LD_INT 4
33644: ARRAY
33645: PPUSH
33646: LD_EXP 78
33650: PUSH
33651: LD_VAR 0 2
33655: ARRAY
33656: PPUSH
33657: LD_INT 21
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PPUSH
33667: CALL_OW 72
33671: PPUSH
33672: EMPTY
33673: PPUSH
33674: CALL 64625 0 7
33678: NOT
33679: IFFALSE 33729
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33681: LD_ADDR_EXP 83
33685: PUSH
33686: LD_EXP 83
33690: PPUSH
33691: LD_VAR 0 2
33695: PPUSH
33696: LD_EXP 83
33700: PUSH
33701: LD_VAR 0 2
33705: ARRAY
33706: PPUSH
33707: LD_INT 1
33709: PPUSH
33710: LD_INT 1
33712: NEG
33713: PPUSH
33714: LD_INT 0
33716: PPUSH
33717: CALL 57192 0 4
33721: PPUSH
33722: CALL_OW 1
33726: ST_TO_ADDR
// continue ;
33727: GO 33160
// end ; end ;
33729: GO 33160
33731: POP
33732: POP
// end ; end ;
33733: GO 32589
33735: POP
33736: POP
// end ;
33737: LD_VAR 0 1
33741: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33742: LD_INT 0
33744: PPUSH
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
33749: PPUSH
// if not mc_bases then
33750: LD_EXP 78
33754: NOT
33755: IFFALSE 33759
// exit ;
33757: GO 34186
// for i = 1 to mc_bases do
33759: LD_ADDR_VAR 0 2
33763: PUSH
33764: DOUBLE
33765: LD_INT 1
33767: DEC
33768: ST_TO_ADDR
33769: LD_EXP 78
33773: PUSH
33774: FOR_TO
33775: IFFALSE 34184
// begin tmp := mc_build_upgrade [ i ] ;
33777: LD_ADDR_VAR 0 4
33781: PUSH
33782: LD_EXP 110
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33793: LD_ADDR_VAR 0 6
33797: PUSH
33798: LD_EXP 111
33802: PUSH
33803: LD_VAR 0 2
33807: ARRAY
33808: PPUSH
33809: LD_INT 2
33811: PUSH
33812: LD_INT 30
33814: PUSH
33815: LD_INT 6
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 30
33824: PUSH
33825: LD_INT 7
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: LIST
33836: PPUSH
33837: CALL_OW 72
33841: ST_TO_ADDR
// if not tmp and not lab then
33842: LD_VAR 0 4
33846: NOT
33847: PUSH
33848: LD_VAR 0 6
33852: NOT
33853: AND
33854: IFFALSE 33858
// continue ;
33856: GO 33774
// if tmp then
33858: LD_VAR 0 4
33862: IFFALSE 33982
// for j in tmp do
33864: LD_ADDR_VAR 0 3
33868: PUSH
33869: LD_VAR 0 4
33873: PUSH
33874: FOR_IN
33875: IFFALSE 33980
// begin if UpgradeCost ( j ) then
33877: LD_VAR 0 3
33881: PPUSH
33882: CALL 64285 0 1
33886: IFFALSE 33978
// begin ComUpgrade ( j ) ;
33888: LD_VAR 0 3
33892: PPUSH
33893: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33897: LD_ADDR_EXP 110
33901: PUSH
33902: LD_EXP 110
33906: PPUSH
33907: LD_VAR 0 2
33911: PPUSH
33912: LD_EXP 110
33916: PUSH
33917: LD_VAR 0 2
33921: ARRAY
33922: PUSH
33923: LD_VAR 0 3
33927: DIFF
33928: PPUSH
33929: CALL_OW 1
33933: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33934: LD_ADDR_EXP 85
33938: PUSH
33939: LD_EXP 85
33943: PPUSH
33944: LD_VAR 0 2
33948: PUSH
33949: LD_EXP 85
33953: PUSH
33954: LD_VAR 0 2
33958: ARRAY
33959: PUSH
33960: LD_INT 1
33962: PLUS
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PPUSH
33968: LD_VAR 0 3
33972: PPUSH
33973: CALL 57774 0 3
33977: ST_TO_ADDR
// end ; end ;
33978: GO 33874
33980: POP
33981: POP
// if not lab or not mc_lab_upgrade [ i ] then
33982: LD_VAR 0 6
33986: NOT
33987: PUSH
33988: LD_EXP 112
33992: PUSH
33993: LD_VAR 0 2
33997: ARRAY
33998: NOT
33999: OR
34000: IFFALSE 34004
// continue ;
34002: GO 33774
// for j in lab do
34004: LD_ADDR_VAR 0 3
34008: PUSH
34009: LD_VAR 0 6
34013: PUSH
34014: FOR_IN
34015: IFFALSE 34180
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34017: LD_VAR 0 3
34021: PPUSH
34022: CALL_OW 266
34026: PUSH
34027: LD_INT 6
34029: PUSH
34030: LD_INT 7
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: IN
34037: PUSH
34038: LD_VAR 0 3
34042: PPUSH
34043: CALL_OW 461
34047: PUSH
34048: LD_INT 1
34050: NONEQUAL
34051: AND
34052: IFFALSE 34178
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34054: LD_VAR 0 3
34058: PPUSH
34059: LD_EXP 112
34063: PUSH
34064: LD_VAR 0 2
34068: ARRAY
34069: PUSH
34070: LD_INT 1
34072: ARRAY
34073: PPUSH
34074: CALL 64490 0 2
34078: IFFALSE 34178
// begin ComCancel ( j ) ;
34080: LD_VAR 0 3
34084: PPUSH
34085: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34089: LD_VAR 0 3
34093: PPUSH
34094: LD_EXP 112
34098: PUSH
34099: LD_VAR 0 2
34103: ARRAY
34104: PUSH
34105: LD_INT 1
34107: ARRAY
34108: PPUSH
34109: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34113: LD_VAR 0 3
34117: PUSH
34118: LD_EXP 85
34122: PUSH
34123: LD_VAR 0 2
34127: ARRAY
34128: IN
34129: NOT
34130: IFFALSE 34176
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34132: LD_ADDR_EXP 85
34136: PUSH
34137: LD_EXP 85
34141: PPUSH
34142: LD_VAR 0 2
34146: PUSH
34147: LD_EXP 85
34151: PUSH
34152: LD_VAR 0 2
34156: ARRAY
34157: PUSH
34158: LD_INT 1
34160: PLUS
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PPUSH
34166: LD_VAR 0 3
34170: PPUSH
34171: CALL 57774 0 3
34175: ST_TO_ADDR
// break ;
34176: GO 34180
// end ; end ; end ;
34178: GO 34014
34180: POP
34181: POP
// end ;
34182: GO 33774
34184: POP
34185: POP
// end ;
34186: LD_VAR 0 1
34190: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34191: LD_INT 0
34193: PPUSH
34194: PPUSH
34195: PPUSH
34196: PPUSH
34197: PPUSH
34198: PPUSH
34199: PPUSH
34200: PPUSH
34201: PPUSH
// if not mc_bases then
34202: LD_EXP 78
34206: NOT
34207: IFFALSE 34211
// exit ;
34209: GO 34616
// for i = 1 to mc_bases do
34211: LD_ADDR_VAR 0 2
34215: PUSH
34216: DOUBLE
34217: LD_INT 1
34219: DEC
34220: ST_TO_ADDR
34221: LD_EXP 78
34225: PUSH
34226: FOR_TO
34227: IFFALSE 34614
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34229: LD_EXP 86
34233: PUSH
34234: LD_VAR 0 2
34238: ARRAY
34239: NOT
34240: PUSH
34241: LD_EXP 78
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: PPUSH
34252: LD_INT 30
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PPUSH
34262: CALL_OW 72
34266: NOT
34267: OR
34268: IFFALSE 34272
// continue ;
34270: GO 34226
// busy := false ;
34272: LD_ADDR_VAR 0 8
34276: PUSH
34277: LD_INT 0
34279: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34280: LD_ADDR_VAR 0 4
34284: PUSH
34285: LD_EXP 78
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PPUSH
34296: LD_INT 30
34298: PUSH
34299: LD_INT 3
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PPUSH
34306: CALL_OW 72
34310: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34311: LD_ADDR_VAR 0 6
34315: PUSH
34316: LD_EXP 86
34320: PUSH
34321: LD_VAR 0 2
34325: ARRAY
34326: PPUSH
34327: LD_INT 2
34329: PUSH
34330: LD_INT 30
34332: PUSH
34333: LD_INT 32
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 30
34342: PUSH
34343: LD_INT 33
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: LIST
34354: PPUSH
34355: CALL_OW 72
34359: ST_TO_ADDR
// if not t then
34360: LD_VAR 0 6
34364: NOT
34365: IFFALSE 34369
// continue ;
34367: GO 34226
// for j in tmp do
34369: LD_ADDR_VAR 0 3
34373: PUSH
34374: LD_VAR 0 4
34378: PUSH
34379: FOR_IN
34380: IFFALSE 34410
// if not BuildingStatus ( j ) = bs_idle then
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL_OW 461
34391: PUSH
34392: LD_INT 2
34394: EQUAL
34395: NOT
34396: IFFALSE 34408
// begin busy := true ;
34398: LD_ADDR_VAR 0 8
34402: PUSH
34403: LD_INT 1
34405: ST_TO_ADDR
// break ;
34406: GO 34410
// end ;
34408: GO 34379
34410: POP
34411: POP
// if busy then
34412: LD_VAR 0 8
34416: IFFALSE 34420
// continue ;
34418: GO 34226
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34420: LD_ADDR_VAR 0 7
34424: PUSH
34425: LD_VAR 0 6
34429: PPUSH
34430: LD_INT 35
34432: PUSH
34433: LD_INT 0
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PPUSH
34440: CALL_OW 72
34444: ST_TO_ADDR
// if tw then
34445: LD_VAR 0 7
34449: IFFALSE 34526
// begin tw := tw [ 1 ] ;
34451: LD_ADDR_VAR 0 7
34455: PUSH
34456: LD_VAR 0 7
34460: PUSH
34461: LD_INT 1
34463: ARRAY
34464: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34465: LD_ADDR_VAR 0 9
34469: PUSH
34470: LD_VAR 0 7
34474: PPUSH
34475: LD_EXP 103
34479: PUSH
34480: LD_VAR 0 2
34484: ARRAY
34485: PPUSH
34486: CALL 62782 0 2
34490: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34491: LD_EXP 117
34495: PUSH
34496: LD_VAR 0 2
34500: ARRAY
34501: IFFALSE 34524
// if not weapon in mc_allowed_tower_weapons [ i ] then
34503: LD_VAR 0 9
34507: PUSH
34508: LD_EXP 117
34512: PUSH
34513: LD_VAR 0 2
34517: ARRAY
34518: IN
34519: NOT
34520: IFFALSE 34524
// continue ;
34522: GO 34226
// end else
34524: GO 34589
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34526: LD_ADDR_VAR 0 5
34530: PUSH
34531: LD_EXP 86
34535: PUSH
34536: LD_VAR 0 2
34540: ARRAY
34541: PPUSH
34542: LD_VAR 0 4
34546: PPUSH
34547: CALL 89652 0 2
34551: ST_TO_ADDR
// if not tmp2 then
34552: LD_VAR 0 5
34556: NOT
34557: IFFALSE 34561
// continue ;
34559: GO 34226
// tw := tmp2 [ 1 ] ;
34561: LD_ADDR_VAR 0 7
34565: PUSH
34566: LD_VAR 0 5
34570: PUSH
34571: LD_INT 1
34573: ARRAY
34574: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
34575: LD_ADDR_VAR 0 9
34579: PUSH
34580: LD_VAR 0 5
34584: PUSH
34585: LD_INT 2
34587: ARRAY
34588: ST_TO_ADDR
// end ; if not weapon then
34589: LD_VAR 0 9
34593: NOT
34594: IFFALSE 34598
// continue ;
34596: GO 34226
// ComPlaceWeapon ( tw , weapon ) ;
34598: LD_VAR 0 7
34602: PPUSH
34603: LD_VAR 0 9
34607: PPUSH
34608: CALL_OW 148
// end ;
34612: GO 34226
34614: POP
34615: POP
// end ;
34616: LD_VAR 0 1
34620: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34621: LD_INT 0
34623: PPUSH
34624: PPUSH
34625: PPUSH
34626: PPUSH
34627: PPUSH
34628: PPUSH
34629: PPUSH
// if not mc_bases then
34630: LD_EXP 78
34634: NOT
34635: IFFALSE 34639
// exit ;
34637: GO 35414
// for i = 1 to mc_bases do
34639: LD_ADDR_VAR 0 2
34643: PUSH
34644: DOUBLE
34645: LD_INT 1
34647: DEC
34648: ST_TO_ADDR
34649: LD_EXP 78
34653: PUSH
34654: FOR_TO
34655: IFFALSE 35412
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34657: LD_EXP 91
34661: PUSH
34662: LD_VAR 0 2
34666: ARRAY
34667: NOT
34668: PUSH
34669: LD_EXP 91
34673: PUSH
34674: LD_VAR 0 2
34678: ARRAY
34679: PUSH
34680: LD_EXP 92
34684: PUSH
34685: LD_VAR 0 2
34689: ARRAY
34690: EQUAL
34691: OR
34692: PUSH
34693: LD_EXP 101
34697: PUSH
34698: LD_VAR 0 2
34702: ARRAY
34703: OR
34704: IFFALSE 34708
// continue ;
34706: GO 34654
// if mc_miners [ i ] then
34708: LD_EXP 92
34712: PUSH
34713: LD_VAR 0 2
34717: ARRAY
34718: IFFALSE 35099
// begin for j = mc_miners [ i ] downto 1 do
34720: LD_ADDR_VAR 0 3
34724: PUSH
34725: DOUBLE
34726: LD_EXP 92
34730: PUSH
34731: LD_VAR 0 2
34735: ARRAY
34736: INC
34737: ST_TO_ADDR
34738: LD_INT 1
34740: PUSH
34741: FOR_DOWNTO
34742: IFFALSE 35097
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34744: LD_EXP 92
34748: PUSH
34749: LD_VAR 0 2
34753: ARRAY
34754: PUSH
34755: LD_VAR 0 3
34759: ARRAY
34760: PPUSH
34761: CALL_OW 301
34765: PUSH
34766: LD_EXP 92
34770: PUSH
34771: LD_VAR 0 2
34775: ARRAY
34776: PUSH
34777: LD_VAR 0 3
34781: ARRAY
34782: PPUSH
34783: CALL_OW 257
34787: PUSH
34788: LD_INT 1
34790: NONEQUAL
34791: OR
34792: IFFALSE 34855
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34794: LD_ADDR_VAR 0 5
34798: PUSH
34799: LD_EXP 92
34803: PUSH
34804: LD_VAR 0 2
34808: ARRAY
34809: PUSH
34810: LD_EXP 92
34814: PUSH
34815: LD_VAR 0 2
34819: ARRAY
34820: PUSH
34821: LD_VAR 0 3
34825: ARRAY
34826: DIFF
34827: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34828: LD_ADDR_EXP 92
34832: PUSH
34833: LD_EXP 92
34837: PPUSH
34838: LD_VAR 0 2
34842: PPUSH
34843: LD_VAR 0 5
34847: PPUSH
34848: CALL_OW 1
34852: ST_TO_ADDR
// continue ;
34853: GO 34741
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34855: LD_EXP 92
34859: PUSH
34860: LD_VAR 0 2
34864: ARRAY
34865: PUSH
34866: LD_VAR 0 3
34870: ARRAY
34871: PPUSH
34872: CALL_OW 257
34876: PUSH
34877: LD_INT 1
34879: EQUAL
34880: PUSH
34881: LD_EXP 92
34885: PUSH
34886: LD_VAR 0 2
34890: ARRAY
34891: PUSH
34892: LD_VAR 0 3
34896: ARRAY
34897: PPUSH
34898: CALL_OW 459
34902: NOT
34903: AND
34904: PUSH
34905: LD_EXP 92
34909: PUSH
34910: LD_VAR 0 2
34914: ARRAY
34915: PUSH
34916: LD_VAR 0 3
34920: ARRAY
34921: PPUSH
34922: CALL_OW 314
34926: NOT
34927: AND
34928: IFFALSE 35095
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34930: LD_EXP 92
34934: PUSH
34935: LD_VAR 0 2
34939: ARRAY
34940: PUSH
34941: LD_VAR 0 3
34945: ARRAY
34946: PPUSH
34947: CALL_OW 310
34951: IFFALSE 34974
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34953: LD_EXP 92
34957: PUSH
34958: LD_VAR 0 2
34962: ARRAY
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PPUSH
34970: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34974: LD_EXP 92
34978: PUSH
34979: LD_VAR 0 2
34983: ARRAY
34984: PUSH
34985: LD_VAR 0 3
34989: ARRAY
34990: PPUSH
34991: CALL_OW 314
34995: NOT
34996: IFFALSE 35095
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
34998: LD_ADDR_VAR 0 7
35002: PUSH
35003: LD_VAR 0 3
35007: PUSH
35008: LD_EXP 91
35012: PUSH
35013: LD_VAR 0 2
35017: ARRAY
35018: PPUSH
35019: CALL 54914 0 1
35023: MOD
35024: PUSH
35025: LD_INT 1
35027: PLUS
35028: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35029: LD_EXP 92
35033: PUSH
35034: LD_VAR 0 2
35038: ARRAY
35039: PUSH
35040: LD_VAR 0 3
35044: ARRAY
35045: PPUSH
35046: LD_EXP 91
35050: PUSH
35051: LD_VAR 0 2
35055: ARRAY
35056: PUSH
35057: LD_VAR 0 7
35061: ARRAY
35062: PUSH
35063: LD_INT 1
35065: ARRAY
35066: PPUSH
35067: LD_EXP 91
35071: PUSH
35072: LD_VAR 0 2
35076: ARRAY
35077: PUSH
35078: LD_VAR 0 7
35082: ARRAY
35083: PUSH
35084: LD_INT 2
35086: ARRAY
35087: PPUSH
35088: LD_INT 0
35090: PPUSH
35091: CALL_OW 193
// end ; end ; end ;
35095: GO 34741
35097: POP
35098: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35099: LD_ADDR_VAR 0 5
35103: PUSH
35104: LD_EXP 78
35108: PUSH
35109: LD_VAR 0 2
35113: ARRAY
35114: PPUSH
35115: LD_INT 2
35117: PUSH
35118: LD_INT 30
35120: PUSH
35121: LD_INT 4
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 30
35130: PUSH
35131: LD_INT 5
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 30
35140: PUSH
35141: LD_INT 32
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: PPUSH
35154: CALL_OW 72
35158: ST_TO_ADDR
// if not tmp then
35159: LD_VAR 0 5
35163: NOT
35164: IFFALSE 35168
// continue ;
35166: GO 34654
// list := [ ] ;
35168: LD_ADDR_VAR 0 6
35172: PUSH
35173: EMPTY
35174: ST_TO_ADDR
// for j in tmp do
35175: LD_ADDR_VAR 0 3
35179: PUSH
35180: LD_VAR 0 5
35184: PUSH
35185: FOR_IN
35186: IFFALSE 35255
// begin for k in UnitsInside ( j ) do
35188: LD_ADDR_VAR 0 4
35192: PUSH
35193: LD_VAR 0 3
35197: PPUSH
35198: CALL_OW 313
35202: PUSH
35203: FOR_IN
35204: IFFALSE 35251
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35206: LD_VAR 0 4
35210: PPUSH
35211: CALL_OW 257
35215: PUSH
35216: LD_INT 1
35218: EQUAL
35219: PUSH
35220: LD_VAR 0 4
35224: PPUSH
35225: CALL_OW 459
35229: NOT
35230: AND
35231: IFFALSE 35249
// list := list ^ k ;
35233: LD_ADDR_VAR 0 6
35237: PUSH
35238: LD_VAR 0 6
35242: PUSH
35243: LD_VAR 0 4
35247: ADD
35248: ST_TO_ADDR
35249: GO 35203
35251: POP
35252: POP
// end ;
35253: GO 35185
35255: POP
35256: POP
// list := list diff mc_miners [ i ] ;
35257: LD_ADDR_VAR 0 6
35261: PUSH
35262: LD_VAR 0 6
35266: PUSH
35267: LD_EXP 92
35271: PUSH
35272: LD_VAR 0 2
35276: ARRAY
35277: DIFF
35278: ST_TO_ADDR
// if not list then
35279: LD_VAR 0 6
35283: NOT
35284: IFFALSE 35288
// continue ;
35286: GO 34654
// k := mc_mines [ i ] - mc_miners [ i ] ;
35288: LD_ADDR_VAR 0 4
35292: PUSH
35293: LD_EXP 91
35297: PUSH
35298: LD_VAR 0 2
35302: ARRAY
35303: PUSH
35304: LD_EXP 92
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: MINUS
35315: ST_TO_ADDR
// if k > list then
35316: LD_VAR 0 4
35320: PUSH
35321: LD_VAR 0 6
35325: GREATER
35326: IFFALSE 35338
// k := list ;
35328: LD_ADDR_VAR 0 4
35332: PUSH
35333: LD_VAR 0 6
35337: ST_TO_ADDR
// for j = 1 to k do
35338: LD_ADDR_VAR 0 3
35342: PUSH
35343: DOUBLE
35344: LD_INT 1
35346: DEC
35347: ST_TO_ADDR
35348: LD_VAR 0 4
35352: PUSH
35353: FOR_TO
35354: IFFALSE 35408
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35356: LD_ADDR_EXP 92
35360: PUSH
35361: LD_EXP 92
35365: PPUSH
35366: LD_VAR 0 2
35370: PUSH
35371: LD_EXP 92
35375: PUSH
35376: LD_VAR 0 2
35380: ARRAY
35381: PUSH
35382: LD_INT 1
35384: PLUS
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PPUSH
35390: LD_VAR 0 6
35394: PUSH
35395: LD_VAR 0 3
35399: ARRAY
35400: PPUSH
35401: CALL 57774 0 3
35405: ST_TO_ADDR
35406: GO 35353
35408: POP
35409: POP
// end ;
35410: GO 34654
35412: POP
35413: POP
// end ;
35414: LD_VAR 0 1
35418: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35419: LD_INT 0
35421: PPUSH
35422: PPUSH
35423: PPUSH
35424: PPUSH
35425: PPUSH
35426: PPUSH
35427: PPUSH
35428: PPUSH
35429: PPUSH
35430: PPUSH
35431: PPUSH
// if not mc_bases then
35432: LD_EXP 78
35436: NOT
35437: IFFALSE 35441
// exit ;
35439: GO 37264
// for i = 1 to mc_bases do
35441: LD_ADDR_VAR 0 2
35445: PUSH
35446: DOUBLE
35447: LD_INT 1
35449: DEC
35450: ST_TO_ADDR
35451: LD_EXP 78
35455: PUSH
35456: FOR_TO
35457: IFFALSE 37262
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35459: LD_EXP 78
35463: PUSH
35464: LD_VAR 0 2
35468: ARRAY
35469: NOT
35470: PUSH
35471: LD_EXP 85
35475: PUSH
35476: LD_VAR 0 2
35480: ARRAY
35481: OR
35482: IFFALSE 35486
// continue ;
35484: GO 35456
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35486: LD_EXP 94
35490: PUSH
35491: LD_VAR 0 2
35495: ARRAY
35496: NOT
35497: PUSH
35498: LD_EXP 95
35502: PUSH
35503: LD_VAR 0 2
35507: ARRAY
35508: AND
35509: IFFALSE 35547
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35511: LD_ADDR_EXP 95
35515: PUSH
35516: LD_EXP 95
35520: PPUSH
35521: LD_VAR 0 2
35525: PPUSH
35526: EMPTY
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35533: LD_VAR 0 2
35537: PPUSH
35538: LD_INT 107
35540: PPUSH
35541: CALL 26287 0 2
// continue ;
35545: GO 35456
// end ; target := [ ] ;
35547: LD_ADDR_VAR 0 7
35551: PUSH
35552: EMPTY
35553: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35554: LD_ADDR_VAR 0 6
35558: PUSH
35559: LD_EXP 78
35563: PUSH
35564: LD_VAR 0 2
35568: ARRAY
35569: PUSH
35570: LD_INT 1
35572: ARRAY
35573: PPUSH
35574: CALL_OW 255
35578: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35579: LD_ADDR_VAR 0 9
35583: PUSH
35584: LD_EXP 78
35588: PUSH
35589: LD_VAR 0 2
35593: ARRAY
35594: PPUSH
35595: LD_INT 2
35597: PUSH
35598: LD_INT 30
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 30
35610: PUSH
35611: LD_INT 1
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: LIST
35622: PPUSH
35623: CALL_OW 72
35627: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35628: LD_ADDR_VAR 0 3
35632: PUSH
35633: DOUBLE
35634: LD_EXP 94
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: INC
35645: ST_TO_ADDR
35646: LD_INT 1
35648: PUSH
35649: FOR_DOWNTO
35650: IFFALSE 35895
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35652: LD_EXP 94
35656: PUSH
35657: LD_VAR 0 2
35661: ARRAY
35662: PUSH
35663: LD_VAR 0 3
35667: ARRAY
35668: PUSH
35669: LD_INT 2
35671: ARRAY
35672: PPUSH
35673: LD_EXP 94
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 3
35688: ARRAY
35689: PUSH
35690: LD_INT 3
35692: ARRAY
35693: PPUSH
35694: CALL_OW 488
35698: PUSH
35699: LD_EXP 94
35703: PUSH
35704: LD_VAR 0 2
35708: ARRAY
35709: PUSH
35710: LD_VAR 0 3
35714: ARRAY
35715: PUSH
35716: LD_INT 2
35718: ARRAY
35719: PPUSH
35720: LD_EXP 94
35724: PUSH
35725: LD_VAR 0 2
35729: ARRAY
35730: PUSH
35731: LD_VAR 0 3
35735: ARRAY
35736: PUSH
35737: LD_INT 3
35739: ARRAY
35740: PPUSH
35741: CALL_OW 284
35745: PUSH
35746: LD_INT 0
35748: EQUAL
35749: AND
35750: IFFALSE 35805
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35752: LD_ADDR_VAR 0 5
35756: PUSH
35757: LD_EXP 94
35761: PUSH
35762: LD_VAR 0 2
35766: ARRAY
35767: PPUSH
35768: LD_VAR 0 3
35772: PPUSH
35773: CALL_OW 3
35777: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35778: LD_ADDR_EXP 94
35782: PUSH
35783: LD_EXP 94
35787: PPUSH
35788: LD_VAR 0 2
35792: PPUSH
35793: LD_VAR 0 5
35797: PPUSH
35798: CALL_OW 1
35802: ST_TO_ADDR
// continue ;
35803: GO 35649
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35805: LD_VAR 0 6
35809: PPUSH
35810: LD_EXP 94
35814: PUSH
35815: LD_VAR 0 2
35819: ARRAY
35820: PUSH
35821: LD_VAR 0 3
35825: ARRAY
35826: PUSH
35827: LD_INT 2
35829: ARRAY
35830: PPUSH
35831: LD_EXP 94
35835: PUSH
35836: LD_VAR 0 2
35840: ARRAY
35841: PUSH
35842: LD_VAR 0 3
35846: ARRAY
35847: PUSH
35848: LD_INT 3
35850: ARRAY
35851: PPUSH
35852: LD_INT 30
35854: PPUSH
35855: CALL 58670 0 4
35859: PUSH
35860: LD_INT 4
35862: ARRAY
35863: PUSH
35864: LD_INT 0
35866: EQUAL
35867: IFFALSE 35893
// begin target := mc_crates [ i ] [ j ] ;
35869: LD_ADDR_VAR 0 7
35873: PUSH
35874: LD_EXP 94
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: PUSH
35885: LD_VAR 0 3
35889: ARRAY
35890: ST_TO_ADDR
// break ;
35891: GO 35895
// end ; end ;
35893: GO 35649
35895: POP
35896: POP
// if not target then
35897: LD_VAR 0 7
35901: NOT
35902: IFFALSE 35906
// continue ;
35904: GO 35456
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35906: LD_ADDR_VAR 0 8
35910: PUSH
35911: LD_EXP 97
35915: PUSH
35916: LD_VAR 0 2
35920: ARRAY
35921: PPUSH
35922: LD_INT 2
35924: PUSH
35925: LD_INT 3
35927: PUSH
35928: LD_INT 58
35930: PUSH
35931: EMPTY
35932: LIST
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 61
35940: PUSH
35941: EMPTY
35942: LIST
35943: PUSH
35944: LD_INT 33
35946: PUSH
35947: LD_INT 5
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 33
35956: PUSH
35957: LD_INT 3
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: PUSH
35974: LD_INT 34
35976: PUSH
35977: LD_INT 32
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 34
35986: PUSH
35987: LD_INT 51
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 34
35996: PUSH
35997: LD_INT 12
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PPUSH
36014: CALL_OW 72
36018: ST_TO_ADDR
// if not cargo then
36019: LD_VAR 0 8
36023: NOT
36024: IFFALSE 36730
// begin if mc_crates_collector [ i ] < 5 then
36026: LD_EXP 95
36030: PUSH
36031: LD_VAR 0 2
36035: ARRAY
36036: PUSH
36037: LD_INT 5
36039: LESS
36040: IFFALSE 36406
// begin if mc_ape [ i ] then
36042: LD_EXP 107
36046: PUSH
36047: LD_VAR 0 2
36051: ARRAY
36052: IFFALSE 36099
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36054: LD_ADDR_VAR 0 5
36058: PUSH
36059: LD_EXP 107
36063: PUSH
36064: LD_VAR 0 2
36068: ARRAY
36069: PPUSH
36070: LD_INT 25
36072: PUSH
36073: LD_INT 16
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 24
36082: PUSH
36083: LD_INT 750
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PPUSH
36094: CALL_OW 72
36098: ST_TO_ADDR
// if not tmp then
36099: LD_VAR 0 5
36103: NOT
36104: IFFALSE 36151
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36106: LD_ADDR_VAR 0 5
36110: PUSH
36111: LD_EXP 78
36115: PUSH
36116: LD_VAR 0 2
36120: ARRAY
36121: PPUSH
36122: LD_INT 25
36124: PUSH
36125: LD_INT 2
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 24
36134: PUSH
36135: LD_INT 750
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PPUSH
36146: CALL_OW 72
36150: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36151: LD_EXP 107
36155: PUSH
36156: LD_VAR 0 2
36160: ARRAY
36161: PUSH
36162: LD_EXP 78
36166: PUSH
36167: LD_VAR 0 2
36171: ARRAY
36172: PPUSH
36173: LD_INT 25
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 24
36185: PUSH
36186: LD_INT 750
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PPUSH
36197: CALL_OW 72
36201: AND
36202: PUSH
36203: LD_VAR 0 5
36207: PUSH
36208: LD_INT 5
36210: LESS
36211: AND
36212: IFFALSE 36294
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36214: LD_ADDR_VAR 0 3
36218: PUSH
36219: LD_EXP 78
36223: PUSH
36224: LD_VAR 0 2
36228: ARRAY
36229: PPUSH
36230: LD_INT 25
36232: PUSH
36233: LD_INT 2
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 24
36242: PUSH
36243: LD_INT 750
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PPUSH
36254: CALL_OW 72
36258: PUSH
36259: FOR_IN
36260: IFFALSE 36292
// begin tmp := tmp union j ;
36262: LD_ADDR_VAR 0 5
36266: PUSH
36267: LD_VAR 0 5
36271: PUSH
36272: LD_VAR 0 3
36276: UNION
36277: ST_TO_ADDR
// if tmp >= 5 then
36278: LD_VAR 0 5
36282: PUSH
36283: LD_INT 5
36285: GREATEREQUAL
36286: IFFALSE 36290
// break ;
36288: GO 36292
// end ;
36290: GO 36259
36292: POP
36293: POP
// end ; if not tmp then
36294: LD_VAR 0 5
36298: NOT
36299: IFFALSE 36303
// continue ;
36301: GO 35456
// for j in tmp do
36303: LD_ADDR_VAR 0 3
36307: PUSH
36308: LD_VAR 0 5
36312: PUSH
36313: FOR_IN
36314: IFFALSE 36404
// if not GetTag ( j ) then
36316: LD_VAR 0 3
36320: PPUSH
36321: CALL_OW 110
36325: NOT
36326: IFFALSE 36402
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36328: LD_ADDR_EXP 95
36332: PUSH
36333: LD_EXP 95
36337: PPUSH
36338: LD_VAR 0 2
36342: PUSH
36343: LD_EXP 95
36347: PUSH
36348: LD_VAR 0 2
36352: ARRAY
36353: PUSH
36354: LD_INT 1
36356: PLUS
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PPUSH
36362: LD_VAR 0 3
36366: PPUSH
36367: CALL 57774 0 3
36371: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36372: LD_VAR 0 3
36376: PPUSH
36377: LD_INT 107
36379: PPUSH
36380: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36384: LD_EXP 95
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: PUSH
36395: LD_INT 5
36397: GREATEREQUAL
36398: IFFALSE 36402
// break ;
36400: GO 36404
// end ;
36402: GO 36313
36404: POP
36405: POP
// end ; if mc_crates_collector [ i ] and target then
36406: LD_EXP 95
36410: PUSH
36411: LD_VAR 0 2
36415: ARRAY
36416: PUSH
36417: LD_VAR 0 7
36421: AND
36422: IFFALSE 36728
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36424: LD_EXP 95
36428: PUSH
36429: LD_VAR 0 2
36433: ARRAY
36434: PUSH
36435: LD_VAR 0 7
36439: PUSH
36440: LD_INT 1
36442: ARRAY
36443: LESS
36444: IFFALSE 36464
// tmp := mc_crates_collector [ i ] else
36446: LD_ADDR_VAR 0 5
36450: PUSH
36451: LD_EXP 95
36455: PUSH
36456: LD_VAR 0 2
36460: ARRAY
36461: ST_TO_ADDR
36462: GO 36478
// tmp := target [ 1 ] ;
36464: LD_ADDR_VAR 0 5
36468: PUSH
36469: LD_VAR 0 7
36473: PUSH
36474: LD_INT 1
36476: ARRAY
36477: ST_TO_ADDR
// k := 0 ;
36478: LD_ADDR_VAR 0 4
36482: PUSH
36483: LD_INT 0
36485: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36486: LD_ADDR_VAR 0 3
36490: PUSH
36491: LD_EXP 95
36495: PUSH
36496: LD_VAR 0 2
36500: ARRAY
36501: PUSH
36502: FOR_IN
36503: IFFALSE 36726
// begin k := k + 1 ;
36505: LD_ADDR_VAR 0 4
36509: PUSH
36510: LD_VAR 0 4
36514: PUSH
36515: LD_INT 1
36517: PLUS
36518: ST_TO_ADDR
// if k > tmp then
36519: LD_VAR 0 4
36523: PUSH
36524: LD_VAR 0 5
36528: GREATER
36529: IFFALSE 36533
// break ;
36531: GO 36726
// if not GetClass ( j ) in [ 2 , 16 ] then
36533: LD_VAR 0 3
36537: PPUSH
36538: CALL_OW 257
36542: PUSH
36543: LD_INT 2
36545: PUSH
36546: LD_INT 16
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: IN
36553: NOT
36554: IFFALSE 36607
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
36556: LD_ADDR_EXP 95
36560: PUSH
36561: LD_EXP 95
36565: PPUSH
36566: LD_VAR 0 2
36570: PPUSH
36571: LD_EXP 95
36575: PUSH
36576: LD_VAR 0 2
36580: ARRAY
36581: PUSH
36582: LD_VAR 0 3
36586: DIFF
36587: PPUSH
36588: CALL_OW 1
36592: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36593: LD_VAR 0 3
36597: PPUSH
36598: LD_INT 0
36600: PPUSH
36601: CALL_OW 109
// continue ;
36605: GO 36502
// end ; if IsInUnit ( j ) then
36607: LD_VAR 0 3
36611: PPUSH
36612: CALL_OW 310
36616: IFFALSE 36627
// ComExitBuilding ( j ) ;
36618: LD_VAR 0 3
36622: PPUSH
36623: CALL_OW 122
// wait ( 3 ) ;
36627: LD_INT 3
36629: PPUSH
36630: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36634: LD_VAR 0 3
36638: PPUSH
36639: CALL_OW 314
36643: PUSH
36644: LD_VAR 0 6
36648: PPUSH
36649: LD_VAR 0 7
36653: PUSH
36654: LD_INT 2
36656: ARRAY
36657: PPUSH
36658: LD_VAR 0 7
36662: PUSH
36663: LD_INT 3
36665: ARRAY
36666: PPUSH
36667: LD_INT 30
36669: PPUSH
36670: CALL 58670 0 4
36674: PUSH
36675: LD_INT 4
36677: ARRAY
36678: AND
36679: IFFALSE 36697
// ComStandNearbyBuilding ( j , depot ) else
36681: LD_VAR 0 3
36685: PPUSH
36686: LD_VAR 0 9
36690: PPUSH
36691: CALL 54376 0 2
36695: GO 36724
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36697: LD_VAR 0 3
36701: PPUSH
36702: LD_VAR 0 7
36706: PUSH
36707: LD_INT 2
36709: ARRAY
36710: PPUSH
36711: LD_VAR 0 7
36715: PUSH
36716: LD_INT 3
36718: ARRAY
36719: PPUSH
36720: CALL_OW 117
// end ;
36724: GO 36502
36726: POP
36727: POP
// end ; end else
36728: GO 37260
// begin for j in cargo do
36730: LD_ADDR_VAR 0 3
36734: PUSH
36735: LD_VAR 0 8
36739: PUSH
36740: FOR_IN
36741: IFFALSE 37258
// begin if GetTag ( j ) <> 0 then
36743: LD_VAR 0 3
36747: PPUSH
36748: CALL_OW 110
36752: PUSH
36753: LD_INT 0
36755: NONEQUAL
36756: IFFALSE 36760
// continue ;
36758: GO 36740
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36760: LD_VAR 0 3
36764: PPUSH
36765: CALL_OW 256
36769: PUSH
36770: LD_INT 1000
36772: LESS
36773: PUSH
36774: LD_VAR 0 3
36778: PPUSH
36779: LD_EXP 102
36783: PUSH
36784: LD_VAR 0 2
36788: ARRAY
36789: PPUSH
36790: CALL_OW 308
36794: NOT
36795: AND
36796: IFFALSE 36818
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36798: LD_VAR 0 3
36802: PPUSH
36803: LD_EXP 102
36807: PUSH
36808: LD_VAR 0 2
36812: ARRAY
36813: PPUSH
36814: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36818: LD_VAR 0 3
36822: PPUSH
36823: CALL_OW 256
36827: PUSH
36828: LD_INT 1000
36830: LESS
36831: PUSH
36832: LD_VAR 0 3
36836: PPUSH
36837: LD_EXP 102
36841: PUSH
36842: LD_VAR 0 2
36846: ARRAY
36847: PPUSH
36848: CALL_OW 308
36852: AND
36853: IFFALSE 36857
// continue ;
36855: GO 36740
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36857: LD_VAR 0 3
36861: PPUSH
36862: CALL_OW 262
36866: PUSH
36867: LD_INT 2
36869: EQUAL
36870: PUSH
36871: LD_VAR 0 3
36875: PPUSH
36876: CALL_OW 261
36880: PUSH
36881: LD_INT 15
36883: LESS
36884: AND
36885: IFFALSE 36889
// continue ;
36887: GO 36740
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36889: LD_VAR 0 3
36893: PPUSH
36894: CALL_OW 262
36898: PUSH
36899: LD_INT 1
36901: EQUAL
36902: PUSH
36903: LD_VAR 0 3
36907: PPUSH
36908: CALL_OW 261
36912: PUSH
36913: LD_INT 10
36915: LESS
36916: AND
36917: IFFALSE 37197
// begin if not depot then
36919: LD_VAR 0 9
36923: NOT
36924: IFFALSE 36928
// continue ;
36926: GO 36740
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36928: LD_VAR 0 3
36932: PPUSH
36933: LD_VAR 0 9
36937: PPUSH
36938: LD_VAR 0 3
36942: PPUSH
36943: CALL_OW 74
36947: PPUSH
36948: CALL_OW 296
36952: PUSH
36953: LD_INT 6
36955: LESS
36956: IFFALSE 36972
// SetFuel ( j , 100 ) else
36958: LD_VAR 0 3
36962: PPUSH
36963: LD_INT 100
36965: PPUSH
36966: CALL_OW 240
36970: GO 37197
// if GetFuel ( j ) = 0 then
36972: LD_VAR 0 3
36976: PPUSH
36977: CALL_OW 261
36981: PUSH
36982: LD_INT 0
36984: EQUAL
36985: IFFALSE 37197
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36987: LD_ADDR_EXP 97
36991: PUSH
36992: LD_EXP 97
36996: PPUSH
36997: LD_VAR 0 2
37001: PPUSH
37002: LD_EXP 97
37006: PUSH
37007: LD_VAR 0 2
37011: ARRAY
37012: PUSH
37013: LD_VAR 0 3
37017: DIFF
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37024: LD_VAR 0 3
37028: PPUSH
37029: CALL_OW 263
37033: PUSH
37034: LD_INT 1
37036: EQUAL
37037: IFFALSE 37053
// ComExitVehicle ( IsInUnit ( j ) ) ;
37039: LD_VAR 0 3
37043: PPUSH
37044: CALL_OW 310
37048: PPUSH
37049: CALL_OW 121
// if GetControl ( j ) = control_remote then
37053: LD_VAR 0 3
37057: PPUSH
37058: CALL_OW 263
37062: PUSH
37063: LD_INT 2
37065: EQUAL
37066: IFFALSE 37077
// ComUnlink ( j ) ;
37068: LD_VAR 0 3
37072: PPUSH
37073: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37077: LD_ADDR_VAR 0 10
37081: PUSH
37082: LD_VAR 0 2
37086: PPUSH
37087: LD_INT 3
37089: PPUSH
37090: CALL 46841 0 2
37094: ST_TO_ADDR
// if fac then
37095: LD_VAR 0 10
37099: IFFALSE 37195
// begin for k in fac do
37101: LD_ADDR_VAR 0 4
37105: PUSH
37106: LD_VAR 0 10
37110: PUSH
37111: FOR_IN
37112: IFFALSE 37193
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37114: LD_ADDR_VAR 0 11
37118: PUSH
37119: LD_VAR 0 10
37123: PPUSH
37124: LD_VAR 0 3
37128: PPUSH
37129: CALL_OW 265
37133: PPUSH
37134: LD_VAR 0 3
37138: PPUSH
37139: CALL_OW 262
37143: PPUSH
37144: LD_VAR 0 3
37148: PPUSH
37149: CALL_OW 263
37153: PPUSH
37154: LD_VAR 0 3
37158: PPUSH
37159: CALL_OW 264
37163: PPUSH
37164: CALL 55272 0 5
37168: ST_TO_ADDR
// if components then
37169: LD_VAR 0 11
37173: IFFALSE 37191
// begin MC_InsertProduceList ( i , components ) ;
37175: LD_VAR 0 2
37179: PPUSH
37180: LD_VAR 0 11
37184: PPUSH
37185: CALL 46386 0 2
// break ;
37189: GO 37193
// end ; end ;
37191: GO 37111
37193: POP
37194: POP
// end ; continue ;
37195: GO 36740
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37197: LD_VAR 0 3
37201: PPUSH
37202: LD_INT 1
37204: PPUSH
37205: CALL_OW 289
37209: PUSH
37210: LD_INT 100
37212: LESS
37213: PUSH
37214: LD_VAR 0 3
37218: PPUSH
37219: CALL_OW 314
37223: NOT
37224: AND
37225: IFFALSE 37254
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37227: LD_VAR 0 3
37231: PPUSH
37232: LD_VAR 0 7
37236: PUSH
37237: LD_INT 2
37239: ARRAY
37240: PPUSH
37241: LD_VAR 0 7
37245: PUSH
37246: LD_INT 3
37248: ARRAY
37249: PPUSH
37250: CALL_OW 117
// break ;
37254: GO 37258
// end ;
37256: GO 36740
37258: POP
37259: POP
// end ; end ;
37260: GO 35456
37262: POP
37263: POP
// end ;
37264: LD_VAR 0 1
37268: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37269: LD_INT 0
37271: PPUSH
37272: PPUSH
37273: PPUSH
37274: PPUSH
// if not mc_bases then
37275: LD_EXP 78
37279: NOT
37280: IFFALSE 37284
// exit ;
37282: GO 37445
// for i = 1 to mc_bases do
37284: LD_ADDR_VAR 0 2
37288: PUSH
37289: DOUBLE
37290: LD_INT 1
37292: DEC
37293: ST_TO_ADDR
37294: LD_EXP 78
37298: PUSH
37299: FOR_TO
37300: IFFALSE 37443
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37302: LD_ADDR_VAR 0 4
37306: PUSH
37307: LD_EXP 97
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PUSH
37318: LD_EXP 100
37322: PUSH
37323: LD_VAR 0 2
37327: ARRAY
37328: UNION
37329: PPUSH
37330: LD_INT 33
37332: PUSH
37333: LD_INT 2
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PPUSH
37340: CALL_OW 72
37344: ST_TO_ADDR
// if tmp then
37345: LD_VAR 0 4
37349: IFFALSE 37441
// for j in tmp do
37351: LD_ADDR_VAR 0 3
37355: PUSH
37356: LD_VAR 0 4
37360: PUSH
37361: FOR_IN
37362: IFFALSE 37439
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37364: LD_VAR 0 3
37368: PPUSH
37369: CALL_OW 312
37373: NOT
37374: PUSH
37375: LD_VAR 0 3
37379: PPUSH
37380: CALL_OW 256
37384: PUSH
37385: LD_INT 250
37387: GREATEREQUAL
37388: AND
37389: IFFALSE 37402
// Connect ( j ) else
37391: LD_VAR 0 3
37395: PPUSH
37396: CALL 60743 0 1
37400: GO 37437
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37402: LD_VAR 0 3
37406: PPUSH
37407: CALL_OW 256
37411: PUSH
37412: LD_INT 250
37414: LESS
37415: PUSH
37416: LD_VAR 0 3
37420: PPUSH
37421: CALL_OW 312
37425: AND
37426: IFFALSE 37437
// ComUnlink ( j ) ;
37428: LD_VAR 0 3
37432: PPUSH
37433: CALL_OW 136
37437: GO 37361
37439: POP
37440: POP
// end ;
37441: GO 37299
37443: POP
37444: POP
// end ;
37445: LD_VAR 0 1
37449: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37450: LD_INT 0
37452: PPUSH
37453: PPUSH
37454: PPUSH
37455: PPUSH
37456: PPUSH
// if not mc_bases then
37457: LD_EXP 78
37461: NOT
37462: IFFALSE 37466
// exit ;
37464: GO 37911
// for i = 1 to mc_bases do
37466: LD_ADDR_VAR 0 2
37470: PUSH
37471: DOUBLE
37472: LD_INT 1
37474: DEC
37475: ST_TO_ADDR
37476: LD_EXP 78
37480: PUSH
37481: FOR_TO
37482: IFFALSE 37909
// begin if not mc_produce [ i ] then
37484: LD_EXP 99
37488: PUSH
37489: LD_VAR 0 2
37493: ARRAY
37494: NOT
37495: IFFALSE 37499
// continue ;
37497: GO 37481
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37499: LD_ADDR_VAR 0 5
37503: PUSH
37504: LD_EXP 78
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: PPUSH
37515: LD_INT 30
37517: PUSH
37518: LD_INT 3
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PPUSH
37525: CALL_OW 72
37529: ST_TO_ADDR
// if not fac then
37530: LD_VAR 0 5
37534: NOT
37535: IFFALSE 37539
// continue ;
37537: GO 37481
// for j in fac do
37539: LD_ADDR_VAR 0 3
37543: PUSH
37544: LD_VAR 0 5
37548: PUSH
37549: FOR_IN
37550: IFFALSE 37905
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37552: LD_VAR 0 3
37556: PPUSH
37557: CALL_OW 461
37561: PUSH
37562: LD_INT 2
37564: NONEQUAL
37565: PUSH
37566: LD_VAR 0 3
37570: PPUSH
37571: LD_INT 15
37573: PPUSH
37574: CALL 60371 0 2
37578: PUSH
37579: LD_INT 4
37581: ARRAY
37582: OR
37583: IFFALSE 37587
// continue ;
37585: GO 37549
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
37587: LD_VAR 0 3
37591: PPUSH
37592: LD_EXP 99
37596: PUSH
37597: LD_VAR 0 2
37601: ARRAY
37602: PUSH
37603: LD_INT 1
37605: ARRAY
37606: PUSH
37607: LD_INT 1
37609: ARRAY
37610: PPUSH
37611: LD_EXP 99
37615: PUSH
37616: LD_VAR 0 2
37620: ARRAY
37621: PUSH
37622: LD_INT 1
37624: ARRAY
37625: PUSH
37626: LD_INT 2
37628: ARRAY
37629: PPUSH
37630: LD_EXP 99
37634: PUSH
37635: LD_VAR 0 2
37639: ARRAY
37640: PUSH
37641: LD_INT 1
37643: ARRAY
37644: PUSH
37645: LD_INT 3
37647: ARRAY
37648: PPUSH
37649: LD_EXP 99
37653: PUSH
37654: LD_VAR 0 2
37658: ARRAY
37659: PUSH
37660: LD_INT 1
37662: ARRAY
37663: PUSH
37664: LD_INT 4
37666: ARRAY
37667: PPUSH
37668: CALL_OW 448
37672: PUSH
37673: LD_VAR 0 3
37677: PPUSH
37678: LD_EXP 99
37682: PUSH
37683: LD_VAR 0 2
37687: ARRAY
37688: PUSH
37689: LD_INT 1
37691: ARRAY
37692: PUSH
37693: LD_INT 1
37695: ARRAY
37696: PUSH
37697: LD_EXP 99
37701: PUSH
37702: LD_VAR 0 2
37706: ARRAY
37707: PUSH
37708: LD_INT 1
37710: ARRAY
37711: PUSH
37712: LD_INT 2
37714: ARRAY
37715: PUSH
37716: LD_EXP 99
37720: PUSH
37721: LD_VAR 0 2
37725: ARRAY
37726: PUSH
37727: LD_INT 1
37729: ARRAY
37730: PUSH
37731: LD_INT 3
37733: ARRAY
37734: PUSH
37735: LD_EXP 99
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PUSH
37746: LD_INT 1
37748: ARRAY
37749: PUSH
37750: LD_INT 4
37752: ARRAY
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: PPUSH
37760: CALL 64138 0 2
37764: AND
37765: IFFALSE 37903
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37767: LD_VAR 0 3
37771: PPUSH
37772: LD_EXP 99
37776: PUSH
37777: LD_VAR 0 2
37781: ARRAY
37782: PUSH
37783: LD_INT 1
37785: ARRAY
37786: PUSH
37787: LD_INT 1
37789: ARRAY
37790: PPUSH
37791: LD_EXP 99
37795: PUSH
37796: LD_VAR 0 2
37800: ARRAY
37801: PUSH
37802: LD_INT 1
37804: ARRAY
37805: PUSH
37806: LD_INT 2
37808: ARRAY
37809: PPUSH
37810: LD_EXP 99
37814: PUSH
37815: LD_VAR 0 2
37819: ARRAY
37820: PUSH
37821: LD_INT 1
37823: ARRAY
37824: PUSH
37825: LD_INT 3
37827: ARRAY
37828: PPUSH
37829: LD_EXP 99
37833: PUSH
37834: LD_VAR 0 2
37838: ARRAY
37839: PUSH
37840: LD_INT 1
37842: ARRAY
37843: PUSH
37844: LD_INT 4
37846: ARRAY
37847: PPUSH
37848: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37852: LD_ADDR_VAR 0 4
37856: PUSH
37857: LD_EXP 99
37861: PUSH
37862: LD_VAR 0 2
37866: ARRAY
37867: PPUSH
37868: LD_INT 1
37870: PPUSH
37871: CALL_OW 3
37875: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37876: LD_ADDR_EXP 99
37880: PUSH
37881: LD_EXP 99
37885: PPUSH
37886: LD_VAR 0 2
37890: PPUSH
37891: LD_VAR 0 4
37895: PPUSH
37896: CALL_OW 1
37900: ST_TO_ADDR
// break ;
37901: GO 37905
// end ; end ;
37903: GO 37549
37905: POP
37906: POP
// end ;
37907: GO 37481
37909: POP
37910: POP
// end ;
37911: LD_VAR 0 1
37915: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37916: LD_INT 0
37918: PPUSH
37919: PPUSH
37920: PPUSH
// if not mc_bases then
37921: LD_EXP 78
37925: NOT
37926: IFFALSE 37930
// exit ;
37928: GO 38019
// for i = 1 to mc_bases do
37930: LD_ADDR_VAR 0 2
37934: PUSH
37935: DOUBLE
37936: LD_INT 1
37938: DEC
37939: ST_TO_ADDR
37940: LD_EXP 78
37944: PUSH
37945: FOR_TO
37946: IFFALSE 38017
// begin if mc_attack [ i ] then
37948: LD_EXP 98
37952: PUSH
37953: LD_VAR 0 2
37957: ARRAY
37958: IFFALSE 38015
// begin tmp := mc_attack [ i ] [ 1 ] ;
37960: LD_ADDR_VAR 0 3
37964: PUSH
37965: LD_EXP 98
37969: PUSH
37970: LD_VAR 0 2
37974: ARRAY
37975: PUSH
37976: LD_INT 1
37978: ARRAY
37979: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37980: LD_ADDR_EXP 98
37984: PUSH
37985: LD_EXP 98
37989: PPUSH
37990: LD_VAR 0 2
37994: PPUSH
37995: EMPTY
37996: PPUSH
37997: CALL_OW 1
38001: ST_TO_ADDR
// Attack ( tmp ) ;
38002: LD_VAR 0 3
38006: PPUSH
38007: CALL 114267 0 1
// exit ;
38011: POP
38012: POP
38013: GO 38019
// end ; end ;
38015: GO 37945
38017: POP
38018: POP
// end ;
38019: LD_VAR 0 1
38023: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38024: LD_INT 0
38026: PPUSH
38027: PPUSH
38028: PPUSH
38029: PPUSH
38030: PPUSH
38031: PPUSH
38032: PPUSH
// if not mc_bases then
38033: LD_EXP 78
38037: NOT
38038: IFFALSE 38042
// exit ;
38040: GO 38899
// for i = 1 to mc_bases do
38042: LD_ADDR_VAR 0 2
38046: PUSH
38047: DOUBLE
38048: LD_INT 1
38050: DEC
38051: ST_TO_ADDR
38052: LD_EXP 78
38056: PUSH
38057: FOR_TO
38058: IFFALSE 38897
// begin if not mc_bases [ i ] then
38060: LD_EXP 78
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: NOT
38071: IFFALSE 38075
// continue ;
38073: GO 38057
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38075: LD_ADDR_VAR 0 7
38079: PUSH
38080: LD_EXP 78
38084: PUSH
38085: LD_VAR 0 2
38089: ARRAY
38090: PUSH
38091: LD_INT 1
38093: ARRAY
38094: PPUSH
38095: CALL 54598 0 1
38099: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38100: LD_ADDR_EXP 101
38104: PUSH
38105: LD_EXP 101
38109: PPUSH
38110: LD_VAR 0 2
38114: PPUSH
38115: LD_EXP 78
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: PUSH
38126: LD_INT 1
38128: ARRAY
38129: PPUSH
38130: CALL_OW 255
38134: PPUSH
38135: LD_EXP 103
38139: PUSH
38140: LD_VAR 0 2
38144: ARRAY
38145: PPUSH
38146: CALL 54563 0 2
38150: PPUSH
38151: CALL_OW 1
38155: ST_TO_ADDR
// if not mc_scan [ i ] then
38156: LD_EXP 101
38160: PUSH
38161: LD_VAR 0 2
38165: ARRAY
38166: NOT
38167: IFFALSE 38345
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38169: LD_ADDR_EXP 121
38173: PUSH
38174: LD_EXP 121
38178: PPUSH
38179: LD_VAR 0 2
38183: PPUSH
38184: LD_INT 0
38186: PPUSH
38187: CALL_OW 1
38191: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38192: LD_ADDR_VAR 0 4
38196: PUSH
38197: LD_EXP 78
38201: PUSH
38202: LD_VAR 0 2
38206: ARRAY
38207: PPUSH
38208: LD_INT 2
38210: PUSH
38211: LD_INT 25
38213: PUSH
38214: LD_INT 5
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 25
38223: PUSH
38224: LD_INT 8
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 25
38233: PUSH
38234: LD_INT 9
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: PPUSH
38247: CALL_OW 72
38251: ST_TO_ADDR
// if not tmp then
38252: LD_VAR 0 4
38256: NOT
38257: IFFALSE 38261
// continue ;
38259: GO 38057
// for j in tmp do
38261: LD_ADDR_VAR 0 3
38265: PUSH
38266: LD_VAR 0 4
38270: PUSH
38271: FOR_IN
38272: IFFALSE 38343
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38274: LD_VAR 0 3
38278: PPUSH
38279: CALL_OW 310
38283: PPUSH
38284: CALL_OW 266
38288: PUSH
38289: LD_INT 5
38291: EQUAL
38292: PUSH
38293: LD_VAR 0 3
38297: PPUSH
38298: CALL_OW 257
38302: PUSH
38303: LD_INT 1
38305: EQUAL
38306: AND
38307: PUSH
38308: LD_VAR 0 3
38312: PPUSH
38313: CALL_OW 459
38317: NOT
38318: AND
38319: PUSH
38320: LD_VAR 0 7
38324: AND
38325: IFFALSE 38341
// ComChangeProfession ( j , class ) ;
38327: LD_VAR 0 3
38331: PPUSH
38332: LD_VAR 0 7
38336: PPUSH
38337: CALL_OW 123
38341: GO 38271
38343: POP
38344: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38345: LD_EXP 101
38349: PUSH
38350: LD_VAR 0 2
38354: ARRAY
38355: PUSH
38356: LD_EXP 121
38360: PUSH
38361: LD_VAR 0 2
38365: ARRAY
38366: NOT
38367: AND
38368: PUSH
38369: LD_EXP 100
38373: PUSH
38374: LD_VAR 0 2
38378: ARRAY
38379: NOT
38380: AND
38381: PUSH
38382: LD_EXP 78
38386: PUSH
38387: LD_VAR 0 2
38391: ARRAY
38392: PPUSH
38393: LD_INT 50
38395: PUSH
38396: EMPTY
38397: LIST
38398: PUSH
38399: LD_INT 2
38401: PUSH
38402: LD_INT 30
38404: PUSH
38405: LD_INT 32
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 30
38414: PUSH
38415: LD_INT 33
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 30
38424: PUSH
38425: LD_INT 4
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 30
38434: PUSH
38435: LD_INT 5
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PPUSH
38453: CALL_OW 72
38457: PUSH
38458: LD_INT 4
38460: LESS
38461: PUSH
38462: LD_EXP 78
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PPUSH
38473: LD_INT 3
38475: PUSH
38476: LD_INT 24
38478: PUSH
38479: LD_INT 1000
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 2
38492: PUSH
38493: LD_INT 30
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 30
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: LIST
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PPUSH
38522: CALL_OW 72
38526: OR
38527: AND
38528: IFFALSE 38779
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38530: LD_ADDR_EXP 121
38534: PUSH
38535: LD_EXP 121
38539: PPUSH
38540: LD_VAR 0 2
38544: PPUSH
38545: LD_INT 1
38547: PPUSH
38548: CALL_OW 1
38552: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38553: LD_ADDR_VAR 0 4
38557: PUSH
38558: LD_EXP 78
38562: PUSH
38563: LD_VAR 0 2
38567: ARRAY
38568: PPUSH
38569: LD_INT 2
38571: PUSH
38572: LD_INT 25
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 25
38584: PUSH
38585: LD_INT 5
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 25
38594: PUSH
38595: LD_INT 8
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 25
38604: PUSH
38605: LD_INT 9
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: PPUSH
38619: CALL_OW 72
38623: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38624: LD_ADDR_VAR 0 4
38628: PUSH
38629: LD_VAR 0 4
38633: PUSH
38634: LD_VAR 0 4
38638: PPUSH
38639: LD_INT 18
38641: PPUSH
38642: CALL 87686 0 2
38646: DIFF
38647: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38648: LD_VAR 0 4
38652: NOT
38653: PUSH
38654: LD_EXP 78
38658: PUSH
38659: LD_VAR 0 2
38663: ARRAY
38664: PPUSH
38665: LD_INT 2
38667: PUSH
38668: LD_INT 30
38670: PUSH
38671: LD_INT 4
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 30
38680: PUSH
38681: LD_INT 5
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: LIST
38692: PPUSH
38693: CALL_OW 72
38697: NOT
38698: AND
38699: IFFALSE 38761
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38701: LD_ADDR_VAR 0 4
38705: PUSH
38706: LD_EXP 78
38710: PUSH
38711: LD_VAR 0 2
38715: ARRAY
38716: PPUSH
38717: LD_INT 2
38719: PUSH
38720: LD_INT 25
38722: PUSH
38723: LD_INT 2
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 25
38732: PUSH
38733: LD_INT 3
38735: PUSH
38736: EMPTY
38737: LIST
38738: LIST
38739: PUSH
38740: LD_INT 25
38742: PUSH
38743: LD_INT 4
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: PPUSH
38756: CALL_OW 72
38760: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38761: LD_VAR 0 2
38765: PPUSH
38766: LD_VAR 0 4
38770: PPUSH
38771: CALL 118976 0 2
// exit ;
38775: POP
38776: POP
38777: GO 38899
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38779: LD_EXP 101
38783: PUSH
38784: LD_VAR 0 2
38788: ARRAY
38789: PUSH
38790: LD_EXP 121
38794: PUSH
38795: LD_VAR 0 2
38799: ARRAY
38800: NOT
38801: AND
38802: PUSH
38803: LD_EXP 100
38807: PUSH
38808: LD_VAR 0 2
38812: ARRAY
38813: AND
38814: IFFALSE 38895
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38816: LD_ADDR_EXP 121
38820: PUSH
38821: LD_EXP 121
38825: PPUSH
38826: LD_VAR 0 2
38830: PPUSH
38831: LD_INT 1
38833: PPUSH
38834: CALL_OW 1
38838: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38839: LD_ADDR_VAR 0 4
38843: PUSH
38844: LD_EXP 100
38848: PUSH
38849: LD_VAR 0 2
38853: ARRAY
38854: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38855: LD_ADDR_EXP 100
38859: PUSH
38860: LD_EXP 100
38864: PPUSH
38865: LD_VAR 0 2
38869: PPUSH
38870: EMPTY
38871: PPUSH
38872: CALL_OW 1
38876: ST_TO_ADDR
// Defend ( i , tmp ) ;
38877: LD_VAR 0 2
38881: PPUSH
38882: LD_VAR 0 4
38886: PPUSH
38887: CALL 119572 0 2
// exit ;
38891: POP
38892: POP
38893: GO 38899
// end ; end ;
38895: GO 38057
38897: POP
38898: POP
// end ;
38899: LD_VAR 0 1
38903: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38904: LD_INT 0
38906: PPUSH
38907: PPUSH
38908: PPUSH
38909: PPUSH
38910: PPUSH
38911: PPUSH
38912: PPUSH
38913: PPUSH
38914: PPUSH
38915: PPUSH
38916: PPUSH
// if not mc_bases then
38917: LD_EXP 78
38921: NOT
38922: IFFALSE 38926
// exit ;
38924: GO 40013
// for i = 1 to mc_bases do
38926: LD_ADDR_VAR 0 2
38930: PUSH
38931: DOUBLE
38932: LD_INT 1
38934: DEC
38935: ST_TO_ADDR
38936: LD_EXP 78
38940: PUSH
38941: FOR_TO
38942: IFFALSE 40011
// begin tmp := mc_lab [ i ] ;
38944: LD_ADDR_VAR 0 6
38948: PUSH
38949: LD_EXP 111
38953: PUSH
38954: LD_VAR 0 2
38958: ARRAY
38959: ST_TO_ADDR
// if not tmp then
38960: LD_VAR 0 6
38964: NOT
38965: IFFALSE 38969
// continue ;
38967: GO 38941
// idle_lab := 0 ;
38969: LD_ADDR_VAR 0 11
38973: PUSH
38974: LD_INT 0
38976: ST_TO_ADDR
// for j in tmp do
38977: LD_ADDR_VAR 0 3
38981: PUSH
38982: LD_VAR 0 6
38986: PUSH
38987: FOR_IN
38988: IFFALSE 40007
// begin researching := false ;
38990: LD_ADDR_VAR 0 10
38994: PUSH
38995: LD_INT 0
38997: ST_TO_ADDR
// side := GetSide ( j ) ;
38998: LD_ADDR_VAR 0 4
39002: PUSH
39003: LD_VAR 0 3
39007: PPUSH
39008: CALL_OW 255
39012: ST_TO_ADDR
// if not mc_tech [ side ] then
39013: LD_EXP 105
39017: PUSH
39018: LD_VAR 0 4
39022: ARRAY
39023: NOT
39024: IFFALSE 39028
// continue ;
39026: GO 38987
// if BuildingStatus ( j ) = bs_idle then
39028: LD_VAR 0 3
39032: PPUSH
39033: CALL_OW 461
39037: PUSH
39038: LD_INT 2
39040: EQUAL
39041: IFFALSE 39229
// begin if idle_lab and UnitsInside ( j ) < 6 then
39043: LD_VAR 0 11
39047: PUSH
39048: LD_VAR 0 3
39052: PPUSH
39053: CALL_OW 313
39057: PUSH
39058: LD_INT 6
39060: LESS
39061: AND
39062: IFFALSE 39133
// begin tmp2 := UnitsInside ( idle_lab ) ;
39064: LD_ADDR_VAR 0 9
39068: PUSH
39069: LD_VAR 0 11
39073: PPUSH
39074: CALL_OW 313
39078: ST_TO_ADDR
// if tmp2 then
39079: LD_VAR 0 9
39083: IFFALSE 39125
// for x in tmp2 do
39085: LD_ADDR_VAR 0 7
39089: PUSH
39090: LD_VAR 0 9
39094: PUSH
39095: FOR_IN
39096: IFFALSE 39123
// begin ComExitBuilding ( x ) ;
39098: LD_VAR 0 7
39102: PPUSH
39103: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39107: LD_VAR 0 7
39111: PPUSH
39112: LD_VAR 0 3
39116: PPUSH
39117: CALL_OW 180
// end ;
39121: GO 39095
39123: POP
39124: POP
// idle_lab := 0 ;
39125: LD_ADDR_VAR 0 11
39129: PUSH
39130: LD_INT 0
39132: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39133: LD_ADDR_VAR 0 5
39137: PUSH
39138: LD_EXP 105
39142: PUSH
39143: LD_VAR 0 4
39147: ARRAY
39148: PUSH
39149: FOR_IN
39150: IFFALSE 39210
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39152: LD_VAR 0 3
39156: PPUSH
39157: LD_VAR 0 5
39161: PPUSH
39162: CALL_OW 430
39166: PUSH
39167: LD_VAR 0 4
39171: PPUSH
39172: LD_VAR 0 5
39176: PPUSH
39177: CALL 53668 0 2
39181: AND
39182: IFFALSE 39208
// begin researching := true ;
39184: LD_ADDR_VAR 0 10
39188: PUSH
39189: LD_INT 1
39191: ST_TO_ADDR
// ComResearch ( j , t ) ;
39192: LD_VAR 0 3
39196: PPUSH
39197: LD_VAR 0 5
39201: PPUSH
39202: CALL_OW 124
// break ;
39206: GO 39210
// end ;
39208: GO 39149
39210: POP
39211: POP
// if not researching then
39212: LD_VAR 0 10
39216: NOT
39217: IFFALSE 39229
// idle_lab := j ;
39219: LD_ADDR_VAR 0 11
39223: PUSH
39224: LD_VAR 0 3
39228: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39229: LD_VAR 0 3
39233: PPUSH
39234: CALL_OW 461
39238: PUSH
39239: LD_INT 10
39241: EQUAL
39242: IFFALSE 39830
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39244: LD_EXP 107
39248: PUSH
39249: LD_VAR 0 2
39253: ARRAY
39254: NOT
39255: PUSH
39256: LD_EXP 108
39260: PUSH
39261: LD_VAR 0 2
39265: ARRAY
39266: NOT
39267: AND
39268: PUSH
39269: LD_EXP 105
39273: PUSH
39274: LD_VAR 0 4
39278: ARRAY
39279: PUSH
39280: LD_INT 1
39282: GREATER
39283: AND
39284: IFFALSE 39415
// begin ComCancel ( j ) ;
39286: LD_VAR 0 3
39290: PPUSH
39291: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39295: LD_ADDR_EXP 105
39299: PUSH
39300: LD_EXP 105
39304: PPUSH
39305: LD_VAR 0 4
39309: PPUSH
39310: LD_EXP 105
39314: PUSH
39315: LD_VAR 0 4
39319: ARRAY
39320: PPUSH
39321: LD_EXP 105
39325: PUSH
39326: LD_VAR 0 4
39330: ARRAY
39331: PUSH
39332: LD_INT 1
39334: MINUS
39335: PPUSH
39336: LD_EXP 105
39340: PUSH
39341: LD_VAR 0 4
39345: ARRAY
39346: PPUSH
39347: LD_INT 0
39349: PPUSH
39350: CALL 57192 0 4
39354: PPUSH
39355: CALL_OW 1
39359: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39360: LD_ADDR_EXP 105
39364: PUSH
39365: LD_EXP 105
39369: PPUSH
39370: LD_VAR 0 4
39374: PPUSH
39375: LD_EXP 105
39379: PUSH
39380: LD_VAR 0 4
39384: ARRAY
39385: PPUSH
39386: LD_EXP 105
39390: PUSH
39391: LD_VAR 0 4
39395: ARRAY
39396: PPUSH
39397: LD_INT 1
39399: PPUSH
39400: LD_INT 0
39402: PPUSH
39403: CALL 57192 0 4
39407: PPUSH
39408: CALL_OW 1
39412: ST_TO_ADDR
// continue ;
39413: GO 38987
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39415: LD_EXP 107
39419: PUSH
39420: LD_VAR 0 2
39424: ARRAY
39425: PUSH
39426: LD_EXP 108
39430: PUSH
39431: LD_VAR 0 2
39435: ARRAY
39436: NOT
39437: AND
39438: IFFALSE 39565
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39440: LD_ADDR_EXP 108
39444: PUSH
39445: LD_EXP 108
39449: PPUSH
39450: LD_VAR 0 2
39454: PUSH
39455: LD_EXP 108
39459: PUSH
39460: LD_VAR 0 2
39464: ARRAY
39465: PUSH
39466: LD_INT 1
39468: PLUS
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PPUSH
39474: LD_EXP 107
39478: PUSH
39479: LD_VAR 0 2
39483: ARRAY
39484: PUSH
39485: LD_INT 1
39487: ARRAY
39488: PPUSH
39489: CALL 57774 0 3
39493: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39494: LD_EXP 107
39498: PUSH
39499: LD_VAR 0 2
39503: ARRAY
39504: PUSH
39505: LD_INT 1
39507: ARRAY
39508: PPUSH
39509: LD_INT 112
39511: PPUSH
39512: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39516: LD_ADDR_VAR 0 9
39520: PUSH
39521: LD_EXP 107
39525: PUSH
39526: LD_VAR 0 2
39530: ARRAY
39531: PPUSH
39532: LD_INT 1
39534: PPUSH
39535: CALL_OW 3
39539: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39540: LD_ADDR_EXP 107
39544: PUSH
39545: LD_EXP 107
39549: PPUSH
39550: LD_VAR 0 2
39554: PPUSH
39555: LD_VAR 0 9
39559: PPUSH
39560: CALL_OW 1
39564: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
39565: LD_EXP 107
39569: PUSH
39570: LD_VAR 0 2
39574: ARRAY
39575: PUSH
39576: LD_EXP 108
39580: PUSH
39581: LD_VAR 0 2
39585: ARRAY
39586: AND
39587: PUSH
39588: LD_EXP 108
39592: PUSH
39593: LD_VAR 0 2
39597: ARRAY
39598: PUSH
39599: LD_INT 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 310
39607: NOT
39608: AND
39609: PUSH
39610: LD_VAR 0 3
39614: PPUSH
39615: CALL_OW 313
39619: PUSH
39620: LD_INT 6
39622: EQUAL
39623: AND
39624: IFFALSE 39680
// begin tmp2 := UnitsInside ( j ) ;
39626: LD_ADDR_VAR 0 9
39630: PUSH
39631: LD_VAR 0 3
39635: PPUSH
39636: CALL_OW 313
39640: ST_TO_ADDR
// if tmp2 = 6 then
39641: LD_VAR 0 9
39645: PUSH
39646: LD_INT 6
39648: EQUAL
39649: IFFALSE 39680
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39651: LD_VAR 0 9
39655: PUSH
39656: LD_INT 1
39658: ARRAY
39659: PPUSH
39660: LD_INT 112
39662: PPUSH
39663: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39667: LD_VAR 0 9
39671: PUSH
39672: LD_INT 1
39674: ARRAY
39675: PPUSH
39676: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39680: LD_EXP 108
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_EXP 108
39695: PUSH
39696: LD_VAR 0 2
39700: ARRAY
39701: PUSH
39702: LD_INT 1
39704: ARRAY
39705: PPUSH
39706: CALL_OW 314
39710: NOT
39711: AND
39712: PUSH
39713: LD_EXP 108
39717: PUSH
39718: LD_VAR 0 2
39722: ARRAY
39723: PUSH
39724: LD_INT 1
39726: ARRAY
39727: PPUSH
39728: CALL_OW 310
39732: NOT
39733: AND
39734: IFFALSE 39760
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39736: LD_EXP 108
39740: PUSH
39741: LD_VAR 0 2
39745: ARRAY
39746: PUSH
39747: LD_INT 1
39749: ARRAY
39750: PPUSH
39751: LD_VAR 0 3
39755: PPUSH
39756: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39760: LD_EXP 108
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: PUSH
39771: LD_INT 1
39773: ARRAY
39774: PPUSH
39775: CALL_OW 310
39779: PUSH
39780: LD_EXP 108
39784: PUSH
39785: LD_VAR 0 2
39789: ARRAY
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PPUSH
39795: CALL_OW 310
39799: PPUSH
39800: CALL_OW 461
39804: PUSH
39805: LD_INT 3
39807: NONEQUAL
39808: AND
39809: IFFALSE 39830
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39811: LD_EXP 108
39815: PUSH
39816: LD_VAR 0 2
39820: ARRAY
39821: PUSH
39822: LD_INT 1
39824: ARRAY
39825: PPUSH
39826: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39830: LD_VAR 0 3
39834: PPUSH
39835: CALL_OW 461
39839: PUSH
39840: LD_INT 6
39842: EQUAL
39843: PUSH
39844: LD_VAR 0 6
39848: PUSH
39849: LD_INT 1
39851: GREATER
39852: AND
39853: IFFALSE 40005
// begin sci := [ ] ;
39855: LD_ADDR_VAR 0 8
39859: PUSH
39860: EMPTY
39861: ST_TO_ADDR
// for x in ( tmp diff j ) do
39862: LD_ADDR_VAR 0 7
39866: PUSH
39867: LD_VAR 0 6
39871: PUSH
39872: LD_VAR 0 3
39876: DIFF
39877: PUSH
39878: FOR_IN
39879: IFFALSE 39931
// begin if sci = 6 then
39881: LD_VAR 0 8
39885: PUSH
39886: LD_INT 6
39888: EQUAL
39889: IFFALSE 39893
// break ;
39891: GO 39931
// if BuildingStatus ( x ) = bs_idle then
39893: LD_VAR 0 7
39897: PPUSH
39898: CALL_OW 461
39902: PUSH
39903: LD_INT 2
39905: EQUAL
39906: IFFALSE 39929
// sci := sci ^ UnitsInside ( x ) ;
39908: LD_ADDR_VAR 0 8
39912: PUSH
39913: LD_VAR 0 8
39917: PUSH
39918: LD_VAR 0 7
39922: PPUSH
39923: CALL_OW 313
39927: ADD
39928: ST_TO_ADDR
// end ;
39929: GO 39878
39931: POP
39932: POP
// if not sci then
39933: LD_VAR 0 8
39937: NOT
39938: IFFALSE 39942
// continue ;
39940: GO 38987
// for x in sci do
39942: LD_ADDR_VAR 0 7
39946: PUSH
39947: LD_VAR 0 8
39951: PUSH
39952: FOR_IN
39953: IFFALSE 40003
// if IsInUnit ( x ) and not HasTask ( x ) then
39955: LD_VAR 0 7
39959: PPUSH
39960: CALL_OW 310
39964: PUSH
39965: LD_VAR 0 7
39969: PPUSH
39970: CALL_OW 314
39974: NOT
39975: AND
39976: IFFALSE 40001
// begin ComExitBuilding ( x ) ;
39978: LD_VAR 0 7
39982: PPUSH
39983: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39987: LD_VAR 0 7
39991: PPUSH
39992: LD_VAR 0 3
39996: PPUSH
39997: CALL_OW 180
// end ;
40001: GO 39952
40003: POP
40004: POP
// end ; end ;
40005: GO 38987
40007: POP
40008: POP
// end ;
40009: GO 38941
40011: POP
40012: POP
// end ;
40013: LD_VAR 0 1
40017: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40018: LD_INT 0
40020: PPUSH
40021: PPUSH
// if not mc_bases then
40022: LD_EXP 78
40026: NOT
40027: IFFALSE 40031
// exit ;
40029: GO 40112
// for i = 1 to mc_bases do
40031: LD_ADDR_VAR 0 2
40035: PUSH
40036: DOUBLE
40037: LD_INT 1
40039: DEC
40040: ST_TO_ADDR
40041: LD_EXP 78
40045: PUSH
40046: FOR_TO
40047: IFFALSE 40110
// if mc_mines [ i ] and mc_miners [ i ] then
40049: LD_EXP 91
40053: PUSH
40054: LD_VAR 0 2
40058: ARRAY
40059: PUSH
40060: LD_EXP 92
40064: PUSH
40065: LD_VAR 0 2
40069: ARRAY
40070: AND
40071: IFFALSE 40108
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40073: LD_EXP 92
40077: PUSH
40078: LD_VAR 0 2
40082: ARRAY
40083: PUSH
40084: LD_INT 1
40086: ARRAY
40087: PPUSH
40088: CALL_OW 255
40092: PPUSH
40093: LD_EXP 91
40097: PUSH
40098: LD_VAR 0 2
40102: ARRAY
40103: PPUSH
40104: CALL 54751 0 2
40108: GO 40046
40110: POP
40111: POP
// end ;
40112: LD_VAR 0 1
40116: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40117: LD_INT 0
40119: PPUSH
40120: PPUSH
40121: PPUSH
40122: PPUSH
40123: PPUSH
40124: PPUSH
40125: PPUSH
40126: PPUSH
// if not mc_bases or not mc_parking then
40127: LD_EXP 78
40131: NOT
40132: PUSH
40133: LD_EXP 102
40137: NOT
40138: OR
40139: IFFALSE 40143
// exit ;
40141: GO 40881
// for i = 1 to mc_bases do
40143: LD_ADDR_VAR 0 2
40147: PUSH
40148: DOUBLE
40149: LD_INT 1
40151: DEC
40152: ST_TO_ADDR
40153: LD_EXP 78
40157: PUSH
40158: FOR_TO
40159: IFFALSE 40879
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40161: LD_EXP 78
40165: PUSH
40166: LD_VAR 0 2
40170: ARRAY
40171: NOT
40172: PUSH
40173: LD_EXP 102
40177: PUSH
40178: LD_VAR 0 2
40182: ARRAY
40183: NOT
40184: OR
40185: IFFALSE 40189
// continue ;
40187: GO 40158
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40189: LD_ADDR_VAR 0 5
40193: PUSH
40194: LD_EXP 78
40198: PUSH
40199: LD_VAR 0 2
40203: ARRAY
40204: PUSH
40205: LD_INT 1
40207: ARRAY
40208: PPUSH
40209: CALL_OW 255
40213: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40214: LD_ADDR_VAR 0 6
40218: PUSH
40219: LD_EXP 78
40223: PUSH
40224: LD_VAR 0 2
40228: ARRAY
40229: PPUSH
40230: LD_INT 30
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PPUSH
40240: CALL_OW 72
40244: ST_TO_ADDR
// if not fac then
40245: LD_VAR 0 6
40249: NOT
40250: IFFALSE 40301
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40252: LD_ADDR_VAR 0 6
40256: PUSH
40257: LD_EXP 78
40261: PUSH
40262: LD_VAR 0 2
40266: ARRAY
40267: PPUSH
40268: LD_INT 2
40270: PUSH
40271: LD_INT 30
40273: PUSH
40274: LD_INT 0
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 30
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: LIST
40295: PPUSH
40296: CALL_OW 72
40300: ST_TO_ADDR
// if not fac then
40301: LD_VAR 0 6
40305: NOT
40306: IFFALSE 40310
// continue ;
40308: GO 40158
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40310: LD_ADDR_VAR 0 7
40314: PUSH
40315: LD_EXP 102
40319: PUSH
40320: LD_VAR 0 2
40324: ARRAY
40325: PPUSH
40326: LD_INT 22
40328: PUSH
40329: LD_VAR 0 5
40333: PUSH
40334: EMPTY
40335: LIST
40336: LIST
40337: PUSH
40338: LD_INT 21
40340: PUSH
40341: LD_INT 2
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: PUSH
40351: LD_INT 60
40353: PUSH
40354: EMPTY
40355: LIST
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 3
40363: PUSH
40364: LD_INT 24
40366: PUSH
40367: LD_INT 1000
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: PPUSH
40384: CALL_OW 70
40388: ST_TO_ADDR
// for j in fac do
40389: LD_ADDR_VAR 0 3
40393: PUSH
40394: LD_VAR 0 6
40398: PUSH
40399: FOR_IN
40400: IFFALSE 40495
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40402: LD_ADDR_VAR 0 7
40406: PUSH
40407: LD_VAR 0 7
40411: PUSH
40412: LD_INT 22
40414: PUSH
40415: LD_VAR 0 5
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 91
40426: PUSH
40427: LD_VAR 0 3
40431: PUSH
40432: LD_INT 15
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 21
40442: PUSH
40443: LD_INT 2
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 3
40452: PUSH
40453: LD_INT 60
40455: PUSH
40456: EMPTY
40457: LIST
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 24
40468: PUSH
40469: LD_INT 1000
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: PPUSH
40487: CALL_OW 69
40491: UNION
40492: ST_TO_ADDR
40493: GO 40399
40495: POP
40496: POP
// if not vehs then
40497: LD_VAR 0 7
40501: NOT
40502: IFFALSE 40528
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40504: LD_ADDR_EXP 90
40508: PUSH
40509: LD_EXP 90
40513: PPUSH
40514: LD_VAR 0 2
40518: PPUSH
40519: EMPTY
40520: PPUSH
40521: CALL_OW 1
40525: ST_TO_ADDR
// continue ;
40526: GO 40158
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40528: LD_ADDR_VAR 0 8
40532: PUSH
40533: LD_EXP 78
40537: PUSH
40538: LD_VAR 0 2
40542: ARRAY
40543: PPUSH
40544: LD_INT 30
40546: PUSH
40547: LD_INT 3
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PPUSH
40554: CALL_OW 72
40558: ST_TO_ADDR
// if tmp then
40559: LD_VAR 0 8
40563: IFFALSE 40666
// begin for j in tmp do
40565: LD_ADDR_VAR 0 3
40569: PUSH
40570: LD_VAR 0 8
40574: PUSH
40575: FOR_IN
40576: IFFALSE 40664
// for k in UnitsInside ( j ) do
40578: LD_ADDR_VAR 0 4
40582: PUSH
40583: LD_VAR 0 3
40587: PPUSH
40588: CALL_OW 313
40592: PUSH
40593: FOR_IN
40594: IFFALSE 40660
// if k then
40596: LD_VAR 0 4
40600: IFFALSE 40658
// if not k in mc_repair_vehicle [ i ] then
40602: LD_VAR 0 4
40606: PUSH
40607: LD_EXP 90
40611: PUSH
40612: LD_VAR 0 2
40616: ARRAY
40617: IN
40618: NOT
40619: IFFALSE 40658
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40621: LD_ADDR_EXP 90
40625: PUSH
40626: LD_EXP 90
40630: PPUSH
40631: LD_VAR 0 2
40635: PPUSH
40636: LD_EXP 90
40640: PUSH
40641: LD_VAR 0 2
40645: ARRAY
40646: PUSH
40647: LD_VAR 0 4
40651: UNION
40652: PPUSH
40653: CALL_OW 1
40657: ST_TO_ADDR
40658: GO 40593
40660: POP
40661: POP
40662: GO 40575
40664: POP
40665: POP
// end ; if not mc_repair_vehicle [ i ] then
40666: LD_EXP 90
40670: PUSH
40671: LD_VAR 0 2
40675: ARRAY
40676: NOT
40677: IFFALSE 40681
// continue ;
40679: GO 40158
// for j in mc_repair_vehicle [ i ] do
40681: LD_ADDR_VAR 0 3
40685: PUSH
40686: LD_EXP 90
40690: PUSH
40691: LD_VAR 0 2
40695: ARRAY
40696: PUSH
40697: FOR_IN
40698: IFFALSE 40875
// begin if GetClass ( j ) <> 3 then
40700: LD_VAR 0 3
40704: PPUSH
40705: CALL_OW 257
40709: PUSH
40710: LD_INT 3
40712: NONEQUAL
40713: IFFALSE 40754
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40715: LD_ADDR_EXP 90
40719: PUSH
40720: LD_EXP 90
40724: PPUSH
40725: LD_VAR 0 2
40729: PPUSH
40730: LD_EXP 90
40734: PUSH
40735: LD_VAR 0 2
40739: ARRAY
40740: PUSH
40741: LD_VAR 0 3
40745: DIFF
40746: PPUSH
40747: CALL_OW 1
40751: ST_TO_ADDR
// continue ;
40752: GO 40697
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40754: LD_VAR 0 3
40758: PPUSH
40759: CALL_OW 311
40763: NOT
40764: PUSH
40765: LD_VAR 0 3
40769: PUSH
40770: LD_EXP 81
40774: PUSH
40775: LD_VAR 0 2
40779: ARRAY
40780: PUSH
40781: LD_INT 1
40783: ARRAY
40784: IN
40785: NOT
40786: AND
40787: PUSH
40788: LD_VAR 0 3
40792: PUSH
40793: LD_EXP 81
40797: PUSH
40798: LD_VAR 0 2
40802: ARRAY
40803: PUSH
40804: LD_INT 2
40806: ARRAY
40807: IN
40808: NOT
40809: AND
40810: IFFALSE 40873
// begin if IsInUnit ( j ) then
40812: LD_VAR 0 3
40816: PPUSH
40817: CALL_OW 310
40821: IFFALSE 40834
// ComExitBuilding ( j ) else
40823: LD_VAR 0 3
40827: PPUSH
40828: CALL_OW 122
40832: GO 40873
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40834: LD_VAR 0 3
40838: PPUSH
40839: LD_VAR 0 7
40843: PUSH
40844: LD_INT 1
40846: ARRAY
40847: PPUSH
40848: CALL 92169 0 2
40852: NOT
40853: IFFALSE 40873
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40855: LD_VAR 0 3
40859: PPUSH
40860: LD_VAR 0 7
40864: PUSH
40865: LD_INT 1
40867: ARRAY
40868: PPUSH
40869: CALL_OW 129
// end ; end ;
40873: GO 40697
40875: POP
40876: POP
// end ;
40877: GO 40158
40879: POP
40880: POP
// end ;
40881: LD_VAR 0 1
40885: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40886: LD_INT 0
40888: PPUSH
40889: PPUSH
40890: PPUSH
40891: PPUSH
40892: PPUSH
40893: PPUSH
40894: PPUSH
40895: PPUSH
40896: PPUSH
40897: PPUSH
40898: PPUSH
// if not mc_bases then
40899: LD_EXP 78
40903: NOT
40904: IFFALSE 40908
// exit ;
40906: GO 41710
// for i = 1 to mc_bases do
40908: LD_ADDR_VAR 0 2
40912: PUSH
40913: DOUBLE
40914: LD_INT 1
40916: DEC
40917: ST_TO_ADDR
40918: LD_EXP 78
40922: PUSH
40923: FOR_TO
40924: IFFALSE 41708
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40926: LD_EXP 106
40930: PUSH
40931: LD_VAR 0 2
40935: ARRAY
40936: NOT
40937: PUSH
40938: LD_EXP 81
40942: PUSH
40943: LD_VAR 0 2
40947: ARRAY
40948: PUSH
40949: LD_INT 1
40951: ARRAY
40952: OR
40953: PUSH
40954: LD_EXP 81
40958: PUSH
40959: LD_VAR 0 2
40963: ARRAY
40964: PUSH
40965: LD_INT 2
40967: ARRAY
40968: OR
40969: PUSH
40970: LD_EXP 104
40974: PUSH
40975: LD_VAR 0 2
40979: ARRAY
40980: PPUSH
40981: LD_INT 1
40983: PPUSH
40984: CALL_OW 325
40988: NOT
40989: OR
40990: PUSH
40991: LD_EXP 101
40995: PUSH
40996: LD_VAR 0 2
41000: ARRAY
41001: OR
41002: IFFALSE 41006
// continue ;
41004: GO 40923
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41006: LD_ADDR_VAR 0 8
41010: PUSH
41011: LD_EXP 78
41015: PUSH
41016: LD_VAR 0 2
41020: ARRAY
41021: PPUSH
41022: LD_INT 25
41024: PUSH
41025: LD_INT 4
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: LD_INT 50
41034: PUSH
41035: EMPTY
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: PUSH
41041: LD_INT 60
41043: PUSH
41044: EMPTY
41045: LIST
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: LIST
41055: PPUSH
41056: CALL_OW 72
41060: PUSH
41061: LD_EXP 82
41065: PUSH
41066: LD_VAR 0 2
41070: ARRAY
41071: DIFF
41072: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41073: LD_ADDR_VAR 0 9
41077: PUSH
41078: LD_EXP 78
41082: PUSH
41083: LD_VAR 0 2
41087: ARRAY
41088: PPUSH
41089: LD_INT 2
41091: PUSH
41092: LD_INT 30
41094: PUSH
41095: LD_INT 0
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 30
41104: PUSH
41105: LD_INT 1
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: LIST
41116: PPUSH
41117: CALL_OW 72
41121: ST_TO_ADDR
// if not tmp or not dep then
41122: LD_VAR 0 8
41126: NOT
41127: PUSH
41128: LD_VAR 0 9
41132: NOT
41133: OR
41134: IFFALSE 41138
// continue ;
41136: GO 40923
// side := GetSide ( tmp [ 1 ] ) ;
41138: LD_ADDR_VAR 0 11
41142: PUSH
41143: LD_VAR 0 8
41147: PUSH
41148: LD_INT 1
41150: ARRAY
41151: PPUSH
41152: CALL_OW 255
41156: ST_TO_ADDR
// dep := dep [ 1 ] ;
41157: LD_ADDR_VAR 0 9
41161: PUSH
41162: LD_VAR 0 9
41166: PUSH
41167: LD_INT 1
41169: ARRAY
41170: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41171: LD_ADDR_VAR 0 7
41175: PUSH
41176: LD_EXP 106
41180: PUSH
41181: LD_VAR 0 2
41185: ARRAY
41186: PPUSH
41187: LD_INT 22
41189: PUSH
41190: LD_INT 0
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 25
41199: PUSH
41200: LD_INT 12
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PPUSH
41211: CALL_OW 70
41215: PUSH
41216: LD_INT 22
41218: PUSH
41219: LD_INT 0
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 25
41228: PUSH
41229: LD_INT 12
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 91
41238: PUSH
41239: LD_VAR 0 9
41243: PUSH
41244: LD_INT 20
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: LIST
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: LIST
41256: PPUSH
41257: CALL_OW 69
41261: UNION
41262: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41263: LD_ADDR_VAR 0 10
41267: PUSH
41268: LD_EXP 106
41272: PUSH
41273: LD_VAR 0 2
41277: ARRAY
41278: PPUSH
41279: LD_INT 81
41281: PUSH
41282: LD_VAR 0 11
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PPUSH
41291: CALL_OW 70
41295: ST_TO_ADDR
// if not apes or danger_at_area then
41296: LD_VAR 0 7
41300: NOT
41301: PUSH
41302: LD_VAR 0 10
41306: OR
41307: IFFALSE 41357
// begin if mc_taming [ i ] then
41309: LD_EXP 109
41313: PUSH
41314: LD_VAR 0 2
41318: ARRAY
41319: IFFALSE 41355
// begin MC_Reset ( i , 121 ) ;
41321: LD_VAR 0 2
41325: PPUSH
41326: LD_INT 121
41328: PPUSH
41329: CALL 26287 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41333: LD_ADDR_EXP 109
41337: PUSH
41338: LD_EXP 109
41342: PPUSH
41343: LD_VAR 0 2
41347: PPUSH
41348: EMPTY
41349: PPUSH
41350: CALL_OW 1
41354: ST_TO_ADDR
// end ; continue ;
41355: GO 40923
// end ; for j in tmp do
41357: LD_ADDR_VAR 0 3
41361: PUSH
41362: LD_VAR 0 8
41366: PUSH
41367: FOR_IN
41368: IFFALSE 41704
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41370: LD_VAR 0 3
41374: PUSH
41375: LD_EXP 109
41379: PUSH
41380: LD_VAR 0 2
41384: ARRAY
41385: IN
41386: NOT
41387: PUSH
41388: LD_EXP 109
41392: PUSH
41393: LD_VAR 0 2
41397: ARRAY
41398: PUSH
41399: LD_INT 3
41401: LESS
41402: AND
41403: IFFALSE 41461
// begin SetTag ( j , 121 ) ;
41405: LD_VAR 0 3
41409: PPUSH
41410: LD_INT 121
41412: PPUSH
41413: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41417: LD_ADDR_EXP 109
41421: PUSH
41422: LD_EXP 109
41426: PPUSH
41427: LD_VAR 0 2
41431: PUSH
41432: LD_EXP 109
41436: PUSH
41437: LD_VAR 0 2
41441: ARRAY
41442: PUSH
41443: LD_INT 1
41445: PLUS
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PPUSH
41451: LD_VAR 0 3
41455: PPUSH
41456: CALL 57774 0 3
41460: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41461: LD_VAR 0 3
41465: PUSH
41466: LD_EXP 109
41470: PUSH
41471: LD_VAR 0 2
41475: ARRAY
41476: IN
41477: IFFALSE 41702
// begin if GetClass ( j ) <> 4 then
41479: LD_VAR 0 3
41483: PPUSH
41484: CALL_OW 257
41488: PUSH
41489: LD_INT 4
41491: NONEQUAL
41492: IFFALSE 41545
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41494: LD_ADDR_EXP 109
41498: PUSH
41499: LD_EXP 109
41503: PPUSH
41504: LD_VAR 0 2
41508: PPUSH
41509: LD_EXP 109
41513: PUSH
41514: LD_VAR 0 2
41518: ARRAY
41519: PUSH
41520: LD_VAR 0 3
41524: DIFF
41525: PPUSH
41526: CALL_OW 1
41530: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41531: LD_VAR 0 3
41535: PPUSH
41536: LD_INT 0
41538: PPUSH
41539: CALL_OW 109
// continue ;
41543: GO 41367
// end ; if IsInUnit ( j ) then
41545: LD_VAR 0 3
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41565
// ComExitBuilding ( j ) ;
41556: LD_VAR 0 3
41560: PPUSH
41561: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
41565: LD_ADDR_VAR 0 6
41569: PUSH
41570: LD_VAR 0 7
41574: PPUSH
41575: LD_VAR 0 3
41579: PPUSH
41580: CALL_OW 74
41584: ST_TO_ADDR
// if not ape then
41585: LD_VAR 0 6
41589: NOT
41590: IFFALSE 41594
// break ;
41592: GO 41704
// x := GetX ( ape ) ;
41594: LD_ADDR_VAR 0 4
41598: PUSH
41599: LD_VAR 0 6
41603: PPUSH
41604: CALL_OW 250
41608: ST_TO_ADDR
// y := GetY ( ape ) ;
41609: LD_ADDR_VAR 0 5
41613: PUSH
41614: LD_VAR 0 6
41618: PPUSH
41619: CALL_OW 251
41623: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41624: LD_VAR 0 4
41628: PPUSH
41629: LD_VAR 0 5
41633: PPUSH
41634: CALL_OW 488
41638: NOT
41639: PUSH
41640: LD_VAR 0 11
41644: PPUSH
41645: LD_VAR 0 4
41649: PPUSH
41650: LD_VAR 0 5
41654: PPUSH
41655: LD_INT 20
41657: PPUSH
41658: CALL 58670 0 4
41662: PUSH
41663: LD_INT 4
41665: ARRAY
41666: OR
41667: IFFALSE 41671
// break ;
41669: GO 41704
// if not HasTask ( j ) then
41671: LD_VAR 0 3
41675: PPUSH
41676: CALL_OW 314
41680: NOT
41681: IFFALSE 41702
// ComTameXY ( j , x , y ) ;
41683: LD_VAR 0 3
41687: PPUSH
41688: LD_VAR 0 4
41692: PPUSH
41693: LD_VAR 0 5
41697: PPUSH
41698: CALL_OW 131
// end ; end ;
41702: GO 41367
41704: POP
41705: POP
// end ;
41706: GO 40923
41708: POP
41709: POP
// end ;
41710: LD_VAR 0 1
41714: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41715: LD_INT 0
41717: PPUSH
41718: PPUSH
41719: PPUSH
41720: PPUSH
41721: PPUSH
41722: PPUSH
41723: PPUSH
41724: PPUSH
// if not mc_bases then
41725: LD_EXP 78
41729: NOT
41730: IFFALSE 41734
// exit ;
41732: GO 42360
// for i = 1 to mc_bases do
41734: LD_ADDR_VAR 0 2
41738: PUSH
41739: DOUBLE
41740: LD_INT 1
41742: DEC
41743: ST_TO_ADDR
41744: LD_EXP 78
41748: PUSH
41749: FOR_TO
41750: IFFALSE 42358
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41752: LD_EXP 107
41756: PUSH
41757: LD_VAR 0 2
41761: ARRAY
41762: NOT
41763: PUSH
41764: LD_EXP 107
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PPUSH
41775: LD_INT 25
41777: PUSH
41778: LD_INT 12
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PPUSH
41785: CALL_OW 72
41789: NOT
41790: OR
41791: IFFALSE 41795
// continue ;
41793: GO 41749
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41795: LD_ADDR_VAR 0 5
41799: PUSH
41800: LD_EXP 107
41804: PUSH
41805: LD_VAR 0 2
41809: ARRAY
41810: PUSH
41811: LD_INT 1
41813: ARRAY
41814: PPUSH
41815: CALL_OW 255
41819: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41820: LD_VAR 0 5
41824: PPUSH
41825: LD_INT 2
41827: PPUSH
41828: CALL_OW 325
41832: IFFALSE 42085
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41834: LD_ADDR_VAR 0 4
41838: PUSH
41839: LD_EXP 107
41843: PUSH
41844: LD_VAR 0 2
41848: ARRAY
41849: PPUSH
41850: LD_INT 25
41852: PUSH
41853: LD_INT 16
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PPUSH
41860: CALL_OW 72
41864: ST_TO_ADDR
// if tmp < 6 then
41865: LD_VAR 0 4
41869: PUSH
41870: LD_INT 6
41872: LESS
41873: IFFALSE 42085
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41875: LD_ADDR_VAR 0 6
41879: PUSH
41880: LD_EXP 78
41884: PUSH
41885: LD_VAR 0 2
41889: ARRAY
41890: PPUSH
41891: LD_INT 2
41893: PUSH
41894: LD_INT 30
41896: PUSH
41897: LD_INT 0
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 30
41906: PUSH
41907: LD_INT 1
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: LIST
41918: PPUSH
41919: CALL_OW 72
41923: ST_TO_ADDR
// if depot then
41924: LD_VAR 0 6
41928: IFFALSE 42085
// begin selected := 0 ;
41930: LD_ADDR_VAR 0 7
41934: PUSH
41935: LD_INT 0
41937: ST_TO_ADDR
// for j in depot do
41938: LD_ADDR_VAR 0 3
41942: PUSH
41943: LD_VAR 0 6
41947: PUSH
41948: FOR_IN
41949: IFFALSE 41980
// begin if UnitsInside ( j ) < 6 then
41951: LD_VAR 0 3
41955: PPUSH
41956: CALL_OW 313
41960: PUSH
41961: LD_INT 6
41963: LESS
41964: IFFALSE 41978
// begin selected := j ;
41966: LD_ADDR_VAR 0 7
41970: PUSH
41971: LD_VAR 0 3
41975: ST_TO_ADDR
// break ;
41976: GO 41980
// end ; end ;
41978: GO 41948
41980: POP
41981: POP
// if selected then
41982: LD_VAR 0 7
41986: IFFALSE 42085
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41988: LD_ADDR_VAR 0 3
41992: PUSH
41993: LD_EXP 107
41997: PUSH
41998: LD_VAR 0 2
42002: ARRAY
42003: PPUSH
42004: LD_INT 25
42006: PUSH
42007: LD_INT 12
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PPUSH
42014: CALL_OW 72
42018: PUSH
42019: FOR_IN
42020: IFFALSE 42083
// if not HasTask ( j ) then
42022: LD_VAR 0 3
42026: PPUSH
42027: CALL_OW 314
42031: NOT
42032: IFFALSE 42081
// begin if not IsInUnit ( j ) then
42034: LD_VAR 0 3
42038: PPUSH
42039: CALL_OW 310
42043: NOT
42044: IFFALSE 42060
// ComEnterUnit ( j , selected ) ;
42046: LD_VAR 0 3
42050: PPUSH
42051: LD_VAR 0 7
42055: PPUSH
42056: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42060: LD_VAR 0 3
42064: PPUSH
42065: LD_INT 16
42067: PPUSH
42068: CALL_OW 183
// AddComExitBuilding ( j ) ;
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 182
// end ;
42081: GO 42019
42083: POP
42084: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42085: LD_VAR 0 5
42089: PPUSH
42090: LD_INT 11
42092: PPUSH
42093: CALL_OW 325
42097: IFFALSE 42356
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42099: LD_ADDR_VAR 0 4
42103: PUSH
42104: LD_EXP 107
42108: PUSH
42109: LD_VAR 0 2
42113: ARRAY
42114: PPUSH
42115: LD_INT 25
42117: PUSH
42118: LD_INT 16
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PPUSH
42125: CALL_OW 72
42129: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42130: LD_VAR 0 4
42134: PUSH
42135: LD_INT 6
42137: GREATEREQUAL
42138: PUSH
42139: LD_VAR 0 5
42143: PPUSH
42144: LD_INT 2
42146: PPUSH
42147: CALL_OW 325
42151: NOT
42152: OR
42153: IFFALSE 42356
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42155: LD_ADDR_VAR 0 8
42159: PUSH
42160: LD_EXP 78
42164: PUSH
42165: LD_VAR 0 2
42169: ARRAY
42170: PPUSH
42171: LD_INT 2
42173: PUSH
42174: LD_INT 30
42176: PUSH
42177: LD_INT 4
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: PUSH
42184: LD_INT 30
42186: PUSH
42187: LD_INT 5
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: LIST
42198: PPUSH
42199: CALL_OW 72
42203: ST_TO_ADDR
// if barracks then
42204: LD_VAR 0 8
42208: IFFALSE 42356
// begin selected := 0 ;
42210: LD_ADDR_VAR 0 7
42214: PUSH
42215: LD_INT 0
42217: ST_TO_ADDR
// for j in barracks do
42218: LD_ADDR_VAR 0 3
42222: PUSH
42223: LD_VAR 0 8
42227: PUSH
42228: FOR_IN
42229: IFFALSE 42260
// begin if UnitsInside ( j ) < 6 then
42231: LD_VAR 0 3
42235: PPUSH
42236: CALL_OW 313
42240: PUSH
42241: LD_INT 6
42243: LESS
42244: IFFALSE 42258
// begin selected := j ;
42246: LD_ADDR_VAR 0 7
42250: PUSH
42251: LD_VAR 0 3
42255: ST_TO_ADDR
// break ;
42256: GO 42260
// end ; end ;
42258: GO 42228
42260: POP
42261: POP
// if selected then
42262: LD_VAR 0 7
42266: IFFALSE 42356
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42268: LD_ADDR_VAR 0 3
42272: PUSH
42273: LD_EXP 107
42277: PUSH
42278: LD_VAR 0 2
42282: ARRAY
42283: PPUSH
42284: LD_INT 25
42286: PUSH
42287: LD_INT 12
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PPUSH
42294: CALL_OW 72
42298: PUSH
42299: FOR_IN
42300: IFFALSE 42354
// if not IsInUnit ( j ) and not HasTask ( j ) then
42302: LD_VAR 0 3
42306: PPUSH
42307: CALL_OW 310
42311: NOT
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: CALL_OW 314
42322: NOT
42323: AND
42324: IFFALSE 42352
// begin ComEnterUnit ( j , selected ) ;
42326: LD_VAR 0 3
42330: PPUSH
42331: LD_VAR 0 7
42335: PPUSH
42336: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42340: LD_VAR 0 3
42344: PPUSH
42345: LD_INT 15
42347: PPUSH
42348: CALL_OW 183
// end ;
42352: GO 42299
42354: POP
42355: POP
// end ; end ; end ; end ; end ;
42356: GO 41749
42358: POP
42359: POP
// end ;
42360: LD_VAR 0 1
42364: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42365: LD_INT 0
42367: PPUSH
42368: PPUSH
42369: PPUSH
42370: PPUSH
// if not mc_bases then
42371: LD_EXP 78
42375: NOT
42376: IFFALSE 42380
// exit ;
42378: GO 42558
// for i = 1 to mc_bases do
42380: LD_ADDR_VAR 0 2
42384: PUSH
42385: DOUBLE
42386: LD_INT 1
42388: DEC
42389: ST_TO_ADDR
42390: LD_EXP 78
42394: PUSH
42395: FOR_TO
42396: IFFALSE 42556
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42398: LD_ADDR_VAR 0 4
42402: PUSH
42403: LD_EXP 78
42407: PUSH
42408: LD_VAR 0 2
42412: ARRAY
42413: PPUSH
42414: LD_INT 25
42416: PUSH
42417: LD_INT 9
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PPUSH
42424: CALL_OW 72
42428: ST_TO_ADDR
// if not tmp then
42429: LD_VAR 0 4
42433: NOT
42434: IFFALSE 42438
// continue ;
42436: GO 42395
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42438: LD_EXP 104
42442: PUSH
42443: LD_VAR 0 2
42447: ARRAY
42448: PPUSH
42449: LD_INT 29
42451: PPUSH
42452: CALL_OW 325
42456: NOT
42457: PUSH
42458: LD_EXP 104
42462: PUSH
42463: LD_VAR 0 2
42467: ARRAY
42468: PPUSH
42469: LD_INT 28
42471: PPUSH
42472: CALL_OW 325
42476: NOT
42477: AND
42478: IFFALSE 42482
// continue ;
42480: GO 42395
// for j in tmp do
42482: LD_ADDR_VAR 0 3
42486: PUSH
42487: LD_VAR 0 4
42491: PUSH
42492: FOR_IN
42493: IFFALSE 42552
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42495: LD_VAR 0 3
42499: PUSH
42500: LD_EXP 81
42504: PUSH
42505: LD_VAR 0 2
42509: ARRAY
42510: PUSH
42511: LD_INT 1
42513: ARRAY
42514: IN
42515: NOT
42516: PUSH
42517: LD_VAR 0 3
42521: PUSH
42522: LD_EXP 81
42526: PUSH
42527: LD_VAR 0 2
42531: ARRAY
42532: PUSH
42533: LD_INT 2
42535: ARRAY
42536: IN
42537: NOT
42538: AND
42539: IFFALSE 42550
// ComSpaceTimeShoot ( j ) ;
42541: LD_VAR 0 3
42545: PPUSH
42546: CALL 53759 0 1
42550: GO 42492
42552: POP
42553: POP
// end ;
42554: GO 42395
42556: POP
42557: POP
// end ;
42558: LD_VAR 0 1
42562: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
42563: LD_INT 0
42565: PPUSH
42566: PPUSH
42567: PPUSH
42568: PPUSH
42569: PPUSH
42570: PPUSH
42571: PPUSH
42572: PPUSH
42573: PPUSH
// if not mc_bases then
42574: LD_EXP 78
42578: NOT
42579: IFFALSE 42583
// exit ;
42581: GO 43205
// for i = 1 to mc_bases do
42583: LD_ADDR_VAR 0 2
42587: PUSH
42588: DOUBLE
42589: LD_INT 1
42591: DEC
42592: ST_TO_ADDR
42593: LD_EXP 78
42597: PUSH
42598: FOR_TO
42599: IFFALSE 43203
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42601: LD_EXP 113
42605: PUSH
42606: LD_VAR 0 2
42610: ARRAY
42611: NOT
42612: PUSH
42613: LD_INT 38
42615: PPUSH
42616: LD_EXP 104
42620: PUSH
42621: LD_VAR 0 2
42625: ARRAY
42626: PPUSH
42627: CALL_OW 321
42631: PUSH
42632: LD_INT 2
42634: NONEQUAL
42635: OR
42636: IFFALSE 42640
// continue ;
42638: GO 42598
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42640: LD_ADDR_VAR 0 8
42644: PUSH
42645: LD_EXP 78
42649: PUSH
42650: LD_VAR 0 2
42654: ARRAY
42655: PPUSH
42656: LD_INT 30
42658: PUSH
42659: LD_INT 34
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PPUSH
42666: CALL_OW 72
42670: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42671: LD_ADDR_VAR 0 9
42675: PUSH
42676: LD_EXP 78
42680: PUSH
42681: LD_VAR 0 2
42685: ARRAY
42686: PPUSH
42687: LD_INT 25
42689: PUSH
42690: LD_INT 4
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PPUSH
42697: CALL_OW 72
42701: PPUSH
42702: LD_INT 0
42704: PPUSH
42705: CALL 87686 0 2
42709: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42710: LD_VAR 0 9
42714: NOT
42715: PUSH
42716: LD_VAR 0 8
42720: NOT
42721: OR
42722: PUSH
42723: LD_EXP 78
42727: PUSH
42728: LD_VAR 0 2
42732: ARRAY
42733: PPUSH
42734: LD_INT 124
42736: PPUSH
42737: CALL 87686 0 2
42741: OR
42742: IFFALSE 42746
// continue ;
42744: GO 42598
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42746: LD_EXP 114
42750: PUSH
42751: LD_VAR 0 2
42755: ARRAY
42756: PUSH
42757: LD_EXP 113
42761: PUSH
42762: LD_VAR 0 2
42766: ARRAY
42767: LESS
42768: PUSH
42769: LD_EXP 114
42773: PUSH
42774: LD_VAR 0 2
42778: ARRAY
42779: PUSH
42780: LD_VAR 0 8
42784: LESS
42785: AND
42786: IFFALSE 43201
// begin tmp := sci [ 1 ] ;
42788: LD_ADDR_VAR 0 7
42792: PUSH
42793: LD_VAR 0 9
42797: PUSH
42798: LD_INT 1
42800: ARRAY
42801: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42802: LD_VAR 0 7
42806: PPUSH
42807: LD_INT 124
42809: PPUSH
42810: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42814: LD_ADDR_VAR 0 3
42818: PUSH
42819: DOUBLE
42820: LD_EXP 113
42824: PUSH
42825: LD_VAR 0 2
42829: ARRAY
42830: INC
42831: ST_TO_ADDR
42832: LD_EXP 113
42836: PUSH
42837: LD_VAR 0 2
42841: ARRAY
42842: PUSH
42843: FOR_DOWNTO
42844: IFFALSE 43187
// begin if IsInUnit ( tmp ) then
42846: LD_VAR 0 7
42850: PPUSH
42851: CALL_OW 310
42855: IFFALSE 42866
// ComExitBuilding ( tmp ) ;
42857: LD_VAR 0 7
42861: PPUSH
42862: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42866: LD_INT 35
42868: PPUSH
42869: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42873: LD_VAR 0 7
42877: PPUSH
42878: CALL_OW 310
42882: NOT
42883: PUSH
42884: LD_VAR 0 7
42888: PPUSH
42889: CALL_OW 314
42893: NOT
42894: AND
42895: IFFALSE 42866
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42897: LD_ADDR_VAR 0 6
42901: PUSH
42902: LD_VAR 0 7
42906: PPUSH
42907: CALL_OW 250
42911: PUSH
42912: LD_VAR 0 7
42916: PPUSH
42917: CALL_OW 251
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42926: LD_INT 35
42928: PPUSH
42929: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42933: LD_ADDR_VAR 0 4
42937: PUSH
42938: LD_EXP 113
42942: PUSH
42943: LD_VAR 0 2
42947: ARRAY
42948: PUSH
42949: LD_VAR 0 3
42953: ARRAY
42954: PUSH
42955: LD_INT 1
42957: ARRAY
42958: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42959: LD_ADDR_VAR 0 5
42963: PUSH
42964: LD_EXP 113
42968: PUSH
42969: LD_VAR 0 2
42973: ARRAY
42974: PUSH
42975: LD_VAR 0 3
42979: ARRAY
42980: PUSH
42981: LD_INT 2
42983: ARRAY
42984: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42985: LD_VAR 0 7
42989: PPUSH
42990: LD_INT 10
42992: PPUSH
42993: CALL 60371 0 2
42997: PUSH
42998: LD_INT 4
43000: ARRAY
43001: IFFALSE 43039
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43003: LD_VAR 0 7
43007: PPUSH
43008: LD_VAR 0 6
43012: PUSH
43013: LD_INT 1
43015: ARRAY
43016: PPUSH
43017: LD_VAR 0 6
43021: PUSH
43022: LD_INT 2
43024: ARRAY
43025: PPUSH
43026: CALL_OW 111
// wait ( 0 0$10 ) ;
43030: LD_INT 350
43032: PPUSH
43033: CALL_OW 67
// end else
43037: GO 43065
// begin ComMoveXY ( tmp , x , y ) ;
43039: LD_VAR 0 7
43043: PPUSH
43044: LD_VAR 0 4
43048: PPUSH
43049: LD_VAR 0 5
43053: PPUSH
43054: CALL_OW 111
// wait ( 0 0$3 ) ;
43058: LD_INT 105
43060: PPUSH
43061: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43065: LD_VAR 0 7
43069: PPUSH
43070: LD_VAR 0 4
43074: PPUSH
43075: LD_VAR 0 5
43079: PPUSH
43080: CALL_OW 307
43084: IFFALSE 42926
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43086: LD_VAR 0 7
43090: PPUSH
43091: LD_VAR 0 4
43095: PPUSH
43096: LD_VAR 0 5
43100: PPUSH
43101: LD_VAR 0 8
43105: PUSH
43106: LD_VAR 0 3
43110: ARRAY
43111: PPUSH
43112: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43116: LD_INT 35
43118: PPUSH
43119: CALL_OW 67
// until not HasTask ( tmp ) ;
43123: LD_VAR 0 7
43127: PPUSH
43128: CALL_OW 314
43132: NOT
43133: IFFALSE 43116
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43135: LD_ADDR_EXP 114
43139: PUSH
43140: LD_EXP 114
43144: PPUSH
43145: LD_VAR 0 2
43149: PUSH
43150: LD_EXP 114
43154: PUSH
43155: LD_VAR 0 2
43159: ARRAY
43160: PUSH
43161: LD_INT 1
43163: PLUS
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PPUSH
43169: LD_VAR 0 8
43173: PUSH
43174: LD_VAR 0 3
43178: ARRAY
43179: PPUSH
43180: CALL 57774 0 3
43184: ST_TO_ADDR
// end ;
43185: GO 42843
43187: POP
43188: POP
// MC_Reset ( i , 124 ) ;
43189: LD_VAR 0 2
43193: PPUSH
43194: LD_INT 124
43196: PPUSH
43197: CALL 26287 0 2
// end ; end ;
43201: GO 42598
43203: POP
43204: POP
// end ;
43205: LD_VAR 0 1
43209: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43210: LD_INT 0
43212: PPUSH
43213: PPUSH
43214: PPUSH
// if not mc_bases then
43215: LD_EXP 78
43219: NOT
43220: IFFALSE 43224
// exit ;
43222: GO 43830
// for i = 1 to mc_bases do
43224: LD_ADDR_VAR 0 2
43228: PUSH
43229: DOUBLE
43230: LD_INT 1
43232: DEC
43233: ST_TO_ADDR
43234: LD_EXP 78
43238: PUSH
43239: FOR_TO
43240: IFFALSE 43828
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43242: LD_ADDR_VAR 0 3
43246: PUSH
43247: LD_EXP 78
43251: PUSH
43252: LD_VAR 0 2
43256: ARRAY
43257: PPUSH
43258: LD_INT 25
43260: PUSH
43261: LD_INT 4
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PPUSH
43268: CALL_OW 72
43272: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43273: LD_VAR 0 3
43277: NOT
43278: PUSH
43279: LD_EXP 115
43283: PUSH
43284: LD_VAR 0 2
43288: ARRAY
43289: NOT
43290: OR
43291: PUSH
43292: LD_EXP 78
43296: PUSH
43297: LD_VAR 0 2
43301: ARRAY
43302: PPUSH
43303: LD_INT 2
43305: PUSH
43306: LD_INT 30
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: EMPTY
43313: LIST
43314: LIST
43315: PUSH
43316: LD_INT 30
43318: PUSH
43319: LD_INT 1
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: LIST
43330: PPUSH
43331: CALL_OW 72
43335: NOT
43336: OR
43337: IFFALSE 43387
// begin if mc_deposits_finder [ i ] then
43339: LD_EXP 116
43343: PUSH
43344: LD_VAR 0 2
43348: ARRAY
43349: IFFALSE 43385
// begin MC_Reset ( i , 125 ) ;
43351: LD_VAR 0 2
43355: PPUSH
43356: LD_INT 125
43358: PPUSH
43359: CALL 26287 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43363: LD_ADDR_EXP 116
43367: PUSH
43368: LD_EXP 116
43372: PPUSH
43373: LD_VAR 0 2
43377: PPUSH
43378: EMPTY
43379: PPUSH
43380: CALL_OW 1
43384: ST_TO_ADDR
// end ; continue ;
43385: GO 43239
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43387: LD_EXP 115
43391: PUSH
43392: LD_VAR 0 2
43396: ARRAY
43397: PUSH
43398: LD_INT 1
43400: ARRAY
43401: PUSH
43402: LD_INT 3
43404: ARRAY
43405: PUSH
43406: LD_INT 1
43408: EQUAL
43409: PUSH
43410: LD_INT 20
43412: PPUSH
43413: LD_EXP 104
43417: PUSH
43418: LD_VAR 0 2
43422: ARRAY
43423: PPUSH
43424: CALL_OW 321
43428: PUSH
43429: LD_INT 2
43431: NONEQUAL
43432: AND
43433: IFFALSE 43483
// begin if mc_deposits_finder [ i ] then
43435: LD_EXP 116
43439: PUSH
43440: LD_VAR 0 2
43444: ARRAY
43445: IFFALSE 43481
// begin MC_Reset ( i , 125 ) ;
43447: LD_VAR 0 2
43451: PPUSH
43452: LD_INT 125
43454: PPUSH
43455: CALL 26287 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43459: LD_ADDR_EXP 116
43463: PUSH
43464: LD_EXP 116
43468: PPUSH
43469: LD_VAR 0 2
43473: PPUSH
43474: EMPTY
43475: PPUSH
43476: CALL_OW 1
43480: ST_TO_ADDR
// end ; continue ;
43481: GO 43239
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43483: LD_EXP 115
43487: PUSH
43488: LD_VAR 0 2
43492: ARRAY
43493: PUSH
43494: LD_INT 1
43496: ARRAY
43497: PUSH
43498: LD_INT 1
43500: ARRAY
43501: PPUSH
43502: LD_EXP 115
43506: PUSH
43507: LD_VAR 0 2
43511: ARRAY
43512: PUSH
43513: LD_INT 1
43515: ARRAY
43516: PUSH
43517: LD_INT 2
43519: ARRAY
43520: PPUSH
43521: LD_EXP 104
43525: PUSH
43526: LD_VAR 0 2
43530: ARRAY
43531: PPUSH
43532: CALL_OW 440
43536: IFFALSE 43579
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43538: LD_ADDR_EXP 115
43542: PUSH
43543: LD_EXP 115
43547: PPUSH
43548: LD_VAR 0 2
43552: PPUSH
43553: LD_EXP 115
43557: PUSH
43558: LD_VAR 0 2
43562: ARRAY
43563: PPUSH
43564: LD_INT 1
43566: PPUSH
43567: CALL_OW 3
43571: PPUSH
43572: CALL_OW 1
43576: ST_TO_ADDR
43577: GO 43826
// begin if not mc_deposits_finder [ i ] then
43579: LD_EXP 116
43583: PUSH
43584: LD_VAR 0 2
43588: ARRAY
43589: NOT
43590: IFFALSE 43642
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
43592: LD_ADDR_EXP 116
43596: PUSH
43597: LD_EXP 116
43601: PPUSH
43602: LD_VAR 0 2
43606: PPUSH
43607: LD_VAR 0 3
43611: PUSH
43612: LD_INT 1
43614: ARRAY
43615: PUSH
43616: EMPTY
43617: LIST
43618: PPUSH
43619: CALL_OW 1
43623: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43624: LD_VAR 0 3
43628: PUSH
43629: LD_INT 1
43631: ARRAY
43632: PPUSH
43633: LD_INT 125
43635: PPUSH
43636: CALL_OW 109
// end else
43640: GO 43826
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43642: LD_EXP 116
43646: PUSH
43647: LD_VAR 0 2
43651: ARRAY
43652: PUSH
43653: LD_INT 1
43655: ARRAY
43656: PPUSH
43657: CALL_OW 310
43661: IFFALSE 43684
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43663: LD_EXP 116
43667: PUSH
43668: LD_VAR 0 2
43672: ARRAY
43673: PUSH
43674: LD_INT 1
43676: ARRAY
43677: PPUSH
43678: CALL_OW 122
43682: GO 43826
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43684: LD_EXP 116
43688: PUSH
43689: LD_VAR 0 2
43693: ARRAY
43694: PUSH
43695: LD_INT 1
43697: ARRAY
43698: PPUSH
43699: CALL_OW 314
43703: NOT
43704: PUSH
43705: LD_EXP 116
43709: PUSH
43710: LD_VAR 0 2
43714: ARRAY
43715: PUSH
43716: LD_INT 1
43718: ARRAY
43719: PPUSH
43720: LD_EXP 115
43724: PUSH
43725: LD_VAR 0 2
43729: ARRAY
43730: PUSH
43731: LD_INT 1
43733: ARRAY
43734: PUSH
43735: LD_INT 1
43737: ARRAY
43738: PPUSH
43739: LD_EXP 115
43743: PUSH
43744: LD_VAR 0 2
43748: ARRAY
43749: PUSH
43750: LD_INT 1
43752: ARRAY
43753: PUSH
43754: LD_INT 2
43756: ARRAY
43757: PPUSH
43758: CALL_OW 297
43762: PUSH
43763: LD_INT 6
43765: GREATER
43766: AND
43767: IFFALSE 43826
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43769: LD_EXP 116
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: PUSH
43780: LD_INT 1
43782: ARRAY
43783: PPUSH
43784: LD_EXP 115
43788: PUSH
43789: LD_VAR 0 2
43793: ARRAY
43794: PUSH
43795: LD_INT 1
43797: ARRAY
43798: PUSH
43799: LD_INT 1
43801: ARRAY
43802: PPUSH
43803: LD_EXP 115
43807: PUSH
43808: LD_VAR 0 2
43812: ARRAY
43813: PUSH
43814: LD_INT 1
43816: ARRAY
43817: PUSH
43818: LD_INT 2
43820: ARRAY
43821: PPUSH
43822: CALL_OW 111
// end ; end ; end ;
43826: GO 43239
43828: POP
43829: POP
// end ;
43830: LD_VAR 0 1
43834: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43835: LD_INT 0
43837: PPUSH
43838: PPUSH
43839: PPUSH
43840: PPUSH
43841: PPUSH
43842: PPUSH
43843: PPUSH
43844: PPUSH
43845: PPUSH
43846: PPUSH
43847: PPUSH
// if not mc_bases then
43848: LD_EXP 78
43852: NOT
43853: IFFALSE 43857
// exit ;
43855: GO 44797
// for i = 1 to mc_bases do
43857: LD_ADDR_VAR 0 2
43861: PUSH
43862: DOUBLE
43863: LD_INT 1
43865: DEC
43866: ST_TO_ADDR
43867: LD_EXP 78
43871: PUSH
43872: FOR_TO
43873: IFFALSE 44795
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43875: LD_EXP 78
43879: PUSH
43880: LD_VAR 0 2
43884: ARRAY
43885: NOT
43886: PUSH
43887: LD_EXP 101
43891: PUSH
43892: LD_VAR 0 2
43896: ARRAY
43897: OR
43898: IFFALSE 43902
// continue ;
43900: GO 43872
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43902: LD_ADDR_VAR 0 7
43906: PUSH
43907: LD_EXP 78
43911: PUSH
43912: LD_VAR 0 2
43916: ARRAY
43917: PUSH
43918: LD_INT 1
43920: ARRAY
43921: PPUSH
43922: CALL_OW 248
43926: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43927: LD_VAR 0 7
43931: PUSH
43932: LD_INT 3
43934: EQUAL
43935: PUSH
43936: LD_EXP 97
43940: PUSH
43941: LD_VAR 0 2
43945: ARRAY
43946: PUSH
43947: LD_EXP 100
43951: PUSH
43952: LD_VAR 0 2
43956: ARRAY
43957: UNION
43958: PPUSH
43959: LD_INT 33
43961: PUSH
43962: LD_INT 2
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PPUSH
43969: CALL_OW 72
43973: NOT
43974: OR
43975: IFFALSE 43979
// continue ;
43977: GO 43872
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43979: LD_ADDR_VAR 0 9
43983: PUSH
43984: LD_EXP 78
43988: PUSH
43989: LD_VAR 0 2
43993: ARRAY
43994: PPUSH
43995: LD_INT 30
43997: PUSH
43998: LD_INT 36
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PPUSH
44005: CALL_OW 72
44009: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44010: LD_ADDR_VAR 0 10
44014: PUSH
44015: LD_EXP 97
44019: PUSH
44020: LD_VAR 0 2
44024: ARRAY
44025: PPUSH
44026: LD_INT 34
44028: PUSH
44029: LD_INT 31
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PPUSH
44036: CALL_OW 72
44040: ST_TO_ADDR
// if not cts and not mcts then
44041: LD_VAR 0 9
44045: NOT
44046: PUSH
44047: LD_VAR 0 10
44051: NOT
44052: AND
44053: IFFALSE 44057
// continue ;
44055: GO 43872
// x := cts ;
44057: LD_ADDR_VAR 0 11
44061: PUSH
44062: LD_VAR 0 9
44066: ST_TO_ADDR
// if not x then
44067: LD_VAR 0 11
44071: NOT
44072: IFFALSE 44084
// x := mcts ;
44074: LD_ADDR_VAR 0 11
44078: PUSH
44079: LD_VAR 0 10
44083: ST_TO_ADDR
// if not x then
44084: LD_VAR 0 11
44088: NOT
44089: IFFALSE 44093
// continue ;
44091: GO 43872
// if mc_remote_driver [ i ] then
44093: LD_EXP 118
44097: PUSH
44098: LD_VAR 0 2
44102: ARRAY
44103: IFFALSE 44490
// for j in mc_remote_driver [ i ] do
44105: LD_ADDR_VAR 0 3
44109: PUSH
44110: LD_EXP 118
44114: PUSH
44115: LD_VAR 0 2
44119: ARRAY
44120: PUSH
44121: FOR_IN
44122: IFFALSE 44488
// begin if GetClass ( j ) <> 3 then
44124: LD_VAR 0 3
44128: PPUSH
44129: CALL_OW 257
44133: PUSH
44134: LD_INT 3
44136: NONEQUAL
44137: IFFALSE 44190
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44139: LD_ADDR_EXP 118
44143: PUSH
44144: LD_EXP 118
44148: PPUSH
44149: LD_VAR 0 2
44153: PPUSH
44154: LD_EXP 118
44158: PUSH
44159: LD_VAR 0 2
44163: ARRAY
44164: PUSH
44165: LD_VAR 0 3
44169: DIFF
44170: PPUSH
44171: CALL_OW 1
44175: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44176: LD_VAR 0 3
44180: PPUSH
44181: LD_INT 0
44183: PPUSH
44184: CALL_OW 109
// continue ;
44188: GO 44121
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44190: LD_EXP 97
44194: PUSH
44195: LD_VAR 0 2
44199: ARRAY
44200: PPUSH
44201: LD_INT 34
44203: PUSH
44204: LD_INT 31
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 58
44213: PUSH
44214: EMPTY
44215: LIST
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PPUSH
44221: CALL_OW 72
44225: PUSH
44226: LD_VAR 0 3
44230: PPUSH
44231: CALL 87721 0 1
44235: NOT
44236: AND
44237: IFFALSE 44308
// begin if IsInUnit ( j ) then
44239: LD_VAR 0 3
44243: PPUSH
44244: CALL_OW 310
44248: IFFALSE 44259
// ComExitBuilding ( j ) ;
44250: LD_VAR 0 3
44254: PPUSH
44255: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44259: LD_VAR 0 3
44263: PPUSH
44264: LD_EXP 97
44268: PUSH
44269: LD_VAR 0 2
44273: ARRAY
44274: PPUSH
44275: LD_INT 34
44277: PUSH
44278: LD_INT 31
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 58
44287: PUSH
44288: EMPTY
44289: LIST
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PPUSH
44295: CALL_OW 72
44299: PUSH
44300: LD_INT 1
44302: ARRAY
44303: PPUSH
44304: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44308: LD_VAR 0 3
44312: PPUSH
44313: CALL_OW 310
44317: NOT
44318: PUSH
44319: LD_VAR 0 3
44323: PPUSH
44324: CALL_OW 310
44328: PPUSH
44329: CALL_OW 266
44333: PUSH
44334: LD_INT 36
44336: NONEQUAL
44337: PUSH
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL 87721 0 1
44347: NOT
44348: AND
44349: OR
44350: IFFALSE 44486
// begin if IsInUnit ( j ) then
44352: LD_VAR 0 3
44356: PPUSH
44357: CALL_OW 310
44361: IFFALSE 44372
// ComExitBuilding ( j ) ;
44363: LD_VAR 0 3
44367: PPUSH
44368: CALL_OW 122
// ct := 0 ;
44372: LD_ADDR_VAR 0 8
44376: PUSH
44377: LD_INT 0
44379: ST_TO_ADDR
// for k in x do
44380: LD_ADDR_VAR 0 4
44384: PUSH
44385: LD_VAR 0 11
44389: PUSH
44390: FOR_IN
44391: IFFALSE 44464
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44393: LD_VAR 0 4
44397: PPUSH
44398: CALL_OW 264
44402: PUSH
44403: LD_INT 31
44405: EQUAL
44406: PUSH
44407: LD_VAR 0 4
44411: PPUSH
44412: CALL_OW 311
44416: NOT
44417: AND
44418: PUSH
44419: LD_VAR 0 4
44423: PPUSH
44424: CALL_OW 266
44428: PUSH
44429: LD_INT 36
44431: EQUAL
44432: PUSH
44433: LD_VAR 0 4
44437: PPUSH
44438: CALL_OW 313
44442: PUSH
44443: LD_INT 3
44445: LESS
44446: AND
44447: OR
44448: IFFALSE 44462
// begin ct := k ;
44450: LD_ADDR_VAR 0 8
44454: PUSH
44455: LD_VAR 0 4
44459: ST_TO_ADDR
// break ;
44460: GO 44464
// end ;
44462: GO 44390
44464: POP
44465: POP
// if ct then
44466: LD_VAR 0 8
44470: IFFALSE 44486
// ComEnterUnit ( j , ct ) ;
44472: LD_VAR 0 3
44476: PPUSH
44477: LD_VAR 0 8
44481: PPUSH
44482: CALL_OW 120
// end ; end ;
44486: GO 44121
44488: POP
44489: POP
// places := 0 ;
44490: LD_ADDR_VAR 0 5
44494: PUSH
44495: LD_INT 0
44497: ST_TO_ADDR
// for j = 1 to x do
44498: LD_ADDR_VAR 0 3
44502: PUSH
44503: DOUBLE
44504: LD_INT 1
44506: DEC
44507: ST_TO_ADDR
44508: LD_VAR 0 11
44512: PUSH
44513: FOR_TO
44514: IFFALSE 44590
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44516: LD_VAR 0 11
44520: PUSH
44521: LD_VAR 0 3
44525: ARRAY
44526: PPUSH
44527: CALL_OW 264
44531: PUSH
44532: LD_INT 31
44534: EQUAL
44535: IFFALSE 44553
// places := places + 1 else
44537: LD_ADDR_VAR 0 5
44541: PUSH
44542: LD_VAR 0 5
44546: PUSH
44547: LD_INT 1
44549: PLUS
44550: ST_TO_ADDR
44551: GO 44588
// if GetBType ( x [ j ] ) = b_control_tower then
44553: LD_VAR 0 11
44557: PUSH
44558: LD_VAR 0 3
44562: ARRAY
44563: PPUSH
44564: CALL_OW 266
44568: PUSH
44569: LD_INT 36
44571: EQUAL
44572: IFFALSE 44588
// places := places + 3 ;
44574: LD_ADDR_VAR 0 5
44578: PUSH
44579: LD_VAR 0 5
44583: PUSH
44584: LD_INT 3
44586: PLUS
44587: ST_TO_ADDR
44588: GO 44513
44590: POP
44591: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
44592: LD_VAR 0 5
44596: PUSH
44597: LD_INT 0
44599: EQUAL
44600: PUSH
44601: LD_VAR 0 5
44605: PUSH
44606: LD_EXP 118
44610: PUSH
44611: LD_VAR 0 2
44615: ARRAY
44616: LESSEQUAL
44617: OR
44618: IFFALSE 44622
// continue ;
44620: GO 43872
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44622: LD_ADDR_VAR 0 6
44626: PUSH
44627: LD_EXP 78
44631: PUSH
44632: LD_VAR 0 2
44636: ARRAY
44637: PPUSH
44638: LD_INT 25
44640: PUSH
44641: LD_INT 3
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PPUSH
44648: CALL_OW 72
44652: PUSH
44653: LD_EXP 118
44657: PUSH
44658: LD_VAR 0 2
44662: ARRAY
44663: DIFF
44664: PPUSH
44665: LD_INT 3
44667: PPUSH
44668: CALL 88621 0 2
44672: ST_TO_ADDR
// for j in tmp do
44673: LD_ADDR_VAR 0 3
44677: PUSH
44678: LD_VAR 0 6
44682: PUSH
44683: FOR_IN
44684: IFFALSE 44719
// if GetTag ( j ) > 0 then
44686: LD_VAR 0 3
44690: PPUSH
44691: CALL_OW 110
44695: PUSH
44696: LD_INT 0
44698: GREATER
44699: IFFALSE 44717
// tmp := tmp diff j ;
44701: LD_ADDR_VAR 0 6
44705: PUSH
44706: LD_VAR 0 6
44710: PUSH
44711: LD_VAR 0 3
44715: DIFF
44716: ST_TO_ADDR
44717: GO 44683
44719: POP
44720: POP
// if not tmp then
44721: LD_VAR 0 6
44725: NOT
44726: IFFALSE 44730
// continue ;
44728: GO 43872
// if places then
44730: LD_VAR 0 5
44734: IFFALSE 44793
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44736: LD_ADDR_EXP 118
44740: PUSH
44741: LD_EXP 118
44745: PPUSH
44746: LD_VAR 0 2
44750: PPUSH
44751: LD_EXP 118
44755: PUSH
44756: LD_VAR 0 2
44760: ARRAY
44761: PUSH
44762: LD_VAR 0 6
44766: PUSH
44767: LD_INT 1
44769: ARRAY
44770: UNION
44771: PPUSH
44772: CALL_OW 1
44776: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44777: LD_VAR 0 6
44781: PUSH
44782: LD_INT 1
44784: ARRAY
44785: PPUSH
44786: LD_INT 126
44788: PPUSH
44789: CALL_OW 109
// end ; end ;
44793: GO 43872
44795: POP
44796: POP
// end ;
44797: LD_VAR 0 1
44801: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44802: LD_INT 0
44804: PPUSH
44805: PPUSH
44806: PPUSH
44807: PPUSH
44808: PPUSH
44809: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44810: LD_VAR 0 1
44814: NOT
44815: PUSH
44816: LD_VAR 0 2
44820: NOT
44821: OR
44822: PUSH
44823: LD_VAR 0 3
44827: NOT
44828: OR
44829: PUSH
44830: LD_VAR 0 4
44834: PUSH
44835: LD_INT 1
44837: PUSH
44838: LD_INT 2
44840: PUSH
44841: LD_INT 3
44843: PUSH
44844: LD_INT 4
44846: PUSH
44847: LD_INT 5
44849: PUSH
44850: LD_INT 8
44852: PUSH
44853: LD_INT 9
44855: PUSH
44856: LD_INT 15
44858: PUSH
44859: LD_INT 16
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: IN
44873: NOT
44874: OR
44875: IFFALSE 44879
// exit ;
44877: GO 45737
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44879: LD_ADDR_VAR 0 2
44883: PUSH
44884: LD_VAR 0 2
44888: PPUSH
44889: LD_INT 21
44891: PUSH
44892: LD_INT 3
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 24
44901: PUSH
44902: LD_INT 250
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PPUSH
44913: CALL_OW 72
44917: ST_TO_ADDR
// case class of 1 , 15 :
44918: LD_VAR 0 4
44922: PUSH
44923: LD_INT 1
44925: DOUBLE
44926: EQUAL
44927: IFTRUE 44937
44929: LD_INT 15
44931: DOUBLE
44932: EQUAL
44933: IFTRUE 44937
44935: GO 45022
44937: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44938: LD_ADDR_VAR 0 8
44942: PUSH
44943: LD_VAR 0 2
44947: PPUSH
44948: LD_INT 2
44950: PUSH
44951: LD_INT 30
44953: PUSH
44954: LD_INT 32
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 30
44963: PUSH
44964: LD_INT 31
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: LIST
44975: PPUSH
44976: CALL_OW 72
44980: PUSH
44981: LD_VAR 0 2
44985: PPUSH
44986: LD_INT 2
44988: PUSH
44989: LD_INT 30
44991: PUSH
44992: LD_INT 4
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 30
45001: PUSH
45002: LD_INT 5
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: LIST
45013: PPUSH
45014: CALL_OW 72
45018: ADD
45019: ST_TO_ADDR
45020: GO 45268
45022: LD_INT 2
45024: DOUBLE
45025: EQUAL
45026: IFTRUE 45036
45028: LD_INT 16
45030: DOUBLE
45031: EQUAL
45032: IFTRUE 45036
45034: GO 45082
45036: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45037: LD_ADDR_VAR 0 8
45041: PUSH
45042: LD_VAR 0 2
45046: PPUSH
45047: LD_INT 2
45049: PUSH
45050: LD_INT 30
45052: PUSH
45053: LD_INT 0
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PUSH
45060: LD_INT 30
45062: PUSH
45063: LD_INT 1
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: LIST
45074: PPUSH
45075: CALL_OW 72
45079: ST_TO_ADDR
45080: GO 45268
45082: LD_INT 3
45084: DOUBLE
45085: EQUAL
45086: IFTRUE 45090
45088: GO 45136
45090: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45091: LD_ADDR_VAR 0 8
45095: PUSH
45096: LD_VAR 0 2
45100: PPUSH
45101: LD_INT 2
45103: PUSH
45104: LD_INT 30
45106: PUSH
45107: LD_INT 2
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 30
45116: PUSH
45117: LD_INT 3
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: EMPTY
45125: LIST
45126: LIST
45127: LIST
45128: PPUSH
45129: CALL_OW 72
45133: ST_TO_ADDR
45134: GO 45268
45136: LD_INT 4
45138: DOUBLE
45139: EQUAL
45140: IFTRUE 45144
45142: GO 45201
45144: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45145: LD_ADDR_VAR 0 8
45149: PUSH
45150: LD_VAR 0 2
45154: PPUSH
45155: LD_INT 2
45157: PUSH
45158: LD_INT 30
45160: PUSH
45161: LD_INT 6
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 30
45170: PUSH
45171: LD_INT 7
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 30
45180: PUSH
45181: LD_INT 8
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: PPUSH
45194: CALL_OW 72
45198: ST_TO_ADDR
45199: GO 45268
45201: LD_INT 5
45203: DOUBLE
45204: EQUAL
45205: IFTRUE 45221
45207: LD_INT 8
45209: DOUBLE
45210: EQUAL
45211: IFTRUE 45221
45213: LD_INT 9
45215: DOUBLE
45216: EQUAL
45217: IFTRUE 45221
45219: GO 45267
45221: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45222: LD_ADDR_VAR 0 8
45226: PUSH
45227: LD_VAR 0 2
45231: PPUSH
45232: LD_INT 2
45234: PUSH
45235: LD_INT 30
45237: PUSH
45238: LD_INT 4
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 30
45247: PUSH
45248: LD_INT 5
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: LIST
45259: PPUSH
45260: CALL_OW 72
45264: ST_TO_ADDR
45265: GO 45268
45267: POP
// if not tmp then
45268: LD_VAR 0 8
45272: NOT
45273: IFFALSE 45277
// exit ;
45275: GO 45737
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45277: LD_VAR 0 4
45281: PUSH
45282: LD_INT 1
45284: PUSH
45285: LD_INT 15
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: IN
45292: PUSH
45293: LD_EXP 87
45297: PUSH
45298: LD_VAR 0 1
45302: ARRAY
45303: AND
45304: IFFALSE 45460
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45306: LD_ADDR_VAR 0 9
45310: PUSH
45311: LD_EXP 87
45315: PUSH
45316: LD_VAR 0 1
45320: ARRAY
45321: PUSH
45322: LD_INT 1
45324: ARRAY
45325: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45326: LD_VAR 0 9
45330: PUSH
45331: LD_EXP 88
45335: PUSH
45336: LD_VAR 0 1
45340: ARRAY
45341: IN
45342: NOT
45343: IFFALSE 45458
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45345: LD_ADDR_EXP 88
45349: PUSH
45350: LD_EXP 88
45354: PPUSH
45355: LD_VAR 0 1
45359: PUSH
45360: LD_EXP 88
45364: PUSH
45365: LD_VAR 0 1
45369: ARRAY
45370: PUSH
45371: LD_INT 1
45373: PLUS
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PPUSH
45379: LD_VAR 0 9
45383: PPUSH
45384: CALL 57774 0 3
45388: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45389: LD_ADDR_EXP 87
45393: PUSH
45394: LD_EXP 87
45398: PPUSH
45399: LD_VAR 0 1
45403: PPUSH
45404: LD_EXP 87
45408: PUSH
45409: LD_VAR 0 1
45413: ARRAY
45414: PUSH
45415: LD_VAR 0 9
45419: DIFF
45420: PPUSH
45421: CALL_OW 1
45425: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45426: LD_VAR 0 3
45430: PPUSH
45431: LD_EXP 88
45435: PUSH
45436: LD_VAR 0 1
45440: ARRAY
45441: PUSH
45442: LD_EXP 88
45446: PUSH
45447: LD_VAR 0 1
45451: ARRAY
45452: ARRAY
45453: PPUSH
45454: CALL_OW 120
// end ; exit ;
45458: GO 45737
// end ; if tmp > 1 then
45460: LD_VAR 0 8
45464: PUSH
45465: LD_INT 1
45467: GREATER
45468: IFFALSE 45572
// for i = 2 to tmp do
45470: LD_ADDR_VAR 0 6
45474: PUSH
45475: DOUBLE
45476: LD_INT 2
45478: DEC
45479: ST_TO_ADDR
45480: LD_VAR 0 8
45484: PUSH
45485: FOR_TO
45486: IFFALSE 45570
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45488: LD_VAR 0 8
45492: PUSH
45493: LD_VAR 0 6
45497: ARRAY
45498: PPUSH
45499: CALL_OW 461
45503: PUSH
45504: LD_INT 6
45506: EQUAL
45507: IFFALSE 45568
// begin x := tmp [ i ] ;
45509: LD_ADDR_VAR 0 9
45513: PUSH
45514: LD_VAR 0 8
45518: PUSH
45519: LD_VAR 0 6
45523: ARRAY
45524: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45525: LD_ADDR_VAR 0 8
45529: PUSH
45530: LD_VAR 0 8
45534: PPUSH
45535: LD_VAR 0 6
45539: PPUSH
45540: CALL_OW 3
45544: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45545: LD_ADDR_VAR 0 8
45549: PUSH
45550: LD_VAR 0 8
45554: PPUSH
45555: LD_INT 1
45557: PPUSH
45558: LD_VAR 0 9
45562: PPUSH
45563: CALL_OW 2
45567: ST_TO_ADDR
// end ;
45568: GO 45485
45570: POP
45571: POP
// for i in tmp do
45572: LD_ADDR_VAR 0 6
45576: PUSH
45577: LD_VAR 0 8
45581: PUSH
45582: FOR_IN
45583: IFFALSE 45610
// begin if IsNotFull ( i ) then
45585: LD_VAR 0 6
45589: PPUSH
45590: CALL 54996 0 1
45594: IFFALSE 45608
// begin j := i ;
45596: LD_ADDR_VAR 0 7
45600: PUSH
45601: LD_VAR 0 6
45605: ST_TO_ADDR
// break ;
45606: GO 45610
// end ; end ;
45608: GO 45582
45610: POP
45611: POP
// if j then
45612: LD_VAR 0 7
45616: IFFALSE 45634
// ComEnterUnit ( unit , j ) else
45618: LD_VAR 0 3
45622: PPUSH
45623: LD_VAR 0 7
45627: PPUSH
45628: CALL_OW 120
45632: GO 45737
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45634: LD_ADDR_VAR 0 10
45638: PUSH
45639: LD_VAR 0 2
45643: PPUSH
45644: LD_INT 2
45646: PUSH
45647: LD_INT 30
45649: PUSH
45650: LD_INT 0
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 30
45659: PUSH
45660: LD_INT 1
45662: PUSH
45663: EMPTY
45664: LIST
45665: LIST
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: LIST
45671: PPUSH
45672: CALL_OW 72
45676: ST_TO_ADDR
// if depot then
45677: LD_VAR 0 10
45681: IFFALSE 45737
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45683: LD_ADDR_VAR 0 10
45687: PUSH
45688: LD_VAR 0 10
45692: PPUSH
45693: LD_VAR 0 3
45697: PPUSH
45698: CALL_OW 74
45702: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45703: LD_VAR 0 3
45707: PPUSH
45708: LD_VAR 0 10
45712: PPUSH
45713: CALL_OW 296
45717: PUSH
45718: LD_INT 10
45720: GREATER
45721: IFFALSE 45737
// ComStandNearbyBuilding ( unit , depot ) ;
45723: LD_VAR 0 3
45727: PPUSH
45728: LD_VAR 0 10
45732: PPUSH
45733: CALL 54376 0 2
// end ; end ; end ;
45737: LD_VAR 0 5
45741: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45742: LD_INT 0
45744: PPUSH
45745: PPUSH
45746: PPUSH
45747: PPUSH
// if not mc_bases then
45748: LD_EXP 78
45752: NOT
45753: IFFALSE 45757
// exit ;
45755: GO 45996
// for i = 1 to mc_bases do
45757: LD_ADDR_VAR 0 2
45761: PUSH
45762: DOUBLE
45763: LD_INT 1
45765: DEC
45766: ST_TO_ADDR
45767: LD_EXP 78
45771: PUSH
45772: FOR_TO
45773: IFFALSE 45994
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45775: LD_ADDR_VAR 0 4
45779: PUSH
45780: LD_EXP 78
45784: PUSH
45785: LD_VAR 0 2
45789: ARRAY
45790: PPUSH
45791: LD_INT 21
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PPUSH
45801: CALL_OW 72
45805: PUSH
45806: LD_EXP 107
45810: PUSH
45811: LD_VAR 0 2
45815: ARRAY
45816: UNION
45817: ST_TO_ADDR
// if not tmp then
45818: LD_VAR 0 4
45822: NOT
45823: IFFALSE 45827
// continue ;
45825: GO 45772
// for j in tmp do
45827: LD_ADDR_VAR 0 3
45831: PUSH
45832: LD_VAR 0 4
45836: PUSH
45837: FOR_IN
45838: IFFALSE 45990
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45840: LD_VAR 0 3
45844: PPUSH
45845: CALL_OW 110
45849: NOT
45850: PUSH
45851: LD_VAR 0 3
45855: PPUSH
45856: CALL_OW 314
45860: NOT
45861: AND
45862: PUSH
45863: LD_VAR 0 3
45867: PPUSH
45868: CALL_OW 311
45872: NOT
45873: AND
45874: PUSH
45875: LD_VAR 0 3
45879: PPUSH
45880: CALL_OW 310
45884: NOT
45885: AND
45886: PUSH
45887: LD_VAR 0 3
45891: PUSH
45892: LD_EXP 81
45896: PUSH
45897: LD_VAR 0 2
45901: ARRAY
45902: PUSH
45903: LD_INT 1
45905: ARRAY
45906: IN
45907: NOT
45908: AND
45909: PUSH
45910: LD_VAR 0 3
45914: PUSH
45915: LD_EXP 81
45919: PUSH
45920: LD_VAR 0 2
45924: ARRAY
45925: PUSH
45926: LD_INT 2
45928: ARRAY
45929: IN
45930: NOT
45931: AND
45932: PUSH
45933: LD_VAR 0 3
45937: PUSH
45938: LD_EXP 90
45942: PUSH
45943: LD_VAR 0 2
45947: ARRAY
45948: IN
45949: NOT
45950: AND
45951: IFFALSE 45988
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45953: LD_VAR 0 2
45957: PPUSH
45958: LD_EXP 78
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: PPUSH
45969: LD_VAR 0 3
45973: PPUSH
45974: LD_VAR 0 3
45978: PPUSH
45979: CALL_OW 257
45983: PPUSH
45984: CALL 44802 0 4
// end ;
45988: GO 45837
45990: POP
45991: POP
// end ;
45992: GO 45772
45994: POP
45995: POP
// end ;
45996: LD_VAR 0 1
46000: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46001: LD_INT 0
46003: PPUSH
46004: PPUSH
46005: PPUSH
46006: PPUSH
46007: PPUSH
46008: PPUSH
// if not mc_bases [ base ] then
46009: LD_EXP 78
46013: PUSH
46014: LD_VAR 0 1
46018: ARRAY
46019: NOT
46020: IFFALSE 46024
// exit ;
46022: GO 46225
// tmp := [ ] ;
46024: LD_ADDR_VAR 0 6
46028: PUSH
46029: EMPTY
46030: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46031: LD_ADDR_VAR 0 7
46035: PUSH
46036: LD_VAR 0 3
46040: PPUSH
46041: LD_INT 0
46043: PPUSH
46044: CALL_OW 517
46048: ST_TO_ADDR
// if not list then
46049: LD_VAR 0 7
46053: NOT
46054: IFFALSE 46058
// exit ;
46056: GO 46225
// c := Count ( list [ 1 ] ) ;
46058: LD_ADDR_VAR 0 9
46062: PUSH
46063: LD_VAR 0 7
46067: PUSH
46068: LD_INT 1
46070: ARRAY
46071: PPUSH
46072: CALL 54914 0 1
46076: ST_TO_ADDR
// if amount > c then
46077: LD_VAR 0 2
46081: PUSH
46082: LD_VAR 0 9
46086: GREATER
46087: IFFALSE 46099
// amount := c ;
46089: LD_ADDR_VAR 0 2
46093: PUSH
46094: LD_VAR 0 9
46098: ST_TO_ADDR
// for i := 1 to amount do
46099: LD_ADDR_VAR 0 5
46103: PUSH
46104: DOUBLE
46105: LD_INT 1
46107: DEC
46108: ST_TO_ADDR
46109: LD_VAR 0 2
46113: PUSH
46114: FOR_TO
46115: IFFALSE 46173
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46117: LD_ADDR_VAR 0 6
46121: PUSH
46122: LD_VAR 0 6
46126: PPUSH
46127: LD_VAR 0 5
46131: PPUSH
46132: LD_VAR 0 7
46136: PUSH
46137: LD_INT 1
46139: ARRAY
46140: PUSH
46141: LD_VAR 0 5
46145: ARRAY
46146: PUSH
46147: LD_VAR 0 7
46151: PUSH
46152: LD_INT 2
46154: ARRAY
46155: PUSH
46156: LD_VAR 0 5
46160: ARRAY
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PPUSH
46166: CALL_OW 1
46170: ST_TO_ADDR
46171: GO 46114
46173: POP
46174: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46175: LD_ADDR_EXP 91
46179: PUSH
46180: LD_EXP 91
46184: PPUSH
46185: LD_VAR 0 1
46189: PPUSH
46190: LD_VAR 0 6
46194: PPUSH
46195: CALL_OW 1
46199: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46200: LD_ADDR_EXP 93
46204: PUSH
46205: LD_EXP 93
46209: PPUSH
46210: LD_VAR 0 1
46214: PPUSH
46215: LD_VAR 0 3
46219: PPUSH
46220: CALL_OW 1
46224: ST_TO_ADDR
// end ;
46225: LD_VAR 0 4
46229: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46230: LD_INT 0
46232: PPUSH
// if not mc_bases [ base ] then
46233: LD_EXP 78
46237: PUSH
46238: LD_VAR 0 1
46242: ARRAY
46243: NOT
46244: IFFALSE 46248
// exit ;
46246: GO 46273
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46248: LD_ADDR_EXP 83
46252: PUSH
46253: LD_EXP 83
46257: PPUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: LD_VAR 0 2
46267: PPUSH
46268: CALL_OW 1
46272: ST_TO_ADDR
// end ;
46273: LD_VAR 0 3
46277: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46278: LD_INT 0
46280: PPUSH
// if not mc_bases [ base ] then
46281: LD_EXP 78
46285: PUSH
46286: LD_VAR 0 1
46290: ARRAY
46291: NOT
46292: IFFALSE 46296
// exit ;
46294: GO 46333
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46296: LD_ADDR_EXP 83
46300: PUSH
46301: LD_EXP 83
46305: PPUSH
46306: LD_VAR 0 1
46310: PPUSH
46311: LD_EXP 83
46315: PUSH
46316: LD_VAR 0 1
46320: ARRAY
46321: PUSH
46322: LD_VAR 0 2
46326: UNION
46327: PPUSH
46328: CALL_OW 1
46332: ST_TO_ADDR
// end ;
46333: LD_VAR 0 3
46337: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46338: LD_INT 0
46340: PPUSH
// if not mc_bases [ base ] then
46341: LD_EXP 78
46345: PUSH
46346: LD_VAR 0 1
46350: ARRAY
46351: NOT
46352: IFFALSE 46356
// exit ;
46354: GO 46381
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46356: LD_ADDR_EXP 99
46360: PUSH
46361: LD_EXP 99
46365: PPUSH
46366: LD_VAR 0 1
46370: PPUSH
46371: LD_VAR 0 2
46375: PPUSH
46376: CALL_OW 1
46380: ST_TO_ADDR
// end ;
46381: LD_VAR 0 3
46385: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46386: LD_INT 0
46388: PPUSH
// if not mc_bases [ base ] then
46389: LD_EXP 78
46393: PUSH
46394: LD_VAR 0 1
46398: ARRAY
46399: NOT
46400: IFFALSE 46404
// exit ;
46402: GO 46441
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46404: LD_ADDR_EXP 99
46408: PUSH
46409: LD_EXP 99
46413: PPUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: LD_EXP 99
46423: PUSH
46424: LD_VAR 0 1
46428: ARRAY
46429: PUSH
46430: LD_VAR 0 2
46434: ADD
46435: PPUSH
46436: CALL_OW 1
46440: ST_TO_ADDR
// end ;
46441: LD_VAR 0 3
46445: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46446: LD_INT 0
46448: PPUSH
// if not mc_bases [ base ] then
46449: LD_EXP 78
46453: PUSH
46454: LD_VAR 0 1
46458: ARRAY
46459: NOT
46460: IFFALSE 46464
// exit ;
46462: GO 46518
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46464: LD_ADDR_EXP 100
46468: PUSH
46469: LD_EXP 100
46473: PPUSH
46474: LD_VAR 0 1
46478: PPUSH
46479: LD_VAR 0 2
46483: PPUSH
46484: CALL_OW 1
46488: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46489: LD_ADDR_EXP 89
46493: PUSH
46494: LD_EXP 89
46498: PPUSH
46499: LD_VAR 0 1
46503: PPUSH
46504: LD_VAR 0 2
46508: PUSH
46509: LD_INT 0
46511: PLUS
46512: PPUSH
46513: CALL_OW 1
46517: ST_TO_ADDR
// end ;
46518: LD_VAR 0 3
46522: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46523: LD_INT 0
46525: PPUSH
// if not mc_bases [ base ] then
46526: LD_EXP 78
46530: PUSH
46531: LD_VAR 0 1
46535: ARRAY
46536: NOT
46537: IFFALSE 46541
// exit ;
46539: GO 46566
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46541: LD_ADDR_EXP 89
46545: PUSH
46546: LD_EXP 89
46550: PPUSH
46551: LD_VAR 0 1
46555: PPUSH
46556: LD_VAR 0 2
46560: PPUSH
46561: CALL_OW 1
46565: ST_TO_ADDR
// end ;
46566: LD_VAR 0 3
46570: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
46571: LD_INT 0
46573: PPUSH
46574: PPUSH
46575: PPUSH
46576: PPUSH
// if not mc_bases [ base ] then
46577: LD_EXP 78
46581: PUSH
46582: LD_VAR 0 1
46586: ARRAY
46587: NOT
46588: IFFALSE 46592
// exit ;
46590: GO 46657
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
46592: LD_ADDR_EXP 98
46596: PUSH
46597: LD_EXP 98
46601: PPUSH
46602: LD_VAR 0 1
46606: PUSH
46607: LD_EXP 98
46611: PUSH
46612: LD_VAR 0 1
46616: ARRAY
46617: PUSH
46618: LD_INT 1
46620: PLUS
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PPUSH
46626: LD_VAR 0 1
46630: PUSH
46631: LD_VAR 0 2
46635: PUSH
46636: LD_VAR 0 3
46640: PUSH
46641: LD_VAR 0 4
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: PPUSH
46652: CALL 57774 0 3
46656: ST_TO_ADDR
// end ;
46657: LD_VAR 0 5
46661: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46662: LD_INT 0
46664: PPUSH
// if not mc_bases [ base ] then
46665: LD_EXP 78
46669: PUSH
46670: LD_VAR 0 1
46674: ARRAY
46675: NOT
46676: IFFALSE 46680
// exit ;
46678: GO 46705
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46680: LD_ADDR_EXP 115
46684: PUSH
46685: LD_EXP 115
46689: PPUSH
46690: LD_VAR 0 1
46694: PPUSH
46695: LD_VAR 0 2
46699: PPUSH
46700: CALL_OW 1
46704: ST_TO_ADDR
// end ;
46705: LD_VAR 0 3
46709: RET
// export function MC_GetMinesField ( base ) ; begin
46710: LD_INT 0
46712: PPUSH
// result := mc_mines [ base ] ;
46713: LD_ADDR_VAR 0 2
46717: PUSH
46718: LD_EXP 91
46722: PUSH
46723: LD_VAR 0 1
46727: ARRAY
46728: ST_TO_ADDR
// end ;
46729: LD_VAR 0 2
46733: RET
// export function MC_GetProduceList ( base ) ; begin
46734: LD_INT 0
46736: PPUSH
// result := mc_produce [ base ] ;
46737: LD_ADDR_VAR 0 2
46741: PUSH
46742: LD_EXP 99
46746: PUSH
46747: LD_VAR 0 1
46751: ARRAY
46752: ST_TO_ADDR
// end ;
46753: LD_VAR 0 2
46757: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46758: LD_INT 0
46760: PPUSH
46761: PPUSH
// if not mc_bases then
46762: LD_EXP 78
46766: NOT
46767: IFFALSE 46771
// exit ;
46769: GO 46836
// if mc_bases [ base ] then
46771: LD_EXP 78
46775: PUSH
46776: LD_VAR 0 1
46780: ARRAY
46781: IFFALSE 46836
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46783: LD_ADDR_VAR 0 3
46787: PUSH
46788: LD_EXP 78
46792: PUSH
46793: LD_VAR 0 1
46797: ARRAY
46798: PPUSH
46799: LD_INT 30
46801: PUSH
46802: LD_VAR 0 2
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PPUSH
46811: CALL_OW 72
46815: ST_TO_ADDR
// if result then
46816: LD_VAR 0 3
46820: IFFALSE 46836
// result := result [ 1 ] ;
46822: LD_ADDR_VAR 0 3
46826: PUSH
46827: LD_VAR 0 3
46831: PUSH
46832: LD_INT 1
46834: ARRAY
46835: ST_TO_ADDR
// end ; end ;
46836: LD_VAR 0 3
46840: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46841: LD_INT 0
46843: PPUSH
46844: PPUSH
// if not mc_bases then
46845: LD_EXP 78
46849: NOT
46850: IFFALSE 46854
// exit ;
46852: GO 46899
// if mc_bases [ base ] then
46854: LD_EXP 78
46858: PUSH
46859: LD_VAR 0 1
46863: ARRAY
46864: IFFALSE 46899
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46866: LD_ADDR_VAR 0 3
46870: PUSH
46871: LD_EXP 78
46875: PUSH
46876: LD_VAR 0 1
46880: ARRAY
46881: PPUSH
46882: LD_INT 30
46884: PUSH
46885: LD_VAR 0 2
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PPUSH
46894: CALL_OW 72
46898: ST_TO_ADDR
// end ;
46899: LD_VAR 0 3
46903: RET
// export function MC_SetTame ( base , area ) ; begin
46904: LD_INT 0
46906: PPUSH
// if not mc_bases or not base then
46907: LD_EXP 78
46911: NOT
46912: PUSH
46913: LD_VAR 0 1
46917: NOT
46918: OR
46919: IFFALSE 46923
// exit ;
46921: GO 46948
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46923: LD_ADDR_EXP 106
46927: PUSH
46928: LD_EXP 106
46932: PPUSH
46933: LD_VAR 0 1
46937: PPUSH
46938: LD_VAR 0 2
46942: PPUSH
46943: CALL_OW 1
46947: ST_TO_ADDR
// end ;
46948: LD_VAR 0 3
46952: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46953: LD_INT 0
46955: PPUSH
46956: PPUSH
// if not mc_bases or not base then
46957: LD_EXP 78
46961: NOT
46962: PUSH
46963: LD_VAR 0 1
46967: NOT
46968: OR
46969: IFFALSE 46973
// exit ;
46971: GO 47075
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46973: LD_ADDR_VAR 0 4
46977: PUSH
46978: LD_EXP 78
46982: PUSH
46983: LD_VAR 0 1
46987: ARRAY
46988: PPUSH
46989: LD_INT 30
46991: PUSH
46992: LD_VAR 0 2
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PPUSH
47001: CALL_OW 72
47005: ST_TO_ADDR
// if not tmp then
47006: LD_VAR 0 4
47010: NOT
47011: IFFALSE 47015
// exit ;
47013: GO 47075
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47015: LD_ADDR_EXP 110
47019: PUSH
47020: LD_EXP 110
47024: PPUSH
47025: LD_VAR 0 1
47029: PPUSH
47030: LD_EXP 110
47034: PUSH
47035: LD_VAR 0 1
47039: ARRAY
47040: PPUSH
47041: LD_EXP 110
47045: PUSH
47046: LD_VAR 0 1
47050: ARRAY
47051: PUSH
47052: LD_INT 1
47054: PLUS
47055: PPUSH
47056: LD_VAR 0 4
47060: PUSH
47061: LD_INT 1
47063: ARRAY
47064: PPUSH
47065: CALL_OW 2
47069: PPUSH
47070: CALL_OW 1
47074: ST_TO_ADDR
// end ;
47075: LD_VAR 0 3
47079: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47080: LD_INT 0
47082: PPUSH
47083: PPUSH
// if not mc_bases or not base or not kinds then
47084: LD_EXP 78
47088: NOT
47089: PUSH
47090: LD_VAR 0 1
47094: NOT
47095: OR
47096: PUSH
47097: LD_VAR 0 2
47101: NOT
47102: OR
47103: IFFALSE 47107
// exit ;
47105: GO 47168
// for i in kinds do
47107: LD_ADDR_VAR 0 4
47111: PUSH
47112: LD_VAR 0 2
47116: PUSH
47117: FOR_IN
47118: IFFALSE 47166
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47120: LD_ADDR_EXP 112
47124: PUSH
47125: LD_EXP 112
47129: PPUSH
47130: LD_VAR 0 1
47134: PUSH
47135: LD_EXP 112
47139: PUSH
47140: LD_VAR 0 1
47144: ARRAY
47145: PUSH
47146: LD_INT 1
47148: PLUS
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PPUSH
47154: LD_VAR 0 4
47158: PPUSH
47159: CALL 57774 0 3
47163: ST_TO_ADDR
47164: GO 47117
47166: POP
47167: POP
// end ;
47168: LD_VAR 0 3
47172: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47173: LD_INT 0
47175: PPUSH
// if not mc_bases or not base or not areas then
47176: LD_EXP 78
47180: NOT
47181: PUSH
47182: LD_VAR 0 1
47186: NOT
47187: OR
47188: PUSH
47189: LD_VAR 0 2
47193: NOT
47194: OR
47195: IFFALSE 47199
// exit ;
47197: GO 47224
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47199: LD_ADDR_EXP 96
47203: PUSH
47204: LD_EXP 96
47208: PPUSH
47209: LD_VAR 0 1
47213: PPUSH
47214: LD_VAR 0 2
47218: PPUSH
47219: CALL_OW 1
47223: ST_TO_ADDR
// end ;
47224: LD_VAR 0 3
47228: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47229: LD_INT 0
47231: PPUSH
// if not mc_bases or not base or not teleports_exit then
47232: LD_EXP 78
47236: NOT
47237: PUSH
47238: LD_VAR 0 1
47242: NOT
47243: OR
47244: PUSH
47245: LD_VAR 0 2
47249: NOT
47250: OR
47251: IFFALSE 47255
// exit ;
47253: GO 47280
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47255: LD_ADDR_EXP 113
47259: PUSH
47260: LD_EXP 113
47264: PPUSH
47265: LD_VAR 0 1
47269: PPUSH
47270: LD_VAR 0 2
47274: PPUSH
47275: CALL_OW 1
47279: ST_TO_ADDR
// end ;
47280: LD_VAR 0 3
47284: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47285: LD_INT 0
47287: PPUSH
47288: PPUSH
47289: PPUSH
// if not mc_bases or not base or not ext_list then
47290: LD_EXP 78
47294: NOT
47295: PUSH
47296: LD_VAR 0 1
47300: NOT
47301: OR
47302: PUSH
47303: LD_VAR 0 5
47307: NOT
47308: OR
47309: IFFALSE 47313
// exit ;
47311: GO 47486
// tmp := GetFacExtXYD ( x , y , d ) ;
47313: LD_ADDR_VAR 0 8
47317: PUSH
47318: LD_VAR 0 2
47322: PPUSH
47323: LD_VAR 0 3
47327: PPUSH
47328: LD_VAR 0 4
47332: PPUSH
47333: CALL 87751 0 3
47337: ST_TO_ADDR
// if not tmp then
47338: LD_VAR 0 8
47342: NOT
47343: IFFALSE 47347
// exit ;
47345: GO 47486
// for i in tmp do
47347: LD_ADDR_VAR 0 7
47351: PUSH
47352: LD_VAR 0 8
47356: PUSH
47357: FOR_IN
47358: IFFALSE 47484
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47360: LD_ADDR_EXP 83
47364: PUSH
47365: LD_EXP 83
47369: PPUSH
47370: LD_VAR 0 1
47374: PPUSH
47375: LD_EXP 83
47379: PUSH
47380: LD_VAR 0 1
47384: ARRAY
47385: PPUSH
47386: LD_EXP 83
47390: PUSH
47391: LD_VAR 0 1
47395: ARRAY
47396: PUSH
47397: LD_INT 1
47399: PLUS
47400: PPUSH
47401: LD_VAR 0 5
47405: PUSH
47406: LD_INT 1
47408: ARRAY
47409: PUSH
47410: LD_VAR 0 7
47414: PUSH
47415: LD_INT 1
47417: ARRAY
47418: PUSH
47419: LD_VAR 0 7
47423: PUSH
47424: LD_INT 2
47426: ARRAY
47427: PUSH
47428: LD_VAR 0 7
47432: PUSH
47433: LD_INT 3
47435: ARRAY
47436: PUSH
47437: EMPTY
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: PPUSH
47443: CALL_OW 2
47447: PPUSH
47448: CALL_OW 1
47452: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47453: LD_ADDR_VAR 0 5
47457: PUSH
47458: LD_VAR 0 5
47462: PPUSH
47463: LD_INT 1
47465: PPUSH
47466: CALL_OW 3
47470: ST_TO_ADDR
// if not ext_list then
47471: LD_VAR 0 5
47475: NOT
47476: IFFALSE 47482
// exit ;
47478: POP
47479: POP
47480: GO 47486
// end ;
47482: GO 47357
47484: POP
47485: POP
// end ;
47486: LD_VAR 0 6
47490: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47491: LD_INT 0
47493: PPUSH
// if not mc_bases or not base or not weapon_list then
47494: LD_EXP 78
47498: NOT
47499: PUSH
47500: LD_VAR 0 1
47504: NOT
47505: OR
47506: PUSH
47507: LD_VAR 0 2
47511: NOT
47512: OR
47513: IFFALSE 47517
// exit ;
47515: GO 47542
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47517: LD_ADDR_EXP 117
47521: PUSH
47522: LD_EXP 117
47526: PPUSH
47527: LD_VAR 0 1
47531: PPUSH
47532: LD_VAR 0 2
47536: PPUSH
47537: CALL_OW 1
47541: ST_TO_ADDR
// end ;
47542: LD_VAR 0 3
47546: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47547: LD_INT 0
47549: PPUSH
// if not mc_bases or not base or not tech_list then
47550: LD_EXP 78
47554: NOT
47555: PUSH
47556: LD_VAR 0 1
47560: NOT
47561: OR
47562: PUSH
47563: LD_VAR 0 2
47567: NOT
47568: OR
47569: IFFALSE 47573
// exit ;
47571: GO 47598
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
47573: LD_ADDR_EXP 105
47577: PUSH
47578: LD_EXP 105
47582: PPUSH
47583: LD_VAR 0 1
47587: PPUSH
47588: LD_VAR 0 2
47592: PPUSH
47593: CALL_OW 1
47597: ST_TO_ADDR
// end ;
47598: LD_VAR 0 3
47602: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47603: LD_INT 0
47605: PPUSH
// if not mc_bases or not parking_area or not base then
47606: LD_EXP 78
47610: NOT
47611: PUSH
47612: LD_VAR 0 2
47616: NOT
47617: OR
47618: PUSH
47619: LD_VAR 0 1
47623: NOT
47624: OR
47625: IFFALSE 47629
// exit ;
47627: GO 47654
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47629: LD_ADDR_EXP 102
47633: PUSH
47634: LD_EXP 102
47638: PPUSH
47639: LD_VAR 0 1
47643: PPUSH
47644: LD_VAR 0 2
47648: PPUSH
47649: CALL_OW 1
47653: ST_TO_ADDR
// end ;
47654: LD_VAR 0 3
47658: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47659: LD_INT 0
47661: PPUSH
// if not mc_bases or not base or not scan_area then
47662: LD_EXP 78
47666: NOT
47667: PUSH
47668: LD_VAR 0 1
47672: NOT
47673: OR
47674: PUSH
47675: LD_VAR 0 2
47679: NOT
47680: OR
47681: IFFALSE 47685
// exit ;
47683: GO 47710
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47685: LD_ADDR_EXP 103
47689: PUSH
47690: LD_EXP 103
47694: PPUSH
47695: LD_VAR 0 1
47699: PPUSH
47700: LD_VAR 0 2
47704: PPUSH
47705: CALL_OW 1
47709: ST_TO_ADDR
// end ;
47710: LD_VAR 0 3
47714: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47715: LD_INT 0
47717: PPUSH
47718: PPUSH
// if not mc_bases or not base then
47719: LD_EXP 78
47723: NOT
47724: PUSH
47725: LD_VAR 0 1
47729: NOT
47730: OR
47731: IFFALSE 47735
// exit ;
47733: GO 47799
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_INT 1
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 3
47748: PUSH
47749: LD_INT 4
47751: PUSH
47752: LD_INT 11
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47762: LD_ADDR_EXP 105
47766: PUSH
47767: LD_EXP 105
47771: PPUSH
47772: LD_VAR 0 1
47776: PPUSH
47777: LD_EXP 105
47781: PUSH
47782: LD_VAR 0 1
47786: ARRAY
47787: PUSH
47788: LD_VAR 0 3
47792: DIFF
47793: PPUSH
47794: CALL_OW 1
47798: ST_TO_ADDR
// end ;
47799: LD_VAR 0 2
47803: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47804: LD_INT 0
47806: PPUSH
// result := mc_vehicles [ base ] ;
47807: LD_ADDR_VAR 0 3
47811: PUSH
47812: LD_EXP 97
47816: PUSH
47817: LD_VAR 0 1
47821: ARRAY
47822: ST_TO_ADDR
// if onlyCombat then
47823: LD_VAR 0 2
47827: IFFALSE 47999
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47829: LD_ADDR_VAR 0 3
47833: PUSH
47834: LD_VAR 0 3
47838: PUSH
47839: LD_VAR 0 3
47843: PPUSH
47844: LD_INT 2
47846: PUSH
47847: LD_INT 34
47849: PUSH
47850: LD_INT 12
47852: PUSH
47853: EMPTY
47854: LIST
47855: LIST
47856: PUSH
47857: LD_INT 34
47859: PUSH
47860: LD_INT 51
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: PUSH
47867: LD_INT 34
47869: PUSH
47870: LD_INT 89
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: PUSH
47877: LD_INT 34
47879: PUSH
47880: LD_INT 32
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 34
47889: PUSH
47890: LD_INT 13
47892: PUSH
47893: EMPTY
47894: LIST
47895: LIST
47896: PUSH
47897: LD_INT 34
47899: PUSH
47900: LD_INT 52
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: PUSH
47907: LD_INT 34
47909: PUSH
47910: LD_INT 88
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: PUSH
47917: LD_INT 34
47919: PUSH
47920: LD_INT 14
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_INT 34
47929: PUSH
47930: LD_INT 53
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 34
47939: PUSH
47940: LD_INT 98
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 34
47949: PUSH
47950: LD_INT 31
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 34
47959: PUSH
47960: LD_INT 48
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 34
47969: PUSH
47970: LD_INT 8
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: PPUSH
47993: CALL_OW 72
47997: DIFF
47998: ST_TO_ADDR
// end ; end_of_file
47999: LD_VAR 0 3
48003: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48004: LD_INT 0
48006: PPUSH
48007: PPUSH
48008: PPUSH
// if not mc_bases or not skirmish then
48009: LD_EXP 78
48013: NOT
48014: PUSH
48015: LD_EXP 76
48019: NOT
48020: OR
48021: IFFALSE 48025
// exit ;
48023: GO 48190
// for i = 1 to mc_bases do
48025: LD_ADDR_VAR 0 4
48029: PUSH
48030: DOUBLE
48031: LD_INT 1
48033: DEC
48034: ST_TO_ADDR
48035: LD_EXP 78
48039: PUSH
48040: FOR_TO
48041: IFFALSE 48188
// begin if sci in mc_bases [ i ] then
48043: LD_VAR 0 2
48047: PUSH
48048: LD_EXP 78
48052: PUSH
48053: LD_VAR 0 4
48057: ARRAY
48058: IN
48059: IFFALSE 48186
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48061: LD_ADDR_EXP 107
48065: PUSH
48066: LD_EXP 107
48070: PPUSH
48071: LD_VAR 0 4
48075: PUSH
48076: LD_EXP 107
48080: PUSH
48081: LD_VAR 0 4
48085: ARRAY
48086: PUSH
48087: LD_INT 1
48089: PLUS
48090: PUSH
48091: EMPTY
48092: LIST
48093: LIST
48094: PPUSH
48095: LD_VAR 0 1
48099: PPUSH
48100: CALL 57774 0 3
48104: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48105: LD_ADDR_VAR 0 5
48109: PUSH
48110: LD_EXP 78
48114: PUSH
48115: LD_VAR 0 4
48119: ARRAY
48120: PPUSH
48121: LD_INT 2
48123: PUSH
48124: LD_INT 30
48126: PUSH
48127: LD_INT 0
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: LD_INT 30
48136: PUSH
48137: LD_INT 1
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: LIST
48148: PPUSH
48149: CALL_OW 72
48153: PPUSH
48154: LD_VAR 0 1
48158: PPUSH
48159: CALL_OW 74
48163: ST_TO_ADDR
// if tmp then
48164: LD_VAR 0 5
48168: IFFALSE 48184
// ComStandNearbyBuilding ( ape , tmp ) ;
48170: LD_VAR 0 1
48174: PPUSH
48175: LD_VAR 0 5
48179: PPUSH
48180: CALL 54376 0 2
// break ;
48184: GO 48188
// end ; end ;
48186: GO 48040
48188: POP
48189: POP
// end ;
48190: LD_VAR 0 3
48194: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48195: LD_INT 0
48197: PPUSH
48198: PPUSH
48199: PPUSH
// if not mc_bases or not skirmish then
48200: LD_EXP 78
48204: NOT
48205: PUSH
48206: LD_EXP 76
48210: NOT
48211: OR
48212: IFFALSE 48216
// exit ;
48214: GO 48305
// for i = 1 to mc_bases do
48216: LD_ADDR_VAR 0 4
48220: PUSH
48221: DOUBLE
48222: LD_INT 1
48224: DEC
48225: ST_TO_ADDR
48226: LD_EXP 78
48230: PUSH
48231: FOR_TO
48232: IFFALSE 48303
// begin if building in mc_busy_turret_list [ i ] then
48234: LD_VAR 0 1
48238: PUSH
48239: LD_EXP 88
48243: PUSH
48244: LD_VAR 0 4
48248: ARRAY
48249: IN
48250: IFFALSE 48301
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48252: LD_ADDR_VAR 0 5
48256: PUSH
48257: LD_EXP 88
48261: PUSH
48262: LD_VAR 0 4
48266: ARRAY
48267: PUSH
48268: LD_VAR 0 1
48272: DIFF
48273: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48274: LD_ADDR_EXP 88
48278: PUSH
48279: LD_EXP 88
48283: PPUSH
48284: LD_VAR 0 4
48288: PPUSH
48289: LD_VAR 0 5
48293: PPUSH
48294: CALL_OW 1
48298: ST_TO_ADDR
// break ;
48299: GO 48303
// end ; end ;
48301: GO 48231
48303: POP
48304: POP
// end ;
48305: LD_VAR 0 3
48309: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48310: LD_INT 0
48312: PPUSH
48313: PPUSH
48314: PPUSH
// if not mc_bases or not skirmish then
48315: LD_EXP 78
48319: NOT
48320: PUSH
48321: LD_EXP 76
48325: NOT
48326: OR
48327: IFFALSE 48331
// exit ;
48329: GO 48530
// for i = 1 to mc_bases do
48331: LD_ADDR_VAR 0 5
48335: PUSH
48336: DOUBLE
48337: LD_INT 1
48339: DEC
48340: ST_TO_ADDR
48341: LD_EXP 78
48345: PUSH
48346: FOR_TO
48347: IFFALSE 48528
// if building in mc_bases [ i ] then
48349: LD_VAR 0 1
48353: PUSH
48354: LD_EXP 78
48358: PUSH
48359: LD_VAR 0 5
48363: ARRAY
48364: IN
48365: IFFALSE 48526
// begin tmp := mc_bases [ i ] diff building ;
48367: LD_ADDR_VAR 0 6
48371: PUSH
48372: LD_EXP 78
48376: PUSH
48377: LD_VAR 0 5
48381: ARRAY
48382: PUSH
48383: LD_VAR 0 1
48387: DIFF
48388: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48389: LD_ADDR_EXP 78
48393: PUSH
48394: LD_EXP 78
48398: PPUSH
48399: LD_VAR 0 5
48403: PPUSH
48404: LD_VAR 0 6
48408: PPUSH
48409: CALL_OW 1
48413: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48414: LD_VAR 0 1
48418: PUSH
48419: LD_EXP 86
48423: PUSH
48424: LD_VAR 0 5
48428: ARRAY
48429: IN
48430: IFFALSE 48469
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48432: LD_ADDR_EXP 86
48436: PUSH
48437: LD_EXP 86
48441: PPUSH
48442: LD_VAR 0 5
48446: PPUSH
48447: LD_EXP 86
48451: PUSH
48452: LD_VAR 0 5
48456: ARRAY
48457: PUSH
48458: LD_VAR 0 1
48462: DIFF
48463: PPUSH
48464: CALL_OW 1
48468: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48469: LD_VAR 0 1
48473: PUSH
48474: LD_EXP 87
48478: PUSH
48479: LD_VAR 0 5
48483: ARRAY
48484: IN
48485: IFFALSE 48524
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48487: LD_ADDR_EXP 87
48491: PUSH
48492: LD_EXP 87
48496: PPUSH
48497: LD_VAR 0 5
48501: PPUSH
48502: LD_EXP 87
48506: PUSH
48507: LD_VAR 0 5
48511: ARRAY
48512: PUSH
48513: LD_VAR 0 1
48517: DIFF
48518: PPUSH
48519: CALL_OW 1
48523: ST_TO_ADDR
// break ;
48524: GO 48528
// end ;
48526: GO 48346
48528: POP
48529: POP
// end ;
48530: LD_VAR 0 4
48534: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48535: LD_INT 0
48537: PPUSH
48538: PPUSH
48539: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48540: LD_EXP 78
48544: NOT
48545: PUSH
48546: LD_EXP 76
48550: NOT
48551: OR
48552: PUSH
48553: LD_VAR 0 3
48557: PUSH
48558: LD_EXP 104
48562: IN
48563: NOT
48564: OR
48565: IFFALSE 48569
// exit ;
48567: GO 48692
// for i = 1 to mc_vehicles do
48569: LD_ADDR_VAR 0 6
48573: PUSH
48574: DOUBLE
48575: LD_INT 1
48577: DEC
48578: ST_TO_ADDR
48579: LD_EXP 97
48583: PUSH
48584: FOR_TO
48585: IFFALSE 48690
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
48587: LD_VAR 0 2
48591: PUSH
48592: LD_EXP 97
48596: PUSH
48597: LD_VAR 0 6
48601: ARRAY
48602: IN
48603: PUSH
48604: LD_VAR 0 1
48608: PUSH
48609: LD_EXP 97
48613: PUSH
48614: LD_VAR 0 6
48618: ARRAY
48619: IN
48620: OR
48621: IFFALSE 48688
// begin tmp := mc_vehicles [ i ] diff old ;
48623: LD_ADDR_VAR 0 7
48627: PUSH
48628: LD_EXP 97
48632: PUSH
48633: LD_VAR 0 6
48637: ARRAY
48638: PUSH
48639: LD_VAR 0 2
48643: DIFF
48644: ST_TO_ADDR
// tmp := tmp diff new ;
48645: LD_ADDR_VAR 0 7
48649: PUSH
48650: LD_VAR 0 7
48654: PUSH
48655: LD_VAR 0 1
48659: DIFF
48660: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48661: LD_ADDR_EXP 97
48665: PUSH
48666: LD_EXP 97
48670: PPUSH
48671: LD_VAR 0 6
48675: PPUSH
48676: LD_VAR 0 7
48680: PPUSH
48681: CALL_OW 1
48685: ST_TO_ADDR
// break ;
48686: GO 48690
// end ;
48688: GO 48584
48690: POP
48691: POP
// end ;
48692: LD_VAR 0 5
48696: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48697: LD_INT 0
48699: PPUSH
48700: PPUSH
48701: PPUSH
48702: PPUSH
// if not mc_bases or not skirmish then
48703: LD_EXP 78
48707: NOT
48708: PUSH
48709: LD_EXP 76
48713: NOT
48714: OR
48715: IFFALSE 48719
// exit ;
48717: GO 49139
// repeat wait ( 0 0$1 ) ;
48719: LD_INT 35
48721: PPUSH
48722: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48726: LD_EXP 122
48730: NOT
48731: IFFALSE 48719
// mc_block_vehicle_constructed_thread := true ;
48733: LD_ADDR_EXP 122
48737: PUSH
48738: LD_INT 1
48740: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48741: LD_ADDR_VAR 0 5
48745: PUSH
48746: LD_VAR 0 1
48750: PPUSH
48751: CALL_OW 255
48755: ST_TO_ADDR
// for i = 1 to mc_bases do
48756: LD_ADDR_VAR 0 4
48760: PUSH
48761: DOUBLE
48762: LD_INT 1
48764: DEC
48765: ST_TO_ADDR
48766: LD_EXP 78
48770: PUSH
48771: FOR_TO
48772: IFFALSE 49129
// begin if factory in mc_bases [ i ] then
48774: LD_VAR 0 2
48778: PUSH
48779: LD_EXP 78
48783: PUSH
48784: LD_VAR 0 4
48788: ARRAY
48789: IN
48790: IFFALSE 49127
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48792: LD_EXP 100
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: PUSH
48803: LD_EXP 89
48807: PUSH
48808: LD_VAR 0 4
48812: ARRAY
48813: LESS
48814: PUSH
48815: LD_VAR 0 1
48819: PPUSH
48820: CALL_OW 264
48824: PUSH
48825: LD_INT 31
48827: PUSH
48828: LD_INT 32
48830: PUSH
48831: LD_INT 51
48833: PUSH
48834: LD_INT 89
48836: PUSH
48837: LD_INT 12
48839: PUSH
48840: LD_INT 30
48842: PUSH
48843: LD_INT 98
48845: PUSH
48846: LD_INT 11
48848: PUSH
48849: LD_INT 53
48851: PUSH
48852: LD_INT 14
48854: PUSH
48855: LD_INT 91
48857: PUSH
48858: LD_INT 29
48860: PUSH
48861: LD_INT 99
48863: PUSH
48864: LD_INT 13
48866: PUSH
48867: LD_INT 52
48869: PUSH
48870: LD_INT 88
48872: PUSH
48873: LD_INT 48
48875: PUSH
48876: LD_INT 8
48878: PUSH
48879: EMPTY
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: LIST
48887: LIST
48888: LIST
48889: LIST
48890: LIST
48891: LIST
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: IN
48899: NOT
48900: AND
48901: IFFALSE 48949
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48903: LD_ADDR_EXP 100
48907: PUSH
48908: LD_EXP 100
48912: PPUSH
48913: LD_VAR 0 4
48917: PUSH
48918: LD_EXP 100
48922: PUSH
48923: LD_VAR 0 4
48927: ARRAY
48928: PUSH
48929: LD_INT 1
48931: PLUS
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PPUSH
48937: LD_VAR 0 1
48941: PPUSH
48942: CALL 57774 0 3
48946: ST_TO_ADDR
48947: GO 48993
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48949: LD_ADDR_EXP 97
48953: PUSH
48954: LD_EXP 97
48958: PPUSH
48959: LD_VAR 0 4
48963: PUSH
48964: LD_EXP 97
48968: PUSH
48969: LD_VAR 0 4
48973: ARRAY
48974: PUSH
48975: LD_INT 1
48977: PLUS
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PPUSH
48983: LD_VAR 0 1
48987: PPUSH
48988: CALL 57774 0 3
48992: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
48993: LD_ADDR_EXP 122
48997: PUSH
48998: LD_INT 0
49000: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49001: LD_VAR 0 1
49005: PPUSH
49006: CALL_OW 263
49010: PUSH
49011: LD_INT 2
49013: EQUAL
49014: IFFALSE 49043
// begin repeat wait ( 0 0$3 ) ;
49016: LD_INT 105
49018: PPUSH
49019: CALL_OW 67
// Connect ( vehicle ) ;
49023: LD_VAR 0 1
49027: PPUSH
49028: CALL 60743 0 1
// until IsControledBy ( vehicle ) ;
49032: LD_VAR 0 1
49036: PPUSH
49037: CALL_OW 312
49041: IFFALSE 49016
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49043: LD_VAR 0 1
49047: PPUSH
49048: LD_EXP 102
49052: PUSH
49053: LD_VAR 0 4
49057: ARRAY
49058: PPUSH
49059: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49063: LD_VAR 0 1
49067: PPUSH
49068: CALL_OW 263
49072: PUSH
49073: LD_INT 1
49075: NONEQUAL
49076: IFFALSE 49080
// break ;
49078: GO 49129
// repeat wait ( 0 0$1 ) ;
49080: LD_INT 35
49082: PPUSH
49083: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49087: LD_VAR 0 1
49091: PPUSH
49092: LD_EXP 102
49096: PUSH
49097: LD_VAR 0 4
49101: ARRAY
49102: PPUSH
49103: CALL_OW 308
49107: IFFALSE 49080
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49109: LD_VAR 0 1
49113: PPUSH
49114: CALL_OW 311
49118: PPUSH
49119: CALL_OW 121
// exit ;
49123: POP
49124: POP
49125: GO 49139
// end ; end ;
49127: GO 48771
49129: POP
49130: POP
// mc_block_vehicle_constructed_thread := false ;
49131: LD_ADDR_EXP 122
49135: PUSH
49136: LD_INT 0
49138: ST_TO_ADDR
// end ;
49139: LD_VAR 0 3
49143: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49144: LD_INT 0
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
// if not mc_bases or not skirmish then
49150: LD_EXP 78
49154: NOT
49155: PUSH
49156: LD_EXP 76
49160: NOT
49161: OR
49162: IFFALSE 49166
// exit ;
49164: GO 49519
// repeat wait ( 0 0$1 ) ;
49166: LD_INT 35
49168: PPUSH
49169: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49173: LD_VAR 0 2
49177: PPUSH
49178: LD_VAR 0 3
49182: PPUSH
49183: CALL_OW 284
49187: IFFALSE 49166
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49189: LD_VAR 0 2
49193: PPUSH
49194: LD_VAR 0 3
49198: PPUSH
49199: CALL_OW 283
49203: PUSH
49204: LD_INT 4
49206: EQUAL
49207: IFFALSE 49211
// exit ;
49209: GO 49519
// for i = 1 to mc_bases do
49211: LD_ADDR_VAR 0 7
49215: PUSH
49216: DOUBLE
49217: LD_INT 1
49219: DEC
49220: ST_TO_ADDR
49221: LD_EXP 78
49225: PUSH
49226: FOR_TO
49227: IFFALSE 49517
// begin if mc_crates_area [ i ] then
49229: LD_EXP 96
49233: PUSH
49234: LD_VAR 0 7
49238: ARRAY
49239: IFFALSE 49350
// for j in mc_crates_area [ i ] do
49241: LD_ADDR_VAR 0 8
49245: PUSH
49246: LD_EXP 96
49250: PUSH
49251: LD_VAR 0 7
49255: ARRAY
49256: PUSH
49257: FOR_IN
49258: IFFALSE 49348
// if InArea ( x , y , j ) then
49260: LD_VAR 0 2
49264: PPUSH
49265: LD_VAR 0 3
49269: PPUSH
49270: LD_VAR 0 8
49274: PPUSH
49275: CALL_OW 309
49279: IFFALSE 49346
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49281: LD_ADDR_EXP 94
49285: PUSH
49286: LD_EXP 94
49290: PPUSH
49291: LD_VAR 0 7
49295: PUSH
49296: LD_EXP 94
49300: PUSH
49301: LD_VAR 0 7
49305: ARRAY
49306: PUSH
49307: LD_INT 1
49309: PLUS
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PPUSH
49315: LD_VAR 0 4
49319: PUSH
49320: LD_VAR 0 2
49324: PUSH
49325: LD_VAR 0 3
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: LIST
49334: PPUSH
49335: CALL 57774 0 3
49339: ST_TO_ADDR
// exit ;
49340: POP
49341: POP
49342: POP
49343: POP
49344: GO 49519
// end ;
49346: GO 49257
49348: POP
49349: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49350: LD_ADDR_VAR 0 9
49354: PUSH
49355: LD_EXP 78
49359: PUSH
49360: LD_VAR 0 7
49364: ARRAY
49365: PPUSH
49366: LD_INT 2
49368: PUSH
49369: LD_INT 30
49371: PUSH
49372: LD_INT 0
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PUSH
49379: LD_INT 30
49381: PUSH
49382: LD_INT 1
49384: PUSH
49385: EMPTY
49386: LIST
49387: LIST
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: LIST
49393: PPUSH
49394: CALL_OW 72
49398: ST_TO_ADDR
// if not depot then
49399: LD_VAR 0 9
49403: NOT
49404: IFFALSE 49408
// continue ;
49406: GO 49226
// for j in depot do
49408: LD_ADDR_VAR 0 8
49412: PUSH
49413: LD_VAR 0 9
49417: PUSH
49418: FOR_IN
49419: IFFALSE 49513
// if GetDistUnitXY ( j , x , y ) < 30 then
49421: LD_VAR 0 8
49425: PPUSH
49426: LD_VAR 0 2
49430: PPUSH
49431: LD_VAR 0 3
49435: PPUSH
49436: CALL_OW 297
49440: PUSH
49441: LD_INT 30
49443: LESS
49444: IFFALSE 49511
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49446: LD_ADDR_EXP 94
49450: PUSH
49451: LD_EXP 94
49455: PPUSH
49456: LD_VAR 0 7
49460: PUSH
49461: LD_EXP 94
49465: PUSH
49466: LD_VAR 0 7
49470: ARRAY
49471: PUSH
49472: LD_INT 1
49474: PLUS
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PPUSH
49480: LD_VAR 0 4
49484: PUSH
49485: LD_VAR 0 2
49489: PUSH
49490: LD_VAR 0 3
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: LIST
49499: PPUSH
49500: CALL 57774 0 3
49504: ST_TO_ADDR
// exit ;
49505: POP
49506: POP
49507: POP
49508: POP
49509: GO 49519
// end ;
49511: GO 49418
49513: POP
49514: POP
// end ;
49515: GO 49226
49517: POP
49518: POP
// end ;
49519: LD_VAR 0 6
49523: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49524: LD_INT 0
49526: PPUSH
49527: PPUSH
49528: PPUSH
49529: PPUSH
// if not mc_bases or not skirmish then
49530: LD_EXP 78
49534: NOT
49535: PUSH
49536: LD_EXP 76
49540: NOT
49541: OR
49542: IFFALSE 49546
// exit ;
49544: GO 49823
// side := GetSide ( lab ) ;
49546: LD_ADDR_VAR 0 4
49550: PUSH
49551: LD_VAR 0 2
49555: PPUSH
49556: CALL_OW 255
49560: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
49561: LD_VAR 0 4
49565: PUSH
49566: LD_EXP 104
49570: IN
49571: NOT
49572: PUSH
49573: LD_EXP 105
49577: NOT
49578: OR
49579: PUSH
49580: LD_EXP 78
49584: NOT
49585: OR
49586: IFFALSE 49590
// exit ;
49588: GO 49823
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
49590: LD_ADDR_EXP 105
49594: PUSH
49595: LD_EXP 105
49599: PPUSH
49600: LD_VAR 0 4
49604: PPUSH
49605: LD_EXP 105
49609: PUSH
49610: LD_VAR 0 4
49614: ARRAY
49615: PUSH
49616: LD_VAR 0 1
49620: DIFF
49621: PPUSH
49622: CALL_OW 1
49626: ST_TO_ADDR
// for i = 1 to mc_bases do
49627: LD_ADDR_VAR 0 5
49631: PUSH
49632: DOUBLE
49633: LD_INT 1
49635: DEC
49636: ST_TO_ADDR
49637: LD_EXP 78
49641: PUSH
49642: FOR_TO
49643: IFFALSE 49821
// begin if lab in mc_bases [ i ] then
49645: LD_VAR 0 2
49649: PUSH
49650: LD_EXP 78
49654: PUSH
49655: LD_VAR 0 5
49659: ARRAY
49660: IN
49661: IFFALSE 49819
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49663: LD_VAR 0 1
49667: PUSH
49668: LD_INT 11
49670: PUSH
49671: LD_INT 4
49673: PUSH
49674: LD_INT 3
49676: PUSH
49677: LD_INT 2
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: IN
49686: PUSH
49687: LD_EXP 108
49691: PUSH
49692: LD_VAR 0 5
49696: ARRAY
49697: AND
49698: IFFALSE 49819
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49700: LD_ADDR_VAR 0 6
49704: PUSH
49705: LD_EXP 108
49709: PUSH
49710: LD_VAR 0 5
49714: ARRAY
49715: PUSH
49716: LD_INT 1
49718: ARRAY
49719: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49720: LD_ADDR_EXP 108
49724: PUSH
49725: LD_EXP 108
49729: PPUSH
49730: LD_VAR 0 5
49734: PPUSH
49735: EMPTY
49736: PPUSH
49737: CALL_OW 1
49741: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49742: LD_VAR 0 6
49746: PPUSH
49747: LD_INT 0
49749: PPUSH
49750: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49754: LD_VAR 0 6
49758: PPUSH
49759: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49763: LD_ADDR_EXP 107
49767: PUSH
49768: LD_EXP 107
49772: PPUSH
49773: LD_VAR 0 5
49777: PPUSH
49778: LD_EXP 107
49782: PUSH
49783: LD_VAR 0 5
49787: ARRAY
49788: PPUSH
49789: LD_INT 1
49791: PPUSH
49792: LD_VAR 0 6
49796: PPUSH
49797: CALL_OW 2
49801: PPUSH
49802: CALL_OW 1
49806: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49807: LD_VAR 0 5
49811: PPUSH
49812: LD_INT 112
49814: PPUSH
49815: CALL 26287 0 2
// end ; end ; end ;
49819: GO 49642
49821: POP
49822: POP
// end ;
49823: LD_VAR 0 3
49827: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49828: LD_INT 0
49830: PPUSH
49831: PPUSH
49832: PPUSH
49833: PPUSH
49834: PPUSH
49835: PPUSH
49836: PPUSH
49837: PPUSH
// if not mc_bases or not skirmish then
49838: LD_EXP 78
49842: NOT
49843: PUSH
49844: LD_EXP 76
49848: NOT
49849: OR
49850: IFFALSE 49854
// exit ;
49852: GO 51223
// for i = 1 to mc_bases do
49854: LD_ADDR_VAR 0 3
49858: PUSH
49859: DOUBLE
49860: LD_INT 1
49862: DEC
49863: ST_TO_ADDR
49864: LD_EXP 78
49868: PUSH
49869: FOR_TO
49870: IFFALSE 51221
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49872: LD_VAR 0 1
49876: PUSH
49877: LD_EXP 78
49881: PUSH
49882: LD_VAR 0 3
49886: ARRAY
49887: IN
49888: PUSH
49889: LD_VAR 0 1
49893: PUSH
49894: LD_EXP 85
49898: PUSH
49899: LD_VAR 0 3
49903: ARRAY
49904: IN
49905: OR
49906: PUSH
49907: LD_VAR 0 1
49911: PUSH
49912: LD_EXP 100
49916: PUSH
49917: LD_VAR 0 3
49921: ARRAY
49922: IN
49923: OR
49924: PUSH
49925: LD_VAR 0 1
49929: PUSH
49930: LD_EXP 97
49934: PUSH
49935: LD_VAR 0 3
49939: ARRAY
49940: IN
49941: OR
49942: PUSH
49943: LD_VAR 0 1
49947: PUSH
49948: LD_EXP 107
49952: PUSH
49953: LD_VAR 0 3
49957: ARRAY
49958: IN
49959: OR
49960: PUSH
49961: LD_VAR 0 1
49965: PUSH
49966: LD_EXP 108
49970: PUSH
49971: LD_VAR 0 3
49975: ARRAY
49976: IN
49977: OR
49978: IFFALSE 51219
// begin if un in mc_ape [ i ] then
49980: LD_VAR 0 1
49984: PUSH
49985: LD_EXP 107
49989: PUSH
49990: LD_VAR 0 3
49994: ARRAY
49995: IN
49996: IFFALSE 50035
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49998: LD_ADDR_EXP 107
50002: PUSH
50003: LD_EXP 107
50007: PPUSH
50008: LD_VAR 0 3
50012: PPUSH
50013: LD_EXP 107
50017: PUSH
50018: LD_VAR 0 3
50022: ARRAY
50023: PUSH
50024: LD_VAR 0 1
50028: DIFF
50029: PPUSH
50030: CALL_OW 1
50034: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50035: LD_VAR 0 1
50039: PUSH
50040: LD_EXP 108
50044: PUSH
50045: LD_VAR 0 3
50049: ARRAY
50050: IN
50051: IFFALSE 50075
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50053: LD_ADDR_EXP 108
50057: PUSH
50058: LD_EXP 108
50062: PPUSH
50063: LD_VAR 0 3
50067: PPUSH
50068: EMPTY
50069: PPUSH
50070: CALL_OW 1
50074: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50075: LD_VAR 0 1
50079: PPUSH
50080: CALL_OW 247
50084: PUSH
50085: LD_INT 2
50087: EQUAL
50088: PUSH
50089: LD_VAR 0 1
50093: PPUSH
50094: CALL_OW 110
50098: PUSH
50099: LD_INT 20
50101: EQUAL
50102: PUSH
50103: LD_VAR 0 1
50107: PUSH
50108: LD_EXP 100
50112: PUSH
50113: LD_VAR 0 3
50117: ARRAY
50118: IN
50119: OR
50120: PUSH
50121: LD_VAR 0 1
50125: PPUSH
50126: CALL_OW 264
50130: PUSH
50131: LD_INT 12
50133: PUSH
50134: LD_INT 51
50136: PUSH
50137: LD_INT 89
50139: PUSH
50140: LD_INT 32
50142: PUSH
50143: LD_INT 13
50145: PUSH
50146: LD_INT 52
50148: PUSH
50149: LD_INT 31
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: LIST
50156: LIST
50157: LIST
50158: LIST
50159: LIST
50160: IN
50161: OR
50162: AND
50163: IFFALSE 50471
// begin if un in mc_defender [ i ] then
50165: LD_VAR 0 1
50169: PUSH
50170: LD_EXP 100
50174: PUSH
50175: LD_VAR 0 3
50179: ARRAY
50180: IN
50181: IFFALSE 50220
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50183: LD_ADDR_EXP 100
50187: PUSH
50188: LD_EXP 100
50192: PPUSH
50193: LD_VAR 0 3
50197: PPUSH
50198: LD_EXP 100
50202: PUSH
50203: LD_VAR 0 3
50207: ARRAY
50208: PUSH
50209: LD_VAR 0 1
50213: DIFF
50214: PPUSH
50215: CALL_OW 1
50219: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50220: LD_ADDR_VAR 0 8
50224: PUSH
50225: LD_VAR 0 3
50229: PPUSH
50230: LD_INT 3
50232: PPUSH
50233: CALL 46841 0 2
50237: ST_TO_ADDR
// if fac then
50238: LD_VAR 0 8
50242: IFFALSE 50471
// begin for j in fac do
50244: LD_ADDR_VAR 0 4
50248: PUSH
50249: LD_VAR 0 8
50253: PUSH
50254: FOR_IN
50255: IFFALSE 50469
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50257: LD_ADDR_VAR 0 9
50261: PUSH
50262: LD_VAR 0 8
50266: PPUSH
50267: LD_VAR 0 1
50271: PPUSH
50272: CALL_OW 265
50276: PPUSH
50277: LD_VAR 0 1
50281: PPUSH
50282: CALL_OW 262
50286: PPUSH
50287: LD_VAR 0 1
50291: PPUSH
50292: CALL_OW 263
50296: PPUSH
50297: LD_VAR 0 1
50301: PPUSH
50302: CALL_OW 264
50306: PPUSH
50307: CALL 55272 0 5
50311: ST_TO_ADDR
// if components then
50312: LD_VAR 0 9
50316: IFFALSE 50467
// begin if GetWeapon ( un ) = ar_control_tower then
50318: LD_VAR 0 1
50322: PPUSH
50323: CALL_OW 264
50327: PUSH
50328: LD_INT 31
50330: EQUAL
50331: IFFALSE 50448
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50333: LD_VAR 0 1
50337: PPUSH
50338: CALL_OW 311
50342: PPUSH
50343: LD_INT 0
50345: PPUSH
50346: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50350: LD_ADDR_EXP 118
50354: PUSH
50355: LD_EXP 118
50359: PPUSH
50360: LD_VAR 0 3
50364: PPUSH
50365: LD_EXP 118
50369: PUSH
50370: LD_VAR 0 3
50374: ARRAY
50375: PUSH
50376: LD_VAR 0 1
50380: PPUSH
50381: CALL_OW 311
50385: DIFF
50386: PPUSH
50387: CALL_OW 1
50391: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50392: LD_ADDR_VAR 0 7
50396: PUSH
50397: LD_EXP 99
50401: PUSH
50402: LD_VAR 0 3
50406: ARRAY
50407: PPUSH
50408: LD_INT 1
50410: PPUSH
50411: LD_VAR 0 9
50415: PPUSH
50416: CALL_OW 2
50420: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50421: LD_ADDR_EXP 99
50425: PUSH
50426: LD_EXP 99
50430: PPUSH
50431: LD_VAR 0 3
50435: PPUSH
50436: LD_VAR 0 7
50440: PPUSH
50441: CALL_OW 1
50445: ST_TO_ADDR
// end else
50446: GO 50465
// MC_InsertProduceList ( i , [ components ] ) ;
50448: LD_VAR 0 3
50452: PPUSH
50453: LD_VAR 0 9
50457: PUSH
50458: EMPTY
50459: LIST
50460: PPUSH
50461: CALL 46386 0 2
// break ;
50465: GO 50469
// end ; end ;
50467: GO 50254
50469: POP
50470: POP
// end ; end ; if GetType ( un ) = unit_building then
50471: LD_VAR 0 1
50475: PPUSH
50476: CALL_OW 247
50480: PUSH
50481: LD_INT 3
50483: EQUAL
50484: IFFALSE 50887
// begin btype := GetBType ( un ) ;
50486: LD_ADDR_VAR 0 5
50490: PUSH
50491: LD_VAR 0 1
50495: PPUSH
50496: CALL_OW 266
50500: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50501: LD_VAR 0 5
50505: PUSH
50506: LD_INT 29
50508: PUSH
50509: LD_INT 30
50511: PUSH
50512: EMPTY
50513: LIST
50514: LIST
50515: IN
50516: IFFALSE 50589
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50518: LD_VAR 0 1
50522: PPUSH
50523: CALL_OW 250
50527: PPUSH
50528: LD_VAR 0 1
50532: PPUSH
50533: CALL_OW 251
50537: PPUSH
50538: LD_VAR 0 1
50542: PPUSH
50543: CALL_OW 255
50547: PPUSH
50548: CALL_OW 440
50552: NOT
50553: IFFALSE 50589
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
50555: LD_VAR 0 1
50559: PPUSH
50560: CALL_OW 250
50564: PPUSH
50565: LD_VAR 0 1
50569: PPUSH
50570: CALL_OW 251
50574: PPUSH
50575: LD_VAR 0 1
50579: PPUSH
50580: CALL_OW 255
50584: PPUSH
50585: CALL_OW 441
// end ; if btype = b_warehouse then
50589: LD_VAR 0 5
50593: PUSH
50594: LD_INT 1
50596: EQUAL
50597: IFFALSE 50615
// begin btype := b_depot ;
50599: LD_ADDR_VAR 0 5
50603: PUSH
50604: LD_INT 0
50606: ST_TO_ADDR
// pos := 1 ;
50607: LD_ADDR_VAR 0 6
50611: PUSH
50612: LD_INT 1
50614: ST_TO_ADDR
// end ; if btype = b_factory then
50615: LD_VAR 0 5
50619: PUSH
50620: LD_INT 3
50622: EQUAL
50623: IFFALSE 50641
// begin btype := b_workshop ;
50625: LD_ADDR_VAR 0 5
50629: PUSH
50630: LD_INT 2
50632: ST_TO_ADDR
// pos := 1 ;
50633: LD_ADDR_VAR 0 6
50637: PUSH
50638: LD_INT 1
50640: ST_TO_ADDR
// end ; if btype = b_barracks then
50641: LD_VAR 0 5
50645: PUSH
50646: LD_INT 5
50648: EQUAL
50649: IFFALSE 50659
// btype := b_armoury ;
50651: LD_ADDR_VAR 0 5
50655: PUSH
50656: LD_INT 4
50658: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50659: LD_VAR 0 5
50663: PUSH
50664: LD_INT 7
50666: PUSH
50667: LD_INT 8
50669: PUSH
50670: EMPTY
50671: LIST
50672: LIST
50673: IN
50674: IFFALSE 50684
// btype := b_lab ;
50676: LD_ADDR_VAR 0 5
50680: PUSH
50681: LD_INT 6
50683: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50684: LD_ADDR_EXP 83
50688: PUSH
50689: LD_EXP 83
50693: PPUSH
50694: LD_VAR 0 3
50698: PUSH
50699: LD_EXP 83
50703: PUSH
50704: LD_VAR 0 3
50708: ARRAY
50709: PUSH
50710: LD_INT 1
50712: PLUS
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PPUSH
50718: LD_VAR 0 5
50722: PUSH
50723: LD_VAR 0 1
50727: PPUSH
50728: CALL_OW 250
50732: PUSH
50733: LD_VAR 0 1
50737: PPUSH
50738: CALL_OW 251
50742: PUSH
50743: LD_VAR 0 1
50747: PPUSH
50748: CALL_OW 254
50752: PUSH
50753: EMPTY
50754: LIST
50755: LIST
50756: LIST
50757: LIST
50758: PPUSH
50759: CALL 57774 0 3
50763: ST_TO_ADDR
// if pos = 1 then
50764: LD_VAR 0 6
50768: PUSH
50769: LD_INT 1
50771: EQUAL
50772: IFFALSE 50887
// begin tmp := mc_build_list [ i ] ;
50774: LD_ADDR_VAR 0 7
50778: PUSH
50779: LD_EXP 83
50783: PUSH
50784: LD_VAR 0 3
50788: ARRAY
50789: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50790: LD_VAR 0 7
50794: PPUSH
50795: LD_INT 2
50797: PUSH
50798: LD_INT 30
50800: PUSH
50801: LD_INT 0
50803: PUSH
50804: EMPTY
50805: LIST
50806: LIST
50807: PUSH
50808: LD_INT 30
50810: PUSH
50811: LD_INT 1
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: LIST
50822: PPUSH
50823: CALL_OW 72
50827: IFFALSE 50837
// pos := 2 ;
50829: LD_ADDR_VAR 0 6
50833: PUSH
50834: LD_INT 2
50836: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50837: LD_ADDR_VAR 0 7
50841: PUSH
50842: LD_VAR 0 7
50846: PPUSH
50847: LD_VAR 0 6
50851: PPUSH
50852: LD_VAR 0 7
50856: PPUSH
50857: CALL 58100 0 3
50861: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50862: LD_ADDR_EXP 83
50866: PUSH
50867: LD_EXP 83
50871: PPUSH
50872: LD_VAR 0 3
50876: PPUSH
50877: LD_VAR 0 7
50881: PPUSH
50882: CALL_OW 1
50886: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50887: LD_VAR 0 1
50891: PUSH
50892: LD_EXP 78
50896: PUSH
50897: LD_VAR 0 3
50901: ARRAY
50902: IN
50903: IFFALSE 50942
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50905: LD_ADDR_EXP 78
50909: PUSH
50910: LD_EXP 78
50914: PPUSH
50915: LD_VAR 0 3
50919: PPUSH
50920: LD_EXP 78
50924: PUSH
50925: LD_VAR 0 3
50929: ARRAY
50930: PUSH
50931: LD_VAR 0 1
50935: DIFF
50936: PPUSH
50937: CALL_OW 1
50941: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50942: LD_VAR 0 1
50946: PUSH
50947: LD_EXP 85
50951: PUSH
50952: LD_VAR 0 3
50956: ARRAY
50957: IN
50958: IFFALSE 50997
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50960: LD_ADDR_EXP 85
50964: PUSH
50965: LD_EXP 85
50969: PPUSH
50970: LD_VAR 0 3
50974: PPUSH
50975: LD_EXP 85
50979: PUSH
50980: LD_VAR 0 3
50984: ARRAY
50985: PUSH
50986: LD_VAR 0 1
50990: DIFF
50991: PPUSH
50992: CALL_OW 1
50996: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50997: LD_VAR 0 1
51001: PUSH
51002: LD_EXP 97
51006: PUSH
51007: LD_VAR 0 3
51011: ARRAY
51012: IN
51013: IFFALSE 51052
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51015: LD_ADDR_EXP 97
51019: PUSH
51020: LD_EXP 97
51024: PPUSH
51025: LD_VAR 0 3
51029: PPUSH
51030: LD_EXP 97
51034: PUSH
51035: LD_VAR 0 3
51039: ARRAY
51040: PUSH
51041: LD_VAR 0 1
51045: DIFF
51046: PPUSH
51047: CALL_OW 1
51051: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51052: LD_VAR 0 1
51056: PUSH
51057: LD_EXP 100
51061: PUSH
51062: LD_VAR 0 3
51066: ARRAY
51067: IN
51068: IFFALSE 51107
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51070: LD_ADDR_EXP 100
51074: PUSH
51075: LD_EXP 100
51079: PPUSH
51080: LD_VAR 0 3
51084: PPUSH
51085: LD_EXP 100
51089: PUSH
51090: LD_VAR 0 3
51094: ARRAY
51095: PUSH
51096: LD_VAR 0 1
51100: DIFF
51101: PPUSH
51102: CALL_OW 1
51106: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51107: LD_VAR 0 1
51111: PUSH
51112: LD_EXP 87
51116: PUSH
51117: LD_VAR 0 3
51121: ARRAY
51122: IN
51123: IFFALSE 51162
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51125: LD_ADDR_EXP 87
51129: PUSH
51130: LD_EXP 87
51134: PPUSH
51135: LD_VAR 0 3
51139: PPUSH
51140: LD_EXP 87
51144: PUSH
51145: LD_VAR 0 3
51149: ARRAY
51150: PUSH
51151: LD_VAR 0 1
51155: DIFF
51156: PPUSH
51157: CALL_OW 1
51161: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51162: LD_VAR 0 1
51166: PUSH
51167: LD_EXP 86
51171: PUSH
51172: LD_VAR 0 3
51176: ARRAY
51177: IN
51178: IFFALSE 51217
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51180: LD_ADDR_EXP 86
51184: PUSH
51185: LD_EXP 86
51189: PPUSH
51190: LD_VAR 0 3
51194: PPUSH
51195: LD_EXP 86
51199: PUSH
51200: LD_VAR 0 3
51204: ARRAY
51205: PUSH
51206: LD_VAR 0 1
51210: DIFF
51211: PPUSH
51212: CALL_OW 1
51216: ST_TO_ADDR
// end ; break ;
51217: GO 51221
// end ;
51219: GO 49869
51221: POP
51222: POP
// end ;
51223: LD_VAR 0 2
51227: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51228: LD_INT 0
51230: PPUSH
51231: PPUSH
51232: PPUSH
// if not mc_bases or not skirmish then
51233: LD_EXP 78
51237: NOT
51238: PUSH
51239: LD_EXP 76
51243: NOT
51244: OR
51245: IFFALSE 51249
// exit ;
51247: GO 51464
// for i = 1 to mc_bases do
51249: LD_ADDR_VAR 0 3
51253: PUSH
51254: DOUBLE
51255: LD_INT 1
51257: DEC
51258: ST_TO_ADDR
51259: LD_EXP 78
51263: PUSH
51264: FOR_TO
51265: IFFALSE 51462
// begin if building in mc_construct_list [ i ] then
51267: LD_VAR 0 1
51271: PUSH
51272: LD_EXP 85
51276: PUSH
51277: LD_VAR 0 3
51281: ARRAY
51282: IN
51283: IFFALSE 51460
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51285: LD_ADDR_EXP 85
51289: PUSH
51290: LD_EXP 85
51294: PPUSH
51295: LD_VAR 0 3
51299: PPUSH
51300: LD_EXP 85
51304: PUSH
51305: LD_VAR 0 3
51309: ARRAY
51310: PUSH
51311: LD_VAR 0 1
51315: DIFF
51316: PPUSH
51317: CALL_OW 1
51321: ST_TO_ADDR
// if building in mc_lab [ i ] then
51322: LD_VAR 0 1
51326: PUSH
51327: LD_EXP 111
51331: PUSH
51332: LD_VAR 0 3
51336: ARRAY
51337: IN
51338: IFFALSE 51393
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51340: LD_ADDR_EXP 112
51344: PUSH
51345: LD_EXP 112
51349: PPUSH
51350: LD_VAR 0 3
51354: PPUSH
51355: LD_EXP 112
51359: PUSH
51360: LD_VAR 0 3
51364: ARRAY
51365: PPUSH
51366: LD_INT 1
51368: PPUSH
51369: LD_EXP 112
51373: PUSH
51374: LD_VAR 0 3
51378: ARRAY
51379: PPUSH
51380: LD_INT 0
51382: PPUSH
51383: CALL 57192 0 4
51387: PPUSH
51388: CALL_OW 1
51392: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51393: LD_VAR 0 1
51397: PUSH
51398: LD_EXP 78
51402: PUSH
51403: LD_VAR 0 3
51407: ARRAY
51408: IN
51409: NOT
51410: IFFALSE 51456
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51412: LD_ADDR_EXP 78
51416: PUSH
51417: LD_EXP 78
51421: PPUSH
51422: LD_VAR 0 3
51426: PUSH
51427: LD_EXP 78
51431: PUSH
51432: LD_VAR 0 3
51436: ARRAY
51437: PUSH
51438: LD_INT 1
51440: PLUS
51441: PUSH
51442: EMPTY
51443: LIST
51444: LIST
51445: PPUSH
51446: LD_VAR 0 1
51450: PPUSH
51451: CALL 57774 0 3
51455: ST_TO_ADDR
// exit ;
51456: POP
51457: POP
51458: GO 51464
// end ; end ;
51460: GO 51264
51462: POP
51463: POP
// end ;
51464: LD_VAR 0 2
51468: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51469: LD_INT 0
51471: PPUSH
51472: PPUSH
51473: PPUSH
51474: PPUSH
51475: PPUSH
51476: PPUSH
51477: PPUSH
// if not mc_bases or not skirmish then
51478: LD_EXP 78
51482: NOT
51483: PUSH
51484: LD_EXP 76
51488: NOT
51489: OR
51490: IFFALSE 51494
// exit ;
51492: GO 52155
// for i = 1 to mc_bases do
51494: LD_ADDR_VAR 0 3
51498: PUSH
51499: DOUBLE
51500: LD_INT 1
51502: DEC
51503: ST_TO_ADDR
51504: LD_EXP 78
51508: PUSH
51509: FOR_TO
51510: IFFALSE 52153
// begin if building in mc_construct_list [ i ] then
51512: LD_VAR 0 1
51516: PUSH
51517: LD_EXP 85
51521: PUSH
51522: LD_VAR 0 3
51526: ARRAY
51527: IN
51528: IFFALSE 52151
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51530: LD_ADDR_EXP 85
51534: PUSH
51535: LD_EXP 85
51539: PPUSH
51540: LD_VAR 0 3
51544: PPUSH
51545: LD_EXP 85
51549: PUSH
51550: LD_VAR 0 3
51554: ARRAY
51555: PUSH
51556: LD_VAR 0 1
51560: DIFF
51561: PPUSH
51562: CALL_OW 1
51566: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51567: LD_ADDR_EXP 78
51571: PUSH
51572: LD_EXP 78
51576: PPUSH
51577: LD_VAR 0 3
51581: PUSH
51582: LD_EXP 78
51586: PUSH
51587: LD_VAR 0 3
51591: ARRAY
51592: PUSH
51593: LD_INT 1
51595: PLUS
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PPUSH
51601: LD_VAR 0 1
51605: PPUSH
51606: CALL 57774 0 3
51610: ST_TO_ADDR
// btype := GetBType ( building ) ;
51611: LD_ADDR_VAR 0 5
51615: PUSH
51616: LD_VAR 0 1
51620: PPUSH
51621: CALL_OW 266
51625: ST_TO_ADDR
// side := GetSide ( building ) ;
51626: LD_ADDR_VAR 0 8
51630: PUSH
51631: LD_VAR 0 1
51635: PPUSH
51636: CALL_OW 255
51640: ST_TO_ADDR
// if btype = b_lab then
51641: LD_VAR 0 5
51645: PUSH
51646: LD_INT 6
51648: EQUAL
51649: IFFALSE 51699
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51651: LD_ADDR_EXP 111
51655: PUSH
51656: LD_EXP 111
51660: PPUSH
51661: LD_VAR 0 3
51665: PUSH
51666: LD_EXP 111
51670: PUSH
51671: LD_VAR 0 3
51675: ARRAY
51676: PUSH
51677: LD_INT 1
51679: PLUS
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PPUSH
51685: LD_VAR 0 1
51689: PPUSH
51690: CALL 57774 0 3
51694: ST_TO_ADDR
// exit ;
51695: POP
51696: POP
51697: GO 52155
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51699: LD_VAR 0 5
51703: PUSH
51704: LD_INT 0
51706: PUSH
51707: LD_INT 2
51709: PUSH
51710: LD_INT 4
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: LIST
51717: IN
51718: IFFALSE 51842
// begin if btype = b_armoury then
51720: LD_VAR 0 5
51724: PUSH
51725: LD_INT 4
51727: EQUAL
51728: IFFALSE 51738
// btype := b_barracks ;
51730: LD_ADDR_VAR 0 5
51734: PUSH
51735: LD_INT 5
51737: ST_TO_ADDR
// if btype = b_depot then
51738: LD_VAR 0 5
51742: PUSH
51743: LD_INT 0
51745: EQUAL
51746: IFFALSE 51756
// btype := b_warehouse ;
51748: LD_ADDR_VAR 0 5
51752: PUSH
51753: LD_INT 1
51755: ST_TO_ADDR
// if btype = b_workshop then
51756: LD_VAR 0 5
51760: PUSH
51761: LD_INT 2
51763: EQUAL
51764: IFFALSE 51774
// btype := b_factory ;
51766: LD_ADDR_VAR 0 5
51770: PUSH
51771: LD_INT 3
51773: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51774: LD_VAR 0 5
51778: PPUSH
51779: LD_VAR 0 8
51783: PPUSH
51784: CALL_OW 323
51788: PUSH
51789: LD_INT 1
51791: EQUAL
51792: IFFALSE 51838
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51794: LD_ADDR_EXP 110
51798: PUSH
51799: LD_EXP 110
51803: PPUSH
51804: LD_VAR 0 3
51808: PUSH
51809: LD_EXP 110
51813: PUSH
51814: LD_VAR 0 3
51818: ARRAY
51819: PUSH
51820: LD_INT 1
51822: PLUS
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: PPUSH
51828: LD_VAR 0 1
51832: PPUSH
51833: CALL 57774 0 3
51837: ST_TO_ADDR
// exit ;
51838: POP
51839: POP
51840: GO 52155
// end ; if btype in [ b_bunker , b_turret ] then
51842: LD_VAR 0 5
51846: PUSH
51847: LD_INT 32
51849: PUSH
51850: LD_INT 33
51852: PUSH
51853: EMPTY
51854: LIST
51855: LIST
51856: IN
51857: IFFALSE 52147
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51859: LD_ADDR_EXP 86
51863: PUSH
51864: LD_EXP 86
51868: PPUSH
51869: LD_VAR 0 3
51873: PUSH
51874: LD_EXP 86
51878: PUSH
51879: LD_VAR 0 3
51883: ARRAY
51884: PUSH
51885: LD_INT 1
51887: PLUS
51888: PUSH
51889: EMPTY
51890: LIST
51891: LIST
51892: PPUSH
51893: LD_VAR 0 1
51897: PPUSH
51898: CALL 57774 0 3
51902: ST_TO_ADDR
// if btype = b_bunker then
51903: LD_VAR 0 5
51907: PUSH
51908: LD_INT 32
51910: EQUAL
51911: IFFALSE 52147
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51913: LD_ADDR_EXP 87
51917: PUSH
51918: LD_EXP 87
51922: PPUSH
51923: LD_VAR 0 3
51927: PUSH
51928: LD_EXP 87
51932: PUSH
51933: LD_VAR 0 3
51937: ARRAY
51938: PUSH
51939: LD_INT 1
51941: PLUS
51942: PUSH
51943: EMPTY
51944: LIST
51945: LIST
51946: PPUSH
51947: LD_VAR 0 1
51951: PPUSH
51952: CALL 57774 0 3
51956: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51957: LD_ADDR_VAR 0 6
51961: PUSH
51962: LD_EXP 78
51966: PUSH
51967: LD_VAR 0 3
51971: ARRAY
51972: PPUSH
51973: LD_INT 25
51975: PUSH
51976: LD_INT 1
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PUSH
51983: LD_INT 3
51985: PUSH
51986: LD_INT 54
51988: PUSH
51989: EMPTY
51990: LIST
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: PPUSH
52000: CALL_OW 72
52004: ST_TO_ADDR
// if tmp then
52005: LD_VAR 0 6
52009: IFFALSE 52015
// exit ;
52011: POP
52012: POP
52013: GO 52155
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52015: LD_ADDR_VAR 0 6
52019: PUSH
52020: LD_EXP 78
52024: PUSH
52025: LD_VAR 0 3
52029: ARRAY
52030: PPUSH
52031: LD_INT 2
52033: PUSH
52034: LD_INT 30
52036: PUSH
52037: LD_INT 4
52039: PUSH
52040: EMPTY
52041: LIST
52042: LIST
52043: PUSH
52044: LD_INT 30
52046: PUSH
52047: LD_INT 5
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: LIST
52058: PPUSH
52059: CALL_OW 72
52063: ST_TO_ADDR
// if not tmp then
52064: LD_VAR 0 6
52068: NOT
52069: IFFALSE 52075
// exit ;
52071: POP
52072: POP
52073: GO 52155
// for j in tmp do
52075: LD_ADDR_VAR 0 4
52079: PUSH
52080: LD_VAR 0 6
52084: PUSH
52085: FOR_IN
52086: IFFALSE 52145
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52088: LD_ADDR_VAR 0 7
52092: PUSH
52093: LD_VAR 0 4
52097: PPUSH
52098: CALL_OW 313
52102: PPUSH
52103: LD_INT 25
52105: PUSH
52106: LD_INT 1
52108: PUSH
52109: EMPTY
52110: LIST
52111: LIST
52112: PPUSH
52113: CALL_OW 72
52117: ST_TO_ADDR
// if units then
52118: LD_VAR 0 7
52122: IFFALSE 52143
// begin ComExitBuilding ( units [ 1 ] ) ;
52124: LD_VAR 0 7
52128: PUSH
52129: LD_INT 1
52131: ARRAY
52132: PPUSH
52133: CALL_OW 122
// exit ;
52137: POP
52138: POP
52139: POP
52140: POP
52141: GO 52155
// end ; end ;
52143: GO 52085
52145: POP
52146: POP
// end ; end ; exit ;
52147: POP
52148: POP
52149: GO 52155
// end ; end ;
52151: GO 51509
52153: POP
52154: POP
// end ;
52155: LD_VAR 0 2
52159: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52160: LD_INT 0
52162: PPUSH
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
// if not mc_bases or not skirmish then
52169: LD_EXP 78
52173: NOT
52174: PUSH
52175: LD_EXP 76
52179: NOT
52180: OR
52181: IFFALSE 52185
// exit ;
52183: GO 52450
// btype := GetBType ( building ) ;
52185: LD_ADDR_VAR 0 6
52189: PUSH
52190: LD_VAR 0 1
52194: PPUSH
52195: CALL_OW 266
52199: ST_TO_ADDR
// x := GetX ( building ) ;
52200: LD_ADDR_VAR 0 7
52204: PUSH
52205: LD_VAR 0 1
52209: PPUSH
52210: CALL_OW 250
52214: ST_TO_ADDR
// y := GetY ( building ) ;
52215: LD_ADDR_VAR 0 8
52219: PUSH
52220: LD_VAR 0 1
52224: PPUSH
52225: CALL_OW 251
52229: ST_TO_ADDR
// d := GetDir ( building ) ;
52230: LD_ADDR_VAR 0 9
52234: PUSH
52235: LD_VAR 0 1
52239: PPUSH
52240: CALL_OW 254
52244: ST_TO_ADDR
// for i = 1 to mc_bases do
52245: LD_ADDR_VAR 0 4
52249: PUSH
52250: DOUBLE
52251: LD_INT 1
52253: DEC
52254: ST_TO_ADDR
52255: LD_EXP 78
52259: PUSH
52260: FOR_TO
52261: IFFALSE 52448
// begin if not mc_build_list [ i ] then
52263: LD_EXP 83
52267: PUSH
52268: LD_VAR 0 4
52272: ARRAY
52273: NOT
52274: IFFALSE 52278
// continue ;
52276: GO 52260
// for j := 1 to mc_build_list [ i ] do
52278: LD_ADDR_VAR 0 5
52282: PUSH
52283: DOUBLE
52284: LD_INT 1
52286: DEC
52287: ST_TO_ADDR
52288: LD_EXP 83
52292: PUSH
52293: LD_VAR 0 4
52297: ARRAY
52298: PUSH
52299: FOR_TO
52300: IFFALSE 52444
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52302: LD_VAR 0 6
52306: PUSH
52307: LD_VAR 0 7
52311: PUSH
52312: LD_VAR 0 8
52316: PUSH
52317: LD_VAR 0 9
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: PPUSH
52328: LD_EXP 83
52332: PUSH
52333: LD_VAR 0 4
52337: ARRAY
52338: PUSH
52339: LD_VAR 0 5
52343: ARRAY
52344: PPUSH
52345: CALL 63954 0 2
52349: IFFALSE 52442
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52351: LD_ADDR_EXP 83
52355: PUSH
52356: LD_EXP 83
52360: PPUSH
52361: LD_VAR 0 4
52365: PPUSH
52366: LD_EXP 83
52370: PUSH
52371: LD_VAR 0 4
52375: ARRAY
52376: PPUSH
52377: LD_VAR 0 5
52381: PPUSH
52382: CALL_OW 3
52386: PPUSH
52387: CALL_OW 1
52391: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52392: LD_ADDR_EXP 85
52396: PUSH
52397: LD_EXP 85
52401: PPUSH
52402: LD_VAR 0 4
52406: PUSH
52407: LD_EXP 85
52411: PUSH
52412: LD_VAR 0 4
52416: ARRAY
52417: PUSH
52418: LD_INT 1
52420: PLUS
52421: PUSH
52422: EMPTY
52423: LIST
52424: LIST
52425: PPUSH
52426: LD_VAR 0 1
52430: PPUSH
52431: CALL 57774 0 3
52435: ST_TO_ADDR
// exit ;
52436: POP
52437: POP
52438: POP
52439: POP
52440: GO 52450
// end ;
52442: GO 52299
52444: POP
52445: POP
// end ;
52446: GO 52260
52448: POP
52449: POP
// end ;
52450: LD_VAR 0 3
52454: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52455: LD_INT 0
52457: PPUSH
52458: PPUSH
52459: PPUSH
// if not mc_bases or not skirmish then
52460: LD_EXP 78
52464: NOT
52465: PUSH
52466: LD_EXP 76
52470: NOT
52471: OR
52472: IFFALSE 52476
// exit ;
52474: GO 52666
// for i = 1 to mc_bases do
52476: LD_ADDR_VAR 0 4
52480: PUSH
52481: DOUBLE
52482: LD_INT 1
52484: DEC
52485: ST_TO_ADDR
52486: LD_EXP 78
52490: PUSH
52491: FOR_TO
52492: IFFALSE 52579
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52494: LD_VAR 0 1
52498: PUSH
52499: LD_EXP 86
52503: PUSH
52504: LD_VAR 0 4
52508: ARRAY
52509: IN
52510: PUSH
52511: LD_VAR 0 1
52515: PUSH
52516: LD_EXP 87
52520: PUSH
52521: LD_VAR 0 4
52525: ARRAY
52526: IN
52527: NOT
52528: AND
52529: IFFALSE 52577
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52531: LD_ADDR_EXP 87
52535: PUSH
52536: LD_EXP 87
52540: PPUSH
52541: LD_VAR 0 4
52545: PUSH
52546: LD_EXP 87
52550: PUSH
52551: LD_VAR 0 4
52555: ARRAY
52556: PUSH
52557: LD_INT 1
52559: PLUS
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: PPUSH
52565: LD_VAR 0 1
52569: PPUSH
52570: CALL 57774 0 3
52574: ST_TO_ADDR
// break ;
52575: GO 52579
// end ; end ;
52577: GO 52491
52579: POP
52580: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
52581: LD_VAR 0 1
52585: PPUSH
52586: CALL_OW 257
52590: PUSH
52591: LD_EXP 104
52595: IN
52596: PUSH
52597: LD_VAR 0 1
52601: PPUSH
52602: CALL_OW 266
52606: PUSH
52607: LD_INT 5
52609: EQUAL
52610: AND
52611: PUSH
52612: LD_VAR 0 2
52616: PPUSH
52617: CALL_OW 110
52621: PUSH
52622: LD_INT 18
52624: NONEQUAL
52625: AND
52626: IFFALSE 52666
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52628: LD_VAR 0 2
52632: PPUSH
52633: CALL_OW 257
52637: PUSH
52638: LD_INT 5
52640: PUSH
52641: LD_INT 8
52643: PUSH
52644: LD_INT 9
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: LIST
52651: IN
52652: IFFALSE 52666
// SetClass ( unit , 1 ) ;
52654: LD_VAR 0 2
52658: PPUSH
52659: LD_INT 1
52661: PPUSH
52662: CALL_OW 336
// end ;
52666: LD_VAR 0 3
52670: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52671: LD_INT 0
52673: PPUSH
52674: PPUSH
// if not mc_bases or not skirmish then
52675: LD_EXP 78
52679: NOT
52680: PUSH
52681: LD_EXP 76
52685: NOT
52686: OR
52687: IFFALSE 52691
// exit ;
52689: GO 52807
// if GetLives ( abandoned_vehicle ) > 250 then
52691: LD_VAR 0 2
52695: PPUSH
52696: CALL_OW 256
52700: PUSH
52701: LD_INT 250
52703: GREATER
52704: IFFALSE 52708
// exit ;
52706: GO 52807
// for i = 1 to mc_bases do
52708: LD_ADDR_VAR 0 6
52712: PUSH
52713: DOUBLE
52714: LD_INT 1
52716: DEC
52717: ST_TO_ADDR
52718: LD_EXP 78
52722: PUSH
52723: FOR_TO
52724: IFFALSE 52805
// begin if driver in mc_bases [ i ] then
52726: LD_VAR 0 1
52730: PUSH
52731: LD_EXP 78
52735: PUSH
52736: LD_VAR 0 6
52740: ARRAY
52741: IN
52742: IFFALSE 52803
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52744: LD_VAR 0 1
52748: PPUSH
52749: LD_EXP 78
52753: PUSH
52754: LD_VAR 0 6
52758: ARRAY
52759: PPUSH
52760: LD_INT 2
52762: PUSH
52763: LD_INT 30
52765: PUSH
52766: LD_INT 0
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: PUSH
52773: LD_INT 30
52775: PUSH
52776: LD_INT 1
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: PPUSH
52788: CALL_OW 72
52792: PUSH
52793: LD_INT 1
52795: ARRAY
52796: PPUSH
52797: CALL 90981 0 2
// break ;
52801: GO 52805
// end ; end ;
52803: GO 52723
52805: POP
52806: POP
// end ; end_of_file
52807: LD_VAR 0 5
52811: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52812: LD_INT 0
52814: PPUSH
52815: PPUSH
// if exist_mode then
52816: LD_VAR 0 2
52820: IFFALSE 52845
// unit := CreateCharacter ( prefix & ident ) else
52822: LD_ADDR_VAR 0 5
52826: PUSH
52827: LD_VAR 0 3
52831: PUSH
52832: LD_VAR 0 1
52836: STR
52837: PPUSH
52838: CALL_OW 34
52842: ST_TO_ADDR
52843: GO 52860
// unit := NewCharacter ( ident ) ;
52845: LD_ADDR_VAR 0 5
52849: PUSH
52850: LD_VAR 0 1
52854: PPUSH
52855: CALL_OW 25
52859: ST_TO_ADDR
// result := unit ;
52860: LD_ADDR_VAR 0 4
52864: PUSH
52865: LD_VAR 0 5
52869: ST_TO_ADDR
// end ;
52870: LD_VAR 0 4
52874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52875: LD_INT 0
52877: PPUSH
52878: PPUSH
// if not side or not nation then
52879: LD_VAR 0 1
52883: NOT
52884: PUSH
52885: LD_VAR 0 2
52889: NOT
52890: OR
52891: IFFALSE 52895
// exit ;
52893: GO 53663
// case nation of nation_american :
52895: LD_VAR 0 2
52899: PUSH
52900: LD_INT 1
52902: DOUBLE
52903: EQUAL
52904: IFTRUE 52908
52906: GO 53122
52908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52909: LD_ADDR_VAR 0 4
52913: PUSH
52914: LD_INT 35
52916: PUSH
52917: LD_INT 45
52919: PUSH
52920: LD_INT 46
52922: PUSH
52923: LD_INT 47
52925: PUSH
52926: LD_INT 82
52928: PUSH
52929: LD_INT 83
52931: PUSH
52932: LD_INT 84
52934: PUSH
52935: LD_INT 85
52937: PUSH
52938: LD_INT 86
52940: PUSH
52941: LD_INT 1
52943: PUSH
52944: LD_INT 2
52946: PUSH
52947: LD_INT 6
52949: PUSH
52950: LD_INT 15
52952: PUSH
52953: LD_INT 16
52955: PUSH
52956: LD_INT 7
52958: PUSH
52959: LD_INT 12
52961: PUSH
52962: LD_INT 13
52964: PUSH
52965: LD_INT 10
52967: PUSH
52968: LD_INT 14
52970: PUSH
52971: LD_INT 20
52973: PUSH
52974: LD_INT 21
52976: PUSH
52977: LD_INT 22
52979: PUSH
52980: LD_INT 25
52982: PUSH
52983: LD_INT 32
52985: PUSH
52986: LD_INT 27
52988: PUSH
52989: LD_INT 36
52991: PUSH
52992: LD_INT 69
52994: PUSH
52995: LD_INT 39
52997: PUSH
52998: LD_INT 34
53000: PUSH
53001: LD_INT 40
53003: PUSH
53004: LD_INT 48
53006: PUSH
53007: LD_INT 49
53009: PUSH
53010: LD_INT 50
53012: PUSH
53013: LD_INT 51
53015: PUSH
53016: LD_INT 52
53018: PUSH
53019: LD_INT 53
53021: PUSH
53022: LD_INT 54
53024: PUSH
53025: LD_INT 55
53027: PUSH
53028: LD_INT 56
53030: PUSH
53031: LD_INT 57
53033: PUSH
53034: LD_INT 58
53036: PUSH
53037: LD_INT 59
53039: PUSH
53040: LD_INT 60
53042: PUSH
53043: LD_INT 61
53045: PUSH
53046: LD_INT 62
53048: PUSH
53049: LD_INT 80
53051: PUSH
53052: LD_INT 82
53054: PUSH
53055: LD_INT 83
53057: PUSH
53058: LD_INT 84
53060: PUSH
53061: LD_INT 85
53063: PUSH
53064: LD_INT 86
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: LIST
53075: LIST
53076: LIST
53077: LIST
53078: LIST
53079: LIST
53080: LIST
53081: LIST
53082: LIST
53083: LIST
53084: LIST
53085: LIST
53086: LIST
53087: LIST
53088: LIST
53089: LIST
53090: LIST
53091: LIST
53092: LIST
53093: LIST
53094: LIST
53095: LIST
53096: LIST
53097: LIST
53098: LIST
53099: LIST
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: LIST
53105: LIST
53106: LIST
53107: LIST
53108: LIST
53109: LIST
53110: LIST
53111: LIST
53112: LIST
53113: LIST
53114: LIST
53115: LIST
53116: LIST
53117: LIST
53118: LIST
53119: ST_TO_ADDR
53120: GO 53587
53122: LD_INT 2
53124: DOUBLE
53125: EQUAL
53126: IFTRUE 53130
53128: GO 53356
53130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53131: LD_ADDR_VAR 0 4
53135: PUSH
53136: LD_INT 35
53138: PUSH
53139: LD_INT 45
53141: PUSH
53142: LD_INT 46
53144: PUSH
53145: LD_INT 47
53147: PUSH
53148: LD_INT 82
53150: PUSH
53151: LD_INT 83
53153: PUSH
53154: LD_INT 84
53156: PUSH
53157: LD_INT 85
53159: PUSH
53160: LD_INT 87
53162: PUSH
53163: LD_INT 70
53165: PUSH
53166: LD_INT 1
53168: PUSH
53169: LD_INT 11
53171: PUSH
53172: LD_INT 3
53174: PUSH
53175: LD_INT 4
53177: PUSH
53178: LD_INT 5
53180: PUSH
53181: LD_INT 6
53183: PUSH
53184: LD_INT 15
53186: PUSH
53187: LD_INT 18
53189: PUSH
53190: LD_INT 7
53192: PUSH
53193: LD_INT 17
53195: PUSH
53196: LD_INT 8
53198: PUSH
53199: LD_INT 20
53201: PUSH
53202: LD_INT 21
53204: PUSH
53205: LD_INT 22
53207: PUSH
53208: LD_INT 72
53210: PUSH
53211: LD_INT 26
53213: PUSH
53214: LD_INT 69
53216: PUSH
53217: LD_INT 39
53219: PUSH
53220: LD_INT 40
53222: PUSH
53223: LD_INT 41
53225: PUSH
53226: LD_INT 42
53228: PUSH
53229: LD_INT 43
53231: PUSH
53232: LD_INT 48
53234: PUSH
53235: LD_INT 49
53237: PUSH
53238: LD_INT 50
53240: PUSH
53241: LD_INT 51
53243: PUSH
53244: LD_INT 52
53246: PUSH
53247: LD_INT 53
53249: PUSH
53250: LD_INT 54
53252: PUSH
53253: LD_INT 55
53255: PUSH
53256: LD_INT 56
53258: PUSH
53259: LD_INT 60
53261: PUSH
53262: LD_INT 61
53264: PUSH
53265: LD_INT 62
53267: PUSH
53268: LD_INT 66
53270: PUSH
53271: LD_INT 67
53273: PUSH
53274: LD_INT 68
53276: PUSH
53277: LD_INT 81
53279: PUSH
53280: LD_INT 82
53282: PUSH
53283: LD_INT 83
53285: PUSH
53286: LD_INT 84
53288: PUSH
53289: LD_INT 85
53291: PUSH
53292: LD_INT 87
53294: PUSH
53295: LD_INT 88
53297: PUSH
53298: EMPTY
53299: LIST
53300: LIST
53301: LIST
53302: LIST
53303: LIST
53304: LIST
53305: LIST
53306: LIST
53307: LIST
53308: LIST
53309: LIST
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: LIST
53319: LIST
53320: LIST
53321: LIST
53322: LIST
53323: LIST
53324: LIST
53325: LIST
53326: LIST
53327: LIST
53328: LIST
53329: LIST
53330: LIST
53331: LIST
53332: LIST
53333: LIST
53334: LIST
53335: LIST
53336: LIST
53337: LIST
53338: LIST
53339: LIST
53340: LIST
53341: LIST
53342: LIST
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: LIST
53349: LIST
53350: LIST
53351: LIST
53352: LIST
53353: ST_TO_ADDR
53354: GO 53587
53356: LD_INT 3
53358: DOUBLE
53359: EQUAL
53360: IFTRUE 53364
53362: GO 53586
53364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53365: LD_ADDR_VAR 0 4
53369: PUSH
53370: LD_INT 46
53372: PUSH
53373: LD_INT 47
53375: PUSH
53376: LD_INT 1
53378: PUSH
53379: LD_INT 2
53381: PUSH
53382: LD_INT 82
53384: PUSH
53385: LD_INT 83
53387: PUSH
53388: LD_INT 84
53390: PUSH
53391: LD_INT 85
53393: PUSH
53394: LD_INT 86
53396: PUSH
53397: LD_INT 11
53399: PUSH
53400: LD_INT 9
53402: PUSH
53403: LD_INT 20
53405: PUSH
53406: LD_INT 19
53408: PUSH
53409: LD_INT 21
53411: PUSH
53412: LD_INT 24
53414: PUSH
53415: LD_INT 22
53417: PUSH
53418: LD_INT 25
53420: PUSH
53421: LD_INT 28
53423: PUSH
53424: LD_INT 29
53426: PUSH
53427: LD_INT 30
53429: PUSH
53430: LD_INT 31
53432: PUSH
53433: LD_INT 37
53435: PUSH
53436: LD_INT 38
53438: PUSH
53439: LD_INT 32
53441: PUSH
53442: LD_INT 27
53444: PUSH
53445: LD_INT 33
53447: PUSH
53448: LD_INT 69
53450: PUSH
53451: LD_INT 39
53453: PUSH
53454: LD_INT 34
53456: PUSH
53457: LD_INT 40
53459: PUSH
53460: LD_INT 71
53462: PUSH
53463: LD_INT 23
53465: PUSH
53466: LD_INT 44
53468: PUSH
53469: LD_INT 48
53471: PUSH
53472: LD_INT 49
53474: PUSH
53475: LD_INT 50
53477: PUSH
53478: LD_INT 51
53480: PUSH
53481: LD_INT 52
53483: PUSH
53484: LD_INT 53
53486: PUSH
53487: LD_INT 54
53489: PUSH
53490: LD_INT 55
53492: PUSH
53493: LD_INT 56
53495: PUSH
53496: LD_INT 57
53498: PUSH
53499: LD_INT 58
53501: PUSH
53502: LD_INT 59
53504: PUSH
53505: LD_INT 63
53507: PUSH
53508: LD_INT 64
53510: PUSH
53511: LD_INT 65
53513: PUSH
53514: LD_INT 82
53516: PUSH
53517: LD_INT 83
53519: PUSH
53520: LD_INT 84
53522: PUSH
53523: LD_INT 85
53525: PUSH
53526: LD_INT 86
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: LIST
53537: LIST
53538: LIST
53539: LIST
53540: LIST
53541: LIST
53542: LIST
53543: LIST
53544: LIST
53545: LIST
53546: LIST
53547: LIST
53548: LIST
53549: LIST
53550: LIST
53551: LIST
53552: LIST
53553: LIST
53554: LIST
53555: LIST
53556: LIST
53557: LIST
53558: LIST
53559: LIST
53560: LIST
53561: LIST
53562: LIST
53563: LIST
53564: LIST
53565: LIST
53566: LIST
53567: LIST
53568: LIST
53569: LIST
53570: LIST
53571: LIST
53572: LIST
53573: LIST
53574: LIST
53575: LIST
53576: LIST
53577: LIST
53578: LIST
53579: LIST
53580: LIST
53581: LIST
53582: LIST
53583: ST_TO_ADDR
53584: GO 53587
53586: POP
// if state > - 1 and state < 3 then
53587: LD_VAR 0 3
53591: PUSH
53592: LD_INT 1
53594: NEG
53595: GREATER
53596: PUSH
53597: LD_VAR 0 3
53601: PUSH
53602: LD_INT 3
53604: LESS
53605: AND
53606: IFFALSE 53663
// for i in result do
53608: LD_ADDR_VAR 0 5
53612: PUSH
53613: LD_VAR 0 4
53617: PUSH
53618: FOR_IN
53619: IFFALSE 53661
// if GetTech ( i , side ) <> state then
53621: LD_VAR 0 5
53625: PPUSH
53626: LD_VAR 0 1
53630: PPUSH
53631: CALL_OW 321
53635: PUSH
53636: LD_VAR 0 3
53640: NONEQUAL
53641: IFFALSE 53659
// result := result diff i ;
53643: LD_ADDR_VAR 0 4
53647: PUSH
53648: LD_VAR 0 4
53652: PUSH
53653: LD_VAR 0 5
53657: DIFF
53658: ST_TO_ADDR
53659: GO 53618
53661: POP
53662: POP
// end ;
53663: LD_VAR 0 4
53667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53668: LD_INT 0
53670: PPUSH
53671: PPUSH
53672: PPUSH
// result := true ;
53673: LD_ADDR_VAR 0 3
53677: PUSH
53678: LD_INT 1
53680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53681: LD_ADDR_VAR 0 5
53685: PUSH
53686: LD_VAR 0 2
53690: PPUSH
53691: CALL_OW 480
53695: ST_TO_ADDR
// if not tmp then
53696: LD_VAR 0 5
53700: NOT
53701: IFFALSE 53705
// exit ;
53703: GO 53754
// for i in tmp do
53705: LD_ADDR_VAR 0 4
53709: PUSH
53710: LD_VAR 0 5
53714: PUSH
53715: FOR_IN
53716: IFFALSE 53752
// if GetTech ( i , side ) <> state_researched then
53718: LD_VAR 0 4
53722: PPUSH
53723: LD_VAR 0 1
53727: PPUSH
53728: CALL_OW 321
53732: PUSH
53733: LD_INT 2
53735: NONEQUAL
53736: IFFALSE 53750
// begin result := false ;
53738: LD_ADDR_VAR 0 3
53742: PUSH
53743: LD_INT 0
53745: ST_TO_ADDR
// exit ;
53746: POP
53747: POP
53748: GO 53754
// end ;
53750: GO 53715
53752: POP
53753: POP
// end ;
53754: LD_VAR 0 3
53758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53759: LD_INT 0
53761: PPUSH
53762: PPUSH
53763: PPUSH
53764: PPUSH
53765: PPUSH
53766: PPUSH
53767: PPUSH
53768: PPUSH
53769: PPUSH
53770: PPUSH
53771: PPUSH
53772: PPUSH
53773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53774: LD_VAR 0 1
53778: NOT
53779: PUSH
53780: LD_VAR 0 1
53784: PPUSH
53785: CALL_OW 257
53789: PUSH
53790: LD_INT 9
53792: NONEQUAL
53793: OR
53794: IFFALSE 53798
// exit ;
53796: GO 54371
// side := GetSide ( unit ) ;
53798: LD_ADDR_VAR 0 9
53802: PUSH
53803: LD_VAR 0 1
53807: PPUSH
53808: CALL_OW 255
53812: ST_TO_ADDR
// tech_space := tech_spacanom ;
53813: LD_ADDR_VAR 0 12
53817: PUSH
53818: LD_INT 29
53820: ST_TO_ADDR
// tech_time := tech_taurad ;
53821: LD_ADDR_VAR 0 13
53825: PUSH
53826: LD_INT 28
53828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53829: LD_ADDR_VAR 0 11
53833: PUSH
53834: LD_VAR 0 1
53838: PPUSH
53839: CALL_OW 310
53843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53844: LD_VAR 0 11
53848: PPUSH
53849: CALL_OW 247
53853: PUSH
53854: LD_INT 2
53856: EQUAL
53857: IFFALSE 53861
// exit ;
53859: GO 54371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53861: LD_ADDR_VAR 0 8
53865: PUSH
53866: LD_INT 81
53868: PUSH
53869: LD_VAR 0 9
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: PUSH
53878: LD_INT 3
53880: PUSH
53881: LD_INT 21
53883: PUSH
53884: LD_INT 3
53886: PUSH
53887: EMPTY
53888: LIST
53889: LIST
53890: PUSH
53891: EMPTY
53892: LIST
53893: LIST
53894: PUSH
53895: EMPTY
53896: LIST
53897: LIST
53898: PPUSH
53899: CALL_OW 69
53903: ST_TO_ADDR
// if not tmp then
53904: LD_VAR 0 8
53908: NOT
53909: IFFALSE 53913
// exit ;
53911: GO 54371
// if in_unit then
53913: LD_VAR 0 11
53917: IFFALSE 53941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53919: LD_ADDR_VAR 0 10
53923: PUSH
53924: LD_VAR 0 8
53928: PPUSH
53929: LD_VAR 0 11
53933: PPUSH
53934: CALL_OW 74
53938: ST_TO_ADDR
53939: GO 53961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53941: LD_ADDR_VAR 0 10
53945: PUSH
53946: LD_VAR 0 8
53950: PPUSH
53951: LD_VAR 0 1
53955: PPUSH
53956: CALL_OW 74
53960: ST_TO_ADDR
// if not enemy then
53961: LD_VAR 0 10
53965: NOT
53966: IFFALSE 53970
// exit ;
53968: GO 54371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53970: LD_VAR 0 11
53974: PUSH
53975: LD_VAR 0 11
53979: PPUSH
53980: LD_VAR 0 10
53984: PPUSH
53985: CALL_OW 296
53989: PUSH
53990: LD_INT 13
53992: GREATER
53993: AND
53994: PUSH
53995: LD_VAR 0 1
53999: PPUSH
54000: LD_VAR 0 10
54004: PPUSH
54005: CALL_OW 296
54009: PUSH
54010: LD_INT 12
54012: GREATER
54013: OR
54014: IFFALSE 54018
// exit ;
54016: GO 54371
// missile := [ 1 ] ;
54018: LD_ADDR_VAR 0 14
54022: PUSH
54023: LD_INT 1
54025: PUSH
54026: EMPTY
54027: LIST
54028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54029: LD_VAR 0 9
54033: PPUSH
54034: LD_VAR 0 12
54038: PPUSH
54039: CALL_OW 325
54043: IFFALSE 54072
// missile := Replace ( missile , missile + 1 , 2 ) ;
54045: LD_ADDR_VAR 0 14
54049: PUSH
54050: LD_VAR 0 14
54054: PPUSH
54055: LD_VAR 0 14
54059: PUSH
54060: LD_INT 1
54062: PLUS
54063: PPUSH
54064: LD_INT 2
54066: PPUSH
54067: CALL_OW 1
54071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54072: LD_VAR 0 9
54076: PPUSH
54077: LD_VAR 0 13
54081: PPUSH
54082: CALL_OW 325
54086: PUSH
54087: LD_VAR 0 10
54091: PPUSH
54092: CALL_OW 255
54096: PPUSH
54097: LD_VAR 0 13
54101: PPUSH
54102: CALL_OW 325
54106: NOT
54107: AND
54108: IFFALSE 54137
// missile := Replace ( missile , missile + 1 , 3 ) ;
54110: LD_ADDR_VAR 0 14
54114: PUSH
54115: LD_VAR 0 14
54119: PPUSH
54120: LD_VAR 0 14
54124: PUSH
54125: LD_INT 1
54127: PLUS
54128: PPUSH
54129: LD_INT 3
54131: PPUSH
54132: CALL_OW 1
54136: ST_TO_ADDR
// if missile < 2 then
54137: LD_VAR 0 14
54141: PUSH
54142: LD_INT 2
54144: LESS
54145: IFFALSE 54149
// exit ;
54147: GO 54371
// x := GetX ( enemy ) ;
54149: LD_ADDR_VAR 0 4
54153: PUSH
54154: LD_VAR 0 10
54158: PPUSH
54159: CALL_OW 250
54163: ST_TO_ADDR
// y := GetY ( enemy ) ;
54164: LD_ADDR_VAR 0 5
54168: PUSH
54169: LD_VAR 0 10
54173: PPUSH
54174: CALL_OW 251
54178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54179: LD_ADDR_VAR 0 6
54183: PUSH
54184: LD_VAR 0 4
54188: PUSH
54189: LD_INT 1
54191: NEG
54192: PPUSH
54193: LD_INT 1
54195: PPUSH
54196: CALL_OW 12
54200: PLUS
54201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54202: LD_ADDR_VAR 0 7
54206: PUSH
54207: LD_VAR 0 5
54211: PUSH
54212: LD_INT 1
54214: NEG
54215: PPUSH
54216: LD_INT 1
54218: PPUSH
54219: CALL_OW 12
54223: PLUS
54224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54225: LD_VAR 0 6
54229: PPUSH
54230: LD_VAR 0 7
54234: PPUSH
54235: CALL_OW 488
54239: NOT
54240: IFFALSE 54262
// begin _x := x ;
54242: LD_ADDR_VAR 0 6
54246: PUSH
54247: LD_VAR 0 4
54251: ST_TO_ADDR
// _y := y ;
54252: LD_ADDR_VAR 0 7
54256: PUSH
54257: LD_VAR 0 5
54261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54262: LD_ADDR_VAR 0 3
54266: PUSH
54267: LD_INT 1
54269: PPUSH
54270: LD_VAR 0 14
54274: PPUSH
54275: CALL_OW 12
54279: ST_TO_ADDR
// case i of 1 :
54280: LD_VAR 0 3
54284: PUSH
54285: LD_INT 1
54287: DOUBLE
54288: EQUAL
54289: IFTRUE 54293
54291: GO 54310
54293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54294: LD_VAR 0 1
54298: PPUSH
54299: LD_VAR 0 10
54303: PPUSH
54304: CALL_OW 115
54308: GO 54371
54310: LD_INT 2
54312: DOUBLE
54313: EQUAL
54314: IFTRUE 54318
54316: GO 54340
54318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54319: LD_VAR 0 1
54323: PPUSH
54324: LD_VAR 0 6
54328: PPUSH
54329: LD_VAR 0 7
54333: PPUSH
54334: CALL_OW 153
54338: GO 54371
54340: LD_INT 3
54342: DOUBLE
54343: EQUAL
54344: IFTRUE 54348
54346: GO 54370
54348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54349: LD_VAR 0 1
54353: PPUSH
54354: LD_VAR 0 6
54358: PPUSH
54359: LD_VAR 0 7
54363: PPUSH
54364: CALL_OW 154
54368: GO 54371
54370: POP
// end ;
54371: LD_VAR 0 2
54375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54376: LD_INT 0
54378: PPUSH
54379: PPUSH
54380: PPUSH
54381: PPUSH
54382: PPUSH
54383: PPUSH
// if not unit or not building then
54384: LD_VAR 0 1
54388: NOT
54389: PUSH
54390: LD_VAR 0 2
54394: NOT
54395: OR
54396: IFFALSE 54400
// exit ;
54398: GO 54558
// x := GetX ( building ) ;
54400: LD_ADDR_VAR 0 5
54404: PUSH
54405: LD_VAR 0 2
54409: PPUSH
54410: CALL_OW 250
54414: ST_TO_ADDR
// y := GetY ( building ) ;
54415: LD_ADDR_VAR 0 6
54419: PUSH
54420: LD_VAR 0 2
54424: PPUSH
54425: CALL_OW 251
54429: ST_TO_ADDR
// for i = 0 to 5 do
54430: LD_ADDR_VAR 0 4
54434: PUSH
54435: DOUBLE
54436: LD_INT 0
54438: DEC
54439: ST_TO_ADDR
54440: LD_INT 5
54442: PUSH
54443: FOR_TO
54444: IFFALSE 54556
// begin _x := ShiftX ( x , i , 3 ) ;
54446: LD_ADDR_VAR 0 7
54450: PUSH
54451: LD_VAR 0 5
54455: PPUSH
54456: LD_VAR 0 4
54460: PPUSH
54461: LD_INT 3
54463: PPUSH
54464: CALL_OW 272
54468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54469: LD_ADDR_VAR 0 8
54473: PUSH
54474: LD_VAR 0 6
54478: PPUSH
54479: LD_VAR 0 4
54483: PPUSH
54484: LD_INT 3
54486: PPUSH
54487: CALL_OW 273
54491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54492: LD_VAR 0 7
54496: PPUSH
54497: LD_VAR 0 8
54501: PPUSH
54502: CALL_OW 488
54506: NOT
54507: IFFALSE 54511
// continue ;
54509: GO 54443
// if HexInfo ( _x , _y ) = 0 then
54511: LD_VAR 0 7
54515: PPUSH
54516: LD_VAR 0 8
54520: PPUSH
54521: CALL_OW 428
54525: PUSH
54526: LD_INT 0
54528: EQUAL
54529: IFFALSE 54554
// begin ComMoveXY ( unit , _x , _y ) ;
54531: LD_VAR 0 1
54535: PPUSH
54536: LD_VAR 0 7
54540: PPUSH
54541: LD_VAR 0 8
54545: PPUSH
54546: CALL_OW 111
// exit ;
54550: POP
54551: POP
54552: GO 54558
// end ; end ;
54554: GO 54443
54556: POP
54557: POP
// end ;
54558: LD_VAR 0 3
54562: RET
// export function ScanBase ( side , base_area ) ; begin
54563: LD_INT 0
54565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
54566: LD_ADDR_VAR 0 3
54570: PUSH
54571: LD_VAR 0 2
54575: PPUSH
54576: LD_INT 81
54578: PUSH
54579: LD_VAR 0 1
54583: PUSH
54584: EMPTY
54585: LIST
54586: LIST
54587: PPUSH
54588: CALL_OW 70
54592: ST_TO_ADDR
// end ;
54593: LD_VAR 0 3
54597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54598: LD_INT 0
54600: PPUSH
54601: PPUSH
54602: PPUSH
54603: PPUSH
// result := false ;
54604: LD_ADDR_VAR 0 2
54608: PUSH
54609: LD_INT 0
54611: ST_TO_ADDR
// side := GetSide ( unit ) ;
54612: LD_ADDR_VAR 0 3
54616: PUSH
54617: LD_VAR 0 1
54621: PPUSH
54622: CALL_OW 255
54626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54627: LD_ADDR_VAR 0 4
54631: PUSH
54632: LD_VAR 0 1
54636: PPUSH
54637: CALL_OW 248
54641: ST_TO_ADDR
// case nat of 1 :
54642: LD_VAR 0 4
54646: PUSH
54647: LD_INT 1
54649: DOUBLE
54650: EQUAL
54651: IFTRUE 54655
54653: GO 54666
54655: POP
// tech := tech_lassight ; 2 :
54656: LD_ADDR_VAR 0 5
54660: PUSH
54661: LD_INT 12
54663: ST_TO_ADDR
54664: GO 54705
54666: LD_INT 2
54668: DOUBLE
54669: EQUAL
54670: IFTRUE 54674
54672: GO 54685
54674: POP
// tech := tech_mortar ; 3 :
54675: LD_ADDR_VAR 0 5
54679: PUSH
54680: LD_INT 41
54682: ST_TO_ADDR
54683: GO 54705
54685: LD_INT 3
54687: DOUBLE
54688: EQUAL
54689: IFTRUE 54693
54691: GO 54704
54693: POP
// tech := tech_bazooka ; end ;
54694: LD_ADDR_VAR 0 5
54698: PUSH
54699: LD_INT 44
54701: ST_TO_ADDR
54702: GO 54705
54704: POP
// if Researched ( side , tech ) then
54705: LD_VAR 0 3
54709: PPUSH
54710: LD_VAR 0 5
54714: PPUSH
54715: CALL_OW 325
54719: IFFALSE 54746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54721: LD_ADDR_VAR 0 2
54725: PUSH
54726: LD_INT 5
54728: PUSH
54729: LD_INT 8
54731: PUSH
54732: LD_INT 9
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: LIST
54739: PUSH
54740: LD_VAR 0 4
54744: ARRAY
54745: ST_TO_ADDR
// end ;
54746: LD_VAR 0 2
54750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54751: LD_INT 0
54753: PPUSH
54754: PPUSH
54755: PPUSH
// if not mines then
54756: LD_VAR 0 2
54760: NOT
54761: IFFALSE 54765
// exit ;
54763: GO 54909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54765: LD_ADDR_VAR 0 5
54769: PUSH
54770: LD_INT 81
54772: PUSH
54773: LD_VAR 0 1
54777: PUSH
54778: EMPTY
54779: LIST
54780: LIST
54781: PUSH
54782: LD_INT 3
54784: PUSH
54785: LD_INT 21
54787: PUSH
54788: LD_INT 3
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PPUSH
54803: CALL_OW 69
54807: ST_TO_ADDR
// for i in mines do
54808: LD_ADDR_VAR 0 4
54812: PUSH
54813: LD_VAR 0 2
54817: PUSH
54818: FOR_IN
54819: IFFALSE 54907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54821: LD_VAR 0 4
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PPUSH
54830: LD_VAR 0 4
54834: PUSH
54835: LD_INT 2
54837: ARRAY
54838: PPUSH
54839: CALL_OW 458
54843: NOT
54844: IFFALSE 54848
// continue ;
54846: GO 54818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54848: LD_VAR 0 4
54852: PUSH
54853: LD_INT 1
54855: ARRAY
54856: PPUSH
54857: LD_VAR 0 4
54861: PUSH
54862: LD_INT 2
54864: ARRAY
54865: PPUSH
54866: CALL_OW 428
54870: PUSH
54871: LD_VAR 0 5
54875: IN
54876: IFFALSE 54905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54878: LD_VAR 0 4
54882: PUSH
54883: LD_INT 1
54885: ARRAY
54886: PPUSH
54887: LD_VAR 0 4
54891: PUSH
54892: LD_INT 2
54894: ARRAY
54895: PPUSH
54896: LD_VAR 0 1
54900: PPUSH
54901: CALL_OW 456
// end ;
54905: GO 54818
54907: POP
54908: POP
// end ;
54909: LD_VAR 0 3
54913: RET
// export function Count ( array ) ; begin
54914: LD_INT 0
54916: PPUSH
// result := array + 0 ;
54917: LD_ADDR_VAR 0 2
54921: PUSH
54922: LD_VAR 0 1
54926: PUSH
54927: LD_INT 0
54929: PLUS
54930: ST_TO_ADDR
// end ;
54931: LD_VAR 0 2
54935: RET
// export function IsEmpty ( building ) ; begin
54936: LD_INT 0
54938: PPUSH
// if not building then
54939: LD_VAR 0 1
54943: NOT
54944: IFFALSE 54948
// exit ;
54946: GO 54991
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54948: LD_ADDR_VAR 0 2
54952: PUSH
54953: LD_VAR 0 1
54957: PUSH
54958: LD_INT 22
54960: PUSH
54961: LD_VAR 0 1
54965: PPUSH
54966: CALL_OW 255
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: PUSH
54975: LD_INT 58
54977: PUSH
54978: EMPTY
54979: LIST
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PPUSH
54985: CALL_OW 69
54989: IN
54990: ST_TO_ADDR
// end ;
54991: LD_VAR 0 2
54995: RET
// export function IsNotFull ( building ) ; var places ; begin
54996: LD_INT 0
54998: PPUSH
54999: PPUSH
// if not building then
55000: LD_VAR 0 1
55004: NOT
55005: IFFALSE 55009
// exit ;
55007: GO 55037
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55009: LD_ADDR_VAR 0 2
55013: PUSH
55014: LD_VAR 0 1
55018: PPUSH
55019: LD_INT 3
55021: PUSH
55022: LD_INT 62
55024: PUSH
55025: EMPTY
55026: LIST
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: PPUSH
55032: CALL_OW 72
55036: ST_TO_ADDR
// end ;
55037: LD_VAR 0 2
55041: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55042: LD_INT 0
55044: PPUSH
55045: PPUSH
55046: PPUSH
55047: PPUSH
// tmp := [ ] ;
55048: LD_ADDR_VAR 0 3
55052: PUSH
55053: EMPTY
55054: ST_TO_ADDR
// list := [ ] ;
55055: LD_ADDR_VAR 0 5
55059: PUSH
55060: EMPTY
55061: ST_TO_ADDR
// for i = 16 to 25 do
55062: LD_ADDR_VAR 0 4
55066: PUSH
55067: DOUBLE
55068: LD_INT 16
55070: DEC
55071: ST_TO_ADDR
55072: LD_INT 25
55074: PUSH
55075: FOR_TO
55076: IFFALSE 55149
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55078: LD_ADDR_VAR 0 3
55082: PUSH
55083: LD_VAR 0 3
55087: PUSH
55088: LD_INT 22
55090: PUSH
55091: LD_VAR 0 1
55095: PPUSH
55096: CALL_OW 255
55100: PUSH
55101: EMPTY
55102: LIST
55103: LIST
55104: PUSH
55105: LD_INT 91
55107: PUSH
55108: LD_VAR 0 1
55112: PUSH
55113: LD_INT 6
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: LIST
55120: PUSH
55121: LD_INT 30
55123: PUSH
55124: LD_VAR 0 4
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: LIST
55137: PUSH
55138: EMPTY
55139: LIST
55140: PPUSH
55141: CALL_OW 69
55145: ADD
55146: ST_TO_ADDR
55147: GO 55075
55149: POP
55150: POP
// for i = 1 to tmp do
55151: LD_ADDR_VAR 0 4
55155: PUSH
55156: DOUBLE
55157: LD_INT 1
55159: DEC
55160: ST_TO_ADDR
55161: LD_VAR 0 3
55165: PUSH
55166: FOR_TO
55167: IFFALSE 55255
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55169: LD_ADDR_VAR 0 5
55173: PUSH
55174: LD_VAR 0 5
55178: PUSH
55179: LD_VAR 0 3
55183: PUSH
55184: LD_VAR 0 4
55188: ARRAY
55189: PPUSH
55190: CALL_OW 266
55194: PUSH
55195: LD_VAR 0 3
55199: PUSH
55200: LD_VAR 0 4
55204: ARRAY
55205: PPUSH
55206: CALL_OW 250
55210: PUSH
55211: LD_VAR 0 3
55215: PUSH
55216: LD_VAR 0 4
55220: ARRAY
55221: PPUSH
55222: CALL_OW 251
55226: PUSH
55227: LD_VAR 0 3
55231: PUSH
55232: LD_VAR 0 4
55236: ARRAY
55237: PPUSH
55238: CALL_OW 254
55242: PUSH
55243: EMPTY
55244: LIST
55245: LIST
55246: LIST
55247: LIST
55248: PUSH
55249: EMPTY
55250: LIST
55251: ADD
55252: ST_TO_ADDR
55253: GO 55166
55255: POP
55256: POP
// result := list ;
55257: LD_ADDR_VAR 0 2
55261: PUSH
55262: LD_VAR 0 5
55266: ST_TO_ADDR
// end ;
55267: LD_VAR 0 2
55271: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55272: LD_INT 0
55274: PPUSH
55275: PPUSH
55276: PPUSH
55277: PPUSH
55278: PPUSH
55279: PPUSH
55280: PPUSH
// if not factory then
55281: LD_VAR 0 1
55285: NOT
55286: IFFALSE 55290
// exit ;
55288: GO 55883
// if control = control_apeman then
55290: LD_VAR 0 4
55294: PUSH
55295: LD_INT 5
55297: EQUAL
55298: IFFALSE 55407
// begin tmp := UnitsInside ( factory ) ;
55300: LD_ADDR_VAR 0 8
55304: PUSH
55305: LD_VAR 0 1
55309: PPUSH
55310: CALL_OW 313
55314: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55315: LD_VAR 0 8
55319: PPUSH
55320: LD_INT 25
55322: PUSH
55323: LD_INT 12
55325: PUSH
55326: EMPTY
55327: LIST
55328: LIST
55329: PPUSH
55330: CALL_OW 72
55334: NOT
55335: IFFALSE 55345
// control := control_manual ;
55337: LD_ADDR_VAR 0 4
55341: PUSH
55342: LD_INT 1
55344: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55345: LD_ADDR_VAR 0 8
55349: PUSH
55350: LD_VAR 0 1
55354: PPUSH
55355: CALL 55042 0 1
55359: ST_TO_ADDR
// if tmp then
55360: LD_VAR 0 8
55364: IFFALSE 55407
// begin for i in tmp do
55366: LD_ADDR_VAR 0 7
55370: PUSH
55371: LD_VAR 0 8
55375: PUSH
55376: FOR_IN
55377: IFFALSE 55405
// if i [ 1 ] = b_ext_radio then
55379: LD_VAR 0 7
55383: PUSH
55384: LD_INT 1
55386: ARRAY
55387: PUSH
55388: LD_INT 22
55390: EQUAL
55391: IFFALSE 55403
// begin control := control_remote ;
55393: LD_ADDR_VAR 0 4
55397: PUSH
55398: LD_INT 2
55400: ST_TO_ADDR
// break ;
55401: GO 55405
// end ;
55403: GO 55376
55405: POP
55406: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55407: LD_VAR 0 1
55411: PPUSH
55412: LD_VAR 0 2
55416: PPUSH
55417: LD_VAR 0 3
55421: PPUSH
55422: LD_VAR 0 4
55426: PPUSH
55427: LD_VAR 0 5
55431: PPUSH
55432: CALL_OW 448
55436: IFFALSE 55471
// begin result := [ chassis , engine , control , weapon ] ;
55438: LD_ADDR_VAR 0 6
55442: PUSH
55443: LD_VAR 0 2
55447: PUSH
55448: LD_VAR 0 3
55452: PUSH
55453: LD_VAR 0 4
55457: PUSH
55458: LD_VAR 0 5
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: LIST
55467: LIST
55468: ST_TO_ADDR
// exit ;
55469: GO 55883
// end ; _chassis := AvailableChassisList ( factory ) ;
55471: LD_ADDR_VAR 0 9
55475: PUSH
55476: LD_VAR 0 1
55480: PPUSH
55481: CALL_OW 475
55485: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55486: LD_ADDR_VAR 0 11
55490: PUSH
55491: LD_VAR 0 1
55495: PPUSH
55496: CALL_OW 476
55500: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55501: LD_ADDR_VAR 0 12
55505: PUSH
55506: LD_VAR 0 1
55510: PPUSH
55511: CALL_OW 477
55515: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55516: LD_ADDR_VAR 0 10
55520: PUSH
55521: LD_VAR 0 1
55525: PPUSH
55526: CALL_OW 478
55530: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55531: LD_VAR 0 9
55535: NOT
55536: PUSH
55537: LD_VAR 0 11
55541: NOT
55542: OR
55543: PUSH
55544: LD_VAR 0 12
55548: NOT
55549: OR
55550: PUSH
55551: LD_VAR 0 10
55555: NOT
55556: OR
55557: IFFALSE 55592
// begin result := [ chassis , engine , control , weapon ] ;
55559: LD_ADDR_VAR 0 6
55563: PUSH
55564: LD_VAR 0 2
55568: PUSH
55569: LD_VAR 0 3
55573: PUSH
55574: LD_VAR 0 4
55578: PUSH
55579: LD_VAR 0 5
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: LIST
55588: LIST
55589: ST_TO_ADDR
// exit ;
55590: GO 55883
// end ; if not chassis in _chassis then
55592: LD_VAR 0 2
55596: PUSH
55597: LD_VAR 0 9
55601: IN
55602: NOT
55603: IFFALSE 55629
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55605: LD_ADDR_VAR 0 2
55609: PUSH
55610: LD_VAR 0 9
55614: PUSH
55615: LD_INT 1
55617: PPUSH
55618: LD_VAR 0 9
55622: PPUSH
55623: CALL_OW 12
55627: ARRAY
55628: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55629: LD_VAR 0 2
55633: PPUSH
55634: LD_VAR 0 3
55638: PPUSH
55639: CALL 55888 0 2
55643: NOT
55644: IFFALSE 55703
// repeat engine := _engine [ 1 ] ;
55646: LD_ADDR_VAR 0 3
55650: PUSH
55651: LD_VAR 0 11
55655: PUSH
55656: LD_INT 1
55658: ARRAY
55659: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55660: LD_ADDR_VAR 0 11
55664: PUSH
55665: LD_VAR 0 11
55669: PPUSH
55670: LD_INT 1
55672: PPUSH
55673: CALL_OW 3
55677: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55678: LD_VAR 0 2
55682: PPUSH
55683: LD_VAR 0 3
55687: PPUSH
55688: CALL 55888 0 2
55692: PUSH
55693: LD_VAR 0 11
55697: PUSH
55698: EMPTY
55699: EQUAL
55700: OR
55701: IFFALSE 55646
// if not control in _control then
55703: LD_VAR 0 4
55707: PUSH
55708: LD_VAR 0 12
55712: IN
55713: NOT
55714: IFFALSE 55740
// control := _control [ rand ( 1 , _control ) ] ;
55716: LD_ADDR_VAR 0 4
55720: PUSH
55721: LD_VAR 0 12
55725: PUSH
55726: LD_INT 1
55728: PPUSH
55729: LD_VAR 0 12
55733: PPUSH
55734: CALL_OW 12
55738: ARRAY
55739: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55740: LD_VAR 0 2
55744: PPUSH
55745: LD_VAR 0 5
55749: PPUSH
55750: CALL 56108 0 2
55754: NOT
55755: IFFALSE 55814
// repeat weapon := _weapon [ 1 ] ;
55757: LD_ADDR_VAR 0 5
55761: PUSH
55762: LD_VAR 0 10
55766: PUSH
55767: LD_INT 1
55769: ARRAY
55770: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55771: LD_ADDR_VAR 0 10
55775: PUSH
55776: LD_VAR 0 10
55780: PPUSH
55781: LD_INT 1
55783: PPUSH
55784: CALL_OW 3
55788: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55789: LD_VAR 0 2
55793: PPUSH
55794: LD_VAR 0 5
55798: PPUSH
55799: CALL 56108 0 2
55803: PUSH
55804: LD_VAR 0 10
55808: PUSH
55809: EMPTY
55810: EQUAL
55811: OR
55812: IFFALSE 55757
// result := [ ] ;
55814: LD_ADDR_VAR 0 6
55818: PUSH
55819: EMPTY
55820: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55821: LD_VAR 0 1
55825: PPUSH
55826: LD_VAR 0 2
55830: PPUSH
55831: LD_VAR 0 3
55835: PPUSH
55836: LD_VAR 0 4
55840: PPUSH
55841: LD_VAR 0 5
55845: PPUSH
55846: CALL_OW 448
55850: IFFALSE 55883
// result := [ chassis , engine , control , weapon ] ;
55852: LD_ADDR_VAR 0 6
55856: PUSH
55857: LD_VAR 0 2
55861: PUSH
55862: LD_VAR 0 3
55866: PUSH
55867: LD_VAR 0 4
55871: PUSH
55872: LD_VAR 0 5
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: LIST
55881: LIST
55882: ST_TO_ADDR
// end ;
55883: LD_VAR 0 6
55887: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55888: LD_INT 0
55890: PPUSH
// if not chassis or not engine then
55891: LD_VAR 0 1
55895: NOT
55896: PUSH
55897: LD_VAR 0 2
55901: NOT
55902: OR
55903: IFFALSE 55907
// exit ;
55905: GO 56103
// case engine of engine_solar :
55907: LD_VAR 0 2
55911: PUSH
55912: LD_INT 2
55914: DOUBLE
55915: EQUAL
55916: IFTRUE 55920
55918: GO 55958
55920: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55921: LD_ADDR_VAR 0 3
55925: PUSH
55926: LD_INT 11
55928: PUSH
55929: LD_INT 12
55931: PUSH
55932: LD_INT 13
55934: PUSH
55935: LD_INT 14
55937: PUSH
55938: LD_INT 1
55940: PUSH
55941: LD_INT 2
55943: PUSH
55944: LD_INT 3
55946: PUSH
55947: EMPTY
55948: LIST
55949: LIST
55950: LIST
55951: LIST
55952: LIST
55953: LIST
55954: LIST
55955: ST_TO_ADDR
55956: GO 56087
55958: LD_INT 1
55960: DOUBLE
55961: EQUAL
55962: IFTRUE 55966
55964: GO 56028
55966: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55967: LD_ADDR_VAR 0 3
55971: PUSH
55972: LD_INT 11
55974: PUSH
55975: LD_INT 12
55977: PUSH
55978: LD_INT 13
55980: PUSH
55981: LD_INT 14
55983: PUSH
55984: LD_INT 1
55986: PUSH
55987: LD_INT 2
55989: PUSH
55990: LD_INT 3
55992: PUSH
55993: LD_INT 4
55995: PUSH
55996: LD_INT 5
55998: PUSH
55999: LD_INT 21
56001: PUSH
56002: LD_INT 23
56004: PUSH
56005: LD_INT 22
56007: PUSH
56008: LD_INT 24
56010: PUSH
56011: EMPTY
56012: LIST
56013: LIST
56014: LIST
56015: LIST
56016: LIST
56017: LIST
56018: LIST
56019: LIST
56020: LIST
56021: LIST
56022: LIST
56023: LIST
56024: LIST
56025: ST_TO_ADDR
56026: GO 56087
56028: LD_INT 3
56030: DOUBLE
56031: EQUAL
56032: IFTRUE 56036
56034: GO 56086
56036: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56037: LD_ADDR_VAR 0 3
56041: PUSH
56042: LD_INT 13
56044: PUSH
56045: LD_INT 14
56047: PUSH
56048: LD_INT 2
56050: PUSH
56051: LD_INT 3
56053: PUSH
56054: LD_INT 4
56056: PUSH
56057: LD_INT 5
56059: PUSH
56060: LD_INT 21
56062: PUSH
56063: LD_INT 22
56065: PUSH
56066: LD_INT 23
56068: PUSH
56069: LD_INT 24
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: LIST
56079: LIST
56080: LIST
56081: LIST
56082: LIST
56083: ST_TO_ADDR
56084: GO 56087
56086: POP
// result := ( chassis in result ) ;
56087: LD_ADDR_VAR 0 3
56091: PUSH
56092: LD_VAR 0 1
56096: PUSH
56097: LD_VAR 0 3
56101: IN
56102: ST_TO_ADDR
// end ;
56103: LD_VAR 0 3
56107: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56108: LD_INT 0
56110: PPUSH
// if not chassis or not weapon then
56111: LD_VAR 0 1
56115: NOT
56116: PUSH
56117: LD_VAR 0 2
56121: NOT
56122: OR
56123: IFFALSE 56127
// exit ;
56125: GO 57187
// case weapon of us_machine_gun :
56127: LD_VAR 0 2
56131: PUSH
56132: LD_INT 2
56134: DOUBLE
56135: EQUAL
56136: IFTRUE 56140
56138: GO 56170
56140: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56141: LD_ADDR_VAR 0 3
56145: PUSH
56146: LD_INT 1
56148: PUSH
56149: LD_INT 2
56151: PUSH
56152: LD_INT 3
56154: PUSH
56155: LD_INT 4
56157: PUSH
56158: LD_INT 5
56160: PUSH
56161: EMPTY
56162: LIST
56163: LIST
56164: LIST
56165: LIST
56166: LIST
56167: ST_TO_ADDR
56168: GO 57171
56170: LD_INT 3
56172: DOUBLE
56173: EQUAL
56174: IFTRUE 56178
56176: GO 56208
56178: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56179: LD_ADDR_VAR 0 3
56183: PUSH
56184: LD_INT 1
56186: PUSH
56187: LD_INT 2
56189: PUSH
56190: LD_INT 3
56192: PUSH
56193: LD_INT 4
56195: PUSH
56196: LD_INT 5
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: LIST
56203: LIST
56204: LIST
56205: ST_TO_ADDR
56206: GO 57171
56208: LD_INT 11
56210: DOUBLE
56211: EQUAL
56212: IFTRUE 56216
56214: GO 56246
56216: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56217: LD_ADDR_VAR 0 3
56221: PUSH
56222: LD_INT 1
56224: PUSH
56225: LD_INT 2
56227: PUSH
56228: LD_INT 3
56230: PUSH
56231: LD_INT 4
56233: PUSH
56234: LD_INT 5
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: LIST
56241: LIST
56242: LIST
56243: ST_TO_ADDR
56244: GO 57171
56246: LD_INT 4
56248: DOUBLE
56249: EQUAL
56250: IFTRUE 56254
56252: GO 56280
56254: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56255: LD_ADDR_VAR 0 3
56259: PUSH
56260: LD_INT 2
56262: PUSH
56263: LD_INT 3
56265: PUSH
56266: LD_INT 4
56268: PUSH
56269: LD_INT 5
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: LIST
56276: LIST
56277: ST_TO_ADDR
56278: GO 57171
56280: LD_INT 5
56282: DOUBLE
56283: EQUAL
56284: IFTRUE 56288
56286: GO 56314
56288: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56289: LD_ADDR_VAR 0 3
56293: PUSH
56294: LD_INT 2
56296: PUSH
56297: LD_INT 3
56299: PUSH
56300: LD_INT 4
56302: PUSH
56303: LD_INT 5
56305: PUSH
56306: EMPTY
56307: LIST
56308: LIST
56309: LIST
56310: LIST
56311: ST_TO_ADDR
56312: GO 57171
56314: LD_INT 9
56316: DOUBLE
56317: EQUAL
56318: IFTRUE 56322
56320: GO 56348
56322: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56323: LD_ADDR_VAR 0 3
56327: PUSH
56328: LD_INT 2
56330: PUSH
56331: LD_INT 3
56333: PUSH
56334: LD_INT 4
56336: PUSH
56337: LD_INT 5
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: LIST
56344: LIST
56345: ST_TO_ADDR
56346: GO 57171
56348: LD_INT 7
56350: DOUBLE
56351: EQUAL
56352: IFTRUE 56356
56354: GO 56382
56356: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56357: LD_ADDR_VAR 0 3
56361: PUSH
56362: LD_INT 2
56364: PUSH
56365: LD_INT 3
56367: PUSH
56368: LD_INT 4
56370: PUSH
56371: LD_INT 5
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: LIST
56378: LIST
56379: ST_TO_ADDR
56380: GO 57171
56382: LD_INT 12
56384: DOUBLE
56385: EQUAL
56386: IFTRUE 56390
56388: GO 56416
56390: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56391: LD_ADDR_VAR 0 3
56395: PUSH
56396: LD_INT 2
56398: PUSH
56399: LD_INT 3
56401: PUSH
56402: LD_INT 4
56404: PUSH
56405: LD_INT 5
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: LIST
56412: LIST
56413: ST_TO_ADDR
56414: GO 57171
56416: LD_INT 13
56418: DOUBLE
56419: EQUAL
56420: IFTRUE 56424
56422: GO 56450
56424: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56425: LD_ADDR_VAR 0 3
56429: PUSH
56430: LD_INT 2
56432: PUSH
56433: LD_INT 3
56435: PUSH
56436: LD_INT 4
56438: PUSH
56439: LD_INT 5
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: LIST
56446: LIST
56447: ST_TO_ADDR
56448: GO 57171
56450: LD_INT 14
56452: DOUBLE
56453: EQUAL
56454: IFTRUE 56458
56456: GO 56476
56458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56459: LD_ADDR_VAR 0 3
56463: PUSH
56464: LD_INT 4
56466: PUSH
56467: LD_INT 5
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: ST_TO_ADDR
56474: GO 57171
56476: LD_INT 6
56478: DOUBLE
56479: EQUAL
56480: IFTRUE 56484
56482: GO 56502
56484: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56485: LD_ADDR_VAR 0 3
56489: PUSH
56490: LD_INT 4
56492: PUSH
56493: LD_INT 5
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: ST_TO_ADDR
56500: GO 57171
56502: LD_INT 10
56504: DOUBLE
56505: EQUAL
56506: IFTRUE 56510
56508: GO 56528
56510: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56511: LD_ADDR_VAR 0 3
56515: PUSH
56516: LD_INT 4
56518: PUSH
56519: LD_INT 5
56521: PUSH
56522: EMPTY
56523: LIST
56524: LIST
56525: ST_TO_ADDR
56526: GO 57171
56528: LD_INT 22
56530: DOUBLE
56531: EQUAL
56532: IFTRUE 56536
56534: GO 56562
56536: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56537: LD_ADDR_VAR 0 3
56541: PUSH
56542: LD_INT 11
56544: PUSH
56545: LD_INT 12
56547: PUSH
56548: LD_INT 13
56550: PUSH
56551: LD_INT 14
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: LIST
56558: LIST
56559: ST_TO_ADDR
56560: GO 57171
56562: LD_INT 23
56564: DOUBLE
56565: EQUAL
56566: IFTRUE 56570
56568: GO 56596
56570: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56571: LD_ADDR_VAR 0 3
56575: PUSH
56576: LD_INT 11
56578: PUSH
56579: LD_INT 12
56581: PUSH
56582: LD_INT 13
56584: PUSH
56585: LD_INT 14
56587: PUSH
56588: EMPTY
56589: LIST
56590: LIST
56591: LIST
56592: LIST
56593: ST_TO_ADDR
56594: GO 57171
56596: LD_INT 24
56598: DOUBLE
56599: EQUAL
56600: IFTRUE 56604
56602: GO 56630
56604: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56605: LD_ADDR_VAR 0 3
56609: PUSH
56610: LD_INT 11
56612: PUSH
56613: LD_INT 12
56615: PUSH
56616: LD_INT 13
56618: PUSH
56619: LD_INT 14
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: LIST
56626: LIST
56627: ST_TO_ADDR
56628: GO 57171
56630: LD_INT 30
56632: DOUBLE
56633: EQUAL
56634: IFTRUE 56638
56636: GO 56664
56638: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56639: LD_ADDR_VAR 0 3
56643: PUSH
56644: LD_INT 11
56646: PUSH
56647: LD_INT 12
56649: PUSH
56650: LD_INT 13
56652: PUSH
56653: LD_INT 14
56655: PUSH
56656: EMPTY
56657: LIST
56658: LIST
56659: LIST
56660: LIST
56661: ST_TO_ADDR
56662: GO 57171
56664: LD_INT 25
56666: DOUBLE
56667: EQUAL
56668: IFTRUE 56672
56670: GO 56690
56672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56673: LD_ADDR_VAR 0 3
56677: PUSH
56678: LD_INT 13
56680: PUSH
56681: LD_INT 14
56683: PUSH
56684: EMPTY
56685: LIST
56686: LIST
56687: ST_TO_ADDR
56688: GO 57171
56690: LD_INT 27
56692: DOUBLE
56693: EQUAL
56694: IFTRUE 56698
56696: GO 56716
56698: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56699: LD_ADDR_VAR 0 3
56703: PUSH
56704: LD_INT 13
56706: PUSH
56707: LD_INT 14
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: ST_TO_ADDR
56714: GO 57171
56716: LD_INT 92
56718: DOUBLE
56719: EQUAL
56720: IFTRUE 56724
56722: GO 56750
56724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56725: LD_ADDR_VAR 0 3
56729: PUSH
56730: LD_INT 11
56732: PUSH
56733: LD_INT 12
56735: PUSH
56736: LD_INT 13
56738: PUSH
56739: LD_INT 14
56741: PUSH
56742: EMPTY
56743: LIST
56744: LIST
56745: LIST
56746: LIST
56747: ST_TO_ADDR
56748: GO 57171
56750: LD_INT 28
56752: DOUBLE
56753: EQUAL
56754: IFTRUE 56758
56756: GO 56776
56758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56759: LD_ADDR_VAR 0 3
56763: PUSH
56764: LD_INT 13
56766: PUSH
56767: LD_INT 14
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: ST_TO_ADDR
56774: GO 57171
56776: LD_INT 29
56778: DOUBLE
56779: EQUAL
56780: IFTRUE 56784
56782: GO 56802
56784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56785: LD_ADDR_VAR 0 3
56789: PUSH
56790: LD_INT 13
56792: PUSH
56793: LD_INT 14
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: ST_TO_ADDR
56800: GO 57171
56802: LD_INT 31
56804: DOUBLE
56805: EQUAL
56806: IFTRUE 56810
56808: GO 56828
56810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56811: LD_ADDR_VAR 0 3
56815: PUSH
56816: LD_INT 13
56818: PUSH
56819: LD_INT 14
56821: PUSH
56822: EMPTY
56823: LIST
56824: LIST
56825: ST_TO_ADDR
56826: GO 57171
56828: LD_INT 26
56830: DOUBLE
56831: EQUAL
56832: IFTRUE 56836
56834: GO 56854
56836: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56837: LD_ADDR_VAR 0 3
56841: PUSH
56842: LD_INT 13
56844: PUSH
56845: LD_INT 14
56847: PUSH
56848: EMPTY
56849: LIST
56850: LIST
56851: ST_TO_ADDR
56852: GO 57171
56854: LD_INT 42
56856: DOUBLE
56857: EQUAL
56858: IFTRUE 56862
56860: GO 56888
56862: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56863: LD_ADDR_VAR 0 3
56867: PUSH
56868: LD_INT 21
56870: PUSH
56871: LD_INT 22
56873: PUSH
56874: LD_INT 23
56876: PUSH
56877: LD_INT 24
56879: PUSH
56880: EMPTY
56881: LIST
56882: LIST
56883: LIST
56884: LIST
56885: ST_TO_ADDR
56886: GO 57171
56888: LD_INT 43
56890: DOUBLE
56891: EQUAL
56892: IFTRUE 56896
56894: GO 56922
56896: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56897: LD_ADDR_VAR 0 3
56901: PUSH
56902: LD_INT 21
56904: PUSH
56905: LD_INT 22
56907: PUSH
56908: LD_INT 23
56910: PUSH
56911: LD_INT 24
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: LIST
56918: LIST
56919: ST_TO_ADDR
56920: GO 57171
56922: LD_INT 44
56924: DOUBLE
56925: EQUAL
56926: IFTRUE 56930
56928: GO 56956
56930: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56931: LD_ADDR_VAR 0 3
56935: PUSH
56936: LD_INT 21
56938: PUSH
56939: LD_INT 22
56941: PUSH
56942: LD_INT 23
56944: PUSH
56945: LD_INT 24
56947: PUSH
56948: EMPTY
56949: LIST
56950: LIST
56951: LIST
56952: LIST
56953: ST_TO_ADDR
56954: GO 57171
56956: LD_INT 45
56958: DOUBLE
56959: EQUAL
56960: IFTRUE 56964
56962: GO 56990
56964: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56965: LD_ADDR_VAR 0 3
56969: PUSH
56970: LD_INT 21
56972: PUSH
56973: LD_INT 22
56975: PUSH
56976: LD_INT 23
56978: PUSH
56979: LD_INT 24
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: LIST
56986: LIST
56987: ST_TO_ADDR
56988: GO 57171
56990: LD_INT 49
56992: DOUBLE
56993: EQUAL
56994: IFTRUE 56998
56996: GO 57024
56998: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56999: LD_ADDR_VAR 0 3
57003: PUSH
57004: LD_INT 21
57006: PUSH
57007: LD_INT 22
57009: PUSH
57010: LD_INT 23
57012: PUSH
57013: LD_INT 24
57015: PUSH
57016: EMPTY
57017: LIST
57018: LIST
57019: LIST
57020: LIST
57021: ST_TO_ADDR
57022: GO 57171
57024: LD_INT 51
57026: DOUBLE
57027: EQUAL
57028: IFTRUE 57032
57030: GO 57058
57032: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57033: LD_ADDR_VAR 0 3
57037: PUSH
57038: LD_INT 21
57040: PUSH
57041: LD_INT 22
57043: PUSH
57044: LD_INT 23
57046: PUSH
57047: LD_INT 24
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: LIST
57054: LIST
57055: ST_TO_ADDR
57056: GO 57171
57058: LD_INT 52
57060: DOUBLE
57061: EQUAL
57062: IFTRUE 57066
57064: GO 57092
57066: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57067: LD_ADDR_VAR 0 3
57071: PUSH
57072: LD_INT 21
57074: PUSH
57075: LD_INT 22
57077: PUSH
57078: LD_INT 23
57080: PUSH
57081: LD_INT 24
57083: PUSH
57084: EMPTY
57085: LIST
57086: LIST
57087: LIST
57088: LIST
57089: ST_TO_ADDR
57090: GO 57171
57092: LD_INT 53
57094: DOUBLE
57095: EQUAL
57096: IFTRUE 57100
57098: GO 57118
57100: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57101: LD_ADDR_VAR 0 3
57105: PUSH
57106: LD_INT 23
57108: PUSH
57109: LD_INT 24
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: ST_TO_ADDR
57116: GO 57171
57118: LD_INT 46
57120: DOUBLE
57121: EQUAL
57122: IFTRUE 57126
57124: GO 57144
57126: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57127: LD_ADDR_VAR 0 3
57131: PUSH
57132: LD_INT 23
57134: PUSH
57135: LD_INT 24
57137: PUSH
57138: EMPTY
57139: LIST
57140: LIST
57141: ST_TO_ADDR
57142: GO 57171
57144: LD_INT 47
57146: DOUBLE
57147: EQUAL
57148: IFTRUE 57152
57150: GO 57170
57152: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57153: LD_ADDR_VAR 0 3
57157: PUSH
57158: LD_INT 23
57160: PUSH
57161: LD_INT 24
57163: PUSH
57164: EMPTY
57165: LIST
57166: LIST
57167: ST_TO_ADDR
57168: GO 57171
57170: POP
// result := ( chassis in result ) ;
57171: LD_ADDR_VAR 0 3
57175: PUSH
57176: LD_VAR 0 1
57180: PUSH
57181: LD_VAR 0 3
57185: IN
57186: ST_TO_ADDR
// end ;
57187: LD_VAR 0 3
57191: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57192: LD_INT 0
57194: PPUSH
57195: PPUSH
57196: PPUSH
57197: PPUSH
57198: PPUSH
57199: PPUSH
57200: PPUSH
// result := array ;
57201: LD_ADDR_VAR 0 5
57205: PUSH
57206: LD_VAR 0 1
57210: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57211: LD_VAR 0 1
57215: NOT
57216: PUSH
57217: LD_VAR 0 2
57221: NOT
57222: OR
57223: PUSH
57224: LD_VAR 0 3
57228: NOT
57229: OR
57230: PUSH
57231: LD_VAR 0 2
57235: PUSH
57236: LD_VAR 0 1
57240: GREATER
57241: OR
57242: PUSH
57243: LD_VAR 0 3
57247: PUSH
57248: LD_VAR 0 1
57252: GREATER
57253: OR
57254: IFFALSE 57258
// exit ;
57256: GO 57554
// if direction then
57258: LD_VAR 0 4
57262: IFFALSE 57326
// begin d := 1 ;
57264: LD_ADDR_VAR 0 9
57268: PUSH
57269: LD_INT 1
57271: ST_TO_ADDR
// if i_from > i_to then
57272: LD_VAR 0 2
57276: PUSH
57277: LD_VAR 0 3
57281: GREATER
57282: IFFALSE 57308
// length := ( array - i_from ) + i_to else
57284: LD_ADDR_VAR 0 11
57288: PUSH
57289: LD_VAR 0 1
57293: PUSH
57294: LD_VAR 0 2
57298: MINUS
57299: PUSH
57300: LD_VAR 0 3
57304: PLUS
57305: ST_TO_ADDR
57306: GO 57324
// length := i_to - i_from ;
57308: LD_ADDR_VAR 0 11
57312: PUSH
57313: LD_VAR 0 3
57317: PUSH
57318: LD_VAR 0 2
57322: MINUS
57323: ST_TO_ADDR
// end else
57324: GO 57387
// begin d := - 1 ;
57326: LD_ADDR_VAR 0 9
57330: PUSH
57331: LD_INT 1
57333: NEG
57334: ST_TO_ADDR
// if i_from > i_to then
57335: LD_VAR 0 2
57339: PUSH
57340: LD_VAR 0 3
57344: GREATER
57345: IFFALSE 57365
// length := i_from - i_to else
57347: LD_ADDR_VAR 0 11
57351: PUSH
57352: LD_VAR 0 2
57356: PUSH
57357: LD_VAR 0 3
57361: MINUS
57362: ST_TO_ADDR
57363: GO 57387
// length := ( array - i_to ) + i_from ;
57365: LD_ADDR_VAR 0 11
57369: PUSH
57370: LD_VAR 0 1
57374: PUSH
57375: LD_VAR 0 3
57379: MINUS
57380: PUSH
57381: LD_VAR 0 2
57385: PLUS
57386: ST_TO_ADDR
// end ; if not length then
57387: LD_VAR 0 11
57391: NOT
57392: IFFALSE 57396
// exit ;
57394: GO 57554
// tmp := array ;
57396: LD_ADDR_VAR 0 10
57400: PUSH
57401: LD_VAR 0 1
57405: ST_TO_ADDR
// for i = 1 to length do
57406: LD_ADDR_VAR 0 6
57410: PUSH
57411: DOUBLE
57412: LD_INT 1
57414: DEC
57415: ST_TO_ADDR
57416: LD_VAR 0 11
57420: PUSH
57421: FOR_TO
57422: IFFALSE 57542
// begin for j = 1 to array do
57424: LD_ADDR_VAR 0 7
57428: PUSH
57429: DOUBLE
57430: LD_INT 1
57432: DEC
57433: ST_TO_ADDR
57434: LD_VAR 0 1
57438: PUSH
57439: FOR_TO
57440: IFFALSE 57528
// begin k := j + d ;
57442: LD_ADDR_VAR 0 8
57446: PUSH
57447: LD_VAR 0 7
57451: PUSH
57452: LD_VAR 0 9
57456: PLUS
57457: ST_TO_ADDR
// if k > array then
57458: LD_VAR 0 8
57462: PUSH
57463: LD_VAR 0 1
57467: GREATER
57468: IFFALSE 57478
// k := 1 ;
57470: LD_ADDR_VAR 0 8
57474: PUSH
57475: LD_INT 1
57477: ST_TO_ADDR
// if not k then
57478: LD_VAR 0 8
57482: NOT
57483: IFFALSE 57495
// k := array ;
57485: LD_ADDR_VAR 0 8
57489: PUSH
57490: LD_VAR 0 1
57494: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57495: LD_ADDR_VAR 0 10
57499: PUSH
57500: LD_VAR 0 10
57504: PPUSH
57505: LD_VAR 0 8
57509: PPUSH
57510: LD_VAR 0 1
57514: PUSH
57515: LD_VAR 0 7
57519: ARRAY
57520: PPUSH
57521: CALL_OW 1
57525: ST_TO_ADDR
// end ;
57526: GO 57439
57528: POP
57529: POP
// array := tmp ;
57530: LD_ADDR_VAR 0 1
57534: PUSH
57535: LD_VAR 0 10
57539: ST_TO_ADDR
// end ;
57540: GO 57421
57542: POP
57543: POP
// result := array ;
57544: LD_ADDR_VAR 0 5
57548: PUSH
57549: LD_VAR 0 1
57553: ST_TO_ADDR
// end ;
57554: LD_VAR 0 5
57558: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57559: LD_INT 0
57561: PPUSH
57562: PPUSH
// result := 0 ;
57563: LD_ADDR_VAR 0 3
57567: PUSH
57568: LD_INT 0
57570: ST_TO_ADDR
// if not array or not value in array then
57571: LD_VAR 0 1
57575: NOT
57576: PUSH
57577: LD_VAR 0 2
57581: PUSH
57582: LD_VAR 0 1
57586: IN
57587: NOT
57588: OR
57589: IFFALSE 57593
// exit ;
57591: GO 57647
// for i = 1 to array do
57593: LD_ADDR_VAR 0 4
57597: PUSH
57598: DOUBLE
57599: LD_INT 1
57601: DEC
57602: ST_TO_ADDR
57603: LD_VAR 0 1
57607: PUSH
57608: FOR_TO
57609: IFFALSE 57645
// if value = array [ i ] then
57611: LD_VAR 0 2
57615: PUSH
57616: LD_VAR 0 1
57620: PUSH
57621: LD_VAR 0 4
57625: ARRAY
57626: EQUAL
57627: IFFALSE 57643
// begin result := i ;
57629: LD_ADDR_VAR 0 3
57633: PUSH
57634: LD_VAR 0 4
57638: ST_TO_ADDR
// exit ;
57639: POP
57640: POP
57641: GO 57647
// end ;
57643: GO 57608
57645: POP
57646: POP
// end ;
57647: LD_VAR 0 3
57651: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57652: LD_INT 0
57654: PPUSH
// vc_chassis := chassis ;
57655: LD_ADDR_OWVAR 37
57659: PUSH
57660: LD_VAR 0 1
57664: ST_TO_ADDR
// vc_engine := engine ;
57665: LD_ADDR_OWVAR 39
57669: PUSH
57670: LD_VAR 0 2
57674: ST_TO_ADDR
// vc_control := control ;
57675: LD_ADDR_OWVAR 38
57679: PUSH
57680: LD_VAR 0 3
57684: ST_TO_ADDR
// vc_weapon := weapon ;
57685: LD_ADDR_OWVAR 40
57689: PUSH
57690: LD_VAR 0 4
57694: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57695: LD_ADDR_OWVAR 41
57699: PUSH
57700: LD_VAR 0 5
57704: ST_TO_ADDR
// end ;
57705: LD_VAR 0 6
57709: RET
// export function WantPlant ( unit ) ; var task ; begin
57710: LD_INT 0
57712: PPUSH
57713: PPUSH
// result := false ;
57714: LD_ADDR_VAR 0 2
57718: PUSH
57719: LD_INT 0
57721: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57722: LD_ADDR_VAR 0 3
57726: PUSH
57727: LD_VAR 0 1
57731: PPUSH
57732: CALL_OW 437
57736: ST_TO_ADDR
// if task then
57737: LD_VAR 0 3
57741: IFFALSE 57769
// if task [ 1 ] [ 1 ] = p then
57743: LD_VAR 0 3
57747: PUSH
57748: LD_INT 1
57750: ARRAY
57751: PUSH
57752: LD_INT 1
57754: ARRAY
57755: PUSH
57756: LD_STRING p
57758: EQUAL
57759: IFFALSE 57769
// result := true ;
57761: LD_ADDR_VAR 0 2
57765: PUSH
57766: LD_INT 1
57768: ST_TO_ADDR
// end ;
57769: LD_VAR 0 2
57773: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57774: LD_INT 0
57776: PPUSH
57777: PPUSH
57778: PPUSH
57779: PPUSH
// if pos < 1 then
57780: LD_VAR 0 2
57784: PUSH
57785: LD_INT 1
57787: LESS
57788: IFFALSE 57792
// exit ;
57790: GO 58095
// if pos = 1 then
57792: LD_VAR 0 2
57796: PUSH
57797: LD_INT 1
57799: EQUAL
57800: IFFALSE 57833
// result := Replace ( arr , pos [ 1 ] , value ) else
57802: LD_ADDR_VAR 0 4
57806: PUSH
57807: LD_VAR 0 1
57811: PPUSH
57812: LD_VAR 0 2
57816: PUSH
57817: LD_INT 1
57819: ARRAY
57820: PPUSH
57821: LD_VAR 0 3
57825: PPUSH
57826: CALL_OW 1
57830: ST_TO_ADDR
57831: GO 58095
// begin tmp := arr ;
57833: LD_ADDR_VAR 0 6
57837: PUSH
57838: LD_VAR 0 1
57842: ST_TO_ADDR
// s_arr := [ tmp ] ;
57843: LD_ADDR_VAR 0 7
57847: PUSH
57848: LD_VAR 0 6
57852: PUSH
57853: EMPTY
57854: LIST
57855: ST_TO_ADDR
// for i = 1 to pos - 1 do
57856: LD_ADDR_VAR 0 5
57860: PUSH
57861: DOUBLE
57862: LD_INT 1
57864: DEC
57865: ST_TO_ADDR
57866: LD_VAR 0 2
57870: PUSH
57871: LD_INT 1
57873: MINUS
57874: PUSH
57875: FOR_TO
57876: IFFALSE 57921
// begin tmp := tmp [ pos [ i ] ] ;
57878: LD_ADDR_VAR 0 6
57882: PUSH
57883: LD_VAR 0 6
57887: PUSH
57888: LD_VAR 0 2
57892: PUSH
57893: LD_VAR 0 5
57897: ARRAY
57898: ARRAY
57899: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57900: LD_ADDR_VAR 0 7
57904: PUSH
57905: LD_VAR 0 7
57909: PUSH
57910: LD_VAR 0 6
57914: PUSH
57915: EMPTY
57916: LIST
57917: ADD
57918: ST_TO_ADDR
// end ;
57919: GO 57875
57921: POP
57922: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57923: LD_ADDR_VAR 0 6
57927: PUSH
57928: LD_VAR 0 6
57932: PPUSH
57933: LD_VAR 0 2
57937: PUSH
57938: LD_VAR 0 2
57942: ARRAY
57943: PPUSH
57944: LD_VAR 0 3
57948: PPUSH
57949: CALL_OW 1
57953: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57954: LD_ADDR_VAR 0 7
57958: PUSH
57959: LD_VAR 0 7
57963: PPUSH
57964: LD_VAR 0 7
57968: PPUSH
57969: LD_VAR 0 6
57973: PPUSH
57974: CALL_OW 1
57978: ST_TO_ADDR
// for i = s_arr downto 2 do
57979: LD_ADDR_VAR 0 5
57983: PUSH
57984: DOUBLE
57985: LD_VAR 0 7
57989: INC
57990: ST_TO_ADDR
57991: LD_INT 2
57993: PUSH
57994: FOR_DOWNTO
57995: IFFALSE 58079
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57997: LD_ADDR_VAR 0 6
58001: PUSH
58002: LD_VAR 0 7
58006: PUSH
58007: LD_VAR 0 5
58011: PUSH
58012: LD_INT 1
58014: MINUS
58015: ARRAY
58016: PPUSH
58017: LD_VAR 0 2
58021: PUSH
58022: LD_VAR 0 5
58026: PUSH
58027: LD_INT 1
58029: MINUS
58030: ARRAY
58031: PPUSH
58032: LD_VAR 0 7
58036: PUSH
58037: LD_VAR 0 5
58041: ARRAY
58042: PPUSH
58043: CALL_OW 1
58047: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58048: LD_ADDR_VAR 0 7
58052: PUSH
58053: LD_VAR 0 7
58057: PPUSH
58058: LD_VAR 0 5
58062: PUSH
58063: LD_INT 1
58065: MINUS
58066: PPUSH
58067: LD_VAR 0 6
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// end ;
58077: GO 57994
58079: POP
58080: POP
// result := s_arr [ 1 ] ;
58081: LD_ADDR_VAR 0 4
58085: PUSH
58086: LD_VAR 0 7
58090: PUSH
58091: LD_INT 1
58093: ARRAY
58094: ST_TO_ADDR
// end ; end ;
58095: LD_VAR 0 4
58099: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58100: LD_INT 0
58102: PPUSH
58103: PPUSH
// if not list then
58104: LD_VAR 0 1
58108: NOT
58109: IFFALSE 58113
// exit ;
58111: GO 58204
// i := list [ pos1 ] ;
58113: LD_ADDR_VAR 0 5
58117: PUSH
58118: LD_VAR 0 1
58122: PUSH
58123: LD_VAR 0 2
58127: ARRAY
58128: ST_TO_ADDR
// if not i then
58129: LD_VAR 0 5
58133: NOT
58134: IFFALSE 58138
// exit ;
58136: GO 58204
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58138: LD_ADDR_VAR 0 1
58142: PUSH
58143: LD_VAR 0 1
58147: PPUSH
58148: LD_VAR 0 2
58152: PPUSH
58153: LD_VAR 0 1
58157: PUSH
58158: LD_VAR 0 3
58162: ARRAY
58163: PPUSH
58164: CALL_OW 1
58168: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58169: LD_ADDR_VAR 0 1
58173: PUSH
58174: LD_VAR 0 1
58178: PPUSH
58179: LD_VAR 0 3
58183: PPUSH
58184: LD_VAR 0 5
58188: PPUSH
58189: CALL_OW 1
58193: ST_TO_ADDR
// result := list ;
58194: LD_ADDR_VAR 0 4
58198: PUSH
58199: LD_VAR 0 1
58203: ST_TO_ADDR
// end ;
58204: LD_VAR 0 4
58208: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58209: LD_INT 0
58211: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58212: LD_ADDR_VAR 0 5
58216: PUSH
58217: LD_VAR 0 1
58221: PPUSH
58222: CALL_OW 250
58226: PPUSH
58227: LD_VAR 0 1
58231: PPUSH
58232: CALL_OW 251
58236: PPUSH
58237: LD_VAR 0 2
58241: PPUSH
58242: LD_VAR 0 3
58246: PPUSH
58247: LD_VAR 0 4
58251: PPUSH
58252: CALL 58262 0 5
58256: ST_TO_ADDR
// end ;
58257: LD_VAR 0 5
58261: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58262: LD_INT 0
58264: PPUSH
58265: PPUSH
58266: PPUSH
58267: PPUSH
// if not list then
58268: LD_VAR 0 3
58272: NOT
58273: IFFALSE 58277
// exit ;
58275: GO 58665
// result := [ ] ;
58277: LD_ADDR_VAR 0 6
58281: PUSH
58282: EMPTY
58283: ST_TO_ADDR
// for i in list do
58284: LD_ADDR_VAR 0 7
58288: PUSH
58289: LD_VAR 0 3
58293: PUSH
58294: FOR_IN
58295: IFFALSE 58497
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58297: LD_ADDR_VAR 0 9
58301: PUSH
58302: LD_VAR 0 7
58306: PPUSH
58307: LD_VAR 0 1
58311: PPUSH
58312: LD_VAR 0 2
58316: PPUSH
58317: CALL_OW 297
58321: ST_TO_ADDR
// if not result then
58322: LD_VAR 0 6
58326: NOT
58327: IFFALSE 58353
// result := [ [ i , tmp ] ] else
58329: LD_ADDR_VAR 0 6
58333: PUSH
58334: LD_VAR 0 7
58338: PUSH
58339: LD_VAR 0 9
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: PUSH
58348: EMPTY
58349: LIST
58350: ST_TO_ADDR
58351: GO 58495
// begin if result [ result ] [ 2 ] < tmp then
58353: LD_VAR 0 6
58357: PUSH
58358: LD_VAR 0 6
58362: ARRAY
58363: PUSH
58364: LD_INT 2
58366: ARRAY
58367: PUSH
58368: LD_VAR 0 9
58372: LESS
58373: IFFALSE 58415
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58375: LD_ADDR_VAR 0 6
58379: PUSH
58380: LD_VAR 0 6
58384: PPUSH
58385: LD_VAR 0 6
58389: PUSH
58390: LD_INT 1
58392: PLUS
58393: PPUSH
58394: LD_VAR 0 7
58398: PUSH
58399: LD_VAR 0 9
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: PPUSH
58408: CALL_OW 2
58412: ST_TO_ADDR
58413: GO 58495
// for j = 1 to result do
58415: LD_ADDR_VAR 0 8
58419: PUSH
58420: DOUBLE
58421: LD_INT 1
58423: DEC
58424: ST_TO_ADDR
58425: LD_VAR 0 6
58429: PUSH
58430: FOR_TO
58431: IFFALSE 58493
// begin if tmp < result [ j ] [ 2 ] then
58433: LD_VAR 0 9
58437: PUSH
58438: LD_VAR 0 6
58442: PUSH
58443: LD_VAR 0 8
58447: ARRAY
58448: PUSH
58449: LD_INT 2
58451: ARRAY
58452: LESS
58453: IFFALSE 58491
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58455: LD_ADDR_VAR 0 6
58459: PUSH
58460: LD_VAR 0 6
58464: PPUSH
58465: LD_VAR 0 8
58469: PPUSH
58470: LD_VAR 0 7
58474: PUSH
58475: LD_VAR 0 9
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: PPUSH
58484: CALL_OW 2
58488: ST_TO_ADDR
// break ;
58489: GO 58493
// end ; end ;
58491: GO 58430
58493: POP
58494: POP
// end ; end ;
58495: GO 58294
58497: POP
58498: POP
// if result and not asc then
58499: LD_VAR 0 6
58503: PUSH
58504: LD_VAR 0 4
58508: NOT
58509: AND
58510: IFFALSE 58585
// begin tmp := result ;
58512: LD_ADDR_VAR 0 9
58516: PUSH
58517: LD_VAR 0 6
58521: ST_TO_ADDR
// for i = tmp downto 1 do
58522: LD_ADDR_VAR 0 7
58526: PUSH
58527: DOUBLE
58528: LD_VAR 0 9
58532: INC
58533: ST_TO_ADDR
58534: LD_INT 1
58536: PUSH
58537: FOR_DOWNTO
58538: IFFALSE 58583
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58540: LD_ADDR_VAR 0 6
58544: PUSH
58545: LD_VAR 0 6
58549: PPUSH
58550: LD_VAR 0 9
58554: PUSH
58555: LD_VAR 0 7
58559: MINUS
58560: PUSH
58561: LD_INT 1
58563: PLUS
58564: PPUSH
58565: LD_VAR 0 9
58569: PUSH
58570: LD_VAR 0 7
58574: ARRAY
58575: PPUSH
58576: CALL_OW 1
58580: ST_TO_ADDR
58581: GO 58537
58583: POP
58584: POP
// end ; tmp := [ ] ;
58585: LD_ADDR_VAR 0 9
58589: PUSH
58590: EMPTY
58591: ST_TO_ADDR
// if mode then
58592: LD_VAR 0 5
58596: IFFALSE 58665
// begin for i = 1 to result do
58598: LD_ADDR_VAR 0 7
58602: PUSH
58603: DOUBLE
58604: LD_INT 1
58606: DEC
58607: ST_TO_ADDR
58608: LD_VAR 0 6
58612: PUSH
58613: FOR_TO
58614: IFFALSE 58653
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58616: LD_ADDR_VAR 0 9
58620: PUSH
58621: LD_VAR 0 9
58625: PPUSH
58626: LD_VAR 0 7
58630: PPUSH
58631: LD_VAR 0 6
58635: PUSH
58636: LD_VAR 0 7
58640: ARRAY
58641: PUSH
58642: LD_INT 1
58644: ARRAY
58645: PPUSH
58646: CALL_OW 1
58650: ST_TO_ADDR
58651: GO 58613
58653: POP
58654: POP
// result := tmp ;
58655: LD_ADDR_VAR 0 6
58659: PUSH
58660: LD_VAR 0 9
58664: ST_TO_ADDR
// end ; end ;
58665: LD_VAR 0 6
58669: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58670: LD_INT 0
58672: PPUSH
58673: PPUSH
58674: PPUSH
58675: PPUSH
58676: PPUSH
58677: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58678: LD_ADDR_VAR 0 5
58682: PUSH
58683: LD_INT 0
58685: PUSH
58686: LD_INT 0
58688: PUSH
58689: LD_INT 0
58691: PUSH
58692: EMPTY
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: LIST
58698: LIST
58699: ST_TO_ADDR
// if not x or not y then
58700: LD_VAR 0 2
58704: NOT
58705: PUSH
58706: LD_VAR 0 3
58710: NOT
58711: OR
58712: IFFALSE 58716
// exit ;
58714: GO 60366
// if not range then
58716: LD_VAR 0 4
58720: NOT
58721: IFFALSE 58731
// range := 10 ;
58723: LD_ADDR_VAR 0 4
58727: PUSH
58728: LD_INT 10
58730: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58731: LD_ADDR_VAR 0 8
58735: PUSH
58736: LD_INT 81
58738: PUSH
58739: LD_VAR 0 1
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: PUSH
58748: LD_INT 92
58750: PUSH
58751: LD_VAR 0 2
58755: PUSH
58756: LD_VAR 0 3
58760: PUSH
58761: LD_VAR 0 4
58765: PUSH
58766: EMPTY
58767: LIST
58768: LIST
58769: LIST
58770: LIST
58771: PUSH
58772: LD_INT 3
58774: PUSH
58775: LD_INT 21
58777: PUSH
58778: LD_INT 3
58780: PUSH
58781: EMPTY
58782: LIST
58783: LIST
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: LIST
58793: PPUSH
58794: CALL_OW 69
58798: ST_TO_ADDR
// if not tmp then
58799: LD_VAR 0 8
58803: NOT
58804: IFFALSE 58808
// exit ;
58806: GO 60366
// for i in tmp do
58808: LD_ADDR_VAR 0 6
58812: PUSH
58813: LD_VAR 0 8
58817: PUSH
58818: FOR_IN
58819: IFFALSE 60341
// begin points := [ 0 , 0 , 0 ] ;
58821: LD_ADDR_VAR 0 9
58825: PUSH
58826: LD_INT 0
58828: PUSH
58829: LD_INT 0
58831: PUSH
58832: LD_INT 0
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: LIST
58839: ST_TO_ADDR
// bpoints := 1 ;
58840: LD_ADDR_VAR 0 10
58844: PUSH
58845: LD_INT 1
58847: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58848: LD_VAR 0 6
58852: PPUSH
58853: CALL_OW 247
58857: PUSH
58858: LD_INT 1
58860: DOUBLE
58861: EQUAL
58862: IFTRUE 58866
58864: GO 59444
58866: POP
// begin if GetClass ( i ) = 1 then
58867: LD_VAR 0 6
58871: PPUSH
58872: CALL_OW 257
58876: PUSH
58877: LD_INT 1
58879: EQUAL
58880: IFFALSE 58901
// points := [ 10 , 5 , 3 ] ;
58882: LD_ADDR_VAR 0 9
58886: PUSH
58887: LD_INT 10
58889: PUSH
58890: LD_INT 5
58892: PUSH
58893: LD_INT 3
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: LIST
58900: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58901: LD_VAR 0 6
58905: PPUSH
58906: CALL_OW 257
58910: PUSH
58911: LD_INT 2
58913: PUSH
58914: LD_INT 3
58916: PUSH
58917: LD_INT 4
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: LIST
58924: IN
58925: IFFALSE 58946
// points := [ 3 , 2 , 1 ] ;
58927: LD_ADDR_VAR 0 9
58931: PUSH
58932: LD_INT 3
58934: PUSH
58935: LD_INT 2
58937: PUSH
58938: LD_INT 1
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: LIST
58945: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58946: LD_VAR 0 6
58950: PPUSH
58951: CALL_OW 257
58955: PUSH
58956: LD_INT 5
58958: EQUAL
58959: IFFALSE 58980
// points := [ 130 , 5 , 2 ] ;
58961: LD_ADDR_VAR 0 9
58965: PUSH
58966: LD_INT 130
58968: PUSH
58969: LD_INT 5
58971: PUSH
58972: LD_INT 2
58974: PUSH
58975: EMPTY
58976: LIST
58977: LIST
58978: LIST
58979: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58980: LD_VAR 0 6
58984: PPUSH
58985: CALL_OW 257
58989: PUSH
58990: LD_INT 8
58992: EQUAL
58993: IFFALSE 59014
// points := [ 35 , 35 , 30 ] ;
58995: LD_ADDR_VAR 0 9
58999: PUSH
59000: LD_INT 35
59002: PUSH
59003: LD_INT 35
59005: PUSH
59006: LD_INT 30
59008: PUSH
59009: EMPTY
59010: LIST
59011: LIST
59012: LIST
59013: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59014: LD_VAR 0 6
59018: PPUSH
59019: CALL_OW 257
59023: PUSH
59024: LD_INT 9
59026: EQUAL
59027: IFFALSE 59048
// points := [ 20 , 55 , 40 ] ;
59029: LD_ADDR_VAR 0 9
59033: PUSH
59034: LD_INT 20
59036: PUSH
59037: LD_INT 55
59039: PUSH
59040: LD_INT 40
59042: PUSH
59043: EMPTY
59044: LIST
59045: LIST
59046: LIST
59047: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59048: LD_VAR 0 6
59052: PPUSH
59053: CALL_OW 257
59057: PUSH
59058: LD_INT 12
59060: PUSH
59061: LD_INT 16
59063: PUSH
59064: EMPTY
59065: LIST
59066: LIST
59067: IN
59068: IFFALSE 59089
// points := [ 5 , 3 , 2 ] ;
59070: LD_ADDR_VAR 0 9
59074: PUSH
59075: LD_INT 5
59077: PUSH
59078: LD_INT 3
59080: PUSH
59081: LD_INT 2
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: LIST
59088: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59089: LD_VAR 0 6
59093: PPUSH
59094: CALL_OW 257
59098: PUSH
59099: LD_INT 17
59101: EQUAL
59102: IFFALSE 59123
// points := [ 100 , 50 , 75 ] ;
59104: LD_ADDR_VAR 0 9
59108: PUSH
59109: LD_INT 100
59111: PUSH
59112: LD_INT 50
59114: PUSH
59115: LD_INT 75
59117: PUSH
59118: EMPTY
59119: LIST
59120: LIST
59121: LIST
59122: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59123: LD_VAR 0 6
59127: PPUSH
59128: CALL_OW 257
59132: PUSH
59133: LD_INT 15
59135: EQUAL
59136: IFFALSE 59157
// points := [ 10 , 5 , 3 ] ;
59138: LD_ADDR_VAR 0 9
59142: PUSH
59143: LD_INT 10
59145: PUSH
59146: LD_INT 5
59148: PUSH
59149: LD_INT 3
59151: PUSH
59152: EMPTY
59153: LIST
59154: LIST
59155: LIST
59156: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59157: LD_VAR 0 6
59161: PPUSH
59162: CALL_OW 257
59166: PUSH
59167: LD_INT 14
59169: EQUAL
59170: IFFALSE 59191
// points := [ 10 , 0 , 0 ] ;
59172: LD_ADDR_VAR 0 9
59176: PUSH
59177: LD_INT 10
59179: PUSH
59180: LD_INT 0
59182: PUSH
59183: LD_INT 0
59185: PUSH
59186: EMPTY
59187: LIST
59188: LIST
59189: LIST
59190: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59191: LD_VAR 0 6
59195: PPUSH
59196: CALL_OW 257
59200: PUSH
59201: LD_INT 11
59203: EQUAL
59204: IFFALSE 59225
// points := [ 30 , 10 , 5 ] ;
59206: LD_ADDR_VAR 0 9
59210: PUSH
59211: LD_INT 30
59213: PUSH
59214: LD_INT 10
59216: PUSH
59217: LD_INT 5
59219: PUSH
59220: EMPTY
59221: LIST
59222: LIST
59223: LIST
59224: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59225: LD_VAR 0 1
59229: PPUSH
59230: LD_INT 5
59232: PPUSH
59233: CALL_OW 321
59237: PUSH
59238: LD_INT 2
59240: EQUAL
59241: IFFALSE 59258
// bpoints := bpoints * 1.8 ;
59243: LD_ADDR_VAR 0 10
59247: PUSH
59248: LD_VAR 0 10
59252: PUSH
59253: LD_REAL  1.80000000000000E+0000
59256: MUL
59257: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59258: LD_VAR 0 6
59262: PPUSH
59263: CALL_OW 257
59267: PUSH
59268: LD_INT 1
59270: PUSH
59271: LD_INT 2
59273: PUSH
59274: LD_INT 3
59276: PUSH
59277: LD_INT 4
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: LIST
59284: LIST
59285: IN
59286: PUSH
59287: LD_VAR 0 1
59291: PPUSH
59292: LD_INT 51
59294: PPUSH
59295: CALL_OW 321
59299: PUSH
59300: LD_INT 2
59302: EQUAL
59303: AND
59304: IFFALSE 59321
// bpoints := bpoints * 1.2 ;
59306: LD_ADDR_VAR 0 10
59310: PUSH
59311: LD_VAR 0 10
59315: PUSH
59316: LD_REAL  1.20000000000000E+0000
59319: MUL
59320: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59321: LD_VAR 0 6
59325: PPUSH
59326: CALL_OW 257
59330: PUSH
59331: LD_INT 5
59333: PUSH
59334: LD_INT 7
59336: PUSH
59337: LD_INT 9
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: LIST
59344: IN
59345: PUSH
59346: LD_VAR 0 1
59350: PPUSH
59351: LD_INT 52
59353: PPUSH
59354: CALL_OW 321
59358: PUSH
59359: LD_INT 2
59361: EQUAL
59362: AND
59363: IFFALSE 59380
// bpoints := bpoints * 1.5 ;
59365: LD_ADDR_VAR 0 10
59369: PUSH
59370: LD_VAR 0 10
59374: PUSH
59375: LD_REAL  1.50000000000000E+0000
59378: MUL
59379: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59380: LD_VAR 0 1
59384: PPUSH
59385: LD_INT 66
59387: PPUSH
59388: CALL_OW 321
59392: PUSH
59393: LD_INT 2
59395: EQUAL
59396: IFFALSE 59413
// bpoints := bpoints * 1.1 ;
59398: LD_ADDR_VAR 0 10
59402: PUSH
59403: LD_VAR 0 10
59407: PUSH
59408: LD_REAL  1.10000000000000E+0000
59411: MUL
59412: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59413: LD_ADDR_VAR 0 10
59417: PUSH
59418: LD_VAR 0 10
59422: PUSH
59423: LD_VAR 0 6
59427: PPUSH
59428: LD_INT 1
59430: PPUSH
59431: CALL_OW 259
59435: PUSH
59436: LD_REAL  1.15000000000000E+0000
59439: MUL
59440: MUL
59441: ST_TO_ADDR
// end ; unit_vehicle :
59442: GO 60270
59444: LD_INT 2
59446: DOUBLE
59447: EQUAL
59448: IFTRUE 59452
59450: GO 60258
59452: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59453: LD_VAR 0 6
59457: PPUSH
59458: CALL_OW 264
59462: PUSH
59463: LD_INT 2
59465: PUSH
59466: LD_INT 42
59468: PUSH
59469: LD_INT 24
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: LIST
59476: IN
59477: IFFALSE 59498
// points := [ 25 , 5 , 3 ] ;
59479: LD_ADDR_VAR 0 9
59483: PUSH
59484: LD_INT 25
59486: PUSH
59487: LD_INT 5
59489: PUSH
59490: LD_INT 3
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: LIST
59497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59498: LD_VAR 0 6
59502: PPUSH
59503: CALL_OW 264
59507: PUSH
59508: LD_INT 4
59510: PUSH
59511: LD_INT 43
59513: PUSH
59514: LD_INT 25
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: LIST
59521: IN
59522: IFFALSE 59543
// points := [ 40 , 15 , 5 ] ;
59524: LD_ADDR_VAR 0 9
59528: PUSH
59529: LD_INT 40
59531: PUSH
59532: LD_INT 15
59534: PUSH
59535: LD_INT 5
59537: PUSH
59538: EMPTY
59539: LIST
59540: LIST
59541: LIST
59542: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59543: LD_VAR 0 6
59547: PPUSH
59548: CALL_OW 264
59552: PUSH
59553: LD_INT 3
59555: PUSH
59556: LD_INT 23
59558: PUSH
59559: EMPTY
59560: LIST
59561: LIST
59562: IN
59563: IFFALSE 59584
// points := [ 7 , 25 , 8 ] ;
59565: LD_ADDR_VAR 0 9
59569: PUSH
59570: LD_INT 7
59572: PUSH
59573: LD_INT 25
59575: PUSH
59576: LD_INT 8
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: LIST
59583: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59584: LD_VAR 0 6
59588: PPUSH
59589: CALL_OW 264
59593: PUSH
59594: LD_INT 5
59596: PUSH
59597: LD_INT 27
59599: PUSH
59600: LD_INT 44
59602: PUSH
59603: EMPTY
59604: LIST
59605: LIST
59606: LIST
59607: IN
59608: IFFALSE 59629
// points := [ 14 , 50 , 16 ] ;
59610: LD_ADDR_VAR 0 9
59614: PUSH
59615: LD_INT 14
59617: PUSH
59618: LD_INT 50
59620: PUSH
59621: LD_INT 16
59623: PUSH
59624: EMPTY
59625: LIST
59626: LIST
59627: LIST
59628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59629: LD_VAR 0 6
59633: PPUSH
59634: CALL_OW 264
59638: PUSH
59639: LD_INT 6
59641: PUSH
59642: LD_INT 46
59644: PUSH
59645: EMPTY
59646: LIST
59647: LIST
59648: IN
59649: IFFALSE 59670
// points := [ 32 , 120 , 70 ] ;
59651: LD_ADDR_VAR 0 9
59655: PUSH
59656: LD_INT 32
59658: PUSH
59659: LD_INT 120
59661: PUSH
59662: LD_INT 70
59664: PUSH
59665: EMPTY
59666: LIST
59667: LIST
59668: LIST
59669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59670: LD_VAR 0 6
59674: PPUSH
59675: CALL_OW 264
59679: PUSH
59680: LD_INT 7
59682: PUSH
59683: LD_INT 28
59685: PUSH
59686: LD_INT 45
59688: PUSH
59689: LD_INT 92
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: LIST
59696: LIST
59697: IN
59698: IFFALSE 59719
// points := [ 35 , 20 , 45 ] ;
59700: LD_ADDR_VAR 0 9
59704: PUSH
59705: LD_INT 35
59707: PUSH
59708: LD_INT 20
59710: PUSH
59711: LD_INT 45
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: LIST
59718: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59719: LD_VAR 0 6
59723: PPUSH
59724: CALL_OW 264
59728: PUSH
59729: LD_INT 47
59731: PUSH
59732: EMPTY
59733: LIST
59734: IN
59735: IFFALSE 59756
// points := [ 67 , 45 , 75 ] ;
59737: LD_ADDR_VAR 0 9
59741: PUSH
59742: LD_INT 67
59744: PUSH
59745: LD_INT 45
59747: PUSH
59748: LD_INT 75
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: LIST
59755: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59756: LD_VAR 0 6
59760: PPUSH
59761: CALL_OW 264
59765: PUSH
59766: LD_INT 26
59768: PUSH
59769: EMPTY
59770: LIST
59771: IN
59772: IFFALSE 59793
// points := [ 120 , 30 , 80 ] ;
59774: LD_ADDR_VAR 0 9
59778: PUSH
59779: LD_INT 120
59781: PUSH
59782: LD_INT 30
59784: PUSH
59785: LD_INT 80
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: LIST
59792: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59793: LD_VAR 0 6
59797: PPUSH
59798: CALL_OW 264
59802: PUSH
59803: LD_INT 22
59805: PUSH
59806: EMPTY
59807: LIST
59808: IN
59809: IFFALSE 59830
// points := [ 40 , 1 , 1 ] ;
59811: LD_ADDR_VAR 0 9
59815: PUSH
59816: LD_INT 40
59818: PUSH
59819: LD_INT 1
59821: PUSH
59822: LD_INT 1
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: LIST
59829: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59830: LD_VAR 0 6
59834: PPUSH
59835: CALL_OW 264
59839: PUSH
59840: LD_INT 29
59842: PUSH
59843: EMPTY
59844: LIST
59845: IN
59846: IFFALSE 59867
// points := [ 70 , 200 , 400 ] ;
59848: LD_ADDR_VAR 0 9
59852: PUSH
59853: LD_INT 70
59855: PUSH
59856: LD_INT 200
59858: PUSH
59859: LD_INT 400
59861: PUSH
59862: EMPTY
59863: LIST
59864: LIST
59865: LIST
59866: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59867: LD_VAR 0 6
59871: PPUSH
59872: CALL_OW 264
59876: PUSH
59877: LD_INT 14
59879: PUSH
59880: LD_INT 53
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: IN
59887: IFFALSE 59908
// points := [ 40 , 10 , 20 ] ;
59889: LD_ADDR_VAR 0 9
59893: PUSH
59894: LD_INT 40
59896: PUSH
59897: LD_INT 10
59899: PUSH
59900: LD_INT 20
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: LIST
59907: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59908: LD_VAR 0 6
59912: PPUSH
59913: CALL_OW 264
59917: PUSH
59918: LD_INT 9
59920: PUSH
59921: EMPTY
59922: LIST
59923: IN
59924: IFFALSE 59945
// points := [ 5 , 70 , 20 ] ;
59926: LD_ADDR_VAR 0 9
59930: PUSH
59931: LD_INT 5
59933: PUSH
59934: LD_INT 70
59936: PUSH
59937: LD_INT 20
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: LIST
59944: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59945: LD_VAR 0 6
59949: PPUSH
59950: CALL_OW 264
59954: PUSH
59955: LD_INT 10
59957: PUSH
59958: EMPTY
59959: LIST
59960: IN
59961: IFFALSE 59982
// points := [ 35 , 110 , 70 ] ;
59963: LD_ADDR_VAR 0 9
59967: PUSH
59968: LD_INT 35
59970: PUSH
59971: LD_INT 110
59973: PUSH
59974: LD_INT 70
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: LIST
59981: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59982: LD_VAR 0 6
59986: PPUSH
59987: CALL_OW 265
59991: PUSH
59992: LD_INT 25
59994: EQUAL
59995: IFFALSE 60016
// points := [ 80 , 65 , 100 ] ;
59997: LD_ADDR_VAR 0 9
60001: PUSH
60002: LD_INT 80
60004: PUSH
60005: LD_INT 65
60007: PUSH
60008: LD_INT 100
60010: PUSH
60011: EMPTY
60012: LIST
60013: LIST
60014: LIST
60015: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60016: LD_VAR 0 6
60020: PPUSH
60021: CALL_OW 263
60025: PUSH
60026: LD_INT 1
60028: EQUAL
60029: IFFALSE 60064
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60031: LD_ADDR_VAR 0 10
60035: PUSH
60036: LD_VAR 0 10
60040: PUSH
60041: LD_VAR 0 6
60045: PPUSH
60046: CALL_OW 311
60050: PPUSH
60051: LD_INT 3
60053: PPUSH
60054: CALL_OW 259
60058: PUSH
60059: LD_INT 4
60061: MUL
60062: MUL
60063: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60064: LD_VAR 0 6
60068: PPUSH
60069: CALL_OW 263
60073: PUSH
60074: LD_INT 2
60076: EQUAL
60077: IFFALSE 60128
// begin j := IsControledBy ( i ) ;
60079: LD_ADDR_VAR 0 7
60083: PUSH
60084: LD_VAR 0 6
60088: PPUSH
60089: CALL_OW 312
60093: ST_TO_ADDR
// if j then
60094: LD_VAR 0 7
60098: IFFALSE 60128
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60100: LD_ADDR_VAR 0 10
60104: PUSH
60105: LD_VAR 0 10
60109: PUSH
60110: LD_VAR 0 7
60114: PPUSH
60115: LD_INT 3
60117: PPUSH
60118: CALL_OW 259
60122: PUSH
60123: LD_INT 3
60125: MUL
60126: MUL
60127: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60128: LD_VAR 0 6
60132: PPUSH
60133: CALL_OW 264
60137: PUSH
60138: LD_INT 5
60140: PUSH
60141: LD_INT 6
60143: PUSH
60144: LD_INT 46
60146: PUSH
60147: LD_INT 44
60149: PUSH
60150: LD_INT 47
60152: PUSH
60153: LD_INT 45
60155: PUSH
60156: LD_INT 28
60158: PUSH
60159: LD_INT 7
60161: PUSH
60162: LD_INT 27
60164: PUSH
60165: LD_INT 29
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: LIST
60172: LIST
60173: LIST
60174: LIST
60175: LIST
60176: LIST
60177: LIST
60178: LIST
60179: IN
60180: PUSH
60181: LD_VAR 0 1
60185: PPUSH
60186: LD_INT 52
60188: PPUSH
60189: CALL_OW 321
60193: PUSH
60194: LD_INT 2
60196: EQUAL
60197: AND
60198: IFFALSE 60215
// bpoints := bpoints * 1.2 ;
60200: LD_ADDR_VAR 0 10
60204: PUSH
60205: LD_VAR 0 10
60209: PUSH
60210: LD_REAL  1.20000000000000E+0000
60213: MUL
60214: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60215: LD_VAR 0 6
60219: PPUSH
60220: CALL_OW 264
60224: PUSH
60225: LD_INT 6
60227: PUSH
60228: LD_INT 46
60230: PUSH
60231: LD_INT 47
60233: PUSH
60234: EMPTY
60235: LIST
60236: LIST
60237: LIST
60238: IN
60239: IFFALSE 60256
// bpoints := bpoints * 1.2 ;
60241: LD_ADDR_VAR 0 10
60245: PUSH
60246: LD_VAR 0 10
60250: PUSH
60251: LD_REAL  1.20000000000000E+0000
60254: MUL
60255: ST_TO_ADDR
// end ; unit_building :
60256: GO 60270
60258: LD_INT 3
60260: DOUBLE
60261: EQUAL
60262: IFTRUE 60266
60264: GO 60269
60266: POP
// ; end ;
60267: GO 60270
60269: POP
// for j = 1 to 3 do
60270: LD_ADDR_VAR 0 7
60274: PUSH
60275: DOUBLE
60276: LD_INT 1
60278: DEC
60279: ST_TO_ADDR
60280: LD_INT 3
60282: PUSH
60283: FOR_TO
60284: IFFALSE 60337
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60286: LD_ADDR_VAR 0 5
60290: PUSH
60291: LD_VAR 0 5
60295: PPUSH
60296: LD_VAR 0 7
60300: PPUSH
60301: LD_VAR 0 5
60305: PUSH
60306: LD_VAR 0 7
60310: ARRAY
60311: PUSH
60312: LD_VAR 0 9
60316: PUSH
60317: LD_VAR 0 7
60321: ARRAY
60322: PUSH
60323: LD_VAR 0 10
60327: MUL
60328: PLUS
60329: PPUSH
60330: CALL_OW 1
60334: ST_TO_ADDR
60335: GO 60283
60337: POP
60338: POP
// end ;
60339: GO 58818
60341: POP
60342: POP
// result := Replace ( result , 4 , tmp ) ;
60343: LD_ADDR_VAR 0 5
60347: PUSH
60348: LD_VAR 0 5
60352: PPUSH
60353: LD_INT 4
60355: PPUSH
60356: LD_VAR 0 8
60360: PPUSH
60361: CALL_OW 1
60365: ST_TO_ADDR
// end ;
60366: LD_VAR 0 5
60370: RET
// export function DangerAtRange ( unit , range ) ; begin
60371: LD_INT 0
60373: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60374: LD_ADDR_VAR 0 3
60378: PUSH
60379: LD_VAR 0 1
60383: PPUSH
60384: CALL_OW 255
60388: PPUSH
60389: LD_VAR 0 1
60393: PPUSH
60394: CALL_OW 250
60398: PPUSH
60399: LD_VAR 0 1
60403: PPUSH
60404: CALL_OW 251
60408: PPUSH
60409: LD_VAR 0 2
60413: PPUSH
60414: CALL 58670 0 4
60418: ST_TO_ADDR
// end ;
60419: LD_VAR 0 3
60423: RET
// export function DangerInArea ( side , area ) ; begin
60424: LD_INT 0
60426: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60427: LD_ADDR_VAR 0 3
60431: PUSH
60432: LD_VAR 0 2
60436: PPUSH
60437: LD_INT 81
60439: PUSH
60440: LD_VAR 0 1
60444: PUSH
60445: EMPTY
60446: LIST
60447: LIST
60448: PPUSH
60449: CALL_OW 70
60453: ST_TO_ADDR
// end ;
60454: LD_VAR 0 3
60458: RET
// export function IsExtension ( b ) ; begin
60459: LD_INT 0
60461: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60462: LD_ADDR_VAR 0 2
60466: PUSH
60467: LD_VAR 0 1
60471: PUSH
60472: LD_INT 23
60474: PUSH
60475: LD_INT 20
60477: PUSH
60478: LD_INT 22
60480: PUSH
60481: LD_INT 17
60483: PUSH
60484: LD_INT 24
60486: PUSH
60487: LD_INT 21
60489: PUSH
60490: LD_INT 19
60492: PUSH
60493: LD_INT 16
60495: PUSH
60496: LD_INT 25
60498: PUSH
60499: LD_INT 18
60501: PUSH
60502: EMPTY
60503: LIST
60504: LIST
60505: LIST
60506: LIST
60507: LIST
60508: LIST
60509: LIST
60510: LIST
60511: LIST
60512: LIST
60513: IN
60514: ST_TO_ADDR
// end ;
60515: LD_VAR 0 2
60519: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
60520: LD_INT 0
60522: PPUSH
60523: PPUSH
60524: PPUSH
// result := [ ] ;
60525: LD_ADDR_VAR 0 4
60529: PUSH
60530: EMPTY
60531: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60532: LD_ADDR_VAR 0 5
60536: PUSH
60537: LD_VAR 0 2
60541: PPUSH
60542: LD_INT 21
60544: PUSH
60545: LD_INT 3
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PPUSH
60552: CALL_OW 70
60556: ST_TO_ADDR
// if not tmp then
60557: LD_VAR 0 5
60561: NOT
60562: IFFALSE 60566
// exit ;
60564: GO 60630
// if checkLink then
60566: LD_VAR 0 3
60570: IFFALSE 60620
// begin for i in tmp do
60572: LD_ADDR_VAR 0 6
60576: PUSH
60577: LD_VAR 0 5
60581: PUSH
60582: FOR_IN
60583: IFFALSE 60618
// if GetBase ( i ) <> base then
60585: LD_VAR 0 6
60589: PPUSH
60590: CALL_OW 274
60594: PUSH
60595: LD_VAR 0 1
60599: NONEQUAL
60600: IFFALSE 60616
// ComLinkToBase ( base , i ) ;
60602: LD_VAR 0 1
60606: PPUSH
60607: LD_VAR 0 6
60611: PPUSH
60612: CALL_OW 169
60616: GO 60582
60618: POP
60619: POP
// end ; result := tmp ;
60620: LD_ADDR_VAR 0 4
60624: PUSH
60625: LD_VAR 0 5
60629: ST_TO_ADDR
// end ;
60630: LD_VAR 0 4
60634: RET
// export function ComComplete ( units , b ) ; var i ; begin
60635: LD_INT 0
60637: PPUSH
60638: PPUSH
// if not units then
60639: LD_VAR 0 1
60643: NOT
60644: IFFALSE 60648
// exit ;
60646: GO 60738
// for i in units do
60648: LD_ADDR_VAR 0 4
60652: PUSH
60653: LD_VAR 0 1
60657: PUSH
60658: FOR_IN
60659: IFFALSE 60736
// if BuildingStatus ( b ) = bs_build then
60661: LD_VAR 0 2
60665: PPUSH
60666: CALL_OW 461
60670: PUSH
60671: LD_INT 1
60673: EQUAL
60674: IFFALSE 60734
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60676: LD_VAR 0 4
60680: PPUSH
60681: LD_STRING h
60683: PUSH
60684: LD_VAR 0 2
60688: PPUSH
60689: CALL_OW 250
60693: PUSH
60694: LD_VAR 0 2
60698: PPUSH
60699: CALL_OW 251
60703: PUSH
60704: LD_VAR 0 2
60708: PUSH
60709: LD_INT 0
60711: PUSH
60712: LD_INT 0
60714: PUSH
60715: LD_INT 0
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: LIST
60722: LIST
60723: LIST
60724: LIST
60725: LIST
60726: PUSH
60727: EMPTY
60728: LIST
60729: PPUSH
60730: CALL_OW 446
60734: GO 60658
60736: POP
60737: POP
// end ;
60738: LD_VAR 0 3
60742: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60743: LD_INT 0
60745: PPUSH
60746: PPUSH
60747: PPUSH
60748: PPUSH
60749: PPUSH
60750: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60751: LD_VAR 0 1
60755: NOT
60756: PUSH
60757: LD_VAR 0 1
60761: PPUSH
60762: CALL_OW 263
60766: PUSH
60767: LD_INT 2
60769: NONEQUAL
60770: OR
60771: IFFALSE 60775
// exit ;
60773: GO 61091
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60775: LD_ADDR_VAR 0 6
60779: PUSH
60780: LD_INT 22
60782: PUSH
60783: LD_VAR 0 1
60787: PPUSH
60788: CALL_OW 255
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: PUSH
60797: LD_INT 2
60799: PUSH
60800: LD_INT 30
60802: PUSH
60803: LD_INT 36
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: LD_INT 34
60812: PUSH
60813: LD_INT 31
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PUSH
60820: EMPTY
60821: LIST
60822: LIST
60823: LIST
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PPUSH
60829: CALL_OW 69
60833: ST_TO_ADDR
// if not tmp then
60834: LD_VAR 0 6
60838: NOT
60839: IFFALSE 60843
// exit ;
60841: GO 61091
// result := [ ] ;
60843: LD_ADDR_VAR 0 2
60847: PUSH
60848: EMPTY
60849: ST_TO_ADDR
// for i in tmp do
60850: LD_ADDR_VAR 0 3
60854: PUSH
60855: LD_VAR 0 6
60859: PUSH
60860: FOR_IN
60861: IFFALSE 60932
// begin t := UnitsInside ( i ) ;
60863: LD_ADDR_VAR 0 4
60867: PUSH
60868: LD_VAR 0 3
60872: PPUSH
60873: CALL_OW 313
60877: ST_TO_ADDR
// if t then
60878: LD_VAR 0 4
60882: IFFALSE 60930
// for j in t do
60884: LD_ADDR_VAR 0 7
60888: PUSH
60889: LD_VAR 0 4
60893: PUSH
60894: FOR_IN
60895: IFFALSE 60928
// result := Replace ( result , result + 1 , j ) ;
60897: LD_ADDR_VAR 0 2
60901: PUSH
60902: LD_VAR 0 2
60906: PPUSH
60907: LD_VAR 0 2
60911: PUSH
60912: LD_INT 1
60914: PLUS
60915: PPUSH
60916: LD_VAR 0 7
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
60926: GO 60894
60928: POP
60929: POP
// end ;
60930: GO 60860
60932: POP
60933: POP
// if not result then
60934: LD_VAR 0 2
60938: NOT
60939: IFFALSE 60943
// exit ;
60941: GO 61091
// mech := result [ 1 ] ;
60943: LD_ADDR_VAR 0 5
60947: PUSH
60948: LD_VAR 0 2
60952: PUSH
60953: LD_INT 1
60955: ARRAY
60956: ST_TO_ADDR
// if result > 1 then
60957: LD_VAR 0 2
60961: PUSH
60962: LD_INT 1
60964: GREATER
60965: IFFALSE 61077
// begin for i = 2 to result do
60967: LD_ADDR_VAR 0 3
60971: PUSH
60972: DOUBLE
60973: LD_INT 2
60975: DEC
60976: ST_TO_ADDR
60977: LD_VAR 0 2
60981: PUSH
60982: FOR_TO
60983: IFFALSE 61075
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60985: LD_ADDR_VAR 0 4
60989: PUSH
60990: LD_VAR 0 2
60994: PUSH
60995: LD_VAR 0 3
60999: ARRAY
61000: PPUSH
61001: LD_INT 3
61003: PPUSH
61004: CALL_OW 259
61008: PUSH
61009: LD_VAR 0 2
61013: PUSH
61014: LD_VAR 0 3
61018: ARRAY
61019: PPUSH
61020: CALL_OW 432
61024: MINUS
61025: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61026: LD_VAR 0 4
61030: PUSH
61031: LD_VAR 0 5
61035: PPUSH
61036: LD_INT 3
61038: PPUSH
61039: CALL_OW 259
61043: PUSH
61044: LD_VAR 0 5
61048: PPUSH
61049: CALL_OW 432
61053: MINUS
61054: GREATEREQUAL
61055: IFFALSE 61073
// mech := result [ i ] ;
61057: LD_ADDR_VAR 0 5
61061: PUSH
61062: LD_VAR 0 2
61066: PUSH
61067: LD_VAR 0 3
61071: ARRAY
61072: ST_TO_ADDR
// end ;
61073: GO 60982
61075: POP
61076: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61077: LD_VAR 0 1
61081: PPUSH
61082: LD_VAR 0 5
61086: PPUSH
61087: CALL_OW 135
// end ;
61091: LD_VAR 0 2
61095: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61096: LD_INT 0
61098: PPUSH
61099: PPUSH
61100: PPUSH
61101: PPUSH
61102: PPUSH
61103: PPUSH
61104: PPUSH
61105: PPUSH
61106: PPUSH
61107: PPUSH
61108: PPUSH
61109: PPUSH
61110: PPUSH
// result := [ ] ;
61111: LD_ADDR_VAR 0 7
61115: PUSH
61116: EMPTY
61117: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61118: LD_VAR 0 1
61122: PPUSH
61123: CALL_OW 266
61127: PUSH
61128: LD_INT 0
61130: PUSH
61131: LD_INT 1
61133: PUSH
61134: EMPTY
61135: LIST
61136: LIST
61137: IN
61138: NOT
61139: IFFALSE 61143
// exit ;
61141: GO 62777
// if name then
61143: LD_VAR 0 3
61147: IFFALSE 61163
// SetBName ( base_dep , name ) ;
61149: LD_VAR 0 1
61153: PPUSH
61154: LD_VAR 0 3
61158: PPUSH
61159: CALL_OW 500
// base := GetBase ( base_dep ) ;
61163: LD_ADDR_VAR 0 15
61167: PUSH
61168: LD_VAR 0 1
61172: PPUSH
61173: CALL_OW 274
61177: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61178: LD_ADDR_VAR 0 16
61182: PUSH
61183: LD_VAR 0 1
61187: PPUSH
61188: CALL_OW 255
61192: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61193: LD_ADDR_VAR 0 17
61197: PUSH
61198: LD_VAR 0 1
61202: PPUSH
61203: CALL_OW 248
61207: ST_TO_ADDR
// if sources then
61208: LD_VAR 0 5
61212: IFFALSE 61259
// for i = 1 to 3 do
61214: LD_ADDR_VAR 0 8
61218: PUSH
61219: DOUBLE
61220: LD_INT 1
61222: DEC
61223: ST_TO_ADDR
61224: LD_INT 3
61226: PUSH
61227: FOR_TO
61228: IFFALSE 61257
// AddResourceType ( base , i , sources [ i ] ) ;
61230: LD_VAR 0 15
61234: PPUSH
61235: LD_VAR 0 8
61239: PPUSH
61240: LD_VAR 0 5
61244: PUSH
61245: LD_VAR 0 8
61249: ARRAY
61250: PPUSH
61251: CALL_OW 276
61255: GO 61227
61257: POP
61258: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
61259: LD_ADDR_VAR 0 18
61263: PUSH
61264: LD_VAR 0 15
61268: PPUSH
61269: LD_VAR 0 2
61273: PPUSH
61274: LD_INT 1
61276: PPUSH
61277: CALL 60520 0 3
61281: ST_TO_ADDR
// InitHc ;
61282: CALL_OW 19
// InitUc ;
61286: CALL_OW 18
// uc_side := side ;
61290: LD_ADDR_OWVAR 20
61294: PUSH
61295: LD_VAR 0 16
61299: ST_TO_ADDR
// uc_nation := nation ;
61300: LD_ADDR_OWVAR 21
61304: PUSH
61305: LD_VAR 0 17
61309: ST_TO_ADDR
// if buildings then
61310: LD_VAR 0 18
61314: IFFALSE 62636
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61316: LD_ADDR_VAR 0 19
61320: PUSH
61321: LD_VAR 0 18
61325: PPUSH
61326: LD_INT 2
61328: PUSH
61329: LD_INT 30
61331: PUSH
61332: LD_INT 29
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: PUSH
61339: LD_INT 30
61341: PUSH
61342: LD_INT 30
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PUSH
61349: EMPTY
61350: LIST
61351: LIST
61352: LIST
61353: PPUSH
61354: CALL_OW 72
61358: ST_TO_ADDR
// if tmp then
61359: LD_VAR 0 19
61363: IFFALSE 61411
// for i in tmp do
61365: LD_ADDR_VAR 0 8
61369: PUSH
61370: LD_VAR 0 19
61374: PUSH
61375: FOR_IN
61376: IFFALSE 61409
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61378: LD_VAR 0 8
61382: PPUSH
61383: CALL_OW 250
61387: PPUSH
61388: LD_VAR 0 8
61392: PPUSH
61393: CALL_OW 251
61397: PPUSH
61398: LD_VAR 0 16
61402: PPUSH
61403: CALL_OW 441
61407: GO 61375
61409: POP
61410: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61411: LD_VAR 0 18
61415: PPUSH
61416: LD_INT 2
61418: PUSH
61419: LD_INT 30
61421: PUSH
61422: LD_INT 32
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 30
61431: PUSH
61432: LD_INT 33
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: LIST
61443: PPUSH
61444: CALL_OW 72
61448: IFFALSE 61536
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61450: LD_ADDR_VAR 0 8
61454: PUSH
61455: LD_VAR 0 18
61459: PPUSH
61460: LD_INT 2
61462: PUSH
61463: LD_INT 30
61465: PUSH
61466: LD_INT 32
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PUSH
61473: LD_INT 30
61475: PUSH
61476: LD_INT 33
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: PUSH
61483: EMPTY
61484: LIST
61485: LIST
61486: LIST
61487: PPUSH
61488: CALL_OW 72
61492: PUSH
61493: FOR_IN
61494: IFFALSE 61534
// begin if not GetBWeapon ( i ) then
61496: LD_VAR 0 8
61500: PPUSH
61501: CALL_OW 269
61505: NOT
61506: IFFALSE 61532
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61508: LD_VAR 0 8
61512: PPUSH
61513: LD_VAR 0 8
61517: PPUSH
61518: LD_VAR 0 2
61522: PPUSH
61523: CALL 62782 0 2
61527: PPUSH
61528: CALL_OW 431
// end ;
61532: GO 61493
61534: POP
61535: POP
// end ; for i = 1 to personel do
61536: LD_ADDR_VAR 0 8
61540: PUSH
61541: DOUBLE
61542: LD_INT 1
61544: DEC
61545: ST_TO_ADDR
61546: LD_VAR 0 6
61550: PUSH
61551: FOR_TO
61552: IFFALSE 62616
// begin if i > 4 then
61554: LD_VAR 0 8
61558: PUSH
61559: LD_INT 4
61561: GREATER
61562: IFFALSE 61566
// break ;
61564: GO 62616
// case i of 1 :
61566: LD_VAR 0 8
61570: PUSH
61571: LD_INT 1
61573: DOUBLE
61574: EQUAL
61575: IFTRUE 61579
61577: GO 61659
61579: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61580: LD_ADDR_VAR 0 12
61584: PUSH
61585: LD_VAR 0 18
61589: PPUSH
61590: LD_INT 22
61592: PUSH
61593: LD_VAR 0 16
61597: PUSH
61598: EMPTY
61599: LIST
61600: LIST
61601: PUSH
61602: LD_INT 58
61604: PUSH
61605: EMPTY
61606: LIST
61607: PUSH
61608: LD_INT 2
61610: PUSH
61611: LD_INT 30
61613: PUSH
61614: LD_INT 32
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: PUSH
61621: LD_INT 30
61623: PUSH
61624: LD_INT 4
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: LD_INT 30
61633: PUSH
61634: LD_INT 5
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: LIST
61645: LIST
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: LIST
61651: PPUSH
61652: CALL_OW 72
61656: ST_TO_ADDR
61657: GO 61881
61659: LD_INT 2
61661: DOUBLE
61662: EQUAL
61663: IFTRUE 61667
61665: GO 61729
61667: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61668: LD_ADDR_VAR 0 12
61672: PUSH
61673: LD_VAR 0 18
61677: PPUSH
61678: LD_INT 22
61680: PUSH
61681: LD_VAR 0 16
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: PUSH
61690: LD_INT 2
61692: PUSH
61693: LD_INT 30
61695: PUSH
61696: LD_INT 0
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 30
61705: PUSH
61706: LD_INT 1
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: LIST
61717: PUSH
61718: EMPTY
61719: LIST
61720: LIST
61721: PPUSH
61722: CALL_OW 72
61726: ST_TO_ADDR
61727: GO 61881
61729: LD_INT 3
61731: DOUBLE
61732: EQUAL
61733: IFTRUE 61737
61735: GO 61799
61737: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61738: LD_ADDR_VAR 0 12
61742: PUSH
61743: LD_VAR 0 18
61747: PPUSH
61748: LD_INT 22
61750: PUSH
61751: LD_VAR 0 16
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: LD_INT 2
61762: PUSH
61763: LD_INT 30
61765: PUSH
61766: LD_INT 2
61768: PUSH
61769: EMPTY
61770: LIST
61771: LIST
61772: PUSH
61773: LD_INT 30
61775: PUSH
61776: LD_INT 3
61778: PUSH
61779: EMPTY
61780: LIST
61781: LIST
61782: PUSH
61783: EMPTY
61784: LIST
61785: LIST
61786: LIST
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: PPUSH
61792: CALL_OW 72
61796: ST_TO_ADDR
61797: GO 61881
61799: LD_INT 4
61801: DOUBLE
61802: EQUAL
61803: IFTRUE 61807
61805: GO 61880
61807: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61808: LD_ADDR_VAR 0 12
61812: PUSH
61813: LD_VAR 0 18
61817: PPUSH
61818: LD_INT 22
61820: PUSH
61821: LD_VAR 0 16
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: PUSH
61830: LD_INT 2
61832: PUSH
61833: LD_INT 30
61835: PUSH
61836: LD_INT 6
61838: PUSH
61839: EMPTY
61840: LIST
61841: LIST
61842: PUSH
61843: LD_INT 30
61845: PUSH
61846: LD_INT 7
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: PUSH
61853: LD_INT 30
61855: PUSH
61856: LD_INT 8
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: LIST
61867: LIST
61868: PUSH
61869: EMPTY
61870: LIST
61871: LIST
61872: PPUSH
61873: CALL_OW 72
61877: ST_TO_ADDR
61878: GO 61881
61880: POP
// if i = 1 then
61881: LD_VAR 0 8
61885: PUSH
61886: LD_INT 1
61888: EQUAL
61889: IFFALSE 62000
// begin tmp := [ ] ;
61891: LD_ADDR_VAR 0 19
61895: PUSH
61896: EMPTY
61897: ST_TO_ADDR
// for j in f do
61898: LD_ADDR_VAR 0 9
61902: PUSH
61903: LD_VAR 0 12
61907: PUSH
61908: FOR_IN
61909: IFFALSE 61982
// if GetBType ( j ) = b_bunker then
61911: LD_VAR 0 9
61915: PPUSH
61916: CALL_OW 266
61920: PUSH
61921: LD_INT 32
61923: EQUAL
61924: IFFALSE 61951
// tmp := Insert ( tmp , 1 , j ) else
61926: LD_ADDR_VAR 0 19
61930: PUSH
61931: LD_VAR 0 19
61935: PPUSH
61936: LD_INT 1
61938: PPUSH
61939: LD_VAR 0 9
61943: PPUSH
61944: CALL_OW 2
61948: ST_TO_ADDR
61949: GO 61980
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61951: LD_ADDR_VAR 0 19
61955: PUSH
61956: LD_VAR 0 19
61960: PPUSH
61961: LD_VAR 0 19
61965: PUSH
61966: LD_INT 1
61968: PLUS
61969: PPUSH
61970: LD_VAR 0 9
61974: PPUSH
61975: CALL_OW 2
61979: ST_TO_ADDR
61980: GO 61908
61982: POP
61983: POP
// if tmp then
61984: LD_VAR 0 19
61988: IFFALSE 62000
// f := tmp ;
61990: LD_ADDR_VAR 0 12
61994: PUSH
61995: LD_VAR 0 19
61999: ST_TO_ADDR
// end ; x := personel [ i ] ;
62000: LD_ADDR_VAR 0 13
62004: PUSH
62005: LD_VAR 0 6
62009: PUSH
62010: LD_VAR 0 8
62014: ARRAY
62015: ST_TO_ADDR
// if x = - 1 then
62016: LD_VAR 0 13
62020: PUSH
62021: LD_INT 1
62023: NEG
62024: EQUAL
62025: IFFALSE 62234
// begin for j in f do
62027: LD_ADDR_VAR 0 9
62031: PUSH
62032: LD_VAR 0 12
62036: PUSH
62037: FOR_IN
62038: IFFALSE 62230
// repeat InitHc ;
62040: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62044: LD_VAR 0 9
62048: PPUSH
62049: CALL_OW 266
62053: PUSH
62054: LD_INT 5
62056: EQUAL
62057: IFFALSE 62127
// begin if UnitsInside ( j ) < 3 then
62059: LD_VAR 0 9
62063: PPUSH
62064: CALL_OW 313
62068: PUSH
62069: LD_INT 3
62071: LESS
62072: IFFALSE 62108
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62074: LD_INT 0
62076: PPUSH
62077: LD_INT 5
62079: PUSH
62080: LD_INT 8
62082: PUSH
62083: LD_INT 9
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: LIST
62090: PUSH
62091: LD_VAR 0 17
62095: ARRAY
62096: PPUSH
62097: LD_VAR 0 4
62101: PPUSH
62102: CALL_OW 380
62106: GO 62125
// PrepareHuman ( false , i , skill ) ;
62108: LD_INT 0
62110: PPUSH
62111: LD_VAR 0 8
62115: PPUSH
62116: LD_VAR 0 4
62120: PPUSH
62121: CALL_OW 380
// end else
62125: GO 62144
// PrepareHuman ( false , i , skill ) ;
62127: LD_INT 0
62129: PPUSH
62130: LD_VAR 0 8
62134: PPUSH
62135: LD_VAR 0 4
62139: PPUSH
62140: CALL_OW 380
// un := CreateHuman ;
62144: LD_ADDR_VAR 0 14
62148: PUSH
62149: CALL_OW 44
62153: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62154: LD_ADDR_VAR 0 7
62158: PUSH
62159: LD_VAR 0 7
62163: PPUSH
62164: LD_INT 1
62166: PPUSH
62167: LD_VAR 0 14
62171: PPUSH
62172: CALL_OW 2
62176: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62177: LD_VAR 0 14
62181: PPUSH
62182: LD_VAR 0 9
62186: PPUSH
62187: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62191: LD_VAR 0 9
62195: PPUSH
62196: CALL_OW 313
62200: PUSH
62201: LD_INT 6
62203: EQUAL
62204: PUSH
62205: LD_VAR 0 9
62209: PPUSH
62210: CALL_OW 266
62214: PUSH
62215: LD_INT 32
62217: PUSH
62218: LD_INT 31
62220: PUSH
62221: EMPTY
62222: LIST
62223: LIST
62224: IN
62225: OR
62226: IFFALSE 62040
62228: GO 62037
62230: POP
62231: POP
// end else
62232: GO 62614
// for j = 1 to x do
62234: LD_ADDR_VAR 0 9
62238: PUSH
62239: DOUBLE
62240: LD_INT 1
62242: DEC
62243: ST_TO_ADDR
62244: LD_VAR 0 13
62248: PUSH
62249: FOR_TO
62250: IFFALSE 62612
// begin InitHc ;
62252: CALL_OW 19
// if not f then
62256: LD_VAR 0 12
62260: NOT
62261: IFFALSE 62350
// begin PrepareHuman ( false , i , skill ) ;
62263: LD_INT 0
62265: PPUSH
62266: LD_VAR 0 8
62270: PPUSH
62271: LD_VAR 0 4
62275: PPUSH
62276: CALL_OW 380
// un := CreateHuman ;
62280: LD_ADDR_VAR 0 14
62284: PUSH
62285: CALL_OW 44
62289: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62290: LD_ADDR_VAR 0 7
62294: PUSH
62295: LD_VAR 0 7
62299: PPUSH
62300: LD_INT 1
62302: PPUSH
62303: LD_VAR 0 14
62307: PPUSH
62308: CALL_OW 2
62312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62313: LD_VAR 0 14
62317: PPUSH
62318: LD_VAR 0 1
62322: PPUSH
62323: CALL_OW 250
62327: PPUSH
62328: LD_VAR 0 1
62332: PPUSH
62333: CALL_OW 251
62337: PPUSH
62338: LD_INT 10
62340: PPUSH
62341: LD_INT 0
62343: PPUSH
62344: CALL_OW 50
// continue ;
62348: GO 62249
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62350: LD_VAR 0 12
62354: PUSH
62355: LD_INT 1
62357: ARRAY
62358: PPUSH
62359: CALL_OW 313
62363: PUSH
62364: LD_VAR 0 12
62368: PUSH
62369: LD_INT 1
62371: ARRAY
62372: PPUSH
62373: CALL_OW 266
62377: PUSH
62378: LD_INT 32
62380: PUSH
62381: LD_INT 31
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: IN
62388: AND
62389: PUSH
62390: LD_VAR 0 12
62394: PUSH
62395: LD_INT 1
62397: ARRAY
62398: PPUSH
62399: CALL_OW 313
62403: PUSH
62404: LD_INT 6
62406: EQUAL
62407: OR
62408: IFFALSE 62428
// f := Delete ( f , 1 ) ;
62410: LD_ADDR_VAR 0 12
62414: PUSH
62415: LD_VAR 0 12
62419: PPUSH
62420: LD_INT 1
62422: PPUSH
62423: CALL_OW 3
62427: ST_TO_ADDR
// if not f then
62428: LD_VAR 0 12
62432: NOT
62433: IFFALSE 62451
// begin x := x + 2 ;
62435: LD_ADDR_VAR 0 13
62439: PUSH
62440: LD_VAR 0 13
62444: PUSH
62445: LD_INT 2
62447: PLUS
62448: ST_TO_ADDR
// continue ;
62449: GO 62249
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62451: LD_VAR 0 12
62455: PUSH
62456: LD_INT 1
62458: ARRAY
62459: PPUSH
62460: CALL_OW 266
62464: PUSH
62465: LD_INT 5
62467: EQUAL
62468: IFFALSE 62542
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62470: LD_VAR 0 12
62474: PUSH
62475: LD_INT 1
62477: ARRAY
62478: PPUSH
62479: CALL_OW 313
62483: PUSH
62484: LD_INT 3
62486: LESS
62487: IFFALSE 62523
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62489: LD_INT 0
62491: PPUSH
62492: LD_INT 5
62494: PUSH
62495: LD_INT 8
62497: PUSH
62498: LD_INT 9
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: LIST
62505: PUSH
62506: LD_VAR 0 17
62510: ARRAY
62511: PPUSH
62512: LD_VAR 0 4
62516: PPUSH
62517: CALL_OW 380
62521: GO 62540
// PrepareHuman ( false , i , skill ) ;
62523: LD_INT 0
62525: PPUSH
62526: LD_VAR 0 8
62530: PPUSH
62531: LD_VAR 0 4
62535: PPUSH
62536: CALL_OW 380
// end else
62540: GO 62559
// PrepareHuman ( false , i , skill ) ;
62542: LD_INT 0
62544: PPUSH
62545: LD_VAR 0 8
62549: PPUSH
62550: LD_VAR 0 4
62554: PPUSH
62555: CALL_OW 380
// un := CreateHuman ;
62559: LD_ADDR_VAR 0 14
62563: PUSH
62564: CALL_OW 44
62568: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62569: LD_ADDR_VAR 0 7
62573: PUSH
62574: LD_VAR 0 7
62578: PPUSH
62579: LD_INT 1
62581: PPUSH
62582: LD_VAR 0 14
62586: PPUSH
62587: CALL_OW 2
62591: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62592: LD_VAR 0 14
62596: PPUSH
62597: LD_VAR 0 12
62601: PUSH
62602: LD_INT 1
62604: ARRAY
62605: PPUSH
62606: CALL_OW 52
// end ;
62610: GO 62249
62612: POP
62613: POP
// end ;
62614: GO 61551
62616: POP
62617: POP
// result := result ^ buildings ;
62618: LD_ADDR_VAR 0 7
62622: PUSH
62623: LD_VAR 0 7
62627: PUSH
62628: LD_VAR 0 18
62632: ADD
62633: ST_TO_ADDR
// end else
62634: GO 62777
// begin for i = 1 to personel do
62636: LD_ADDR_VAR 0 8
62640: PUSH
62641: DOUBLE
62642: LD_INT 1
62644: DEC
62645: ST_TO_ADDR
62646: LD_VAR 0 6
62650: PUSH
62651: FOR_TO
62652: IFFALSE 62775
// begin if i > 4 then
62654: LD_VAR 0 8
62658: PUSH
62659: LD_INT 4
62661: GREATER
62662: IFFALSE 62666
// break ;
62664: GO 62775
// x := personel [ i ] ;
62666: LD_ADDR_VAR 0 13
62670: PUSH
62671: LD_VAR 0 6
62675: PUSH
62676: LD_VAR 0 8
62680: ARRAY
62681: ST_TO_ADDR
// if x = - 1 then
62682: LD_VAR 0 13
62686: PUSH
62687: LD_INT 1
62689: NEG
62690: EQUAL
62691: IFFALSE 62695
// continue ;
62693: GO 62651
// PrepareHuman ( false , i , skill ) ;
62695: LD_INT 0
62697: PPUSH
62698: LD_VAR 0 8
62702: PPUSH
62703: LD_VAR 0 4
62707: PPUSH
62708: CALL_OW 380
// un := CreateHuman ;
62712: LD_ADDR_VAR 0 14
62716: PUSH
62717: CALL_OW 44
62721: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62722: LD_VAR 0 14
62726: PPUSH
62727: LD_VAR 0 1
62731: PPUSH
62732: CALL_OW 250
62736: PPUSH
62737: LD_VAR 0 1
62741: PPUSH
62742: CALL_OW 251
62746: PPUSH
62747: LD_INT 10
62749: PPUSH
62750: LD_INT 0
62752: PPUSH
62753: CALL_OW 50
// result := result ^ un ;
62757: LD_ADDR_VAR 0 7
62761: PUSH
62762: LD_VAR 0 7
62766: PUSH
62767: LD_VAR 0 14
62771: ADD
62772: ST_TO_ADDR
// end ;
62773: GO 62651
62775: POP
62776: POP
// end ; end ;
62777: LD_VAR 0 7
62781: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62782: LD_INT 0
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
62798: PPUSH
62799: PPUSH
// result := false ;
62800: LD_ADDR_VAR 0 3
62804: PUSH
62805: LD_INT 0
62807: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62808: LD_VAR 0 1
62812: NOT
62813: PUSH
62814: LD_VAR 0 1
62818: PPUSH
62819: CALL_OW 266
62823: PUSH
62824: LD_INT 32
62826: PUSH
62827: LD_INT 33
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: IN
62834: NOT
62835: OR
62836: IFFALSE 62840
// exit ;
62838: GO 63949
// nat := GetNation ( tower ) ;
62840: LD_ADDR_VAR 0 12
62844: PUSH
62845: LD_VAR 0 1
62849: PPUSH
62850: CALL_OW 248
62854: ST_TO_ADDR
// side := GetSide ( tower ) ;
62855: LD_ADDR_VAR 0 16
62859: PUSH
62860: LD_VAR 0 1
62864: PPUSH
62865: CALL_OW 255
62869: ST_TO_ADDR
// x := GetX ( tower ) ;
62870: LD_ADDR_VAR 0 10
62874: PUSH
62875: LD_VAR 0 1
62879: PPUSH
62880: CALL_OW 250
62884: ST_TO_ADDR
// y := GetY ( tower ) ;
62885: LD_ADDR_VAR 0 11
62889: PUSH
62890: LD_VAR 0 1
62894: PPUSH
62895: CALL_OW 251
62899: ST_TO_ADDR
// if not x or not y then
62900: LD_VAR 0 10
62904: NOT
62905: PUSH
62906: LD_VAR 0 11
62910: NOT
62911: OR
62912: IFFALSE 62916
// exit ;
62914: GO 63949
// weapon := 0 ;
62916: LD_ADDR_VAR 0 18
62920: PUSH
62921: LD_INT 0
62923: ST_TO_ADDR
// fac_list := [ ] ;
62924: LD_ADDR_VAR 0 17
62928: PUSH
62929: EMPTY
62930: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62931: LD_ADDR_VAR 0 6
62935: PUSH
62936: LD_VAR 0 1
62940: PPUSH
62941: CALL_OW 274
62945: PPUSH
62946: LD_VAR 0 2
62950: PPUSH
62951: LD_INT 0
62953: PPUSH
62954: CALL 60520 0 3
62958: PPUSH
62959: LD_INT 30
62961: PUSH
62962: LD_INT 3
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: PPUSH
62969: CALL_OW 72
62973: ST_TO_ADDR
// if not factories then
62974: LD_VAR 0 6
62978: NOT
62979: IFFALSE 62983
// exit ;
62981: GO 63949
// for i in factories do
62983: LD_ADDR_VAR 0 8
62987: PUSH
62988: LD_VAR 0 6
62992: PUSH
62993: FOR_IN
62994: IFFALSE 63019
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62996: LD_ADDR_VAR 0 17
63000: PUSH
63001: LD_VAR 0 17
63005: PUSH
63006: LD_VAR 0 8
63010: PPUSH
63011: CALL_OW 478
63015: UNION
63016: ST_TO_ADDR
63017: GO 62993
63019: POP
63020: POP
// if not fac_list then
63021: LD_VAR 0 17
63025: NOT
63026: IFFALSE 63030
// exit ;
63028: GO 63949
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63030: LD_ADDR_VAR 0 5
63034: PUSH
63035: LD_INT 4
63037: PUSH
63038: LD_INT 5
63040: PUSH
63041: LD_INT 9
63043: PUSH
63044: LD_INT 10
63046: PUSH
63047: LD_INT 6
63049: PUSH
63050: LD_INT 7
63052: PUSH
63053: LD_INT 11
63055: PUSH
63056: EMPTY
63057: LIST
63058: LIST
63059: LIST
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 27
63067: PUSH
63068: LD_INT 28
63070: PUSH
63071: LD_INT 26
63073: PUSH
63074: LD_INT 30
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: LIST
63081: LIST
63082: PUSH
63083: LD_INT 43
63085: PUSH
63086: LD_INT 44
63088: PUSH
63089: LD_INT 46
63091: PUSH
63092: LD_INT 45
63094: PUSH
63095: LD_INT 47
63097: PUSH
63098: LD_INT 49
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: LIST
63105: LIST
63106: LIST
63107: LIST
63108: PUSH
63109: EMPTY
63110: LIST
63111: LIST
63112: LIST
63113: PUSH
63114: LD_VAR 0 12
63118: ARRAY
63119: ST_TO_ADDR
// list := list isect fac_list ;
63120: LD_ADDR_VAR 0 5
63124: PUSH
63125: LD_VAR 0 5
63129: PUSH
63130: LD_VAR 0 17
63134: ISECT
63135: ST_TO_ADDR
// if not list then
63136: LD_VAR 0 5
63140: NOT
63141: IFFALSE 63145
// exit ;
63143: GO 63949
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63145: LD_VAR 0 12
63149: PUSH
63150: LD_INT 3
63152: EQUAL
63153: PUSH
63154: LD_INT 49
63156: PUSH
63157: LD_VAR 0 5
63161: IN
63162: AND
63163: PUSH
63164: LD_INT 31
63166: PPUSH
63167: LD_VAR 0 16
63171: PPUSH
63172: CALL_OW 321
63176: PUSH
63177: LD_INT 2
63179: EQUAL
63180: AND
63181: IFFALSE 63241
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63183: LD_INT 22
63185: PUSH
63186: LD_VAR 0 16
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 35
63197: PUSH
63198: LD_INT 49
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 91
63207: PUSH
63208: LD_VAR 0 1
63212: PUSH
63213: LD_INT 10
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: LIST
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: LIST
63225: PPUSH
63226: CALL_OW 69
63230: NOT
63231: IFFALSE 63241
// weapon := ru_time_lapser ;
63233: LD_ADDR_VAR 0 18
63237: PUSH
63238: LD_INT 49
63240: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63241: LD_VAR 0 12
63245: PUSH
63246: LD_INT 1
63248: PUSH
63249: LD_INT 2
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: IN
63256: PUSH
63257: LD_INT 11
63259: PUSH
63260: LD_VAR 0 5
63264: IN
63265: PUSH
63266: LD_INT 30
63268: PUSH
63269: LD_VAR 0 5
63273: IN
63274: OR
63275: AND
63276: PUSH
63277: LD_INT 6
63279: PPUSH
63280: LD_VAR 0 16
63284: PPUSH
63285: CALL_OW 321
63289: PUSH
63290: LD_INT 2
63292: EQUAL
63293: AND
63294: IFFALSE 63459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63296: LD_INT 22
63298: PUSH
63299: LD_VAR 0 16
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 2
63310: PUSH
63311: LD_INT 35
63313: PUSH
63314: LD_INT 11
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PUSH
63321: LD_INT 35
63323: PUSH
63324: LD_INT 30
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 91
63338: PUSH
63339: LD_VAR 0 1
63343: PUSH
63344: LD_INT 18
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: LIST
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: LIST
63356: PPUSH
63357: CALL_OW 69
63361: NOT
63362: PUSH
63363: LD_INT 22
63365: PUSH
63366: LD_VAR 0 16
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PUSH
63375: LD_INT 2
63377: PUSH
63378: LD_INT 30
63380: PUSH
63381: LD_INT 32
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: PUSH
63388: LD_INT 30
63390: PUSH
63391: LD_INT 33
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: LIST
63402: PUSH
63403: LD_INT 91
63405: PUSH
63406: LD_VAR 0 1
63410: PUSH
63411: LD_INT 12
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: LIST
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: LIST
63423: PUSH
63424: EMPTY
63425: LIST
63426: PPUSH
63427: CALL_OW 69
63431: PUSH
63432: LD_INT 2
63434: GREATER
63435: AND
63436: IFFALSE 63459
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63438: LD_ADDR_VAR 0 18
63442: PUSH
63443: LD_INT 11
63445: PUSH
63446: LD_INT 30
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PUSH
63453: LD_VAR 0 12
63457: ARRAY
63458: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63459: LD_VAR 0 18
63463: NOT
63464: PUSH
63465: LD_INT 40
63467: PPUSH
63468: LD_VAR 0 16
63472: PPUSH
63473: CALL_OW 321
63477: PUSH
63478: LD_INT 2
63480: EQUAL
63481: AND
63482: PUSH
63483: LD_INT 7
63485: PUSH
63486: LD_VAR 0 5
63490: IN
63491: PUSH
63492: LD_INT 28
63494: PUSH
63495: LD_VAR 0 5
63499: IN
63500: OR
63501: PUSH
63502: LD_INT 45
63504: PUSH
63505: LD_VAR 0 5
63509: IN
63510: OR
63511: AND
63512: IFFALSE 63766
// begin hex := GetHexInfo ( x , y ) ;
63514: LD_ADDR_VAR 0 4
63518: PUSH
63519: LD_VAR 0 10
63523: PPUSH
63524: LD_VAR 0 11
63528: PPUSH
63529: CALL_OW 546
63533: ST_TO_ADDR
// if hex [ 1 ] then
63534: LD_VAR 0 4
63538: PUSH
63539: LD_INT 1
63541: ARRAY
63542: IFFALSE 63546
// exit ;
63544: GO 63949
// height := hex [ 2 ] ;
63546: LD_ADDR_VAR 0 15
63550: PUSH
63551: LD_VAR 0 4
63555: PUSH
63556: LD_INT 2
63558: ARRAY
63559: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63560: LD_ADDR_VAR 0 14
63564: PUSH
63565: LD_INT 0
63567: PUSH
63568: LD_INT 2
63570: PUSH
63571: LD_INT 3
63573: PUSH
63574: LD_INT 5
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: LIST
63581: LIST
63582: ST_TO_ADDR
// for i in tmp do
63583: LD_ADDR_VAR 0 8
63587: PUSH
63588: LD_VAR 0 14
63592: PUSH
63593: FOR_IN
63594: IFFALSE 63764
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63596: LD_ADDR_VAR 0 9
63600: PUSH
63601: LD_VAR 0 10
63605: PPUSH
63606: LD_VAR 0 8
63610: PPUSH
63611: LD_INT 5
63613: PPUSH
63614: CALL_OW 272
63618: PUSH
63619: LD_VAR 0 11
63623: PPUSH
63624: LD_VAR 0 8
63628: PPUSH
63629: LD_INT 5
63631: PPUSH
63632: CALL_OW 273
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63641: LD_VAR 0 9
63645: PUSH
63646: LD_INT 1
63648: ARRAY
63649: PPUSH
63650: LD_VAR 0 9
63654: PUSH
63655: LD_INT 2
63657: ARRAY
63658: PPUSH
63659: CALL_OW 488
63663: IFFALSE 63762
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63665: LD_ADDR_VAR 0 4
63669: PUSH
63670: LD_VAR 0 9
63674: PUSH
63675: LD_INT 1
63677: ARRAY
63678: PPUSH
63679: LD_VAR 0 9
63683: PUSH
63684: LD_INT 2
63686: ARRAY
63687: PPUSH
63688: CALL_OW 546
63692: ST_TO_ADDR
// if hex [ 1 ] then
63693: LD_VAR 0 4
63697: PUSH
63698: LD_INT 1
63700: ARRAY
63701: IFFALSE 63705
// continue ;
63703: GO 63593
// h := hex [ 2 ] ;
63705: LD_ADDR_VAR 0 13
63709: PUSH
63710: LD_VAR 0 4
63714: PUSH
63715: LD_INT 2
63717: ARRAY
63718: ST_TO_ADDR
// if h + 7 < height then
63719: LD_VAR 0 13
63723: PUSH
63724: LD_INT 7
63726: PLUS
63727: PUSH
63728: LD_VAR 0 15
63732: LESS
63733: IFFALSE 63762
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63735: LD_ADDR_VAR 0 18
63739: PUSH
63740: LD_INT 7
63742: PUSH
63743: LD_INT 28
63745: PUSH
63746: LD_INT 45
63748: PUSH
63749: EMPTY
63750: LIST
63751: LIST
63752: LIST
63753: PUSH
63754: LD_VAR 0 12
63758: ARRAY
63759: ST_TO_ADDR
// break ;
63760: GO 63764
// end ; end ; end ;
63762: GO 63593
63764: POP
63765: POP
// end ; if not weapon then
63766: LD_VAR 0 18
63770: NOT
63771: IFFALSE 63831
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63773: LD_ADDR_VAR 0 5
63777: PUSH
63778: LD_VAR 0 5
63782: PUSH
63783: LD_INT 11
63785: PUSH
63786: LD_INT 30
63788: PUSH
63789: LD_INT 49
63791: PUSH
63792: EMPTY
63793: LIST
63794: LIST
63795: LIST
63796: DIFF
63797: ST_TO_ADDR
// if not list then
63798: LD_VAR 0 5
63802: NOT
63803: IFFALSE 63807
// exit ;
63805: GO 63949
// weapon := list [ rand ( 1 , list ) ] ;
63807: LD_ADDR_VAR 0 18
63811: PUSH
63812: LD_VAR 0 5
63816: PUSH
63817: LD_INT 1
63819: PPUSH
63820: LD_VAR 0 5
63824: PPUSH
63825: CALL_OW 12
63829: ARRAY
63830: ST_TO_ADDR
// end ; if weapon then
63831: LD_VAR 0 18
63835: IFFALSE 63949
// begin tmp := CostOfWeapon ( weapon ) ;
63837: LD_ADDR_VAR 0 14
63841: PUSH
63842: LD_VAR 0 18
63846: PPUSH
63847: CALL_OW 451
63851: ST_TO_ADDR
// j := GetBase ( tower ) ;
63852: LD_ADDR_VAR 0 9
63856: PUSH
63857: LD_VAR 0 1
63861: PPUSH
63862: CALL_OW 274
63866: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63867: LD_VAR 0 9
63871: PPUSH
63872: LD_INT 1
63874: PPUSH
63875: CALL_OW 275
63879: PUSH
63880: LD_VAR 0 14
63884: PUSH
63885: LD_INT 1
63887: ARRAY
63888: GREATEREQUAL
63889: PUSH
63890: LD_VAR 0 9
63894: PPUSH
63895: LD_INT 2
63897: PPUSH
63898: CALL_OW 275
63902: PUSH
63903: LD_VAR 0 14
63907: PUSH
63908: LD_INT 2
63910: ARRAY
63911: GREATEREQUAL
63912: AND
63913: PUSH
63914: LD_VAR 0 9
63918: PPUSH
63919: LD_INT 3
63921: PPUSH
63922: CALL_OW 275
63926: PUSH
63927: LD_VAR 0 14
63931: PUSH
63932: LD_INT 3
63934: ARRAY
63935: GREATEREQUAL
63936: AND
63937: IFFALSE 63949
// result := weapon ;
63939: LD_ADDR_VAR 0 3
63943: PUSH
63944: LD_VAR 0 18
63948: ST_TO_ADDR
// end ; end ;
63949: LD_VAR 0 3
63953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63954: LD_INT 0
63956: PPUSH
63957: PPUSH
// result := true ;
63958: LD_ADDR_VAR 0 3
63962: PUSH
63963: LD_INT 1
63965: ST_TO_ADDR
// if array1 = array2 then
63966: LD_VAR 0 1
63970: PUSH
63971: LD_VAR 0 2
63975: EQUAL
63976: IFFALSE 64036
// begin for i = 1 to array1 do
63978: LD_ADDR_VAR 0 4
63982: PUSH
63983: DOUBLE
63984: LD_INT 1
63986: DEC
63987: ST_TO_ADDR
63988: LD_VAR 0 1
63992: PUSH
63993: FOR_TO
63994: IFFALSE 64032
// if array1 [ i ] <> array2 [ i ] then
63996: LD_VAR 0 1
64000: PUSH
64001: LD_VAR 0 4
64005: ARRAY
64006: PUSH
64007: LD_VAR 0 2
64011: PUSH
64012: LD_VAR 0 4
64016: ARRAY
64017: NONEQUAL
64018: IFFALSE 64030
// begin result := false ;
64020: LD_ADDR_VAR 0 3
64024: PUSH
64025: LD_INT 0
64027: ST_TO_ADDR
// break ;
64028: GO 64032
// end ;
64030: GO 63993
64032: POP
64033: POP
// end else
64034: GO 64044
// result := false ;
64036: LD_ADDR_VAR 0 3
64040: PUSH
64041: LD_INT 0
64043: ST_TO_ADDR
// end ;
64044: LD_VAR 0 3
64048: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64049: LD_INT 0
64051: PPUSH
64052: PPUSH
// if not array1 or not array2 then
64053: LD_VAR 0 1
64057: NOT
64058: PUSH
64059: LD_VAR 0 2
64063: NOT
64064: OR
64065: IFFALSE 64069
// exit ;
64067: GO 64133
// result := true ;
64069: LD_ADDR_VAR 0 3
64073: PUSH
64074: LD_INT 1
64076: ST_TO_ADDR
// for i = 1 to array1 do
64077: LD_ADDR_VAR 0 4
64081: PUSH
64082: DOUBLE
64083: LD_INT 1
64085: DEC
64086: ST_TO_ADDR
64087: LD_VAR 0 1
64091: PUSH
64092: FOR_TO
64093: IFFALSE 64131
// if array1 [ i ] <> array2 [ i ] then
64095: LD_VAR 0 1
64099: PUSH
64100: LD_VAR 0 4
64104: ARRAY
64105: PUSH
64106: LD_VAR 0 2
64110: PUSH
64111: LD_VAR 0 4
64115: ARRAY
64116: NONEQUAL
64117: IFFALSE 64129
// begin result := false ;
64119: LD_ADDR_VAR 0 3
64123: PUSH
64124: LD_INT 0
64126: ST_TO_ADDR
// break ;
64127: GO 64131
// end ;
64129: GO 64092
64131: POP
64132: POP
// end ;
64133: LD_VAR 0 3
64137: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64138: LD_INT 0
64140: PPUSH
64141: PPUSH
64142: PPUSH
// pom := GetBase ( fac ) ;
64143: LD_ADDR_VAR 0 5
64147: PUSH
64148: LD_VAR 0 1
64152: PPUSH
64153: CALL_OW 274
64157: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64158: LD_ADDR_VAR 0 4
64162: PUSH
64163: LD_VAR 0 2
64167: PUSH
64168: LD_INT 1
64170: ARRAY
64171: PPUSH
64172: LD_VAR 0 2
64176: PUSH
64177: LD_INT 2
64179: ARRAY
64180: PPUSH
64181: LD_VAR 0 2
64185: PUSH
64186: LD_INT 3
64188: ARRAY
64189: PPUSH
64190: LD_VAR 0 2
64194: PUSH
64195: LD_INT 4
64197: ARRAY
64198: PPUSH
64199: CALL_OW 449
64203: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64204: LD_ADDR_VAR 0 3
64208: PUSH
64209: LD_VAR 0 5
64213: PPUSH
64214: LD_INT 1
64216: PPUSH
64217: CALL_OW 275
64221: PUSH
64222: LD_VAR 0 4
64226: PUSH
64227: LD_INT 1
64229: ARRAY
64230: GREATEREQUAL
64231: PUSH
64232: LD_VAR 0 5
64236: PPUSH
64237: LD_INT 2
64239: PPUSH
64240: CALL_OW 275
64244: PUSH
64245: LD_VAR 0 4
64249: PUSH
64250: LD_INT 2
64252: ARRAY
64253: GREATEREQUAL
64254: AND
64255: PUSH
64256: LD_VAR 0 5
64260: PPUSH
64261: LD_INT 3
64263: PPUSH
64264: CALL_OW 275
64268: PUSH
64269: LD_VAR 0 4
64273: PUSH
64274: LD_INT 3
64276: ARRAY
64277: GREATEREQUAL
64278: AND
64279: ST_TO_ADDR
// end ;
64280: LD_VAR 0 3
64284: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64285: LD_INT 0
64287: PPUSH
64288: PPUSH
64289: PPUSH
64290: PPUSH
// pom := GetBase ( building ) ;
64291: LD_ADDR_VAR 0 3
64295: PUSH
64296: LD_VAR 0 1
64300: PPUSH
64301: CALL_OW 274
64305: ST_TO_ADDR
// if not pom then
64306: LD_VAR 0 3
64310: NOT
64311: IFFALSE 64315
// exit ;
64313: GO 64485
// btype := GetBType ( building ) ;
64315: LD_ADDR_VAR 0 5
64319: PUSH
64320: LD_VAR 0 1
64324: PPUSH
64325: CALL_OW 266
64329: ST_TO_ADDR
// if btype = b_armoury then
64330: LD_VAR 0 5
64334: PUSH
64335: LD_INT 4
64337: EQUAL
64338: IFFALSE 64348
// btype := b_barracks ;
64340: LD_ADDR_VAR 0 5
64344: PUSH
64345: LD_INT 5
64347: ST_TO_ADDR
// if btype = b_depot then
64348: LD_VAR 0 5
64352: PUSH
64353: LD_INT 0
64355: EQUAL
64356: IFFALSE 64366
// btype := b_warehouse ;
64358: LD_ADDR_VAR 0 5
64362: PUSH
64363: LD_INT 1
64365: ST_TO_ADDR
// if btype = b_workshop then
64366: LD_VAR 0 5
64370: PUSH
64371: LD_INT 2
64373: EQUAL
64374: IFFALSE 64384
// btype := b_factory ;
64376: LD_ADDR_VAR 0 5
64380: PUSH
64381: LD_INT 3
64383: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64384: LD_ADDR_VAR 0 4
64388: PUSH
64389: LD_VAR 0 5
64393: PPUSH
64394: LD_VAR 0 1
64398: PPUSH
64399: CALL_OW 248
64403: PPUSH
64404: CALL_OW 450
64408: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64409: LD_ADDR_VAR 0 2
64413: PUSH
64414: LD_VAR 0 3
64418: PPUSH
64419: LD_INT 1
64421: PPUSH
64422: CALL_OW 275
64426: PUSH
64427: LD_VAR 0 4
64431: PUSH
64432: LD_INT 1
64434: ARRAY
64435: GREATEREQUAL
64436: PUSH
64437: LD_VAR 0 3
64441: PPUSH
64442: LD_INT 2
64444: PPUSH
64445: CALL_OW 275
64449: PUSH
64450: LD_VAR 0 4
64454: PUSH
64455: LD_INT 2
64457: ARRAY
64458: GREATEREQUAL
64459: AND
64460: PUSH
64461: LD_VAR 0 3
64465: PPUSH
64466: LD_INT 3
64468: PPUSH
64469: CALL_OW 275
64473: PUSH
64474: LD_VAR 0 4
64478: PUSH
64479: LD_INT 3
64481: ARRAY
64482: GREATEREQUAL
64483: AND
64484: ST_TO_ADDR
// end ;
64485: LD_VAR 0 2
64489: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64490: LD_INT 0
64492: PPUSH
64493: PPUSH
64494: PPUSH
// pom := GetBase ( building ) ;
64495: LD_ADDR_VAR 0 4
64499: PUSH
64500: LD_VAR 0 1
64504: PPUSH
64505: CALL_OW 274
64509: ST_TO_ADDR
// if not pom then
64510: LD_VAR 0 4
64514: NOT
64515: IFFALSE 64519
// exit ;
64517: GO 64620
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64519: LD_ADDR_VAR 0 5
64523: PUSH
64524: LD_VAR 0 2
64528: PPUSH
64529: LD_VAR 0 1
64533: PPUSH
64534: CALL_OW 248
64538: PPUSH
64539: CALL_OW 450
64543: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64544: LD_ADDR_VAR 0 3
64548: PUSH
64549: LD_VAR 0 4
64553: PPUSH
64554: LD_INT 1
64556: PPUSH
64557: CALL_OW 275
64561: PUSH
64562: LD_VAR 0 5
64566: PUSH
64567: LD_INT 1
64569: ARRAY
64570: GREATEREQUAL
64571: PUSH
64572: LD_VAR 0 4
64576: PPUSH
64577: LD_INT 2
64579: PPUSH
64580: CALL_OW 275
64584: PUSH
64585: LD_VAR 0 5
64589: PUSH
64590: LD_INT 2
64592: ARRAY
64593: GREATEREQUAL
64594: AND
64595: PUSH
64596: LD_VAR 0 4
64600: PPUSH
64601: LD_INT 3
64603: PPUSH
64604: CALL_OW 275
64608: PUSH
64609: LD_VAR 0 5
64613: PUSH
64614: LD_INT 3
64616: ARRAY
64617: GREATEREQUAL
64618: AND
64619: ST_TO_ADDR
// end ;
64620: LD_VAR 0 3
64624: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64625: LD_INT 0
64627: PPUSH
64628: PPUSH
64629: PPUSH
64630: PPUSH
64631: PPUSH
64632: PPUSH
64633: PPUSH
64634: PPUSH
64635: PPUSH
64636: PPUSH
64637: PPUSH
// result := false ;
64638: LD_ADDR_VAR 0 8
64642: PUSH
64643: LD_INT 0
64645: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64646: LD_VAR 0 5
64650: NOT
64651: PUSH
64652: LD_VAR 0 1
64656: NOT
64657: OR
64658: PUSH
64659: LD_VAR 0 2
64663: NOT
64664: OR
64665: PUSH
64666: LD_VAR 0 3
64670: NOT
64671: OR
64672: IFFALSE 64676
// exit ;
64674: GO 65490
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64676: LD_ADDR_VAR 0 14
64680: PUSH
64681: LD_VAR 0 1
64685: PPUSH
64686: LD_VAR 0 2
64690: PPUSH
64691: LD_VAR 0 3
64695: PPUSH
64696: LD_VAR 0 4
64700: PPUSH
64701: LD_VAR 0 5
64705: PUSH
64706: LD_INT 1
64708: ARRAY
64709: PPUSH
64710: CALL_OW 248
64714: PPUSH
64715: LD_INT 0
64717: PPUSH
64718: CALL 66723 0 6
64722: ST_TO_ADDR
// if not hexes then
64723: LD_VAR 0 14
64727: NOT
64728: IFFALSE 64732
// exit ;
64730: GO 65490
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64732: LD_ADDR_VAR 0 17
64736: PUSH
64737: LD_VAR 0 5
64741: PPUSH
64742: LD_INT 22
64744: PUSH
64745: LD_VAR 0 13
64749: PPUSH
64750: CALL_OW 255
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: PUSH
64759: LD_INT 2
64761: PUSH
64762: LD_INT 30
64764: PUSH
64765: LD_INT 0
64767: PUSH
64768: EMPTY
64769: LIST
64770: LIST
64771: PUSH
64772: LD_INT 30
64774: PUSH
64775: LD_INT 1
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: EMPTY
64783: LIST
64784: LIST
64785: LIST
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PPUSH
64791: CALL_OW 72
64795: ST_TO_ADDR
// for i = 1 to hexes do
64796: LD_ADDR_VAR 0 9
64800: PUSH
64801: DOUBLE
64802: LD_INT 1
64804: DEC
64805: ST_TO_ADDR
64806: LD_VAR 0 14
64810: PUSH
64811: FOR_TO
64812: IFFALSE 65488
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64814: LD_ADDR_VAR 0 13
64818: PUSH
64819: LD_VAR 0 14
64823: PUSH
64824: LD_VAR 0 9
64828: ARRAY
64829: PUSH
64830: LD_INT 1
64832: ARRAY
64833: PPUSH
64834: LD_VAR 0 14
64838: PUSH
64839: LD_VAR 0 9
64843: ARRAY
64844: PUSH
64845: LD_INT 2
64847: ARRAY
64848: PPUSH
64849: CALL_OW 428
64853: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64854: LD_VAR 0 14
64858: PUSH
64859: LD_VAR 0 9
64863: ARRAY
64864: PUSH
64865: LD_INT 1
64867: ARRAY
64868: PPUSH
64869: LD_VAR 0 14
64873: PUSH
64874: LD_VAR 0 9
64878: ARRAY
64879: PUSH
64880: LD_INT 2
64882: ARRAY
64883: PPUSH
64884: CALL_OW 351
64888: PUSH
64889: LD_VAR 0 14
64893: PUSH
64894: LD_VAR 0 9
64898: ARRAY
64899: PUSH
64900: LD_INT 1
64902: ARRAY
64903: PPUSH
64904: LD_VAR 0 14
64908: PUSH
64909: LD_VAR 0 9
64913: ARRAY
64914: PUSH
64915: LD_INT 2
64917: ARRAY
64918: PPUSH
64919: CALL_OW 488
64923: NOT
64924: OR
64925: PUSH
64926: LD_VAR 0 13
64930: PPUSH
64931: CALL_OW 247
64935: PUSH
64936: LD_INT 3
64938: EQUAL
64939: OR
64940: IFFALSE 64946
// exit ;
64942: POP
64943: POP
64944: GO 65490
// if not tmp then
64946: LD_VAR 0 13
64950: NOT
64951: IFFALSE 64955
// continue ;
64953: GO 64811
// result := true ;
64955: LD_ADDR_VAR 0 8
64959: PUSH
64960: LD_INT 1
64962: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64963: LD_VAR 0 6
64967: PUSH
64968: LD_VAR 0 13
64972: PPUSH
64973: CALL_OW 247
64977: PUSH
64978: LD_INT 2
64980: EQUAL
64981: AND
64982: PUSH
64983: LD_VAR 0 13
64987: PPUSH
64988: CALL_OW 263
64992: PUSH
64993: LD_INT 1
64995: EQUAL
64996: AND
64997: IFFALSE 65161
// begin if IsDrivenBy ( tmp ) then
64999: LD_VAR 0 13
65003: PPUSH
65004: CALL_OW 311
65008: IFFALSE 65012
// continue ;
65010: GO 64811
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65012: LD_VAR 0 6
65016: PPUSH
65017: LD_INT 3
65019: PUSH
65020: LD_INT 60
65022: PUSH
65023: EMPTY
65024: LIST
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 3
65032: PUSH
65033: LD_INT 55
65035: PUSH
65036: EMPTY
65037: LIST
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PPUSH
65047: CALL_OW 72
65051: IFFALSE 65159
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65053: LD_ADDR_VAR 0 18
65057: PUSH
65058: LD_VAR 0 6
65062: PPUSH
65063: LD_INT 3
65065: PUSH
65066: LD_INT 60
65068: PUSH
65069: EMPTY
65070: LIST
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PUSH
65076: LD_INT 3
65078: PUSH
65079: LD_INT 55
65081: PUSH
65082: EMPTY
65083: LIST
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: PPUSH
65093: CALL_OW 72
65097: PUSH
65098: LD_INT 1
65100: ARRAY
65101: ST_TO_ADDR
// if IsInUnit ( driver ) then
65102: LD_VAR 0 18
65106: PPUSH
65107: CALL_OW 310
65111: IFFALSE 65122
// ComExit ( driver ) ;
65113: LD_VAR 0 18
65117: PPUSH
65118: CALL 90502 0 1
// AddComEnterUnit ( driver , tmp ) ;
65122: LD_VAR 0 18
65126: PPUSH
65127: LD_VAR 0 13
65131: PPUSH
65132: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65136: LD_VAR 0 18
65140: PPUSH
65141: LD_VAR 0 7
65145: PPUSH
65146: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65150: LD_VAR 0 18
65154: PPUSH
65155: CALL_OW 181
// end ; continue ;
65159: GO 64811
// end ; if not cleaners or not tmp in cleaners then
65161: LD_VAR 0 6
65165: NOT
65166: PUSH
65167: LD_VAR 0 13
65171: PUSH
65172: LD_VAR 0 6
65176: IN
65177: NOT
65178: OR
65179: IFFALSE 65486
// begin if dep then
65181: LD_VAR 0 17
65185: IFFALSE 65321
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65187: LD_ADDR_VAR 0 16
65191: PUSH
65192: LD_VAR 0 17
65196: PUSH
65197: LD_INT 1
65199: ARRAY
65200: PPUSH
65201: CALL_OW 250
65205: PPUSH
65206: LD_VAR 0 17
65210: PUSH
65211: LD_INT 1
65213: ARRAY
65214: PPUSH
65215: CALL_OW 254
65219: PPUSH
65220: LD_INT 5
65222: PPUSH
65223: CALL_OW 272
65227: PUSH
65228: LD_VAR 0 17
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PPUSH
65237: CALL_OW 251
65241: PPUSH
65242: LD_VAR 0 17
65246: PUSH
65247: LD_INT 1
65249: ARRAY
65250: PPUSH
65251: CALL_OW 254
65255: PPUSH
65256: LD_INT 5
65258: PPUSH
65259: CALL_OW 273
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65268: LD_VAR 0 16
65272: PUSH
65273: LD_INT 1
65275: ARRAY
65276: PPUSH
65277: LD_VAR 0 16
65281: PUSH
65282: LD_INT 2
65284: ARRAY
65285: PPUSH
65286: CALL_OW 488
65290: IFFALSE 65321
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65292: LD_VAR 0 13
65296: PPUSH
65297: LD_VAR 0 16
65301: PUSH
65302: LD_INT 1
65304: ARRAY
65305: PPUSH
65306: LD_VAR 0 16
65310: PUSH
65311: LD_INT 2
65313: ARRAY
65314: PPUSH
65315: CALL_OW 111
// continue ;
65319: GO 64811
// end ; end ; r := GetDir ( tmp ) ;
65321: LD_ADDR_VAR 0 15
65325: PUSH
65326: LD_VAR 0 13
65330: PPUSH
65331: CALL_OW 254
65335: ST_TO_ADDR
// if r = 5 then
65336: LD_VAR 0 15
65340: PUSH
65341: LD_INT 5
65343: EQUAL
65344: IFFALSE 65354
// r := 0 ;
65346: LD_ADDR_VAR 0 15
65350: PUSH
65351: LD_INT 0
65353: ST_TO_ADDR
// for j = r to 5 do
65354: LD_ADDR_VAR 0 10
65358: PUSH
65359: DOUBLE
65360: LD_VAR 0 15
65364: DEC
65365: ST_TO_ADDR
65366: LD_INT 5
65368: PUSH
65369: FOR_TO
65370: IFFALSE 65484
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65372: LD_ADDR_VAR 0 11
65376: PUSH
65377: LD_VAR 0 13
65381: PPUSH
65382: CALL_OW 250
65386: PPUSH
65387: LD_VAR 0 10
65391: PPUSH
65392: LD_INT 2
65394: PPUSH
65395: CALL_OW 272
65399: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65400: LD_ADDR_VAR 0 12
65404: PUSH
65405: LD_VAR 0 13
65409: PPUSH
65410: CALL_OW 251
65414: PPUSH
65415: LD_VAR 0 10
65419: PPUSH
65420: LD_INT 2
65422: PPUSH
65423: CALL_OW 273
65427: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65428: LD_VAR 0 11
65432: PPUSH
65433: LD_VAR 0 12
65437: PPUSH
65438: CALL_OW 488
65442: PUSH
65443: LD_VAR 0 11
65447: PPUSH
65448: LD_VAR 0 12
65452: PPUSH
65453: CALL_OW 428
65457: NOT
65458: AND
65459: IFFALSE 65482
// begin ComMoveXY ( tmp , _x , _y ) ;
65461: LD_VAR 0 13
65465: PPUSH
65466: LD_VAR 0 11
65470: PPUSH
65471: LD_VAR 0 12
65475: PPUSH
65476: CALL_OW 111
// break ;
65480: GO 65484
// end ; end ;
65482: GO 65369
65484: POP
65485: POP
// end ; end ;
65486: GO 64811
65488: POP
65489: POP
// end ;
65490: LD_VAR 0 8
65494: RET
// export function BuildingTechInvented ( side , btype ) ; begin
65495: LD_INT 0
65497: PPUSH
// result := true ;
65498: LD_ADDR_VAR 0 3
65502: PUSH
65503: LD_INT 1
65505: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
65506: LD_VAR 0 2
65510: PUSH
65511: LD_INT 24
65513: DOUBLE
65514: EQUAL
65515: IFTRUE 65525
65517: LD_INT 33
65519: DOUBLE
65520: EQUAL
65521: IFTRUE 65525
65523: GO 65550
65525: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
65526: LD_ADDR_VAR 0 3
65530: PUSH
65531: LD_INT 32
65533: PPUSH
65534: LD_VAR 0 1
65538: PPUSH
65539: CALL_OW 321
65543: PUSH
65544: LD_INT 2
65546: EQUAL
65547: ST_TO_ADDR
65548: GO 65866
65550: LD_INT 20
65552: DOUBLE
65553: EQUAL
65554: IFTRUE 65558
65556: GO 65583
65558: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
65559: LD_ADDR_VAR 0 3
65563: PUSH
65564: LD_INT 6
65566: PPUSH
65567: LD_VAR 0 1
65571: PPUSH
65572: CALL_OW 321
65576: PUSH
65577: LD_INT 2
65579: EQUAL
65580: ST_TO_ADDR
65581: GO 65866
65583: LD_INT 22
65585: DOUBLE
65586: EQUAL
65587: IFTRUE 65597
65589: LD_INT 36
65591: DOUBLE
65592: EQUAL
65593: IFTRUE 65597
65595: GO 65622
65597: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65598: LD_ADDR_VAR 0 3
65602: PUSH
65603: LD_INT 15
65605: PPUSH
65606: LD_VAR 0 1
65610: PPUSH
65611: CALL_OW 321
65615: PUSH
65616: LD_INT 2
65618: EQUAL
65619: ST_TO_ADDR
65620: GO 65866
65622: LD_INT 30
65624: DOUBLE
65625: EQUAL
65626: IFTRUE 65630
65628: GO 65655
65630: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65631: LD_ADDR_VAR 0 3
65635: PUSH
65636: LD_INT 20
65638: PPUSH
65639: LD_VAR 0 1
65643: PPUSH
65644: CALL_OW 321
65648: PUSH
65649: LD_INT 2
65651: EQUAL
65652: ST_TO_ADDR
65653: GO 65866
65655: LD_INT 28
65657: DOUBLE
65658: EQUAL
65659: IFTRUE 65669
65661: LD_INT 21
65663: DOUBLE
65664: EQUAL
65665: IFTRUE 65669
65667: GO 65694
65669: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65670: LD_ADDR_VAR 0 3
65674: PUSH
65675: LD_INT 21
65677: PPUSH
65678: LD_VAR 0 1
65682: PPUSH
65683: CALL_OW 321
65687: PUSH
65688: LD_INT 2
65690: EQUAL
65691: ST_TO_ADDR
65692: GO 65866
65694: LD_INT 16
65696: DOUBLE
65697: EQUAL
65698: IFTRUE 65702
65700: GO 65727
65702: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65703: LD_ADDR_VAR 0 3
65707: PUSH
65708: LD_INT 84
65710: PPUSH
65711: LD_VAR 0 1
65715: PPUSH
65716: CALL_OW 321
65720: PUSH
65721: LD_INT 2
65723: EQUAL
65724: ST_TO_ADDR
65725: GO 65866
65727: LD_INT 19
65729: DOUBLE
65730: EQUAL
65731: IFTRUE 65741
65733: LD_INT 23
65735: DOUBLE
65736: EQUAL
65737: IFTRUE 65741
65739: GO 65766
65741: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65742: LD_ADDR_VAR 0 3
65746: PUSH
65747: LD_INT 83
65749: PPUSH
65750: LD_VAR 0 1
65754: PPUSH
65755: CALL_OW 321
65759: PUSH
65760: LD_INT 2
65762: EQUAL
65763: ST_TO_ADDR
65764: GO 65866
65766: LD_INT 17
65768: DOUBLE
65769: EQUAL
65770: IFTRUE 65774
65772: GO 65799
65774: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65775: LD_ADDR_VAR 0 3
65779: PUSH
65780: LD_INT 39
65782: PPUSH
65783: LD_VAR 0 1
65787: PPUSH
65788: CALL_OW 321
65792: PUSH
65793: LD_INT 2
65795: EQUAL
65796: ST_TO_ADDR
65797: GO 65866
65799: LD_INT 18
65801: DOUBLE
65802: EQUAL
65803: IFTRUE 65807
65805: GO 65832
65807: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65808: LD_ADDR_VAR 0 3
65812: PUSH
65813: LD_INT 40
65815: PPUSH
65816: LD_VAR 0 1
65820: PPUSH
65821: CALL_OW 321
65825: PUSH
65826: LD_INT 2
65828: EQUAL
65829: ST_TO_ADDR
65830: GO 65866
65832: LD_INT 27
65834: DOUBLE
65835: EQUAL
65836: IFTRUE 65840
65838: GO 65865
65840: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65841: LD_ADDR_VAR 0 3
65845: PUSH
65846: LD_INT 35
65848: PPUSH
65849: LD_VAR 0 1
65853: PPUSH
65854: CALL_OW 321
65858: PUSH
65859: LD_INT 2
65861: EQUAL
65862: ST_TO_ADDR
65863: GO 65866
65865: POP
// end ;
65866: LD_VAR 0 3
65870: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65871: LD_INT 0
65873: PPUSH
65874: PPUSH
65875: PPUSH
65876: PPUSH
65877: PPUSH
65878: PPUSH
65879: PPUSH
65880: PPUSH
65881: PPUSH
65882: PPUSH
65883: PPUSH
// result := false ;
65884: LD_ADDR_VAR 0 6
65888: PUSH
65889: LD_INT 0
65891: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65892: LD_VAR 0 1
65896: NOT
65897: PUSH
65898: LD_VAR 0 1
65902: PPUSH
65903: CALL_OW 266
65907: PUSH
65908: LD_INT 0
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: IN
65918: NOT
65919: OR
65920: PUSH
65921: LD_VAR 0 2
65925: NOT
65926: OR
65927: PUSH
65928: LD_VAR 0 5
65932: PUSH
65933: LD_INT 0
65935: PUSH
65936: LD_INT 1
65938: PUSH
65939: LD_INT 2
65941: PUSH
65942: LD_INT 3
65944: PUSH
65945: LD_INT 4
65947: PUSH
65948: LD_INT 5
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: IN
65959: NOT
65960: OR
65961: PUSH
65962: LD_VAR 0 3
65966: PPUSH
65967: LD_VAR 0 4
65971: PPUSH
65972: CALL_OW 488
65976: NOT
65977: OR
65978: IFFALSE 65982
// exit ;
65980: GO 66718
// side := GetSide ( depot ) ;
65982: LD_ADDR_VAR 0 9
65986: PUSH
65987: LD_VAR 0 1
65991: PPUSH
65992: CALL_OW 255
65996: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65997: LD_VAR 0 9
66001: PPUSH
66002: LD_VAR 0 2
66006: PPUSH
66007: CALL 65495 0 2
66011: NOT
66012: IFFALSE 66016
// exit ;
66014: GO 66718
// pom := GetBase ( depot ) ;
66016: LD_ADDR_VAR 0 10
66020: PUSH
66021: LD_VAR 0 1
66025: PPUSH
66026: CALL_OW 274
66030: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66031: LD_ADDR_VAR 0 11
66035: PUSH
66036: LD_VAR 0 2
66040: PPUSH
66041: LD_VAR 0 1
66045: PPUSH
66046: CALL_OW 248
66050: PPUSH
66051: CALL_OW 450
66055: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66056: LD_VAR 0 10
66060: PPUSH
66061: LD_INT 1
66063: PPUSH
66064: CALL_OW 275
66068: PUSH
66069: LD_VAR 0 11
66073: PUSH
66074: LD_INT 1
66076: ARRAY
66077: GREATEREQUAL
66078: PUSH
66079: LD_VAR 0 10
66083: PPUSH
66084: LD_INT 2
66086: PPUSH
66087: CALL_OW 275
66091: PUSH
66092: LD_VAR 0 11
66096: PUSH
66097: LD_INT 2
66099: ARRAY
66100: GREATEREQUAL
66101: AND
66102: PUSH
66103: LD_VAR 0 10
66107: PPUSH
66108: LD_INT 3
66110: PPUSH
66111: CALL_OW 275
66115: PUSH
66116: LD_VAR 0 11
66120: PUSH
66121: LD_INT 3
66123: ARRAY
66124: GREATEREQUAL
66125: AND
66126: NOT
66127: IFFALSE 66131
// exit ;
66129: GO 66718
// if GetBType ( depot ) = b_depot then
66131: LD_VAR 0 1
66135: PPUSH
66136: CALL_OW 266
66140: PUSH
66141: LD_INT 0
66143: EQUAL
66144: IFFALSE 66156
// dist := 28 else
66146: LD_ADDR_VAR 0 14
66150: PUSH
66151: LD_INT 28
66153: ST_TO_ADDR
66154: GO 66164
// dist := 36 ;
66156: LD_ADDR_VAR 0 14
66160: PUSH
66161: LD_INT 36
66163: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
66164: LD_VAR 0 1
66168: PPUSH
66169: LD_VAR 0 3
66173: PPUSH
66174: LD_VAR 0 4
66178: PPUSH
66179: CALL_OW 297
66183: PUSH
66184: LD_VAR 0 14
66188: GREATER
66189: IFFALSE 66193
// exit ;
66191: GO 66718
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
66193: LD_ADDR_VAR 0 12
66197: PUSH
66198: LD_VAR 0 2
66202: PPUSH
66203: LD_VAR 0 3
66207: PPUSH
66208: LD_VAR 0 4
66212: PPUSH
66213: LD_VAR 0 5
66217: PPUSH
66218: LD_VAR 0 1
66222: PPUSH
66223: CALL_OW 248
66227: PPUSH
66228: LD_INT 0
66230: PPUSH
66231: CALL 66723 0 6
66235: ST_TO_ADDR
// if not hexes then
66236: LD_VAR 0 12
66240: NOT
66241: IFFALSE 66245
// exit ;
66243: GO 66718
// hex := GetHexInfo ( x , y ) ;
66245: LD_ADDR_VAR 0 15
66249: PUSH
66250: LD_VAR 0 3
66254: PPUSH
66255: LD_VAR 0 4
66259: PPUSH
66260: CALL_OW 546
66264: ST_TO_ADDR
// if hex [ 1 ] then
66265: LD_VAR 0 15
66269: PUSH
66270: LD_INT 1
66272: ARRAY
66273: IFFALSE 66277
// exit ;
66275: GO 66718
// height := hex [ 2 ] ;
66277: LD_ADDR_VAR 0 13
66281: PUSH
66282: LD_VAR 0 15
66286: PUSH
66287: LD_INT 2
66289: ARRAY
66290: ST_TO_ADDR
// for i = 1 to hexes do
66291: LD_ADDR_VAR 0 7
66295: PUSH
66296: DOUBLE
66297: LD_INT 1
66299: DEC
66300: ST_TO_ADDR
66301: LD_VAR 0 12
66305: PUSH
66306: FOR_TO
66307: IFFALSE 66637
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
66309: LD_VAR 0 12
66313: PUSH
66314: LD_VAR 0 7
66318: ARRAY
66319: PUSH
66320: LD_INT 1
66322: ARRAY
66323: PPUSH
66324: LD_VAR 0 12
66328: PUSH
66329: LD_VAR 0 7
66333: ARRAY
66334: PUSH
66335: LD_INT 2
66337: ARRAY
66338: PPUSH
66339: CALL_OW 488
66343: NOT
66344: PUSH
66345: LD_VAR 0 12
66349: PUSH
66350: LD_VAR 0 7
66354: ARRAY
66355: PUSH
66356: LD_INT 1
66358: ARRAY
66359: PPUSH
66360: LD_VAR 0 12
66364: PUSH
66365: LD_VAR 0 7
66369: ARRAY
66370: PUSH
66371: LD_INT 2
66373: ARRAY
66374: PPUSH
66375: CALL_OW 428
66379: PUSH
66380: LD_INT 0
66382: GREATER
66383: OR
66384: PUSH
66385: LD_VAR 0 12
66389: PUSH
66390: LD_VAR 0 7
66394: ARRAY
66395: PUSH
66396: LD_INT 1
66398: ARRAY
66399: PPUSH
66400: LD_VAR 0 12
66404: PUSH
66405: LD_VAR 0 7
66409: ARRAY
66410: PUSH
66411: LD_INT 2
66413: ARRAY
66414: PPUSH
66415: CALL_OW 351
66419: OR
66420: IFFALSE 66426
// exit ;
66422: POP
66423: POP
66424: GO 66718
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66426: LD_ADDR_VAR 0 8
66430: PUSH
66431: LD_VAR 0 12
66435: PUSH
66436: LD_VAR 0 7
66440: ARRAY
66441: PUSH
66442: LD_INT 1
66444: ARRAY
66445: PPUSH
66446: LD_VAR 0 12
66450: PUSH
66451: LD_VAR 0 7
66455: ARRAY
66456: PUSH
66457: LD_INT 2
66459: ARRAY
66460: PPUSH
66461: CALL_OW 546
66465: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
66466: LD_VAR 0 8
66470: PUSH
66471: LD_INT 1
66473: ARRAY
66474: PUSH
66475: LD_VAR 0 8
66479: PUSH
66480: LD_INT 2
66482: ARRAY
66483: PUSH
66484: LD_VAR 0 13
66488: PUSH
66489: LD_INT 2
66491: PLUS
66492: GREATER
66493: OR
66494: PUSH
66495: LD_VAR 0 8
66499: PUSH
66500: LD_INT 2
66502: ARRAY
66503: PUSH
66504: LD_VAR 0 13
66508: PUSH
66509: LD_INT 2
66511: MINUS
66512: LESS
66513: OR
66514: PUSH
66515: LD_VAR 0 8
66519: PUSH
66520: LD_INT 3
66522: ARRAY
66523: PUSH
66524: LD_INT 0
66526: PUSH
66527: LD_INT 8
66529: PUSH
66530: LD_INT 9
66532: PUSH
66533: LD_INT 10
66535: PUSH
66536: LD_INT 11
66538: PUSH
66539: LD_INT 12
66541: PUSH
66542: LD_INT 13
66544: PUSH
66545: LD_INT 16
66547: PUSH
66548: LD_INT 17
66550: PUSH
66551: LD_INT 18
66553: PUSH
66554: LD_INT 19
66556: PUSH
66557: LD_INT 20
66559: PUSH
66560: LD_INT 21
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: IN
66578: NOT
66579: OR
66580: PUSH
66581: LD_VAR 0 8
66585: PUSH
66586: LD_INT 5
66588: ARRAY
66589: NOT
66590: OR
66591: PUSH
66592: LD_VAR 0 8
66596: PUSH
66597: LD_INT 6
66599: ARRAY
66600: PUSH
66601: LD_INT 1
66603: PUSH
66604: LD_INT 2
66606: PUSH
66607: LD_INT 7
66609: PUSH
66610: LD_INT 9
66612: PUSH
66613: LD_INT 10
66615: PUSH
66616: LD_INT 11
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: IN
66627: NOT
66628: OR
66629: IFFALSE 66635
// exit ;
66631: POP
66632: POP
66633: GO 66718
// end ;
66635: GO 66306
66637: POP
66638: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66639: LD_VAR 0 9
66643: PPUSH
66644: LD_VAR 0 3
66648: PPUSH
66649: LD_VAR 0 4
66653: PPUSH
66654: LD_INT 20
66656: PPUSH
66657: CALL 58670 0 4
66661: PUSH
66662: LD_INT 4
66664: ARRAY
66665: IFFALSE 66669
// exit ;
66667: GO 66718
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66669: LD_VAR 0 2
66673: PUSH
66674: LD_INT 29
66676: PUSH
66677: LD_INT 30
66679: PUSH
66680: EMPTY
66681: LIST
66682: LIST
66683: IN
66684: PUSH
66685: LD_VAR 0 3
66689: PPUSH
66690: LD_VAR 0 4
66694: PPUSH
66695: LD_VAR 0 9
66699: PPUSH
66700: CALL_OW 440
66704: NOT
66705: AND
66706: IFFALSE 66710
// exit ;
66708: GO 66718
// result := true ;
66710: LD_ADDR_VAR 0 6
66714: PUSH
66715: LD_INT 1
66717: ST_TO_ADDR
// end ;
66718: LD_VAR 0 6
66722: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66723: LD_INT 0
66725: PPUSH
66726: PPUSH
66727: PPUSH
66728: PPUSH
66729: PPUSH
66730: PPUSH
66731: PPUSH
66732: PPUSH
66733: PPUSH
66734: PPUSH
66735: PPUSH
66736: PPUSH
66737: PPUSH
66738: PPUSH
66739: PPUSH
66740: PPUSH
66741: PPUSH
66742: PPUSH
66743: PPUSH
66744: PPUSH
66745: PPUSH
66746: PPUSH
66747: PPUSH
66748: PPUSH
66749: PPUSH
66750: PPUSH
66751: PPUSH
66752: PPUSH
66753: PPUSH
66754: PPUSH
66755: PPUSH
66756: PPUSH
66757: PPUSH
66758: PPUSH
66759: PPUSH
66760: PPUSH
66761: PPUSH
66762: PPUSH
66763: PPUSH
66764: PPUSH
66765: PPUSH
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
66772: PPUSH
66773: PPUSH
66774: PPUSH
66775: PPUSH
66776: PPUSH
66777: PPUSH
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
66782: PPUSH
// result = [ ] ;
66783: LD_ADDR_VAR 0 7
66787: PUSH
66788: EMPTY
66789: ST_TO_ADDR
// temp_list = [ ] ;
66790: LD_ADDR_VAR 0 9
66794: PUSH
66795: EMPTY
66796: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66797: LD_VAR 0 4
66801: PUSH
66802: LD_INT 0
66804: PUSH
66805: LD_INT 1
66807: PUSH
66808: LD_INT 2
66810: PUSH
66811: LD_INT 3
66813: PUSH
66814: LD_INT 4
66816: PUSH
66817: LD_INT 5
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: IN
66828: NOT
66829: PUSH
66830: LD_VAR 0 1
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: LD_INT 1
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: IN
66845: PUSH
66846: LD_VAR 0 5
66850: PUSH
66851: LD_INT 1
66853: PUSH
66854: LD_INT 2
66856: PUSH
66857: LD_INT 3
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: LIST
66864: IN
66865: NOT
66866: AND
66867: OR
66868: IFFALSE 66872
// exit ;
66870: GO 85263
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66872: LD_VAR 0 1
66876: PUSH
66877: LD_INT 6
66879: PUSH
66880: LD_INT 7
66882: PUSH
66883: LD_INT 8
66885: PUSH
66886: LD_INT 13
66888: PUSH
66889: LD_INT 12
66891: PUSH
66892: LD_INT 15
66894: PUSH
66895: LD_INT 11
66897: PUSH
66898: LD_INT 14
66900: PUSH
66901: LD_INT 10
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: IN
66915: IFFALSE 66925
// btype = b_lab ;
66917: LD_ADDR_VAR 0 1
66921: PUSH
66922: LD_INT 6
66924: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66925: LD_VAR 0 6
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: LD_INT 1
66935: PUSH
66936: LD_INT 2
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: IN
66944: NOT
66945: PUSH
66946: LD_VAR 0 1
66950: PUSH
66951: LD_INT 0
66953: PUSH
66954: LD_INT 1
66956: PUSH
66957: LD_INT 2
66959: PUSH
66960: LD_INT 3
66962: PUSH
66963: LD_INT 6
66965: PUSH
66966: LD_INT 36
66968: PUSH
66969: LD_INT 4
66971: PUSH
66972: LD_INT 5
66974: PUSH
66975: LD_INT 31
66977: PUSH
66978: LD_INT 32
66980: PUSH
66981: LD_INT 33
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: IN
66997: NOT
66998: PUSH
66999: LD_VAR 0 6
67003: PUSH
67004: LD_INT 1
67006: EQUAL
67007: AND
67008: OR
67009: PUSH
67010: LD_VAR 0 1
67014: PUSH
67015: LD_INT 2
67017: PUSH
67018: LD_INT 3
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: IN
67025: NOT
67026: PUSH
67027: LD_VAR 0 6
67031: PUSH
67032: LD_INT 2
67034: EQUAL
67035: AND
67036: OR
67037: IFFALSE 67047
// mode = 0 ;
67039: LD_ADDR_VAR 0 6
67043: PUSH
67044: LD_INT 0
67046: ST_TO_ADDR
// case mode of 0 :
67047: LD_VAR 0 6
67051: PUSH
67052: LD_INT 0
67054: DOUBLE
67055: EQUAL
67056: IFTRUE 67060
67058: GO 78513
67060: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67061: LD_ADDR_VAR 0 11
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 0
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 0
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 1
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 0
67109: PUSH
67110: LD_INT 1
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 1
67119: NEG
67120: PUSH
67121: LD_INT 0
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: LD_INT 1
67130: NEG
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: LD_INT 2
67146: NEG
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 0
67154: PUSH
67155: LD_INT 2
67157: NEG
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 1
67165: PUSH
67166: LD_INT 1
67168: NEG
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 1
67176: PUSH
67177: LD_INT 2
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 0
67186: PUSH
67187: LD_INT 2
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 1
67196: NEG
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 1
67207: PUSH
67208: LD_INT 3
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 0
67217: PUSH
67218: LD_INT 3
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: LD_INT 2
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67254: LD_ADDR_VAR 0 12
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: LD_INT 0
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 1
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: LD_INT 1
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: NEG
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 1
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 1
67338: NEG
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: LD_INT 0
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: LD_INT 1
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 2
67377: NEG
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: LD_INT 1
67392: NEG
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 2
67400: NEG
67401: PUSH
67402: LD_INT 1
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 3
67411: NEG
67412: PUSH
67413: LD_INT 0
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 3
67422: NEG
67423: PUSH
67424: LD_INT 1
67426: NEG
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67450: LD_ADDR_VAR 0 13
67454: PUSH
67455: LD_INT 0
67457: PUSH
67458: LD_INT 0
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 0
67467: PUSH
67468: LD_INT 1
67470: NEG
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: LD_INT 0
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: LD_INT 1
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: PUSH
67496: LD_INT 0
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 1
67508: NEG
67509: PUSH
67510: LD_INT 0
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 1
67519: NEG
67520: PUSH
67521: LD_INT 1
67523: NEG
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 1
67531: NEG
67532: PUSH
67533: LD_INT 2
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 2
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 2
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 1
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: LD_INT 1
67577: NEG
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 2
67585: NEG
67586: PUSH
67587: LD_INT 2
67589: NEG
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 2
67597: NEG
67598: PUSH
67599: LD_INT 3
67601: NEG
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: LD_INT 3
67609: NEG
67610: PUSH
67611: LD_INT 2
67613: NEG
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 3
67621: NEG
67622: PUSH
67623: LD_INT 3
67625: NEG
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67649: LD_ADDR_VAR 0 14
67653: PUSH
67654: LD_INT 0
67656: PUSH
67657: LD_INT 0
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: LD_INT 1
67669: NEG
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: LD_INT 0
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 1
67687: PUSH
67688: LD_INT 1
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 0
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 1
67707: NEG
67708: PUSH
67709: LD_INT 0
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: NEG
67719: PUSH
67720: LD_INT 1
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 1
67730: NEG
67731: PUSH
67732: LD_INT 2
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 0
67742: PUSH
67743: LD_INT 2
67745: NEG
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 1
67753: PUSH
67754: LD_INT 1
67756: NEG
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 1
67764: PUSH
67765: LD_INT 2
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: LD_INT 2
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: LD_INT 1
67784: NEG
67785: PUSH
67786: LD_INT 1
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: NEG
67796: PUSH
67797: LD_INT 3
67799: NEG
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: LD_INT 3
67810: NEG
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: LD_INT 1
67818: PUSH
67819: LD_INT 2
67821: NEG
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67845: LD_ADDR_VAR 0 15
67849: PUSH
67850: LD_INT 0
67852: PUSH
67853: LD_INT 0
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 0
67862: PUSH
67863: LD_INT 1
67865: NEG
67866: PUSH
67867: EMPTY
67868: LIST
67869: LIST
67870: PUSH
67871: LD_INT 1
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 1
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: LD_INT 1
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 1
67903: NEG
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 1
67914: NEG
67915: PUSH
67916: LD_INT 1
67918: NEG
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: PUSH
67924: LD_INT 1
67926: PUSH
67927: LD_INT 1
67929: NEG
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: LD_INT 2
67937: PUSH
67938: LD_INT 0
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: LD_INT 2
67947: PUSH
67948: LD_INT 1
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 1
67957: NEG
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: NEG
67969: PUSH
67970: LD_INT 0
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 2
67979: NEG
67980: PUSH
67981: LD_INT 1
67983: NEG
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 2
67991: PUSH
67992: LD_INT 1
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 3
68002: PUSH
68003: LD_INT 0
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 3
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68038: LD_ADDR_VAR 0 16
68042: PUSH
68043: LD_INT 0
68045: PUSH
68046: LD_INT 0
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 0
68055: PUSH
68056: LD_INT 1
68058: NEG
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: LD_INT 0
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: LD_INT 1
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: LD_INT 0
68086: PUSH
68087: LD_INT 1
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 1
68096: NEG
68097: PUSH
68098: LD_INT 0
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: LD_INT 1
68111: NEG
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 1
68119: NEG
68120: PUSH
68121: LD_INT 2
68123: NEG
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 2
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 2
68141: PUSH
68142: LD_INT 2
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: LD_INT 2
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 2
68161: NEG
68162: PUSH
68163: LD_INT 1
68165: NEG
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 2
68173: NEG
68174: PUSH
68175: LD_INT 2
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 3
68185: PUSH
68186: LD_INT 2
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 3
68195: PUSH
68196: LD_INT 3
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 2
68205: PUSH
68206: LD_INT 3
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68231: LD_ADDR_VAR 0 17
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: LD_INT 0
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 0
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 1
68259: PUSH
68260: LD_INT 0
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: LD_INT 1
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 0
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 1
68289: NEG
68290: PUSH
68291: LD_INT 0
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 1
68300: NEG
68301: PUSH
68302: LD_INT 1
68304: NEG
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 1
68312: NEG
68313: PUSH
68314: LD_INT 2
68316: NEG
68317: PUSH
68318: EMPTY
68319: LIST
68320: LIST
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: LD_INT 2
68327: NEG
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: LD_INT 1
68338: NEG
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: LD_INT 2
68346: PUSH
68347: LD_INT 0
68349: PUSH
68350: EMPTY
68351: LIST
68352: LIST
68353: PUSH
68354: LD_INT 2
68356: PUSH
68357: LD_INT 1
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 2
68366: PUSH
68367: LD_INT 2
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: LD_INT 2
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 0
68386: PUSH
68387: LD_INT 2
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 1
68396: NEG
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 2
68407: NEG
68408: PUSH
68409: LD_INT 0
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 2
68418: NEG
68419: PUSH
68420: LD_INT 1
68422: NEG
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 2
68430: NEG
68431: PUSH
68432: LD_INT 2
68434: NEG
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68461: LD_ADDR_VAR 0 18
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: LD_INT 0
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 1
68489: PUSH
68490: LD_INT 0
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: LD_INT 1
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 0
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 1
68519: NEG
68520: PUSH
68521: LD_INT 0
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 1
68530: NEG
68531: PUSH
68532: LD_INT 1
68534: NEG
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: LD_INT 1
68542: NEG
68543: PUSH
68544: LD_INT 2
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 0
68554: PUSH
68555: LD_INT 2
68557: NEG
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 1
68565: PUSH
68566: LD_INT 1
68568: NEG
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 2
68576: PUSH
68577: LD_INT 0
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 2
68586: PUSH
68587: LD_INT 1
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 2
68596: PUSH
68597: LD_INT 2
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 1
68606: PUSH
68607: LD_INT 2
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 0
68616: PUSH
68617: LD_INT 2
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 1
68626: NEG
68627: PUSH
68628: LD_INT 1
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 2
68637: NEG
68638: PUSH
68639: LD_INT 0
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 2
68648: NEG
68649: PUSH
68650: LD_INT 1
68652: NEG
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 2
68660: NEG
68661: PUSH
68662: LD_INT 2
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68691: LD_ADDR_VAR 0 19
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: LD_INT 0
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 0
68708: PUSH
68709: LD_INT 1
68711: NEG
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 1
68719: PUSH
68720: LD_INT 0
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 0
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 1
68749: NEG
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 1
68760: NEG
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 2
68776: NEG
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 0
68784: PUSH
68785: LD_INT 2
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: PUSH
68796: LD_INT 1
68798: NEG
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 2
68806: PUSH
68807: LD_INT 0
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 2
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: LD_INT 2
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 1
68836: PUSH
68837: LD_INT 2
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: LD_INT 2
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PUSH
68865: LD_INT 2
68867: NEG
68868: PUSH
68869: LD_INT 0
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 2
68878: NEG
68879: PUSH
68880: LD_INT 1
68882: NEG
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 2
68890: NEG
68891: PUSH
68892: LD_INT 2
68894: NEG
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68921: LD_ADDR_VAR 0 20
68925: PUSH
68926: LD_INT 0
68928: PUSH
68929: LD_INT 0
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: LD_INT 0
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: LD_INT 1
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: LD_INT 1
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: LD_INT 0
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 1
68990: NEG
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: NEG
69003: PUSH
69004: LD_INT 2
69006: NEG
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 2
69017: NEG
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 1
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 2
69036: PUSH
69037: LD_INT 0
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 2
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: LD_INT 2
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: LD_INT 2
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: LD_INT 1
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 2
69097: NEG
69098: PUSH
69099: LD_INT 0
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 2
69108: NEG
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 2
69120: NEG
69121: PUSH
69122: LD_INT 2
69124: NEG
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69151: LD_ADDR_VAR 0 21
69155: PUSH
69156: LD_INT 0
69158: PUSH
69159: LD_INT 0
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 0
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 1
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: LD_INT 1
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 0
69199: PUSH
69200: LD_INT 1
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: LD_INT 0
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: LD_INT 1
69224: NEG
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 1
69232: NEG
69233: PUSH
69234: LD_INT 2
69236: NEG
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: LD_INT 2
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: PUSH
69256: LD_INT 1
69258: NEG
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 2
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 1
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 2
69286: PUSH
69287: LD_INT 2
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 1
69296: PUSH
69297: LD_INT 2
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 0
69306: PUSH
69307: LD_INT 2
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 1
69316: NEG
69317: PUSH
69318: LD_INT 1
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 2
69327: NEG
69328: PUSH
69329: LD_INT 0
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 2
69350: NEG
69351: PUSH
69352: LD_INT 2
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: LIST
69373: LIST
69374: LIST
69375: LIST
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69381: LD_ADDR_VAR 0 22
69385: PUSH
69386: LD_INT 0
69388: PUSH
69389: LD_INT 0
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 0
69398: PUSH
69399: LD_INT 1
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: LD_INT 0
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: LD_INT 1
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 0
69429: PUSH
69430: LD_INT 1
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: LD_INT 0
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 1
69450: NEG
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: NEG
69463: PUSH
69464: LD_INT 2
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 0
69474: PUSH
69475: LD_INT 2
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: LD_INT 1
69488: NEG
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 2
69496: PUSH
69497: LD_INT 0
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 2
69506: PUSH
69507: LD_INT 1
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 2
69516: PUSH
69517: LD_INT 2
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 1
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 1
69546: NEG
69547: PUSH
69548: LD_INT 1
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 2
69557: NEG
69558: PUSH
69559: LD_INT 0
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 2
69568: NEG
69569: PUSH
69570: LD_INT 1
69572: NEG
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 2
69580: NEG
69581: PUSH
69582: LD_INT 2
69584: NEG
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69611: LD_ADDR_VAR 0 23
69615: PUSH
69616: LD_INT 0
69618: PUSH
69619: LD_INT 0
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 0
69628: PUSH
69629: LD_INT 1
69631: NEG
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 1
69639: PUSH
69640: LD_INT 0
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 0
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: NEG
69670: PUSH
69671: LD_INT 0
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 1
69680: NEG
69681: PUSH
69682: LD_INT 1
69684: NEG
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 1
69692: NEG
69693: PUSH
69694: LD_INT 2
69696: NEG
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 0
69704: PUSH
69705: LD_INT 2
69707: NEG
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 1
69715: PUSH
69716: LD_INT 1
69718: NEG
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: LD_INT 2
69726: PUSH
69727: LD_INT 0
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 2
69746: PUSH
69747: LD_INT 2
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 0
69766: PUSH
69767: LD_INT 2
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: LD_INT 0
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: PUSH
69796: LD_INT 2
69798: NEG
69799: PUSH
69800: LD_INT 1
69802: NEG
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: NEG
69811: PUSH
69812: LD_INT 2
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 2
69822: NEG
69823: PUSH
69824: LD_INT 3
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: NEG
69835: PUSH
69836: LD_INT 3
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: PUSH
69847: LD_INT 2
69849: NEG
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: PUSH
69858: LD_INT 1
69860: NEG
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69891: LD_ADDR_VAR 0 24
69895: PUSH
69896: LD_INT 0
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: PUSH
69920: LD_INT 0
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: LD_INT 1
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: LD_INT 1
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: LD_INT 0
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 1
69960: NEG
69961: PUSH
69962: LD_INT 1
69964: NEG
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 1
69972: NEG
69973: PUSH
69974: LD_INT 2
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: LD_INT 2
69987: NEG
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: PUSH
69996: LD_INT 1
69998: NEG
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 2
70006: PUSH
70007: LD_INT 0
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 2
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 2
70026: PUSH
70027: LD_INT 2
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: LD_INT 2
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: LD_INT 2
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: LD_INT 1
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 2
70067: NEG
70068: PUSH
70069: LD_INT 0
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 2
70078: NEG
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 2
70090: NEG
70091: PUSH
70092: LD_INT 2
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 1
70102: PUSH
70103: LD_INT 2
70105: NEG
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 3
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 3
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
70167: LD_ADDR_VAR 0 25
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: LD_INT 0
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: LD_INT 0
70184: PUSH
70185: LD_INT 1
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 1
70195: PUSH
70196: LD_INT 0
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 1
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 1
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: LD_INT 0
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: NEG
70237: PUSH
70238: LD_INT 1
70240: NEG
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: LD_INT 1
70248: NEG
70249: PUSH
70250: LD_INT 2
70252: NEG
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PUSH
70258: LD_INT 0
70260: PUSH
70261: LD_INT 2
70263: NEG
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 2
70282: PUSH
70283: LD_INT 0
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 2
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 2
70302: PUSH
70303: LD_INT 2
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 1
70312: PUSH
70313: LD_INT 2
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 0
70322: PUSH
70323: LD_INT 2
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 1
70332: NEG
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 2
70343: NEG
70344: PUSH
70345: LD_INT 0
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: LD_INT 2
70354: NEG
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 2
70366: NEG
70367: PUSH
70368: LD_INT 2
70370: NEG
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 3
70378: PUSH
70379: LD_INT 1
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 3
70388: PUSH
70389: LD_INT 2
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 2
70398: PUSH
70399: LD_INT 3
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: PUSH
70409: LD_INT 3
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
70441: LD_ADDR_VAR 0 26
70445: PUSH
70446: LD_INT 0
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 0
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 1
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 0
70489: PUSH
70490: LD_INT 1
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 1
70499: NEG
70500: PUSH
70501: LD_INT 0
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 1
70510: NEG
70511: PUSH
70512: LD_INT 1
70514: NEG
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 1
70522: NEG
70523: PUSH
70524: LD_INT 2
70526: NEG
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 0
70534: PUSH
70535: LD_INT 2
70537: NEG
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: LD_INT 1
70545: PUSH
70546: LD_INT 1
70548: NEG
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 2
70556: PUSH
70557: LD_INT 0
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: PUSH
70567: LD_INT 1
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 2
70576: PUSH
70577: LD_INT 2
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: LD_INT 2
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: LD_INT 2
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: LD_INT 1
70606: NEG
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: EMPTY
70623: LIST
70624: LIST
70625: PUSH
70626: LD_INT 2
70628: NEG
70629: PUSH
70630: LD_INT 1
70632: NEG
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 2
70640: NEG
70641: PUSH
70642: LD_INT 2
70644: NEG
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 2
70652: PUSH
70653: LD_INT 3
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: LD_INT 3
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 2
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 2
70683: NEG
70684: PUSH
70685: LD_INT 1
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70717: LD_ADDR_VAR 0 27
70721: PUSH
70722: LD_INT 0
70724: PUSH
70725: LD_INT 0
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 0
70734: PUSH
70735: LD_INT 1
70737: NEG
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: LD_INT 1
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: LD_INT 1
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 1
70775: NEG
70776: PUSH
70777: LD_INT 0
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: LD_INT 1
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: NEG
70799: PUSH
70800: LD_INT 2
70802: NEG
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 0
70810: PUSH
70811: LD_INT 2
70813: NEG
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: LD_INT 1
70824: NEG
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 2
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: LD_INT 2
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 1
70862: PUSH
70863: LD_INT 2
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 0
70872: PUSH
70873: LD_INT 2
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 1
70882: NEG
70883: PUSH
70884: LD_INT 1
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 2
70893: NEG
70894: PUSH
70895: LD_INT 0
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 2
70904: NEG
70905: PUSH
70906: LD_INT 1
70908: NEG
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: LD_INT 2
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 1
70928: NEG
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 2
70939: NEG
70940: PUSH
70941: LD_INT 1
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 3
70950: NEG
70951: PUSH
70952: LD_INT 1
70954: NEG
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 3
70962: NEG
70963: PUSH
70964: LD_INT 2
70966: NEG
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70997: LD_ADDR_VAR 0 28
71001: PUSH
71002: LD_INT 0
71004: PUSH
71005: LD_INT 0
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: LD_INT 1
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 1
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 1
71035: PUSH
71036: LD_INT 1
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 1
71055: NEG
71056: PUSH
71057: LD_INT 0
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: LD_INT 1
71070: NEG
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: LD_INT 1
71078: NEG
71079: PUSH
71080: LD_INT 2
71082: NEG
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: LD_INT 2
71093: NEG
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 1
71101: PUSH
71102: LD_INT 1
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 2
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 2
71122: PUSH
71123: LD_INT 1
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 2
71132: PUSH
71133: LD_INT 2
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: LD_INT 2
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 0
71152: PUSH
71153: LD_INT 2
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 1
71162: NEG
71163: PUSH
71164: LD_INT 1
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 2
71173: NEG
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: NEG
71185: PUSH
71186: LD_INT 1
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 2
71196: NEG
71197: PUSH
71198: LD_INT 2
71200: NEG
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 2
71208: NEG
71209: PUSH
71210: LD_INT 3
71212: NEG
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 1
71220: NEG
71221: PUSH
71222: LD_INT 3
71224: NEG
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 3
71232: NEG
71233: PUSH
71234: LD_INT 1
71236: NEG
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 3
71244: NEG
71245: PUSH
71246: LD_INT 2
71248: NEG
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71279: LD_ADDR_VAR 0 29
71283: PUSH
71284: LD_INT 0
71286: PUSH
71287: LD_INT 0
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 0
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 1
71307: PUSH
71308: LD_INT 0
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: PUSH
71318: LD_INT 1
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 0
71327: PUSH
71328: LD_INT 1
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 1
71337: NEG
71338: PUSH
71339: LD_INT 0
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 1
71348: NEG
71349: PUSH
71350: LD_INT 1
71352: NEG
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 1
71360: NEG
71361: PUSH
71362: LD_INT 2
71364: NEG
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 0
71372: PUSH
71373: LD_INT 2
71375: NEG
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 1
71383: PUSH
71384: LD_INT 1
71386: NEG
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 2
71394: PUSH
71395: LD_INT 0
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 2
71404: PUSH
71405: LD_INT 1
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: LD_INT 2
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: LD_INT 2
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 1
71434: NEG
71435: PUSH
71436: LD_INT 1
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 2
71445: NEG
71446: PUSH
71447: LD_INT 1
71449: NEG
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 2
71457: NEG
71458: PUSH
71459: LD_INT 2
71461: NEG
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 2
71469: NEG
71470: PUSH
71471: LD_INT 3
71473: NEG
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 2
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 3
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: LD_INT 3
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: LD_INT 2
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 3
71523: NEG
71524: PUSH
71525: LD_INT 2
71527: NEG
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71558: LD_ADDR_VAR 0 30
71562: PUSH
71563: LD_INT 0
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 0
71575: PUSH
71576: LD_INT 1
71578: NEG
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 1
71586: PUSH
71587: LD_INT 0
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: LD_INT 1
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 0
71606: PUSH
71607: LD_INT 1
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 1
71616: NEG
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 1
71627: NEG
71628: PUSH
71629: LD_INT 1
71631: NEG
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 1
71639: NEG
71640: PUSH
71641: LD_INT 2
71643: NEG
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 2
71654: NEG
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: PUSH
71663: LD_INT 1
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 2
71683: PUSH
71684: LD_INT 1
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 2
71693: PUSH
71694: LD_INT 2
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 1
71703: PUSH
71704: LD_INT 2
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 1
71713: NEG
71714: PUSH
71715: LD_INT 1
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 2
71724: NEG
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 2
71735: NEG
71736: PUSH
71737: LD_INT 1
71739: NEG
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: LD_INT 3
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 1
71759: PUSH
71760: LD_INT 2
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 3
71770: PUSH
71771: LD_INT 2
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 2
71780: PUSH
71781: LD_INT 3
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 2
71790: NEG
71791: PUSH
71792: LD_INT 1
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: LD_INT 3
71801: NEG
71802: PUSH
71803: LD_INT 1
71805: NEG
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71836: LD_ADDR_VAR 0 31
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 0
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: LD_INT 0
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 1
71874: PUSH
71875: LD_INT 1
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 0
71884: PUSH
71885: LD_INT 1
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: NEG
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: LD_INT 1
71909: NEG
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: LD_INT 2
71921: NEG
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 2
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 2
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 2
71960: PUSH
71961: LD_INT 2
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 1
71970: PUSH
71971: LD_INT 2
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: LD_INT 0
71980: PUSH
71981: LD_INT 2
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: NEG
71991: PUSH
71992: LD_INT 1
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 2
72001: NEG
72002: PUSH
72003: LD_INT 1
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 2
72013: NEG
72014: PUSH
72015: LD_INT 2
72017: NEG
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: NEG
72026: PUSH
72027: LD_INT 3
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 2
72037: PUSH
72038: LD_INT 1
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 3
72048: PUSH
72049: LD_INT 1
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 1
72058: PUSH
72059: LD_INT 3
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: LD_INT 2
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 3
72079: NEG
72080: PUSH
72081: LD_INT 2
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72114: LD_ADDR_VAR 0 32
72118: PUSH
72119: LD_INT 0
72121: PUSH
72122: LD_INT 0
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 0
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: PUSH
72143: LD_INT 0
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 1
72152: PUSH
72153: LD_INT 1
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 0
72162: PUSH
72163: LD_INT 1
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: LD_INT 1
72172: NEG
72173: PUSH
72174: LD_INT 0
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 1
72183: NEG
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 1
72195: NEG
72196: PUSH
72197: LD_INT 2
72199: NEG
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: LD_INT 2
72210: NEG
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 1
72221: NEG
72222: PUSH
72223: EMPTY
72224: LIST
72225: LIST
72226: PUSH
72227: LD_INT 2
72229: PUSH
72230: LD_INT 1
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: PUSH
72237: LD_INT 2
72239: PUSH
72240: LD_INT 2
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 1
72249: PUSH
72250: LD_INT 2
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: LD_INT 2
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: LD_INT 2
72280: NEG
72281: PUSH
72282: LD_INT 0
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: LD_INT 2
72291: NEG
72292: PUSH
72293: LD_INT 1
72295: NEG
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 1
72303: NEG
72304: PUSH
72305: LD_INT 3
72307: NEG
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: LD_INT 2
72318: NEG
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 3
72326: PUSH
72327: LD_INT 2
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 2
72336: PUSH
72337: LD_INT 3
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 2
72346: NEG
72347: PUSH
72348: LD_INT 1
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 3
72357: NEG
72358: PUSH
72359: LD_INT 1
72361: NEG
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72392: LD_ADDR_VAR 0 33
72396: PUSH
72397: LD_INT 0
72399: PUSH
72400: LD_INT 0
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 0
72409: PUSH
72410: LD_INT 1
72412: NEG
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: LD_INT 0
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: LD_INT 1
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: LD_INT 0
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: NEG
72462: PUSH
72463: LD_INT 1
72465: NEG
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: LD_INT 2
72477: NEG
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: PUSH
72486: LD_INT 1
72488: NEG
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: LD_INT 2
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 2
72506: PUSH
72507: LD_INT 1
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 0
72526: PUSH
72527: LD_INT 2
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 2
72547: NEG
72548: PUSH
72549: LD_INT 0
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 2
72558: NEG
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 2
72570: NEG
72571: PUSH
72572: LD_INT 2
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: NEG
72583: PUSH
72584: LD_INT 3
72586: NEG
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: PUSH
72595: LD_INT 1
72597: NEG
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 3
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 1
72615: PUSH
72616: LD_INT 3
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: NEG
72626: PUSH
72627: LD_INT 2
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 3
72636: NEG
72637: PUSH
72638: LD_INT 2
72640: NEG
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72671: LD_ADDR_VAR 0 34
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: LD_INT 0
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: LD_INT 1
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 1
72709: PUSH
72710: LD_INT 1
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: NEG
72741: PUSH
72742: LD_INT 1
72744: NEG
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: LD_INT 2
72756: NEG
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 0
72764: PUSH
72765: LD_INT 2
72767: NEG
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: LD_INT 1
72778: NEG
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 2
72786: PUSH
72787: LD_INT 1
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: LD_INT 2
72796: PUSH
72797: LD_INT 2
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 1
72816: NEG
72817: PUSH
72818: LD_INT 1
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 2
72827: NEG
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 2
72838: NEG
72839: PUSH
72840: LD_INT 1
72842: NEG
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 2
72850: NEG
72851: PUSH
72852: LD_INT 2
72854: NEG
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: NEG
72863: PUSH
72864: LD_INT 3
72866: NEG
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 1
72874: PUSH
72875: LD_INT 2
72877: NEG
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: LD_INT 3
72885: PUSH
72886: LD_INT 2
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: LD_INT 3
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 2
72905: NEG
72906: PUSH
72907: LD_INT 1
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 3
72916: NEG
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: LIST
72950: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72951: LD_ADDR_VAR 0 35
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: LD_INT 0
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 0
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 1
72979: PUSH
72980: LD_INT 0
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 1
72989: PUSH
72990: LD_INT 1
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 0
72999: PUSH
73000: LD_INT 1
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 1
73020: NEG
73021: PUSH
73022: LD_INT 1
73024: NEG
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 2
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 2
73042: NEG
73043: PUSH
73044: LD_INT 1
73046: NEG
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73063: LD_ADDR_VAR 0 36
73067: PUSH
73068: LD_INT 0
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 1
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 1
73091: PUSH
73092: LD_INT 0
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 1
73101: PUSH
73102: LD_INT 1
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 0
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 1
73121: NEG
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 1
73132: NEG
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 2
73148: NEG
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: LD_INT 2
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73175: LD_ADDR_VAR 0 37
73179: PUSH
73180: LD_INT 0
73182: PUSH
73183: LD_INT 0
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 0
73192: PUSH
73193: LD_INT 1
73195: NEG
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 1
73203: PUSH
73204: LD_INT 0
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 1
73213: PUSH
73214: LD_INT 1
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 0
73223: PUSH
73224: LD_INT 1
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: LD_INT 1
73233: NEG
73234: PUSH
73235: LD_INT 0
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: LD_INT 1
73248: NEG
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 1
73256: PUSH
73257: LD_INT 1
73259: NEG
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 1
73267: NEG
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73287: LD_ADDR_VAR 0 38
73291: PUSH
73292: LD_INT 0
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: PUSH
73326: LD_INT 1
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 1
73345: NEG
73346: PUSH
73347: LD_INT 0
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 1
73356: NEG
73357: PUSH
73358: LD_INT 1
73360: NEG
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 2
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 2
73378: NEG
73379: PUSH
73380: LD_INT 1
73382: NEG
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: LIST
73398: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73399: LD_ADDR_VAR 0 39
73403: PUSH
73404: LD_INT 0
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 0
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: LD_INT 0
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PUSH
73435: LD_INT 1
73437: PUSH
73438: LD_INT 1
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: LD_INT 1
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 1
73457: NEG
73458: PUSH
73459: LD_INT 0
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 1
73468: NEG
73469: PUSH
73470: LD_INT 1
73472: NEG
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 1
73480: NEG
73481: PUSH
73482: LD_INT 2
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 1
73492: PUSH
73493: LD_INT 2
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73511: LD_ADDR_VAR 0 40
73515: PUSH
73516: LD_INT 0
73518: PUSH
73519: LD_INT 0
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 0
73528: PUSH
73529: LD_INT 1
73531: NEG
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 1
73539: PUSH
73540: LD_INT 0
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 1
73549: PUSH
73550: LD_INT 1
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 0
73559: PUSH
73560: LD_INT 1
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 1
73569: NEG
73570: PUSH
73571: LD_INT 0
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 1
73580: NEG
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: NEG
73604: PUSH
73605: LD_INT 1
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73623: LD_ADDR_VAR 0 41
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 0
73640: PUSH
73641: LD_INT 1
73643: NEG
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: PUSH
73652: LD_INT 0
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: LD_INT 1
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 1
73681: NEG
73682: PUSH
73683: LD_INT 0
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 1
73692: NEG
73693: PUSH
73694: LD_INT 1
73696: NEG
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 1
73704: NEG
73705: PUSH
73706: LD_INT 2
73708: NEG
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 1
73716: PUSH
73717: LD_INT 1
73719: NEG
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 2
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: PUSH
73738: LD_INT 1
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 2
73747: PUSH
73748: LD_INT 2
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 1
73757: PUSH
73758: LD_INT 2
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 1
73767: NEG
73768: PUSH
73769: LD_INT 1
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 2
73778: NEG
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 2
73789: NEG
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 2
73801: NEG
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 2
73813: NEG
73814: PUSH
73815: LD_INT 3
73817: NEG
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 2
73825: PUSH
73826: LD_INT 1
73828: NEG
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 3
73836: PUSH
73837: LD_INT 0
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 3
73846: PUSH
73847: LD_INT 1
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 3
73856: PUSH
73857: LD_INT 2
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: LD_INT 3
73866: PUSH
73867: LD_INT 3
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 2
73876: PUSH
73877: LD_INT 3
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 2
73886: NEG
73887: PUSH
73888: LD_INT 1
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: LD_INT 3
73897: NEG
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 3
73908: NEG
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 3
73920: NEG
73921: PUSH
73922: LD_INT 2
73924: NEG
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 3
73932: NEG
73933: PUSH
73934: LD_INT 3
73936: NEG
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73973: LD_ADDR_VAR 0 42
73977: PUSH
73978: LD_INT 0
73980: PUSH
73981: LD_INT 0
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: LD_INT 1
73993: NEG
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: PUSH
74012: LD_INT 1
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 0
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 1
74031: NEG
74032: PUSH
74033: LD_INT 0
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 1
74042: NEG
74043: PUSH
74044: LD_INT 1
74046: NEG
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 1
74054: NEG
74055: PUSH
74056: LD_INT 2
74058: NEG
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: LD_INT 2
74069: NEG
74070: PUSH
74071: EMPTY
74072: LIST
74073: LIST
74074: PUSH
74075: LD_INT 1
74077: PUSH
74078: LD_INT 1
74080: NEG
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 2
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: PUSH
74099: LD_INT 2
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: LD_INT 2
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: LD_INT 2
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 2
74139: NEG
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 2
74151: NEG
74152: PUSH
74153: LD_INT 2
74155: NEG
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 2
74163: NEG
74164: PUSH
74165: LD_INT 3
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 1
74175: NEG
74176: PUSH
74177: LD_INT 3
74179: NEG
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 0
74187: PUSH
74188: LD_INT 3
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 1
74198: PUSH
74199: LD_INT 2
74201: NEG
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 3
74209: PUSH
74210: LD_INT 2
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 3
74219: PUSH
74220: LD_INT 3
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 2
74229: PUSH
74230: LD_INT 3
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 1
74239: PUSH
74240: LD_INT 3
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: LD_INT 3
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 1
74259: NEG
74260: PUSH
74261: LD_INT 2
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 3
74270: NEG
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 3
74282: NEG
74283: PUSH
74284: LD_INT 3
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74323: LD_ADDR_VAR 0 43
74327: PUSH
74328: LD_INT 0
74330: PUSH
74331: LD_INT 0
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 0
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: PUSH
74352: LD_INT 0
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 1
74361: PUSH
74362: LD_INT 1
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: LD_INT 1
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 1
74381: NEG
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: NEG
74393: PUSH
74394: LD_INT 1
74396: NEG
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: LD_INT 2
74408: NEG
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: LD_INT 2
74419: NEG
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 1
74427: PUSH
74428: LD_INT 1
74430: NEG
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 2
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 2
74448: PUSH
74449: LD_INT 1
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 1
74458: PUSH
74459: LD_INT 2
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: LD_INT 2
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 1
74478: NEG
74479: PUSH
74480: LD_INT 1
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 2
74489: NEG
74490: PUSH
74491: LD_INT 0
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: LD_INT 2
74500: NEG
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: NEG
74513: PUSH
74514: LD_INT 3
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 0
74524: PUSH
74525: LD_INT 3
74527: NEG
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 1
74535: PUSH
74536: LD_INT 2
74538: NEG
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 2
74546: PUSH
74547: LD_INT 1
74549: NEG
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: PUSH
74555: LD_INT 3
74557: PUSH
74558: LD_INT 0
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 3
74567: PUSH
74568: LD_INT 1
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 1
74577: PUSH
74578: LD_INT 3
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: LD_INT 3
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: NEG
74598: PUSH
74599: LD_INT 2
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 2
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 3
74619: NEG
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 3
74630: NEG
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: LIST
74644: LIST
74645: LIST
74646: LIST
74647: LIST
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74671: LD_ADDR_VAR 0 44
74675: PUSH
74676: LD_INT 0
74678: PUSH
74679: LD_INT 0
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: LD_INT 1
74691: NEG
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 1
74699: PUSH
74700: LD_INT 0
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 1
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 0
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 1
74740: NEG
74741: PUSH
74742: LD_INT 1
74744: NEG
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: LD_INT 1
74752: NEG
74753: PUSH
74754: LD_INT 2
74756: NEG
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: LD_INT 1
74767: NEG
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 2
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 2
74785: PUSH
74786: LD_INT 1
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 2
74795: PUSH
74796: LD_INT 2
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 1
74805: PUSH
74806: LD_INT 2
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 1
74815: NEG
74816: PUSH
74817: LD_INT 1
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: LD_INT 2
74826: NEG
74827: PUSH
74828: LD_INT 0
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 2
74837: NEG
74838: PUSH
74839: LD_INT 1
74841: NEG
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 2
74849: NEG
74850: PUSH
74851: LD_INT 2
74853: NEG
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 2
74861: NEG
74862: PUSH
74863: LD_INT 3
74865: NEG
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 2
74873: PUSH
74874: LD_INT 1
74876: NEG
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 3
74884: PUSH
74885: LD_INT 0
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 3
74894: PUSH
74895: LD_INT 1
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 3
74904: PUSH
74905: LD_INT 2
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PUSH
74912: LD_INT 3
74914: PUSH
74915: LD_INT 3
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 2
74924: PUSH
74925: LD_INT 3
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 2
74934: NEG
74935: PUSH
74936: LD_INT 1
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 3
74945: NEG
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 3
74956: NEG
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 3
74968: NEG
74969: PUSH
74970: LD_INT 2
74972: NEG
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 3
74980: NEG
74981: PUSH
74982: LD_INT 3
74984: NEG
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: LIST
74994: LIST
74995: LIST
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75021: LD_ADDR_VAR 0 45
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 0
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: LD_INT 1
75041: NEG
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: LD_INT 0
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: PUSH
75060: LD_INT 1
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 0
75069: PUSH
75070: LD_INT 1
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 1
75079: NEG
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 1
75090: NEG
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 1
75102: NEG
75103: PUSH
75104: LD_INT 2
75106: NEG
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 0
75114: PUSH
75115: LD_INT 2
75117: NEG
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: LD_INT 1
75125: PUSH
75126: LD_INT 1
75128: NEG
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 2
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 2
75146: PUSH
75147: LD_INT 2
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: LD_INT 1
75156: PUSH
75157: LD_INT 2
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: LD_INT 2
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: LD_INT 1
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 2
75187: NEG
75188: PUSH
75189: LD_INT 1
75191: NEG
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 2
75199: NEG
75200: PUSH
75201: LD_INT 2
75203: NEG
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 2
75211: NEG
75212: PUSH
75213: LD_INT 3
75215: NEG
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 1
75223: NEG
75224: PUSH
75225: LD_INT 3
75227: NEG
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: LD_INT 3
75238: NEG
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 1
75246: PUSH
75247: LD_INT 2
75249: NEG
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 3
75257: PUSH
75258: LD_INT 2
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 3
75267: PUSH
75268: LD_INT 3
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 2
75277: PUSH
75278: LD_INT 3
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: LD_INT 3
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 0
75297: PUSH
75298: LD_INT 3
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: NEG
75308: PUSH
75309: LD_INT 2
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 3
75318: NEG
75319: PUSH
75320: LD_INT 2
75322: NEG
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 3
75330: NEG
75331: PUSH
75332: LD_INT 3
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75371: LD_ADDR_VAR 0 46
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: LD_INT 0
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 1
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 1
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 1
75429: NEG
75430: PUSH
75431: LD_INT 0
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 1
75440: NEG
75441: PUSH
75442: LD_INT 1
75444: NEG
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: LD_INT 2
75456: NEG
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 0
75464: PUSH
75465: LD_INT 2
75467: NEG
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 1
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 0
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 2
75496: PUSH
75497: LD_INT 1
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 2
75537: NEG
75538: PUSH
75539: LD_INT 0
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 2
75548: NEG
75549: PUSH
75550: LD_INT 1
75552: NEG
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 1
75560: NEG
75561: PUSH
75562: LD_INT 3
75564: NEG
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 0
75572: PUSH
75573: LD_INT 3
75575: NEG
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 1
75583: PUSH
75584: LD_INT 2
75586: NEG
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: PUSH
75595: LD_INT 1
75597: NEG
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 3
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 3
75615: PUSH
75616: LD_INT 1
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 1
75625: PUSH
75626: LD_INT 3
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 0
75635: PUSH
75636: LD_INT 3
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 1
75645: NEG
75646: PUSH
75647: LD_INT 2
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: LD_INT 2
75656: NEG
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 3
75667: NEG
75668: PUSH
75669: LD_INT 0
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 3
75678: NEG
75679: PUSH
75680: LD_INT 1
75682: NEG
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75719: LD_ADDR_VAR 0 47
75723: PUSH
75724: LD_INT 0
75726: PUSH
75727: LD_INT 0
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 0
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: LD_INT 0
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 1
75757: PUSH
75758: LD_INT 1
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: LD_INT 1
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: LD_INT 0
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: LD_INT 2
75804: NEG
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: LD_INT 2
75815: NEG
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 1
75823: PUSH
75824: LD_INT 1
75826: NEG
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 2
75834: NEG
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 2
75846: NEG
75847: PUSH
75848: LD_INT 2
75850: NEG
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: LIST
75860: LIST
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75870: LD_ADDR_VAR 0 48
75874: PUSH
75875: LD_INT 0
75877: PUSH
75878: LD_INT 0
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: LD_INT 1
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 1
75908: PUSH
75909: LD_INT 1
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 0
75918: PUSH
75919: LD_INT 1
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 1
75939: NEG
75940: PUSH
75941: LD_INT 1
75943: NEG
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 1
75951: NEG
75952: PUSH
75953: LD_INT 2
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 0
75963: PUSH
75964: LD_INT 2
75966: NEG
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: LD_INT 1
75977: NEG
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: LD_INT 0
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: LD_INT 1
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76017: LD_ADDR_VAR 0 49
76021: PUSH
76022: LD_INT 0
76024: PUSH
76025: LD_INT 0
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 0
76034: PUSH
76035: LD_INT 1
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 1
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: PUSH
76056: LD_INT 1
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 0
76065: PUSH
76066: LD_INT 1
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 1
76075: NEG
76076: PUSH
76077: LD_INT 0
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 1
76086: NEG
76087: PUSH
76088: LD_INT 1
76090: NEG
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: LD_INT 1
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 2
76109: PUSH
76110: LD_INT 0
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 2
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 2
76129: PUSH
76130: LD_INT 2
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 1
76139: PUSH
76140: LD_INT 2
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76161: LD_ADDR_VAR 0 50
76165: PUSH
76166: LD_INT 0
76168: PUSH
76169: LD_INT 0
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 0
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: LD_INT 1
76189: PUSH
76190: LD_INT 0
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 1
76199: PUSH
76200: LD_INT 1
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 0
76209: PUSH
76210: LD_INT 1
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 1
76219: NEG
76220: PUSH
76221: LD_INT 0
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: LD_INT 1
76230: NEG
76231: PUSH
76232: LD_INT 1
76234: NEG
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 2
76242: PUSH
76243: LD_INT 1
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 2
76252: PUSH
76253: LD_INT 2
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 1
76262: PUSH
76263: LD_INT 2
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 0
76272: PUSH
76273: LD_INT 2
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PUSH
76280: LD_INT 1
76282: NEG
76283: PUSH
76284: LD_INT 1
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76305: LD_ADDR_VAR 0 51
76309: PUSH
76310: LD_INT 0
76312: PUSH
76313: LD_INT 0
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: LD_INT 1
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 1
76333: PUSH
76334: LD_INT 0
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: LD_INT 1
76343: PUSH
76344: LD_INT 1
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 0
76353: PUSH
76354: LD_INT 1
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 1
76363: NEG
76364: PUSH
76365: LD_INT 0
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: LD_INT 1
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 1
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 0
76396: PUSH
76397: LD_INT 2
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 1
76406: NEG
76407: PUSH
76408: LD_INT 1
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 2
76417: NEG
76418: PUSH
76419: LD_INT 0
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 1
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76452: LD_ADDR_VAR 0 52
76456: PUSH
76457: LD_INT 0
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 0
76469: PUSH
76470: LD_INT 1
76472: NEG
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 1
76480: PUSH
76481: LD_INT 0
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: LD_INT 1
76490: PUSH
76491: LD_INT 1
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 0
76500: PUSH
76501: LD_INT 1
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 1
76510: NEG
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 1
76521: NEG
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 1
76533: NEG
76534: PUSH
76535: LD_INT 2
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: LD_INT 1
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 2
76556: NEG
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 2
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 2
76579: NEG
76580: PUSH
76581: LD_INT 2
76583: NEG
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76603: LD_ADDR_VAR 0 53
76607: PUSH
76608: LD_INT 0
76610: PUSH
76611: LD_INT 0
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 0
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 1
76631: PUSH
76632: LD_INT 0
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: LD_INT 1
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: PUSH
76649: LD_INT 0
76651: PUSH
76652: LD_INT 1
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: LD_INT 0
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 1
76672: NEG
76673: PUSH
76674: LD_INT 1
76676: NEG
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: LD_INT 1
76684: NEG
76685: PUSH
76686: LD_INT 2
76688: NEG
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 0
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 1
76707: PUSH
76708: LD_INT 1
76710: NEG
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 2
76718: PUSH
76719: LD_INT 0
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 2
76728: PUSH
76729: LD_INT 1
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 2
76738: PUSH
76739: LD_INT 2
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: LD_INT 1
76748: PUSH
76749: LD_INT 2
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 0
76758: PUSH
76759: LD_INT 2
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: PUSH
76766: LD_INT 1
76768: NEG
76769: PUSH
76770: LD_INT 1
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: LD_INT 2
76779: NEG
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 2
76790: NEG
76791: PUSH
76792: LD_INT 1
76794: NEG
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 2
76802: NEG
76803: PUSH
76804: LD_INT 2
76806: NEG
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: LIST
76822: LIST
76823: LIST
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76833: LD_ADDR_VAR 0 54
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: LD_INT 0
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 0
76850: PUSH
76851: LD_INT 1
76853: NEG
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 1
76861: PUSH
76862: LD_INT 0
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: LD_INT 1
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: LD_INT 0
76881: PUSH
76882: LD_INT 1
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: PUSH
76889: LD_INT 1
76891: NEG
76892: PUSH
76893: LD_INT 0
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 1
76902: NEG
76903: PUSH
76904: LD_INT 1
76906: NEG
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: LD_INT 1
76914: NEG
76915: PUSH
76916: LD_INT 2
76918: NEG
76919: PUSH
76920: EMPTY
76921: LIST
76922: LIST
76923: PUSH
76924: LD_INT 0
76926: PUSH
76927: LD_INT 2
76929: NEG
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: LD_INT 1
76940: NEG
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 2
76948: PUSH
76949: LD_INT 0
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: PUSH
76956: LD_INT 2
76958: PUSH
76959: LD_INT 1
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 2
76968: PUSH
76969: LD_INT 2
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 1
76978: PUSH
76979: LD_INT 2
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: LD_INT 2
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: LD_INT 1
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 2
77009: NEG
77010: PUSH
77011: LD_INT 0
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 2
77020: NEG
77021: PUSH
77022: LD_INT 1
77024: NEG
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: LD_INT 2
77036: NEG
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77063: LD_ADDR_VAR 0 55
77067: PUSH
77068: LD_INT 0
77070: PUSH
77071: LD_INT 0
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: LD_INT 1
77083: NEG
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 1
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 0
77111: PUSH
77112: LD_INT 1
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: LD_INT 1
77121: NEG
77122: PUSH
77123: LD_INT 0
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 1
77132: NEG
77133: PUSH
77134: LD_INT 1
77136: NEG
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 1
77144: NEG
77145: PUSH
77146: LD_INT 2
77148: NEG
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: LD_INT 2
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: LD_INT 1
77170: NEG
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 2
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 2
77188: PUSH
77189: LD_INT 1
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 2
77198: PUSH
77199: LD_INT 2
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: LD_INT 2
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 0
77218: PUSH
77219: LD_INT 2
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 1
77228: NEG
77229: PUSH
77230: LD_INT 1
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 2
77239: NEG
77240: PUSH
77241: LD_INT 0
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 2
77250: NEG
77251: PUSH
77252: LD_INT 1
77254: NEG
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PUSH
77260: LD_INT 2
77262: NEG
77263: PUSH
77264: LD_INT 2
77266: NEG
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77293: LD_ADDR_VAR 0 56
77297: PUSH
77298: LD_INT 0
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: LD_INT 1
77313: NEG
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 1
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: LD_INT 1
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 0
77341: PUSH
77342: LD_INT 1
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: LD_INT 0
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 1
77362: NEG
77363: PUSH
77364: LD_INT 1
77366: NEG
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 1
77374: NEG
77375: PUSH
77376: LD_INT 2
77378: NEG
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 0
77386: PUSH
77387: LD_INT 2
77389: NEG
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 1
77397: PUSH
77398: LD_INT 1
77400: NEG
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 2
77408: PUSH
77409: LD_INT 0
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 2
77418: PUSH
77419: LD_INT 1
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 2
77428: PUSH
77429: LD_INT 2
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 1
77438: PUSH
77439: LD_INT 2
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 0
77448: PUSH
77449: LD_INT 2
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 1
77458: NEG
77459: PUSH
77460: LD_INT 1
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 2
77469: NEG
77470: PUSH
77471: LD_INT 0
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: LD_INT 2
77480: NEG
77481: PUSH
77482: LD_INT 1
77484: NEG
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 2
77492: NEG
77493: PUSH
77494: LD_INT 2
77496: NEG
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: LIST
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77523: LD_ADDR_VAR 0 57
77527: PUSH
77528: LD_INT 0
77530: PUSH
77531: LD_INT 0
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 0
77540: PUSH
77541: LD_INT 1
77543: NEG
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 1
77551: PUSH
77552: LD_INT 0
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 1
77561: PUSH
77562: LD_INT 1
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: LD_INT 1
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 1
77581: NEG
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 1
77592: NEG
77593: PUSH
77594: LD_INT 1
77596: NEG
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: LD_INT 2
77608: NEG
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 0
77616: PUSH
77617: LD_INT 2
77619: NEG
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 1
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 2
77658: PUSH
77659: LD_INT 2
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 1
77668: PUSH
77669: LD_INT 2
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 0
77678: PUSH
77679: LD_INT 2
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: NEG
77689: PUSH
77690: LD_INT 1
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 2
77710: NEG
77711: PUSH
77712: LD_INT 1
77714: NEG
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 2
77722: NEG
77723: PUSH
77724: LD_INT 2
77726: NEG
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77753: LD_ADDR_VAR 0 58
77757: PUSH
77758: LD_INT 0
77760: PUSH
77761: LD_INT 0
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: LD_INT 0
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 1
77791: PUSH
77792: LD_INT 1
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 0
77801: PUSH
77802: LD_INT 1
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 1
77811: NEG
77812: PUSH
77813: LD_INT 0
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: LD_INT 1
77822: NEG
77823: PUSH
77824: LD_INT 1
77826: NEG
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 1
77834: NEG
77835: PUSH
77836: LD_INT 2
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 0
77846: PUSH
77847: LD_INT 2
77849: NEG
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 1
77857: PUSH
77858: LD_INT 1
77860: NEG
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 2
77868: PUSH
77869: LD_INT 0
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: LD_INT 1
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 2
77888: PUSH
77889: LD_INT 2
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 1
77898: PUSH
77899: LD_INT 2
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 2
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 2
77929: NEG
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 2
77940: NEG
77941: PUSH
77942: LD_INT 1
77944: NEG
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 2
77952: NEG
77953: PUSH
77954: LD_INT 2
77956: NEG
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77983: LD_ADDR_VAR 0 59
77987: PUSH
77988: LD_INT 0
77990: PUSH
77991: LD_INT 0
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 0
78000: PUSH
78001: LD_INT 1
78003: NEG
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 1
78011: PUSH
78012: LD_INT 0
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: LD_INT 1
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 0
78031: PUSH
78032: LD_INT 1
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 1
78041: NEG
78042: PUSH
78043: LD_INT 0
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 1
78052: NEG
78053: PUSH
78054: LD_INT 1
78056: NEG
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78071: LD_ADDR_VAR 0 60
78075: PUSH
78076: LD_INT 0
78078: PUSH
78079: LD_INT 0
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 1
78091: NEG
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 1
78099: PUSH
78100: LD_INT 0
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 1
78109: PUSH
78110: LD_INT 1
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: LD_INT 0
78119: PUSH
78120: LD_INT 1
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 1
78129: NEG
78130: PUSH
78131: LD_INT 0
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: NEG
78141: PUSH
78142: LD_INT 1
78144: NEG
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78159: LD_ADDR_VAR 0 61
78163: PUSH
78164: LD_INT 0
78166: PUSH
78167: LD_INT 0
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 0
78176: PUSH
78177: LD_INT 1
78179: NEG
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 1
78187: PUSH
78188: LD_INT 0
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 1
78197: PUSH
78198: LD_INT 1
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: LD_INT 1
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 1
78217: NEG
78218: PUSH
78219: LD_INT 0
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 1
78228: NEG
78229: PUSH
78230: LD_INT 1
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78247: LD_ADDR_VAR 0 62
78251: PUSH
78252: LD_INT 0
78254: PUSH
78255: LD_INT 0
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 0
78264: PUSH
78265: LD_INT 1
78267: NEG
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 1
78285: PUSH
78286: LD_INT 1
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 0
78295: PUSH
78296: LD_INT 1
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 1
78305: NEG
78306: PUSH
78307: LD_INT 0
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 1
78316: NEG
78317: PUSH
78318: LD_INT 1
78320: NEG
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: LIST
78330: LIST
78331: LIST
78332: LIST
78333: LIST
78334: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78335: LD_ADDR_VAR 0 63
78339: PUSH
78340: LD_INT 0
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 0
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 1
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 1
78373: PUSH
78374: LD_INT 1
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 0
78383: PUSH
78384: LD_INT 1
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: LD_INT 0
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 1
78404: NEG
78405: PUSH
78406: LD_INT 1
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78423: LD_ADDR_VAR 0 64
78427: PUSH
78428: LD_INT 0
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 0
78440: PUSH
78441: LD_INT 1
78443: NEG
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 1
78451: PUSH
78452: LD_INT 0
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: LD_INT 1
78464: PUSH
78465: EMPTY
78466: LIST
78467: LIST
78468: PUSH
78469: LD_INT 0
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 1
78481: NEG
78482: PUSH
78483: LD_INT 0
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 1
78492: NEG
78493: PUSH
78494: LD_INT 1
78496: NEG
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: LIST
78510: ST_TO_ADDR
// end ; 1 :
78511: GO 84408
78513: LD_INT 1
78515: DOUBLE
78516: EQUAL
78517: IFTRUE 78521
78519: GO 81144
78521: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78522: LD_ADDR_VAR 0 11
78526: PUSH
78527: LD_INT 1
78529: NEG
78530: PUSH
78531: LD_INT 3
78533: NEG
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 0
78541: PUSH
78542: LD_INT 3
78544: NEG
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 1
78552: PUSH
78553: LD_INT 2
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: LIST
78565: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78566: LD_ADDR_VAR 0 12
78570: PUSH
78571: LD_INT 2
78573: PUSH
78574: LD_INT 1
78576: NEG
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 3
78584: PUSH
78585: LD_INT 0
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 3
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: LIST
78606: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78607: LD_ADDR_VAR 0 13
78611: PUSH
78612: LD_INT 3
78614: PUSH
78615: LD_INT 2
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 3
78624: PUSH
78625: LD_INT 3
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 2
78634: PUSH
78635: LD_INT 3
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: LIST
78646: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78647: LD_ADDR_VAR 0 14
78651: PUSH
78652: LD_INT 1
78654: PUSH
78655: LD_INT 3
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: LD_INT 3
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 1
78674: NEG
78675: PUSH
78676: LD_INT 2
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: LIST
78687: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78688: LD_ADDR_VAR 0 15
78692: PUSH
78693: LD_INT 2
78695: NEG
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 3
78706: NEG
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 3
78717: NEG
78718: PUSH
78719: LD_INT 1
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: LIST
78731: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78732: LD_ADDR_VAR 0 16
78736: PUSH
78737: LD_INT 2
78739: NEG
78740: PUSH
78741: LD_INT 3
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 3
78751: NEG
78752: PUSH
78753: LD_INT 2
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 3
78763: NEG
78764: PUSH
78765: LD_INT 3
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: LIST
78777: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78778: LD_ADDR_VAR 0 17
78782: PUSH
78783: LD_INT 1
78785: NEG
78786: PUSH
78787: LD_INT 3
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: LD_INT 3
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 1
78808: PUSH
78809: LD_INT 2
78811: NEG
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: LIST
78821: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78822: LD_ADDR_VAR 0 18
78826: PUSH
78827: LD_INT 2
78829: PUSH
78830: LD_INT 1
78832: NEG
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 3
78840: PUSH
78841: LD_INT 0
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 3
78850: PUSH
78851: LD_INT 1
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: LIST
78862: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78863: LD_ADDR_VAR 0 19
78867: PUSH
78868: LD_INT 3
78870: PUSH
78871: LD_INT 2
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 3
78880: PUSH
78881: LD_INT 3
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 2
78890: PUSH
78891: LD_INT 3
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: LIST
78902: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78903: LD_ADDR_VAR 0 20
78907: PUSH
78908: LD_INT 1
78910: PUSH
78911: LD_INT 3
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 0
78920: PUSH
78921: LD_INT 3
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 1
78930: NEG
78931: PUSH
78932: LD_INT 2
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: LIST
78943: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78944: LD_ADDR_VAR 0 21
78948: PUSH
78949: LD_INT 2
78951: NEG
78952: PUSH
78953: LD_INT 1
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 3
78962: NEG
78963: PUSH
78964: LD_INT 0
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 3
78973: NEG
78974: PUSH
78975: LD_INT 1
78977: NEG
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: LIST
78987: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78988: LD_ADDR_VAR 0 22
78992: PUSH
78993: LD_INT 2
78995: NEG
78996: PUSH
78997: LD_INT 3
78999: NEG
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 3
79007: NEG
79008: PUSH
79009: LD_INT 2
79011: NEG
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 3
79019: NEG
79020: PUSH
79021: LD_INT 3
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: LIST
79033: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79034: LD_ADDR_VAR 0 23
79038: PUSH
79039: LD_INT 0
79041: PUSH
79042: LD_INT 3
79044: NEG
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 1
79052: NEG
79053: PUSH
79054: LD_INT 4
79056: NEG
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 1
79064: PUSH
79065: LD_INT 3
79067: NEG
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: LIST
79077: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79078: LD_ADDR_VAR 0 24
79082: PUSH
79083: LD_INT 3
79085: PUSH
79086: LD_INT 0
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 3
79095: PUSH
79096: LD_INT 1
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 4
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: LIST
79118: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79119: LD_ADDR_VAR 0 25
79123: PUSH
79124: LD_INT 3
79126: PUSH
79127: LD_INT 3
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 4
79136: PUSH
79137: LD_INT 3
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 3
79146: PUSH
79147: LD_INT 4
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: LIST
79158: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
79159: LD_ADDR_VAR 0 26
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: LD_INT 3
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 1
79176: PUSH
79177: LD_INT 4
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: LD_INT 3
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: LIST
79199: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
79200: LD_ADDR_VAR 0 27
79204: PUSH
79205: LD_INT 3
79207: NEG
79208: PUSH
79209: LD_INT 0
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PUSH
79216: LD_INT 3
79218: NEG
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 4
79229: NEG
79230: PUSH
79231: LD_INT 1
79233: NEG
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: LIST
79243: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
79244: LD_ADDR_VAR 0 28
79248: PUSH
79249: LD_INT 3
79251: NEG
79252: PUSH
79253: LD_INT 3
79255: NEG
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: LD_INT 3
79263: NEG
79264: PUSH
79265: LD_INT 4
79267: NEG
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 4
79275: NEG
79276: PUSH
79277: LD_INT 3
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: LIST
79289: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
79290: LD_ADDR_VAR 0 29
79294: PUSH
79295: LD_INT 1
79297: NEG
79298: PUSH
79299: LD_INT 3
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 0
79309: PUSH
79310: LD_INT 3
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 1
79320: PUSH
79321: LD_INT 2
79323: NEG
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 1
79331: NEG
79332: PUSH
79333: LD_INT 4
79335: NEG
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: LD_INT 0
79343: PUSH
79344: LD_INT 4
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 1
79354: PUSH
79355: LD_INT 3
79357: NEG
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 1
79365: NEG
79366: PUSH
79367: LD_INT 5
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 0
79377: PUSH
79378: LD_INT 5
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 1
79388: PUSH
79389: LD_INT 4
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 1
79399: NEG
79400: PUSH
79401: LD_INT 6
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: LD_INT 6
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 1
79422: PUSH
79423: LD_INT 5
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
79445: LD_ADDR_VAR 0 30
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 3
79463: PUSH
79464: LD_INT 0
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 3
79473: PUSH
79474: LD_INT 1
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 3
79483: PUSH
79484: LD_INT 1
79486: NEG
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 4
79494: PUSH
79495: LD_INT 0
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 4
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 4
79514: PUSH
79515: LD_INT 1
79517: NEG
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 5
79525: PUSH
79526: LD_INT 0
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 5
79535: PUSH
79536: LD_INT 1
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 5
79545: PUSH
79546: LD_INT 1
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 6
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 6
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79588: LD_ADDR_VAR 0 31
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: LD_INT 2
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 3
79605: PUSH
79606: LD_INT 3
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 2
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 4
79625: PUSH
79626: LD_INT 3
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 4
79635: PUSH
79636: LD_INT 4
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 3
79645: PUSH
79646: LD_INT 4
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 5
79655: PUSH
79656: LD_INT 4
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 5
79665: PUSH
79666: LD_INT 5
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 4
79675: PUSH
79676: LD_INT 5
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 6
79685: PUSH
79686: LD_INT 5
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 6
79695: PUSH
79696: LD_INT 6
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 5
79705: PUSH
79706: LD_INT 6
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79727: LD_ADDR_VAR 0 32
79731: PUSH
79732: LD_INT 1
79734: PUSH
79735: LD_INT 3
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 0
79744: PUSH
79745: LD_INT 3
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 1
79754: NEG
79755: PUSH
79756: LD_INT 2
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: PUSH
79766: LD_INT 4
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: LD_INT 0
79775: PUSH
79776: LD_INT 4
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: LD_INT 3
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 1
79796: PUSH
79797: LD_INT 5
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 0
79806: PUSH
79807: LD_INT 5
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 1
79816: NEG
79817: PUSH
79818: LD_INT 4
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 1
79827: PUSH
79828: LD_INT 6
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 0
79837: PUSH
79838: LD_INT 6
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 1
79847: NEG
79848: PUSH
79849: LD_INT 5
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79870: LD_ADDR_VAR 0 33
79874: PUSH
79875: LD_INT 2
79877: NEG
79878: PUSH
79879: LD_INT 1
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 3
79888: NEG
79889: PUSH
79890: LD_INT 0
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 3
79899: NEG
79900: PUSH
79901: LD_INT 1
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 3
79911: NEG
79912: PUSH
79913: LD_INT 1
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 4
79922: NEG
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 4
79933: NEG
79934: PUSH
79935: LD_INT 1
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 4
79945: NEG
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 5
79956: NEG
79957: PUSH
79958: LD_INT 0
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 5
79967: NEG
79968: PUSH
79969: LD_INT 1
79971: NEG
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 5
79979: NEG
79980: PUSH
79981: LD_INT 1
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 6
79990: NEG
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 6
80001: NEG
80002: PUSH
80003: LD_INT 1
80005: NEG
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80025: LD_ADDR_VAR 0 34
80029: PUSH
80030: LD_INT 2
80032: NEG
80033: PUSH
80034: LD_INT 3
80036: NEG
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 3
80044: NEG
80045: PUSH
80046: LD_INT 2
80048: NEG
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 3
80056: NEG
80057: PUSH
80058: LD_INT 3
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 3
80068: NEG
80069: PUSH
80070: LD_INT 4
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 4
80080: NEG
80081: PUSH
80082: LD_INT 3
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 4
80092: NEG
80093: PUSH
80094: LD_INT 4
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 4
80104: NEG
80105: PUSH
80106: LD_INT 5
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 5
80116: NEG
80117: PUSH
80118: LD_INT 4
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 5
80128: NEG
80129: PUSH
80130: LD_INT 5
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 5
80140: NEG
80141: PUSH
80142: LD_INT 6
80144: NEG
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 6
80152: NEG
80153: PUSH
80154: LD_INT 5
80156: NEG
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 6
80164: NEG
80165: PUSH
80166: LD_INT 6
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
80188: LD_ADDR_VAR 0 41
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: LD_INT 2
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: LD_INT 3
80210: NEG
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 1
80218: PUSH
80219: LD_INT 2
80221: NEG
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: LIST
80231: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
80232: LD_ADDR_VAR 0 42
80236: PUSH
80237: LD_INT 2
80239: PUSH
80240: LD_INT 0
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 2
80249: PUSH
80250: LD_INT 1
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 3
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: LIST
80272: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
80273: LD_ADDR_VAR 0 43
80277: PUSH
80278: LD_INT 2
80280: PUSH
80281: LD_INT 2
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 3
80290: PUSH
80291: LD_INT 2
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 2
80300: PUSH
80301: LD_INT 3
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: LIST
80312: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
80313: LD_ADDR_VAR 0 44
80317: PUSH
80318: LD_INT 0
80320: PUSH
80321: LD_INT 2
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: PUSH
80331: LD_INT 3
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 1
80340: NEG
80341: PUSH
80342: LD_INT 2
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: LIST
80353: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80354: LD_ADDR_VAR 0 45
80358: PUSH
80359: LD_INT 2
80361: NEG
80362: PUSH
80363: LD_INT 0
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 2
80372: NEG
80373: PUSH
80374: LD_INT 1
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 3
80383: NEG
80384: PUSH
80385: LD_INT 1
80387: NEG
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: LIST
80397: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
80398: LD_ADDR_VAR 0 46
80402: PUSH
80403: LD_INT 2
80405: NEG
80406: PUSH
80407: LD_INT 2
80409: NEG
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 2
80417: NEG
80418: PUSH
80419: LD_INT 3
80421: NEG
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 3
80429: NEG
80430: PUSH
80431: LD_INT 2
80433: NEG
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: LIST
80443: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
80444: LD_ADDR_VAR 0 47
80448: PUSH
80449: LD_INT 2
80451: NEG
80452: PUSH
80453: LD_INT 3
80455: NEG
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 3
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80477: LD_ADDR_VAR 0 48
80481: PUSH
80482: LD_INT 1
80484: PUSH
80485: LD_INT 2
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: LD_INT 1
80498: NEG
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
80508: LD_ADDR_VAR 0 49
80512: PUSH
80513: LD_INT 3
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 3
80525: PUSH
80526: LD_INT 2
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
80537: LD_ADDR_VAR 0 50
80541: PUSH
80542: LD_INT 2
80544: PUSH
80545: LD_INT 3
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 1
80554: PUSH
80555: LD_INT 3
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80566: LD_ADDR_VAR 0 51
80570: PUSH
80571: LD_INT 1
80573: NEG
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 2
80584: NEG
80585: PUSH
80586: LD_INT 1
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80597: LD_ADDR_VAR 0 52
80601: PUSH
80602: LD_INT 3
80604: NEG
80605: PUSH
80606: LD_INT 1
80608: NEG
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 3
80616: NEG
80617: PUSH
80618: LD_INT 2
80620: NEG
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80630: LD_ADDR_VAR 0 53
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 3
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: LD_INT 3
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: LD_INT 2
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: LIST
80673: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80674: LD_ADDR_VAR 0 54
80678: PUSH
80679: LD_INT 2
80681: PUSH
80682: LD_INT 1
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 3
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 3
80702: PUSH
80703: LD_INT 1
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: LIST
80714: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80715: LD_ADDR_VAR 0 55
80719: PUSH
80720: LD_INT 3
80722: PUSH
80723: LD_INT 2
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 3
80732: PUSH
80733: LD_INT 3
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 2
80742: PUSH
80743: LD_INT 3
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: LIST
80754: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80755: LD_ADDR_VAR 0 56
80759: PUSH
80760: LD_INT 1
80762: PUSH
80763: LD_INT 3
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 0
80772: PUSH
80773: LD_INT 3
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: NEG
80783: PUSH
80784: LD_INT 2
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: LIST
80795: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80796: LD_ADDR_VAR 0 57
80800: PUSH
80801: LD_INT 2
80803: NEG
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 3
80814: NEG
80815: PUSH
80816: LD_INT 0
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 3
80825: NEG
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: LIST
80839: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80840: LD_ADDR_VAR 0 58
80844: PUSH
80845: LD_INT 2
80847: NEG
80848: PUSH
80849: LD_INT 3
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 3
80859: NEG
80860: PUSH
80861: LD_INT 2
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 3
80871: NEG
80872: PUSH
80873: LD_INT 3
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: LIST
80885: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80886: LD_ADDR_VAR 0 59
80890: PUSH
80891: LD_INT 1
80893: NEG
80894: PUSH
80895: LD_INT 2
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 0
80905: PUSH
80906: LD_INT 2
80908: NEG
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: PUSH
80917: LD_INT 1
80919: NEG
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: LIST
80929: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80930: LD_ADDR_VAR 0 60
80934: PUSH
80935: LD_INT 1
80937: PUSH
80938: LD_INT 1
80940: NEG
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 2
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 2
80958: PUSH
80959: LD_INT 1
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: LIST
80970: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80971: LD_ADDR_VAR 0 61
80975: PUSH
80976: LD_INT 2
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 2
80988: PUSH
80989: LD_INT 2
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: PUSH
80999: LD_INT 2
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: LIST
81010: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81011: LD_ADDR_VAR 0 62
81015: PUSH
81016: LD_INT 1
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 0
81028: PUSH
81029: LD_INT 2
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 1
81038: NEG
81039: PUSH
81040: LD_INT 1
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: LIST
81051: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81052: LD_ADDR_VAR 0 63
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: LD_INT 1
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 2
81070: NEG
81071: PUSH
81072: LD_INT 0
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 2
81081: NEG
81082: PUSH
81083: LD_INT 1
81085: NEG
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: LIST
81095: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81096: LD_ADDR_VAR 0 64
81100: PUSH
81101: LD_INT 1
81103: NEG
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: LD_INT 1
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 2
81127: NEG
81128: PUSH
81129: LD_INT 2
81131: NEG
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: LIST
81141: ST_TO_ADDR
// end ; 2 :
81142: GO 84408
81144: LD_INT 2
81146: DOUBLE
81147: EQUAL
81148: IFTRUE 81152
81150: GO 84407
81152: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81153: LD_ADDR_VAR 0 29
81157: PUSH
81158: LD_INT 4
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 4
81170: PUSH
81171: LD_INT 1
81173: NEG
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 5
81181: PUSH
81182: LD_INT 0
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 5
81191: PUSH
81192: LD_INT 1
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 4
81201: PUSH
81202: LD_INT 1
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 3
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 3
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 3
81232: PUSH
81233: LD_INT 2
81235: NEG
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 5
81243: PUSH
81244: LD_INT 2
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 3
81253: PUSH
81254: LD_INT 3
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 3
81263: PUSH
81264: LD_INT 2
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 4
81273: PUSH
81274: LD_INT 3
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 4
81283: PUSH
81284: LD_INT 4
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: PUSH
81291: LD_INT 3
81293: PUSH
81294: LD_INT 4
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 2
81303: PUSH
81304: LD_INT 3
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 2
81313: PUSH
81314: LD_INT 2
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 4
81323: PUSH
81324: LD_INT 2
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: LD_INT 4
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 0
81343: PUSH
81344: LD_INT 4
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: LD_INT 0
81353: PUSH
81354: LD_INT 3
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 1
81363: PUSH
81364: LD_INT 4
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 1
81373: PUSH
81374: LD_INT 5
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 0
81383: PUSH
81384: LD_INT 5
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: NEG
81394: PUSH
81395: LD_INT 4
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 1
81404: NEG
81405: PUSH
81406: LD_INT 3
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 2
81415: PUSH
81416: LD_INT 5
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 2
81425: NEG
81426: PUSH
81427: LD_INT 3
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 3
81436: NEG
81437: PUSH
81438: LD_INT 0
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 3
81447: NEG
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 2
81459: NEG
81460: PUSH
81461: LD_INT 0
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 2
81470: NEG
81471: PUSH
81472: LD_INT 1
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 3
81481: NEG
81482: PUSH
81483: LD_INT 1
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 4
81492: NEG
81493: PUSH
81494: LD_INT 0
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 4
81503: NEG
81504: PUSH
81505: LD_INT 1
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 4
81515: NEG
81516: PUSH
81517: LD_INT 2
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: NEG
81528: PUSH
81529: LD_INT 2
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 4
81538: NEG
81539: PUSH
81540: LD_INT 4
81542: NEG
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 4
81550: NEG
81551: PUSH
81552: LD_INT 5
81554: NEG
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 3
81562: NEG
81563: PUSH
81564: LD_INT 4
81566: NEG
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 3
81574: NEG
81575: PUSH
81576: LD_INT 3
81578: NEG
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 4
81586: NEG
81587: PUSH
81588: LD_INT 3
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 5
81598: NEG
81599: PUSH
81600: LD_INT 4
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 5
81610: NEG
81611: PUSH
81612: LD_INT 5
81614: NEG
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 3
81622: NEG
81623: PUSH
81624: LD_INT 5
81626: NEG
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 5
81634: NEG
81635: PUSH
81636: LD_INT 3
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81691: LD_ADDR_VAR 0 30
81695: PUSH
81696: LD_INT 4
81698: PUSH
81699: LD_INT 4
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 4
81708: PUSH
81709: LD_INT 3
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: LD_INT 5
81718: PUSH
81719: LD_INT 4
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 5
81728: PUSH
81729: LD_INT 5
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 4
81738: PUSH
81739: LD_INT 5
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 3
81748: PUSH
81749: LD_INT 4
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 3
81758: PUSH
81759: LD_INT 3
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 5
81768: PUSH
81769: LD_INT 3
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 3
81778: PUSH
81779: LD_INT 5
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 0
81788: PUSH
81789: LD_INT 3
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 0
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: LD_INT 3
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 1
81818: PUSH
81819: LD_INT 4
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 0
81828: PUSH
81829: LD_INT 4
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 1
81838: NEG
81839: PUSH
81840: LD_INT 3
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 1
81849: NEG
81850: PUSH
81851: LD_INT 2
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: LD_INT 4
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 2
81870: NEG
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 4
81881: NEG
81882: PUSH
81883: LD_INT 0
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 4
81892: NEG
81893: PUSH
81894: LD_INT 1
81896: NEG
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 3
81904: NEG
81905: PUSH
81906: LD_INT 0
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 3
81915: NEG
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 4
81926: NEG
81927: PUSH
81928: LD_INT 1
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 5
81937: NEG
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 5
81948: NEG
81949: PUSH
81950: LD_INT 1
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 5
81960: NEG
81961: PUSH
81962: LD_INT 2
81964: NEG
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 3
81972: NEG
81973: PUSH
81974: LD_INT 2
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 3
81983: NEG
81984: PUSH
81985: LD_INT 3
81987: NEG
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 3
81995: NEG
81996: PUSH
81997: LD_INT 4
81999: NEG
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 2
82007: NEG
82008: PUSH
82009: LD_INT 3
82011: NEG
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 2
82019: NEG
82020: PUSH
82021: LD_INT 2
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 3
82031: NEG
82032: PUSH
82033: LD_INT 2
82035: NEG
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 4
82043: NEG
82044: PUSH
82045: LD_INT 3
82047: NEG
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 4
82055: NEG
82056: PUSH
82057: LD_INT 4
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 2
82067: NEG
82068: PUSH
82069: LD_INT 4
82071: NEG
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 4
82079: NEG
82080: PUSH
82081: LD_INT 2
82083: NEG
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 0
82091: PUSH
82092: LD_INT 4
82094: NEG
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 0
82102: PUSH
82103: LD_INT 5
82105: NEG
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: LD_INT 4
82116: NEG
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: LD_INT 3
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: LD_INT 3
82138: NEG
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 1
82146: NEG
82147: PUSH
82148: LD_INT 4
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 1
82158: NEG
82159: PUSH
82160: LD_INT 5
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: PUSH
82171: LD_INT 3
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 2
82181: NEG
82182: PUSH
82183: LD_INT 5
82185: NEG
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
82238: LD_ADDR_VAR 0 31
82242: PUSH
82243: LD_INT 0
82245: PUSH
82246: LD_INT 4
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 0
82255: PUSH
82256: LD_INT 3
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: PUSH
82266: LD_INT 4
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: LD_INT 5
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: LD_INT 5
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 1
82295: NEG
82296: PUSH
82297: LD_INT 4
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 1
82306: NEG
82307: PUSH
82308: LD_INT 3
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: PUSH
82315: LD_INT 2
82317: PUSH
82318: LD_INT 5
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 2
82327: NEG
82328: PUSH
82329: LD_INT 3
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 3
82338: NEG
82339: PUSH
82340: LD_INT 0
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 3
82349: NEG
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 2
82361: NEG
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 2
82372: NEG
82373: PUSH
82374: LD_INT 1
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 3
82383: NEG
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 4
82394: NEG
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 4
82405: NEG
82406: PUSH
82407: LD_INT 1
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 4
82417: NEG
82418: PUSH
82419: LD_INT 2
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 2
82429: NEG
82430: PUSH
82431: LD_INT 2
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 4
82440: NEG
82441: PUSH
82442: LD_INT 4
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 4
82452: NEG
82453: PUSH
82454: LD_INT 5
82456: NEG
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 3
82464: NEG
82465: PUSH
82466: LD_INT 4
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 3
82476: NEG
82477: PUSH
82478: LD_INT 3
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 4
82488: NEG
82489: PUSH
82490: LD_INT 3
82492: NEG
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 5
82500: NEG
82501: PUSH
82502: LD_INT 4
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 5
82512: NEG
82513: PUSH
82514: LD_INT 5
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: LD_INT 5
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 5
82536: NEG
82537: PUSH
82538: LD_INT 3
82540: NEG
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 0
82548: PUSH
82549: LD_INT 3
82551: NEG
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: LD_INT 0
82559: PUSH
82560: LD_INT 4
82562: NEG
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 1
82570: PUSH
82571: LD_INT 3
82573: NEG
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 2
82584: NEG
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 0
82592: PUSH
82593: LD_INT 2
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 1
82603: NEG
82604: PUSH
82605: LD_INT 3
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 1
82615: NEG
82616: PUSH
82617: LD_INT 4
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: PUSH
82628: LD_INT 2
82630: NEG
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 2
82638: NEG
82639: PUSH
82640: LD_INT 4
82642: NEG
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 4
82650: PUSH
82651: LD_INT 0
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 4
82660: PUSH
82661: LD_INT 1
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 5
82671: PUSH
82672: LD_INT 0
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 5
82681: PUSH
82682: LD_INT 1
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 4
82691: PUSH
82692: LD_INT 1
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 3
82701: PUSH
82702: LD_INT 0
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 3
82711: PUSH
82712: LD_INT 1
82714: NEG
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 3
82722: PUSH
82723: LD_INT 2
82725: NEG
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 5
82733: PUSH
82734: LD_INT 2
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82788: LD_ADDR_VAR 0 32
82792: PUSH
82793: LD_INT 4
82795: NEG
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 4
82806: NEG
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 3
82818: NEG
82819: PUSH
82820: LD_INT 0
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 3
82829: NEG
82830: PUSH
82831: LD_INT 1
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 4
82840: NEG
82841: PUSH
82842: LD_INT 1
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 5
82851: NEG
82852: PUSH
82853: LD_INT 0
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 5
82862: NEG
82863: PUSH
82864: LD_INT 1
82866: NEG
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 5
82874: NEG
82875: PUSH
82876: LD_INT 2
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 3
82886: NEG
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 3
82897: NEG
82898: PUSH
82899: LD_INT 3
82901: NEG
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 3
82909: NEG
82910: PUSH
82911: LD_INT 4
82913: NEG
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 2
82921: NEG
82922: PUSH
82923: LD_INT 3
82925: NEG
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: LD_INT 2
82933: NEG
82934: PUSH
82935: LD_INT 2
82937: NEG
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 3
82945: NEG
82946: PUSH
82947: LD_INT 2
82949: NEG
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 4
82957: NEG
82958: PUSH
82959: LD_INT 3
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 4
82969: NEG
82970: PUSH
82971: LD_INT 4
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 2
82981: NEG
82982: PUSH
82983: LD_INT 4
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 4
82993: NEG
82994: PUSH
82995: LD_INT 2
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 0
83005: PUSH
83006: LD_INT 4
83008: NEG
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 5
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 4
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 1
83038: PUSH
83039: LD_INT 3
83041: NEG
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 0
83049: PUSH
83050: LD_INT 3
83052: NEG
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 1
83060: NEG
83061: PUSH
83062: LD_INT 4
83064: NEG
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: NEG
83073: PUSH
83074: LD_INT 5
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 2
83084: PUSH
83085: LD_INT 3
83087: NEG
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 2
83095: NEG
83096: PUSH
83097: LD_INT 5
83099: NEG
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: LD_INT 0
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 3
83117: PUSH
83118: LD_INT 1
83120: NEG
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 4
83128: PUSH
83129: LD_INT 0
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 4
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 3
83148: PUSH
83149: LD_INT 1
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 2
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 2
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 2
83179: PUSH
83180: LD_INT 2
83182: NEG
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 4
83190: PUSH
83191: LD_INT 2
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 4
83200: PUSH
83201: LD_INT 4
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 4
83210: PUSH
83211: LD_INT 3
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 5
83220: PUSH
83221: LD_INT 4
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 5
83230: PUSH
83231: LD_INT 5
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 4
83240: PUSH
83241: LD_INT 5
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 3
83250: PUSH
83251: LD_INT 4
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 3
83260: PUSH
83261: LD_INT 3
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 5
83270: PUSH
83271: LD_INT 3
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 3
83280: PUSH
83281: LD_INT 5
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
83335: LD_ADDR_VAR 0 33
83339: PUSH
83340: LD_INT 4
83342: NEG
83343: PUSH
83344: LD_INT 4
83346: NEG
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 4
83354: NEG
83355: PUSH
83356: LD_INT 5
83358: NEG
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 3
83366: NEG
83367: PUSH
83368: LD_INT 4
83370: NEG
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 3
83378: NEG
83379: PUSH
83380: LD_INT 3
83382: NEG
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 4
83390: NEG
83391: PUSH
83392: LD_INT 3
83394: NEG
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 5
83402: NEG
83403: PUSH
83404: LD_INT 4
83406: NEG
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 5
83414: NEG
83415: PUSH
83416: LD_INT 5
83418: NEG
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 3
83426: NEG
83427: PUSH
83428: LD_INT 5
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 5
83438: NEG
83439: PUSH
83440: LD_INT 3
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: LD_INT 3
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: LD_INT 4
83464: NEG
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 1
83472: PUSH
83473: LD_INT 3
83475: NEG
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 1
83483: PUSH
83484: LD_INT 2
83486: NEG
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 0
83494: PUSH
83495: LD_INT 2
83497: NEG
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 1
83505: NEG
83506: PUSH
83507: LD_INT 3
83509: NEG
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: LD_INT 4
83521: NEG
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 2
83529: PUSH
83530: LD_INT 2
83532: NEG
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 2
83540: NEG
83541: PUSH
83542: LD_INT 4
83544: NEG
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 4
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 4
83562: PUSH
83563: LD_INT 1
83565: NEG
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_INT 5
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 5
83583: PUSH
83584: LD_INT 1
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 4
83593: PUSH
83594: LD_INT 1
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 3
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 3
83613: PUSH
83614: LD_INT 1
83616: NEG
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 3
83624: PUSH
83625: LD_INT 2
83627: NEG
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: LD_INT 5
83635: PUSH
83636: LD_INT 2
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 3
83645: PUSH
83646: LD_INT 3
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 3
83655: PUSH
83656: LD_INT 2
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 4
83665: PUSH
83666: LD_INT 3
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 4
83675: PUSH
83676: LD_INT 4
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: LD_INT 3
83685: PUSH
83686: LD_INT 4
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 2
83695: PUSH
83696: LD_INT 3
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 2
83705: PUSH
83706: LD_INT 2
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 4
83715: PUSH
83716: LD_INT 2
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 2
83725: PUSH
83726: LD_INT 4
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 0
83735: PUSH
83736: LD_INT 4
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 0
83745: PUSH
83746: LD_INT 3
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 1
83755: PUSH
83756: LD_INT 4
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: LD_INT 5
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 0
83775: PUSH
83776: LD_INT 5
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 1
83785: NEG
83786: PUSH
83787: LD_INT 4
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 1
83796: NEG
83797: PUSH
83798: LD_INT 3
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: LD_INT 2
83807: PUSH
83808: LD_INT 5
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 2
83817: NEG
83818: PUSH
83819: LD_INT 3
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83873: LD_ADDR_VAR 0 34
83877: PUSH
83878: LD_INT 0
83880: PUSH
83881: LD_INT 4
83883: NEG
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 0
83891: PUSH
83892: LD_INT 5
83894: NEG
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 1
83902: PUSH
83903: LD_INT 4
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: PUSH
83914: LD_INT 3
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 0
83924: PUSH
83925: LD_INT 3
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 1
83935: NEG
83936: PUSH
83937: LD_INT 4
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: NEG
83948: PUSH
83949: LD_INT 5
83951: NEG
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 2
83959: PUSH
83960: LD_INT 3
83962: NEG
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 2
83970: NEG
83971: PUSH
83972: LD_INT 5
83974: NEG
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 3
83982: PUSH
83983: LD_INT 0
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 3
83992: PUSH
83993: LD_INT 1
83995: NEG
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 4
84003: PUSH
84004: LD_INT 0
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PUSH
84011: LD_INT 4
84013: PUSH
84014: LD_INT 1
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 3
84023: PUSH
84024: LD_INT 1
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 2
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 2
84043: PUSH
84044: LD_INT 1
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 2
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 4
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: LD_INT 4
84075: PUSH
84076: LD_INT 4
84078: PUSH
84079: EMPTY
84080: LIST
84081: LIST
84082: PUSH
84083: LD_INT 4
84085: PUSH
84086: LD_INT 3
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 5
84095: PUSH
84096: LD_INT 4
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 5
84105: PUSH
84106: LD_INT 5
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 4
84115: PUSH
84116: LD_INT 5
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 3
84125: PUSH
84126: LD_INT 4
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 3
84135: PUSH
84136: LD_INT 3
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 5
84145: PUSH
84146: LD_INT 3
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: LD_INT 3
84155: PUSH
84156: LD_INT 5
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 0
84165: PUSH
84166: LD_INT 3
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 0
84175: PUSH
84176: LD_INT 2
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 1
84185: PUSH
84186: LD_INT 3
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 1
84195: PUSH
84196: LD_INT 4
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 0
84205: PUSH
84206: LD_INT 4
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: LD_INT 3
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: LD_INT 2
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 2
84237: PUSH
84238: LD_INT 4
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 2
84247: NEG
84248: PUSH
84249: LD_INT 2
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 4
84258: NEG
84259: PUSH
84260: LD_INT 0
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 4
84269: NEG
84270: PUSH
84271: LD_INT 1
84273: NEG
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 3
84281: NEG
84282: PUSH
84283: LD_INT 0
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: PUSH
84290: LD_INT 3
84292: NEG
84293: PUSH
84294: LD_INT 1
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 4
84303: NEG
84304: PUSH
84305: LD_INT 1
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 5
84314: NEG
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PUSH
84323: LD_INT 5
84325: NEG
84326: PUSH
84327: LD_INT 1
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 5
84337: NEG
84338: PUSH
84339: LD_INT 2
84341: NEG
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 3
84349: NEG
84350: PUSH
84351: LD_INT 2
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: ST_TO_ADDR
// end ; end ;
84405: GO 84408
84407: POP
// case btype of b_depot , b_warehouse :
84408: LD_VAR 0 1
84412: PUSH
84413: LD_INT 0
84415: DOUBLE
84416: EQUAL
84417: IFTRUE 84427
84419: LD_INT 1
84421: DOUBLE
84422: EQUAL
84423: IFTRUE 84427
84425: GO 84628
84427: POP
// case nation of nation_american :
84428: LD_VAR 0 5
84432: PUSH
84433: LD_INT 1
84435: DOUBLE
84436: EQUAL
84437: IFTRUE 84441
84439: GO 84497
84441: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
84442: LD_ADDR_VAR 0 9
84446: PUSH
84447: LD_VAR 0 11
84451: PUSH
84452: LD_VAR 0 12
84456: PUSH
84457: LD_VAR 0 13
84461: PUSH
84462: LD_VAR 0 14
84466: PUSH
84467: LD_VAR 0 15
84471: PUSH
84472: LD_VAR 0 16
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: PUSH
84485: LD_VAR 0 4
84489: PUSH
84490: LD_INT 1
84492: PLUS
84493: ARRAY
84494: ST_TO_ADDR
84495: GO 84626
84497: LD_INT 2
84499: DOUBLE
84500: EQUAL
84501: IFTRUE 84505
84503: GO 84561
84505: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
84506: LD_ADDR_VAR 0 9
84510: PUSH
84511: LD_VAR 0 17
84515: PUSH
84516: LD_VAR 0 18
84520: PUSH
84521: LD_VAR 0 19
84525: PUSH
84526: LD_VAR 0 20
84530: PUSH
84531: LD_VAR 0 21
84535: PUSH
84536: LD_VAR 0 22
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: PUSH
84549: LD_VAR 0 4
84553: PUSH
84554: LD_INT 1
84556: PLUS
84557: ARRAY
84558: ST_TO_ADDR
84559: GO 84626
84561: LD_INT 3
84563: DOUBLE
84564: EQUAL
84565: IFTRUE 84569
84567: GO 84625
84569: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
84570: LD_ADDR_VAR 0 9
84574: PUSH
84575: LD_VAR 0 23
84579: PUSH
84580: LD_VAR 0 24
84584: PUSH
84585: LD_VAR 0 25
84589: PUSH
84590: LD_VAR 0 26
84594: PUSH
84595: LD_VAR 0 27
84599: PUSH
84600: LD_VAR 0 28
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: PUSH
84613: LD_VAR 0 4
84617: PUSH
84618: LD_INT 1
84620: PLUS
84621: ARRAY
84622: ST_TO_ADDR
84623: GO 84626
84625: POP
84626: GO 85181
84628: LD_INT 2
84630: DOUBLE
84631: EQUAL
84632: IFTRUE 84642
84634: LD_INT 3
84636: DOUBLE
84637: EQUAL
84638: IFTRUE 84642
84640: GO 84698
84642: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84643: LD_ADDR_VAR 0 9
84647: PUSH
84648: LD_VAR 0 29
84652: PUSH
84653: LD_VAR 0 30
84657: PUSH
84658: LD_VAR 0 31
84662: PUSH
84663: LD_VAR 0 32
84667: PUSH
84668: LD_VAR 0 33
84672: PUSH
84673: LD_VAR 0 34
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: PUSH
84686: LD_VAR 0 4
84690: PUSH
84691: LD_INT 1
84693: PLUS
84694: ARRAY
84695: ST_TO_ADDR
84696: GO 85181
84698: LD_INT 16
84700: DOUBLE
84701: EQUAL
84702: IFTRUE 84760
84704: LD_INT 17
84706: DOUBLE
84707: EQUAL
84708: IFTRUE 84760
84710: LD_INT 18
84712: DOUBLE
84713: EQUAL
84714: IFTRUE 84760
84716: LD_INT 19
84718: DOUBLE
84719: EQUAL
84720: IFTRUE 84760
84722: LD_INT 22
84724: DOUBLE
84725: EQUAL
84726: IFTRUE 84760
84728: LD_INT 20
84730: DOUBLE
84731: EQUAL
84732: IFTRUE 84760
84734: LD_INT 21
84736: DOUBLE
84737: EQUAL
84738: IFTRUE 84760
84740: LD_INT 23
84742: DOUBLE
84743: EQUAL
84744: IFTRUE 84760
84746: LD_INT 24
84748: DOUBLE
84749: EQUAL
84750: IFTRUE 84760
84752: LD_INT 25
84754: DOUBLE
84755: EQUAL
84756: IFTRUE 84760
84758: GO 84816
84760: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84761: LD_ADDR_VAR 0 9
84765: PUSH
84766: LD_VAR 0 35
84770: PUSH
84771: LD_VAR 0 36
84775: PUSH
84776: LD_VAR 0 37
84780: PUSH
84781: LD_VAR 0 38
84785: PUSH
84786: LD_VAR 0 39
84790: PUSH
84791: LD_VAR 0 40
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: PUSH
84804: LD_VAR 0 4
84808: PUSH
84809: LD_INT 1
84811: PLUS
84812: ARRAY
84813: ST_TO_ADDR
84814: GO 85181
84816: LD_INT 6
84818: DOUBLE
84819: EQUAL
84820: IFTRUE 84872
84822: LD_INT 7
84824: DOUBLE
84825: EQUAL
84826: IFTRUE 84872
84828: LD_INT 8
84830: DOUBLE
84831: EQUAL
84832: IFTRUE 84872
84834: LD_INT 13
84836: DOUBLE
84837: EQUAL
84838: IFTRUE 84872
84840: LD_INT 12
84842: DOUBLE
84843: EQUAL
84844: IFTRUE 84872
84846: LD_INT 15
84848: DOUBLE
84849: EQUAL
84850: IFTRUE 84872
84852: LD_INT 11
84854: DOUBLE
84855: EQUAL
84856: IFTRUE 84872
84858: LD_INT 14
84860: DOUBLE
84861: EQUAL
84862: IFTRUE 84872
84864: LD_INT 10
84866: DOUBLE
84867: EQUAL
84868: IFTRUE 84872
84870: GO 84928
84872: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84873: LD_ADDR_VAR 0 9
84877: PUSH
84878: LD_VAR 0 41
84882: PUSH
84883: LD_VAR 0 42
84887: PUSH
84888: LD_VAR 0 43
84892: PUSH
84893: LD_VAR 0 44
84897: PUSH
84898: LD_VAR 0 45
84902: PUSH
84903: LD_VAR 0 46
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: PUSH
84916: LD_VAR 0 4
84920: PUSH
84921: LD_INT 1
84923: PLUS
84924: ARRAY
84925: ST_TO_ADDR
84926: GO 85181
84928: LD_INT 36
84930: DOUBLE
84931: EQUAL
84932: IFTRUE 84936
84934: GO 84992
84936: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84937: LD_ADDR_VAR 0 9
84941: PUSH
84942: LD_VAR 0 47
84946: PUSH
84947: LD_VAR 0 48
84951: PUSH
84952: LD_VAR 0 49
84956: PUSH
84957: LD_VAR 0 50
84961: PUSH
84962: LD_VAR 0 51
84966: PUSH
84967: LD_VAR 0 52
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: PUSH
84980: LD_VAR 0 4
84984: PUSH
84985: LD_INT 1
84987: PLUS
84988: ARRAY
84989: ST_TO_ADDR
84990: GO 85181
84992: LD_INT 4
84994: DOUBLE
84995: EQUAL
84996: IFTRUE 85018
84998: LD_INT 5
85000: DOUBLE
85001: EQUAL
85002: IFTRUE 85018
85004: LD_INT 34
85006: DOUBLE
85007: EQUAL
85008: IFTRUE 85018
85010: LD_INT 37
85012: DOUBLE
85013: EQUAL
85014: IFTRUE 85018
85016: GO 85074
85018: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85019: LD_ADDR_VAR 0 9
85023: PUSH
85024: LD_VAR 0 53
85028: PUSH
85029: LD_VAR 0 54
85033: PUSH
85034: LD_VAR 0 55
85038: PUSH
85039: LD_VAR 0 56
85043: PUSH
85044: LD_VAR 0 57
85048: PUSH
85049: LD_VAR 0 58
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: PUSH
85062: LD_VAR 0 4
85066: PUSH
85067: LD_INT 1
85069: PLUS
85070: ARRAY
85071: ST_TO_ADDR
85072: GO 85181
85074: LD_INT 31
85076: DOUBLE
85077: EQUAL
85078: IFTRUE 85124
85080: LD_INT 32
85082: DOUBLE
85083: EQUAL
85084: IFTRUE 85124
85086: LD_INT 33
85088: DOUBLE
85089: EQUAL
85090: IFTRUE 85124
85092: LD_INT 27
85094: DOUBLE
85095: EQUAL
85096: IFTRUE 85124
85098: LD_INT 26
85100: DOUBLE
85101: EQUAL
85102: IFTRUE 85124
85104: LD_INT 28
85106: DOUBLE
85107: EQUAL
85108: IFTRUE 85124
85110: LD_INT 29
85112: DOUBLE
85113: EQUAL
85114: IFTRUE 85124
85116: LD_INT 30
85118: DOUBLE
85119: EQUAL
85120: IFTRUE 85124
85122: GO 85180
85124: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85125: LD_ADDR_VAR 0 9
85129: PUSH
85130: LD_VAR 0 59
85134: PUSH
85135: LD_VAR 0 60
85139: PUSH
85140: LD_VAR 0 61
85144: PUSH
85145: LD_VAR 0 62
85149: PUSH
85150: LD_VAR 0 63
85154: PUSH
85155: LD_VAR 0 64
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: PUSH
85168: LD_VAR 0 4
85172: PUSH
85173: LD_INT 1
85175: PLUS
85176: ARRAY
85177: ST_TO_ADDR
85178: GO 85181
85180: POP
// temp_list2 = [ ] ;
85181: LD_ADDR_VAR 0 10
85185: PUSH
85186: EMPTY
85187: ST_TO_ADDR
// for i in temp_list do
85188: LD_ADDR_VAR 0 8
85192: PUSH
85193: LD_VAR 0 9
85197: PUSH
85198: FOR_IN
85199: IFFALSE 85251
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
85201: LD_ADDR_VAR 0 10
85205: PUSH
85206: LD_VAR 0 10
85210: PUSH
85211: LD_VAR 0 8
85215: PUSH
85216: LD_INT 1
85218: ARRAY
85219: PUSH
85220: LD_VAR 0 2
85224: PLUS
85225: PUSH
85226: LD_VAR 0 8
85230: PUSH
85231: LD_INT 2
85233: ARRAY
85234: PUSH
85235: LD_VAR 0 3
85239: PLUS
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: EMPTY
85246: LIST
85247: ADD
85248: ST_TO_ADDR
85249: GO 85198
85251: POP
85252: POP
// result = temp_list2 ;
85253: LD_ADDR_VAR 0 7
85257: PUSH
85258: LD_VAR 0 10
85262: ST_TO_ADDR
// end ;
85263: LD_VAR 0 7
85267: RET
// export function EnemyInRange ( unit , dist ) ; begin
85268: LD_INT 0
85270: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
85271: LD_ADDR_VAR 0 3
85275: PUSH
85276: LD_VAR 0 1
85280: PPUSH
85281: CALL_OW 255
85285: PPUSH
85286: LD_VAR 0 1
85290: PPUSH
85291: CALL_OW 250
85295: PPUSH
85296: LD_VAR 0 1
85300: PPUSH
85301: CALL_OW 251
85305: PPUSH
85306: LD_VAR 0 2
85310: PPUSH
85311: CALL 58670 0 4
85315: PUSH
85316: LD_INT 4
85318: ARRAY
85319: ST_TO_ADDR
// end ;
85320: LD_VAR 0 3
85324: RET
// export function PlayerSeeMe ( unit ) ; begin
85325: LD_INT 0
85327: PPUSH
// result := See ( your_side , unit ) ;
85328: LD_ADDR_VAR 0 2
85332: PUSH
85333: LD_OWVAR 2
85337: PPUSH
85338: LD_VAR 0 1
85342: PPUSH
85343: CALL_OW 292
85347: ST_TO_ADDR
// end ;
85348: LD_VAR 0 2
85352: RET
// export function ReverseDir ( unit ) ; begin
85353: LD_INT 0
85355: PPUSH
// if not unit then
85356: LD_VAR 0 1
85360: NOT
85361: IFFALSE 85365
// exit ;
85363: GO 85388
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
85365: LD_ADDR_VAR 0 2
85369: PUSH
85370: LD_VAR 0 1
85374: PPUSH
85375: CALL_OW 254
85379: PUSH
85380: LD_INT 3
85382: PLUS
85383: PUSH
85384: LD_INT 6
85386: MOD
85387: ST_TO_ADDR
// end ;
85388: LD_VAR 0 2
85392: RET
// export function ReverseArray ( array ) ; var i ; begin
85393: LD_INT 0
85395: PPUSH
85396: PPUSH
// if not array then
85397: LD_VAR 0 1
85401: NOT
85402: IFFALSE 85406
// exit ;
85404: GO 85461
// result := [ ] ;
85406: LD_ADDR_VAR 0 2
85410: PUSH
85411: EMPTY
85412: ST_TO_ADDR
// for i := array downto 1 do
85413: LD_ADDR_VAR 0 3
85417: PUSH
85418: DOUBLE
85419: LD_VAR 0 1
85423: INC
85424: ST_TO_ADDR
85425: LD_INT 1
85427: PUSH
85428: FOR_DOWNTO
85429: IFFALSE 85459
// result := Join ( result , array [ i ] ) ;
85431: LD_ADDR_VAR 0 2
85435: PUSH
85436: LD_VAR 0 2
85440: PPUSH
85441: LD_VAR 0 1
85445: PUSH
85446: LD_VAR 0 3
85450: ARRAY
85451: PPUSH
85452: CALL 90104 0 2
85456: ST_TO_ADDR
85457: GO 85428
85459: POP
85460: POP
// end ;
85461: LD_VAR 0 2
85465: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
85466: LD_INT 0
85468: PPUSH
85469: PPUSH
85470: PPUSH
85471: PPUSH
85472: PPUSH
85473: PPUSH
// if not unit or not hexes then
85474: LD_VAR 0 1
85478: NOT
85479: PUSH
85480: LD_VAR 0 2
85484: NOT
85485: OR
85486: IFFALSE 85490
// exit ;
85488: GO 85613
// dist := 9999 ;
85490: LD_ADDR_VAR 0 5
85494: PUSH
85495: LD_INT 9999
85497: ST_TO_ADDR
// for i = 1 to hexes do
85498: LD_ADDR_VAR 0 4
85502: PUSH
85503: DOUBLE
85504: LD_INT 1
85506: DEC
85507: ST_TO_ADDR
85508: LD_VAR 0 2
85512: PUSH
85513: FOR_TO
85514: IFFALSE 85601
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85516: LD_ADDR_VAR 0 6
85520: PUSH
85521: LD_VAR 0 1
85525: PPUSH
85526: LD_VAR 0 2
85530: PUSH
85531: LD_VAR 0 4
85535: ARRAY
85536: PUSH
85537: LD_INT 1
85539: ARRAY
85540: PPUSH
85541: LD_VAR 0 2
85545: PUSH
85546: LD_VAR 0 4
85550: ARRAY
85551: PUSH
85552: LD_INT 2
85554: ARRAY
85555: PPUSH
85556: CALL_OW 297
85560: ST_TO_ADDR
// if tdist < dist then
85561: LD_VAR 0 6
85565: PUSH
85566: LD_VAR 0 5
85570: LESS
85571: IFFALSE 85599
// begin hex := hexes [ i ] ;
85573: LD_ADDR_VAR 0 8
85577: PUSH
85578: LD_VAR 0 2
85582: PUSH
85583: LD_VAR 0 4
85587: ARRAY
85588: ST_TO_ADDR
// dist := tdist ;
85589: LD_ADDR_VAR 0 5
85593: PUSH
85594: LD_VAR 0 6
85598: ST_TO_ADDR
// end ; end ;
85599: GO 85513
85601: POP
85602: POP
// result := hex ;
85603: LD_ADDR_VAR 0 3
85607: PUSH
85608: LD_VAR 0 8
85612: ST_TO_ADDR
// end ;
85613: LD_VAR 0 3
85617: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85618: LD_INT 0
85620: PPUSH
85621: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85622: LD_VAR 0 1
85626: NOT
85627: PUSH
85628: LD_VAR 0 1
85632: PUSH
85633: LD_INT 21
85635: PUSH
85636: LD_INT 2
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 23
85645: PUSH
85646: LD_INT 2
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PPUSH
85657: CALL_OW 69
85661: IN
85662: NOT
85663: OR
85664: IFFALSE 85668
// exit ;
85666: GO 85715
// for i = 1 to 3 do
85668: LD_ADDR_VAR 0 3
85672: PUSH
85673: DOUBLE
85674: LD_INT 1
85676: DEC
85677: ST_TO_ADDR
85678: LD_INT 3
85680: PUSH
85681: FOR_TO
85682: IFFALSE 85713
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85684: LD_VAR 0 1
85688: PPUSH
85689: CALL_OW 250
85693: PPUSH
85694: LD_VAR 0 1
85698: PPUSH
85699: CALL_OW 251
85703: PPUSH
85704: LD_INT 1
85706: PPUSH
85707: CALL_OW 453
85711: GO 85681
85713: POP
85714: POP
// end ;
85715: LD_VAR 0 2
85719: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85720: LD_INT 0
85722: PPUSH
85723: PPUSH
85724: PPUSH
85725: PPUSH
85726: PPUSH
85727: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85728: LD_VAR 0 1
85732: NOT
85733: PUSH
85734: LD_VAR 0 2
85738: NOT
85739: OR
85740: PUSH
85741: LD_VAR 0 1
85745: PPUSH
85746: CALL_OW 314
85750: OR
85751: IFFALSE 85755
// exit ;
85753: GO 86222
// if GetLives ( i ) < 250 then
85755: LD_VAR 0 4
85759: PPUSH
85760: CALL_OW 256
85764: PUSH
85765: LD_INT 250
85767: LESS
85768: IFFALSE 85781
// begin ComAutodestruct ( i ) ;
85770: LD_VAR 0 4
85774: PPUSH
85775: CALL 85618 0 1
// exit ;
85779: GO 86222
// end ; x := GetX ( enemy_unit ) ;
85781: LD_ADDR_VAR 0 7
85785: PUSH
85786: LD_VAR 0 2
85790: PPUSH
85791: CALL_OW 250
85795: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85796: LD_ADDR_VAR 0 8
85800: PUSH
85801: LD_VAR 0 2
85805: PPUSH
85806: CALL_OW 251
85810: ST_TO_ADDR
// if not x or not y then
85811: LD_VAR 0 7
85815: NOT
85816: PUSH
85817: LD_VAR 0 8
85821: NOT
85822: OR
85823: IFFALSE 85827
// exit ;
85825: GO 86222
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85827: LD_ADDR_VAR 0 6
85831: PUSH
85832: LD_VAR 0 7
85836: PPUSH
85837: LD_INT 0
85839: PPUSH
85840: LD_INT 4
85842: PPUSH
85843: CALL_OW 272
85847: PUSH
85848: LD_VAR 0 8
85852: PPUSH
85853: LD_INT 0
85855: PPUSH
85856: LD_INT 4
85858: PPUSH
85859: CALL_OW 273
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_VAR 0 7
85872: PPUSH
85873: LD_INT 1
85875: PPUSH
85876: LD_INT 4
85878: PPUSH
85879: CALL_OW 272
85883: PUSH
85884: LD_VAR 0 8
85888: PPUSH
85889: LD_INT 1
85891: PPUSH
85892: LD_INT 4
85894: PPUSH
85895: CALL_OW 273
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_VAR 0 7
85908: PPUSH
85909: LD_INT 2
85911: PPUSH
85912: LD_INT 4
85914: PPUSH
85915: CALL_OW 272
85919: PUSH
85920: LD_VAR 0 8
85924: PPUSH
85925: LD_INT 2
85927: PPUSH
85928: LD_INT 4
85930: PPUSH
85931: CALL_OW 273
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_VAR 0 7
85944: PPUSH
85945: LD_INT 3
85947: PPUSH
85948: LD_INT 4
85950: PPUSH
85951: CALL_OW 272
85955: PUSH
85956: LD_VAR 0 8
85960: PPUSH
85961: LD_INT 3
85963: PPUSH
85964: LD_INT 4
85966: PPUSH
85967: CALL_OW 273
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_VAR 0 7
85980: PPUSH
85981: LD_INT 4
85983: PPUSH
85984: LD_INT 4
85986: PPUSH
85987: CALL_OW 272
85991: PUSH
85992: LD_VAR 0 8
85996: PPUSH
85997: LD_INT 4
85999: PPUSH
86000: LD_INT 4
86002: PPUSH
86003: CALL_OW 273
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_VAR 0 7
86016: PPUSH
86017: LD_INT 5
86019: PPUSH
86020: LD_INT 4
86022: PPUSH
86023: CALL_OW 272
86027: PUSH
86028: LD_VAR 0 8
86032: PPUSH
86033: LD_INT 5
86035: PPUSH
86036: LD_INT 4
86038: PPUSH
86039: CALL_OW 273
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: ST_TO_ADDR
// for i = tmp downto 1 do
86056: LD_ADDR_VAR 0 4
86060: PUSH
86061: DOUBLE
86062: LD_VAR 0 6
86066: INC
86067: ST_TO_ADDR
86068: LD_INT 1
86070: PUSH
86071: FOR_DOWNTO
86072: IFFALSE 86173
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86074: LD_VAR 0 6
86078: PUSH
86079: LD_VAR 0 4
86083: ARRAY
86084: PUSH
86085: LD_INT 1
86087: ARRAY
86088: PPUSH
86089: LD_VAR 0 6
86093: PUSH
86094: LD_VAR 0 4
86098: ARRAY
86099: PUSH
86100: LD_INT 2
86102: ARRAY
86103: PPUSH
86104: CALL_OW 488
86108: NOT
86109: PUSH
86110: LD_VAR 0 6
86114: PUSH
86115: LD_VAR 0 4
86119: ARRAY
86120: PUSH
86121: LD_INT 1
86123: ARRAY
86124: PPUSH
86125: LD_VAR 0 6
86129: PUSH
86130: LD_VAR 0 4
86134: ARRAY
86135: PUSH
86136: LD_INT 2
86138: ARRAY
86139: PPUSH
86140: CALL_OW 428
86144: PUSH
86145: LD_INT 0
86147: NONEQUAL
86148: OR
86149: IFFALSE 86171
// tmp := Delete ( tmp , i ) ;
86151: LD_ADDR_VAR 0 6
86155: PUSH
86156: LD_VAR 0 6
86160: PPUSH
86161: LD_VAR 0 4
86165: PPUSH
86166: CALL_OW 3
86170: ST_TO_ADDR
86171: GO 86071
86173: POP
86174: POP
// j := GetClosestHex ( unit , tmp ) ;
86175: LD_ADDR_VAR 0 5
86179: PUSH
86180: LD_VAR 0 1
86184: PPUSH
86185: LD_VAR 0 6
86189: PPUSH
86190: CALL 85466 0 2
86194: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
86195: LD_VAR 0 1
86199: PPUSH
86200: LD_VAR 0 5
86204: PUSH
86205: LD_INT 1
86207: ARRAY
86208: PPUSH
86209: LD_VAR 0 5
86213: PUSH
86214: LD_INT 2
86216: ARRAY
86217: PPUSH
86218: CALL_OW 111
// end ;
86222: LD_VAR 0 3
86226: RET
// export function PrepareApemanSoldier ( ) ; begin
86227: LD_INT 0
86229: PPUSH
// uc_nation := 0 ;
86230: LD_ADDR_OWVAR 21
86234: PUSH
86235: LD_INT 0
86237: ST_TO_ADDR
// hc_sex := sex_male ;
86238: LD_ADDR_OWVAR 27
86242: PUSH
86243: LD_INT 1
86245: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
86246: LD_ADDR_OWVAR 28
86250: PUSH
86251: LD_INT 15
86253: ST_TO_ADDR
// hc_gallery :=  ;
86254: LD_ADDR_OWVAR 33
86258: PUSH
86259: LD_STRING 
86261: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86262: LD_ADDR_OWVAR 31
86266: PUSH
86267: LD_INT 0
86269: PPUSH
86270: LD_INT 3
86272: PPUSH
86273: CALL_OW 12
86277: PUSH
86278: LD_INT 0
86280: PPUSH
86281: LD_INT 3
86283: PPUSH
86284: CALL_OW 12
86288: PUSH
86289: LD_INT 0
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: ST_TO_ADDR
// end ;
86301: LD_VAR 0 1
86305: RET
// export function PrepareApemanEngineer ( ) ; begin
86306: LD_INT 0
86308: PPUSH
// uc_nation := 0 ;
86309: LD_ADDR_OWVAR 21
86313: PUSH
86314: LD_INT 0
86316: ST_TO_ADDR
// hc_sex := sex_male ;
86317: LD_ADDR_OWVAR 27
86321: PUSH
86322: LD_INT 1
86324: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
86325: LD_ADDR_OWVAR 28
86329: PUSH
86330: LD_INT 16
86332: ST_TO_ADDR
// hc_gallery :=  ;
86333: LD_ADDR_OWVAR 33
86337: PUSH
86338: LD_STRING 
86340: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86341: LD_ADDR_OWVAR 31
86345: PUSH
86346: LD_INT 0
86348: PPUSH
86349: LD_INT 3
86351: PPUSH
86352: CALL_OW 12
86356: PUSH
86357: LD_INT 0
86359: PPUSH
86360: LD_INT 3
86362: PPUSH
86363: CALL_OW 12
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: LD_INT 0
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: ST_TO_ADDR
// end ;
86380: LD_VAR 0 1
86384: RET
// export function PrepareApeman ( agressivity ) ; begin
86385: LD_INT 0
86387: PPUSH
// uc_side := 0 ;
86388: LD_ADDR_OWVAR 20
86392: PUSH
86393: LD_INT 0
86395: ST_TO_ADDR
// uc_nation := 0 ;
86396: LD_ADDR_OWVAR 21
86400: PUSH
86401: LD_INT 0
86403: ST_TO_ADDR
// hc_sex := sex_male ;
86404: LD_ADDR_OWVAR 27
86408: PUSH
86409: LD_INT 1
86411: ST_TO_ADDR
// hc_class := class_apeman ;
86412: LD_ADDR_OWVAR 28
86416: PUSH
86417: LD_INT 12
86419: ST_TO_ADDR
// hc_gallery :=  ;
86420: LD_ADDR_OWVAR 33
86424: PUSH
86425: LD_STRING 
86427: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86428: LD_ADDR_OWVAR 35
86432: PUSH
86433: LD_VAR 0 1
86437: NEG
86438: PPUSH
86439: LD_VAR 0 1
86443: PPUSH
86444: CALL_OW 12
86448: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86449: LD_ADDR_OWVAR 31
86453: PUSH
86454: LD_INT 0
86456: PPUSH
86457: LD_INT 3
86459: PPUSH
86460: CALL_OW 12
86464: PUSH
86465: LD_INT 0
86467: PPUSH
86468: LD_INT 3
86470: PPUSH
86471: CALL_OW 12
86475: PUSH
86476: LD_INT 0
86478: PUSH
86479: LD_INT 0
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: ST_TO_ADDR
// end ;
86488: LD_VAR 0 2
86492: RET
// export function PrepareTiger ( agressivity ) ; begin
86493: LD_INT 0
86495: PPUSH
// uc_side := 0 ;
86496: LD_ADDR_OWVAR 20
86500: PUSH
86501: LD_INT 0
86503: ST_TO_ADDR
// uc_nation := 0 ;
86504: LD_ADDR_OWVAR 21
86508: PUSH
86509: LD_INT 0
86511: ST_TO_ADDR
// hc_class := class_tiger ;
86512: LD_ADDR_OWVAR 28
86516: PUSH
86517: LD_INT 14
86519: ST_TO_ADDR
// hc_gallery :=  ;
86520: LD_ADDR_OWVAR 33
86524: PUSH
86525: LD_STRING 
86527: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86528: LD_ADDR_OWVAR 35
86532: PUSH
86533: LD_VAR 0 1
86537: NEG
86538: PPUSH
86539: LD_VAR 0 1
86543: PPUSH
86544: CALL_OW 12
86548: ST_TO_ADDR
// end ;
86549: LD_VAR 0 2
86553: RET
// export function PrepareEnchidna ( ) ; begin
86554: LD_INT 0
86556: PPUSH
// uc_side := 0 ;
86557: LD_ADDR_OWVAR 20
86561: PUSH
86562: LD_INT 0
86564: ST_TO_ADDR
// uc_nation := 0 ;
86565: LD_ADDR_OWVAR 21
86569: PUSH
86570: LD_INT 0
86572: ST_TO_ADDR
// hc_class := class_baggie ;
86573: LD_ADDR_OWVAR 28
86577: PUSH
86578: LD_INT 13
86580: ST_TO_ADDR
// hc_gallery :=  ;
86581: LD_ADDR_OWVAR 33
86585: PUSH
86586: LD_STRING 
86588: ST_TO_ADDR
// end ;
86589: LD_VAR 0 1
86593: RET
// export function PrepareFrog ( ) ; begin
86594: LD_INT 0
86596: PPUSH
// uc_side := 0 ;
86597: LD_ADDR_OWVAR 20
86601: PUSH
86602: LD_INT 0
86604: ST_TO_ADDR
// uc_nation := 0 ;
86605: LD_ADDR_OWVAR 21
86609: PUSH
86610: LD_INT 0
86612: ST_TO_ADDR
// hc_class := class_frog ;
86613: LD_ADDR_OWVAR 28
86617: PUSH
86618: LD_INT 19
86620: ST_TO_ADDR
// hc_gallery :=  ;
86621: LD_ADDR_OWVAR 33
86625: PUSH
86626: LD_STRING 
86628: ST_TO_ADDR
// end ;
86629: LD_VAR 0 1
86633: RET
// export function PrepareFish ( ) ; begin
86634: LD_INT 0
86636: PPUSH
// uc_side := 0 ;
86637: LD_ADDR_OWVAR 20
86641: PUSH
86642: LD_INT 0
86644: ST_TO_ADDR
// uc_nation := 0 ;
86645: LD_ADDR_OWVAR 21
86649: PUSH
86650: LD_INT 0
86652: ST_TO_ADDR
// hc_class := class_fish ;
86653: LD_ADDR_OWVAR 28
86657: PUSH
86658: LD_INT 20
86660: ST_TO_ADDR
// hc_gallery :=  ;
86661: LD_ADDR_OWVAR 33
86665: PUSH
86666: LD_STRING 
86668: ST_TO_ADDR
// end ;
86669: LD_VAR 0 1
86673: RET
// export function PrepareBird ( ) ; begin
86674: LD_INT 0
86676: PPUSH
// uc_side := 0 ;
86677: LD_ADDR_OWVAR 20
86681: PUSH
86682: LD_INT 0
86684: ST_TO_ADDR
// uc_nation := 0 ;
86685: LD_ADDR_OWVAR 21
86689: PUSH
86690: LD_INT 0
86692: ST_TO_ADDR
// hc_class := class_phororhacos ;
86693: LD_ADDR_OWVAR 28
86697: PUSH
86698: LD_INT 18
86700: ST_TO_ADDR
// hc_gallery :=  ;
86701: LD_ADDR_OWVAR 33
86705: PUSH
86706: LD_STRING 
86708: ST_TO_ADDR
// end ;
86709: LD_VAR 0 1
86713: RET
// export function PrepareHorse ( ) ; begin
86714: LD_INT 0
86716: PPUSH
// uc_side := 0 ;
86717: LD_ADDR_OWVAR 20
86721: PUSH
86722: LD_INT 0
86724: ST_TO_ADDR
// uc_nation := 0 ;
86725: LD_ADDR_OWVAR 21
86729: PUSH
86730: LD_INT 0
86732: ST_TO_ADDR
// hc_class := class_horse ;
86733: LD_ADDR_OWVAR 28
86737: PUSH
86738: LD_INT 21
86740: ST_TO_ADDR
// hc_gallery :=  ;
86741: LD_ADDR_OWVAR 33
86745: PUSH
86746: LD_STRING 
86748: ST_TO_ADDR
// end ;
86749: LD_VAR 0 1
86753: RET
// export function PrepareMastodont ( ) ; begin
86754: LD_INT 0
86756: PPUSH
// uc_side := 0 ;
86757: LD_ADDR_OWVAR 20
86761: PUSH
86762: LD_INT 0
86764: ST_TO_ADDR
// uc_nation := 0 ;
86765: LD_ADDR_OWVAR 21
86769: PUSH
86770: LD_INT 0
86772: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86773: LD_ADDR_OWVAR 37
86777: PUSH
86778: LD_INT 31
86780: ST_TO_ADDR
// vc_control := control_rider ;
86781: LD_ADDR_OWVAR 38
86785: PUSH
86786: LD_INT 4
86788: ST_TO_ADDR
// end ;
86789: LD_VAR 0 1
86793: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86794: LD_INT 0
86796: PPUSH
86797: PPUSH
86798: PPUSH
// uc_side = 0 ;
86799: LD_ADDR_OWVAR 20
86803: PUSH
86804: LD_INT 0
86806: ST_TO_ADDR
// uc_nation = 0 ;
86807: LD_ADDR_OWVAR 21
86811: PUSH
86812: LD_INT 0
86814: ST_TO_ADDR
// InitHc_All ( ) ;
86815: CALL_OW 584
// InitVc ;
86819: CALL_OW 20
// if mastodonts then
86823: LD_VAR 0 6
86827: IFFALSE 86894
// for i = 1 to mastodonts do
86829: LD_ADDR_VAR 0 11
86833: PUSH
86834: DOUBLE
86835: LD_INT 1
86837: DEC
86838: ST_TO_ADDR
86839: LD_VAR 0 6
86843: PUSH
86844: FOR_TO
86845: IFFALSE 86892
// begin vc_chassis := 31 ;
86847: LD_ADDR_OWVAR 37
86851: PUSH
86852: LD_INT 31
86854: ST_TO_ADDR
// vc_control := control_rider ;
86855: LD_ADDR_OWVAR 38
86859: PUSH
86860: LD_INT 4
86862: ST_TO_ADDR
// animal := CreateVehicle ;
86863: LD_ADDR_VAR 0 12
86867: PUSH
86868: CALL_OW 45
86872: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86873: LD_VAR 0 12
86877: PPUSH
86878: LD_VAR 0 8
86882: PPUSH
86883: LD_INT 0
86885: PPUSH
86886: CALL 89022 0 3
// end ;
86890: GO 86844
86892: POP
86893: POP
// if horses then
86894: LD_VAR 0 5
86898: IFFALSE 86965
// for i = 1 to horses do
86900: LD_ADDR_VAR 0 11
86904: PUSH
86905: DOUBLE
86906: LD_INT 1
86908: DEC
86909: ST_TO_ADDR
86910: LD_VAR 0 5
86914: PUSH
86915: FOR_TO
86916: IFFALSE 86963
// begin hc_class := 21 ;
86918: LD_ADDR_OWVAR 28
86922: PUSH
86923: LD_INT 21
86925: ST_TO_ADDR
// hc_gallery :=  ;
86926: LD_ADDR_OWVAR 33
86930: PUSH
86931: LD_STRING 
86933: ST_TO_ADDR
// animal := CreateHuman ;
86934: LD_ADDR_VAR 0 12
86938: PUSH
86939: CALL_OW 44
86943: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86944: LD_VAR 0 12
86948: PPUSH
86949: LD_VAR 0 8
86953: PPUSH
86954: LD_INT 0
86956: PPUSH
86957: CALL 89022 0 3
// end ;
86961: GO 86915
86963: POP
86964: POP
// if birds then
86965: LD_VAR 0 1
86969: IFFALSE 87036
// for i = 1 to birds do
86971: LD_ADDR_VAR 0 11
86975: PUSH
86976: DOUBLE
86977: LD_INT 1
86979: DEC
86980: ST_TO_ADDR
86981: LD_VAR 0 1
86985: PUSH
86986: FOR_TO
86987: IFFALSE 87034
// begin hc_class = 18 ;
86989: LD_ADDR_OWVAR 28
86993: PUSH
86994: LD_INT 18
86996: ST_TO_ADDR
// hc_gallery =  ;
86997: LD_ADDR_OWVAR 33
87001: PUSH
87002: LD_STRING 
87004: ST_TO_ADDR
// animal := CreateHuman ;
87005: LD_ADDR_VAR 0 12
87009: PUSH
87010: CALL_OW 44
87014: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87015: LD_VAR 0 12
87019: PPUSH
87020: LD_VAR 0 8
87024: PPUSH
87025: LD_INT 0
87027: PPUSH
87028: CALL 89022 0 3
// end ;
87032: GO 86986
87034: POP
87035: POP
// if tigers then
87036: LD_VAR 0 2
87040: IFFALSE 87124
// for i = 1 to tigers do
87042: LD_ADDR_VAR 0 11
87046: PUSH
87047: DOUBLE
87048: LD_INT 1
87050: DEC
87051: ST_TO_ADDR
87052: LD_VAR 0 2
87056: PUSH
87057: FOR_TO
87058: IFFALSE 87122
// begin hc_class = class_tiger ;
87060: LD_ADDR_OWVAR 28
87064: PUSH
87065: LD_INT 14
87067: ST_TO_ADDR
// hc_gallery =  ;
87068: LD_ADDR_OWVAR 33
87072: PUSH
87073: LD_STRING 
87075: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87076: LD_ADDR_OWVAR 35
87080: PUSH
87081: LD_INT 7
87083: NEG
87084: PPUSH
87085: LD_INT 7
87087: PPUSH
87088: CALL_OW 12
87092: ST_TO_ADDR
// animal := CreateHuman ;
87093: LD_ADDR_VAR 0 12
87097: PUSH
87098: CALL_OW 44
87102: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87103: LD_VAR 0 12
87107: PPUSH
87108: LD_VAR 0 8
87112: PPUSH
87113: LD_INT 0
87115: PPUSH
87116: CALL 89022 0 3
// end ;
87120: GO 87057
87122: POP
87123: POP
// if apemans then
87124: LD_VAR 0 3
87128: IFFALSE 87251
// for i = 1 to apemans do
87130: LD_ADDR_VAR 0 11
87134: PUSH
87135: DOUBLE
87136: LD_INT 1
87138: DEC
87139: ST_TO_ADDR
87140: LD_VAR 0 3
87144: PUSH
87145: FOR_TO
87146: IFFALSE 87249
// begin hc_class = class_apeman ;
87148: LD_ADDR_OWVAR 28
87152: PUSH
87153: LD_INT 12
87155: ST_TO_ADDR
// hc_gallery =  ;
87156: LD_ADDR_OWVAR 33
87160: PUSH
87161: LD_STRING 
87163: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
87164: LD_ADDR_OWVAR 35
87168: PUSH
87169: LD_INT 2
87171: NEG
87172: PPUSH
87173: LD_INT 2
87175: PPUSH
87176: CALL_OW 12
87180: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
87181: LD_ADDR_OWVAR 31
87185: PUSH
87186: LD_INT 1
87188: PPUSH
87189: LD_INT 3
87191: PPUSH
87192: CALL_OW 12
87196: PUSH
87197: LD_INT 1
87199: PPUSH
87200: LD_INT 3
87202: PPUSH
87203: CALL_OW 12
87207: PUSH
87208: LD_INT 0
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: ST_TO_ADDR
// animal := CreateHuman ;
87220: LD_ADDR_VAR 0 12
87224: PUSH
87225: CALL_OW 44
87229: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87230: LD_VAR 0 12
87234: PPUSH
87235: LD_VAR 0 8
87239: PPUSH
87240: LD_INT 0
87242: PPUSH
87243: CALL 89022 0 3
// end ;
87247: GO 87145
87249: POP
87250: POP
// if enchidnas then
87251: LD_VAR 0 4
87255: IFFALSE 87322
// for i = 1 to enchidnas do
87257: LD_ADDR_VAR 0 11
87261: PUSH
87262: DOUBLE
87263: LD_INT 1
87265: DEC
87266: ST_TO_ADDR
87267: LD_VAR 0 4
87271: PUSH
87272: FOR_TO
87273: IFFALSE 87320
// begin hc_class = 13 ;
87275: LD_ADDR_OWVAR 28
87279: PUSH
87280: LD_INT 13
87282: ST_TO_ADDR
// hc_gallery =  ;
87283: LD_ADDR_OWVAR 33
87287: PUSH
87288: LD_STRING 
87290: ST_TO_ADDR
// animal := CreateHuman ;
87291: LD_ADDR_VAR 0 12
87295: PUSH
87296: CALL_OW 44
87300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87301: LD_VAR 0 12
87305: PPUSH
87306: LD_VAR 0 8
87310: PPUSH
87311: LD_INT 0
87313: PPUSH
87314: CALL 89022 0 3
// end ;
87318: GO 87272
87320: POP
87321: POP
// if fishes then
87322: LD_VAR 0 7
87326: IFFALSE 87393
// for i = 1 to fishes do
87328: LD_ADDR_VAR 0 11
87332: PUSH
87333: DOUBLE
87334: LD_INT 1
87336: DEC
87337: ST_TO_ADDR
87338: LD_VAR 0 7
87342: PUSH
87343: FOR_TO
87344: IFFALSE 87391
// begin hc_class = 20 ;
87346: LD_ADDR_OWVAR 28
87350: PUSH
87351: LD_INT 20
87353: ST_TO_ADDR
// hc_gallery =  ;
87354: LD_ADDR_OWVAR 33
87358: PUSH
87359: LD_STRING 
87361: ST_TO_ADDR
// animal := CreateHuman ;
87362: LD_ADDR_VAR 0 12
87366: PUSH
87367: CALL_OW 44
87371: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
87372: LD_VAR 0 12
87376: PPUSH
87377: LD_VAR 0 9
87381: PPUSH
87382: LD_INT 0
87384: PPUSH
87385: CALL 89022 0 3
// end ;
87389: GO 87343
87391: POP
87392: POP
// end ;
87393: LD_VAR 0 10
87397: RET
// export function WantHeal ( sci , unit ) ; begin
87398: LD_INT 0
87400: PPUSH
// if GetTaskList ( sci ) > 0 then
87401: LD_VAR 0 1
87405: PPUSH
87406: CALL_OW 437
87410: PUSH
87411: LD_INT 0
87413: GREATER
87414: IFFALSE 87484
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
87416: LD_VAR 0 1
87420: PPUSH
87421: CALL_OW 437
87425: PUSH
87426: LD_INT 1
87428: ARRAY
87429: PUSH
87430: LD_INT 1
87432: ARRAY
87433: PUSH
87434: LD_STRING l
87436: EQUAL
87437: PUSH
87438: LD_VAR 0 1
87442: PPUSH
87443: CALL_OW 437
87447: PUSH
87448: LD_INT 1
87450: ARRAY
87451: PUSH
87452: LD_INT 4
87454: ARRAY
87455: PUSH
87456: LD_VAR 0 2
87460: EQUAL
87461: AND
87462: IFFALSE 87474
// result := true else
87464: LD_ADDR_VAR 0 3
87468: PUSH
87469: LD_INT 1
87471: ST_TO_ADDR
87472: GO 87482
// result := false ;
87474: LD_ADDR_VAR 0 3
87478: PUSH
87479: LD_INT 0
87481: ST_TO_ADDR
// end else
87482: GO 87492
// result := false ;
87484: LD_ADDR_VAR 0 3
87488: PUSH
87489: LD_INT 0
87491: ST_TO_ADDR
// end ;
87492: LD_VAR 0 3
87496: RET
// export function HealTarget ( sci ) ; begin
87497: LD_INT 0
87499: PPUSH
// if not sci then
87500: LD_VAR 0 1
87504: NOT
87505: IFFALSE 87509
// exit ;
87507: GO 87574
// result := 0 ;
87509: LD_ADDR_VAR 0 2
87513: PUSH
87514: LD_INT 0
87516: ST_TO_ADDR
// if GetTaskList ( sci ) then
87517: LD_VAR 0 1
87521: PPUSH
87522: CALL_OW 437
87526: IFFALSE 87574
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
87528: LD_VAR 0 1
87532: PPUSH
87533: CALL_OW 437
87537: PUSH
87538: LD_INT 1
87540: ARRAY
87541: PUSH
87542: LD_INT 1
87544: ARRAY
87545: PUSH
87546: LD_STRING l
87548: EQUAL
87549: IFFALSE 87574
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
87551: LD_ADDR_VAR 0 2
87555: PUSH
87556: LD_VAR 0 1
87560: PPUSH
87561: CALL_OW 437
87565: PUSH
87566: LD_INT 1
87568: ARRAY
87569: PUSH
87570: LD_INT 4
87572: ARRAY
87573: ST_TO_ADDR
// end ;
87574: LD_VAR 0 2
87578: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87579: LD_INT 0
87581: PPUSH
87582: PPUSH
87583: PPUSH
87584: PPUSH
// if not base_units then
87585: LD_VAR 0 1
87589: NOT
87590: IFFALSE 87594
// exit ;
87592: GO 87681
// result := false ;
87594: LD_ADDR_VAR 0 2
87598: PUSH
87599: LD_INT 0
87601: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87602: LD_ADDR_VAR 0 5
87606: PUSH
87607: LD_VAR 0 1
87611: PPUSH
87612: LD_INT 21
87614: PUSH
87615: LD_INT 3
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PPUSH
87622: CALL_OW 72
87626: ST_TO_ADDR
// if not tmp then
87627: LD_VAR 0 5
87631: NOT
87632: IFFALSE 87636
// exit ;
87634: GO 87681
// for i in tmp do
87636: LD_ADDR_VAR 0 3
87640: PUSH
87641: LD_VAR 0 5
87645: PUSH
87646: FOR_IN
87647: IFFALSE 87679
// begin result := EnemyInRange ( i , 22 ) ;
87649: LD_ADDR_VAR 0 2
87653: PUSH
87654: LD_VAR 0 3
87658: PPUSH
87659: LD_INT 22
87661: PPUSH
87662: CALL 85268 0 2
87666: ST_TO_ADDR
// if result then
87667: LD_VAR 0 2
87671: IFFALSE 87677
// exit ;
87673: POP
87674: POP
87675: GO 87681
// end ;
87677: GO 87646
87679: POP
87680: POP
// end ;
87681: LD_VAR 0 2
87685: RET
// export function FilterByTag ( units , tag ) ; begin
87686: LD_INT 0
87688: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87689: LD_ADDR_VAR 0 3
87693: PUSH
87694: LD_VAR 0 1
87698: PPUSH
87699: LD_INT 120
87701: PUSH
87702: LD_VAR 0 2
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PPUSH
87711: CALL_OW 72
87715: ST_TO_ADDR
// end ;
87716: LD_VAR 0 3
87720: RET
// export function IsDriver ( un ) ; begin
87721: LD_INT 0
87723: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87724: LD_ADDR_VAR 0 2
87728: PUSH
87729: LD_VAR 0 1
87733: PUSH
87734: LD_INT 55
87736: PUSH
87737: EMPTY
87738: LIST
87739: PPUSH
87740: CALL_OW 69
87744: IN
87745: ST_TO_ADDR
// end ;
87746: LD_VAR 0 2
87750: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87751: LD_INT 0
87753: PPUSH
87754: PPUSH
// list := [ ] ;
87755: LD_ADDR_VAR 0 5
87759: PUSH
87760: EMPTY
87761: ST_TO_ADDR
// case d of 0 :
87762: LD_VAR 0 3
87766: PUSH
87767: LD_INT 0
87769: DOUBLE
87770: EQUAL
87771: IFTRUE 87775
87773: GO 87908
87775: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87776: LD_ADDR_VAR 0 5
87780: PUSH
87781: LD_VAR 0 1
87785: PUSH
87786: LD_INT 4
87788: MINUS
87789: PUSH
87790: LD_VAR 0 2
87794: PUSH
87795: LD_INT 4
87797: MINUS
87798: PUSH
87799: LD_INT 2
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: LIST
87806: PUSH
87807: LD_VAR 0 1
87811: PUSH
87812: LD_INT 3
87814: MINUS
87815: PUSH
87816: LD_VAR 0 2
87820: PUSH
87821: LD_INT 1
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: LIST
87828: PUSH
87829: LD_VAR 0 1
87833: PUSH
87834: LD_INT 4
87836: PLUS
87837: PUSH
87838: LD_VAR 0 2
87842: PUSH
87843: LD_INT 4
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: LIST
87850: PUSH
87851: LD_VAR 0 1
87855: PUSH
87856: LD_INT 3
87858: PLUS
87859: PUSH
87860: LD_VAR 0 2
87864: PUSH
87865: LD_INT 3
87867: PLUS
87868: PUSH
87869: LD_INT 5
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: LIST
87876: PUSH
87877: LD_VAR 0 1
87881: PUSH
87882: LD_VAR 0 2
87886: PUSH
87887: LD_INT 4
87889: PLUS
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: LIST
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: ST_TO_ADDR
// end ; 1 :
87906: GO 88606
87908: LD_INT 1
87910: DOUBLE
87911: EQUAL
87912: IFTRUE 87916
87914: GO 88049
87916: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87917: LD_ADDR_VAR 0 5
87921: PUSH
87922: LD_VAR 0 1
87926: PUSH
87927: LD_VAR 0 2
87931: PUSH
87932: LD_INT 4
87934: MINUS
87935: PUSH
87936: LD_INT 3
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: LIST
87943: PUSH
87944: LD_VAR 0 1
87948: PUSH
87949: LD_INT 3
87951: MINUS
87952: PUSH
87953: LD_VAR 0 2
87957: PUSH
87958: LD_INT 3
87960: MINUS
87961: PUSH
87962: LD_INT 2
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: LIST
87969: PUSH
87970: LD_VAR 0 1
87974: PUSH
87975: LD_INT 4
87977: MINUS
87978: PUSH
87979: LD_VAR 0 2
87983: PUSH
87984: LD_INT 1
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: PUSH
87992: LD_VAR 0 1
87996: PUSH
87997: LD_VAR 0 2
88001: PUSH
88002: LD_INT 3
88004: PLUS
88005: PUSH
88006: LD_INT 0
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: LIST
88013: PUSH
88014: LD_VAR 0 1
88018: PUSH
88019: LD_INT 4
88021: PLUS
88022: PUSH
88023: LD_VAR 0 2
88027: PUSH
88028: LD_INT 4
88030: PLUS
88031: PUSH
88032: LD_INT 5
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: LIST
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: ST_TO_ADDR
// end ; 2 :
88047: GO 88606
88049: LD_INT 2
88051: DOUBLE
88052: EQUAL
88053: IFTRUE 88057
88055: GO 88186
88057: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88058: LD_ADDR_VAR 0 5
88062: PUSH
88063: LD_VAR 0 1
88067: PUSH
88068: LD_VAR 0 2
88072: PUSH
88073: LD_INT 3
88075: MINUS
88076: PUSH
88077: LD_INT 3
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: LIST
88084: PUSH
88085: LD_VAR 0 1
88089: PUSH
88090: LD_INT 4
88092: PLUS
88093: PUSH
88094: LD_VAR 0 2
88098: PUSH
88099: LD_INT 4
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: LIST
88106: PUSH
88107: LD_VAR 0 1
88111: PUSH
88112: LD_VAR 0 2
88116: PUSH
88117: LD_INT 4
88119: PLUS
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: LIST
88128: PUSH
88129: LD_VAR 0 1
88133: PUSH
88134: LD_INT 3
88136: MINUS
88137: PUSH
88138: LD_VAR 0 2
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: LIST
88150: PUSH
88151: LD_VAR 0 1
88155: PUSH
88156: LD_INT 4
88158: MINUS
88159: PUSH
88160: LD_VAR 0 2
88164: PUSH
88165: LD_INT 4
88167: MINUS
88168: PUSH
88169: LD_INT 2
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: LIST
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: ST_TO_ADDR
// end ; 3 :
88184: GO 88606
88186: LD_INT 3
88188: DOUBLE
88189: EQUAL
88190: IFTRUE 88194
88192: GO 88327
88194: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88195: LD_ADDR_VAR 0 5
88199: PUSH
88200: LD_VAR 0 1
88204: PUSH
88205: LD_INT 3
88207: PLUS
88208: PUSH
88209: LD_VAR 0 2
88213: PUSH
88214: LD_INT 4
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: LIST
88221: PUSH
88222: LD_VAR 0 1
88226: PUSH
88227: LD_INT 4
88229: PLUS
88230: PUSH
88231: LD_VAR 0 2
88235: PUSH
88236: LD_INT 4
88238: PLUS
88239: PUSH
88240: LD_INT 5
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: LIST
88247: PUSH
88248: LD_VAR 0 1
88252: PUSH
88253: LD_INT 4
88255: MINUS
88256: PUSH
88257: LD_VAR 0 2
88261: PUSH
88262: LD_INT 1
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: LIST
88269: PUSH
88270: LD_VAR 0 1
88274: PUSH
88275: LD_VAR 0 2
88279: PUSH
88280: LD_INT 4
88282: MINUS
88283: PUSH
88284: LD_INT 3
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: LIST
88291: PUSH
88292: LD_VAR 0 1
88296: PUSH
88297: LD_INT 3
88299: MINUS
88300: PUSH
88301: LD_VAR 0 2
88305: PUSH
88306: LD_INT 3
88308: MINUS
88309: PUSH
88310: LD_INT 2
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: LIST
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: ST_TO_ADDR
// end ; 4 :
88325: GO 88606
88327: LD_INT 4
88329: DOUBLE
88330: EQUAL
88331: IFTRUE 88335
88333: GO 88468
88335: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88336: LD_ADDR_VAR 0 5
88340: PUSH
88341: LD_VAR 0 1
88345: PUSH
88346: LD_VAR 0 2
88350: PUSH
88351: LD_INT 4
88353: PLUS
88354: PUSH
88355: LD_INT 0
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: LIST
88362: PUSH
88363: LD_VAR 0 1
88367: PUSH
88368: LD_INT 3
88370: PLUS
88371: PUSH
88372: LD_VAR 0 2
88376: PUSH
88377: LD_INT 3
88379: PLUS
88380: PUSH
88381: LD_INT 5
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: LIST
88388: PUSH
88389: LD_VAR 0 1
88393: PUSH
88394: LD_INT 4
88396: PLUS
88397: PUSH
88398: LD_VAR 0 2
88402: PUSH
88403: LD_INT 4
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: LIST
88410: PUSH
88411: LD_VAR 0 1
88415: PUSH
88416: LD_VAR 0 2
88420: PUSH
88421: LD_INT 3
88423: MINUS
88424: PUSH
88425: LD_INT 3
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: LIST
88432: PUSH
88433: LD_VAR 0 1
88437: PUSH
88438: LD_INT 4
88440: MINUS
88441: PUSH
88442: LD_VAR 0 2
88446: PUSH
88447: LD_INT 4
88449: MINUS
88450: PUSH
88451: LD_INT 2
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: LIST
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: ST_TO_ADDR
// end ; 5 :
88466: GO 88606
88468: LD_INT 5
88470: DOUBLE
88471: EQUAL
88472: IFTRUE 88476
88474: GO 88605
88476: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88477: LD_ADDR_VAR 0 5
88481: PUSH
88482: LD_VAR 0 1
88486: PUSH
88487: LD_INT 4
88489: MINUS
88490: PUSH
88491: LD_VAR 0 2
88495: PUSH
88496: LD_INT 1
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: LIST
88503: PUSH
88504: LD_VAR 0 1
88508: PUSH
88509: LD_VAR 0 2
88513: PUSH
88514: LD_INT 4
88516: MINUS
88517: PUSH
88518: LD_INT 3
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: LIST
88525: PUSH
88526: LD_VAR 0 1
88530: PUSH
88531: LD_INT 4
88533: PLUS
88534: PUSH
88535: LD_VAR 0 2
88539: PUSH
88540: LD_INT 4
88542: PLUS
88543: PUSH
88544: LD_INT 5
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: LIST
88551: PUSH
88552: LD_VAR 0 1
88556: PUSH
88557: LD_INT 3
88559: PLUS
88560: PUSH
88561: LD_VAR 0 2
88565: PUSH
88566: LD_INT 4
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: LIST
88573: PUSH
88574: LD_VAR 0 1
88578: PUSH
88579: LD_VAR 0 2
88583: PUSH
88584: LD_INT 3
88586: PLUS
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: LIST
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: ST_TO_ADDR
// end ; end ;
88603: GO 88606
88605: POP
// result := list ;
88606: LD_ADDR_VAR 0 4
88610: PUSH
88611: LD_VAR 0 5
88615: ST_TO_ADDR
// end ;
88616: LD_VAR 0 4
88620: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88621: LD_INT 0
88623: PPUSH
88624: PPUSH
88625: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88626: LD_VAR 0 1
88630: NOT
88631: PUSH
88632: LD_VAR 0 2
88636: PUSH
88637: LD_INT 1
88639: PUSH
88640: LD_INT 2
88642: PUSH
88643: LD_INT 3
88645: PUSH
88646: LD_INT 4
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: IN
88655: NOT
88656: OR
88657: IFFALSE 88661
// exit ;
88659: GO 88744
// tmp := [ ] ;
88661: LD_ADDR_VAR 0 5
88665: PUSH
88666: EMPTY
88667: ST_TO_ADDR
// for i in units do
88668: LD_ADDR_VAR 0 4
88672: PUSH
88673: LD_VAR 0 1
88677: PUSH
88678: FOR_IN
88679: IFFALSE 88713
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
88681: LD_ADDR_VAR 0 5
88685: PUSH
88686: LD_VAR 0 5
88690: PPUSH
88691: LD_VAR 0 4
88695: PPUSH
88696: LD_VAR 0 2
88700: PPUSH
88701: CALL_OW 259
88705: PPUSH
88706: CALL 90104 0 2
88710: ST_TO_ADDR
88711: GO 88678
88713: POP
88714: POP
// if not tmp then
88715: LD_VAR 0 5
88719: NOT
88720: IFFALSE 88724
// exit ;
88722: GO 88744
// result := SortListByListDesc ( units , tmp ) ;
88724: LD_ADDR_VAR 0 3
88728: PUSH
88729: LD_VAR 0 1
88733: PPUSH
88734: LD_VAR 0 5
88738: PPUSH
88739: CALL_OW 77
88743: ST_TO_ADDR
// end ;
88744: LD_VAR 0 3
88748: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88749: LD_INT 0
88751: PPUSH
88752: PPUSH
88753: PPUSH
// result := false ;
88754: LD_ADDR_VAR 0 3
88758: PUSH
88759: LD_INT 0
88761: ST_TO_ADDR
// if not building then
88762: LD_VAR 0 2
88766: NOT
88767: IFFALSE 88771
// exit ;
88769: GO 88909
// x := GetX ( building ) ;
88771: LD_ADDR_VAR 0 4
88775: PUSH
88776: LD_VAR 0 2
88780: PPUSH
88781: CALL_OW 250
88785: ST_TO_ADDR
// y := GetY ( building ) ;
88786: LD_ADDR_VAR 0 5
88790: PUSH
88791: LD_VAR 0 2
88795: PPUSH
88796: CALL_OW 251
88800: ST_TO_ADDR
// if not x or not y then
88801: LD_VAR 0 4
88805: NOT
88806: PUSH
88807: LD_VAR 0 5
88811: NOT
88812: OR
88813: IFFALSE 88817
// exit ;
88815: GO 88909
// if GetTaskList ( unit ) then
88817: LD_VAR 0 1
88821: PPUSH
88822: CALL_OW 437
88826: IFFALSE 88909
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88828: LD_STRING e
88830: PUSH
88831: LD_VAR 0 1
88835: PPUSH
88836: CALL_OW 437
88840: PUSH
88841: LD_INT 1
88843: ARRAY
88844: PUSH
88845: LD_INT 1
88847: ARRAY
88848: EQUAL
88849: PUSH
88850: LD_VAR 0 4
88854: PUSH
88855: LD_VAR 0 1
88859: PPUSH
88860: CALL_OW 437
88864: PUSH
88865: LD_INT 1
88867: ARRAY
88868: PUSH
88869: LD_INT 2
88871: ARRAY
88872: EQUAL
88873: AND
88874: PUSH
88875: LD_VAR 0 5
88879: PUSH
88880: LD_VAR 0 1
88884: PPUSH
88885: CALL_OW 437
88889: PUSH
88890: LD_INT 1
88892: ARRAY
88893: PUSH
88894: LD_INT 3
88896: ARRAY
88897: EQUAL
88898: AND
88899: IFFALSE 88909
// result := true end ;
88901: LD_ADDR_VAR 0 3
88905: PUSH
88906: LD_INT 1
88908: ST_TO_ADDR
// end ;
88909: LD_VAR 0 3
88913: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88914: LD_INT 0
88916: PPUSH
// result := false ;
88917: LD_ADDR_VAR 0 4
88921: PUSH
88922: LD_INT 0
88924: ST_TO_ADDR
// if GetTaskList ( unit ) then
88925: LD_VAR 0 1
88929: PPUSH
88930: CALL_OW 437
88934: IFFALSE 89017
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88936: LD_STRING M
88938: PUSH
88939: LD_VAR 0 1
88943: PPUSH
88944: CALL_OW 437
88948: PUSH
88949: LD_INT 1
88951: ARRAY
88952: PUSH
88953: LD_INT 1
88955: ARRAY
88956: EQUAL
88957: PUSH
88958: LD_VAR 0 2
88962: PUSH
88963: LD_VAR 0 1
88967: PPUSH
88968: CALL_OW 437
88972: PUSH
88973: LD_INT 1
88975: ARRAY
88976: PUSH
88977: LD_INT 2
88979: ARRAY
88980: EQUAL
88981: AND
88982: PUSH
88983: LD_VAR 0 3
88987: PUSH
88988: LD_VAR 0 1
88992: PPUSH
88993: CALL_OW 437
88997: PUSH
88998: LD_INT 1
89000: ARRAY
89001: PUSH
89002: LD_INT 3
89004: ARRAY
89005: EQUAL
89006: AND
89007: IFFALSE 89017
// result := true ;
89009: LD_ADDR_VAR 0 4
89013: PUSH
89014: LD_INT 1
89016: ST_TO_ADDR
// end ; end ;
89017: LD_VAR 0 4
89021: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89022: LD_INT 0
89024: PPUSH
89025: PPUSH
89026: PPUSH
89027: PPUSH
// if not unit or not area then
89028: LD_VAR 0 1
89032: NOT
89033: PUSH
89034: LD_VAR 0 2
89038: NOT
89039: OR
89040: IFFALSE 89044
// exit ;
89042: GO 89207
// tmp := AreaToList ( area , i ) ;
89044: LD_ADDR_VAR 0 6
89048: PUSH
89049: LD_VAR 0 2
89053: PPUSH
89054: LD_VAR 0 5
89058: PPUSH
89059: CALL_OW 517
89063: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89064: LD_ADDR_VAR 0 5
89068: PUSH
89069: DOUBLE
89070: LD_INT 1
89072: DEC
89073: ST_TO_ADDR
89074: LD_VAR 0 6
89078: PUSH
89079: LD_INT 1
89081: ARRAY
89082: PUSH
89083: FOR_TO
89084: IFFALSE 89205
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89086: LD_ADDR_VAR 0 7
89090: PUSH
89091: LD_VAR 0 6
89095: PUSH
89096: LD_INT 1
89098: ARRAY
89099: PUSH
89100: LD_VAR 0 5
89104: ARRAY
89105: PUSH
89106: LD_VAR 0 6
89110: PUSH
89111: LD_INT 2
89113: ARRAY
89114: PUSH
89115: LD_VAR 0 5
89119: ARRAY
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
89125: LD_INT 92
89127: PUSH
89128: LD_VAR 0 7
89132: PUSH
89133: LD_INT 1
89135: ARRAY
89136: PUSH
89137: LD_VAR 0 7
89141: PUSH
89142: LD_INT 2
89144: ARRAY
89145: PUSH
89146: LD_INT 3
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: PPUSH
89155: CALL_OW 69
89159: PUSH
89160: LD_INT 0
89162: EQUAL
89163: IFFALSE 89203
// begin PlaceUnitArea ( unit , area , mode ) ;
89165: LD_VAR 0 1
89169: PPUSH
89170: LD_VAR 0 2
89174: PPUSH
89175: LD_VAR 0 3
89179: PPUSH
89180: CALL_OW 49
// result := IsPlaced ( unit ) ;
89184: LD_ADDR_VAR 0 4
89188: PUSH
89189: LD_VAR 0 1
89193: PPUSH
89194: CALL_OW 305
89198: ST_TO_ADDR
// exit ;
89199: POP
89200: POP
89201: GO 89207
// end ; end ;
89203: GO 89083
89205: POP
89206: POP
// end ;
89207: LD_VAR 0 4
89211: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89212: LD_INT 0
89214: PPUSH
89215: PPUSH
89216: PPUSH
// if not side or side > 8 then
89217: LD_VAR 0 1
89221: NOT
89222: PUSH
89223: LD_VAR 0 1
89227: PUSH
89228: LD_INT 8
89230: GREATER
89231: OR
89232: IFFALSE 89236
// exit ;
89234: GO 89423
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89236: LD_ADDR_VAR 0 4
89240: PUSH
89241: LD_INT 22
89243: PUSH
89244: LD_VAR 0 1
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 21
89255: PUSH
89256: LD_INT 3
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PPUSH
89267: CALL_OW 69
89271: ST_TO_ADDR
// if not tmp then
89272: LD_VAR 0 4
89276: NOT
89277: IFFALSE 89281
// exit ;
89279: GO 89423
// enable_addtolog := true ;
89281: LD_ADDR_OWVAR 81
89285: PUSH
89286: LD_INT 1
89288: ST_TO_ADDR
// AddToLog ( [ ) ;
89289: LD_STRING [
89291: PPUSH
89292: CALL_OW 561
// for i in tmp do
89296: LD_ADDR_VAR 0 3
89300: PUSH
89301: LD_VAR 0 4
89305: PUSH
89306: FOR_IN
89307: IFFALSE 89414
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89309: LD_STRING [
89311: PUSH
89312: LD_VAR 0 3
89316: PPUSH
89317: CALL_OW 266
89321: STR
89322: PUSH
89323: LD_STRING , 
89325: STR
89326: PUSH
89327: LD_VAR 0 3
89331: PPUSH
89332: CALL_OW 250
89336: STR
89337: PUSH
89338: LD_STRING , 
89340: STR
89341: PUSH
89342: LD_VAR 0 3
89346: PPUSH
89347: CALL_OW 251
89351: STR
89352: PUSH
89353: LD_STRING , 
89355: STR
89356: PUSH
89357: LD_VAR 0 3
89361: PPUSH
89362: CALL_OW 254
89366: STR
89367: PUSH
89368: LD_STRING , 
89370: STR
89371: PUSH
89372: LD_VAR 0 3
89376: PPUSH
89377: LD_INT 1
89379: PPUSH
89380: CALL_OW 268
89384: STR
89385: PUSH
89386: LD_STRING , 
89388: STR
89389: PUSH
89390: LD_VAR 0 3
89394: PPUSH
89395: LD_INT 2
89397: PPUSH
89398: CALL_OW 268
89402: STR
89403: PUSH
89404: LD_STRING ],
89406: STR
89407: PPUSH
89408: CALL_OW 561
// end ;
89412: GO 89306
89414: POP
89415: POP
// AddToLog ( ]; ) ;
89416: LD_STRING ];
89418: PPUSH
89419: CALL_OW 561
// end ;
89423: LD_VAR 0 2
89427: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89428: LD_INT 0
89430: PPUSH
89431: PPUSH
89432: PPUSH
89433: PPUSH
89434: PPUSH
// if not area or not rate or not max then
89435: LD_VAR 0 1
89439: NOT
89440: PUSH
89441: LD_VAR 0 2
89445: NOT
89446: OR
89447: PUSH
89448: LD_VAR 0 4
89452: NOT
89453: OR
89454: IFFALSE 89458
// exit ;
89456: GO 89647
// while 1 do
89458: LD_INT 1
89460: IFFALSE 89647
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89462: LD_ADDR_VAR 0 9
89466: PUSH
89467: LD_VAR 0 1
89471: PPUSH
89472: LD_INT 1
89474: PPUSH
89475: CALL_OW 287
89479: PUSH
89480: LD_INT 10
89482: MUL
89483: ST_TO_ADDR
// r := rate / 10 ;
89484: LD_ADDR_VAR 0 7
89488: PUSH
89489: LD_VAR 0 2
89493: PUSH
89494: LD_INT 10
89496: DIVREAL
89497: ST_TO_ADDR
// time := 1 1$00 ;
89498: LD_ADDR_VAR 0 8
89502: PUSH
89503: LD_INT 2100
89505: ST_TO_ADDR
// if amount < min then
89506: LD_VAR 0 9
89510: PUSH
89511: LD_VAR 0 3
89515: LESS
89516: IFFALSE 89534
// r := r * 2 else
89518: LD_ADDR_VAR 0 7
89522: PUSH
89523: LD_VAR 0 7
89527: PUSH
89528: LD_INT 2
89530: MUL
89531: ST_TO_ADDR
89532: GO 89560
// if amount > max then
89534: LD_VAR 0 9
89538: PUSH
89539: LD_VAR 0 4
89543: GREATER
89544: IFFALSE 89560
// r := r / 2 ;
89546: LD_ADDR_VAR 0 7
89550: PUSH
89551: LD_VAR 0 7
89555: PUSH
89556: LD_INT 2
89558: DIVREAL
89559: ST_TO_ADDR
// time := time / r ;
89560: LD_ADDR_VAR 0 8
89564: PUSH
89565: LD_VAR 0 8
89569: PUSH
89570: LD_VAR 0 7
89574: DIVREAL
89575: ST_TO_ADDR
// if time < 0 then
89576: LD_VAR 0 8
89580: PUSH
89581: LD_INT 0
89583: LESS
89584: IFFALSE 89601
// time := time * - 1 ;
89586: LD_ADDR_VAR 0 8
89590: PUSH
89591: LD_VAR 0 8
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: MUL
89600: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
89601: LD_VAR 0 8
89605: PUSH
89606: LD_INT 35
89608: PPUSH
89609: LD_INT 875
89611: PPUSH
89612: CALL_OW 12
89616: PLUS
89617: PPUSH
89618: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89622: LD_INT 1
89624: PPUSH
89625: LD_INT 5
89627: PPUSH
89628: CALL_OW 12
89632: PPUSH
89633: LD_VAR 0 1
89637: PPUSH
89638: LD_INT 1
89640: PPUSH
89641: CALL_OW 55
// end ;
89645: GO 89458
// end ;
89647: LD_VAR 0 5
89651: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89652: LD_INT 0
89654: PPUSH
89655: PPUSH
89656: PPUSH
89657: PPUSH
89658: PPUSH
89659: PPUSH
89660: PPUSH
89661: PPUSH
// if not turrets or not factories then
89662: LD_VAR 0 1
89666: NOT
89667: PUSH
89668: LD_VAR 0 2
89672: NOT
89673: OR
89674: IFFALSE 89678
// exit ;
89676: GO 89985
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89678: LD_ADDR_VAR 0 10
89682: PUSH
89683: LD_INT 5
89685: PUSH
89686: LD_INT 6
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 2
89695: PUSH
89696: LD_INT 4
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 3
89705: PUSH
89706: LD_INT 5
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 24
89720: PUSH
89721: LD_INT 25
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 23
89730: PUSH
89731: LD_INT 27
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 42
89744: PUSH
89745: LD_INT 43
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 44
89754: PUSH
89755: LD_INT 46
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 45
89764: PUSH
89765: LD_INT 47
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: LIST
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: LIST
89781: ST_TO_ADDR
// result := [ ] ;
89782: LD_ADDR_VAR 0 3
89786: PUSH
89787: EMPTY
89788: ST_TO_ADDR
// for i in turrets do
89789: LD_ADDR_VAR 0 4
89793: PUSH
89794: LD_VAR 0 1
89798: PUSH
89799: FOR_IN
89800: IFFALSE 89983
// begin nat := GetNation ( i ) ;
89802: LD_ADDR_VAR 0 7
89806: PUSH
89807: LD_VAR 0 4
89811: PPUSH
89812: CALL_OW 248
89816: ST_TO_ADDR
// weapon := 0 ;
89817: LD_ADDR_VAR 0 8
89821: PUSH
89822: LD_INT 0
89824: ST_TO_ADDR
// if not nat then
89825: LD_VAR 0 7
89829: NOT
89830: IFFALSE 89834
// continue ;
89832: GO 89799
// for j in list [ nat ] do
89834: LD_ADDR_VAR 0 5
89838: PUSH
89839: LD_VAR 0 10
89843: PUSH
89844: LD_VAR 0 7
89848: ARRAY
89849: PUSH
89850: FOR_IN
89851: IFFALSE 89892
// if GetBWeapon ( i ) = j [ 1 ] then
89853: LD_VAR 0 4
89857: PPUSH
89858: CALL_OW 269
89862: PUSH
89863: LD_VAR 0 5
89867: PUSH
89868: LD_INT 1
89870: ARRAY
89871: EQUAL
89872: IFFALSE 89890
// begin weapon := j [ 2 ] ;
89874: LD_ADDR_VAR 0 8
89878: PUSH
89879: LD_VAR 0 5
89883: PUSH
89884: LD_INT 2
89886: ARRAY
89887: ST_TO_ADDR
// break ;
89888: GO 89892
// end ;
89890: GO 89850
89892: POP
89893: POP
// if not weapon then
89894: LD_VAR 0 8
89898: NOT
89899: IFFALSE 89903
// continue ;
89901: GO 89799
// for k in factories do
89903: LD_ADDR_VAR 0 6
89907: PUSH
89908: LD_VAR 0 2
89912: PUSH
89913: FOR_IN
89914: IFFALSE 89979
// begin weapons := AvailableWeaponList ( k ) ;
89916: LD_ADDR_VAR 0 9
89920: PUSH
89921: LD_VAR 0 6
89925: PPUSH
89926: CALL_OW 478
89930: ST_TO_ADDR
// if not weapons then
89931: LD_VAR 0 9
89935: NOT
89936: IFFALSE 89940
// continue ;
89938: GO 89913
// if weapon in weapons then
89940: LD_VAR 0 8
89944: PUSH
89945: LD_VAR 0 9
89949: IN
89950: IFFALSE 89977
// begin result := [ i , weapon ] ;
89952: LD_ADDR_VAR 0 3
89956: PUSH
89957: LD_VAR 0 4
89961: PUSH
89962: LD_VAR 0 8
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: ST_TO_ADDR
// exit ;
89971: POP
89972: POP
89973: POP
89974: POP
89975: GO 89985
// end ; end ;
89977: GO 89913
89979: POP
89980: POP
// end ;
89981: GO 89799
89983: POP
89984: POP
// end ;
89985: LD_VAR 0 3
89989: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89990: LD_INT 0
89992: PPUSH
// if not side or side > 8 then
89993: LD_VAR 0 3
89997: NOT
89998: PUSH
89999: LD_VAR 0 3
90003: PUSH
90004: LD_INT 8
90006: GREATER
90007: OR
90008: IFFALSE 90012
// exit ;
90010: GO 90071
// if not range then
90012: LD_VAR 0 4
90016: NOT
90017: IFFALSE 90028
// range := - 12 ;
90019: LD_ADDR_VAR 0 4
90023: PUSH
90024: LD_INT 12
90026: NEG
90027: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90028: LD_VAR 0 1
90032: PPUSH
90033: LD_VAR 0 2
90037: PPUSH
90038: LD_VAR 0 3
90042: PPUSH
90043: LD_VAR 0 4
90047: PPUSH
90048: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90052: LD_VAR 0 1
90056: PPUSH
90057: LD_VAR 0 2
90061: PPUSH
90062: LD_VAR 0 3
90066: PPUSH
90067: CALL_OW 331
// end ;
90071: LD_VAR 0 5
90075: RET
// export function Video ( mode ) ; begin
90076: LD_INT 0
90078: PPUSH
// ingame_video = mode ;
90079: LD_ADDR_OWVAR 52
90083: PUSH
90084: LD_VAR 0 1
90088: ST_TO_ADDR
// interface_hidden = mode ;
90089: LD_ADDR_OWVAR 54
90093: PUSH
90094: LD_VAR 0 1
90098: ST_TO_ADDR
// end ;
90099: LD_VAR 0 2
90103: RET
// export function Join ( array , element ) ; begin
90104: LD_INT 0
90106: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90107: LD_ADDR_VAR 0 3
90111: PUSH
90112: LD_VAR 0 1
90116: PPUSH
90117: LD_VAR 0 1
90121: PUSH
90122: LD_INT 1
90124: PLUS
90125: PPUSH
90126: LD_VAR 0 2
90130: PPUSH
90131: CALL_OW 1
90135: ST_TO_ADDR
// end ;
90136: LD_VAR 0 3
90140: RET
// export function JoinUnion ( array , element ) ; begin
90141: LD_INT 0
90143: PPUSH
// result := array union element ;
90144: LD_ADDR_VAR 0 3
90148: PUSH
90149: LD_VAR 0 1
90153: PUSH
90154: LD_VAR 0 2
90158: UNION
90159: ST_TO_ADDR
// end ;
90160: LD_VAR 0 3
90164: RET
// export function GetBehemoths ( side ) ; begin
90165: LD_INT 0
90167: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
90168: LD_ADDR_VAR 0 2
90172: PUSH
90173: LD_INT 22
90175: PUSH
90176: LD_VAR 0 1
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: PUSH
90185: LD_INT 31
90187: PUSH
90188: LD_INT 25
90190: PUSH
90191: EMPTY
90192: LIST
90193: LIST
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PPUSH
90199: CALL_OW 69
90203: ST_TO_ADDR
// end ;
90204: LD_VAR 0 2
90208: RET
// export function Shuffle ( array ) ; var i , index ; begin
90209: LD_INT 0
90211: PPUSH
90212: PPUSH
90213: PPUSH
// result := [ ] ;
90214: LD_ADDR_VAR 0 2
90218: PUSH
90219: EMPTY
90220: ST_TO_ADDR
// if not array then
90221: LD_VAR 0 1
90225: NOT
90226: IFFALSE 90230
// exit ;
90228: GO 90329
// Randomize ;
90230: CALL_OW 10
// for i = array downto 1 do
90234: LD_ADDR_VAR 0 3
90238: PUSH
90239: DOUBLE
90240: LD_VAR 0 1
90244: INC
90245: ST_TO_ADDR
90246: LD_INT 1
90248: PUSH
90249: FOR_DOWNTO
90250: IFFALSE 90327
// begin index := rand ( 1 , array ) ;
90252: LD_ADDR_VAR 0 4
90256: PUSH
90257: LD_INT 1
90259: PPUSH
90260: LD_VAR 0 1
90264: PPUSH
90265: CALL_OW 12
90269: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90270: LD_ADDR_VAR 0 2
90274: PUSH
90275: LD_VAR 0 2
90279: PPUSH
90280: LD_VAR 0 2
90284: PUSH
90285: LD_INT 1
90287: PLUS
90288: PPUSH
90289: LD_VAR 0 1
90293: PUSH
90294: LD_VAR 0 4
90298: ARRAY
90299: PPUSH
90300: CALL_OW 2
90304: ST_TO_ADDR
// array := Delete ( array , index ) ;
90305: LD_ADDR_VAR 0 1
90309: PUSH
90310: LD_VAR 0 1
90314: PPUSH
90315: LD_VAR 0 4
90319: PPUSH
90320: CALL_OW 3
90324: ST_TO_ADDR
// end ;
90325: GO 90249
90327: POP
90328: POP
// end ;
90329: LD_VAR 0 2
90333: RET
// export function GetBaseMaterials ( base ) ; begin
90334: LD_INT 0
90336: PPUSH
// result := [ 0 , 0 , 0 ] ;
90337: LD_ADDR_VAR 0 2
90341: PUSH
90342: LD_INT 0
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: LIST
90355: ST_TO_ADDR
// if not base then
90356: LD_VAR 0 1
90360: NOT
90361: IFFALSE 90365
// exit ;
90363: GO 90414
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90365: LD_ADDR_VAR 0 2
90369: PUSH
90370: LD_VAR 0 1
90374: PPUSH
90375: LD_INT 1
90377: PPUSH
90378: CALL_OW 275
90382: PUSH
90383: LD_VAR 0 1
90387: PPUSH
90388: LD_INT 2
90390: PPUSH
90391: CALL_OW 275
90395: PUSH
90396: LD_VAR 0 1
90400: PPUSH
90401: LD_INT 3
90403: PPUSH
90404: CALL_OW 275
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: LIST
90413: ST_TO_ADDR
// end ;
90414: LD_VAR 0 2
90418: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
90419: LD_INT 0
90421: PPUSH
90422: PPUSH
// result := array ;
90423: LD_ADDR_VAR 0 3
90427: PUSH
90428: LD_VAR 0 1
90432: ST_TO_ADDR
// if size >= result then
90433: LD_VAR 0 2
90437: PUSH
90438: LD_VAR 0 3
90442: GREATEREQUAL
90443: IFFALSE 90447
// exit ;
90445: GO 90497
// if size then
90447: LD_VAR 0 2
90451: IFFALSE 90497
// for i := array downto size do
90453: LD_ADDR_VAR 0 4
90457: PUSH
90458: DOUBLE
90459: LD_VAR 0 1
90463: INC
90464: ST_TO_ADDR
90465: LD_VAR 0 2
90469: PUSH
90470: FOR_DOWNTO
90471: IFFALSE 90495
// result := Delete ( result , result ) ;
90473: LD_ADDR_VAR 0 3
90477: PUSH
90478: LD_VAR 0 3
90482: PPUSH
90483: LD_VAR 0 3
90487: PPUSH
90488: CALL_OW 3
90492: ST_TO_ADDR
90493: GO 90470
90495: POP
90496: POP
// end ;
90497: LD_VAR 0 3
90501: RET
// export function ComExit ( unit ) ; var tmp ; begin
90502: LD_INT 0
90504: PPUSH
90505: PPUSH
// if not IsInUnit ( unit ) then
90506: LD_VAR 0 1
90510: PPUSH
90511: CALL_OW 310
90515: NOT
90516: IFFALSE 90520
// exit ;
90518: GO 90580
// tmp := IsInUnit ( unit ) ;
90520: LD_ADDR_VAR 0 3
90524: PUSH
90525: LD_VAR 0 1
90529: PPUSH
90530: CALL_OW 310
90534: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
90535: LD_VAR 0 3
90539: PPUSH
90540: CALL_OW 247
90544: PUSH
90545: LD_INT 2
90547: EQUAL
90548: IFFALSE 90561
// ComExitVehicle ( unit ) else
90550: LD_VAR 0 1
90554: PPUSH
90555: CALL_OW 121
90559: GO 90570
// ComExitBuilding ( unit ) ;
90561: LD_VAR 0 1
90565: PPUSH
90566: CALL_OW 122
// result := tmp ;
90570: LD_ADDR_VAR 0 2
90574: PUSH
90575: LD_VAR 0 3
90579: ST_TO_ADDR
// end ;
90580: LD_VAR 0 2
90584: RET
// export function ComExitAll ( units ) ; var i ; begin
90585: LD_INT 0
90587: PPUSH
90588: PPUSH
// if not units then
90589: LD_VAR 0 1
90593: NOT
90594: IFFALSE 90598
// exit ;
90596: GO 90624
// for i in units do
90598: LD_ADDR_VAR 0 3
90602: PUSH
90603: LD_VAR 0 1
90607: PUSH
90608: FOR_IN
90609: IFFALSE 90622
// ComExit ( i ) ;
90611: LD_VAR 0 3
90615: PPUSH
90616: CALL 90502 0 1
90620: GO 90608
90622: POP
90623: POP
// end ;
90624: LD_VAR 0 2
90628: RET
// export function ResetHc ; begin
90629: LD_INT 0
90631: PPUSH
// InitHc ;
90632: CALL_OW 19
// hc_importance := 0 ;
90636: LD_ADDR_OWVAR 32
90640: PUSH
90641: LD_INT 0
90643: ST_TO_ADDR
// end ;
90644: LD_VAR 0 1
90648: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
90649: LD_INT 0
90651: PPUSH
90652: PPUSH
90653: PPUSH
// _x := ( x1 + x2 ) div 2 ;
90654: LD_ADDR_VAR 0 6
90658: PUSH
90659: LD_VAR 0 1
90663: PUSH
90664: LD_VAR 0 3
90668: PLUS
90669: PUSH
90670: LD_INT 2
90672: DIV
90673: ST_TO_ADDR
// if _x < 0 then
90674: LD_VAR 0 6
90678: PUSH
90679: LD_INT 0
90681: LESS
90682: IFFALSE 90699
// _x := _x * - 1 ;
90684: LD_ADDR_VAR 0 6
90688: PUSH
90689: LD_VAR 0 6
90693: PUSH
90694: LD_INT 1
90696: NEG
90697: MUL
90698: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90699: LD_ADDR_VAR 0 7
90703: PUSH
90704: LD_VAR 0 2
90708: PUSH
90709: LD_VAR 0 4
90713: PLUS
90714: PUSH
90715: LD_INT 2
90717: DIV
90718: ST_TO_ADDR
// if _y < 0 then
90719: LD_VAR 0 7
90723: PUSH
90724: LD_INT 0
90726: LESS
90727: IFFALSE 90744
// _y := _y * - 1 ;
90729: LD_ADDR_VAR 0 7
90733: PUSH
90734: LD_VAR 0 7
90738: PUSH
90739: LD_INT 1
90741: NEG
90742: MUL
90743: ST_TO_ADDR
// result := [ _x , _y ] ;
90744: LD_ADDR_VAR 0 5
90748: PUSH
90749: LD_VAR 0 6
90753: PUSH
90754: LD_VAR 0 7
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: ST_TO_ADDR
// end ;
90763: LD_VAR 0 5
90767: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90768: LD_INT 0
90770: PPUSH
90771: PPUSH
90772: PPUSH
90773: PPUSH
// task := GetTaskList ( unit ) ;
90774: LD_ADDR_VAR 0 7
90778: PUSH
90779: LD_VAR 0 1
90783: PPUSH
90784: CALL_OW 437
90788: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90789: LD_VAR 0 7
90793: NOT
90794: PUSH
90795: LD_VAR 0 1
90799: PPUSH
90800: LD_VAR 0 2
90804: PPUSH
90805: CALL_OW 308
90809: NOT
90810: AND
90811: IFFALSE 90815
// exit ;
90813: GO 90933
// if IsInArea ( unit , area ) then
90815: LD_VAR 0 1
90819: PPUSH
90820: LD_VAR 0 2
90824: PPUSH
90825: CALL_OW 308
90829: IFFALSE 90847
// begin ComMoveToArea ( unit , goAway ) ;
90831: LD_VAR 0 1
90835: PPUSH
90836: LD_VAR 0 3
90840: PPUSH
90841: CALL_OW 113
// exit ;
90845: GO 90933
// end ; if task [ 1 ] [ 1 ] <> M then
90847: LD_VAR 0 7
90851: PUSH
90852: LD_INT 1
90854: ARRAY
90855: PUSH
90856: LD_INT 1
90858: ARRAY
90859: PUSH
90860: LD_STRING M
90862: NONEQUAL
90863: IFFALSE 90867
// exit ;
90865: GO 90933
// x := task [ 1 ] [ 2 ] ;
90867: LD_ADDR_VAR 0 5
90871: PUSH
90872: LD_VAR 0 7
90876: PUSH
90877: LD_INT 1
90879: ARRAY
90880: PUSH
90881: LD_INT 2
90883: ARRAY
90884: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90885: LD_ADDR_VAR 0 6
90889: PUSH
90890: LD_VAR 0 7
90894: PUSH
90895: LD_INT 1
90897: ARRAY
90898: PUSH
90899: LD_INT 3
90901: ARRAY
90902: ST_TO_ADDR
// if InArea ( x , y , area ) then
90903: LD_VAR 0 5
90907: PPUSH
90908: LD_VAR 0 6
90912: PPUSH
90913: LD_VAR 0 2
90917: PPUSH
90918: CALL_OW 309
90922: IFFALSE 90933
// ComStop ( unit ) ;
90924: LD_VAR 0 1
90928: PPUSH
90929: CALL_OW 141
// end ;
90933: LD_VAR 0 4
90937: RET
// export function Abs ( value ) ; begin
90938: LD_INT 0
90940: PPUSH
// result := value ;
90941: LD_ADDR_VAR 0 2
90945: PUSH
90946: LD_VAR 0 1
90950: ST_TO_ADDR
// if value < 0 then
90951: LD_VAR 0 1
90955: PUSH
90956: LD_INT 0
90958: LESS
90959: IFFALSE 90976
// result := value * - 1 ;
90961: LD_ADDR_VAR 0 2
90965: PUSH
90966: LD_VAR 0 1
90970: PUSH
90971: LD_INT 1
90973: NEG
90974: MUL
90975: ST_TO_ADDR
// end ;
90976: LD_VAR 0 2
90980: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90981: LD_INT 0
90983: PPUSH
90984: PPUSH
90985: PPUSH
90986: PPUSH
90987: PPUSH
90988: PPUSH
90989: PPUSH
90990: PPUSH
// if not unit or not building then
90991: LD_VAR 0 1
90995: NOT
90996: PUSH
90997: LD_VAR 0 2
91001: NOT
91002: OR
91003: IFFALSE 91007
// exit ;
91005: GO 91233
// x := GetX ( building ) ;
91007: LD_ADDR_VAR 0 4
91011: PUSH
91012: LD_VAR 0 2
91016: PPUSH
91017: CALL_OW 250
91021: ST_TO_ADDR
// y := GetY ( building ) ;
91022: LD_ADDR_VAR 0 6
91026: PUSH
91027: LD_VAR 0 2
91031: PPUSH
91032: CALL_OW 251
91036: ST_TO_ADDR
// d := GetDir ( building ) ;
91037: LD_ADDR_VAR 0 8
91041: PUSH
91042: LD_VAR 0 2
91046: PPUSH
91047: CALL_OW 254
91051: ST_TO_ADDR
// r := 4 ;
91052: LD_ADDR_VAR 0 9
91056: PUSH
91057: LD_INT 4
91059: ST_TO_ADDR
// for i := 1 to 5 do
91060: LD_ADDR_VAR 0 10
91064: PUSH
91065: DOUBLE
91066: LD_INT 1
91068: DEC
91069: ST_TO_ADDR
91070: LD_INT 5
91072: PUSH
91073: FOR_TO
91074: IFFALSE 91231
// begin _x := ShiftX ( x , d , r + i ) ;
91076: LD_ADDR_VAR 0 5
91080: PUSH
91081: LD_VAR 0 4
91085: PPUSH
91086: LD_VAR 0 8
91090: PPUSH
91091: LD_VAR 0 9
91095: PUSH
91096: LD_VAR 0 10
91100: PLUS
91101: PPUSH
91102: CALL_OW 272
91106: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91107: LD_ADDR_VAR 0 7
91111: PUSH
91112: LD_VAR 0 6
91116: PPUSH
91117: LD_VAR 0 8
91121: PPUSH
91122: LD_VAR 0 9
91126: PUSH
91127: LD_VAR 0 10
91131: PLUS
91132: PPUSH
91133: CALL_OW 273
91137: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91138: LD_VAR 0 5
91142: PPUSH
91143: LD_VAR 0 7
91147: PPUSH
91148: CALL_OW 488
91152: PUSH
91153: LD_VAR 0 5
91157: PPUSH
91158: LD_VAR 0 7
91162: PPUSH
91163: CALL_OW 428
91167: PPUSH
91168: CALL_OW 247
91172: PUSH
91173: LD_INT 3
91175: PUSH
91176: LD_INT 2
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: IN
91183: NOT
91184: AND
91185: IFFALSE 91229
// begin ComMoveXY ( unit , _x , _y ) ;
91187: LD_VAR 0 1
91191: PPUSH
91192: LD_VAR 0 5
91196: PPUSH
91197: LD_VAR 0 7
91201: PPUSH
91202: CALL_OW 111
// result := [ _x , _y ] ;
91206: LD_ADDR_VAR 0 3
91210: PUSH
91211: LD_VAR 0 5
91215: PUSH
91216: LD_VAR 0 7
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: ST_TO_ADDR
// exit ;
91225: POP
91226: POP
91227: GO 91233
// end ; end ;
91229: GO 91073
91231: POP
91232: POP
// end ;
91233: LD_VAR 0 3
91237: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
91238: LD_INT 0
91240: PPUSH
91241: PPUSH
91242: PPUSH
// result := 0 ;
91243: LD_ADDR_VAR 0 3
91247: PUSH
91248: LD_INT 0
91250: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
91251: LD_VAR 0 1
91255: PUSH
91256: LD_INT 0
91258: LESS
91259: PUSH
91260: LD_VAR 0 1
91264: PUSH
91265: LD_INT 8
91267: GREATER
91268: OR
91269: PUSH
91270: LD_VAR 0 2
91274: PUSH
91275: LD_INT 0
91277: LESS
91278: OR
91279: PUSH
91280: LD_VAR 0 2
91284: PUSH
91285: LD_INT 8
91287: GREATER
91288: OR
91289: IFFALSE 91293
// exit ;
91291: GO 91368
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
91293: LD_ADDR_VAR 0 4
91297: PUSH
91298: LD_INT 22
91300: PUSH
91301: LD_VAR 0 2
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PPUSH
91310: CALL_OW 69
91314: PUSH
91315: FOR_IN
91316: IFFALSE 91366
// begin un := UnitShoot ( i ) ;
91318: LD_ADDR_VAR 0 5
91322: PUSH
91323: LD_VAR 0 4
91327: PPUSH
91328: CALL_OW 504
91332: ST_TO_ADDR
// if GetSide ( un ) = side1 then
91333: LD_VAR 0 5
91337: PPUSH
91338: CALL_OW 255
91342: PUSH
91343: LD_VAR 0 1
91347: EQUAL
91348: IFFALSE 91364
// begin result := un ;
91350: LD_ADDR_VAR 0 3
91354: PUSH
91355: LD_VAR 0 5
91359: ST_TO_ADDR
// exit ;
91360: POP
91361: POP
91362: GO 91368
// end ; end ;
91364: GO 91315
91366: POP
91367: POP
// end ;
91368: LD_VAR 0 3
91372: RET
// export function GetCargoBay ( units ) ; begin
91373: LD_INT 0
91375: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
91376: LD_ADDR_VAR 0 2
91380: PUSH
91381: LD_VAR 0 1
91385: PPUSH
91386: LD_INT 2
91388: PUSH
91389: LD_INT 34
91391: PUSH
91392: LD_INT 12
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 34
91401: PUSH
91402: LD_INT 51
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 34
91411: PUSH
91412: LD_INT 32
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 34
91421: PUSH
91422: LD_INT 89
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: PPUSH
91436: CALL_OW 72
91440: ST_TO_ADDR
// end ;
91441: LD_VAR 0 2
91445: RET
// export function Negate ( value ) ; begin
91446: LD_INT 0
91448: PPUSH
// result := not value ;
91449: LD_ADDR_VAR 0 2
91453: PUSH
91454: LD_VAR 0 1
91458: NOT
91459: ST_TO_ADDR
// end ;
91460: LD_VAR 0 2
91464: RET
// export function Inc ( value ) ; begin
91465: LD_INT 0
91467: PPUSH
// result := value + 1 ;
91468: LD_ADDR_VAR 0 2
91472: PUSH
91473: LD_VAR 0 1
91477: PUSH
91478: LD_INT 1
91480: PLUS
91481: ST_TO_ADDR
// end ;
91482: LD_VAR 0 2
91486: RET
// export function Dec ( value ) ; begin
91487: LD_INT 0
91489: PPUSH
// result := value - 1 ;
91490: LD_ADDR_VAR 0 2
91494: PUSH
91495: LD_VAR 0 1
91499: PUSH
91500: LD_INT 1
91502: MINUS
91503: ST_TO_ADDR
// end ;
91504: LD_VAR 0 2
91508: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
91509: LD_INT 0
91511: PPUSH
91512: PPUSH
91513: PPUSH
91514: PPUSH
91515: PPUSH
91516: PPUSH
91517: PPUSH
91518: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
91519: LD_VAR 0 1
91523: PPUSH
91524: LD_VAR 0 2
91528: PPUSH
91529: CALL_OW 488
91533: NOT
91534: PUSH
91535: LD_VAR 0 3
91539: PPUSH
91540: LD_VAR 0 4
91544: PPUSH
91545: CALL_OW 488
91549: NOT
91550: OR
91551: IFFALSE 91564
// begin result := - 1 ;
91553: LD_ADDR_VAR 0 5
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: ST_TO_ADDR
// exit ;
91562: GO 91799
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
91564: LD_ADDR_VAR 0 12
91568: PUSH
91569: LD_VAR 0 1
91573: PPUSH
91574: LD_VAR 0 2
91578: PPUSH
91579: LD_VAR 0 3
91583: PPUSH
91584: LD_VAR 0 4
91588: PPUSH
91589: CALL 90649 0 4
91593: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
91594: LD_ADDR_VAR 0 11
91598: PUSH
91599: LD_VAR 0 1
91603: PPUSH
91604: LD_VAR 0 2
91608: PPUSH
91609: LD_VAR 0 12
91613: PUSH
91614: LD_INT 1
91616: ARRAY
91617: PPUSH
91618: LD_VAR 0 12
91622: PUSH
91623: LD_INT 2
91625: ARRAY
91626: PPUSH
91627: CALL_OW 298
91631: ST_TO_ADDR
// distance := 9999 ;
91632: LD_ADDR_VAR 0 10
91636: PUSH
91637: LD_INT 9999
91639: ST_TO_ADDR
// for i := 0 to 5 do
91640: LD_ADDR_VAR 0 6
91644: PUSH
91645: DOUBLE
91646: LD_INT 0
91648: DEC
91649: ST_TO_ADDR
91650: LD_INT 5
91652: PUSH
91653: FOR_TO
91654: IFFALSE 91797
// begin _x := ShiftX ( x1 , i , centerDist ) ;
91656: LD_ADDR_VAR 0 7
91660: PUSH
91661: LD_VAR 0 1
91665: PPUSH
91666: LD_VAR 0 6
91670: PPUSH
91671: LD_VAR 0 11
91675: PPUSH
91676: CALL_OW 272
91680: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91681: LD_ADDR_VAR 0 8
91685: PUSH
91686: LD_VAR 0 2
91690: PPUSH
91691: LD_VAR 0 6
91695: PPUSH
91696: LD_VAR 0 11
91700: PPUSH
91701: CALL_OW 273
91705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91706: LD_VAR 0 7
91710: PPUSH
91711: LD_VAR 0 8
91715: PPUSH
91716: CALL_OW 488
91720: NOT
91721: IFFALSE 91725
// continue ;
91723: GO 91653
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91725: LD_ADDR_VAR 0 9
91729: PUSH
91730: LD_VAR 0 12
91734: PUSH
91735: LD_INT 1
91737: ARRAY
91738: PPUSH
91739: LD_VAR 0 12
91743: PUSH
91744: LD_INT 2
91746: ARRAY
91747: PPUSH
91748: LD_VAR 0 7
91752: PPUSH
91753: LD_VAR 0 8
91757: PPUSH
91758: CALL_OW 298
91762: ST_TO_ADDR
// if tmp < distance then
91763: LD_VAR 0 9
91767: PUSH
91768: LD_VAR 0 10
91772: LESS
91773: IFFALSE 91795
// begin result := i ;
91775: LD_ADDR_VAR 0 5
91779: PUSH
91780: LD_VAR 0 6
91784: ST_TO_ADDR
// distance := tmp ;
91785: LD_ADDR_VAR 0 10
91789: PUSH
91790: LD_VAR 0 9
91794: ST_TO_ADDR
// end ; end ;
91795: GO 91653
91797: POP
91798: POP
// end ;
91799: LD_VAR 0 5
91803: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91804: LD_INT 0
91806: PPUSH
91807: PPUSH
// if not driver or not IsInUnit ( driver ) then
91808: LD_VAR 0 1
91812: NOT
91813: PUSH
91814: LD_VAR 0 1
91818: PPUSH
91819: CALL_OW 310
91823: NOT
91824: OR
91825: IFFALSE 91829
// exit ;
91827: GO 91919
// vehicle := IsInUnit ( driver ) ;
91829: LD_ADDR_VAR 0 3
91833: PUSH
91834: LD_VAR 0 1
91838: PPUSH
91839: CALL_OW 310
91843: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91844: LD_VAR 0 1
91848: PPUSH
91849: LD_STRING \
91851: PUSH
91852: LD_INT 0
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: LD_INT 0
91860: PUSH
91861: LD_INT 0
91863: PUSH
91864: LD_INT 0
91866: PUSH
91867: LD_INT 0
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: PUSH
91879: LD_STRING E
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: LD_INT 0
91887: PUSH
91888: LD_VAR 0 3
91892: PUSH
91893: LD_INT 0
91895: PUSH
91896: LD_INT 0
91898: PUSH
91899: LD_INT 0
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PPUSH
91915: CALL_OW 446
// end ;
91919: LD_VAR 0 2
91923: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91924: LD_INT 0
91926: PPUSH
91927: PPUSH
// if not driver or not IsInUnit ( driver ) then
91928: LD_VAR 0 1
91932: NOT
91933: PUSH
91934: LD_VAR 0 1
91938: PPUSH
91939: CALL_OW 310
91943: NOT
91944: OR
91945: IFFALSE 91949
// exit ;
91947: GO 92039
// vehicle := IsInUnit ( driver ) ;
91949: LD_ADDR_VAR 0 3
91953: PUSH
91954: LD_VAR 0 1
91958: PPUSH
91959: CALL_OW 310
91963: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91964: LD_VAR 0 1
91968: PPUSH
91969: LD_STRING \
91971: PUSH
91972: LD_INT 0
91974: PUSH
91975: LD_INT 0
91977: PUSH
91978: LD_INT 0
91980: PUSH
91981: LD_INT 0
91983: PUSH
91984: LD_INT 0
91986: PUSH
91987: LD_INT 0
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: PUSH
91999: LD_STRING E
92001: PUSH
92002: LD_INT 0
92004: PUSH
92005: LD_INT 0
92007: PUSH
92008: LD_VAR 0 3
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 0
92018: PUSH
92019: LD_INT 0
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PPUSH
92035: CALL_OW 447
// end ;
92039: LD_VAR 0 2
92043: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92044: LD_INT 0
92046: PPUSH
92047: PPUSH
92048: PPUSH
// tmp := [ ] ;
92049: LD_ADDR_VAR 0 5
92053: PUSH
92054: EMPTY
92055: ST_TO_ADDR
// for i in units do
92056: LD_ADDR_VAR 0 4
92060: PUSH
92061: LD_VAR 0 1
92065: PUSH
92066: FOR_IN
92067: IFFALSE 92105
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92069: LD_ADDR_VAR 0 5
92073: PUSH
92074: LD_VAR 0 5
92078: PPUSH
92079: LD_VAR 0 5
92083: PUSH
92084: LD_INT 1
92086: PLUS
92087: PPUSH
92088: LD_VAR 0 4
92092: PPUSH
92093: CALL_OW 256
92097: PPUSH
92098: CALL_OW 2
92102: ST_TO_ADDR
92103: GO 92066
92105: POP
92106: POP
// if not tmp then
92107: LD_VAR 0 5
92111: NOT
92112: IFFALSE 92116
// exit ;
92114: GO 92164
// if asc then
92116: LD_VAR 0 2
92120: IFFALSE 92144
// result := SortListByListAsc ( units , tmp ) else
92122: LD_ADDR_VAR 0 3
92126: PUSH
92127: LD_VAR 0 1
92131: PPUSH
92132: LD_VAR 0 5
92136: PPUSH
92137: CALL_OW 76
92141: ST_TO_ADDR
92142: GO 92164
// result := SortListByListDesc ( units , tmp ) ;
92144: LD_ADDR_VAR 0 3
92148: PUSH
92149: LD_VAR 0 1
92153: PPUSH
92154: LD_VAR 0 5
92158: PPUSH
92159: CALL_OW 77
92163: ST_TO_ADDR
// end ;
92164: LD_VAR 0 3
92168: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
92169: LD_INT 0
92171: PPUSH
92172: PPUSH
// task := GetTaskList ( mech ) ;
92173: LD_ADDR_VAR 0 4
92177: PUSH
92178: LD_VAR 0 1
92182: PPUSH
92183: CALL_OW 437
92187: ST_TO_ADDR
// if not task then
92188: LD_VAR 0 4
92192: NOT
92193: IFFALSE 92197
// exit ;
92195: GO 92239
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
92197: LD_ADDR_VAR 0 3
92201: PUSH
92202: LD_VAR 0 4
92206: PUSH
92207: LD_INT 1
92209: ARRAY
92210: PUSH
92211: LD_INT 1
92213: ARRAY
92214: PUSH
92215: LD_STRING r
92217: EQUAL
92218: PUSH
92219: LD_VAR 0 4
92223: PUSH
92224: LD_INT 1
92226: ARRAY
92227: PUSH
92228: LD_INT 4
92230: ARRAY
92231: PUSH
92232: LD_VAR 0 2
92236: EQUAL
92237: AND
92238: ST_TO_ADDR
// end ;
92239: LD_VAR 0 3
92243: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
92244: LD_INT 0
92246: PPUSH
// SetDir ( unit , d ) ;
92247: LD_VAR 0 1
92251: PPUSH
92252: LD_VAR 0 4
92256: PPUSH
92257: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
92261: LD_VAR 0 1
92265: PPUSH
92266: LD_VAR 0 2
92270: PPUSH
92271: LD_VAR 0 3
92275: PPUSH
92276: LD_VAR 0 5
92280: PPUSH
92281: CALL_OW 48
// end ;
92285: LD_VAR 0 6
92289: RET
// export function ToNaturalNumber ( number ) ; begin
92290: LD_INT 0
92292: PPUSH
// result := number div 1 ;
92293: LD_ADDR_VAR 0 2
92297: PUSH
92298: LD_VAR 0 1
92302: PUSH
92303: LD_INT 1
92305: DIV
92306: ST_TO_ADDR
// if number < 0 then
92307: LD_VAR 0 1
92311: PUSH
92312: LD_INT 0
92314: LESS
92315: IFFALSE 92325
// result := 0 ;
92317: LD_ADDR_VAR 0 2
92321: PUSH
92322: LD_INT 0
92324: ST_TO_ADDR
// end ;
92325: LD_VAR 0 2
92329: RET
// export function SortByClass ( units , class ) ; var un ; begin
92330: LD_INT 0
92332: PPUSH
92333: PPUSH
// if not units or not class then
92334: LD_VAR 0 1
92338: NOT
92339: PUSH
92340: LD_VAR 0 2
92344: NOT
92345: OR
92346: IFFALSE 92350
// exit ;
92348: GO 92445
// result := [ ] ;
92350: LD_ADDR_VAR 0 3
92354: PUSH
92355: EMPTY
92356: ST_TO_ADDR
// for un in units do
92357: LD_ADDR_VAR 0 4
92361: PUSH
92362: LD_VAR 0 1
92366: PUSH
92367: FOR_IN
92368: IFFALSE 92443
// if GetClass ( un ) = class then
92370: LD_VAR 0 4
92374: PPUSH
92375: CALL_OW 257
92379: PUSH
92380: LD_VAR 0 2
92384: EQUAL
92385: IFFALSE 92412
// result := Insert ( result , 1 , un ) else
92387: LD_ADDR_VAR 0 3
92391: PUSH
92392: LD_VAR 0 3
92396: PPUSH
92397: LD_INT 1
92399: PPUSH
92400: LD_VAR 0 4
92404: PPUSH
92405: CALL_OW 2
92409: ST_TO_ADDR
92410: GO 92441
// result := Replace ( result , result + 1 , un ) ;
92412: LD_ADDR_VAR 0 3
92416: PUSH
92417: LD_VAR 0 3
92421: PPUSH
92422: LD_VAR 0 3
92426: PUSH
92427: LD_INT 1
92429: PLUS
92430: PPUSH
92431: LD_VAR 0 4
92435: PPUSH
92436: CALL_OW 1
92440: ST_TO_ADDR
92441: GO 92367
92443: POP
92444: POP
// end ;
92445: LD_VAR 0 3
92449: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
92450: LD_INT 0
92452: PPUSH
92453: PPUSH
92454: PPUSH
92455: PPUSH
92456: PPUSH
92457: PPUSH
92458: PPUSH
// result := [ ] ;
92459: LD_ADDR_VAR 0 4
92463: PUSH
92464: EMPTY
92465: ST_TO_ADDR
// if x - r < 0 then
92466: LD_VAR 0 1
92470: PUSH
92471: LD_VAR 0 3
92475: MINUS
92476: PUSH
92477: LD_INT 0
92479: LESS
92480: IFFALSE 92492
// min_x := 0 else
92482: LD_ADDR_VAR 0 8
92486: PUSH
92487: LD_INT 0
92489: ST_TO_ADDR
92490: GO 92508
// min_x := x - r ;
92492: LD_ADDR_VAR 0 8
92496: PUSH
92497: LD_VAR 0 1
92501: PUSH
92502: LD_VAR 0 3
92506: MINUS
92507: ST_TO_ADDR
// if y - r < 0 then
92508: LD_VAR 0 2
92512: PUSH
92513: LD_VAR 0 3
92517: MINUS
92518: PUSH
92519: LD_INT 0
92521: LESS
92522: IFFALSE 92534
// min_y := 0 else
92524: LD_ADDR_VAR 0 7
92528: PUSH
92529: LD_INT 0
92531: ST_TO_ADDR
92532: GO 92550
// min_y := y - r ;
92534: LD_ADDR_VAR 0 7
92538: PUSH
92539: LD_VAR 0 2
92543: PUSH
92544: LD_VAR 0 3
92548: MINUS
92549: ST_TO_ADDR
// max_x := x + r ;
92550: LD_ADDR_VAR 0 9
92554: PUSH
92555: LD_VAR 0 1
92559: PUSH
92560: LD_VAR 0 3
92564: PLUS
92565: ST_TO_ADDR
// max_y := y + r ;
92566: LD_ADDR_VAR 0 10
92570: PUSH
92571: LD_VAR 0 2
92575: PUSH
92576: LD_VAR 0 3
92580: PLUS
92581: ST_TO_ADDR
// for _x = min_x to max_x do
92582: LD_ADDR_VAR 0 5
92586: PUSH
92587: DOUBLE
92588: LD_VAR 0 8
92592: DEC
92593: ST_TO_ADDR
92594: LD_VAR 0 9
92598: PUSH
92599: FOR_TO
92600: IFFALSE 92701
// for _y = min_y to max_y do
92602: LD_ADDR_VAR 0 6
92606: PUSH
92607: DOUBLE
92608: LD_VAR 0 7
92612: DEC
92613: ST_TO_ADDR
92614: LD_VAR 0 10
92618: PUSH
92619: FOR_TO
92620: IFFALSE 92697
// begin if not ValidHex ( _x , _y ) then
92622: LD_VAR 0 5
92626: PPUSH
92627: LD_VAR 0 6
92631: PPUSH
92632: CALL_OW 488
92636: NOT
92637: IFFALSE 92641
// continue ;
92639: GO 92619
// if GetResourceTypeXY ( _x , _y ) then
92641: LD_VAR 0 5
92645: PPUSH
92646: LD_VAR 0 6
92650: PPUSH
92651: CALL_OW 283
92655: IFFALSE 92695
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
92657: LD_ADDR_VAR 0 4
92661: PUSH
92662: LD_VAR 0 4
92666: PPUSH
92667: LD_VAR 0 4
92671: PUSH
92672: LD_INT 1
92674: PLUS
92675: PPUSH
92676: LD_VAR 0 5
92680: PUSH
92681: LD_VAR 0 6
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PPUSH
92690: CALL_OW 1
92694: ST_TO_ADDR
// end ;
92695: GO 92619
92697: POP
92698: POP
92699: GO 92599
92701: POP
92702: POP
// end ;
92703: LD_VAR 0 4
92707: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92708: LD_INT 0
92710: PPUSH
92711: PPUSH
92712: PPUSH
92713: PPUSH
92714: PPUSH
92715: PPUSH
92716: PPUSH
92717: PPUSH
// if not units then
92718: LD_VAR 0 1
92722: NOT
92723: IFFALSE 92727
// exit ;
92725: GO 93251
// result := UnitFilter ( units , [ f_ok ] ) ;
92727: LD_ADDR_VAR 0 3
92731: PUSH
92732: LD_VAR 0 1
92736: PPUSH
92737: LD_INT 50
92739: PUSH
92740: EMPTY
92741: LIST
92742: PPUSH
92743: CALL_OW 72
92747: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92748: LD_ADDR_VAR 0 8
92752: PUSH
92753: LD_VAR 0 1
92757: PUSH
92758: LD_INT 1
92760: ARRAY
92761: PPUSH
92762: CALL_OW 255
92766: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92767: LD_ADDR_VAR 0 10
92771: PUSH
92772: LD_INT 29
92774: PUSH
92775: LD_INT 91
92777: PUSH
92778: LD_INT 49
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: LIST
92785: ST_TO_ADDR
// if not result then
92786: LD_VAR 0 3
92790: NOT
92791: IFFALSE 92795
// exit ;
92793: GO 93251
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92795: LD_ADDR_VAR 0 5
92799: PUSH
92800: LD_INT 81
92802: PUSH
92803: LD_VAR 0 8
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PPUSH
92812: CALL_OW 69
92816: ST_TO_ADDR
// for i in result do
92817: LD_ADDR_VAR 0 4
92821: PUSH
92822: LD_VAR 0 3
92826: PUSH
92827: FOR_IN
92828: IFFALSE 93249
// begin tag := GetTag ( i ) + 1 ;
92830: LD_ADDR_VAR 0 9
92834: PUSH
92835: LD_VAR 0 4
92839: PPUSH
92840: CALL_OW 110
92844: PUSH
92845: LD_INT 1
92847: PLUS
92848: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92849: LD_ADDR_VAR 0 7
92853: PUSH
92854: LD_VAR 0 4
92858: PPUSH
92859: CALL_OW 250
92863: PPUSH
92864: LD_VAR 0 4
92868: PPUSH
92869: CALL_OW 251
92873: PPUSH
92874: LD_INT 6
92876: PPUSH
92877: CALL 92450 0 3
92881: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92882: LD_VAR 0 4
92886: PPUSH
92887: CALL_OW 247
92891: PUSH
92892: LD_INT 2
92894: EQUAL
92895: PUSH
92896: LD_VAR 0 7
92900: AND
92901: PUSH
92902: LD_VAR 0 4
92906: PPUSH
92907: CALL_OW 264
92911: PUSH
92912: LD_VAR 0 10
92916: IN
92917: NOT
92918: AND
92919: IFFALSE 92958
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92921: LD_VAR 0 4
92925: PPUSH
92926: LD_VAR 0 7
92930: PUSH
92931: LD_INT 1
92933: ARRAY
92934: PUSH
92935: LD_INT 1
92937: ARRAY
92938: PPUSH
92939: LD_VAR 0 7
92943: PUSH
92944: LD_INT 1
92946: ARRAY
92947: PUSH
92948: LD_INT 2
92950: ARRAY
92951: PPUSH
92952: CALL_OW 116
92956: GO 93247
// if path > tag then
92958: LD_VAR 0 2
92962: PUSH
92963: LD_VAR 0 9
92967: GREATER
92968: IFFALSE 93176
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92970: LD_ADDR_VAR 0 6
92974: PUSH
92975: LD_VAR 0 5
92979: PPUSH
92980: LD_INT 91
92982: PUSH
92983: LD_VAR 0 4
92987: PUSH
92988: LD_INT 8
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: LIST
92995: PPUSH
92996: CALL_OW 72
93000: ST_TO_ADDR
// if nearEnemy then
93001: LD_VAR 0 6
93005: IFFALSE 93074
// begin if GetWeapon ( i ) = ru_time_lapser then
93007: LD_VAR 0 4
93011: PPUSH
93012: CALL_OW 264
93016: PUSH
93017: LD_INT 49
93019: EQUAL
93020: IFFALSE 93048
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93022: LD_VAR 0 4
93026: PPUSH
93027: LD_VAR 0 6
93031: PPUSH
93032: LD_VAR 0 4
93036: PPUSH
93037: CALL_OW 74
93041: PPUSH
93042: CALL_OW 112
93046: GO 93072
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93048: LD_VAR 0 4
93052: PPUSH
93053: LD_VAR 0 6
93057: PPUSH
93058: LD_VAR 0 4
93062: PPUSH
93063: CALL_OW 74
93067: PPUSH
93068: CALL_OW 115
// end else
93072: GO 93174
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93074: LD_VAR 0 4
93078: PPUSH
93079: LD_VAR 0 2
93083: PUSH
93084: LD_VAR 0 9
93088: ARRAY
93089: PUSH
93090: LD_INT 1
93092: ARRAY
93093: PPUSH
93094: LD_VAR 0 2
93098: PUSH
93099: LD_VAR 0 9
93103: ARRAY
93104: PUSH
93105: LD_INT 2
93107: ARRAY
93108: PPUSH
93109: CALL_OW 297
93113: PUSH
93114: LD_INT 6
93116: GREATER
93117: IFFALSE 93160
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93119: LD_VAR 0 4
93123: PPUSH
93124: LD_VAR 0 2
93128: PUSH
93129: LD_VAR 0 9
93133: ARRAY
93134: PUSH
93135: LD_INT 1
93137: ARRAY
93138: PPUSH
93139: LD_VAR 0 2
93143: PUSH
93144: LD_VAR 0 9
93148: ARRAY
93149: PUSH
93150: LD_INT 2
93152: ARRAY
93153: PPUSH
93154: CALL_OW 114
93158: GO 93174
// SetTag ( i , tag ) ;
93160: LD_VAR 0 4
93164: PPUSH
93165: LD_VAR 0 9
93169: PPUSH
93170: CALL_OW 109
// end else
93174: GO 93247
// if enemy then
93176: LD_VAR 0 5
93180: IFFALSE 93247
// begin if GetWeapon ( i ) = ru_time_lapser then
93182: LD_VAR 0 4
93186: PPUSH
93187: CALL_OW 264
93191: PUSH
93192: LD_INT 49
93194: EQUAL
93195: IFFALSE 93223
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
93197: LD_VAR 0 4
93201: PPUSH
93202: LD_VAR 0 5
93206: PPUSH
93207: LD_VAR 0 4
93211: PPUSH
93212: CALL_OW 74
93216: PPUSH
93217: CALL_OW 112
93221: GO 93247
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
93223: LD_VAR 0 4
93227: PPUSH
93228: LD_VAR 0 5
93232: PPUSH
93233: LD_VAR 0 4
93237: PPUSH
93238: CALL_OW 74
93242: PPUSH
93243: CALL_OW 115
// end ; end ;
93247: GO 92827
93249: POP
93250: POP
// end ;
93251: LD_VAR 0 3
93255: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
93256: LD_INT 0
93258: PPUSH
93259: PPUSH
93260: PPUSH
// if not unit or IsInUnit ( unit ) then
93261: LD_VAR 0 1
93265: NOT
93266: PUSH
93267: LD_VAR 0 1
93271: PPUSH
93272: CALL_OW 310
93276: OR
93277: IFFALSE 93281
// exit ;
93279: GO 93372
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
93281: LD_ADDR_VAR 0 4
93285: PUSH
93286: LD_VAR 0 1
93290: PPUSH
93291: CALL_OW 250
93295: PPUSH
93296: LD_VAR 0 2
93300: PPUSH
93301: LD_INT 1
93303: PPUSH
93304: CALL_OW 272
93308: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
93309: LD_ADDR_VAR 0 5
93313: PUSH
93314: LD_VAR 0 1
93318: PPUSH
93319: CALL_OW 251
93323: PPUSH
93324: LD_VAR 0 2
93328: PPUSH
93329: LD_INT 1
93331: PPUSH
93332: CALL_OW 273
93336: ST_TO_ADDR
// if ValidHex ( x , y ) then
93337: LD_VAR 0 4
93341: PPUSH
93342: LD_VAR 0 5
93346: PPUSH
93347: CALL_OW 488
93351: IFFALSE 93372
// ComTurnXY ( unit , x , y ) ;
93353: LD_VAR 0 1
93357: PPUSH
93358: LD_VAR 0 4
93362: PPUSH
93363: LD_VAR 0 5
93367: PPUSH
93368: CALL_OW 118
// end ;
93372: LD_VAR 0 3
93376: RET
// export function SeeUnits ( side , units ) ; var i ; begin
93377: LD_INT 0
93379: PPUSH
93380: PPUSH
// result := false ;
93381: LD_ADDR_VAR 0 3
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// if not units then
93389: LD_VAR 0 2
93393: NOT
93394: IFFALSE 93398
// exit ;
93396: GO 93443
// for i in units do
93398: LD_ADDR_VAR 0 4
93402: PUSH
93403: LD_VAR 0 2
93407: PUSH
93408: FOR_IN
93409: IFFALSE 93441
// if See ( side , i ) then
93411: LD_VAR 0 1
93415: PPUSH
93416: LD_VAR 0 4
93420: PPUSH
93421: CALL_OW 292
93425: IFFALSE 93439
// begin result := true ;
93427: LD_ADDR_VAR 0 3
93431: PUSH
93432: LD_INT 1
93434: ST_TO_ADDR
// exit ;
93435: POP
93436: POP
93437: GO 93443
// end ;
93439: GO 93408
93441: POP
93442: POP
// end ;
93443: LD_VAR 0 3
93447: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
93448: LD_INT 0
93450: PPUSH
93451: PPUSH
93452: PPUSH
93453: PPUSH
// if not unit or not points then
93454: LD_VAR 0 1
93458: NOT
93459: PUSH
93460: LD_VAR 0 2
93464: NOT
93465: OR
93466: IFFALSE 93470
// exit ;
93468: GO 93560
// dist := 99999 ;
93470: LD_ADDR_VAR 0 5
93474: PUSH
93475: LD_INT 99999
93477: ST_TO_ADDR
// for i in points do
93478: LD_ADDR_VAR 0 4
93482: PUSH
93483: LD_VAR 0 2
93487: PUSH
93488: FOR_IN
93489: IFFALSE 93558
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
93491: LD_ADDR_VAR 0 6
93495: PUSH
93496: LD_VAR 0 1
93500: PPUSH
93501: LD_VAR 0 4
93505: PUSH
93506: LD_INT 1
93508: ARRAY
93509: PPUSH
93510: LD_VAR 0 4
93514: PUSH
93515: LD_INT 2
93517: ARRAY
93518: PPUSH
93519: CALL_OW 297
93523: ST_TO_ADDR
// if tmpDist < dist then
93524: LD_VAR 0 6
93528: PUSH
93529: LD_VAR 0 5
93533: LESS
93534: IFFALSE 93556
// begin result := i ;
93536: LD_ADDR_VAR 0 3
93540: PUSH
93541: LD_VAR 0 4
93545: ST_TO_ADDR
// dist := tmpDist ;
93546: LD_ADDR_VAR 0 5
93550: PUSH
93551: LD_VAR 0 6
93555: ST_TO_ADDR
// end ; end ;
93556: GO 93488
93558: POP
93559: POP
// end ;
93560: LD_VAR 0 3
93564: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
93565: LD_INT 0
93567: PPUSH
// uc_side := side ;
93568: LD_ADDR_OWVAR 20
93572: PUSH
93573: LD_VAR 0 1
93577: ST_TO_ADDR
// uc_nation := 3 ;
93578: LD_ADDR_OWVAR 21
93582: PUSH
93583: LD_INT 3
93585: ST_TO_ADDR
// vc_chassis := 25 ;
93586: LD_ADDR_OWVAR 37
93590: PUSH
93591: LD_INT 25
93593: ST_TO_ADDR
// vc_engine := engine_siberite ;
93594: LD_ADDR_OWVAR 39
93598: PUSH
93599: LD_INT 3
93601: ST_TO_ADDR
// vc_control := control_computer ;
93602: LD_ADDR_OWVAR 38
93606: PUSH
93607: LD_INT 3
93609: ST_TO_ADDR
// vc_weapon := 59 ;
93610: LD_ADDR_OWVAR 40
93614: PUSH
93615: LD_INT 59
93617: ST_TO_ADDR
// result := CreateVehicle ;
93618: LD_ADDR_VAR 0 5
93622: PUSH
93623: CALL_OW 45
93627: ST_TO_ADDR
// SetDir ( result , d ) ;
93628: LD_VAR 0 5
93632: PPUSH
93633: LD_VAR 0 4
93637: PPUSH
93638: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
93642: LD_VAR 0 5
93646: PPUSH
93647: LD_VAR 0 2
93651: PPUSH
93652: LD_VAR 0 3
93656: PPUSH
93657: LD_INT 0
93659: PPUSH
93660: CALL_OW 48
// end ;
93664: LD_VAR 0 5
93668: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93669: LD_INT 0
93671: PPUSH
93672: PPUSH
93673: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93674: LD_ADDR_VAR 0 2
93678: PUSH
93679: LD_INT 0
93681: PUSH
93682: LD_INT 0
93684: PUSH
93685: LD_INT 0
93687: PUSH
93688: LD_INT 0
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93697: LD_VAR 0 1
93701: NOT
93702: PUSH
93703: LD_VAR 0 1
93707: PPUSH
93708: CALL_OW 264
93712: PUSH
93713: LD_INT 12
93715: PUSH
93716: LD_INT 51
93718: PUSH
93719: LD_INT 32
93721: PUSH
93722: LD_INT 89
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: IN
93731: NOT
93732: OR
93733: IFFALSE 93737
// exit ;
93735: GO 93835
// for i := 1 to 3 do
93737: LD_ADDR_VAR 0 3
93741: PUSH
93742: DOUBLE
93743: LD_INT 1
93745: DEC
93746: ST_TO_ADDR
93747: LD_INT 3
93749: PUSH
93750: FOR_TO
93751: IFFALSE 93833
// begin tmp := GetCargo ( cargo , i ) ;
93753: LD_ADDR_VAR 0 4
93757: PUSH
93758: LD_VAR 0 1
93762: PPUSH
93763: LD_VAR 0 3
93767: PPUSH
93768: CALL_OW 289
93772: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93773: LD_ADDR_VAR 0 2
93777: PUSH
93778: LD_VAR 0 2
93782: PPUSH
93783: LD_VAR 0 3
93787: PPUSH
93788: LD_VAR 0 4
93792: PPUSH
93793: CALL_OW 1
93797: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93798: LD_ADDR_VAR 0 2
93802: PUSH
93803: LD_VAR 0 2
93807: PPUSH
93808: LD_INT 4
93810: PPUSH
93811: LD_VAR 0 2
93815: PUSH
93816: LD_INT 4
93818: ARRAY
93819: PUSH
93820: LD_VAR 0 4
93824: PLUS
93825: PPUSH
93826: CALL_OW 1
93830: ST_TO_ADDR
// end ;
93831: GO 93750
93833: POP
93834: POP
// end ;
93835: LD_VAR 0 2
93839: RET
// export function Length ( array ) ; begin
93840: LD_INT 0
93842: PPUSH
// result := array + 0 ;
93843: LD_ADDR_VAR 0 2
93847: PUSH
93848: LD_VAR 0 1
93852: PUSH
93853: LD_INT 0
93855: PLUS
93856: ST_TO_ADDR
// end ;
93857: LD_VAR 0 2
93861: RET
// export function PrepareArray ( array ) ; begin
93862: LD_INT 0
93864: PPUSH
// result := array diff 0 ;
93865: LD_ADDR_VAR 0 2
93869: PUSH
93870: LD_VAR 0 1
93874: PUSH
93875: LD_INT 0
93877: DIFF
93878: ST_TO_ADDR
// if not result [ 1 ] then
93879: LD_VAR 0 2
93883: PUSH
93884: LD_INT 1
93886: ARRAY
93887: NOT
93888: IFFALSE 93908
// result := Delete ( result , 1 ) ;
93890: LD_ADDR_VAR 0 2
93894: PUSH
93895: LD_VAR 0 2
93899: PPUSH
93900: LD_INT 1
93902: PPUSH
93903: CALL_OW 3
93907: ST_TO_ADDR
// end ;
93908: LD_VAR 0 2
93912: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93913: LD_INT 0
93915: PPUSH
93916: PPUSH
93917: PPUSH
93918: PPUSH
// sibRocketRange := 25 ;
93919: LD_ADDR_VAR 0 6
93923: PUSH
93924: LD_INT 25
93926: ST_TO_ADDR
// result := false ;
93927: LD_ADDR_VAR 0 4
93931: PUSH
93932: LD_INT 0
93934: ST_TO_ADDR
// for i := 0 to 5 do
93935: LD_ADDR_VAR 0 5
93939: PUSH
93940: DOUBLE
93941: LD_INT 0
93943: DEC
93944: ST_TO_ADDR
93945: LD_INT 5
93947: PUSH
93948: FOR_TO
93949: IFFALSE 94016
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
93951: LD_VAR 0 1
93955: PPUSH
93956: LD_VAR 0 5
93960: PPUSH
93961: LD_VAR 0 6
93965: PPUSH
93966: CALL_OW 272
93970: PPUSH
93971: LD_VAR 0 2
93975: PPUSH
93976: LD_VAR 0 5
93980: PPUSH
93981: LD_VAR 0 6
93985: PPUSH
93986: CALL_OW 273
93990: PPUSH
93991: LD_VAR 0 3
93995: PPUSH
93996: CALL_OW 309
94000: IFFALSE 94014
// begin result := true ;
94002: LD_ADDR_VAR 0 4
94006: PUSH
94007: LD_INT 1
94009: ST_TO_ADDR
// exit ;
94010: POP
94011: POP
94012: GO 94018
// end ;
94014: GO 93948
94016: POP
94017: POP
// end ;
94018: LD_VAR 0 4
94022: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94023: LD_INT 0
94025: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94026: LD_VAR 0 1
94030: PPUSH
94031: LD_VAR 0 2
94035: PPUSH
94036: LD_INT 0
94038: PPUSH
94039: LD_INT 0
94041: PPUSH
94042: LD_INT 1
94044: PPUSH
94045: LD_INT 0
94047: PPUSH
94048: CALL_OW 587
// end ;
94052: LD_VAR 0 3
94056: RET
// export function CenterOnNow ( unit ) ; begin
94057: LD_INT 0
94059: PPUSH
// result := IsInUnit ( unit ) ;
94060: LD_ADDR_VAR 0 2
94064: PUSH
94065: LD_VAR 0 1
94069: PPUSH
94070: CALL_OW 310
94074: ST_TO_ADDR
// if not result then
94075: LD_VAR 0 2
94079: NOT
94080: IFFALSE 94092
// result := unit ;
94082: LD_ADDR_VAR 0 2
94086: PUSH
94087: LD_VAR 0 1
94091: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94092: LD_VAR 0 1
94096: PPUSH
94097: CALL_OW 87
// end ;
94101: LD_VAR 0 2
94105: RET
// export function ComMoveHex ( unit , hex ) ; begin
94106: LD_INT 0
94108: PPUSH
// if not hex then
94109: LD_VAR 0 2
94113: NOT
94114: IFFALSE 94118
// exit ;
94116: GO 94171
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94118: LD_VAR 0 2
94122: PUSH
94123: LD_INT 1
94125: ARRAY
94126: PPUSH
94127: LD_VAR 0 2
94131: PUSH
94132: LD_INT 2
94134: ARRAY
94135: PPUSH
94136: CALL_OW 428
94140: IFFALSE 94144
// exit ;
94142: GO 94171
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
94144: LD_VAR 0 1
94148: PPUSH
94149: LD_VAR 0 2
94153: PUSH
94154: LD_INT 1
94156: ARRAY
94157: PPUSH
94158: LD_VAR 0 2
94162: PUSH
94163: LD_INT 2
94165: ARRAY
94166: PPUSH
94167: CALL_OW 111
// end ; end_of_file end_of_file
94171: LD_VAR 0 3
94175: RET
// export globalGameSaveCounter ; every 0 0$1 do
94176: GO 94178
94178: DISABLE
// begin enable ;
94179: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94180: LD_STRING updateTimer(
94182: PUSH
94183: LD_OWVAR 1
94187: STR
94188: PUSH
94189: LD_STRING );
94191: STR
94192: PPUSH
94193: CALL_OW 559
// end ;
94197: END
// every 0 0$1 do
94198: GO 94200
94200: DISABLE
// begin globalGameSaveCounter := 0 ;
94201: LD_ADDR_EXP 123
94205: PUSH
94206: LD_INT 0
94208: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94209: LD_STRING setGameSaveCounter(0)
94211: PPUSH
94212: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94216: LD_STRING initStreamRollete();
94218: PPUSH
94219: CALL_OW 559
// InitStreamMode ;
94223: CALL 95549 0 0
// DefineStreamItems ( false ) ;
94227: LD_INT 0
94229: PPUSH
94230: CALL 96013 0 1
// end ;
94234: END
// export function SOS_MapStart ( ) ; begin
94235: LD_INT 0
94237: PPUSH
// if streamModeActive then
94238: LD_EXP 124
94242: IFFALSE 94251
// DefineStreamItems ( true ) ;
94244: LD_INT 1
94246: PPUSH
94247: CALL 96013 0 1
// UpdateLuaVariables ( ) ;
94251: CALL 94268 0 0
// UpdateFactoryWaypoints ( ) ;
94255: CALL 108882 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94259: CALL 109139 0 0
// end ;
94263: LD_VAR 0 1
94267: RET
// function UpdateLuaVariables ( ) ; begin
94268: LD_INT 0
94270: PPUSH
// if globalGameSaveCounter then
94271: LD_EXP 123
94275: IFFALSE 94309
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94277: LD_ADDR_EXP 123
94281: PUSH
94282: LD_EXP 123
94286: PPUSH
94287: CALL 91465 0 1
94291: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94292: LD_STRING setGameSaveCounter(
94294: PUSH
94295: LD_EXP 123
94299: STR
94300: PUSH
94301: LD_STRING )
94303: STR
94304: PPUSH
94305: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94309: LD_STRING setGameDifficulty(
94311: PUSH
94312: LD_OWVAR 67
94316: STR
94317: PUSH
94318: LD_STRING )
94320: STR
94321: PPUSH
94322: CALL_OW 559
// end ;
94326: LD_VAR 0 1
94330: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94331: LD_INT 0
94333: PPUSH
// if p2 = stream_mode then
94334: LD_VAR 0 2
94338: PUSH
94339: LD_INT 100
94341: EQUAL
94342: IFFALSE 95345
// begin if not StreamModeActive then
94344: LD_EXP 124
94348: NOT
94349: IFFALSE 94359
// StreamModeActive := true ;
94351: LD_ADDR_EXP 124
94355: PUSH
94356: LD_INT 1
94358: ST_TO_ADDR
// if p3 = 0 then
94359: LD_VAR 0 3
94363: PUSH
94364: LD_INT 0
94366: EQUAL
94367: IFFALSE 94373
// InitStreamMode ;
94369: CALL 95549 0 0
// if p3 = 1 then
94373: LD_VAR 0 3
94377: PUSH
94378: LD_INT 1
94380: EQUAL
94381: IFFALSE 94391
// sRocket := true ;
94383: LD_ADDR_EXP 129
94387: PUSH
94388: LD_INT 1
94390: ST_TO_ADDR
// if p3 = 2 then
94391: LD_VAR 0 3
94395: PUSH
94396: LD_INT 2
94398: EQUAL
94399: IFFALSE 94409
// sSpeed := true ;
94401: LD_ADDR_EXP 128
94405: PUSH
94406: LD_INT 1
94408: ST_TO_ADDR
// if p3 = 3 then
94409: LD_VAR 0 3
94413: PUSH
94414: LD_INT 3
94416: EQUAL
94417: IFFALSE 94427
// sEngine := true ;
94419: LD_ADDR_EXP 130
94423: PUSH
94424: LD_INT 1
94426: ST_TO_ADDR
// if p3 = 4 then
94427: LD_VAR 0 3
94431: PUSH
94432: LD_INT 4
94434: EQUAL
94435: IFFALSE 94445
// sSpec := true ;
94437: LD_ADDR_EXP 127
94441: PUSH
94442: LD_INT 1
94444: ST_TO_ADDR
// if p3 = 5 then
94445: LD_VAR 0 3
94449: PUSH
94450: LD_INT 5
94452: EQUAL
94453: IFFALSE 94463
// sLevel := true ;
94455: LD_ADDR_EXP 131
94459: PUSH
94460: LD_INT 1
94462: ST_TO_ADDR
// if p3 = 6 then
94463: LD_VAR 0 3
94467: PUSH
94468: LD_INT 6
94470: EQUAL
94471: IFFALSE 94481
// sArmoury := true ;
94473: LD_ADDR_EXP 132
94477: PUSH
94478: LD_INT 1
94480: ST_TO_ADDR
// if p3 = 7 then
94481: LD_VAR 0 3
94485: PUSH
94486: LD_INT 7
94488: EQUAL
94489: IFFALSE 94499
// sRadar := true ;
94491: LD_ADDR_EXP 133
94495: PUSH
94496: LD_INT 1
94498: ST_TO_ADDR
// if p3 = 8 then
94499: LD_VAR 0 3
94503: PUSH
94504: LD_INT 8
94506: EQUAL
94507: IFFALSE 94517
// sBunker := true ;
94509: LD_ADDR_EXP 134
94513: PUSH
94514: LD_INT 1
94516: ST_TO_ADDR
// if p3 = 9 then
94517: LD_VAR 0 3
94521: PUSH
94522: LD_INT 9
94524: EQUAL
94525: IFFALSE 94535
// sHack := true ;
94527: LD_ADDR_EXP 135
94531: PUSH
94532: LD_INT 1
94534: ST_TO_ADDR
// if p3 = 10 then
94535: LD_VAR 0 3
94539: PUSH
94540: LD_INT 10
94542: EQUAL
94543: IFFALSE 94553
// sFire := true ;
94545: LD_ADDR_EXP 136
94549: PUSH
94550: LD_INT 1
94552: ST_TO_ADDR
// if p3 = 11 then
94553: LD_VAR 0 3
94557: PUSH
94558: LD_INT 11
94560: EQUAL
94561: IFFALSE 94571
// sRefresh := true ;
94563: LD_ADDR_EXP 137
94567: PUSH
94568: LD_INT 1
94570: ST_TO_ADDR
// if p3 = 12 then
94571: LD_VAR 0 3
94575: PUSH
94576: LD_INT 12
94578: EQUAL
94579: IFFALSE 94589
// sExp := true ;
94581: LD_ADDR_EXP 138
94585: PUSH
94586: LD_INT 1
94588: ST_TO_ADDR
// if p3 = 13 then
94589: LD_VAR 0 3
94593: PUSH
94594: LD_INT 13
94596: EQUAL
94597: IFFALSE 94607
// sDepot := true ;
94599: LD_ADDR_EXP 139
94603: PUSH
94604: LD_INT 1
94606: ST_TO_ADDR
// if p3 = 14 then
94607: LD_VAR 0 3
94611: PUSH
94612: LD_INT 14
94614: EQUAL
94615: IFFALSE 94625
// sFlag := true ;
94617: LD_ADDR_EXP 140
94621: PUSH
94622: LD_INT 1
94624: ST_TO_ADDR
// if p3 = 15 then
94625: LD_VAR 0 3
94629: PUSH
94630: LD_INT 15
94632: EQUAL
94633: IFFALSE 94643
// sKamikadze := true ;
94635: LD_ADDR_EXP 148
94639: PUSH
94640: LD_INT 1
94642: ST_TO_ADDR
// if p3 = 16 then
94643: LD_VAR 0 3
94647: PUSH
94648: LD_INT 16
94650: EQUAL
94651: IFFALSE 94661
// sTroll := true ;
94653: LD_ADDR_EXP 149
94657: PUSH
94658: LD_INT 1
94660: ST_TO_ADDR
// if p3 = 17 then
94661: LD_VAR 0 3
94665: PUSH
94666: LD_INT 17
94668: EQUAL
94669: IFFALSE 94679
// sSlow := true ;
94671: LD_ADDR_EXP 150
94675: PUSH
94676: LD_INT 1
94678: ST_TO_ADDR
// if p3 = 18 then
94679: LD_VAR 0 3
94683: PUSH
94684: LD_INT 18
94686: EQUAL
94687: IFFALSE 94697
// sLack := true ;
94689: LD_ADDR_EXP 151
94693: PUSH
94694: LD_INT 1
94696: ST_TO_ADDR
// if p3 = 19 then
94697: LD_VAR 0 3
94701: PUSH
94702: LD_INT 19
94704: EQUAL
94705: IFFALSE 94715
// sTank := true ;
94707: LD_ADDR_EXP 153
94711: PUSH
94712: LD_INT 1
94714: ST_TO_ADDR
// if p3 = 20 then
94715: LD_VAR 0 3
94719: PUSH
94720: LD_INT 20
94722: EQUAL
94723: IFFALSE 94733
// sRemote := true ;
94725: LD_ADDR_EXP 154
94729: PUSH
94730: LD_INT 1
94732: ST_TO_ADDR
// if p3 = 21 then
94733: LD_VAR 0 3
94737: PUSH
94738: LD_INT 21
94740: EQUAL
94741: IFFALSE 94751
// sPowell := true ;
94743: LD_ADDR_EXP 155
94747: PUSH
94748: LD_INT 1
94750: ST_TO_ADDR
// if p3 = 22 then
94751: LD_VAR 0 3
94755: PUSH
94756: LD_INT 22
94758: EQUAL
94759: IFFALSE 94769
// sTeleport := true ;
94761: LD_ADDR_EXP 158
94765: PUSH
94766: LD_INT 1
94768: ST_TO_ADDR
// if p3 = 23 then
94769: LD_VAR 0 3
94773: PUSH
94774: LD_INT 23
94776: EQUAL
94777: IFFALSE 94787
// sOilTower := true ;
94779: LD_ADDR_EXP 160
94783: PUSH
94784: LD_INT 1
94786: ST_TO_ADDR
// if p3 = 24 then
94787: LD_VAR 0 3
94791: PUSH
94792: LD_INT 24
94794: EQUAL
94795: IFFALSE 94805
// sShovel := true ;
94797: LD_ADDR_EXP 161
94801: PUSH
94802: LD_INT 1
94804: ST_TO_ADDR
// if p3 = 25 then
94805: LD_VAR 0 3
94809: PUSH
94810: LD_INT 25
94812: EQUAL
94813: IFFALSE 94823
// sSheik := true ;
94815: LD_ADDR_EXP 162
94819: PUSH
94820: LD_INT 1
94822: ST_TO_ADDR
// if p3 = 26 then
94823: LD_VAR 0 3
94827: PUSH
94828: LD_INT 26
94830: EQUAL
94831: IFFALSE 94841
// sEarthquake := true ;
94833: LD_ADDR_EXP 164
94837: PUSH
94838: LD_INT 1
94840: ST_TO_ADDR
// if p3 = 27 then
94841: LD_VAR 0 3
94845: PUSH
94846: LD_INT 27
94848: EQUAL
94849: IFFALSE 94859
// sAI := true ;
94851: LD_ADDR_EXP 165
94855: PUSH
94856: LD_INT 1
94858: ST_TO_ADDR
// if p3 = 28 then
94859: LD_VAR 0 3
94863: PUSH
94864: LD_INT 28
94866: EQUAL
94867: IFFALSE 94877
// sCargo := true ;
94869: LD_ADDR_EXP 168
94873: PUSH
94874: LD_INT 1
94876: ST_TO_ADDR
// if p3 = 29 then
94877: LD_VAR 0 3
94881: PUSH
94882: LD_INT 29
94884: EQUAL
94885: IFFALSE 94895
// sDLaser := true ;
94887: LD_ADDR_EXP 169
94891: PUSH
94892: LD_INT 1
94894: ST_TO_ADDR
// if p3 = 30 then
94895: LD_VAR 0 3
94899: PUSH
94900: LD_INT 30
94902: EQUAL
94903: IFFALSE 94913
// sExchange := true ;
94905: LD_ADDR_EXP 170
94909: PUSH
94910: LD_INT 1
94912: ST_TO_ADDR
// if p3 = 31 then
94913: LD_VAR 0 3
94917: PUSH
94918: LD_INT 31
94920: EQUAL
94921: IFFALSE 94931
// sFac := true ;
94923: LD_ADDR_EXP 171
94927: PUSH
94928: LD_INT 1
94930: ST_TO_ADDR
// if p3 = 32 then
94931: LD_VAR 0 3
94935: PUSH
94936: LD_INT 32
94938: EQUAL
94939: IFFALSE 94949
// sPower := true ;
94941: LD_ADDR_EXP 172
94945: PUSH
94946: LD_INT 1
94948: ST_TO_ADDR
// if p3 = 33 then
94949: LD_VAR 0 3
94953: PUSH
94954: LD_INT 33
94956: EQUAL
94957: IFFALSE 94967
// sRandom := true ;
94959: LD_ADDR_EXP 173
94963: PUSH
94964: LD_INT 1
94966: ST_TO_ADDR
// if p3 = 34 then
94967: LD_VAR 0 3
94971: PUSH
94972: LD_INT 34
94974: EQUAL
94975: IFFALSE 94985
// sShield := true ;
94977: LD_ADDR_EXP 174
94981: PUSH
94982: LD_INT 1
94984: ST_TO_ADDR
// if p3 = 35 then
94985: LD_VAR 0 3
94989: PUSH
94990: LD_INT 35
94992: EQUAL
94993: IFFALSE 95003
// sTime := true ;
94995: LD_ADDR_EXP 175
94999: PUSH
95000: LD_INT 1
95002: ST_TO_ADDR
// if p3 = 36 then
95003: LD_VAR 0 3
95007: PUSH
95008: LD_INT 36
95010: EQUAL
95011: IFFALSE 95021
// sTools := true ;
95013: LD_ADDR_EXP 176
95017: PUSH
95018: LD_INT 1
95020: ST_TO_ADDR
// if p3 = 101 then
95021: LD_VAR 0 3
95025: PUSH
95026: LD_INT 101
95028: EQUAL
95029: IFFALSE 95039
// sSold := true ;
95031: LD_ADDR_EXP 141
95035: PUSH
95036: LD_INT 1
95038: ST_TO_ADDR
// if p3 = 102 then
95039: LD_VAR 0 3
95043: PUSH
95044: LD_INT 102
95046: EQUAL
95047: IFFALSE 95057
// sDiff := true ;
95049: LD_ADDR_EXP 142
95053: PUSH
95054: LD_INT 1
95056: ST_TO_ADDR
// if p3 = 103 then
95057: LD_VAR 0 3
95061: PUSH
95062: LD_INT 103
95064: EQUAL
95065: IFFALSE 95075
// sFog := true ;
95067: LD_ADDR_EXP 145
95071: PUSH
95072: LD_INT 1
95074: ST_TO_ADDR
// if p3 = 104 then
95075: LD_VAR 0 3
95079: PUSH
95080: LD_INT 104
95082: EQUAL
95083: IFFALSE 95093
// sReset := true ;
95085: LD_ADDR_EXP 146
95089: PUSH
95090: LD_INT 1
95092: ST_TO_ADDR
// if p3 = 105 then
95093: LD_VAR 0 3
95097: PUSH
95098: LD_INT 105
95100: EQUAL
95101: IFFALSE 95111
// sSun := true ;
95103: LD_ADDR_EXP 147
95107: PUSH
95108: LD_INT 1
95110: ST_TO_ADDR
// if p3 = 106 then
95111: LD_VAR 0 3
95115: PUSH
95116: LD_INT 106
95118: EQUAL
95119: IFFALSE 95129
// sTiger := true ;
95121: LD_ADDR_EXP 143
95125: PUSH
95126: LD_INT 1
95128: ST_TO_ADDR
// if p3 = 107 then
95129: LD_VAR 0 3
95133: PUSH
95134: LD_INT 107
95136: EQUAL
95137: IFFALSE 95147
// sBomb := true ;
95139: LD_ADDR_EXP 144
95143: PUSH
95144: LD_INT 1
95146: ST_TO_ADDR
// if p3 = 108 then
95147: LD_VAR 0 3
95151: PUSH
95152: LD_INT 108
95154: EQUAL
95155: IFFALSE 95165
// sWound := true ;
95157: LD_ADDR_EXP 152
95161: PUSH
95162: LD_INT 1
95164: ST_TO_ADDR
// if p3 = 109 then
95165: LD_VAR 0 3
95169: PUSH
95170: LD_INT 109
95172: EQUAL
95173: IFFALSE 95183
// sBetray := true ;
95175: LD_ADDR_EXP 156
95179: PUSH
95180: LD_INT 1
95182: ST_TO_ADDR
// if p3 = 110 then
95183: LD_VAR 0 3
95187: PUSH
95188: LD_INT 110
95190: EQUAL
95191: IFFALSE 95201
// sContamin := true ;
95193: LD_ADDR_EXP 157
95197: PUSH
95198: LD_INT 1
95200: ST_TO_ADDR
// if p3 = 111 then
95201: LD_VAR 0 3
95205: PUSH
95206: LD_INT 111
95208: EQUAL
95209: IFFALSE 95219
// sOil := true ;
95211: LD_ADDR_EXP 159
95215: PUSH
95216: LD_INT 1
95218: ST_TO_ADDR
// if p3 = 112 then
95219: LD_VAR 0 3
95223: PUSH
95224: LD_INT 112
95226: EQUAL
95227: IFFALSE 95237
// sStu := true ;
95229: LD_ADDR_EXP 163
95233: PUSH
95234: LD_INT 1
95236: ST_TO_ADDR
// if p3 = 113 then
95237: LD_VAR 0 3
95241: PUSH
95242: LD_INT 113
95244: EQUAL
95245: IFFALSE 95255
// sBazooka := true ;
95247: LD_ADDR_EXP 166
95251: PUSH
95252: LD_INT 1
95254: ST_TO_ADDR
// if p3 = 114 then
95255: LD_VAR 0 3
95259: PUSH
95260: LD_INT 114
95262: EQUAL
95263: IFFALSE 95273
// sMortar := true ;
95265: LD_ADDR_EXP 167
95269: PUSH
95270: LD_INT 1
95272: ST_TO_ADDR
// if p3 = 115 then
95273: LD_VAR 0 3
95277: PUSH
95278: LD_INT 115
95280: EQUAL
95281: IFFALSE 95291
// sRanger := true ;
95283: LD_ADDR_EXP 177
95287: PUSH
95288: LD_INT 1
95290: ST_TO_ADDR
// if p3 = 116 then
95291: LD_VAR 0 3
95295: PUSH
95296: LD_INT 116
95298: EQUAL
95299: IFFALSE 95309
// sComputer := true ;
95301: LD_ADDR_EXP 178
95305: PUSH
95306: LD_INT 1
95308: ST_TO_ADDR
// if p3 = 117 then
95309: LD_VAR 0 3
95313: PUSH
95314: LD_INT 117
95316: EQUAL
95317: IFFALSE 95327
// s30 := true ;
95319: LD_ADDR_EXP 179
95323: PUSH
95324: LD_INT 1
95326: ST_TO_ADDR
// if p3 = 118 then
95327: LD_VAR 0 3
95331: PUSH
95332: LD_INT 118
95334: EQUAL
95335: IFFALSE 95345
// s60 := true ;
95337: LD_ADDR_EXP 180
95341: PUSH
95342: LD_INT 1
95344: ST_TO_ADDR
// end ; if p2 = hack_mode then
95345: LD_VAR 0 2
95349: PUSH
95350: LD_INT 101
95352: EQUAL
95353: IFFALSE 95481
// begin case p3 of 1 :
95355: LD_VAR 0 3
95359: PUSH
95360: LD_INT 1
95362: DOUBLE
95363: EQUAL
95364: IFTRUE 95368
95366: GO 95375
95368: POP
// hHackUnlimitedResources ; 2 :
95369: CALL 107628 0 0
95373: GO 95481
95375: LD_INT 2
95377: DOUBLE
95378: EQUAL
95379: IFTRUE 95383
95381: GO 95390
95383: POP
// hHackSetLevel10 ; 3 :
95384: CALL 107761 0 0
95388: GO 95481
95390: LD_INT 3
95392: DOUBLE
95393: EQUAL
95394: IFTRUE 95398
95396: GO 95405
95398: POP
// hHackSetLevel10YourUnits ; 4 :
95399: CALL 107846 0 0
95403: GO 95481
95405: LD_INT 4
95407: DOUBLE
95408: EQUAL
95409: IFTRUE 95413
95411: GO 95420
95413: POP
// hHackInvincible ; 5 :
95414: CALL 108294 0 0
95418: GO 95481
95420: LD_INT 5
95422: DOUBLE
95423: EQUAL
95424: IFTRUE 95428
95426: GO 95435
95428: POP
// hHackInvisible ; 6 :
95429: CALL 108405 0 0
95433: GO 95481
95435: LD_INT 6
95437: DOUBLE
95438: EQUAL
95439: IFTRUE 95443
95441: GO 95450
95443: POP
// hHackChangeYourSide ; 7 :
95444: CALL 108462 0 0
95448: GO 95481
95450: LD_INT 7
95452: DOUBLE
95453: EQUAL
95454: IFTRUE 95458
95456: GO 95465
95458: POP
// hHackChangeUnitSide ; 8 :
95459: CALL 108504 0 0
95463: GO 95481
95465: LD_INT 8
95467: DOUBLE
95468: EQUAL
95469: IFTRUE 95473
95471: GO 95480
95473: POP
// hHackFog ; end ;
95474: CALL 108605 0 0
95478: GO 95481
95480: POP
// end ; if p2 = game_save_mode then
95481: LD_VAR 0 2
95485: PUSH
95486: LD_INT 102
95488: EQUAL
95489: IFFALSE 95544
// begin if p3 = 1 then
95491: LD_VAR 0 3
95495: PUSH
95496: LD_INT 1
95498: EQUAL
95499: IFFALSE 95511
// globalGameSaveCounter := p4 ;
95501: LD_ADDR_EXP 123
95505: PUSH
95506: LD_VAR 0 4
95510: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95511: LD_VAR 0 3
95515: PUSH
95516: LD_INT 2
95518: EQUAL
95519: PUSH
95520: LD_EXP 123
95524: AND
95525: IFFALSE 95544
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95527: LD_STRING setGameSaveCounter(
95529: PUSH
95530: LD_EXP 123
95534: STR
95535: PUSH
95536: LD_STRING )
95538: STR
95539: PPUSH
95540: CALL_OW 559
// end ; end ;
95544: LD_VAR 0 7
95548: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95549: LD_INT 0
95551: PPUSH
// streamModeActive := false ;
95552: LD_ADDR_EXP 124
95556: PUSH
95557: LD_INT 0
95559: ST_TO_ADDR
// normalCounter := 36 ;
95560: LD_ADDR_EXP 125
95564: PUSH
95565: LD_INT 36
95567: ST_TO_ADDR
// hardcoreCounter := 18 ;
95568: LD_ADDR_EXP 126
95572: PUSH
95573: LD_INT 18
95575: ST_TO_ADDR
// sRocket := false ;
95576: LD_ADDR_EXP 129
95580: PUSH
95581: LD_INT 0
95583: ST_TO_ADDR
// sSpeed := false ;
95584: LD_ADDR_EXP 128
95588: PUSH
95589: LD_INT 0
95591: ST_TO_ADDR
// sEngine := false ;
95592: LD_ADDR_EXP 130
95596: PUSH
95597: LD_INT 0
95599: ST_TO_ADDR
// sSpec := false ;
95600: LD_ADDR_EXP 127
95604: PUSH
95605: LD_INT 0
95607: ST_TO_ADDR
// sLevel := false ;
95608: LD_ADDR_EXP 131
95612: PUSH
95613: LD_INT 0
95615: ST_TO_ADDR
// sArmoury := false ;
95616: LD_ADDR_EXP 132
95620: PUSH
95621: LD_INT 0
95623: ST_TO_ADDR
// sRadar := false ;
95624: LD_ADDR_EXP 133
95628: PUSH
95629: LD_INT 0
95631: ST_TO_ADDR
// sBunker := false ;
95632: LD_ADDR_EXP 134
95636: PUSH
95637: LD_INT 0
95639: ST_TO_ADDR
// sHack := false ;
95640: LD_ADDR_EXP 135
95644: PUSH
95645: LD_INT 0
95647: ST_TO_ADDR
// sFire := false ;
95648: LD_ADDR_EXP 136
95652: PUSH
95653: LD_INT 0
95655: ST_TO_ADDR
// sRefresh := false ;
95656: LD_ADDR_EXP 137
95660: PUSH
95661: LD_INT 0
95663: ST_TO_ADDR
// sExp := false ;
95664: LD_ADDR_EXP 138
95668: PUSH
95669: LD_INT 0
95671: ST_TO_ADDR
// sDepot := false ;
95672: LD_ADDR_EXP 139
95676: PUSH
95677: LD_INT 0
95679: ST_TO_ADDR
// sFlag := false ;
95680: LD_ADDR_EXP 140
95684: PUSH
95685: LD_INT 0
95687: ST_TO_ADDR
// sKamikadze := false ;
95688: LD_ADDR_EXP 148
95692: PUSH
95693: LD_INT 0
95695: ST_TO_ADDR
// sTroll := false ;
95696: LD_ADDR_EXP 149
95700: PUSH
95701: LD_INT 0
95703: ST_TO_ADDR
// sSlow := false ;
95704: LD_ADDR_EXP 150
95708: PUSH
95709: LD_INT 0
95711: ST_TO_ADDR
// sLack := false ;
95712: LD_ADDR_EXP 151
95716: PUSH
95717: LD_INT 0
95719: ST_TO_ADDR
// sTank := false ;
95720: LD_ADDR_EXP 153
95724: PUSH
95725: LD_INT 0
95727: ST_TO_ADDR
// sRemote := false ;
95728: LD_ADDR_EXP 154
95732: PUSH
95733: LD_INT 0
95735: ST_TO_ADDR
// sPowell := false ;
95736: LD_ADDR_EXP 155
95740: PUSH
95741: LD_INT 0
95743: ST_TO_ADDR
// sTeleport := false ;
95744: LD_ADDR_EXP 158
95748: PUSH
95749: LD_INT 0
95751: ST_TO_ADDR
// sOilTower := false ;
95752: LD_ADDR_EXP 160
95756: PUSH
95757: LD_INT 0
95759: ST_TO_ADDR
// sShovel := false ;
95760: LD_ADDR_EXP 161
95764: PUSH
95765: LD_INT 0
95767: ST_TO_ADDR
// sSheik := false ;
95768: LD_ADDR_EXP 162
95772: PUSH
95773: LD_INT 0
95775: ST_TO_ADDR
// sEarthquake := false ;
95776: LD_ADDR_EXP 164
95780: PUSH
95781: LD_INT 0
95783: ST_TO_ADDR
// sAI := false ;
95784: LD_ADDR_EXP 165
95788: PUSH
95789: LD_INT 0
95791: ST_TO_ADDR
// sCargo := false ;
95792: LD_ADDR_EXP 168
95796: PUSH
95797: LD_INT 0
95799: ST_TO_ADDR
// sDLaser := false ;
95800: LD_ADDR_EXP 169
95804: PUSH
95805: LD_INT 0
95807: ST_TO_ADDR
// sExchange := false ;
95808: LD_ADDR_EXP 170
95812: PUSH
95813: LD_INT 0
95815: ST_TO_ADDR
// sFac := false ;
95816: LD_ADDR_EXP 171
95820: PUSH
95821: LD_INT 0
95823: ST_TO_ADDR
// sPower := false ;
95824: LD_ADDR_EXP 172
95828: PUSH
95829: LD_INT 0
95831: ST_TO_ADDR
// sRandom := false ;
95832: LD_ADDR_EXP 173
95836: PUSH
95837: LD_INT 0
95839: ST_TO_ADDR
// sShield := false ;
95840: LD_ADDR_EXP 174
95844: PUSH
95845: LD_INT 0
95847: ST_TO_ADDR
// sTime := false ;
95848: LD_ADDR_EXP 175
95852: PUSH
95853: LD_INT 0
95855: ST_TO_ADDR
// sTools := false ;
95856: LD_ADDR_EXP 176
95860: PUSH
95861: LD_INT 0
95863: ST_TO_ADDR
// sSold := false ;
95864: LD_ADDR_EXP 141
95868: PUSH
95869: LD_INT 0
95871: ST_TO_ADDR
// sDiff := false ;
95872: LD_ADDR_EXP 142
95876: PUSH
95877: LD_INT 0
95879: ST_TO_ADDR
// sFog := false ;
95880: LD_ADDR_EXP 145
95884: PUSH
95885: LD_INT 0
95887: ST_TO_ADDR
// sReset := false ;
95888: LD_ADDR_EXP 146
95892: PUSH
95893: LD_INT 0
95895: ST_TO_ADDR
// sSun := false ;
95896: LD_ADDR_EXP 147
95900: PUSH
95901: LD_INT 0
95903: ST_TO_ADDR
// sTiger := false ;
95904: LD_ADDR_EXP 143
95908: PUSH
95909: LD_INT 0
95911: ST_TO_ADDR
// sBomb := false ;
95912: LD_ADDR_EXP 144
95916: PUSH
95917: LD_INT 0
95919: ST_TO_ADDR
// sWound := false ;
95920: LD_ADDR_EXP 152
95924: PUSH
95925: LD_INT 0
95927: ST_TO_ADDR
// sBetray := false ;
95928: LD_ADDR_EXP 156
95932: PUSH
95933: LD_INT 0
95935: ST_TO_ADDR
// sContamin := false ;
95936: LD_ADDR_EXP 157
95940: PUSH
95941: LD_INT 0
95943: ST_TO_ADDR
// sOil := false ;
95944: LD_ADDR_EXP 159
95948: PUSH
95949: LD_INT 0
95951: ST_TO_ADDR
// sStu := false ;
95952: LD_ADDR_EXP 163
95956: PUSH
95957: LD_INT 0
95959: ST_TO_ADDR
// sBazooka := false ;
95960: LD_ADDR_EXP 166
95964: PUSH
95965: LD_INT 0
95967: ST_TO_ADDR
// sMortar := false ;
95968: LD_ADDR_EXP 167
95972: PUSH
95973: LD_INT 0
95975: ST_TO_ADDR
// sRanger := false ;
95976: LD_ADDR_EXP 177
95980: PUSH
95981: LD_INT 0
95983: ST_TO_ADDR
// sComputer := false ;
95984: LD_ADDR_EXP 178
95988: PUSH
95989: LD_INT 0
95991: ST_TO_ADDR
// s30 := false ;
95992: LD_ADDR_EXP 179
95996: PUSH
95997: LD_INT 0
95999: ST_TO_ADDR
// s60 := false ;
96000: LD_ADDR_EXP 180
96004: PUSH
96005: LD_INT 0
96007: ST_TO_ADDR
// end ;
96008: LD_VAR 0 1
96012: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96013: LD_INT 0
96015: PPUSH
96016: PPUSH
96017: PPUSH
96018: PPUSH
96019: PPUSH
96020: PPUSH
96021: PPUSH
// result := [ ] ;
96022: LD_ADDR_VAR 0 2
96026: PUSH
96027: EMPTY
96028: ST_TO_ADDR
// if campaign_id = 1 then
96029: LD_OWVAR 69
96033: PUSH
96034: LD_INT 1
96036: EQUAL
96037: IFFALSE 99203
// begin case mission_number of 1 :
96039: LD_OWVAR 70
96043: PUSH
96044: LD_INT 1
96046: DOUBLE
96047: EQUAL
96048: IFTRUE 96052
96050: GO 96128
96052: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96053: LD_ADDR_VAR 0 2
96057: PUSH
96058: LD_INT 2
96060: PUSH
96061: LD_INT 4
96063: PUSH
96064: LD_INT 11
96066: PUSH
96067: LD_INT 12
96069: PUSH
96070: LD_INT 15
96072: PUSH
96073: LD_INT 16
96075: PUSH
96076: LD_INT 22
96078: PUSH
96079: LD_INT 23
96081: PUSH
96082: LD_INT 26
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 101
96098: PUSH
96099: LD_INT 102
96101: PUSH
96102: LD_INT 106
96104: PUSH
96105: LD_INT 116
96107: PUSH
96108: LD_INT 117
96110: PUSH
96111: LD_INT 118
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: ST_TO_ADDR
96126: GO 99201
96128: LD_INT 2
96130: DOUBLE
96131: EQUAL
96132: IFTRUE 96136
96134: GO 96220
96136: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96137: LD_ADDR_VAR 0 2
96141: PUSH
96142: LD_INT 2
96144: PUSH
96145: LD_INT 4
96147: PUSH
96148: LD_INT 11
96150: PUSH
96151: LD_INT 12
96153: PUSH
96154: LD_INT 15
96156: PUSH
96157: LD_INT 16
96159: PUSH
96160: LD_INT 22
96162: PUSH
96163: LD_INT 23
96165: PUSH
96166: LD_INT 26
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 101
96182: PUSH
96183: LD_INT 102
96185: PUSH
96186: LD_INT 105
96188: PUSH
96189: LD_INT 106
96191: PUSH
96192: LD_INT 108
96194: PUSH
96195: LD_INT 116
96197: PUSH
96198: LD_INT 117
96200: PUSH
96201: LD_INT 118
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: ST_TO_ADDR
96218: GO 99201
96220: LD_INT 3
96222: DOUBLE
96223: EQUAL
96224: IFTRUE 96228
96226: GO 96316
96228: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96229: LD_ADDR_VAR 0 2
96233: PUSH
96234: LD_INT 2
96236: PUSH
96237: LD_INT 4
96239: PUSH
96240: LD_INT 5
96242: PUSH
96243: LD_INT 11
96245: PUSH
96246: LD_INT 12
96248: PUSH
96249: LD_INT 15
96251: PUSH
96252: LD_INT 16
96254: PUSH
96255: LD_INT 22
96257: PUSH
96258: LD_INT 26
96260: PUSH
96261: LD_INT 36
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 101
96278: PUSH
96279: LD_INT 102
96281: PUSH
96282: LD_INT 105
96284: PUSH
96285: LD_INT 106
96287: PUSH
96288: LD_INT 108
96290: PUSH
96291: LD_INT 116
96293: PUSH
96294: LD_INT 117
96296: PUSH
96297: LD_INT 118
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: ST_TO_ADDR
96314: GO 99201
96316: LD_INT 4
96318: DOUBLE
96319: EQUAL
96320: IFTRUE 96324
96322: GO 96420
96324: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96325: LD_ADDR_VAR 0 2
96329: PUSH
96330: LD_INT 2
96332: PUSH
96333: LD_INT 4
96335: PUSH
96336: LD_INT 5
96338: PUSH
96339: LD_INT 8
96341: PUSH
96342: LD_INT 11
96344: PUSH
96345: LD_INT 12
96347: PUSH
96348: LD_INT 15
96350: PUSH
96351: LD_INT 16
96353: PUSH
96354: LD_INT 22
96356: PUSH
96357: LD_INT 23
96359: PUSH
96360: LD_INT 26
96362: PUSH
96363: LD_INT 36
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: PUSH
96380: LD_INT 101
96382: PUSH
96383: LD_INT 102
96385: PUSH
96386: LD_INT 105
96388: PUSH
96389: LD_INT 106
96391: PUSH
96392: LD_INT 108
96394: PUSH
96395: LD_INT 116
96397: PUSH
96398: LD_INT 117
96400: PUSH
96401: LD_INT 118
96403: PUSH
96404: EMPTY
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: ST_TO_ADDR
96418: GO 99201
96420: LD_INT 5
96422: DOUBLE
96423: EQUAL
96424: IFTRUE 96428
96426: GO 96540
96428: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96429: LD_ADDR_VAR 0 2
96433: PUSH
96434: LD_INT 2
96436: PUSH
96437: LD_INT 4
96439: PUSH
96440: LD_INT 5
96442: PUSH
96443: LD_INT 6
96445: PUSH
96446: LD_INT 8
96448: PUSH
96449: LD_INT 11
96451: PUSH
96452: LD_INT 12
96454: PUSH
96455: LD_INT 15
96457: PUSH
96458: LD_INT 16
96460: PUSH
96461: LD_INT 22
96463: PUSH
96464: LD_INT 23
96466: PUSH
96467: LD_INT 25
96469: PUSH
96470: LD_INT 26
96472: PUSH
96473: LD_INT 36
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 101
96494: PUSH
96495: LD_INT 102
96497: PUSH
96498: LD_INT 105
96500: PUSH
96501: LD_INT 106
96503: PUSH
96504: LD_INT 108
96506: PUSH
96507: LD_INT 109
96509: PUSH
96510: LD_INT 112
96512: PUSH
96513: LD_INT 116
96515: PUSH
96516: LD_INT 117
96518: PUSH
96519: LD_INT 118
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: ST_TO_ADDR
96538: GO 99201
96540: LD_INT 6
96542: DOUBLE
96543: EQUAL
96544: IFTRUE 96548
96546: GO 96680
96548: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96549: LD_ADDR_VAR 0 2
96553: PUSH
96554: LD_INT 2
96556: PUSH
96557: LD_INT 4
96559: PUSH
96560: LD_INT 5
96562: PUSH
96563: LD_INT 6
96565: PUSH
96566: LD_INT 8
96568: PUSH
96569: LD_INT 11
96571: PUSH
96572: LD_INT 12
96574: PUSH
96575: LD_INT 15
96577: PUSH
96578: LD_INT 16
96580: PUSH
96581: LD_INT 20
96583: PUSH
96584: LD_INT 21
96586: PUSH
96587: LD_INT 22
96589: PUSH
96590: LD_INT 23
96592: PUSH
96593: LD_INT 25
96595: PUSH
96596: LD_INT 26
96598: PUSH
96599: LD_INT 30
96601: PUSH
96602: LD_INT 31
96604: PUSH
96605: LD_INT 32
96607: PUSH
96608: LD_INT 36
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 101
96634: PUSH
96635: LD_INT 102
96637: PUSH
96638: LD_INT 105
96640: PUSH
96641: LD_INT 106
96643: PUSH
96644: LD_INT 108
96646: PUSH
96647: LD_INT 109
96649: PUSH
96650: LD_INT 112
96652: PUSH
96653: LD_INT 116
96655: PUSH
96656: LD_INT 117
96658: PUSH
96659: LD_INT 118
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: ST_TO_ADDR
96678: GO 99201
96680: LD_INT 7
96682: DOUBLE
96683: EQUAL
96684: IFTRUE 96688
96686: GO 96800
96688: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96689: LD_ADDR_VAR 0 2
96693: PUSH
96694: LD_INT 2
96696: PUSH
96697: LD_INT 4
96699: PUSH
96700: LD_INT 5
96702: PUSH
96703: LD_INT 7
96705: PUSH
96706: LD_INT 11
96708: PUSH
96709: LD_INT 12
96711: PUSH
96712: LD_INT 15
96714: PUSH
96715: LD_INT 16
96717: PUSH
96718: LD_INT 20
96720: PUSH
96721: LD_INT 21
96723: PUSH
96724: LD_INT 22
96726: PUSH
96727: LD_INT 23
96729: PUSH
96730: LD_INT 25
96732: PUSH
96733: LD_INT 26
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: PUSH
96752: LD_INT 101
96754: PUSH
96755: LD_INT 102
96757: PUSH
96758: LD_INT 103
96760: PUSH
96761: LD_INT 105
96763: PUSH
96764: LD_INT 106
96766: PUSH
96767: LD_INT 108
96769: PUSH
96770: LD_INT 112
96772: PUSH
96773: LD_INT 116
96775: PUSH
96776: LD_INT 117
96778: PUSH
96779: LD_INT 118
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: ST_TO_ADDR
96798: GO 99201
96800: LD_INT 8
96802: DOUBLE
96803: EQUAL
96804: IFTRUE 96808
96806: GO 96948
96808: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96809: LD_ADDR_VAR 0 2
96813: PUSH
96814: LD_INT 2
96816: PUSH
96817: LD_INT 4
96819: PUSH
96820: LD_INT 5
96822: PUSH
96823: LD_INT 6
96825: PUSH
96826: LD_INT 7
96828: PUSH
96829: LD_INT 8
96831: PUSH
96832: LD_INT 11
96834: PUSH
96835: LD_INT 12
96837: PUSH
96838: LD_INT 15
96840: PUSH
96841: LD_INT 16
96843: PUSH
96844: LD_INT 20
96846: PUSH
96847: LD_INT 21
96849: PUSH
96850: LD_INT 22
96852: PUSH
96853: LD_INT 23
96855: PUSH
96856: LD_INT 25
96858: PUSH
96859: LD_INT 26
96861: PUSH
96862: LD_INT 30
96864: PUSH
96865: LD_INT 31
96867: PUSH
96868: LD_INT 32
96870: PUSH
96871: LD_INT 36
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 101
96898: PUSH
96899: LD_INT 102
96901: PUSH
96902: LD_INT 103
96904: PUSH
96905: LD_INT 105
96907: PUSH
96908: LD_INT 106
96910: PUSH
96911: LD_INT 108
96913: PUSH
96914: LD_INT 109
96916: PUSH
96917: LD_INT 112
96919: PUSH
96920: LD_INT 116
96922: PUSH
96923: LD_INT 117
96925: PUSH
96926: LD_INT 118
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: ST_TO_ADDR
96946: GO 99201
96948: LD_INT 9
96950: DOUBLE
96951: EQUAL
96952: IFTRUE 96956
96954: GO 97104
96956: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96957: LD_ADDR_VAR 0 2
96961: PUSH
96962: LD_INT 2
96964: PUSH
96965: LD_INT 4
96967: PUSH
96968: LD_INT 5
96970: PUSH
96971: LD_INT 6
96973: PUSH
96974: LD_INT 7
96976: PUSH
96977: LD_INT 8
96979: PUSH
96980: LD_INT 11
96982: PUSH
96983: LD_INT 12
96985: PUSH
96986: LD_INT 15
96988: PUSH
96989: LD_INT 16
96991: PUSH
96992: LD_INT 20
96994: PUSH
96995: LD_INT 21
96997: PUSH
96998: LD_INT 22
97000: PUSH
97001: LD_INT 23
97003: PUSH
97004: LD_INT 25
97006: PUSH
97007: LD_INT 26
97009: PUSH
97010: LD_INT 28
97012: PUSH
97013: LD_INT 30
97015: PUSH
97016: LD_INT 31
97018: PUSH
97019: LD_INT 32
97021: PUSH
97022: LD_INT 36
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 101
97050: PUSH
97051: LD_INT 102
97053: PUSH
97054: LD_INT 103
97056: PUSH
97057: LD_INT 105
97059: PUSH
97060: LD_INT 106
97062: PUSH
97063: LD_INT 108
97065: PUSH
97066: LD_INT 109
97068: PUSH
97069: LD_INT 112
97071: PUSH
97072: LD_INT 114
97074: PUSH
97075: LD_INT 116
97077: PUSH
97078: LD_INT 117
97080: PUSH
97081: LD_INT 118
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: ST_TO_ADDR
97102: GO 99201
97104: LD_INT 10
97106: DOUBLE
97107: EQUAL
97108: IFTRUE 97112
97110: GO 97308
97112: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97113: LD_ADDR_VAR 0 2
97117: PUSH
97118: LD_INT 2
97120: PUSH
97121: LD_INT 4
97123: PUSH
97124: LD_INT 5
97126: PUSH
97127: LD_INT 6
97129: PUSH
97130: LD_INT 7
97132: PUSH
97133: LD_INT 8
97135: PUSH
97136: LD_INT 9
97138: PUSH
97139: LD_INT 10
97141: PUSH
97142: LD_INT 11
97144: PUSH
97145: LD_INT 12
97147: PUSH
97148: LD_INT 13
97150: PUSH
97151: LD_INT 14
97153: PUSH
97154: LD_INT 15
97156: PUSH
97157: LD_INT 16
97159: PUSH
97160: LD_INT 17
97162: PUSH
97163: LD_INT 18
97165: PUSH
97166: LD_INT 19
97168: PUSH
97169: LD_INT 20
97171: PUSH
97172: LD_INT 21
97174: PUSH
97175: LD_INT 22
97177: PUSH
97178: LD_INT 23
97180: PUSH
97181: LD_INT 24
97183: PUSH
97184: LD_INT 25
97186: PUSH
97187: LD_INT 26
97189: PUSH
97190: LD_INT 28
97192: PUSH
97193: LD_INT 30
97195: PUSH
97196: LD_INT 31
97198: PUSH
97199: LD_INT 32
97201: PUSH
97202: LD_INT 36
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 101
97238: PUSH
97239: LD_INT 102
97241: PUSH
97242: LD_INT 103
97244: PUSH
97245: LD_INT 104
97247: PUSH
97248: LD_INT 105
97250: PUSH
97251: LD_INT 106
97253: PUSH
97254: LD_INT 107
97256: PUSH
97257: LD_INT 108
97259: PUSH
97260: LD_INT 109
97262: PUSH
97263: LD_INT 110
97265: PUSH
97266: LD_INT 111
97268: PUSH
97269: LD_INT 112
97271: PUSH
97272: LD_INT 114
97274: PUSH
97275: LD_INT 116
97277: PUSH
97278: LD_INT 117
97280: PUSH
97281: LD_INT 118
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: ST_TO_ADDR
97306: GO 99201
97308: LD_INT 11
97310: DOUBLE
97311: EQUAL
97312: IFTRUE 97316
97314: GO 97520
97316: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97317: LD_ADDR_VAR 0 2
97321: PUSH
97322: LD_INT 2
97324: PUSH
97325: LD_INT 3
97327: PUSH
97328: LD_INT 4
97330: PUSH
97331: LD_INT 5
97333: PUSH
97334: LD_INT 6
97336: PUSH
97337: LD_INT 7
97339: PUSH
97340: LD_INT 8
97342: PUSH
97343: LD_INT 9
97345: PUSH
97346: LD_INT 10
97348: PUSH
97349: LD_INT 11
97351: PUSH
97352: LD_INT 12
97354: PUSH
97355: LD_INT 13
97357: PUSH
97358: LD_INT 14
97360: PUSH
97361: LD_INT 15
97363: PUSH
97364: LD_INT 16
97366: PUSH
97367: LD_INT 17
97369: PUSH
97370: LD_INT 18
97372: PUSH
97373: LD_INT 19
97375: PUSH
97376: LD_INT 20
97378: PUSH
97379: LD_INT 21
97381: PUSH
97382: LD_INT 22
97384: PUSH
97385: LD_INT 23
97387: PUSH
97388: LD_INT 24
97390: PUSH
97391: LD_INT 25
97393: PUSH
97394: LD_INT 26
97396: PUSH
97397: LD_INT 28
97399: PUSH
97400: LD_INT 30
97402: PUSH
97403: LD_INT 31
97405: PUSH
97406: LD_INT 32
97408: PUSH
97409: LD_INT 34
97411: PUSH
97412: LD_INT 36
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: PUSH
97448: LD_INT 101
97450: PUSH
97451: LD_INT 102
97453: PUSH
97454: LD_INT 103
97456: PUSH
97457: LD_INT 104
97459: PUSH
97460: LD_INT 105
97462: PUSH
97463: LD_INT 106
97465: PUSH
97466: LD_INT 107
97468: PUSH
97469: LD_INT 108
97471: PUSH
97472: LD_INT 109
97474: PUSH
97475: LD_INT 110
97477: PUSH
97478: LD_INT 111
97480: PUSH
97481: LD_INT 112
97483: PUSH
97484: LD_INT 114
97486: PUSH
97487: LD_INT 116
97489: PUSH
97490: LD_INT 117
97492: PUSH
97493: LD_INT 118
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: ST_TO_ADDR
97518: GO 99201
97520: LD_INT 12
97522: DOUBLE
97523: EQUAL
97524: IFTRUE 97528
97526: GO 97748
97528: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97529: LD_ADDR_VAR 0 2
97533: PUSH
97534: LD_INT 1
97536: PUSH
97537: LD_INT 2
97539: PUSH
97540: LD_INT 3
97542: PUSH
97543: LD_INT 4
97545: PUSH
97546: LD_INT 5
97548: PUSH
97549: LD_INT 6
97551: PUSH
97552: LD_INT 7
97554: PUSH
97555: LD_INT 8
97557: PUSH
97558: LD_INT 9
97560: PUSH
97561: LD_INT 10
97563: PUSH
97564: LD_INT 11
97566: PUSH
97567: LD_INT 12
97569: PUSH
97570: LD_INT 13
97572: PUSH
97573: LD_INT 14
97575: PUSH
97576: LD_INT 15
97578: PUSH
97579: LD_INT 16
97581: PUSH
97582: LD_INT 17
97584: PUSH
97585: LD_INT 18
97587: PUSH
97588: LD_INT 19
97590: PUSH
97591: LD_INT 20
97593: PUSH
97594: LD_INT 21
97596: PUSH
97597: LD_INT 22
97599: PUSH
97600: LD_INT 23
97602: PUSH
97603: LD_INT 24
97605: PUSH
97606: LD_INT 25
97608: PUSH
97609: LD_INT 26
97611: PUSH
97612: LD_INT 27
97614: PUSH
97615: LD_INT 28
97617: PUSH
97618: LD_INT 30
97620: PUSH
97621: LD_INT 31
97623: PUSH
97624: LD_INT 32
97626: PUSH
97627: LD_INT 33
97629: PUSH
97630: LD_INT 34
97632: PUSH
97633: LD_INT 36
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 101
97674: PUSH
97675: LD_INT 102
97677: PUSH
97678: LD_INT 103
97680: PUSH
97681: LD_INT 104
97683: PUSH
97684: LD_INT 105
97686: PUSH
97687: LD_INT 106
97689: PUSH
97690: LD_INT 107
97692: PUSH
97693: LD_INT 108
97695: PUSH
97696: LD_INT 109
97698: PUSH
97699: LD_INT 110
97701: PUSH
97702: LD_INT 111
97704: PUSH
97705: LD_INT 112
97707: PUSH
97708: LD_INT 113
97710: PUSH
97711: LD_INT 114
97713: PUSH
97714: LD_INT 116
97716: PUSH
97717: LD_INT 117
97719: PUSH
97720: LD_INT 118
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: ST_TO_ADDR
97746: GO 99201
97748: LD_INT 13
97750: DOUBLE
97751: EQUAL
97752: IFTRUE 97756
97754: GO 97964
97756: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97757: LD_ADDR_VAR 0 2
97761: PUSH
97762: LD_INT 1
97764: PUSH
97765: LD_INT 2
97767: PUSH
97768: LD_INT 3
97770: PUSH
97771: LD_INT 4
97773: PUSH
97774: LD_INT 5
97776: PUSH
97777: LD_INT 8
97779: PUSH
97780: LD_INT 9
97782: PUSH
97783: LD_INT 10
97785: PUSH
97786: LD_INT 11
97788: PUSH
97789: LD_INT 12
97791: PUSH
97792: LD_INT 14
97794: PUSH
97795: LD_INT 15
97797: PUSH
97798: LD_INT 16
97800: PUSH
97801: LD_INT 17
97803: PUSH
97804: LD_INT 18
97806: PUSH
97807: LD_INT 19
97809: PUSH
97810: LD_INT 20
97812: PUSH
97813: LD_INT 21
97815: PUSH
97816: LD_INT 22
97818: PUSH
97819: LD_INT 23
97821: PUSH
97822: LD_INT 24
97824: PUSH
97825: LD_INT 25
97827: PUSH
97828: LD_INT 26
97830: PUSH
97831: LD_INT 27
97833: PUSH
97834: LD_INT 28
97836: PUSH
97837: LD_INT 30
97839: PUSH
97840: LD_INT 31
97842: PUSH
97843: LD_INT 32
97845: PUSH
97846: LD_INT 33
97848: PUSH
97849: LD_INT 34
97851: PUSH
97852: LD_INT 36
97854: PUSH
97855: EMPTY
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 101
97890: PUSH
97891: LD_INT 102
97893: PUSH
97894: LD_INT 103
97896: PUSH
97897: LD_INT 104
97899: PUSH
97900: LD_INT 105
97902: PUSH
97903: LD_INT 106
97905: PUSH
97906: LD_INT 107
97908: PUSH
97909: LD_INT 108
97911: PUSH
97912: LD_INT 109
97914: PUSH
97915: LD_INT 110
97917: PUSH
97918: LD_INT 111
97920: PUSH
97921: LD_INT 112
97923: PUSH
97924: LD_INT 113
97926: PUSH
97927: LD_INT 114
97929: PUSH
97930: LD_INT 116
97932: PUSH
97933: LD_INT 117
97935: PUSH
97936: LD_INT 118
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: PUSH
97958: EMPTY
97959: LIST
97960: LIST
97961: ST_TO_ADDR
97962: GO 99201
97964: LD_INT 14
97966: DOUBLE
97967: EQUAL
97968: IFTRUE 97972
97970: GO 98196
97972: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97973: LD_ADDR_VAR 0 2
97977: PUSH
97978: LD_INT 1
97980: PUSH
97981: LD_INT 2
97983: PUSH
97984: LD_INT 3
97986: PUSH
97987: LD_INT 4
97989: PUSH
97990: LD_INT 5
97992: PUSH
97993: LD_INT 6
97995: PUSH
97996: LD_INT 7
97998: PUSH
97999: LD_INT 8
98001: PUSH
98002: LD_INT 9
98004: PUSH
98005: LD_INT 10
98007: PUSH
98008: LD_INT 11
98010: PUSH
98011: LD_INT 12
98013: PUSH
98014: LD_INT 13
98016: PUSH
98017: LD_INT 14
98019: PUSH
98020: LD_INT 15
98022: PUSH
98023: LD_INT 16
98025: PUSH
98026: LD_INT 17
98028: PUSH
98029: LD_INT 18
98031: PUSH
98032: LD_INT 19
98034: PUSH
98035: LD_INT 20
98037: PUSH
98038: LD_INT 21
98040: PUSH
98041: LD_INT 22
98043: PUSH
98044: LD_INT 23
98046: PUSH
98047: LD_INT 24
98049: PUSH
98050: LD_INT 25
98052: PUSH
98053: LD_INT 26
98055: PUSH
98056: LD_INT 27
98058: PUSH
98059: LD_INT 28
98061: PUSH
98062: LD_INT 29
98064: PUSH
98065: LD_INT 30
98067: PUSH
98068: LD_INT 31
98070: PUSH
98071: LD_INT 32
98073: PUSH
98074: LD_INT 33
98076: PUSH
98077: LD_INT 34
98079: PUSH
98080: LD_INT 36
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: PUSH
98120: LD_INT 101
98122: PUSH
98123: LD_INT 102
98125: PUSH
98126: LD_INT 103
98128: PUSH
98129: LD_INT 104
98131: PUSH
98132: LD_INT 105
98134: PUSH
98135: LD_INT 106
98137: PUSH
98138: LD_INT 107
98140: PUSH
98141: LD_INT 108
98143: PUSH
98144: LD_INT 109
98146: PUSH
98147: LD_INT 110
98149: PUSH
98150: LD_INT 111
98152: PUSH
98153: LD_INT 112
98155: PUSH
98156: LD_INT 113
98158: PUSH
98159: LD_INT 114
98161: PUSH
98162: LD_INT 116
98164: PUSH
98165: LD_INT 117
98167: PUSH
98168: LD_INT 118
98170: PUSH
98171: EMPTY
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: ST_TO_ADDR
98194: GO 99201
98196: LD_INT 15
98198: DOUBLE
98199: EQUAL
98200: IFTRUE 98204
98202: GO 98428
98204: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98205: LD_ADDR_VAR 0 2
98209: PUSH
98210: LD_INT 1
98212: PUSH
98213: LD_INT 2
98215: PUSH
98216: LD_INT 3
98218: PUSH
98219: LD_INT 4
98221: PUSH
98222: LD_INT 5
98224: PUSH
98225: LD_INT 6
98227: PUSH
98228: LD_INT 7
98230: PUSH
98231: LD_INT 8
98233: PUSH
98234: LD_INT 9
98236: PUSH
98237: LD_INT 10
98239: PUSH
98240: LD_INT 11
98242: PUSH
98243: LD_INT 12
98245: PUSH
98246: LD_INT 13
98248: PUSH
98249: LD_INT 14
98251: PUSH
98252: LD_INT 15
98254: PUSH
98255: LD_INT 16
98257: PUSH
98258: LD_INT 17
98260: PUSH
98261: LD_INT 18
98263: PUSH
98264: LD_INT 19
98266: PUSH
98267: LD_INT 20
98269: PUSH
98270: LD_INT 21
98272: PUSH
98273: LD_INT 22
98275: PUSH
98276: LD_INT 23
98278: PUSH
98279: LD_INT 24
98281: PUSH
98282: LD_INT 25
98284: PUSH
98285: LD_INT 26
98287: PUSH
98288: LD_INT 27
98290: PUSH
98291: LD_INT 28
98293: PUSH
98294: LD_INT 29
98296: PUSH
98297: LD_INT 30
98299: PUSH
98300: LD_INT 31
98302: PUSH
98303: LD_INT 32
98305: PUSH
98306: LD_INT 33
98308: PUSH
98309: LD_INT 34
98311: PUSH
98312: LD_INT 36
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: PUSH
98352: LD_INT 101
98354: PUSH
98355: LD_INT 102
98357: PUSH
98358: LD_INT 103
98360: PUSH
98361: LD_INT 104
98363: PUSH
98364: LD_INT 105
98366: PUSH
98367: LD_INT 106
98369: PUSH
98370: LD_INT 107
98372: PUSH
98373: LD_INT 108
98375: PUSH
98376: LD_INT 109
98378: PUSH
98379: LD_INT 110
98381: PUSH
98382: LD_INT 111
98384: PUSH
98385: LD_INT 112
98387: PUSH
98388: LD_INT 113
98390: PUSH
98391: LD_INT 114
98393: PUSH
98394: LD_INT 116
98396: PUSH
98397: LD_INT 117
98399: PUSH
98400: LD_INT 118
98402: PUSH
98403: EMPTY
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: ST_TO_ADDR
98426: GO 99201
98428: LD_INT 16
98430: DOUBLE
98431: EQUAL
98432: IFTRUE 98436
98434: GO 98572
98436: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98437: LD_ADDR_VAR 0 2
98441: PUSH
98442: LD_INT 2
98444: PUSH
98445: LD_INT 4
98447: PUSH
98448: LD_INT 5
98450: PUSH
98451: LD_INT 7
98453: PUSH
98454: LD_INT 11
98456: PUSH
98457: LD_INT 12
98459: PUSH
98460: LD_INT 15
98462: PUSH
98463: LD_INT 16
98465: PUSH
98466: LD_INT 20
98468: PUSH
98469: LD_INT 21
98471: PUSH
98472: LD_INT 22
98474: PUSH
98475: LD_INT 23
98477: PUSH
98478: LD_INT 25
98480: PUSH
98481: LD_INT 26
98483: PUSH
98484: LD_INT 30
98486: PUSH
98487: LD_INT 31
98489: PUSH
98490: LD_INT 32
98492: PUSH
98493: LD_INT 33
98495: PUSH
98496: LD_INT 34
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: PUSH
98520: LD_INT 101
98522: PUSH
98523: LD_INT 102
98525: PUSH
98526: LD_INT 103
98528: PUSH
98529: LD_INT 106
98531: PUSH
98532: LD_INT 108
98534: PUSH
98535: LD_INT 112
98537: PUSH
98538: LD_INT 113
98540: PUSH
98541: LD_INT 114
98543: PUSH
98544: LD_INT 116
98546: PUSH
98547: LD_INT 117
98549: PUSH
98550: LD_INT 118
98552: PUSH
98553: EMPTY
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: ST_TO_ADDR
98570: GO 99201
98572: LD_INT 17
98574: DOUBLE
98575: EQUAL
98576: IFTRUE 98580
98578: GO 98804
98580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98581: LD_ADDR_VAR 0 2
98585: PUSH
98586: LD_INT 1
98588: PUSH
98589: LD_INT 2
98591: PUSH
98592: LD_INT 3
98594: PUSH
98595: LD_INT 4
98597: PUSH
98598: LD_INT 5
98600: PUSH
98601: LD_INT 6
98603: PUSH
98604: LD_INT 7
98606: PUSH
98607: LD_INT 8
98609: PUSH
98610: LD_INT 9
98612: PUSH
98613: LD_INT 10
98615: PUSH
98616: LD_INT 11
98618: PUSH
98619: LD_INT 12
98621: PUSH
98622: LD_INT 13
98624: PUSH
98625: LD_INT 14
98627: PUSH
98628: LD_INT 15
98630: PUSH
98631: LD_INT 16
98633: PUSH
98634: LD_INT 17
98636: PUSH
98637: LD_INT 18
98639: PUSH
98640: LD_INT 19
98642: PUSH
98643: LD_INT 20
98645: PUSH
98646: LD_INT 21
98648: PUSH
98649: LD_INT 22
98651: PUSH
98652: LD_INT 23
98654: PUSH
98655: LD_INT 24
98657: PUSH
98658: LD_INT 25
98660: PUSH
98661: LD_INT 26
98663: PUSH
98664: LD_INT 27
98666: PUSH
98667: LD_INT 28
98669: PUSH
98670: LD_INT 29
98672: PUSH
98673: LD_INT 30
98675: PUSH
98676: LD_INT 31
98678: PUSH
98679: LD_INT 32
98681: PUSH
98682: LD_INT 33
98684: PUSH
98685: LD_INT 34
98687: PUSH
98688: LD_INT 36
98690: PUSH
98691: EMPTY
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: PUSH
98728: LD_INT 101
98730: PUSH
98731: LD_INT 102
98733: PUSH
98734: LD_INT 103
98736: PUSH
98737: LD_INT 104
98739: PUSH
98740: LD_INT 105
98742: PUSH
98743: LD_INT 106
98745: PUSH
98746: LD_INT 107
98748: PUSH
98749: LD_INT 108
98751: PUSH
98752: LD_INT 109
98754: PUSH
98755: LD_INT 110
98757: PUSH
98758: LD_INT 111
98760: PUSH
98761: LD_INT 112
98763: PUSH
98764: LD_INT 113
98766: PUSH
98767: LD_INT 114
98769: PUSH
98770: LD_INT 116
98772: PUSH
98773: LD_INT 117
98775: PUSH
98776: LD_INT 118
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: PUSH
98798: EMPTY
98799: LIST
98800: LIST
98801: ST_TO_ADDR
98802: GO 99201
98804: LD_INT 18
98806: DOUBLE
98807: EQUAL
98808: IFTRUE 98812
98810: GO 98960
98812: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98813: LD_ADDR_VAR 0 2
98817: PUSH
98818: LD_INT 2
98820: PUSH
98821: LD_INT 4
98823: PUSH
98824: LD_INT 5
98826: PUSH
98827: LD_INT 7
98829: PUSH
98830: LD_INT 11
98832: PUSH
98833: LD_INT 12
98835: PUSH
98836: LD_INT 15
98838: PUSH
98839: LD_INT 16
98841: PUSH
98842: LD_INT 20
98844: PUSH
98845: LD_INT 21
98847: PUSH
98848: LD_INT 22
98850: PUSH
98851: LD_INT 23
98853: PUSH
98854: LD_INT 25
98856: PUSH
98857: LD_INT 26
98859: PUSH
98860: LD_INT 30
98862: PUSH
98863: LD_INT 31
98865: PUSH
98866: LD_INT 32
98868: PUSH
98869: LD_INT 33
98871: PUSH
98872: LD_INT 34
98874: PUSH
98875: LD_INT 35
98877: PUSH
98878: LD_INT 36
98880: PUSH
98881: EMPTY
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 101
98906: PUSH
98907: LD_INT 102
98909: PUSH
98910: LD_INT 103
98912: PUSH
98913: LD_INT 106
98915: PUSH
98916: LD_INT 108
98918: PUSH
98919: LD_INT 112
98921: PUSH
98922: LD_INT 113
98924: PUSH
98925: LD_INT 114
98927: PUSH
98928: LD_INT 115
98930: PUSH
98931: LD_INT 116
98933: PUSH
98934: LD_INT 117
98936: PUSH
98937: LD_INT 118
98939: PUSH
98940: EMPTY
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: ST_TO_ADDR
98958: GO 99201
98960: LD_INT 19
98962: DOUBLE
98963: EQUAL
98964: IFTRUE 98968
98966: GO 99200
98968: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98969: LD_ADDR_VAR 0 2
98973: PUSH
98974: LD_INT 1
98976: PUSH
98977: LD_INT 2
98979: PUSH
98980: LD_INT 3
98982: PUSH
98983: LD_INT 4
98985: PUSH
98986: LD_INT 5
98988: PUSH
98989: LD_INT 6
98991: PUSH
98992: LD_INT 7
98994: PUSH
98995: LD_INT 8
98997: PUSH
98998: LD_INT 9
99000: PUSH
99001: LD_INT 10
99003: PUSH
99004: LD_INT 11
99006: PUSH
99007: LD_INT 12
99009: PUSH
99010: LD_INT 13
99012: PUSH
99013: LD_INT 14
99015: PUSH
99016: LD_INT 15
99018: PUSH
99019: LD_INT 16
99021: PUSH
99022: LD_INT 17
99024: PUSH
99025: LD_INT 18
99027: PUSH
99028: LD_INT 19
99030: PUSH
99031: LD_INT 20
99033: PUSH
99034: LD_INT 21
99036: PUSH
99037: LD_INT 22
99039: PUSH
99040: LD_INT 23
99042: PUSH
99043: LD_INT 24
99045: PUSH
99046: LD_INT 25
99048: PUSH
99049: LD_INT 26
99051: PUSH
99052: LD_INT 27
99054: PUSH
99055: LD_INT 28
99057: PUSH
99058: LD_INT 29
99060: PUSH
99061: LD_INT 30
99063: PUSH
99064: LD_INT 31
99066: PUSH
99067: LD_INT 32
99069: PUSH
99070: LD_INT 33
99072: PUSH
99073: LD_INT 34
99075: PUSH
99076: LD_INT 35
99078: PUSH
99079: LD_INT 36
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: LIST
99097: LIST
99098: LIST
99099: LIST
99100: LIST
99101: LIST
99102: LIST
99103: LIST
99104: LIST
99105: LIST
99106: LIST
99107: LIST
99108: LIST
99109: LIST
99110: LIST
99111: LIST
99112: LIST
99113: LIST
99114: LIST
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: PUSH
99120: LD_INT 101
99122: PUSH
99123: LD_INT 102
99125: PUSH
99126: LD_INT 103
99128: PUSH
99129: LD_INT 104
99131: PUSH
99132: LD_INT 105
99134: PUSH
99135: LD_INT 106
99137: PUSH
99138: LD_INT 107
99140: PUSH
99141: LD_INT 108
99143: PUSH
99144: LD_INT 109
99146: PUSH
99147: LD_INT 110
99149: PUSH
99150: LD_INT 111
99152: PUSH
99153: LD_INT 112
99155: PUSH
99156: LD_INT 113
99158: PUSH
99159: LD_INT 114
99161: PUSH
99162: LD_INT 115
99164: PUSH
99165: LD_INT 116
99167: PUSH
99168: LD_INT 117
99170: PUSH
99171: LD_INT 118
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: ST_TO_ADDR
99198: GO 99201
99200: POP
// end else
99201: GO 99432
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99203: LD_ADDR_VAR 0 2
99207: PUSH
99208: LD_INT 1
99210: PUSH
99211: LD_INT 2
99213: PUSH
99214: LD_INT 3
99216: PUSH
99217: LD_INT 4
99219: PUSH
99220: LD_INT 5
99222: PUSH
99223: LD_INT 6
99225: PUSH
99226: LD_INT 7
99228: PUSH
99229: LD_INT 8
99231: PUSH
99232: LD_INT 9
99234: PUSH
99235: LD_INT 10
99237: PUSH
99238: LD_INT 11
99240: PUSH
99241: LD_INT 12
99243: PUSH
99244: LD_INT 13
99246: PUSH
99247: LD_INT 14
99249: PUSH
99250: LD_INT 15
99252: PUSH
99253: LD_INT 16
99255: PUSH
99256: LD_INT 17
99258: PUSH
99259: LD_INT 18
99261: PUSH
99262: LD_INT 19
99264: PUSH
99265: LD_INT 20
99267: PUSH
99268: LD_INT 21
99270: PUSH
99271: LD_INT 22
99273: PUSH
99274: LD_INT 23
99276: PUSH
99277: LD_INT 24
99279: PUSH
99280: LD_INT 25
99282: PUSH
99283: LD_INT 26
99285: PUSH
99286: LD_INT 27
99288: PUSH
99289: LD_INT 28
99291: PUSH
99292: LD_INT 29
99294: PUSH
99295: LD_INT 30
99297: PUSH
99298: LD_INT 31
99300: PUSH
99301: LD_INT 32
99303: PUSH
99304: LD_INT 33
99306: PUSH
99307: LD_INT 34
99309: PUSH
99310: LD_INT 35
99312: PUSH
99313: LD_INT 36
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: PUSH
99354: LD_INT 101
99356: PUSH
99357: LD_INT 102
99359: PUSH
99360: LD_INT 103
99362: PUSH
99363: LD_INT 104
99365: PUSH
99366: LD_INT 105
99368: PUSH
99369: LD_INT 106
99371: PUSH
99372: LD_INT 107
99374: PUSH
99375: LD_INT 108
99377: PUSH
99378: LD_INT 109
99380: PUSH
99381: LD_INT 110
99383: PUSH
99384: LD_INT 111
99386: PUSH
99387: LD_INT 112
99389: PUSH
99390: LD_INT 113
99392: PUSH
99393: LD_INT 114
99395: PUSH
99396: LD_INT 115
99398: PUSH
99399: LD_INT 116
99401: PUSH
99402: LD_INT 117
99404: PUSH
99405: LD_INT 118
99407: PUSH
99408: EMPTY
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: ST_TO_ADDR
// if result then
99432: LD_VAR 0 2
99436: IFFALSE 100222
// begin normal :=  ;
99438: LD_ADDR_VAR 0 5
99442: PUSH
99443: LD_STRING 
99445: ST_TO_ADDR
// hardcore :=  ;
99446: LD_ADDR_VAR 0 6
99450: PUSH
99451: LD_STRING 
99453: ST_TO_ADDR
// active :=  ;
99454: LD_ADDR_VAR 0 7
99458: PUSH
99459: LD_STRING 
99461: ST_TO_ADDR
// for i = 1 to normalCounter do
99462: LD_ADDR_VAR 0 8
99466: PUSH
99467: DOUBLE
99468: LD_INT 1
99470: DEC
99471: ST_TO_ADDR
99472: LD_EXP 125
99476: PUSH
99477: FOR_TO
99478: IFFALSE 99579
// begin tmp := 0 ;
99480: LD_ADDR_VAR 0 3
99484: PUSH
99485: LD_STRING 0
99487: ST_TO_ADDR
// if result [ 1 ] then
99488: LD_VAR 0 2
99492: PUSH
99493: LD_INT 1
99495: ARRAY
99496: IFFALSE 99561
// if result [ 1 ] [ 1 ] = i then
99498: LD_VAR 0 2
99502: PUSH
99503: LD_INT 1
99505: ARRAY
99506: PUSH
99507: LD_INT 1
99509: ARRAY
99510: PUSH
99511: LD_VAR 0 8
99515: EQUAL
99516: IFFALSE 99561
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99518: LD_ADDR_VAR 0 2
99522: PUSH
99523: LD_VAR 0 2
99527: PPUSH
99528: LD_INT 1
99530: PPUSH
99531: LD_VAR 0 2
99535: PUSH
99536: LD_INT 1
99538: ARRAY
99539: PPUSH
99540: LD_INT 1
99542: PPUSH
99543: CALL_OW 3
99547: PPUSH
99548: CALL_OW 1
99552: ST_TO_ADDR
// tmp := 1 ;
99553: LD_ADDR_VAR 0 3
99557: PUSH
99558: LD_STRING 1
99560: ST_TO_ADDR
// end ; normal := normal & tmp ;
99561: LD_ADDR_VAR 0 5
99565: PUSH
99566: LD_VAR 0 5
99570: PUSH
99571: LD_VAR 0 3
99575: STR
99576: ST_TO_ADDR
// end ;
99577: GO 99477
99579: POP
99580: POP
// for i = 1 to hardcoreCounter do
99581: LD_ADDR_VAR 0 8
99585: PUSH
99586: DOUBLE
99587: LD_INT 1
99589: DEC
99590: ST_TO_ADDR
99591: LD_EXP 126
99595: PUSH
99596: FOR_TO
99597: IFFALSE 99702
// begin tmp := 0 ;
99599: LD_ADDR_VAR 0 3
99603: PUSH
99604: LD_STRING 0
99606: ST_TO_ADDR
// if result [ 2 ] then
99607: LD_VAR 0 2
99611: PUSH
99612: LD_INT 2
99614: ARRAY
99615: IFFALSE 99684
// if result [ 2 ] [ 1 ] = 100 + i then
99617: LD_VAR 0 2
99621: PUSH
99622: LD_INT 2
99624: ARRAY
99625: PUSH
99626: LD_INT 1
99628: ARRAY
99629: PUSH
99630: LD_INT 100
99632: PUSH
99633: LD_VAR 0 8
99637: PLUS
99638: EQUAL
99639: IFFALSE 99684
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99641: LD_ADDR_VAR 0 2
99645: PUSH
99646: LD_VAR 0 2
99650: PPUSH
99651: LD_INT 2
99653: PPUSH
99654: LD_VAR 0 2
99658: PUSH
99659: LD_INT 2
99661: ARRAY
99662: PPUSH
99663: LD_INT 1
99665: PPUSH
99666: CALL_OW 3
99670: PPUSH
99671: CALL_OW 1
99675: ST_TO_ADDR
// tmp := 1 ;
99676: LD_ADDR_VAR 0 3
99680: PUSH
99681: LD_STRING 1
99683: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99684: LD_ADDR_VAR 0 6
99688: PUSH
99689: LD_VAR 0 6
99693: PUSH
99694: LD_VAR 0 3
99698: STR
99699: ST_TO_ADDR
// end ;
99700: GO 99596
99702: POP
99703: POP
// if isGameLoad then
99704: LD_VAR 0 1
99708: IFFALSE 100183
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99710: LD_ADDR_VAR 0 4
99714: PUSH
99715: LD_EXP 129
99719: PUSH
99720: LD_EXP 128
99724: PUSH
99725: LD_EXP 130
99729: PUSH
99730: LD_EXP 127
99734: PUSH
99735: LD_EXP 131
99739: PUSH
99740: LD_EXP 132
99744: PUSH
99745: LD_EXP 133
99749: PUSH
99750: LD_EXP 134
99754: PUSH
99755: LD_EXP 135
99759: PUSH
99760: LD_EXP 136
99764: PUSH
99765: LD_EXP 137
99769: PUSH
99770: LD_EXP 138
99774: PUSH
99775: LD_EXP 139
99779: PUSH
99780: LD_EXP 140
99784: PUSH
99785: LD_EXP 148
99789: PUSH
99790: LD_EXP 149
99794: PUSH
99795: LD_EXP 150
99799: PUSH
99800: LD_EXP 151
99804: PUSH
99805: LD_EXP 153
99809: PUSH
99810: LD_EXP 154
99814: PUSH
99815: LD_EXP 155
99819: PUSH
99820: LD_EXP 158
99824: PUSH
99825: LD_EXP 160
99829: PUSH
99830: LD_EXP 161
99834: PUSH
99835: LD_EXP 162
99839: PUSH
99840: LD_EXP 164
99844: PUSH
99845: LD_EXP 165
99849: PUSH
99850: LD_EXP 168
99854: PUSH
99855: LD_EXP 169
99859: PUSH
99860: LD_EXP 170
99864: PUSH
99865: LD_EXP 171
99869: PUSH
99870: LD_EXP 172
99874: PUSH
99875: LD_EXP 173
99879: PUSH
99880: LD_EXP 174
99884: PUSH
99885: LD_EXP 175
99889: PUSH
99890: LD_EXP 176
99894: PUSH
99895: LD_EXP 141
99899: PUSH
99900: LD_EXP 142
99904: PUSH
99905: LD_EXP 145
99909: PUSH
99910: LD_EXP 146
99914: PUSH
99915: LD_EXP 147
99919: PUSH
99920: LD_EXP 143
99924: PUSH
99925: LD_EXP 144
99929: PUSH
99930: LD_EXP 152
99934: PUSH
99935: LD_EXP 156
99939: PUSH
99940: LD_EXP 157
99944: PUSH
99945: LD_EXP 159
99949: PUSH
99950: LD_EXP 163
99954: PUSH
99955: LD_EXP 166
99959: PUSH
99960: LD_EXP 167
99964: PUSH
99965: LD_EXP 177
99969: PUSH
99970: LD_EXP 178
99974: PUSH
99975: LD_EXP 179
99979: PUSH
99980: LD_EXP 180
99984: PUSH
99985: EMPTY
99986: LIST
99987: LIST
99988: LIST
99989: LIST
99990: LIST
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: ST_TO_ADDR
// tmp :=  ;
100041: LD_ADDR_VAR 0 3
100045: PUSH
100046: LD_STRING 
100048: ST_TO_ADDR
// for i = 1 to normalCounter do
100049: LD_ADDR_VAR 0 8
100053: PUSH
100054: DOUBLE
100055: LD_INT 1
100057: DEC
100058: ST_TO_ADDR
100059: LD_EXP 125
100063: PUSH
100064: FOR_TO
100065: IFFALSE 100101
// begin if flags [ i ] then
100067: LD_VAR 0 4
100071: PUSH
100072: LD_VAR 0 8
100076: ARRAY
100077: IFFALSE 100099
// tmp := tmp & i & ; ;
100079: LD_ADDR_VAR 0 3
100083: PUSH
100084: LD_VAR 0 3
100088: PUSH
100089: LD_VAR 0 8
100093: STR
100094: PUSH
100095: LD_STRING ;
100097: STR
100098: ST_TO_ADDR
// end ;
100099: GO 100064
100101: POP
100102: POP
// for i = 1 to hardcoreCounter do
100103: LD_ADDR_VAR 0 8
100107: PUSH
100108: DOUBLE
100109: LD_INT 1
100111: DEC
100112: ST_TO_ADDR
100113: LD_EXP 126
100117: PUSH
100118: FOR_TO
100119: IFFALSE 100165
// begin if flags [ normalCounter + i ] then
100121: LD_VAR 0 4
100125: PUSH
100126: LD_EXP 125
100130: PUSH
100131: LD_VAR 0 8
100135: PLUS
100136: ARRAY
100137: IFFALSE 100163
// tmp := tmp & ( 100 + i ) & ; ;
100139: LD_ADDR_VAR 0 3
100143: PUSH
100144: LD_VAR 0 3
100148: PUSH
100149: LD_INT 100
100151: PUSH
100152: LD_VAR 0 8
100156: PLUS
100157: STR
100158: PUSH
100159: LD_STRING ;
100161: STR
100162: ST_TO_ADDR
// end ;
100163: GO 100118
100165: POP
100166: POP
// if tmp then
100167: LD_VAR 0 3
100171: IFFALSE 100183
// active := tmp ;
100173: LD_ADDR_VAR 0 7
100177: PUSH
100178: LD_VAR 0 3
100182: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100183: LD_STRING getStreamItemsFromMission("
100185: PUSH
100186: LD_VAR 0 5
100190: STR
100191: PUSH
100192: LD_STRING ","
100194: STR
100195: PUSH
100196: LD_VAR 0 6
100200: STR
100201: PUSH
100202: LD_STRING ","
100204: STR
100205: PUSH
100206: LD_VAR 0 7
100210: STR
100211: PUSH
100212: LD_STRING ")
100214: STR
100215: PPUSH
100216: CALL_OW 559
// end else
100220: GO 100229
// ToLua ( getStreamItemsFromMission("","","") ) ;
100222: LD_STRING getStreamItemsFromMission("","","")
100224: PPUSH
100225: CALL_OW 559
// end ;
100229: LD_VAR 0 2
100233: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100234: LD_EXP 124
100238: PUSH
100239: LD_EXP 129
100243: AND
100244: IFFALSE 100368
100246: GO 100248
100248: DISABLE
100249: LD_INT 0
100251: PPUSH
100252: PPUSH
// begin enable ;
100253: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100254: LD_ADDR_VAR 0 2
100258: PUSH
100259: LD_INT 22
100261: PUSH
100262: LD_OWVAR 2
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 2
100273: PUSH
100274: LD_INT 34
100276: PUSH
100277: LD_INT 7
100279: PUSH
100280: EMPTY
100281: LIST
100282: LIST
100283: PUSH
100284: LD_INT 34
100286: PUSH
100287: LD_INT 45
100289: PUSH
100290: EMPTY
100291: LIST
100292: LIST
100293: PUSH
100294: LD_INT 34
100296: PUSH
100297: LD_INT 28
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: PUSH
100304: LD_INT 34
100306: PUSH
100307: LD_INT 47
100309: PUSH
100310: EMPTY
100311: LIST
100312: LIST
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: LIST
100318: LIST
100319: LIST
100320: PUSH
100321: EMPTY
100322: LIST
100323: LIST
100324: PPUSH
100325: CALL_OW 69
100329: ST_TO_ADDR
// if not tmp then
100330: LD_VAR 0 2
100334: NOT
100335: IFFALSE 100339
// exit ;
100337: GO 100368
// for i in tmp do
100339: LD_ADDR_VAR 0 1
100343: PUSH
100344: LD_VAR 0 2
100348: PUSH
100349: FOR_IN
100350: IFFALSE 100366
// begin SetLives ( i , 0 ) ;
100352: LD_VAR 0 1
100356: PPUSH
100357: LD_INT 0
100359: PPUSH
100360: CALL_OW 234
// end ;
100364: GO 100349
100366: POP
100367: POP
// end ;
100368: PPOPN 2
100370: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100371: LD_EXP 124
100375: PUSH
100376: LD_EXP 130
100380: AND
100381: IFFALSE 100465
100383: GO 100385
100385: DISABLE
100386: LD_INT 0
100388: PPUSH
100389: PPUSH
// begin enable ;
100390: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100391: LD_ADDR_VAR 0 2
100395: PUSH
100396: LD_INT 22
100398: PUSH
100399: LD_OWVAR 2
100403: PUSH
100404: EMPTY
100405: LIST
100406: LIST
100407: PUSH
100408: LD_INT 32
100410: PUSH
100411: LD_INT 3
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: PPUSH
100422: CALL_OW 69
100426: ST_TO_ADDR
// if not tmp then
100427: LD_VAR 0 2
100431: NOT
100432: IFFALSE 100436
// exit ;
100434: GO 100465
// for i in tmp do
100436: LD_ADDR_VAR 0 1
100440: PUSH
100441: LD_VAR 0 2
100445: PUSH
100446: FOR_IN
100447: IFFALSE 100463
// begin SetLives ( i , 0 ) ;
100449: LD_VAR 0 1
100453: PPUSH
100454: LD_INT 0
100456: PPUSH
100457: CALL_OW 234
// end ;
100461: GO 100446
100463: POP
100464: POP
// end ;
100465: PPOPN 2
100467: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100468: LD_EXP 124
100472: PUSH
100473: LD_EXP 127
100477: AND
100478: IFFALSE 100571
100480: GO 100482
100482: DISABLE
100483: LD_INT 0
100485: PPUSH
// begin enable ;
100486: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100487: LD_ADDR_VAR 0 1
100491: PUSH
100492: LD_INT 22
100494: PUSH
100495: LD_OWVAR 2
100499: PUSH
100500: EMPTY
100501: LIST
100502: LIST
100503: PUSH
100504: LD_INT 2
100506: PUSH
100507: LD_INT 25
100509: PUSH
100510: LD_INT 5
100512: PUSH
100513: EMPTY
100514: LIST
100515: LIST
100516: PUSH
100517: LD_INT 25
100519: PUSH
100520: LD_INT 9
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: PUSH
100527: LD_INT 25
100529: PUSH
100530: LD_INT 8
100532: PUSH
100533: EMPTY
100534: LIST
100535: LIST
100536: PUSH
100537: EMPTY
100538: LIST
100539: LIST
100540: LIST
100541: LIST
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: PPUSH
100547: CALL_OW 69
100551: PUSH
100552: FOR_IN
100553: IFFALSE 100569
// begin SetClass ( i , 1 ) ;
100555: LD_VAR 0 1
100559: PPUSH
100560: LD_INT 1
100562: PPUSH
100563: CALL_OW 336
// end ;
100567: GO 100552
100569: POP
100570: POP
// end ;
100571: PPOPN 1
100573: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100574: LD_EXP 124
100578: PUSH
100579: LD_EXP 128
100583: AND
100584: PUSH
100585: LD_OWVAR 65
100589: PUSH
100590: LD_INT 7
100592: LESS
100593: AND
100594: IFFALSE 100608
100596: GO 100598
100598: DISABLE
// begin enable ;
100599: ENABLE
// game_speed := 7 ;
100600: LD_ADDR_OWVAR 65
100604: PUSH
100605: LD_INT 7
100607: ST_TO_ADDR
// end ;
100608: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100609: LD_EXP 124
100613: PUSH
100614: LD_EXP 131
100618: AND
100619: IFFALSE 100821
100621: GO 100623
100623: DISABLE
100624: LD_INT 0
100626: PPUSH
100627: PPUSH
100628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100629: LD_ADDR_VAR 0 3
100633: PUSH
100634: LD_INT 81
100636: PUSH
100637: LD_OWVAR 2
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: PUSH
100646: LD_INT 21
100648: PUSH
100649: LD_INT 1
100651: PUSH
100652: EMPTY
100653: LIST
100654: LIST
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PPUSH
100660: CALL_OW 69
100664: ST_TO_ADDR
// if not tmp then
100665: LD_VAR 0 3
100669: NOT
100670: IFFALSE 100674
// exit ;
100672: GO 100821
// if tmp > 5 then
100674: LD_VAR 0 3
100678: PUSH
100679: LD_INT 5
100681: GREATER
100682: IFFALSE 100694
// k := 5 else
100684: LD_ADDR_VAR 0 2
100688: PUSH
100689: LD_INT 5
100691: ST_TO_ADDR
100692: GO 100704
// k := tmp ;
100694: LD_ADDR_VAR 0 2
100698: PUSH
100699: LD_VAR 0 3
100703: ST_TO_ADDR
// for i := 1 to k do
100704: LD_ADDR_VAR 0 1
100708: PUSH
100709: DOUBLE
100710: LD_INT 1
100712: DEC
100713: ST_TO_ADDR
100714: LD_VAR 0 2
100718: PUSH
100719: FOR_TO
100720: IFFALSE 100819
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100722: LD_VAR 0 3
100726: PUSH
100727: LD_VAR 0 1
100731: ARRAY
100732: PPUSH
100733: LD_VAR 0 1
100737: PUSH
100738: LD_INT 4
100740: MOD
100741: PUSH
100742: LD_INT 1
100744: PLUS
100745: PPUSH
100746: CALL_OW 259
100750: PUSH
100751: LD_INT 10
100753: LESS
100754: IFFALSE 100817
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100756: LD_VAR 0 3
100760: PUSH
100761: LD_VAR 0 1
100765: ARRAY
100766: PPUSH
100767: LD_VAR 0 1
100771: PUSH
100772: LD_INT 4
100774: MOD
100775: PUSH
100776: LD_INT 1
100778: PLUS
100779: PPUSH
100780: LD_VAR 0 3
100784: PUSH
100785: LD_VAR 0 1
100789: ARRAY
100790: PPUSH
100791: LD_VAR 0 1
100795: PUSH
100796: LD_INT 4
100798: MOD
100799: PUSH
100800: LD_INT 1
100802: PLUS
100803: PPUSH
100804: CALL_OW 259
100808: PUSH
100809: LD_INT 1
100811: PLUS
100812: PPUSH
100813: CALL_OW 237
100817: GO 100719
100819: POP
100820: POP
// end ;
100821: PPOPN 3
100823: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100824: LD_EXP 124
100828: PUSH
100829: LD_EXP 132
100833: AND
100834: IFFALSE 100854
100836: GO 100838
100838: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100839: LD_INT 4
100841: PPUSH
100842: LD_OWVAR 2
100846: PPUSH
100847: LD_INT 0
100849: PPUSH
100850: CALL_OW 324
100854: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100855: LD_EXP 124
100859: PUSH
100860: LD_EXP 161
100864: AND
100865: IFFALSE 100885
100867: GO 100869
100869: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100870: LD_INT 19
100872: PPUSH
100873: LD_OWVAR 2
100877: PPUSH
100878: LD_INT 0
100880: PPUSH
100881: CALL_OW 324
100885: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100886: LD_EXP 124
100890: PUSH
100891: LD_EXP 133
100895: AND
100896: IFFALSE 100998
100898: GO 100900
100900: DISABLE
100901: LD_INT 0
100903: PPUSH
100904: PPUSH
// begin enable ;
100905: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100906: LD_ADDR_VAR 0 2
100910: PUSH
100911: LD_INT 22
100913: PUSH
100914: LD_OWVAR 2
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: LD_INT 2
100925: PUSH
100926: LD_INT 34
100928: PUSH
100929: LD_INT 11
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PUSH
100936: LD_INT 34
100938: PUSH
100939: LD_INT 30
100941: PUSH
100942: EMPTY
100943: LIST
100944: LIST
100945: PUSH
100946: EMPTY
100947: LIST
100948: LIST
100949: LIST
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PPUSH
100955: CALL_OW 69
100959: ST_TO_ADDR
// if not tmp then
100960: LD_VAR 0 2
100964: NOT
100965: IFFALSE 100969
// exit ;
100967: GO 100998
// for i in tmp do
100969: LD_ADDR_VAR 0 1
100973: PUSH
100974: LD_VAR 0 2
100978: PUSH
100979: FOR_IN
100980: IFFALSE 100996
// begin SetLives ( i , 0 ) ;
100982: LD_VAR 0 1
100986: PPUSH
100987: LD_INT 0
100989: PPUSH
100990: CALL_OW 234
// end ;
100994: GO 100979
100996: POP
100997: POP
// end ;
100998: PPOPN 2
101000: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101001: LD_EXP 124
101005: PUSH
101006: LD_EXP 134
101010: AND
101011: IFFALSE 101031
101013: GO 101015
101015: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101016: LD_INT 32
101018: PPUSH
101019: LD_OWVAR 2
101023: PPUSH
101024: LD_INT 0
101026: PPUSH
101027: CALL_OW 324
101031: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101032: LD_EXP 124
101036: PUSH
101037: LD_EXP 135
101041: AND
101042: IFFALSE 101223
101044: GO 101046
101046: DISABLE
101047: LD_INT 0
101049: PPUSH
101050: PPUSH
101051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101052: LD_ADDR_VAR 0 2
101056: PUSH
101057: LD_INT 22
101059: PUSH
101060: LD_OWVAR 2
101064: PUSH
101065: EMPTY
101066: LIST
101067: LIST
101068: PUSH
101069: LD_INT 33
101071: PUSH
101072: LD_INT 3
101074: PUSH
101075: EMPTY
101076: LIST
101077: LIST
101078: PUSH
101079: EMPTY
101080: LIST
101081: LIST
101082: PPUSH
101083: CALL_OW 69
101087: ST_TO_ADDR
// if not tmp then
101088: LD_VAR 0 2
101092: NOT
101093: IFFALSE 101097
// exit ;
101095: GO 101223
// side := 0 ;
101097: LD_ADDR_VAR 0 3
101101: PUSH
101102: LD_INT 0
101104: ST_TO_ADDR
// for i := 1 to 8 do
101105: LD_ADDR_VAR 0 1
101109: PUSH
101110: DOUBLE
101111: LD_INT 1
101113: DEC
101114: ST_TO_ADDR
101115: LD_INT 8
101117: PUSH
101118: FOR_TO
101119: IFFALSE 101167
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101121: LD_OWVAR 2
101125: PUSH
101126: LD_VAR 0 1
101130: NONEQUAL
101131: PUSH
101132: LD_OWVAR 2
101136: PPUSH
101137: LD_VAR 0 1
101141: PPUSH
101142: CALL_OW 81
101146: PUSH
101147: LD_INT 2
101149: EQUAL
101150: AND
101151: IFFALSE 101165
// begin side := i ;
101153: LD_ADDR_VAR 0 3
101157: PUSH
101158: LD_VAR 0 1
101162: ST_TO_ADDR
// break ;
101163: GO 101167
// end ;
101165: GO 101118
101167: POP
101168: POP
// if not side then
101169: LD_VAR 0 3
101173: NOT
101174: IFFALSE 101178
// exit ;
101176: GO 101223
// for i := 1 to tmp do
101178: LD_ADDR_VAR 0 1
101182: PUSH
101183: DOUBLE
101184: LD_INT 1
101186: DEC
101187: ST_TO_ADDR
101188: LD_VAR 0 2
101192: PUSH
101193: FOR_TO
101194: IFFALSE 101221
// if Prob ( 60 ) then
101196: LD_INT 60
101198: PPUSH
101199: CALL_OW 13
101203: IFFALSE 101219
// SetSide ( i , side ) ;
101205: LD_VAR 0 1
101209: PPUSH
101210: LD_VAR 0 3
101214: PPUSH
101215: CALL_OW 235
101219: GO 101193
101221: POP
101222: POP
// end ;
101223: PPOPN 3
101225: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101226: LD_EXP 124
101230: PUSH
101231: LD_EXP 137
101235: AND
101236: IFFALSE 101355
101238: GO 101240
101240: DISABLE
101241: LD_INT 0
101243: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101244: LD_ADDR_VAR 0 1
101248: PUSH
101249: LD_INT 22
101251: PUSH
101252: LD_OWVAR 2
101256: PUSH
101257: EMPTY
101258: LIST
101259: LIST
101260: PUSH
101261: LD_INT 21
101263: PUSH
101264: LD_INT 1
101266: PUSH
101267: EMPTY
101268: LIST
101269: LIST
101270: PUSH
101271: LD_INT 3
101273: PUSH
101274: LD_INT 23
101276: PUSH
101277: LD_INT 0
101279: PUSH
101280: EMPTY
101281: LIST
101282: LIST
101283: PUSH
101284: EMPTY
101285: LIST
101286: LIST
101287: PUSH
101288: EMPTY
101289: LIST
101290: LIST
101291: LIST
101292: PPUSH
101293: CALL_OW 69
101297: PUSH
101298: FOR_IN
101299: IFFALSE 101353
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101301: LD_VAR 0 1
101305: PPUSH
101306: CALL_OW 257
101310: PUSH
101311: LD_INT 1
101313: PUSH
101314: LD_INT 2
101316: PUSH
101317: LD_INT 3
101319: PUSH
101320: LD_INT 4
101322: PUSH
101323: EMPTY
101324: LIST
101325: LIST
101326: LIST
101327: LIST
101328: IN
101329: IFFALSE 101351
// SetClass ( un , rand ( 1 , 4 ) ) ;
101331: LD_VAR 0 1
101335: PPUSH
101336: LD_INT 1
101338: PPUSH
101339: LD_INT 4
101341: PPUSH
101342: CALL_OW 12
101346: PPUSH
101347: CALL_OW 336
101351: GO 101298
101353: POP
101354: POP
// end ;
101355: PPOPN 1
101357: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101358: LD_EXP 124
101362: PUSH
101363: LD_EXP 136
101367: AND
101368: IFFALSE 101447
101370: GO 101372
101372: DISABLE
101373: LD_INT 0
101375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101376: LD_ADDR_VAR 0 1
101380: PUSH
101381: LD_INT 22
101383: PUSH
101384: LD_OWVAR 2
101388: PUSH
101389: EMPTY
101390: LIST
101391: LIST
101392: PUSH
101393: LD_INT 21
101395: PUSH
101396: LD_INT 3
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: PPUSH
101407: CALL_OW 69
101411: ST_TO_ADDR
// if not tmp then
101412: LD_VAR 0 1
101416: NOT
101417: IFFALSE 101421
// exit ;
101419: GO 101447
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101421: LD_VAR 0 1
101425: PUSH
101426: LD_INT 1
101428: PPUSH
101429: LD_VAR 0 1
101433: PPUSH
101434: CALL_OW 12
101438: ARRAY
101439: PPUSH
101440: LD_INT 100
101442: PPUSH
101443: CALL_OW 234
// end ;
101447: PPOPN 1
101449: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101450: LD_EXP 124
101454: PUSH
101455: LD_EXP 138
101459: AND
101460: IFFALSE 101558
101462: GO 101464
101464: DISABLE
101465: LD_INT 0
101467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101468: LD_ADDR_VAR 0 1
101472: PUSH
101473: LD_INT 22
101475: PUSH
101476: LD_OWVAR 2
101480: PUSH
101481: EMPTY
101482: LIST
101483: LIST
101484: PUSH
101485: LD_INT 21
101487: PUSH
101488: LD_INT 1
101490: PUSH
101491: EMPTY
101492: LIST
101493: LIST
101494: PUSH
101495: EMPTY
101496: LIST
101497: LIST
101498: PPUSH
101499: CALL_OW 69
101503: ST_TO_ADDR
// if not tmp then
101504: LD_VAR 0 1
101508: NOT
101509: IFFALSE 101513
// exit ;
101511: GO 101558
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101513: LD_VAR 0 1
101517: PUSH
101518: LD_INT 1
101520: PPUSH
101521: LD_VAR 0 1
101525: PPUSH
101526: CALL_OW 12
101530: ARRAY
101531: PPUSH
101532: LD_INT 1
101534: PPUSH
101535: LD_INT 4
101537: PPUSH
101538: CALL_OW 12
101542: PPUSH
101543: LD_INT 3000
101545: PPUSH
101546: LD_INT 9000
101548: PPUSH
101549: CALL_OW 12
101553: PPUSH
101554: CALL_OW 492
// end ;
101558: PPOPN 1
101560: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101561: LD_EXP 124
101565: PUSH
101566: LD_EXP 139
101570: AND
101571: IFFALSE 101591
101573: GO 101575
101575: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101576: LD_INT 1
101578: PPUSH
101579: LD_OWVAR 2
101583: PPUSH
101584: LD_INT 0
101586: PPUSH
101587: CALL_OW 324
101591: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101592: LD_EXP 124
101596: PUSH
101597: LD_EXP 140
101601: AND
101602: IFFALSE 101685
101604: GO 101606
101606: DISABLE
101607: LD_INT 0
101609: PPUSH
101610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101611: LD_ADDR_VAR 0 2
101615: PUSH
101616: LD_INT 22
101618: PUSH
101619: LD_OWVAR 2
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: LD_INT 21
101630: PUSH
101631: LD_INT 3
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: PUSH
101638: EMPTY
101639: LIST
101640: LIST
101641: PPUSH
101642: CALL_OW 69
101646: ST_TO_ADDR
// if not tmp then
101647: LD_VAR 0 2
101651: NOT
101652: IFFALSE 101656
// exit ;
101654: GO 101685
// for i in tmp do
101656: LD_ADDR_VAR 0 1
101660: PUSH
101661: LD_VAR 0 2
101665: PUSH
101666: FOR_IN
101667: IFFALSE 101683
// SetBLevel ( i , 10 ) ;
101669: LD_VAR 0 1
101673: PPUSH
101674: LD_INT 10
101676: PPUSH
101677: CALL_OW 241
101681: GO 101666
101683: POP
101684: POP
// end ;
101685: PPOPN 2
101687: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101688: LD_EXP 124
101692: PUSH
101693: LD_EXP 141
101697: AND
101698: IFFALSE 101809
101700: GO 101702
101702: DISABLE
101703: LD_INT 0
101705: PPUSH
101706: PPUSH
101707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101708: LD_ADDR_VAR 0 3
101712: PUSH
101713: LD_INT 22
101715: PUSH
101716: LD_OWVAR 2
101720: PUSH
101721: EMPTY
101722: LIST
101723: LIST
101724: PUSH
101725: LD_INT 25
101727: PUSH
101728: LD_INT 1
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: PPUSH
101739: CALL_OW 69
101743: ST_TO_ADDR
// if not tmp then
101744: LD_VAR 0 3
101748: NOT
101749: IFFALSE 101753
// exit ;
101751: GO 101809
// un := tmp [ rand ( 1 , tmp ) ] ;
101753: LD_ADDR_VAR 0 2
101757: PUSH
101758: LD_VAR 0 3
101762: PUSH
101763: LD_INT 1
101765: PPUSH
101766: LD_VAR 0 3
101770: PPUSH
101771: CALL_OW 12
101775: ARRAY
101776: ST_TO_ADDR
// if Crawls ( un ) then
101777: LD_VAR 0 2
101781: PPUSH
101782: CALL_OW 318
101786: IFFALSE 101797
// ComWalk ( un ) ;
101788: LD_VAR 0 2
101792: PPUSH
101793: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101797: LD_VAR 0 2
101801: PPUSH
101802: LD_INT 5
101804: PPUSH
101805: CALL_OW 336
// end ;
101809: PPOPN 3
101811: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101812: LD_EXP 124
101816: PUSH
101817: LD_EXP 142
101821: AND
101822: PUSH
101823: LD_OWVAR 67
101827: PUSH
101828: LD_INT 4
101830: LESS
101831: AND
101832: IFFALSE 101851
101834: GO 101836
101836: DISABLE
// begin Difficulty := Difficulty + 1 ;
101837: LD_ADDR_OWVAR 67
101841: PUSH
101842: LD_OWVAR 67
101846: PUSH
101847: LD_INT 1
101849: PLUS
101850: ST_TO_ADDR
// end ;
101851: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101852: LD_EXP 124
101856: PUSH
101857: LD_EXP 143
101861: AND
101862: IFFALSE 101965
101864: GO 101866
101866: DISABLE
101867: LD_INT 0
101869: PPUSH
// begin for i := 1 to 5 do
101870: LD_ADDR_VAR 0 1
101874: PUSH
101875: DOUBLE
101876: LD_INT 1
101878: DEC
101879: ST_TO_ADDR
101880: LD_INT 5
101882: PUSH
101883: FOR_TO
101884: IFFALSE 101963
// begin uc_nation := nation_nature ;
101886: LD_ADDR_OWVAR 21
101890: PUSH
101891: LD_INT 0
101893: ST_TO_ADDR
// uc_side := 0 ;
101894: LD_ADDR_OWVAR 20
101898: PUSH
101899: LD_INT 0
101901: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101902: LD_ADDR_OWVAR 29
101906: PUSH
101907: LD_INT 12
101909: PUSH
101910: LD_INT 12
101912: PUSH
101913: EMPTY
101914: LIST
101915: LIST
101916: ST_TO_ADDR
// hc_agressivity := 20 ;
101917: LD_ADDR_OWVAR 35
101921: PUSH
101922: LD_INT 20
101924: ST_TO_ADDR
// hc_class := class_tiger ;
101925: LD_ADDR_OWVAR 28
101929: PUSH
101930: LD_INT 14
101932: ST_TO_ADDR
// hc_gallery :=  ;
101933: LD_ADDR_OWVAR 33
101937: PUSH
101938: LD_STRING 
101940: ST_TO_ADDR
// hc_name :=  ;
101941: LD_ADDR_OWVAR 26
101945: PUSH
101946: LD_STRING 
101948: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101949: CALL_OW 44
101953: PPUSH
101954: LD_INT 0
101956: PPUSH
101957: CALL_OW 51
// end ;
101961: GO 101883
101963: POP
101964: POP
// end ;
101965: PPOPN 1
101967: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101968: LD_EXP 124
101972: PUSH
101973: LD_EXP 144
101977: AND
101978: IFFALSE 101987
101980: GO 101982
101982: DISABLE
// StreamSibBomb ;
101983: CALL 101988 0 0
101987: END
// export function StreamSibBomb ; var i , x , y ; begin
101988: LD_INT 0
101990: PPUSH
101991: PPUSH
101992: PPUSH
101993: PPUSH
// result := false ;
101994: LD_ADDR_VAR 0 1
101998: PUSH
101999: LD_INT 0
102001: ST_TO_ADDR
// for i := 1 to 16 do
102002: LD_ADDR_VAR 0 2
102006: PUSH
102007: DOUBLE
102008: LD_INT 1
102010: DEC
102011: ST_TO_ADDR
102012: LD_INT 16
102014: PUSH
102015: FOR_TO
102016: IFFALSE 102215
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102018: LD_ADDR_VAR 0 3
102022: PUSH
102023: LD_INT 10
102025: PUSH
102026: LD_INT 20
102028: PUSH
102029: LD_INT 30
102031: PUSH
102032: LD_INT 40
102034: PUSH
102035: LD_INT 50
102037: PUSH
102038: LD_INT 60
102040: PUSH
102041: LD_INT 70
102043: PUSH
102044: LD_INT 80
102046: PUSH
102047: LD_INT 90
102049: PUSH
102050: LD_INT 100
102052: PUSH
102053: LD_INT 110
102055: PUSH
102056: LD_INT 120
102058: PUSH
102059: LD_INT 130
102061: PUSH
102062: LD_INT 140
102064: PUSH
102065: LD_INT 150
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: LIST
102072: LIST
102073: LIST
102074: LIST
102075: LIST
102076: LIST
102077: LIST
102078: LIST
102079: LIST
102080: LIST
102081: LIST
102082: LIST
102083: LIST
102084: PUSH
102085: LD_INT 1
102087: PPUSH
102088: LD_INT 15
102090: PPUSH
102091: CALL_OW 12
102095: ARRAY
102096: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102097: LD_ADDR_VAR 0 4
102101: PUSH
102102: LD_INT 10
102104: PUSH
102105: LD_INT 20
102107: PUSH
102108: LD_INT 30
102110: PUSH
102111: LD_INT 40
102113: PUSH
102114: LD_INT 50
102116: PUSH
102117: LD_INT 60
102119: PUSH
102120: LD_INT 70
102122: PUSH
102123: LD_INT 80
102125: PUSH
102126: LD_INT 90
102128: PUSH
102129: LD_INT 100
102131: PUSH
102132: LD_INT 110
102134: PUSH
102135: LD_INT 120
102137: PUSH
102138: LD_INT 130
102140: PUSH
102141: LD_INT 140
102143: PUSH
102144: LD_INT 150
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: LIST
102155: LIST
102156: LIST
102157: LIST
102158: LIST
102159: LIST
102160: LIST
102161: LIST
102162: LIST
102163: PUSH
102164: LD_INT 1
102166: PPUSH
102167: LD_INT 15
102169: PPUSH
102170: CALL_OW 12
102174: ARRAY
102175: ST_TO_ADDR
// if ValidHex ( x , y ) then
102176: LD_VAR 0 3
102180: PPUSH
102181: LD_VAR 0 4
102185: PPUSH
102186: CALL_OW 488
102190: IFFALSE 102213
// begin result := [ x , y ] ;
102192: LD_ADDR_VAR 0 1
102196: PUSH
102197: LD_VAR 0 3
102201: PUSH
102202: LD_VAR 0 4
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: ST_TO_ADDR
// break ;
102211: GO 102215
// end ; end ;
102213: GO 102015
102215: POP
102216: POP
// if result then
102217: LD_VAR 0 1
102221: IFFALSE 102281
// begin ToLua ( playSibBomb() ) ;
102223: LD_STRING playSibBomb()
102225: PPUSH
102226: CALL_OW 559
// wait ( 0 0$14 ) ;
102230: LD_INT 490
102232: PPUSH
102233: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102237: LD_VAR 0 1
102241: PUSH
102242: LD_INT 1
102244: ARRAY
102245: PPUSH
102246: LD_VAR 0 1
102250: PUSH
102251: LD_INT 2
102253: ARRAY
102254: PPUSH
102255: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102259: LD_VAR 0 1
102263: PUSH
102264: LD_INT 1
102266: ARRAY
102267: PPUSH
102268: LD_VAR 0 1
102272: PUSH
102273: LD_INT 2
102275: ARRAY
102276: PPUSH
102277: CALL_OW 429
// end ; end ;
102281: LD_VAR 0 1
102285: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102286: LD_EXP 124
102290: PUSH
102291: LD_EXP 146
102295: AND
102296: IFFALSE 102308
102298: GO 102300
102300: DISABLE
// YouLost (  ) ;
102301: LD_STRING 
102303: PPUSH
102304: CALL_OW 104
102308: END
// every 0 0$1 trigger StreamModeActive and sFog do
102309: LD_EXP 124
102313: PUSH
102314: LD_EXP 145
102318: AND
102319: IFFALSE 102333
102321: GO 102323
102323: DISABLE
// FogOff ( your_side ) ;
102324: LD_OWVAR 2
102328: PPUSH
102329: CALL_OW 344
102333: END
// every 0 0$1 trigger StreamModeActive and sSun do
102334: LD_EXP 124
102338: PUSH
102339: LD_EXP 147
102343: AND
102344: IFFALSE 102372
102346: GO 102348
102348: DISABLE
// begin solar_recharge_percent := 0 ;
102349: LD_ADDR_OWVAR 79
102353: PUSH
102354: LD_INT 0
102356: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102357: LD_INT 10500
102359: PPUSH
102360: CALL_OW 67
// solar_recharge_percent := 100 ;
102364: LD_ADDR_OWVAR 79
102368: PUSH
102369: LD_INT 100
102371: ST_TO_ADDR
// end ;
102372: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102373: LD_EXP 124
102377: PUSH
102378: LD_EXP 148
102382: AND
102383: IFFALSE 102622
102385: GO 102387
102387: DISABLE
102388: LD_INT 0
102390: PPUSH
102391: PPUSH
102392: PPUSH
// begin tmp := [ ] ;
102393: LD_ADDR_VAR 0 3
102397: PUSH
102398: EMPTY
102399: ST_TO_ADDR
// for i := 1 to 6 do
102400: LD_ADDR_VAR 0 1
102404: PUSH
102405: DOUBLE
102406: LD_INT 1
102408: DEC
102409: ST_TO_ADDR
102410: LD_INT 6
102412: PUSH
102413: FOR_TO
102414: IFFALSE 102519
// begin uc_nation := nation_nature ;
102416: LD_ADDR_OWVAR 21
102420: PUSH
102421: LD_INT 0
102423: ST_TO_ADDR
// uc_side := 0 ;
102424: LD_ADDR_OWVAR 20
102428: PUSH
102429: LD_INT 0
102431: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102432: LD_ADDR_OWVAR 29
102436: PUSH
102437: LD_INT 12
102439: PUSH
102440: LD_INT 12
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: ST_TO_ADDR
// hc_agressivity := 20 ;
102447: LD_ADDR_OWVAR 35
102451: PUSH
102452: LD_INT 20
102454: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102455: LD_ADDR_OWVAR 28
102459: PUSH
102460: LD_INT 17
102462: ST_TO_ADDR
// hc_gallery :=  ;
102463: LD_ADDR_OWVAR 33
102467: PUSH
102468: LD_STRING 
102470: ST_TO_ADDR
// hc_name :=  ;
102471: LD_ADDR_OWVAR 26
102475: PUSH
102476: LD_STRING 
102478: ST_TO_ADDR
// un := CreateHuman ;
102479: LD_ADDR_VAR 0 2
102483: PUSH
102484: CALL_OW 44
102488: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102489: LD_VAR 0 2
102493: PPUSH
102494: LD_INT 1
102496: PPUSH
102497: CALL_OW 51
// tmp := tmp ^ un ;
102501: LD_ADDR_VAR 0 3
102505: PUSH
102506: LD_VAR 0 3
102510: PUSH
102511: LD_VAR 0 2
102515: ADD
102516: ST_TO_ADDR
// end ;
102517: GO 102413
102519: POP
102520: POP
// repeat wait ( 0 0$1 ) ;
102521: LD_INT 35
102523: PPUSH
102524: CALL_OW 67
// for un in tmp do
102528: LD_ADDR_VAR 0 2
102532: PUSH
102533: LD_VAR 0 3
102537: PUSH
102538: FOR_IN
102539: IFFALSE 102613
// begin if IsDead ( un ) then
102541: LD_VAR 0 2
102545: PPUSH
102546: CALL_OW 301
102550: IFFALSE 102570
// begin tmp := tmp diff un ;
102552: LD_ADDR_VAR 0 3
102556: PUSH
102557: LD_VAR 0 3
102561: PUSH
102562: LD_VAR 0 2
102566: DIFF
102567: ST_TO_ADDR
// continue ;
102568: GO 102538
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102570: LD_VAR 0 2
102574: PPUSH
102575: LD_INT 3
102577: PUSH
102578: LD_INT 22
102580: PUSH
102581: LD_INT 0
102583: PUSH
102584: EMPTY
102585: LIST
102586: LIST
102587: PUSH
102588: EMPTY
102589: LIST
102590: LIST
102591: PPUSH
102592: CALL_OW 69
102596: PPUSH
102597: LD_VAR 0 2
102601: PPUSH
102602: CALL_OW 74
102606: PPUSH
102607: CALL_OW 115
// end ;
102611: GO 102538
102613: POP
102614: POP
// until not tmp ;
102615: LD_VAR 0 3
102619: NOT
102620: IFFALSE 102521
// end ;
102622: PPOPN 3
102624: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102625: LD_EXP 124
102629: PUSH
102630: LD_EXP 149
102634: AND
102635: IFFALSE 102689
102637: GO 102639
102639: DISABLE
// begin ToLua ( displayTroll(); ) ;
102640: LD_STRING displayTroll();
102642: PPUSH
102643: CALL_OW 559
// wait ( 3 3$00 ) ;
102647: LD_INT 6300
102649: PPUSH
102650: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102654: LD_STRING hideTroll();
102656: PPUSH
102657: CALL_OW 559
// wait ( 1 1$00 ) ;
102661: LD_INT 2100
102663: PPUSH
102664: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102668: LD_STRING displayTroll();
102670: PPUSH
102671: CALL_OW 559
// wait ( 1 1$00 ) ;
102675: LD_INT 2100
102677: PPUSH
102678: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102682: LD_STRING hideTroll();
102684: PPUSH
102685: CALL_OW 559
// end ;
102689: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102690: LD_EXP 124
102694: PUSH
102695: LD_EXP 150
102699: AND
102700: IFFALSE 102763
102702: GO 102704
102704: DISABLE
102705: LD_INT 0
102707: PPUSH
// begin p := 0 ;
102708: LD_ADDR_VAR 0 1
102712: PUSH
102713: LD_INT 0
102715: ST_TO_ADDR
// repeat game_speed := 1 ;
102716: LD_ADDR_OWVAR 65
102720: PUSH
102721: LD_INT 1
102723: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102724: LD_INT 35
102726: PPUSH
102727: CALL_OW 67
// p := p + 1 ;
102731: LD_ADDR_VAR 0 1
102735: PUSH
102736: LD_VAR 0 1
102740: PUSH
102741: LD_INT 1
102743: PLUS
102744: ST_TO_ADDR
// until p >= 60 ;
102745: LD_VAR 0 1
102749: PUSH
102750: LD_INT 60
102752: GREATEREQUAL
102753: IFFALSE 102716
// game_speed := 4 ;
102755: LD_ADDR_OWVAR 65
102759: PUSH
102760: LD_INT 4
102762: ST_TO_ADDR
// end ;
102763: PPOPN 1
102765: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102766: LD_EXP 124
102770: PUSH
102771: LD_EXP 151
102775: AND
102776: IFFALSE 102922
102778: GO 102780
102780: DISABLE
102781: LD_INT 0
102783: PPUSH
102784: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102785: LD_ADDR_VAR 0 1
102789: PUSH
102790: LD_INT 22
102792: PUSH
102793: LD_OWVAR 2
102797: PUSH
102798: EMPTY
102799: LIST
102800: LIST
102801: PUSH
102802: LD_INT 2
102804: PUSH
102805: LD_INT 30
102807: PUSH
102808: LD_INT 0
102810: PUSH
102811: EMPTY
102812: LIST
102813: LIST
102814: PUSH
102815: LD_INT 30
102817: PUSH
102818: LD_INT 1
102820: PUSH
102821: EMPTY
102822: LIST
102823: LIST
102824: PUSH
102825: EMPTY
102826: LIST
102827: LIST
102828: LIST
102829: PUSH
102830: EMPTY
102831: LIST
102832: LIST
102833: PPUSH
102834: CALL_OW 69
102838: ST_TO_ADDR
// if not depot then
102839: LD_VAR 0 1
102843: NOT
102844: IFFALSE 102848
// exit ;
102846: GO 102922
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102848: LD_ADDR_VAR 0 2
102852: PUSH
102853: LD_VAR 0 1
102857: PUSH
102858: LD_INT 1
102860: PPUSH
102861: LD_VAR 0 1
102865: PPUSH
102866: CALL_OW 12
102870: ARRAY
102871: PPUSH
102872: CALL_OW 274
102876: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102877: LD_VAR 0 2
102881: PPUSH
102882: LD_INT 1
102884: PPUSH
102885: LD_INT 0
102887: PPUSH
102888: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102892: LD_VAR 0 2
102896: PPUSH
102897: LD_INT 2
102899: PPUSH
102900: LD_INT 0
102902: PPUSH
102903: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102907: LD_VAR 0 2
102911: PPUSH
102912: LD_INT 3
102914: PPUSH
102915: LD_INT 0
102917: PPUSH
102918: CALL_OW 277
// end ;
102922: PPOPN 2
102924: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102925: LD_EXP 124
102929: PUSH
102930: LD_EXP 152
102934: AND
102935: IFFALSE 103032
102937: GO 102939
102939: DISABLE
102940: LD_INT 0
102942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102943: LD_ADDR_VAR 0 1
102947: PUSH
102948: LD_INT 22
102950: PUSH
102951: LD_OWVAR 2
102955: PUSH
102956: EMPTY
102957: LIST
102958: LIST
102959: PUSH
102960: LD_INT 21
102962: PUSH
102963: LD_INT 1
102965: PUSH
102966: EMPTY
102967: LIST
102968: LIST
102969: PUSH
102970: LD_INT 3
102972: PUSH
102973: LD_INT 23
102975: PUSH
102976: LD_INT 0
102978: PUSH
102979: EMPTY
102980: LIST
102981: LIST
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: LIST
102991: PPUSH
102992: CALL_OW 69
102996: ST_TO_ADDR
// if not tmp then
102997: LD_VAR 0 1
103001: NOT
103002: IFFALSE 103006
// exit ;
103004: GO 103032
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103006: LD_VAR 0 1
103010: PUSH
103011: LD_INT 1
103013: PPUSH
103014: LD_VAR 0 1
103018: PPUSH
103019: CALL_OW 12
103023: ARRAY
103024: PPUSH
103025: LD_INT 200
103027: PPUSH
103028: CALL_OW 234
// end ;
103032: PPOPN 1
103034: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103035: LD_EXP 124
103039: PUSH
103040: LD_EXP 153
103044: AND
103045: IFFALSE 103124
103047: GO 103049
103049: DISABLE
103050: LD_INT 0
103052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103053: LD_ADDR_VAR 0 1
103057: PUSH
103058: LD_INT 22
103060: PUSH
103061: LD_OWVAR 2
103065: PUSH
103066: EMPTY
103067: LIST
103068: LIST
103069: PUSH
103070: LD_INT 21
103072: PUSH
103073: LD_INT 2
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PUSH
103080: EMPTY
103081: LIST
103082: LIST
103083: PPUSH
103084: CALL_OW 69
103088: ST_TO_ADDR
// if not tmp then
103089: LD_VAR 0 1
103093: NOT
103094: IFFALSE 103098
// exit ;
103096: GO 103124
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103098: LD_VAR 0 1
103102: PUSH
103103: LD_INT 1
103105: PPUSH
103106: LD_VAR 0 1
103110: PPUSH
103111: CALL_OW 12
103115: ARRAY
103116: PPUSH
103117: LD_INT 60
103119: PPUSH
103120: CALL_OW 234
// end ;
103124: PPOPN 1
103126: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103127: LD_EXP 124
103131: PUSH
103132: LD_EXP 154
103136: AND
103137: IFFALSE 103236
103139: GO 103141
103141: DISABLE
103142: LD_INT 0
103144: PPUSH
103145: PPUSH
// begin enable ;
103146: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103147: LD_ADDR_VAR 0 1
103151: PUSH
103152: LD_INT 22
103154: PUSH
103155: LD_OWVAR 2
103159: PUSH
103160: EMPTY
103161: LIST
103162: LIST
103163: PUSH
103164: LD_INT 61
103166: PUSH
103167: EMPTY
103168: LIST
103169: PUSH
103170: LD_INT 33
103172: PUSH
103173: LD_INT 2
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PUSH
103180: EMPTY
103181: LIST
103182: LIST
103183: LIST
103184: PPUSH
103185: CALL_OW 69
103189: ST_TO_ADDR
// if not tmp then
103190: LD_VAR 0 1
103194: NOT
103195: IFFALSE 103199
// exit ;
103197: GO 103236
// for i in tmp do
103199: LD_ADDR_VAR 0 2
103203: PUSH
103204: LD_VAR 0 1
103208: PUSH
103209: FOR_IN
103210: IFFALSE 103234
// if IsControledBy ( i ) then
103212: LD_VAR 0 2
103216: PPUSH
103217: CALL_OW 312
103221: IFFALSE 103232
// ComUnlink ( i ) ;
103223: LD_VAR 0 2
103227: PPUSH
103228: CALL_OW 136
103232: GO 103209
103234: POP
103235: POP
// end ;
103236: PPOPN 2
103238: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103239: LD_EXP 124
103243: PUSH
103244: LD_EXP 155
103248: AND
103249: IFFALSE 103389
103251: GO 103253
103253: DISABLE
103254: LD_INT 0
103256: PPUSH
103257: PPUSH
// begin ToLua ( displayPowell(); ) ;
103258: LD_STRING displayPowell();
103260: PPUSH
103261: CALL_OW 559
// uc_side := 0 ;
103265: LD_ADDR_OWVAR 20
103269: PUSH
103270: LD_INT 0
103272: ST_TO_ADDR
// uc_nation := 2 ;
103273: LD_ADDR_OWVAR 21
103277: PUSH
103278: LD_INT 2
103280: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103281: LD_ADDR_OWVAR 37
103285: PUSH
103286: LD_INT 14
103288: ST_TO_ADDR
// vc_engine := engine_siberite ;
103289: LD_ADDR_OWVAR 39
103293: PUSH
103294: LD_INT 3
103296: ST_TO_ADDR
// vc_control := control_apeman ;
103297: LD_ADDR_OWVAR 38
103301: PUSH
103302: LD_INT 5
103304: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103305: LD_ADDR_OWVAR 40
103309: PUSH
103310: LD_INT 29
103312: ST_TO_ADDR
// un := CreateVehicle ;
103313: LD_ADDR_VAR 0 2
103317: PUSH
103318: CALL_OW 45
103322: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103323: LD_VAR 0 2
103327: PPUSH
103328: LD_INT 1
103330: PPUSH
103331: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103335: LD_INT 35
103337: PPUSH
103338: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103342: LD_VAR 0 2
103346: PPUSH
103347: LD_INT 22
103349: PUSH
103350: LD_OWVAR 2
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: PPUSH
103359: CALL_OW 69
103363: PPUSH
103364: LD_VAR 0 2
103368: PPUSH
103369: CALL_OW 74
103373: PPUSH
103374: CALL_OW 115
// until IsDead ( un ) ;
103378: LD_VAR 0 2
103382: PPUSH
103383: CALL_OW 301
103387: IFFALSE 103335
// end ;
103389: PPOPN 2
103391: END
// every 0 0$1 trigger StreamModeActive and sStu do
103392: LD_EXP 124
103396: PUSH
103397: LD_EXP 163
103401: AND
103402: IFFALSE 103418
103404: GO 103406
103406: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103407: LD_STRING displayStucuk();
103409: PPUSH
103410: CALL_OW 559
// ResetFog ;
103414: CALL_OW 335
// end ;
103418: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103419: LD_EXP 124
103423: PUSH
103424: LD_EXP 156
103428: AND
103429: IFFALSE 103570
103431: GO 103433
103433: DISABLE
103434: LD_INT 0
103436: PPUSH
103437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103438: LD_ADDR_VAR 0 2
103442: PUSH
103443: LD_INT 22
103445: PUSH
103446: LD_OWVAR 2
103450: PUSH
103451: EMPTY
103452: LIST
103453: LIST
103454: PUSH
103455: LD_INT 21
103457: PUSH
103458: LD_INT 1
103460: PUSH
103461: EMPTY
103462: LIST
103463: LIST
103464: PUSH
103465: EMPTY
103466: LIST
103467: LIST
103468: PPUSH
103469: CALL_OW 69
103473: ST_TO_ADDR
// if not tmp then
103474: LD_VAR 0 2
103478: NOT
103479: IFFALSE 103483
// exit ;
103481: GO 103570
// un := tmp [ rand ( 1 , tmp ) ] ;
103483: LD_ADDR_VAR 0 1
103487: PUSH
103488: LD_VAR 0 2
103492: PUSH
103493: LD_INT 1
103495: PPUSH
103496: LD_VAR 0 2
103500: PPUSH
103501: CALL_OW 12
103505: ARRAY
103506: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103507: LD_VAR 0 1
103511: PPUSH
103512: LD_INT 0
103514: PPUSH
103515: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103519: LD_VAR 0 1
103523: PPUSH
103524: LD_OWVAR 3
103528: PUSH
103529: LD_VAR 0 1
103533: DIFF
103534: PPUSH
103535: LD_VAR 0 1
103539: PPUSH
103540: CALL_OW 74
103544: PPUSH
103545: CALL_OW 115
// wait ( 0 0$20 ) ;
103549: LD_INT 700
103551: PPUSH
103552: CALL_OW 67
// SetSide ( un , your_side ) ;
103556: LD_VAR 0 1
103560: PPUSH
103561: LD_OWVAR 2
103565: PPUSH
103566: CALL_OW 235
// end ;
103570: PPOPN 2
103572: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103573: LD_EXP 124
103577: PUSH
103578: LD_EXP 157
103582: AND
103583: IFFALSE 103689
103585: GO 103587
103587: DISABLE
103588: LD_INT 0
103590: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103591: LD_ADDR_VAR 0 1
103595: PUSH
103596: LD_INT 22
103598: PUSH
103599: LD_OWVAR 2
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PUSH
103608: LD_INT 2
103610: PUSH
103611: LD_INT 30
103613: PUSH
103614: LD_INT 0
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: PUSH
103621: LD_INT 30
103623: PUSH
103624: LD_INT 1
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: PUSH
103631: EMPTY
103632: LIST
103633: LIST
103634: LIST
103635: PUSH
103636: EMPTY
103637: LIST
103638: LIST
103639: PPUSH
103640: CALL_OW 69
103644: ST_TO_ADDR
// if not depot then
103645: LD_VAR 0 1
103649: NOT
103650: IFFALSE 103654
// exit ;
103652: GO 103689
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103654: LD_VAR 0 1
103658: PUSH
103659: LD_INT 1
103661: ARRAY
103662: PPUSH
103663: CALL_OW 250
103667: PPUSH
103668: LD_VAR 0 1
103672: PUSH
103673: LD_INT 1
103675: ARRAY
103676: PPUSH
103677: CALL_OW 251
103681: PPUSH
103682: LD_INT 70
103684: PPUSH
103685: CALL_OW 495
// end ;
103689: PPOPN 1
103691: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103692: LD_EXP 124
103696: PUSH
103697: LD_EXP 158
103701: AND
103702: IFFALSE 103913
103704: GO 103706
103706: DISABLE
103707: LD_INT 0
103709: PPUSH
103710: PPUSH
103711: PPUSH
103712: PPUSH
103713: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103714: LD_ADDR_VAR 0 5
103718: PUSH
103719: LD_INT 22
103721: PUSH
103722: LD_OWVAR 2
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: PUSH
103731: LD_INT 21
103733: PUSH
103734: LD_INT 1
103736: PUSH
103737: EMPTY
103738: LIST
103739: LIST
103740: PUSH
103741: EMPTY
103742: LIST
103743: LIST
103744: PPUSH
103745: CALL_OW 69
103749: ST_TO_ADDR
// if not tmp then
103750: LD_VAR 0 5
103754: NOT
103755: IFFALSE 103759
// exit ;
103757: GO 103913
// for i in tmp do
103759: LD_ADDR_VAR 0 1
103763: PUSH
103764: LD_VAR 0 5
103768: PUSH
103769: FOR_IN
103770: IFFALSE 103911
// begin d := rand ( 0 , 5 ) ;
103772: LD_ADDR_VAR 0 4
103776: PUSH
103777: LD_INT 0
103779: PPUSH
103780: LD_INT 5
103782: PPUSH
103783: CALL_OW 12
103787: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103788: LD_ADDR_VAR 0 2
103792: PUSH
103793: LD_VAR 0 1
103797: PPUSH
103798: CALL_OW 250
103802: PPUSH
103803: LD_VAR 0 4
103807: PPUSH
103808: LD_INT 3
103810: PPUSH
103811: LD_INT 12
103813: PPUSH
103814: CALL_OW 12
103818: PPUSH
103819: CALL_OW 272
103823: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103824: LD_ADDR_VAR 0 3
103828: PUSH
103829: LD_VAR 0 1
103833: PPUSH
103834: CALL_OW 251
103838: PPUSH
103839: LD_VAR 0 4
103843: PPUSH
103844: LD_INT 3
103846: PPUSH
103847: LD_INT 12
103849: PPUSH
103850: CALL_OW 12
103854: PPUSH
103855: CALL_OW 273
103859: ST_TO_ADDR
// if ValidHex ( x , y ) then
103860: LD_VAR 0 2
103864: PPUSH
103865: LD_VAR 0 3
103869: PPUSH
103870: CALL_OW 488
103874: IFFALSE 103909
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103876: LD_VAR 0 1
103880: PPUSH
103881: LD_VAR 0 2
103885: PPUSH
103886: LD_VAR 0 3
103890: PPUSH
103891: LD_INT 3
103893: PPUSH
103894: LD_INT 6
103896: PPUSH
103897: CALL_OW 12
103901: PPUSH
103902: LD_INT 1
103904: PPUSH
103905: CALL_OW 483
// end ;
103909: GO 103769
103911: POP
103912: POP
// end ;
103913: PPOPN 5
103915: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103916: LD_EXP 124
103920: PUSH
103921: LD_EXP 159
103925: AND
103926: IFFALSE 104020
103928: GO 103930
103930: DISABLE
103931: LD_INT 0
103933: PPUSH
103934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103935: LD_ADDR_VAR 0 2
103939: PUSH
103940: LD_INT 22
103942: PUSH
103943: LD_OWVAR 2
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: PUSH
103952: LD_INT 32
103954: PUSH
103955: LD_INT 1
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: PUSH
103962: LD_INT 21
103964: PUSH
103965: LD_INT 2
103967: PUSH
103968: EMPTY
103969: LIST
103970: LIST
103971: PUSH
103972: EMPTY
103973: LIST
103974: LIST
103975: LIST
103976: PPUSH
103977: CALL_OW 69
103981: ST_TO_ADDR
// if not tmp then
103982: LD_VAR 0 2
103986: NOT
103987: IFFALSE 103991
// exit ;
103989: GO 104020
// for i in tmp do
103991: LD_ADDR_VAR 0 1
103995: PUSH
103996: LD_VAR 0 2
104000: PUSH
104001: FOR_IN
104002: IFFALSE 104018
// SetFuel ( i , 0 ) ;
104004: LD_VAR 0 1
104008: PPUSH
104009: LD_INT 0
104011: PPUSH
104012: CALL_OW 240
104016: GO 104001
104018: POP
104019: POP
// end ;
104020: PPOPN 2
104022: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104023: LD_EXP 124
104027: PUSH
104028: LD_EXP 160
104032: AND
104033: IFFALSE 104099
104035: GO 104037
104037: DISABLE
104038: LD_INT 0
104040: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104041: LD_ADDR_VAR 0 1
104045: PUSH
104046: LD_INT 22
104048: PUSH
104049: LD_OWVAR 2
104053: PUSH
104054: EMPTY
104055: LIST
104056: LIST
104057: PUSH
104058: LD_INT 30
104060: PUSH
104061: LD_INT 29
104063: PUSH
104064: EMPTY
104065: LIST
104066: LIST
104067: PUSH
104068: EMPTY
104069: LIST
104070: LIST
104071: PPUSH
104072: CALL_OW 69
104076: ST_TO_ADDR
// if not tmp then
104077: LD_VAR 0 1
104081: NOT
104082: IFFALSE 104086
// exit ;
104084: GO 104099
// DestroyUnit ( tmp [ 1 ] ) ;
104086: LD_VAR 0 1
104090: PUSH
104091: LD_INT 1
104093: ARRAY
104094: PPUSH
104095: CALL_OW 65
// end ;
104099: PPOPN 1
104101: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104102: LD_EXP 124
104106: PUSH
104107: LD_EXP 162
104111: AND
104112: IFFALSE 104241
104114: GO 104116
104116: DISABLE
104117: LD_INT 0
104119: PPUSH
// begin uc_side := 0 ;
104120: LD_ADDR_OWVAR 20
104124: PUSH
104125: LD_INT 0
104127: ST_TO_ADDR
// uc_nation := nation_arabian ;
104128: LD_ADDR_OWVAR 21
104132: PUSH
104133: LD_INT 2
104135: ST_TO_ADDR
// hc_gallery :=  ;
104136: LD_ADDR_OWVAR 33
104140: PUSH
104141: LD_STRING 
104143: ST_TO_ADDR
// hc_name :=  ;
104144: LD_ADDR_OWVAR 26
104148: PUSH
104149: LD_STRING 
104151: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104152: LD_INT 1
104154: PPUSH
104155: LD_INT 11
104157: PPUSH
104158: LD_INT 10
104160: PPUSH
104161: CALL_OW 380
// un := CreateHuman ;
104165: LD_ADDR_VAR 0 1
104169: PUSH
104170: CALL_OW 44
104174: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104175: LD_VAR 0 1
104179: PPUSH
104180: LD_INT 1
104182: PPUSH
104183: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104187: LD_INT 35
104189: PPUSH
104190: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104194: LD_VAR 0 1
104198: PPUSH
104199: LD_INT 22
104201: PUSH
104202: LD_OWVAR 2
104206: PUSH
104207: EMPTY
104208: LIST
104209: LIST
104210: PPUSH
104211: CALL_OW 69
104215: PPUSH
104216: LD_VAR 0 1
104220: PPUSH
104221: CALL_OW 74
104225: PPUSH
104226: CALL_OW 115
// until IsDead ( un ) ;
104230: LD_VAR 0 1
104234: PPUSH
104235: CALL_OW 301
104239: IFFALSE 104187
// end ;
104241: PPOPN 1
104243: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104244: LD_EXP 124
104248: PUSH
104249: LD_EXP 164
104253: AND
104254: IFFALSE 104266
104256: GO 104258
104258: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104259: LD_STRING earthquake(getX(game), 0, 32)
104261: PPUSH
104262: CALL_OW 559
104266: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104267: LD_EXP 124
104271: PUSH
104272: LD_EXP 165
104276: AND
104277: IFFALSE 104368
104279: GO 104281
104281: DISABLE
104282: LD_INT 0
104284: PPUSH
// begin enable ;
104285: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104286: LD_ADDR_VAR 0 1
104290: PUSH
104291: LD_INT 22
104293: PUSH
104294: LD_OWVAR 2
104298: PUSH
104299: EMPTY
104300: LIST
104301: LIST
104302: PUSH
104303: LD_INT 21
104305: PUSH
104306: LD_INT 2
104308: PUSH
104309: EMPTY
104310: LIST
104311: LIST
104312: PUSH
104313: LD_INT 33
104315: PUSH
104316: LD_INT 3
104318: PUSH
104319: EMPTY
104320: LIST
104321: LIST
104322: PUSH
104323: EMPTY
104324: LIST
104325: LIST
104326: LIST
104327: PPUSH
104328: CALL_OW 69
104332: ST_TO_ADDR
// if not tmp then
104333: LD_VAR 0 1
104337: NOT
104338: IFFALSE 104342
// exit ;
104340: GO 104368
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104342: LD_VAR 0 1
104346: PUSH
104347: LD_INT 1
104349: PPUSH
104350: LD_VAR 0 1
104354: PPUSH
104355: CALL_OW 12
104359: ARRAY
104360: PPUSH
104361: LD_INT 1
104363: PPUSH
104364: CALL_OW 234
// end ;
104368: PPOPN 1
104370: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104371: LD_EXP 124
104375: PUSH
104376: LD_EXP 166
104380: AND
104381: IFFALSE 104522
104383: GO 104385
104385: DISABLE
104386: LD_INT 0
104388: PPUSH
104389: PPUSH
104390: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104391: LD_ADDR_VAR 0 3
104395: PUSH
104396: LD_INT 22
104398: PUSH
104399: LD_OWVAR 2
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PUSH
104408: LD_INT 25
104410: PUSH
104411: LD_INT 1
104413: PUSH
104414: EMPTY
104415: LIST
104416: LIST
104417: PUSH
104418: EMPTY
104419: LIST
104420: LIST
104421: PPUSH
104422: CALL_OW 69
104426: ST_TO_ADDR
// if not tmp then
104427: LD_VAR 0 3
104431: NOT
104432: IFFALSE 104436
// exit ;
104434: GO 104522
// un := tmp [ rand ( 1 , tmp ) ] ;
104436: LD_ADDR_VAR 0 2
104440: PUSH
104441: LD_VAR 0 3
104445: PUSH
104446: LD_INT 1
104448: PPUSH
104449: LD_VAR 0 3
104453: PPUSH
104454: CALL_OW 12
104458: ARRAY
104459: ST_TO_ADDR
// if Crawls ( un ) then
104460: LD_VAR 0 2
104464: PPUSH
104465: CALL_OW 318
104469: IFFALSE 104480
// ComWalk ( un ) ;
104471: LD_VAR 0 2
104475: PPUSH
104476: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104480: LD_VAR 0 2
104484: PPUSH
104485: LD_INT 9
104487: PPUSH
104488: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104492: LD_INT 28
104494: PPUSH
104495: LD_OWVAR 2
104499: PPUSH
104500: LD_INT 2
104502: PPUSH
104503: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104507: LD_INT 29
104509: PPUSH
104510: LD_OWVAR 2
104514: PPUSH
104515: LD_INT 2
104517: PPUSH
104518: CALL_OW 322
// end ;
104522: PPOPN 3
104524: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104525: LD_EXP 124
104529: PUSH
104530: LD_EXP 167
104534: AND
104535: IFFALSE 104646
104537: GO 104539
104539: DISABLE
104540: LD_INT 0
104542: PPUSH
104543: PPUSH
104544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104545: LD_ADDR_VAR 0 3
104549: PUSH
104550: LD_INT 22
104552: PUSH
104553: LD_OWVAR 2
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: PUSH
104562: LD_INT 25
104564: PUSH
104565: LD_INT 1
104567: PUSH
104568: EMPTY
104569: LIST
104570: LIST
104571: PUSH
104572: EMPTY
104573: LIST
104574: LIST
104575: PPUSH
104576: CALL_OW 69
104580: ST_TO_ADDR
// if not tmp then
104581: LD_VAR 0 3
104585: NOT
104586: IFFALSE 104590
// exit ;
104588: GO 104646
// un := tmp [ rand ( 1 , tmp ) ] ;
104590: LD_ADDR_VAR 0 2
104594: PUSH
104595: LD_VAR 0 3
104599: PUSH
104600: LD_INT 1
104602: PPUSH
104603: LD_VAR 0 3
104607: PPUSH
104608: CALL_OW 12
104612: ARRAY
104613: ST_TO_ADDR
// if Crawls ( un ) then
104614: LD_VAR 0 2
104618: PPUSH
104619: CALL_OW 318
104623: IFFALSE 104634
// ComWalk ( un ) ;
104625: LD_VAR 0 2
104629: PPUSH
104630: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104634: LD_VAR 0 2
104638: PPUSH
104639: LD_INT 8
104641: PPUSH
104642: CALL_OW 336
// end ;
104646: PPOPN 3
104648: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104649: LD_EXP 124
104653: PUSH
104654: LD_EXP 168
104658: AND
104659: IFFALSE 104803
104661: GO 104663
104663: DISABLE
104664: LD_INT 0
104666: PPUSH
104667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104668: LD_ADDR_VAR 0 2
104672: PUSH
104673: LD_INT 22
104675: PUSH
104676: LD_OWVAR 2
104680: PUSH
104681: EMPTY
104682: LIST
104683: LIST
104684: PUSH
104685: LD_INT 21
104687: PUSH
104688: LD_INT 2
104690: PUSH
104691: EMPTY
104692: LIST
104693: LIST
104694: PUSH
104695: LD_INT 2
104697: PUSH
104698: LD_INT 34
104700: PUSH
104701: LD_INT 12
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: PUSH
104708: LD_INT 34
104710: PUSH
104711: LD_INT 51
104713: PUSH
104714: EMPTY
104715: LIST
104716: LIST
104717: PUSH
104718: LD_INT 34
104720: PUSH
104721: LD_INT 32
104723: PUSH
104724: EMPTY
104725: LIST
104726: LIST
104727: PUSH
104728: EMPTY
104729: LIST
104730: LIST
104731: LIST
104732: LIST
104733: PUSH
104734: EMPTY
104735: LIST
104736: LIST
104737: LIST
104738: PPUSH
104739: CALL_OW 69
104743: ST_TO_ADDR
// if not tmp then
104744: LD_VAR 0 2
104748: NOT
104749: IFFALSE 104753
// exit ;
104751: GO 104803
// for i in tmp do
104753: LD_ADDR_VAR 0 1
104757: PUSH
104758: LD_VAR 0 2
104762: PUSH
104763: FOR_IN
104764: IFFALSE 104801
// if GetCargo ( i , mat_artifact ) = 0 then
104766: LD_VAR 0 1
104770: PPUSH
104771: LD_INT 4
104773: PPUSH
104774: CALL_OW 289
104778: PUSH
104779: LD_INT 0
104781: EQUAL
104782: IFFALSE 104799
// SetCargo ( i , mat_siberit , 100 ) ;
104784: LD_VAR 0 1
104788: PPUSH
104789: LD_INT 3
104791: PPUSH
104792: LD_INT 100
104794: PPUSH
104795: CALL_OW 290
104799: GO 104763
104801: POP
104802: POP
// end ;
104803: PPOPN 2
104805: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104806: LD_EXP 124
104810: PUSH
104811: LD_EXP 169
104815: AND
104816: IFFALSE 104999
104818: GO 104820
104820: DISABLE
104821: LD_INT 0
104823: PPUSH
104824: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104825: LD_ADDR_VAR 0 2
104829: PUSH
104830: LD_INT 22
104832: PUSH
104833: LD_OWVAR 2
104837: PUSH
104838: EMPTY
104839: LIST
104840: LIST
104841: PPUSH
104842: CALL_OW 69
104846: ST_TO_ADDR
// if not tmp then
104847: LD_VAR 0 2
104851: NOT
104852: IFFALSE 104856
// exit ;
104854: GO 104999
// for i := 1 to 2 do
104856: LD_ADDR_VAR 0 1
104860: PUSH
104861: DOUBLE
104862: LD_INT 1
104864: DEC
104865: ST_TO_ADDR
104866: LD_INT 2
104868: PUSH
104869: FOR_TO
104870: IFFALSE 104997
// begin uc_side := your_side ;
104872: LD_ADDR_OWVAR 20
104876: PUSH
104877: LD_OWVAR 2
104881: ST_TO_ADDR
// uc_nation := nation_american ;
104882: LD_ADDR_OWVAR 21
104886: PUSH
104887: LD_INT 1
104889: ST_TO_ADDR
// vc_chassis := us_morphling ;
104890: LD_ADDR_OWVAR 37
104894: PUSH
104895: LD_INT 5
104897: ST_TO_ADDR
// vc_engine := engine_siberite ;
104898: LD_ADDR_OWVAR 39
104902: PUSH
104903: LD_INT 3
104905: ST_TO_ADDR
// vc_control := control_computer ;
104906: LD_ADDR_OWVAR 38
104910: PUSH
104911: LD_INT 3
104913: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104914: LD_ADDR_OWVAR 40
104918: PUSH
104919: LD_INT 10
104921: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104922: LD_VAR 0 2
104926: PUSH
104927: LD_INT 1
104929: ARRAY
104930: PPUSH
104931: CALL_OW 310
104935: NOT
104936: IFFALSE 104983
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104938: CALL_OW 45
104942: PPUSH
104943: LD_VAR 0 2
104947: PUSH
104948: LD_INT 1
104950: ARRAY
104951: PPUSH
104952: CALL_OW 250
104956: PPUSH
104957: LD_VAR 0 2
104961: PUSH
104962: LD_INT 1
104964: ARRAY
104965: PPUSH
104966: CALL_OW 251
104970: PPUSH
104971: LD_INT 12
104973: PPUSH
104974: LD_INT 1
104976: PPUSH
104977: CALL_OW 50
104981: GO 104995
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104983: CALL_OW 45
104987: PPUSH
104988: LD_INT 1
104990: PPUSH
104991: CALL_OW 51
// end ;
104995: GO 104869
104997: POP
104998: POP
// end ;
104999: PPOPN 2
105001: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105002: LD_EXP 124
105006: PUSH
105007: LD_EXP 170
105011: AND
105012: IFFALSE 105234
105014: GO 105016
105016: DISABLE
105017: LD_INT 0
105019: PPUSH
105020: PPUSH
105021: PPUSH
105022: PPUSH
105023: PPUSH
105024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105025: LD_ADDR_VAR 0 6
105029: PUSH
105030: LD_INT 22
105032: PUSH
105033: LD_OWVAR 2
105037: PUSH
105038: EMPTY
105039: LIST
105040: LIST
105041: PUSH
105042: LD_INT 21
105044: PUSH
105045: LD_INT 1
105047: PUSH
105048: EMPTY
105049: LIST
105050: LIST
105051: PUSH
105052: LD_INT 3
105054: PUSH
105055: LD_INT 23
105057: PUSH
105058: LD_INT 0
105060: PUSH
105061: EMPTY
105062: LIST
105063: LIST
105064: PUSH
105065: EMPTY
105066: LIST
105067: LIST
105068: PUSH
105069: EMPTY
105070: LIST
105071: LIST
105072: LIST
105073: PPUSH
105074: CALL_OW 69
105078: ST_TO_ADDR
// if not tmp then
105079: LD_VAR 0 6
105083: NOT
105084: IFFALSE 105088
// exit ;
105086: GO 105234
// s1 := rand ( 1 , 4 ) ;
105088: LD_ADDR_VAR 0 2
105092: PUSH
105093: LD_INT 1
105095: PPUSH
105096: LD_INT 4
105098: PPUSH
105099: CALL_OW 12
105103: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105104: LD_ADDR_VAR 0 4
105108: PUSH
105109: LD_VAR 0 6
105113: PUSH
105114: LD_INT 1
105116: ARRAY
105117: PPUSH
105118: LD_VAR 0 2
105122: PPUSH
105123: CALL_OW 259
105127: ST_TO_ADDR
// if s1 = 1 then
105128: LD_VAR 0 2
105132: PUSH
105133: LD_INT 1
105135: EQUAL
105136: IFFALSE 105156
// s2 := rand ( 2 , 4 ) else
105138: LD_ADDR_VAR 0 3
105142: PUSH
105143: LD_INT 2
105145: PPUSH
105146: LD_INT 4
105148: PPUSH
105149: CALL_OW 12
105153: ST_TO_ADDR
105154: GO 105164
// s2 := 1 ;
105156: LD_ADDR_VAR 0 3
105160: PUSH
105161: LD_INT 1
105163: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105164: LD_ADDR_VAR 0 5
105168: PUSH
105169: LD_VAR 0 6
105173: PUSH
105174: LD_INT 1
105176: ARRAY
105177: PPUSH
105178: LD_VAR 0 3
105182: PPUSH
105183: CALL_OW 259
105187: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105188: LD_VAR 0 6
105192: PUSH
105193: LD_INT 1
105195: ARRAY
105196: PPUSH
105197: LD_VAR 0 2
105201: PPUSH
105202: LD_VAR 0 5
105206: PPUSH
105207: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105211: LD_VAR 0 6
105215: PUSH
105216: LD_INT 1
105218: ARRAY
105219: PPUSH
105220: LD_VAR 0 3
105224: PPUSH
105225: LD_VAR 0 4
105229: PPUSH
105230: CALL_OW 237
// end ;
105234: PPOPN 6
105236: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105237: LD_EXP 124
105241: PUSH
105242: LD_EXP 171
105246: AND
105247: IFFALSE 105326
105249: GO 105251
105251: DISABLE
105252: LD_INT 0
105254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105255: LD_ADDR_VAR 0 1
105259: PUSH
105260: LD_INT 22
105262: PUSH
105263: LD_OWVAR 2
105267: PUSH
105268: EMPTY
105269: LIST
105270: LIST
105271: PUSH
105272: LD_INT 30
105274: PUSH
105275: LD_INT 3
105277: PUSH
105278: EMPTY
105279: LIST
105280: LIST
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PPUSH
105286: CALL_OW 69
105290: ST_TO_ADDR
// if not tmp then
105291: LD_VAR 0 1
105295: NOT
105296: IFFALSE 105300
// exit ;
105298: GO 105326
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105300: LD_VAR 0 1
105304: PUSH
105305: LD_INT 1
105307: PPUSH
105308: LD_VAR 0 1
105312: PPUSH
105313: CALL_OW 12
105317: ARRAY
105318: PPUSH
105319: LD_INT 1
105321: PPUSH
105322: CALL_OW 234
// end ;
105326: PPOPN 1
105328: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105329: LD_EXP 124
105333: PUSH
105334: LD_EXP 172
105338: AND
105339: IFFALSE 105451
105341: GO 105343
105343: DISABLE
105344: LD_INT 0
105346: PPUSH
105347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105348: LD_ADDR_VAR 0 2
105352: PUSH
105353: LD_INT 22
105355: PUSH
105356: LD_OWVAR 2
105360: PUSH
105361: EMPTY
105362: LIST
105363: LIST
105364: PUSH
105365: LD_INT 2
105367: PUSH
105368: LD_INT 30
105370: PUSH
105371: LD_INT 27
105373: PUSH
105374: EMPTY
105375: LIST
105376: LIST
105377: PUSH
105378: LD_INT 30
105380: PUSH
105381: LD_INT 26
105383: PUSH
105384: EMPTY
105385: LIST
105386: LIST
105387: PUSH
105388: LD_INT 30
105390: PUSH
105391: LD_INT 28
105393: PUSH
105394: EMPTY
105395: LIST
105396: LIST
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: LIST
105402: LIST
105403: PUSH
105404: EMPTY
105405: LIST
105406: LIST
105407: PPUSH
105408: CALL_OW 69
105412: ST_TO_ADDR
// if not tmp then
105413: LD_VAR 0 2
105417: NOT
105418: IFFALSE 105422
// exit ;
105420: GO 105451
// for i in tmp do
105422: LD_ADDR_VAR 0 1
105426: PUSH
105427: LD_VAR 0 2
105431: PUSH
105432: FOR_IN
105433: IFFALSE 105449
// SetLives ( i , 1 ) ;
105435: LD_VAR 0 1
105439: PPUSH
105440: LD_INT 1
105442: PPUSH
105443: CALL_OW 234
105447: GO 105432
105449: POP
105450: POP
// end ;
105451: PPOPN 2
105453: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105454: LD_EXP 124
105458: PUSH
105459: LD_EXP 173
105463: AND
105464: IFFALSE 105751
105466: GO 105468
105468: DISABLE
105469: LD_INT 0
105471: PPUSH
105472: PPUSH
105473: PPUSH
// begin i := rand ( 1 , 7 ) ;
105474: LD_ADDR_VAR 0 1
105478: PUSH
105479: LD_INT 1
105481: PPUSH
105482: LD_INT 7
105484: PPUSH
105485: CALL_OW 12
105489: ST_TO_ADDR
// case i of 1 :
105490: LD_VAR 0 1
105494: PUSH
105495: LD_INT 1
105497: DOUBLE
105498: EQUAL
105499: IFTRUE 105503
105501: GO 105513
105503: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105504: LD_STRING earthquake(getX(game), 0, 32)
105506: PPUSH
105507: CALL_OW 559
105511: GO 105751
105513: LD_INT 2
105515: DOUBLE
105516: EQUAL
105517: IFTRUE 105521
105519: GO 105535
105521: POP
// begin ToLua ( displayStucuk(); ) ;
105522: LD_STRING displayStucuk();
105524: PPUSH
105525: CALL_OW 559
// ResetFog ;
105529: CALL_OW 335
// end ; 3 :
105533: GO 105751
105535: LD_INT 3
105537: DOUBLE
105538: EQUAL
105539: IFTRUE 105543
105541: GO 105647
105543: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105544: LD_ADDR_VAR 0 2
105548: PUSH
105549: LD_INT 22
105551: PUSH
105552: LD_OWVAR 2
105556: PUSH
105557: EMPTY
105558: LIST
105559: LIST
105560: PUSH
105561: LD_INT 25
105563: PUSH
105564: LD_INT 1
105566: PUSH
105567: EMPTY
105568: LIST
105569: LIST
105570: PUSH
105571: EMPTY
105572: LIST
105573: LIST
105574: PPUSH
105575: CALL_OW 69
105579: ST_TO_ADDR
// if not tmp then
105580: LD_VAR 0 2
105584: NOT
105585: IFFALSE 105589
// exit ;
105587: GO 105751
// un := tmp [ rand ( 1 , tmp ) ] ;
105589: LD_ADDR_VAR 0 3
105593: PUSH
105594: LD_VAR 0 2
105598: PUSH
105599: LD_INT 1
105601: PPUSH
105602: LD_VAR 0 2
105606: PPUSH
105607: CALL_OW 12
105611: ARRAY
105612: ST_TO_ADDR
// if Crawls ( un ) then
105613: LD_VAR 0 3
105617: PPUSH
105618: CALL_OW 318
105622: IFFALSE 105633
// ComWalk ( un ) ;
105624: LD_VAR 0 3
105628: PPUSH
105629: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105633: LD_VAR 0 3
105637: PPUSH
105638: LD_INT 8
105640: PPUSH
105641: CALL_OW 336
// end ; 4 :
105645: GO 105751
105647: LD_INT 4
105649: DOUBLE
105650: EQUAL
105651: IFTRUE 105655
105653: GO 105729
105655: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105656: LD_ADDR_VAR 0 2
105660: PUSH
105661: LD_INT 22
105663: PUSH
105664: LD_OWVAR 2
105668: PUSH
105669: EMPTY
105670: LIST
105671: LIST
105672: PUSH
105673: LD_INT 30
105675: PUSH
105676: LD_INT 29
105678: PUSH
105679: EMPTY
105680: LIST
105681: LIST
105682: PUSH
105683: EMPTY
105684: LIST
105685: LIST
105686: PPUSH
105687: CALL_OW 69
105691: ST_TO_ADDR
// if not tmp then
105692: LD_VAR 0 2
105696: NOT
105697: IFFALSE 105701
// exit ;
105699: GO 105751
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105701: LD_VAR 0 2
105705: PUSH
105706: LD_INT 1
105708: ARRAY
105709: PPUSH
105710: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105714: LD_VAR 0 2
105718: PUSH
105719: LD_INT 1
105721: ARRAY
105722: PPUSH
105723: CALL_OW 65
// end ; 5 .. 7 :
105727: GO 105751
105729: LD_INT 5
105731: DOUBLE
105732: GREATEREQUAL
105733: IFFALSE 105741
105735: LD_INT 7
105737: DOUBLE
105738: LESSEQUAL
105739: IFTRUE 105743
105741: GO 105750
105743: POP
// StreamSibBomb ; end ;
105744: CALL 101988 0 0
105748: GO 105751
105750: POP
// end ;
105751: PPOPN 3
105753: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105754: LD_EXP 124
105758: PUSH
105759: LD_EXP 174
105763: AND
105764: IFFALSE 105920
105766: GO 105768
105768: DISABLE
105769: LD_INT 0
105771: PPUSH
105772: PPUSH
105773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105774: LD_ADDR_VAR 0 2
105778: PUSH
105779: LD_INT 81
105781: PUSH
105782: LD_OWVAR 2
105786: PUSH
105787: EMPTY
105788: LIST
105789: LIST
105790: PUSH
105791: LD_INT 2
105793: PUSH
105794: LD_INT 21
105796: PUSH
105797: LD_INT 1
105799: PUSH
105800: EMPTY
105801: LIST
105802: LIST
105803: PUSH
105804: LD_INT 21
105806: PUSH
105807: LD_INT 2
105809: PUSH
105810: EMPTY
105811: LIST
105812: LIST
105813: PUSH
105814: EMPTY
105815: LIST
105816: LIST
105817: LIST
105818: PUSH
105819: EMPTY
105820: LIST
105821: LIST
105822: PPUSH
105823: CALL_OW 69
105827: ST_TO_ADDR
// if not tmp then
105828: LD_VAR 0 2
105832: NOT
105833: IFFALSE 105837
// exit ;
105835: GO 105920
// p := 0 ;
105837: LD_ADDR_VAR 0 3
105841: PUSH
105842: LD_INT 0
105844: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105845: LD_INT 35
105847: PPUSH
105848: CALL_OW 67
// p := p + 1 ;
105852: LD_ADDR_VAR 0 3
105856: PUSH
105857: LD_VAR 0 3
105861: PUSH
105862: LD_INT 1
105864: PLUS
105865: ST_TO_ADDR
// for i in tmp do
105866: LD_ADDR_VAR 0 1
105870: PUSH
105871: LD_VAR 0 2
105875: PUSH
105876: FOR_IN
105877: IFFALSE 105908
// if GetLives ( i ) < 1000 then
105879: LD_VAR 0 1
105883: PPUSH
105884: CALL_OW 256
105888: PUSH
105889: LD_INT 1000
105891: LESS
105892: IFFALSE 105906
// SetLives ( i , 1000 ) ;
105894: LD_VAR 0 1
105898: PPUSH
105899: LD_INT 1000
105901: PPUSH
105902: CALL_OW 234
105906: GO 105876
105908: POP
105909: POP
// until p > 20 ;
105910: LD_VAR 0 3
105914: PUSH
105915: LD_INT 20
105917: GREATER
105918: IFFALSE 105845
// end ;
105920: PPOPN 3
105922: END
// every 0 0$1 trigger StreamModeActive and sTime do
105923: LD_EXP 124
105927: PUSH
105928: LD_EXP 175
105932: AND
105933: IFFALSE 105968
105935: GO 105937
105937: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105938: LD_INT 28
105940: PPUSH
105941: LD_OWVAR 2
105945: PPUSH
105946: LD_INT 2
105948: PPUSH
105949: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105953: LD_INT 30
105955: PPUSH
105956: LD_OWVAR 2
105960: PPUSH
105961: LD_INT 2
105963: PPUSH
105964: CALL_OW 322
// end ;
105968: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105969: LD_EXP 124
105973: PUSH
105974: LD_EXP 176
105978: AND
105979: IFFALSE 106100
105981: GO 105983
105983: DISABLE
105984: LD_INT 0
105986: PPUSH
105987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105988: LD_ADDR_VAR 0 2
105992: PUSH
105993: LD_INT 22
105995: PUSH
105996: LD_OWVAR 2
106000: PUSH
106001: EMPTY
106002: LIST
106003: LIST
106004: PUSH
106005: LD_INT 21
106007: PUSH
106008: LD_INT 1
106010: PUSH
106011: EMPTY
106012: LIST
106013: LIST
106014: PUSH
106015: LD_INT 3
106017: PUSH
106018: LD_INT 23
106020: PUSH
106021: LD_INT 0
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: PUSH
106028: EMPTY
106029: LIST
106030: LIST
106031: PUSH
106032: EMPTY
106033: LIST
106034: LIST
106035: LIST
106036: PPUSH
106037: CALL_OW 69
106041: ST_TO_ADDR
// if not tmp then
106042: LD_VAR 0 2
106046: NOT
106047: IFFALSE 106051
// exit ;
106049: GO 106100
// for i in tmp do
106051: LD_ADDR_VAR 0 1
106055: PUSH
106056: LD_VAR 0 2
106060: PUSH
106061: FOR_IN
106062: IFFALSE 106098
// begin if Crawls ( i ) then
106064: LD_VAR 0 1
106068: PPUSH
106069: CALL_OW 318
106073: IFFALSE 106084
// ComWalk ( i ) ;
106075: LD_VAR 0 1
106079: PPUSH
106080: CALL_OW 138
// SetClass ( i , 2 ) ;
106084: LD_VAR 0 1
106088: PPUSH
106089: LD_INT 2
106091: PPUSH
106092: CALL_OW 336
// end ;
106096: GO 106061
106098: POP
106099: POP
// end ;
106100: PPOPN 2
106102: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106103: LD_EXP 124
106107: PUSH
106108: LD_EXP 177
106112: AND
106113: IFFALSE 106401
106115: GO 106117
106117: DISABLE
106118: LD_INT 0
106120: PPUSH
106121: PPUSH
106122: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106123: LD_OWVAR 2
106127: PPUSH
106128: LD_INT 9
106130: PPUSH
106131: LD_INT 1
106133: PPUSH
106134: LD_INT 1
106136: PPUSH
106137: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106141: LD_INT 9
106143: PPUSH
106144: LD_OWVAR 2
106148: PPUSH
106149: CALL_OW 343
// uc_side := 9 ;
106153: LD_ADDR_OWVAR 20
106157: PUSH
106158: LD_INT 9
106160: ST_TO_ADDR
// uc_nation := 2 ;
106161: LD_ADDR_OWVAR 21
106165: PUSH
106166: LD_INT 2
106168: ST_TO_ADDR
// hc_name := Dark Warrior ;
106169: LD_ADDR_OWVAR 26
106173: PUSH
106174: LD_STRING Dark Warrior
106176: ST_TO_ADDR
// hc_gallery :=  ;
106177: LD_ADDR_OWVAR 33
106181: PUSH
106182: LD_STRING 
106184: ST_TO_ADDR
// hc_noskilllimit := true ;
106185: LD_ADDR_OWVAR 76
106189: PUSH
106190: LD_INT 1
106192: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106193: LD_ADDR_OWVAR 31
106197: PUSH
106198: LD_INT 30
106200: PUSH
106201: LD_INT 30
106203: PUSH
106204: LD_INT 30
106206: PUSH
106207: LD_INT 30
106209: PUSH
106210: EMPTY
106211: LIST
106212: LIST
106213: LIST
106214: LIST
106215: ST_TO_ADDR
// un := CreateHuman ;
106216: LD_ADDR_VAR 0 3
106220: PUSH
106221: CALL_OW 44
106225: ST_TO_ADDR
// hc_noskilllimit := false ;
106226: LD_ADDR_OWVAR 76
106230: PUSH
106231: LD_INT 0
106233: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106234: LD_VAR 0 3
106238: PPUSH
106239: LD_INT 1
106241: PPUSH
106242: CALL_OW 51
// ToLua ( playRanger() ) ;
106246: LD_STRING playRanger()
106248: PPUSH
106249: CALL_OW 559
// p := 0 ;
106253: LD_ADDR_VAR 0 2
106257: PUSH
106258: LD_INT 0
106260: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106261: LD_INT 35
106263: PPUSH
106264: CALL_OW 67
// p := p + 1 ;
106268: LD_ADDR_VAR 0 2
106272: PUSH
106273: LD_VAR 0 2
106277: PUSH
106278: LD_INT 1
106280: PLUS
106281: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106282: LD_VAR 0 3
106286: PPUSH
106287: CALL_OW 256
106291: PUSH
106292: LD_INT 1000
106294: LESS
106295: IFFALSE 106309
// SetLives ( un , 1000 ) ;
106297: LD_VAR 0 3
106301: PPUSH
106302: LD_INT 1000
106304: PPUSH
106305: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106309: LD_VAR 0 3
106313: PPUSH
106314: LD_INT 81
106316: PUSH
106317: LD_OWVAR 2
106321: PUSH
106322: EMPTY
106323: LIST
106324: LIST
106325: PUSH
106326: LD_INT 91
106328: PUSH
106329: LD_VAR 0 3
106333: PUSH
106334: LD_INT 30
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: LIST
106341: PUSH
106342: EMPTY
106343: LIST
106344: LIST
106345: PPUSH
106346: CALL_OW 69
106350: PPUSH
106351: LD_VAR 0 3
106355: PPUSH
106356: CALL_OW 74
106360: PPUSH
106361: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106365: LD_VAR 0 2
106369: PUSH
106370: LD_INT 80
106372: GREATER
106373: PUSH
106374: LD_VAR 0 3
106378: PPUSH
106379: CALL_OW 301
106383: OR
106384: IFFALSE 106261
// if un then
106386: LD_VAR 0 3
106390: IFFALSE 106401
// RemoveUnit ( un ) ;
106392: LD_VAR 0 3
106396: PPUSH
106397: CALL_OW 64
// end ;
106401: PPOPN 3
106403: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106404: LD_EXP 178
106408: IFFALSE 106524
106410: GO 106412
106412: DISABLE
106413: LD_INT 0
106415: PPUSH
106416: PPUSH
106417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106418: LD_ADDR_VAR 0 2
106422: PUSH
106423: LD_INT 81
106425: PUSH
106426: LD_OWVAR 2
106430: PUSH
106431: EMPTY
106432: LIST
106433: LIST
106434: PUSH
106435: LD_INT 21
106437: PUSH
106438: LD_INT 1
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: PUSH
106445: EMPTY
106446: LIST
106447: LIST
106448: PPUSH
106449: CALL_OW 69
106453: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106454: LD_STRING playComputer()
106456: PPUSH
106457: CALL_OW 559
// if not tmp then
106461: LD_VAR 0 2
106465: NOT
106466: IFFALSE 106470
// exit ;
106468: GO 106524
// for i in tmp do
106470: LD_ADDR_VAR 0 1
106474: PUSH
106475: LD_VAR 0 2
106479: PUSH
106480: FOR_IN
106481: IFFALSE 106522
// for j := 1 to 4 do
106483: LD_ADDR_VAR 0 3
106487: PUSH
106488: DOUBLE
106489: LD_INT 1
106491: DEC
106492: ST_TO_ADDR
106493: LD_INT 4
106495: PUSH
106496: FOR_TO
106497: IFFALSE 106518
// SetSkill ( i , j , 10 ) ;
106499: LD_VAR 0 1
106503: PPUSH
106504: LD_VAR 0 3
106508: PPUSH
106509: LD_INT 10
106511: PPUSH
106512: CALL_OW 237
106516: GO 106496
106518: POP
106519: POP
106520: GO 106480
106522: POP
106523: POP
// end ;
106524: PPOPN 3
106526: END
// every 0 0$1 trigger s30 do var i , tmp ;
106527: LD_EXP 179
106531: IFFALSE 106600
106533: GO 106535
106535: DISABLE
106536: LD_INT 0
106538: PPUSH
106539: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106540: LD_ADDR_VAR 0 2
106544: PUSH
106545: LD_INT 22
106547: PUSH
106548: LD_OWVAR 2
106552: PUSH
106553: EMPTY
106554: LIST
106555: LIST
106556: PPUSH
106557: CALL_OW 69
106561: ST_TO_ADDR
// if not tmp then
106562: LD_VAR 0 2
106566: NOT
106567: IFFALSE 106571
// exit ;
106569: GO 106600
// for i in tmp do
106571: LD_ADDR_VAR 0 1
106575: PUSH
106576: LD_VAR 0 2
106580: PUSH
106581: FOR_IN
106582: IFFALSE 106598
// SetLives ( i , 300 ) ;
106584: LD_VAR 0 1
106588: PPUSH
106589: LD_INT 300
106591: PPUSH
106592: CALL_OW 234
106596: GO 106581
106598: POP
106599: POP
// end ;
106600: PPOPN 2
106602: END
// every 0 0$1 trigger s60 do var i , tmp ;
106603: LD_EXP 180
106607: IFFALSE 106676
106609: GO 106611
106611: DISABLE
106612: LD_INT 0
106614: PPUSH
106615: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106616: LD_ADDR_VAR 0 2
106620: PUSH
106621: LD_INT 22
106623: PUSH
106624: LD_OWVAR 2
106628: PUSH
106629: EMPTY
106630: LIST
106631: LIST
106632: PPUSH
106633: CALL_OW 69
106637: ST_TO_ADDR
// if not tmp then
106638: LD_VAR 0 2
106642: NOT
106643: IFFALSE 106647
// exit ;
106645: GO 106676
// for i in tmp do
106647: LD_ADDR_VAR 0 1
106651: PUSH
106652: LD_VAR 0 2
106656: PUSH
106657: FOR_IN
106658: IFFALSE 106674
// SetLives ( i , 600 ) ;
106660: LD_VAR 0 1
106664: PPUSH
106665: LD_INT 600
106667: PPUSH
106668: CALL_OW 234
106672: GO 106657
106674: POP
106675: POP
// end ;
106676: PPOPN 2
106678: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106679: LD_INT 0
106681: PPUSH
// case cmd of 301 :
106682: LD_VAR 0 1
106686: PUSH
106687: LD_INT 301
106689: DOUBLE
106690: EQUAL
106691: IFTRUE 106695
106693: GO 106727
106695: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106696: LD_VAR 0 6
106700: PPUSH
106701: LD_VAR 0 7
106705: PPUSH
106706: LD_VAR 0 8
106710: PPUSH
106711: LD_VAR 0 4
106715: PPUSH
106716: LD_VAR 0 5
106720: PPUSH
106721: CALL 107936 0 5
106725: GO 106848
106727: LD_INT 302
106729: DOUBLE
106730: EQUAL
106731: IFTRUE 106735
106733: GO 106772
106735: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106736: LD_VAR 0 6
106740: PPUSH
106741: LD_VAR 0 7
106745: PPUSH
106746: LD_VAR 0 8
106750: PPUSH
106751: LD_VAR 0 9
106755: PPUSH
106756: LD_VAR 0 4
106760: PPUSH
106761: LD_VAR 0 5
106765: PPUSH
106766: CALL 108027 0 6
106770: GO 106848
106772: LD_INT 303
106774: DOUBLE
106775: EQUAL
106776: IFTRUE 106780
106778: GO 106817
106780: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106781: LD_VAR 0 6
106785: PPUSH
106786: LD_VAR 0 7
106790: PPUSH
106791: LD_VAR 0 8
106795: PPUSH
106796: LD_VAR 0 9
106800: PPUSH
106801: LD_VAR 0 4
106805: PPUSH
106806: LD_VAR 0 5
106810: PPUSH
106811: CALL 106853 0 6
106815: GO 106848
106817: LD_INT 304
106819: DOUBLE
106820: EQUAL
106821: IFTRUE 106825
106823: GO 106847
106825: POP
// hHackTeleport ( unit , x , y ) ; end ;
106826: LD_VAR 0 2
106830: PPUSH
106831: LD_VAR 0 4
106835: PPUSH
106836: LD_VAR 0 5
106840: PPUSH
106841: CALL 108620 0 3
106845: GO 106848
106847: POP
// end ;
106848: LD_VAR 0 12
106852: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106853: LD_INT 0
106855: PPUSH
106856: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106857: LD_VAR 0 1
106861: PUSH
106862: LD_INT 1
106864: LESS
106865: PUSH
106866: LD_VAR 0 1
106870: PUSH
106871: LD_INT 3
106873: GREATER
106874: OR
106875: PUSH
106876: LD_VAR 0 5
106880: PPUSH
106881: LD_VAR 0 6
106885: PPUSH
106886: CALL_OW 428
106890: OR
106891: IFFALSE 106895
// exit ;
106893: GO 107623
// uc_side := your_side ;
106895: LD_ADDR_OWVAR 20
106899: PUSH
106900: LD_OWVAR 2
106904: ST_TO_ADDR
// uc_nation := nation ;
106905: LD_ADDR_OWVAR 21
106909: PUSH
106910: LD_VAR 0 1
106914: ST_TO_ADDR
// bc_level = 1 ;
106915: LD_ADDR_OWVAR 43
106919: PUSH
106920: LD_INT 1
106922: ST_TO_ADDR
// case btype of 1 :
106923: LD_VAR 0 2
106927: PUSH
106928: LD_INT 1
106930: DOUBLE
106931: EQUAL
106932: IFTRUE 106936
106934: GO 106947
106936: POP
// bc_type := b_depot ; 2 :
106937: LD_ADDR_OWVAR 42
106941: PUSH
106942: LD_INT 0
106944: ST_TO_ADDR
106945: GO 107567
106947: LD_INT 2
106949: DOUBLE
106950: EQUAL
106951: IFTRUE 106955
106953: GO 106966
106955: POP
// bc_type := b_warehouse ; 3 :
106956: LD_ADDR_OWVAR 42
106960: PUSH
106961: LD_INT 1
106963: ST_TO_ADDR
106964: GO 107567
106966: LD_INT 3
106968: DOUBLE
106969: EQUAL
106970: IFTRUE 106974
106972: GO 106985
106974: POP
// bc_type := b_lab ; 4 .. 9 :
106975: LD_ADDR_OWVAR 42
106979: PUSH
106980: LD_INT 6
106982: ST_TO_ADDR
106983: GO 107567
106985: LD_INT 4
106987: DOUBLE
106988: GREATEREQUAL
106989: IFFALSE 106997
106991: LD_INT 9
106993: DOUBLE
106994: LESSEQUAL
106995: IFTRUE 106999
106997: GO 107059
106999: POP
// begin bc_type := b_lab_half ;
107000: LD_ADDR_OWVAR 42
107004: PUSH
107005: LD_INT 7
107007: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107008: LD_ADDR_OWVAR 44
107012: PUSH
107013: LD_INT 10
107015: PUSH
107016: LD_INT 11
107018: PUSH
107019: LD_INT 12
107021: PUSH
107022: LD_INT 15
107024: PUSH
107025: LD_INT 14
107027: PUSH
107028: LD_INT 13
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: LIST
107035: LIST
107036: LIST
107037: LIST
107038: PUSH
107039: LD_VAR 0 2
107043: PUSH
107044: LD_INT 3
107046: MINUS
107047: ARRAY
107048: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107049: LD_ADDR_OWVAR 45
107053: PUSH
107054: LD_INT 9
107056: ST_TO_ADDR
// end ; 10 .. 13 :
107057: GO 107567
107059: LD_INT 10
107061: DOUBLE
107062: GREATEREQUAL
107063: IFFALSE 107071
107065: LD_INT 13
107067: DOUBLE
107068: LESSEQUAL
107069: IFTRUE 107073
107071: GO 107150
107073: POP
// begin bc_type := b_lab_full ;
107074: LD_ADDR_OWVAR 42
107078: PUSH
107079: LD_INT 8
107081: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107082: LD_ADDR_OWVAR 44
107086: PUSH
107087: LD_INT 10
107089: PUSH
107090: LD_INT 12
107092: PUSH
107093: LD_INT 14
107095: PUSH
107096: LD_INT 13
107098: PUSH
107099: EMPTY
107100: LIST
107101: LIST
107102: LIST
107103: LIST
107104: PUSH
107105: LD_VAR 0 2
107109: PUSH
107110: LD_INT 9
107112: MINUS
107113: ARRAY
107114: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107115: LD_ADDR_OWVAR 45
107119: PUSH
107120: LD_INT 11
107122: PUSH
107123: LD_INT 15
107125: PUSH
107126: LD_INT 12
107128: PUSH
107129: LD_INT 15
107131: PUSH
107132: EMPTY
107133: LIST
107134: LIST
107135: LIST
107136: LIST
107137: PUSH
107138: LD_VAR 0 2
107142: PUSH
107143: LD_INT 9
107145: MINUS
107146: ARRAY
107147: ST_TO_ADDR
// end ; 14 :
107148: GO 107567
107150: LD_INT 14
107152: DOUBLE
107153: EQUAL
107154: IFTRUE 107158
107156: GO 107169
107158: POP
// bc_type := b_workshop ; 15 :
107159: LD_ADDR_OWVAR 42
107163: PUSH
107164: LD_INT 2
107166: ST_TO_ADDR
107167: GO 107567
107169: LD_INT 15
107171: DOUBLE
107172: EQUAL
107173: IFTRUE 107177
107175: GO 107188
107177: POP
// bc_type := b_factory ; 16 :
107178: LD_ADDR_OWVAR 42
107182: PUSH
107183: LD_INT 3
107185: ST_TO_ADDR
107186: GO 107567
107188: LD_INT 16
107190: DOUBLE
107191: EQUAL
107192: IFTRUE 107196
107194: GO 107207
107196: POP
// bc_type := b_ext_gun ; 17 :
107197: LD_ADDR_OWVAR 42
107201: PUSH
107202: LD_INT 17
107204: ST_TO_ADDR
107205: GO 107567
107207: LD_INT 17
107209: DOUBLE
107210: EQUAL
107211: IFTRUE 107215
107213: GO 107243
107215: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107216: LD_ADDR_OWVAR 42
107220: PUSH
107221: LD_INT 19
107223: PUSH
107224: LD_INT 23
107226: PUSH
107227: LD_INT 19
107229: PUSH
107230: EMPTY
107231: LIST
107232: LIST
107233: LIST
107234: PUSH
107235: LD_VAR 0 1
107239: ARRAY
107240: ST_TO_ADDR
107241: GO 107567
107243: LD_INT 18
107245: DOUBLE
107246: EQUAL
107247: IFTRUE 107251
107249: GO 107262
107251: POP
// bc_type := b_ext_radar ; 19 :
107252: LD_ADDR_OWVAR 42
107256: PUSH
107257: LD_INT 20
107259: ST_TO_ADDR
107260: GO 107567
107262: LD_INT 19
107264: DOUBLE
107265: EQUAL
107266: IFTRUE 107270
107268: GO 107281
107270: POP
// bc_type := b_ext_radio ; 20 :
107271: LD_ADDR_OWVAR 42
107275: PUSH
107276: LD_INT 22
107278: ST_TO_ADDR
107279: GO 107567
107281: LD_INT 20
107283: DOUBLE
107284: EQUAL
107285: IFTRUE 107289
107287: GO 107300
107289: POP
// bc_type := b_ext_siberium ; 21 :
107290: LD_ADDR_OWVAR 42
107294: PUSH
107295: LD_INT 21
107297: ST_TO_ADDR
107298: GO 107567
107300: LD_INT 21
107302: DOUBLE
107303: EQUAL
107304: IFTRUE 107308
107306: GO 107319
107308: POP
// bc_type := b_ext_computer ; 22 :
107309: LD_ADDR_OWVAR 42
107313: PUSH
107314: LD_INT 24
107316: ST_TO_ADDR
107317: GO 107567
107319: LD_INT 22
107321: DOUBLE
107322: EQUAL
107323: IFTRUE 107327
107325: GO 107338
107327: POP
// bc_type := b_ext_track ; 23 :
107328: LD_ADDR_OWVAR 42
107332: PUSH
107333: LD_INT 16
107335: ST_TO_ADDR
107336: GO 107567
107338: LD_INT 23
107340: DOUBLE
107341: EQUAL
107342: IFTRUE 107346
107344: GO 107357
107346: POP
// bc_type := b_ext_laser ; 24 :
107347: LD_ADDR_OWVAR 42
107351: PUSH
107352: LD_INT 25
107354: ST_TO_ADDR
107355: GO 107567
107357: LD_INT 24
107359: DOUBLE
107360: EQUAL
107361: IFTRUE 107365
107363: GO 107376
107365: POP
// bc_type := b_control_tower ; 25 :
107366: LD_ADDR_OWVAR 42
107370: PUSH
107371: LD_INT 36
107373: ST_TO_ADDR
107374: GO 107567
107376: LD_INT 25
107378: DOUBLE
107379: EQUAL
107380: IFTRUE 107384
107382: GO 107395
107384: POP
// bc_type := b_breastwork ; 26 :
107385: LD_ADDR_OWVAR 42
107389: PUSH
107390: LD_INT 31
107392: ST_TO_ADDR
107393: GO 107567
107395: LD_INT 26
107397: DOUBLE
107398: EQUAL
107399: IFTRUE 107403
107401: GO 107414
107403: POP
// bc_type := b_bunker ; 27 :
107404: LD_ADDR_OWVAR 42
107408: PUSH
107409: LD_INT 32
107411: ST_TO_ADDR
107412: GO 107567
107414: LD_INT 27
107416: DOUBLE
107417: EQUAL
107418: IFTRUE 107422
107420: GO 107433
107422: POP
// bc_type := b_turret ; 28 :
107423: LD_ADDR_OWVAR 42
107427: PUSH
107428: LD_INT 33
107430: ST_TO_ADDR
107431: GO 107567
107433: LD_INT 28
107435: DOUBLE
107436: EQUAL
107437: IFTRUE 107441
107439: GO 107452
107441: POP
// bc_type := b_armoury ; 29 :
107442: LD_ADDR_OWVAR 42
107446: PUSH
107447: LD_INT 4
107449: ST_TO_ADDR
107450: GO 107567
107452: LD_INT 29
107454: DOUBLE
107455: EQUAL
107456: IFTRUE 107460
107458: GO 107471
107460: POP
// bc_type := b_barracks ; 30 :
107461: LD_ADDR_OWVAR 42
107465: PUSH
107466: LD_INT 5
107468: ST_TO_ADDR
107469: GO 107567
107471: LD_INT 30
107473: DOUBLE
107474: EQUAL
107475: IFTRUE 107479
107477: GO 107490
107479: POP
// bc_type := b_solar_power ; 31 :
107480: LD_ADDR_OWVAR 42
107484: PUSH
107485: LD_INT 27
107487: ST_TO_ADDR
107488: GO 107567
107490: LD_INT 31
107492: DOUBLE
107493: EQUAL
107494: IFTRUE 107498
107496: GO 107509
107498: POP
// bc_type := b_oil_power ; 32 :
107499: LD_ADDR_OWVAR 42
107503: PUSH
107504: LD_INT 26
107506: ST_TO_ADDR
107507: GO 107567
107509: LD_INT 32
107511: DOUBLE
107512: EQUAL
107513: IFTRUE 107517
107515: GO 107528
107517: POP
// bc_type := b_siberite_power ; 33 :
107518: LD_ADDR_OWVAR 42
107522: PUSH
107523: LD_INT 28
107525: ST_TO_ADDR
107526: GO 107567
107528: LD_INT 33
107530: DOUBLE
107531: EQUAL
107532: IFTRUE 107536
107534: GO 107547
107536: POP
// bc_type := b_oil_mine ; 34 :
107537: LD_ADDR_OWVAR 42
107541: PUSH
107542: LD_INT 29
107544: ST_TO_ADDR
107545: GO 107567
107547: LD_INT 34
107549: DOUBLE
107550: EQUAL
107551: IFTRUE 107555
107553: GO 107566
107555: POP
// bc_type := b_siberite_mine ; end ;
107556: LD_ADDR_OWVAR 42
107560: PUSH
107561: LD_INT 30
107563: ST_TO_ADDR
107564: GO 107567
107566: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107567: LD_ADDR_VAR 0 8
107571: PUSH
107572: LD_VAR 0 5
107576: PPUSH
107577: LD_VAR 0 6
107581: PPUSH
107582: LD_VAR 0 3
107586: PPUSH
107587: CALL_OW 47
107591: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107592: LD_OWVAR 42
107596: PUSH
107597: LD_INT 32
107599: PUSH
107600: LD_INT 33
107602: PUSH
107603: EMPTY
107604: LIST
107605: LIST
107606: IN
107607: IFFALSE 107623
// PlaceWeaponTurret ( b , weapon ) ;
107609: LD_VAR 0 8
107613: PPUSH
107614: LD_VAR 0 4
107618: PPUSH
107619: CALL_OW 431
// end ;
107623: LD_VAR 0 7
107627: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107628: LD_INT 0
107630: PPUSH
107631: PPUSH
107632: PPUSH
107633: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107634: LD_ADDR_VAR 0 4
107638: PUSH
107639: LD_INT 22
107641: PUSH
107642: LD_OWVAR 2
107646: PUSH
107647: EMPTY
107648: LIST
107649: LIST
107650: PUSH
107651: LD_INT 2
107653: PUSH
107654: LD_INT 30
107656: PUSH
107657: LD_INT 0
107659: PUSH
107660: EMPTY
107661: LIST
107662: LIST
107663: PUSH
107664: LD_INT 30
107666: PUSH
107667: LD_INT 1
107669: PUSH
107670: EMPTY
107671: LIST
107672: LIST
107673: PUSH
107674: EMPTY
107675: LIST
107676: LIST
107677: LIST
107678: PUSH
107679: EMPTY
107680: LIST
107681: LIST
107682: PPUSH
107683: CALL_OW 69
107687: ST_TO_ADDR
// if not tmp then
107688: LD_VAR 0 4
107692: NOT
107693: IFFALSE 107697
// exit ;
107695: GO 107756
// for i in tmp do
107697: LD_ADDR_VAR 0 2
107701: PUSH
107702: LD_VAR 0 4
107706: PUSH
107707: FOR_IN
107708: IFFALSE 107754
// for j = 1 to 3 do
107710: LD_ADDR_VAR 0 3
107714: PUSH
107715: DOUBLE
107716: LD_INT 1
107718: DEC
107719: ST_TO_ADDR
107720: LD_INT 3
107722: PUSH
107723: FOR_TO
107724: IFFALSE 107750
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107726: LD_VAR 0 2
107730: PPUSH
107731: CALL_OW 274
107735: PPUSH
107736: LD_VAR 0 3
107740: PPUSH
107741: LD_INT 99999
107743: PPUSH
107744: CALL_OW 277
107748: GO 107723
107750: POP
107751: POP
107752: GO 107707
107754: POP
107755: POP
// end ;
107756: LD_VAR 0 1
107760: RET
// export function hHackSetLevel10 ; var i , j ; begin
107761: LD_INT 0
107763: PPUSH
107764: PPUSH
107765: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107766: LD_ADDR_VAR 0 2
107770: PUSH
107771: LD_INT 21
107773: PUSH
107774: LD_INT 1
107776: PUSH
107777: EMPTY
107778: LIST
107779: LIST
107780: PPUSH
107781: CALL_OW 69
107785: PUSH
107786: FOR_IN
107787: IFFALSE 107839
// if IsSelected ( i ) then
107789: LD_VAR 0 2
107793: PPUSH
107794: CALL_OW 306
107798: IFFALSE 107837
// begin for j := 1 to 4 do
107800: LD_ADDR_VAR 0 3
107804: PUSH
107805: DOUBLE
107806: LD_INT 1
107808: DEC
107809: ST_TO_ADDR
107810: LD_INT 4
107812: PUSH
107813: FOR_TO
107814: IFFALSE 107835
// SetSkill ( i , j , 10 ) ;
107816: LD_VAR 0 2
107820: PPUSH
107821: LD_VAR 0 3
107825: PPUSH
107826: LD_INT 10
107828: PPUSH
107829: CALL_OW 237
107833: GO 107813
107835: POP
107836: POP
// end ;
107837: GO 107786
107839: POP
107840: POP
// end ;
107841: LD_VAR 0 1
107845: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107846: LD_INT 0
107848: PPUSH
107849: PPUSH
107850: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107851: LD_ADDR_VAR 0 2
107855: PUSH
107856: LD_INT 22
107858: PUSH
107859: LD_OWVAR 2
107863: PUSH
107864: EMPTY
107865: LIST
107866: LIST
107867: PUSH
107868: LD_INT 21
107870: PUSH
107871: LD_INT 1
107873: PUSH
107874: EMPTY
107875: LIST
107876: LIST
107877: PUSH
107878: EMPTY
107879: LIST
107880: LIST
107881: PPUSH
107882: CALL_OW 69
107886: PUSH
107887: FOR_IN
107888: IFFALSE 107929
// begin for j := 1 to 4 do
107890: LD_ADDR_VAR 0 3
107894: PUSH
107895: DOUBLE
107896: LD_INT 1
107898: DEC
107899: ST_TO_ADDR
107900: LD_INT 4
107902: PUSH
107903: FOR_TO
107904: IFFALSE 107925
// SetSkill ( i , j , 10 ) ;
107906: LD_VAR 0 2
107910: PPUSH
107911: LD_VAR 0 3
107915: PPUSH
107916: LD_INT 10
107918: PPUSH
107919: CALL_OW 237
107923: GO 107903
107925: POP
107926: POP
// end ;
107927: GO 107887
107929: POP
107930: POP
// end ;
107931: LD_VAR 0 1
107935: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107936: LD_INT 0
107938: PPUSH
// uc_side := your_side ;
107939: LD_ADDR_OWVAR 20
107943: PUSH
107944: LD_OWVAR 2
107948: ST_TO_ADDR
// uc_nation := nation ;
107949: LD_ADDR_OWVAR 21
107953: PUSH
107954: LD_VAR 0 1
107958: ST_TO_ADDR
// InitHc ;
107959: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107963: LD_INT 0
107965: PPUSH
107966: LD_VAR 0 2
107970: PPUSH
107971: LD_VAR 0 3
107975: PPUSH
107976: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107980: LD_VAR 0 4
107984: PPUSH
107985: LD_VAR 0 5
107989: PPUSH
107990: CALL_OW 428
107994: PUSH
107995: LD_INT 0
107997: EQUAL
107998: IFFALSE 108022
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108000: CALL_OW 44
108004: PPUSH
108005: LD_VAR 0 4
108009: PPUSH
108010: LD_VAR 0 5
108014: PPUSH
108015: LD_INT 1
108017: PPUSH
108018: CALL_OW 48
// end ;
108022: LD_VAR 0 6
108026: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108027: LD_INT 0
108029: PPUSH
108030: PPUSH
// uc_side := your_side ;
108031: LD_ADDR_OWVAR 20
108035: PUSH
108036: LD_OWVAR 2
108040: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108041: LD_VAR 0 1
108045: PUSH
108046: LD_INT 1
108048: PUSH
108049: LD_INT 2
108051: PUSH
108052: LD_INT 3
108054: PUSH
108055: LD_INT 4
108057: PUSH
108058: LD_INT 5
108060: PUSH
108061: EMPTY
108062: LIST
108063: LIST
108064: LIST
108065: LIST
108066: LIST
108067: IN
108068: IFFALSE 108080
// uc_nation := nation_american else
108070: LD_ADDR_OWVAR 21
108074: PUSH
108075: LD_INT 1
108077: ST_TO_ADDR
108078: GO 108123
// if chassis in [ 11 , 12 , 13 , 14 ] then
108080: LD_VAR 0 1
108084: PUSH
108085: LD_INT 11
108087: PUSH
108088: LD_INT 12
108090: PUSH
108091: LD_INT 13
108093: PUSH
108094: LD_INT 14
108096: PUSH
108097: EMPTY
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: IN
108103: IFFALSE 108115
// uc_nation := nation_arabian else
108105: LD_ADDR_OWVAR 21
108109: PUSH
108110: LD_INT 2
108112: ST_TO_ADDR
108113: GO 108123
// uc_nation := nation_russian ;
108115: LD_ADDR_OWVAR 21
108119: PUSH
108120: LD_INT 3
108122: ST_TO_ADDR
// vc_chassis := chassis ;
108123: LD_ADDR_OWVAR 37
108127: PUSH
108128: LD_VAR 0 1
108132: ST_TO_ADDR
// vc_engine := engine ;
108133: LD_ADDR_OWVAR 39
108137: PUSH
108138: LD_VAR 0 2
108142: ST_TO_ADDR
// vc_control := control ;
108143: LD_ADDR_OWVAR 38
108147: PUSH
108148: LD_VAR 0 3
108152: ST_TO_ADDR
// vc_weapon := weapon ;
108153: LD_ADDR_OWVAR 40
108157: PUSH
108158: LD_VAR 0 4
108162: ST_TO_ADDR
// un := CreateVehicle ;
108163: LD_ADDR_VAR 0 8
108167: PUSH
108168: CALL_OW 45
108172: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108173: LD_VAR 0 8
108177: PPUSH
108178: LD_INT 0
108180: PPUSH
108181: LD_INT 5
108183: PPUSH
108184: CALL_OW 12
108188: PPUSH
108189: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108193: LD_VAR 0 8
108197: PPUSH
108198: LD_VAR 0 5
108202: PPUSH
108203: LD_VAR 0 6
108207: PPUSH
108208: LD_INT 1
108210: PPUSH
108211: CALL_OW 48
// end ;
108215: LD_VAR 0 7
108219: RET
// export hInvincible ; every 1 do
108220: GO 108222
108222: DISABLE
// hInvincible := [ ] ;
108223: LD_ADDR_EXP 181
108227: PUSH
108228: EMPTY
108229: ST_TO_ADDR
108230: END
// every 10 do var i ;
108231: GO 108233
108233: DISABLE
108234: LD_INT 0
108236: PPUSH
// begin enable ;
108237: ENABLE
// if not hInvincible then
108238: LD_EXP 181
108242: NOT
108243: IFFALSE 108247
// exit ;
108245: GO 108291
// for i in hInvincible do
108247: LD_ADDR_VAR 0 1
108251: PUSH
108252: LD_EXP 181
108256: PUSH
108257: FOR_IN
108258: IFFALSE 108289
// if GetLives ( i ) < 1000 then
108260: LD_VAR 0 1
108264: PPUSH
108265: CALL_OW 256
108269: PUSH
108270: LD_INT 1000
108272: LESS
108273: IFFALSE 108287
// SetLives ( i , 1000 ) ;
108275: LD_VAR 0 1
108279: PPUSH
108280: LD_INT 1000
108282: PPUSH
108283: CALL_OW 234
108287: GO 108257
108289: POP
108290: POP
// end ;
108291: PPOPN 1
108293: END
// export function hHackInvincible ; var i ; begin
108294: LD_INT 0
108296: PPUSH
108297: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108298: LD_ADDR_VAR 0 2
108302: PUSH
108303: LD_INT 2
108305: PUSH
108306: LD_INT 21
108308: PUSH
108309: LD_INT 1
108311: PUSH
108312: EMPTY
108313: LIST
108314: LIST
108315: PUSH
108316: LD_INT 21
108318: PUSH
108319: LD_INT 2
108321: PUSH
108322: EMPTY
108323: LIST
108324: LIST
108325: PUSH
108326: EMPTY
108327: LIST
108328: LIST
108329: LIST
108330: PPUSH
108331: CALL_OW 69
108335: PUSH
108336: FOR_IN
108337: IFFALSE 108398
// if IsSelected ( i ) then
108339: LD_VAR 0 2
108343: PPUSH
108344: CALL_OW 306
108348: IFFALSE 108396
// begin if i in hInvincible then
108350: LD_VAR 0 2
108354: PUSH
108355: LD_EXP 181
108359: IN
108360: IFFALSE 108380
// hInvincible := hInvincible diff i else
108362: LD_ADDR_EXP 181
108366: PUSH
108367: LD_EXP 181
108371: PUSH
108372: LD_VAR 0 2
108376: DIFF
108377: ST_TO_ADDR
108378: GO 108396
// hInvincible := hInvincible union i ;
108380: LD_ADDR_EXP 181
108384: PUSH
108385: LD_EXP 181
108389: PUSH
108390: LD_VAR 0 2
108394: UNION
108395: ST_TO_ADDR
// end ;
108396: GO 108336
108398: POP
108399: POP
// end ;
108400: LD_VAR 0 1
108404: RET
// export function hHackInvisible ; var i , j ; begin
108405: LD_INT 0
108407: PPUSH
108408: PPUSH
108409: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108410: LD_ADDR_VAR 0 2
108414: PUSH
108415: LD_INT 21
108417: PUSH
108418: LD_INT 1
108420: PUSH
108421: EMPTY
108422: LIST
108423: LIST
108424: PPUSH
108425: CALL_OW 69
108429: PUSH
108430: FOR_IN
108431: IFFALSE 108455
// if IsSelected ( i ) then
108433: LD_VAR 0 2
108437: PPUSH
108438: CALL_OW 306
108442: IFFALSE 108453
// ComForceInvisible ( i ) ;
108444: LD_VAR 0 2
108448: PPUSH
108449: CALL_OW 496
108453: GO 108430
108455: POP
108456: POP
// end ;
108457: LD_VAR 0 1
108461: RET
// export function hHackChangeYourSide ; begin
108462: LD_INT 0
108464: PPUSH
// if your_side = 8 then
108465: LD_OWVAR 2
108469: PUSH
108470: LD_INT 8
108472: EQUAL
108473: IFFALSE 108485
// your_side := 0 else
108475: LD_ADDR_OWVAR 2
108479: PUSH
108480: LD_INT 0
108482: ST_TO_ADDR
108483: GO 108499
// your_side := your_side + 1 ;
108485: LD_ADDR_OWVAR 2
108489: PUSH
108490: LD_OWVAR 2
108494: PUSH
108495: LD_INT 1
108497: PLUS
108498: ST_TO_ADDR
// end ;
108499: LD_VAR 0 1
108503: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108504: LD_INT 0
108506: PPUSH
108507: PPUSH
108508: PPUSH
// for i in all_units do
108509: LD_ADDR_VAR 0 2
108513: PUSH
108514: LD_OWVAR 3
108518: PUSH
108519: FOR_IN
108520: IFFALSE 108598
// if IsSelected ( i ) then
108522: LD_VAR 0 2
108526: PPUSH
108527: CALL_OW 306
108531: IFFALSE 108596
// begin j := GetSide ( i ) ;
108533: LD_ADDR_VAR 0 3
108537: PUSH
108538: LD_VAR 0 2
108542: PPUSH
108543: CALL_OW 255
108547: ST_TO_ADDR
// if j = 8 then
108548: LD_VAR 0 3
108552: PUSH
108553: LD_INT 8
108555: EQUAL
108556: IFFALSE 108568
// j := 0 else
108558: LD_ADDR_VAR 0 3
108562: PUSH
108563: LD_INT 0
108565: ST_TO_ADDR
108566: GO 108582
// j := j + 1 ;
108568: LD_ADDR_VAR 0 3
108572: PUSH
108573: LD_VAR 0 3
108577: PUSH
108578: LD_INT 1
108580: PLUS
108581: ST_TO_ADDR
// SetSide ( i , j ) ;
108582: LD_VAR 0 2
108586: PPUSH
108587: LD_VAR 0 3
108591: PPUSH
108592: CALL_OW 235
// end ;
108596: GO 108519
108598: POP
108599: POP
// end ;
108600: LD_VAR 0 1
108604: RET
// export function hHackFog ; begin
108605: LD_INT 0
108607: PPUSH
// FogOff ( true ) ;
108608: LD_INT 1
108610: PPUSH
108611: CALL_OW 344
// end ;
108615: LD_VAR 0 1
108619: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108620: LD_INT 0
108622: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108623: LD_VAR 0 1
108627: PPUSH
108628: LD_VAR 0 2
108632: PPUSH
108633: LD_VAR 0 3
108637: PPUSH
108638: LD_INT 1
108640: PPUSH
108641: LD_INT 1
108643: PPUSH
108644: CALL_OW 483
// CenterOnXY ( x , y ) ;
108648: LD_VAR 0 2
108652: PPUSH
108653: LD_VAR 0 3
108657: PPUSH
108658: CALL_OW 84
// end ;
108662: LD_VAR 0 4
108666: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108667: LD_INT 0
108669: PPUSH
108670: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108671: LD_VAR 0 1
108675: NOT
108676: PUSH
108677: LD_VAR 0 2
108681: PPUSH
108682: LD_VAR 0 3
108686: PPUSH
108687: CALL_OW 488
108691: NOT
108692: OR
108693: PUSH
108694: LD_VAR 0 1
108698: PPUSH
108699: CALL_OW 266
108703: PUSH
108704: LD_INT 3
108706: NONEQUAL
108707: PUSH
108708: LD_VAR 0 1
108712: PPUSH
108713: CALL_OW 247
108717: PUSH
108718: LD_INT 1
108720: EQUAL
108721: NOT
108722: AND
108723: OR
108724: IFFALSE 108728
// exit ;
108726: GO 108877
// if GetType ( factory ) = unit_human then
108728: LD_VAR 0 1
108732: PPUSH
108733: CALL_OW 247
108737: PUSH
108738: LD_INT 1
108740: EQUAL
108741: IFFALSE 108758
// factory := IsInUnit ( factory ) ;
108743: LD_ADDR_VAR 0 1
108747: PUSH
108748: LD_VAR 0 1
108752: PPUSH
108753: CALL_OW 310
108757: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108758: LD_VAR 0 1
108762: PPUSH
108763: CALL_OW 266
108767: PUSH
108768: LD_INT 3
108770: NONEQUAL
108771: IFFALSE 108775
// exit ;
108773: GO 108877
// if HexInfo ( x , y ) = factory then
108775: LD_VAR 0 2
108779: PPUSH
108780: LD_VAR 0 3
108784: PPUSH
108785: CALL_OW 428
108789: PUSH
108790: LD_VAR 0 1
108794: EQUAL
108795: IFFALSE 108822
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108797: LD_ADDR_EXP 182
108801: PUSH
108802: LD_EXP 182
108806: PPUSH
108807: LD_VAR 0 1
108811: PPUSH
108812: LD_INT 0
108814: PPUSH
108815: CALL_OW 1
108819: ST_TO_ADDR
108820: GO 108873
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108822: LD_ADDR_EXP 182
108826: PUSH
108827: LD_EXP 182
108831: PPUSH
108832: LD_VAR 0 1
108836: PPUSH
108837: LD_VAR 0 1
108841: PPUSH
108842: CALL_OW 255
108846: PUSH
108847: LD_VAR 0 1
108851: PUSH
108852: LD_VAR 0 2
108856: PUSH
108857: LD_VAR 0 3
108861: PUSH
108862: EMPTY
108863: LIST
108864: LIST
108865: LIST
108866: LIST
108867: PPUSH
108868: CALL_OW 1
108872: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108873: CALL 108882 0 0
// end ;
108877: LD_VAR 0 4
108881: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108882: LD_INT 0
108884: PPUSH
108885: PPUSH
108886: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108887: LD_STRING resetFactoryWaypoint();
108889: PPUSH
108890: CALL_OW 559
// if factoryWaypoints then
108894: LD_EXP 182
108898: IFFALSE 109024
// begin list := PrepareArray ( factoryWaypoints ) ;
108900: LD_ADDR_VAR 0 3
108904: PUSH
108905: LD_EXP 182
108909: PPUSH
108910: CALL 93862 0 1
108914: ST_TO_ADDR
// for i := 1 to list do
108915: LD_ADDR_VAR 0 2
108919: PUSH
108920: DOUBLE
108921: LD_INT 1
108923: DEC
108924: ST_TO_ADDR
108925: LD_VAR 0 3
108929: PUSH
108930: FOR_TO
108931: IFFALSE 109022
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108933: LD_STRING setFactoryWaypointXY(
108935: PUSH
108936: LD_VAR 0 3
108940: PUSH
108941: LD_VAR 0 2
108945: ARRAY
108946: PUSH
108947: LD_INT 1
108949: ARRAY
108950: STR
108951: PUSH
108952: LD_STRING ,
108954: STR
108955: PUSH
108956: LD_VAR 0 3
108960: PUSH
108961: LD_VAR 0 2
108965: ARRAY
108966: PUSH
108967: LD_INT 2
108969: ARRAY
108970: STR
108971: PUSH
108972: LD_STRING ,
108974: STR
108975: PUSH
108976: LD_VAR 0 3
108980: PUSH
108981: LD_VAR 0 2
108985: ARRAY
108986: PUSH
108987: LD_INT 3
108989: ARRAY
108990: STR
108991: PUSH
108992: LD_STRING ,
108994: STR
108995: PUSH
108996: LD_VAR 0 3
109000: PUSH
109001: LD_VAR 0 2
109005: ARRAY
109006: PUSH
109007: LD_INT 4
109009: ARRAY
109010: STR
109011: PUSH
109012: LD_STRING )
109014: STR
109015: PPUSH
109016: CALL_OW 559
109020: GO 108930
109022: POP
109023: POP
// end ; end ;
109024: LD_VAR 0 1
109028: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109029: LD_INT 0
109031: PPUSH
// if HexInfo ( x , y ) = warehouse then
109032: LD_VAR 0 2
109036: PPUSH
109037: LD_VAR 0 3
109041: PPUSH
109042: CALL_OW 428
109046: PUSH
109047: LD_VAR 0 1
109051: EQUAL
109052: IFFALSE 109079
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109054: LD_ADDR_EXP 183
109058: PUSH
109059: LD_EXP 183
109063: PPUSH
109064: LD_VAR 0 1
109068: PPUSH
109069: LD_INT 0
109071: PPUSH
109072: CALL_OW 1
109076: ST_TO_ADDR
109077: GO 109130
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109079: LD_ADDR_EXP 183
109083: PUSH
109084: LD_EXP 183
109088: PPUSH
109089: LD_VAR 0 1
109093: PPUSH
109094: LD_VAR 0 1
109098: PPUSH
109099: CALL_OW 255
109103: PUSH
109104: LD_VAR 0 1
109108: PUSH
109109: LD_VAR 0 2
109113: PUSH
109114: LD_VAR 0 3
109118: PUSH
109119: EMPTY
109120: LIST
109121: LIST
109122: LIST
109123: LIST
109124: PPUSH
109125: CALL_OW 1
109129: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109130: CALL 109139 0 0
// end ;
109134: LD_VAR 0 4
109138: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109139: LD_INT 0
109141: PPUSH
109142: PPUSH
109143: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109144: LD_STRING resetWarehouseGatheringPoints();
109146: PPUSH
109147: CALL_OW 559
// if warehouseGatheringPoints then
109151: LD_EXP 183
109155: IFFALSE 109281
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109157: LD_ADDR_VAR 0 3
109161: PUSH
109162: LD_EXP 183
109166: PPUSH
109167: CALL 93862 0 1
109171: ST_TO_ADDR
// for i := 1 to list do
109172: LD_ADDR_VAR 0 2
109176: PUSH
109177: DOUBLE
109178: LD_INT 1
109180: DEC
109181: ST_TO_ADDR
109182: LD_VAR 0 3
109186: PUSH
109187: FOR_TO
109188: IFFALSE 109279
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109190: LD_STRING setWarehouseGatheringPointXY(
109192: PUSH
109193: LD_VAR 0 3
109197: PUSH
109198: LD_VAR 0 2
109202: ARRAY
109203: PUSH
109204: LD_INT 1
109206: ARRAY
109207: STR
109208: PUSH
109209: LD_STRING ,
109211: STR
109212: PUSH
109213: LD_VAR 0 3
109217: PUSH
109218: LD_VAR 0 2
109222: ARRAY
109223: PUSH
109224: LD_INT 2
109226: ARRAY
109227: STR
109228: PUSH
109229: LD_STRING ,
109231: STR
109232: PUSH
109233: LD_VAR 0 3
109237: PUSH
109238: LD_VAR 0 2
109242: ARRAY
109243: PUSH
109244: LD_INT 3
109246: ARRAY
109247: STR
109248: PUSH
109249: LD_STRING ,
109251: STR
109252: PUSH
109253: LD_VAR 0 3
109257: PUSH
109258: LD_VAR 0 2
109262: ARRAY
109263: PUSH
109264: LD_INT 4
109266: ARRAY
109267: STR
109268: PUSH
109269: LD_STRING )
109271: STR
109272: PPUSH
109273: CALL_OW 559
109277: GO 109187
109279: POP
109280: POP
// end ; end ;
109281: LD_VAR 0 1
109285: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109286: LD_EXP 183
109290: IFFALSE 109975
109292: GO 109294
109294: DISABLE
109295: LD_INT 0
109297: PPUSH
109298: PPUSH
109299: PPUSH
109300: PPUSH
109301: PPUSH
109302: PPUSH
109303: PPUSH
109304: PPUSH
109305: PPUSH
// begin enable ;
109306: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109307: LD_ADDR_VAR 0 3
109311: PUSH
109312: LD_EXP 183
109316: PPUSH
109317: CALL 93862 0 1
109321: ST_TO_ADDR
// if not list then
109322: LD_VAR 0 3
109326: NOT
109327: IFFALSE 109331
// exit ;
109329: GO 109975
// for i := 1 to list do
109331: LD_ADDR_VAR 0 1
109335: PUSH
109336: DOUBLE
109337: LD_INT 1
109339: DEC
109340: ST_TO_ADDR
109341: LD_VAR 0 3
109345: PUSH
109346: FOR_TO
109347: IFFALSE 109973
// begin depot := list [ i ] [ 2 ] ;
109349: LD_ADDR_VAR 0 8
109353: PUSH
109354: LD_VAR 0 3
109358: PUSH
109359: LD_VAR 0 1
109363: ARRAY
109364: PUSH
109365: LD_INT 2
109367: ARRAY
109368: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109369: LD_ADDR_VAR 0 5
109373: PUSH
109374: LD_VAR 0 3
109378: PUSH
109379: LD_VAR 0 1
109383: ARRAY
109384: PUSH
109385: LD_INT 1
109387: ARRAY
109388: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109389: LD_VAR 0 8
109393: PPUSH
109394: CALL_OW 301
109398: PUSH
109399: LD_VAR 0 5
109403: PUSH
109404: LD_VAR 0 8
109408: PPUSH
109409: CALL_OW 255
109413: NONEQUAL
109414: OR
109415: IFFALSE 109444
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109417: LD_ADDR_EXP 183
109421: PUSH
109422: LD_EXP 183
109426: PPUSH
109427: LD_VAR 0 8
109431: PPUSH
109432: LD_INT 0
109434: PPUSH
109435: CALL_OW 1
109439: ST_TO_ADDR
// exit ;
109440: POP
109441: POP
109442: GO 109975
// end ; x := list [ i ] [ 3 ] ;
109444: LD_ADDR_VAR 0 6
109448: PUSH
109449: LD_VAR 0 3
109453: PUSH
109454: LD_VAR 0 1
109458: ARRAY
109459: PUSH
109460: LD_INT 3
109462: ARRAY
109463: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109464: LD_ADDR_VAR 0 7
109468: PUSH
109469: LD_VAR 0 3
109473: PUSH
109474: LD_VAR 0 1
109478: ARRAY
109479: PUSH
109480: LD_INT 4
109482: ARRAY
109483: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109484: LD_ADDR_VAR 0 9
109488: PUSH
109489: LD_VAR 0 6
109493: PPUSH
109494: LD_VAR 0 7
109498: PPUSH
109499: LD_INT 16
109501: PPUSH
109502: CALL 92450 0 3
109506: ST_TO_ADDR
// if not cratesNearbyPoint then
109507: LD_VAR 0 9
109511: NOT
109512: IFFALSE 109518
// exit ;
109514: POP
109515: POP
109516: GO 109975
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109518: LD_ADDR_VAR 0 4
109522: PUSH
109523: LD_INT 22
109525: PUSH
109526: LD_VAR 0 5
109530: PUSH
109531: EMPTY
109532: LIST
109533: LIST
109534: PUSH
109535: LD_INT 3
109537: PUSH
109538: LD_INT 60
109540: PUSH
109541: EMPTY
109542: LIST
109543: PUSH
109544: EMPTY
109545: LIST
109546: LIST
109547: PUSH
109548: LD_INT 91
109550: PUSH
109551: LD_VAR 0 8
109555: PUSH
109556: LD_INT 6
109558: PUSH
109559: EMPTY
109560: LIST
109561: LIST
109562: LIST
109563: PUSH
109564: LD_INT 2
109566: PUSH
109567: LD_INT 25
109569: PUSH
109570: LD_INT 2
109572: PUSH
109573: EMPTY
109574: LIST
109575: LIST
109576: PUSH
109577: LD_INT 25
109579: PUSH
109580: LD_INT 16
109582: PUSH
109583: EMPTY
109584: LIST
109585: LIST
109586: PUSH
109587: EMPTY
109588: LIST
109589: LIST
109590: LIST
109591: PUSH
109592: EMPTY
109593: LIST
109594: LIST
109595: LIST
109596: LIST
109597: PPUSH
109598: CALL_OW 69
109602: PUSH
109603: LD_VAR 0 8
109607: PPUSH
109608: CALL_OW 313
109612: PPUSH
109613: LD_INT 3
109615: PUSH
109616: LD_INT 60
109618: PUSH
109619: EMPTY
109620: LIST
109621: PUSH
109622: EMPTY
109623: LIST
109624: LIST
109625: PUSH
109626: LD_INT 2
109628: PUSH
109629: LD_INT 25
109631: PUSH
109632: LD_INT 2
109634: PUSH
109635: EMPTY
109636: LIST
109637: LIST
109638: PUSH
109639: LD_INT 25
109641: PUSH
109642: LD_INT 16
109644: PUSH
109645: EMPTY
109646: LIST
109647: LIST
109648: PUSH
109649: EMPTY
109650: LIST
109651: LIST
109652: LIST
109653: PUSH
109654: EMPTY
109655: LIST
109656: LIST
109657: PPUSH
109658: CALL_OW 72
109662: UNION
109663: ST_TO_ADDR
// if tmp then
109664: LD_VAR 0 4
109668: IFFALSE 109748
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109670: LD_ADDR_VAR 0 4
109674: PUSH
109675: LD_VAR 0 4
109679: PPUSH
109680: LD_INT 3
109682: PPUSH
109683: CALL 90419 0 2
109687: ST_TO_ADDR
// for j in tmp do
109688: LD_ADDR_VAR 0 2
109692: PUSH
109693: LD_VAR 0 4
109697: PUSH
109698: FOR_IN
109699: IFFALSE 109742
// begin if IsInUnit ( j ) then
109701: LD_VAR 0 2
109705: PPUSH
109706: CALL_OW 310
109710: IFFALSE 109721
// ComExit ( j ) ;
109712: LD_VAR 0 2
109716: PPUSH
109717: CALL 90502 0 1
// AddComCollect ( j , x , y ) ;
109721: LD_VAR 0 2
109725: PPUSH
109726: LD_VAR 0 6
109730: PPUSH
109731: LD_VAR 0 7
109735: PPUSH
109736: CALL_OW 177
// end ;
109740: GO 109698
109742: POP
109743: POP
// exit ;
109744: POP
109745: POP
109746: GO 109975
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109748: LD_ADDR_VAR 0 4
109752: PUSH
109753: LD_INT 22
109755: PUSH
109756: LD_VAR 0 5
109760: PUSH
109761: EMPTY
109762: LIST
109763: LIST
109764: PUSH
109765: LD_INT 91
109767: PUSH
109768: LD_VAR 0 8
109772: PUSH
109773: LD_INT 8
109775: PUSH
109776: EMPTY
109777: LIST
109778: LIST
109779: LIST
109780: PUSH
109781: LD_INT 2
109783: PUSH
109784: LD_INT 34
109786: PUSH
109787: LD_INT 12
109789: PUSH
109790: EMPTY
109791: LIST
109792: LIST
109793: PUSH
109794: LD_INT 34
109796: PUSH
109797: LD_INT 51
109799: PUSH
109800: EMPTY
109801: LIST
109802: LIST
109803: PUSH
109804: LD_INT 34
109806: PUSH
109807: LD_INT 32
109809: PUSH
109810: EMPTY
109811: LIST
109812: LIST
109813: PUSH
109814: LD_INT 34
109816: PUSH
109817: LD_INT 89
109819: PUSH
109820: EMPTY
109821: LIST
109822: LIST
109823: PUSH
109824: EMPTY
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: PUSH
109831: EMPTY
109832: LIST
109833: LIST
109834: LIST
109835: PPUSH
109836: CALL_OW 69
109840: ST_TO_ADDR
// if tmp then
109841: LD_VAR 0 4
109845: IFFALSE 109971
// begin for j in tmp do
109847: LD_ADDR_VAR 0 2
109851: PUSH
109852: LD_VAR 0 4
109856: PUSH
109857: FOR_IN
109858: IFFALSE 109969
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109860: LD_VAR 0 2
109864: PPUSH
109865: CALL_OW 262
109869: PUSH
109870: LD_INT 3
109872: EQUAL
109873: PUSH
109874: LD_VAR 0 2
109878: PPUSH
109879: CALL_OW 261
109883: PUSH
109884: LD_INT 20
109886: GREATER
109887: OR
109888: PUSH
109889: LD_VAR 0 2
109893: PPUSH
109894: CALL_OW 314
109898: NOT
109899: AND
109900: PUSH
109901: LD_VAR 0 2
109905: PPUSH
109906: CALL_OW 263
109910: PUSH
109911: LD_INT 1
109913: NONEQUAL
109914: PUSH
109915: LD_VAR 0 2
109919: PPUSH
109920: CALL_OW 311
109924: OR
109925: AND
109926: IFFALSE 109967
// begin ComCollect ( j , x , y ) ;
109928: LD_VAR 0 2
109932: PPUSH
109933: LD_VAR 0 6
109937: PPUSH
109938: LD_VAR 0 7
109942: PPUSH
109943: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109947: LD_VAR 0 2
109951: PPUSH
109952: LD_VAR 0 8
109956: PPUSH
109957: CALL_OW 172
// exit ;
109961: POP
109962: POP
109963: POP
109964: POP
109965: GO 109975
// end ;
109967: GO 109857
109969: POP
109970: POP
// end ; end ;
109971: GO 109346
109973: POP
109974: POP
// end ; end_of_file
109975: PPOPN 9
109977: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
109978: LD_INT 0
109980: PPUSH
109981: PPUSH
109982: PPUSH
109983: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
109984: LD_VAR 0 1
109988: PPUSH
109989: CALL_OW 264
109993: PUSH
109994: LD_INT 91
109996: EQUAL
109997: IFFALSE 110069
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109999: LD_INT 68
110001: PPUSH
110002: LD_VAR 0 1
110006: PPUSH
110007: CALL_OW 255
110011: PPUSH
110012: CALL_OW 321
110016: PUSH
110017: LD_INT 2
110019: EQUAL
110020: IFFALSE 110032
// eff := 70 else
110022: LD_ADDR_VAR 0 4
110026: PUSH
110027: LD_INT 70
110029: ST_TO_ADDR
110030: GO 110040
// eff := 30 ;
110032: LD_ADDR_VAR 0 4
110036: PUSH
110037: LD_INT 30
110039: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110040: LD_VAR 0 1
110044: PPUSH
110045: CALL_OW 250
110049: PPUSH
110050: LD_VAR 0 1
110054: PPUSH
110055: CALL_OW 251
110059: PPUSH
110060: LD_VAR 0 4
110064: PPUSH
110065: CALL_OW 495
// end ; end ;
110069: LD_VAR 0 2
110073: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110074: LD_INT 0
110076: PPUSH
// end ;
110077: LD_VAR 0 4
110081: RET
// export function SOS_Command ( cmd ) ; begin
110082: LD_INT 0
110084: PPUSH
// end ;
110085: LD_VAR 0 2
110089: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110090: LD_INT 0
110092: PPUSH
// end ;
110093: LD_VAR 0 6
110097: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
110098: LD_INT 0
110100: PPUSH
110101: PPUSH
// if not vehicle or not factory then
110102: LD_VAR 0 1
110106: NOT
110107: PUSH
110108: LD_VAR 0 2
110112: NOT
110113: OR
110114: IFFALSE 110118
// exit ;
110116: GO 110349
// if factoryWaypoints >= factory then
110118: LD_EXP 182
110122: PUSH
110123: LD_VAR 0 2
110127: GREATEREQUAL
110128: IFFALSE 110349
// if factoryWaypoints [ factory ] then
110130: LD_EXP 182
110134: PUSH
110135: LD_VAR 0 2
110139: ARRAY
110140: IFFALSE 110349
// begin if GetControl ( vehicle ) = control_manual then
110142: LD_VAR 0 1
110146: PPUSH
110147: CALL_OW 263
110151: PUSH
110152: LD_INT 1
110154: EQUAL
110155: IFFALSE 110236
// begin driver := IsDrivenBy ( vehicle ) ;
110157: LD_ADDR_VAR 0 4
110161: PUSH
110162: LD_VAR 0 1
110166: PPUSH
110167: CALL_OW 311
110171: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110172: LD_VAR 0 4
110176: PPUSH
110177: LD_EXP 182
110181: PUSH
110182: LD_VAR 0 2
110186: ARRAY
110187: PUSH
110188: LD_INT 3
110190: ARRAY
110191: PPUSH
110192: LD_EXP 182
110196: PUSH
110197: LD_VAR 0 2
110201: ARRAY
110202: PUSH
110203: LD_INT 4
110205: ARRAY
110206: PPUSH
110207: CALL_OW 171
// AddComExitVehicle ( driver ) ;
110211: LD_VAR 0 4
110215: PPUSH
110216: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
110220: LD_VAR 0 4
110224: PPUSH
110225: LD_VAR 0 2
110229: PPUSH
110230: CALL_OW 180
// end else
110234: GO 110349
// if GetControl ( vehicle ) = control_remote then
110236: LD_VAR 0 1
110240: PPUSH
110241: CALL_OW 263
110245: PUSH
110246: LD_INT 2
110248: EQUAL
110249: IFFALSE 110310
// begin wait ( 0 0$2 ) ;
110251: LD_INT 70
110253: PPUSH
110254: CALL_OW 67
// if Connect ( vehicle ) then
110258: LD_VAR 0 1
110262: PPUSH
110263: CALL 60743 0 1
110267: IFFALSE 110308
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110269: LD_VAR 0 1
110273: PPUSH
110274: LD_EXP 182
110278: PUSH
110279: LD_VAR 0 2
110283: ARRAY
110284: PUSH
110285: LD_INT 3
110287: ARRAY
110288: PPUSH
110289: LD_EXP 182
110293: PUSH
110294: LD_VAR 0 2
110298: ARRAY
110299: PUSH
110300: LD_INT 4
110302: ARRAY
110303: PPUSH
110304: CALL_OW 171
// end else
110308: GO 110349
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110310: LD_VAR 0 1
110314: PPUSH
110315: LD_EXP 182
110319: PUSH
110320: LD_VAR 0 2
110324: ARRAY
110325: PUSH
110326: LD_INT 3
110328: ARRAY
110329: PPUSH
110330: LD_EXP 182
110334: PUSH
110335: LD_VAR 0 2
110339: ARRAY
110340: PUSH
110341: LD_INT 4
110343: ARRAY
110344: PPUSH
110345: CALL_OW 171
// end ; end ;
110349: LD_VAR 0 3
110353: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
110354: LD_INT 0
110356: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
110357: LD_VAR 0 1
110361: PUSH
110362: LD_INT 250
110364: EQUAL
110365: PUSH
110366: LD_VAR 0 2
110370: PPUSH
110371: CALL_OW 264
110375: PUSH
110376: LD_INT 81
110378: EQUAL
110379: AND
110380: IFFALSE 110401
// MinerPlaceMine ( unit , x , y ) ;
110382: LD_VAR 0 2
110386: PPUSH
110387: LD_VAR 0 4
110391: PPUSH
110392: LD_VAR 0 5
110396: PPUSH
110397: CALL 112786 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
110401: LD_VAR 0 1
110405: PUSH
110406: LD_INT 251
110408: EQUAL
110409: PUSH
110410: LD_VAR 0 2
110414: PPUSH
110415: CALL_OW 264
110419: PUSH
110420: LD_INT 81
110422: EQUAL
110423: AND
110424: IFFALSE 110445
// MinerDetonateMine ( unit , x , y ) ;
110426: LD_VAR 0 2
110430: PPUSH
110431: LD_VAR 0 4
110435: PPUSH
110436: LD_VAR 0 5
110440: PPUSH
110441: CALL 113061 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
110445: LD_VAR 0 1
110449: PUSH
110450: LD_INT 252
110452: EQUAL
110453: PUSH
110454: LD_VAR 0 2
110458: PPUSH
110459: CALL_OW 264
110463: PUSH
110464: LD_INT 81
110466: EQUAL
110467: AND
110468: IFFALSE 110489
// MinerCreateMinefield ( unit , x , y ) ;
110470: LD_VAR 0 2
110474: PPUSH
110475: LD_VAR 0 4
110479: PPUSH
110480: LD_VAR 0 5
110484: PPUSH
110485: CALL 113478 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
110489: LD_VAR 0 1
110493: PUSH
110494: LD_INT 253
110496: EQUAL
110497: PUSH
110498: LD_VAR 0 2
110502: PPUSH
110503: CALL_OW 257
110507: PUSH
110508: LD_INT 5
110510: EQUAL
110511: AND
110512: IFFALSE 110533
// ComBinocular ( unit , x , y ) ;
110514: LD_VAR 0 2
110518: PPUSH
110519: LD_VAR 0 4
110523: PPUSH
110524: LD_VAR 0 5
110528: PPUSH
110529: CALL 113847 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
110533: LD_VAR 0 1
110537: PUSH
110538: LD_INT 254
110540: EQUAL
110541: PUSH
110542: LD_VAR 0 2
110546: PPUSH
110547: CALL_OW 264
110551: PUSH
110552: LD_INT 99
110554: EQUAL
110555: AND
110556: PUSH
110557: LD_VAR 0 3
110561: PPUSH
110562: CALL_OW 263
110566: PUSH
110567: LD_INT 3
110569: EQUAL
110570: AND
110571: IFFALSE 110587
// HackDestroyVehicle ( unit , selectedUnit ) ;
110573: LD_VAR 0 2
110577: PPUSH
110578: LD_VAR 0 3
110582: PPUSH
110583: CALL 112150 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
110587: LD_VAR 0 1
110591: PUSH
110592: LD_INT 255
110594: EQUAL
110595: PUSH
110596: LD_VAR 0 2
110600: PPUSH
110601: CALL_OW 264
110605: PUSH
110606: LD_INT 14
110608: PUSH
110609: LD_INT 53
110611: PUSH
110612: EMPTY
110613: LIST
110614: LIST
110615: IN
110616: AND
110617: PUSH
110618: LD_VAR 0 4
110622: PPUSH
110623: LD_VAR 0 5
110627: PPUSH
110628: CALL_OW 488
110632: AND
110633: IFFALSE 110657
// CutTreeXYR ( unit , x , y , 12 ) ;
110635: LD_VAR 0 2
110639: PPUSH
110640: LD_VAR 0 4
110644: PPUSH
110645: LD_VAR 0 5
110649: PPUSH
110650: LD_INT 12
110652: PPUSH
110653: CALL 110720 0 4
// if cmd = 256 then
110657: LD_VAR 0 1
110661: PUSH
110662: LD_INT 256
110664: EQUAL
110665: IFFALSE 110686
// SetFactoryWaypoint ( unit , x , y ) ;
110667: LD_VAR 0 2
110671: PPUSH
110672: LD_VAR 0 4
110676: PPUSH
110677: LD_VAR 0 5
110681: PPUSH
110682: CALL 108667 0 3
// if cmd = 257 then
110686: LD_VAR 0 1
110690: PUSH
110691: LD_INT 257
110693: EQUAL
110694: IFFALSE 110715
// SetWarehouseGatheringPoint ( unit , x , y ) ;
110696: LD_VAR 0 2
110700: PPUSH
110701: LD_VAR 0 4
110705: PPUSH
110706: LD_VAR 0 5
110710: PPUSH
110711: CALL 109029 0 3
// end ;
110715: LD_VAR 0 6
110719: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110720: LD_INT 0
110722: PPUSH
110723: PPUSH
110724: PPUSH
110725: PPUSH
110726: PPUSH
110727: PPUSH
110728: PPUSH
110729: PPUSH
110730: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
110731: LD_VAR 0 1
110735: NOT
110736: PUSH
110737: LD_VAR 0 2
110741: PPUSH
110742: LD_VAR 0 3
110746: PPUSH
110747: CALL_OW 488
110751: NOT
110752: OR
110753: PUSH
110754: LD_VAR 0 4
110758: NOT
110759: OR
110760: IFFALSE 110764
// exit ;
110762: GO 111104
// list := [ ] ;
110764: LD_ADDR_VAR 0 13
110768: PUSH
110769: EMPTY
110770: ST_TO_ADDR
// if x - r < 0 then
110771: LD_VAR 0 2
110775: PUSH
110776: LD_VAR 0 4
110780: MINUS
110781: PUSH
110782: LD_INT 0
110784: LESS
110785: IFFALSE 110797
// min_x := 0 else
110787: LD_ADDR_VAR 0 7
110791: PUSH
110792: LD_INT 0
110794: ST_TO_ADDR
110795: GO 110813
// min_x := x - r ;
110797: LD_ADDR_VAR 0 7
110801: PUSH
110802: LD_VAR 0 2
110806: PUSH
110807: LD_VAR 0 4
110811: MINUS
110812: ST_TO_ADDR
// if y - r < 0 then
110813: LD_VAR 0 3
110817: PUSH
110818: LD_VAR 0 4
110822: MINUS
110823: PUSH
110824: LD_INT 0
110826: LESS
110827: IFFALSE 110839
// min_y := 0 else
110829: LD_ADDR_VAR 0 8
110833: PUSH
110834: LD_INT 0
110836: ST_TO_ADDR
110837: GO 110855
// min_y := y - r ;
110839: LD_ADDR_VAR 0 8
110843: PUSH
110844: LD_VAR 0 3
110848: PUSH
110849: LD_VAR 0 4
110853: MINUS
110854: ST_TO_ADDR
// max_x := x + r ;
110855: LD_ADDR_VAR 0 9
110859: PUSH
110860: LD_VAR 0 2
110864: PUSH
110865: LD_VAR 0 4
110869: PLUS
110870: ST_TO_ADDR
// max_y := y + r ;
110871: LD_ADDR_VAR 0 10
110875: PUSH
110876: LD_VAR 0 3
110880: PUSH
110881: LD_VAR 0 4
110885: PLUS
110886: ST_TO_ADDR
// for _x = min_x to max_x do
110887: LD_ADDR_VAR 0 11
110891: PUSH
110892: DOUBLE
110893: LD_VAR 0 7
110897: DEC
110898: ST_TO_ADDR
110899: LD_VAR 0 9
110903: PUSH
110904: FOR_TO
110905: IFFALSE 111022
// for _y = min_y to max_y do
110907: LD_ADDR_VAR 0 12
110911: PUSH
110912: DOUBLE
110913: LD_VAR 0 8
110917: DEC
110918: ST_TO_ADDR
110919: LD_VAR 0 10
110923: PUSH
110924: FOR_TO
110925: IFFALSE 111018
// begin if not ValidHex ( _x , _y ) then
110927: LD_VAR 0 11
110931: PPUSH
110932: LD_VAR 0 12
110936: PPUSH
110937: CALL_OW 488
110941: NOT
110942: IFFALSE 110946
// continue ;
110944: GO 110924
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110946: LD_VAR 0 11
110950: PPUSH
110951: LD_VAR 0 12
110955: PPUSH
110956: CALL_OW 351
110960: PUSH
110961: LD_VAR 0 11
110965: PPUSH
110966: LD_VAR 0 12
110970: PPUSH
110971: CALL_OW 554
110975: AND
110976: IFFALSE 111016
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110978: LD_ADDR_VAR 0 13
110982: PUSH
110983: LD_VAR 0 13
110987: PPUSH
110988: LD_VAR 0 13
110992: PUSH
110993: LD_INT 1
110995: PLUS
110996: PPUSH
110997: LD_VAR 0 11
111001: PUSH
111002: LD_VAR 0 12
111006: PUSH
111007: EMPTY
111008: LIST
111009: LIST
111010: PPUSH
111011: CALL_OW 2
111015: ST_TO_ADDR
// end ;
111016: GO 110924
111018: POP
111019: POP
111020: GO 110904
111022: POP
111023: POP
// if not list then
111024: LD_VAR 0 13
111028: NOT
111029: IFFALSE 111033
// exit ;
111031: GO 111104
// for i in list do
111033: LD_ADDR_VAR 0 6
111037: PUSH
111038: LD_VAR 0 13
111042: PUSH
111043: FOR_IN
111044: IFFALSE 111102
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
111046: LD_VAR 0 1
111050: PPUSH
111051: LD_STRING M
111053: PUSH
111054: LD_VAR 0 6
111058: PUSH
111059: LD_INT 1
111061: ARRAY
111062: PUSH
111063: LD_VAR 0 6
111067: PUSH
111068: LD_INT 2
111070: ARRAY
111071: PUSH
111072: LD_INT 0
111074: PUSH
111075: LD_INT 0
111077: PUSH
111078: LD_INT 0
111080: PUSH
111081: LD_INT 0
111083: PUSH
111084: EMPTY
111085: LIST
111086: LIST
111087: LIST
111088: LIST
111089: LIST
111090: LIST
111091: LIST
111092: PUSH
111093: EMPTY
111094: LIST
111095: PPUSH
111096: CALL_OW 447
111100: GO 111043
111102: POP
111103: POP
// end ;
111104: LD_VAR 0 5
111108: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
111109: LD_EXP 185
111113: NOT
111114: IFFALSE 111164
111116: GO 111118
111118: DISABLE
// begin initHack := true ;
111119: LD_ADDR_EXP 185
111123: PUSH
111124: LD_INT 1
111126: ST_TO_ADDR
// hackTanks := [ ] ;
111127: LD_ADDR_EXP 186
111131: PUSH
111132: EMPTY
111133: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
111134: LD_ADDR_EXP 187
111138: PUSH
111139: EMPTY
111140: ST_TO_ADDR
// hackLimit := 3 ;
111141: LD_ADDR_EXP 188
111145: PUSH
111146: LD_INT 3
111148: ST_TO_ADDR
// hackDist := 12 ;
111149: LD_ADDR_EXP 189
111153: PUSH
111154: LD_INT 12
111156: ST_TO_ADDR
// hackCounter := [ ] ;
111157: LD_ADDR_EXP 190
111161: PUSH
111162: EMPTY
111163: ST_TO_ADDR
// end ;
111164: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
111165: LD_EXP 185
111169: PUSH
111170: LD_INT 34
111172: PUSH
111173: LD_INT 99
111175: PUSH
111176: EMPTY
111177: LIST
111178: LIST
111179: PPUSH
111180: CALL_OW 69
111184: AND
111185: IFFALSE 111438
111187: GO 111189
111189: DISABLE
111190: LD_INT 0
111192: PPUSH
111193: PPUSH
// begin enable ;
111194: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
111195: LD_ADDR_VAR 0 1
111199: PUSH
111200: LD_INT 34
111202: PUSH
111203: LD_INT 99
111205: PUSH
111206: EMPTY
111207: LIST
111208: LIST
111209: PPUSH
111210: CALL_OW 69
111214: PUSH
111215: FOR_IN
111216: IFFALSE 111436
// begin if not i in hackTanks then
111218: LD_VAR 0 1
111222: PUSH
111223: LD_EXP 186
111227: IN
111228: NOT
111229: IFFALSE 111312
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
111231: LD_ADDR_EXP 186
111235: PUSH
111236: LD_EXP 186
111240: PPUSH
111241: LD_EXP 186
111245: PUSH
111246: LD_INT 1
111248: PLUS
111249: PPUSH
111250: LD_VAR 0 1
111254: PPUSH
111255: CALL_OW 1
111259: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
111260: LD_ADDR_EXP 187
111264: PUSH
111265: LD_EXP 187
111269: PPUSH
111270: LD_EXP 187
111274: PUSH
111275: LD_INT 1
111277: PLUS
111278: PPUSH
111279: EMPTY
111280: PPUSH
111281: CALL_OW 1
111285: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
111286: LD_ADDR_EXP 190
111290: PUSH
111291: LD_EXP 190
111295: PPUSH
111296: LD_EXP 190
111300: PUSH
111301: LD_INT 1
111303: PLUS
111304: PPUSH
111305: EMPTY
111306: PPUSH
111307: CALL_OW 1
111311: ST_TO_ADDR
// end ; if not IsOk ( i ) then
111312: LD_VAR 0 1
111316: PPUSH
111317: CALL_OW 302
111321: NOT
111322: IFFALSE 111335
// begin HackUnlinkAll ( i ) ;
111324: LD_VAR 0 1
111328: PPUSH
111329: CALL 111441 0 1
// continue ;
111333: GO 111215
// end ; HackCheckCapturedStatus ( i ) ;
111335: LD_VAR 0 1
111339: PPUSH
111340: CALL 111884 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
111344: LD_ADDR_VAR 0 2
111348: PUSH
111349: LD_INT 81
111351: PUSH
111352: LD_VAR 0 1
111356: PPUSH
111357: CALL_OW 255
111361: PUSH
111362: EMPTY
111363: LIST
111364: LIST
111365: PUSH
111366: LD_INT 33
111368: PUSH
111369: LD_INT 3
111371: PUSH
111372: EMPTY
111373: LIST
111374: LIST
111375: PUSH
111376: LD_INT 91
111378: PUSH
111379: LD_VAR 0 1
111383: PUSH
111384: LD_EXP 189
111388: PUSH
111389: EMPTY
111390: LIST
111391: LIST
111392: LIST
111393: PUSH
111394: LD_INT 50
111396: PUSH
111397: EMPTY
111398: LIST
111399: PUSH
111400: EMPTY
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: PPUSH
111406: CALL_OW 69
111410: ST_TO_ADDR
// if not tmp then
111411: LD_VAR 0 2
111415: NOT
111416: IFFALSE 111420
// continue ;
111418: GO 111215
// HackLink ( i , tmp ) ;
111420: LD_VAR 0 1
111424: PPUSH
111425: LD_VAR 0 2
111429: PPUSH
111430: CALL 111577 0 2
// end ;
111434: GO 111215
111436: POP
111437: POP
// end ;
111438: PPOPN 2
111440: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
111441: LD_INT 0
111443: PPUSH
111444: PPUSH
111445: PPUSH
// if not hack in hackTanks then
111446: LD_VAR 0 1
111450: PUSH
111451: LD_EXP 186
111455: IN
111456: NOT
111457: IFFALSE 111461
// exit ;
111459: GO 111572
// index := GetElementIndex ( hackTanks , hack ) ;
111461: LD_ADDR_VAR 0 4
111465: PUSH
111466: LD_EXP 186
111470: PPUSH
111471: LD_VAR 0 1
111475: PPUSH
111476: CALL 57559 0 2
111480: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
111481: LD_EXP 187
111485: PUSH
111486: LD_VAR 0 4
111490: ARRAY
111491: IFFALSE 111572
// begin for i in hackTanksCaptured [ index ] do
111493: LD_ADDR_VAR 0 3
111497: PUSH
111498: LD_EXP 187
111502: PUSH
111503: LD_VAR 0 4
111507: ARRAY
111508: PUSH
111509: FOR_IN
111510: IFFALSE 111536
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
111512: LD_VAR 0 3
111516: PUSH
111517: LD_INT 1
111519: ARRAY
111520: PPUSH
111521: LD_VAR 0 3
111525: PUSH
111526: LD_INT 2
111528: ARRAY
111529: PPUSH
111530: CALL_OW 235
111534: GO 111509
111536: POP
111537: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
111538: LD_ADDR_EXP 187
111542: PUSH
111543: LD_EXP 187
111547: PPUSH
111548: LD_VAR 0 4
111552: PPUSH
111553: EMPTY
111554: PPUSH
111555: CALL_OW 1
111559: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
111560: LD_VAR 0 1
111564: PPUSH
111565: LD_INT 0
111567: PPUSH
111568: CALL_OW 505
// end ; end ;
111572: LD_VAR 0 2
111576: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
111577: LD_INT 0
111579: PPUSH
111580: PPUSH
111581: PPUSH
// if not hack in hackTanks or not vehicles then
111582: LD_VAR 0 1
111586: PUSH
111587: LD_EXP 186
111591: IN
111592: NOT
111593: PUSH
111594: LD_VAR 0 2
111598: NOT
111599: OR
111600: IFFALSE 111604
// exit ;
111602: GO 111879
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
111604: LD_ADDR_VAR 0 2
111608: PUSH
111609: LD_VAR 0 1
111613: PPUSH
111614: LD_VAR 0 2
111618: PPUSH
111619: LD_INT 1
111621: PPUSH
111622: LD_INT 1
111624: PPUSH
111625: CALL 58209 0 4
111629: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
111630: LD_ADDR_VAR 0 5
111634: PUSH
111635: LD_EXP 186
111639: PPUSH
111640: LD_VAR 0 1
111644: PPUSH
111645: CALL 57559 0 2
111649: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
111650: LD_EXP 187
111654: PUSH
111655: LD_VAR 0 5
111659: ARRAY
111660: PUSH
111661: LD_EXP 188
111665: LESS
111666: IFFALSE 111855
// begin for i := 1 to vehicles do
111668: LD_ADDR_VAR 0 4
111672: PUSH
111673: DOUBLE
111674: LD_INT 1
111676: DEC
111677: ST_TO_ADDR
111678: LD_VAR 0 2
111682: PUSH
111683: FOR_TO
111684: IFFALSE 111853
// begin if hackTanksCaptured [ index ] = hackLimit then
111686: LD_EXP 187
111690: PUSH
111691: LD_VAR 0 5
111695: ARRAY
111696: PUSH
111697: LD_EXP 188
111701: EQUAL
111702: IFFALSE 111706
// break ;
111704: GO 111853
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111706: LD_ADDR_EXP 190
111710: PUSH
111711: LD_EXP 190
111715: PPUSH
111716: LD_VAR 0 5
111720: PPUSH
111721: LD_EXP 190
111725: PUSH
111726: LD_VAR 0 5
111730: ARRAY
111731: PUSH
111732: LD_INT 1
111734: PLUS
111735: PPUSH
111736: CALL_OW 1
111740: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111741: LD_ADDR_EXP 187
111745: PUSH
111746: LD_EXP 187
111750: PPUSH
111751: LD_VAR 0 5
111755: PUSH
111756: LD_EXP 187
111760: PUSH
111761: LD_VAR 0 5
111765: ARRAY
111766: PUSH
111767: LD_INT 1
111769: PLUS
111770: PUSH
111771: EMPTY
111772: LIST
111773: LIST
111774: PPUSH
111775: LD_VAR 0 2
111779: PUSH
111780: LD_VAR 0 4
111784: ARRAY
111785: PUSH
111786: LD_VAR 0 2
111790: PUSH
111791: LD_VAR 0 4
111795: ARRAY
111796: PPUSH
111797: CALL_OW 255
111801: PUSH
111802: EMPTY
111803: LIST
111804: LIST
111805: PPUSH
111806: CALL 57774 0 3
111810: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111811: LD_VAR 0 2
111815: PUSH
111816: LD_VAR 0 4
111820: ARRAY
111821: PPUSH
111822: LD_VAR 0 1
111826: PPUSH
111827: CALL_OW 255
111831: PPUSH
111832: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111836: LD_VAR 0 2
111840: PUSH
111841: LD_VAR 0 4
111845: ARRAY
111846: PPUSH
111847: CALL_OW 141
// end ;
111851: GO 111683
111853: POP
111854: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111855: LD_VAR 0 1
111859: PPUSH
111860: LD_EXP 187
111864: PUSH
111865: LD_VAR 0 5
111869: ARRAY
111870: PUSH
111871: LD_INT 0
111873: PLUS
111874: PPUSH
111875: CALL_OW 505
// end ;
111879: LD_VAR 0 3
111883: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111884: LD_INT 0
111886: PPUSH
111887: PPUSH
111888: PPUSH
111889: PPUSH
// if not hack in hackTanks then
111890: LD_VAR 0 1
111894: PUSH
111895: LD_EXP 186
111899: IN
111900: NOT
111901: IFFALSE 111905
// exit ;
111903: GO 112145
// index := GetElementIndex ( hackTanks , hack ) ;
111905: LD_ADDR_VAR 0 4
111909: PUSH
111910: LD_EXP 186
111914: PPUSH
111915: LD_VAR 0 1
111919: PPUSH
111920: CALL 57559 0 2
111924: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111925: LD_ADDR_VAR 0 3
111929: PUSH
111930: DOUBLE
111931: LD_EXP 187
111935: PUSH
111936: LD_VAR 0 4
111940: ARRAY
111941: INC
111942: ST_TO_ADDR
111943: LD_INT 1
111945: PUSH
111946: FOR_DOWNTO
111947: IFFALSE 112119
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111949: LD_ADDR_VAR 0 5
111953: PUSH
111954: LD_EXP 187
111958: PUSH
111959: LD_VAR 0 4
111963: ARRAY
111964: PUSH
111965: LD_VAR 0 3
111969: ARRAY
111970: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111971: LD_VAR 0 5
111975: PUSH
111976: LD_INT 1
111978: ARRAY
111979: PPUSH
111980: CALL_OW 302
111984: NOT
111985: PUSH
111986: LD_VAR 0 5
111990: PUSH
111991: LD_INT 1
111993: ARRAY
111994: PPUSH
111995: CALL_OW 255
111999: PUSH
112000: LD_VAR 0 1
112004: PPUSH
112005: CALL_OW 255
112009: NONEQUAL
112010: OR
112011: IFFALSE 112117
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
112013: LD_VAR 0 5
112017: PUSH
112018: LD_INT 1
112020: ARRAY
112021: PPUSH
112022: CALL_OW 305
112026: PUSH
112027: LD_VAR 0 5
112031: PUSH
112032: LD_INT 1
112034: ARRAY
112035: PPUSH
112036: CALL_OW 255
112040: PUSH
112041: LD_VAR 0 1
112045: PPUSH
112046: CALL_OW 255
112050: EQUAL
112051: AND
112052: IFFALSE 112076
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
112054: LD_VAR 0 5
112058: PUSH
112059: LD_INT 1
112061: ARRAY
112062: PPUSH
112063: LD_VAR 0 5
112067: PUSH
112068: LD_INT 2
112070: ARRAY
112071: PPUSH
112072: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
112076: LD_ADDR_EXP 187
112080: PUSH
112081: LD_EXP 187
112085: PPUSH
112086: LD_VAR 0 4
112090: PPUSH
112091: LD_EXP 187
112095: PUSH
112096: LD_VAR 0 4
112100: ARRAY
112101: PPUSH
112102: LD_VAR 0 3
112106: PPUSH
112107: CALL_OW 3
112111: PPUSH
112112: CALL_OW 1
112116: ST_TO_ADDR
// end ; end ;
112117: GO 111946
112119: POP
112120: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112121: LD_VAR 0 1
112125: PPUSH
112126: LD_EXP 187
112130: PUSH
112131: LD_VAR 0 4
112135: ARRAY
112136: PUSH
112137: LD_INT 0
112139: PLUS
112140: PPUSH
112141: CALL_OW 505
// end ;
112145: LD_VAR 0 2
112149: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
112150: LD_INT 0
112152: PPUSH
112153: PPUSH
112154: PPUSH
112155: PPUSH
// if not hack in hackTanks then
112156: LD_VAR 0 1
112160: PUSH
112161: LD_EXP 186
112165: IN
112166: NOT
112167: IFFALSE 112171
// exit ;
112169: GO 112256
// index := GetElementIndex ( hackTanks , hack ) ;
112171: LD_ADDR_VAR 0 5
112175: PUSH
112176: LD_EXP 186
112180: PPUSH
112181: LD_VAR 0 1
112185: PPUSH
112186: CALL 57559 0 2
112190: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
112191: LD_ADDR_VAR 0 4
112195: PUSH
112196: DOUBLE
112197: LD_INT 1
112199: DEC
112200: ST_TO_ADDR
112201: LD_EXP 187
112205: PUSH
112206: LD_VAR 0 5
112210: ARRAY
112211: PUSH
112212: FOR_TO
112213: IFFALSE 112254
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
112215: LD_EXP 187
112219: PUSH
112220: LD_VAR 0 5
112224: ARRAY
112225: PUSH
112226: LD_VAR 0 4
112230: ARRAY
112231: PUSH
112232: LD_INT 1
112234: ARRAY
112235: PUSH
112236: LD_VAR 0 2
112240: EQUAL
112241: IFFALSE 112252
// KillUnit ( vehicle ) ;
112243: LD_VAR 0 2
112247: PPUSH
112248: CALL_OW 66
112252: GO 112212
112254: POP
112255: POP
// end ;
112256: LD_VAR 0 3
112260: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
112261: LD_EXP 191
112265: NOT
112266: IFFALSE 112301
112268: GO 112270
112270: DISABLE
// begin initMiner := true ;
112271: LD_ADDR_EXP 191
112275: PUSH
112276: LD_INT 1
112278: ST_TO_ADDR
// minersList := [ ] ;
112279: LD_ADDR_EXP 192
112283: PUSH
112284: EMPTY
112285: ST_TO_ADDR
// minerMinesList := [ ] ;
112286: LD_ADDR_EXP 193
112290: PUSH
112291: EMPTY
112292: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
112293: LD_ADDR_EXP 194
112297: PUSH
112298: LD_INT 5
112300: ST_TO_ADDR
// end ;
112301: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
112302: LD_EXP 191
112306: PUSH
112307: LD_INT 34
112309: PUSH
112310: LD_INT 81
112312: PUSH
112313: EMPTY
112314: LIST
112315: LIST
112316: PPUSH
112317: CALL_OW 69
112321: AND
112322: IFFALSE 112783
112324: GO 112326
112326: DISABLE
112327: LD_INT 0
112329: PPUSH
112330: PPUSH
112331: PPUSH
112332: PPUSH
// begin enable ;
112333: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
112334: LD_ADDR_VAR 0 1
112338: PUSH
112339: LD_INT 34
112341: PUSH
112342: LD_INT 81
112344: PUSH
112345: EMPTY
112346: LIST
112347: LIST
112348: PPUSH
112349: CALL_OW 69
112353: PUSH
112354: FOR_IN
112355: IFFALSE 112427
// begin if not i in minersList then
112357: LD_VAR 0 1
112361: PUSH
112362: LD_EXP 192
112366: IN
112367: NOT
112368: IFFALSE 112425
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
112370: LD_ADDR_EXP 192
112374: PUSH
112375: LD_EXP 192
112379: PPUSH
112380: LD_EXP 192
112384: PUSH
112385: LD_INT 1
112387: PLUS
112388: PPUSH
112389: LD_VAR 0 1
112393: PPUSH
112394: CALL_OW 1
112398: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
112399: LD_ADDR_EXP 193
112403: PUSH
112404: LD_EXP 193
112408: PPUSH
112409: LD_EXP 193
112413: PUSH
112414: LD_INT 1
112416: PLUS
112417: PPUSH
112418: EMPTY
112419: PPUSH
112420: CALL_OW 1
112424: ST_TO_ADDR
// end end ;
112425: GO 112354
112427: POP
112428: POP
// for i := minerMinesList downto 1 do
112429: LD_ADDR_VAR 0 1
112433: PUSH
112434: DOUBLE
112435: LD_EXP 193
112439: INC
112440: ST_TO_ADDR
112441: LD_INT 1
112443: PUSH
112444: FOR_DOWNTO
112445: IFFALSE 112781
// begin if IsLive ( minersList [ i ] ) then
112447: LD_EXP 192
112451: PUSH
112452: LD_VAR 0 1
112456: ARRAY
112457: PPUSH
112458: CALL_OW 300
112462: IFFALSE 112490
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
112464: LD_EXP 192
112468: PUSH
112469: LD_VAR 0 1
112473: ARRAY
112474: PPUSH
112475: LD_EXP 193
112479: PUSH
112480: LD_VAR 0 1
112484: ARRAY
112485: PPUSH
112486: CALL_OW 505
// if not minerMinesList [ i ] then
112490: LD_EXP 193
112494: PUSH
112495: LD_VAR 0 1
112499: ARRAY
112500: NOT
112501: IFFALSE 112505
// continue ;
112503: GO 112444
// for j := minerMinesList [ i ] downto 1 do
112505: LD_ADDR_VAR 0 2
112509: PUSH
112510: DOUBLE
112511: LD_EXP 193
112515: PUSH
112516: LD_VAR 0 1
112520: ARRAY
112521: INC
112522: ST_TO_ADDR
112523: LD_INT 1
112525: PUSH
112526: FOR_DOWNTO
112527: IFFALSE 112777
// begin side := GetSide ( minersList [ i ] ) ;
112529: LD_ADDR_VAR 0 3
112533: PUSH
112534: LD_EXP 192
112538: PUSH
112539: LD_VAR 0 1
112543: ARRAY
112544: PPUSH
112545: CALL_OW 255
112549: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
112550: LD_ADDR_VAR 0 4
112554: PUSH
112555: LD_EXP 193
112559: PUSH
112560: LD_VAR 0 1
112564: ARRAY
112565: PUSH
112566: LD_VAR 0 2
112570: ARRAY
112571: PUSH
112572: LD_INT 1
112574: ARRAY
112575: PPUSH
112576: LD_EXP 193
112580: PUSH
112581: LD_VAR 0 1
112585: ARRAY
112586: PUSH
112587: LD_VAR 0 2
112591: ARRAY
112592: PUSH
112593: LD_INT 2
112595: ARRAY
112596: PPUSH
112597: CALL_OW 428
112601: ST_TO_ADDR
// if not tmp then
112602: LD_VAR 0 4
112606: NOT
112607: IFFALSE 112611
// continue ;
112609: GO 112526
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112611: LD_VAR 0 4
112615: PUSH
112616: LD_INT 81
112618: PUSH
112619: LD_VAR 0 3
112623: PUSH
112624: EMPTY
112625: LIST
112626: LIST
112627: PPUSH
112628: CALL_OW 69
112632: IN
112633: PUSH
112634: LD_EXP 193
112638: PUSH
112639: LD_VAR 0 1
112643: ARRAY
112644: PUSH
112645: LD_VAR 0 2
112649: ARRAY
112650: PUSH
112651: LD_INT 1
112653: ARRAY
112654: PPUSH
112655: LD_EXP 193
112659: PUSH
112660: LD_VAR 0 1
112664: ARRAY
112665: PUSH
112666: LD_VAR 0 2
112670: ARRAY
112671: PUSH
112672: LD_INT 2
112674: ARRAY
112675: PPUSH
112676: CALL_OW 458
112680: AND
112681: IFFALSE 112775
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112683: LD_EXP 193
112687: PUSH
112688: LD_VAR 0 1
112692: ARRAY
112693: PUSH
112694: LD_VAR 0 2
112698: ARRAY
112699: PUSH
112700: LD_INT 1
112702: ARRAY
112703: PPUSH
112704: LD_EXP 193
112708: PUSH
112709: LD_VAR 0 1
112713: ARRAY
112714: PUSH
112715: LD_VAR 0 2
112719: ARRAY
112720: PUSH
112721: LD_INT 2
112723: ARRAY
112724: PPUSH
112725: LD_VAR 0 3
112729: PPUSH
112730: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112734: LD_ADDR_EXP 193
112738: PUSH
112739: LD_EXP 193
112743: PPUSH
112744: LD_VAR 0 1
112748: PPUSH
112749: LD_EXP 193
112753: PUSH
112754: LD_VAR 0 1
112758: ARRAY
112759: PPUSH
112760: LD_VAR 0 2
112764: PPUSH
112765: CALL_OW 3
112769: PPUSH
112770: CALL_OW 1
112774: ST_TO_ADDR
// end ; end ;
112775: GO 112526
112777: POP
112778: POP
// end ;
112779: GO 112444
112781: POP
112782: POP
// end ;
112783: PPOPN 4
112785: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
112786: LD_INT 0
112788: PPUSH
112789: PPUSH
// result := false ;
112790: LD_ADDR_VAR 0 4
112794: PUSH
112795: LD_INT 0
112797: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112798: LD_VAR 0 1
112802: PPUSH
112803: CALL_OW 264
112807: PUSH
112808: LD_INT 81
112810: EQUAL
112811: NOT
112812: IFFALSE 112816
// exit ;
112814: GO 113056
// index := GetElementIndex ( minersList , unit ) ;
112816: LD_ADDR_VAR 0 5
112820: PUSH
112821: LD_EXP 192
112825: PPUSH
112826: LD_VAR 0 1
112830: PPUSH
112831: CALL 57559 0 2
112835: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112836: LD_EXP 193
112840: PUSH
112841: LD_VAR 0 5
112845: ARRAY
112846: PUSH
112847: LD_EXP 194
112851: GREATEREQUAL
112852: IFFALSE 112856
// exit ;
112854: GO 113056
// ComMoveXY ( unit , x , y ) ;
112856: LD_VAR 0 1
112860: PPUSH
112861: LD_VAR 0 2
112865: PPUSH
112866: LD_VAR 0 3
112870: PPUSH
112871: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112875: LD_INT 35
112877: PPUSH
112878: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112882: LD_VAR 0 1
112886: PPUSH
112887: LD_VAR 0 2
112891: PPUSH
112892: LD_VAR 0 3
112896: PPUSH
112897: CALL 88914 0 3
112901: NOT
112902: PUSH
112903: LD_VAR 0 1
112907: PPUSH
112908: CALL_OW 314
112912: AND
112913: IFFALSE 112917
// exit ;
112915: GO 113056
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112917: LD_VAR 0 2
112921: PPUSH
112922: LD_VAR 0 3
112926: PPUSH
112927: CALL_OW 428
112931: PUSH
112932: LD_VAR 0 1
112936: EQUAL
112937: PUSH
112938: LD_VAR 0 1
112942: PPUSH
112943: CALL_OW 314
112947: NOT
112948: AND
112949: IFFALSE 112875
// PlaySoundXY ( x , y , PlantMine ) ;
112951: LD_VAR 0 2
112955: PPUSH
112956: LD_VAR 0 3
112960: PPUSH
112961: LD_STRING PlantMine
112963: PPUSH
112964: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112968: LD_VAR 0 2
112972: PPUSH
112973: LD_VAR 0 3
112977: PPUSH
112978: LD_VAR 0 1
112982: PPUSH
112983: CALL_OW 255
112987: PPUSH
112988: LD_INT 0
112990: PPUSH
112991: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112995: LD_ADDR_EXP 193
112999: PUSH
113000: LD_EXP 193
113004: PPUSH
113005: LD_VAR 0 5
113009: PUSH
113010: LD_EXP 193
113014: PUSH
113015: LD_VAR 0 5
113019: ARRAY
113020: PUSH
113021: LD_INT 1
113023: PLUS
113024: PUSH
113025: EMPTY
113026: LIST
113027: LIST
113028: PPUSH
113029: LD_VAR 0 2
113033: PUSH
113034: LD_VAR 0 3
113038: PUSH
113039: EMPTY
113040: LIST
113041: LIST
113042: PPUSH
113043: CALL 57774 0 3
113047: ST_TO_ADDR
// result := true ;
113048: LD_ADDR_VAR 0 4
113052: PUSH
113053: LD_INT 1
113055: ST_TO_ADDR
// end ;
113056: LD_VAR 0 4
113060: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
113061: LD_INT 0
113063: PPUSH
113064: PPUSH
113065: PPUSH
// if not unit in minersList then
113066: LD_VAR 0 1
113070: PUSH
113071: LD_EXP 192
113075: IN
113076: NOT
113077: IFFALSE 113081
// exit ;
113079: GO 113473
// index := GetElementIndex ( minersList , unit ) ;
113081: LD_ADDR_VAR 0 6
113085: PUSH
113086: LD_EXP 192
113090: PPUSH
113091: LD_VAR 0 1
113095: PPUSH
113096: CALL 57559 0 2
113100: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
113101: LD_ADDR_VAR 0 5
113105: PUSH
113106: DOUBLE
113107: LD_EXP 193
113111: PUSH
113112: LD_VAR 0 6
113116: ARRAY
113117: INC
113118: ST_TO_ADDR
113119: LD_INT 1
113121: PUSH
113122: FOR_DOWNTO
113123: IFFALSE 113284
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
113125: LD_EXP 193
113129: PUSH
113130: LD_VAR 0 6
113134: ARRAY
113135: PUSH
113136: LD_VAR 0 5
113140: ARRAY
113141: PUSH
113142: LD_INT 1
113144: ARRAY
113145: PUSH
113146: LD_VAR 0 2
113150: EQUAL
113151: PUSH
113152: LD_EXP 193
113156: PUSH
113157: LD_VAR 0 6
113161: ARRAY
113162: PUSH
113163: LD_VAR 0 5
113167: ARRAY
113168: PUSH
113169: LD_INT 2
113171: ARRAY
113172: PUSH
113173: LD_VAR 0 3
113177: EQUAL
113178: AND
113179: IFFALSE 113282
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113181: LD_EXP 193
113185: PUSH
113186: LD_VAR 0 6
113190: ARRAY
113191: PUSH
113192: LD_VAR 0 5
113196: ARRAY
113197: PUSH
113198: LD_INT 1
113200: ARRAY
113201: PPUSH
113202: LD_EXP 193
113206: PUSH
113207: LD_VAR 0 6
113211: ARRAY
113212: PUSH
113213: LD_VAR 0 5
113217: ARRAY
113218: PUSH
113219: LD_INT 2
113221: ARRAY
113222: PPUSH
113223: LD_VAR 0 1
113227: PPUSH
113228: CALL_OW 255
113232: PPUSH
113233: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113237: LD_ADDR_EXP 193
113241: PUSH
113242: LD_EXP 193
113246: PPUSH
113247: LD_VAR 0 6
113251: PPUSH
113252: LD_EXP 193
113256: PUSH
113257: LD_VAR 0 6
113261: ARRAY
113262: PPUSH
113263: LD_VAR 0 5
113267: PPUSH
113268: CALL_OW 3
113272: PPUSH
113273: CALL_OW 1
113277: ST_TO_ADDR
// exit ;
113278: POP
113279: POP
113280: GO 113473
// end ; end ;
113282: GO 113122
113284: POP
113285: POP
// for i := minerMinesList [ index ] downto 1 do
113286: LD_ADDR_VAR 0 5
113290: PUSH
113291: DOUBLE
113292: LD_EXP 193
113296: PUSH
113297: LD_VAR 0 6
113301: ARRAY
113302: INC
113303: ST_TO_ADDR
113304: LD_INT 1
113306: PUSH
113307: FOR_DOWNTO
113308: IFFALSE 113471
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
113310: LD_EXP 193
113314: PUSH
113315: LD_VAR 0 6
113319: ARRAY
113320: PUSH
113321: LD_VAR 0 5
113325: ARRAY
113326: PUSH
113327: LD_INT 1
113329: ARRAY
113330: PPUSH
113331: LD_EXP 193
113335: PUSH
113336: LD_VAR 0 6
113340: ARRAY
113341: PUSH
113342: LD_VAR 0 5
113346: ARRAY
113347: PUSH
113348: LD_INT 2
113350: ARRAY
113351: PPUSH
113352: LD_VAR 0 2
113356: PPUSH
113357: LD_VAR 0 3
113361: PPUSH
113362: CALL_OW 298
113366: PUSH
113367: LD_INT 6
113369: LESS
113370: IFFALSE 113469
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113372: LD_EXP 193
113376: PUSH
113377: LD_VAR 0 6
113381: ARRAY
113382: PUSH
113383: LD_VAR 0 5
113387: ARRAY
113388: PUSH
113389: LD_INT 1
113391: ARRAY
113392: PPUSH
113393: LD_EXP 193
113397: PUSH
113398: LD_VAR 0 6
113402: ARRAY
113403: PUSH
113404: LD_VAR 0 5
113408: ARRAY
113409: PUSH
113410: LD_INT 2
113412: ARRAY
113413: PPUSH
113414: LD_VAR 0 1
113418: PPUSH
113419: CALL_OW 255
113423: PPUSH
113424: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113428: LD_ADDR_EXP 193
113432: PUSH
113433: LD_EXP 193
113437: PPUSH
113438: LD_VAR 0 6
113442: PPUSH
113443: LD_EXP 193
113447: PUSH
113448: LD_VAR 0 6
113452: ARRAY
113453: PPUSH
113454: LD_VAR 0 5
113458: PPUSH
113459: CALL_OW 3
113463: PPUSH
113464: CALL_OW 1
113468: ST_TO_ADDR
// end ; end ;
113469: GO 113307
113471: POP
113472: POP
// end ;
113473: LD_VAR 0 4
113477: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
113478: LD_INT 0
113480: PPUSH
113481: PPUSH
113482: PPUSH
113483: PPUSH
113484: PPUSH
113485: PPUSH
113486: PPUSH
113487: PPUSH
113488: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
113489: LD_VAR 0 1
113493: PPUSH
113494: CALL_OW 264
113498: PUSH
113499: LD_INT 81
113501: EQUAL
113502: NOT
113503: PUSH
113504: LD_VAR 0 1
113508: PUSH
113509: LD_EXP 192
113513: IN
113514: NOT
113515: OR
113516: IFFALSE 113520
// exit ;
113518: GO 113842
// index := GetElementIndex ( minersList , unit ) ;
113520: LD_ADDR_VAR 0 6
113524: PUSH
113525: LD_EXP 192
113529: PPUSH
113530: LD_VAR 0 1
113534: PPUSH
113535: CALL 57559 0 2
113539: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
113540: LD_ADDR_VAR 0 8
113544: PUSH
113545: LD_EXP 194
113549: PUSH
113550: LD_EXP 193
113554: PUSH
113555: LD_VAR 0 6
113559: ARRAY
113560: MINUS
113561: ST_TO_ADDR
// if not minesFreeAmount then
113562: LD_VAR 0 8
113566: NOT
113567: IFFALSE 113571
// exit ;
113569: GO 113842
// tmp := [ ] ;
113571: LD_ADDR_VAR 0 7
113575: PUSH
113576: EMPTY
113577: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
113578: LD_ADDR_VAR 0 5
113582: PUSH
113583: DOUBLE
113584: LD_INT 1
113586: DEC
113587: ST_TO_ADDR
113588: LD_VAR 0 8
113592: PUSH
113593: FOR_TO
113594: IFFALSE 113789
// begin _d := rand ( 0 , 5 ) ;
113596: LD_ADDR_VAR 0 11
113600: PUSH
113601: LD_INT 0
113603: PPUSH
113604: LD_INT 5
113606: PPUSH
113607: CALL_OW 12
113611: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113612: LD_ADDR_VAR 0 12
113616: PUSH
113617: LD_INT 2
113619: PPUSH
113620: LD_INT 6
113622: PPUSH
113623: CALL_OW 12
113627: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113628: LD_ADDR_VAR 0 9
113632: PUSH
113633: LD_VAR 0 2
113637: PPUSH
113638: LD_VAR 0 11
113642: PPUSH
113643: LD_VAR 0 12
113647: PPUSH
113648: CALL_OW 272
113652: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113653: LD_ADDR_VAR 0 10
113657: PUSH
113658: LD_VAR 0 3
113662: PPUSH
113663: LD_VAR 0 11
113667: PPUSH
113668: LD_VAR 0 12
113672: PPUSH
113673: CALL_OW 273
113677: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113678: LD_VAR 0 9
113682: PPUSH
113683: LD_VAR 0 10
113687: PPUSH
113688: CALL_OW 488
113692: PUSH
113693: LD_VAR 0 9
113697: PUSH
113698: LD_VAR 0 10
113702: PUSH
113703: EMPTY
113704: LIST
113705: LIST
113706: PUSH
113707: LD_VAR 0 7
113711: IN
113712: NOT
113713: AND
113714: PUSH
113715: LD_VAR 0 9
113719: PPUSH
113720: LD_VAR 0 10
113724: PPUSH
113725: CALL_OW 458
113729: NOT
113730: AND
113731: IFFALSE 113773
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113733: LD_ADDR_VAR 0 7
113737: PUSH
113738: LD_VAR 0 7
113742: PPUSH
113743: LD_VAR 0 7
113747: PUSH
113748: LD_INT 1
113750: PLUS
113751: PPUSH
113752: LD_VAR 0 9
113756: PUSH
113757: LD_VAR 0 10
113761: PUSH
113762: EMPTY
113763: LIST
113764: LIST
113765: PPUSH
113766: CALL_OW 1
113770: ST_TO_ADDR
113771: GO 113787
// i := i - 1 ;
113773: LD_ADDR_VAR 0 5
113777: PUSH
113778: LD_VAR 0 5
113782: PUSH
113783: LD_INT 1
113785: MINUS
113786: ST_TO_ADDR
// end ;
113787: GO 113593
113789: POP
113790: POP
// for i in tmp do
113791: LD_ADDR_VAR 0 5
113795: PUSH
113796: LD_VAR 0 7
113800: PUSH
113801: FOR_IN
113802: IFFALSE 113840
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113804: LD_VAR 0 1
113808: PPUSH
113809: LD_VAR 0 5
113813: PUSH
113814: LD_INT 1
113816: ARRAY
113817: PPUSH
113818: LD_VAR 0 5
113822: PUSH
113823: LD_INT 2
113825: ARRAY
113826: PPUSH
113827: CALL 112786 0 3
113831: NOT
113832: IFFALSE 113838
// exit ;
113834: POP
113835: POP
113836: GO 113842
113838: GO 113801
113840: POP
113841: POP
// end ;
113842: LD_VAR 0 4
113846: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
113847: LD_INT 0
113849: PPUSH
113850: PPUSH
113851: PPUSH
113852: PPUSH
113853: PPUSH
113854: PPUSH
113855: PPUSH
// if not GetClass ( unit ) = class_sniper then
113856: LD_VAR 0 1
113860: PPUSH
113861: CALL_OW 257
113865: PUSH
113866: LD_INT 5
113868: EQUAL
113869: NOT
113870: IFFALSE 113874
// exit ;
113872: GO 114262
// dist := 8 ;
113874: LD_ADDR_VAR 0 5
113878: PUSH
113879: LD_INT 8
113881: ST_TO_ADDR
// viewRange := 12 ;
113882: LD_ADDR_VAR 0 7
113886: PUSH
113887: LD_INT 12
113889: ST_TO_ADDR
// side := GetSide ( unit ) ;
113890: LD_ADDR_VAR 0 6
113894: PUSH
113895: LD_VAR 0 1
113899: PPUSH
113900: CALL_OW 255
113904: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113905: LD_INT 61
113907: PPUSH
113908: LD_VAR 0 6
113912: PPUSH
113913: CALL_OW 321
113917: PUSH
113918: LD_INT 2
113920: EQUAL
113921: IFFALSE 113931
// viewRange := 16 ;
113923: LD_ADDR_VAR 0 7
113927: PUSH
113928: LD_INT 16
113930: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113931: LD_VAR 0 1
113935: PPUSH
113936: LD_VAR 0 2
113940: PPUSH
113941: LD_VAR 0 3
113945: PPUSH
113946: CALL_OW 297
113950: PUSH
113951: LD_VAR 0 5
113955: GREATER
113956: IFFALSE 114035
// begin ComMoveXY ( unit , x , y ) ;
113958: LD_VAR 0 1
113962: PPUSH
113963: LD_VAR 0 2
113967: PPUSH
113968: LD_VAR 0 3
113972: PPUSH
113973: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113977: LD_INT 35
113979: PPUSH
113980: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113984: LD_VAR 0 1
113988: PPUSH
113989: LD_VAR 0 2
113993: PPUSH
113994: LD_VAR 0 3
113998: PPUSH
113999: CALL 88914 0 3
114003: NOT
114004: IFFALSE 114008
// exit ;
114006: GO 114262
// until GetDistUnitXY ( unit , x , y ) < dist ;
114008: LD_VAR 0 1
114012: PPUSH
114013: LD_VAR 0 2
114017: PPUSH
114018: LD_VAR 0 3
114022: PPUSH
114023: CALL_OW 297
114027: PUSH
114028: LD_VAR 0 5
114032: LESS
114033: IFFALSE 113977
// end ; ComTurnXY ( unit , x , y ) ;
114035: LD_VAR 0 1
114039: PPUSH
114040: LD_VAR 0 2
114044: PPUSH
114045: LD_VAR 0 3
114049: PPUSH
114050: CALL_OW 118
// wait ( 5 ) ;
114054: LD_INT 5
114056: PPUSH
114057: CALL_OW 67
// _d := GetDir ( unit ) ;
114061: LD_ADDR_VAR 0 10
114065: PUSH
114066: LD_VAR 0 1
114070: PPUSH
114071: CALL_OW 254
114075: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
114076: LD_ADDR_VAR 0 8
114080: PUSH
114081: LD_VAR 0 1
114085: PPUSH
114086: CALL_OW 250
114090: PPUSH
114091: LD_VAR 0 10
114095: PPUSH
114096: LD_VAR 0 5
114100: PPUSH
114101: CALL_OW 272
114105: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
114106: LD_ADDR_VAR 0 9
114110: PUSH
114111: LD_VAR 0 1
114115: PPUSH
114116: CALL_OW 251
114120: PPUSH
114121: LD_VAR 0 10
114125: PPUSH
114126: LD_VAR 0 5
114130: PPUSH
114131: CALL_OW 273
114135: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
114136: LD_VAR 0 8
114140: PPUSH
114141: LD_VAR 0 9
114145: PPUSH
114146: CALL_OW 488
114150: NOT
114151: IFFALSE 114155
// exit ;
114153: GO 114262
// ComAnimCustom ( unit , 1 ) ;
114155: LD_VAR 0 1
114159: PPUSH
114160: LD_INT 1
114162: PPUSH
114163: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
114167: LD_VAR 0 8
114171: PPUSH
114172: LD_VAR 0 9
114176: PPUSH
114177: LD_VAR 0 6
114181: PPUSH
114182: LD_VAR 0 7
114186: PPUSH
114187: CALL_OW 330
// repeat wait ( 1 ) ;
114191: LD_INT 1
114193: PPUSH
114194: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
114198: LD_VAR 0 1
114202: PPUSH
114203: CALL_OW 316
114207: PUSH
114208: LD_VAR 0 1
114212: PPUSH
114213: CALL_OW 314
114217: OR
114218: PUSH
114219: LD_VAR 0 1
114223: PPUSH
114224: CALL_OW 302
114228: NOT
114229: OR
114230: PUSH
114231: LD_VAR 0 1
114235: PPUSH
114236: CALL_OW 301
114240: OR
114241: IFFALSE 114191
// RemoveSeeing ( _x , _y , side ) ;
114243: LD_VAR 0 8
114247: PPUSH
114248: LD_VAR 0 9
114252: PPUSH
114253: LD_VAR 0 6
114257: PPUSH
114258: CALL_OW 331
// end ; end_of_file
114262: LD_VAR 0 4
114266: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114267: LD_INT 0
114269: PPUSH
114270: PPUSH
114271: PPUSH
114272: PPUSH
114273: PPUSH
114274: PPUSH
114275: PPUSH
114276: PPUSH
114277: PPUSH
114278: PPUSH
114279: PPUSH
114280: PPUSH
114281: PPUSH
114282: PPUSH
114283: PPUSH
114284: PPUSH
114285: PPUSH
114286: PPUSH
114287: PPUSH
114288: PPUSH
114289: PPUSH
114290: PPUSH
114291: PPUSH
114292: PPUSH
114293: PPUSH
114294: PPUSH
114295: PPUSH
114296: PPUSH
114297: PPUSH
114298: PPUSH
114299: PPUSH
114300: PPUSH
114301: PPUSH
114302: PPUSH
// if not list then
114303: LD_VAR 0 1
114307: NOT
114308: IFFALSE 114312
// exit ;
114310: GO 118971
// base := list [ 1 ] ;
114312: LD_ADDR_VAR 0 3
114316: PUSH
114317: LD_VAR 0 1
114321: PUSH
114322: LD_INT 1
114324: ARRAY
114325: ST_TO_ADDR
// group := list [ 2 ] ;
114326: LD_ADDR_VAR 0 4
114330: PUSH
114331: LD_VAR 0 1
114335: PUSH
114336: LD_INT 2
114338: ARRAY
114339: ST_TO_ADDR
// path := list [ 3 ] ;
114340: LD_ADDR_VAR 0 5
114344: PUSH
114345: LD_VAR 0 1
114349: PUSH
114350: LD_INT 3
114352: ARRAY
114353: ST_TO_ADDR
// flags := list [ 4 ] ;
114354: LD_ADDR_VAR 0 6
114358: PUSH
114359: LD_VAR 0 1
114363: PUSH
114364: LD_INT 4
114366: ARRAY
114367: ST_TO_ADDR
// mined := [ ] ;
114368: LD_ADDR_VAR 0 27
114372: PUSH
114373: EMPTY
114374: ST_TO_ADDR
// bombed := [ ] ;
114375: LD_ADDR_VAR 0 28
114379: PUSH
114380: EMPTY
114381: ST_TO_ADDR
// healers := [ ] ;
114382: LD_ADDR_VAR 0 31
114386: PUSH
114387: EMPTY
114388: ST_TO_ADDR
// to_heal := [ ] ;
114389: LD_ADDR_VAR 0 30
114393: PUSH
114394: EMPTY
114395: ST_TO_ADDR
// repairs := [ ] ;
114396: LD_ADDR_VAR 0 33
114400: PUSH
114401: EMPTY
114402: ST_TO_ADDR
// to_repair := [ ] ;
114403: LD_ADDR_VAR 0 32
114407: PUSH
114408: EMPTY
114409: ST_TO_ADDR
// if not group or not path then
114410: LD_VAR 0 4
114414: NOT
114415: PUSH
114416: LD_VAR 0 5
114420: NOT
114421: OR
114422: IFFALSE 114426
// exit ;
114424: GO 118971
// side := GetSide ( group [ 1 ] ) ;
114426: LD_ADDR_VAR 0 35
114430: PUSH
114431: LD_VAR 0 4
114435: PUSH
114436: LD_INT 1
114438: ARRAY
114439: PPUSH
114440: CALL_OW 255
114444: ST_TO_ADDR
// if flags then
114445: LD_VAR 0 6
114449: IFFALSE 114593
// begin f_ignore_area := flags [ 1 ] ;
114451: LD_ADDR_VAR 0 17
114455: PUSH
114456: LD_VAR 0 6
114460: PUSH
114461: LD_INT 1
114463: ARRAY
114464: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114465: LD_ADDR_VAR 0 18
114469: PUSH
114470: LD_VAR 0 6
114474: PUSH
114475: LD_INT 2
114477: ARRAY
114478: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114479: LD_ADDR_VAR 0 19
114483: PUSH
114484: LD_VAR 0 6
114488: PUSH
114489: LD_INT 3
114491: ARRAY
114492: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114493: LD_ADDR_VAR 0 20
114497: PUSH
114498: LD_VAR 0 6
114502: PUSH
114503: LD_INT 4
114505: ARRAY
114506: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114507: LD_ADDR_VAR 0 21
114511: PUSH
114512: LD_VAR 0 6
114516: PUSH
114517: LD_INT 5
114519: ARRAY
114520: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114521: LD_ADDR_VAR 0 22
114525: PUSH
114526: LD_VAR 0 6
114530: PUSH
114531: LD_INT 6
114533: ARRAY
114534: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114535: LD_ADDR_VAR 0 23
114539: PUSH
114540: LD_VAR 0 6
114544: PUSH
114545: LD_INT 7
114547: ARRAY
114548: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114549: LD_ADDR_VAR 0 24
114553: PUSH
114554: LD_VAR 0 6
114558: PUSH
114559: LD_INT 8
114561: ARRAY
114562: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114563: LD_ADDR_VAR 0 25
114567: PUSH
114568: LD_VAR 0 6
114572: PUSH
114573: LD_INT 9
114575: ARRAY
114576: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114577: LD_ADDR_VAR 0 26
114581: PUSH
114582: LD_VAR 0 6
114586: PUSH
114587: LD_INT 10
114589: ARRAY
114590: ST_TO_ADDR
// end else
114591: GO 114673
// begin f_ignore_area := false ;
114593: LD_ADDR_VAR 0 17
114597: PUSH
114598: LD_INT 0
114600: ST_TO_ADDR
// f_capture := false ;
114601: LD_ADDR_VAR 0 18
114605: PUSH
114606: LD_INT 0
114608: ST_TO_ADDR
// f_ignore_civ := false ;
114609: LD_ADDR_VAR 0 19
114613: PUSH
114614: LD_INT 0
114616: ST_TO_ADDR
// f_murder := false ;
114617: LD_ADDR_VAR 0 20
114621: PUSH
114622: LD_INT 0
114624: ST_TO_ADDR
// f_mines := false ;
114625: LD_ADDR_VAR 0 21
114629: PUSH
114630: LD_INT 0
114632: ST_TO_ADDR
// f_repair := false ;
114633: LD_ADDR_VAR 0 22
114637: PUSH
114638: LD_INT 0
114640: ST_TO_ADDR
// f_heal := false ;
114641: LD_ADDR_VAR 0 23
114645: PUSH
114646: LD_INT 0
114648: ST_TO_ADDR
// f_spacetime := false ;
114649: LD_ADDR_VAR 0 24
114653: PUSH
114654: LD_INT 0
114656: ST_TO_ADDR
// f_attack_depot := false ;
114657: LD_ADDR_VAR 0 25
114661: PUSH
114662: LD_INT 0
114664: ST_TO_ADDR
// f_crawl := false ;
114665: LD_ADDR_VAR 0 26
114669: PUSH
114670: LD_INT 0
114672: ST_TO_ADDR
// end ; if f_heal then
114673: LD_VAR 0 23
114677: IFFALSE 114704
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114679: LD_ADDR_VAR 0 31
114683: PUSH
114684: LD_VAR 0 4
114688: PPUSH
114689: LD_INT 25
114691: PUSH
114692: LD_INT 4
114694: PUSH
114695: EMPTY
114696: LIST
114697: LIST
114698: PPUSH
114699: CALL_OW 72
114703: ST_TO_ADDR
// if f_repair then
114704: LD_VAR 0 22
114708: IFFALSE 114735
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114710: LD_ADDR_VAR 0 33
114714: PUSH
114715: LD_VAR 0 4
114719: PPUSH
114720: LD_INT 25
114722: PUSH
114723: LD_INT 3
114725: PUSH
114726: EMPTY
114727: LIST
114728: LIST
114729: PPUSH
114730: CALL_OW 72
114734: ST_TO_ADDR
// units_path := [ ] ;
114735: LD_ADDR_VAR 0 16
114739: PUSH
114740: EMPTY
114741: ST_TO_ADDR
// for i = 1 to group do
114742: LD_ADDR_VAR 0 7
114746: PUSH
114747: DOUBLE
114748: LD_INT 1
114750: DEC
114751: ST_TO_ADDR
114752: LD_VAR 0 4
114756: PUSH
114757: FOR_TO
114758: IFFALSE 114787
// units_path := Replace ( units_path , i , path ) ;
114760: LD_ADDR_VAR 0 16
114764: PUSH
114765: LD_VAR 0 16
114769: PPUSH
114770: LD_VAR 0 7
114774: PPUSH
114775: LD_VAR 0 5
114779: PPUSH
114780: CALL_OW 1
114784: ST_TO_ADDR
114785: GO 114757
114787: POP
114788: POP
// repeat for i = group downto 1 do
114789: LD_ADDR_VAR 0 7
114793: PUSH
114794: DOUBLE
114795: LD_VAR 0 4
114799: INC
114800: ST_TO_ADDR
114801: LD_INT 1
114803: PUSH
114804: FOR_DOWNTO
114805: IFFALSE 118927
// begin wait ( 5 ) ;
114807: LD_INT 5
114809: PPUSH
114810: CALL_OW 67
// tmp := [ ] ;
114814: LD_ADDR_VAR 0 14
114818: PUSH
114819: EMPTY
114820: ST_TO_ADDR
// attacking := false ;
114821: LD_ADDR_VAR 0 29
114825: PUSH
114826: LD_INT 0
114828: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114829: LD_VAR 0 4
114833: PUSH
114834: LD_VAR 0 7
114838: ARRAY
114839: PPUSH
114840: CALL_OW 301
114844: PUSH
114845: LD_VAR 0 4
114849: PUSH
114850: LD_VAR 0 7
114854: ARRAY
114855: NOT
114856: OR
114857: IFFALSE 114966
// begin if GetType ( group [ i ] ) = unit_human then
114859: LD_VAR 0 4
114863: PUSH
114864: LD_VAR 0 7
114868: ARRAY
114869: PPUSH
114870: CALL_OW 247
114874: PUSH
114875: LD_INT 1
114877: EQUAL
114878: IFFALSE 114924
// begin to_heal := to_heal diff group [ i ] ;
114880: LD_ADDR_VAR 0 30
114884: PUSH
114885: LD_VAR 0 30
114889: PUSH
114890: LD_VAR 0 4
114894: PUSH
114895: LD_VAR 0 7
114899: ARRAY
114900: DIFF
114901: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114902: LD_ADDR_VAR 0 31
114906: PUSH
114907: LD_VAR 0 31
114911: PUSH
114912: LD_VAR 0 4
114916: PUSH
114917: LD_VAR 0 7
114921: ARRAY
114922: DIFF
114923: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114924: LD_ADDR_VAR 0 4
114928: PUSH
114929: LD_VAR 0 4
114933: PPUSH
114934: LD_VAR 0 7
114938: PPUSH
114939: CALL_OW 3
114943: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114944: LD_ADDR_VAR 0 16
114948: PUSH
114949: LD_VAR 0 16
114953: PPUSH
114954: LD_VAR 0 7
114958: PPUSH
114959: CALL_OW 3
114963: ST_TO_ADDR
// continue ;
114964: GO 114804
// end ; if f_repair then
114966: LD_VAR 0 22
114970: IFFALSE 115459
// begin if GetType ( group [ i ] ) = unit_vehicle then
114972: LD_VAR 0 4
114976: PUSH
114977: LD_VAR 0 7
114981: ARRAY
114982: PPUSH
114983: CALL_OW 247
114987: PUSH
114988: LD_INT 2
114990: EQUAL
114991: IFFALSE 115181
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114993: LD_VAR 0 4
114997: PUSH
114998: LD_VAR 0 7
115002: ARRAY
115003: PPUSH
115004: CALL_OW 256
115008: PUSH
115009: LD_INT 700
115011: LESS
115012: PUSH
115013: LD_VAR 0 4
115017: PUSH
115018: LD_VAR 0 7
115022: ARRAY
115023: PUSH
115024: LD_VAR 0 32
115028: IN
115029: NOT
115030: AND
115031: IFFALSE 115055
// to_repair := to_repair union group [ i ] ;
115033: LD_ADDR_VAR 0 32
115037: PUSH
115038: LD_VAR 0 32
115042: PUSH
115043: LD_VAR 0 4
115047: PUSH
115048: LD_VAR 0 7
115052: ARRAY
115053: UNION
115054: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
115055: LD_VAR 0 4
115059: PUSH
115060: LD_VAR 0 7
115064: ARRAY
115065: PPUSH
115066: CALL_OW 256
115070: PUSH
115071: LD_INT 1000
115073: EQUAL
115074: PUSH
115075: LD_VAR 0 4
115079: PUSH
115080: LD_VAR 0 7
115084: ARRAY
115085: PUSH
115086: LD_VAR 0 32
115090: IN
115091: AND
115092: IFFALSE 115116
// to_repair := to_repair diff group [ i ] ;
115094: LD_ADDR_VAR 0 32
115098: PUSH
115099: LD_VAR 0 32
115103: PUSH
115104: LD_VAR 0 4
115108: PUSH
115109: LD_VAR 0 7
115113: ARRAY
115114: DIFF
115115: ST_TO_ADDR
// if group [ i ] in to_repair then
115116: LD_VAR 0 4
115120: PUSH
115121: LD_VAR 0 7
115125: ARRAY
115126: PUSH
115127: LD_VAR 0 32
115131: IN
115132: IFFALSE 115179
// begin if not IsInArea ( group [ i ] , f_repair ) then
115134: LD_VAR 0 4
115138: PUSH
115139: LD_VAR 0 7
115143: ARRAY
115144: PPUSH
115145: LD_VAR 0 22
115149: PPUSH
115150: CALL_OW 308
115154: NOT
115155: IFFALSE 115177
// ComMoveToArea ( group [ i ] , f_repair ) ;
115157: LD_VAR 0 4
115161: PUSH
115162: LD_VAR 0 7
115166: ARRAY
115167: PPUSH
115168: LD_VAR 0 22
115172: PPUSH
115173: CALL_OW 113
// continue ;
115177: GO 114804
// end ; end else
115179: GO 115459
// if group [ i ] in repairs then
115181: LD_VAR 0 4
115185: PUSH
115186: LD_VAR 0 7
115190: ARRAY
115191: PUSH
115192: LD_VAR 0 33
115196: IN
115197: IFFALSE 115459
// begin if IsInUnit ( group [ i ] ) then
115199: LD_VAR 0 4
115203: PUSH
115204: LD_VAR 0 7
115208: ARRAY
115209: PPUSH
115210: CALL_OW 310
115214: IFFALSE 115282
// begin z := IsInUnit ( group [ i ] ) ;
115216: LD_ADDR_VAR 0 13
115220: PUSH
115221: LD_VAR 0 4
115225: PUSH
115226: LD_VAR 0 7
115230: ARRAY
115231: PPUSH
115232: CALL_OW 310
115236: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115237: LD_VAR 0 13
115241: PUSH
115242: LD_VAR 0 32
115246: IN
115247: PUSH
115248: LD_VAR 0 13
115252: PPUSH
115253: LD_VAR 0 22
115257: PPUSH
115258: CALL_OW 308
115262: AND
115263: IFFALSE 115280
// ComExitVehicle ( group [ i ] ) ;
115265: LD_VAR 0 4
115269: PUSH
115270: LD_VAR 0 7
115274: ARRAY
115275: PPUSH
115276: CALL_OW 121
// end else
115280: GO 115459
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115282: LD_ADDR_VAR 0 13
115286: PUSH
115287: LD_VAR 0 4
115291: PPUSH
115292: LD_INT 95
115294: PUSH
115295: LD_VAR 0 22
115299: PUSH
115300: EMPTY
115301: LIST
115302: LIST
115303: PUSH
115304: LD_INT 58
115306: PUSH
115307: EMPTY
115308: LIST
115309: PUSH
115310: EMPTY
115311: LIST
115312: LIST
115313: PPUSH
115314: CALL_OW 72
115318: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115319: LD_VAR 0 4
115323: PUSH
115324: LD_VAR 0 7
115328: ARRAY
115329: PPUSH
115330: CALL_OW 314
115334: NOT
115335: IFFALSE 115457
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115337: LD_ADDR_VAR 0 10
115341: PUSH
115342: LD_VAR 0 13
115346: PPUSH
115347: LD_VAR 0 4
115351: PUSH
115352: LD_VAR 0 7
115356: ARRAY
115357: PPUSH
115358: CALL_OW 74
115362: ST_TO_ADDR
// if not x then
115363: LD_VAR 0 10
115367: NOT
115368: IFFALSE 115372
// continue ;
115370: GO 114804
// if GetLives ( x ) < 1000 then
115372: LD_VAR 0 10
115376: PPUSH
115377: CALL_OW 256
115381: PUSH
115382: LD_INT 1000
115384: LESS
115385: IFFALSE 115409
// ComRepairVehicle ( group [ i ] , x ) else
115387: LD_VAR 0 4
115391: PUSH
115392: LD_VAR 0 7
115396: ARRAY
115397: PPUSH
115398: LD_VAR 0 10
115402: PPUSH
115403: CALL_OW 129
115407: GO 115457
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115409: LD_VAR 0 23
115413: PUSH
115414: LD_VAR 0 4
115418: PUSH
115419: LD_VAR 0 7
115423: ARRAY
115424: PPUSH
115425: CALL_OW 256
115429: PUSH
115430: LD_INT 1000
115432: LESS
115433: AND
115434: NOT
115435: IFFALSE 115457
// ComEnterUnit ( group [ i ] , x ) ;
115437: LD_VAR 0 4
115441: PUSH
115442: LD_VAR 0 7
115446: ARRAY
115447: PPUSH
115448: LD_VAR 0 10
115452: PPUSH
115453: CALL_OW 120
// end ; continue ;
115457: GO 114804
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115459: LD_VAR 0 23
115463: PUSH
115464: LD_VAR 0 4
115468: PUSH
115469: LD_VAR 0 7
115473: ARRAY
115474: PPUSH
115475: CALL_OW 247
115479: PUSH
115480: LD_INT 1
115482: EQUAL
115483: AND
115484: IFFALSE 115962
// begin if group [ i ] in healers then
115486: LD_VAR 0 4
115490: PUSH
115491: LD_VAR 0 7
115495: ARRAY
115496: PUSH
115497: LD_VAR 0 31
115501: IN
115502: IFFALSE 115775
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115504: LD_VAR 0 4
115508: PUSH
115509: LD_VAR 0 7
115513: ARRAY
115514: PPUSH
115515: LD_VAR 0 23
115519: PPUSH
115520: CALL_OW 308
115524: NOT
115525: PUSH
115526: LD_VAR 0 4
115530: PUSH
115531: LD_VAR 0 7
115535: ARRAY
115536: PPUSH
115537: CALL_OW 314
115541: NOT
115542: AND
115543: IFFALSE 115567
// ComMoveToArea ( group [ i ] , f_heal ) else
115545: LD_VAR 0 4
115549: PUSH
115550: LD_VAR 0 7
115554: ARRAY
115555: PPUSH
115556: LD_VAR 0 23
115560: PPUSH
115561: CALL_OW 113
115565: GO 115773
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115567: LD_VAR 0 4
115571: PUSH
115572: LD_VAR 0 7
115576: ARRAY
115577: PPUSH
115578: CALL 87497 0 1
115582: PPUSH
115583: CALL_OW 256
115587: PUSH
115588: LD_INT 1000
115590: EQUAL
115591: IFFALSE 115610
// ComStop ( group [ i ] ) else
115593: LD_VAR 0 4
115597: PUSH
115598: LD_VAR 0 7
115602: ARRAY
115603: PPUSH
115604: CALL_OW 141
115608: GO 115773
// if not HasTask ( group [ i ] ) and to_heal then
115610: LD_VAR 0 4
115614: PUSH
115615: LD_VAR 0 7
115619: ARRAY
115620: PPUSH
115621: CALL_OW 314
115625: NOT
115626: PUSH
115627: LD_VAR 0 30
115631: AND
115632: IFFALSE 115773
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115634: LD_ADDR_VAR 0 13
115638: PUSH
115639: LD_VAR 0 30
115643: PPUSH
115644: LD_INT 3
115646: PUSH
115647: LD_INT 54
115649: PUSH
115650: EMPTY
115651: LIST
115652: PUSH
115653: EMPTY
115654: LIST
115655: LIST
115656: PPUSH
115657: CALL_OW 72
115661: PPUSH
115662: LD_VAR 0 4
115666: PUSH
115667: LD_VAR 0 7
115671: ARRAY
115672: PPUSH
115673: CALL_OW 74
115677: ST_TO_ADDR
// if z then
115678: LD_VAR 0 13
115682: IFFALSE 115773
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115684: LD_INT 91
115686: PUSH
115687: LD_VAR 0 13
115691: PUSH
115692: LD_INT 10
115694: PUSH
115695: EMPTY
115696: LIST
115697: LIST
115698: LIST
115699: PUSH
115700: LD_INT 81
115702: PUSH
115703: LD_VAR 0 13
115707: PPUSH
115708: CALL_OW 255
115712: PUSH
115713: EMPTY
115714: LIST
115715: LIST
115716: PUSH
115717: EMPTY
115718: LIST
115719: LIST
115720: PPUSH
115721: CALL_OW 69
115725: PUSH
115726: LD_INT 0
115728: EQUAL
115729: IFFALSE 115753
// ComHeal ( group [ i ] , z ) else
115731: LD_VAR 0 4
115735: PUSH
115736: LD_VAR 0 7
115740: ARRAY
115741: PPUSH
115742: LD_VAR 0 13
115746: PPUSH
115747: CALL_OW 128
115751: GO 115773
// ComMoveToArea ( group [ i ] , f_heal ) ;
115753: LD_VAR 0 4
115757: PUSH
115758: LD_VAR 0 7
115762: ARRAY
115763: PPUSH
115764: LD_VAR 0 23
115768: PPUSH
115769: CALL_OW 113
// end ; continue ;
115773: GO 114804
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115775: LD_VAR 0 4
115779: PUSH
115780: LD_VAR 0 7
115784: ARRAY
115785: PPUSH
115786: CALL_OW 256
115790: PUSH
115791: LD_INT 700
115793: LESS
115794: PUSH
115795: LD_VAR 0 4
115799: PUSH
115800: LD_VAR 0 7
115804: ARRAY
115805: PUSH
115806: LD_VAR 0 30
115810: IN
115811: NOT
115812: AND
115813: IFFALSE 115837
// to_heal := to_heal union group [ i ] ;
115815: LD_ADDR_VAR 0 30
115819: PUSH
115820: LD_VAR 0 30
115824: PUSH
115825: LD_VAR 0 4
115829: PUSH
115830: LD_VAR 0 7
115834: ARRAY
115835: UNION
115836: ST_TO_ADDR
// if group [ i ] in to_heal then
115837: LD_VAR 0 4
115841: PUSH
115842: LD_VAR 0 7
115846: ARRAY
115847: PUSH
115848: LD_VAR 0 30
115852: IN
115853: IFFALSE 115962
// begin if GetLives ( group [ i ] ) = 1000 then
115855: LD_VAR 0 4
115859: PUSH
115860: LD_VAR 0 7
115864: ARRAY
115865: PPUSH
115866: CALL_OW 256
115870: PUSH
115871: LD_INT 1000
115873: EQUAL
115874: IFFALSE 115900
// to_heal := to_heal diff group [ i ] else
115876: LD_ADDR_VAR 0 30
115880: PUSH
115881: LD_VAR 0 30
115885: PUSH
115886: LD_VAR 0 4
115890: PUSH
115891: LD_VAR 0 7
115895: ARRAY
115896: DIFF
115897: ST_TO_ADDR
115898: GO 115962
// begin if not IsInArea ( group [ i ] , to_heal ) then
115900: LD_VAR 0 4
115904: PUSH
115905: LD_VAR 0 7
115909: ARRAY
115910: PPUSH
115911: LD_VAR 0 30
115915: PPUSH
115916: CALL_OW 308
115920: NOT
115921: IFFALSE 115945
// ComMoveToArea ( group [ i ] , f_heal ) else
115923: LD_VAR 0 4
115927: PUSH
115928: LD_VAR 0 7
115932: ARRAY
115933: PPUSH
115934: LD_VAR 0 23
115938: PPUSH
115939: CALL_OW 113
115943: GO 115960
// ComHold ( group [ i ] ) ;
115945: LD_VAR 0 4
115949: PUSH
115950: LD_VAR 0 7
115954: ARRAY
115955: PPUSH
115956: CALL_OW 140
// continue ;
115960: GO 114804
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115962: LD_VAR 0 4
115966: PUSH
115967: LD_VAR 0 7
115971: ARRAY
115972: PPUSH
115973: LD_INT 10
115975: PPUSH
115976: CALL 85268 0 2
115980: NOT
115981: PUSH
115982: LD_VAR 0 16
115986: PUSH
115987: LD_VAR 0 7
115991: ARRAY
115992: PUSH
115993: EMPTY
115994: EQUAL
115995: NOT
115996: AND
115997: IFFALSE 116263
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115999: LD_VAR 0 4
116003: PUSH
116004: LD_VAR 0 7
116008: ARRAY
116009: PPUSH
116010: CALL_OW 262
116014: PUSH
116015: LD_INT 1
116017: PUSH
116018: LD_INT 2
116020: PUSH
116021: EMPTY
116022: LIST
116023: LIST
116024: IN
116025: IFFALSE 116066
// if GetFuel ( group [ i ] ) < 10 then
116027: LD_VAR 0 4
116031: PUSH
116032: LD_VAR 0 7
116036: ARRAY
116037: PPUSH
116038: CALL_OW 261
116042: PUSH
116043: LD_INT 10
116045: LESS
116046: IFFALSE 116066
// SetFuel ( group [ i ] , 12 ) ;
116048: LD_VAR 0 4
116052: PUSH
116053: LD_VAR 0 7
116057: ARRAY
116058: PPUSH
116059: LD_INT 12
116061: PPUSH
116062: CALL_OW 240
// if units_path [ i ] then
116066: LD_VAR 0 16
116070: PUSH
116071: LD_VAR 0 7
116075: ARRAY
116076: IFFALSE 116261
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
116078: LD_VAR 0 4
116082: PUSH
116083: LD_VAR 0 7
116087: ARRAY
116088: PPUSH
116089: LD_VAR 0 16
116093: PUSH
116094: LD_VAR 0 7
116098: ARRAY
116099: PUSH
116100: LD_INT 1
116102: ARRAY
116103: PUSH
116104: LD_INT 1
116106: ARRAY
116107: PPUSH
116108: LD_VAR 0 16
116112: PUSH
116113: LD_VAR 0 7
116117: ARRAY
116118: PUSH
116119: LD_INT 1
116121: ARRAY
116122: PUSH
116123: LD_INT 2
116125: ARRAY
116126: PPUSH
116127: CALL_OW 297
116131: PUSH
116132: LD_INT 6
116134: GREATER
116135: IFFALSE 116210
// begin if not HasTask ( group [ i ] ) then
116137: LD_VAR 0 4
116141: PUSH
116142: LD_VAR 0 7
116146: ARRAY
116147: PPUSH
116148: CALL_OW 314
116152: NOT
116153: IFFALSE 116208
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
116155: LD_VAR 0 4
116159: PUSH
116160: LD_VAR 0 7
116164: ARRAY
116165: PPUSH
116166: LD_VAR 0 16
116170: PUSH
116171: LD_VAR 0 7
116175: ARRAY
116176: PUSH
116177: LD_INT 1
116179: ARRAY
116180: PUSH
116181: LD_INT 1
116183: ARRAY
116184: PPUSH
116185: LD_VAR 0 16
116189: PUSH
116190: LD_VAR 0 7
116194: ARRAY
116195: PUSH
116196: LD_INT 1
116198: ARRAY
116199: PUSH
116200: LD_INT 2
116202: ARRAY
116203: PPUSH
116204: CALL_OW 114
// end else
116208: GO 116261
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
116210: LD_ADDR_VAR 0 15
116214: PUSH
116215: LD_VAR 0 16
116219: PUSH
116220: LD_VAR 0 7
116224: ARRAY
116225: PPUSH
116226: LD_INT 1
116228: PPUSH
116229: CALL_OW 3
116233: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
116234: LD_ADDR_VAR 0 16
116238: PUSH
116239: LD_VAR 0 16
116243: PPUSH
116244: LD_VAR 0 7
116248: PPUSH
116249: LD_VAR 0 15
116253: PPUSH
116254: CALL_OW 1
116258: ST_TO_ADDR
// continue ;
116259: GO 114804
// end ; end ; end else
116261: GO 118925
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116263: LD_ADDR_VAR 0 14
116267: PUSH
116268: LD_INT 81
116270: PUSH
116271: LD_VAR 0 4
116275: PUSH
116276: LD_VAR 0 7
116280: ARRAY
116281: PPUSH
116282: CALL_OW 255
116286: PUSH
116287: EMPTY
116288: LIST
116289: LIST
116290: PPUSH
116291: CALL_OW 69
116295: ST_TO_ADDR
// if not tmp then
116296: LD_VAR 0 14
116300: NOT
116301: IFFALSE 116305
// continue ;
116303: GO 114804
// if f_ignore_area then
116305: LD_VAR 0 17
116309: IFFALSE 116397
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116311: LD_ADDR_VAR 0 15
116315: PUSH
116316: LD_VAR 0 14
116320: PPUSH
116321: LD_INT 3
116323: PUSH
116324: LD_INT 92
116326: PUSH
116327: LD_VAR 0 17
116331: PUSH
116332: LD_INT 1
116334: ARRAY
116335: PUSH
116336: LD_VAR 0 17
116340: PUSH
116341: LD_INT 2
116343: ARRAY
116344: PUSH
116345: LD_VAR 0 17
116349: PUSH
116350: LD_INT 3
116352: ARRAY
116353: PUSH
116354: EMPTY
116355: LIST
116356: LIST
116357: LIST
116358: LIST
116359: PUSH
116360: EMPTY
116361: LIST
116362: LIST
116363: PPUSH
116364: CALL_OW 72
116368: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116369: LD_VAR 0 14
116373: PUSH
116374: LD_VAR 0 15
116378: DIFF
116379: IFFALSE 116397
// tmp := tmp diff tmp2 ;
116381: LD_ADDR_VAR 0 14
116385: PUSH
116386: LD_VAR 0 14
116390: PUSH
116391: LD_VAR 0 15
116395: DIFF
116396: ST_TO_ADDR
// end ; if not f_murder then
116397: LD_VAR 0 20
116401: NOT
116402: IFFALSE 116460
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116404: LD_ADDR_VAR 0 15
116408: PUSH
116409: LD_VAR 0 14
116413: PPUSH
116414: LD_INT 3
116416: PUSH
116417: LD_INT 50
116419: PUSH
116420: EMPTY
116421: LIST
116422: PUSH
116423: EMPTY
116424: LIST
116425: LIST
116426: PPUSH
116427: CALL_OW 72
116431: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116432: LD_VAR 0 14
116436: PUSH
116437: LD_VAR 0 15
116441: DIFF
116442: IFFALSE 116460
// tmp := tmp diff tmp2 ;
116444: LD_ADDR_VAR 0 14
116448: PUSH
116449: LD_VAR 0 14
116453: PUSH
116454: LD_VAR 0 15
116458: DIFF
116459: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116460: LD_ADDR_VAR 0 14
116464: PUSH
116465: LD_VAR 0 4
116469: PUSH
116470: LD_VAR 0 7
116474: ARRAY
116475: PPUSH
116476: LD_VAR 0 14
116480: PPUSH
116481: LD_INT 1
116483: PPUSH
116484: LD_INT 1
116486: PPUSH
116487: CALL 58209 0 4
116491: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116492: LD_VAR 0 4
116496: PUSH
116497: LD_VAR 0 7
116501: ARRAY
116502: PPUSH
116503: CALL_OW 257
116507: PUSH
116508: LD_INT 1
116510: EQUAL
116511: IFFALSE 116959
// begin if WantPlant ( group [ i ] ) then
116513: LD_VAR 0 4
116517: PUSH
116518: LD_VAR 0 7
116522: ARRAY
116523: PPUSH
116524: CALL 57710 0 1
116528: IFFALSE 116532
// continue ;
116530: GO 114804
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116532: LD_VAR 0 18
116536: PUSH
116537: LD_VAR 0 4
116541: PUSH
116542: LD_VAR 0 7
116546: ARRAY
116547: PPUSH
116548: CALL_OW 310
116552: NOT
116553: AND
116554: PUSH
116555: LD_VAR 0 14
116559: PUSH
116560: LD_INT 1
116562: ARRAY
116563: PUSH
116564: LD_VAR 0 14
116568: PPUSH
116569: LD_INT 21
116571: PUSH
116572: LD_INT 2
116574: PUSH
116575: EMPTY
116576: LIST
116577: LIST
116578: PUSH
116579: LD_INT 58
116581: PUSH
116582: EMPTY
116583: LIST
116584: PUSH
116585: EMPTY
116586: LIST
116587: LIST
116588: PPUSH
116589: CALL_OW 72
116593: IN
116594: AND
116595: IFFALSE 116631
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116597: LD_VAR 0 4
116601: PUSH
116602: LD_VAR 0 7
116606: ARRAY
116607: PPUSH
116608: LD_VAR 0 14
116612: PUSH
116613: LD_INT 1
116615: ARRAY
116616: PPUSH
116617: CALL_OW 120
// attacking := true ;
116621: LD_ADDR_VAR 0 29
116625: PUSH
116626: LD_INT 1
116628: ST_TO_ADDR
// continue ;
116629: GO 114804
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116631: LD_VAR 0 26
116635: PUSH
116636: LD_VAR 0 4
116640: PUSH
116641: LD_VAR 0 7
116645: ARRAY
116646: PPUSH
116647: CALL_OW 257
116651: PUSH
116652: LD_INT 1
116654: EQUAL
116655: AND
116656: PUSH
116657: LD_VAR 0 4
116661: PUSH
116662: LD_VAR 0 7
116666: ARRAY
116667: PPUSH
116668: CALL_OW 256
116672: PUSH
116673: LD_INT 800
116675: LESS
116676: AND
116677: PUSH
116678: LD_VAR 0 4
116682: PUSH
116683: LD_VAR 0 7
116687: ARRAY
116688: PPUSH
116689: CALL_OW 318
116693: NOT
116694: AND
116695: IFFALSE 116712
// ComCrawl ( group [ i ] ) ;
116697: LD_VAR 0 4
116701: PUSH
116702: LD_VAR 0 7
116706: ARRAY
116707: PPUSH
116708: CALL_OW 137
// if f_mines then
116712: LD_VAR 0 21
116716: IFFALSE 116959
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116718: LD_VAR 0 14
116722: PUSH
116723: LD_INT 1
116725: ARRAY
116726: PPUSH
116727: CALL_OW 247
116731: PUSH
116732: LD_INT 3
116734: EQUAL
116735: PUSH
116736: LD_VAR 0 14
116740: PUSH
116741: LD_INT 1
116743: ARRAY
116744: PUSH
116745: LD_VAR 0 27
116749: IN
116750: NOT
116751: AND
116752: IFFALSE 116959
// begin x := GetX ( tmp [ 1 ] ) ;
116754: LD_ADDR_VAR 0 10
116758: PUSH
116759: LD_VAR 0 14
116763: PUSH
116764: LD_INT 1
116766: ARRAY
116767: PPUSH
116768: CALL_OW 250
116772: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116773: LD_ADDR_VAR 0 11
116777: PUSH
116778: LD_VAR 0 14
116782: PUSH
116783: LD_INT 1
116785: ARRAY
116786: PPUSH
116787: CALL_OW 251
116791: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116792: LD_ADDR_VAR 0 12
116796: PUSH
116797: LD_VAR 0 4
116801: PUSH
116802: LD_VAR 0 7
116806: ARRAY
116807: PPUSH
116808: CALL 85353 0 1
116812: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116813: LD_VAR 0 4
116817: PUSH
116818: LD_VAR 0 7
116822: ARRAY
116823: PPUSH
116824: LD_VAR 0 10
116828: PPUSH
116829: LD_VAR 0 11
116833: PPUSH
116834: LD_VAR 0 14
116838: PUSH
116839: LD_INT 1
116841: ARRAY
116842: PPUSH
116843: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116847: LD_VAR 0 4
116851: PUSH
116852: LD_VAR 0 7
116856: ARRAY
116857: PPUSH
116858: LD_VAR 0 10
116862: PPUSH
116863: LD_VAR 0 12
116867: PPUSH
116868: LD_INT 7
116870: PPUSH
116871: CALL_OW 272
116875: PPUSH
116876: LD_VAR 0 11
116880: PPUSH
116881: LD_VAR 0 12
116885: PPUSH
116886: LD_INT 7
116888: PPUSH
116889: CALL_OW 273
116893: PPUSH
116894: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116898: LD_VAR 0 4
116902: PUSH
116903: LD_VAR 0 7
116907: ARRAY
116908: PPUSH
116909: LD_INT 71
116911: PPUSH
116912: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116916: LD_ADDR_VAR 0 27
116920: PUSH
116921: LD_VAR 0 27
116925: PPUSH
116926: LD_VAR 0 27
116930: PUSH
116931: LD_INT 1
116933: PLUS
116934: PPUSH
116935: LD_VAR 0 14
116939: PUSH
116940: LD_INT 1
116942: ARRAY
116943: PPUSH
116944: CALL_OW 1
116948: ST_TO_ADDR
// attacking := true ;
116949: LD_ADDR_VAR 0 29
116953: PUSH
116954: LD_INT 1
116956: ST_TO_ADDR
// continue ;
116957: GO 114804
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116959: LD_VAR 0 4
116963: PUSH
116964: LD_VAR 0 7
116968: ARRAY
116969: PPUSH
116970: CALL_OW 257
116974: PUSH
116975: LD_INT 17
116977: EQUAL
116978: PUSH
116979: LD_VAR 0 4
116983: PUSH
116984: LD_VAR 0 7
116988: ARRAY
116989: PPUSH
116990: CALL_OW 110
116994: PUSH
116995: LD_INT 71
116997: EQUAL
116998: NOT
116999: AND
117000: IFFALSE 117146
// begin attacking := false ;
117002: LD_ADDR_VAR 0 29
117006: PUSH
117007: LD_INT 0
117009: ST_TO_ADDR
// k := 5 ;
117010: LD_ADDR_VAR 0 9
117014: PUSH
117015: LD_INT 5
117017: ST_TO_ADDR
// if tmp < k then
117018: LD_VAR 0 14
117022: PUSH
117023: LD_VAR 0 9
117027: LESS
117028: IFFALSE 117040
// k := tmp ;
117030: LD_ADDR_VAR 0 9
117034: PUSH
117035: LD_VAR 0 14
117039: ST_TO_ADDR
// for j = 1 to k do
117040: LD_ADDR_VAR 0 8
117044: PUSH
117045: DOUBLE
117046: LD_INT 1
117048: DEC
117049: ST_TO_ADDR
117050: LD_VAR 0 9
117054: PUSH
117055: FOR_TO
117056: IFFALSE 117144
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
117058: LD_VAR 0 14
117062: PUSH
117063: LD_VAR 0 8
117067: ARRAY
117068: PUSH
117069: LD_VAR 0 14
117073: PPUSH
117074: LD_INT 58
117076: PUSH
117077: EMPTY
117078: LIST
117079: PPUSH
117080: CALL_OW 72
117084: IN
117085: NOT
117086: IFFALSE 117142
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117088: LD_VAR 0 4
117092: PUSH
117093: LD_VAR 0 7
117097: ARRAY
117098: PPUSH
117099: LD_VAR 0 14
117103: PUSH
117104: LD_VAR 0 8
117108: ARRAY
117109: PPUSH
117110: CALL_OW 115
// attacking := true ;
117114: LD_ADDR_VAR 0 29
117118: PUSH
117119: LD_INT 1
117121: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
117122: LD_VAR 0 4
117126: PUSH
117127: LD_VAR 0 7
117131: ARRAY
117132: PPUSH
117133: LD_INT 71
117135: PPUSH
117136: CALL_OW 109
// continue ;
117140: GO 117055
// end ; end ;
117142: GO 117055
117144: POP
117145: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
117146: LD_VAR 0 4
117150: PUSH
117151: LD_VAR 0 7
117155: ARRAY
117156: PPUSH
117157: CALL_OW 257
117161: PUSH
117162: LD_INT 8
117164: EQUAL
117165: PUSH
117166: LD_VAR 0 4
117170: PUSH
117171: LD_VAR 0 7
117175: ARRAY
117176: PPUSH
117177: CALL_OW 264
117181: PUSH
117182: LD_INT 28
117184: PUSH
117185: LD_INT 45
117187: PUSH
117188: LD_INT 7
117190: PUSH
117191: LD_INT 47
117193: PUSH
117194: EMPTY
117195: LIST
117196: LIST
117197: LIST
117198: LIST
117199: IN
117200: OR
117201: IFFALSE 117457
// begin attacking := false ;
117203: LD_ADDR_VAR 0 29
117207: PUSH
117208: LD_INT 0
117210: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
117211: LD_VAR 0 14
117215: PUSH
117216: LD_INT 1
117218: ARRAY
117219: PPUSH
117220: CALL_OW 266
117224: PUSH
117225: LD_INT 32
117227: PUSH
117228: LD_INT 31
117230: PUSH
117231: LD_INT 33
117233: PUSH
117234: LD_INT 4
117236: PUSH
117237: LD_INT 5
117239: PUSH
117240: EMPTY
117241: LIST
117242: LIST
117243: LIST
117244: LIST
117245: LIST
117246: IN
117247: IFFALSE 117433
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117249: LD_ADDR_VAR 0 9
117253: PUSH
117254: LD_VAR 0 14
117258: PUSH
117259: LD_INT 1
117261: ARRAY
117262: PPUSH
117263: CALL_OW 266
117267: PPUSH
117268: LD_VAR 0 14
117272: PUSH
117273: LD_INT 1
117275: ARRAY
117276: PPUSH
117277: CALL_OW 250
117281: PPUSH
117282: LD_VAR 0 14
117286: PUSH
117287: LD_INT 1
117289: ARRAY
117290: PPUSH
117291: CALL_OW 251
117295: PPUSH
117296: LD_VAR 0 14
117300: PUSH
117301: LD_INT 1
117303: ARRAY
117304: PPUSH
117305: CALL_OW 254
117309: PPUSH
117310: LD_VAR 0 14
117314: PUSH
117315: LD_INT 1
117317: ARRAY
117318: PPUSH
117319: CALL_OW 248
117323: PPUSH
117324: LD_INT 0
117326: PPUSH
117327: CALL 66723 0 6
117331: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117332: LD_ADDR_VAR 0 8
117336: PUSH
117337: LD_VAR 0 4
117341: PUSH
117342: LD_VAR 0 7
117346: ARRAY
117347: PPUSH
117348: LD_VAR 0 9
117352: PPUSH
117353: CALL 85466 0 2
117357: ST_TO_ADDR
// if j then
117358: LD_VAR 0 8
117362: IFFALSE 117431
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117364: LD_VAR 0 8
117368: PUSH
117369: LD_INT 1
117371: ARRAY
117372: PPUSH
117373: LD_VAR 0 8
117377: PUSH
117378: LD_INT 2
117380: ARRAY
117381: PPUSH
117382: CALL_OW 488
117386: IFFALSE 117431
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117388: LD_VAR 0 4
117392: PUSH
117393: LD_VAR 0 7
117397: ARRAY
117398: PPUSH
117399: LD_VAR 0 8
117403: PUSH
117404: LD_INT 1
117406: ARRAY
117407: PPUSH
117408: LD_VAR 0 8
117412: PUSH
117413: LD_INT 2
117415: ARRAY
117416: PPUSH
117417: CALL_OW 116
// attacking := true ;
117421: LD_ADDR_VAR 0 29
117425: PUSH
117426: LD_INT 1
117428: ST_TO_ADDR
// continue ;
117429: GO 114804
// end ; end else
117431: GO 117457
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117433: LD_VAR 0 4
117437: PUSH
117438: LD_VAR 0 7
117442: ARRAY
117443: PPUSH
117444: LD_VAR 0 14
117448: PUSH
117449: LD_INT 1
117451: ARRAY
117452: PPUSH
117453: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117457: LD_VAR 0 4
117461: PUSH
117462: LD_VAR 0 7
117466: ARRAY
117467: PPUSH
117468: CALL_OW 265
117472: PUSH
117473: LD_INT 11
117475: EQUAL
117476: IFFALSE 117754
// begin k := 10 ;
117478: LD_ADDR_VAR 0 9
117482: PUSH
117483: LD_INT 10
117485: ST_TO_ADDR
// x := 0 ;
117486: LD_ADDR_VAR 0 10
117490: PUSH
117491: LD_INT 0
117493: ST_TO_ADDR
// if tmp < k then
117494: LD_VAR 0 14
117498: PUSH
117499: LD_VAR 0 9
117503: LESS
117504: IFFALSE 117516
// k := tmp ;
117506: LD_ADDR_VAR 0 9
117510: PUSH
117511: LD_VAR 0 14
117515: ST_TO_ADDR
// for j = k downto 1 do
117516: LD_ADDR_VAR 0 8
117520: PUSH
117521: DOUBLE
117522: LD_VAR 0 9
117526: INC
117527: ST_TO_ADDR
117528: LD_INT 1
117530: PUSH
117531: FOR_DOWNTO
117532: IFFALSE 117607
// begin if GetType ( tmp [ j ] ) = unit_human then
117534: LD_VAR 0 14
117538: PUSH
117539: LD_VAR 0 8
117543: ARRAY
117544: PPUSH
117545: CALL_OW 247
117549: PUSH
117550: LD_INT 1
117552: EQUAL
117553: IFFALSE 117605
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117555: LD_VAR 0 4
117559: PUSH
117560: LD_VAR 0 7
117564: ARRAY
117565: PPUSH
117566: LD_VAR 0 14
117570: PUSH
117571: LD_VAR 0 8
117575: ARRAY
117576: PPUSH
117577: CALL 85720 0 2
// x := tmp [ j ] ;
117581: LD_ADDR_VAR 0 10
117585: PUSH
117586: LD_VAR 0 14
117590: PUSH
117591: LD_VAR 0 8
117595: ARRAY
117596: ST_TO_ADDR
// attacking := true ;
117597: LD_ADDR_VAR 0 29
117601: PUSH
117602: LD_INT 1
117604: ST_TO_ADDR
// end ; end ;
117605: GO 117531
117607: POP
117608: POP
// if not x then
117609: LD_VAR 0 10
117613: NOT
117614: IFFALSE 117754
// begin attacking := true ;
117616: LD_ADDR_VAR 0 29
117620: PUSH
117621: LD_INT 1
117623: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117624: LD_VAR 0 4
117628: PUSH
117629: LD_VAR 0 7
117633: ARRAY
117634: PPUSH
117635: CALL_OW 250
117639: PPUSH
117640: LD_VAR 0 4
117644: PUSH
117645: LD_VAR 0 7
117649: ARRAY
117650: PPUSH
117651: CALL_OW 251
117655: PPUSH
117656: CALL_OW 546
117660: PUSH
117661: LD_INT 2
117663: ARRAY
117664: PUSH
117665: LD_VAR 0 14
117669: PUSH
117670: LD_INT 1
117672: ARRAY
117673: PPUSH
117674: CALL_OW 250
117678: PPUSH
117679: LD_VAR 0 14
117683: PUSH
117684: LD_INT 1
117686: ARRAY
117687: PPUSH
117688: CALL_OW 251
117692: PPUSH
117693: CALL_OW 546
117697: PUSH
117698: LD_INT 2
117700: ARRAY
117701: EQUAL
117702: IFFALSE 117730
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117704: LD_VAR 0 4
117708: PUSH
117709: LD_VAR 0 7
117713: ARRAY
117714: PPUSH
117715: LD_VAR 0 14
117719: PUSH
117720: LD_INT 1
117722: ARRAY
117723: PPUSH
117724: CALL 85720 0 2
117728: GO 117754
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117730: LD_VAR 0 4
117734: PUSH
117735: LD_VAR 0 7
117739: ARRAY
117740: PPUSH
117741: LD_VAR 0 14
117745: PUSH
117746: LD_INT 1
117748: ARRAY
117749: PPUSH
117750: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117754: LD_VAR 0 4
117758: PUSH
117759: LD_VAR 0 7
117763: ARRAY
117764: PPUSH
117765: CALL_OW 264
117769: PUSH
117770: LD_INT 29
117772: EQUAL
117773: IFFALSE 118139
// begin if WantsToAttack ( group [ i ] ) in bombed then
117775: LD_VAR 0 4
117779: PUSH
117780: LD_VAR 0 7
117784: ARRAY
117785: PPUSH
117786: CALL_OW 319
117790: PUSH
117791: LD_VAR 0 28
117795: IN
117796: IFFALSE 117800
// continue ;
117798: GO 114804
// k := 8 ;
117800: LD_ADDR_VAR 0 9
117804: PUSH
117805: LD_INT 8
117807: ST_TO_ADDR
// x := 0 ;
117808: LD_ADDR_VAR 0 10
117812: PUSH
117813: LD_INT 0
117815: ST_TO_ADDR
// if tmp < k then
117816: LD_VAR 0 14
117820: PUSH
117821: LD_VAR 0 9
117825: LESS
117826: IFFALSE 117838
// k := tmp ;
117828: LD_ADDR_VAR 0 9
117832: PUSH
117833: LD_VAR 0 14
117837: ST_TO_ADDR
// for j = 1 to k do
117838: LD_ADDR_VAR 0 8
117842: PUSH
117843: DOUBLE
117844: LD_INT 1
117846: DEC
117847: ST_TO_ADDR
117848: LD_VAR 0 9
117852: PUSH
117853: FOR_TO
117854: IFFALSE 117986
// begin if GetType ( tmp [ j ] ) = unit_building then
117856: LD_VAR 0 14
117860: PUSH
117861: LD_VAR 0 8
117865: ARRAY
117866: PPUSH
117867: CALL_OW 247
117871: PUSH
117872: LD_INT 3
117874: EQUAL
117875: IFFALSE 117984
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117877: LD_VAR 0 14
117881: PUSH
117882: LD_VAR 0 8
117886: ARRAY
117887: PUSH
117888: LD_VAR 0 28
117892: IN
117893: NOT
117894: PUSH
117895: LD_VAR 0 14
117899: PUSH
117900: LD_VAR 0 8
117904: ARRAY
117905: PPUSH
117906: CALL_OW 313
117910: AND
117911: IFFALSE 117984
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117913: LD_VAR 0 4
117917: PUSH
117918: LD_VAR 0 7
117922: ARRAY
117923: PPUSH
117924: LD_VAR 0 14
117928: PUSH
117929: LD_VAR 0 8
117933: ARRAY
117934: PPUSH
117935: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117939: LD_ADDR_VAR 0 28
117943: PUSH
117944: LD_VAR 0 28
117948: PPUSH
117949: LD_VAR 0 28
117953: PUSH
117954: LD_INT 1
117956: PLUS
117957: PPUSH
117958: LD_VAR 0 14
117962: PUSH
117963: LD_VAR 0 8
117967: ARRAY
117968: PPUSH
117969: CALL_OW 1
117973: ST_TO_ADDR
// attacking := true ;
117974: LD_ADDR_VAR 0 29
117978: PUSH
117979: LD_INT 1
117981: ST_TO_ADDR
// break ;
117982: GO 117986
// end ; end ;
117984: GO 117853
117986: POP
117987: POP
// if not attacking and f_attack_depot then
117988: LD_VAR 0 29
117992: NOT
117993: PUSH
117994: LD_VAR 0 25
117998: AND
117999: IFFALSE 118094
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118001: LD_ADDR_VAR 0 13
118005: PUSH
118006: LD_VAR 0 14
118010: PPUSH
118011: LD_INT 2
118013: PUSH
118014: LD_INT 30
118016: PUSH
118017: LD_INT 0
118019: PUSH
118020: EMPTY
118021: LIST
118022: LIST
118023: PUSH
118024: LD_INT 30
118026: PUSH
118027: LD_INT 1
118029: PUSH
118030: EMPTY
118031: LIST
118032: LIST
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: LIST
118038: PPUSH
118039: CALL_OW 72
118043: ST_TO_ADDR
// if z then
118044: LD_VAR 0 13
118048: IFFALSE 118094
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
118050: LD_VAR 0 4
118054: PUSH
118055: LD_VAR 0 7
118059: ARRAY
118060: PPUSH
118061: LD_VAR 0 13
118065: PPUSH
118066: LD_VAR 0 4
118070: PUSH
118071: LD_VAR 0 7
118075: ARRAY
118076: PPUSH
118077: CALL_OW 74
118081: PPUSH
118082: CALL_OW 115
// attacking := true ;
118086: LD_ADDR_VAR 0 29
118090: PUSH
118091: LD_INT 1
118093: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
118094: LD_VAR 0 4
118098: PUSH
118099: LD_VAR 0 7
118103: ARRAY
118104: PPUSH
118105: CALL_OW 256
118109: PUSH
118110: LD_INT 500
118112: LESS
118113: IFFALSE 118139
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118115: LD_VAR 0 4
118119: PUSH
118120: LD_VAR 0 7
118124: ARRAY
118125: PPUSH
118126: LD_VAR 0 14
118130: PUSH
118131: LD_INT 1
118133: ARRAY
118134: PPUSH
118135: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
118139: LD_VAR 0 4
118143: PUSH
118144: LD_VAR 0 7
118148: ARRAY
118149: PPUSH
118150: CALL_OW 264
118154: PUSH
118155: LD_INT 49
118157: EQUAL
118158: IFFALSE 118279
// begin if not HasTask ( group [ i ] ) then
118160: LD_VAR 0 4
118164: PUSH
118165: LD_VAR 0 7
118169: ARRAY
118170: PPUSH
118171: CALL_OW 314
118175: NOT
118176: IFFALSE 118279
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
118178: LD_ADDR_VAR 0 9
118182: PUSH
118183: LD_INT 81
118185: PUSH
118186: LD_VAR 0 4
118190: PUSH
118191: LD_VAR 0 7
118195: ARRAY
118196: PPUSH
118197: CALL_OW 255
118201: PUSH
118202: EMPTY
118203: LIST
118204: LIST
118205: PPUSH
118206: CALL_OW 69
118210: PPUSH
118211: LD_VAR 0 4
118215: PUSH
118216: LD_VAR 0 7
118220: ARRAY
118221: PPUSH
118222: CALL_OW 74
118226: ST_TO_ADDR
// if k then
118227: LD_VAR 0 9
118231: IFFALSE 118279
// if GetDistUnits ( group [ i ] , k ) > 10 then
118233: LD_VAR 0 4
118237: PUSH
118238: LD_VAR 0 7
118242: ARRAY
118243: PPUSH
118244: LD_VAR 0 9
118248: PPUSH
118249: CALL_OW 296
118253: PUSH
118254: LD_INT 10
118256: GREATER
118257: IFFALSE 118279
// ComMoveUnit ( group [ i ] , k ) ;
118259: LD_VAR 0 4
118263: PUSH
118264: LD_VAR 0 7
118268: ARRAY
118269: PPUSH
118270: LD_VAR 0 9
118274: PPUSH
118275: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118279: LD_VAR 0 4
118283: PUSH
118284: LD_VAR 0 7
118288: ARRAY
118289: PPUSH
118290: CALL_OW 256
118294: PUSH
118295: LD_INT 250
118297: LESS
118298: PUSH
118299: LD_VAR 0 4
118303: PUSH
118304: LD_VAR 0 7
118308: ARRAY
118309: PUSH
118310: LD_INT 21
118312: PUSH
118313: LD_INT 2
118315: PUSH
118316: EMPTY
118317: LIST
118318: LIST
118319: PUSH
118320: LD_INT 23
118322: PUSH
118323: LD_INT 2
118325: PUSH
118326: EMPTY
118327: LIST
118328: LIST
118329: PUSH
118330: EMPTY
118331: LIST
118332: LIST
118333: PPUSH
118334: CALL_OW 69
118338: IN
118339: AND
118340: IFFALSE 118465
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118342: LD_ADDR_VAR 0 9
118346: PUSH
118347: LD_OWVAR 3
118351: PUSH
118352: LD_VAR 0 4
118356: PUSH
118357: LD_VAR 0 7
118361: ARRAY
118362: DIFF
118363: PPUSH
118364: LD_VAR 0 4
118368: PUSH
118369: LD_VAR 0 7
118373: ARRAY
118374: PPUSH
118375: CALL_OW 74
118379: ST_TO_ADDR
// if not k then
118380: LD_VAR 0 9
118384: NOT
118385: IFFALSE 118389
// continue ;
118387: GO 114804
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118389: LD_VAR 0 9
118393: PUSH
118394: LD_INT 81
118396: PUSH
118397: LD_VAR 0 4
118401: PUSH
118402: LD_VAR 0 7
118406: ARRAY
118407: PPUSH
118408: CALL_OW 255
118412: PUSH
118413: EMPTY
118414: LIST
118415: LIST
118416: PPUSH
118417: CALL_OW 69
118421: IN
118422: PUSH
118423: LD_VAR 0 9
118427: PPUSH
118428: LD_VAR 0 4
118432: PUSH
118433: LD_VAR 0 7
118437: ARRAY
118438: PPUSH
118439: CALL_OW 296
118443: PUSH
118444: LD_INT 5
118446: LESS
118447: AND
118448: IFFALSE 118465
// ComAutodestruct ( group [ i ] ) ;
118450: LD_VAR 0 4
118454: PUSH
118455: LD_VAR 0 7
118459: ARRAY
118460: PPUSH
118461: CALL 85618 0 1
// end ; if f_attack_depot then
118465: LD_VAR 0 25
118469: IFFALSE 118581
// begin k := 6 ;
118471: LD_ADDR_VAR 0 9
118475: PUSH
118476: LD_INT 6
118478: ST_TO_ADDR
// if tmp < k then
118479: LD_VAR 0 14
118483: PUSH
118484: LD_VAR 0 9
118488: LESS
118489: IFFALSE 118501
// k := tmp ;
118491: LD_ADDR_VAR 0 9
118495: PUSH
118496: LD_VAR 0 14
118500: ST_TO_ADDR
// for j = 1 to k do
118501: LD_ADDR_VAR 0 8
118505: PUSH
118506: DOUBLE
118507: LD_INT 1
118509: DEC
118510: ST_TO_ADDR
118511: LD_VAR 0 9
118515: PUSH
118516: FOR_TO
118517: IFFALSE 118579
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118519: LD_VAR 0 8
118523: PPUSH
118524: CALL_OW 266
118528: PUSH
118529: LD_INT 0
118531: PUSH
118532: LD_INT 1
118534: PUSH
118535: EMPTY
118536: LIST
118537: LIST
118538: IN
118539: IFFALSE 118577
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118541: LD_VAR 0 4
118545: PUSH
118546: LD_VAR 0 7
118550: ARRAY
118551: PPUSH
118552: LD_VAR 0 14
118556: PUSH
118557: LD_VAR 0 8
118561: ARRAY
118562: PPUSH
118563: CALL_OW 115
// attacking := true ;
118567: LD_ADDR_VAR 0 29
118571: PUSH
118572: LD_INT 1
118574: ST_TO_ADDR
// break ;
118575: GO 118579
// end ;
118577: GO 118516
118579: POP
118580: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118581: LD_VAR 0 4
118585: PUSH
118586: LD_VAR 0 7
118590: ARRAY
118591: PPUSH
118592: CALL_OW 302
118596: PUSH
118597: LD_VAR 0 29
118601: NOT
118602: AND
118603: IFFALSE 118925
// begin if GetTag ( group [ i ] ) = 71 then
118605: LD_VAR 0 4
118609: PUSH
118610: LD_VAR 0 7
118614: ARRAY
118615: PPUSH
118616: CALL_OW 110
118620: PUSH
118621: LD_INT 71
118623: EQUAL
118624: IFFALSE 118665
// begin if HasTask ( group [ i ] ) then
118626: LD_VAR 0 4
118630: PUSH
118631: LD_VAR 0 7
118635: ARRAY
118636: PPUSH
118637: CALL_OW 314
118641: IFFALSE 118647
// continue else
118643: GO 114804
118645: GO 118665
// SetTag ( group [ i ] , 0 ) ;
118647: LD_VAR 0 4
118651: PUSH
118652: LD_VAR 0 7
118656: ARRAY
118657: PPUSH
118658: LD_INT 0
118660: PPUSH
118661: CALL_OW 109
// end ; k := 8 ;
118665: LD_ADDR_VAR 0 9
118669: PUSH
118670: LD_INT 8
118672: ST_TO_ADDR
// x := 0 ;
118673: LD_ADDR_VAR 0 10
118677: PUSH
118678: LD_INT 0
118680: ST_TO_ADDR
// if tmp < k then
118681: LD_VAR 0 14
118685: PUSH
118686: LD_VAR 0 9
118690: LESS
118691: IFFALSE 118703
// k := tmp ;
118693: LD_ADDR_VAR 0 9
118697: PUSH
118698: LD_VAR 0 14
118702: ST_TO_ADDR
// for j = 1 to k do
118703: LD_ADDR_VAR 0 8
118707: PUSH
118708: DOUBLE
118709: LD_INT 1
118711: DEC
118712: ST_TO_ADDR
118713: LD_VAR 0 9
118717: PUSH
118718: FOR_TO
118719: IFFALSE 118817
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118721: LD_VAR 0 14
118725: PUSH
118726: LD_VAR 0 8
118730: ARRAY
118731: PPUSH
118732: CALL_OW 247
118736: PUSH
118737: LD_INT 1
118739: EQUAL
118740: PUSH
118741: LD_VAR 0 14
118745: PUSH
118746: LD_VAR 0 8
118750: ARRAY
118751: PPUSH
118752: CALL_OW 256
118756: PUSH
118757: LD_INT 250
118759: LESS
118760: PUSH
118761: LD_VAR 0 20
118765: AND
118766: PUSH
118767: LD_VAR 0 20
118771: NOT
118772: PUSH
118773: LD_VAR 0 14
118777: PUSH
118778: LD_VAR 0 8
118782: ARRAY
118783: PPUSH
118784: CALL_OW 256
118788: PUSH
118789: LD_INT 250
118791: GREATEREQUAL
118792: AND
118793: OR
118794: AND
118795: IFFALSE 118815
// begin x := tmp [ j ] ;
118797: LD_ADDR_VAR 0 10
118801: PUSH
118802: LD_VAR 0 14
118806: PUSH
118807: LD_VAR 0 8
118811: ARRAY
118812: ST_TO_ADDR
// break ;
118813: GO 118817
// end ;
118815: GO 118718
118817: POP
118818: POP
// if x then
118819: LD_VAR 0 10
118823: IFFALSE 118847
// ComAttackUnit ( group [ i ] , x ) else
118825: LD_VAR 0 4
118829: PUSH
118830: LD_VAR 0 7
118834: ARRAY
118835: PPUSH
118836: LD_VAR 0 10
118840: PPUSH
118841: CALL_OW 115
118845: GO 118871
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118847: LD_VAR 0 4
118851: PUSH
118852: LD_VAR 0 7
118856: ARRAY
118857: PPUSH
118858: LD_VAR 0 14
118862: PUSH
118863: LD_INT 1
118865: ARRAY
118866: PPUSH
118867: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118871: LD_VAR 0 4
118875: PUSH
118876: LD_VAR 0 7
118880: ARRAY
118881: PPUSH
118882: CALL_OW 314
118886: NOT
118887: IFFALSE 118925
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118889: LD_VAR 0 4
118893: PUSH
118894: LD_VAR 0 7
118898: ARRAY
118899: PPUSH
118900: LD_VAR 0 14
118904: PPUSH
118905: LD_VAR 0 4
118909: PUSH
118910: LD_VAR 0 7
118914: ARRAY
118915: PPUSH
118916: CALL_OW 74
118920: PPUSH
118921: CALL_OW 115
// end ; end ; end ;
118925: GO 114804
118927: POP
118928: POP
// wait ( 0 0$2 ) ;
118929: LD_INT 70
118931: PPUSH
118932: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118936: LD_VAR 0 4
118940: NOT
118941: PUSH
118942: LD_VAR 0 4
118946: PUSH
118947: EMPTY
118948: EQUAL
118949: OR
118950: PUSH
118951: LD_INT 81
118953: PUSH
118954: LD_VAR 0 35
118958: PUSH
118959: EMPTY
118960: LIST
118961: LIST
118962: PPUSH
118963: CALL_OW 69
118967: NOT
118968: OR
118969: IFFALSE 114789
// end ;
118971: LD_VAR 0 2
118975: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118976: LD_INT 0
118978: PPUSH
118979: PPUSH
118980: PPUSH
118981: PPUSH
118982: PPUSH
118983: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118984: LD_VAR 0 1
118988: NOT
118989: PUSH
118990: LD_EXP 78
118994: PUSH
118995: LD_VAR 0 1
118999: ARRAY
119000: NOT
119001: OR
119002: PUSH
119003: LD_VAR 0 2
119007: NOT
119008: OR
119009: IFFALSE 119013
// exit ;
119011: GO 119567
// side := mc_sides [ base ] ;
119013: LD_ADDR_VAR 0 6
119017: PUSH
119018: LD_EXP 104
119022: PUSH
119023: LD_VAR 0 1
119027: ARRAY
119028: ST_TO_ADDR
// if not side then
119029: LD_VAR 0 6
119033: NOT
119034: IFFALSE 119038
// exit ;
119036: GO 119567
// for i in solds do
119038: LD_ADDR_VAR 0 7
119042: PUSH
119043: LD_VAR 0 2
119047: PUSH
119048: FOR_IN
119049: IFFALSE 119110
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
119051: LD_VAR 0 7
119055: PPUSH
119056: CALL_OW 310
119060: PPUSH
119061: CALL_OW 266
119065: PUSH
119066: LD_INT 32
119068: PUSH
119069: LD_INT 31
119071: PUSH
119072: EMPTY
119073: LIST
119074: LIST
119075: IN
119076: IFFALSE 119096
// solds := solds diff i else
119078: LD_ADDR_VAR 0 2
119082: PUSH
119083: LD_VAR 0 2
119087: PUSH
119088: LD_VAR 0 7
119092: DIFF
119093: ST_TO_ADDR
119094: GO 119108
// SetTag ( i , 18 ) ;
119096: LD_VAR 0 7
119100: PPUSH
119101: LD_INT 18
119103: PPUSH
119104: CALL_OW 109
119108: GO 119048
119110: POP
119111: POP
// if not solds then
119112: LD_VAR 0 2
119116: NOT
119117: IFFALSE 119121
// exit ;
119119: GO 119567
// repeat wait ( 0 0$2 ) ;
119121: LD_INT 70
119123: PPUSH
119124: CALL_OW 67
// enemy := mc_scan [ base ] ;
119128: LD_ADDR_VAR 0 4
119132: PUSH
119133: LD_EXP 101
119137: PUSH
119138: LD_VAR 0 1
119142: ARRAY
119143: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119144: LD_EXP 78
119148: PUSH
119149: LD_VAR 0 1
119153: ARRAY
119154: NOT
119155: PUSH
119156: LD_EXP 78
119160: PUSH
119161: LD_VAR 0 1
119165: ARRAY
119166: PUSH
119167: EMPTY
119168: EQUAL
119169: OR
119170: IFFALSE 119207
// begin for i in solds do
119172: LD_ADDR_VAR 0 7
119176: PUSH
119177: LD_VAR 0 2
119181: PUSH
119182: FOR_IN
119183: IFFALSE 119196
// ComStop ( i ) ;
119185: LD_VAR 0 7
119189: PPUSH
119190: CALL_OW 141
119194: GO 119182
119196: POP
119197: POP
// solds := [ ] ;
119198: LD_ADDR_VAR 0 2
119202: PUSH
119203: EMPTY
119204: ST_TO_ADDR
// exit ;
119205: GO 119567
// end ; for i in solds do
119207: LD_ADDR_VAR 0 7
119211: PUSH
119212: LD_VAR 0 2
119216: PUSH
119217: FOR_IN
119218: IFFALSE 119539
// begin if IsInUnit ( i ) then
119220: LD_VAR 0 7
119224: PPUSH
119225: CALL_OW 310
119229: IFFALSE 119240
// ComExitBuilding ( i ) ;
119231: LD_VAR 0 7
119235: PPUSH
119236: CALL_OW 122
// if GetLives ( i ) > 500 then
119240: LD_VAR 0 7
119244: PPUSH
119245: CALL_OW 256
119249: PUSH
119250: LD_INT 500
119252: GREATER
119253: IFFALSE 119306
// begin e := NearestUnitToUnit ( enemy , i ) ;
119255: LD_ADDR_VAR 0 5
119259: PUSH
119260: LD_VAR 0 4
119264: PPUSH
119265: LD_VAR 0 7
119269: PPUSH
119270: CALL_OW 74
119274: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119275: LD_VAR 0 7
119279: PPUSH
119280: LD_VAR 0 5
119284: PPUSH
119285: CALL_OW 250
119289: PPUSH
119290: LD_VAR 0 5
119294: PPUSH
119295: CALL_OW 251
119299: PPUSH
119300: CALL_OW 114
// end else
119304: GO 119537
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119306: LD_VAR 0 7
119310: PPUSH
119311: LD_EXP 78
119315: PUSH
119316: LD_VAR 0 1
119320: ARRAY
119321: PPUSH
119322: LD_INT 2
119324: PUSH
119325: LD_INT 30
119327: PUSH
119328: LD_INT 0
119330: PUSH
119331: EMPTY
119332: LIST
119333: LIST
119334: PUSH
119335: LD_INT 30
119337: PUSH
119338: LD_INT 1
119340: PUSH
119341: EMPTY
119342: LIST
119343: LIST
119344: PUSH
119345: LD_INT 30
119347: PUSH
119348: LD_INT 6
119350: PUSH
119351: EMPTY
119352: LIST
119353: LIST
119354: PUSH
119355: EMPTY
119356: LIST
119357: LIST
119358: LIST
119359: LIST
119360: PPUSH
119361: CALL_OW 72
119365: PPUSH
119366: LD_VAR 0 7
119370: PPUSH
119371: CALL_OW 74
119375: PPUSH
119376: CALL_OW 296
119380: PUSH
119381: LD_INT 10
119383: GREATER
119384: IFFALSE 119537
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119386: LD_ADDR_VAR 0 8
119390: PUSH
119391: LD_EXP 78
119395: PUSH
119396: LD_VAR 0 1
119400: ARRAY
119401: PPUSH
119402: LD_INT 2
119404: PUSH
119405: LD_INT 30
119407: PUSH
119408: LD_INT 0
119410: PUSH
119411: EMPTY
119412: LIST
119413: LIST
119414: PUSH
119415: LD_INT 30
119417: PUSH
119418: LD_INT 1
119420: PUSH
119421: EMPTY
119422: LIST
119423: LIST
119424: PUSH
119425: LD_INT 30
119427: PUSH
119428: LD_INT 6
119430: PUSH
119431: EMPTY
119432: LIST
119433: LIST
119434: PUSH
119435: EMPTY
119436: LIST
119437: LIST
119438: LIST
119439: LIST
119440: PPUSH
119441: CALL_OW 72
119445: PPUSH
119446: LD_VAR 0 7
119450: PPUSH
119451: CALL_OW 74
119455: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119456: LD_VAR 0 7
119460: PPUSH
119461: LD_VAR 0 8
119465: PPUSH
119466: CALL_OW 250
119470: PPUSH
119471: LD_INT 3
119473: PPUSH
119474: LD_INT 5
119476: PPUSH
119477: CALL_OW 272
119481: PPUSH
119482: LD_VAR 0 8
119486: PPUSH
119487: CALL_OW 251
119491: PPUSH
119492: LD_INT 3
119494: PPUSH
119495: LD_INT 5
119497: PPUSH
119498: CALL_OW 273
119502: PPUSH
119503: CALL_OW 111
// SetTag ( i , 0 ) ;
119507: LD_VAR 0 7
119511: PPUSH
119512: LD_INT 0
119514: PPUSH
119515: CALL_OW 109
// solds := solds diff i ;
119519: LD_ADDR_VAR 0 2
119523: PUSH
119524: LD_VAR 0 2
119528: PUSH
119529: LD_VAR 0 7
119533: DIFF
119534: ST_TO_ADDR
// continue ;
119535: GO 119217
// end ; end ;
119537: GO 119217
119539: POP
119540: POP
// until not solds or not enemy ;
119541: LD_VAR 0 2
119545: NOT
119546: PUSH
119547: LD_VAR 0 4
119551: NOT
119552: OR
119553: IFFALSE 119121
// MC_Reset ( base , 18 ) ;
119555: LD_VAR 0 1
119559: PPUSH
119560: LD_INT 18
119562: PPUSH
119563: CALL 26287 0 2
// end ;
119567: LD_VAR 0 3
119571: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119572: LD_INT 0
119574: PPUSH
119575: PPUSH
119576: PPUSH
119577: PPUSH
119578: PPUSH
119579: PPUSH
119580: PPUSH
119581: PPUSH
119582: PPUSH
119583: PPUSH
119584: PPUSH
119585: PPUSH
119586: PPUSH
119587: PPUSH
119588: PPUSH
119589: PPUSH
119590: PPUSH
119591: PPUSH
119592: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119593: LD_ADDR_VAR 0 12
119597: PUSH
119598: LD_EXP 78
119602: PUSH
119603: LD_VAR 0 1
119607: ARRAY
119608: PPUSH
119609: LD_INT 25
119611: PUSH
119612: LD_INT 3
119614: PUSH
119615: EMPTY
119616: LIST
119617: LIST
119618: PPUSH
119619: CALL_OW 72
119623: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119624: LD_EXP 118
119628: PUSH
119629: LD_VAR 0 1
119633: ARRAY
119634: IFFALSE 119658
// mechs := mechs diff mc_remote_driver [ base ] ;
119636: LD_ADDR_VAR 0 12
119640: PUSH
119641: LD_VAR 0 12
119645: PUSH
119646: LD_EXP 118
119650: PUSH
119651: LD_VAR 0 1
119655: ARRAY
119656: DIFF
119657: ST_TO_ADDR
// for i in mechs do
119658: LD_ADDR_VAR 0 4
119662: PUSH
119663: LD_VAR 0 12
119667: PUSH
119668: FOR_IN
119669: IFFALSE 119704
// if GetTag ( i ) > 0 then
119671: LD_VAR 0 4
119675: PPUSH
119676: CALL_OW 110
119680: PUSH
119681: LD_INT 0
119683: GREATER
119684: IFFALSE 119702
// mechs := mechs diff i ;
119686: LD_ADDR_VAR 0 12
119690: PUSH
119691: LD_VAR 0 12
119695: PUSH
119696: LD_VAR 0 4
119700: DIFF
119701: ST_TO_ADDR
119702: GO 119668
119704: POP
119705: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119706: LD_ADDR_VAR 0 8
119710: PUSH
119711: LD_EXP 78
119715: PUSH
119716: LD_VAR 0 1
119720: ARRAY
119721: PPUSH
119722: LD_INT 2
119724: PUSH
119725: LD_INT 25
119727: PUSH
119728: LD_INT 1
119730: PUSH
119731: EMPTY
119732: LIST
119733: LIST
119734: PUSH
119735: LD_INT 25
119737: PUSH
119738: LD_INT 5
119740: PUSH
119741: EMPTY
119742: LIST
119743: LIST
119744: PUSH
119745: LD_INT 25
119747: PUSH
119748: LD_INT 8
119750: PUSH
119751: EMPTY
119752: LIST
119753: LIST
119754: PUSH
119755: LD_INT 25
119757: PUSH
119758: LD_INT 9
119760: PUSH
119761: EMPTY
119762: LIST
119763: LIST
119764: PUSH
119765: EMPTY
119766: LIST
119767: LIST
119768: LIST
119769: LIST
119770: LIST
119771: PPUSH
119772: CALL_OW 72
119776: ST_TO_ADDR
// if not defenders and not solds then
119777: LD_VAR 0 2
119781: NOT
119782: PUSH
119783: LD_VAR 0 8
119787: NOT
119788: AND
119789: IFFALSE 119793
// exit ;
119791: GO 121563
// depot_under_attack := false ;
119793: LD_ADDR_VAR 0 16
119797: PUSH
119798: LD_INT 0
119800: ST_TO_ADDR
// sold_defenders := [ ] ;
119801: LD_ADDR_VAR 0 17
119805: PUSH
119806: EMPTY
119807: ST_TO_ADDR
// if mechs then
119808: LD_VAR 0 12
119812: IFFALSE 119965
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119814: LD_ADDR_VAR 0 4
119818: PUSH
119819: LD_VAR 0 2
119823: PPUSH
119824: LD_INT 21
119826: PUSH
119827: LD_INT 2
119829: PUSH
119830: EMPTY
119831: LIST
119832: LIST
119833: PPUSH
119834: CALL_OW 72
119838: PUSH
119839: FOR_IN
119840: IFFALSE 119963
// begin if GetTag ( i ) <> 20 then
119842: LD_VAR 0 4
119846: PPUSH
119847: CALL_OW 110
119851: PUSH
119852: LD_INT 20
119854: NONEQUAL
119855: IFFALSE 119869
// SetTag ( i , 20 ) ;
119857: LD_VAR 0 4
119861: PPUSH
119862: LD_INT 20
119864: PPUSH
119865: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119869: LD_VAR 0 4
119873: PPUSH
119874: CALL_OW 263
119878: PUSH
119879: LD_INT 1
119881: EQUAL
119882: PUSH
119883: LD_VAR 0 4
119887: PPUSH
119888: CALL_OW 311
119892: NOT
119893: AND
119894: IFFALSE 119961
// begin un := mechs [ 1 ] ;
119896: LD_ADDR_VAR 0 10
119900: PUSH
119901: LD_VAR 0 12
119905: PUSH
119906: LD_INT 1
119908: ARRAY
119909: ST_TO_ADDR
// ComExit ( un ) ;
119910: LD_VAR 0 10
119914: PPUSH
119915: CALL 90502 0 1
// AddComEnterUnit ( un , i ) ;
119919: LD_VAR 0 10
119923: PPUSH
119924: LD_VAR 0 4
119928: PPUSH
119929: CALL_OW 180
// SetTag ( un , 19 ) ;
119933: LD_VAR 0 10
119937: PPUSH
119938: LD_INT 19
119940: PPUSH
119941: CALL_OW 109
// mechs := mechs diff un ;
119945: LD_ADDR_VAR 0 12
119949: PUSH
119950: LD_VAR 0 12
119954: PUSH
119955: LD_VAR 0 10
119959: DIFF
119960: ST_TO_ADDR
// end ; end ;
119961: GO 119839
119963: POP
119964: POP
// if solds then
119965: LD_VAR 0 8
119969: IFFALSE 120028
// for i in solds do
119971: LD_ADDR_VAR 0 4
119975: PUSH
119976: LD_VAR 0 8
119980: PUSH
119981: FOR_IN
119982: IFFALSE 120026
// if not GetTag ( i ) then
119984: LD_VAR 0 4
119988: PPUSH
119989: CALL_OW 110
119993: NOT
119994: IFFALSE 120024
// begin defenders := defenders union i ;
119996: LD_ADDR_VAR 0 2
120000: PUSH
120001: LD_VAR 0 2
120005: PUSH
120006: LD_VAR 0 4
120010: UNION
120011: ST_TO_ADDR
// SetTag ( i , 18 ) ;
120012: LD_VAR 0 4
120016: PPUSH
120017: LD_INT 18
120019: PPUSH
120020: CALL_OW 109
// end ;
120024: GO 119981
120026: POP
120027: POP
// repeat wait ( 0 0$2 ) ;
120028: LD_INT 70
120030: PPUSH
120031: CALL_OW 67
// enemy := mc_scan [ base ] ;
120035: LD_ADDR_VAR 0 21
120039: PUSH
120040: LD_EXP 101
120044: PUSH
120045: LD_VAR 0 1
120049: ARRAY
120050: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120051: LD_EXP 78
120055: PUSH
120056: LD_VAR 0 1
120060: ARRAY
120061: NOT
120062: PUSH
120063: LD_EXP 78
120067: PUSH
120068: LD_VAR 0 1
120072: ARRAY
120073: PUSH
120074: EMPTY
120075: EQUAL
120076: OR
120077: IFFALSE 120114
// begin for i in defenders do
120079: LD_ADDR_VAR 0 4
120083: PUSH
120084: LD_VAR 0 2
120088: PUSH
120089: FOR_IN
120090: IFFALSE 120103
// ComStop ( i ) ;
120092: LD_VAR 0 4
120096: PPUSH
120097: CALL_OW 141
120101: GO 120089
120103: POP
120104: POP
// defenders := [ ] ;
120105: LD_ADDR_VAR 0 2
120109: PUSH
120110: EMPTY
120111: ST_TO_ADDR
// exit ;
120112: GO 121563
// end ; for i in defenders do
120114: LD_ADDR_VAR 0 4
120118: PUSH
120119: LD_VAR 0 2
120123: PUSH
120124: FOR_IN
120125: IFFALSE 121023
// begin e := NearestUnitToUnit ( enemy , i ) ;
120127: LD_ADDR_VAR 0 13
120131: PUSH
120132: LD_VAR 0 21
120136: PPUSH
120137: LD_VAR 0 4
120141: PPUSH
120142: CALL_OW 74
120146: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120147: LD_ADDR_VAR 0 7
120151: PUSH
120152: LD_EXP 78
120156: PUSH
120157: LD_VAR 0 1
120161: ARRAY
120162: PPUSH
120163: LD_INT 2
120165: PUSH
120166: LD_INT 30
120168: PUSH
120169: LD_INT 0
120171: PUSH
120172: EMPTY
120173: LIST
120174: LIST
120175: PUSH
120176: LD_INT 30
120178: PUSH
120179: LD_INT 1
120181: PUSH
120182: EMPTY
120183: LIST
120184: LIST
120185: PUSH
120186: EMPTY
120187: LIST
120188: LIST
120189: LIST
120190: PPUSH
120191: CALL_OW 72
120195: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
120196: LD_ADDR_VAR 0 16
120200: PUSH
120201: LD_VAR 0 7
120205: NOT
120206: PUSH
120207: LD_VAR 0 7
120211: PPUSH
120212: LD_INT 3
120214: PUSH
120215: LD_INT 24
120217: PUSH
120218: LD_INT 600
120220: PUSH
120221: EMPTY
120222: LIST
120223: LIST
120224: PUSH
120225: EMPTY
120226: LIST
120227: LIST
120228: PPUSH
120229: CALL_OW 72
120233: OR
120234: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
120235: LD_VAR 0 4
120239: PPUSH
120240: CALL_OW 247
120244: PUSH
120245: LD_INT 2
120247: DOUBLE
120248: EQUAL
120249: IFTRUE 120253
120251: GO 120649
120253: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120254: LD_VAR 0 4
120258: PPUSH
120259: CALL_OW 256
120263: PUSH
120264: LD_INT 1000
120266: EQUAL
120267: PUSH
120268: LD_VAR 0 4
120272: PPUSH
120273: LD_VAR 0 13
120277: PPUSH
120278: CALL_OW 296
120282: PUSH
120283: LD_INT 40
120285: LESS
120286: PUSH
120287: LD_VAR 0 13
120291: PPUSH
120292: LD_EXP 103
120296: PUSH
120297: LD_VAR 0 1
120301: ARRAY
120302: PPUSH
120303: CALL_OW 308
120307: OR
120308: AND
120309: IFFALSE 120431
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120311: LD_VAR 0 4
120315: PPUSH
120316: CALL_OW 262
120320: PUSH
120321: LD_INT 1
120323: EQUAL
120324: PUSH
120325: LD_VAR 0 4
120329: PPUSH
120330: CALL_OW 261
120334: PUSH
120335: LD_INT 30
120337: LESS
120338: AND
120339: PUSH
120340: LD_VAR 0 7
120344: AND
120345: IFFALSE 120415
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120347: LD_VAR 0 4
120351: PPUSH
120352: LD_VAR 0 7
120356: PPUSH
120357: LD_VAR 0 4
120361: PPUSH
120362: CALL_OW 74
120366: PPUSH
120367: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120371: LD_VAR 0 4
120375: PPUSH
120376: LD_VAR 0 7
120380: PPUSH
120381: LD_VAR 0 4
120385: PPUSH
120386: CALL_OW 74
120390: PPUSH
120391: CALL_OW 296
120395: PUSH
120396: LD_INT 6
120398: LESS
120399: IFFALSE 120413
// SetFuel ( i , 100 ) ;
120401: LD_VAR 0 4
120405: PPUSH
120406: LD_INT 100
120408: PPUSH
120409: CALL_OW 240
// end else
120413: GO 120429
// ComAttackUnit ( i , e ) ;
120415: LD_VAR 0 4
120419: PPUSH
120420: LD_VAR 0 13
120424: PPUSH
120425: CALL_OW 115
// end else
120429: GO 120532
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120431: LD_VAR 0 13
120435: PPUSH
120436: LD_EXP 103
120440: PUSH
120441: LD_VAR 0 1
120445: ARRAY
120446: PPUSH
120447: CALL_OW 308
120451: NOT
120452: PUSH
120453: LD_VAR 0 4
120457: PPUSH
120458: LD_VAR 0 13
120462: PPUSH
120463: CALL_OW 296
120467: PUSH
120468: LD_INT 40
120470: GREATEREQUAL
120471: AND
120472: PUSH
120473: LD_VAR 0 4
120477: PPUSH
120478: CALL_OW 256
120482: PUSH
120483: LD_INT 650
120485: LESSEQUAL
120486: OR
120487: PUSH
120488: LD_VAR 0 4
120492: PPUSH
120493: LD_EXP 102
120497: PUSH
120498: LD_VAR 0 1
120502: ARRAY
120503: PPUSH
120504: CALL_OW 308
120508: NOT
120509: AND
120510: IFFALSE 120532
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120512: LD_VAR 0 4
120516: PPUSH
120517: LD_EXP 102
120521: PUSH
120522: LD_VAR 0 1
120526: ARRAY
120527: PPUSH
120528: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120532: LD_VAR 0 4
120536: PPUSH
120537: CALL_OW 256
120541: PUSH
120542: LD_INT 1000
120544: LESS
120545: PUSH
120546: LD_VAR 0 4
120550: PPUSH
120551: CALL_OW 263
120555: PUSH
120556: LD_INT 1
120558: EQUAL
120559: AND
120560: PUSH
120561: LD_VAR 0 4
120565: PPUSH
120566: CALL_OW 311
120570: AND
120571: PUSH
120572: LD_VAR 0 4
120576: PPUSH
120577: LD_EXP 102
120581: PUSH
120582: LD_VAR 0 1
120586: ARRAY
120587: PPUSH
120588: CALL_OW 308
120592: AND
120593: IFFALSE 120647
// begin mech := IsDrivenBy ( i ) ;
120595: LD_ADDR_VAR 0 9
120599: PUSH
120600: LD_VAR 0 4
120604: PPUSH
120605: CALL_OW 311
120609: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120610: LD_VAR 0 9
120614: PPUSH
120615: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120619: LD_VAR 0 9
120623: PPUSH
120624: LD_VAR 0 4
120628: PPUSH
120629: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120633: LD_VAR 0 9
120637: PPUSH
120638: LD_VAR 0 4
120642: PPUSH
120643: CALL_OW 180
// end ; end ; unit_human :
120647: GO 120994
120649: LD_INT 1
120651: DOUBLE
120652: EQUAL
120653: IFTRUE 120657
120655: GO 120993
120657: POP
// begin b := IsInUnit ( i ) ;
120658: LD_ADDR_VAR 0 18
120662: PUSH
120663: LD_VAR 0 4
120667: PPUSH
120668: CALL_OW 310
120672: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120673: LD_ADDR_VAR 0 19
120677: PUSH
120678: LD_VAR 0 18
120682: NOT
120683: PUSH
120684: LD_VAR 0 18
120688: PPUSH
120689: CALL_OW 266
120693: PUSH
120694: LD_INT 32
120696: PUSH
120697: LD_INT 31
120699: PUSH
120700: EMPTY
120701: LIST
120702: LIST
120703: IN
120704: OR
120705: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120706: LD_VAR 0 18
120710: PPUSH
120711: CALL_OW 266
120715: PUSH
120716: LD_INT 5
120718: EQUAL
120719: PUSH
120720: LD_VAR 0 4
120724: PPUSH
120725: CALL_OW 257
120729: PUSH
120730: LD_INT 1
120732: PUSH
120733: LD_INT 2
120735: PUSH
120736: LD_INT 3
120738: PUSH
120739: LD_INT 4
120741: PUSH
120742: EMPTY
120743: LIST
120744: LIST
120745: LIST
120746: LIST
120747: IN
120748: AND
120749: IFFALSE 120786
// begin class := AllowSpecClass ( i ) ;
120751: LD_ADDR_VAR 0 20
120755: PUSH
120756: LD_VAR 0 4
120760: PPUSH
120761: CALL 54598 0 1
120765: ST_TO_ADDR
// if class then
120766: LD_VAR 0 20
120770: IFFALSE 120786
// ComChangeProfession ( i , class ) ;
120772: LD_VAR 0 4
120776: PPUSH
120777: LD_VAR 0 20
120781: PPUSH
120782: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120786: LD_VAR 0 16
120790: PUSH
120791: LD_VAR 0 2
120795: PPUSH
120796: LD_INT 21
120798: PUSH
120799: LD_INT 2
120801: PUSH
120802: EMPTY
120803: LIST
120804: LIST
120805: PPUSH
120806: CALL_OW 72
120810: PUSH
120811: LD_INT 1
120813: LESSEQUAL
120814: OR
120815: PUSH
120816: LD_VAR 0 19
120820: AND
120821: PUSH
120822: LD_VAR 0 4
120826: PUSH
120827: LD_VAR 0 17
120831: IN
120832: NOT
120833: AND
120834: IFFALSE 120927
// begin if b then
120836: LD_VAR 0 18
120840: IFFALSE 120889
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120842: LD_VAR 0 18
120846: PPUSH
120847: LD_VAR 0 21
120851: PPUSH
120852: LD_VAR 0 18
120856: PPUSH
120857: CALL_OW 74
120861: PPUSH
120862: CALL_OW 296
120866: PUSH
120867: LD_INT 10
120869: LESS
120870: PUSH
120871: LD_VAR 0 18
120875: PPUSH
120876: CALL_OW 461
120880: PUSH
120881: LD_INT 7
120883: NONEQUAL
120884: AND
120885: IFFALSE 120889
// continue ;
120887: GO 120124
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120889: LD_ADDR_VAR 0 17
120893: PUSH
120894: LD_VAR 0 17
120898: PPUSH
120899: LD_VAR 0 17
120903: PUSH
120904: LD_INT 1
120906: PLUS
120907: PPUSH
120908: LD_VAR 0 4
120912: PPUSH
120913: CALL_OW 1
120917: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120918: LD_VAR 0 4
120922: PPUSH
120923: CALL_OW 122
// end ; if sold_defenders then
120927: LD_VAR 0 17
120931: IFFALSE 120991
// if i in sold_defenders then
120933: LD_VAR 0 4
120937: PUSH
120938: LD_VAR 0 17
120942: IN
120943: IFFALSE 120991
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120945: LD_VAR 0 4
120949: PPUSH
120950: CALL_OW 314
120954: NOT
120955: PUSH
120956: LD_VAR 0 4
120960: PPUSH
120961: LD_VAR 0 13
120965: PPUSH
120966: CALL_OW 296
120970: PUSH
120971: LD_INT 30
120973: LESS
120974: AND
120975: IFFALSE 120991
// ComAttackUnit ( i , e ) ;
120977: LD_VAR 0 4
120981: PPUSH
120982: LD_VAR 0 13
120986: PPUSH
120987: CALL_OW 115
// end ; end ; end ;
120991: GO 120994
120993: POP
// if IsDead ( i ) then
120994: LD_VAR 0 4
120998: PPUSH
120999: CALL_OW 301
121003: IFFALSE 121021
// defenders := defenders diff i ;
121005: LD_ADDR_VAR 0 2
121009: PUSH
121010: LD_VAR 0 2
121014: PUSH
121015: LD_VAR 0 4
121019: DIFF
121020: ST_TO_ADDR
// end ;
121021: GO 120124
121023: POP
121024: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
121025: LD_VAR 0 21
121029: NOT
121030: PUSH
121031: LD_VAR 0 2
121035: NOT
121036: OR
121037: PUSH
121038: LD_EXP 78
121042: PUSH
121043: LD_VAR 0 1
121047: ARRAY
121048: NOT
121049: OR
121050: IFFALSE 120028
// MC_Reset ( base , 18 ) ;
121052: LD_VAR 0 1
121056: PPUSH
121057: LD_INT 18
121059: PPUSH
121060: CALL 26287 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121064: LD_ADDR_VAR 0 2
121068: PUSH
121069: LD_VAR 0 2
121073: PUSH
121074: LD_VAR 0 2
121078: PPUSH
121079: LD_INT 2
121081: PUSH
121082: LD_INT 25
121084: PUSH
121085: LD_INT 1
121087: PUSH
121088: EMPTY
121089: LIST
121090: LIST
121091: PUSH
121092: LD_INT 25
121094: PUSH
121095: LD_INT 5
121097: PUSH
121098: EMPTY
121099: LIST
121100: LIST
121101: PUSH
121102: LD_INT 25
121104: PUSH
121105: LD_INT 8
121107: PUSH
121108: EMPTY
121109: LIST
121110: LIST
121111: PUSH
121112: LD_INT 25
121114: PUSH
121115: LD_INT 9
121117: PUSH
121118: EMPTY
121119: LIST
121120: LIST
121121: PUSH
121122: EMPTY
121123: LIST
121124: LIST
121125: LIST
121126: LIST
121127: LIST
121128: PPUSH
121129: CALL_OW 72
121133: DIFF
121134: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
121135: LD_VAR 0 21
121139: NOT
121140: PUSH
121141: LD_VAR 0 2
121145: PPUSH
121146: LD_INT 21
121148: PUSH
121149: LD_INT 2
121151: PUSH
121152: EMPTY
121153: LIST
121154: LIST
121155: PPUSH
121156: CALL_OW 72
121160: AND
121161: IFFALSE 121499
// begin tmp := FilterByTag ( defenders , 19 ) ;
121163: LD_ADDR_VAR 0 11
121167: PUSH
121168: LD_VAR 0 2
121172: PPUSH
121173: LD_INT 19
121175: PPUSH
121176: CALL 87686 0 2
121180: ST_TO_ADDR
// if tmp then
121181: LD_VAR 0 11
121185: IFFALSE 121255
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
121187: LD_ADDR_VAR 0 11
121191: PUSH
121192: LD_VAR 0 11
121196: PPUSH
121197: LD_INT 25
121199: PUSH
121200: LD_INT 3
121202: PUSH
121203: EMPTY
121204: LIST
121205: LIST
121206: PPUSH
121207: CALL_OW 72
121211: ST_TO_ADDR
// if tmp then
121212: LD_VAR 0 11
121216: IFFALSE 121255
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
121218: LD_ADDR_EXP 90
121222: PUSH
121223: LD_EXP 90
121227: PPUSH
121228: LD_VAR 0 1
121232: PPUSH
121233: LD_EXP 90
121237: PUSH
121238: LD_VAR 0 1
121242: ARRAY
121243: PUSH
121244: LD_VAR 0 11
121248: UNION
121249: PPUSH
121250: CALL_OW 1
121254: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121255: LD_VAR 0 1
121259: PPUSH
121260: LD_INT 19
121262: PPUSH
121263: CALL 26287 0 2
// repeat wait ( 0 0$1 ) ;
121267: LD_INT 35
121269: PPUSH
121270: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121274: LD_EXP 78
121278: PUSH
121279: LD_VAR 0 1
121283: ARRAY
121284: NOT
121285: PUSH
121286: LD_EXP 78
121290: PUSH
121291: LD_VAR 0 1
121295: ARRAY
121296: PUSH
121297: EMPTY
121298: EQUAL
121299: OR
121300: IFFALSE 121337
// begin for i in defenders do
121302: LD_ADDR_VAR 0 4
121306: PUSH
121307: LD_VAR 0 2
121311: PUSH
121312: FOR_IN
121313: IFFALSE 121326
// ComStop ( i ) ;
121315: LD_VAR 0 4
121319: PPUSH
121320: CALL_OW 141
121324: GO 121312
121326: POP
121327: POP
// defenders := [ ] ;
121328: LD_ADDR_VAR 0 2
121332: PUSH
121333: EMPTY
121334: ST_TO_ADDR
// exit ;
121335: GO 121563
// end ; for i in defenders do
121337: LD_ADDR_VAR 0 4
121341: PUSH
121342: LD_VAR 0 2
121346: PUSH
121347: FOR_IN
121348: IFFALSE 121437
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121350: LD_VAR 0 4
121354: PPUSH
121355: LD_EXP 102
121359: PUSH
121360: LD_VAR 0 1
121364: ARRAY
121365: PPUSH
121366: CALL_OW 308
121370: NOT
121371: IFFALSE 121395
// ComMoveToArea ( i , mc_parking [ base ] ) else
121373: LD_VAR 0 4
121377: PPUSH
121378: LD_EXP 102
121382: PUSH
121383: LD_VAR 0 1
121387: ARRAY
121388: PPUSH
121389: CALL_OW 113
121393: GO 121435
// if GetControl ( i ) = control_manual then
121395: LD_VAR 0 4
121399: PPUSH
121400: CALL_OW 263
121404: PUSH
121405: LD_INT 1
121407: EQUAL
121408: IFFALSE 121435
// if IsDrivenBy ( i ) then
121410: LD_VAR 0 4
121414: PPUSH
121415: CALL_OW 311
121419: IFFALSE 121435
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121421: LD_VAR 0 4
121425: PPUSH
121426: CALL_OW 311
121430: PPUSH
121431: CALL_OW 121
// end ;
121435: GO 121347
121437: POP
121438: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121439: LD_VAR 0 2
121443: PPUSH
121444: LD_INT 95
121446: PUSH
121447: LD_EXP 102
121451: PUSH
121452: LD_VAR 0 1
121456: ARRAY
121457: PUSH
121458: EMPTY
121459: LIST
121460: LIST
121461: PPUSH
121462: CALL_OW 72
121466: PUSH
121467: LD_VAR 0 2
121471: EQUAL
121472: PUSH
121473: LD_EXP 101
121477: PUSH
121478: LD_VAR 0 1
121482: ARRAY
121483: OR
121484: PUSH
121485: LD_EXP 78
121489: PUSH
121490: LD_VAR 0 1
121494: ARRAY
121495: NOT
121496: OR
121497: IFFALSE 121267
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121499: LD_ADDR_EXP 100
121503: PUSH
121504: LD_EXP 100
121508: PPUSH
121509: LD_VAR 0 1
121513: PPUSH
121514: LD_VAR 0 2
121518: PPUSH
121519: LD_INT 21
121521: PUSH
121522: LD_INT 2
121524: PUSH
121525: EMPTY
121526: LIST
121527: LIST
121528: PPUSH
121529: CALL_OW 72
121533: PPUSH
121534: CALL_OW 1
121538: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121539: LD_VAR 0 1
121543: PPUSH
121544: LD_INT 19
121546: PPUSH
121547: CALL 26287 0 2
// MC_Reset ( base , 20 ) ;
121551: LD_VAR 0 1
121555: PPUSH
121556: LD_INT 20
121558: PPUSH
121559: CALL 26287 0 2
// end ; end_of_file
121563: LD_VAR 0 3
121567: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
121568: LD_VAR 0 1
121572: PUSH
121573: LD_INT 200
121575: DOUBLE
121576: GREATEREQUAL
121577: IFFALSE 121585
121579: LD_INT 299
121581: DOUBLE
121582: LESSEQUAL
121583: IFTRUE 121587
121585: GO 121619
121587: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
121588: LD_VAR 0 1
121592: PPUSH
121593: LD_VAR 0 2
121597: PPUSH
121598: LD_VAR 0 3
121602: PPUSH
121603: LD_VAR 0 4
121607: PPUSH
121608: LD_VAR 0 5
121612: PPUSH
121613: CALL 110354 0 5
121617: GO 121696
121619: LD_INT 300
121621: DOUBLE
121622: GREATEREQUAL
121623: IFFALSE 121631
121625: LD_INT 399
121627: DOUBLE
121628: LESSEQUAL
121629: IFTRUE 121633
121631: GO 121695
121633: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121634: LD_VAR 0 1
121638: PPUSH
121639: LD_VAR 0 2
121643: PPUSH
121644: LD_VAR 0 3
121648: PPUSH
121649: LD_VAR 0 4
121653: PPUSH
121654: LD_VAR 0 5
121658: PPUSH
121659: LD_VAR 0 6
121663: PPUSH
121664: LD_VAR 0 7
121668: PPUSH
121669: LD_VAR 0 8
121673: PPUSH
121674: LD_VAR 0 9
121678: PPUSH
121679: LD_VAR 0 10
121683: PPUSH
121684: LD_VAR 0 11
121688: PPUSH
121689: CALL 106679 0 11
121693: GO 121696
121695: POP
// end ;
121696: PPOPN 11
121698: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121699: LD_VAR 0 1
121703: PPUSH
121704: LD_VAR 0 2
121708: PPUSH
121709: LD_VAR 0 3
121713: PPUSH
121714: LD_VAR 0 4
121718: PPUSH
121719: LD_VAR 0 5
121723: PPUSH
121724: CALL 110090 0 5
// end ; end_of_file
121728: PPOPN 5
121730: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121731: LD_VAR 0 1
121735: PPUSH
121736: LD_VAR 0 2
121740: PPUSH
121741: LD_VAR 0 3
121745: PPUSH
121746: LD_VAR 0 4
121750: PPUSH
121751: LD_VAR 0 5
121755: PPUSH
121756: LD_VAR 0 6
121760: PPUSH
121761: CALL 94331 0 6
// end ;
121765: PPOPN 6
121767: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121768: LD_INT 0
121770: PPUSH
// begin if not units then
121771: LD_VAR 0 1
121775: NOT
121776: IFFALSE 121780
// exit ;
121778: GO 121780
// end ;
121780: PPOPN 7
121782: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121783: CALL 94235 0 0
// end ;
121787: PPOPN 1
121789: END
