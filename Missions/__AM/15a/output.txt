// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20694 0 0
// InitMacro ;
  19: CALL 20862 0 0
// InitNature ;
  23: CALL 17360 0 0
// InitArtifact ;
  27: CALL 17977 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4641 0 0
// PrepareAlliance ;
  48: CALL 1429 0 0
// PrepareArabian ;
  52: CALL 6413 0 0
// PrepareRussian ;
  56: CALL 8422 0 0
// PrepareLegion ;
  60: CALL 6845 0 0
// Action ;
  64: CALL 10987 0 0
// MC_Start ( ) ;
  68: CALL 23027 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: LD_INT 10
 280: PUSH
 281: EMPTY
 282: LIST
 283: LIST
 284: LIST
 285: LIST
 286: PUSH
 287: LD_OWVAR 67
 291: ARRAY
 292: PPUSH
 293: LD_INT 28
 295: PPUSH
 296: CALL 44716 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 10
 305: PUSH
 306: LD_INT 11
 308: PUSH
 309: LD_INT 13
 311: PUSH
 312: LD_INT 15
 314: PUSH
 315: EMPTY
 316: LIST
 317: LIST
 318: LIST
 319: LIST
 320: PPUSH
 321: CALL 45776 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 325: LD_INT 1
 327: PPUSH
 328: LD_INT 29
 330: PUSH
 331: EMPTY
 332: LIST
 333: PPUSH
 334: CALL 45869 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 338: LD_ADDR_EXP 122
 342: PUSH
 343: LD_EXP 122
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 2
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 25
 363: PUSH
 364: LD_INT 15
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: PPUSH
 380: CALL_OW 1
 384: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 385: LD_INT 1
 387: PPUSH
 388: LD_INT 13
 390: PUSH
 391: LD_INT 2
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: LD_INT 31
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: PUSH
 406: LD_INT 13
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 1
 414: PUSH
 415: LD_INT 31
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: LIST
 423: PUSH
 424: LD_INT 13
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 1
 432: PUSH
 433: LD_INT 28
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: PUSH
 442: LD_INT 13
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 1
 450: PUSH
 451: LD_INT 28
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: PUSH
 460: LD_INT 13
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: LD_INT 28
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: PUSH
 478: LD_INT 13
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 28
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PUSH
 496: LD_INT 13
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 2
 504: PUSH
 505: LD_EXP 78
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 45034 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 529: LD_INT 1
 531: PPUSH
 532: LD_INT 4
 534: PPUSH
 535: CALL 45219 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 539: LD_INT 2
 541: PPUSH
 542: LD_INT 10
 544: PUSH
 545: LD_INT 11
 547: PUSH
 548: LD_INT 12
 550: PUSH
 551: LD_INT 14
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 45776 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 564: LD_INT 2
 566: PPUSH
 567: LD_INT 14
 569: PUSH
 570: EMPTY
 571: LIST
 572: PPUSH
 573: CALL 45869 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 577: LD_INT 2
 579: PPUSH
 580: LD_INT 21
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 51
 591: PUSH
 592: EMPTY
 593: LIST
 594: LIST
 595: LIST
 596: LIST
 597: PUSH
 598: LD_INT 22
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 52
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: LIST
 615: PUSH
 616: LD_INT 22
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 52
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: LIST
 632: LIST
 633: PUSH
 634: LD_INT 24
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 47
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_INT 24
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 47
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 24
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 47
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: LD_INT 24
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 3
 696: PUSH
 697: LD_INT 47
 699: PUSH
 700: EMPTY
 701: LIST
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 24
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 47
 717: PUSH
 718: EMPTY
 719: LIST
 720: LIST
 721: LIST
 722: LIST
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PPUSH
 734: CALL 45034 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 738: LD_INT 2
 740: PPUSH
 741: LD_INT 5
 743: PPUSH
 744: CALL 45219 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 748: LD_INT 2
 750: PPUSH
 751: LD_INT 0
 753: PPUSH
 754: CALL 45649 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 758: LD_INT 3
 760: PPUSH
 761: LD_INT 10
 763: PUSH
 764: LD_INT 12
 766: PUSH
 767: LD_INT 14
 769: PUSH
 770: LD_INT 15
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: LD_OWVAR 67
 783: ARRAY
 784: PPUSH
 785: LD_INT 24
 787: PPUSH
 788: CALL 44716 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 792: LD_INT 3
 794: PPUSH
 795: LD_INT 10
 797: PUSH
 798: LD_INT 11
 800: PUSH
 801: LD_INT 13
 803: PUSH
 804: LD_INT 15
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PPUSH
 813: CALL 45776 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 817: LD_INT 3
 819: PPUSH
 820: LD_INT 13
 822: PUSH
 823: EMPTY
 824: LIST
 825: PPUSH
 826: CALL 45869 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 830: LD_ADDR_EXP 122
 834: PUSH
 835: LD_EXP 122
 839: PPUSH
 840: LD_INT 3
 842: PPUSH
 843: LD_INT 22
 845: PUSH
 846: LD_INT 8
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 25
 855: PUSH
 856: LD_INT 15
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PPUSH
 867: CALL_OW 69
 871: PPUSH
 872: CALL_OW 1
 876: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 13
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: LD_INT 31
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 13
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 31
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 13
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: LD_INT 2
 924: PUSH
 925: LD_INT 32
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 14
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 28
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 14
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 28
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 14
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 1
 978: PUSH
 979: LD_INT 28
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_INT 14
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 1
 996: PUSH
 997: LD_INT 28
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: LIST
1004: LIST
1005: PUSH
1006: LD_INT 14
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_EXP 78
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL 45034 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1040: LD_INT 3
1042: PPUSH
1043: LD_INT 4
1045: PPUSH
1046: CALL 45219 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1050: LD_INT 4
1052: PPUSH
1053: LD_INT 10
1055: PUSH
1056: LD_INT 12
1058: PUSH
1059: LD_INT 11
1061: PUSH
1062: LD_INT 15
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PPUSH
1071: CALL 45776 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 33
1080: PUSH
1081: EMPTY
1082: LIST
1083: PPUSH
1084: CALL 45869 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 5
1093: PUSH
1094: LD_INT 6
1096: PUSH
1097: LD_INT 7
1099: PUSH
1100: LD_INT 9
1102: PUSH
1103: LD_INT 10
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: PPUSH
1113: CALL 46187 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1117: LD_INT 4
1119: PPUSH
1120: LD_INT 54
1122: PPUSH
1123: LD_INT 85
1125: PPUSH
1126: LD_INT 2
1128: PPUSH
1129: LD_INT 25
1131: PUSH
1132: LD_INT 16
1134: PUSH
1135: LD_INT 17
1137: PUSH
1138: LD_INT 18
1140: PUSH
1141: LD_INT 22
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PPUSH
1151: CALL 45981 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 7
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 1
1184: PUSH
1185: LD_INT 6
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 5
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: LD_INT 7
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 5
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 1
1220: PUSH
1221: LD_INT 6
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 5
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: LD_INT 12
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 3
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 3
1256: PUSH
1257: LD_INT 13
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 45034 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PPUSH
1284: CALL 45219 0 2
// MC_SetTame ( 4 , powellApe ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 11
1293: PPUSH
1294: CALL 45600 0 2
// end ;
1298: LD_VAR 0 1
1302: RET
// every 0 0$1 trigger debug do var i ;
1303: LD_EXP 1
1307: IFFALSE 1405
1309: GO 1311
1311: DISABLE
1312: LD_INT 0
1314: PPUSH
// begin enable ;
1315: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1316: LD_ADDR_VAR 0 1
1320: PUSH
1321: LD_INT 22
1323: PUSH
1324: LD_INT 7
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 2
1333: PUSH
1334: LD_INT 21
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 21
1346: PUSH
1347: LD_INT 2
1349: PUSH
1350: EMPTY
1351: LIST
1352: LIST
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 3
1361: PUSH
1362: LD_INT 24
1364: PUSH
1365: LD_INT 1000
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL_OW 69
1385: PUSH
1386: FOR_IN
1387: IFFALSE 1403
// SetLives ( i , 1000 ) ;
1389: LD_VAR 0 1
1393: PPUSH
1394: LD_INT 1000
1396: PPUSH
1397: CALL_OW 234
1401: GO 1386
1403: POP
1404: POP
// end ;
1405: PPOPN 1
1407: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1408: LD_EXP 16
1412: PUSH
1413: LD_INT 5
1415: GREATEREQUAL
1416: IFFALSE 1428
1418: GO 1420
1420: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1421: LD_STRING ACH_ARTIFACT
1423: PPUSH
1424: CALL_OW 543
1428: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1429: LD_INT 0
1431: PPUSH
1432: PPUSH
1433: PPUSH
1434: PPUSH
1435: PPUSH
// uc_side := 7 ;
1436: LD_ADDR_OWVAR 20
1440: PUSH
1441: LD_INT 7
1443: ST_TO_ADDR
// tmp := [ ] ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: EMPTY
1450: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1451: LD_ADDR_EXP 17
1455: PUSH
1456: LD_STRING JMM
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 14a_
1467: PPUSH
1468: CALL 51488 0 3
1472: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1473: LD_ADDR_EXP 49
1477: PUSH
1478: LD_STRING Burlak
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: LD_STRING 14a_
1489: PPUSH
1490: CALL 51488 0 3
1494: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1495: LD_ADDR_EXP 32
1499: PUSH
1500: LD_STRING Joan
1502: PPUSH
1503: LD_EXP 1
1507: NOT
1508: PPUSH
1509: LD_STRING 13a_
1511: PPUSH
1512: CALL 51488 0 3
1516: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1517: LD_ADDR_EXP 18
1521: PUSH
1522: LD_STRING Roth
1524: PPUSH
1525: LD_EXP 1
1529: NOT
1530: PPUSH
1531: LD_STRING 13a_
1533: PPUSH
1534: CALL 51488 0 3
1538: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1539: LD_ADDR_EXP 35
1543: PUSH
1544: LD_STRING Gossudarov
1546: PPUSH
1547: LD_EXP 1
1551: NOT
1552: PPUSH
1553: LD_STRING 13a_
1555: PPUSH
1556: CALL 51488 0 3
1560: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1561: LD_ADDR_EXP 23
1565: PUSH
1566: LD_STRING Denis
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 13a_
1577: PPUSH
1578: CALL 51488 0 3
1582: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1583: LD_ADDR_EXP 33
1587: PUSH
1588: LD_STRING DeltaDoctor
1590: PPUSH
1591: LD_EXP 1
1595: NOT
1596: PPUSH
1597: LD_STRING 13a_
1599: PPUSH
1600: CALL 51488 0 3
1604: ST_TO_ADDR
// if DeltaDoctor then
1605: LD_EXP 33
1609: IFFALSE 1627
// tmp := tmp ^ DeltaDoctor ;
1611: LD_ADDR_VAR 0 5
1615: PUSH
1616: LD_VAR 0 5
1620: PUSH
1621: LD_EXP 33
1625: ADD
1626: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1627: LD_ADDR_EXP 31
1631: PUSH
1632: LD_STRING Simms
1634: PPUSH
1635: LD_EXP 1
1639: NOT
1640: PPUSH
1641: LD_STRING 13a_
1643: PPUSH
1644: CALL 51488 0 3
1648: ST_TO_ADDR
// if Simms then
1649: LD_EXP 31
1653: IFFALSE 1671
// tmp := tmp ^ Simms ;
1655: LD_ADDR_VAR 0 5
1659: PUSH
1660: LD_VAR 0 5
1664: PUSH
1665: LD_EXP 31
1669: ADD
1670: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1671: LD_ADDR_EXP 29
1675: PUSH
1676: LD_STRING Frank
1678: PPUSH
1679: LD_EXP 1
1683: NOT
1684: PPUSH
1685: LD_STRING 13a_
1687: PPUSH
1688: CALL 51488 0 3
1692: ST_TO_ADDR
// if Frank then
1693: LD_EXP 29
1697: IFFALSE 1715
// tmp := tmp ^ Frank ;
1699: LD_ADDR_VAR 0 5
1703: PUSH
1704: LD_VAR 0 5
1708: PUSH
1709: LD_EXP 29
1713: ADD
1714: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1715: LD_ADDR_EXP 36
1719: PUSH
1720: LD_STRING Kirilenkova
1722: PPUSH
1723: LD_EXP 1
1727: NOT
1728: PPUSH
1729: LD_STRING 13a_
1731: PPUSH
1732: CALL 51488 0 3
1736: ST_TO_ADDR
// if Kirilenkova then
1737: LD_EXP 36
1741: IFFALSE 1759
// tmp := tmp ^ Kirilenkova ;
1743: LD_ADDR_VAR 0 5
1747: PUSH
1748: LD_VAR 0 5
1752: PUSH
1753: LD_EXP 36
1757: ADD
1758: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1759: LD_ADDR_EXP 37
1763: PUSH
1764: LD_STRING Titov
1766: PPUSH
1767: LD_EXP 1
1771: NOT
1772: PPUSH
1773: LD_STRING 13a_
1775: PPUSH
1776: CALL 51488 0 3
1780: ST_TO_ADDR
// if Titov then
1781: LD_EXP 37
1785: IFFALSE 1803
// tmp := tmp ^ Titov ;
1787: LD_ADDR_VAR 0 5
1791: PUSH
1792: LD_VAR 0 5
1796: PUSH
1797: LD_EXP 37
1801: ADD
1802: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1803: LD_ADDR_EXP 38
1807: PUSH
1808: LD_STRING Fadeev
1810: PPUSH
1811: LD_EXP 1
1815: NOT
1816: PPUSH
1817: LD_STRING 13a_
1819: PPUSH
1820: CALL 51488 0 3
1824: ST_TO_ADDR
// if Fadeev then
1825: LD_EXP 38
1829: IFFALSE 1847
// tmp := tmp ^ Fadeev ;
1831: LD_ADDR_VAR 0 5
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 38
1845: ADD
1846: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1847: LD_ADDR_EXP 39
1851: PUSH
1852: LD_STRING Dolgov
1854: PPUSH
1855: LD_EXP 1
1859: NOT
1860: PPUSH
1861: LD_STRING 13a_
1863: PPUSH
1864: CALL 51488 0 3
1868: ST_TO_ADDR
// if Dolgov then
1869: LD_EXP 39
1873: IFFALSE 1891
// tmp := tmp ^ Dolgov ;
1875: LD_ADDR_VAR 0 5
1879: PUSH
1880: LD_VAR 0 5
1884: PUSH
1885: LD_EXP 39
1889: ADD
1890: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1891: LD_ADDR_EXP 40
1895: PUSH
1896: LD_STRING Petrosyan
1898: PPUSH
1899: LD_EXP 1
1903: NOT
1904: PPUSH
1905: LD_STRING 13a_
1907: PPUSH
1908: CALL 51488 0 3
1912: ST_TO_ADDR
// if Petrosyan then
1913: LD_EXP 40
1917: IFFALSE 1935
// tmp := tmp ^ Petrosyan ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_VAR 0 5
1928: PUSH
1929: LD_EXP 40
1933: ADD
1934: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1935: LD_ADDR_EXP 41
1939: PUSH
1940: LD_STRING Scholtze
1942: PPUSH
1943: LD_EXP 1
1947: NOT
1948: PPUSH
1949: LD_STRING 13a_
1951: PPUSH
1952: CALL 51488 0 3
1956: ST_TO_ADDR
// if Scholtze then
1957: LD_EXP 41
1961: IFFALSE 1979
// tmp := tmp ^ Scholtze ;
1963: LD_ADDR_VAR 0 5
1967: PUSH
1968: LD_VAR 0 5
1972: PUSH
1973: LD_EXP 41
1977: ADD
1978: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1979: LD_ADDR_EXP 42
1983: PUSH
1984: LD_STRING Oblukov
1986: PPUSH
1987: LD_EXP 1
1991: NOT
1992: PPUSH
1993: LD_STRING 13a_
1995: PPUSH
1996: CALL 51488 0 3
2000: ST_TO_ADDR
// if Oblukov then
2001: LD_EXP 42
2005: IFFALSE 2023
// tmp := tmp ^ Oblukov ;
2007: LD_ADDR_VAR 0 5
2011: PUSH
2012: LD_VAR 0 5
2016: PUSH
2017: LD_EXP 42
2021: ADD
2022: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2023: LD_ADDR_EXP 43
2027: PUSH
2028: LD_STRING Kapitsova
2030: PPUSH
2031: LD_EXP 1
2035: NOT
2036: PPUSH
2037: LD_STRING 13a_
2039: PPUSH
2040: CALL 51488 0 3
2044: ST_TO_ADDR
// if Kapitsova then
2045: LD_EXP 43
2049: IFFALSE 2067
// tmp := tmp ^ Kapitsova ;
2051: LD_ADDR_VAR 0 5
2055: PUSH
2056: LD_VAR 0 5
2060: PUSH
2061: LD_EXP 43
2065: ADD
2066: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2067: LD_ADDR_EXP 44
2071: PUSH
2072: LD_STRING Lipshchin
2074: PPUSH
2075: LD_EXP 1
2079: NOT
2080: PPUSH
2081: LD_STRING 13a_
2083: PPUSH
2084: CALL 51488 0 3
2088: ST_TO_ADDR
// if Lipshchin then
2089: LD_EXP 44
2093: IFFALSE 2111
// tmp := tmp ^ Lipshchin ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 5
2104: PUSH
2105: LD_EXP 44
2109: ADD
2110: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2111: LD_ADDR_EXP 45
2115: PUSH
2116: LD_STRING Petrovova
2118: PPUSH
2119: LD_EXP 1
2123: NOT
2124: PPUSH
2125: LD_STRING 13a_
2127: PPUSH
2128: CALL 51488 0 3
2132: ST_TO_ADDR
// if Petrovova then
2133: LD_EXP 45
2137: IFFALSE 2155
// tmp := tmp ^ Petrovova ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 5
2148: PUSH
2149: LD_EXP 45
2153: ADD
2154: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2155: LD_ADDR_EXP 46
2159: PUSH
2160: LD_STRING Kovalyuk
2162: PPUSH
2163: LD_EXP 1
2167: NOT
2168: PPUSH
2169: LD_STRING 13a_
2171: PPUSH
2172: CALL 51488 0 3
2176: ST_TO_ADDR
// if Kovalyuk then
2177: LD_EXP 46
2181: IFFALSE 2199
// tmp := tmp ^ Kovalyuk ;
2183: LD_ADDR_VAR 0 5
2187: PUSH
2188: LD_VAR 0 5
2192: PUSH
2193: LD_EXP 46
2197: ADD
2198: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2199: LD_ADDR_EXP 47
2203: PUSH
2204: LD_STRING Kuzmov
2206: PPUSH
2207: LD_EXP 1
2211: NOT
2212: PPUSH
2213: LD_STRING 13a_
2215: PPUSH
2216: CALL 51488 0 3
2220: ST_TO_ADDR
// if Kuzmov then
2221: LD_EXP 47
2225: IFFALSE 2243
// tmp := tmp ^ Kuzmov ;
2227: LD_ADDR_VAR 0 5
2231: PUSH
2232: LD_VAR 0 5
2236: PUSH
2237: LD_EXP 47
2241: ADD
2242: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2243: LD_ADDR_EXP 48
2247: PUSH
2248: LD_STRING Karamazov
2250: PPUSH
2251: LD_EXP 1
2255: NOT
2256: PPUSH
2257: LD_STRING 13a_
2259: PPUSH
2260: CALL 51488 0 3
2264: ST_TO_ADDR
// if Karamazov then
2265: LD_EXP 48
2269: IFFALSE 2287
// tmp := tmp ^ Karamazov ;
2271: LD_ADDR_VAR 0 5
2275: PUSH
2276: LD_VAR 0 5
2280: PUSH
2281: LD_EXP 48
2285: ADD
2286: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2287: LD_ADDR_EXP 50
2291: PUSH
2292: LD_STRING Belkov
2294: PPUSH
2295: LD_EXP 1
2299: NOT
2300: PPUSH
2301: LD_STRING 13a_
2303: PPUSH
2304: CALL 51488 0 3
2308: ST_TO_ADDR
// if Belkov then
2309: LD_EXP 50
2313: IFFALSE 2331
// tmp := tmp ^ Belkov ;
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 5
2324: PUSH
2325: LD_EXP 50
2329: ADD
2330: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2331: LD_ADDR_EXP 51
2335: PUSH
2336: LD_STRING Gnyevko
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13a_
2347: PPUSH
2348: CALL 51488 0 3
2352: ST_TO_ADDR
// if Gnyevko then
2353: LD_EXP 51
2357: IFFALSE 2375
// tmp := tmp ^ Gnyevko ;
2359: LD_ADDR_VAR 0 5
2363: PUSH
2364: LD_VAR 0 5
2368: PUSH
2369: LD_EXP 51
2373: ADD
2374: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2375: LD_ADDR_EXP 34
2379: PUSH
2380: LD_STRING Coonie
2382: PPUSH
2383: CALL_OW 25
2387: ST_TO_ADDR
// if not Lisa then
2388: LD_EXP 19
2392: NOT
2393: IFFALSE 2439
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2395: LD_ADDR_EXP 19
2399: PUSH
2400: LD_STRING Lisa
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13a_
2411: PPUSH
2412: CALL 51488 0 3
2416: ST_TO_ADDR
// if Lisa then
2417: LD_EXP 19
2421: IFFALSE 2439
// tmp := tmp ^ Lisa ;
2423: LD_ADDR_VAR 0 5
2427: PUSH
2428: LD_VAR 0 5
2432: PUSH
2433: LD_EXP 19
2437: ADD
2438: ST_TO_ADDR
// end ; if not Donaldson then
2439: LD_EXP 20
2443: NOT
2444: IFFALSE 2490
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2446: LD_ADDR_EXP 20
2450: PUSH
2451: LD_STRING Donaldson
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13a_
2462: PPUSH
2463: CALL 51488 0 3
2467: ST_TO_ADDR
// if Donaldson then
2468: LD_EXP 20
2472: IFFALSE 2490
// tmp := tmp ^ Donaldson ;
2474: LD_ADDR_VAR 0 5
2478: PUSH
2479: LD_VAR 0 5
2483: PUSH
2484: LD_EXP 20
2488: ADD
2489: ST_TO_ADDR
// end ; if not Bobby then
2490: LD_EXP 21
2494: NOT
2495: IFFALSE 2541
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2497: LD_ADDR_EXP 21
2501: PUSH
2502: LD_STRING Bobby
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13a_
2513: PPUSH
2514: CALL 51488 0 3
2518: ST_TO_ADDR
// if Bobby then
2519: LD_EXP 21
2523: IFFALSE 2541
// tmp := tmp ^ Bobby ;
2525: LD_ADDR_VAR 0 5
2529: PUSH
2530: LD_VAR 0 5
2534: PUSH
2535: LD_EXP 21
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cyrus then
2541: LD_EXP 22
2545: NOT
2546: IFFALSE 2592
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2548: LD_ADDR_EXP 22
2552: PUSH
2553: LD_STRING Cyrus
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13a_
2564: PPUSH
2565: CALL 51488 0 3
2569: ST_TO_ADDR
// if Cyrus then
2570: LD_EXP 22
2574: IFFALSE 2592
// tmp := tmp ^ Cyrus ;
2576: LD_ADDR_VAR 0 5
2580: PUSH
2581: LD_VAR 0 5
2585: PUSH
2586: LD_EXP 22
2590: ADD
2591: ST_TO_ADDR
// end ; if not Brown then
2592: LD_EXP 24
2596: NOT
2597: IFFALSE 2643
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2599: LD_ADDR_EXP 24
2603: PUSH
2604: LD_STRING Brown
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13a_
2615: PPUSH
2616: CALL 51488 0 3
2620: ST_TO_ADDR
// if Brown then
2621: LD_EXP 24
2625: IFFALSE 2643
// tmp := tmp ^ Brown ;
2627: LD_ADDR_VAR 0 5
2631: PUSH
2632: LD_VAR 0 5
2636: PUSH
2637: LD_EXP 24
2641: ADD
2642: ST_TO_ADDR
// end ; if not Gladstone then
2643: LD_EXP 25
2647: NOT
2648: IFFALSE 2694
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2650: LD_ADDR_EXP 25
2654: PUSH
2655: LD_STRING Gladstone
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13a_
2666: PPUSH
2667: CALL 51488 0 3
2671: ST_TO_ADDR
// if Gladstone then
2672: LD_EXP 25
2676: IFFALSE 2694
// tmp := tmp ^ Gladstone ;
2678: LD_ADDR_VAR 0 5
2682: PUSH
2683: LD_VAR 0 5
2687: PUSH
2688: LD_EXP 25
2692: ADD
2693: ST_TO_ADDR
// end ; if not Cornel then
2694: LD_EXP 27
2698: NOT
2699: IFFALSE 2745
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2701: LD_ADDR_EXP 27
2705: PUSH
2706: LD_STRING Cornel
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13a_
2717: PPUSH
2718: CALL 51488 0 3
2722: ST_TO_ADDR
// if Cornel then
2723: LD_EXP 27
2727: IFFALSE 2745
// tmp := tmp ^ Cornel ;
2729: LD_ADDR_VAR 0 5
2733: PUSH
2734: LD_VAR 0 5
2738: PUSH
2739: LD_EXP 27
2743: ADD
2744: ST_TO_ADDR
// end ; if not Houten then
2745: LD_EXP 26
2749: NOT
2750: IFFALSE 2796
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2752: LD_ADDR_EXP 26
2756: PUSH
2757: LD_STRING Houten
2759: PPUSH
2760: LD_EXP 1
2764: NOT
2765: PPUSH
2766: LD_STRING 13a_
2768: PPUSH
2769: CALL 51488 0 3
2773: ST_TO_ADDR
// if Houten then
2774: LD_EXP 26
2778: IFFALSE 2796
// tmp := tmp ^ Houten ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_EXP 26
2794: ADD
2795: ST_TO_ADDR
// end ; if not Gary then
2796: LD_EXP 28
2800: NOT
2801: IFFALSE 2847
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2803: LD_ADDR_EXP 28
2807: PUSH
2808: LD_STRING Gary
2810: PPUSH
2811: LD_EXP 1
2815: NOT
2816: PPUSH
2817: LD_STRING 13a_
2819: PPUSH
2820: CALL 51488 0 3
2824: ST_TO_ADDR
// if Gary then
2825: LD_EXP 28
2829: IFFALSE 2847
// tmp := tmp ^ Gary ;
2831: LD_ADDR_VAR 0 5
2835: PUSH
2836: LD_VAR 0 5
2840: PUSH
2841: LD_EXP 28
2845: ADD
2846: ST_TO_ADDR
// end ; if not Kikuchi then
2847: LD_EXP 30
2851: NOT
2852: IFFALSE 2898
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2854: LD_ADDR_EXP 30
2858: PUSH
2859: LD_STRING Kikuchi
2861: PPUSH
2862: LD_EXP 1
2866: NOT
2867: PPUSH
2868: LD_STRING 13a_
2870: PPUSH
2871: CALL 51488 0 3
2875: ST_TO_ADDR
// if Kikuchi then
2876: LD_EXP 30
2880: IFFALSE 2898
// tmp := tmp ^ Kikuchi ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_EXP 30
2896: ADD
2897: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2898: LD_ADDR_VAR 0 5
2902: PUSH
2903: LD_VAR 0 5
2907: PUSH
2908: LD_STRING 13a_others
2910: PPUSH
2911: CALL_OW 31
2915: UNION
2916: ST_TO_ADDR
// tmp := tmp diff 0 ;
2917: LD_ADDR_VAR 0 5
2921: PUSH
2922: LD_VAR 0 5
2926: PUSH
2927: LD_INT 0
2929: DIFF
2930: ST_TO_ADDR
// if tmp < 15 then
2931: LD_VAR 0 5
2935: PUSH
2936: LD_INT 15
2938: LESS
2939: IFFALSE 3027
// for i = 15 downto tmp do
2941: LD_ADDR_VAR 0 2
2945: PUSH
2946: DOUBLE
2947: LD_INT 15
2949: INC
2950: ST_TO_ADDR
2951: LD_VAR 0 5
2955: PUSH
2956: FOR_DOWNTO
2957: IFFALSE 3025
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2959: LD_ADDR_OWVAR 21
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: LD_INT 3
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 1
2976: PPUSH
2977: LD_INT 2
2979: PPUSH
2980: CALL_OW 12
2984: ARRAY
2985: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2986: LD_INT 0
2988: PPUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 4
2994: PPUSH
2995: CALL_OW 12
2999: PPUSH
3000: LD_INT 8
3002: PPUSH
3003: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3007: LD_ADDR_VAR 0 5
3011: PUSH
3012: LD_VAR 0 5
3016: PUSH
3017: CALL_OW 44
3021: ADD
3022: ST_TO_ADDR
// end ;
3023: GO 2956
3025: POP
3026: POP
// if not debug then
3027: LD_EXP 1
3031: NOT
3032: IFFALSE 3212
// selected = CharacterSelection (  , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3034: LD_ADDR_VAR 0 4
3038: PUSH
3039: LD_STRING 
3041: PPUSH
3042: LD_INT 15
3044: PUSH
3045: LD_INT 14
3047: PUSH
3048: LD_INT 13
3050: PUSH
3051: LD_INT 12
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_OWVAR 67
3064: ARRAY
3065: PPUSH
3066: LD_INT 15
3068: PUSH
3069: LD_INT 14
3071: PUSH
3072: LD_INT 13
3074: PUSH
3075: LD_INT 12
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: PUSH
3084: LD_OWVAR 67
3088: ARRAY
3089: PPUSH
3090: LD_INT -5
3092: PUSH
3093: LD_EXP 17
3097: PUSH
3098: LD_EXP 49
3102: PUSH
3103: LD_EXP 18
3107: PUSH
3108: LD_EXP 32
3112: PUSH
3113: LD_EXP 23
3117: PUSH
3118: LD_EXP 35
3122: PUSH
3123: LD_INT -2
3125: PUSH
3126: LD_INT -3
3128: PUSH
3129: LD_INT -5
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PUSH
3144: LD_VAR 0 5
3148: ADD
3149: PPUSH
3150: LD_INT 1
3152: PUSH
3153: LD_INT 4
3155: PUSH
3156: LD_INT 2
3158: PUSH
3159: LD_INT 1
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: PUSH
3166: LD_INT 3
3168: PUSH
3169: LD_INT 5
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: PUSH
3183: LD_INT 9
3185: PUSH
3186: LD_INT 0
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: LIST
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: CALL_OW 42
3209: ST_TO_ADDR
3210: GO 3291
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3212: LD_ADDR_VAR 0 4
3216: PUSH
3217: LD_EXP 37
3221: PUSH
3222: LD_EXP 38
3226: PUSH
3227: LD_EXP 39
3231: PUSH
3232: LD_EXP 40
3236: PUSH
3237: LD_EXP 41
3241: PUSH
3242: LD_EXP 42
3246: PUSH
3247: LD_EXP 43
3251: PUSH
3252: LD_EXP 44
3256: PUSH
3257: LD_EXP 45
3261: PUSH
3262: LD_EXP 46
3266: PUSH
3267: LD_EXP 47
3271: PUSH
3272: LD_EXP 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: ST_TO_ADDR
// uc_nation := 1 ;
3291: LD_ADDR_OWVAR 21
3295: PUSH
3296: LD_INT 1
3298: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3299: LD_INT 5
3301: PPUSH
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 6
3310: PPUSH
3311: LD_INT 100
3313: PPUSH
3314: CALL 56352 0 5
// veh := CreateVehicle ;
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: CALL_OW 45
3327: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3328: LD_VAR 0 3
3332: PPUSH
3333: LD_INT 7
3335: NEG
3336: PPUSH
3337: CALL_OW 242
// SetDir ( veh , 3 ) ;
3341: LD_VAR 0 3
3345: PPUSH
3346: LD_INT 3
3348: PPUSH
3349: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3353: LD_VAR 0 3
3357: PPUSH
3358: LD_INT 31
3360: PPUSH
3361: LD_INT 0
3363: PPUSH
3364: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3368: LD_EXP 17
3372: PPUSH
3373: LD_VAR 0 3
3377: PPUSH
3378: CALL_OW 52
// if Joan then
3382: LD_EXP 32
3386: IFFALSE 3458
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3388: LD_INT 3
3390: PPUSH
3391: LD_INT 3
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: LD_INT 11
3399: PPUSH
3400: LD_INT 100
3402: PPUSH
3403: CALL 56352 0 5
// veh := CreateVehicle ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: CALL_OW 45
3416: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3417: LD_VAR 0 3
3421: PPUSH
3422: LD_INT 3
3424: PPUSH
3425: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3429: LD_VAR 0 3
3433: PPUSH
3434: LD_INT 30
3436: PPUSH
3437: LD_INT 0
3439: PPUSH
3440: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3444: LD_EXP 32
3448: PPUSH
3449: LD_VAR 0 3
3453: PPUSH
3454: CALL_OW 52
// end ; if Roth then
3458: LD_EXP 18
3462: IFFALSE 3534
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3464: LD_INT 3
3466: PPUSH
3467: LD_INT 3
3469: PPUSH
3470: LD_INT 1
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: LD_INT 100
3478: PPUSH
3479: CALL 56352 0 5
// veh := CreateVehicle ;
3483: LD_ADDR_VAR 0 3
3487: PUSH
3488: CALL_OW 45
3492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3493: LD_VAR 0 3
3497: PPUSH
3498: LD_INT 3
3500: PPUSH
3501: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3505: LD_VAR 0 3
3509: PPUSH
3510: LD_INT 30
3512: PPUSH
3513: LD_INT 0
3515: PPUSH
3516: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3520: LD_EXP 18
3524: PPUSH
3525: LD_VAR 0 3
3529: PPUSH
3530: CALL_OW 52
// end ; if Denis then
3534: LD_EXP 23
3538: IFFALSE 3610
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3540: LD_INT 5
3542: PPUSH
3543: LD_INT 3
3545: PPUSH
3546: LD_INT 1
3548: PPUSH
3549: LD_INT 9
3551: PPUSH
3552: LD_INT 100
3554: PPUSH
3555: CALL 56352 0 5
// veh := CreateVehicle ;
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: CALL_OW 45
3568: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3569: LD_VAR 0 3
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3581: LD_VAR 0 3
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 0
3591: PPUSH
3592: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3596: LD_EXP 23
3600: PPUSH
3601: LD_VAR 0 3
3605: PPUSH
3606: CALL_OW 52
// end ; uc_nation := 3 ;
3610: LD_ADDR_OWVAR 21
3614: PUSH
3615: LD_INT 3
3617: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3618: LD_INT 22
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 100
3632: PPUSH
3633: CALL 56352 0 5
// veh := CreateVehicle ;
3637: LD_ADDR_VAR 0 3
3641: PUSH
3642: CALL_OW 45
3646: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3647: LD_VAR 0 3
3651: PPUSH
3652: LD_INT 7
3654: NEG
3655: PPUSH
3656: CALL_OW 242
// SetDir ( veh , 3 ) ;
3660: LD_VAR 0 3
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_INT 31
3679: PPUSH
3680: LD_INT 0
3682: PPUSH
3683: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3687: LD_EXP 49
3691: PPUSH
3692: LD_VAR 0 3
3696: PPUSH
3697: CALL_OW 52
// if Gossudarov then
3701: LD_EXP 35
3705: IFFALSE 3792
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3707: LD_INT 22
3709: PPUSH
3710: LD_INT 3
3712: PPUSH
3713: LD_INT 1
3715: PPUSH
3716: LD_INT 51
3718: PPUSH
3719: LD_INT 100
3721: PPUSH
3722: CALL 56352 0 5
// veh := CreateVehicle ;
3726: LD_ADDR_VAR 0 3
3730: PUSH
3731: CALL_OW 45
3735: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3736: LD_VAR 0 3
3740: PPUSH
3741: LD_INT 3
3743: PPUSH
3744: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3748: LD_VAR 0 3
3752: PPUSH
3753: LD_INT 30
3755: PPUSH
3756: LD_INT 0
3758: PPUSH
3759: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3763: LD_EXP 35
3767: PPUSH
3768: LD_VAR 0 3
3772: PPUSH
3773: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3777: LD_VAR 0 3
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 100
3787: PPUSH
3788: CALL_OW 290
// end ; for i in selected do
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: LD_VAR 0 4
3801: PUSH
3802: FOR_IN
3803: IFFALSE 4361
// begin uc_nation := GetNation ( i ) ;
3805: LD_ADDR_OWVAR 21
3809: PUSH
3810: LD_VAR 0 2
3814: PPUSH
3815: CALL_OW 248
3819: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3820: LD_VAR 0 2
3824: PUSH
3825: LD_EXP 19
3829: PUSH
3830: LD_EXP 20
3834: PUSH
3835: LD_EXP 22
3839: PUSH
3840: LD_EXP 21
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: IN
3851: IFFALSE 3874
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3853: LD_INT 5
3855: PPUSH
3856: LD_INT 3
3858: PPUSH
3859: LD_INT 1
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 100
3867: PPUSH
3868: CALL 56352 0 5
3872: GO 4308
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 42
3883: PUSH
3884: LD_EXP 47
3888: PUSH
3889: LD_EXP 45
3893: PUSH
3894: LD_EXP 37
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: IN
3905: IFFALSE 3936
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3907: LD_INT 24
3909: PPUSH
3910: LD_INT 1
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: LD_INT 46
3918: PPUSH
3919: LD_INT 65
3921: PPUSH
3922: LD_INT 75
3924: PPUSH
3925: CALL_OW 12
3929: PPUSH
3930: CALL 56352 0 5
3934: GO 4308
// if i = Karamazov then
3936: LD_VAR 0 2
3940: PUSH
3941: LD_EXP 48
3945: EQUAL
3946: IFFALSE 3969
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3948: LD_INT 22
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_INT 1
3956: PPUSH
3957: LD_INT 52
3959: PPUSH
3960: LD_INT 100
3962: PPUSH
3963: CALL 56352 0 5
3967: GO 4308
// if i = Brown then
3969: LD_VAR 0 2
3973: PUSH
3974: LD_EXP 24
3978: EQUAL
3979: IFFALSE 4002
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3981: LD_INT 3
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 13
3992: PPUSH
3993: LD_INT 100
3995: PPUSH
3996: CALL 56352 0 5
4000: GO 4308
// if uc_nation = nation_american then
4002: LD_OWVAR 21
4006: PUSH
4007: LD_INT 1
4009: EQUAL
4010: IFFALSE 4161
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4012: LD_INT 3
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: LD_INT 5
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: LIST
4025: PUSH
4026: LD_OWVAR 21
4030: PUSH
4031: LD_INT 3
4033: MOD
4034: PUSH
4035: LD_INT 1
4037: PLUS
4038: ARRAY
4039: PPUSH
4040: LD_INT 1
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: LIST
4053: PUSH
4054: LD_OWVAR 21
4058: PUSH
4059: LD_INT 3
4061: MOD
4062: PUSH
4063: LD_INT 1
4065: PLUS
4066: ARRAY
4067: PPUSH
4068: LD_INT 1
4070: PPUSH
4071: LD_INT 11
4073: PUSH
4074: LD_INT 4
4076: PUSH
4077: LD_INT 5
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 6
4087: PUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 9
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: PUSH
4099: LD_INT 6
4101: PUSH
4102: LD_INT 9
4104: PUSH
4105: LD_INT 12
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: PUSH
4118: LD_OWVAR 21
4122: PUSH
4123: LD_INT 3
4125: MOD
4126: PUSH
4127: LD_INT 1
4129: PLUS
4130: ARRAY
4131: PUSH
4132: LD_INT 1
4134: PPUSH
4135: LD_INT 3
4137: PPUSH
4138: CALL_OW 12
4142: ARRAY
4143: PPUSH
4144: LD_INT 65
4146: PPUSH
4147: LD_INT 75
4149: PPUSH
4150: CALL_OW 12
4154: PPUSH
4155: CALL 56352 0 5
// end else
4159: GO 4308
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4161: LD_INT 22
4163: PUSH
4164: LD_INT 23
4166: PUSH
4167: LD_INT 23
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: LIST
4174: PUSH
4175: LD_OWVAR 21
4179: PUSH
4180: LD_INT 3
4182: MOD
4183: PUSH
4184: LD_INT 1
4186: PLUS
4187: ARRAY
4188: PPUSH
4189: LD_INT 1
4191: PUSH
4192: LD_INT 3
4194: PUSH
4195: LD_INT 1
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: LIST
4202: PUSH
4203: LD_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: MOD
4211: PUSH
4212: LD_INT 1
4214: PLUS
4215: ARRAY
4216: PPUSH
4217: LD_INT 1
4219: PPUSH
4220: LD_INT 45
4222: PUSH
4223: LD_INT 43
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 46
4236: PUSH
4237: LD_INT 45
4239: PUSH
4240: LD_INT 44
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: LIST
4247: PUSH
4248: LD_INT 46
4250: PUSH
4251: LD_INT 43
4253: PUSH
4254: LD_INT 45
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: LIST
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_OWVAR 21
4271: PUSH
4272: LD_INT 3
4274: MOD
4275: PUSH
4276: LD_INT 1
4278: PLUS
4279: ARRAY
4280: PUSH
4281: LD_INT 1
4283: PPUSH
4284: LD_INT 3
4286: PPUSH
4287: CALL_OW 12
4291: ARRAY
4292: PPUSH
4293: LD_INT 65
4295: PPUSH
4296: LD_INT 75
4298: PPUSH
4299: CALL_OW 12
4303: PPUSH
4304: CALL 56352 0 5
// end ; veh := CreateVehicle ;
4308: LD_ADDR_VAR 0 3
4312: PUSH
4313: CALL_OW 45
4317: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4318: LD_VAR 0 3
4322: PPUSH
4323: LD_INT 3
4325: PPUSH
4326: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4330: LD_VAR 0 3
4334: PPUSH
4335: LD_INT 30
4337: PPUSH
4338: LD_INT 0
4340: PPUSH
4341: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4345: LD_VAR 0 2
4349: PPUSH
4350: LD_VAR 0 3
4354: PPUSH
4355: CALL_OW 52
// end ;
4359: GO 3802
4361: POP
4362: POP
// if artifactArCaptured then
4363: LD_EXP 9
4367: IFFALSE 4453
// begin uc_nation := nation_american ;
4369: LD_ADDR_OWVAR 21
4373: PUSH
4374: LD_INT 1
4376: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4377: LD_INT 3
4379: PPUSH
4380: LD_INT 3
4382: PPUSH
4383: LD_INT 3
4385: PPUSH
4386: LD_INT 12
4388: PPUSH
4389: LD_INT 100
4391: PPUSH
4392: CALL 56352 0 5
// veh := CreateVehicle ;
4396: LD_ADDR_VAR 0 3
4400: PUSH
4401: CALL_OW 45
4405: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4406: LD_VAR 0 3
4410: PPUSH
4411: LD_INT 3
4413: PPUSH
4414: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4418: LD_VAR 0 3
4422: PPUSH
4423: LD_INT 198
4425: PPUSH
4426: LD_INT 22
4428: PPUSH
4429: LD_INT 0
4431: PPUSH
4432: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4436: LD_VAR 0 3
4440: PPUSH
4441: LD_INT 4
4443: PPUSH
4444: LD_INT 50
4446: PPUSH
4447: CALL_OW 290
// end else
4451: GO 4472
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 5
4458: PPUSH
4459: LD_INT 267
4461: PPUSH
4462: LD_INT 226
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 58
// end ; uc_nation := nation_american ;
4472: LD_ADDR_OWVAR 21
4476: PUSH
4477: LD_INT 1
4479: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4480: LD_INT 3
4482: PPUSH
4483: LD_INT 3
4485: PPUSH
4486: LD_INT 3
4488: PPUSH
4489: LD_INT 12
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 56352 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4509: LD_VAR 0 3
4513: PPUSH
4514: LD_INT 3
4516: PPUSH
4517: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4521: LD_VAR 0 3
4525: PPUSH
4526: LD_INT 218
4528: PPUSH
4529: LD_INT 23
4531: PPUSH
4532: LD_INT 0
4534: PPUSH
4535: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4539: LD_VAR 0 3
4543: PPUSH
4544: LD_INT 4
4546: PPUSH
4547: LD_INT 30
4549: PPUSH
4550: CALL_OW 290
// uc_nation := nation_russian ;
4554: LD_ADDR_OWVAR 21
4558: PUSH
4559: LD_INT 3
4561: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4562: LD_INT 22
4564: PPUSH
4565: LD_INT 3
4567: PPUSH
4568: LD_INT 3
4570: PPUSH
4571: LD_INT 51
4573: PPUSH
4574: LD_INT 100
4576: PPUSH
4577: CALL 56352 0 5
// veh := CreateVehicle ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: CALL_OW 45
4590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 3
4598: PPUSH
4599: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4603: LD_VAR 0 3
4607: PPUSH
4608: LD_INT 214
4610: PPUSH
4611: LD_INT 20
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4621: LD_VAR 0 3
4625: PPUSH
4626: LD_INT 4
4628: PPUSH
4629: LD_INT 40
4631: PPUSH
4632: CALL_OW 290
// end ; end_of_file
4636: LD_VAR 0 1
4640: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
4650: PPUSH
4651: PPUSH
4652: PPUSH
// InitHc ;
4653: CALL_OW 19
// uc_side := 1 ;
4657: LD_ADDR_OWVAR 20
4661: PUSH
4662: LD_INT 1
4664: ST_TO_ADDR
// uc_nation := 1 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 1
4672: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4673: LD_ADDR_VAR 0 2
4677: PUSH
4678: LD_INT 22
4680: PUSH
4681: LD_INT 1
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 21
4690: PUSH
4691: LD_INT 3
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PPUSH
4702: CALL_OW 69
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4724
// SetBLevel ( i , 10 ) ;
4710: LD_VAR 0 2
4714: PPUSH
4715: LD_INT 10
4717: PPUSH
4718: CALL_OW 241
4722: GO 4707
4724: POP
4725: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4726: LD_INT 387
4728: PPUSH
4729: CALL_OW 274
4733: PPUSH
4734: LD_INT 1
4736: PPUSH
4737: LD_INT 7500
4739: PPUSH
4740: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4744: LD_INT 387
4746: PPUSH
4747: CALL_OW 274
4751: PPUSH
4752: LD_INT 2
4754: PPUSH
4755: LD_INT 4000
4757: PPUSH
4758: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4762: LD_INT 387
4764: PPUSH
4765: CALL_OW 274
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 50
4775: PPUSH
4776: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4780: LD_INT 476
4782: PPUSH
4783: CALL_OW 274
4787: PPUSH
4788: LD_INT 1
4790: PPUSH
4791: LD_INT 5500
4793: PPUSH
4794: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4798: LD_INT 476
4800: PPUSH
4801: CALL_OW 274
4805: PPUSH
4806: LD_INT 2
4808: PPUSH
4809: LD_INT 4000
4811: PPUSH
4812: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4816: LD_INT 476
4818: PPUSH
4819: CALL_OW 274
4823: PPUSH
4824: LD_INT 3
4826: PPUSH
4827: LD_INT 10
4829: PPUSH
4830: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4834: LD_ADDR_EXP 52
4838: PUSH
4839: LD_STRING Powell
4841: PPUSH
4842: CALL_OW 25
4846: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4847: LD_EXP 52
4851: PPUSH
4852: LD_INT 387
4854: PPUSH
4855: CALL_OW 52
// tmp := [ ] ;
4859: LD_ADDR_VAR 0 6
4863: PUSH
4864: EMPTY
4865: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4866: LD_ADDR_EXP 19
4870: PUSH
4871: LD_STRING Lisa
4873: PPUSH
4874: LD_EXP 1
4878: NOT
4879: PPUSH
4880: LD_STRING 12p_
4882: PPUSH
4883: CALL 51488 0 3
4887: ST_TO_ADDR
// if Lisa then
4888: LD_EXP 19
4892: IFFALSE 4910
// tmp := tmp ^ Lisa ;
4894: LD_ADDR_VAR 0 6
4898: PUSH
4899: LD_VAR 0 6
4903: PUSH
4904: LD_EXP 19
4908: ADD
4909: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4910: LD_ADDR_EXP 20
4914: PUSH
4915: LD_STRING Donaldson
4917: PPUSH
4918: LD_EXP 1
4922: NOT
4923: PPUSH
4924: LD_STRING 12p_
4926: PPUSH
4927: CALL 51488 0 3
4931: ST_TO_ADDR
// if Donaldson then
4932: LD_EXP 20
4936: IFFALSE 4954
// tmp := tmp ^ Donaldson ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_VAR 0 6
4947: PUSH
4948: LD_EXP 20
4952: ADD
4953: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4954: LD_ADDR_EXP 21
4958: PUSH
4959: LD_STRING Bobby
4961: PPUSH
4962: LD_EXP 1
4966: NOT
4967: PPUSH
4968: LD_STRING 12p_
4970: PPUSH
4971: CALL 51488 0 3
4975: ST_TO_ADDR
// if Bobby then
4976: LD_EXP 21
4980: IFFALSE 4998
// tmp := tmp ^ Bobby ;
4982: LD_ADDR_VAR 0 6
4986: PUSH
4987: LD_VAR 0 6
4991: PUSH
4992: LD_EXP 21
4996: ADD
4997: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4998: LD_ADDR_EXP 22
5002: PUSH
5003: LD_STRING Cyrus
5005: PPUSH
5006: LD_EXP 1
5010: NOT
5011: PPUSH
5012: LD_STRING 12p_
5014: PPUSH
5015: CALL 51488 0 3
5019: ST_TO_ADDR
// if Cyrus then
5020: LD_EXP 22
5024: IFFALSE 5042
// tmp := tmp ^ Cyrus ;
5026: LD_ADDR_VAR 0 6
5030: PUSH
5031: LD_VAR 0 6
5035: PUSH
5036: LD_EXP 22
5040: ADD
5041: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5042: LD_ADDR_EXP 24
5046: PUSH
5047: LD_STRING Brown
5049: PPUSH
5050: LD_EXP 1
5054: NOT
5055: PPUSH
5056: LD_STRING 12p_
5058: PPUSH
5059: CALL 51488 0 3
5063: ST_TO_ADDR
// if Brown then
5064: LD_EXP 24
5068: IFFALSE 5086
// tmp := tmp ^ Brown ;
5070: LD_ADDR_VAR 0 6
5074: PUSH
5075: LD_VAR 0 6
5079: PUSH
5080: LD_EXP 24
5084: ADD
5085: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5086: LD_ADDR_EXP 25
5090: PUSH
5091: LD_STRING Gladstone
5093: PPUSH
5094: LD_EXP 1
5098: NOT
5099: PPUSH
5100: LD_STRING 12p_
5102: PPUSH
5103: CALL 51488 0 3
5107: ST_TO_ADDR
// if Gladstone then
5108: LD_EXP 25
5112: IFFALSE 5130
// tmp := tmp ^ Gladstone ;
5114: LD_ADDR_VAR 0 6
5118: PUSH
5119: LD_VAR 0 6
5123: PUSH
5124: LD_EXP 25
5128: ADD
5129: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5130: LD_ADDR_EXP 26
5134: PUSH
5135: LD_STRING Houten
5137: PPUSH
5138: LD_EXP 1
5142: NOT
5143: PPUSH
5144: LD_STRING 12p_
5146: PPUSH
5147: CALL 51488 0 3
5151: ST_TO_ADDR
// if Houten then
5152: LD_EXP 26
5156: IFFALSE 5174
// tmp := tmp ^ Houten ;
5158: LD_ADDR_VAR 0 6
5162: PUSH
5163: LD_VAR 0 6
5167: PUSH
5168: LD_EXP 26
5172: ADD
5173: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5174: LD_ADDR_EXP 27
5178: PUSH
5179: LD_STRING Cornel
5181: PPUSH
5182: LD_EXP 1
5186: NOT
5187: PPUSH
5188: LD_STRING 12p_
5190: PPUSH
5191: CALL 51488 0 3
5195: ST_TO_ADDR
// if Cornel then
5196: LD_EXP 27
5200: IFFALSE 5218
// tmp := tmp ^ Cornel ;
5202: LD_ADDR_VAR 0 6
5206: PUSH
5207: LD_VAR 0 6
5211: PUSH
5212: LD_EXP 27
5216: ADD
5217: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5218: LD_ADDR_EXP 28
5222: PUSH
5223: LD_STRING Gary
5225: PPUSH
5226: LD_EXP 1
5230: NOT
5231: PPUSH
5232: LD_STRING 12p_
5234: PPUSH
5235: CALL 51488 0 3
5239: ST_TO_ADDR
// if Gary then
5240: LD_EXP 28
5244: IFFALSE 5262
// tmp := tmp ^ Gary ;
5246: LD_ADDR_VAR 0 6
5250: PUSH
5251: LD_VAR 0 6
5255: PUSH
5256: LD_EXP 28
5260: ADD
5261: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5262: LD_ADDR_EXP 30
5266: PUSH
5267: LD_STRING Kikuchi
5269: PPUSH
5270: LD_EXP 1
5274: NOT
5275: PPUSH
5276: LD_STRING 12p_
5278: PPUSH
5279: CALL 51488 0 3
5283: ST_TO_ADDR
// if Kikuchi then
5284: LD_EXP 30
5288: IFFALSE 5306
// tmp := tmp ^ Kikuchi ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_EXP 30
5304: ADD
5305: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5306: LD_ADDR_VAR 0 6
5310: PUSH
5311: LD_VAR 0 6
5315: PUSH
5316: LD_STRING 12p_others
5318: PPUSH
5319: CALL_OW 31
5323: UNION
5324: ST_TO_ADDR
// if tmp < 36 then
5325: LD_VAR 0 6
5329: PUSH
5330: LD_INT 36
5332: LESS
5333: IFFALSE 5400
// for i = 1 to 36 - tmp do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 36
5347: PUSH
5348: LD_VAR 0 6
5352: MINUS
5353: PUSH
5354: FOR_TO
5355: IFFALSE 5398
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5357: LD_INT 1
5359: PPUSH
5360: LD_VAR 0 2
5364: PUSH
5365: LD_INT 4
5367: MOD
5368: PUSH
5369: LD_INT 1
5371: PLUS
5372: PPUSH
5373: LD_INT 10
5375: PPUSH
5376: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5380: LD_ADDR_VAR 0 6
5384: PUSH
5385: LD_VAR 0 6
5389: PUSH
5390: CALL_OW 44
5394: ADD
5395: ST_TO_ADDR
// end ;
5396: GO 5354
5398: POP
5399: POP
// for i in tmp do
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_VAR 0 6
5409: PUSH
5410: FOR_IN
5411: IFFALSE 5436
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5413: LD_VAR 0 2
5417: PPUSH
5418: LD_INT 62
5420: PPUSH
5421: LD_INT 93
5423: PPUSH
5424: LD_INT 9
5426: PPUSH
5427: LD_INT 0
5429: PPUSH
5430: CALL_OW 50
5434: GO 5410
5436: POP
5437: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5438: LD_ADDR_EXP 93
5442: PUSH
5443: LD_EXP 93
5447: PPUSH
5448: LD_INT 4
5450: PPUSH
5451: LD_INT 22
5453: PUSH
5454: LD_INT 1
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: CALL_OW 69
5465: PUSH
5466: LD_EXP 52
5470: DIFF
5471: PPUSH
5472: CALL_OW 1
5476: ST_TO_ADDR
// uc_side := 0 ;
5477: LD_ADDR_OWVAR 20
5481: PUSH
5482: LD_INT 0
5484: ST_TO_ADDR
// uc_nation := 0 ;
5485: LD_ADDR_OWVAR 21
5489: PUSH
5490: LD_INT 0
5492: ST_TO_ADDR
// for i = 1 to 4 do
5493: LD_ADDR_VAR 0 2
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_INT 4
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5538
// begin InitHc ;
5509: CALL_OW 19
// hc_class := class_apeman ;
5513: LD_ADDR_OWVAR 28
5517: PUSH
5518: LD_INT 12
5520: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5521: CALL_OW 44
5525: PPUSH
5526: LD_INT 11
5528: PPUSH
5529: LD_INT 0
5531: PPUSH
5532: CALL_OW 49
// end ;
5536: GO 5506
5538: POP
5539: POP
// end ;
5540: LD_VAR 0 1
5544: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5545: LD_EXP 4
5549: NOT
5550: PUSH
5551: LD_INT 4
5553: PPUSH
5554: LD_INT 1
5556: PPUSH
5557: CALL 46500 0 2
5561: NOT
5562: AND
5563: IFFALSE 6335
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
5571: PPUSH
5572: PPUSH
// begin enable ;
5573: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5574: LD_INT 22
5576: PUSH
5577: LD_INT 1
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 23
5586: PUSH
5587: LD_INT 1
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: LD_INT 30
5596: PUSH
5597: LD_INT 3
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 69
5613: NOT
5614: IFFALSE 5618
// exit ;
5616: GO 6335
// if Prob ( 40 ) then
5618: LD_INT 40
5620: PPUSH
5621: CALL_OW 13
5625: IFFALSE 5752
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5627: LD_INT 4
5629: PPUSH
5630: LD_INT 5
5632: PUSH
5633: LD_INT 1
5635: PUSH
5636: LD_INT 2
5638: PUSH
5639: LD_INT 7
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: PUSH
5648: LD_INT 5
5650: PUSH
5651: LD_INT 1
5653: PUSH
5654: LD_INT 2
5656: PUSH
5657: LD_INT 7
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: PUSH
5666: LD_INT 5
5668: PUSH
5669: LD_INT 1
5671: PUSH
5672: LD_INT 2
5674: PUSH
5675: LD_INT 7
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: LD_INT 1
5689: PUSH
5690: LD_INT 2
5692: PUSH
5693: LD_INT 6
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_INT 5
5704: PUSH
5705: LD_INT 1
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 6
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: PUSH
5720: LD_INT 5
5722: PUSH
5723: LD_INT 1
5725: PUSH
5726: LD_INT 2
5728: PUSH
5729: LD_INT 6
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PPUSH
5746: CALL 45082 0 2
// end else
5750: GO 5875
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5752: LD_INT 4
5754: PPUSH
5755: LD_INT 5
5757: PUSH
5758: LD_INT 1
5760: PUSH
5761: LD_INT 2
5763: PUSH
5764: LD_INT 7
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 5
5775: PUSH
5776: LD_INT 1
5778: PUSH
5779: LD_INT 2
5781: PUSH
5782: LD_INT 9
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 5
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 9
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 5
5811: PUSH
5812: LD_INT 1
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 6
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: PUSH
5827: LD_INT 5
5829: PUSH
5830: LD_INT 1
5832: PUSH
5833: LD_INT 2
5835: PUSH
5836: LD_INT 6
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 5
5847: PUSH
5848: LD_INT 1
5850: PUSH
5851: LD_INT 2
5853: PUSH
5854: LD_INT 6
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: PPUSH
5871: CALL 45082 0 2
// end ; repeat wait ( 0 0$1 ) ;
5875: LD_INT 35
5877: PPUSH
5878: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5882: LD_INT 4
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: CALL 46500 0 2
5892: PUSH
5893: LD_INT 6
5895: GREATEREQUAL
5896: IFFALSE 5875
// wait ( 0 0$30 ) ;
5898: LD_INT 1050
5900: PPUSH
5901: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5905: LD_ADDR_VAR 0 2
5909: PUSH
5910: LD_INT 4
5912: PPUSH
5913: LD_INT 1
5915: PPUSH
5916: CALL 46500 0 2
5920: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5921: LD_ADDR_EXP 112
5925: PUSH
5926: LD_EXP 112
5930: PPUSH
5931: LD_INT 4
5933: PPUSH
5934: LD_EXP 112
5938: PUSH
5939: LD_INT 4
5941: ARRAY
5942: PUSH
5943: LD_VAR 0 2
5947: DIFF
5948: PPUSH
5949: CALL_OW 1
5953: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5954: LD_ADDR_VAR 0 3
5958: PUSH
5959: LD_INT 0
5961: PPUSH
5962: LD_INT 2
5964: PPUSH
5965: CALL_OW 12
5969: ST_TO_ADDR
// if target then
5970: LD_VAR 0 3
5974: IFFALSE 6102
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5976: LD_ADDR_VAR 0 2
5980: PUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: LD_INT 24
5988: PUSH
5989: LD_INT 250
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PPUSH
5996: CALL_OW 72
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 1
6005: PUSH
6006: LD_VAR 0 2
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6052
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_INT 114
6021: PPUSH
6022: LD_INT 108
6024: PPUSH
6025: CALL_OW 297
6029: PUSH
6030: LD_INT 9
6032: GREATER
6033: IFFALSE 6050
// ComMoveXY ( i , 114 , 108 ) ;
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 114
6042: PPUSH
6043: LD_INT 108
6045: PPUSH
6046: CALL_OW 111
6050: GO 6011
6052: POP
6053: POP
// wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6061: LD_VAR 0 2
6065: PPUSH
6066: LD_INT 92
6068: PUSH
6069: LD_INT 114
6071: PUSH
6072: LD_INT 108
6074: PUSH
6075: LD_INT 9
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 72
6088: PUSH
6089: LD_VAR 0 2
6093: PUSH
6094: LD_INT 1
6096: MINUS
6097: GREATEREQUAL
6098: IFFALSE 5976
// end else
6100: GO 6226
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 129
6147: PPUSH
6148: LD_INT 139
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 129 , 139 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 129
6168: PPUSH
6169: LD_INT 139
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 129
6197: PUSH
6198: LD_INT 139
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end ; repeat wait ( 0 0$1 ) ;
6226: LD_INT 35
6228: PPUSH
6229: CALL_OW 67
// for i in tmp do
6233: LD_ADDR_VAR 0 1
6237: PUSH
6238: LD_VAR 0 2
6242: PUSH
6243: FOR_IN
6244: IFFALSE 6326
// begin if GetLives ( i ) > 251 then
6246: LD_VAR 0 1
6250: PPUSH
6251: CALL_OW 256
6255: PUSH
6256: LD_INT 251
6258: GREATER
6259: IFFALSE 6297
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 81
6268: PUSH
6269: LD_INT 1
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 69
6280: PPUSH
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 74
6290: PPUSH
6291: CALL_OW 115
6295: GO 6324
// if IsDead ( i ) then
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 301
6306: IFFALSE 6324
// tmp := tmp diff i ;
6308: LD_ADDR_VAR 0 2
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_VAR 0 1
6322: DIFF
6323: ST_TO_ADDR
// end ;
6324: GO 6243
6326: POP
6327: POP
// until not tmp ;
6328: LD_VAR 0 2
6332: NOT
6333: IFFALSE 6226
// end ;
6335: PPOPN 3
6337: END
// every 30 30$00 trigger not americanDestroyed do
6338: LD_EXP 4
6342: NOT
6343: IFFALSE 6412
6345: GO 6347
6347: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6348: LD_INT 63000
6350: PUSH
6351: LD_INT 42000
6353: PUSH
6354: LD_INT 31500
6356: PUSH
6357: LD_INT 21000
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PUSH
6366: LD_OWVAR 67
6370: ARRAY
6371: PPUSH
6372: CALL_OW 67
// if americanDestroyed then
6376: LD_EXP 4
6380: IFFALSE 6384
// exit ;
6382: GO 6412
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6384: LD_INT 4
6386: PPUSH
6387: LD_INT 5
6389: PUSH
6390: LD_INT 3
6392: PUSH
6393: LD_INT 1
6395: PUSH
6396: LD_INT 8
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: EMPTY
6406: LIST
6407: PPUSH
6408: CALL 45082 0 2
// end ; end_of_file
6412: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6413: LD_INT 0
6415: PPUSH
6416: PPUSH
6417: PPUSH
6418: PPUSH
6419: PPUSH
// side := 2 ;
6420: LD_ADDR_VAR 0 5
6424: PUSH
6425: LD_INT 2
6427: ST_TO_ADDR
// InitHc ;
6428: CALL_OW 19
// uc_side := side ;
6432: LD_ADDR_OWVAR 20
6436: PUSH
6437: LD_VAR 0 5
6441: ST_TO_ADDR
// uc_nation := 2 ;
6442: LD_ADDR_OWVAR 21
6446: PUSH
6447: LD_INT 2
6449: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6450: LD_ADDR_VAR 0 2
6454: PUSH
6455: LD_INT 22
6457: PUSH
6458: LD_INT 2
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 21
6467: PUSH
6468: LD_INT 3
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PPUSH
6479: CALL_OW 69
6483: PUSH
6484: FOR_IN
6485: IFFALSE 6501
// SetBLevel ( i , 10 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 10
6494: PPUSH
6495: CALL_OW 241
6499: GO 6484
6501: POP
6502: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6503: LD_ADDR_VAR 0 4
6507: PUSH
6508: LD_INT 22
6510: PUSH
6511: LD_VAR 0 5
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 30
6522: PUSH
6523: LD_INT 32
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 58
6532: PUSH
6533: EMPTY
6534: LIST
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: PPUSH
6541: CALL_OW 69
6545: ST_TO_ADDR
// for i = 1 to 10 do
6546: LD_ADDR_VAR 0 2
6550: PUSH
6551: DOUBLE
6552: LD_INT 1
6554: DEC
6555: ST_TO_ADDR
6556: LD_INT 10
6558: PUSH
6559: FOR_TO
6560: IFFALSE 6632
// begin uc_nation := nation_nature ;
6562: LD_ADDR_OWVAR 21
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6570: LD_ADDR_OWVAR 28
6574: PUSH
6575: LD_INT 15
6577: ST_TO_ADDR
// hc_gallery :=  ;
6578: LD_ADDR_OWVAR 33
6582: PUSH
6583: LD_STRING 
6585: ST_TO_ADDR
// hc_name :=  ;
6586: LD_ADDR_OWVAR 26
6590: PUSH
6591: LD_STRING 
6593: ST_TO_ADDR
// un := CreateHuman ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: CALL_OW 44
6603: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6604: LD_VAR 0 3
6608: PPUSH
6609: LD_VAR 0 4
6613: PUSH
6614: LD_VAR 0 4
6618: PUSH
6619: LD_VAR 0 2
6623: MINUS
6624: ARRAY
6625: PPUSH
6626: CALL_OW 52
// end ;
6630: GO 6559
6632: POP
6633: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6634: LD_INT 503
6636: PPUSH
6637: LD_INT 27
6639: PPUSH
6640: LD_STRING 
6642: PPUSH
6643: LD_INT 8
6645: PUSH
6646: LD_INT 9
6648: PUSH
6649: LD_INT 10
6651: PUSH
6652: LD_INT 10
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_OWVAR 67
6665: ARRAY
6666: PPUSH
6667: LD_INT 3000
6669: PUSH
6670: LD_INT 500
6672: PUSH
6673: LD_INT 150
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: PPUSH
6681: LD_INT 16
6683: PUSH
6684: LD_INT 6
6686: PUSH
6687: LD_INT 6
6689: PUSH
6690: LD_INT 6
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: PPUSH
6699: CALL 59798 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6703: LD_ADDR_EXP 93
6707: PUSH
6708: LD_EXP 93
6712: PPUSH
6713: LD_INT 1
6715: PPUSH
6716: LD_INT 22
6718: PUSH
6719: LD_VAR 0 5
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 23
6730: PUSH
6731: LD_INT 2
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 3
6740: PUSH
6741: LD_INT 21
6743: PUSH
6744: LD_INT 2
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: PPUSH
6760: CALL_OW 69
6764: PPUSH
6765: CALL_OW 1
6769: ST_TO_ADDR
// end ;
6770: LD_VAR 0 1
6774: RET
// export Omar ; export function PrepareOmarAli ; begin
6775: LD_INT 0
6777: PPUSH
// uc_side := 5 ;
6778: LD_ADDR_OWVAR 20
6782: PUSH
6783: LD_INT 5
6785: ST_TO_ADDR
// uc_nation := 2 ;
6786: LD_ADDR_OWVAR 21
6790: PUSH
6791: LD_INT 2
6793: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6794: LD_ADDR_EXP 53
6798: PUSH
6799: LD_STRING Omar
6801: PPUSH
6802: CALL_OW 25
6806: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6807: LD_EXP 53
6811: PPUSH
6812: LD_INT 330
6814: PPUSH
6815: LD_INT 244
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6825: LD_EXP 53
6829: PPUSH
6830: LD_INT 252
6832: PPUSH
6833: LD_INT 220
6835: PPUSH
6836: CALL_OW 111
// end ; end_of_file
6840: LD_VAR 0 1
6844: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6845: LD_INT 0
6847: PPUSH
6848: PPUSH
6849: PPUSH
6850: PPUSH
6851: PPUSH
// side := 8 ;
6852: LD_ADDR_VAR 0 3
6856: PUSH
6857: LD_INT 8
6859: ST_TO_ADDR
// InitHc ;
6860: CALL_OW 19
// uc_side := side ;
6864: LD_ADDR_OWVAR 20
6868: PUSH
6869: LD_VAR 0 3
6873: ST_TO_ADDR
// uc_nation := 2 ;
6874: LD_ADDR_OWVAR 21
6878: PUSH
6879: LD_INT 2
6881: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6882: LD_ADDR_VAR 0 2
6886: PUSH
6887: LD_INT 22
6889: PUSH
6890: LD_VAR 0 3
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: LD_INT 21
6901: PUSH
6902: LD_INT 3
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: PUSH
6918: FOR_IN
6919: IFFALSE 6935
// SetBLevel ( i , 10 ) ;
6921: LD_VAR 0 2
6925: PPUSH
6926: LD_INT 10
6928: PPUSH
6929: CALL_OW 241
6933: GO 6918
6935: POP
6936: POP
// Schulz := NewCharacter ( Schulz ) ;
6937: LD_ADDR_EXP 54
6941: PUSH
6942: LD_STRING Schulz
6944: PPUSH
6945: CALL_OW 25
6949: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6950: LD_ADDR_EXP 55
6954: PUSH
6955: LD_STRING Kozlov
6957: PPUSH
6958: LD_INT 0
6960: PPUSH
6961: LD_STRING 
6963: PPUSH
6964: CALL 51488 0 3
6968: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6969: LD_EXP 55
6973: PPUSH
6974: LD_INT 22
6976: PUSH
6977: LD_INT 8
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 23
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 8
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: LD_INT 1
7016: ARRAY
7017: PPUSH
7018: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7022: LD_EXP 55
7026: PPUSH
7027: LD_INT 3
7029: PPUSH
7030: LD_INT 10
7032: PPUSH
7033: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7037: LD_ADDR_VAR 0 5
7041: PUSH
7042: LD_INT 22
7044: PUSH
7045: LD_VAR 0 3
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: LD_INT 30
7056: PUSH
7057: LD_INT 32
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 58
7066: PUSH
7067: EMPTY
7068: LIST
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 69
7079: ST_TO_ADDR
// for i = 1 to 10 do
7080: LD_ADDR_VAR 0 2
7084: PUSH
7085: DOUBLE
7086: LD_INT 1
7088: DEC
7089: ST_TO_ADDR
7090: LD_INT 10
7092: PUSH
7093: FOR_TO
7094: IFFALSE 7166
// begin uc_nation := nation_nature ;
7096: LD_ADDR_OWVAR 21
7100: PUSH
7101: LD_INT 0
7103: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7104: LD_ADDR_OWVAR 28
7108: PUSH
7109: LD_INT 15
7111: ST_TO_ADDR
// hc_gallery :=  ;
7112: LD_ADDR_OWVAR 33
7116: PUSH
7117: LD_STRING 
7119: ST_TO_ADDR
// hc_name :=  ;
7120: LD_ADDR_OWVAR 26
7124: PUSH
7125: LD_STRING 
7127: ST_TO_ADDR
// un := CreateHuman ;
7128: LD_ADDR_VAR 0 4
7132: PUSH
7133: CALL_OW 44
7137: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7138: LD_VAR 0 4
7142: PPUSH
7143: LD_VAR 0 5
7147: PUSH
7148: LD_VAR 0 5
7152: PUSH
7153: LD_VAR 0 2
7157: MINUS
7158: ARRAY
7159: PPUSH
7160: CALL_OW 52
// end ;
7164: GO 7093
7166: POP
7167: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7168: LD_INT 324
7170: PPUSH
7171: LD_INT 3
7173: PPUSH
7174: LD_STRING 
7176: PPUSH
7177: LD_INT 8
7179: PUSH
7180: LD_INT 9
7182: PUSH
7183: LD_INT 10
7185: PUSH
7186: LD_INT 10
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: PUSH
7195: LD_OWVAR 67
7199: ARRAY
7200: PPUSH
7201: LD_INT 3000
7203: PUSH
7204: LD_INT 500
7206: PUSH
7207: LD_INT 150
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: LIST
7214: PPUSH
7215: LD_INT 16
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: LD_INT 6
7223: PUSH
7224: LD_INT 8
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL 59798 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7237: LD_ADDR_EXP 93
7241: PUSH
7242: LD_EXP 93
7246: PPUSH
7247: LD_INT 3
7249: PPUSH
7250: LD_INT 22
7252: PUSH
7253: LD_VAR 0 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 23
7264: PUSH
7265: LD_INT 2
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 3
7274: PUSH
7275: LD_INT 21
7277: PUSH
7278: LD_INT 2
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: PPUSH
7294: CALL_OW 69
7298: PUSH
7299: LD_EXP 54
7303: DIFF
7304: PPUSH
7305: CALL_OW 1
7309: ST_TO_ADDR
// end ;
7310: LD_VAR 0 1
7314: RET
// export function BuildKozlovBomb ; begin
7315: LD_INT 0
7317: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7318: LD_INT 332
7320: PPUSH
7321: CALL_OW 302
7325: NOT
7326: PUSH
7327: LD_INT 336
7329: PPUSH
7330: CALL_OW 302
7334: NOT
7335: OR
7336: IFFALSE 7340
// exit ;
7338: GO 7437
// ComChangeProfession ( Kozlov , 4 ) ;
7340: LD_EXP 55
7344: PPUSH
7345: LD_INT 4
7347: PPUSH
7348: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7352: LD_INT 336
7354: PPUSH
7355: LD_INT 25
7357: PPUSH
7358: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7362: LD_INT 35
7364: PPUSH
7365: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7369: LD_INT 25
7371: PPUSH
7372: LD_INT 8
7374: PPUSH
7375: CALL_OW 321
7379: PUSH
7380: LD_INT 2
7382: EQUAL
7383: IFFALSE 7362
// ComExitBuilding ( Kozlov ) ;
7385: LD_EXP 55
7389: PPUSH
7390: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7394: LD_EXP 55
7398: PPUSH
7399: LD_INT 332
7401: PPUSH
7402: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7406: LD_EXP 55
7410: PPUSH
7411: LD_INT 3
7413: PPUSH
7414: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7418: LD_INT 332
7420: PPUSH
7421: LD_INT 23
7423: PPUSH
7424: LD_INT 3
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 48
7432: PPUSH
7433: CALL_OW 125
// end ;
7437: LD_VAR 0 1
7441: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7442: LD_EXP 3
7446: NOT
7447: PUSH
7448: LD_INT 3
7450: PPUSH
7451: LD_INT 1
7453: PPUSH
7454: CALL 46500 0 2
7458: NOT
7459: AND
7460: IFFALSE 8316
7462: GO 7464
7464: DISABLE
7465: LD_INT 0
7467: PPUSH
7468: PPUSH
7469: PPUSH
// begin enable ;
7470: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7471: LD_INT 22
7473: PUSH
7474: LD_INT 8
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PUSH
7481: LD_INT 23
7483: PUSH
7484: LD_INT 2
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 3
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: NOT
7511: IFFALSE 7515
// exit ;
7513: GO 8316
// if Prob ( 40 ) then
7515: LD_INT 40
7517: PPUSH
7518: CALL_OW 13
7522: IFFALSE 7649
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7524: LD_INT 3
7526: PPUSH
7527: LD_INT 14
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 2
7535: PUSH
7536: LD_INT 28
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 14
7547: PUSH
7548: LD_INT 1
7550: PUSH
7551: LD_INT 2
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 14
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 28
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 28
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 14
7601: PUSH
7602: LD_INT 1
7604: PUSH
7605: LD_INT 2
7607: PUSH
7608: LD_INT 28
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 14
7619: PUSH
7620: LD_INT 1
7622: PUSH
7623: LD_INT 2
7625: PUSH
7626: LD_INT 26
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: PPUSH
7643: CALL 45082 0 2
// end else
7647: GO 7856
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7649: LD_INT 3
7651: PPUSH
7652: LD_INT 14
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: LD_INT 2
7660: PUSH
7661: LD_INT 27
7663: PUSH
7664: LD_INT 26
7666: PUSH
7667: LD_INT 26
7669: PUSH
7670: LD_INT 28
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: PUSH
7679: LD_OWVAR 67
7683: ARRAY
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 14
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: LD_INT 2
7699: PUSH
7700: LD_INT 27
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 26
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_OWVAR 67
7722: ARRAY
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 14
7732: PUSH
7733: LD_INT 1
7735: PUSH
7736: LD_INT 2
7738: PUSH
7739: LD_INT 26
7741: PUSH
7742: LD_INT 26
7744: PUSH
7745: LD_INT 29
7747: PUSH
7748: LD_INT 29
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: PUSH
7757: LD_OWVAR 67
7761: ARRAY
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 13
7771: PUSH
7772: LD_INT 1
7774: PUSH
7775: LD_INT 2
7777: PUSH
7778: LD_INT 26
7780: PUSH
7781: LD_INT 29
7783: PUSH
7784: LD_INT 29
7786: PUSH
7787: LD_INT 29
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: LD_OWVAR 67
7800: ARRAY
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 13
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: LD_INT 2
7816: PUSH
7817: LD_INT 29
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 14
7828: PUSH
7829: LD_INT 1
7831: PUSH
7832: LD_INT 2
7834: PUSH
7835: LD_INT 26
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: PPUSH
7852: CALL 45082 0 2
// end ; repeat wait ( 0 0$1 ) ;
7856: LD_INT 35
7858: PPUSH
7859: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7863: LD_INT 3
7865: PPUSH
7866: LD_INT 1
7868: PPUSH
7869: CALL 46500 0 2
7873: PUSH
7874: LD_INT 6
7876: GREATEREQUAL
7877: IFFALSE 7856
// wait ( 0 0$30 ) ;
7879: LD_INT 1050
7881: PPUSH
7882: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7886: LD_ADDR_VAR 0 2
7890: PUSH
7891: LD_INT 3
7893: PPUSH
7894: LD_INT 1
7896: PPUSH
7897: CALL 46500 0 2
7901: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7902: LD_ADDR_EXP 112
7906: PUSH
7907: LD_EXP 112
7911: PPUSH
7912: LD_INT 3
7914: PPUSH
7915: LD_EXP 112
7919: PUSH
7920: LD_INT 3
7922: ARRAY
7923: PUSH
7924: LD_VAR 0 2
7928: DIFF
7929: PPUSH
7930: CALL_OW 1
7934: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7935: LD_ADDR_VAR 0 3
7939: PUSH
7940: LD_INT 0
7942: PPUSH
7943: LD_INT 2
7945: PPUSH
7946: CALL_OW 12
7950: ST_TO_ADDR
// if target then
7951: LD_VAR 0 3
7955: IFFALSE 8083
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7957: LD_ADDR_VAR 0 2
7961: PUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_INT 24
7969: PUSH
7970: LD_INT 250
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PPUSH
7977: CALL_OW 72
7981: ST_TO_ADDR
// for i in tmp do
7982: LD_ADDR_VAR 0 1
7986: PUSH
7987: LD_VAR 0 2
7991: PUSH
7992: FOR_IN
7993: IFFALSE 8033
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7995: LD_VAR 0 1
7999: PPUSH
8000: LD_INT 89
8002: PPUSH
8003: LD_INT 71
8005: PPUSH
8006: CALL_OW 297
8010: PUSH
8011: LD_INT 9
8013: GREATER
8014: IFFALSE 8031
// ComMoveXY ( i , 89 , 71 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 89
8023: PPUSH
8024: LD_INT 71
8026: PPUSH
8027: CALL_OW 111
8031: GO 7992
8033: POP
8034: POP
// wait ( 0 0$1 ) ;
8035: LD_INT 35
8037: PPUSH
8038: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8042: LD_VAR 0 2
8046: PPUSH
8047: LD_INT 92
8049: PUSH
8050: LD_INT 89
8052: PUSH
8053: LD_INT 71
8055: PUSH
8056: LD_INT 9
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: LIST
8063: LIST
8064: PPUSH
8065: CALL_OW 72
8069: PUSH
8070: LD_VAR 0 2
8074: PUSH
8075: LD_INT 1
8077: MINUS
8078: GREATEREQUAL
8079: IFFALSE 7957
// end else
8081: GO 8207
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: LD_VAR 0 2
8092: PPUSH
8093: LD_INT 24
8095: PUSH
8096: LD_INT 250
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 72
8107: ST_TO_ADDR
// for i in tmp do
8108: LD_ADDR_VAR 0 1
8112: PUSH
8113: LD_VAR 0 2
8117: PUSH
8118: FOR_IN
8119: IFFALSE 8159
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8121: LD_VAR 0 1
8125: PPUSH
8126: LD_INT 147
8128: PPUSH
8129: LD_INT 4
8131: PPUSH
8132: CALL_OW 297
8136: PUSH
8137: LD_INT 9
8139: GREATER
8140: IFFALSE 8157
// ComMoveXY ( i , 147 , 4 ) ;
8142: LD_VAR 0 1
8146: PPUSH
8147: LD_INT 147
8149: PPUSH
8150: LD_INT 4
8152: PPUSH
8153: CALL_OW 111
8157: GO 8118
8159: POP
8160: POP
// wait ( 0 0$1 ) ;
8161: LD_INT 35
8163: PPUSH
8164: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8168: LD_VAR 0 2
8172: PPUSH
8173: LD_INT 92
8175: PUSH
8176: LD_INT 147
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: LD_INT 9
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: PPUSH
8191: CALL_OW 72
8195: PUSH
8196: LD_VAR 0 2
8200: PUSH
8201: LD_INT 1
8203: MINUS
8204: GREATEREQUAL
8205: IFFALSE 8083
// end ; repeat wait ( 0 0$1 ) ;
8207: LD_INT 35
8209: PPUSH
8210: CALL_OW 67
// for i in tmp do
8214: LD_ADDR_VAR 0 1
8218: PUSH
8219: LD_VAR 0 2
8223: PUSH
8224: FOR_IN
8225: IFFALSE 8307
// begin if GetLives ( i ) > 251 then
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 256
8236: PUSH
8237: LD_INT 251
8239: GREATER
8240: IFFALSE 8278
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8242: LD_VAR 0 1
8246: PPUSH
8247: LD_INT 81
8249: PUSH
8250: LD_INT 8
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 69
8261: PPUSH
8262: LD_VAR 0 1
8266: PPUSH
8267: CALL_OW 74
8271: PPUSH
8272: CALL_OW 115
8276: GO 8305
// if IsDead ( i ) then
8278: LD_VAR 0 1
8282: PPUSH
8283: CALL_OW 301
8287: IFFALSE 8305
// tmp := tmp diff i ;
8289: LD_ADDR_VAR 0 2
8293: PUSH
8294: LD_VAR 0 2
8298: PUSH
8299: LD_VAR 0 1
8303: DIFF
8304: ST_TO_ADDR
// end ;
8305: GO 8224
8307: POP
8308: POP
// until not tmp ;
8309: LD_VAR 0 2
8313: NOT
8314: IFFALSE 8207
// end ;
8316: PPOPN 3
8318: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8319: LD_EXP 55
8323: PPUSH
8324: CALL_OW 302
8328: PUSH
8329: LD_EXP 3
8333: NOT
8334: AND
8335: IFFALSE 8344
8337: GO 8339
8339: DISABLE
// BuildKozlovBomb ;
8340: CALL 7315 0 0
8344: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 8
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 48
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PPUSH
8369: CALL_OW 69
8373: IFFALSE 8421
8375: GO 8377
8377: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8378: LD_INT 22
8380: PUSH
8381: LD_INT 8
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 34
8390: PUSH
8391: LD_INT 48
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: EMPTY
8399: LIST
8400: LIST
8401: PPUSH
8402: CALL_OW 69
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PPUSH
8411: LD_INT 173
8413: PPUSH
8414: LD_INT 96
8416: PPUSH
8417: CALL_OW 116
// end ; end_of_file
8421: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8422: LD_INT 0
8424: PPUSH
8425: PPUSH
8426: PPUSH
8427: PPUSH
8428: PPUSH
8429: PPUSH
8430: PPUSH
8431: PPUSH
8432: PPUSH
// side := 3 ;
8433: LD_ADDR_VAR 0 6
8437: PUSH
8438: LD_INT 3
8440: ST_TO_ADDR
// InitHc ;
8441: CALL_OW 19
// uc_side := side ;
8445: LD_ADDR_OWVAR 20
8449: PUSH
8450: LD_VAR 0 6
8454: ST_TO_ADDR
// uc_nation := 3 ;
8455: LD_ADDR_OWVAR 21
8459: PUSH
8460: LD_INT 3
8462: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_INT 22
8470: PUSH
8471: LD_VAR 0 6
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: LD_INT 21
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PUSH
8490: EMPTY
8491: LIST
8492: LIST
8493: PPUSH
8494: CALL_OW 69
8498: PUSH
8499: FOR_IN
8500: IFFALSE 8516
// SetBLevel ( i , 10 ) ;
8502: LD_VAR 0 2
8506: PPUSH
8507: LD_INT 10
8509: PPUSH
8510: CALL_OW 241
8514: GO 8499
8516: POP
8517: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8518: LD_ADDR_VAR 0 9
8522: PUSH
8523: LD_INT 22
8525: PUSH
8526: LD_VAR 0 6
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: LD_INT 30
8537: PUSH
8538: LD_INT 34
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PPUSH
8549: CALL_OW 69
8553: ST_TO_ADDR
// if teleport then
8554: LD_VAR 0 9
8558: IFFALSE 8579
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8560: LD_VAR 0 9
8564: PUSH
8565: LD_INT 1
8567: ARRAY
8568: PPUSH
8569: LD_INT 123
8571: PPUSH
8572: LD_INT 122
8574: PPUSH
8575: CALL_OW 243
// hc_importance := 0 ;
8579: LD_ADDR_OWVAR 32
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8587: LD_ADDR_EXP 56
8591: PUSH
8592: LD_STRING Platonov
8594: PPUSH
8595: CALL_OW 25
8599: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8600: LD_ADDR_EXP 57
8604: PUSH
8605: LD_STRING Yakotich
8607: PPUSH
8608: CALL_OW 25
8612: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8613: LD_ADDR_EXP 58
8617: PUSH
8618: LD_STRING Gleb
8620: PPUSH
8621: CALL_OW 25
8625: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8626: LD_STRING 03_Cornel
8628: PPUSH
8629: CALL_OW 28
8633: IFFALSE 8681
// begin Bierezov := NewCharacter ( Mikhail ) ;
8635: LD_ADDR_EXP 59
8639: PUSH
8640: LD_STRING Mikhail
8642: PPUSH
8643: CALL_OW 25
8647: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8648: LD_EXP 59
8652: PPUSH
8653: LD_INT 197
8655: PPUSH
8656: LD_INT 111
8658: PPUSH
8659: LD_INT 9
8661: PPUSH
8662: LD_INT 0
8664: PPUSH
8665: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8669: LD_EXP 59
8673: PPUSH
8674: LD_INT 3
8676: PPUSH
8677: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8681: LD_EXP 56
8685: PPUSH
8686: LD_INT 126
8688: PPUSH
8689: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8693: LD_EXP 57
8697: PPUSH
8698: LD_INT 197
8700: PPUSH
8701: LD_INT 111
8703: PPUSH
8704: LD_INT 9
8706: PPUSH
8707: LD_INT 0
8709: PPUSH
8710: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8714: LD_EXP 58
8718: PPUSH
8719: LD_INT 197
8721: PPUSH
8722: LD_INT 111
8724: PPUSH
8725: LD_INT 9
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8735: LD_ADDR_VAR 0 5
8739: PUSH
8740: LD_INT 126
8742: PPUSH
8743: LD_INT 2
8745: PPUSH
8746: LD_STRING zhukov
8748: PPUSH
8749: LD_INT 9
8751: PUSH
8752: LD_INT 10
8754: PUSH
8755: LD_INT 10
8757: PUSH
8758: LD_INT 10
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_OWVAR 67
8771: ARRAY
8772: PPUSH
8773: LD_INT 9000
8775: PUSH
8776: LD_INT 1000
8778: PUSH
8779: LD_INT 300
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: LIST
8786: PPUSH
8787: LD_INT 21
8789: PUSH
8790: LD_INT 8
8792: PUSH
8793: LD_INT 13
8795: PUSH
8796: LD_INT 8
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: PPUSH
8805: CALL 59798 0 6
8809: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 267
8817: PPUSH
8818: CALL_OW 274
8822: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8823: LD_VAR 0 4
8827: PPUSH
8828: LD_INT 1
8830: PPUSH
8831: LD_INT 5000
8833: PPUSH
8834: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 2
8845: PPUSH
8846: LD_INT 200
8848: PPUSH
8849: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: LD_INT 200
8863: PPUSH
8864: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8868: LD_ADDR_EXP 93
8872: PUSH
8873: LD_EXP 93
8877: PPUSH
8878: LD_INT 2
8880: PPUSH
8881: LD_VAR 0 5
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_VAR 0 6
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: LD_INT 3
8900: PUSH
8901: LD_INT 21
8903: PUSH
8904: LD_INT 2
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PPUSH
8919: CALL_OW 69
8923: UNION
8924: PUSH
8925: LD_EXP 56
8929: DIFF
8930: PPUSH
8931: CALL_OW 1
8935: ST_TO_ADDR
// behemoths := [ ] ;
8936: LD_ADDR_EXP 60
8940: PUSH
8941: EMPTY
8942: ST_TO_ADDR
// behemothBuilders := [ ] ;
8943: LD_ADDR_EXP 61
8947: PUSH
8948: EMPTY
8949: ST_TO_ADDR
// j := 3 ;
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: LD_INT 3
8957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8958: LD_ADDR_VAR 0 2
8962: PUSH
8963: LD_INT 22
8965: PUSH
8966: LD_INT 3
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 25
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: PPUSH
8987: CALL_OW 69
8991: PUSH
8992: FOR_IN
8993: IFFALSE 9043
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8995: LD_ADDR_EXP 61
8999: PUSH
9000: LD_EXP 61
9004: PPUSH
9005: LD_VAR 0 2
9009: PPUSH
9010: CALL 88225 0 2
9014: ST_TO_ADDR
// j := j - 1 ;
9015: LD_ADDR_VAR 0 3
9019: PUSH
9020: LD_VAR 0 3
9024: PUSH
9025: LD_INT 1
9027: MINUS
9028: ST_TO_ADDR
// if j = 0 then
9029: LD_VAR 0 3
9033: PUSH
9034: LD_INT 0
9036: EQUAL
9037: IFFALSE 9041
// break ;
9039: GO 9043
// end ;
9041: GO 8992
9043: POP
9044: POP
// end ;
9045: LD_VAR 0 1
9049: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9050: LD_INT 0
9052: PPUSH
9053: PPUSH
9054: PPUSH
9055: PPUSH
9056: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9057: LD_ADDR_VAR 0 4
9061: PUSH
9062: LD_INT 209
9064: PUSH
9065: LD_INT 149
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: LD_INT 219
9074: PUSH
9075: LD_INT 154
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 223
9084: PUSH
9085: LD_INT 149
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 232
9094: PUSH
9095: LD_INT 155
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: LIST
9106: LIST
9107: ST_TO_ADDR
// if not behemothBuilders then
9108: LD_EXP 61
9112: NOT
9113: IFFALSE 9117
// exit ;
9115: GO 9221
// j := 1 ;
9117: LD_ADDR_VAR 0 3
9121: PUSH
9122: LD_INT 1
9124: ST_TO_ADDR
// for i in behemothBuilders do
9125: LD_ADDR_VAR 0 2
9129: PUSH
9130: LD_EXP 61
9134: PUSH
9135: FOR_IN
9136: IFFALSE 9219
// begin if IsInUnit ( i ) then
9138: LD_VAR 0 2
9142: PPUSH
9143: CALL_OW 310
9147: IFFALSE 9158
// ComExitBuilding ( i ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9158: LD_VAR 0 2
9162: PPUSH
9163: LD_INT 37
9165: PPUSH
9166: LD_VAR 0 4
9170: PUSH
9171: LD_VAR 0 3
9175: ARRAY
9176: PUSH
9177: LD_INT 1
9179: ARRAY
9180: PPUSH
9181: LD_VAR 0 4
9185: PUSH
9186: LD_VAR 0 3
9190: ARRAY
9191: PUSH
9192: LD_INT 2
9194: ARRAY
9195: PPUSH
9196: LD_INT 0
9198: PPUSH
9199: CALL_OW 230
// j := j + 1 ;
9203: LD_ADDR_VAR 0 3
9207: PUSH
9208: LD_VAR 0 3
9212: PUSH
9213: LD_INT 1
9215: PLUS
9216: ST_TO_ADDR
// end ;
9217: GO 9135
9219: POP
9220: POP
// end ;
9221: LD_VAR 0 1
9225: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9226: LD_INT 3
9228: PPUSH
9229: CALL 88286 0 1
9233: PUSH
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 37
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: AND
9264: IFFALSE 9450
9266: GO 9268
9268: DISABLE
9269: LD_INT 0
9271: PPUSH
9272: PPUSH
// begin enable ;
9273: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9274: LD_ADDR_VAR 0 2
9278: PUSH
9279: LD_INT 3
9281: PPUSH
9282: CALL 88286 0 1
9286: ST_TO_ADDR
// for i in tmp do
9287: LD_ADDR_VAR 0 1
9291: PUSH
9292: LD_VAR 0 2
9296: PUSH
9297: FOR_IN
9298: IFFALSE 9448
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9300: LD_VAR 0 1
9304: PPUSH
9305: LD_INT 7
9307: PPUSH
9308: CALL_OW 308
9312: PUSH
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 110
9322: PUSH
9323: LD_INT 2
9325: EQUAL
9326: NOT
9327: AND
9328: IFFALSE 9342
// SetTag ( i , 2 ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9342: LD_INT 81
9344: PUSH
9345: LD_INT 3
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 91
9354: PUSH
9355: LD_VAR 0 1
9359: PUSH
9360: LD_INT 12
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: LIST
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PPUSH
9372: CALL_OW 69
9376: NOT
9377: PUSH
9378: LD_VAR 0 1
9382: PPUSH
9383: CALL_OW 110
9387: PUSH
9388: LD_INT 2
9390: EQUAL
9391: NOT
9392: AND
9393: IFFALSE 9412
// ComAgressiveMove ( i , 64 , 93 ) else
9395: LD_VAR 0 1
9399: PPUSH
9400: LD_INT 64
9402: PPUSH
9403: LD_INT 93
9405: PPUSH
9406: CALL_OW 114
9410: GO 9446
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9412: LD_VAR 0 1
9416: PPUSH
9417: LD_INT 81
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: PPUSH
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 74
9441: PPUSH
9442: CALL_OW 115
// end ;
9446: GO 9297
9448: POP
9449: POP
// end ;
9450: PPOPN 2
9452: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9453: LD_EXP 2
9457: NOT
9458: PUSH
9459: LD_INT 2
9461: PPUSH
9462: LD_INT 1
9464: PPUSH
9465: CALL 46500 0 2
9469: NOT
9470: AND
9471: IFFALSE 10395
9473: GO 9475
9475: DISABLE
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
// begin enable ;
9482: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9483: LD_INT 22
9485: PUSH
9486: LD_INT 3
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 30
9495: PUSH
9496: LD_INT 3
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PPUSH
9507: CALL_OW 69
9511: NOT
9512: IFFALSE 9516
// exit ;
9514: GO 10395
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9516: LD_ADDR_VAR 0 4
9520: PUSH
9521: LD_INT 22
9523: PUSH
9524: LD_INT 3
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 30
9533: PUSH
9534: LD_INT 34
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PPUSH
9545: CALL_OW 69
9549: ST_TO_ADDR
// if Prob ( 40 ) then
9550: LD_INT 40
9552: PPUSH
9553: CALL_OW 13
9557: IFFALSE 9684
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9559: LD_INT 2
9561: PPUSH
9562: LD_INT 22
9564: PUSH
9565: LD_INT 3
9567: PUSH
9568: LD_INT 3
9570: PUSH
9571: LD_INT 49
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 22
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 3
9588: PUSH
9589: LD_INT 49
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: PUSH
9598: LD_INT 22
9600: PUSH
9601: LD_INT 3
9603: PUSH
9604: LD_INT 3
9606: PUSH
9607: LD_INT 49
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: LD_INT 24
9618: PUSH
9619: LD_INT 3
9621: PUSH
9622: LD_INT 3
9624: PUSH
9625: LD_INT 46
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 24
9636: PUSH
9637: LD_INT 3
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: LD_INT 46
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: PUSH
9652: LD_INT 24
9654: PUSH
9655: LD_INT 3
9657: PUSH
9658: LD_INT 3
9660: PUSH
9661: LD_INT 46
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL 45082 0 2
// end else
9682: GO 9807
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9684: LD_INT 2
9686: PPUSH
9687: LD_INT 24
9689: PUSH
9690: LD_INT 3
9692: PUSH
9693: LD_INT 3
9695: PUSH
9696: LD_INT 47
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: LIST
9703: LIST
9704: PUSH
9705: LD_INT 24
9707: PUSH
9708: LD_INT 3
9710: PUSH
9711: LD_INT 3
9713: PUSH
9714: LD_INT 47
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: PUSH
9723: LD_INT 24
9725: PUSH
9726: LD_INT 3
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 47
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: PUSH
9741: LD_INT 24
9743: PUSH
9744: LD_INT 3
9746: PUSH
9747: LD_INT 3
9749: PUSH
9750: LD_INT 46
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 24
9761: PUSH
9762: LD_INT 3
9764: PUSH
9765: LD_INT 3
9767: PUSH
9768: LD_INT 46
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: PUSH
9777: LD_INT 24
9779: PUSH
9780: LD_INT 3
9782: PUSH
9783: LD_INT 3
9785: PUSH
9786: LD_INT 46
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: PPUSH
9803: CALL 45082 0 2
// end ; if Difficulty > 1 then
9807: LD_OWVAR 67
9811: PUSH
9812: LD_INT 1
9814: GREATER
9815: IFFALSE 9845
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9817: LD_INT 2
9819: PPUSH
9820: LD_INT 24
9822: PUSH
9823: LD_INT 3
9825: PUSH
9826: LD_INT 3
9828: PUSH
9829: LD_INT 47
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: PUSH
9838: EMPTY
9839: LIST
9840: PPUSH
9841: CALL 45082 0 2
// repeat wait ( 0 0$1 ) ;
9845: LD_INT 35
9847: PPUSH
9848: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
9852: LD_INT 2
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL 46500 0 2
9862: PUSH
9863: LD_INT 6
9865: PUSH
9866: LD_INT 7
9868: PUSH
9869: LD_INT 7
9871: PUSH
9872: LD_INT 7
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: PUSH
9881: LD_OWVAR 67
9885: ARRAY
9886: GREATEREQUAL
9887: IFFALSE 9845
// wait ( 0 0$30 ) ;
9889: LD_INT 1050
9891: PPUSH
9892: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9896: LD_ADDR_VAR 0 2
9900: PUSH
9901: LD_INT 2
9903: PPUSH
9904: LD_INT 1
9906: PPUSH
9907: CALL 46500 0 2
9911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9912: LD_ADDR_EXP 112
9916: PUSH
9917: LD_EXP 112
9921: PPUSH
9922: LD_INT 2
9924: PPUSH
9925: LD_EXP 112
9929: PUSH
9930: LD_INT 2
9932: ARRAY
9933: PUSH
9934: LD_VAR 0 2
9938: DIFF
9939: PPUSH
9940: CALL_OW 1
9944: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9945: LD_ADDR_VAR 0 3
9949: PUSH
9950: LD_INT 0
9952: PPUSH
9953: LD_INT 1
9955: PPUSH
9956: CALL_OW 12
9960: ST_TO_ADDR
// if target then
9961: LD_VAR 0 3
9965: IFFALSE 10093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9967: LD_ADDR_VAR 0 2
9971: PUSH
9972: LD_VAR 0 2
9976: PPUSH
9977: LD_INT 24
9979: PUSH
9980: LD_INT 250
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PPUSH
9987: CALL_OW 72
9991: ST_TO_ADDR
// for i in tmp do
9992: LD_ADDR_VAR 0 1
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: FOR_IN
10003: IFFALSE 10043
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10005: LD_VAR 0 1
10009: PPUSH
10010: LD_INT 139
10012: PPUSH
10013: LD_INT 89
10015: PPUSH
10016: CALL_OW 297
10020: PUSH
10021: LD_INT 9
10023: GREATER
10024: IFFALSE 10041
// ComMoveXY ( i , 139 , 89 ) ;
10026: LD_VAR 0 1
10030: PPUSH
10031: LD_INT 139
10033: PPUSH
10034: LD_INT 89
10036: PPUSH
10037: CALL_OW 111
10041: GO 10002
10043: POP
10044: POP
// wait ( 0 0$1 ) ;
10045: LD_INT 35
10047: PPUSH
10048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10052: LD_VAR 0 2
10056: PPUSH
10057: LD_INT 92
10059: PUSH
10060: LD_INT 139
10062: PUSH
10063: LD_INT 89
10065: PUSH
10066: LD_INT 9
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: PPUSH
10075: CALL_OW 72
10079: PUSH
10080: LD_VAR 0 2
10084: PUSH
10085: LD_INT 1
10087: MINUS
10088: GREATEREQUAL
10089: IFFALSE 9967
// end else
10091: GO 10235
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10093: LD_VAR 0 2
10097: PPUSH
10098: LD_VAR 0 4
10102: PUSH
10103: LD_INT 1
10105: ARRAY
10106: PPUSH
10107: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10111: LD_ADDR_VAR 0 2
10115: PUSH
10116: LD_VAR 0 2
10120: PPUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 250
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: ST_TO_ADDR
// for i in tmp do
10136: LD_ADDR_VAR 0 1
10140: PUSH
10141: LD_VAR 0 2
10145: PUSH
10146: FOR_IN
10147: IFFALSE 10187
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10149: LD_VAR 0 1
10153: PPUSH
10154: LD_INT 124
10156: PPUSH
10157: LD_INT 139
10159: PPUSH
10160: CALL_OW 297
10164: PUSH
10165: LD_INT 9
10167: GREATER
10168: IFFALSE 10185
// ComMoveXY ( i , 124 , 139 ) ;
10170: LD_VAR 0 1
10174: PPUSH
10175: LD_INT 124
10177: PPUSH
10178: LD_INT 139
10180: PPUSH
10181: CALL_OW 111
10185: GO 10146
10187: POP
10188: POP
// wait ( 0 0$1 ) ;
10189: LD_INT 35
10191: PPUSH
10192: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10196: LD_VAR 0 2
10200: PPUSH
10201: LD_INT 92
10203: PUSH
10204: LD_INT 124
10206: PUSH
10207: LD_INT 139
10209: PUSH
10210: LD_INT 9
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 72
10223: PUSH
10224: LD_VAR 0 2
10228: PUSH
10229: LD_INT 1
10231: MINUS
10232: GREATEREQUAL
10233: IFFALSE 10111
// end ; repeat wait ( 0 0$1 ) ;
10235: LD_INT 35
10237: PPUSH
10238: CALL_OW 67
// for i in tmp do
10242: LD_ADDR_VAR 0 1
10246: PUSH
10247: LD_VAR 0 2
10251: PUSH
10252: FOR_IN
10253: IFFALSE 10386
// begin if GetLives ( i ) > 251 then
10255: LD_VAR 0 1
10259: PPUSH
10260: CALL_OW 256
10264: PUSH
10265: LD_INT 251
10267: GREATER
10268: IFFALSE 10357
// begin if GetWeapon ( i ) = ru_time_lapser then
10270: LD_VAR 0 1
10274: PPUSH
10275: CALL_OW 264
10279: PUSH
10280: LD_INT 49
10282: EQUAL
10283: IFFALSE 10321
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10285: LD_VAR 0 1
10289: PPUSH
10290: LD_INT 81
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: PPUSH
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 74
10314: PPUSH
10315: CALL_OW 112
10319: GO 10355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 81
10328: PUSH
10329: LD_INT 3
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PPUSH
10336: CALL_OW 69
10340: PPUSH
10341: LD_VAR 0 1
10345: PPUSH
10346: CALL_OW 74
10350: PPUSH
10351: CALL_OW 115
// end else
10355: GO 10384
// if IsDead ( i ) then
10357: LD_VAR 0 1
10361: PPUSH
10362: CALL_OW 301
10366: IFFALSE 10384
// tmp := tmp diff i ;
10368: LD_ADDR_VAR 0 2
10372: PUSH
10373: LD_VAR 0 2
10377: PUSH
10378: LD_VAR 0 1
10382: DIFF
10383: ST_TO_ADDR
// end ;
10384: GO 10252
10386: POP
10387: POP
// until not tmp ;
10388: LD_VAR 0 2
10392: NOT
10393: IFFALSE 10235
// end ;
10395: PPOPN 4
10397: END
// every 30 30$00 trigger not russianDestroyed do
10398: LD_EXP 2
10402: NOT
10403: IFFALSE 10472
10405: GO 10407
10407: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10408: LD_INT 105000
10410: PUSH
10411: LD_INT 84000
10413: PUSH
10414: LD_INT 63000
10416: PUSH
10417: LD_INT 52500
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_OWVAR 67
10430: ARRAY
10431: PPUSH
10432: CALL_OW 67
// if russianDestroyed then
10436: LD_EXP 2
10440: IFFALSE 10444
// exit ;
10442: GO 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 23
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 1
10455: PUSH
10456: LD_INT 48
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 45082 0 2
// end ; end_of_file
10472: END
// export function CustomEvent ( event ) ; begin
10473: LD_INT 0
10475: PPUSH
// end ;
10476: LD_VAR 0 2
10480: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10481: LD_VAR 0 2
10485: PPUSH
10486: LD_VAR 0 3
10490: PPUSH
10491: LD_INT 15
10493: PPUSH
10494: CALL_OW 309
10498: IFFALSE 10507
// YouLost ( MothContaminate ) ;
10500: LD_STRING MothContaminate
10502: PPUSH
10503: CALL_OW 104
// end ;
10507: PPOPN 3
10509: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10510: LD_VAR 0 2
10514: PPUSH
10515: LD_VAR 0 3
10519: PPUSH
10520: LD_INT 15
10522: PPUSH
10523: CALL_OW 309
10527: IFFALSE 10543
// begin wait ( 0 0$6 ) ;
10529: LD_INT 210
10531: PPUSH
10532: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10536: LD_STRING MothContaminateBomb
10538: PPUSH
10539: CALL_OW 104
// end ; end ;
10543: PPOPN 3
10545: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10546: LD_VAR 0 1
10550: PUSH
10551: LD_EXP 17
10555: EQUAL
10556: IFFALSE 10567
// begin YouLost ( JMM ) ;
10558: LD_STRING JMM
10560: PPUSH
10561: CALL_OW 104
// exit ;
10565: GO 10666
// end ; if un = Powell then
10567: LD_VAR 0 1
10571: PUSH
10572: LD_EXP 52
10576: EQUAL
10577: IFFALSE 10587
// americanDestroyed := true ;
10579: LD_ADDR_EXP 4
10583: PUSH
10584: LD_INT 1
10586: ST_TO_ADDR
// if un = Platonov then
10587: LD_VAR 0 1
10591: PUSH
10592: LD_EXP 56
10596: EQUAL
10597: IFFALSE 10607
// russianDestroyed := true ;
10599: LD_ADDR_EXP 2
10603: PUSH
10604: LD_INT 1
10606: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10607: LD_VAR 0 1
10611: PUSH
10612: LD_INT 22
10614: PUSH
10615: LD_INT 7
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 21
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10657
// vehicleLostCounter := vehicleLostCounter + 1 ;
10643: LD_ADDR_EXP 15
10647: PUSH
10648: LD_EXP 15
10652: PUSH
10653: LD_INT 1
10655: PLUS
10656: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 48502 0 1
// end ;
10666: PPOPN 1
10668: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_VAR 0 2
10678: PPUSH
10679: CALL 50836 0 2
// end ;
10683: PPOPN 2
10685: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10686: LD_VAR 0 1
10690: PPUSH
10691: CALL 49904 0 1
// end ;
10695: PPOPN 1
10697: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10698: LD_VAR 0 1
10702: PUSH
10703: LD_INT 22
10705: PUSH
10706: LD_INT 8
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 30
10715: PUSH
10716: LD_INT 2
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 23
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 69
10742: IN
10743: IFFALSE 10770
// begin ComUpgrade ( building ) ;
10745: LD_VAR 0 1
10749: PPUSH
10750: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10754: LD_EXP 55
10758: PPUSH
10759: LD_VAR 0 1
10763: PPUSH
10764: CALL 59337 0 2
// exit ;
10768: GO 10779
// end ; MCE_BuildingComplete ( building ) ;
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL 50145 0 1
// end ;
10779: PPOPN 1
10781: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10782: LD_VAR 0 1
10786: PPUSH
10787: LD_VAR 0 2
10791: PPUSH
10792: CALL 48198 0 2
// end ;
10796: PPOPN 2
10798: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: LD_VAR 0 3
10813: PPUSH
10814: LD_VAR 0 4
10818: PPUSH
10819: LD_VAR 0 5
10823: PPUSH
10824: CALL 47818 0 5
// end ;
10828: PPOPN 5
10830: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10831: LD_VAR 0 1
10835: PPUSH
10836: LD_VAR 0 2
10840: PPUSH
10841: CALL 47399 0 2
// end ;
10845: PPOPN 2
10847: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10848: LD_VAR 0 1
10852: PPUSH
10853: LD_VAR 0 2
10857: PPUSH
10858: LD_VAR 0 3
10862: PPUSH
10863: LD_VAR 0 4
10867: PPUSH
10868: CALL 47237 0 4
// end ;
10872: PPOPN 4
10874: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: CALL 47012 0 3
// end ;
10894: PPOPN 3
10896: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_VAR 0 2
10906: PPUSH
10907: CALL 46897 0 2
// end ;
10911: PPOPN 2
10913: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10914: LD_VAR 0 1
10918: PPUSH
10919: LD_VAR 0 2
10923: PPUSH
10924: CALL 51131 0 2
// end ;
10928: PPOPN 2
10930: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_VAR 0 4
10950: PPUSH
10951: CALL 51347 0 4
// end ;
10955: PPOPN 4
10957: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: CALL 46706 0 2
// end ;
10972: PPOPN 2
10974: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10975: LD_VAR 0 1
10979: PPUSH
10980: CALL 104934 0 1
// end ; end_of_file
10984: PPOPN 1
10986: END
// export function Action ; begin
10987: LD_INT 0
10989: PPUSH
// InGameOn ;
10990: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10994: LD_INT 206
10996: PPUSH
10997: LD_INT 11
10999: PPUSH
11000: CALL_OW 86
// wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11011: LD_EXP 17
11015: PPUSH
11016: LD_STRING DStart-JMM-JMM-1
11018: PPUSH
11019: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11023: LD_EXP 49
11027: PPUSH
11028: LD_STRING DStart-JMM-Bur-1
11030: PPUSH
11031: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11035: LD_EXP 17
11039: PPUSH
11040: LD_STRING DStart-JMM-JMM-2
11042: PPUSH
11043: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11047: LD_EXP 49
11051: PPUSH
11052: LD_STRING DStart-JMM-Bur-2
11054: PPUSH
11055: CALL_OW 88
// InGameOff ;
11059: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11063: LD_STRING MStart
11065: PPUSH
11066: CALL_OW 337
// SaveForQuickRestart ;
11070: CALL_OW 22
// end ;
11074: LD_VAR 0 1
11078: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11079: LD_INT 7
11081: PPUSH
11082: LD_INT 255
11084: PPUSH
11085: LD_INT 219
11087: PPUSH
11088: CALL_OW 293
11092: IFFALSE 11701
11094: GO 11096
11096: DISABLE
11097: LD_INT 0
11099: PPUSH
// begin wait ( 0 0$3 ) ;
11100: LD_INT 105
11102: PPUSH
11103: CALL_OW 67
// alienSpotted := true ;
11107: LD_ADDR_EXP 10
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11115: LD_ADDR_VAR 0 1
11119: PUSH
11120: LD_INT 22
11122: PUSH
11123: LD_INT 7
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: PUSH
11130: LD_INT 23
11132: PUSH
11133: LD_INT 3
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PUSH
11140: LD_INT 21
11142: PUSH
11143: LD_INT 1
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: PUSH
11150: LD_INT 26
11152: PUSH
11153: LD_INT 1
11155: PUSH
11156: EMPTY
11157: LIST
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: PUSH
11171: LD_EXP 49
11175: PUSH
11176: LD_EXP 37
11180: PUSH
11181: LD_EXP 39
11185: PUSH
11186: LD_EXP 40
11190: PUSH
11191: LD_EXP 47
11195: PUSH
11196: LD_EXP 46
11200: PUSH
11201: LD_EXP 41
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: DIFF
11215: ST_TO_ADDR
// DialogueOn ;
11216: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11220: LD_INT 255
11222: PPUSH
11223: LD_INT 219
11225: PPUSH
11226: LD_INT 7
11228: PPUSH
11229: LD_INT 20
11231: NEG
11232: PPUSH
11233: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11237: LD_INT 255
11239: PPUSH
11240: LD_INT 219
11242: PPUSH
11243: CALL_OW 86
// if speaker then
11247: LD_VAR 0 1
11251: IFFALSE 11269
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11253: LD_VAR 0 1
11257: PUSH
11258: LD_INT 1
11260: ARRAY
11261: PPUSH
11262: LD_STRING DAlienBase-RSol1-1
11264: PPUSH
11265: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11269: LD_EXP 17
11273: PPUSH
11274: LD_STRING DAlienBase-JMM-1
11276: PPUSH
11277: CALL_OW 88
// if IsOk ( Burlak ) then
11281: LD_EXP 49
11285: PPUSH
11286: CALL_OW 302
11290: IFFALSE 11311
// begin dwait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11299: LD_EXP 49
11303: PPUSH
11304: LD_STRING DAlienBase-Bur-1
11306: PPUSH
11307: CALL_OW 88
// end ; if IsOk ( Roth ) then
11311: LD_EXP 18
11315: PPUSH
11316: CALL_OW 302
11320: IFFALSE 11334
// Say ( Roth , DAlienBase-Roth-1 ) ;
11322: LD_EXP 18
11326: PPUSH
11327: LD_STRING DAlienBase-Roth-1
11329: PPUSH
11330: CALL_OW 88
// if IsOk ( Gossudarov ) then
11334: LD_EXP 35
11338: PPUSH
11339: CALL_OW 302
11343: IFFALSE 11359
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11345: LD_EXP 35
11349: PPUSH
11350: LD_STRING DAlienBase-Gos-1
11352: PPUSH
11353: CALL_OW 88
11357: GO 11476
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11359: LD_ADDR_VAR 0 1
11363: PUSH
11364: LD_INT 22
11366: PUSH
11367: LD_INT 7
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 25
11376: PUSH
11377: LD_INT 4
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 21
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: PPUSH
11410: CALL_OW 69
11414: PUSH
11415: LD_EXP 18
11419: PUSH
11420: LD_EXP 17
11424: PUSH
11425: LD_EXP 49
11429: PUSH
11430: LD_EXP 37
11434: PUSH
11435: LD_EXP 47
11439: PUSH
11440: LD_EXP 46
11444: PUSH
11445: EMPTY
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: DIFF
11453: ST_TO_ADDR
// if speaker then
11454: LD_VAR 0 1
11458: IFFALSE 11476
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11460: LD_VAR 0 1
11464: PUSH
11465: LD_INT 1
11467: ARRAY
11468: PPUSH
11469: LD_STRING DAlienBase-Sci1-1
11471: PPUSH
11472: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11476: LD_INT 255
11478: PPUSH
11479: LD_INT 219
11481: PPUSH
11482: LD_INT 7
11484: PPUSH
11485: CALL_OW 331
// DialogueOff ;
11489: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11493: LD_INT 35
11495: PPUSH
11496: CALL_OW 67
// until IsSelected ( alien ) ;
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 306
11507: IFFALSE 11493
// if not artifactIResearched or not artifactIIResearched then
11509: LD_EXP 12
11513: NOT
11514: PUSH
11515: LD_EXP 13
11519: NOT
11520: OR
11521: IFFALSE 11701
// begin if IsOk ( Roth ) then
11523: LD_EXP 18
11527: PPUSH
11528: CALL_OW 302
11532: IFFALSE 11548
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11534: LD_EXP 18
11538: PPUSH
11539: LD_STRING DAlieBaseNotReady-Roth-1
11541: PPUSH
11542: CALL_OW 88
11546: GO 11701
// if IsOk ( Gossudarov ) then
11548: LD_EXP 35
11552: PPUSH
11553: CALL_OW 302
11557: IFFALSE 11573
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11559: LD_EXP 35
11563: PPUSH
11564: LD_STRING DAlieBaseNotReady-Gos-1
11566: PPUSH
11567: CALL_OW 88
11571: GO 11701
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11573: LD_ADDR_VAR 0 1
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_INT 7
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 23
11590: PUSH
11591: LD_INT 3
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: LD_INT 25
11600: PUSH
11601: LD_INT 4
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PUSH
11608: LD_INT 21
11610: PUSH
11611: LD_INT 1
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 26
11620: PUSH
11621: LD_INT 1
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: PPUSH
11635: CALL_OW 69
11639: PUSH
11640: LD_EXP 18
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 49
11654: PUSH
11655: LD_EXP 37
11659: PUSH
11660: LD_EXP 47
11664: PUSH
11665: LD_EXP 46
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: DIFF
11678: ST_TO_ADDR
// if speaker then
11679: LD_VAR 0 1
11683: IFFALSE 11701
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11685: LD_VAR 0 1
11689: PUSH
11690: LD_INT 1
11692: ARRAY
11693: PPUSH
11694: LD_STRING DAlieBaseNotReady-RSci1-1
11696: PPUSH
11697: CALL_OW 88
// end ; end ; end ;
11701: PPOPN 1
11703: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11704: LD_INT 24
11706: PPUSH
11707: LD_INT 7
11709: PPUSH
11710: CALL_OW 321
11714: PUSH
11715: LD_INT 2
11717: EQUAL
11718: IFFALSE 12409
11720: GO 11722
11722: DISABLE
11723: LD_INT 0
11725: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11726: LD_ADDR_VAR 0 1
11730: PUSH
11731: LD_INT 22
11733: PUSH
11734: LD_INT 7
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 23
11743: PUSH
11744: LD_INT 3
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: PUSH
11751: LD_INT 25
11753: PUSH
11754: LD_INT 4
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: PUSH
11761: LD_INT 21
11763: PUSH
11764: LD_INT 1
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: LD_INT 26
11773: PUSH
11774: LD_INT 1
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL_OW 69
11792: PUSH
11793: LD_EXP 18
11797: PUSH
11798: LD_EXP 17
11802: PUSH
11803: LD_EXP 49
11807: PUSH
11808: LD_EXP 37
11812: PUSH
11813: LD_EXP 47
11817: PUSH
11818: LD_EXP 46
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: DIFF
11831: ST_TO_ADDR
// if not speaker then
11832: LD_VAR 0 1
11836: NOT
11837: IFFALSE 11841
// exit ;
11839: GO 12409
// DialogueOn ;
11841: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11845: LD_VAR 0 1
11849: PUSH
11850: LD_INT 1
11852: ARRAY
11853: PPUSH
11854: LD_STRING DArtefTechnology-RSci1-1
11856: PPUSH
11857: CALL_OW 88
// if IsOk ( Burlak ) then
11861: LD_EXP 49
11865: PPUSH
11866: CALL_OW 302
11870: IFFALSE 11884
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11872: LD_EXP 49
11876: PPUSH
11877: LD_STRING DArtefTechnology-Bur-1
11879: PPUSH
11880: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11884: LD_VAR 0 1
11888: PUSH
11889: LD_INT 1
11891: ARRAY
11892: PPUSH
11893: LD_STRING DArtefTechnology-RSci1-2
11895: PPUSH
11896: CALL_OW 88
// if Denis then
11900: LD_EXP 23
11904: IFFALSE 11921
// speaker := [ Denis ] else
11906: LD_ADDR_VAR 0 1
11910: PUSH
11911: LD_EXP 23
11915: PUSH
11916: EMPTY
11917: LIST
11918: ST_TO_ADDR
11919: GO 12027
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11921: LD_ADDR_VAR 0 1
11925: PUSH
11926: LD_INT 22
11928: PUSH
11929: LD_INT 7
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 23
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 25
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 26
11968: PUSH
11969: LD_INT 1
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: PPUSH
11983: CALL_OW 69
11987: PUSH
11988: LD_EXP 18
11992: PUSH
11993: LD_EXP 17
11997: PUSH
11998: LD_EXP 49
12002: PUSH
12003: LD_EXP 37
12007: PUSH
12008: LD_EXP 47
12012: PUSH
12013: LD_EXP 46
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: DIFF
12026: ST_TO_ADDR
// if speaker then
12027: LD_VAR 0 1
12031: IFFALSE 12049
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12033: LD_VAR 0 1
12037: PUSH
12038: LD_INT 1
12040: ARRAY
12041: PPUSH
12042: LD_STRING DArtefTechnology-Sci1-2
12044: PPUSH
12045: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12049: LD_ADDR_VAR 0 1
12053: PUSH
12054: LD_INT 22
12056: PUSH
12057: LD_INT 7
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 3
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 25
12076: PUSH
12077: LD_INT 4
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 1
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 26
12096: PUSH
12097: LD_INT 1
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: PPUSH
12111: CALL_OW 69
12115: PUSH
12116: LD_EXP 18
12120: PUSH
12121: LD_EXP 17
12125: PUSH
12126: LD_EXP 49
12130: PUSH
12131: LD_EXP 37
12135: PUSH
12136: LD_EXP 47
12140: PUSH
12141: LD_EXP 46
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: DIFF
12154: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12155: LD_VAR 0 1
12159: PUSH
12160: LD_EXP 9
12164: PUSH
12165: LD_EXP 5
12169: OR
12170: AND
12171: IFFALSE 12405
// begin if arabianDestroyed and IsOk ( Burlak ) then
12173: LD_EXP 5
12177: PUSH
12178: LD_EXP 49
12182: PPUSH
12183: CALL_OW 302
12187: AND
12188: IFFALSE 12204
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12190: LD_EXP 49
12194: PPUSH
12195: LD_STRING DArtefTechnology-Bur-2
12197: PPUSH
12198: CALL_OW 88
12202: GO 12216
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12204: LD_EXP 17
12208: PPUSH
12209: LD_STRING DArtefTechnology-JMM-2
12211: PPUSH
12212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12216: LD_VAR 0 1
12220: PUSH
12221: LD_INT 1
12223: ARRAY
12224: PPUSH
12225: LD_STRING DArtefTechnology-RSci1-3
12227: PPUSH
12228: CALL_OW 88
// if Denis then
12232: LD_EXP 23
12236: IFFALSE 12253
// speaker := [ Denis ] else
12238: LD_ADDR_VAR 0 1
12242: PUSH
12243: LD_EXP 23
12247: PUSH
12248: EMPTY
12249: LIST
12250: ST_TO_ADDR
12251: GO 12359
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12253: LD_ADDR_VAR 0 1
12257: PUSH
12258: LD_INT 22
12260: PUSH
12261: LD_INT 7
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: PUSH
12268: LD_INT 23
12270: PUSH
12271: LD_INT 1
12273: PUSH
12274: EMPTY
12275: LIST
12276: LIST
12277: PUSH
12278: LD_INT 25
12280: PUSH
12281: LD_INT 4
12283: PUSH
12284: EMPTY
12285: LIST
12286: LIST
12287: PUSH
12288: LD_INT 21
12290: PUSH
12291: LD_INT 1
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: PUSH
12298: LD_INT 26
12300: PUSH
12301: LD_INT 1
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: PPUSH
12315: CALL_OW 69
12319: PUSH
12320: LD_EXP 18
12324: PUSH
12325: LD_EXP 17
12329: PUSH
12330: LD_EXP 49
12334: PUSH
12335: LD_EXP 37
12339: PUSH
12340: LD_EXP 47
12344: PUSH
12345: LD_EXP 46
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: DIFF
12358: ST_TO_ADDR
// if speaker then
12359: LD_VAR 0 1
12363: IFFALSE 12405
// if alienSpotted then
12365: LD_EXP 10
12369: IFFALSE 12389
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12371: LD_VAR 0 1
12375: PUSH
12376: LD_INT 1
12378: ARRAY
12379: PPUSH
12380: LD_STRING DArtefTechnology-Sci1-3
12382: PPUSH
12383: CALL_OW 88
12387: GO 12405
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12389: LD_VAR 0 1
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PPUSH
12398: LD_STRING DArtefTechnology-Sci1-3a
12400: PPUSH
12401: CALL_OW 88
// end ; DialogueOff ;
12405: CALL_OW 7
// end ;
12409: PPOPN 1
12411: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12412: LD_EXP 12
12416: IFFALSE 12611
12418: GO 12420
12420: DISABLE
12421: LD_INT 0
12423: PPUSH
// begin if Denis then
12424: LD_EXP 23
12428: IFFALSE 12445
// speaker := [ Denis ] else
12430: LD_ADDR_VAR 0 1
12434: PUSH
12435: LD_EXP 23
12439: PUSH
12440: EMPTY
12441: LIST
12442: ST_TO_ADDR
12443: GO 12551
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12445: LD_ADDR_VAR 0 1
12449: PUSH
12450: LD_INT 22
12452: PUSH
12453: LD_INT 7
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 23
12462: PUSH
12463: LD_INT 1
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 21
12482: PUSH
12483: LD_INT 1
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 26
12492: PUSH
12493: LD_INT 1
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: PPUSH
12507: CALL_OW 69
12511: PUSH
12512: LD_EXP 18
12516: PUSH
12517: LD_EXP 17
12521: PUSH
12522: LD_EXP 49
12526: PUSH
12527: LD_EXP 37
12531: PUSH
12532: LD_EXP 47
12536: PUSH
12537: LD_EXP 46
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: DIFF
12550: ST_TO_ADDR
// if not speaker then
12551: LD_VAR 0 1
12555: NOT
12556: IFFALSE 12560
// exit ;
12558: GO 12611
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12560: LD_VAR 0 1
12564: PUSH
12565: LD_INT 1
12567: ARRAY
12568: PPUSH
12569: LD_STRING DArtefTechnologyAm-Sci1-1
12571: PPUSH
12572: CALL_OW 88
// if IsOk ( Burlak ) then
12576: LD_EXP 49
12580: PPUSH
12581: CALL_OW 302
12585: IFFALSE 12599
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12587: LD_EXP 49
12591: PPUSH
12592: LD_STRING DArtefTechnologyAm-Bur-1
12594: PPUSH
12595: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12599: LD_EXP 17
12603: PPUSH
12604: LD_STRING DArtefTechnologyAm-JMM-1
12606: PPUSH
12607: CALL_OW 88
// end ;
12611: PPOPN 1
12613: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12614: LD_EXP 13
12618: IFFALSE 12808
12620: GO 12622
12622: DISABLE
12623: LD_INT 0
12625: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12626: LD_ADDR_VAR 0 1
12630: PUSH
12631: LD_INT 22
12633: PUSH
12634: LD_INT 7
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 23
12643: PUSH
12644: LD_INT 3
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 4
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 21
12663: PUSH
12664: LD_INT 1
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: LD_INT 26
12673: PUSH
12674: LD_INT 1
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: LIST
12687: PPUSH
12688: CALL_OW 69
12692: PUSH
12693: LD_EXP 18
12697: PUSH
12698: LD_EXP 17
12702: PUSH
12703: LD_EXP 49
12707: PUSH
12708: LD_EXP 37
12712: PUSH
12713: LD_EXP 47
12717: PUSH
12718: LD_EXP 46
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: DIFF
12731: ST_TO_ADDR
// if not speaker then
12732: LD_VAR 0 1
12736: NOT
12737: IFFALSE 12741
// exit ;
12739: GO 12808
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12741: LD_VAR 0 1
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: PPUSH
12750: LD_STRING DArtefTechnologyRu-RSci1-1
12752: PPUSH
12753: CALL_OW 88
// if IsOk ( Burlak ) then
12757: LD_EXP 49
12761: PPUSH
12762: CALL_OW 302
12766: IFFALSE 12780
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12768: LD_EXP 49
12772: PPUSH
12773: LD_STRING DArtefTechnologyRu-Bur-1
12775: PPUSH
12776: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12780: LD_VAR 0 1
12784: PUSH
12785: LD_INT 1
12787: ARRAY
12788: PPUSH
12789: LD_STRING DArtefTechnologyRu-RSci1-2
12791: PPUSH
12792: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12796: LD_EXP 17
12800: PPUSH
12801: LD_STRING DArtefTechnologyRu-JMM-1
12803: PPUSH
12804: CALL_OW 88
// end ;
12808: PPOPN 1
12810: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12811: LD_INT 24
12813: PPUSH
12814: LD_INT 7
12816: PPUSH
12817: CALL_OW 321
12821: PUSH
12822: LD_INT 2
12824: EQUAL
12825: PUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 255
12833: PUSH
12834: LD_INT 7
12836: EQUAL
12837: AND
12838: IFFALSE 12998
12840: GO 12842
12842: DISABLE
12843: LD_INT 0
12845: PPUSH
// begin if Denis then
12846: LD_EXP 23
12850: IFFALSE 12867
// speaker := [ Denis ] else
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_EXP 23
12861: PUSH
12862: EMPTY
12863: LIST
12864: ST_TO_ADDR
12865: GO 12973
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12867: LD_ADDR_VAR 0 1
12871: PUSH
12872: LD_INT 22
12874: PUSH
12875: LD_INT 7
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PUSH
12882: LD_INT 23
12884: PUSH
12885: LD_INT 1
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 25
12894: PUSH
12895: LD_INT 4
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 21
12904: PUSH
12905: LD_INT 1
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 26
12914: PUSH
12915: LD_INT 1
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: PUSH
12934: LD_EXP 18
12938: PUSH
12939: LD_EXP 17
12943: PUSH
12944: LD_EXP 49
12948: PUSH
12949: LD_EXP 37
12953: PUSH
12954: LD_EXP 47
12958: PUSH
12959: LD_EXP 46
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: DIFF
12972: ST_TO_ADDR
// if not speaker then
12973: LD_VAR 0 1
12977: NOT
12978: IFFALSE 12982
// exit ;
12980: GO 12998
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12982: LD_VAR 0 1
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: LD_STRING DArtefTechnologyArStart-Sci1-1
12993: PPUSH
12994: CALL_OW 88
// end ;
12998: PPOPN 1
13000: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13001: LD_EXP 14
13005: IFFALSE 13286
13007: GO 13009
13009: DISABLE
13010: LD_INT 0
13012: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_INT 22
13020: PUSH
13021: LD_INT 7
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 23
13030: PUSH
13031: LD_INT 3
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 25
13040: PUSH
13041: LD_INT 4
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: LD_INT 21
13050: PUSH
13051: LD_INT 1
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PUSH
13058: LD_INT 26
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: PUSH
13080: LD_EXP 18
13084: PUSH
13085: LD_EXP 17
13089: PUSH
13090: LD_EXP 49
13094: PUSH
13095: LD_EXP 37
13099: PUSH
13100: LD_EXP 47
13104: PUSH
13105: LD_EXP 46
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: DIFF
13118: ST_TO_ADDR
// if not speaker then
13119: LD_VAR 0 1
13123: NOT
13124: IFFALSE 13128
// exit ;
13126: GO 13286
// DialogueOn ;
13128: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-1
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-1
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-2
13171: PPUSH
13172: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13176: LD_EXP 17
13180: PPUSH
13181: LD_STRING DArtefTechnologyAr-JMM-2
13183: PPUSH
13184: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 1
13195: ARRAY
13196: PPUSH
13197: LD_STRING DArtefTechnologyAr-RSci1-3
13199: PPUSH
13200: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13204: LD_EXP 17
13208: PPUSH
13209: LD_STRING DArtefTechnologyAr-JMM-3
13211: PPUSH
13212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13216: LD_VAR 0 1
13220: PUSH
13221: LD_INT 1
13223: ARRAY
13224: PPUSH
13225: LD_STRING DArtefTechnologyAr-RSci1-4
13227: PPUSH
13228: CALL_OW 88
// if IsOk ( Burlak ) then
13232: LD_EXP 49
13236: PPUSH
13237: CALL_OW 302
13241: IFFALSE 13255
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13243: LD_EXP 49
13247: PPUSH
13248: LD_STRING DArtefTechnologyAr-Bur-4
13250: PPUSH
13251: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13255: LD_EXP 17
13259: PPUSH
13260: LD_STRING DArtefTechnologyAr-JMM-4
13262: PPUSH
13263: CALL_OW 88
// DialogueOff ;
13267: CALL_OW 7
// wait ( 0 0$45 ) ;
13271: LD_INT 1575
13273: PPUSH
13274: CALL_OW 67
// spawnOmar := true ;
13278: LD_ADDR_EXP 11
13282: PUSH
13283: LD_INT 1
13285: ST_TO_ADDR
// end ;
13286: PPOPN 1
13288: END
// every 0 0$1 trigger spawnOmar do
13289: LD_EXP 11
13293: IFFALSE 13673
13295: GO 13297
13297: DISABLE
// begin PrepareOmarAli ;
13298: CALL 6775 0 0
// if not HasTask ( Omar ) then
13302: LD_EXP 53
13306: PPUSH
13307: CALL_OW 314
13311: NOT
13312: IFFALSE 13329
// ComMoveXY ( Omar , 252 , 220 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_INT 252
13321: PPUSH
13322: LD_INT 220
13324: PPUSH
13325: CALL_OW 111
// if not Omar then
13329: LD_EXP 53
13333: NOT
13334: IFFALSE 13338
// exit ;
13336: GO 13673
// repeat wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13345: LD_EXP 53
13349: PPUSH
13350: CALL_OW 314
13354: NOT
13355: PUSH
13356: LD_EXP 53
13360: PPUSH
13361: LD_INT 252
13363: PPUSH
13364: LD_INT 220
13366: PPUSH
13367: CALL_OW 297
13371: PUSH
13372: LD_INT 6
13374: GREATER
13375: AND
13376: IFFALSE 13393
// ComMoveXY ( Omar , 252 , 220 ) ;
13378: LD_EXP 53
13382: PPUSH
13383: LD_INT 252
13385: PPUSH
13386: LD_INT 220
13388: PPUSH
13389: CALL_OW 111
// until See ( 7 , Omar ) ;
13393: LD_INT 7
13395: PPUSH
13396: LD_EXP 53
13400: PPUSH
13401: CALL_OW 292
13405: IFFALSE 13338
// CenterNowOnUnits ( Omar ) ;
13407: LD_EXP 53
13411: PPUSH
13412: CALL_OW 87
// DialogueOn ;
13416: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13420: LD_EXP 53
13424: PPUSH
13425: LD_STRING DOmar-Omar-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DOmar-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13444: LD_EXP 53
13448: PPUSH
13449: LD_STRING DOmar-Omar-2
13451: PPUSH
13452: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13456: LD_EXP 17
13460: PPUSH
13461: LD_STRING DOmar-JMM-2
13463: PPUSH
13464: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13468: LD_EXP 53
13472: PPUSH
13473: LD_STRING DOmar-Omar-3
13475: PPUSH
13476: CALL_OW 88
// if IsOk ( Burlak ) then
13480: LD_EXP 49
13484: PPUSH
13485: CALL_OW 302
13489: IFFALSE 13505
// Say ( Burlak , DOmar-Bur-3 ) else
13491: LD_EXP 49
13495: PPUSH
13496: LD_STRING DOmar-Bur-3
13498: PPUSH
13499: CALL_OW 88
13503: GO 13517
// Say ( JMM , DOmar-JMM-3 ) ;
13505: LD_EXP 17
13509: PPUSH
13510: LD_STRING DOmar-JMM-3
13512: PPUSH
13513: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13517: LD_EXP 53
13521: PPUSH
13522: LD_STRING DOmar-Omar-4
13524: PPUSH
13525: CALL_OW 88
// case Query ( QAccept ) of 1 :
13529: LD_STRING QAccept
13531: PPUSH
13532: CALL_OW 97
13536: PUSH
13537: LD_INT 1
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13581
13545: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13546: LD_EXP 17
13550: PPUSH
13551: LD_STRING DQrAccept#1-JMM-1
13553: PPUSH
13554: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13558: LD_EXP 53
13562: PPUSH
13563: LD_INT 7
13565: PPUSH
13566: CALL_OW 235
// ComStop ( Omar ) ;
13570: LD_EXP 53
13574: PPUSH
13575: CALL_OW 141
// end ; 2 :
13579: GO 13630
13581: LD_INT 2
13583: DOUBLE
13584: EQUAL
13585: IFTRUE 13589
13587: GO 13629
13589: POP
// begin if IsOk ( Burlak ) then
13590: LD_EXP 49
13594: PPUSH
13595: CALL_OW 302
13599: IFFALSE 13615
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13601: LD_EXP 49
13605: PPUSH
13606: LD_STRING DQrAccept#2-Bur-1
13608: PPUSH
13609: CALL_OW 88
13613: GO 13627
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13615: LD_EXP 17
13619: PPUSH
13620: LD_STRING DQrAccept#2-JMM-1
13622: PPUSH
13623: CALL_OW 88
// end ; end ;
13627: GO 13630
13629: POP
// DialogueOff ;
13630: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 255
13643: PUSH
13644: LD_INT 7
13646: EQUAL
13647: IFFALSE 13658
// begin SetAchievement ( ACH_OMAR ) ;
13649: LD_STRING ACH_OMAR
13651: PPUSH
13652: CALL_OW 543
// exit ;
13656: GO 13673
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13658: LD_EXP 53
13662: PPUSH
13663: LD_INT 202
13665: PPUSH
13666: LD_INT 115
13668: PPUSH
13669: CALL_OW 111
// end ;
13673: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13674: LD_EXP 53
13678: PPUSH
13679: LD_INT 200
13681: PPUSH
13682: LD_INT 98
13684: PPUSH
13685: CALL_OW 297
13689: PUSH
13690: LD_INT 40
13692: LESS
13693: PUSH
13694: LD_EXP 2
13698: AND
13699: IFFALSE 13917
13701: GO 13703
13703: DISABLE
// begin SetSide ( Omar , 5 ) ;
13704: LD_EXP 53
13708: PPUSH
13709: LD_INT 5
13711: PPUSH
13712: CALL_OW 235
// if IsInUnit ( Omar ) then
13716: LD_EXP 53
13720: PPUSH
13721: CALL_OW 310
13725: IFFALSE 13736
// ComExitVehicle ( Omar ) ;
13727: LD_EXP 53
13731: PPUSH
13732: CALL_OW 121
// if IsInUnit ( Omar ) then
13736: LD_EXP 53
13740: PPUSH
13741: CALL_OW 310
13745: IFFALSE 13756
// ComExitBuilding ( Omar ) ;
13747: LD_EXP 53
13751: PPUSH
13752: CALL_OW 122
// wait ( 0 0$1 ) ;
13756: LD_INT 35
13758: PPUSH
13759: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13763: LD_EXP 53
13767: PPUSH
13768: LD_INT 203
13770: PPUSH
13771: LD_INT 120
13773: PPUSH
13774: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13778: LD_INT 35
13780: PPUSH
13781: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13785: LD_EXP 53
13789: PPUSH
13790: CALL_OW 306
13794: PUSH
13795: LD_EXP 53
13799: PPUSH
13800: LD_INT 203
13802: PPUSH
13803: LD_INT 120
13805: PPUSH
13806: CALL_OW 297
13810: PUSH
13811: LD_INT 6
13813: LESS
13814: OR
13815: IFFALSE 13778
// CenterNowOnUnits ( Omar ) ;
13817: LD_EXP 53
13821: PPUSH
13822: CALL_OW 87
// DialogueOn ;
13826: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13830: LD_EXP 17
13834: PPUSH
13835: LD_STRING DOmarContam-JMM-1
13837: PPUSH
13838: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13842: LD_EXP 53
13846: PPUSH
13847: LD_STRING DOmarContam-Omar-1
13849: PPUSH
13850: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13854: LD_EXP 17
13858: PPUSH
13859: LD_STRING DOmarContam-JMM-2
13861: PPUSH
13862: CALL_OW 88
// DialogueOff ;
13866: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13870: LD_INT 5
13872: PPUSH
13873: LD_INT 7
13875: PPUSH
13876: LD_INT 2
13878: PPUSH
13879: LD_INT 1
13881: PPUSH
13882: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13886: LD_INT 105
13888: PPUSH
13889: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13893: LD_EXP 53
13897: PPUSH
13898: LD_INT 203
13900: PPUSH
13901: LD_INT 120
13903: PPUSH
13904: CALL_OW 307
13908: IFFALSE 13886
// YouLost ( MothContaminate ) ;
13910: LD_STRING MothContaminate
13912: PPUSH
13913: CALL_OW 104
// end ;
13917: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13918: LD_EXP 4
13922: NOT
13923: PUSH
13924: LD_INT 22
13926: PUSH
13927: LD_INT 1
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: LD_INT 34
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PPUSH
13948: CALL_OW 69
13952: AND
13953: IFFALSE 14072
13955: GO 13957
13957: DISABLE
// begin wait ( 0 0$5 ) ;
13958: LD_INT 175
13960: PPUSH
13961: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13965: LD_EXP 52
13969: PPUSH
13970: CALL_OW 302
13974: NOT
13975: PUSH
13976: LD_INT 22
13978: PUSH
13979: LD_INT 1
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 34
13988: PUSH
13989: LD_INT 8
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PPUSH
14000: CALL_OW 69
14004: NOT
14005: OR
14006: IFFALSE 14010
// exit ;
14008: GO 14072
// DialogueOn ;
14010: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14014: LD_EXP 52
14018: PPUSH
14019: LD_STRING DWinAmericans-Pow-1
14021: PPUSH
14022: CALL_OW 94
// if IsOk ( Burlak ) then
14026: LD_EXP 49
14030: PPUSH
14031: CALL_OW 302
14035: IFFALSE 14049
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14037: LD_EXP 49
14041: PPUSH
14042: LD_STRING DWinAmericans-Bur-1
14044: PPUSH
14045: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14049: LD_EXP 17
14053: PPUSH
14054: LD_STRING DWinAmericans-JMM-1
14056: PPUSH
14057: CALL_OW 88
// DialogueOff ;
14061: CALL_OW 7
// YouLost ( AmBomb ) ;
14065: LD_STRING AmBomb
14067: PPUSH
14068: CALL_OW 104
// end ;
14072: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14073: LD_EXP 2
14077: NOT
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 3
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 34
14091: PUSH
14092: LD_INT 48
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: CALL_OW 69
14107: AND
14108: IFFALSE 14227
14110: GO 14112
14112: DISABLE
// begin wait ( 0 0$5 ) ;
14113: LD_INT 175
14115: PPUSH
14116: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14120: LD_EXP 56
14124: PPUSH
14125: CALL_OW 302
14129: NOT
14130: PUSH
14131: LD_INT 22
14133: PUSH
14134: LD_INT 3
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: LD_INT 34
14143: PUSH
14144: LD_INT 48
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PPUSH
14155: CALL_OW 69
14159: NOT
14160: OR
14161: IFFALSE 14165
// exit ;
14163: GO 14227
// DialogueOn ;
14165: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14169: LD_EXP 56
14173: PPUSH
14174: LD_STRING DWinRussians-Pla-1
14176: PPUSH
14177: CALL_OW 94
// if IsOk ( Burlak ) then
14181: LD_EXP 49
14185: PPUSH
14186: CALL_OW 302
14190: IFFALSE 14204
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14192: LD_EXP 49
14196: PPUSH
14197: LD_STRING DWinRussians-Bur-1
14199: PPUSH
14200: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14204: LD_EXP 17
14208: PPUSH
14209: LD_STRING DWinRussians-JMM-1
14211: PPUSH
14212: CALL_OW 88
// DialogueOff ;
14216: CALL_OW 7
// YouLost ( RuBomb ) ;
14220: LD_STRING RuBomb
14222: PPUSH
14223: CALL_OW 104
// end ;
14227: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14228: LD_INT 7
14230: PPUSH
14231: LD_INT 22
14233: PUSH
14234: LD_INT 7
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PPUSH
14241: CALL_OW 70
14245: PUSH
14246: LD_EXP 4
14250: NOT
14251: AND
14252: IFFALSE 14281
14254: GO 14256
14256: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14257: LD_EXP 52
14261: PPUSH
14262: LD_STRING DSurrenderAmericans-Pow-1
14264: PPUSH
14265: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14269: LD_EXP 17
14273: PPUSH
14274: LD_STRING DSurrenderAmericans-JMM-1
14276: PPUSH
14277: CALL_OW 88
// end ;
14281: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14282: LD_INT 2
14284: PPUSH
14285: LD_INT 22
14287: PUSH
14288: LD_INT 7
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 70
14299: PUSH
14300: LD_EXP 2
14304: NOT
14305: AND
14306: PUSH
14307: LD_EXP 49
14311: AND
14312: IFFALSE 14341
14314: GO 14316
14316: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14317: LD_EXP 56
14321: PPUSH
14322: LD_STRING DSurrenderRussians-Pla-1
14324: PPUSH
14325: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14329: LD_EXP 49
14333: PPUSH
14334: LD_STRING DSurrenderRussians-Bur-1
14336: PPUSH
14337: CALL_OW 88
// end ;
14341: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14342: LD_EXP 4
14346: IFFALSE 14729
14348: GO 14350
14350: DISABLE
14351: LD_INT 0
14353: PPUSH
14354: PPUSH
14355: PPUSH
// begin MC_Kill ( 4 ) ;
14356: LD_INT 4
14358: PPUSH
14359: CALL 21104 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14363: LD_INT 1
14365: PPUSH
14366: LD_INT 7
14368: PPUSH
14369: LD_INT 1
14371: PPUSH
14372: LD_INT 1
14374: PPUSH
14375: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14379: LD_ADDR_VAR 0 3
14383: PUSH
14384: LD_INT 22
14386: PUSH
14387: LD_INT 1
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 26
14396: PUSH
14397: LD_INT 1
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: LD_INT 23
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: LIST
14418: PPUSH
14419: CALL_OW 69
14423: PUSH
14424: LD_EXP 52
14428: PUSH
14429: LD_EXP 25
14433: PUSH
14434: LD_EXP 22
14438: PUSH
14439: LD_EXP 21
14443: PUSH
14444: LD_EXP 28
14448: PUSH
14449: LD_EXP 26
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: DIFF
14462: ST_TO_ADDR
// if speaker then
14463: LD_VAR 0 3
14467: IFFALSE 14493
// begin DialogueOn ;
14469: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14473: LD_VAR 0 3
14477: PUSH
14478: LD_INT 1
14480: ARRAY
14481: PPUSH
14482: LD_STRING DSurrenderAmericans-Sol1-1a
14484: PPUSH
14485: CALL_OW 94
// DialogueOff ;
14489: CALL_OW 7
// end ; americanCapitulated := true ;
14493: LD_ADDR_EXP 6
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14501: LD_ADDR_VAR 0 2
14505: PUSH
14506: LD_INT 22
14508: PUSH
14509: LD_INT 1
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PUSH
14516: LD_INT 21
14518: PUSH
14519: LD_INT 1
14521: PUSH
14522: EMPTY
14523: LIST
14524: LIST
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PPUSH
14530: CALL_OW 69
14534: PUSH
14535: LD_INT 22
14537: PUSH
14538: LD_INT 1
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: LD_INT 21
14547: PUSH
14548: LD_INT 2
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: PUSH
14555: LD_INT 1
14557: PUSH
14558: EMPTY
14559: LIST
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: LIST
14565: PPUSH
14566: CALL_OW 69
14570: ADD
14571: ST_TO_ADDR
// if tmp then
14572: LD_VAR 0 2
14576: IFFALSE 14729
// repeat wait ( 0 0$1 ) ;
14578: LD_INT 35
14580: PPUSH
14581: CALL_OW 67
// for i in tmp do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_VAR 0 2
14594: PUSH
14595: FOR_IN
14596: IFFALSE 14678
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14598: LD_VAR 0 1
14602: PPUSH
14603: CALL_OW 310
14607: PUSH
14608: LD_VAR 0 1
14612: PPUSH
14613: CALL_OW 310
14617: PPUSH
14618: CALL_OW 247
14622: PUSH
14623: LD_INT 3
14625: EQUAL
14626: AND
14627: IFFALSE 14638
// ComExitBuilding ( i ) ;
14629: LD_VAR 0 1
14633: PPUSH
14634: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14638: LD_VAR 0 1
14642: PPUSH
14643: LD_INT 122
14645: PPUSH
14646: LD_INT 242
14648: PPUSH
14649: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14653: LD_VAR 0 1
14657: PPUSH
14658: LD_INT 35
14660: PPUSH
14661: CALL_OW 308
14665: IFFALSE 14676
// RemoveUnit ( i ) ;
14667: LD_VAR 0 1
14671: PPUSH
14672: CALL_OW 64
// end ;
14676: GO 14595
14678: POP
14679: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14680: LD_INT 22
14682: PUSH
14683: LD_INT 1
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: LD_INT 2
14692: PUSH
14693: LD_INT 21
14695: PUSH
14696: LD_INT 1
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: LD_INT 33
14705: PUSH
14706: LD_INT 1
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: PPUSH
14722: CALL_OW 69
14726: NOT
14727: IFFALSE 14578
// end ;
14729: PPOPN 3
14731: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14732: LD_EXP 2
14736: IFFALSE 15137
14738: GO 14740
14740: DISABLE
14741: LD_INT 0
14743: PPUSH
14744: PPUSH
14745: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14746: LD_INT 35
14748: PPUSH
14749: CALL_OW 67
// until IsDead ( Yakotich ) ;
14753: LD_EXP 57
14757: PPUSH
14758: CALL_OW 301
14762: IFFALSE 14746
// MC_Kill ( 2 ) ;
14764: LD_INT 2
14766: PPUSH
14767: CALL 21104 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14771: LD_INT 3
14773: PPUSH
14774: LD_INT 7
14776: PPUSH
14777: LD_INT 1
14779: PPUSH
14780: LD_INT 1
14782: PPUSH
14783: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14787: LD_ADDR_VAR 0 3
14791: PUSH
14792: LD_INT 22
14794: PUSH
14795: LD_INT 3
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 26
14804: PUSH
14805: LD_INT 1
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 23
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 69
14831: PUSH
14832: LD_EXP 56
14836: PUSH
14837: LD_EXP 57
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: DIFF
14846: ST_TO_ADDR
// if speaker then
14847: LD_VAR 0 3
14851: IFFALSE 14901
// begin DialogueOn ;
14853: CALL_OW 6
// if Burlak then
14857: LD_EXP 49
14861: IFFALSE 14881
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14863: LD_VAR 0 3
14867: PUSH
14868: LD_INT 1
14870: ARRAY
14871: PPUSH
14872: LD_STRING DSurrenderRussians-RSol1-1
14874: PPUSH
14875: CALL_OW 94
14879: GO 14897
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14881: LD_VAR 0 3
14885: PUSH
14886: LD_INT 1
14888: ARRAY
14889: PPUSH
14890: LD_STRING DSurrenderRussians-RSol1-1a
14892: PPUSH
14893: CALL_OW 94
// DialogueOff ;
14897: CALL_OW 7
// end ; russianCapitulated := true ;
14901: LD_ADDR_EXP 7
14905: PUSH
14906: LD_INT 1
14908: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14909: LD_ADDR_VAR 0 2
14913: PUSH
14914: LD_INT 22
14916: PUSH
14917: LD_INT 3
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: LD_INT 21
14926: PUSH
14927: LD_INT 1
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: PPUSH
14938: CALL_OW 69
14942: PUSH
14943: LD_INT 22
14945: PUSH
14946: LD_INT 3
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 1
14965: PUSH
14966: EMPTY
14967: LIST
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL_OW 69
14978: ADD
14979: ST_TO_ADDR
// if tmp then
14980: LD_VAR 0 2
14984: IFFALSE 15137
// repeat wait ( 0 0$1 ) ;
14986: LD_INT 35
14988: PPUSH
14989: CALL_OW 67
// for i in tmp do
14993: LD_ADDR_VAR 0 1
14997: PUSH
14998: LD_VAR 0 2
15002: PUSH
15003: FOR_IN
15004: IFFALSE 15086
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15006: LD_VAR 0 1
15010: PPUSH
15011: CALL_OW 310
15015: PUSH
15016: LD_VAR 0 1
15020: PPUSH
15021: CALL_OW 310
15025: PPUSH
15026: CALL_OW 247
15030: PUSH
15031: LD_INT 3
15033: EQUAL
15034: AND
15035: IFFALSE 15046
// ComExitBuilding ( i ) ;
15037: LD_VAR 0 1
15041: PPUSH
15042: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15046: LD_VAR 0 1
15050: PPUSH
15051: LD_INT 154
15053: PPUSH
15054: LD_INT 1
15056: PPUSH
15057: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 36
15068: PPUSH
15069: CALL_OW 308
15073: IFFALSE 15084
// RemoveUnit ( i ) ;
15075: LD_VAR 0 1
15079: PPUSH
15080: CALL_OW 64
// end ;
15084: GO 15003
15086: POP
15087: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15088: LD_INT 22
15090: PUSH
15091: LD_INT 3
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PUSH
15098: LD_INT 2
15100: PUSH
15101: LD_INT 21
15103: PUSH
15104: LD_INT 1
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PUSH
15111: LD_INT 33
15113: PUSH
15114: LD_INT 1
15116: PUSH
15117: EMPTY
15118: LIST
15119: LIST
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: PPUSH
15130: CALL_OW 69
15134: NOT
15135: IFFALSE 14986
// end ;
15137: PPOPN 3
15139: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15140: LD_INT 22
15142: PUSH
15143: LD_INT 8
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PUSH
15150: LD_INT 21
15152: PUSH
15153: LD_INT 1
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 23
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PPUSH
15175: CALL_OW 69
15179: PUSH
15180: LD_INT 18
15182: LESS
15183: PUSH
15184: LD_EXP 55
15188: PPUSH
15189: CALL_OW 301
15193: OR
15194: PUSH
15195: LD_INT 324
15197: PPUSH
15198: CALL_OW 255
15202: PUSH
15203: LD_INT 7
15205: EQUAL
15206: OR
15207: IFFALSE 15220
15209: GO 15211
15211: DISABLE
// legionDestroyed := true ;
15212: LD_ADDR_EXP 3
15216: PUSH
15217: LD_INT 1
15219: ST_TO_ADDR
15220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15221: LD_INT 22
15223: PUSH
15224: LD_INT 2
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: PUSH
15231: LD_INT 21
15233: PUSH
15234: LD_INT 1
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PUSH
15241: LD_INT 23
15243: PUSH
15244: LD_INT 2
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: PPUSH
15256: CALL_OW 69
15260: PUSH
15261: LD_INT 9
15263: LESS
15264: IFFALSE 15277
15266: GO 15268
15268: DISABLE
// arabianDestroyed := true ;
15269: LD_ADDR_EXP 5
15273: PUSH
15274: LD_INT 1
15276: ST_TO_ADDR
15277: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15278: LD_EXP 5
15282: IFFALSE 15526
15284: GO 15286
15286: DISABLE
15287: LD_INT 0
15289: PPUSH
15290: PPUSH
// begin MC_Kill ( 1 ) ;
15291: LD_INT 1
15293: PPUSH
15294: CALL 21104 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15298: LD_ADDR_VAR 0 2
15302: PUSH
15303: LD_INT 22
15305: PUSH
15306: LD_INT 2
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: PUSH
15313: LD_INT 21
15315: PUSH
15316: LD_INT 1
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL_OW 69
15331: PUSH
15332: LD_INT 22
15334: PUSH
15335: LD_INT 8
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PUSH
15342: LD_INT 21
15344: PUSH
15345: LD_INT 2
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: LD_INT 1
15354: PUSH
15355: EMPTY
15356: LIST
15357: PUSH
15358: EMPTY
15359: LIST
15360: LIST
15361: LIST
15362: PPUSH
15363: CALL_OW 69
15367: ADD
15368: ST_TO_ADDR
// if tmp then
15369: LD_VAR 0 2
15373: IFFALSE 15526
// repeat wait ( 0 0$1 ) ;
15375: LD_INT 35
15377: PPUSH
15378: CALL_OW 67
// for i in tmp do
15382: LD_ADDR_VAR 0 1
15386: PUSH
15387: LD_VAR 0 2
15391: PUSH
15392: FOR_IN
15393: IFFALSE 15475
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15395: LD_VAR 0 1
15399: PPUSH
15400: CALL_OW 310
15404: PUSH
15405: LD_VAR 0 1
15409: PPUSH
15410: CALL_OW 310
15414: PPUSH
15415: CALL_OW 247
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15435
// ComExitBuilding ( i ) ;
15426: LD_VAR 0 1
15430: PPUSH
15431: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_INT 254
15442: PPUSH
15443: LD_INT 268
15445: PPUSH
15446: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15450: LD_VAR 0 1
15454: PPUSH
15455: LD_INT 34
15457: PPUSH
15458: CALL_OW 308
15462: IFFALSE 15473
// RemoveUnit ( i ) ;
15464: LD_VAR 0 1
15468: PPUSH
15469: CALL_OW 64
// end ;
15473: GO 15392
15475: POP
15476: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15477: LD_INT 22
15479: PUSH
15480: LD_INT 2
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: PUSH
15487: LD_INT 2
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 33
15502: PUSH
15503: LD_INT 1
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PPUSH
15519: CALL_OW 69
15523: NOT
15524: IFFALSE 15375
// end ;
15526: PPOPN 2
15528: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15529: LD_EXP 3
15533: IFFALSE 15885
15535: GO 15537
15537: DISABLE
15538: LD_INT 0
15540: PPUSH
15541: PPUSH
// begin MC_Kill ( 3 ) ;
15542: LD_INT 3
15544: PPUSH
15545: CALL 21104 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15549: LD_INT 8
15551: PPUSH
15552: LD_INT 7
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 1
15560: PPUSH
15561: CALL_OW 80
// DialogueOn ;
15565: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15569: LD_EXP 54
15573: PPUSH
15574: LD_STRING D15-Szulc-1
15576: PPUSH
15577: CALL_OW 94
// DialogueOff ;
15581: CALL_OW 7
// legionCapitulated := true ;
15585: LD_ADDR_EXP 8
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15593: LD_ADDR_VAR 0 1
15597: PUSH
15598: LD_INT 22
15600: PUSH
15601: LD_INT 8
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PUSH
15608: LD_INT 21
15610: PUSH
15611: LD_INT 3
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: LD_INT 23
15620: PUSH
15621: LD_INT 3
15623: PUSH
15624: EMPTY
15625: LIST
15626: LIST
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: PPUSH
15633: CALL_OW 69
15637: PUSH
15638: FOR_IN
15639: IFFALSE 15655
// SetLives ( i , 3 ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: LD_INT 3
15648: PPUSH
15649: CALL_OW 234
15653: GO 15638
15655: POP
15656: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15657: LD_ADDR_VAR 0 2
15661: PUSH
15662: LD_INT 22
15664: PUSH
15665: LD_INT 8
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 21
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PPUSH
15686: CALL_OW 69
15690: PUSH
15691: LD_INT 22
15693: PUSH
15694: LD_INT 8
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 21
15703: PUSH
15704: LD_INT 2
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PUSH
15711: LD_INT 1
15713: PUSH
15714: EMPTY
15715: LIST
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: ADD
15727: ST_TO_ADDR
// if tmp then
15728: LD_VAR 0 2
15732: IFFALSE 15885
// repeat wait ( 0 0$1 ) ;
15734: LD_INT 35
15736: PPUSH
15737: CALL_OW 67
// for i in tmp do
15741: LD_ADDR_VAR 0 1
15745: PUSH
15746: LD_VAR 0 2
15750: PUSH
15751: FOR_IN
15752: IFFALSE 15834
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15754: LD_VAR 0 1
15758: PPUSH
15759: CALL_OW 310
15763: PUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 310
15773: PPUSH
15774: CALL_OW 247
15778: PUSH
15779: LD_INT 3
15781: EQUAL
15782: AND
15783: IFFALSE 15794
// ComExitBuilding ( i ) ;
15785: LD_VAR 0 1
15789: PPUSH
15790: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15794: LD_VAR 0 1
15798: PPUSH
15799: LD_INT 10
15801: PPUSH
15802: LD_INT 1
15804: PPUSH
15805: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15809: LD_VAR 0 1
15813: PPUSH
15814: LD_INT 32
15816: PPUSH
15817: CALL_OW 308
15821: IFFALSE 15832
// RemoveUnit ( i ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: CALL_OW 64
// end ;
15832: GO 15751
15834: POP
15835: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15836: LD_INT 22
15838: PUSH
15839: LD_INT 8
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: LD_INT 21
15851: PUSH
15852: LD_INT 1
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PUSH
15859: LD_INT 33
15861: PUSH
15862: LD_INT 1
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: LIST
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: PPUSH
15878: CALL_OW 69
15882: NOT
15883: IFFALSE 15734
// end ;
15885: PPOPN 2
15887: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15888: LD_EXP 4
15892: PUSH
15893: LD_EXP 2
15897: AND
15898: PUSH
15899: LD_EXP 3
15903: AND
15904: PUSH
15905: LD_EXP 5
15909: AND
15910: PUSH
15911: LD_EXP 6
15915: AND
15916: PUSH
15917: LD_EXP 7
15921: AND
15922: PUSH
15923: LD_EXP 8
15927: AND
15928: PUSH
15929: LD_EXP 53
15933: PPUSH
15934: CALL_OW 255
15938: PUSH
15939: LD_INT 5
15941: NONEQUAL
15942: PUSH
15943: LD_EXP 53
15947: PPUSH
15948: CALL_OW 301
15952: OR
15953: PUSH
15954: LD_EXP 53
15958: PPUSH
15959: CALL_OW 305
15963: NOT
15964: OR
15965: AND
15966: IFFALSE 17357
15968: GO 15970
15970: DISABLE
15971: LD_INT 0
15973: PPUSH
15974: PPUSH
// begin wait ( 0 0$5 ) ;
15975: LD_INT 175
15977: PPUSH
15978: CALL_OW 67
// music_class := 5 ;
15982: LD_ADDR_OWVAR 72
15986: PUSH
15987: LD_INT 5
15989: ST_TO_ADDR
// music_nat := 5 ;
15990: LD_ADDR_OWVAR 71
15994: PUSH
15995: LD_INT 5
15997: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15998: LD_EXP 15
16002: PUSH
16003: LD_INT 3
16005: LESS
16006: IFFALSE 16015
// SetAchievement ( ACH_ECONOMY ) ;
16008: LD_STRING ACH_ECONOMY
16010: PPUSH
16011: CALL_OW 543
// if tick < 60 60$00 then
16015: LD_OWVAR 1
16019: PUSH
16020: LD_INT 126000
16022: LESS
16023: IFFALSE 16039
// begin wait ( 3 ) ;
16025: LD_INT 3
16027: PPUSH
16028: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16032: LD_STRING ACH_ASPEED_19
16034: PPUSH
16035: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16039: LD_EXP 17
16043: PPUSH
16044: CALL_OW 87
// InGameOn ;
16048: CALL_OW 8
// DialogueOn ;
16052: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16056: LD_EXP 17
16060: PPUSH
16061: LD_STRING DEnd-JMM-JMM-1
16063: PPUSH
16064: CALL_OW 88
// if Joan then
16068: LD_EXP 32
16072: IFFALSE 16088
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16074: LD_EXP 32
16078: PPUSH
16079: LD_STRING DEnd-JMM-Joan-1
16081: PPUSH
16082: CALL_OW 88
16086: GO 16132
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16088: LD_EXP 19
16092: PUSH
16093: LD_EXP 19
16097: PPUSH
16098: CALL_OW 255
16102: PUSH
16103: LD_INT 7
16105: EQUAL
16106: AND
16107: PUSH
16108: LD_EXP 19
16112: PPUSH
16113: CALL_OW 305
16117: AND
16118: IFFALSE 16132
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16120: LD_EXP 19
16124: PPUSH
16125: LD_STRING DEnd-JMM-Lisa-1
16127: PPUSH
16128: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16132: LD_EXP 29
16136: PUSH
16137: LD_EXP 29
16141: PPUSH
16142: CALL_OW 305
16146: AND
16147: IFFALSE 16161
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16149: LD_EXP 29
16153: PPUSH
16154: LD_STRING DEnd-JMM-Frank-1
16156: PPUSH
16157: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16161: LD_EXP 22
16165: PUSH
16166: LD_EXP 22
16170: PPUSH
16171: CALL_OW 255
16175: PUSH
16176: LD_INT 7
16178: EQUAL
16179: AND
16180: PUSH
16181: LD_EXP 22
16185: PPUSH
16186: CALL_OW 305
16190: AND
16191: IFFALSE 16205
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16193: LD_EXP 22
16197: PPUSH
16198: LD_STRING DEnd-JMM-Cyrus-1
16200: PPUSH
16201: CALL_OW 88
// if Burlak then
16205: LD_EXP 49
16209: IFFALSE 16223
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16211: LD_EXP 49
16215: PPUSH
16216: LD_STRING DEnd-JMM-Bur-1
16218: PPUSH
16219: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16223: LD_EXP 32
16227: PUSH
16228: LD_EXP 19
16232: AND
16233: PUSH
16234: LD_EXP 19
16238: PPUSH
16239: CALL_OW 255
16243: PUSH
16244: LD_INT 7
16246: EQUAL
16247: AND
16248: PUSH
16249: LD_EXP 19
16253: PPUSH
16254: CALL_OW 305
16258: AND
16259: IFFALSE 16273
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16261: LD_EXP 19
16265: PPUSH
16266: LD_STRING DEnd-Burlak-Lisa-1
16268: PPUSH
16269: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16273: LD_EXP 50
16277: PUSH
16278: LD_EXP 50
16282: PPUSH
16283: CALL_OW 305
16287: AND
16288: IFFALSE 16302
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16290: LD_EXP 50
16294: PPUSH
16295: LD_STRING DEnd-JMM-Bel-1
16297: PPUSH
16298: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16302: LD_EXP 51
16306: PUSH
16307: LD_EXP 51
16311: PPUSH
16312: CALL_OW 305
16316: AND
16317: IFFALSE 16331
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16319: LD_EXP 51
16323: PPUSH
16324: LD_STRING DEnd-JMM-Gny-1
16326: PPUSH
16327: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16331: LD_EXP 27
16335: PUSH
16336: LD_EXP 27
16340: PPUSH
16341: CALL_OW 255
16345: PUSH
16346: LD_INT 7
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_EXP 27
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16363: LD_EXP 27
16367: PPUSH
16368: LD_STRING DEnd-JMM-Corn-1
16370: PPUSH
16371: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16375: LD_EXP 20
16379: PUSH
16380: LD_EXP 20
16384: PPUSH
16385: CALL_OW 255
16389: PUSH
16390: LD_INT 7
16392: EQUAL
16393: AND
16394: PUSH
16395: LD_EXP 20
16399: PPUSH
16400: CALL_OW 305
16404: AND
16405: IFFALSE 16419
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16407: LD_EXP 20
16411: PPUSH
16412: LD_STRING DEnd-JMM-Don-1
16414: PPUSH
16415: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16419: LD_EXP 21
16423: PUSH
16424: LD_EXP 21
16428: PPUSH
16429: CALL_OW 255
16433: PUSH
16434: LD_INT 7
16436: EQUAL
16437: AND
16438: PUSH
16439: LD_EXP 21
16443: PPUSH
16444: CALL_OW 305
16448: AND
16449: IFFALSE 16463
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16451: LD_EXP 21
16455: PPUSH
16456: LD_STRING DEnd-JMM-Bobby-1
16458: PPUSH
16459: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16463: LD_EXP 23
16467: PUSH
16468: LD_EXP 23
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: AND
16482: PUSH
16483: LD_EXP 23
16487: PPUSH
16488: CALL_OW 305
16492: AND
16493: IFFALSE 16507
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16495: LD_EXP 23
16499: PPUSH
16500: LD_STRING DEnd-JMM-Den-1
16502: PPUSH
16503: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16507: LD_EXP 25
16511: PUSH
16512: LD_EXP 25
16516: PPUSH
16517: CALL_OW 255
16521: PUSH
16522: LD_INT 7
16524: EQUAL
16525: AND
16526: PUSH
16527: LD_EXP 25
16531: PPUSH
16532: CALL_OW 305
16536: AND
16537: IFFALSE 16551
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16539: LD_EXP 25
16543: PPUSH
16544: LD_STRING DEnd-JMM-Glad-1
16546: PPUSH
16547: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16551: LD_EXP 30
16555: PUSH
16556: LD_EXP 30
16560: PPUSH
16561: CALL_OW 255
16565: PUSH
16566: LD_INT 7
16568: EQUAL
16569: AND
16570: PUSH
16571: LD_EXP 30
16575: PPUSH
16576: CALL_OW 305
16580: AND
16581: IFFALSE 16595
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16583: LD_EXP 30
16587: PPUSH
16588: LD_STRING DEnd-JMM-Yam-1
16590: PPUSH
16591: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16595: LD_EXP 24
16599: PUSH
16600: LD_EXP 24
16604: PPUSH
16605: CALL_OW 255
16609: PUSH
16610: LD_INT 7
16612: EQUAL
16613: AND
16614: PUSH
16615: LD_EXP 24
16619: PPUSH
16620: CALL_OW 305
16624: AND
16625: IFFALSE 16639
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16627: LD_EXP 24
16631: PPUSH
16632: LD_STRING DEnd-JMM-Brown-1
16634: PPUSH
16635: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16639: LD_EXP 34
16643: PUSH
16644: LD_EXP 34
16648: PPUSH
16649: CALL_OW 255
16653: PUSH
16654: LD_INT 7
16656: EQUAL
16657: AND
16658: PUSH
16659: LD_EXP 34
16663: PPUSH
16664: CALL_OW 305
16668: AND
16669: IFFALSE 16683
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16671: LD_EXP 34
16675: PPUSH
16676: LD_STRING DEnd-JMM-Con-1
16678: PPUSH
16679: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16683: LD_EXP 28
16687: PUSH
16688: LD_EXP 28
16692: PPUSH
16693: CALL_OW 255
16697: PUSH
16698: LD_INT 7
16700: EQUAL
16701: AND
16702: PUSH
16703: LD_EXP 28
16707: PPUSH
16708: CALL_OW 305
16712: AND
16713: IFFALSE 16727
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16715: LD_EXP 28
16719: PPUSH
16720: LD_STRING DEnd-JMM-Gary-1
16722: PPUSH
16723: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16727: LD_EXP 31
16731: PUSH
16732: LD_EXP 18
16736: AND
16737: PUSH
16738: LD_EXP 31
16742: PPUSH
16743: CALL_OW 305
16747: AND
16748: IFFALSE 16762
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16750: LD_EXP 31
16754: PPUSH
16755: LD_STRING DEnd-JMM-Sim-1
16757: PPUSH
16758: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16762: LD_EXP 26
16766: PUSH
16767: LD_EXP 26
16771: PPUSH
16772: CALL_OW 255
16776: PUSH
16777: LD_INT 7
16779: EQUAL
16780: AND
16781: PUSH
16782: LD_EXP 26
16786: PPUSH
16787: CALL_OW 305
16791: AND
16792: IFFALSE 16806
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16794: LD_EXP 26
16798: PPUSH
16799: LD_STRING DEnd-JMM-VanH-1
16801: PPUSH
16802: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16806: LD_EXP 39
16810: PUSH
16811: LD_EXP 39
16815: PPUSH
16816: CALL_OW 305
16820: AND
16821: IFFALSE 16835
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16823: LD_EXP 39
16827: PPUSH
16828: LD_STRING DEnd-JMM-Dol-1
16830: PPUSH
16831: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16835: LD_EXP 43
16839: PUSH
16840: LD_EXP 43
16844: PPUSH
16845: CALL_OW 305
16849: AND
16850: IFFALSE 16864
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16852: LD_EXP 43
16856: PPUSH
16857: LD_STRING DEnd-JMM-Kap-1
16859: PPUSH
16860: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16864: LD_EXP 46
16868: PUSH
16869: LD_EXP 46
16873: PPUSH
16874: CALL_OW 305
16878: AND
16879: IFFALSE 16893
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16881: LD_EXP 46
16885: PPUSH
16886: LD_STRING DEnd-JMM-Kov-1
16888: PPUSH
16889: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16893: LD_EXP 41
16897: PUSH
16898: LD_EXP 41
16902: PPUSH
16903: CALL_OW 305
16907: AND
16908: IFFALSE 16922
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16910: LD_EXP 41
16914: PPUSH
16915: LD_STRING DEnd-JMM-Sch-1
16917: PPUSH
16918: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16922: LD_EXP 37
16926: PUSH
16927: LD_EXP 37
16931: PPUSH
16932: CALL_OW 305
16936: AND
16937: IFFALSE 16951
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16939: LD_EXP 37
16943: PPUSH
16944: LD_STRING DEnd-JMM-Tit-1
16946: PPUSH
16947: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16951: LD_EXP 42
16955: PUSH
16956: LD_EXP 42
16960: PPUSH
16961: CALL_OW 305
16965: AND
16966: IFFALSE 16980
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16968: LD_EXP 42
16972: PPUSH
16973: LD_STRING DEnd-JMM-Obl-1
16975: PPUSH
16976: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16980: LD_EXP 44
16984: PUSH
16985: LD_EXP 44
16989: PPUSH
16990: CALL_OW 305
16994: AND
16995: IFFALSE 17009
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16997: LD_EXP 44
17001: PPUSH
17002: LD_STRING DEnd-JMM-Lip-1
17004: PPUSH
17005: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17009: LD_EXP 38
17013: PUSH
17014: LD_EXP 38
17018: PPUSH
17019: CALL_OW 305
17023: AND
17024: PUSH
17025: LD_EXP 49
17029: AND
17030: IFFALSE 17044
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17032: LD_EXP 38
17036: PPUSH
17037: LD_STRING DEnd-Burlak-Fad-1
17039: PPUSH
17040: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17044: LD_EXP 45
17048: PUSH
17049: LD_EXP 45
17053: PPUSH
17054: CALL_OW 305
17058: AND
17059: IFFALSE 17073
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17061: LD_EXP 45
17065: PPUSH
17066: LD_STRING DEnd-Burlak-Ptr-1
17068: PPUSH
17069: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17073: LD_EXP 47
17077: PUSH
17078: LD_EXP 47
17082: PPUSH
17083: CALL_OW 305
17087: AND
17088: IFFALSE 17102
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17090: LD_EXP 47
17094: PPUSH
17095: LD_STRING DEnd-Burlak-Kuz-1
17097: PPUSH
17098: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17102: LD_EXP 36
17106: PUSH
17107: LD_EXP 36
17111: PPUSH
17112: CALL_OW 305
17116: AND
17117: PUSH
17118: LD_EXP 49
17122: AND
17123: IFFALSE 17137
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17125: LD_EXP 36
17129: PPUSH
17130: LD_STRING DEnd-Burlak-Kir-1
17132: PPUSH
17133: CALL_OW 88
// if Burlak then
17137: LD_EXP 49
17141: IFFALSE 17155
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17143: LD_EXP 17
17147: PPUSH
17148: LD_STRING DEnd-Burlak-JMM-1
17150: PPUSH
17151: CALL_OW 88
// dwait ( 0 0$2 ) ;
17155: LD_INT 70
17157: PPUSH
17158: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17162: LD_EXP 54
17166: PPUSH
17167: LD_STRING DEnd-Szulc
17169: PPUSH
17170: CALL_OW 94
// dwait ( 0 0$1 ) ;
17174: LD_INT 35
17176: PPUSH
17177: CALL_OW 68
// if IsLive ( Burlak ) then
17181: LD_EXP 49
17185: PPUSH
17186: CALL_OW 300
17190: IFFALSE 17202
// med1 := 1 else
17192: LD_ADDR_VAR 0 1
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
17200: GO 17211
// med1 := - 1 ;
17202: LD_ADDR_VAR 0 1
17206: PUSH
17207: LD_INT 1
17209: NEG
17210: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17211: LD_EXP 12
17215: PUSH
17216: LD_EXP 13
17220: AND
17221: PUSH
17222: LD_EXP 14
17226: AND
17227: IFFALSE 17239
// med2 := 1 else
17229: LD_ADDR_VAR 0 2
17233: PUSH
17234: LD_INT 1
17236: ST_TO_ADDR
17237: GO 17248
// med2 := - 1 ;
17239: LD_ADDR_VAR 0 2
17243: PUSH
17244: LD_INT 1
17246: NEG
17247: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17248: LD_STRING Hero
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17258: LD_STRING Artefact
17260: PPUSH
17261: LD_VAR 0 2
17265: PPUSH
17266: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17270: LD_STRING ReconcileBurlak
17272: PPUSH
17273: LD_VAR 0 1
17277: PPUSH
17278: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17282: LD_OWVAR 67
17286: PUSH
17287: LD_INT 3
17289: GREATEREQUAL
17290: PUSH
17291: LD_VAR 0 1
17295: PUSH
17296: LD_INT 1
17298: EQUAL
17299: AND
17300: PUSH
17301: LD_VAR 0 2
17305: PUSH
17306: LD_INT 1
17308: EQUAL
17309: AND
17310: IFFALSE 17322
// SetAchievementEX ( ACH_AMER , 19 ) ;
17312: LD_STRING ACH_AMER
17314: PPUSH
17315: LD_INT 19
17317: PPUSH
17318: CALL_OW 564
// GiveMedals ( MAIN ) ;
17322: LD_STRING MAIN
17324: PPUSH
17325: CALL_OW 102
// InGameOff ;
17329: CALL_OW 9
// DialogueOff ;
17333: CALL_OW 7
// music_nat := 1 ;
17337: LD_ADDR_OWVAR 71
17341: PUSH
17342: LD_INT 1
17344: ST_TO_ADDR
// music_class := 4 ;
17345: LD_ADDR_OWVAR 72
17349: PUSH
17350: LD_INT 4
17352: ST_TO_ADDR
// YouWin ;
17353: CALL_OW 103
// end ; end_of_file
17357: PPOPN 2
17359: END
// export function InitNature ; begin
17360: LD_INT 0
17362: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17363: LD_INT 3
17365: PPUSH
17366: LD_INT 3
17368: PPUSH
17369: LD_INT 2
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 1
17377: PPUSH
17378: LD_INT 0
17380: PPUSH
17381: LD_INT 0
17383: PPUSH
17384: LD_INT 17
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: CALL 84851 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17394: LD_INT 2
17396: PPUSH
17397: LD_INT 1
17399: PPUSH
17400: LD_INT 1
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 18
17417: PPUSH
17418: LD_INT 0
17420: PPUSH
17421: CALL 84851 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17425: LD_INT 4
17427: PPUSH
17428: LD_INT 1
17430: PPUSH
17431: LD_INT 2
17433: PPUSH
17434: LD_INT 4
17436: PPUSH
17437: LD_INT 2
17439: PPUSH
17440: LD_INT 1
17442: PPUSH
17443: LD_INT 0
17445: PPUSH
17446: LD_INT 19
17448: PPUSH
17449: LD_INT 0
17451: PPUSH
17452: CALL 84851 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17456: LD_INT 0
17458: PPUSH
17459: LD_INT 0
17461: PPUSH
17462: LD_INT 0
17464: PPUSH
17465: LD_INT 0
17467: PPUSH
17468: LD_INT 0
17470: PPUSH
17471: LD_INT 0
17473: PPUSH
17474: LD_INT 9
17476: PPUSH
17477: LD_INT 0
17479: PPUSH
17480: LD_INT 20
17482: PPUSH
17483: CALL 84851 0 9
// end ; end_of_file
17487: LD_VAR 0 1
17491: RET
// every 0 0$30 do var time ;
17492: GO 17494
17494: DISABLE
17495: LD_INT 0
17497: PPUSH
// begin time := 0 0$30 ;
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1050
17505: ST_TO_ADDR
// repeat wait ( time ) ;
17506: LD_VAR 0 1
17510: PPUSH
17511: CALL_OW 67
// if Prob ( 50 ) then
17515: LD_INT 50
17517: PPUSH
17518: CALL_OW 13
17522: IFFALSE 17551
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17524: LD_INT 1
17526: PPUSH
17527: LD_INT 5
17529: PPUSH
17530: CALL_OW 12
17534: PPUSH
17535: LD_INT 106
17537: PPUSH
17538: LD_INT 89
17540: PPUSH
17541: LD_INT 45
17543: PPUSH
17544: LD_INT 1
17546: PPUSH
17547: CALL_OW 56
// time := time + 0 0$3 ;
17551: LD_ADDR_VAR 0 1
17555: PUSH
17556: LD_VAR 0 1
17560: PUSH
17561: LD_INT 105
17563: PLUS
17564: ST_TO_ADDR
// if Prob ( 30 ) then
17565: LD_INT 30
17567: PPUSH
17568: CALL_OW 13
17572: IFFALSE 17618
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17574: LD_INT 525
17576: PPUSH
17577: LD_INT 735
17579: PPUSH
17580: CALL_OW 12
17584: PPUSH
17585: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17589: LD_INT 1
17591: PPUSH
17592: LD_INT 5
17594: PPUSH
17595: CALL_OW 12
17599: PPUSH
17600: LD_INT 21
17602: PPUSH
17603: LD_INT 26
17605: PPUSH
17606: LD_INT 12
17608: PPUSH
17609: LD_INT 1
17611: PPUSH
17612: CALL_OW 56
// end else
17616: GO 17654
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17618: LD_INT 700
17620: PPUSH
17621: LD_INT 1225
17623: PPUSH
17624: CALL_OW 12
17628: PPUSH
17629: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17633: LD_INT 1
17635: PPUSH
17636: LD_INT 5
17638: PPUSH
17639: CALL_OW 12
17643: PPUSH
17644: LD_INT 14
17646: PPUSH
17647: LD_INT 1
17649: PPUSH
17650: CALL_OW 55
// end ; if Prob ( 50 ) then
17654: LD_INT 50
17656: PPUSH
17657: CALL_OW 13
17661: IFFALSE 17707
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17663: LD_INT 700
17665: PPUSH
17666: LD_INT 1050
17668: PPUSH
17669: CALL_OW 12
17673: PPUSH
17674: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17678: LD_INT 1
17680: PPUSH
17681: LD_INT 5
17683: PPUSH
17684: CALL_OW 12
17688: PPUSH
17689: LD_INT 181
17691: PPUSH
17692: LD_INT 218
17694: PPUSH
17695: LD_INT 16
17697: PPUSH
17698: LD_INT 1
17700: PPUSH
17701: CALL_OW 56
// end else
17705: GO 17779
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17707: LD_INT 350
17709: PPUSH
17710: LD_INT 525
17712: PPUSH
17713: CALL_OW 12
17717: PPUSH
17718: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17722: LD_INT 1
17724: PPUSH
17725: LD_INT 5
17727: PPUSH
17728: CALL_OW 12
17732: PPUSH
17733: LD_INT 13
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17743: LD_INT 350
17745: PPUSH
17746: LD_INT 700
17748: PPUSH
17749: CALL_OW 12
17753: PPUSH
17754: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17758: LD_INT 1
17760: PPUSH
17761: LD_INT 5
17763: PPUSH
17764: CALL_OW 12
17768: PPUSH
17769: LD_INT 33
17771: PPUSH
17772: LD_INT 1
17774: PPUSH
17775: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
17779: LD_INT 65
17781: PUSH
17782: LD_INT 62
17784: PUSH
17785: LD_INT 55
17787: PUSH
17788: LD_INT 50
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: PUSH
17797: LD_OWVAR 67
17801: ARRAY
17802: PPUSH
17803: CALL_OW 13
17807: IFFALSE 17853
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17809: LD_INT 525
17811: PPUSH
17812: LD_INT 875
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17824: LD_INT 1
17826: PPUSH
17827: LD_INT 5
17829: PPUSH
17830: CALL_OW 12
17834: PPUSH
17835: LD_INT 294
17837: PPUSH
17838: LD_INT 211
17840: PPUSH
17841: LD_INT 30
17843: PPUSH
17844: LD_INT 1
17846: PPUSH
17847: CALL_OW 56
// end else
17851: GO 17895
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17853: LD_INT 420
17855: PPUSH
17856: LD_INT 770
17858: PPUSH
17859: CALL_OW 12
17863: PPUSH
17864: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17868: LD_INT 1
17870: PPUSH
17871: LD_INT 5
17873: PPUSH
17874: CALL_OW 12
17878: PPUSH
17879: LD_INT 294
17881: PPUSH
17882: LD_INT 211
17884: PPUSH
17885: LD_INT 30
17887: PPUSH
17888: LD_INT 1
17890: PPUSH
17891: CALL_OW 56
// end ; if time > 2 2$20 then
17895: LD_VAR 0 1
17899: PUSH
17900: LD_INT 4900
17902: GREATER
17903: IFFALSE 17913
// time := 0 0$50 ;
17905: LD_ADDR_VAR 0 1
17909: PUSH
17910: LD_INT 1750
17912: ST_TO_ADDR
// until false ;
17913: LD_INT 0
17915: IFFALSE 17506
// end ;
17917: PPOPN 1
17919: END
// every 0 0$45 trigger tick < 10 10$00 do
17920: LD_OWVAR 1
17924: PUSH
17925: LD_INT 21000
17927: LESS
17928: IFFALSE 17976
17930: GO 17932
17932: DISABLE
// begin enable ;
17933: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17934: LD_INT 350
17936: PPUSH
17937: LD_INT 700
17939: PPUSH
17940: CALL_OW 12
17944: PPUSH
17945: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17949: LD_INT 3
17951: PPUSH
17952: LD_INT 5
17954: PPUSH
17955: CALL_OW 12
17959: PPUSH
17960: LD_INT 181
17962: PPUSH
17963: LD_INT 13
17965: PPUSH
17966: LD_INT 20
17968: PPUSH
17969: LD_INT 1
17971: PPUSH
17972: CALL_OW 56
// end ; end_of_file
17976: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17977: LD_INT 0
17979: PPUSH
// SetArtifactRes ( 7 , true ) ;
17980: LD_INT 7
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17990: LD_ADDR_EXP 62
17994: PUSH
17995: EMPTY
17996: PUSH
17997: EMPTY
17998: PUSH
17999: EMPTY
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18006: LD_ADDR_EXP 63
18010: PUSH
18011: LD_INT 1050
18013: PUSH
18014: LD_OWVAR 67
18018: MUL
18019: PUSH
18020: LD_INT 2800
18022: PUSH
18023: LD_OWVAR 67
18027: MUL
18028: PUSH
18029: LD_INT 1
18031: NEG
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: LIST
18037: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18038: LD_ADDR_EXP 64
18042: PUSH
18043: LD_INT 10
18045: PUSH
18046: LD_INT 35
18048: PUSH
18049: LD_INT 100
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18057: LD_ADDR_EXP 65
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: LD_INT 0
18070: PUSH
18071: EMPTY
18072: LIST
18073: LIST
18074: LIST
18075: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18076: LD_ADDR_EXP 67
18080: PUSH
18081: LD_INT 300
18083: PUSH
18084: LD_INT 500
18086: PUSH
18087: LD_INT 800
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: LIST
18094: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18095: LD_ADDR_EXP 68
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 0
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18114: LD_ADDR_EXP 69
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: LD_INT 0
18124: PUSH
18125: LD_INT 0
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: LIST
18132: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18133: LD_ADDR_EXP 66
18137: PUSH
18138: LD_INT 0
18140: PUSH
18141: LD_INT 0
18143: PUSH
18144: LD_INT 0
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: LIST
18151: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18152: LD_ADDR_EXP 70
18156: PUSH
18157: LD_INT 4
18159: PUSH
18160: LD_INT 3
18162: PUSH
18163: LD_INT 1
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 5
18173: PUSH
18174: LD_INT 4
18176: PUSH
18177: LD_INT 2
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: LIST
18184: PUSH
18185: LD_INT 6
18187: PUSH
18188: LD_INT 3
18190: PUSH
18191: LD_INT 3
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: LIST
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18204: LD_ADDR_EXP 71
18208: PUSH
18209: LD_INT 0
18211: PUSH
18212: LD_INT 0
18214: PUSH
18215: LD_INT 0
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: ST_TO_ADDR
// end ;
18223: LD_VAR 0 1
18227: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18228: LD_INT 24
18230: PPUSH
18231: LD_INT 7
18233: PPUSH
18234: CALL_OW 321
18238: PUSH
18239: LD_INT 2
18241: EQUAL
18242: IFFALSE 19168
18244: GO 18246
18246: DISABLE
18247: LD_INT 0
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
// begin enable ;
18254: ENABLE
// for i = 1 to 3 do
18255: LD_ADDR_VAR 0 1
18259: PUSH
18260: DOUBLE
18261: LD_INT 1
18263: DEC
18264: ST_TO_ADDR
18265: LD_INT 3
18267: PUSH
18268: FOR_TO
18269: IFFALSE 19166
// begin pos := FindArtifact ( i + 2 ) ;
18271: LD_ADDR_VAR 0 2
18275: PUSH
18276: LD_VAR 0 1
18280: PUSH
18281: LD_INT 2
18283: PLUS
18284: PPUSH
18285: CALL_OW 469
18289: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18290: LD_ADDR_EXP 62
18294: PUSH
18295: LD_EXP 62
18299: PPUSH
18300: LD_VAR 0 1
18304: PPUSH
18305: LD_VAR 0 2
18309: PPUSH
18310: CALL_OW 1
18314: ST_TO_ADDR
// if pos then
18315: LD_VAR 0 2
18319: IFFALSE 19027
// begin case i of 1 :
18321: LD_VAR 0 1
18325: PUSH
18326: LD_INT 1
18328: DOUBLE
18329: EQUAL
18330: IFTRUE 18334
18332: GO 18411
18334: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18335: LD_ADDR_VAR 0 4
18339: PUSH
18340: LD_INT 22
18342: PUSH
18343: LD_INT 7
18345: PUSH
18346: EMPTY
18347: LIST
18348: LIST
18349: PUSH
18350: LD_INT 23
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 2
18362: PUSH
18363: LD_INT 30
18365: PUSH
18366: LD_INT 8
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 30
18375: PUSH
18376: LD_INT 7
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 30
18385: PUSH
18386: LD_INT 11
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: PPUSH
18404: CALL_OW 69
18408: ST_TO_ADDR
18409: GO 18519
18411: LD_INT 2
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18496
18419: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18420: LD_ADDR_VAR 0 4
18424: PUSH
18425: LD_INT 22
18427: PUSH
18428: LD_INT 7
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: PUSH
18435: LD_INT 23
18437: PUSH
18438: LD_INT 3
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 30
18450: PUSH
18451: LD_INT 8
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 30
18460: PUSH
18461: LD_INT 7
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 30
18470: PUSH
18471: LD_INT 11
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: LIST
18488: PPUSH
18489: CALL_OW 69
18493: ST_TO_ADDR
18494: GO 18519
18496: LD_INT 3
18498: DOUBLE
18499: EQUAL
18500: IFTRUE 18504
18502: GO 18518
18504: POP
// labs := [ alien ] ; end ;
18505: LD_ADDR_VAR 0 4
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: ST_TO_ADDR
18516: GO 18519
18518: POP
// if not labs then
18519: LD_VAR 0 4
18523: NOT
18524: IFFALSE 18528
// continue ;
18526: GO 18268
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18528: LD_ADDR_VAR 0 5
18532: PUSH
18533: LD_VAR 0 4
18537: PPUSH
18538: LD_EXP 62
18542: PUSH
18543: LD_VAR 0 1
18547: ARRAY
18548: PUSH
18549: LD_INT 1
18551: ARRAY
18552: PPUSH
18553: LD_EXP 62
18557: PUSH
18558: LD_VAR 0 1
18562: ARRAY
18563: PUSH
18564: LD_INT 2
18566: ARRAY
18567: PPUSH
18568: CALL_OW 73
18572: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18573: LD_VAR 0 5
18577: NOT
18578: PUSH
18579: LD_VAR 0 5
18583: PUSH
18584: LD_EXP 69
18588: PUSH
18589: LD_VAR 0 1
18593: ARRAY
18594: NONEQUAL
18595: OR
18596: IFFALSE 18701
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18598: LD_INT 7
18600: PPUSH
18601: LD_EXP 70
18605: PUSH
18606: LD_VAR 0 1
18610: ARRAY
18611: PUSH
18612: LD_INT 3
18614: ARRAY
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: LD_EXP 69
18623: PUSH
18624: LD_VAR 0 1
18628: ARRAY
18629: PPUSH
18630: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18634: LD_INT 7
18636: PPUSH
18637: LD_EXP 70
18641: PUSH
18642: LD_VAR 0 1
18646: ARRAY
18647: PUSH
18648: LD_INT 1
18650: ARRAY
18651: PPUSH
18652: LD_INT 0
18654: PPUSH
18655: LD_EXP 69
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PPUSH
18666: CALL_OW 468
// if nearestLab then
18670: LD_VAR 0 5
18674: IFFALSE 18701
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18676: LD_ADDR_EXP 69
18680: PUSH
18681: LD_EXP 69
18685: PPUSH
18686: LD_VAR 0 1
18690: PPUSH
18691: LD_VAR 0 5
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// end ; if not nearestLab then
18701: LD_VAR 0 5
18705: NOT
18706: IFFALSE 18710
// continue ;
18708: GO 18268
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18710: LD_VAR 0 5
18714: PPUSH
18715: LD_EXP 62
18719: PUSH
18720: LD_VAR 0 1
18724: ARRAY
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PPUSH
18730: LD_EXP 62
18734: PUSH
18735: LD_VAR 0 1
18739: ARRAY
18740: PUSH
18741: LD_INT 2
18743: ARRAY
18744: PPUSH
18745: CALL_OW 297
18749: PUSH
18750: LD_INT 8
18752: LESS
18753: IFFALSE 18950
// begin if not artifactsResearched [ i ] then
18755: LD_EXP 65
18759: PUSH
18760: LD_VAR 0 1
18764: ARRAY
18765: NOT
18766: IFFALSE 18847
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18768: LD_VAR 0 5
18772: PPUSH
18773: CALL_OW 461
18777: PUSH
18778: LD_INT 2
18780: EQUAL
18781: IFFALSE 18815
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18783: LD_INT 7
18785: PPUSH
18786: LD_EXP 70
18790: PUSH
18791: LD_VAR 0 1
18795: ARRAY
18796: PUSH
18797: LD_INT 3
18799: ARRAY
18800: PPUSH
18801: LD_INT 2
18803: PPUSH
18804: LD_VAR 0 5
18808: PPUSH
18809: CALL_OW 468
18813: GO 18845
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18815: LD_INT 7
18817: PPUSH
18818: LD_EXP 70
18822: PUSH
18823: LD_VAR 0 1
18827: ARRAY
18828: PUSH
18829: LD_INT 3
18831: ARRAY
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: LD_VAR 0 5
18840: PPUSH
18841: CALL_OW 468
// end else
18845: GO 18948
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 461
18856: PUSH
18857: LD_INT 2
18859: EQUAL
18860: PUSH
18861: LD_EXP 71
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: AND
18872: IFFALSE 18918
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18874: LD_INT 7
18876: PPUSH
18877: LD_EXP 70
18881: PUSH
18882: LD_VAR 0 1
18886: ARRAY
18887: PUSH
18888: LD_INT 1
18890: ARRAY
18891: PPUSH
18892: LD_EXP 70
18896: PUSH
18897: LD_VAR 0 1
18901: ARRAY
18902: PUSH
18903: LD_INT 2
18905: ARRAY
18906: PPUSH
18907: LD_VAR 0 5
18911: PPUSH
18912: CALL_OW 468
18916: GO 18948
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18918: LD_INT 7
18920: PPUSH
18921: LD_EXP 70
18925: PUSH
18926: LD_VAR 0 1
18930: ARRAY
18931: PUSH
18932: LD_INT 1
18934: ARRAY
18935: PPUSH
18936: LD_INT 1
18938: PPUSH
18939: LD_VAR 0 5
18943: PPUSH
18944: CALL_OW 468
// end else
18948: GO 19025
// begin if not artifactsResearched [ i ] then
18950: LD_EXP 65
18954: PUSH
18955: LD_VAR 0 1
18959: ARRAY
18960: NOT
18961: IFFALSE 18995
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18963: LD_INT 7
18965: PPUSH
18966: LD_EXP 70
18970: PUSH
18971: LD_VAR 0 1
18975: ARRAY
18976: PUSH
18977: LD_INT 3
18979: ARRAY
18980: PPUSH
18981: LD_INT 0
18983: PPUSH
18984: LD_VAR 0 5
18988: PPUSH
18989: CALL_OW 468
18993: GO 19025
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18995: LD_INT 7
18997: PPUSH
18998: LD_EXP 70
19002: PUSH
19003: LD_VAR 0 1
19007: ARRAY
19008: PUSH
19009: LD_INT 1
19011: ARRAY
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: LD_VAR 0 5
19020: PPUSH
19021: CALL_OW 468
// end ; end else
19025: GO 19164
// begin if not artifactsLabs [ i ] then
19027: LD_EXP 69
19031: PUSH
19032: LD_VAR 0 1
19036: ARRAY
19037: NOT
19038: IFFALSE 19042
// continue ;
19040: GO 18268
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19042: LD_INT 7
19044: PPUSH
19045: LD_EXP 70
19049: PUSH
19050: LD_VAR 0 1
19054: ARRAY
19055: PUSH
19056: LD_INT 3
19058: ARRAY
19059: PPUSH
19060: LD_INT 0
19062: PPUSH
19063: LD_EXP 69
19067: PUSH
19068: LD_VAR 0 1
19072: ARRAY
19073: PPUSH
19074: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19078: LD_INT 7
19080: PPUSH
19081: LD_EXP 70
19085: PUSH
19086: LD_VAR 0 1
19090: ARRAY
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: PPUSH
19096: LD_INT 0
19098: PPUSH
19099: LD_EXP 69
19103: PUSH
19104: LD_VAR 0 1
19108: ARRAY
19109: PPUSH
19110: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19114: LD_EXP 66
19118: PUSH
19119: LD_VAR 0 1
19123: ARRAY
19124: IFFALSE 19164
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19126: LD_ADDR_EXP 66
19130: PUSH
19131: LD_EXP 66
19135: PPUSH
19136: LD_VAR 0 1
19140: PPUSH
19141: LD_INT 0
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19149: LD_EXP 69
19153: PUSH
19154: LD_VAR 0 1
19158: ARRAY
19159: PPUSH
19160: CALL_OW 127
// end ; end ; end ;
19164: GO 18268
19166: POP
19167: POP
// end ;
19168: PPOPN 5
19170: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19171: LD_INT 0
19173: PPUSH
19174: PPUSH
19175: PPUSH
19176: PPUSH
19177: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19178: LD_VAR 0 2
19182: PUSH
19183: LD_EXP 70
19187: PUSH
19188: LD_INT 1
19190: ARRAY
19191: PUSH
19192: LD_INT 3
19194: ARRAY
19195: EQUAL
19196: IFFALSE 19319
// begin lab := artifactsLabs [ 1 ] ;
19198: LD_ADDR_VAR 0 6
19202: PUSH
19203: LD_EXP 69
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: ST_TO_ADDR
// if not lab then
19212: LD_VAR 0 6
19216: NOT
19217: IFFALSE 19221
// exit ;
19219: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19221: LD_VAR 0 6
19225: PPUSH
19226: LD_EXP 67
19230: PUSH
19231: LD_INT 1
19233: ARRAY
19234: PPUSH
19235: LD_INT 1
19237: PPUSH
19238: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19242: LD_EXP 68
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: IFFALSE 19270
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19252: LD_VAR 0 6
19256: PPUSH
19257: LD_EXP 68
19261: PUSH
19262: LD_INT 1
19264: ARRAY
19265: PPUSH
19266: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19270: LD_ADDR_EXP 66
19274: PUSH
19275: LD_EXP 66
19279: PPUSH
19280: LD_INT 1
19282: PPUSH
19283: LD_INT 1
19285: PPUSH
19286: CALL_OW 1
19290: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19291: LD_INT 7
19293: PPUSH
19294: LD_EXP 70
19298: PUSH
19299: LD_INT 1
19301: ARRAY
19302: PUSH
19303: LD_INT 3
19305: ARRAY
19306: PPUSH
19307: LD_INT 0
19309: PPUSH
19310: LD_VAR 0 6
19314: PPUSH
19315: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19319: LD_VAR 0 2
19323: PUSH
19324: LD_EXP 70
19328: PUSH
19329: LD_INT 2
19331: ARRAY
19332: PUSH
19333: LD_INT 3
19335: ARRAY
19336: EQUAL
19337: IFFALSE 19460
// begin lab := artifactsLabs [ 2 ] ;
19339: LD_ADDR_VAR 0 6
19343: PUSH
19344: LD_EXP 69
19348: PUSH
19349: LD_INT 2
19351: ARRAY
19352: ST_TO_ADDR
// if not lab then
19353: LD_VAR 0 6
19357: NOT
19358: IFFALSE 19362
// exit ;
19360: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19362: LD_VAR 0 6
19366: PPUSH
19367: LD_EXP 67
19371: PUSH
19372: LD_INT 2
19374: ARRAY
19375: PPUSH
19376: LD_INT 1
19378: PPUSH
19379: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19383: LD_EXP 68
19387: PUSH
19388: LD_INT 2
19390: ARRAY
19391: IFFALSE 19411
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19393: LD_VAR 0 6
19397: PPUSH
19398: LD_EXP 68
19402: PUSH
19403: LD_INT 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19411: LD_ADDR_EXP 66
19415: PUSH
19416: LD_EXP 66
19420: PPUSH
19421: LD_INT 2
19423: PPUSH
19424: LD_INT 1
19426: PPUSH
19427: CALL_OW 1
19431: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19432: LD_INT 7
19434: PPUSH
19435: LD_EXP 70
19439: PUSH
19440: LD_INT 2
19442: ARRAY
19443: PUSH
19444: LD_INT 3
19446: ARRAY
19447: PPUSH
19448: LD_INT 0
19450: PPUSH
19451: LD_VAR 0 6
19455: PPUSH
19456: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19460: LD_VAR 0 2
19464: PUSH
19465: LD_EXP 70
19469: PUSH
19470: LD_INT 3
19472: ARRAY
19473: PUSH
19474: LD_INT 3
19476: ARRAY
19477: EQUAL
19478: IFFALSE 19601
// begin lab := artifactsLabs [ 3 ] ;
19480: LD_ADDR_VAR 0 6
19484: PUSH
19485: LD_EXP 69
19489: PUSH
19490: LD_INT 3
19492: ARRAY
19493: ST_TO_ADDR
// if not lab then
19494: LD_VAR 0 6
19498: NOT
19499: IFFALSE 19503
// exit ;
19501: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19503: LD_VAR 0 6
19507: PPUSH
19508: LD_EXP 67
19512: PUSH
19513: LD_INT 3
19515: ARRAY
19516: PPUSH
19517: LD_INT 1
19519: PPUSH
19520: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19524: LD_EXP 68
19528: PUSH
19529: LD_INT 3
19531: ARRAY
19532: IFFALSE 19552
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19534: LD_VAR 0 6
19538: PPUSH
19539: LD_EXP 68
19543: PUSH
19544: LD_INT 3
19546: ARRAY
19547: PPUSH
19548: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19552: LD_ADDR_EXP 66
19556: PUSH
19557: LD_EXP 66
19561: PPUSH
19562: LD_INT 3
19564: PPUSH
19565: LD_INT 1
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19573: LD_INT 7
19575: PPUSH
19576: LD_EXP 70
19580: PUSH
19581: LD_INT 3
19583: ARRAY
19584: PUSH
19585: LD_INT 3
19587: ARRAY
19588: PPUSH
19589: LD_INT 0
19591: PPUSH
19592: LD_VAR 0 6
19596: PPUSH
19597: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19601: LD_VAR 0 2
19605: PUSH
19606: LD_EXP 70
19610: PUSH
19611: LD_INT 1
19613: ARRAY
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: EQUAL
19619: IFFALSE 19777
// begin lab := artifactsLabs [ 1 ] ;
19621: LD_ADDR_VAR 0 6
19625: PUSH
19626: LD_EXP 69
19630: PUSH
19631: LD_INT 1
19633: ARRAY
19634: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19635: LD_VAR 0 6
19639: PPUSH
19640: CALL_OW 274
19644: PPUSH
19645: CALL 88455 0 1
19649: PUSH
19650: LD_INT 3
19652: ARRAY
19653: PUSH
19654: LD_EXP 64
19658: PUSH
19659: LD_INT 1
19661: ARRAY
19662: LESS
19663: IFFALSE 19677
// begin HintSpec ( ArtifactCost , 2 ) ;
19665: LD_STRING ArtifactCost
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 338
// exit ;
19675: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19677: LD_ADDR_EXP 71
19681: PUSH
19682: LD_EXP 71
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 0
19692: PPUSH
19693: CALL_OW 1
19697: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19698: LD_VAR 0 3
19702: PPUSH
19703: LD_VAR 0 4
19707: PPUSH
19708: LD_INT 7
19710: PPUSH
19711: LD_INT 12
19713: NEG
19714: PPUSH
19715: CALL_OW 330
// wait ( 0 0$30 ) ;
19719: LD_INT 1050
19721: PPUSH
19722: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19726: LD_VAR 0 3
19730: PPUSH
19731: LD_VAR 0 4
19735: PPUSH
19736: LD_INT 7
19738: PPUSH
19739: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19743: LD_EXP 63
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19756: LD_ADDR_EXP 71
19760: PUSH
19761: LD_EXP 71
19765: PPUSH
19766: LD_INT 1
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19777: LD_VAR 0 2
19781: PUSH
19782: LD_EXP 70
19786: PUSH
19787: LD_INT 2
19789: ARRAY
19790: PUSH
19791: LD_INT 1
19793: ARRAY
19794: EQUAL
19795: IFFALSE 20032
// begin lab := artifactsLabs [ 2 ] ;
19797: LD_ADDR_VAR 0 6
19801: PUSH
19802: LD_EXP 69
19806: PUSH
19807: LD_INT 2
19809: ARRAY
19810: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19811: LD_VAR 0 3
19815: PUSH
19816: LD_INT 81
19818: PUSH
19819: LD_INT 7
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: LD_INT 3
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 28
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 30
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: LD_INT 35
19861: PUSH
19862: LD_INT 49
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: LD_INT 34
19871: PUSH
19872: LD_INT 49
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: PUSH
19879: LD_INT 30
19881: PUSH
19882: LD_INT 21
19884: PUSH
19885: EMPTY
19886: LIST
19887: LIST
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: PPUSH
19902: CALL_OW 69
19906: IN
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20299
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19912: LD_VAR 0 6
19916: PPUSH
19917: CALL_OW 274
19921: PPUSH
19922: CALL 88455 0 1
19926: PUSH
19927: LD_INT 3
19929: ARRAY
19930: PUSH
19931: LD_EXP 64
19935: PUSH
19936: LD_INT 2
19938: ARRAY
19939: LESS
19940: IFFALSE 19954
// begin HintSpec ( ArtifactCost , 2 ) ;
19942: LD_STRING ArtifactCost
19944: PPUSH
19945: LD_INT 2
19947: PPUSH
19948: CALL_OW 338
// exit ;
19952: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19954: LD_ADDR_EXP 71
19958: PUSH
19959: LD_EXP 71
19963: PPUSH
19964: LD_INT 2
19966: PPUSH
19967: LD_INT 0
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// KillUnit ( x ) ;
19975: LD_VAR 0 3
19979: PPUSH
19980: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19984: LD_ADDR_EXP 16
19988: PUSH
19989: LD_EXP 16
19993: PUSH
19994: LD_INT 1
19996: PLUS
19997: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19998: LD_EXP 63
20002: PUSH
20003: LD_INT 2
20005: ARRAY
20006: PPUSH
20007: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20011: LD_ADDR_EXP 71
20015: PUSH
20016: LD_EXP 71
20020: PPUSH
20021: LD_INT 2
20023: PPUSH
20024: LD_INT 1
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20032: LD_VAR 0 2
20036: PUSH
20037: LD_EXP 70
20041: PUSH
20042: LD_INT 3
20044: ARRAY
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: EQUAL
20050: IFFALSE 20299
// begin lab := artifactsLabs [ 3 ] ;
20052: LD_ADDR_VAR 0 6
20056: PUSH
20057: LD_EXP 69
20061: PUSH
20062: LD_INT 3
20064: ARRAY
20065: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20066: LD_VAR 0 6
20070: PPUSH
20071: CALL_OW 274
20075: PPUSH
20076: CALL 88455 0 1
20080: PUSH
20081: LD_INT 3
20083: ARRAY
20084: PUSH
20085: LD_EXP 64
20089: PUSH
20090: LD_INT 3
20092: ARRAY
20093: LESS
20094: IFFALSE 20108
// begin HintSpec ( ArtifactCost , 2 ) ;
20096: LD_STRING ArtifactCost
20098: PPUSH
20099: LD_INT 2
20101: PPUSH
20102: CALL_OW 338
// exit ;
20106: GO 20299
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20108: LD_INT 37
20110: PPUSH
20111: LD_INT 1
20113: PPUSH
20114: CALL_OW 424
// time := 0 0$30 ;
20118: LD_ADDR_VAR 0 7
20122: PUSH
20123: LD_INT 1050
20125: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20126: LD_ADDR_EXP 71
20130: PUSH
20131: LD_EXP 71
20135: PPUSH
20136: LD_INT 3
20138: PPUSH
20139: LD_INT 0
20141: PPUSH
20142: CALL_OW 1
20146: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20147: LD_ADDR_OWVAR 47
20151: PUSH
20152: LD_STRING #Am15a-1
20154: PUSH
20155: LD_VAR 0 7
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// time := time - 0 0$1 ;
20171: LD_ADDR_VAR 0 7
20175: PUSH
20176: LD_VAR 0 7
20180: PUSH
20181: LD_INT 35
20183: MINUS
20184: ST_TO_ADDR
// until time = 0 0$00 ;
20185: LD_VAR 0 7
20189: PUSH
20190: LD_INT 0
20192: EQUAL
20193: IFFALSE 20147
// display_strings :=  ;
20195: LD_ADDR_OWVAR 47
20199: PUSH
20200: LD_STRING 
20202: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20203: LD_INT 37
20205: PPUSH
20206: LD_INT 0
20208: PPUSH
20209: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20213: LD_ADDR_VAR 0 8
20217: PUSH
20218: LD_INT 37
20220: PPUSH
20221: LD_INT 3
20223: PUSH
20224: LD_INT 21
20226: PUSH
20227: LD_INT 3
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PPUSH
20238: CALL_OW 70
20242: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20243: LD_VAR 0 3
20247: PPUSH
20248: LD_VAR 0 4
20252: PPUSH
20253: CALL_OW 84
// for un in list do
20257: LD_ADDR_VAR 0 9
20261: PUSH
20262: LD_VAR 0 8
20266: PUSH
20267: FOR_IN
20268: IFFALSE 20297
// TeleportUnit ( un , x , y , 12 , true ) ;
20270: LD_VAR 0 9
20274: PPUSH
20275: LD_VAR 0 3
20279: PPUSH
20280: LD_VAR 0 4
20284: PPUSH
20285: LD_INT 12
20287: PPUSH
20288: LD_INT 1
20290: PPUSH
20291: CALL_OW 483
20295: GO 20267
20297: POP
20298: POP
// end ; end ;
20299: PPOPN 9
20301: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20302: LD_INT 0
20304: PPUSH
20305: PPUSH
// begin labNum := 0 ;
20306: LD_ADDR_VAR 0 4
20310: PUSH
20311: LD_INT 0
20313: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20314: LD_ADDR_VAR 0 3
20318: PUSH
20319: DOUBLE
20320: LD_INT 1
20322: DEC
20323: ST_TO_ADDR
20324: LD_EXP 69
20328: PUSH
20329: FOR_TO
20330: IFFALSE 20364
// if artifactsLabs [ i ] = lab then
20332: LD_EXP 69
20336: PUSH
20337: LD_VAR 0 3
20341: ARRAY
20342: PUSH
20343: LD_VAR 0 1
20347: EQUAL
20348: IFFALSE 20362
// begin labNum := i ;
20350: LD_ADDR_VAR 0 4
20354: PUSH
20355: LD_VAR 0 3
20359: ST_TO_ADDR
// break ;
20360: GO 20364
// end ;
20362: GO 20329
20364: POP
20365: POP
// if not labNum then
20366: LD_VAR 0 4
20370: NOT
20371: IFFALSE 20375
// exit ;
20373: GO 20453
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20375: LD_INT 7
20377: PPUSH
20378: LD_EXP 70
20382: PUSH
20383: LD_VAR 0 4
20387: ARRAY
20388: PUSH
20389: LD_INT 3
20391: ARRAY
20392: PPUSH
20393: LD_INT 2
20395: PPUSH
20396: LD_VAR 0 1
20400: PPUSH
20401: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20405: LD_ADDR_EXP 68
20409: PUSH
20410: LD_EXP 68
20414: PPUSH
20415: LD_VAR 0 4
20419: PPUSH
20420: LD_VAR 0 2
20424: PPUSH
20425: CALL_OW 1
20429: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20430: LD_ADDR_EXP 66
20434: PUSH
20435: LD_EXP 66
20439: PPUSH
20440: LD_VAR 0 4
20444: PPUSH
20445: LD_INT 0
20447: PPUSH
20448: CALL_OW 1
20452: ST_TO_ADDR
// end ;
20453: PPOPN 4
20455: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20456: LD_INT 0
20458: PPUSH
20459: PPUSH
// begin labNum := 0 ;
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 0
20467: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20468: LD_ADDR_VAR 0 2
20472: PUSH
20473: DOUBLE
20474: LD_INT 1
20476: DEC
20477: ST_TO_ADDR
20478: LD_EXP 69
20482: PUSH
20483: FOR_TO
20484: IFFALSE 20518
// if artifactsLabs [ i ] = lab then
20486: LD_EXP 69
20490: PUSH
20491: LD_VAR 0 2
20495: ARRAY
20496: PUSH
20497: LD_VAR 0 1
20501: EQUAL
20502: IFFALSE 20516
// begin labNum := i ;
20504: LD_ADDR_VAR 0 3
20508: PUSH
20509: LD_VAR 0 2
20513: ST_TO_ADDR
// break ;
20514: GO 20518
// end ;
20516: GO 20483
20518: POP
20519: POP
// if not labNum then
20520: LD_VAR 0 3
20524: NOT
20525: IFFALSE 20529
// exit ;
20527: GO 20691
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20529: LD_INT 7
20531: PPUSH
20532: LD_EXP 70
20536: PUSH
20537: LD_VAR 0 3
20541: ARRAY
20542: PUSH
20543: LD_INT 3
20545: ARRAY
20546: PPUSH
20547: LD_INT 0
20549: PPUSH
20550: LD_VAR 0 1
20554: PPUSH
20555: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20559: LD_ADDR_EXP 65
20563: PUSH
20564: LD_EXP 65
20568: PPUSH
20569: LD_VAR 0 3
20573: PPUSH
20574: LD_INT 1
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20582: LD_ADDR_EXP 71
20586: PUSH
20587: LD_EXP 71
20591: PPUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 1
20604: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20605: LD_ADDR_EXP 66
20609: PUSH
20610: LD_EXP 66
20614: PPUSH
20615: LD_VAR 0 3
20619: PPUSH
20620: LD_INT 0
20622: PPUSH
20623: CALL_OW 1
20627: ST_TO_ADDR
// case labNum of 1 :
20628: LD_VAR 0 3
20632: PUSH
20633: LD_INT 1
20635: DOUBLE
20636: EQUAL
20637: IFTRUE 20641
20639: GO 20652
20641: POP
// artifactIResearched := true ; 2 :
20642: LD_ADDR_EXP 12
20646: PUSH
20647: LD_INT 1
20649: ST_TO_ADDR
20650: GO 20691
20652: LD_INT 2
20654: DOUBLE
20655: EQUAL
20656: IFTRUE 20660
20658: GO 20671
20660: POP
// artifactIIResearched := true ; 3 :
20661: LD_ADDR_EXP 13
20665: PUSH
20666: LD_INT 1
20668: ST_TO_ADDR
20669: GO 20691
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20690
20679: POP
// artifactIIIResearched := true ; end ;
20680: LD_ADDR_EXP 14
20684: PUSH
20685: LD_INT 1
20687: ST_TO_ADDR
20688: GO 20691
20690: POP
// end ; end_of_file
20691: PPOPN 3
20693: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20694: LD_INT 0
20696: PPUSH
// ar_miner := 81 ;
20697: LD_ADDR_EXP 79
20701: PUSH
20702: LD_INT 81
20704: ST_TO_ADDR
// ar_crane := 88 ;
20705: LD_ADDR_EXP 78
20709: PUSH
20710: LD_INT 88
20712: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20713: LD_ADDR_EXP 73
20717: PUSH
20718: LD_INT 89
20720: ST_TO_ADDR
// us_hack := 99 ;
20721: LD_ADDR_EXP 74
20725: PUSH
20726: LD_INT 99
20728: ST_TO_ADDR
// us_artillery := 97 ;
20729: LD_ADDR_EXP 75
20733: PUSH
20734: LD_INT 97
20736: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20737: LD_ADDR_EXP 76
20741: PUSH
20742: LD_INT 91
20744: ST_TO_ADDR
// ar_mortar := 92 ;
20745: LD_ADDR_EXP 77
20749: PUSH
20750: LD_INT 92
20752: ST_TO_ADDR
// ru_radar := 98 ;
20753: LD_ADDR_EXP 72
20757: PUSH
20758: LD_INT 98
20760: ST_TO_ADDR
// tech_Artillery := 80 ;
20761: LD_ADDR_EXP 80
20765: PUSH
20766: LD_INT 80
20768: ST_TO_ADDR
// tech_RadMat := 81 ;
20769: LD_ADDR_EXP 81
20773: PUSH
20774: LD_INT 81
20776: ST_TO_ADDR
// tech_BasicTools := 82 ;
20777: LD_ADDR_EXP 82
20781: PUSH
20782: LD_INT 82
20784: ST_TO_ADDR
// tech_Cargo := 83 ;
20785: LD_ADDR_EXP 83
20789: PUSH
20790: LD_INT 83
20792: ST_TO_ADDR
// tech_Track := 84 ;
20793: LD_ADDR_EXP 84
20797: PUSH
20798: LD_INT 84
20800: ST_TO_ADDR
// tech_Crane := 85 ;
20801: LD_ADDR_EXP 85
20805: PUSH
20806: LD_INT 85
20808: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20809: LD_ADDR_EXP 86
20813: PUSH
20814: LD_INT 86
20816: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20817: LD_ADDR_EXP 87
20821: PUSH
20822: LD_INT 87
20824: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20825: LD_ADDR_EXP 88
20829: PUSH
20830: LD_INT 88
20832: ST_TO_ADDR
// class_mastodont := 31 ;
20833: LD_ADDR_EXP 89
20837: PUSH
20838: LD_INT 31
20840: ST_TO_ADDR
// class_horse := 21 ;
20841: LD_ADDR_EXP 90
20845: PUSH
20846: LD_INT 21
20848: ST_TO_ADDR
// end ;
20849: LD_VAR 0 1
20853: RET
// every 1 do
20854: GO 20856
20856: DISABLE
// InitGlobalVariables ; end_of_file
20857: CALL 20694 0 0
20861: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20862: LD_INT 0
20864: PPUSH
20865: PPUSH
// skirmish := false ;
20866: LD_ADDR_EXP 91
20870: PUSH
20871: LD_INT 0
20873: ST_TO_ADDR
// debug_mc := false ;
20874: LD_ADDR_EXP 92
20878: PUSH
20879: LD_INT 0
20881: ST_TO_ADDR
// mc_bases := [ ] ;
20882: LD_ADDR_EXP 93
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_sides := [ ] ;
20889: LD_ADDR_EXP 119
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20896: LD_ADDR_EXP 94
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20903: LD_ADDR_EXP 95
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_need_heal := [ ] ;
20910: LD_ADDR_EXP 96
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_healers := [ ] ;
20917: LD_ADDR_EXP 97
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_build_list := [ ] ;
20924: LD_ADDR_EXP 98
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20931: LD_ADDR_EXP 125
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_builders := [ ] ;
20938: LD_ADDR_EXP 99
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_construct_list := [ ] ;
20945: LD_ADDR_EXP 100
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_turret_list := [ ] ;
20952: LD_ADDR_EXP 101
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20959: LD_ADDR_EXP 102
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_miners := [ ] ;
20966: LD_ADDR_EXP 107
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_mines := [ ] ;
20973: LD_ADDR_EXP 106
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_minefields := [ ] ;
20980: LD_ADDR_EXP 108
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_crates := [ ] ;
20987: LD_ADDR_EXP 109
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20994: LD_ADDR_EXP 110
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_crates_area := [ ] ;
21001: LD_ADDR_EXP 111
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// mc_vehicles := [ ] ;
21008: LD_ADDR_EXP 112
21012: PUSH
21013: EMPTY
21014: ST_TO_ADDR
// mc_attack := [ ] ;
21015: LD_ADDR_EXP 113
21019: PUSH
21020: EMPTY
21021: ST_TO_ADDR
// mc_produce := [ ] ;
21022: LD_ADDR_EXP 114
21026: PUSH
21027: EMPTY
21028: ST_TO_ADDR
// mc_defender := [ ] ;
21029: LD_ADDR_EXP 115
21033: PUSH
21034: EMPTY
21035: ST_TO_ADDR
// mc_parking := [ ] ;
21036: LD_ADDR_EXP 117
21040: PUSH
21041: EMPTY
21042: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21043: LD_ADDR_EXP 103
21047: PUSH
21048: EMPTY
21049: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21050: LD_ADDR_EXP 105
21054: PUSH
21055: EMPTY
21056: ST_TO_ADDR
// mc_scan := [ ] ;
21057: LD_ADDR_EXP 116
21061: PUSH
21062: EMPTY
21063: ST_TO_ADDR
// mc_scan_area := [ ] ;
21064: LD_ADDR_EXP 118
21068: PUSH
21069: EMPTY
21070: ST_TO_ADDR
// mc_tech := [ ] ;
21071: LD_ADDR_EXP 120
21075: PUSH
21076: EMPTY
21077: ST_TO_ADDR
// mc_class := [ ] ;
21078: LD_ADDR_EXP 134
21082: PUSH
21083: EMPTY
21084: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21085: LD_ADDR_EXP 135
21089: PUSH
21090: EMPTY
21091: ST_TO_ADDR
// mc_is_defending := [ ] ;
21092: LD_ADDR_EXP 136
21096: PUSH
21097: EMPTY
21098: ST_TO_ADDR
// end ;
21099: LD_VAR 0 1
21103: RET
// export function MC_Kill ( base ) ; begin
21104: LD_INT 0
21106: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21107: LD_ADDR_EXP 93
21111: PUSH
21112: LD_EXP 93
21116: PPUSH
21117: LD_VAR 0 1
21121: PPUSH
21122: EMPTY
21123: PPUSH
21124: CALL_OW 1
21128: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21129: LD_ADDR_EXP 94
21133: PUSH
21134: LD_EXP 94
21138: PPUSH
21139: LD_VAR 0 1
21143: PPUSH
21144: EMPTY
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21151: LD_ADDR_EXP 95
21155: PUSH
21156: LD_EXP 95
21160: PPUSH
21161: LD_VAR 0 1
21165: PPUSH
21166: EMPTY
21167: PPUSH
21168: CALL_OW 1
21172: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21173: LD_ADDR_EXP 96
21177: PUSH
21178: LD_EXP 96
21182: PPUSH
21183: LD_VAR 0 1
21187: PPUSH
21188: EMPTY
21189: PPUSH
21190: CALL_OW 1
21194: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21195: LD_ADDR_EXP 97
21199: PUSH
21200: LD_EXP 97
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: EMPTY
21211: PPUSH
21212: CALL_OW 1
21216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21217: LD_ADDR_EXP 98
21221: PUSH
21222: LD_EXP 98
21226: PPUSH
21227: LD_VAR 0 1
21231: PPUSH
21232: EMPTY
21233: PPUSH
21234: CALL_OW 1
21238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21239: LD_ADDR_EXP 99
21243: PUSH
21244: LD_EXP 99
21248: PPUSH
21249: LD_VAR 0 1
21253: PPUSH
21254: EMPTY
21255: PPUSH
21256: CALL_OW 1
21260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21261: LD_ADDR_EXP 100
21265: PUSH
21266: LD_EXP 100
21270: PPUSH
21271: LD_VAR 0 1
21275: PPUSH
21276: EMPTY
21277: PPUSH
21278: CALL_OW 1
21282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21283: LD_ADDR_EXP 101
21287: PUSH
21288: LD_EXP 101
21292: PPUSH
21293: LD_VAR 0 1
21297: PPUSH
21298: EMPTY
21299: PPUSH
21300: CALL_OW 1
21304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21305: LD_ADDR_EXP 102
21309: PUSH
21310: LD_EXP 102
21314: PPUSH
21315: LD_VAR 0 1
21319: PPUSH
21320: EMPTY
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21327: LD_ADDR_EXP 103
21331: PUSH
21332: LD_EXP 103
21336: PPUSH
21337: LD_VAR 0 1
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21349: LD_ADDR_EXP 104
21353: PUSH
21354: LD_EXP 104
21358: PPUSH
21359: LD_VAR 0 1
21363: PPUSH
21364: LD_INT 0
21366: PPUSH
21367: CALL_OW 1
21371: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21372: LD_ADDR_EXP 105
21376: PUSH
21377: LD_EXP 105
21381: PPUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: EMPTY
21388: PPUSH
21389: CALL_OW 1
21393: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21394: LD_ADDR_EXP 106
21398: PUSH
21399: LD_EXP 106
21403: PPUSH
21404: LD_VAR 0 1
21408: PPUSH
21409: EMPTY
21410: PPUSH
21411: CALL_OW 1
21415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21416: LD_ADDR_EXP 107
21420: PUSH
21421: LD_EXP 107
21425: PPUSH
21426: LD_VAR 0 1
21430: PPUSH
21431: EMPTY
21432: PPUSH
21433: CALL_OW 1
21437: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21438: LD_ADDR_EXP 108
21442: PUSH
21443: LD_EXP 108
21447: PPUSH
21448: LD_VAR 0 1
21452: PPUSH
21453: EMPTY
21454: PPUSH
21455: CALL_OW 1
21459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21460: LD_ADDR_EXP 109
21464: PUSH
21465: LD_EXP 109
21469: PPUSH
21470: LD_VAR 0 1
21474: PPUSH
21475: EMPTY
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21482: LD_ADDR_EXP 110
21486: PUSH
21487: LD_EXP 110
21491: PPUSH
21492: LD_VAR 0 1
21496: PPUSH
21497: EMPTY
21498: PPUSH
21499: CALL_OW 1
21503: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21504: LD_ADDR_EXP 111
21508: PUSH
21509: LD_EXP 111
21513: PPUSH
21514: LD_VAR 0 1
21518: PPUSH
21519: EMPTY
21520: PPUSH
21521: CALL_OW 1
21525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21526: LD_ADDR_EXP 112
21530: PUSH
21531: LD_EXP 112
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: EMPTY
21542: PPUSH
21543: CALL_OW 1
21547: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21548: LD_ADDR_EXP 113
21552: PUSH
21553: LD_EXP 113
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: EMPTY
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21570: LD_ADDR_EXP 114
21574: PUSH
21575: LD_EXP 114
21579: PPUSH
21580: LD_VAR 0 1
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21592: LD_ADDR_EXP 115
21596: PUSH
21597: LD_EXP 115
21601: PPUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21614: LD_ADDR_EXP 116
21618: PUSH
21619: LD_EXP 116
21623: PPUSH
21624: LD_VAR 0 1
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21636: LD_ADDR_EXP 117
21640: PUSH
21641: LD_EXP 117
21645: PPUSH
21646: LD_VAR 0 1
21650: PPUSH
21651: EMPTY
21652: PPUSH
21653: CALL_OW 1
21657: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21658: LD_ADDR_EXP 118
21662: PUSH
21663: LD_EXP 118
21667: PPUSH
21668: LD_VAR 0 1
21672: PPUSH
21673: EMPTY
21674: PPUSH
21675: CALL_OW 1
21679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21680: LD_ADDR_EXP 120
21684: PUSH
21685: LD_EXP 120
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: EMPTY
21696: PPUSH
21697: CALL_OW 1
21701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21702: LD_ADDR_EXP 122
21706: PUSH
21707: LD_EXP 122
21711: PPUSH
21712: LD_VAR 0 1
21716: PPUSH
21717: EMPTY
21718: PPUSH
21719: CALL_OW 1
21723: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21724: LD_ADDR_EXP 123
21728: PUSH
21729: LD_EXP 123
21733: PPUSH
21734: LD_VAR 0 1
21738: PPUSH
21739: EMPTY
21740: PPUSH
21741: CALL_OW 1
21745: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21746: LD_ADDR_EXP 124
21750: PUSH
21751: LD_EXP 124
21755: PPUSH
21756: LD_VAR 0 1
21760: PPUSH
21761: EMPTY
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21768: LD_ADDR_EXP 125
21772: PUSH
21773: LD_EXP 125
21777: PPUSH
21778: LD_VAR 0 1
21782: PPUSH
21783: EMPTY
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21790: LD_ADDR_EXP 126
21794: PUSH
21795: LD_EXP 126
21799: PPUSH
21800: LD_VAR 0 1
21804: PPUSH
21805: EMPTY
21806: PPUSH
21807: CALL_OW 1
21811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21812: LD_ADDR_EXP 127
21816: PUSH
21817: LD_EXP 127
21821: PPUSH
21822: LD_VAR 0 1
21826: PPUSH
21827: EMPTY
21828: PPUSH
21829: CALL_OW 1
21833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21834: LD_ADDR_EXP 128
21838: PUSH
21839: LD_EXP 128
21843: PPUSH
21844: LD_VAR 0 1
21848: PPUSH
21849: EMPTY
21850: PPUSH
21851: CALL_OW 1
21855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21856: LD_ADDR_EXP 129
21860: PUSH
21861: LD_EXP 129
21865: PPUSH
21866: LD_VAR 0 1
21870: PPUSH
21871: EMPTY
21872: PPUSH
21873: CALL_OW 1
21877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21878: LD_ADDR_EXP 130
21882: PUSH
21883: LD_EXP 130
21887: PPUSH
21888: LD_VAR 0 1
21892: PPUSH
21893: EMPTY
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21900: LD_ADDR_EXP 131
21904: PUSH
21905: LD_EXP 131
21909: PPUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: EMPTY
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21922: LD_ADDR_EXP 132
21926: PUSH
21927: LD_EXP 132
21931: PPUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21944: LD_ADDR_EXP 133
21948: PUSH
21949: LD_EXP 133
21953: PPUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21966: LD_ADDR_EXP 134
21970: PUSH
21971: LD_EXP 134
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21988: LD_ADDR_EXP 135
21992: PUSH
21993: LD_EXP 135
21997: PPUSH
21998: LD_VAR 0 1
22002: PPUSH
22003: LD_INT 0
22005: PPUSH
22006: CALL_OW 1
22010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22011: LD_ADDR_EXP 136
22015: PUSH
22016: LD_EXP 136
22020: PPUSH
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 0
22028: PPUSH
22029: CALL_OW 1
22033: ST_TO_ADDR
// end ;
22034: LD_VAR 0 2
22038: RET
// export function MC_Add ( side , units ) ; var base ; begin
22039: LD_INT 0
22041: PPUSH
22042: PPUSH
// base := mc_bases + 1 ;
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: LD_EXP 93
22052: PUSH
22053: LD_INT 1
22055: PLUS
22056: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22057: LD_ADDR_EXP 119
22061: PUSH
22062: LD_EXP 119
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: LD_VAR 0 1
22076: PPUSH
22077: CALL_OW 1
22081: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22082: LD_ADDR_EXP 93
22086: PUSH
22087: LD_EXP 93
22091: PPUSH
22092: LD_VAR 0 4
22096: PPUSH
22097: LD_VAR 0 2
22101: PPUSH
22102: CALL_OW 1
22106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22107: LD_ADDR_EXP 94
22111: PUSH
22112: LD_EXP 94
22116: PPUSH
22117: LD_VAR 0 4
22121: PPUSH
22122: EMPTY
22123: PPUSH
22124: CALL_OW 1
22128: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22129: LD_ADDR_EXP 95
22133: PUSH
22134: LD_EXP 95
22138: PPUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: EMPTY
22145: PPUSH
22146: CALL_OW 1
22150: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22151: LD_ADDR_EXP 96
22155: PUSH
22156: LD_EXP 96
22160: PPUSH
22161: LD_VAR 0 4
22165: PPUSH
22166: EMPTY
22167: PPUSH
22168: CALL_OW 1
22172: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22173: LD_ADDR_EXP 97
22177: PUSH
22178: LD_EXP 97
22182: PPUSH
22183: LD_VAR 0 4
22187: PPUSH
22188: EMPTY
22189: PPUSH
22190: CALL_OW 1
22194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22195: LD_ADDR_EXP 98
22199: PUSH
22200: LD_EXP 98
22204: PPUSH
22205: LD_VAR 0 4
22209: PPUSH
22210: EMPTY
22211: PPUSH
22212: CALL_OW 1
22216: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22217: LD_ADDR_EXP 99
22221: PUSH
22222: LD_EXP 99
22226: PPUSH
22227: LD_VAR 0 4
22231: PPUSH
22232: EMPTY
22233: PPUSH
22234: CALL_OW 1
22238: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22239: LD_ADDR_EXP 100
22243: PUSH
22244: LD_EXP 100
22248: PPUSH
22249: LD_VAR 0 4
22253: PPUSH
22254: EMPTY
22255: PPUSH
22256: CALL_OW 1
22260: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22261: LD_ADDR_EXP 101
22265: PUSH
22266: LD_EXP 101
22270: PPUSH
22271: LD_VAR 0 4
22275: PPUSH
22276: EMPTY
22277: PPUSH
22278: CALL_OW 1
22282: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22283: LD_ADDR_EXP 102
22287: PUSH
22288: LD_EXP 102
22292: PPUSH
22293: LD_VAR 0 4
22297: PPUSH
22298: EMPTY
22299: PPUSH
22300: CALL_OW 1
22304: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22305: LD_ADDR_EXP 103
22309: PUSH
22310: LD_EXP 103
22314: PPUSH
22315: LD_VAR 0 4
22319: PPUSH
22320: EMPTY
22321: PPUSH
22322: CALL_OW 1
22326: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22327: LD_ADDR_EXP 104
22331: PUSH
22332: LD_EXP 104
22336: PPUSH
22337: LD_VAR 0 4
22341: PPUSH
22342: LD_INT 0
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22350: LD_ADDR_EXP 105
22354: PUSH
22355: LD_EXP 105
22359: PPUSH
22360: LD_VAR 0 4
22364: PPUSH
22365: EMPTY
22366: PPUSH
22367: CALL_OW 1
22371: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22372: LD_ADDR_EXP 106
22376: PUSH
22377: LD_EXP 106
22381: PPUSH
22382: LD_VAR 0 4
22386: PPUSH
22387: EMPTY
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22394: LD_ADDR_EXP 107
22398: PUSH
22399: LD_EXP 107
22403: PPUSH
22404: LD_VAR 0 4
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22416: LD_ADDR_EXP 108
22420: PUSH
22421: LD_EXP 108
22425: PPUSH
22426: LD_VAR 0 4
22430: PPUSH
22431: EMPTY
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22438: LD_ADDR_EXP 109
22442: PUSH
22443: LD_EXP 109
22447: PPUSH
22448: LD_VAR 0 4
22452: PPUSH
22453: EMPTY
22454: PPUSH
22455: CALL_OW 1
22459: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22460: LD_ADDR_EXP 110
22464: PUSH
22465: LD_EXP 110
22469: PPUSH
22470: LD_VAR 0 4
22474: PPUSH
22475: EMPTY
22476: PPUSH
22477: CALL_OW 1
22481: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22482: LD_ADDR_EXP 111
22486: PUSH
22487: LD_EXP 111
22491: PPUSH
22492: LD_VAR 0 4
22496: PPUSH
22497: EMPTY
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22504: LD_ADDR_EXP 112
22508: PUSH
22509: LD_EXP 112
22513: PPUSH
22514: LD_VAR 0 4
22518: PPUSH
22519: EMPTY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22526: LD_ADDR_EXP 113
22530: PUSH
22531: LD_EXP 113
22535: PPUSH
22536: LD_VAR 0 4
22540: PPUSH
22541: EMPTY
22542: PPUSH
22543: CALL_OW 1
22547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22548: LD_ADDR_EXP 114
22552: PUSH
22553: LD_EXP 114
22557: PPUSH
22558: LD_VAR 0 4
22562: PPUSH
22563: EMPTY
22564: PPUSH
22565: CALL_OW 1
22569: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22570: LD_ADDR_EXP 115
22574: PUSH
22575: LD_EXP 115
22579: PPUSH
22580: LD_VAR 0 4
22584: PPUSH
22585: EMPTY
22586: PPUSH
22587: CALL_OW 1
22591: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22592: LD_ADDR_EXP 116
22596: PUSH
22597: LD_EXP 116
22601: PPUSH
22602: LD_VAR 0 4
22606: PPUSH
22607: EMPTY
22608: PPUSH
22609: CALL_OW 1
22613: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22614: LD_ADDR_EXP 117
22618: PUSH
22619: LD_EXP 117
22623: PPUSH
22624: LD_VAR 0 4
22628: PPUSH
22629: EMPTY
22630: PPUSH
22631: CALL_OW 1
22635: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22636: LD_ADDR_EXP 118
22640: PUSH
22641: LD_EXP 118
22645: PPUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: EMPTY
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22658: LD_ADDR_EXP 120
22662: PUSH
22663: LD_EXP 120
22667: PPUSH
22668: LD_VAR 0 4
22672: PPUSH
22673: EMPTY
22674: PPUSH
22675: CALL_OW 1
22679: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22680: LD_ADDR_EXP 122
22684: PUSH
22685: LD_EXP 122
22689: PPUSH
22690: LD_VAR 0 4
22694: PPUSH
22695: EMPTY
22696: PPUSH
22697: CALL_OW 1
22701: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22702: LD_ADDR_EXP 123
22706: PUSH
22707: LD_EXP 123
22711: PPUSH
22712: LD_VAR 0 4
22716: PPUSH
22717: EMPTY
22718: PPUSH
22719: CALL_OW 1
22723: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22724: LD_ADDR_EXP 124
22728: PUSH
22729: LD_EXP 124
22733: PPUSH
22734: LD_VAR 0 4
22738: PPUSH
22739: EMPTY
22740: PPUSH
22741: CALL_OW 1
22745: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22746: LD_ADDR_EXP 125
22750: PUSH
22751: LD_EXP 125
22755: PPUSH
22756: LD_VAR 0 4
22760: PPUSH
22761: EMPTY
22762: PPUSH
22763: CALL_OW 1
22767: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22768: LD_ADDR_EXP 126
22772: PUSH
22773: LD_EXP 126
22777: PPUSH
22778: LD_VAR 0 4
22782: PPUSH
22783: EMPTY
22784: PPUSH
22785: CALL_OW 1
22789: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22790: LD_ADDR_EXP 127
22794: PUSH
22795: LD_EXP 127
22799: PPUSH
22800: LD_VAR 0 4
22804: PPUSH
22805: EMPTY
22806: PPUSH
22807: CALL_OW 1
22811: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22812: LD_ADDR_EXP 128
22816: PUSH
22817: LD_EXP 128
22821: PPUSH
22822: LD_VAR 0 4
22826: PPUSH
22827: EMPTY
22828: PPUSH
22829: CALL_OW 1
22833: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22834: LD_ADDR_EXP 129
22838: PUSH
22839: LD_EXP 129
22843: PPUSH
22844: LD_VAR 0 4
22848: PPUSH
22849: EMPTY
22850: PPUSH
22851: CALL_OW 1
22855: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22856: LD_ADDR_EXP 130
22860: PUSH
22861: LD_EXP 130
22865: PPUSH
22866: LD_VAR 0 4
22870: PPUSH
22871: EMPTY
22872: PPUSH
22873: CALL_OW 1
22877: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22878: LD_ADDR_EXP 131
22882: PUSH
22883: LD_EXP 131
22887: PPUSH
22888: LD_VAR 0 4
22892: PPUSH
22893: EMPTY
22894: PPUSH
22895: CALL_OW 1
22899: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22900: LD_ADDR_EXP 132
22904: PUSH
22905: LD_EXP 132
22909: PPUSH
22910: LD_VAR 0 4
22914: PPUSH
22915: EMPTY
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22922: LD_ADDR_EXP 133
22926: PUSH
22927: LD_EXP 133
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: EMPTY
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22944: LD_ADDR_EXP 134
22948: PUSH
22949: LD_EXP 134
22953: PPUSH
22954: LD_VAR 0 4
22958: PPUSH
22959: EMPTY
22960: PPUSH
22961: CALL_OW 1
22965: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22966: LD_ADDR_EXP 135
22970: PUSH
22971: LD_EXP 135
22975: PPUSH
22976: LD_VAR 0 4
22980: PPUSH
22981: LD_INT 0
22983: PPUSH
22984: CALL_OW 1
22988: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22989: LD_ADDR_EXP 136
22993: PUSH
22994: LD_EXP 136
22998: PPUSH
22999: LD_VAR 0 4
23003: PPUSH
23004: LD_INT 0
23006: PPUSH
23007: CALL_OW 1
23011: ST_TO_ADDR
// result := base ;
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_VAR 0 4
23021: ST_TO_ADDR
// end ;
23022: LD_VAR 0 3
23026: RET
// export function MC_Start ( ) ; var i ; begin
23027: LD_INT 0
23029: PPUSH
23030: PPUSH
// for i = 1 to mc_bases do
23031: LD_ADDR_VAR 0 2
23035: PUSH
23036: DOUBLE
23037: LD_INT 1
23039: DEC
23040: ST_TO_ADDR
23041: LD_EXP 93
23045: PUSH
23046: FOR_TO
23047: IFFALSE 24147
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23049: LD_ADDR_EXP 93
23053: PUSH
23054: LD_EXP 93
23058: PPUSH
23059: LD_VAR 0 2
23063: PPUSH
23064: LD_EXP 93
23068: PUSH
23069: LD_VAR 0 2
23073: ARRAY
23074: PUSH
23075: LD_INT 0
23077: DIFF
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23084: LD_ADDR_EXP 94
23088: PUSH
23089: LD_EXP 94
23093: PPUSH
23094: LD_VAR 0 2
23098: PPUSH
23099: EMPTY
23100: PPUSH
23101: CALL_OW 1
23105: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23106: LD_ADDR_EXP 95
23110: PUSH
23111: LD_EXP 95
23115: PPUSH
23116: LD_VAR 0 2
23120: PPUSH
23121: EMPTY
23122: PPUSH
23123: CALL_OW 1
23127: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23128: LD_ADDR_EXP 96
23132: PUSH
23133: LD_EXP 96
23137: PPUSH
23138: LD_VAR 0 2
23142: PPUSH
23143: EMPTY
23144: PPUSH
23145: CALL_OW 1
23149: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23150: LD_ADDR_EXP 97
23154: PUSH
23155: LD_EXP 97
23159: PPUSH
23160: LD_VAR 0 2
23164: PPUSH
23165: EMPTY
23166: PUSH
23167: EMPTY
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 1
23177: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23178: LD_ADDR_EXP 98
23182: PUSH
23183: LD_EXP 98
23187: PPUSH
23188: LD_VAR 0 2
23192: PPUSH
23193: EMPTY
23194: PPUSH
23195: CALL_OW 1
23199: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23200: LD_ADDR_EXP 125
23204: PUSH
23205: LD_EXP 125
23209: PPUSH
23210: LD_VAR 0 2
23214: PPUSH
23215: EMPTY
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23222: LD_ADDR_EXP 99
23226: PUSH
23227: LD_EXP 99
23231: PPUSH
23232: LD_VAR 0 2
23236: PPUSH
23237: EMPTY
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23244: LD_ADDR_EXP 100
23248: PUSH
23249: LD_EXP 100
23253: PPUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: EMPTY
23260: PPUSH
23261: CALL_OW 1
23265: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23266: LD_ADDR_EXP 101
23270: PUSH
23271: LD_EXP 101
23275: PPUSH
23276: LD_VAR 0 2
23280: PPUSH
23281: LD_EXP 93
23285: PUSH
23286: LD_VAR 0 2
23290: ARRAY
23291: PPUSH
23292: LD_INT 2
23294: PUSH
23295: LD_INT 30
23297: PUSH
23298: LD_INT 32
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PUSH
23305: LD_INT 30
23307: PUSH
23308: LD_INT 33
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: LIST
23319: PPUSH
23320: CALL_OW 72
23324: PPUSH
23325: CALL_OW 1
23329: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23330: LD_ADDR_EXP 102
23334: PUSH
23335: LD_EXP 102
23339: PPUSH
23340: LD_VAR 0 2
23344: PPUSH
23345: LD_EXP 93
23349: PUSH
23350: LD_VAR 0 2
23354: ARRAY
23355: PPUSH
23356: LD_INT 2
23358: PUSH
23359: LD_INT 30
23361: PUSH
23362: LD_INT 32
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 30
23371: PUSH
23372: LD_INT 31
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 58
23386: PUSH
23387: EMPTY
23388: LIST
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PPUSH
23394: CALL_OW 72
23398: PPUSH
23399: CALL_OW 1
23403: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23404: LD_ADDR_EXP 103
23408: PUSH
23409: LD_EXP 103
23413: PPUSH
23414: LD_VAR 0 2
23418: PPUSH
23419: EMPTY
23420: PPUSH
23421: CALL_OW 1
23425: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23426: LD_ADDR_EXP 107
23430: PUSH
23431: LD_EXP 107
23435: PPUSH
23436: LD_VAR 0 2
23440: PPUSH
23441: EMPTY
23442: PPUSH
23443: CALL_OW 1
23447: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23448: LD_ADDR_EXP 106
23452: PUSH
23453: LD_EXP 106
23457: PPUSH
23458: LD_VAR 0 2
23462: PPUSH
23463: EMPTY
23464: PPUSH
23465: CALL_OW 1
23469: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23470: LD_ADDR_EXP 108
23474: PUSH
23475: LD_EXP 108
23479: PPUSH
23480: LD_VAR 0 2
23484: PPUSH
23485: EMPTY
23486: PPUSH
23487: CALL_OW 1
23491: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23492: LD_ADDR_EXP 109
23496: PUSH
23497: LD_EXP 109
23501: PPUSH
23502: LD_VAR 0 2
23506: PPUSH
23507: EMPTY
23508: PPUSH
23509: CALL_OW 1
23513: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23514: LD_ADDR_EXP 110
23518: PUSH
23519: LD_EXP 110
23523: PPUSH
23524: LD_VAR 0 2
23528: PPUSH
23529: EMPTY
23530: PPUSH
23531: CALL_OW 1
23535: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23536: LD_ADDR_EXP 111
23540: PUSH
23541: LD_EXP 111
23545: PPUSH
23546: LD_VAR 0 2
23550: PPUSH
23551: EMPTY
23552: PPUSH
23553: CALL_OW 1
23557: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23558: LD_ADDR_EXP 112
23562: PUSH
23563: LD_EXP 112
23567: PPUSH
23568: LD_VAR 0 2
23572: PPUSH
23573: EMPTY
23574: PPUSH
23575: CALL_OW 1
23579: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23580: LD_ADDR_EXP 113
23584: PUSH
23585: LD_EXP 113
23589: PPUSH
23590: LD_VAR 0 2
23594: PPUSH
23595: EMPTY
23596: PPUSH
23597: CALL_OW 1
23601: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23602: LD_ADDR_EXP 114
23606: PUSH
23607: LD_EXP 114
23611: PPUSH
23612: LD_VAR 0 2
23616: PPUSH
23617: EMPTY
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23624: LD_ADDR_EXP 115
23628: PUSH
23629: LD_EXP 115
23633: PPUSH
23634: LD_VAR 0 2
23638: PPUSH
23639: EMPTY
23640: PPUSH
23641: CALL_OW 1
23645: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23646: LD_ADDR_EXP 104
23650: PUSH
23651: LD_EXP 104
23655: PPUSH
23656: LD_VAR 0 2
23660: PPUSH
23661: LD_INT 0
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23669: LD_ADDR_EXP 117
23673: PUSH
23674: LD_EXP 117
23678: PPUSH
23679: LD_VAR 0 2
23683: PPUSH
23684: LD_INT 0
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23692: LD_ADDR_EXP 105
23696: PUSH
23697: LD_EXP 105
23701: PPUSH
23702: LD_VAR 0 2
23706: PPUSH
23707: EMPTY
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23714: LD_ADDR_EXP 116
23718: PUSH
23719: LD_EXP 116
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: LD_INT 0
23731: PPUSH
23732: CALL_OW 1
23736: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23737: LD_ADDR_EXP 118
23741: PUSH
23742: LD_EXP 118
23746: PPUSH
23747: LD_VAR 0 2
23751: PPUSH
23752: EMPTY
23753: PPUSH
23754: CALL_OW 1
23758: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23759: LD_ADDR_EXP 121
23763: PUSH
23764: LD_EXP 121
23768: PPUSH
23769: LD_VAR 0 2
23773: PPUSH
23774: LD_INT 0
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23782: LD_ADDR_EXP 122
23786: PUSH
23787: LD_EXP 122
23791: PPUSH
23792: LD_VAR 0 2
23796: PPUSH
23797: EMPTY
23798: PPUSH
23799: CALL_OW 1
23803: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23804: LD_ADDR_EXP 123
23808: PUSH
23809: LD_EXP 123
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: EMPTY
23820: PPUSH
23821: CALL_OW 1
23825: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23826: LD_ADDR_EXP 124
23830: PUSH
23831: LD_EXP 124
23835: PPUSH
23836: LD_VAR 0 2
23840: PPUSH
23841: EMPTY
23842: PPUSH
23843: CALL_OW 1
23847: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23848: LD_ADDR_EXP 126
23852: PUSH
23853: LD_EXP 126
23857: PPUSH
23858: LD_VAR 0 2
23862: PPUSH
23863: LD_EXP 93
23867: PUSH
23868: LD_VAR 0 2
23872: ARRAY
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 6
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 7
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 8
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: PPUSH
23913: CALL_OW 72
23917: PPUSH
23918: CALL_OW 1
23922: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23923: LD_ADDR_EXP 127
23927: PUSH
23928: LD_EXP 127
23932: PPUSH
23933: LD_VAR 0 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL_OW 1
23944: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23945: LD_ADDR_EXP 128
23949: PUSH
23950: LD_EXP 128
23954: PPUSH
23955: LD_VAR 0 2
23959: PPUSH
23960: EMPTY
23961: PPUSH
23962: CALL_OW 1
23966: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23967: LD_ADDR_EXP 129
23971: PUSH
23972: LD_EXP 129
23976: PPUSH
23977: LD_VAR 0 2
23981: PPUSH
23982: EMPTY
23983: PPUSH
23984: CALL_OW 1
23988: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23989: LD_ADDR_EXP 130
23993: PUSH
23994: LD_EXP 130
23998: PPUSH
23999: LD_VAR 0 2
24003: PPUSH
24004: EMPTY
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24011: LD_ADDR_EXP 131
24015: PUSH
24016: LD_EXP 131
24020: PPUSH
24021: LD_VAR 0 2
24025: PPUSH
24026: EMPTY
24027: PPUSH
24028: CALL_OW 1
24032: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24033: LD_ADDR_EXP 132
24037: PUSH
24038: LD_EXP 132
24042: PPUSH
24043: LD_VAR 0 2
24047: PPUSH
24048: EMPTY
24049: PPUSH
24050: CALL_OW 1
24054: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24055: LD_ADDR_EXP 133
24059: PUSH
24060: LD_EXP 133
24064: PPUSH
24065: LD_VAR 0 2
24069: PPUSH
24070: EMPTY
24071: PPUSH
24072: CALL_OW 1
24076: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24077: LD_ADDR_EXP 134
24081: PUSH
24082: LD_EXP 134
24086: PPUSH
24087: LD_VAR 0 2
24091: PPUSH
24092: EMPTY
24093: PPUSH
24094: CALL_OW 1
24098: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24099: LD_ADDR_EXP 135
24103: PUSH
24104: LD_EXP 135
24108: PPUSH
24109: LD_VAR 0 2
24113: PPUSH
24114: LD_INT 0
24116: PPUSH
24117: CALL_OW 1
24121: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24122: LD_ADDR_EXP 136
24126: PUSH
24127: LD_EXP 136
24131: PPUSH
24132: LD_VAR 0 2
24136: PPUSH
24137: LD_INT 0
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// end ;
24145: GO 23046
24147: POP
24148: POP
// MC_InitSides ( ) ;
24149: CALL 24435 0 0
// MC_InitResearch ( ) ;
24153: CALL 24174 0 0
// CustomInitMacro ( ) ;
24157: CALL 217 0 0
// skirmish := true ;
24161: LD_ADDR_EXP 91
24165: PUSH
24166: LD_INT 1
24168: ST_TO_ADDR
// end ;
24169: LD_VAR 0 1
24173: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24174: LD_INT 0
24176: PPUSH
24177: PPUSH
24178: PPUSH
24179: PPUSH
24180: PPUSH
24181: PPUSH
// if not mc_bases then
24182: LD_EXP 93
24186: NOT
24187: IFFALSE 24191
// exit ;
24189: GO 24430
// for i = 1 to 8 do
24191: LD_ADDR_VAR 0 2
24195: PUSH
24196: DOUBLE
24197: LD_INT 1
24199: DEC
24200: ST_TO_ADDR
24201: LD_INT 8
24203: PUSH
24204: FOR_TO
24205: IFFALSE 24231
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24207: LD_ADDR_EXP 120
24211: PUSH
24212: LD_EXP 120
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
24229: GO 24204
24231: POP
24232: POP
// tmp := [ ] ;
24233: LD_ADDR_VAR 0 5
24237: PUSH
24238: EMPTY
24239: ST_TO_ADDR
// for i = 1 to mc_sides do
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: DOUBLE
24246: LD_INT 1
24248: DEC
24249: ST_TO_ADDR
24250: LD_EXP 119
24254: PUSH
24255: FOR_TO
24256: IFFALSE 24314
// if not mc_sides [ i ] in tmp then
24258: LD_EXP 119
24262: PUSH
24263: LD_VAR 0 2
24267: ARRAY
24268: PUSH
24269: LD_VAR 0 5
24273: IN
24274: NOT
24275: IFFALSE 24312
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 5
24291: PUSH
24292: LD_INT 1
24294: PLUS
24295: PPUSH
24296: LD_EXP 119
24300: PUSH
24301: LD_VAR 0 2
24305: ARRAY
24306: PPUSH
24307: CALL_OW 2
24311: ST_TO_ADDR
24312: GO 24255
24314: POP
24315: POP
// if not tmp then
24316: LD_VAR 0 5
24320: NOT
24321: IFFALSE 24325
// exit ;
24323: GO 24430
// for j in tmp do
24325: LD_ADDR_VAR 0 3
24329: PUSH
24330: LD_VAR 0 5
24334: PUSH
24335: FOR_IN
24336: IFFALSE 24428
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24338: LD_ADDR_VAR 0 6
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_VAR 0 3
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PPUSH
24355: CALL_OW 69
24359: ST_TO_ADDR
// if not un then
24360: LD_VAR 0 6
24364: NOT
24365: IFFALSE 24369
// continue ;
24367: GO 24335
// nation := GetNation ( un [ 1 ] ) ;
24369: LD_ADDR_VAR 0 4
24373: PUSH
24374: LD_VAR 0 6
24378: PUSH
24379: LD_INT 1
24381: ARRAY
24382: PPUSH
24383: CALL_OW 248
24387: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24388: LD_ADDR_EXP 120
24392: PUSH
24393: LD_EXP 120
24397: PPUSH
24398: LD_VAR 0 3
24402: PPUSH
24403: LD_VAR 0 3
24407: PPUSH
24408: LD_VAR 0 4
24412: PPUSH
24413: LD_INT 1
24415: PPUSH
24416: CALL 51551 0 3
24420: PPUSH
24421: CALL_OW 1
24425: ST_TO_ADDR
// end ;
24426: GO 24335
24428: POP
24429: POP
// end ;
24430: LD_VAR 0 1
24434: RET
// export function MC_InitSides ( ) ; var i ; begin
24435: LD_INT 0
24437: PPUSH
24438: PPUSH
// if not mc_bases then
24439: LD_EXP 93
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24522
// for i = 1 to mc_bases do
24448: LD_ADDR_VAR 0 2
24452: PUSH
24453: DOUBLE
24454: LD_INT 1
24456: DEC
24457: ST_TO_ADDR
24458: LD_EXP 93
24462: PUSH
24463: FOR_TO
24464: IFFALSE 24520
// if mc_bases [ i ] then
24466: LD_EXP 93
24470: PUSH
24471: LD_VAR 0 2
24475: ARRAY
24476: IFFALSE 24518
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24478: LD_ADDR_EXP 119
24482: PUSH
24483: LD_EXP 119
24487: PPUSH
24488: LD_VAR 0 2
24492: PPUSH
24493: LD_EXP 93
24497: PUSH
24498: LD_VAR 0 2
24502: ARRAY
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 255
24512: PPUSH
24513: CALL_OW 1
24517: ST_TO_ADDR
24518: GO 24463
24520: POP
24521: POP
// end ;
24522: LD_VAR 0 1
24526: RET
// every 0 0$03 trigger skirmish do
24527: LD_EXP 91
24531: IFFALSE 24685
24533: GO 24535
24535: DISABLE
// begin enable ;
24536: ENABLE
// MC_CheckBuildings ( ) ;
24537: CALL 29183 0 0
// MC_CheckPeopleLife ( ) ;
24541: CALL 29344 0 0
// RaiseSailEvent ( 100 ) ;
24545: LD_INT 100
24547: PPUSH
24548: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24552: LD_INT 103
24554: PPUSH
24555: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24559: LD_INT 104
24561: PPUSH
24562: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24566: LD_INT 105
24568: PPUSH
24569: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24573: LD_INT 106
24575: PPUSH
24576: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24580: LD_INT 107
24582: PPUSH
24583: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24587: LD_INT 108
24589: PPUSH
24590: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24594: LD_INT 109
24596: PPUSH
24597: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24601: LD_INT 110
24603: PPUSH
24604: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24608: LD_INT 111
24610: PPUSH
24611: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24615: LD_INT 112
24617: PPUSH
24618: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24622: LD_INT 113
24624: PPUSH
24625: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24629: LD_INT 120
24631: PPUSH
24632: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24636: LD_INT 121
24638: PPUSH
24639: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24643: LD_INT 122
24645: PPUSH
24646: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24650: LD_INT 123
24652: PPUSH
24653: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24657: LD_INT 124
24659: PPUSH
24660: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24664: LD_INT 125
24666: PPUSH
24667: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24671: LD_INT 126
24673: PPUSH
24674: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24678: LD_INT 200
24680: PPUSH
24681: CALL_OW 427
// end ;
24685: END
// on SailEvent ( event ) do begin if event < 100 then
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 100
24693: LESS
24694: IFFALSE 24705
// CustomEvent ( event ) ;
24696: LD_VAR 0 1
24700: PPUSH
24701: CALL 10473 0 1
// if event = 100 then
24705: LD_VAR 0 1
24709: PUSH
24710: LD_INT 100
24712: EQUAL
24713: IFFALSE 24719
// MC_ClassManager ( ) ;
24715: CALL 25111 0 0
// if event = 101 then
24719: LD_VAR 0 1
24723: PUSH
24724: LD_INT 101
24726: EQUAL
24727: IFFALSE 24733
// MC_RepairBuildings ( ) ;
24729: CALL 29929 0 0
// if event = 102 then
24733: LD_VAR 0 1
24737: PUSH
24738: LD_INT 102
24740: EQUAL
24741: IFFALSE 24747
// MC_Heal ( ) ;
24743: CALL 30836 0 0
// if event = 103 then
24747: LD_VAR 0 1
24751: PUSH
24752: LD_INT 103
24754: EQUAL
24755: IFFALSE 24761
// MC_Build ( ) ;
24757: CALL 31258 0 0
// if event = 104 then
24761: LD_VAR 0 1
24765: PUSH
24766: LD_INT 104
24768: EQUAL
24769: IFFALSE 24775
// MC_TurretWeapon ( ) ;
24771: CALL 32899 0 0
// if event = 105 then
24775: LD_VAR 0 1
24779: PUSH
24780: LD_INT 105
24782: EQUAL
24783: IFFALSE 24789
// MC_BuildUpgrade ( ) ;
24785: CALL 32450 0 0
// if event = 106 then
24789: LD_VAR 0 1
24793: PUSH
24794: LD_INT 106
24796: EQUAL
24797: IFFALSE 24803
// MC_PlantMines ( ) ;
24799: CALL 33329 0 0
// if event = 107 then
24803: LD_VAR 0 1
24807: PUSH
24808: LD_INT 107
24810: EQUAL
24811: IFFALSE 24817
// MC_CollectCrates ( ) ;
24813: CALL 34120 0 0
// if event = 108 then
24817: LD_VAR 0 1
24821: PUSH
24822: LD_INT 108
24824: EQUAL
24825: IFFALSE 24831
// MC_LinkRemoteControl ( ) ;
24827: CALL 35970 0 0
// if event = 109 then
24831: LD_VAR 0 1
24835: PUSH
24836: LD_INT 109
24838: EQUAL
24839: IFFALSE 24845
// MC_ProduceVehicle ( ) ;
24841: CALL 36151 0 0
// if event = 110 then
24845: LD_VAR 0 1
24849: PUSH
24850: LD_INT 110
24852: EQUAL
24853: IFFALSE 24859
// MC_SendAttack ( ) ;
24855: CALL 36617 0 0
// if event = 111 then
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 111
24866: EQUAL
24867: IFFALSE 24873
// MC_Defend ( ) ;
24869: CALL 36725 0 0
// if event = 112 then
24873: LD_VAR 0 1
24877: PUSH
24878: LD_INT 112
24880: EQUAL
24881: IFFALSE 24887
// MC_Research ( ) ;
24883: CALL 37605 0 0
// if event = 113 then
24887: LD_VAR 0 1
24891: PUSH
24892: LD_INT 113
24894: EQUAL
24895: IFFALSE 24901
// MC_MinesTrigger ( ) ;
24897: CALL 38719 0 0
// if event = 120 then
24901: LD_VAR 0 1
24905: PUSH
24906: LD_INT 120
24908: EQUAL
24909: IFFALSE 24915
// MC_RepairVehicle ( ) ;
24911: CALL 38818 0 0
// if event = 121 then
24915: LD_VAR 0 1
24919: PUSH
24920: LD_INT 121
24922: EQUAL
24923: IFFALSE 24929
// MC_TameApe ( ) ;
24925: CALL 39559 0 0
// if event = 122 then
24929: LD_VAR 0 1
24933: PUSH
24934: LD_INT 122
24936: EQUAL
24937: IFFALSE 24943
// MC_ChangeApeClass ( ) ;
24939: CALL 40388 0 0
// if event = 123 then
24943: LD_VAR 0 1
24947: PUSH
24948: LD_INT 123
24950: EQUAL
24951: IFFALSE 24957
// MC_Bazooka ( ) ;
24953: CALL 41038 0 0
// if event = 124 then
24957: LD_VAR 0 1
24961: PUSH
24962: LD_INT 124
24964: EQUAL
24965: IFFALSE 24971
// MC_TeleportExit ( ) ;
24967: CALL 41236 0 0
// if event = 125 then
24971: LD_VAR 0 1
24975: PUSH
24976: LD_INT 125
24978: EQUAL
24979: IFFALSE 24985
// MC_Deposits ( ) ;
24981: CALL 41883 0 0
// if event = 126 then
24985: LD_VAR 0 1
24989: PUSH
24990: LD_INT 126
24992: EQUAL
24993: IFFALSE 24999
// MC_RemoteDriver ( ) ;
24995: CALL 42508 0 0
// if event = 200 then
24999: LD_VAR 0 1
25003: PUSH
25004: LD_INT 200
25006: EQUAL
25007: IFFALSE 25013
// MC_Idle ( ) ;
25009: CALL 44457 0 0
// end ;
25013: PPOPN 1
25015: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25016: LD_INT 0
25018: PPUSH
25019: PPUSH
// if not mc_bases [ base ] or not tag then
25020: LD_EXP 93
25024: PUSH
25025: LD_VAR 0 1
25029: ARRAY
25030: NOT
25031: PUSH
25032: LD_VAR 0 2
25036: NOT
25037: OR
25038: IFFALSE 25042
// exit ;
25040: GO 25106
// for i in mc_bases [ base ] union mc_ape [ base ] do
25042: LD_ADDR_VAR 0 4
25046: PUSH
25047: LD_EXP 93
25051: PUSH
25052: LD_VAR 0 1
25056: ARRAY
25057: PUSH
25058: LD_EXP 122
25062: PUSH
25063: LD_VAR 0 1
25067: ARRAY
25068: UNION
25069: PUSH
25070: FOR_IN
25071: IFFALSE 25104
// if GetTag ( i ) = tag then
25073: LD_VAR 0 4
25077: PPUSH
25078: CALL_OW 110
25082: PUSH
25083: LD_VAR 0 2
25087: EQUAL
25088: IFFALSE 25102
// SetTag ( i , 0 ) ;
25090: LD_VAR 0 4
25094: PPUSH
25095: LD_INT 0
25097: PPUSH
25098: CALL_OW 109
25102: GO 25070
25104: POP
25105: POP
// end ;
25106: LD_VAR 0 3
25110: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25111: LD_INT 0
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
// if not mc_bases then
25121: LD_EXP 93
25125: NOT
25126: IFFALSE 25130
// exit ;
25128: GO 25588
// for i = 1 to mc_bases do
25130: LD_ADDR_VAR 0 2
25134: PUSH
25135: DOUBLE
25136: LD_INT 1
25138: DEC
25139: ST_TO_ADDR
25140: LD_EXP 93
25144: PUSH
25145: FOR_TO
25146: IFFALSE 25586
// begin tmp := MC_ClassCheckReq ( i ) ;
25148: LD_ADDR_VAR 0 4
25152: PUSH
25153: LD_VAR 0 2
25157: PPUSH
25158: CALL 25593 0 1
25162: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25163: LD_ADDR_EXP 134
25167: PUSH
25168: LD_EXP 134
25172: PPUSH
25173: LD_VAR 0 2
25177: PPUSH
25178: LD_VAR 0 4
25182: PPUSH
25183: CALL_OW 1
25187: ST_TO_ADDR
// if not tmp then
25188: LD_VAR 0 4
25192: NOT
25193: IFFALSE 25197
// continue ;
25195: GO 25145
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25197: LD_ADDR_VAR 0 6
25201: PUSH
25202: LD_EXP 93
25206: PUSH
25207: LD_VAR 0 2
25211: ARRAY
25212: PPUSH
25213: LD_INT 2
25215: PUSH
25216: LD_INT 30
25218: PUSH
25219: LD_INT 4
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 30
25228: PUSH
25229: LD_INT 5
25231: PUSH
25232: EMPTY
25233: LIST
25234: LIST
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: LIST
25240: PPUSH
25241: CALL_OW 72
25245: PUSH
25246: LD_EXP 93
25250: PUSH
25251: LD_VAR 0 2
25255: ARRAY
25256: PPUSH
25257: LD_INT 2
25259: PUSH
25260: LD_INT 30
25262: PUSH
25263: LD_INT 0
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 1
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: LIST
25284: PPUSH
25285: CALL_OW 72
25289: PUSH
25290: LD_EXP 93
25294: PUSH
25295: LD_VAR 0 2
25299: ARRAY
25300: PPUSH
25301: LD_INT 30
25303: PUSH
25304: LD_INT 3
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PPUSH
25311: CALL_OW 72
25315: PUSH
25316: LD_EXP 93
25320: PUSH
25321: LD_VAR 0 2
25325: ARRAY
25326: PPUSH
25327: LD_INT 2
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 6
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 7
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 30
25352: PUSH
25353: LD_INT 8
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: LIST
25365: PPUSH
25366: CALL_OW 72
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: ST_TO_ADDR
// for j = 1 to 4 do
25377: LD_ADDR_VAR 0 3
25381: PUSH
25382: DOUBLE
25383: LD_INT 1
25385: DEC
25386: ST_TO_ADDR
25387: LD_INT 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25582
// begin if not tmp [ j ] then
25393: LD_VAR 0 4
25397: PUSH
25398: LD_VAR 0 3
25402: ARRAY
25403: NOT
25404: IFFALSE 25408
// continue ;
25406: GO 25390
// for p in tmp [ j ] do
25408: LD_ADDR_VAR 0 5
25412: PUSH
25413: LD_VAR 0 4
25417: PUSH
25418: LD_VAR 0 3
25422: ARRAY
25423: PUSH
25424: FOR_IN
25425: IFFALSE 25578
// begin if not b [ j ] then
25427: LD_VAR 0 6
25431: PUSH
25432: LD_VAR 0 3
25436: ARRAY
25437: NOT
25438: IFFALSE 25442
// break ;
25440: GO 25578
// e := 0 ;
25442: LD_ADDR_VAR 0 7
25446: PUSH
25447: LD_INT 0
25449: ST_TO_ADDR
// for k in b [ j ] do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 6
25459: PUSH
25460: LD_VAR 0 3
25464: ARRAY
25465: PUSH
25466: FOR_IN
25467: IFFALSE 25494
// if IsNotFull ( k ) then
25469: LD_VAR 0 8
25473: PPUSH
25474: CALL 53704 0 1
25478: IFFALSE 25492
// begin e := k ;
25480: LD_ADDR_VAR 0 7
25484: PUSH
25485: LD_VAR 0 8
25489: ST_TO_ADDR
// break ;
25490: GO 25494
// end ;
25492: GO 25466
25494: POP
25495: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25496: LD_VAR 0 7
25500: PUSH
25501: LD_VAR 0 5
25505: PPUSH
25506: LD_VAR 0 7
25510: PPUSH
25511: CALL 86868 0 2
25515: NOT
25516: AND
25517: IFFALSE 25576
// begin if IsInUnit ( p ) then
25519: LD_VAR 0 5
25523: PPUSH
25524: CALL_OW 310
25528: IFFALSE 25539
// ComExitBuilding ( p ) ;
25530: LD_VAR 0 5
25534: PPUSH
25535: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25539: LD_VAR 0 5
25543: PPUSH
25544: LD_VAR 0 7
25548: PPUSH
25549: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_VAR 0 3
25562: PPUSH
25563: CALL_OW 183
// AddComExitBuilding ( p ) ;
25567: LD_VAR 0 5
25571: PPUSH
25572: CALL_OW 182
// end ; end ;
25576: GO 25424
25578: POP
25579: POP
// end ;
25580: GO 25390
25582: POP
25583: POP
// end ;
25584: GO 25145
25586: POP
25587: POP
// end ;
25588: LD_VAR 0 1
25592: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25593: LD_INT 0
25595: PPUSH
25596: PPUSH
25597: PPUSH
25598: PPUSH
25599: PPUSH
25600: PPUSH
25601: PPUSH
25602: PPUSH
25603: PPUSH
25604: PPUSH
25605: PPUSH
25606: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25607: LD_VAR 0 1
25611: NOT
25612: PUSH
25613: LD_EXP 93
25617: PUSH
25618: LD_VAR 0 1
25622: ARRAY
25623: NOT
25624: OR
25625: PUSH
25626: LD_EXP 93
25630: PUSH
25631: LD_VAR 0 1
25635: ARRAY
25636: PPUSH
25637: LD_INT 2
25639: PUSH
25640: LD_INT 30
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 30
25652: PUSH
25653: LD_INT 1
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: LIST
25664: PPUSH
25665: CALL_OW 72
25669: NOT
25670: OR
25671: IFFALSE 25675
// exit ;
25673: GO 29178
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25675: LD_ADDR_VAR 0 4
25679: PUSH
25680: LD_EXP 93
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: LD_INT 2
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 25
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: PUSH
25714: LD_INT 25
25716: PUSH
25717: LD_INT 3
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 25
25726: PUSH
25727: LD_INT 4
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 25
25736: PUSH
25737: LD_INT 5
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 25
25746: PUSH
25747: LD_INT 8
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 25
25756: PUSH
25757: LD_INT 9
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: PPUSH
25774: CALL_OW 72
25778: ST_TO_ADDR
// if not tmp then
25779: LD_VAR 0 4
25783: NOT
25784: IFFALSE 25788
// exit ;
25786: GO 29178
// for i in tmp do
25788: LD_ADDR_VAR 0 3
25792: PUSH
25793: LD_VAR 0 4
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25830
// if GetTag ( i ) then
25801: LD_VAR 0 3
25805: PPUSH
25806: CALL_OW 110
25810: IFFALSE 25828
// tmp := tmp diff i ;
25812: LD_ADDR_VAR 0 4
25816: PUSH
25817: LD_VAR 0 4
25821: PUSH
25822: LD_VAR 0 3
25826: DIFF
25827: ST_TO_ADDR
25828: GO 25798
25830: POP
25831: POP
// if not tmp then
25832: LD_VAR 0 4
25836: NOT
25837: IFFALSE 25841
// exit ;
25839: GO 29178
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25841: LD_ADDR_VAR 0 5
25845: PUSH
25846: LD_EXP 93
25850: PUSH
25851: LD_VAR 0 1
25855: ARRAY
25856: PPUSH
25857: LD_INT 2
25859: PUSH
25860: LD_INT 25
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 25
25872: PUSH
25873: LD_INT 5
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 25
25882: PUSH
25883: LD_INT 8
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 25
25892: PUSH
25893: LD_INT 9
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: PPUSH
25907: CALL_OW 72
25911: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25912: LD_ADDR_VAR 0 6
25916: PUSH
25917: LD_EXP 93
25921: PUSH
25922: LD_VAR 0 1
25926: ARRAY
25927: PPUSH
25928: LD_INT 25
25930: PUSH
25931: LD_INT 2
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25943: LD_ADDR_VAR 0 7
25947: PUSH
25948: LD_EXP 93
25952: PUSH
25953: LD_VAR 0 1
25957: ARRAY
25958: PPUSH
25959: LD_INT 25
25961: PUSH
25962: LD_INT 3
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PPUSH
25969: CALL_OW 72
25973: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25974: LD_ADDR_VAR 0 8
25978: PUSH
25979: LD_EXP 93
25983: PUSH
25984: LD_VAR 0 1
25988: ARRAY
25989: PPUSH
25990: LD_INT 25
25992: PUSH
25993: LD_INT 4
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 24
26002: PUSH
26003: LD_INT 251
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PPUSH
26014: CALL_OW 72
26018: ST_TO_ADDR
// if mc_is_defending [ base ] then
26019: LD_EXP 136
26023: PUSH
26024: LD_VAR 0 1
26028: ARRAY
26029: IFFALSE 26490
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26031: LD_ADDR_EXP 135
26035: PUSH
26036: LD_EXP 135
26040: PPUSH
26041: LD_VAR 0 1
26045: PPUSH
26046: LD_INT 4
26048: PPUSH
26049: CALL_OW 1
26053: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26054: LD_ADDR_VAR 0 12
26058: PUSH
26059: LD_EXP 93
26063: PUSH
26064: LD_VAR 0 1
26068: ARRAY
26069: PPUSH
26070: LD_INT 2
26072: PUSH
26073: LD_INT 30
26075: PUSH
26076: LD_INT 4
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 30
26085: PUSH
26086: LD_INT 5
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: LIST
26097: PPUSH
26098: CALL_OW 72
26102: ST_TO_ADDR
// if not b then
26103: LD_VAR 0 12
26107: NOT
26108: IFFALSE 26112
// exit ;
26110: GO 29178
// p := [ ] ;
26112: LD_ADDR_VAR 0 11
26116: PUSH
26117: EMPTY
26118: ST_TO_ADDR
// if sci >= 2 then
26119: LD_VAR 0 8
26123: PUSH
26124: LD_INT 2
26126: GREATEREQUAL
26127: IFFALSE 26158
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26129: LD_ADDR_VAR 0 8
26133: PUSH
26134: LD_VAR 0 8
26138: PUSH
26139: LD_INT 1
26141: ARRAY
26142: PUSH
26143: LD_VAR 0 8
26147: PUSH
26148: LD_INT 2
26150: ARRAY
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: ST_TO_ADDR
26156: GO 26219
// if sci = 1 then
26158: LD_VAR 0 8
26162: PUSH
26163: LD_INT 1
26165: EQUAL
26166: IFFALSE 26187
// sci := [ sci [ 1 ] ] else
26168: LD_ADDR_VAR 0 8
26172: PUSH
26173: LD_VAR 0 8
26177: PUSH
26178: LD_INT 1
26180: ARRAY
26181: PUSH
26182: EMPTY
26183: LIST
26184: ST_TO_ADDR
26185: GO 26219
// if sci = 0 then
26187: LD_VAR 0 8
26191: PUSH
26192: LD_INT 0
26194: EQUAL
26195: IFFALSE 26219
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26197: LD_ADDR_VAR 0 11
26201: PUSH
26202: LD_VAR 0 4
26206: PPUSH
26207: LD_INT 4
26209: PPUSH
26210: CALL 86731 0 2
26214: PUSH
26215: LD_INT 1
26217: ARRAY
26218: ST_TO_ADDR
// if eng > 4 then
26219: LD_VAR 0 6
26223: PUSH
26224: LD_INT 4
26226: GREATER
26227: IFFALSE 26273
// for i = eng downto 4 do
26229: LD_ADDR_VAR 0 3
26233: PUSH
26234: DOUBLE
26235: LD_VAR 0 6
26239: INC
26240: ST_TO_ADDR
26241: LD_INT 4
26243: PUSH
26244: FOR_DOWNTO
26245: IFFALSE 26271
// eng := eng diff eng [ i ] ;
26247: LD_ADDR_VAR 0 6
26251: PUSH
26252: LD_VAR 0 6
26256: PUSH
26257: LD_VAR 0 6
26261: PUSH
26262: LD_VAR 0 3
26266: ARRAY
26267: DIFF
26268: ST_TO_ADDR
26269: GO 26244
26271: POP
26272: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26273: LD_ADDR_VAR 0 4
26277: PUSH
26278: LD_VAR 0 4
26282: PUSH
26283: LD_VAR 0 5
26287: PUSH
26288: LD_VAR 0 6
26292: UNION
26293: PUSH
26294: LD_VAR 0 7
26298: UNION
26299: PUSH
26300: LD_VAR 0 8
26304: UNION
26305: DIFF
26306: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26307: LD_ADDR_VAR 0 13
26311: PUSH
26312: LD_EXP 93
26316: PUSH
26317: LD_VAR 0 1
26321: ARRAY
26322: PPUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: LD_INT 32
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 30
26338: PUSH
26339: LD_INT 31
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: PUSH
26356: LD_EXP 93
26360: PUSH
26361: LD_VAR 0 1
26365: ARRAY
26366: PPUSH
26367: LD_INT 2
26369: PUSH
26370: LD_INT 30
26372: PUSH
26373: LD_INT 4
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 30
26382: PUSH
26383: LD_INT 5
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: LIST
26394: PPUSH
26395: CALL_OW 72
26399: PUSH
26400: LD_INT 6
26402: MUL
26403: PLUS
26404: ST_TO_ADDR
// if bcount < tmp then
26405: LD_VAR 0 13
26409: PUSH
26410: LD_VAR 0 4
26414: LESS
26415: IFFALSE 26461
// for i = tmp downto bcount do
26417: LD_ADDR_VAR 0 3
26421: PUSH
26422: DOUBLE
26423: LD_VAR 0 4
26427: INC
26428: ST_TO_ADDR
26429: LD_VAR 0 13
26433: PUSH
26434: FOR_DOWNTO
26435: IFFALSE 26459
// tmp := Delete ( tmp , tmp ) ;
26437: LD_ADDR_VAR 0 4
26441: PUSH
26442: LD_VAR 0 4
26446: PPUSH
26447: LD_VAR 0 4
26451: PPUSH
26452: CALL_OW 3
26456: ST_TO_ADDR
26457: GO 26434
26459: POP
26460: POP
// result := [ tmp , 0 , 0 , p ] ;
26461: LD_ADDR_VAR 0 2
26465: PUSH
26466: LD_VAR 0 4
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: LD_VAR 0 11
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: ST_TO_ADDR
// exit ;
26488: GO 29178
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26490: LD_EXP 93
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: PPUSH
26501: LD_INT 2
26503: PUSH
26504: LD_INT 30
26506: PUSH
26507: LD_INT 6
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 7
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 30
26526: PUSH
26527: LD_INT 8
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: PPUSH
26540: CALL_OW 72
26544: NOT
26545: PUSH
26546: LD_EXP 93
26550: PUSH
26551: LD_VAR 0 1
26555: ARRAY
26556: PPUSH
26557: LD_INT 30
26559: PUSH
26560: LD_INT 3
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PPUSH
26567: CALL_OW 72
26571: NOT
26572: AND
26573: IFFALSE 26645
// begin if eng = tmp then
26575: LD_VAR 0 6
26579: PUSH
26580: LD_VAR 0 4
26584: EQUAL
26585: IFFALSE 26589
// exit ;
26587: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26589: LD_ADDR_EXP 135
26593: PUSH
26594: LD_EXP 135
26598: PPUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: LD_INT 1
26606: PPUSH
26607: CALL_OW 1
26611: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26612: LD_ADDR_VAR 0 2
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: LD_VAR 0 4
26624: PUSH
26625: LD_VAR 0 6
26629: DIFF
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: LD_INT 0
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: ST_TO_ADDR
// exit ;
26643: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26645: LD_EXP 120
26649: PUSH
26650: LD_EXP 119
26654: PUSH
26655: LD_VAR 0 1
26659: ARRAY
26660: ARRAY
26661: PUSH
26662: LD_EXP 93
26666: PUSH
26667: LD_VAR 0 1
26671: ARRAY
26672: PPUSH
26673: LD_INT 2
26675: PUSH
26676: LD_INT 30
26678: PUSH
26679: LD_INT 6
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 30
26688: PUSH
26689: LD_INT 7
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 30
26698: PUSH
26699: LD_INT 8
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: PPUSH
26712: CALL_OW 72
26716: AND
26717: PUSH
26718: LD_EXP 93
26722: PUSH
26723: LD_VAR 0 1
26727: ARRAY
26728: PPUSH
26729: LD_INT 30
26731: PUSH
26732: LD_INT 3
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL_OW 72
26743: NOT
26744: AND
26745: IFFALSE 26959
// begin if sci >= 6 then
26747: LD_VAR 0 8
26751: PUSH
26752: LD_INT 6
26754: GREATEREQUAL
26755: IFFALSE 26759
// exit ;
26757: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26759: LD_ADDR_EXP 135
26763: PUSH
26764: LD_EXP 135
26768: PPUSH
26769: LD_VAR 0 1
26773: PPUSH
26774: LD_INT 2
26776: PPUSH
26777: CALL_OW 1
26781: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26782: LD_ADDR_VAR 0 9
26786: PUSH
26787: LD_VAR 0 4
26791: PUSH
26792: LD_VAR 0 8
26796: DIFF
26797: PPUSH
26798: LD_INT 4
26800: PPUSH
26801: CALL 86731 0 2
26805: ST_TO_ADDR
// p := [ ] ;
26806: LD_ADDR_VAR 0 11
26810: PUSH
26811: EMPTY
26812: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26813: LD_VAR 0 8
26817: PUSH
26818: LD_INT 6
26820: LESS
26821: PUSH
26822: LD_VAR 0 9
26826: PUSH
26827: LD_INT 6
26829: GREATER
26830: AND
26831: IFFALSE 26912
// begin for i = 1 to 6 - sci do
26833: LD_ADDR_VAR 0 3
26837: PUSH
26838: DOUBLE
26839: LD_INT 1
26841: DEC
26842: ST_TO_ADDR
26843: LD_INT 6
26845: PUSH
26846: LD_VAR 0 8
26850: MINUS
26851: PUSH
26852: FOR_TO
26853: IFFALSE 26908
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26855: LD_ADDR_VAR 0 11
26859: PUSH
26860: LD_VAR 0 11
26864: PPUSH
26865: LD_VAR 0 11
26869: PUSH
26870: LD_INT 1
26872: PLUS
26873: PPUSH
26874: LD_VAR 0 9
26878: PUSH
26879: LD_INT 1
26881: ARRAY
26882: PPUSH
26883: CALL_OW 2
26887: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26888: LD_ADDR_VAR 0 9
26892: PUSH
26893: LD_VAR 0 9
26897: PPUSH
26898: LD_INT 1
26900: PPUSH
26901: CALL_OW 3
26905: ST_TO_ADDR
// end ;
26906: GO 26852
26908: POP
26909: POP
// end else
26910: GO 26932
// if sort then
26912: LD_VAR 0 9
26916: IFFALSE 26932
// p := sort [ 1 ] ;
26918: LD_ADDR_VAR 0 11
26922: PUSH
26923: LD_VAR 0 9
26927: PUSH
26928: LD_INT 1
26930: ARRAY
26931: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26932: LD_ADDR_VAR 0 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: LD_INT 0
26945: PUSH
26946: LD_VAR 0 11
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: ST_TO_ADDR
// exit ;
26957: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26959: LD_EXP 120
26963: PUSH
26964: LD_EXP 119
26968: PUSH
26969: LD_VAR 0 1
26973: ARRAY
26974: ARRAY
26975: PUSH
26976: LD_EXP 93
26980: PUSH
26981: LD_VAR 0 1
26985: ARRAY
26986: PPUSH
26987: LD_INT 2
26989: PUSH
26990: LD_INT 30
26992: PUSH
26993: LD_INT 6
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 30
27002: PUSH
27003: LD_INT 7
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 30
27012: PUSH
27013: LD_INT 8
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: PPUSH
27026: CALL_OW 72
27030: AND
27031: PUSH
27032: LD_EXP 93
27036: PUSH
27037: LD_VAR 0 1
27041: ARRAY
27042: PPUSH
27043: LD_INT 30
27045: PUSH
27046: LD_INT 3
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PPUSH
27053: CALL_OW 72
27057: AND
27058: IFFALSE 27792
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27060: LD_ADDR_EXP 135
27064: PUSH
27065: LD_EXP 135
27069: PPUSH
27070: LD_VAR 0 1
27074: PPUSH
27075: LD_INT 3
27077: PPUSH
27078: CALL_OW 1
27082: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27083: LD_ADDR_VAR 0 2
27087: PUSH
27088: LD_INT 0
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 0
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: ST_TO_ADDR
// if not eng then
27106: LD_VAR 0 6
27110: NOT
27111: IFFALSE 27174
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27113: LD_ADDR_VAR 0 11
27117: PUSH
27118: LD_VAR 0 4
27122: PPUSH
27123: LD_INT 2
27125: PPUSH
27126: CALL 86731 0 2
27130: PUSH
27131: LD_INT 1
27133: ARRAY
27134: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27135: LD_ADDR_VAR 0 2
27139: PUSH
27140: LD_VAR 0 2
27144: PPUSH
27145: LD_INT 2
27147: PPUSH
27148: LD_VAR 0 11
27152: PPUSH
27153: CALL_OW 1
27157: ST_TO_ADDR
// tmp := tmp diff p ;
27158: LD_ADDR_VAR 0 4
27162: PUSH
27163: LD_VAR 0 4
27167: PUSH
27168: LD_VAR 0 11
27172: DIFF
27173: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27174: LD_VAR 0 4
27178: PUSH
27179: LD_VAR 0 8
27183: PUSH
27184: LD_INT 6
27186: LESS
27187: AND
27188: IFFALSE 27376
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27190: LD_ADDR_VAR 0 9
27194: PUSH
27195: LD_VAR 0 4
27199: PUSH
27200: LD_VAR 0 8
27204: PUSH
27205: LD_VAR 0 7
27209: UNION
27210: DIFF
27211: PPUSH
27212: LD_INT 4
27214: PPUSH
27215: CALL 86731 0 2
27219: ST_TO_ADDR
// p := [ ] ;
27220: LD_ADDR_VAR 0 11
27224: PUSH
27225: EMPTY
27226: ST_TO_ADDR
// if sort then
27227: LD_VAR 0 9
27231: IFFALSE 27347
// for i = 1 to 6 - sci do
27233: LD_ADDR_VAR 0 3
27237: PUSH
27238: DOUBLE
27239: LD_INT 1
27241: DEC
27242: ST_TO_ADDR
27243: LD_INT 6
27245: PUSH
27246: LD_VAR 0 8
27250: MINUS
27251: PUSH
27252: FOR_TO
27253: IFFALSE 27345
// begin if i = sort then
27255: LD_VAR 0 3
27259: PUSH
27260: LD_VAR 0 9
27264: EQUAL
27265: IFFALSE 27269
// break ;
27267: GO 27345
// if GetClass ( i ) = 4 then
27269: LD_VAR 0 3
27273: PPUSH
27274: CALL_OW 257
27278: PUSH
27279: LD_INT 4
27281: EQUAL
27282: IFFALSE 27286
// continue ;
27284: GO 27252
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27286: LD_ADDR_VAR 0 11
27290: PUSH
27291: LD_VAR 0 11
27295: PPUSH
27296: LD_VAR 0 11
27300: PUSH
27301: LD_INT 1
27303: PLUS
27304: PPUSH
27305: LD_VAR 0 9
27309: PUSH
27310: LD_VAR 0 3
27314: ARRAY
27315: PPUSH
27316: CALL_OW 2
27320: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27321: LD_ADDR_VAR 0 4
27325: PUSH
27326: LD_VAR 0 4
27330: PUSH
27331: LD_VAR 0 9
27335: PUSH
27336: LD_VAR 0 3
27340: ARRAY
27341: DIFF
27342: ST_TO_ADDR
// end ;
27343: GO 27252
27345: POP
27346: POP
// if p then
27347: LD_VAR 0 11
27351: IFFALSE 27376
// result := Replace ( result , 4 , p ) ;
27353: LD_ADDR_VAR 0 2
27357: PUSH
27358: LD_VAR 0 2
27362: PPUSH
27363: LD_INT 4
27365: PPUSH
27366: LD_VAR 0 11
27370: PPUSH
27371: CALL_OW 1
27375: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27376: LD_VAR 0 4
27380: PUSH
27381: LD_VAR 0 7
27385: PUSH
27386: LD_INT 6
27388: LESS
27389: AND
27390: IFFALSE 27578
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27392: LD_ADDR_VAR 0 9
27396: PUSH
27397: LD_VAR 0 4
27401: PUSH
27402: LD_VAR 0 8
27406: PUSH
27407: LD_VAR 0 7
27411: UNION
27412: DIFF
27413: PPUSH
27414: LD_INT 3
27416: PPUSH
27417: CALL 86731 0 2
27421: ST_TO_ADDR
// p := [ ] ;
27422: LD_ADDR_VAR 0 11
27426: PUSH
27427: EMPTY
27428: ST_TO_ADDR
// if sort then
27429: LD_VAR 0 9
27433: IFFALSE 27549
// for i = 1 to 6 - mech do
27435: LD_ADDR_VAR 0 3
27439: PUSH
27440: DOUBLE
27441: LD_INT 1
27443: DEC
27444: ST_TO_ADDR
27445: LD_INT 6
27447: PUSH
27448: LD_VAR 0 7
27452: MINUS
27453: PUSH
27454: FOR_TO
27455: IFFALSE 27547
// begin if i = sort then
27457: LD_VAR 0 3
27461: PUSH
27462: LD_VAR 0 9
27466: EQUAL
27467: IFFALSE 27471
// break ;
27469: GO 27547
// if GetClass ( i ) = 3 then
27471: LD_VAR 0 3
27475: PPUSH
27476: CALL_OW 257
27480: PUSH
27481: LD_INT 3
27483: EQUAL
27484: IFFALSE 27488
// continue ;
27486: GO 27454
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27488: LD_ADDR_VAR 0 11
27492: PUSH
27493: LD_VAR 0 11
27497: PPUSH
27498: LD_VAR 0 11
27502: PUSH
27503: LD_INT 1
27505: PLUS
27506: PPUSH
27507: LD_VAR 0 9
27511: PUSH
27512: LD_VAR 0 3
27516: ARRAY
27517: PPUSH
27518: CALL_OW 2
27522: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27523: LD_ADDR_VAR 0 4
27527: PUSH
27528: LD_VAR 0 4
27532: PUSH
27533: LD_VAR 0 9
27537: PUSH
27538: LD_VAR 0 3
27542: ARRAY
27543: DIFF
27544: ST_TO_ADDR
// end ;
27545: GO 27454
27547: POP
27548: POP
// if p then
27549: LD_VAR 0 11
27553: IFFALSE 27578
// result := Replace ( result , 3 , p ) ;
27555: LD_ADDR_VAR 0 2
27559: PUSH
27560: LD_VAR 0 2
27564: PPUSH
27565: LD_INT 3
27567: PPUSH
27568: LD_VAR 0 11
27572: PPUSH
27573: CALL_OW 1
27577: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27578: LD_VAR 0 4
27582: PUSH
27583: LD_INT 6
27585: GREATER
27586: PUSH
27587: LD_VAR 0 6
27591: PUSH
27592: LD_INT 6
27594: LESS
27595: AND
27596: IFFALSE 27790
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27598: LD_ADDR_VAR 0 9
27602: PUSH
27603: LD_VAR 0 4
27607: PUSH
27608: LD_VAR 0 8
27612: PUSH
27613: LD_VAR 0 7
27617: UNION
27618: PUSH
27619: LD_VAR 0 6
27623: UNION
27624: DIFF
27625: PPUSH
27626: LD_INT 2
27628: PPUSH
27629: CALL 86731 0 2
27633: ST_TO_ADDR
// p := [ ] ;
27634: LD_ADDR_VAR 0 11
27638: PUSH
27639: EMPTY
27640: ST_TO_ADDR
// if sort then
27641: LD_VAR 0 9
27645: IFFALSE 27761
// for i = 1 to 6 - eng do
27647: LD_ADDR_VAR 0 3
27651: PUSH
27652: DOUBLE
27653: LD_INT 1
27655: DEC
27656: ST_TO_ADDR
27657: LD_INT 6
27659: PUSH
27660: LD_VAR 0 6
27664: MINUS
27665: PUSH
27666: FOR_TO
27667: IFFALSE 27759
// begin if i = sort then
27669: LD_VAR 0 3
27673: PUSH
27674: LD_VAR 0 9
27678: EQUAL
27679: IFFALSE 27683
// break ;
27681: GO 27759
// if GetClass ( i ) = 2 then
27683: LD_VAR 0 3
27687: PPUSH
27688: CALL_OW 257
27692: PUSH
27693: LD_INT 2
27695: EQUAL
27696: IFFALSE 27700
// continue ;
27698: GO 27666
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27700: LD_ADDR_VAR 0 11
27704: PUSH
27705: LD_VAR 0 11
27709: PPUSH
27710: LD_VAR 0 11
27714: PUSH
27715: LD_INT 1
27717: PLUS
27718: PPUSH
27719: LD_VAR 0 9
27723: PUSH
27724: LD_VAR 0 3
27728: ARRAY
27729: PPUSH
27730: CALL_OW 2
27734: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27735: LD_ADDR_VAR 0 4
27739: PUSH
27740: LD_VAR 0 4
27744: PUSH
27745: LD_VAR 0 9
27749: PUSH
27750: LD_VAR 0 3
27754: ARRAY
27755: DIFF
27756: ST_TO_ADDR
// end ;
27757: GO 27666
27759: POP
27760: POP
// if p then
27761: LD_VAR 0 11
27765: IFFALSE 27790
// result := Replace ( result , 2 , p ) ;
27767: LD_ADDR_VAR 0 2
27771: PUSH
27772: LD_VAR 0 2
27776: PPUSH
27777: LD_INT 2
27779: PPUSH
27780: LD_VAR 0 11
27784: PPUSH
27785: CALL_OW 1
27789: ST_TO_ADDR
// end ; exit ;
27790: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27792: LD_EXP 120
27796: PUSH
27797: LD_EXP 119
27801: PUSH
27802: LD_VAR 0 1
27806: ARRAY
27807: ARRAY
27808: NOT
27809: PUSH
27810: LD_EXP 93
27814: PUSH
27815: LD_VAR 0 1
27819: ARRAY
27820: PPUSH
27821: LD_INT 30
27823: PUSH
27824: LD_INT 3
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 72
27835: AND
27836: PUSH
27837: LD_EXP 98
27841: PUSH
27842: LD_VAR 0 1
27846: ARRAY
27847: AND
27848: IFFALSE 28456
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27850: LD_ADDR_EXP 135
27854: PUSH
27855: LD_EXP 135
27859: PPUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: LD_INT 5
27867: PPUSH
27868: CALL_OW 1
27872: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27873: LD_ADDR_VAR 0 2
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 0
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: ST_TO_ADDR
// if sci > 1 then
27896: LD_VAR 0 8
27900: PUSH
27901: LD_INT 1
27903: GREATER
27904: IFFALSE 27932
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27906: LD_ADDR_VAR 0 4
27910: PUSH
27911: LD_VAR 0 4
27915: PUSH
27916: LD_VAR 0 8
27920: PUSH
27921: LD_VAR 0 8
27925: PUSH
27926: LD_INT 1
27928: ARRAY
27929: DIFF
27930: DIFF
27931: ST_TO_ADDR
// if tmp and not sci then
27932: LD_VAR 0 4
27936: PUSH
27937: LD_VAR 0 8
27941: NOT
27942: AND
27943: IFFALSE 28012
// begin sort := SortBySkill ( tmp , 4 ) ;
27945: LD_ADDR_VAR 0 9
27949: PUSH
27950: LD_VAR 0 4
27954: PPUSH
27955: LD_INT 4
27957: PPUSH
27958: CALL 86731 0 2
27962: ST_TO_ADDR
// if sort then
27963: LD_VAR 0 9
27967: IFFALSE 27983
// p := sort [ 1 ] ;
27969: LD_ADDR_VAR 0 11
27973: PUSH
27974: LD_VAR 0 9
27978: PUSH
27979: LD_INT 1
27981: ARRAY
27982: ST_TO_ADDR
// if p then
27983: LD_VAR 0 11
27987: IFFALSE 28012
// result := Replace ( result , 4 , p ) ;
27989: LD_ADDR_VAR 0 2
27993: PUSH
27994: LD_VAR 0 2
27998: PPUSH
27999: LD_INT 4
28001: PPUSH
28002: LD_VAR 0 11
28006: PPUSH
28007: CALL_OW 1
28011: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28012: LD_ADDR_VAR 0 4
28016: PUSH
28017: LD_VAR 0 4
28021: PUSH
28022: LD_VAR 0 7
28026: DIFF
28027: ST_TO_ADDR
// if tmp and mech < 6 then
28028: LD_VAR 0 4
28032: PUSH
28033: LD_VAR 0 7
28037: PUSH
28038: LD_INT 6
28040: LESS
28041: AND
28042: IFFALSE 28230
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28044: LD_ADDR_VAR 0 9
28048: PUSH
28049: LD_VAR 0 4
28053: PUSH
28054: LD_VAR 0 8
28058: PUSH
28059: LD_VAR 0 7
28063: UNION
28064: DIFF
28065: PPUSH
28066: LD_INT 3
28068: PPUSH
28069: CALL 86731 0 2
28073: ST_TO_ADDR
// p := [ ] ;
28074: LD_ADDR_VAR 0 11
28078: PUSH
28079: EMPTY
28080: ST_TO_ADDR
// if sort then
28081: LD_VAR 0 9
28085: IFFALSE 28201
// for i = 1 to 6 - mech do
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: DOUBLE
28093: LD_INT 1
28095: DEC
28096: ST_TO_ADDR
28097: LD_INT 6
28099: PUSH
28100: LD_VAR 0 7
28104: MINUS
28105: PUSH
28106: FOR_TO
28107: IFFALSE 28199
// begin if i = sort then
28109: LD_VAR 0 3
28113: PUSH
28114: LD_VAR 0 9
28118: EQUAL
28119: IFFALSE 28123
// break ;
28121: GO 28199
// if GetClass ( i ) = 3 then
28123: LD_VAR 0 3
28127: PPUSH
28128: CALL_OW 257
28132: PUSH
28133: LD_INT 3
28135: EQUAL
28136: IFFALSE 28140
// continue ;
28138: GO 28106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28140: LD_ADDR_VAR 0 11
28144: PUSH
28145: LD_VAR 0 11
28149: PPUSH
28150: LD_VAR 0 11
28154: PUSH
28155: LD_INT 1
28157: PLUS
28158: PPUSH
28159: LD_VAR 0 9
28163: PUSH
28164: LD_VAR 0 3
28168: ARRAY
28169: PPUSH
28170: CALL_OW 2
28174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28175: LD_ADDR_VAR 0 4
28179: PUSH
28180: LD_VAR 0 4
28184: PUSH
28185: LD_VAR 0 9
28189: PUSH
28190: LD_VAR 0 3
28194: ARRAY
28195: DIFF
28196: ST_TO_ADDR
// end ;
28197: GO 28106
28199: POP
28200: POP
// if p then
28201: LD_VAR 0 11
28205: IFFALSE 28230
// result := Replace ( result , 3 , p ) ;
28207: LD_ADDR_VAR 0 2
28211: PUSH
28212: LD_VAR 0 2
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_VAR 0 11
28224: PPUSH
28225: CALL_OW 1
28229: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28230: LD_ADDR_VAR 0 4
28234: PUSH
28235: LD_VAR 0 4
28239: PUSH
28240: LD_VAR 0 6
28244: DIFF
28245: ST_TO_ADDR
// if tmp and eng < 6 then
28246: LD_VAR 0 4
28250: PUSH
28251: LD_VAR 0 6
28255: PUSH
28256: LD_INT 6
28258: LESS
28259: AND
28260: IFFALSE 28454
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28262: LD_ADDR_VAR 0 9
28266: PUSH
28267: LD_VAR 0 4
28271: PUSH
28272: LD_VAR 0 8
28276: PUSH
28277: LD_VAR 0 7
28281: UNION
28282: PUSH
28283: LD_VAR 0 6
28287: UNION
28288: DIFF
28289: PPUSH
28290: LD_INT 2
28292: PPUSH
28293: CALL 86731 0 2
28297: ST_TO_ADDR
// p := [ ] ;
28298: LD_ADDR_VAR 0 11
28302: PUSH
28303: EMPTY
28304: ST_TO_ADDR
// if sort then
28305: LD_VAR 0 9
28309: IFFALSE 28425
// for i = 1 to 6 - eng do
28311: LD_ADDR_VAR 0 3
28315: PUSH
28316: DOUBLE
28317: LD_INT 1
28319: DEC
28320: ST_TO_ADDR
28321: LD_INT 6
28323: PUSH
28324: LD_VAR 0 6
28328: MINUS
28329: PUSH
28330: FOR_TO
28331: IFFALSE 28423
// begin if i = sort then
28333: LD_VAR 0 3
28337: PUSH
28338: LD_VAR 0 9
28342: EQUAL
28343: IFFALSE 28347
// break ;
28345: GO 28423
// if GetClass ( i ) = 2 then
28347: LD_VAR 0 3
28351: PPUSH
28352: CALL_OW 257
28356: PUSH
28357: LD_INT 2
28359: EQUAL
28360: IFFALSE 28364
// continue ;
28362: GO 28330
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28364: LD_ADDR_VAR 0 11
28368: PUSH
28369: LD_VAR 0 11
28373: PPUSH
28374: LD_VAR 0 11
28378: PUSH
28379: LD_INT 1
28381: PLUS
28382: PPUSH
28383: LD_VAR 0 9
28387: PUSH
28388: LD_VAR 0 3
28392: ARRAY
28393: PPUSH
28394: CALL_OW 2
28398: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28399: LD_ADDR_VAR 0 4
28403: PUSH
28404: LD_VAR 0 4
28408: PUSH
28409: LD_VAR 0 9
28413: PUSH
28414: LD_VAR 0 3
28418: ARRAY
28419: DIFF
28420: ST_TO_ADDR
// end ;
28421: GO 28330
28423: POP
28424: POP
// if p then
28425: LD_VAR 0 11
28429: IFFALSE 28454
// result := Replace ( result , 2 , p ) ;
28431: LD_ADDR_VAR 0 2
28435: PUSH
28436: LD_VAR 0 2
28440: PPUSH
28441: LD_INT 2
28443: PPUSH
28444: LD_VAR 0 11
28448: PPUSH
28449: CALL_OW 1
28453: ST_TO_ADDR
// end ; exit ;
28454: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28456: LD_EXP 120
28460: PUSH
28461: LD_EXP 119
28465: PUSH
28466: LD_VAR 0 1
28470: ARRAY
28471: ARRAY
28472: NOT
28473: PUSH
28474: LD_EXP 93
28478: PUSH
28479: LD_VAR 0 1
28483: ARRAY
28484: PPUSH
28485: LD_INT 30
28487: PUSH
28488: LD_INT 3
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PPUSH
28495: CALL_OW 72
28499: AND
28500: PUSH
28501: LD_EXP 98
28505: PUSH
28506: LD_VAR 0 1
28510: ARRAY
28511: NOT
28512: AND
28513: IFFALSE 29178
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28515: LD_ADDR_EXP 135
28519: PUSH
28520: LD_EXP 135
28524: PPUSH
28525: LD_VAR 0 1
28529: PPUSH
28530: LD_INT 6
28532: PPUSH
28533: CALL_OW 1
28537: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28538: LD_ADDR_VAR 0 2
28542: PUSH
28543: LD_INT 0
28545: PUSH
28546: LD_INT 0
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: ST_TO_ADDR
// if sci >= 1 then
28561: LD_VAR 0 8
28565: PUSH
28566: LD_INT 1
28568: GREATEREQUAL
28569: IFFALSE 28591
// tmp := tmp diff sci [ 1 ] ;
28571: LD_ADDR_VAR 0 4
28575: PUSH
28576: LD_VAR 0 4
28580: PUSH
28581: LD_VAR 0 8
28585: PUSH
28586: LD_INT 1
28588: ARRAY
28589: DIFF
28590: ST_TO_ADDR
// if tmp and not sci then
28591: LD_VAR 0 4
28595: PUSH
28596: LD_VAR 0 8
28600: NOT
28601: AND
28602: IFFALSE 28671
// begin sort := SortBySkill ( tmp , 4 ) ;
28604: LD_ADDR_VAR 0 9
28608: PUSH
28609: LD_VAR 0 4
28613: PPUSH
28614: LD_INT 4
28616: PPUSH
28617: CALL 86731 0 2
28621: ST_TO_ADDR
// if sort then
28622: LD_VAR 0 9
28626: IFFALSE 28642
// p := sort [ 1 ] ;
28628: LD_ADDR_VAR 0 11
28632: PUSH
28633: LD_VAR 0 9
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: ST_TO_ADDR
// if p then
28642: LD_VAR 0 11
28646: IFFALSE 28671
// result := Replace ( result , 4 , p ) ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_VAR 0 2
28657: PPUSH
28658: LD_INT 4
28660: PPUSH
28661: LD_VAR 0 11
28665: PPUSH
28666: CALL_OW 1
28670: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 4
28680: PUSH
28681: LD_VAR 0 7
28685: DIFF
28686: ST_TO_ADDR
// if tmp and mech < 6 then
28687: LD_VAR 0 4
28691: PUSH
28692: LD_VAR 0 7
28696: PUSH
28697: LD_INT 6
28699: LESS
28700: AND
28701: IFFALSE 28883
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28703: LD_ADDR_VAR 0 9
28707: PUSH
28708: LD_VAR 0 4
28712: PUSH
28713: LD_VAR 0 7
28717: DIFF
28718: PPUSH
28719: LD_INT 3
28721: PPUSH
28722: CALL 86731 0 2
28726: ST_TO_ADDR
// p := [ ] ;
28727: LD_ADDR_VAR 0 11
28731: PUSH
28732: EMPTY
28733: ST_TO_ADDR
// if sort then
28734: LD_VAR 0 9
28738: IFFALSE 28854
// for i = 1 to 6 - mech do
28740: LD_ADDR_VAR 0 3
28744: PUSH
28745: DOUBLE
28746: LD_INT 1
28748: DEC
28749: ST_TO_ADDR
28750: LD_INT 6
28752: PUSH
28753: LD_VAR 0 7
28757: MINUS
28758: PUSH
28759: FOR_TO
28760: IFFALSE 28852
// begin if i = sort then
28762: LD_VAR 0 3
28766: PUSH
28767: LD_VAR 0 9
28771: EQUAL
28772: IFFALSE 28776
// break ;
28774: GO 28852
// if GetClass ( i ) = 3 then
28776: LD_VAR 0 3
28780: PPUSH
28781: CALL_OW 257
28785: PUSH
28786: LD_INT 3
28788: EQUAL
28789: IFFALSE 28793
// continue ;
28791: GO 28759
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28793: LD_ADDR_VAR 0 11
28797: PUSH
28798: LD_VAR 0 11
28802: PPUSH
28803: LD_VAR 0 11
28807: PUSH
28808: LD_INT 1
28810: PLUS
28811: PPUSH
28812: LD_VAR 0 9
28816: PUSH
28817: LD_VAR 0 3
28821: ARRAY
28822: PPUSH
28823: CALL_OW 2
28827: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28828: LD_ADDR_VAR 0 4
28832: PUSH
28833: LD_VAR 0 4
28837: PUSH
28838: LD_VAR 0 9
28842: PUSH
28843: LD_VAR 0 3
28847: ARRAY
28848: DIFF
28849: ST_TO_ADDR
// end ;
28850: GO 28759
28852: POP
28853: POP
// if p then
28854: LD_VAR 0 11
28858: IFFALSE 28883
// result := Replace ( result , 3 , p ) ;
28860: LD_ADDR_VAR 0 2
28864: PUSH
28865: LD_VAR 0 2
28869: PPUSH
28870: LD_INT 3
28872: PPUSH
28873: LD_VAR 0 11
28877: PPUSH
28878: CALL_OW 1
28882: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28883: LD_ADDR_VAR 0 4
28887: PUSH
28888: LD_VAR 0 4
28892: PUSH
28893: LD_VAR 0 6
28897: DIFF
28898: ST_TO_ADDR
// if tmp and eng < 4 then
28899: LD_VAR 0 4
28903: PUSH
28904: LD_VAR 0 6
28908: PUSH
28909: LD_INT 4
28911: LESS
28912: AND
28913: IFFALSE 29103
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28915: LD_ADDR_VAR 0 9
28919: PUSH
28920: LD_VAR 0 4
28924: PUSH
28925: LD_VAR 0 7
28929: PUSH
28930: LD_VAR 0 6
28934: UNION
28935: DIFF
28936: PPUSH
28937: LD_INT 2
28939: PPUSH
28940: CALL 86731 0 2
28944: ST_TO_ADDR
// p := [ ] ;
28945: LD_ADDR_VAR 0 11
28949: PUSH
28950: EMPTY
28951: ST_TO_ADDR
// if sort then
28952: LD_VAR 0 9
28956: IFFALSE 29072
// for i = 1 to 4 - eng do
28958: LD_ADDR_VAR 0 3
28962: PUSH
28963: DOUBLE
28964: LD_INT 1
28966: DEC
28967: ST_TO_ADDR
28968: LD_INT 4
28970: PUSH
28971: LD_VAR 0 6
28975: MINUS
28976: PUSH
28977: FOR_TO
28978: IFFALSE 29070
// begin if i = sort then
28980: LD_VAR 0 3
28984: PUSH
28985: LD_VAR 0 9
28989: EQUAL
28990: IFFALSE 28994
// break ;
28992: GO 29070
// if GetClass ( i ) = 2 then
28994: LD_VAR 0 3
28998: PPUSH
28999: CALL_OW 257
29003: PUSH
29004: LD_INT 2
29006: EQUAL
29007: IFFALSE 29011
// continue ;
29009: GO 28977
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29011: LD_ADDR_VAR 0 11
29015: PUSH
29016: LD_VAR 0 11
29020: PPUSH
29021: LD_VAR 0 11
29025: PUSH
29026: LD_INT 1
29028: PLUS
29029: PPUSH
29030: LD_VAR 0 9
29034: PUSH
29035: LD_VAR 0 3
29039: ARRAY
29040: PPUSH
29041: CALL_OW 2
29045: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29046: LD_ADDR_VAR 0 4
29050: PUSH
29051: LD_VAR 0 4
29055: PUSH
29056: LD_VAR 0 9
29060: PUSH
29061: LD_VAR 0 3
29065: ARRAY
29066: DIFF
29067: ST_TO_ADDR
// end ;
29068: GO 28977
29070: POP
29071: POP
// if p then
29072: LD_VAR 0 11
29076: IFFALSE 29101
// result := Replace ( result , 2 , p ) ;
29078: LD_ADDR_VAR 0 2
29082: PUSH
29083: LD_VAR 0 2
29087: PPUSH
29088: LD_INT 2
29090: PPUSH
29091: LD_VAR 0 11
29095: PPUSH
29096: CALL_OW 1
29100: ST_TO_ADDR
// end else
29101: GO 29147
// for i = eng downto 5 do
29103: LD_ADDR_VAR 0 3
29107: PUSH
29108: DOUBLE
29109: LD_VAR 0 6
29113: INC
29114: ST_TO_ADDR
29115: LD_INT 5
29117: PUSH
29118: FOR_DOWNTO
29119: IFFALSE 29145
// tmp := tmp union eng [ i ] ;
29121: LD_ADDR_VAR 0 4
29125: PUSH
29126: LD_VAR 0 4
29130: PUSH
29131: LD_VAR 0 6
29135: PUSH
29136: LD_VAR 0 3
29140: ARRAY
29141: UNION
29142: ST_TO_ADDR
29143: GO 29118
29145: POP
29146: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29147: LD_ADDR_VAR 0 2
29151: PUSH
29152: LD_VAR 0 2
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: LD_VAR 0 4
29164: PUSH
29165: LD_VAR 0 5
29169: DIFF
29170: PPUSH
29171: CALL_OW 1
29175: ST_TO_ADDR
// exit ;
29176: GO 29178
// end ; end ;
29178: LD_VAR 0 2
29182: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29183: LD_INT 0
29185: PPUSH
29186: PPUSH
29187: PPUSH
// if not mc_bases then
29188: LD_EXP 93
29192: NOT
29193: IFFALSE 29197
// exit ;
29195: GO 29339
// for i = 1 to mc_bases do
29197: LD_ADDR_VAR 0 2
29201: PUSH
29202: DOUBLE
29203: LD_INT 1
29205: DEC
29206: ST_TO_ADDR
29207: LD_EXP 93
29211: PUSH
29212: FOR_TO
29213: IFFALSE 29330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29215: LD_ADDR_VAR 0 3
29219: PUSH
29220: LD_EXP 93
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: LD_INT 21
29233: PUSH
29234: LD_INT 3
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 3
29243: PUSH
29244: LD_INT 2
29246: PUSH
29247: LD_INT 30
29249: PUSH
29250: LD_INT 29
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 30
29259: PUSH
29260: LD_INT 30
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: LIST
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PUSH
29276: LD_INT 3
29278: PUSH
29279: LD_INT 24
29281: PUSH
29282: LD_INT 1000
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: LIST
29297: PPUSH
29298: CALL_OW 72
29302: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29303: LD_ADDR_EXP 94
29307: PUSH
29308: LD_EXP 94
29312: PPUSH
29313: LD_VAR 0 2
29317: PPUSH
29318: LD_VAR 0 3
29322: PPUSH
29323: CALL_OW 1
29327: ST_TO_ADDR
// end ;
29328: GO 29212
29330: POP
29331: POP
// RaiseSailEvent ( 101 ) ;
29332: LD_INT 101
29334: PPUSH
29335: CALL_OW 427
// end ;
29339: LD_VAR 0 1
29343: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29344: LD_INT 0
29346: PPUSH
29347: PPUSH
29348: PPUSH
29349: PPUSH
29350: PPUSH
29351: PPUSH
29352: PPUSH
// if not mc_bases then
29353: LD_EXP 93
29357: NOT
29358: IFFALSE 29362
// exit ;
29360: GO 29924
// for i = 1 to mc_bases do
29362: LD_ADDR_VAR 0 2
29366: PUSH
29367: DOUBLE
29368: LD_INT 1
29370: DEC
29371: ST_TO_ADDR
29372: LD_EXP 93
29376: PUSH
29377: FOR_TO
29378: IFFALSE 29915
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29380: LD_ADDR_VAR 0 5
29384: PUSH
29385: LD_EXP 93
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_EXP 122
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: UNION
29407: PPUSH
29408: LD_INT 21
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: LD_INT 3
29423: PUSH
29424: LD_INT 54
29426: PUSH
29427: EMPTY
29428: LIST
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 3
29436: PUSH
29437: LD_INT 24
29439: PUSH
29440: LD_INT 1000
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: LIST
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 72
29464: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29465: LD_ADDR_VAR 0 6
29469: PUSH
29470: LD_EXP 93
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PPUSH
29481: LD_INT 21
29483: PUSH
29484: LD_INT 1
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: LD_INT 3
29496: PUSH
29497: LD_INT 54
29499: PUSH
29500: EMPTY
29501: LIST
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 3
29509: PUSH
29510: LD_INT 24
29512: PUSH
29513: LD_INT 250
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: CALL_OW 72
29537: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29538: LD_ADDR_VAR 0 7
29542: PUSH
29543: LD_VAR 0 5
29547: PUSH
29548: LD_VAR 0 6
29552: DIFF
29553: ST_TO_ADDR
// if not need_heal_1 then
29554: LD_VAR 0 6
29558: NOT
29559: IFFALSE 29592
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29561: LD_ADDR_EXP 96
29565: PUSH
29566: LD_EXP 96
29570: PPUSH
29571: LD_VAR 0 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PPUSH
29583: EMPTY
29584: PPUSH
29585: CALL 56474 0 3
29589: ST_TO_ADDR
29590: GO 29662
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29592: LD_ADDR_EXP 96
29596: PUSH
29597: LD_EXP 96
29601: PPUSH
29602: LD_VAR 0 2
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: LD_EXP 96
29618: PUSH
29619: LD_VAR 0 2
29623: ARRAY
29624: PUSH
29625: LD_INT 1
29627: ARRAY
29628: PPUSH
29629: LD_INT 3
29631: PUSH
29632: LD_INT 24
29634: PUSH
29635: LD_INT 1000
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PPUSH
29646: CALL_OW 72
29650: PUSH
29651: LD_VAR 0 6
29655: UNION
29656: PPUSH
29657: CALL 56474 0 3
29661: ST_TO_ADDR
// if not need_heal_2 then
29662: LD_VAR 0 7
29666: NOT
29667: IFFALSE 29700
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29669: LD_ADDR_EXP 96
29673: PUSH
29674: LD_EXP 96
29678: PPUSH
29679: LD_VAR 0 2
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PPUSH
29691: EMPTY
29692: PPUSH
29693: CALL 56474 0 3
29697: ST_TO_ADDR
29698: GO 29732
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29700: LD_ADDR_EXP 96
29704: PUSH
29705: LD_EXP 96
29709: PPUSH
29710: LD_VAR 0 2
29714: PUSH
29715: LD_INT 2
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PPUSH
29722: LD_VAR 0 7
29726: PPUSH
29727: CALL 56474 0 3
29731: ST_TO_ADDR
// if need_heal_2 then
29732: LD_VAR 0 7
29736: IFFALSE 29897
// for j in need_heal_2 do
29738: LD_ADDR_VAR 0 3
29742: PUSH
29743: LD_VAR 0 7
29747: PUSH
29748: FOR_IN
29749: IFFALSE 29895
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29751: LD_ADDR_VAR 0 5
29755: PUSH
29756: LD_EXP 93
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: PPUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 30
29772: PUSH
29773: LD_INT 6
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 30
29782: PUSH
29783: LD_INT 7
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: LD_INT 8
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 30
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 30
29812: PUSH
29813: LD_INT 1
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// if tmp then
29833: LD_VAR 0 5
29837: IFFALSE 29893
// begin k := NearestUnitToUnit ( tmp , j ) ;
29839: LD_ADDR_VAR 0 4
29843: PUSH
29844: LD_VAR 0 5
29848: PPUSH
29849: LD_VAR 0 3
29853: PPUSH
29854: CALL_OW 74
29858: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29859: LD_VAR 0 3
29863: PPUSH
29864: LD_VAR 0 4
29868: PPUSH
29869: CALL_OW 296
29873: PUSH
29874: LD_INT 5
29876: GREATER
29877: IFFALSE 29893
// ComMoveToNearbyEntrance ( j , k ) ;
29879: LD_VAR 0 3
29883: PPUSH
29884: LD_VAR 0 4
29888: PPUSH
29889: CALL 89092 0 2
// end ; end ;
29893: GO 29748
29895: POP
29896: POP
// if not need_heal_1 and not need_heal_2 then
29897: LD_VAR 0 6
29901: NOT
29902: PUSH
29903: LD_VAR 0 7
29907: NOT
29908: AND
29909: IFFALSE 29913
// continue ;
29911: GO 29377
// end ;
29913: GO 29377
29915: POP
29916: POP
// RaiseSailEvent ( 102 ) ;
29917: LD_INT 102
29919: PPUSH
29920: CALL_OW 427
// end ;
29924: LD_VAR 0 1
29928: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29929: LD_INT 0
29931: PPUSH
29932: PPUSH
29933: PPUSH
29934: PPUSH
29935: PPUSH
29936: PPUSH
29937: PPUSH
29938: PPUSH
// if not mc_bases then
29939: LD_EXP 93
29943: NOT
29944: IFFALSE 29948
// exit ;
29946: GO 30831
// for i = 1 to mc_bases do
29948: LD_ADDR_VAR 0 2
29952: PUSH
29953: DOUBLE
29954: LD_INT 1
29956: DEC
29957: ST_TO_ADDR
29958: LD_EXP 93
29962: PUSH
29963: FOR_TO
29964: IFFALSE 30829
// begin if not mc_building_need_repair [ i ] then
29966: LD_EXP 94
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: NOT
29977: IFFALSE 30164
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29979: LD_ADDR_VAR 0 6
29983: PUSH
29984: LD_EXP 112
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: PPUSH
29995: LD_INT 3
29997: PUSH
29998: LD_INT 24
30000: PUSH
30001: LD_INT 1000
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 2
30014: PUSH
30015: LD_INT 34
30017: PUSH
30018: LD_INT 13
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 34
30027: PUSH
30028: LD_INT 52
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 34
30037: PUSH
30038: LD_EXP 78
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PPUSH
30057: CALL_OW 72
30061: ST_TO_ADDR
// if cranes then
30062: LD_VAR 0 6
30066: IFFALSE 30128
// for j in cranes do
30068: LD_ADDR_VAR 0 3
30072: PUSH
30073: LD_VAR 0 6
30077: PUSH
30078: FOR_IN
30079: IFFALSE 30126
// if not IsInArea ( j , mc_parking [ i ] ) then
30081: LD_VAR 0 3
30085: PPUSH
30086: LD_EXP 117
30090: PUSH
30091: LD_VAR 0 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 308
30101: NOT
30102: IFFALSE 30124
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30104: LD_VAR 0 3
30108: PPUSH
30109: LD_EXP 117
30113: PUSH
30114: LD_VAR 0 2
30118: ARRAY
30119: PPUSH
30120: CALL_OW 113
30124: GO 30078
30126: POP
30127: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30128: LD_ADDR_EXP 95
30132: PUSH
30133: LD_EXP 95
30137: PPUSH
30138: LD_VAR 0 2
30142: PPUSH
30143: EMPTY
30144: PPUSH
30145: CALL_OW 1
30149: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30150: LD_VAR 0 2
30154: PPUSH
30155: LD_INT 101
30157: PPUSH
30158: CALL 25016 0 2
// continue ;
30162: GO 29963
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30164: LD_ADDR_EXP 99
30168: PUSH
30169: LD_EXP 99
30173: PPUSH
30174: LD_VAR 0 2
30178: PPUSH
30179: EMPTY
30180: PPUSH
30181: CALL_OW 1
30185: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30186: LD_VAR 0 2
30190: PPUSH
30191: LD_INT 103
30193: PPUSH
30194: CALL 25016 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30198: LD_ADDR_VAR 0 5
30202: PUSH
30203: LD_EXP 93
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PUSH
30214: LD_EXP 122
30218: PUSH
30219: LD_VAR 0 2
30223: ARRAY
30224: UNION
30225: PPUSH
30226: LD_INT 2
30228: PUSH
30229: LD_INT 25
30231: PUSH
30232: LD_INT 2
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 25
30241: PUSH
30242: LD_INT 16
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: PPUSH
30257: CALL_OW 72
30261: ST_TO_ADDR
// if mc_need_heal [ i ] then
30262: LD_EXP 96
30266: PUSH
30267: LD_VAR 0 2
30271: ARRAY
30272: IFFALSE 30316
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30274: LD_ADDR_VAR 0 5
30278: PUSH
30279: LD_VAR 0 5
30283: PUSH
30284: LD_EXP 96
30288: PUSH
30289: LD_VAR 0 2
30293: ARRAY
30294: PUSH
30295: LD_INT 1
30297: ARRAY
30298: PUSH
30299: LD_EXP 96
30303: PUSH
30304: LD_VAR 0 2
30308: ARRAY
30309: PUSH
30310: LD_INT 2
30312: ARRAY
30313: UNION
30314: DIFF
30315: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30316: LD_ADDR_VAR 0 6
30320: PUSH
30321: LD_EXP 112
30325: PUSH
30326: LD_VAR 0 2
30330: ARRAY
30331: PPUSH
30332: LD_INT 2
30334: PUSH
30335: LD_INT 34
30337: PUSH
30338: LD_INT 13
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 34
30347: PUSH
30348: LD_INT 52
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 34
30357: PUSH
30358: LD_EXP 78
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: PPUSH
30373: CALL_OW 72
30377: ST_TO_ADDR
// if cranes then
30378: LD_VAR 0 6
30382: IFFALSE 30518
// begin for j in cranes do
30384: LD_ADDR_VAR 0 3
30388: PUSH
30389: LD_VAR 0 6
30393: PUSH
30394: FOR_IN
30395: IFFALSE 30516
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30397: LD_VAR 0 3
30401: PPUSH
30402: CALL_OW 256
30406: PUSH
30407: LD_INT 1000
30409: EQUAL
30410: PUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: CALL_OW 314
30420: NOT
30421: AND
30422: IFFALSE 30456
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30424: LD_VAR 0 3
30428: PPUSH
30429: LD_EXP 94
30433: PUSH
30434: LD_VAR 0 2
30438: ARRAY
30439: PPUSH
30440: LD_VAR 0 3
30444: PPUSH
30445: CALL_OW 74
30449: PPUSH
30450: CALL_OW 130
30454: GO 30514
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30456: LD_VAR 0 3
30460: PPUSH
30461: CALL_OW 256
30465: PUSH
30466: LD_INT 500
30468: LESS
30469: PUSH
30470: LD_VAR 0 3
30474: PPUSH
30475: LD_EXP 117
30479: PUSH
30480: LD_VAR 0 2
30484: ARRAY
30485: PPUSH
30486: CALL_OW 308
30490: NOT
30491: AND
30492: IFFALSE 30514
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30494: LD_VAR 0 3
30498: PPUSH
30499: LD_EXP 117
30503: PUSH
30504: LD_VAR 0 2
30508: ARRAY
30509: PPUSH
30510: CALL_OW 113
// end ;
30514: GO 30394
30516: POP
30517: POP
// end ; if tmp > 3 then
30518: LD_VAR 0 5
30522: PUSH
30523: LD_INT 3
30525: GREATER
30526: IFFALSE 30546
// tmp := ShrinkArray ( tmp , 4 ) ;
30528: LD_ADDR_VAR 0 5
30532: PUSH
30533: LD_VAR 0 5
30537: PPUSH
30538: LD_INT 4
30540: PPUSH
30541: CALL 88540 0 2
30545: ST_TO_ADDR
// if not tmp then
30546: LD_VAR 0 5
30550: NOT
30551: IFFALSE 30555
// continue ;
30553: GO 29963
// for j in tmp do
30555: LD_ADDR_VAR 0 3
30559: PUSH
30560: LD_VAR 0 5
30564: PUSH
30565: FOR_IN
30566: IFFALSE 30825
// begin if IsInUnit ( j ) then
30568: LD_VAR 0 3
30572: PPUSH
30573: CALL_OW 310
30577: IFFALSE 30588
// ComExitBuilding ( j ) ;
30579: LD_VAR 0 3
30583: PPUSH
30584: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30588: LD_VAR 0 3
30592: PUSH
30593: LD_EXP 95
30597: PUSH
30598: LD_VAR 0 2
30602: ARRAY
30603: IN
30604: NOT
30605: IFFALSE 30663
// begin SetTag ( j , 101 ) ;
30607: LD_VAR 0 3
30611: PPUSH
30612: LD_INT 101
30614: PPUSH
30615: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30619: LD_ADDR_EXP 95
30623: PUSH
30624: LD_EXP 95
30628: PPUSH
30629: LD_VAR 0 2
30633: PUSH
30634: LD_EXP 95
30638: PUSH
30639: LD_VAR 0 2
30643: ARRAY
30644: PUSH
30645: LD_INT 1
30647: PLUS
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PPUSH
30653: LD_VAR 0 3
30657: PPUSH
30658: CALL 56474 0 3
30662: ST_TO_ADDR
// end ; wait ( 1 ) ;
30663: LD_INT 1
30665: PPUSH
30666: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30670: LD_ADDR_VAR 0 7
30674: PUSH
30675: LD_EXP 94
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: ST_TO_ADDR
// if mc_scan [ i ] then
30686: LD_EXP 116
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: IFFALSE 30758
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30698: LD_ADDR_VAR 0 7
30702: PUSH
30703: LD_EXP 94
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PPUSH
30714: LD_INT 3
30716: PUSH
30717: LD_INT 30
30719: PUSH
30720: LD_INT 32
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 30
30729: PUSH
30730: LD_INT 33
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 30
30739: PUSH
30740: LD_INT 31
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: PPUSH
30753: CALL_OW 72
30757: ST_TO_ADDR
// if not to_repair_tmp then
30758: LD_VAR 0 7
30762: NOT
30763: IFFALSE 30767
// continue ;
30765: GO 30565
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30767: LD_ADDR_VAR 0 8
30771: PUSH
30772: LD_VAR 0 7
30776: PPUSH
30777: LD_VAR 0 3
30781: PPUSH
30782: CALL_OW 74
30786: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30787: LD_VAR 0 8
30791: PPUSH
30792: LD_INT 16
30794: PPUSH
30795: CALL 59073 0 2
30799: PUSH
30800: LD_INT 4
30802: ARRAY
30803: PUSH
30804: LD_INT 10
30806: LESS
30807: IFFALSE 30823
// ComRepairBuilding ( j , to_repair ) ;
30809: LD_VAR 0 3
30813: PPUSH
30814: LD_VAR 0 8
30818: PPUSH
30819: CALL_OW 130
// end ;
30823: GO 30565
30825: POP
30826: POP
// end ;
30827: GO 29963
30829: POP
30830: POP
// end ;
30831: LD_VAR 0 1
30835: RET
// export function MC_Heal ; var i , j , tmp ; begin
30836: LD_INT 0
30838: PPUSH
30839: PPUSH
30840: PPUSH
30841: PPUSH
// if not mc_bases then
30842: LD_EXP 93
30846: NOT
30847: IFFALSE 30851
// exit ;
30849: GO 31253
// for i = 1 to mc_bases do
30851: LD_ADDR_VAR 0 2
30855: PUSH
30856: DOUBLE
30857: LD_INT 1
30859: DEC
30860: ST_TO_ADDR
30861: LD_EXP 93
30865: PUSH
30866: FOR_TO
30867: IFFALSE 31251
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30869: LD_EXP 96
30873: PUSH
30874: LD_VAR 0 2
30878: ARRAY
30879: PUSH
30880: LD_INT 1
30882: ARRAY
30883: NOT
30884: PUSH
30885: LD_EXP 96
30889: PUSH
30890: LD_VAR 0 2
30894: ARRAY
30895: PUSH
30896: LD_INT 2
30898: ARRAY
30899: NOT
30900: AND
30901: IFFALSE 30939
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30903: LD_ADDR_EXP 97
30907: PUSH
30908: LD_EXP 97
30912: PPUSH
30913: LD_VAR 0 2
30917: PPUSH
30918: EMPTY
30919: PPUSH
30920: CALL_OW 1
30924: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30925: LD_VAR 0 2
30929: PPUSH
30930: LD_INT 102
30932: PPUSH
30933: CALL 25016 0 2
// continue ;
30937: GO 30866
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30939: LD_ADDR_VAR 0 4
30943: PUSH
30944: LD_EXP 93
30948: PUSH
30949: LD_VAR 0 2
30953: ARRAY
30954: PPUSH
30955: LD_INT 25
30957: PUSH
30958: LD_INT 4
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PPUSH
30965: CALL_OW 72
30969: ST_TO_ADDR
// if not tmp then
30970: LD_VAR 0 4
30974: NOT
30975: IFFALSE 30979
// continue ;
30977: GO 30866
// if mc_taming [ i ] then
30979: LD_EXP 124
30983: PUSH
30984: LD_VAR 0 2
30988: ARRAY
30989: IFFALSE 31013
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30991: LD_ADDR_EXP 124
30995: PUSH
30996: LD_EXP 124
31000: PPUSH
31001: LD_VAR 0 2
31005: PPUSH
31006: EMPTY
31007: PPUSH
31008: CALL_OW 1
31012: ST_TO_ADDR
// for j in tmp do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: FOR_IN
31024: IFFALSE 31247
// begin if IsInUnit ( j ) then
31026: LD_VAR 0 3
31030: PPUSH
31031: CALL_OW 310
31035: IFFALSE 31046
// ComExitBuilding ( j ) ;
31037: LD_VAR 0 3
31041: PPUSH
31042: CALL_OW 122
// if not j in mc_healers [ i ] then
31046: LD_VAR 0 3
31050: PUSH
31051: LD_EXP 97
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: IN
31062: NOT
31063: IFFALSE 31109
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31065: LD_ADDR_EXP 97
31069: PUSH
31070: LD_EXP 97
31074: PPUSH
31075: LD_VAR 0 2
31079: PUSH
31080: LD_EXP 97
31084: PUSH
31085: LD_VAR 0 2
31089: ARRAY
31090: PUSH
31091: LD_INT 1
31093: PLUS
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PPUSH
31099: LD_VAR 0 3
31103: PPUSH
31104: CALL 56474 0 3
31108: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31109: LD_VAR 0 3
31113: PPUSH
31114: CALL_OW 110
31118: PUSH
31119: LD_INT 102
31121: NONEQUAL
31122: IFFALSE 31136
// SetTag ( j , 102 ) ;
31124: LD_VAR 0 3
31128: PPUSH
31129: LD_INT 102
31131: PPUSH
31132: CALL_OW 109
// Wait ( 3 ) ;
31136: LD_INT 3
31138: PPUSH
31139: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31143: LD_EXP 96
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: PUSH
31154: LD_INT 1
31156: ARRAY
31157: IFFALSE 31189
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31159: LD_VAR 0 3
31163: PPUSH
31164: LD_EXP 96
31168: PUSH
31169: LD_VAR 0 2
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PUSH
31179: LD_INT 1
31181: ARRAY
31182: PPUSH
31183: CALL_OW 128
31187: GO 31245
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31189: LD_VAR 0 3
31193: PPUSH
31194: CALL_OW 314
31198: NOT
31199: PUSH
31200: LD_EXP 96
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: PUSH
31211: LD_INT 2
31213: ARRAY
31214: AND
31215: IFFALSE 31245
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31217: LD_VAR 0 3
31221: PPUSH
31222: LD_EXP 96
31226: PUSH
31227: LD_VAR 0 2
31231: ARRAY
31232: PUSH
31233: LD_INT 2
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: ARRAY
31240: PPUSH
31241: CALL_OW 128
// end ;
31245: GO 31023
31247: POP
31248: POP
// end ;
31249: GO 30866
31251: POP
31252: POP
// end ;
31253: LD_VAR 0 1
31257: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31258: LD_INT 0
31260: PPUSH
31261: PPUSH
31262: PPUSH
31263: PPUSH
31264: PPUSH
// if not mc_bases then
31265: LD_EXP 93
31269: NOT
31270: IFFALSE 31274
// exit ;
31272: GO 32445
// for i = 1 to mc_bases do
31274: LD_ADDR_VAR 0 2
31278: PUSH
31279: DOUBLE
31280: LD_INT 1
31282: DEC
31283: ST_TO_ADDR
31284: LD_EXP 93
31288: PUSH
31289: FOR_TO
31290: IFFALSE 32443
// begin if mc_scan [ i ] then
31292: LD_EXP 116
31296: PUSH
31297: LD_VAR 0 2
31301: ARRAY
31302: IFFALSE 31306
// continue ;
31304: GO 31289
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31306: LD_EXP 98
31310: PUSH
31311: LD_VAR 0 2
31315: ARRAY
31316: NOT
31317: PUSH
31318: LD_EXP 100
31322: PUSH
31323: LD_VAR 0 2
31327: ARRAY
31328: NOT
31329: AND
31330: PUSH
31331: LD_EXP 99
31335: PUSH
31336: LD_VAR 0 2
31340: ARRAY
31341: AND
31342: IFFALSE 31380
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31344: LD_ADDR_EXP 99
31348: PUSH
31349: LD_EXP 99
31353: PPUSH
31354: LD_VAR 0 2
31358: PPUSH
31359: EMPTY
31360: PPUSH
31361: CALL_OW 1
31365: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31366: LD_VAR 0 2
31370: PPUSH
31371: LD_INT 103
31373: PPUSH
31374: CALL 25016 0 2
// continue ;
31378: GO 31289
// end ; if mc_construct_list [ i ] then
31380: LD_EXP 100
31384: PUSH
31385: LD_VAR 0 2
31389: ARRAY
31390: IFFALSE 31610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31392: LD_ADDR_VAR 0 4
31396: PUSH
31397: LD_EXP 93
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 25
31410: PUSH
31411: LD_INT 2
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 72
31422: PUSH
31423: LD_EXP 95
31427: PUSH
31428: LD_VAR 0 2
31432: ARRAY
31433: DIFF
31434: ST_TO_ADDR
// if not tmp then
31435: LD_VAR 0 4
31439: NOT
31440: IFFALSE 31444
// continue ;
31442: GO 31289
// for j in tmp do
31444: LD_ADDR_VAR 0 3
31448: PUSH
31449: LD_VAR 0 4
31453: PUSH
31454: FOR_IN
31455: IFFALSE 31606
// begin if not mc_builders [ i ] then
31457: LD_EXP 99
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: NOT
31468: IFFALSE 31526
// begin SetTag ( j , 103 ) ;
31470: LD_VAR 0 3
31474: PPUSH
31475: LD_INT 103
31477: PPUSH
31478: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31482: LD_ADDR_EXP 99
31486: PUSH
31487: LD_EXP 99
31491: PPUSH
31492: LD_VAR 0 2
31496: PUSH
31497: LD_EXP 99
31501: PUSH
31502: LD_VAR 0 2
31506: ARRAY
31507: PUSH
31508: LD_INT 1
31510: PLUS
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PPUSH
31516: LD_VAR 0 3
31520: PPUSH
31521: CALL 56474 0 3
31525: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL_OW 310
31535: IFFALSE 31546
// ComExitBuilding ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 122
// wait ( 3 ) ;
31546: LD_INT 3
31548: PPUSH
31549: CALL_OW 67
// if not mc_construct_list [ i ] then
31553: LD_EXP 100
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: NOT
31564: IFFALSE 31568
// break ;
31566: GO 31606
// if not HasTask ( j ) then
31568: LD_VAR 0 3
31572: PPUSH
31573: CALL_OW 314
31577: NOT
31578: IFFALSE 31604
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31580: LD_VAR 0 3
31584: PPUSH
31585: LD_EXP 100
31589: PUSH
31590: LD_VAR 0 2
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: CALL 59337 0 2
// end ;
31604: GO 31454
31606: POP
31607: POP
// end else
31608: GO 32441
// if mc_build_list [ i ] then
31610: LD_EXP 98
31614: PUSH
31615: LD_VAR 0 2
31619: ARRAY
31620: IFFALSE 32441
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31622: LD_ADDR_VAR 0 5
31626: PUSH
31627: LD_EXP 93
31631: PUSH
31632: LD_VAR 0 2
31636: ARRAY
31637: PPUSH
31638: LD_INT 2
31640: PUSH
31641: LD_INT 30
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 30
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: PPUSH
31666: CALL_OW 72
31670: ST_TO_ADDR
// if depot then
31671: LD_VAR 0 5
31675: IFFALSE 31693
// depot := depot [ 1 ] else
31677: LD_ADDR_VAR 0 5
31681: PUSH
31682: LD_VAR 0 5
31686: PUSH
31687: LD_INT 1
31689: ARRAY
31690: ST_TO_ADDR
31691: GO 31701
// depot := 0 ;
31693: LD_ADDR_VAR 0 5
31697: PUSH
31698: LD_INT 0
31700: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31701: LD_EXP 98
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PUSH
31716: LD_INT 1
31718: ARRAY
31719: PPUSH
31720: CALL 59161 0 1
31724: PUSH
31725: LD_EXP 93
31729: PUSH
31730: LD_VAR 0 2
31734: ARRAY
31735: PPUSH
31736: LD_INT 2
31738: PUSH
31739: LD_INT 30
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 30
31751: PUSH
31752: LD_INT 3
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: LIST
31763: PPUSH
31764: CALL_OW 72
31768: NOT
31769: AND
31770: IFFALSE 31875
// begin for j = 1 to mc_build_list [ i ] do
31772: LD_ADDR_VAR 0 3
31776: PUSH
31777: DOUBLE
31778: LD_INT 1
31780: DEC
31781: ST_TO_ADDR
31782: LD_EXP 98
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PUSH
31793: FOR_TO
31794: IFFALSE 31873
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31796: LD_EXP 98
31800: PUSH
31801: LD_VAR 0 2
31805: ARRAY
31806: PUSH
31807: LD_VAR 0 3
31811: ARRAY
31812: PUSH
31813: LD_INT 1
31815: ARRAY
31816: PUSH
31817: LD_INT 2
31819: EQUAL
31820: IFFALSE 31871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31822: LD_ADDR_EXP 98
31826: PUSH
31827: LD_EXP 98
31831: PPUSH
31832: LD_VAR 0 2
31836: PPUSH
31837: LD_EXP 98
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PPUSH
31848: LD_VAR 0 3
31852: PPUSH
31853: LD_INT 1
31855: PPUSH
31856: LD_INT 0
31858: PPUSH
31859: CALL 55892 0 4
31863: PPUSH
31864: CALL_OW 1
31868: ST_TO_ADDR
// break ;
31869: GO 31873
// end ;
31871: GO 31793
31873: POP
31874: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31875: LD_EXP 98
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: PUSH
31886: LD_INT 1
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: ARRAY
31893: PUSH
31894: LD_INT 0
31896: EQUAL
31897: PUSH
31898: LD_VAR 0 5
31902: PUSH
31903: LD_VAR 0 5
31907: PPUSH
31908: LD_EXP 98
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: PUSH
31919: LD_INT 1
31921: ARRAY
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_EXP 98
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: PUSH
31938: LD_INT 1
31940: ARRAY
31941: PUSH
31942: LD_INT 2
31944: ARRAY
31945: PPUSH
31946: LD_EXP 98
31950: PUSH
31951: LD_VAR 0 2
31955: ARRAY
31956: PUSH
31957: LD_INT 1
31959: ARRAY
31960: PUSH
31961: LD_INT 3
31963: ARRAY
31964: PPUSH
31965: LD_EXP 98
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PUSH
31976: LD_INT 1
31978: ARRAY
31979: PUSH
31980: LD_INT 4
31982: ARRAY
31983: PPUSH
31984: CALL 64577 0 5
31988: AND
31989: OR
31990: IFFALSE 32271
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31992: LD_ADDR_VAR 0 4
31996: PUSH
31997: LD_EXP 93
32001: PUSH
32002: LD_VAR 0 2
32006: ARRAY
32007: PPUSH
32008: LD_INT 25
32010: PUSH
32011: LD_INT 2
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PPUSH
32018: CALL_OW 72
32022: PUSH
32023: LD_EXP 95
32027: PUSH
32028: LD_VAR 0 2
32032: ARRAY
32033: DIFF
32034: ST_TO_ADDR
// if not tmp then
32035: LD_VAR 0 4
32039: NOT
32040: IFFALSE 32044
// continue ;
32042: GO 31289
// for j in tmp do
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: FOR_IN
32055: IFFALSE 32267
// begin if not mc_builders [ i ] then
32057: LD_EXP 99
32061: PUSH
32062: LD_VAR 0 2
32066: ARRAY
32067: NOT
32068: IFFALSE 32126
// begin SetTag ( j , 103 ) ;
32070: LD_VAR 0 3
32074: PPUSH
32075: LD_INT 103
32077: PPUSH
32078: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32082: LD_ADDR_EXP 99
32086: PUSH
32087: LD_EXP 99
32091: PPUSH
32092: LD_VAR 0 2
32096: PUSH
32097: LD_EXP 99
32101: PUSH
32102: LD_VAR 0 2
32106: ARRAY
32107: PUSH
32108: LD_INT 1
32110: PLUS
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PPUSH
32116: LD_VAR 0 3
32120: PPUSH
32121: CALL 56474 0 3
32125: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 310
32135: IFFALSE 32146
// ComExitBuilding ( j ) ;
32137: LD_VAR 0 3
32141: PPUSH
32142: CALL_OW 122
// wait ( 3 ) ;
32146: LD_INT 3
32148: PPUSH
32149: CALL_OW 67
// if not mc_build_list [ i ] then
32153: LD_EXP 98
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: NOT
32164: IFFALSE 32168
// break ;
32166: GO 32267
// if not HasTask ( j ) then
32168: LD_VAR 0 3
32172: PPUSH
32173: CALL_OW 314
32177: NOT
32178: IFFALSE 32265
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32180: LD_VAR 0 3
32184: PPUSH
32185: LD_EXP 98
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: PUSH
32200: LD_INT 1
32202: ARRAY
32203: PPUSH
32204: LD_EXP 98
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_INT 1
32217: ARRAY
32218: PUSH
32219: LD_INT 2
32221: ARRAY
32222: PPUSH
32223: LD_EXP 98
32227: PUSH
32228: LD_VAR 0 2
32232: ARRAY
32233: PUSH
32234: LD_INT 1
32236: ARRAY
32237: PUSH
32238: LD_INT 3
32240: ARRAY
32241: PPUSH
32242: LD_EXP 98
32246: PUSH
32247: LD_VAR 0 2
32251: ARRAY
32252: PUSH
32253: LD_INT 1
32255: ARRAY
32256: PUSH
32257: LD_INT 4
32259: ARRAY
32260: PPUSH
32261: CALL_OW 145
// end ;
32265: GO 32054
32267: POP
32268: POP
// end else
32269: GO 32441
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32271: LD_EXP 93
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: PPUSH
32282: LD_EXP 98
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: LD_INT 1
32295: ARRAY
32296: PUSH
32297: LD_INT 1
32299: ARRAY
32300: PPUSH
32301: LD_EXP 98
32305: PUSH
32306: LD_VAR 0 2
32310: ARRAY
32311: PUSH
32312: LD_INT 1
32314: ARRAY
32315: PUSH
32316: LD_INT 2
32318: ARRAY
32319: PPUSH
32320: LD_EXP 98
32324: PUSH
32325: LD_VAR 0 2
32329: ARRAY
32330: PUSH
32331: LD_INT 1
32333: ARRAY
32334: PUSH
32335: LD_INT 3
32337: ARRAY
32338: PPUSH
32339: LD_EXP 98
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_INT 1
32352: ARRAY
32353: PUSH
32354: LD_INT 4
32356: ARRAY
32357: PPUSH
32358: LD_EXP 93
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PPUSH
32369: LD_INT 21
32371: PUSH
32372: LD_INT 3
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 72
32383: PPUSH
32384: EMPTY
32385: PPUSH
32386: CALL 63327 0 7
32390: NOT
32391: IFFALSE 32441
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32393: LD_ADDR_EXP 98
32397: PUSH
32398: LD_EXP 98
32402: PPUSH
32403: LD_VAR 0 2
32407: PPUSH
32408: LD_EXP 98
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PPUSH
32419: LD_INT 1
32421: PPUSH
32422: LD_INT 1
32424: NEG
32425: PPUSH
32426: LD_INT 0
32428: PPUSH
32429: CALL 55892 0 4
32433: PPUSH
32434: CALL_OW 1
32438: ST_TO_ADDR
// continue ;
32439: GO 31289
// end ; end ; end ;
32441: GO 31289
32443: POP
32444: POP
// end ;
32445: LD_VAR 0 1
32449: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32450: LD_INT 0
32452: PPUSH
32453: PPUSH
32454: PPUSH
32455: PPUSH
32456: PPUSH
32457: PPUSH
// if not mc_bases then
32458: LD_EXP 93
32462: NOT
32463: IFFALSE 32467
// exit ;
32465: GO 32894
// for i = 1 to mc_bases do
32467: LD_ADDR_VAR 0 2
32471: PUSH
32472: DOUBLE
32473: LD_INT 1
32475: DEC
32476: ST_TO_ADDR
32477: LD_EXP 93
32481: PUSH
32482: FOR_TO
32483: IFFALSE 32892
// begin tmp := mc_build_upgrade [ i ] ;
32485: LD_ADDR_VAR 0 4
32489: PUSH
32490: LD_EXP 125
32494: PUSH
32495: LD_VAR 0 2
32499: ARRAY
32500: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32501: LD_ADDR_VAR 0 6
32505: PUSH
32506: LD_EXP 126
32510: PUSH
32511: LD_VAR 0 2
32515: ARRAY
32516: PPUSH
32517: LD_INT 2
32519: PUSH
32520: LD_INT 30
32522: PUSH
32523: LD_INT 6
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 30
32532: PUSH
32533: LD_INT 7
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: LIST
32544: PPUSH
32545: CALL_OW 72
32549: ST_TO_ADDR
// if not tmp and not lab then
32550: LD_VAR 0 4
32554: NOT
32555: PUSH
32556: LD_VAR 0 6
32560: NOT
32561: AND
32562: IFFALSE 32566
// continue ;
32564: GO 32482
// if tmp then
32566: LD_VAR 0 4
32570: IFFALSE 32690
// for j in tmp do
32572: LD_ADDR_VAR 0 3
32576: PUSH
32577: LD_VAR 0 4
32581: PUSH
32582: FOR_IN
32583: IFFALSE 32688
// begin if UpgradeCost ( j ) then
32585: LD_VAR 0 3
32589: PPUSH
32590: CALL 62987 0 1
32594: IFFALSE 32686
// begin ComUpgrade ( j ) ;
32596: LD_VAR 0 3
32600: PPUSH
32601: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32605: LD_ADDR_EXP 125
32609: PUSH
32610: LD_EXP 125
32614: PPUSH
32615: LD_VAR 0 2
32619: PPUSH
32620: LD_EXP 125
32624: PUSH
32625: LD_VAR 0 2
32629: ARRAY
32630: PUSH
32631: LD_VAR 0 3
32635: DIFF
32636: PPUSH
32637: CALL_OW 1
32641: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32642: LD_ADDR_EXP 100
32646: PUSH
32647: LD_EXP 100
32651: PPUSH
32652: LD_VAR 0 2
32656: PUSH
32657: LD_EXP 100
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PPUSH
32676: LD_VAR 0 3
32680: PPUSH
32681: CALL 56474 0 3
32685: ST_TO_ADDR
// end ; end ;
32686: GO 32582
32688: POP
32689: POP
// if not lab or not mc_lab_upgrade [ i ] then
32690: LD_VAR 0 6
32694: NOT
32695: PUSH
32696: LD_EXP 127
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: NOT
32707: OR
32708: IFFALSE 32712
// continue ;
32710: GO 32482
// for j in lab do
32712: LD_ADDR_VAR 0 3
32716: PUSH
32717: LD_VAR 0 6
32721: PUSH
32722: FOR_IN
32723: IFFALSE 32888
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32725: LD_VAR 0 3
32729: PPUSH
32730: CALL_OW 266
32734: PUSH
32735: LD_INT 6
32737: PUSH
32738: LD_INT 7
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: IN
32745: PUSH
32746: LD_VAR 0 3
32750: PPUSH
32751: CALL_OW 461
32755: PUSH
32756: LD_INT 1
32758: NONEQUAL
32759: AND
32760: IFFALSE 32886
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32762: LD_VAR 0 3
32766: PPUSH
32767: LD_EXP 127
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PUSH
32778: LD_INT 1
32780: ARRAY
32781: PPUSH
32782: CALL 63192 0 2
32786: IFFALSE 32886
// begin ComCancel ( j ) ;
32788: LD_VAR 0 3
32792: PPUSH
32793: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32797: LD_VAR 0 3
32801: PPUSH
32802: LD_EXP 127
32806: PUSH
32807: LD_VAR 0 2
32811: ARRAY
32812: PUSH
32813: LD_INT 1
32815: ARRAY
32816: PPUSH
32817: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32821: LD_VAR 0 3
32825: PUSH
32826: LD_EXP 100
32830: PUSH
32831: LD_VAR 0 2
32835: ARRAY
32836: IN
32837: NOT
32838: IFFALSE 32884
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32840: LD_ADDR_EXP 100
32844: PUSH
32845: LD_EXP 100
32849: PPUSH
32850: LD_VAR 0 2
32854: PUSH
32855: LD_EXP 100
32859: PUSH
32860: LD_VAR 0 2
32864: ARRAY
32865: PUSH
32866: LD_INT 1
32868: PLUS
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL 56474 0 3
32883: ST_TO_ADDR
// break ;
32884: GO 32888
// end ; end ; end ;
32886: GO 32722
32888: POP
32889: POP
// end ;
32890: GO 32482
32892: POP
32893: POP
// end ;
32894: LD_VAR 0 1
32898: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32899: LD_INT 0
32901: PPUSH
32902: PPUSH
32903: PPUSH
32904: PPUSH
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
// if not mc_bases then
32910: LD_EXP 93
32914: NOT
32915: IFFALSE 32919
// exit ;
32917: GO 33324
// for i = 1 to mc_bases do
32919: LD_ADDR_VAR 0 2
32923: PUSH
32924: DOUBLE
32925: LD_INT 1
32927: DEC
32928: ST_TO_ADDR
32929: LD_EXP 93
32933: PUSH
32934: FOR_TO
32935: IFFALSE 33322
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32937: LD_EXP 101
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: NOT
32948: PUSH
32949: LD_EXP 93
32953: PUSH
32954: LD_VAR 0 2
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PUSH
32963: LD_INT 3
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PPUSH
32970: CALL_OW 72
32974: NOT
32975: OR
32976: IFFALSE 32980
// continue ;
32978: GO 32934
// busy := false ;
32980: LD_ADDR_VAR 0 8
32984: PUSH
32985: LD_INT 0
32987: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32988: LD_ADDR_VAR 0 4
32992: PUSH
32993: LD_EXP 93
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: LD_INT 30
33006: PUSH
33007: LD_INT 3
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PPUSH
33014: CALL_OW 72
33018: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33019: LD_ADDR_VAR 0 6
33023: PUSH
33024: LD_EXP 101
33028: PUSH
33029: LD_VAR 0 2
33033: ARRAY
33034: PPUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 30
33040: PUSH
33041: LD_INT 32
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 30
33050: PUSH
33051: LD_INT 33
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: LIST
33062: PPUSH
33063: CALL_OW 72
33067: ST_TO_ADDR
// if not t then
33068: LD_VAR 0 6
33072: NOT
33073: IFFALSE 33077
// continue ;
33075: GO 32934
// for j in tmp do
33077: LD_ADDR_VAR 0 3
33081: PUSH
33082: LD_VAR 0 4
33086: PUSH
33087: FOR_IN
33088: IFFALSE 33118
// if not BuildingStatus ( j ) = bs_idle then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 461
33099: PUSH
33100: LD_INT 2
33102: EQUAL
33103: NOT
33104: IFFALSE 33116
// begin busy := true ;
33106: LD_ADDR_VAR 0 8
33110: PUSH
33111: LD_INT 1
33113: ST_TO_ADDR
// break ;
33114: GO 33118
// end ;
33116: GO 33087
33118: POP
33119: POP
// if busy then
33120: LD_VAR 0 8
33124: IFFALSE 33128
// continue ;
33126: GO 32934
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33128: LD_ADDR_VAR 0 7
33132: PUSH
33133: LD_VAR 0 6
33137: PPUSH
33138: LD_INT 35
33140: PUSH
33141: LD_INT 0
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PPUSH
33148: CALL_OW 72
33152: ST_TO_ADDR
// if tw then
33153: LD_VAR 0 7
33157: IFFALSE 33234
// begin tw := tw [ 1 ] ;
33159: LD_ADDR_VAR 0 7
33163: PUSH
33164: LD_VAR 0 7
33168: PUSH
33169: LD_INT 1
33171: ARRAY
33172: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33173: LD_ADDR_VAR 0 9
33177: PUSH
33178: LD_VAR 0 7
33182: PPUSH
33183: LD_EXP 118
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PPUSH
33194: CALL 61484 0 2
33198: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33199: LD_EXP 132
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: IFFALSE 33232
// if not weapon in mc_allowed_tower_weapons [ i ] then
33211: LD_VAR 0 9
33215: PUSH
33216: LD_EXP 132
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: IN
33227: NOT
33228: IFFALSE 33232
// continue ;
33230: GO 32934
// end else
33232: GO 33297
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33234: LD_ADDR_VAR 0 5
33238: PUSH
33239: LD_EXP 101
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: PPUSH
33250: LD_VAR 0 4
33254: PPUSH
33255: CALL 87773 0 2
33259: ST_TO_ADDR
// if not tmp2 then
33260: LD_VAR 0 5
33264: NOT
33265: IFFALSE 33269
// continue ;
33267: GO 32934
// tw := tmp2 [ 1 ] ;
33269: LD_ADDR_VAR 0 7
33273: PUSH
33274: LD_VAR 0 5
33278: PUSH
33279: LD_INT 1
33281: ARRAY
33282: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33283: LD_ADDR_VAR 0 9
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 2
33295: ARRAY
33296: ST_TO_ADDR
// end ; if not weapon then
33297: LD_VAR 0 9
33301: NOT
33302: IFFALSE 33306
// continue ;
33304: GO 32934
// ComPlaceWeapon ( tw , weapon ) ;
33306: LD_VAR 0 7
33310: PPUSH
33311: LD_VAR 0 9
33315: PPUSH
33316: CALL_OW 148
// end ;
33320: GO 32934
33322: POP
33323: POP
// end ;
33324: LD_VAR 0 1
33328: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33329: LD_INT 0
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
// if not mc_bases then
33338: LD_EXP 93
33342: NOT
33343: IFFALSE 33347
// exit ;
33345: GO 34115
// for i = 1 to mc_bases do
33347: LD_ADDR_VAR 0 2
33351: PUSH
33352: DOUBLE
33353: LD_INT 1
33355: DEC
33356: ST_TO_ADDR
33357: LD_EXP 93
33361: PUSH
33362: FOR_TO
33363: IFFALSE 34113
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33365: LD_EXP 106
33369: PUSH
33370: LD_VAR 0 2
33374: ARRAY
33375: NOT
33376: PUSH
33377: LD_EXP 106
33381: PUSH
33382: LD_VAR 0 2
33386: ARRAY
33387: PUSH
33388: LD_EXP 107
33392: PUSH
33393: LD_VAR 0 2
33397: ARRAY
33398: EQUAL
33399: OR
33400: PUSH
33401: LD_EXP 116
33405: PUSH
33406: LD_VAR 0 2
33410: ARRAY
33411: OR
33412: IFFALSE 33416
// continue ;
33414: GO 33362
// if mc_miners [ i ] then
33416: LD_EXP 107
33420: PUSH
33421: LD_VAR 0 2
33425: ARRAY
33426: IFFALSE 33800
// begin for j = mc_miners [ i ] downto 1 do
33428: LD_ADDR_VAR 0 3
33432: PUSH
33433: DOUBLE
33434: LD_EXP 107
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: INC
33445: ST_TO_ADDR
33446: LD_INT 1
33448: PUSH
33449: FOR_DOWNTO
33450: IFFALSE 33798
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33452: LD_EXP 107
33456: PUSH
33457: LD_VAR 0 2
33461: ARRAY
33462: PUSH
33463: LD_VAR 0 3
33467: ARRAY
33468: PPUSH
33469: CALL_OW 301
33473: PUSH
33474: LD_EXP 107
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: PUSH
33485: LD_VAR 0 3
33489: ARRAY
33490: PPUSH
33491: CALL_OW 257
33495: PUSH
33496: LD_INT 1
33498: NONEQUAL
33499: OR
33500: IFFALSE 33563
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_EXP 107
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_EXP 107
33522: PUSH
33523: LD_VAR 0 2
33527: ARRAY
33528: PUSH
33529: LD_VAR 0 3
33533: ARRAY
33534: DIFF
33535: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33536: LD_ADDR_EXP 107
33540: PUSH
33541: LD_EXP 107
33545: PPUSH
33546: LD_VAR 0 2
33550: PPUSH
33551: LD_VAR 0 5
33555: PPUSH
33556: CALL_OW 1
33560: ST_TO_ADDR
// continue ;
33561: GO 33449
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33563: LD_EXP 107
33567: PUSH
33568: LD_VAR 0 2
33572: ARRAY
33573: PUSH
33574: LD_VAR 0 3
33578: ARRAY
33579: PPUSH
33580: CALL_OW 257
33584: PUSH
33585: LD_INT 1
33587: EQUAL
33588: PUSH
33589: LD_EXP 107
33593: PUSH
33594: LD_VAR 0 2
33598: ARRAY
33599: PUSH
33600: LD_VAR 0 3
33604: ARRAY
33605: PPUSH
33606: CALL_OW 459
33610: NOT
33611: AND
33612: PUSH
33613: LD_EXP 107
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PUSH
33624: LD_VAR 0 3
33628: ARRAY
33629: PPUSH
33630: CALL_OW 314
33634: NOT
33635: AND
33636: IFFALSE 33796
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33638: LD_EXP 107
33642: PUSH
33643: LD_VAR 0 2
33647: ARRAY
33648: PUSH
33649: LD_VAR 0 3
33653: ARRAY
33654: PPUSH
33655: CALL_OW 310
33659: IFFALSE 33682
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33661: LD_EXP 107
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_VAR 0 3
33676: ARRAY
33677: PPUSH
33678: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33682: LD_EXP 107
33686: PUSH
33687: LD_VAR 0 2
33691: ARRAY
33692: PUSH
33693: LD_VAR 0 3
33697: ARRAY
33698: PPUSH
33699: CALL_OW 314
33703: NOT
33704: IFFALSE 33796
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33706: LD_ADDR_VAR 0 7
33710: PUSH
33711: LD_INT 1
33713: PPUSH
33714: LD_EXP 106
33718: PUSH
33719: LD_VAR 0 2
33723: ARRAY
33724: PPUSH
33725: CALL_OW 12
33729: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33730: LD_EXP 107
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: PUSH
33741: LD_VAR 0 3
33745: ARRAY
33746: PPUSH
33747: LD_EXP 106
33751: PUSH
33752: LD_VAR 0 2
33756: ARRAY
33757: PUSH
33758: LD_VAR 0 7
33762: ARRAY
33763: PUSH
33764: LD_INT 1
33766: ARRAY
33767: PPUSH
33768: LD_EXP 106
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: LD_VAR 0 7
33783: ARRAY
33784: PUSH
33785: LD_INT 2
33787: ARRAY
33788: PPUSH
33789: LD_INT 0
33791: PPUSH
33792: CALL_OW 193
// end ; end ; end ;
33796: GO 33449
33798: POP
33799: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33800: LD_ADDR_VAR 0 5
33804: PUSH
33805: LD_EXP 93
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PPUSH
33816: LD_INT 2
33818: PUSH
33819: LD_INT 30
33821: PUSH
33822: LD_INT 4
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 30
33831: PUSH
33832: LD_INT 5
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 30
33841: PUSH
33842: LD_INT 32
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: PPUSH
33855: CALL_OW 72
33859: ST_TO_ADDR
// if not tmp then
33860: LD_VAR 0 5
33864: NOT
33865: IFFALSE 33869
// continue ;
33867: GO 33362
// list := [ ] ;
33869: LD_ADDR_VAR 0 6
33873: PUSH
33874: EMPTY
33875: ST_TO_ADDR
// for j in tmp do
33876: LD_ADDR_VAR 0 3
33880: PUSH
33881: LD_VAR 0 5
33885: PUSH
33886: FOR_IN
33887: IFFALSE 33956
// begin for k in UnitsInside ( j ) do
33889: LD_ADDR_VAR 0 4
33893: PUSH
33894: LD_VAR 0 3
33898: PPUSH
33899: CALL_OW 313
33903: PUSH
33904: FOR_IN
33905: IFFALSE 33952
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33907: LD_VAR 0 4
33911: PPUSH
33912: CALL_OW 257
33916: PUSH
33917: LD_INT 1
33919: EQUAL
33920: PUSH
33921: LD_VAR 0 4
33925: PPUSH
33926: CALL_OW 459
33930: NOT
33931: AND
33932: IFFALSE 33950
// list := list ^ k ;
33934: LD_ADDR_VAR 0 6
33938: PUSH
33939: LD_VAR 0 6
33943: PUSH
33944: LD_VAR 0 4
33948: ADD
33949: ST_TO_ADDR
33950: GO 33904
33952: POP
33953: POP
// end ;
33954: GO 33886
33956: POP
33957: POP
// list := list diff mc_miners [ i ] ;
33958: LD_ADDR_VAR 0 6
33962: PUSH
33963: LD_VAR 0 6
33967: PUSH
33968: LD_EXP 107
33972: PUSH
33973: LD_VAR 0 2
33977: ARRAY
33978: DIFF
33979: ST_TO_ADDR
// if not list then
33980: LD_VAR 0 6
33984: NOT
33985: IFFALSE 33989
// continue ;
33987: GO 33362
// k := mc_mines [ i ] - mc_miners [ i ] ;
33989: LD_ADDR_VAR 0 4
33993: PUSH
33994: LD_EXP 106
33998: PUSH
33999: LD_VAR 0 2
34003: ARRAY
34004: PUSH
34005: LD_EXP 107
34009: PUSH
34010: LD_VAR 0 2
34014: ARRAY
34015: MINUS
34016: ST_TO_ADDR
// if k > list then
34017: LD_VAR 0 4
34021: PUSH
34022: LD_VAR 0 6
34026: GREATER
34027: IFFALSE 34039
// k := list ;
34029: LD_ADDR_VAR 0 4
34033: PUSH
34034: LD_VAR 0 6
34038: ST_TO_ADDR
// for j = 1 to k do
34039: LD_ADDR_VAR 0 3
34043: PUSH
34044: DOUBLE
34045: LD_INT 1
34047: DEC
34048: ST_TO_ADDR
34049: LD_VAR 0 4
34053: PUSH
34054: FOR_TO
34055: IFFALSE 34109
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34057: LD_ADDR_EXP 107
34061: PUSH
34062: LD_EXP 107
34066: PPUSH
34067: LD_VAR 0 2
34071: PUSH
34072: LD_EXP 107
34076: PUSH
34077: LD_VAR 0 2
34081: ARRAY
34082: PUSH
34083: LD_INT 1
34085: PLUS
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PPUSH
34091: LD_VAR 0 6
34095: PUSH
34096: LD_VAR 0 3
34100: ARRAY
34101: PPUSH
34102: CALL 56474 0 3
34106: ST_TO_ADDR
34107: GO 34054
34109: POP
34110: POP
// end ;
34111: GO 33362
34113: POP
34114: POP
// end ;
34115: LD_VAR 0 1
34119: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34120: LD_INT 0
34122: PPUSH
34123: PPUSH
34124: PPUSH
34125: PPUSH
34126: PPUSH
34127: PPUSH
34128: PPUSH
34129: PPUSH
34130: PPUSH
34131: PPUSH
34132: PPUSH
// if not mc_bases then
34133: LD_EXP 93
34137: NOT
34138: IFFALSE 34142
// exit ;
34140: GO 35965
// for i = 1 to mc_bases do
34142: LD_ADDR_VAR 0 2
34146: PUSH
34147: DOUBLE
34148: LD_INT 1
34150: DEC
34151: ST_TO_ADDR
34152: LD_EXP 93
34156: PUSH
34157: FOR_TO
34158: IFFALSE 35963
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34160: LD_EXP 93
34164: PUSH
34165: LD_VAR 0 2
34169: ARRAY
34170: NOT
34171: PUSH
34172: LD_EXP 100
34176: PUSH
34177: LD_VAR 0 2
34181: ARRAY
34182: OR
34183: IFFALSE 34187
// continue ;
34185: GO 34157
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34187: LD_EXP 109
34191: PUSH
34192: LD_VAR 0 2
34196: ARRAY
34197: NOT
34198: PUSH
34199: LD_EXP 110
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: AND
34210: IFFALSE 34248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34212: LD_ADDR_EXP 110
34216: PUSH
34217: LD_EXP 110
34221: PPUSH
34222: LD_VAR 0 2
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34234: LD_VAR 0 2
34238: PPUSH
34239: LD_INT 107
34241: PPUSH
34242: CALL 25016 0 2
// continue ;
34246: GO 34157
// end ; target := [ ] ;
34248: LD_ADDR_VAR 0 7
34252: PUSH
34253: EMPTY
34254: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34255: LD_ADDR_VAR 0 6
34259: PUSH
34260: LD_EXP 93
34264: PUSH
34265: LD_VAR 0 2
34269: ARRAY
34270: PUSH
34271: LD_INT 1
34273: ARRAY
34274: PPUSH
34275: CALL_OW 255
34279: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34280: LD_ADDR_VAR 0 9
34284: PUSH
34285: LD_EXP 93
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PPUSH
34296: LD_INT 2
34298: PUSH
34299: LD_INT 30
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 30
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: LIST
34323: PPUSH
34324: CALL_OW 72
34328: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34329: LD_ADDR_VAR 0 3
34333: PUSH
34334: DOUBLE
34335: LD_EXP 109
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: INC
34346: ST_TO_ADDR
34347: LD_INT 1
34349: PUSH
34350: FOR_DOWNTO
34351: IFFALSE 34596
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34353: LD_EXP 109
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: PUSH
34364: LD_VAR 0 3
34368: ARRAY
34369: PUSH
34370: LD_INT 2
34372: ARRAY
34373: PPUSH
34374: LD_EXP 109
34378: PUSH
34379: LD_VAR 0 2
34383: ARRAY
34384: PUSH
34385: LD_VAR 0 3
34389: ARRAY
34390: PUSH
34391: LD_INT 3
34393: ARRAY
34394: PPUSH
34395: CALL_OW 488
34399: PUSH
34400: LD_EXP 109
34404: PUSH
34405: LD_VAR 0 2
34409: ARRAY
34410: PUSH
34411: LD_VAR 0 3
34415: ARRAY
34416: PUSH
34417: LD_INT 2
34419: ARRAY
34420: PPUSH
34421: LD_EXP 109
34425: PUSH
34426: LD_VAR 0 2
34430: ARRAY
34431: PUSH
34432: LD_VAR 0 3
34436: ARRAY
34437: PUSH
34438: LD_INT 3
34440: ARRAY
34441: PPUSH
34442: CALL_OW 284
34446: PUSH
34447: LD_INT 0
34449: EQUAL
34450: AND
34451: IFFALSE 34506
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34453: LD_ADDR_VAR 0 5
34457: PUSH
34458: LD_EXP 109
34462: PUSH
34463: LD_VAR 0 2
34467: ARRAY
34468: PPUSH
34469: LD_VAR 0 3
34473: PPUSH
34474: CALL_OW 3
34478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34479: LD_ADDR_EXP 109
34483: PUSH
34484: LD_EXP 109
34488: PPUSH
34489: LD_VAR 0 2
34493: PPUSH
34494: LD_VAR 0 5
34498: PPUSH
34499: CALL_OW 1
34503: ST_TO_ADDR
// continue ;
34504: GO 34350
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34506: LD_VAR 0 6
34510: PPUSH
34511: LD_EXP 109
34515: PUSH
34516: LD_VAR 0 2
34520: ARRAY
34521: PUSH
34522: LD_VAR 0 3
34526: ARRAY
34527: PUSH
34528: LD_INT 2
34530: ARRAY
34531: PPUSH
34532: LD_EXP 109
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_VAR 0 3
34547: ARRAY
34548: PUSH
34549: LD_INT 3
34551: ARRAY
34552: PPUSH
34553: LD_INT 30
34555: PPUSH
34556: CALL 57370 0 4
34560: PUSH
34561: LD_INT 4
34563: ARRAY
34564: PUSH
34565: LD_INT 0
34567: EQUAL
34568: IFFALSE 34594
// begin target := mc_crates [ i ] [ j ] ;
34570: LD_ADDR_VAR 0 7
34574: PUSH
34575: LD_EXP 109
34579: PUSH
34580: LD_VAR 0 2
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: ARRAY
34591: ST_TO_ADDR
// break ;
34592: GO 34596
// end ; end ;
34594: GO 34350
34596: POP
34597: POP
// if not target then
34598: LD_VAR 0 7
34602: NOT
34603: IFFALSE 34607
// continue ;
34605: GO 34157
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34607: LD_ADDR_VAR 0 8
34611: PUSH
34612: LD_EXP 112
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PPUSH
34623: LD_INT 2
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 58
34631: PUSH
34632: EMPTY
34633: LIST
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 61
34641: PUSH
34642: EMPTY
34643: LIST
34644: PUSH
34645: LD_INT 33
34647: PUSH
34648: LD_INT 5
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 33
34657: PUSH
34658: LD_INT 3
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 34
34677: PUSH
34678: LD_INT 32
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 34
34687: PUSH
34688: LD_INT 51
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 34
34697: PUSH
34698: LD_INT 12
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PPUSH
34715: CALL_OW 72
34719: ST_TO_ADDR
// if not cargo then
34720: LD_VAR 0 8
34724: NOT
34725: IFFALSE 35431
// begin if mc_crates_collector [ i ] < 5 then
34727: LD_EXP 110
34731: PUSH
34732: LD_VAR 0 2
34736: ARRAY
34737: PUSH
34738: LD_INT 5
34740: LESS
34741: IFFALSE 35107
// begin if mc_ape [ i ] then
34743: LD_EXP 122
34747: PUSH
34748: LD_VAR 0 2
34752: ARRAY
34753: IFFALSE 34800
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34755: LD_ADDR_VAR 0 5
34759: PUSH
34760: LD_EXP 122
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PPUSH
34771: LD_INT 25
34773: PUSH
34774: LD_INT 16
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 24
34783: PUSH
34784: LD_INT 750
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PPUSH
34795: CALL_OW 72
34799: ST_TO_ADDR
// if not tmp then
34800: LD_VAR 0 5
34804: NOT
34805: IFFALSE 34852
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34807: LD_ADDR_VAR 0 5
34811: PUSH
34812: LD_EXP 93
34816: PUSH
34817: LD_VAR 0 2
34821: ARRAY
34822: PPUSH
34823: LD_INT 25
34825: PUSH
34826: LD_INT 2
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 24
34835: PUSH
34836: LD_INT 750
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PPUSH
34847: CALL_OW 72
34851: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34852: LD_EXP 122
34856: PUSH
34857: LD_VAR 0 2
34861: ARRAY
34862: PUSH
34863: LD_EXP 93
34867: PUSH
34868: LD_VAR 0 2
34872: ARRAY
34873: PPUSH
34874: LD_INT 25
34876: PUSH
34877: LD_INT 2
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 24
34886: PUSH
34887: LD_INT 750
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PPUSH
34898: CALL_OW 72
34902: AND
34903: PUSH
34904: LD_VAR 0 5
34908: PUSH
34909: LD_INT 5
34911: LESS
34912: AND
34913: IFFALSE 34995
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34915: LD_ADDR_VAR 0 3
34919: PUSH
34920: LD_EXP 93
34924: PUSH
34925: LD_VAR 0 2
34929: ARRAY
34930: PPUSH
34931: LD_INT 25
34933: PUSH
34934: LD_INT 2
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 24
34943: PUSH
34944: LD_INT 750
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PPUSH
34955: CALL_OW 72
34959: PUSH
34960: FOR_IN
34961: IFFALSE 34993
// begin tmp := tmp union j ;
34963: LD_ADDR_VAR 0 5
34967: PUSH
34968: LD_VAR 0 5
34972: PUSH
34973: LD_VAR 0 3
34977: UNION
34978: ST_TO_ADDR
// if tmp >= 5 then
34979: LD_VAR 0 5
34983: PUSH
34984: LD_INT 5
34986: GREATEREQUAL
34987: IFFALSE 34991
// break ;
34989: GO 34993
// end ;
34991: GO 34960
34993: POP
34994: POP
// end ; if not tmp then
34995: LD_VAR 0 5
34999: NOT
35000: IFFALSE 35004
// continue ;
35002: GO 34157
// for j in tmp do
35004: LD_ADDR_VAR 0 3
35008: PUSH
35009: LD_VAR 0 5
35013: PUSH
35014: FOR_IN
35015: IFFALSE 35105
// if not GetTag ( j ) then
35017: LD_VAR 0 3
35021: PPUSH
35022: CALL_OW 110
35026: NOT
35027: IFFALSE 35103
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35029: LD_ADDR_EXP 110
35033: PUSH
35034: LD_EXP 110
35038: PPUSH
35039: LD_VAR 0 2
35043: PUSH
35044: LD_EXP 110
35048: PUSH
35049: LD_VAR 0 2
35053: ARRAY
35054: PUSH
35055: LD_INT 1
35057: PLUS
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PPUSH
35063: LD_VAR 0 3
35067: PPUSH
35068: CALL 56474 0 3
35072: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35073: LD_VAR 0 3
35077: PPUSH
35078: LD_INT 107
35080: PPUSH
35081: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35085: LD_EXP 110
35089: PUSH
35090: LD_VAR 0 2
35094: ARRAY
35095: PUSH
35096: LD_INT 5
35098: GREATEREQUAL
35099: IFFALSE 35103
// break ;
35101: GO 35105
// end ;
35103: GO 35014
35105: POP
35106: POP
// end ; if mc_crates_collector [ i ] and target then
35107: LD_EXP 110
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: PUSH
35118: LD_VAR 0 7
35122: AND
35123: IFFALSE 35429
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35125: LD_EXP 110
35129: PUSH
35130: LD_VAR 0 2
35134: ARRAY
35135: PUSH
35136: LD_VAR 0 7
35140: PUSH
35141: LD_INT 1
35143: ARRAY
35144: LESS
35145: IFFALSE 35165
// tmp := mc_crates_collector [ i ] else
35147: LD_ADDR_VAR 0 5
35151: PUSH
35152: LD_EXP 110
35156: PUSH
35157: LD_VAR 0 2
35161: ARRAY
35162: ST_TO_ADDR
35163: GO 35179
// tmp := target [ 1 ] ;
35165: LD_ADDR_VAR 0 5
35169: PUSH
35170: LD_VAR 0 7
35174: PUSH
35175: LD_INT 1
35177: ARRAY
35178: ST_TO_ADDR
// k := 0 ;
35179: LD_ADDR_VAR 0 4
35183: PUSH
35184: LD_INT 0
35186: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35187: LD_ADDR_VAR 0 3
35191: PUSH
35192: LD_EXP 110
35196: PUSH
35197: LD_VAR 0 2
35201: ARRAY
35202: PUSH
35203: FOR_IN
35204: IFFALSE 35427
// begin k := k + 1 ;
35206: LD_ADDR_VAR 0 4
35210: PUSH
35211: LD_VAR 0 4
35215: PUSH
35216: LD_INT 1
35218: PLUS
35219: ST_TO_ADDR
// if k > tmp then
35220: LD_VAR 0 4
35224: PUSH
35225: LD_VAR 0 5
35229: GREATER
35230: IFFALSE 35234
// break ;
35232: GO 35427
// if not GetClass ( j ) in [ 2 , 16 ] then
35234: LD_VAR 0 3
35238: PPUSH
35239: CALL_OW 257
35243: PUSH
35244: LD_INT 2
35246: PUSH
35247: LD_INT 16
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: IN
35254: NOT
35255: IFFALSE 35308
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35257: LD_ADDR_EXP 110
35261: PUSH
35262: LD_EXP 110
35266: PPUSH
35267: LD_VAR 0 2
35271: PPUSH
35272: LD_EXP 110
35276: PUSH
35277: LD_VAR 0 2
35281: ARRAY
35282: PUSH
35283: LD_VAR 0 3
35287: DIFF
35288: PPUSH
35289: CALL_OW 1
35293: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35294: LD_VAR 0 3
35298: PPUSH
35299: LD_INT 0
35301: PPUSH
35302: CALL_OW 109
// continue ;
35306: GO 35203
// end ; if IsInUnit ( j ) then
35308: LD_VAR 0 3
35312: PPUSH
35313: CALL_OW 310
35317: IFFALSE 35328
// ComExitBuilding ( j ) ;
35319: LD_VAR 0 3
35323: PPUSH
35324: CALL_OW 122
// wait ( 3 ) ;
35328: LD_INT 3
35330: PPUSH
35331: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35335: LD_VAR 0 3
35339: PPUSH
35340: CALL_OW 314
35344: PUSH
35345: LD_VAR 0 6
35349: PPUSH
35350: LD_VAR 0 7
35354: PUSH
35355: LD_INT 2
35357: ARRAY
35358: PPUSH
35359: LD_VAR 0 7
35363: PUSH
35364: LD_INT 3
35366: ARRAY
35367: PPUSH
35368: LD_INT 30
35370: PPUSH
35371: CALL 57370 0 4
35375: PUSH
35376: LD_INT 4
35378: ARRAY
35379: AND
35380: IFFALSE 35398
// ComStandNearbyBuilding ( j , depot ) else
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_VAR 0 9
35391: PPUSH
35392: CALL 53052 0 2
35396: GO 35425
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_VAR 0 7
35407: PUSH
35408: LD_INT 2
35410: ARRAY
35411: PPUSH
35412: LD_VAR 0 7
35416: PUSH
35417: LD_INT 3
35419: ARRAY
35420: PPUSH
35421: CALL_OW 117
// end ;
35425: GO 35203
35427: POP
35428: POP
// end ; end else
35429: GO 35961
// begin for j in cargo do
35431: LD_ADDR_VAR 0 3
35435: PUSH
35436: LD_VAR 0 8
35440: PUSH
35441: FOR_IN
35442: IFFALSE 35959
// begin if GetTag ( j ) <> 0 then
35444: LD_VAR 0 3
35448: PPUSH
35449: CALL_OW 110
35453: PUSH
35454: LD_INT 0
35456: NONEQUAL
35457: IFFALSE 35461
// continue ;
35459: GO 35441
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35461: LD_VAR 0 3
35465: PPUSH
35466: CALL_OW 256
35470: PUSH
35471: LD_INT 1000
35473: LESS
35474: PUSH
35475: LD_VAR 0 3
35479: PPUSH
35480: LD_EXP 117
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PPUSH
35491: CALL_OW 308
35495: NOT
35496: AND
35497: IFFALSE 35519
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35499: LD_VAR 0 3
35503: PPUSH
35504: LD_EXP 117
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PPUSH
35515: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 256
35528: PUSH
35529: LD_INT 1000
35531: LESS
35532: PUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: LD_EXP 117
35542: PUSH
35543: LD_VAR 0 2
35547: ARRAY
35548: PPUSH
35549: CALL_OW 308
35553: AND
35554: IFFALSE 35558
// continue ;
35556: GO 35441
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35558: LD_VAR 0 3
35562: PPUSH
35563: CALL_OW 262
35567: PUSH
35568: LD_INT 2
35570: EQUAL
35571: PUSH
35572: LD_VAR 0 3
35576: PPUSH
35577: CALL_OW 261
35581: PUSH
35582: LD_INT 15
35584: LESS
35585: AND
35586: IFFALSE 35590
// continue ;
35588: GO 35441
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35590: LD_VAR 0 3
35594: PPUSH
35595: CALL_OW 262
35599: PUSH
35600: LD_INT 1
35602: EQUAL
35603: PUSH
35604: LD_VAR 0 3
35608: PPUSH
35609: CALL_OW 261
35613: PUSH
35614: LD_INT 10
35616: LESS
35617: AND
35618: IFFALSE 35898
// begin if not depot then
35620: LD_VAR 0 9
35624: NOT
35625: IFFALSE 35629
// continue ;
35627: GO 35441
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35629: LD_VAR 0 3
35633: PPUSH
35634: LD_VAR 0 9
35638: PPUSH
35639: LD_VAR 0 3
35643: PPUSH
35644: CALL_OW 74
35648: PPUSH
35649: CALL_OW 296
35653: PUSH
35654: LD_INT 6
35656: LESS
35657: IFFALSE 35673
// SetFuel ( j , 100 ) else
35659: LD_VAR 0 3
35663: PPUSH
35664: LD_INT 100
35666: PPUSH
35667: CALL_OW 240
35671: GO 35898
// if GetFuel ( j ) = 0 then
35673: LD_VAR 0 3
35677: PPUSH
35678: CALL_OW 261
35682: PUSH
35683: LD_INT 0
35685: EQUAL
35686: IFFALSE 35898
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35688: LD_ADDR_EXP 112
35692: PUSH
35693: LD_EXP 112
35697: PPUSH
35698: LD_VAR 0 2
35702: PPUSH
35703: LD_EXP 112
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_VAR 0 3
35718: DIFF
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35725: LD_VAR 0 3
35729: PPUSH
35730: CALL_OW 263
35734: PUSH
35735: LD_INT 1
35737: EQUAL
35738: IFFALSE 35754
// ComExitVehicle ( IsInUnit ( j ) ) ;
35740: LD_VAR 0 3
35744: PPUSH
35745: CALL_OW 310
35749: PPUSH
35750: CALL_OW 121
// if GetControl ( j ) = control_remote then
35754: LD_VAR 0 3
35758: PPUSH
35759: CALL_OW 263
35763: PUSH
35764: LD_INT 2
35766: EQUAL
35767: IFFALSE 35778
// ComUnlink ( j ) ;
35769: LD_VAR 0 3
35773: PPUSH
35774: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35778: LD_ADDR_VAR 0 10
35782: PUSH
35783: LD_VAR 0 2
35787: PPUSH
35788: LD_INT 3
35790: PPUSH
35791: CALL 45537 0 2
35795: ST_TO_ADDR
// if fac then
35796: LD_VAR 0 10
35800: IFFALSE 35896
// begin for k in fac do
35802: LD_ADDR_VAR 0 4
35806: PUSH
35807: LD_VAR 0 10
35811: PUSH
35812: FOR_IN
35813: IFFALSE 35894
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35815: LD_ADDR_VAR 0 11
35819: PUSH
35820: LD_VAR 0 10
35824: PPUSH
35825: LD_VAR 0 3
35829: PPUSH
35830: CALL_OW 265
35834: PPUSH
35835: LD_VAR 0 3
35839: PPUSH
35840: CALL_OW 262
35844: PPUSH
35845: LD_VAR 0 3
35849: PPUSH
35850: CALL_OW 263
35854: PPUSH
35855: LD_VAR 0 3
35859: PPUSH
35860: CALL_OW 264
35864: PPUSH
35865: CALL 53970 0 5
35869: ST_TO_ADDR
// if components then
35870: LD_VAR 0 11
35874: IFFALSE 35892
// begin MC_InsertProduceList ( i , components ) ;
35876: LD_VAR 0 2
35880: PPUSH
35881: LD_VAR 0 11
35885: PPUSH
35886: CALL 45082 0 2
// break ;
35890: GO 35894
// end ; end ;
35892: GO 35812
35894: POP
35895: POP
// end ; continue ;
35896: GO 35441
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_INT 1
35905: PPUSH
35906: CALL_OW 289
35910: PUSH
35911: LD_INT 100
35913: LESS
35914: PUSH
35915: LD_VAR 0 3
35919: PPUSH
35920: CALL_OW 314
35924: NOT
35925: AND
35926: IFFALSE 35955
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35928: LD_VAR 0 3
35932: PPUSH
35933: LD_VAR 0 7
35937: PUSH
35938: LD_INT 2
35940: ARRAY
35941: PPUSH
35942: LD_VAR 0 7
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL_OW 117
// break ;
35955: GO 35959
// end ;
35957: GO 35441
35959: POP
35960: POP
// end ; end ;
35961: GO 34157
35963: POP
35964: POP
// end ;
35965: LD_VAR 0 1
35969: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35970: LD_INT 0
35972: PPUSH
35973: PPUSH
35974: PPUSH
35975: PPUSH
// if not mc_bases then
35976: LD_EXP 93
35980: NOT
35981: IFFALSE 35985
// exit ;
35983: GO 36146
// for i = 1 to mc_bases do
35985: LD_ADDR_VAR 0 2
35989: PUSH
35990: DOUBLE
35991: LD_INT 1
35993: DEC
35994: ST_TO_ADDR
35995: LD_EXP 93
35999: PUSH
36000: FOR_TO
36001: IFFALSE 36144
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36003: LD_ADDR_VAR 0 4
36007: PUSH
36008: LD_EXP 112
36012: PUSH
36013: LD_VAR 0 2
36017: ARRAY
36018: PUSH
36019: LD_EXP 115
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: UNION
36030: PPUSH
36031: LD_INT 33
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PPUSH
36041: CALL_OW 72
36045: ST_TO_ADDR
// if tmp then
36046: LD_VAR 0 4
36050: IFFALSE 36142
// for j in tmp do
36052: LD_ADDR_VAR 0 3
36056: PUSH
36057: LD_VAR 0 4
36061: PUSH
36062: FOR_IN
36063: IFFALSE 36140
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36065: LD_VAR 0 3
36069: PPUSH
36070: CALL_OW 312
36074: NOT
36075: PUSH
36076: LD_VAR 0 3
36080: PPUSH
36081: CALL_OW 256
36085: PUSH
36086: LD_INT 250
36088: GREATEREQUAL
36089: AND
36090: IFFALSE 36103
// Connect ( j ) else
36092: LD_VAR 0 3
36096: PPUSH
36097: CALL 59445 0 1
36101: GO 36138
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL_OW 256
36112: PUSH
36113: LD_INT 250
36115: LESS
36116: PUSH
36117: LD_VAR 0 3
36121: PPUSH
36122: CALL_OW 312
36126: AND
36127: IFFALSE 36138
// ComUnlink ( j ) ;
36129: LD_VAR 0 3
36133: PPUSH
36134: CALL_OW 136
36138: GO 36062
36140: POP
36141: POP
// end ;
36142: GO 36000
36144: POP
36145: POP
// end ;
36146: LD_VAR 0 1
36150: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36151: LD_INT 0
36153: PPUSH
36154: PPUSH
36155: PPUSH
36156: PPUSH
36157: PPUSH
// if not mc_bases then
36158: LD_EXP 93
36162: NOT
36163: IFFALSE 36167
// exit ;
36165: GO 36612
// for i = 1 to mc_bases do
36167: LD_ADDR_VAR 0 2
36171: PUSH
36172: DOUBLE
36173: LD_INT 1
36175: DEC
36176: ST_TO_ADDR
36177: LD_EXP 93
36181: PUSH
36182: FOR_TO
36183: IFFALSE 36610
// begin if not mc_produce [ i ] then
36185: LD_EXP 114
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: NOT
36196: IFFALSE 36200
// continue ;
36198: GO 36182
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36200: LD_ADDR_VAR 0 5
36204: PUSH
36205: LD_EXP 93
36209: PUSH
36210: LD_VAR 0 2
36214: ARRAY
36215: PPUSH
36216: LD_INT 30
36218: PUSH
36219: LD_INT 3
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PPUSH
36226: CALL_OW 72
36230: ST_TO_ADDR
// if not fac then
36231: LD_VAR 0 5
36235: NOT
36236: IFFALSE 36240
// continue ;
36238: GO 36182
// for j in fac do
36240: LD_ADDR_VAR 0 3
36244: PUSH
36245: LD_VAR 0 5
36249: PUSH
36250: FOR_IN
36251: IFFALSE 36606
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36253: LD_VAR 0 3
36257: PPUSH
36258: CALL_OW 461
36262: PUSH
36263: LD_INT 2
36265: NONEQUAL
36266: PUSH
36267: LD_VAR 0 3
36271: PPUSH
36272: LD_INT 15
36274: PPUSH
36275: CALL 59073 0 2
36279: PUSH
36280: LD_INT 4
36282: ARRAY
36283: OR
36284: IFFALSE 36288
// continue ;
36286: GO 36250
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36288: LD_VAR 0 3
36292: PPUSH
36293: LD_EXP 114
36297: PUSH
36298: LD_VAR 0 2
36302: ARRAY
36303: PUSH
36304: LD_INT 1
36306: ARRAY
36307: PUSH
36308: LD_INT 1
36310: ARRAY
36311: PPUSH
36312: LD_EXP 114
36316: PUSH
36317: LD_VAR 0 2
36321: ARRAY
36322: PUSH
36323: LD_INT 1
36325: ARRAY
36326: PUSH
36327: LD_INT 2
36329: ARRAY
36330: PPUSH
36331: LD_EXP 114
36335: PUSH
36336: LD_VAR 0 2
36340: ARRAY
36341: PUSH
36342: LD_INT 1
36344: ARRAY
36345: PUSH
36346: LD_INT 3
36348: ARRAY
36349: PPUSH
36350: LD_EXP 114
36354: PUSH
36355: LD_VAR 0 2
36359: ARRAY
36360: PUSH
36361: LD_INT 1
36363: ARRAY
36364: PUSH
36365: LD_INT 4
36367: ARRAY
36368: PPUSH
36369: CALL_OW 448
36373: PUSH
36374: LD_VAR 0 3
36378: PPUSH
36379: LD_EXP 114
36383: PUSH
36384: LD_VAR 0 2
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: PUSH
36394: LD_INT 1
36396: ARRAY
36397: PUSH
36398: LD_EXP 114
36402: PUSH
36403: LD_VAR 0 2
36407: ARRAY
36408: PUSH
36409: LD_INT 1
36411: ARRAY
36412: PUSH
36413: LD_INT 2
36415: ARRAY
36416: PUSH
36417: LD_EXP 114
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PUSH
36428: LD_INT 1
36430: ARRAY
36431: PUSH
36432: LD_INT 3
36434: ARRAY
36435: PUSH
36436: LD_EXP 114
36440: PUSH
36441: LD_VAR 0 2
36445: ARRAY
36446: PUSH
36447: LD_INT 1
36449: ARRAY
36450: PUSH
36451: LD_INT 4
36453: ARRAY
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: PPUSH
36461: CALL 62840 0 2
36465: AND
36466: IFFALSE 36604
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36468: LD_VAR 0 3
36472: PPUSH
36473: LD_EXP 114
36477: PUSH
36478: LD_VAR 0 2
36482: ARRAY
36483: PUSH
36484: LD_INT 1
36486: ARRAY
36487: PUSH
36488: LD_INT 1
36490: ARRAY
36491: PPUSH
36492: LD_EXP 114
36496: PUSH
36497: LD_VAR 0 2
36501: ARRAY
36502: PUSH
36503: LD_INT 1
36505: ARRAY
36506: PUSH
36507: LD_INT 2
36509: ARRAY
36510: PPUSH
36511: LD_EXP 114
36515: PUSH
36516: LD_VAR 0 2
36520: ARRAY
36521: PUSH
36522: LD_INT 1
36524: ARRAY
36525: PUSH
36526: LD_INT 3
36528: ARRAY
36529: PPUSH
36530: LD_EXP 114
36534: PUSH
36535: LD_VAR 0 2
36539: ARRAY
36540: PUSH
36541: LD_INT 1
36543: ARRAY
36544: PUSH
36545: LD_INT 4
36547: ARRAY
36548: PPUSH
36549: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36553: LD_ADDR_VAR 0 4
36557: PUSH
36558: LD_EXP 114
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PPUSH
36569: LD_INT 1
36571: PPUSH
36572: CALL_OW 3
36576: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36577: LD_ADDR_EXP 114
36581: PUSH
36582: LD_EXP 114
36586: PPUSH
36587: LD_VAR 0 2
36591: PPUSH
36592: LD_VAR 0 4
36596: PPUSH
36597: CALL_OW 1
36601: ST_TO_ADDR
// break ;
36602: GO 36606
// end ; end ;
36604: GO 36250
36606: POP
36607: POP
// end ;
36608: GO 36182
36610: POP
36611: POP
// end ;
36612: LD_VAR 0 1
36616: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36617: LD_INT 0
36619: PPUSH
36620: PPUSH
36621: PPUSH
// if not mc_bases then
36622: LD_EXP 93
36626: NOT
36627: IFFALSE 36631
// exit ;
36629: GO 36720
// for i = 1 to mc_bases do
36631: LD_ADDR_VAR 0 2
36635: PUSH
36636: DOUBLE
36637: LD_INT 1
36639: DEC
36640: ST_TO_ADDR
36641: LD_EXP 93
36645: PUSH
36646: FOR_TO
36647: IFFALSE 36718
// begin if mc_attack [ i ] then
36649: LD_EXP 113
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: IFFALSE 36716
// begin tmp := mc_attack [ i ] [ 1 ] ;
36661: LD_ADDR_VAR 0 3
36665: PUSH
36666: LD_EXP 113
36670: PUSH
36671: LD_VAR 0 2
36675: ARRAY
36676: PUSH
36677: LD_INT 1
36679: ARRAY
36680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36681: LD_ADDR_EXP 113
36685: PUSH
36686: LD_EXP 113
36690: PPUSH
36691: LD_VAR 0 2
36695: PPUSH
36696: EMPTY
36697: PPUSH
36698: CALL_OW 1
36702: ST_TO_ADDR
// Attack ( tmp ) ;
36703: LD_VAR 0 3
36707: PPUSH
36708: CALL 108833 0 1
// exit ;
36712: POP
36713: POP
36714: GO 36720
// end ; end ;
36716: GO 36646
36718: POP
36719: POP
// end ;
36720: LD_VAR 0 1
36724: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36725: LD_INT 0
36727: PPUSH
36728: PPUSH
36729: PPUSH
36730: PPUSH
36731: PPUSH
36732: PPUSH
36733: PPUSH
// if not mc_bases then
36734: LD_EXP 93
36738: NOT
36739: IFFALSE 36743
// exit ;
36741: GO 37600
// for i = 1 to mc_bases do
36743: LD_ADDR_VAR 0 2
36747: PUSH
36748: DOUBLE
36749: LD_INT 1
36751: DEC
36752: ST_TO_ADDR
36753: LD_EXP 93
36757: PUSH
36758: FOR_TO
36759: IFFALSE 37598
// begin if not mc_bases [ i ] then
36761: LD_EXP 93
36765: PUSH
36766: LD_VAR 0 2
36770: ARRAY
36771: NOT
36772: IFFALSE 36776
// continue ;
36774: GO 36758
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36776: LD_ADDR_VAR 0 7
36780: PUSH
36781: LD_EXP 93
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: PUSH
36792: LD_INT 1
36794: ARRAY
36795: PPUSH
36796: CALL 53274 0 1
36800: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36801: LD_ADDR_EXP 116
36805: PUSH
36806: LD_EXP 116
36810: PPUSH
36811: LD_VAR 0 2
36815: PPUSH
36816: LD_EXP 93
36820: PUSH
36821: LD_VAR 0 2
36825: ARRAY
36826: PUSH
36827: LD_INT 1
36829: ARRAY
36830: PPUSH
36831: CALL_OW 255
36835: PPUSH
36836: LD_EXP 118
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: PPUSH
36847: CALL 53239 0 2
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// if not mc_scan [ i ] then
36857: LD_EXP 116
36861: PUSH
36862: LD_VAR 0 2
36866: ARRAY
36867: NOT
36868: IFFALSE 37046
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36870: LD_ADDR_EXP 136
36874: PUSH
36875: LD_EXP 136
36879: PPUSH
36880: LD_VAR 0 2
36884: PPUSH
36885: LD_INT 0
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36893: LD_ADDR_VAR 0 4
36897: PUSH
36898: LD_EXP 93
36902: PUSH
36903: LD_VAR 0 2
36907: ARRAY
36908: PPUSH
36909: LD_INT 2
36911: PUSH
36912: LD_INT 25
36914: PUSH
36915: LD_INT 5
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 25
36924: PUSH
36925: LD_INT 8
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 25
36934: PUSH
36935: LD_INT 9
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: PPUSH
36948: CALL_OW 72
36952: ST_TO_ADDR
// if not tmp then
36953: LD_VAR 0 4
36957: NOT
36958: IFFALSE 36962
// continue ;
36960: GO 36758
// for j in tmp do
36962: LD_ADDR_VAR 0 3
36966: PUSH
36967: LD_VAR 0 4
36971: PUSH
36972: FOR_IN
36973: IFFALSE 37044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36975: LD_VAR 0 3
36979: PPUSH
36980: CALL_OW 310
36984: PPUSH
36985: CALL_OW 266
36989: PUSH
36990: LD_INT 5
36992: EQUAL
36993: PUSH
36994: LD_VAR 0 3
36998: PPUSH
36999: CALL_OW 257
37003: PUSH
37004: LD_INT 1
37006: EQUAL
37007: AND
37008: PUSH
37009: LD_VAR 0 3
37013: PPUSH
37014: CALL_OW 459
37018: NOT
37019: AND
37020: PUSH
37021: LD_VAR 0 7
37025: AND
37026: IFFALSE 37042
// ComChangeProfession ( j , class ) ;
37028: LD_VAR 0 3
37032: PPUSH
37033: LD_VAR 0 7
37037: PPUSH
37038: CALL_OW 123
37042: GO 36972
37044: POP
37045: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37046: LD_EXP 116
37050: PUSH
37051: LD_VAR 0 2
37055: ARRAY
37056: PUSH
37057: LD_EXP 136
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: NOT
37068: AND
37069: PUSH
37070: LD_EXP 115
37074: PUSH
37075: LD_VAR 0 2
37079: ARRAY
37080: NOT
37081: AND
37082: PUSH
37083: LD_EXP 93
37087: PUSH
37088: LD_VAR 0 2
37092: ARRAY
37093: PPUSH
37094: LD_INT 50
37096: PUSH
37097: EMPTY
37098: LIST
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: LD_INT 30
37105: PUSH
37106: LD_INT 32
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 30
37115: PUSH
37116: LD_INT 33
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 30
37125: PUSH
37126: LD_INT 4
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 30
37135: PUSH
37136: LD_INT 5
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PPUSH
37154: CALL_OW 72
37158: PUSH
37159: LD_INT 4
37161: LESS
37162: PUSH
37163: LD_EXP 93
37167: PUSH
37168: LD_VAR 0 2
37172: ARRAY
37173: PPUSH
37174: LD_INT 3
37176: PUSH
37177: LD_INT 24
37179: PUSH
37180: LD_INT 1000
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 2
37193: PUSH
37194: LD_INT 30
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PPUSH
37223: CALL_OW 72
37227: OR
37228: AND
37229: IFFALSE 37480
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37231: LD_ADDR_EXP 136
37235: PUSH
37236: LD_EXP 136
37240: PPUSH
37241: LD_VAR 0 2
37245: PPUSH
37246: LD_INT 1
37248: PPUSH
37249: CALL_OW 1
37253: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37254: LD_ADDR_VAR 0 4
37258: PUSH
37259: LD_EXP 93
37263: PUSH
37264: LD_VAR 0 2
37268: ARRAY
37269: PPUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 25
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 25
37285: PUSH
37286: LD_INT 5
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 25
37295: PUSH
37296: LD_INT 8
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 25
37305: PUSH
37306: LD_INT 9
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: PPUSH
37320: CALL_OW 72
37324: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37325: LD_ADDR_VAR 0 4
37329: PUSH
37330: LD_VAR 0 4
37334: PUSH
37335: LD_VAR 0 4
37339: PPUSH
37340: LD_INT 18
37342: PPUSH
37343: CALL 85743 0 2
37347: DIFF
37348: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37349: LD_VAR 0 4
37353: NOT
37354: PUSH
37355: LD_EXP 93
37359: PUSH
37360: LD_VAR 0 2
37364: ARRAY
37365: PPUSH
37366: LD_INT 2
37368: PUSH
37369: LD_INT 30
37371: PUSH
37372: LD_INT 4
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 30
37381: PUSH
37382: LD_INT 5
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: PPUSH
37394: CALL_OW 72
37398: NOT
37399: AND
37400: IFFALSE 37462
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37402: LD_ADDR_VAR 0 4
37406: PUSH
37407: LD_EXP 93
37411: PUSH
37412: LD_VAR 0 2
37416: ARRAY
37417: PPUSH
37418: LD_INT 2
37420: PUSH
37421: LD_INT 25
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 25
37433: PUSH
37434: LD_INT 3
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 25
37443: PUSH
37444: LD_INT 4
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: PPUSH
37457: CALL_OW 72
37461: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37462: LD_VAR 0 2
37466: PPUSH
37467: LD_VAR 0 4
37471: PPUSH
37472: CALL 113542 0 2
// exit ;
37476: POP
37477: POP
37478: GO 37600
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37480: LD_EXP 116
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: PUSH
37491: LD_EXP 136
37495: PUSH
37496: LD_VAR 0 2
37500: ARRAY
37501: NOT
37502: AND
37503: PUSH
37504: LD_EXP 115
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: AND
37515: IFFALSE 37596
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37517: LD_ADDR_EXP 136
37521: PUSH
37522: LD_EXP 136
37526: PPUSH
37527: LD_VAR 0 2
37531: PPUSH
37532: LD_INT 1
37534: PPUSH
37535: CALL_OW 1
37539: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37540: LD_ADDR_VAR 0 4
37544: PUSH
37545: LD_EXP 115
37549: PUSH
37550: LD_VAR 0 2
37554: ARRAY
37555: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37556: LD_ADDR_EXP 115
37560: PUSH
37561: LD_EXP 115
37565: PPUSH
37566: LD_VAR 0 2
37570: PPUSH
37571: EMPTY
37572: PPUSH
37573: CALL_OW 1
37577: ST_TO_ADDR
// Defend ( i , tmp ) ;
37578: LD_VAR 0 2
37582: PPUSH
37583: LD_VAR 0 4
37587: PPUSH
37588: CALL 114138 0 2
// exit ;
37592: POP
37593: POP
37594: GO 37600
// end ; end ;
37596: GO 36758
37598: POP
37599: POP
// end ;
37600: LD_VAR 0 1
37604: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37605: LD_INT 0
37607: PPUSH
37608: PPUSH
37609: PPUSH
37610: PPUSH
37611: PPUSH
37612: PPUSH
37613: PPUSH
37614: PPUSH
37615: PPUSH
37616: PPUSH
37617: PPUSH
// if not mc_bases then
37618: LD_EXP 93
37622: NOT
37623: IFFALSE 37627
// exit ;
37625: GO 38714
// for i = 1 to mc_bases do
37627: LD_ADDR_VAR 0 2
37631: PUSH
37632: DOUBLE
37633: LD_INT 1
37635: DEC
37636: ST_TO_ADDR
37637: LD_EXP 93
37641: PUSH
37642: FOR_TO
37643: IFFALSE 38712
// begin tmp := mc_lab [ i ] ;
37645: LD_ADDR_VAR 0 6
37649: PUSH
37650: LD_EXP 126
37654: PUSH
37655: LD_VAR 0 2
37659: ARRAY
37660: ST_TO_ADDR
// if not tmp then
37661: LD_VAR 0 6
37665: NOT
37666: IFFALSE 37670
// continue ;
37668: GO 37642
// idle_lab := 0 ;
37670: LD_ADDR_VAR 0 11
37674: PUSH
37675: LD_INT 0
37677: ST_TO_ADDR
// for j in tmp do
37678: LD_ADDR_VAR 0 3
37682: PUSH
37683: LD_VAR 0 6
37687: PUSH
37688: FOR_IN
37689: IFFALSE 38708
// begin researching := false ;
37691: LD_ADDR_VAR 0 10
37695: PUSH
37696: LD_INT 0
37698: ST_TO_ADDR
// side := GetSide ( j ) ;
37699: LD_ADDR_VAR 0 4
37703: PUSH
37704: LD_VAR 0 3
37708: PPUSH
37709: CALL_OW 255
37713: ST_TO_ADDR
// if not mc_tech [ side ] then
37714: LD_EXP 120
37718: PUSH
37719: LD_VAR 0 4
37723: ARRAY
37724: NOT
37725: IFFALSE 37729
// continue ;
37727: GO 37688
// if BuildingStatus ( j ) = bs_idle then
37729: LD_VAR 0 3
37733: PPUSH
37734: CALL_OW 461
37738: PUSH
37739: LD_INT 2
37741: EQUAL
37742: IFFALSE 37930
// begin if idle_lab and UnitsInside ( j ) < 6 then
37744: LD_VAR 0 11
37748: PUSH
37749: LD_VAR 0 3
37753: PPUSH
37754: CALL_OW 313
37758: PUSH
37759: LD_INT 6
37761: LESS
37762: AND
37763: IFFALSE 37834
// begin tmp2 := UnitsInside ( idle_lab ) ;
37765: LD_ADDR_VAR 0 9
37769: PUSH
37770: LD_VAR 0 11
37774: PPUSH
37775: CALL_OW 313
37779: ST_TO_ADDR
// if tmp2 then
37780: LD_VAR 0 9
37784: IFFALSE 37826
// for x in tmp2 do
37786: LD_ADDR_VAR 0 7
37790: PUSH
37791: LD_VAR 0 9
37795: PUSH
37796: FOR_IN
37797: IFFALSE 37824
// begin ComExitBuilding ( x ) ;
37799: LD_VAR 0 7
37803: PPUSH
37804: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37808: LD_VAR 0 7
37812: PPUSH
37813: LD_VAR 0 3
37817: PPUSH
37818: CALL_OW 180
// end ;
37822: GO 37796
37824: POP
37825: POP
// idle_lab := 0 ;
37826: LD_ADDR_VAR 0 11
37830: PUSH
37831: LD_INT 0
37833: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37834: LD_ADDR_VAR 0 5
37838: PUSH
37839: LD_EXP 120
37843: PUSH
37844: LD_VAR 0 4
37848: ARRAY
37849: PUSH
37850: FOR_IN
37851: IFFALSE 37911
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37853: LD_VAR 0 3
37857: PPUSH
37858: LD_VAR 0 5
37862: PPUSH
37863: CALL_OW 430
37867: PUSH
37868: LD_VAR 0 4
37872: PPUSH
37873: LD_VAR 0 5
37877: PPUSH
37878: CALL 52344 0 2
37882: AND
37883: IFFALSE 37909
// begin researching := true ;
37885: LD_ADDR_VAR 0 10
37889: PUSH
37890: LD_INT 1
37892: ST_TO_ADDR
// ComResearch ( j , t ) ;
37893: LD_VAR 0 3
37897: PPUSH
37898: LD_VAR 0 5
37902: PPUSH
37903: CALL_OW 124
// break ;
37907: GO 37911
// end ;
37909: GO 37850
37911: POP
37912: POP
// if not researching then
37913: LD_VAR 0 10
37917: NOT
37918: IFFALSE 37930
// idle_lab := j ;
37920: LD_ADDR_VAR 0 11
37924: PUSH
37925: LD_VAR 0 3
37929: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37930: LD_VAR 0 3
37934: PPUSH
37935: CALL_OW 461
37939: PUSH
37940: LD_INT 10
37942: EQUAL
37943: IFFALSE 38531
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37945: LD_EXP 122
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: NOT
37956: PUSH
37957: LD_EXP 123
37961: PUSH
37962: LD_VAR 0 2
37966: ARRAY
37967: NOT
37968: AND
37969: PUSH
37970: LD_EXP 120
37974: PUSH
37975: LD_VAR 0 4
37979: ARRAY
37980: PUSH
37981: LD_INT 1
37983: GREATER
37984: AND
37985: IFFALSE 38116
// begin ComCancel ( j ) ;
37987: LD_VAR 0 3
37991: PPUSH
37992: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37996: LD_ADDR_EXP 120
38000: PUSH
38001: LD_EXP 120
38005: PPUSH
38006: LD_VAR 0 4
38010: PPUSH
38011: LD_EXP 120
38015: PUSH
38016: LD_VAR 0 4
38020: ARRAY
38021: PPUSH
38022: LD_EXP 120
38026: PUSH
38027: LD_VAR 0 4
38031: ARRAY
38032: PUSH
38033: LD_INT 1
38035: MINUS
38036: PPUSH
38037: LD_EXP 120
38041: PUSH
38042: LD_VAR 0 4
38046: ARRAY
38047: PPUSH
38048: LD_INT 0
38050: PPUSH
38051: CALL 55892 0 4
38055: PPUSH
38056: CALL_OW 1
38060: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38061: LD_ADDR_EXP 120
38065: PUSH
38066: LD_EXP 120
38070: PPUSH
38071: LD_VAR 0 4
38075: PPUSH
38076: LD_EXP 120
38080: PUSH
38081: LD_VAR 0 4
38085: ARRAY
38086: PPUSH
38087: LD_EXP 120
38091: PUSH
38092: LD_VAR 0 4
38096: ARRAY
38097: PPUSH
38098: LD_INT 1
38100: PPUSH
38101: LD_INT 0
38103: PPUSH
38104: CALL 55892 0 4
38108: PPUSH
38109: CALL_OW 1
38113: ST_TO_ADDR
// continue ;
38114: GO 37688
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38116: LD_EXP 122
38120: PUSH
38121: LD_VAR 0 2
38125: ARRAY
38126: PUSH
38127: LD_EXP 123
38131: PUSH
38132: LD_VAR 0 2
38136: ARRAY
38137: NOT
38138: AND
38139: IFFALSE 38266
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38141: LD_ADDR_EXP 123
38145: PUSH
38146: LD_EXP 123
38150: PPUSH
38151: LD_VAR 0 2
38155: PUSH
38156: LD_EXP 123
38160: PUSH
38161: LD_VAR 0 2
38165: ARRAY
38166: PUSH
38167: LD_INT 1
38169: PLUS
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PPUSH
38175: LD_EXP 122
38179: PUSH
38180: LD_VAR 0 2
38184: ARRAY
38185: PUSH
38186: LD_INT 1
38188: ARRAY
38189: PPUSH
38190: CALL 56474 0 3
38194: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38195: LD_EXP 122
38199: PUSH
38200: LD_VAR 0 2
38204: ARRAY
38205: PUSH
38206: LD_INT 1
38208: ARRAY
38209: PPUSH
38210: LD_INT 112
38212: PPUSH
38213: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38217: LD_ADDR_VAR 0 9
38221: PUSH
38222: LD_EXP 122
38226: PUSH
38227: LD_VAR 0 2
38231: ARRAY
38232: PPUSH
38233: LD_INT 1
38235: PPUSH
38236: CALL_OW 3
38240: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38241: LD_ADDR_EXP 122
38245: PUSH
38246: LD_EXP 122
38250: PPUSH
38251: LD_VAR 0 2
38255: PPUSH
38256: LD_VAR 0 9
38260: PPUSH
38261: CALL_OW 1
38265: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38266: LD_EXP 122
38270: PUSH
38271: LD_VAR 0 2
38275: ARRAY
38276: PUSH
38277: LD_EXP 123
38281: PUSH
38282: LD_VAR 0 2
38286: ARRAY
38287: AND
38288: PUSH
38289: LD_EXP 123
38293: PUSH
38294: LD_VAR 0 2
38298: ARRAY
38299: PUSH
38300: LD_INT 1
38302: ARRAY
38303: PPUSH
38304: CALL_OW 310
38308: NOT
38309: AND
38310: PUSH
38311: LD_VAR 0 3
38315: PPUSH
38316: CALL_OW 313
38320: PUSH
38321: LD_INT 6
38323: EQUAL
38324: AND
38325: IFFALSE 38381
// begin tmp2 := UnitsInside ( j ) ;
38327: LD_ADDR_VAR 0 9
38331: PUSH
38332: LD_VAR 0 3
38336: PPUSH
38337: CALL_OW 313
38341: ST_TO_ADDR
// if tmp2 = 6 then
38342: LD_VAR 0 9
38346: PUSH
38347: LD_INT 6
38349: EQUAL
38350: IFFALSE 38381
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38352: LD_VAR 0 9
38356: PUSH
38357: LD_INT 1
38359: ARRAY
38360: PPUSH
38361: LD_INT 112
38363: PPUSH
38364: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38368: LD_VAR 0 9
38372: PUSH
38373: LD_INT 1
38375: ARRAY
38376: PPUSH
38377: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38381: LD_EXP 123
38385: PUSH
38386: LD_VAR 0 2
38390: ARRAY
38391: PUSH
38392: LD_EXP 123
38396: PUSH
38397: LD_VAR 0 2
38401: ARRAY
38402: PUSH
38403: LD_INT 1
38405: ARRAY
38406: PPUSH
38407: CALL_OW 314
38411: NOT
38412: AND
38413: PUSH
38414: LD_EXP 123
38418: PUSH
38419: LD_VAR 0 2
38423: ARRAY
38424: PUSH
38425: LD_INT 1
38427: ARRAY
38428: PPUSH
38429: CALL_OW 310
38433: NOT
38434: AND
38435: IFFALSE 38461
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38437: LD_EXP 123
38441: PUSH
38442: LD_VAR 0 2
38446: ARRAY
38447: PUSH
38448: LD_INT 1
38450: ARRAY
38451: PPUSH
38452: LD_VAR 0 3
38456: PPUSH
38457: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38461: LD_EXP 123
38465: PUSH
38466: LD_VAR 0 2
38470: ARRAY
38471: PUSH
38472: LD_INT 1
38474: ARRAY
38475: PPUSH
38476: CALL_OW 310
38480: PUSH
38481: LD_EXP 123
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: PPUSH
38496: CALL_OW 310
38500: PPUSH
38501: CALL_OW 461
38505: PUSH
38506: LD_INT 3
38508: NONEQUAL
38509: AND
38510: IFFALSE 38531
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38512: LD_EXP 123
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: PUSH
38523: LD_INT 1
38525: ARRAY
38526: PPUSH
38527: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38531: LD_VAR 0 3
38535: PPUSH
38536: CALL_OW 461
38540: PUSH
38541: LD_INT 6
38543: EQUAL
38544: PUSH
38545: LD_VAR 0 6
38549: PUSH
38550: LD_INT 1
38552: GREATER
38553: AND
38554: IFFALSE 38706
// begin sci := [ ] ;
38556: LD_ADDR_VAR 0 8
38560: PUSH
38561: EMPTY
38562: ST_TO_ADDR
// for x in ( tmp diff j ) do
38563: LD_ADDR_VAR 0 7
38567: PUSH
38568: LD_VAR 0 6
38572: PUSH
38573: LD_VAR 0 3
38577: DIFF
38578: PUSH
38579: FOR_IN
38580: IFFALSE 38632
// begin if sci = 6 then
38582: LD_VAR 0 8
38586: PUSH
38587: LD_INT 6
38589: EQUAL
38590: IFFALSE 38594
// break ;
38592: GO 38632
// if BuildingStatus ( x ) = bs_idle then
38594: LD_VAR 0 7
38598: PPUSH
38599: CALL_OW 461
38603: PUSH
38604: LD_INT 2
38606: EQUAL
38607: IFFALSE 38630
// sci := sci ^ UnitsInside ( x ) ;
38609: LD_ADDR_VAR 0 8
38613: PUSH
38614: LD_VAR 0 8
38618: PUSH
38619: LD_VAR 0 7
38623: PPUSH
38624: CALL_OW 313
38628: ADD
38629: ST_TO_ADDR
// end ;
38630: GO 38579
38632: POP
38633: POP
// if not sci then
38634: LD_VAR 0 8
38638: NOT
38639: IFFALSE 38643
// continue ;
38641: GO 37688
// for x in sci do
38643: LD_ADDR_VAR 0 7
38647: PUSH
38648: LD_VAR 0 8
38652: PUSH
38653: FOR_IN
38654: IFFALSE 38704
// if IsInUnit ( x ) and not HasTask ( x ) then
38656: LD_VAR 0 7
38660: PPUSH
38661: CALL_OW 310
38665: PUSH
38666: LD_VAR 0 7
38670: PPUSH
38671: CALL_OW 314
38675: NOT
38676: AND
38677: IFFALSE 38702
// begin ComExitBuilding ( x ) ;
38679: LD_VAR 0 7
38683: PPUSH
38684: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38688: LD_VAR 0 7
38692: PPUSH
38693: LD_VAR 0 3
38697: PPUSH
38698: CALL_OW 180
// end ;
38702: GO 38653
38704: POP
38705: POP
// end ; end ;
38706: GO 37688
38708: POP
38709: POP
// end ;
38710: GO 37642
38712: POP
38713: POP
// end ;
38714: LD_VAR 0 1
38718: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38719: LD_INT 0
38721: PPUSH
38722: PPUSH
// if not mc_bases then
38723: LD_EXP 93
38727: NOT
38728: IFFALSE 38732
// exit ;
38730: GO 38813
// for i = 1 to mc_bases do
38732: LD_ADDR_VAR 0 2
38736: PUSH
38737: DOUBLE
38738: LD_INT 1
38740: DEC
38741: ST_TO_ADDR
38742: LD_EXP 93
38746: PUSH
38747: FOR_TO
38748: IFFALSE 38811
// if mc_mines [ i ] and mc_miners [ i ] then
38750: LD_EXP 106
38754: PUSH
38755: LD_VAR 0 2
38759: ARRAY
38760: PUSH
38761: LD_EXP 107
38765: PUSH
38766: LD_VAR 0 2
38770: ARRAY
38771: AND
38772: IFFALSE 38809
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38774: LD_EXP 107
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: PUSH
38785: LD_INT 1
38787: ARRAY
38788: PPUSH
38789: CALL_OW 255
38793: PPUSH
38794: LD_EXP 106
38798: PUSH
38799: LD_VAR 0 2
38803: ARRAY
38804: PPUSH
38805: CALL 53427 0 2
38809: GO 38747
38811: POP
38812: POP
// end ;
38813: LD_VAR 0 1
38817: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38818: LD_INT 0
38820: PPUSH
38821: PPUSH
38822: PPUSH
38823: PPUSH
38824: PPUSH
38825: PPUSH
38826: PPUSH
38827: PPUSH
// if not mc_bases or not mc_parking then
38828: LD_EXP 93
38832: NOT
38833: PUSH
38834: LD_EXP 117
38838: NOT
38839: OR
38840: IFFALSE 38844
// exit ;
38842: GO 39554
// for i = 1 to mc_bases do
38844: LD_ADDR_VAR 0 2
38848: PUSH
38849: DOUBLE
38850: LD_INT 1
38852: DEC
38853: ST_TO_ADDR
38854: LD_EXP 93
38858: PUSH
38859: FOR_TO
38860: IFFALSE 39552
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38862: LD_EXP 93
38866: PUSH
38867: LD_VAR 0 2
38871: ARRAY
38872: NOT
38873: PUSH
38874: LD_EXP 117
38878: PUSH
38879: LD_VAR 0 2
38883: ARRAY
38884: NOT
38885: OR
38886: IFFALSE 38890
// continue ;
38888: GO 38859
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38890: LD_ADDR_VAR 0 5
38894: PUSH
38895: LD_EXP 93
38899: PUSH
38900: LD_VAR 0 2
38904: ARRAY
38905: PUSH
38906: LD_INT 1
38908: ARRAY
38909: PPUSH
38910: CALL_OW 255
38914: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38915: LD_ADDR_VAR 0 6
38919: PUSH
38920: LD_EXP 93
38924: PUSH
38925: LD_VAR 0 2
38929: ARRAY
38930: PPUSH
38931: LD_INT 30
38933: PUSH
38934: LD_INT 3
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL_OW 72
38945: ST_TO_ADDR
// if not fac then
38946: LD_VAR 0 6
38950: NOT
38951: IFFALSE 39002
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38953: LD_ADDR_VAR 0 6
38957: PUSH
38958: LD_EXP 93
38962: PUSH
38963: LD_VAR 0 2
38967: ARRAY
38968: PPUSH
38969: LD_INT 2
38971: PUSH
38972: LD_INT 30
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 30
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: LIST
38996: PPUSH
38997: CALL_OW 72
39001: ST_TO_ADDR
// if not fac then
39002: LD_VAR 0 6
39006: NOT
39007: IFFALSE 39011
// continue ;
39009: GO 38859
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39011: LD_ADDR_VAR 0 7
39015: PUSH
39016: LD_EXP 117
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 22
39029: PUSH
39030: LD_VAR 0 5
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 21
39041: PUSH
39042: LD_INT 2
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 3
39051: PUSH
39052: LD_INT 24
39054: PUSH
39055: LD_INT 1000
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: LIST
39070: PPUSH
39071: CALL_OW 70
39075: ST_TO_ADDR
// for j in fac do
39076: LD_ADDR_VAR 0 3
39080: PUSH
39081: LD_VAR 0 6
39085: PUSH
39086: FOR_IN
39087: IFFALSE 39168
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39089: LD_ADDR_VAR 0 7
39093: PUSH
39094: LD_VAR 0 7
39098: PUSH
39099: LD_INT 22
39101: PUSH
39102: LD_VAR 0 5
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 91
39113: PUSH
39114: LD_VAR 0 3
39118: PUSH
39119: LD_INT 15
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 21
39129: PUSH
39130: LD_INT 2
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 3
39139: PUSH
39140: LD_INT 24
39142: PUSH
39143: LD_INT 1000
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: PPUSH
39160: CALL_OW 69
39164: UNION
39165: ST_TO_ADDR
39166: GO 39086
39168: POP
39169: POP
// if not vehs then
39170: LD_VAR 0 7
39174: NOT
39175: IFFALSE 39201
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39177: LD_ADDR_EXP 105
39181: PUSH
39182: LD_EXP 105
39186: PPUSH
39187: LD_VAR 0 2
39191: PPUSH
39192: EMPTY
39193: PPUSH
39194: CALL_OW 1
39198: ST_TO_ADDR
// continue ;
39199: GO 38859
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39201: LD_ADDR_VAR 0 8
39205: PUSH
39206: LD_EXP 93
39210: PUSH
39211: LD_VAR 0 2
39215: ARRAY
39216: PPUSH
39217: LD_INT 30
39219: PUSH
39220: LD_INT 3
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PPUSH
39227: CALL_OW 72
39231: ST_TO_ADDR
// if tmp then
39232: LD_VAR 0 8
39236: IFFALSE 39339
// begin for j in tmp do
39238: LD_ADDR_VAR 0 3
39242: PUSH
39243: LD_VAR 0 8
39247: PUSH
39248: FOR_IN
39249: IFFALSE 39337
// for k in UnitsInside ( j ) do
39251: LD_ADDR_VAR 0 4
39255: PUSH
39256: LD_VAR 0 3
39260: PPUSH
39261: CALL_OW 313
39265: PUSH
39266: FOR_IN
39267: IFFALSE 39333
// if k then
39269: LD_VAR 0 4
39273: IFFALSE 39331
// if not k in mc_repair_vehicle [ i ] then
39275: LD_VAR 0 4
39279: PUSH
39280: LD_EXP 105
39284: PUSH
39285: LD_VAR 0 2
39289: ARRAY
39290: IN
39291: NOT
39292: IFFALSE 39331
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39294: LD_ADDR_EXP 105
39298: PUSH
39299: LD_EXP 105
39303: PPUSH
39304: LD_VAR 0 2
39308: PPUSH
39309: LD_EXP 105
39313: PUSH
39314: LD_VAR 0 2
39318: ARRAY
39319: PUSH
39320: LD_VAR 0 4
39324: UNION
39325: PPUSH
39326: CALL_OW 1
39330: ST_TO_ADDR
39331: GO 39266
39333: POP
39334: POP
39335: GO 39248
39337: POP
39338: POP
// end ; if not mc_repair_vehicle [ i ] then
39339: LD_EXP 105
39343: PUSH
39344: LD_VAR 0 2
39348: ARRAY
39349: NOT
39350: IFFALSE 39354
// continue ;
39352: GO 38859
// for j in mc_repair_vehicle [ i ] do
39354: LD_ADDR_VAR 0 3
39358: PUSH
39359: LD_EXP 105
39363: PUSH
39364: LD_VAR 0 2
39368: ARRAY
39369: PUSH
39370: FOR_IN
39371: IFFALSE 39548
// begin if GetClass ( j ) <> 3 then
39373: LD_VAR 0 3
39377: PPUSH
39378: CALL_OW 257
39382: PUSH
39383: LD_INT 3
39385: NONEQUAL
39386: IFFALSE 39427
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39388: LD_ADDR_EXP 105
39392: PUSH
39393: LD_EXP 105
39397: PPUSH
39398: LD_VAR 0 2
39402: PPUSH
39403: LD_EXP 105
39407: PUSH
39408: LD_VAR 0 2
39412: ARRAY
39413: PUSH
39414: LD_VAR 0 3
39418: DIFF
39419: PPUSH
39420: CALL_OW 1
39424: ST_TO_ADDR
// continue ;
39425: GO 39370
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39427: LD_VAR 0 3
39431: PPUSH
39432: CALL_OW 311
39436: NOT
39437: PUSH
39438: LD_VAR 0 3
39442: PUSH
39443: LD_EXP 96
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: ARRAY
39457: IN
39458: NOT
39459: AND
39460: PUSH
39461: LD_VAR 0 3
39465: PUSH
39466: LD_EXP 96
39470: PUSH
39471: LD_VAR 0 2
39475: ARRAY
39476: PUSH
39477: LD_INT 2
39479: ARRAY
39480: IN
39481: NOT
39482: AND
39483: IFFALSE 39546
// begin if IsInUnit ( j ) then
39485: LD_VAR 0 3
39489: PPUSH
39490: CALL_OW 310
39494: IFFALSE 39507
// ComExitBuilding ( j ) else
39496: LD_VAR 0 3
39500: PPUSH
39501: CALL_OW 122
39505: GO 39546
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39507: LD_VAR 0 3
39511: PPUSH
39512: LD_VAR 0 7
39516: PUSH
39517: LD_INT 1
39519: ARRAY
39520: PPUSH
39521: CALL 90081 0 2
39525: NOT
39526: IFFALSE 39546
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39528: LD_VAR 0 3
39532: PPUSH
39533: LD_VAR 0 7
39537: PUSH
39538: LD_INT 1
39540: ARRAY
39541: PPUSH
39542: CALL_OW 129
// end ; end ;
39546: GO 39370
39548: POP
39549: POP
// end ;
39550: GO 38859
39552: POP
39553: POP
// end ;
39554: LD_VAR 0 1
39558: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39559: LD_INT 0
39561: PPUSH
39562: PPUSH
39563: PPUSH
39564: PPUSH
39565: PPUSH
39566: PPUSH
39567: PPUSH
39568: PPUSH
39569: PPUSH
39570: PPUSH
39571: PPUSH
// if not mc_bases then
39572: LD_EXP 93
39576: NOT
39577: IFFALSE 39581
// exit ;
39579: GO 40383
// for i = 1 to mc_bases do
39581: LD_ADDR_VAR 0 2
39585: PUSH
39586: DOUBLE
39587: LD_INT 1
39589: DEC
39590: ST_TO_ADDR
39591: LD_EXP 93
39595: PUSH
39596: FOR_TO
39597: IFFALSE 40381
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39599: LD_EXP 121
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: NOT
39610: PUSH
39611: LD_EXP 96
39615: PUSH
39616: LD_VAR 0 2
39620: ARRAY
39621: PUSH
39622: LD_INT 1
39624: ARRAY
39625: OR
39626: PUSH
39627: LD_EXP 96
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: PUSH
39638: LD_INT 2
39640: ARRAY
39641: OR
39642: PUSH
39643: LD_EXP 119
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PPUSH
39654: LD_INT 1
39656: PPUSH
39657: CALL_OW 325
39661: NOT
39662: OR
39663: PUSH
39664: LD_EXP 116
39668: PUSH
39669: LD_VAR 0 2
39673: ARRAY
39674: OR
39675: IFFALSE 39679
// continue ;
39677: GO 39596
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39679: LD_ADDR_VAR 0 8
39683: PUSH
39684: LD_EXP 93
39688: PUSH
39689: LD_VAR 0 2
39693: ARRAY
39694: PPUSH
39695: LD_INT 25
39697: PUSH
39698: LD_INT 4
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 50
39707: PUSH
39708: EMPTY
39709: LIST
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: LD_INT 60
39716: PUSH
39717: EMPTY
39718: LIST
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: LIST
39728: PPUSH
39729: CALL_OW 72
39733: PUSH
39734: LD_EXP 97
39738: PUSH
39739: LD_VAR 0 2
39743: ARRAY
39744: DIFF
39745: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39746: LD_ADDR_VAR 0 9
39750: PUSH
39751: LD_EXP 93
39755: PUSH
39756: LD_VAR 0 2
39760: ARRAY
39761: PPUSH
39762: LD_INT 2
39764: PUSH
39765: LD_INT 30
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 30
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 72
39794: ST_TO_ADDR
// if not tmp or not dep then
39795: LD_VAR 0 8
39799: NOT
39800: PUSH
39801: LD_VAR 0 9
39805: NOT
39806: OR
39807: IFFALSE 39811
// continue ;
39809: GO 39596
// side := GetSide ( tmp [ 1 ] ) ;
39811: LD_ADDR_VAR 0 11
39815: PUSH
39816: LD_VAR 0 8
39820: PUSH
39821: LD_INT 1
39823: ARRAY
39824: PPUSH
39825: CALL_OW 255
39829: ST_TO_ADDR
// dep := dep [ 1 ] ;
39830: LD_ADDR_VAR 0 9
39834: PUSH
39835: LD_VAR 0 9
39839: PUSH
39840: LD_INT 1
39842: ARRAY
39843: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39844: LD_ADDR_VAR 0 7
39848: PUSH
39849: LD_EXP 121
39853: PUSH
39854: LD_VAR 0 2
39858: ARRAY
39859: PPUSH
39860: LD_INT 22
39862: PUSH
39863: LD_INT 0
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 25
39872: PUSH
39873: LD_INT 12
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PPUSH
39884: CALL_OW 70
39888: PUSH
39889: LD_INT 22
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 25
39901: PUSH
39902: LD_INT 12
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 91
39911: PUSH
39912: LD_VAR 0 9
39916: PUSH
39917: LD_INT 20
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: LIST
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL_OW 69
39934: UNION
39935: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39936: LD_ADDR_VAR 0 10
39940: PUSH
39941: LD_EXP 121
39945: PUSH
39946: LD_VAR 0 2
39950: ARRAY
39951: PPUSH
39952: LD_INT 81
39954: PUSH
39955: LD_VAR 0 11
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PPUSH
39964: CALL_OW 70
39968: ST_TO_ADDR
// if not apes or danger_at_area then
39969: LD_VAR 0 7
39973: NOT
39974: PUSH
39975: LD_VAR 0 10
39979: OR
39980: IFFALSE 40030
// begin if mc_taming [ i ] then
39982: LD_EXP 124
39986: PUSH
39987: LD_VAR 0 2
39991: ARRAY
39992: IFFALSE 40028
// begin MC_Reset ( i , 121 ) ;
39994: LD_VAR 0 2
39998: PPUSH
39999: LD_INT 121
40001: PPUSH
40002: CALL 25016 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40006: LD_ADDR_EXP 124
40010: PUSH
40011: LD_EXP 124
40015: PPUSH
40016: LD_VAR 0 2
40020: PPUSH
40021: EMPTY
40022: PPUSH
40023: CALL_OW 1
40027: ST_TO_ADDR
// end ; continue ;
40028: GO 39596
// end ; for j in tmp do
40030: LD_ADDR_VAR 0 3
40034: PUSH
40035: LD_VAR 0 8
40039: PUSH
40040: FOR_IN
40041: IFFALSE 40377
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40043: LD_VAR 0 3
40047: PUSH
40048: LD_EXP 124
40052: PUSH
40053: LD_VAR 0 2
40057: ARRAY
40058: IN
40059: NOT
40060: PUSH
40061: LD_EXP 124
40065: PUSH
40066: LD_VAR 0 2
40070: ARRAY
40071: PUSH
40072: LD_INT 3
40074: LESS
40075: AND
40076: IFFALSE 40134
// begin SetTag ( j , 121 ) ;
40078: LD_VAR 0 3
40082: PPUSH
40083: LD_INT 121
40085: PPUSH
40086: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40090: LD_ADDR_EXP 124
40094: PUSH
40095: LD_EXP 124
40099: PPUSH
40100: LD_VAR 0 2
40104: PUSH
40105: LD_EXP 124
40109: PUSH
40110: LD_VAR 0 2
40114: ARRAY
40115: PUSH
40116: LD_INT 1
40118: PLUS
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PPUSH
40124: LD_VAR 0 3
40128: PPUSH
40129: CALL 56474 0 3
40133: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40134: LD_VAR 0 3
40138: PUSH
40139: LD_EXP 124
40143: PUSH
40144: LD_VAR 0 2
40148: ARRAY
40149: IN
40150: IFFALSE 40375
// begin if GetClass ( j ) <> 4 then
40152: LD_VAR 0 3
40156: PPUSH
40157: CALL_OW 257
40161: PUSH
40162: LD_INT 4
40164: NONEQUAL
40165: IFFALSE 40218
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40167: LD_ADDR_EXP 124
40171: PUSH
40172: LD_EXP 124
40176: PPUSH
40177: LD_VAR 0 2
40181: PPUSH
40182: LD_EXP 124
40186: PUSH
40187: LD_VAR 0 2
40191: ARRAY
40192: PUSH
40193: LD_VAR 0 3
40197: DIFF
40198: PPUSH
40199: CALL_OW 1
40203: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40204: LD_VAR 0 3
40208: PPUSH
40209: LD_INT 0
40211: PPUSH
40212: CALL_OW 109
// continue ;
40216: GO 40040
// end ; if IsInUnit ( j ) then
40218: LD_VAR 0 3
40222: PPUSH
40223: CALL_OW 310
40227: IFFALSE 40238
// ComExitBuilding ( j ) ;
40229: LD_VAR 0 3
40233: PPUSH
40234: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40238: LD_ADDR_VAR 0 6
40242: PUSH
40243: LD_VAR 0 7
40247: PPUSH
40248: LD_VAR 0 3
40252: PPUSH
40253: CALL_OW 74
40257: ST_TO_ADDR
// if not ape then
40258: LD_VAR 0 6
40262: NOT
40263: IFFALSE 40267
// break ;
40265: GO 40377
// x := GetX ( ape ) ;
40267: LD_ADDR_VAR 0 4
40271: PUSH
40272: LD_VAR 0 6
40276: PPUSH
40277: CALL_OW 250
40281: ST_TO_ADDR
// y := GetY ( ape ) ;
40282: LD_ADDR_VAR 0 5
40286: PUSH
40287: LD_VAR 0 6
40291: PPUSH
40292: CALL_OW 251
40296: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40297: LD_VAR 0 4
40301: PPUSH
40302: LD_VAR 0 5
40306: PPUSH
40307: CALL_OW 488
40311: NOT
40312: PUSH
40313: LD_VAR 0 11
40317: PPUSH
40318: LD_VAR 0 4
40322: PPUSH
40323: LD_VAR 0 5
40327: PPUSH
40328: LD_INT 20
40330: PPUSH
40331: CALL 57370 0 4
40335: PUSH
40336: LD_INT 4
40338: ARRAY
40339: OR
40340: IFFALSE 40344
// break ;
40342: GO 40377
// if not HasTask ( j ) then
40344: LD_VAR 0 3
40348: PPUSH
40349: CALL_OW 314
40353: NOT
40354: IFFALSE 40375
// ComTameXY ( j , x , y ) ;
40356: LD_VAR 0 3
40360: PPUSH
40361: LD_VAR 0 4
40365: PPUSH
40366: LD_VAR 0 5
40370: PPUSH
40371: CALL_OW 131
// end ; end ;
40375: GO 40040
40377: POP
40378: POP
// end ;
40379: GO 39596
40381: POP
40382: POP
// end ;
40383: LD_VAR 0 1
40387: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40388: LD_INT 0
40390: PPUSH
40391: PPUSH
40392: PPUSH
40393: PPUSH
40394: PPUSH
40395: PPUSH
40396: PPUSH
40397: PPUSH
// if not mc_bases then
40398: LD_EXP 93
40402: NOT
40403: IFFALSE 40407
// exit ;
40405: GO 41033
// for i = 1 to mc_bases do
40407: LD_ADDR_VAR 0 2
40411: PUSH
40412: DOUBLE
40413: LD_INT 1
40415: DEC
40416: ST_TO_ADDR
40417: LD_EXP 93
40421: PUSH
40422: FOR_TO
40423: IFFALSE 41031
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40425: LD_EXP 122
40429: PUSH
40430: LD_VAR 0 2
40434: ARRAY
40435: NOT
40436: PUSH
40437: LD_EXP 122
40441: PUSH
40442: LD_VAR 0 2
40446: ARRAY
40447: PPUSH
40448: LD_INT 25
40450: PUSH
40451: LD_INT 12
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PPUSH
40458: CALL_OW 72
40462: NOT
40463: OR
40464: IFFALSE 40468
// continue ;
40466: GO 40422
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40468: LD_ADDR_VAR 0 5
40472: PUSH
40473: LD_EXP 122
40477: PUSH
40478: LD_VAR 0 2
40482: ARRAY
40483: PUSH
40484: LD_INT 1
40486: ARRAY
40487: PPUSH
40488: CALL_OW 255
40492: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40493: LD_VAR 0 5
40497: PPUSH
40498: LD_INT 2
40500: PPUSH
40501: CALL_OW 325
40505: IFFALSE 40758
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40507: LD_ADDR_VAR 0 4
40511: PUSH
40512: LD_EXP 122
40516: PUSH
40517: LD_VAR 0 2
40521: ARRAY
40522: PPUSH
40523: LD_INT 25
40525: PUSH
40526: LD_INT 16
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PPUSH
40533: CALL_OW 72
40537: ST_TO_ADDR
// if tmp < 6 then
40538: LD_VAR 0 4
40542: PUSH
40543: LD_INT 6
40545: LESS
40546: IFFALSE 40758
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40548: LD_ADDR_VAR 0 6
40552: PUSH
40553: LD_EXP 93
40557: PUSH
40558: LD_VAR 0 2
40562: ARRAY
40563: PPUSH
40564: LD_INT 2
40566: PUSH
40567: LD_INT 30
40569: PUSH
40570: LD_INT 0
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: PUSH
40577: LD_INT 30
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: LIST
40591: PPUSH
40592: CALL_OW 72
40596: ST_TO_ADDR
// if depot then
40597: LD_VAR 0 6
40601: IFFALSE 40758
// begin selected := 0 ;
40603: LD_ADDR_VAR 0 7
40607: PUSH
40608: LD_INT 0
40610: ST_TO_ADDR
// for j in depot do
40611: LD_ADDR_VAR 0 3
40615: PUSH
40616: LD_VAR 0 6
40620: PUSH
40621: FOR_IN
40622: IFFALSE 40653
// begin if UnitsInside ( j ) < 6 then
40624: LD_VAR 0 3
40628: PPUSH
40629: CALL_OW 313
40633: PUSH
40634: LD_INT 6
40636: LESS
40637: IFFALSE 40651
// begin selected := j ;
40639: LD_ADDR_VAR 0 7
40643: PUSH
40644: LD_VAR 0 3
40648: ST_TO_ADDR
// break ;
40649: GO 40653
// end ; end ;
40651: GO 40621
40653: POP
40654: POP
// if selected then
40655: LD_VAR 0 7
40659: IFFALSE 40758
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40661: LD_ADDR_VAR 0 3
40665: PUSH
40666: LD_EXP 122
40670: PUSH
40671: LD_VAR 0 2
40675: ARRAY
40676: PPUSH
40677: LD_INT 25
40679: PUSH
40680: LD_INT 12
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PPUSH
40687: CALL_OW 72
40691: PUSH
40692: FOR_IN
40693: IFFALSE 40756
// if not HasTask ( j ) then
40695: LD_VAR 0 3
40699: PPUSH
40700: CALL_OW 314
40704: NOT
40705: IFFALSE 40754
// begin if not IsInUnit ( j ) then
40707: LD_VAR 0 3
40711: PPUSH
40712: CALL_OW 310
40716: NOT
40717: IFFALSE 40733
// ComEnterUnit ( j , selected ) ;
40719: LD_VAR 0 3
40723: PPUSH
40724: LD_VAR 0 7
40728: PPUSH
40729: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40733: LD_VAR 0 3
40737: PPUSH
40738: LD_INT 16
40740: PPUSH
40741: CALL_OW 183
// AddComExitBuilding ( j ) ;
40745: LD_VAR 0 3
40749: PPUSH
40750: CALL_OW 182
// end ;
40754: GO 40692
40756: POP
40757: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40758: LD_VAR 0 5
40762: PPUSH
40763: LD_INT 11
40765: PPUSH
40766: CALL_OW 325
40770: IFFALSE 41029
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40772: LD_ADDR_VAR 0 4
40776: PUSH
40777: LD_EXP 122
40781: PUSH
40782: LD_VAR 0 2
40786: ARRAY
40787: PPUSH
40788: LD_INT 25
40790: PUSH
40791: LD_INT 16
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PPUSH
40798: CALL_OW 72
40802: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40803: LD_VAR 0 4
40807: PUSH
40808: LD_INT 6
40810: GREATEREQUAL
40811: PUSH
40812: LD_VAR 0 5
40816: PPUSH
40817: LD_INT 2
40819: PPUSH
40820: CALL_OW 325
40824: NOT
40825: OR
40826: IFFALSE 41029
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40828: LD_ADDR_VAR 0 8
40832: PUSH
40833: LD_EXP 93
40837: PUSH
40838: LD_VAR 0 2
40842: ARRAY
40843: PPUSH
40844: LD_INT 2
40846: PUSH
40847: LD_INT 30
40849: PUSH
40850: LD_INT 4
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 30
40859: PUSH
40860: LD_INT 5
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: LIST
40871: PPUSH
40872: CALL_OW 72
40876: ST_TO_ADDR
// if barracks then
40877: LD_VAR 0 8
40881: IFFALSE 41029
// begin selected := 0 ;
40883: LD_ADDR_VAR 0 7
40887: PUSH
40888: LD_INT 0
40890: ST_TO_ADDR
// for j in barracks do
40891: LD_ADDR_VAR 0 3
40895: PUSH
40896: LD_VAR 0 8
40900: PUSH
40901: FOR_IN
40902: IFFALSE 40933
// begin if UnitsInside ( j ) < 6 then
40904: LD_VAR 0 3
40908: PPUSH
40909: CALL_OW 313
40913: PUSH
40914: LD_INT 6
40916: LESS
40917: IFFALSE 40931
// begin selected := j ;
40919: LD_ADDR_VAR 0 7
40923: PUSH
40924: LD_VAR 0 3
40928: ST_TO_ADDR
// break ;
40929: GO 40933
// end ; end ;
40931: GO 40901
40933: POP
40934: POP
// if selected then
40935: LD_VAR 0 7
40939: IFFALSE 41029
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40941: LD_ADDR_VAR 0 3
40945: PUSH
40946: LD_EXP 122
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: PPUSH
40957: LD_INT 25
40959: PUSH
40960: LD_INT 12
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PPUSH
40967: CALL_OW 72
40971: PUSH
40972: FOR_IN
40973: IFFALSE 41027
// if not IsInUnit ( j ) and not HasTask ( j ) then
40975: LD_VAR 0 3
40979: PPUSH
40980: CALL_OW 310
40984: NOT
40985: PUSH
40986: LD_VAR 0 3
40990: PPUSH
40991: CALL_OW 314
40995: NOT
40996: AND
40997: IFFALSE 41025
// begin ComEnterUnit ( j , selected ) ;
40999: LD_VAR 0 3
41003: PPUSH
41004: LD_VAR 0 7
41008: PPUSH
41009: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41013: LD_VAR 0 3
41017: PPUSH
41018: LD_INT 15
41020: PPUSH
41021: CALL_OW 183
// end ;
41025: GO 40972
41027: POP
41028: POP
// end ; end ; end ; end ; end ;
41029: GO 40422
41031: POP
41032: POP
// end ;
41033: LD_VAR 0 1
41037: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41038: LD_INT 0
41040: PPUSH
41041: PPUSH
41042: PPUSH
41043: PPUSH
// if not mc_bases then
41044: LD_EXP 93
41048: NOT
41049: IFFALSE 41053
// exit ;
41051: GO 41231
// for i = 1 to mc_bases do
41053: LD_ADDR_VAR 0 2
41057: PUSH
41058: DOUBLE
41059: LD_INT 1
41061: DEC
41062: ST_TO_ADDR
41063: LD_EXP 93
41067: PUSH
41068: FOR_TO
41069: IFFALSE 41229
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41071: LD_ADDR_VAR 0 4
41075: PUSH
41076: LD_EXP 93
41080: PUSH
41081: LD_VAR 0 2
41085: ARRAY
41086: PPUSH
41087: LD_INT 25
41089: PUSH
41090: LD_INT 9
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PPUSH
41097: CALL_OW 72
41101: ST_TO_ADDR
// if not tmp then
41102: LD_VAR 0 4
41106: NOT
41107: IFFALSE 41111
// continue ;
41109: GO 41068
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41111: LD_EXP 119
41115: PUSH
41116: LD_VAR 0 2
41120: ARRAY
41121: PPUSH
41122: LD_INT 29
41124: PPUSH
41125: CALL_OW 325
41129: NOT
41130: PUSH
41131: LD_EXP 119
41135: PUSH
41136: LD_VAR 0 2
41140: ARRAY
41141: PPUSH
41142: LD_INT 28
41144: PPUSH
41145: CALL_OW 325
41149: NOT
41150: AND
41151: IFFALSE 41155
// continue ;
41153: GO 41068
// for j in tmp do
41155: LD_ADDR_VAR 0 3
41159: PUSH
41160: LD_VAR 0 4
41164: PUSH
41165: FOR_IN
41166: IFFALSE 41225
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41168: LD_VAR 0 3
41172: PUSH
41173: LD_EXP 96
41177: PUSH
41178: LD_VAR 0 2
41182: ARRAY
41183: PUSH
41184: LD_INT 1
41186: ARRAY
41187: IN
41188: NOT
41189: PUSH
41190: LD_VAR 0 3
41194: PUSH
41195: LD_EXP 96
41199: PUSH
41200: LD_VAR 0 2
41204: ARRAY
41205: PUSH
41206: LD_INT 2
41208: ARRAY
41209: IN
41210: NOT
41211: AND
41212: IFFALSE 41223
// ComSpaceTimeShoot ( j ) ;
41214: LD_VAR 0 3
41218: PPUSH
41219: CALL 52435 0 1
41223: GO 41165
41225: POP
41226: POP
// end ;
41227: GO 41068
41229: POP
41230: POP
// end ;
41231: LD_VAR 0 1
41235: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41236: LD_INT 0
41238: PPUSH
41239: PPUSH
41240: PPUSH
41241: PPUSH
41242: PPUSH
41243: PPUSH
41244: PPUSH
41245: PPUSH
41246: PPUSH
// if not mc_bases then
41247: LD_EXP 93
41251: NOT
41252: IFFALSE 41256
// exit ;
41254: GO 41878
// for i = 1 to mc_bases do
41256: LD_ADDR_VAR 0 2
41260: PUSH
41261: DOUBLE
41262: LD_INT 1
41264: DEC
41265: ST_TO_ADDR
41266: LD_EXP 93
41270: PUSH
41271: FOR_TO
41272: IFFALSE 41876
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41274: LD_EXP 128
41278: PUSH
41279: LD_VAR 0 2
41283: ARRAY
41284: NOT
41285: PUSH
41286: LD_INT 38
41288: PPUSH
41289: LD_EXP 119
41293: PUSH
41294: LD_VAR 0 2
41298: ARRAY
41299: PPUSH
41300: CALL_OW 321
41304: PUSH
41305: LD_INT 2
41307: NONEQUAL
41308: OR
41309: IFFALSE 41313
// continue ;
41311: GO 41271
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41313: LD_ADDR_VAR 0 8
41317: PUSH
41318: LD_EXP 93
41322: PUSH
41323: LD_VAR 0 2
41327: ARRAY
41328: PPUSH
41329: LD_INT 30
41331: PUSH
41332: LD_INT 34
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PPUSH
41339: CALL_OW 72
41343: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41344: LD_ADDR_VAR 0 9
41348: PUSH
41349: LD_EXP 93
41353: PUSH
41354: LD_VAR 0 2
41358: ARRAY
41359: PPUSH
41360: LD_INT 25
41362: PUSH
41363: LD_INT 4
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PPUSH
41370: CALL_OW 72
41374: PPUSH
41375: LD_INT 0
41377: PPUSH
41378: CALL 85743 0 2
41382: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41383: LD_VAR 0 9
41387: NOT
41388: PUSH
41389: LD_VAR 0 8
41393: NOT
41394: OR
41395: PUSH
41396: LD_EXP 93
41400: PUSH
41401: LD_VAR 0 2
41405: ARRAY
41406: PPUSH
41407: LD_INT 124
41409: PPUSH
41410: CALL 85743 0 2
41414: OR
41415: IFFALSE 41419
// continue ;
41417: GO 41271
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41419: LD_EXP 129
41423: PUSH
41424: LD_VAR 0 2
41428: ARRAY
41429: PUSH
41430: LD_EXP 128
41434: PUSH
41435: LD_VAR 0 2
41439: ARRAY
41440: LESS
41441: PUSH
41442: LD_EXP 129
41446: PUSH
41447: LD_VAR 0 2
41451: ARRAY
41452: PUSH
41453: LD_VAR 0 8
41457: LESS
41458: AND
41459: IFFALSE 41874
// begin tmp := sci [ 1 ] ;
41461: LD_ADDR_VAR 0 7
41465: PUSH
41466: LD_VAR 0 9
41470: PUSH
41471: LD_INT 1
41473: ARRAY
41474: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41475: LD_VAR 0 7
41479: PPUSH
41480: LD_INT 124
41482: PPUSH
41483: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41487: LD_ADDR_VAR 0 3
41491: PUSH
41492: DOUBLE
41493: LD_EXP 128
41497: PUSH
41498: LD_VAR 0 2
41502: ARRAY
41503: INC
41504: ST_TO_ADDR
41505: LD_EXP 128
41509: PUSH
41510: LD_VAR 0 2
41514: ARRAY
41515: PUSH
41516: FOR_DOWNTO
41517: IFFALSE 41860
// begin if IsInUnit ( tmp ) then
41519: LD_VAR 0 7
41523: PPUSH
41524: CALL_OW 310
41528: IFFALSE 41539
// ComExitBuilding ( tmp ) ;
41530: LD_VAR 0 7
41534: PPUSH
41535: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41539: LD_INT 35
41541: PPUSH
41542: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41546: LD_VAR 0 7
41550: PPUSH
41551: CALL_OW 310
41555: NOT
41556: PUSH
41557: LD_VAR 0 7
41561: PPUSH
41562: CALL_OW 314
41566: NOT
41567: AND
41568: IFFALSE 41539
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41570: LD_ADDR_VAR 0 6
41574: PUSH
41575: LD_VAR 0 7
41579: PPUSH
41580: CALL_OW 250
41584: PUSH
41585: LD_VAR 0 7
41589: PPUSH
41590: CALL_OW 251
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41599: LD_INT 35
41601: PPUSH
41602: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41606: LD_ADDR_VAR 0 4
41610: PUSH
41611: LD_EXP 128
41615: PUSH
41616: LD_VAR 0 2
41620: ARRAY
41621: PUSH
41622: LD_VAR 0 3
41626: ARRAY
41627: PUSH
41628: LD_INT 1
41630: ARRAY
41631: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41632: LD_ADDR_VAR 0 5
41636: PUSH
41637: LD_EXP 128
41641: PUSH
41642: LD_VAR 0 2
41646: ARRAY
41647: PUSH
41648: LD_VAR 0 3
41652: ARRAY
41653: PUSH
41654: LD_INT 2
41656: ARRAY
41657: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41658: LD_VAR 0 7
41662: PPUSH
41663: LD_INT 10
41665: PPUSH
41666: CALL 59073 0 2
41670: PUSH
41671: LD_INT 4
41673: ARRAY
41674: IFFALSE 41712
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41676: LD_VAR 0 7
41680: PPUSH
41681: LD_VAR 0 6
41685: PUSH
41686: LD_INT 1
41688: ARRAY
41689: PPUSH
41690: LD_VAR 0 6
41694: PUSH
41695: LD_INT 2
41697: ARRAY
41698: PPUSH
41699: CALL_OW 111
// wait ( 0 0$10 ) ;
41703: LD_INT 350
41705: PPUSH
41706: CALL_OW 67
// end else
41710: GO 41738
// begin ComMoveXY ( tmp , x , y ) ;
41712: LD_VAR 0 7
41716: PPUSH
41717: LD_VAR 0 4
41721: PPUSH
41722: LD_VAR 0 5
41726: PPUSH
41727: CALL_OW 111
// wait ( 0 0$3 ) ;
41731: LD_INT 105
41733: PPUSH
41734: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41738: LD_VAR 0 7
41742: PPUSH
41743: LD_VAR 0 4
41747: PPUSH
41748: LD_VAR 0 5
41752: PPUSH
41753: CALL_OW 307
41757: IFFALSE 41599
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41759: LD_VAR 0 7
41763: PPUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: LD_VAR 0 5
41773: PPUSH
41774: LD_VAR 0 8
41778: PUSH
41779: LD_VAR 0 3
41783: ARRAY
41784: PPUSH
41785: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41789: LD_INT 35
41791: PPUSH
41792: CALL_OW 67
// until not HasTask ( tmp ) ;
41796: LD_VAR 0 7
41800: PPUSH
41801: CALL_OW 314
41805: NOT
41806: IFFALSE 41789
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41808: LD_ADDR_EXP 129
41812: PUSH
41813: LD_EXP 129
41817: PPUSH
41818: LD_VAR 0 2
41822: PUSH
41823: LD_EXP 129
41827: PUSH
41828: LD_VAR 0 2
41832: ARRAY
41833: PUSH
41834: LD_INT 1
41836: PLUS
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PPUSH
41842: LD_VAR 0 8
41846: PUSH
41847: LD_VAR 0 3
41851: ARRAY
41852: PPUSH
41853: CALL 56474 0 3
41857: ST_TO_ADDR
// end ;
41858: GO 41516
41860: POP
41861: POP
// MC_Reset ( i , 124 ) ;
41862: LD_VAR 0 2
41866: PPUSH
41867: LD_INT 124
41869: PPUSH
41870: CALL 25016 0 2
// end ; end ;
41874: GO 41271
41876: POP
41877: POP
// end ;
41878: LD_VAR 0 1
41882: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41883: LD_INT 0
41885: PPUSH
41886: PPUSH
41887: PPUSH
// if not mc_bases then
41888: LD_EXP 93
41892: NOT
41893: IFFALSE 41897
// exit ;
41895: GO 42503
// for i = 1 to mc_bases do
41897: LD_ADDR_VAR 0 2
41901: PUSH
41902: DOUBLE
41903: LD_INT 1
41905: DEC
41906: ST_TO_ADDR
41907: LD_EXP 93
41911: PUSH
41912: FOR_TO
41913: IFFALSE 42501
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41915: LD_ADDR_VAR 0 3
41919: PUSH
41920: LD_EXP 93
41924: PUSH
41925: LD_VAR 0 2
41929: ARRAY
41930: PPUSH
41931: LD_INT 25
41933: PUSH
41934: LD_INT 4
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PPUSH
41941: CALL_OW 72
41945: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41946: LD_VAR 0 3
41950: NOT
41951: PUSH
41952: LD_EXP 130
41956: PUSH
41957: LD_VAR 0 2
41961: ARRAY
41962: NOT
41963: OR
41964: PUSH
41965: LD_EXP 93
41969: PUSH
41970: LD_VAR 0 2
41974: ARRAY
41975: PPUSH
41976: LD_INT 2
41978: PUSH
41979: LD_INT 30
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 30
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: LIST
42003: PPUSH
42004: CALL_OW 72
42008: NOT
42009: OR
42010: IFFALSE 42060
// begin if mc_deposits_finder [ i ] then
42012: LD_EXP 131
42016: PUSH
42017: LD_VAR 0 2
42021: ARRAY
42022: IFFALSE 42058
// begin MC_Reset ( i , 125 ) ;
42024: LD_VAR 0 2
42028: PPUSH
42029: LD_INT 125
42031: PPUSH
42032: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42036: LD_ADDR_EXP 131
42040: PUSH
42041: LD_EXP 131
42045: PPUSH
42046: LD_VAR 0 2
42050: PPUSH
42051: EMPTY
42052: PPUSH
42053: CALL_OW 1
42057: ST_TO_ADDR
// end ; continue ;
42058: GO 41912
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42060: LD_EXP 130
42064: PUSH
42065: LD_VAR 0 2
42069: ARRAY
42070: PUSH
42071: LD_INT 1
42073: ARRAY
42074: PUSH
42075: LD_INT 3
42077: ARRAY
42078: PUSH
42079: LD_INT 1
42081: EQUAL
42082: PUSH
42083: LD_INT 20
42085: PPUSH
42086: LD_EXP 119
42090: PUSH
42091: LD_VAR 0 2
42095: ARRAY
42096: PPUSH
42097: CALL_OW 321
42101: PUSH
42102: LD_INT 2
42104: NONEQUAL
42105: AND
42106: IFFALSE 42156
// begin if mc_deposits_finder [ i ] then
42108: LD_EXP 131
42112: PUSH
42113: LD_VAR 0 2
42117: ARRAY
42118: IFFALSE 42154
// begin MC_Reset ( i , 125 ) ;
42120: LD_VAR 0 2
42124: PPUSH
42125: LD_INT 125
42127: PPUSH
42128: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42132: LD_ADDR_EXP 131
42136: PUSH
42137: LD_EXP 131
42141: PPUSH
42142: LD_VAR 0 2
42146: PPUSH
42147: EMPTY
42148: PPUSH
42149: CALL_OW 1
42153: ST_TO_ADDR
// end ; continue ;
42154: GO 41912
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42156: LD_EXP 130
42160: PUSH
42161: LD_VAR 0 2
42165: ARRAY
42166: PUSH
42167: LD_INT 1
42169: ARRAY
42170: PUSH
42171: LD_INT 1
42173: ARRAY
42174: PPUSH
42175: LD_EXP 130
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_INT 1
42188: ARRAY
42189: PUSH
42190: LD_INT 2
42192: ARRAY
42193: PPUSH
42194: LD_EXP 119
42198: PUSH
42199: LD_VAR 0 2
42203: ARRAY
42204: PPUSH
42205: CALL_OW 440
42209: IFFALSE 42252
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42211: LD_ADDR_EXP 130
42215: PUSH
42216: LD_EXP 130
42220: PPUSH
42221: LD_VAR 0 2
42225: PPUSH
42226: LD_EXP 130
42230: PUSH
42231: LD_VAR 0 2
42235: ARRAY
42236: PPUSH
42237: LD_INT 1
42239: PPUSH
42240: CALL_OW 3
42244: PPUSH
42245: CALL_OW 1
42249: ST_TO_ADDR
42250: GO 42499
// begin if not mc_deposits_finder [ i ] then
42252: LD_EXP 131
42256: PUSH
42257: LD_VAR 0 2
42261: ARRAY
42262: NOT
42263: IFFALSE 42315
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42265: LD_ADDR_EXP 131
42269: PUSH
42270: LD_EXP 131
42274: PPUSH
42275: LD_VAR 0 2
42279: PPUSH
42280: LD_VAR 0 3
42284: PUSH
42285: LD_INT 1
42287: ARRAY
42288: PUSH
42289: EMPTY
42290: LIST
42291: PPUSH
42292: CALL_OW 1
42296: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42297: LD_VAR 0 3
42301: PUSH
42302: LD_INT 1
42304: ARRAY
42305: PPUSH
42306: LD_INT 125
42308: PPUSH
42309: CALL_OW 109
// end else
42313: GO 42499
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42315: LD_EXP 131
42319: PUSH
42320: LD_VAR 0 2
42324: ARRAY
42325: PUSH
42326: LD_INT 1
42328: ARRAY
42329: PPUSH
42330: CALL_OW 310
42334: IFFALSE 42357
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42336: LD_EXP 131
42340: PUSH
42341: LD_VAR 0 2
42345: ARRAY
42346: PUSH
42347: LD_INT 1
42349: ARRAY
42350: PPUSH
42351: CALL_OW 122
42355: GO 42499
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42357: LD_EXP 131
42361: PUSH
42362: LD_VAR 0 2
42366: ARRAY
42367: PUSH
42368: LD_INT 1
42370: ARRAY
42371: PPUSH
42372: CALL_OW 314
42376: NOT
42377: PUSH
42378: LD_EXP 131
42382: PUSH
42383: LD_VAR 0 2
42387: ARRAY
42388: PUSH
42389: LD_INT 1
42391: ARRAY
42392: PPUSH
42393: LD_EXP 130
42397: PUSH
42398: LD_VAR 0 2
42402: ARRAY
42403: PUSH
42404: LD_INT 1
42406: ARRAY
42407: PUSH
42408: LD_INT 1
42410: ARRAY
42411: PPUSH
42412: LD_EXP 130
42416: PUSH
42417: LD_VAR 0 2
42421: ARRAY
42422: PUSH
42423: LD_INT 1
42425: ARRAY
42426: PUSH
42427: LD_INT 2
42429: ARRAY
42430: PPUSH
42431: CALL_OW 297
42435: PUSH
42436: LD_INT 6
42438: GREATER
42439: AND
42440: IFFALSE 42499
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42442: LD_EXP 131
42446: PUSH
42447: LD_VAR 0 2
42451: ARRAY
42452: PUSH
42453: LD_INT 1
42455: ARRAY
42456: PPUSH
42457: LD_EXP 130
42461: PUSH
42462: LD_VAR 0 2
42466: ARRAY
42467: PUSH
42468: LD_INT 1
42470: ARRAY
42471: PUSH
42472: LD_INT 1
42474: ARRAY
42475: PPUSH
42476: LD_EXP 130
42480: PUSH
42481: LD_VAR 0 2
42485: ARRAY
42486: PUSH
42487: LD_INT 1
42489: ARRAY
42490: PUSH
42491: LD_INT 2
42493: ARRAY
42494: PPUSH
42495: CALL_OW 111
// end ; end ; end ;
42499: GO 41912
42501: POP
42502: POP
// end ;
42503: LD_VAR 0 1
42507: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42508: LD_INT 0
42510: PPUSH
42511: PPUSH
42512: PPUSH
42513: PPUSH
42514: PPUSH
42515: PPUSH
42516: PPUSH
42517: PPUSH
42518: PPUSH
42519: PPUSH
42520: PPUSH
// if not mc_bases then
42521: LD_EXP 93
42525: NOT
42526: IFFALSE 42530
// exit ;
42528: GO 43470
// for i = 1 to mc_bases do
42530: LD_ADDR_VAR 0 2
42534: PUSH
42535: DOUBLE
42536: LD_INT 1
42538: DEC
42539: ST_TO_ADDR
42540: LD_EXP 93
42544: PUSH
42545: FOR_TO
42546: IFFALSE 43468
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42548: LD_EXP 93
42552: PUSH
42553: LD_VAR 0 2
42557: ARRAY
42558: NOT
42559: PUSH
42560: LD_EXP 116
42564: PUSH
42565: LD_VAR 0 2
42569: ARRAY
42570: OR
42571: IFFALSE 42575
// continue ;
42573: GO 42545
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42575: LD_ADDR_VAR 0 7
42579: PUSH
42580: LD_EXP 93
42584: PUSH
42585: LD_VAR 0 2
42589: ARRAY
42590: PUSH
42591: LD_INT 1
42593: ARRAY
42594: PPUSH
42595: CALL_OW 248
42599: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42600: LD_VAR 0 7
42604: PUSH
42605: LD_INT 3
42607: EQUAL
42608: PUSH
42609: LD_EXP 112
42613: PUSH
42614: LD_VAR 0 2
42618: ARRAY
42619: PUSH
42620: LD_EXP 115
42624: PUSH
42625: LD_VAR 0 2
42629: ARRAY
42630: UNION
42631: PPUSH
42632: LD_INT 33
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PPUSH
42642: CALL_OW 72
42646: NOT
42647: OR
42648: IFFALSE 42652
// continue ;
42650: GO 42545
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42652: LD_ADDR_VAR 0 9
42656: PUSH
42657: LD_EXP 93
42661: PUSH
42662: LD_VAR 0 2
42666: ARRAY
42667: PPUSH
42668: LD_INT 30
42670: PUSH
42671: LD_INT 36
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PPUSH
42678: CALL_OW 72
42682: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42683: LD_ADDR_VAR 0 10
42687: PUSH
42688: LD_EXP 112
42692: PUSH
42693: LD_VAR 0 2
42697: ARRAY
42698: PPUSH
42699: LD_INT 34
42701: PUSH
42702: LD_INT 31
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PPUSH
42709: CALL_OW 72
42713: ST_TO_ADDR
// if not cts and not mcts then
42714: LD_VAR 0 9
42718: NOT
42719: PUSH
42720: LD_VAR 0 10
42724: NOT
42725: AND
42726: IFFALSE 42730
// continue ;
42728: GO 42545
// x := cts ;
42730: LD_ADDR_VAR 0 11
42734: PUSH
42735: LD_VAR 0 9
42739: ST_TO_ADDR
// if not x then
42740: LD_VAR 0 11
42744: NOT
42745: IFFALSE 42757
// x := mcts ;
42747: LD_ADDR_VAR 0 11
42751: PUSH
42752: LD_VAR 0 10
42756: ST_TO_ADDR
// if not x then
42757: LD_VAR 0 11
42761: NOT
42762: IFFALSE 42766
// continue ;
42764: GO 42545
// if mc_remote_driver [ i ] then
42766: LD_EXP 133
42770: PUSH
42771: LD_VAR 0 2
42775: ARRAY
42776: IFFALSE 43163
// for j in mc_remote_driver [ i ] do
42778: LD_ADDR_VAR 0 3
42782: PUSH
42783: LD_EXP 133
42787: PUSH
42788: LD_VAR 0 2
42792: ARRAY
42793: PUSH
42794: FOR_IN
42795: IFFALSE 43161
// begin if GetClass ( j ) <> 3 then
42797: LD_VAR 0 3
42801: PPUSH
42802: CALL_OW 257
42806: PUSH
42807: LD_INT 3
42809: NONEQUAL
42810: IFFALSE 42863
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42812: LD_ADDR_EXP 133
42816: PUSH
42817: LD_EXP 133
42821: PPUSH
42822: LD_VAR 0 2
42826: PPUSH
42827: LD_EXP 133
42831: PUSH
42832: LD_VAR 0 2
42836: ARRAY
42837: PUSH
42838: LD_VAR 0 3
42842: DIFF
42843: PPUSH
42844: CALL_OW 1
42848: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42849: LD_VAR 0 3
42853: PPUSH
42854: LD_INT 0
42856: PPUSH
42857: CALL_OW 109
// continue ;
42861: GO 42794
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42863: LD_EXP 112
42867: PUSH
42868: LD_VAR 0 2
42872: ARRAY
42873: PPUSH
42874: LD_INT 34
42876: PUSH
42877: LD_INT 31
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 58
42886: PUSH
42887: EMPTY
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: PUSH
42899: LD_VAR 0 3
42903: PPUSH
42904: CALL 85831 0 1
42908: NOT
42909: AND
42910: IFFALSE 42981
// begin if IsInUnit ( j ) then
42912: LD_VAR 0 3
42916: PPUSH
42917: CALL_OW 310
42921: IFFALSE 42932
// ComExitBuilding ( j ) ;
42923: LD_VAR 0 3
42927: PPUSH
42928: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42932: LD_VAR 0 3
42936: PPUSH
42937: LD_EXP 112
42941: PUSH
42942: LD_VAR 0 2
42946: ARRAY
42947: PPUSH
42948: LD_INT 34
42950: PUSH
42951: LD_INT 31
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 58
42960: PUSH
42961: EMPTY
42962: LIST
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PPUSH
42968: CALL_OW 72
42972: PUSH
42973: LD_INT 1
42975: ARRAY
42976: PPUSH
42977: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42981: LD_VAR 0 3
42985: PPUSH
42986: CALL_OW 310
42990: NOT
42991: PUSH
42992: LD_VAR 0 3
42996: PPUSH
42997: CALL_OW 310
43001: PPUSH
43002: CALL_OW 266
43006: PUSH
43007: LD_INT 36
43009: NONEQUAL
43010: PUSH
43011: LD_VAR 0 3
43015: PPUSH
43016: CALL 85831 0 1
43020: NOT
43021: AND
43022: OR
43023: IFFALSE 43159
// begin if IsInUnit ( j ) then
43025: LD_VAR 0 3
43029: PPUSH
43030: CALL_OW 310
43034: IFFALSE 43045
// ComExitBuilding ( j ) ;
43036: LD_VAR 0 3
43040: PPUSH
43041: CALL_OW 122
// ct := 0 ;
43045: LD_ADDR_VAR 0 8
43049: PUSH
43050: LD_INT 0
43052: ST_TO_ADDR
// for k in x do
43053: LD_ADDR_VAR 0 4
43057: PUSH
43058: LD_VAR 0 11
43062: PUSH
43063: FOR_IN
43064: IFFALSE 43137
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43066: LD_VAR 0 4
43070: PPUSH
43071: CALL_OW 264
43075: PUSH
43076: LD_INT 31
43078: EQUAL
43079: PUSH
43080: LD_VAR 0 4
43084: PPUSH
43085: CALL_OW 311
43089: NOT
43090: AND
43091: PUSH
43092: LD_VAR 0 4
43096: PPUSH
43097: CALL_OW 266
43101: PUSH
43102: LD_INT 36
43104: EQUAL
43105: PUSH
43106: LD_VAR 0 4
43110: PPUSH
43111: CALL_OW 313
43115: PUSH
43116: LD_INT 3
43118: LESS
43119: AND
43120: OR
43121: IFFALSE 43135
// begin ct := k ;
43123: LD_ADDR_VAR 0 8
43127: PUSH
43128: LD_VAR 0 4
43132: ST_TO_ADDR
// break ;
43133: GO 43137
// end ;
43135: GO 43063
43137: POP
43138: POP
// if ct then
43139: LD_VAR 0 8
43143: IFFALSE 43159
// ComEnterUnit ( j , ct ) ;
43145: LD_VAR 0 3
43149: PPUSH
43150: LD_VAR 0 8
43154: PPUSH
43155: CALL_OW 120
// end ; end ;
43159: GO 42794
43161: POP
43162: POP
// places := 0 ;
43163: LD_ADDR_VAR 0 5
43167: PUSH
43168: LD_INT 0
43170: ST_TO_ADDR
// for j = 1 to x do
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: DOUBLE
43177: LD_INT 1
43179: DEC
43180: ST_TO_ADDR
43181: LD_VAR 0 11
43185: PUSH
43186: FOR_TO
43187: IFFALSE 43263
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43189: LD_VAR 0 11
43193: PUSH
43194: LD_VAR 0 3
43198: ARRAY
43199: PPUSH
43200: CALL_OW 264
43204: PUSH
43205: LD_INT 31
43207: EQUAL
43208: IFFALSE 43226
// places := places + 1 else
43210: LD_ADDR_VAR 0 5
43214: PUSH
43215: LD_VAR 0 5
43219: PUSH
43220: LD_INT 1
43222: PLUS
43223: ST_TO_ADDR
43224: GO 43261
// if GetBType ( x [ j ] ) = b_control_tower then
43226: LD_VAR 0 11
43230: PUSH
43231: LD_VAR 0 3
43235: ARRAY
43236: PPUSH
43237: CALL_OW 266
43241: PUSH
43242: LD_INT 36
43244: EQUAL
43245: IFFALSE 43261
// places := places + 3 ;
43247: LD_ADDR_VAR 0 5
43251: PUSH
43252: LD_VAR 0 5
43256: PUSH
43257: LD_INT 3
43259: PLUS
43260: ST_TO_ADDR
43261: GO 43186
43263: POP
43264: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43265: LD_VAR 0 5
43269: PUSH
43270: LD_INT 0
43272: EQUAL
43273: PUSH
43274: LD_VAR 0 5
43278: PUSH
43279: LD_EXP 133
43283: PUSH
43284: LD_VAR 0 2
43288: ARRAY
43289: LESSEQUAL
43290: OR
43291: IFFALSE 43295
// continue ;
43293: GO 42545
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43295: LD_ADDR_VAR 0 6
43299: PUSH
43300: LD_EXP 93
43304: PUSH
43305: LD_VAR 0 2
43309: ARRAY
43310: PPUSH
43311: LD_INT 25
43313: PUSH
43314: LD_INT 3
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PPUSH
43321: CALL_OW 72
43325: PUSH
43326: LD_EXP 133
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: DIFF
43337: PPUSH
43338: LD_INT 3
43340: PPUSH
43341: CALL 86731 0 2
43345: ST_TO_ADDR
// for j in tmp do
43346: LD_ADDR_VAR 0 3
43350: PUSH
43351: LD_VAR 0 6
43355: PUSH
43356: FOR_IN
43357: IFFALSE 43392
// if GetTag ( j ) > 0 then
43359: LD_VAR 0 3
43363: PPUSH
43364: CALL_OW 110
43368: PUSH
43369: LD_INT 0
43371: GREATER
43372: IFFALSE 43390
// tmp := tmp diff j ;
43374: LD_ADDR_VAR 0 6
43378: PUSH
43379: LD_VAR 0 6
43383: PUSH
43384: LD_VAR 0 3
43388: DIFF
43389: ST_TO_ADDR
43390: GO 43356
43392: POP
43393: POP
// if not tmp then
43394: LD_VAR 0 6
43398: NOT
43399: IFFALSE 43403
// continue ;
43401: GO 42545
// if places then
43403: LD_VAR 0 5
43407: IFFALSE 43466
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43409: LD_ADDR_EXP 133
43413: PUSH
43414: LD_EXP 133
43418: PPUSH
43419: LD_VAR 0 2
43423: PPUSH
43424: LD_EXP 133
43428: PUSH
43429: LD_VAR 0 2
43433: ARRAY
43434: PUSH
43435: LD_VAR 0 6
43439: PUSH
43440: LD_INT 1
43442: ARRAY
43443: UNION
43444: PPUSH
43445: CALL_OW 1
43449: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43450: LD_VAR 0 6
43454: PUSH
43455: LD_INT 1
43457: ARRAY
43458: PPUSH
43459: LD_INT 126
43461: PPUSH
43462: CALL_OW 109
// end ; end ;
43466: GO 42545
43468: POP
43469: POP
// end ;
43470: LD_VAR 0 1
43474: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43475: LD_INT 0
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
43481: PPUSH
43482: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43483: LD_VAR 0 1
43487: NOT
43488: PUSH
43489: LD_VAR 0 2
43493: NOT
43494: OR
43495: PUSH
43496: LD_VAR 0 3
43500: NOT
43501: OR
43502: PUSH
43503: LD_VAR 0 4
43507: PUSH
43508: LD_INT 1
43510: PUSH
43511: LD_INT 2
43513: PUSH
43514: LD_INT 3
43516: PUSH
43517: LD_INT 4
43519: PUSH
43520: LD_INT 5
43522: PUSH
43523: LD_INT 8
43525: PUSH
43526: LD_INT 9
43528: PUSH
43529: LD_INT 15
43531: PUSH
43532: LD_INT 16
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: IN
43546: NOT
43547: OR
43548: IFFALSE 43552
// exit ;
43550: GO 44452
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43552: LD_ADDR_VAR 0 2
43556: PUSH
43557: LD_VAR 0 2
43561: PPUSH
43562: LD_INT 21
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 24
43574: PUSH
43575: LD_INT 250
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PPUSH
43586: CALL_OW 72
43590: ST_TO_ADDR
// case class of 1 , 15 :
43591: LD_VAR 0 4
43595: PUSH
43596: LD_INT 1
43598: DOUBLE
43599: EQUAL
43600: IFTRUE 43610
43602: LD_INT 15
43604: DOUBLE
43605: EQUAL
43606: IFTRUE 43610
43608: GO 43695
43610: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43611: LD_ADDR_VAR 0 8
43615: PUSH
43616: LD_VAR 0 2
43620: PPUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 30
43626: PUSH
43627: LD_INT 32
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 30
43636: PUSH
43637: LD_INT 31
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: LIST
43648: PPUSH
43649: CALL_OW 72
43653: PUSH
43654: LD_VAR 0 2
43658: PPUSH
43659: LD_INT 2
43661: PUSH
43662: LD_INT 30
43664: PUSH
43665: LD_INT 4
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 30
43674: PUSH
43675: LD_INT 5
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: LIST
43686: PPUSH
43687: CALL_OW 72
43691: ADD
43692: ST_TO_ADDR
43693: GO 43941
43695: LD_INT 2
43697: DOUBLE
43698: EQUAL
43699: IFTRUE 43709
43701: LD_INT 16
43703: DOUBLE
43704: EQUAL
43705: IFTRUE 43709
43707: GO 43755
43709: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43710: LD_ADDR_VAR 0 8
43714: PUSH
43715: LD_VAR 0 2
43719: PPUSH
43720: LD_INT 2
43722: PUSH
43723: LD_INT 30
43725: PUSH
43726: LD_INT 0
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: LD_INT 30
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: LIST
43747: PPUSH
43748: CALL_OW 72
43752: ST_TO_ADDR
43753: GO 43941
43755: LD_INT 3
43757: DOUBLE
43758: EQUAL
43759: IFTRUE 43763
43761: GO 43809
43763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43764: LD_ADDR_VAR 0 8
43768: PUSH
43769: LD_VAR 0 2
43773: PPUSH
43774: LD_INT 2
43776: PUSH
43777: LD_INT 30
43779: PUSH
43780: LD_INT 2
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 30
43789: PUSH
43790: LD_INT 3
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: LIST
43801: PPUSH
43802: CALL_OW 72
43806: ST_TO_ADDR
43807: GO 43941
43809: LD_INT 4
43811: DOUBLE
43812: EQUAL
43813: IFTRUE 43817
43815: GO 43874
43817: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43818: LD_ADDR_VAR 0 8
43822: PUSH
43823: LD_VAR 0 2
43827: PPUSH
43828: LD_INT 2
43830: PUSH
43831: LD_INT 30
43833: PUSH
43834: LD_INT 6
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 30
43843: PUSH
43844: LD_INT 7
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: LD_INT 30
43853: PUSH
43854: LD_INT 8
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: PPUSH
43867: CALL_OW 72
43871: ST_TO_ADDR
43872: GO 43941
43874: LD_INT 5
43876: DOUBLE
43877: EQUAL
43878: IFTRUE 43894
43880: LD_INT 8
43882: DOUBLE
43883: EQUAL
43884: IFTRUE 43894
43886: LD_INT 9
43888: DOUBLE
43889: EQUAL
43890: IFTRUE 43894
43892: GO 43940
43894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43895: LD_ADDR_VAR 0 8
43899: PUSH
43900: LD_VAR 0 2
43904: PPUSH
43905: LD_INT 2
43907: PUSH
43908: LD_INT 30
43910: PUSH
43911: LD_INT 4
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 30
43920: PUSH
43921: LD_INT 5
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: LIST
43932: PPUSH
43933: CALL_OW 72
43937: ST_TO_ADDR
43938: GO 43941
43940: POP
// if not tmp then
43941: LD_VAR 0 8
43945: NOT
43946: IFFALSE 43950
// exit ;
43948: GO 44452
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43950: LD_VAR 0 4
43954: PUSH
43955: LD_INT 1
43957: PUSH
43958: LD_INT 15
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: IN
43965: PUSH
43966: LD_EXP 102
43970: PUSH
43971: LD_VAR 0 1
43975: ARRAY
43976: AND
43977: IFFALSE 44133
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43979: LD_ADDR_VAR 0 9
43983: PUSH
43984: LD_EXP 102
43988: PUSH
43989: LD_VAR 0 1
43993: ARRAY
43994: PUSH
43995: LD_INT 1
43997: ARRAY
43998: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43999: LD_VAR 0 9
44003: PUSH
44004: LD_EXP 103
44008: PUSH
44009: LD_VAR 0 1
44013: ARRAY
44014: IN
44015: NOT
44016: IFFALSE 44131
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44018: LD_ADDR_EXP 103
44022: PUSH
44023: LD_EXP 103
44027: PPUSH
44028: LD_VAR 0 1
44032: PUSH
44033: LD_EXP 103
44037: PUSH
44038: LD_VAR 0 1
44042: ARRAY
44043: PUSH
44044: LD_INT 1
44046: PLUS
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PPUSH
44052: LD_VAR 0 9
44056: PPUSH
44057: CALL 56474 0 3
44061: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44062: LD_ADDR_EXP 102
44066: PUSH
44067: LD_EXP 102
44071: PPUSH
44072: LD_VAR 0 1
44076: PPUSH
44077: LD_EXP 102
44081: PUSH
44082: LD_VAR 0 1
44086: ARRAY
44087: PUSH
44088: LD_VAR 0 9
44092: DIFF
44093: PPUSH
44094: CALL_OW 1
44098: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44099: LD_VAR 0 3
44103: PPUSH
44104: LD_EXP 103
44108: PUSH
44109: LD_VAR 0 1
44113: ARRAY
44114: PUSH
44115: LD_EXP 103
44119: PUSH
44120: LD_VAR 0 1
44124: ARRAY
44125: ARRAY
44126: PPUSH
44127: CALL_OW 120
// end ; exit ;
44131: GO 44452
// end ; if tmp > 1 then
44133: LD_VAR 0 8
44137: PUSH
44138: LD_INT 1
44140: GREATER
44141: IFFALSE 44245
// for i = 2 to tmp do
44143: LD_ADDR_VAR 0 6
44147: PUSH
44148: DOUBLE
44149: LD_INT 2
44151: DEC
44152: ST_TO_ADDR
44153: LD_VAR 0 8
44157: PUSH
44158: FOR_TO
44159: IFFALSE 44243
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44161: LD_VAR 0 8
44165: PUSH
44166: LD_VAR 0 6
44170: ARRAY
44171: PPUSH
44172: CALL_OW 461
44176: PUSH
44177: LD_INT 6
44179: EQUAL
44180: IFFALSE 44241
// begin x := tmp [ i ] ;
44182: LD_ADDR_VAR 0 9
44186: PUSH
44187: LD_VAR 0 8
44191: PUSH
44192: LD_VAR 0 6
44196: ARRAY
44197: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44198: LD_ADDR_VAR 0 8
44202: PUSH
44203: LD_VAR 0 8
44207: PPUSH
44208: LD_VAR 0 6
44212: PPUSH
44213: CALL_OW 3
44217: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44218: LD_ADDR_VAR 0 8
44222: PUSH
44223: LD_VAR 0 8
44227: PPUSH
44228: LD_INT 1
44230: PPUSH
44231: LD_VAR 0 9
44235: PPUSH
44236: CALL_OW 2
44240: ST_TO_ADDR
// end ;
44241: GO 44158
44243: POP
44244: POP
// for i in tmp do
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_VAR 0 8
44254: PUSH
44255: FOR_IN
44256: IFFALSE 44325
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44258: LD_VAR 0 6
44262: PPUSH
44263: CALL_OW 313
44267: PUSH
44268: LD_INT 6
44270: LESS
44271: PUSH
44272: LD_VAR 0 6
44276: PPUSH
44277: CALL_OW 266
44281: PUSH
44282: LD_INT 31
44284: PUSH
44285: LD_INT 32
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: IN
44292: NOT
44293: AND
44294: PUSH
44295: LD_VAR 0 6
44299: PPUSH
44300: CALL_OW 313
44304: PUSH
44305: LD_INT 0
44307: EQUAL
44308: OR
44309: IFFALSE 44323
// begin j := i ;
44311: LD_ADDR_VAR 0 7
44315: PUSH
44316: LD_VAR 0 6
44320: ST_TO_ADDR
// break ;
44321: GO 44325
// end ; end ;
44323: GO 44255
44325: POP
44326: POP
// if j then
44327: LD_VAR 0 7
44331: IFFALSE 44349
// ComEnterUnit ( unit , j ) else
44333: LD_VAR 0 3
44337: PPUSH
44338: LD_VAR 0 7
44342: PPUSH
44343: CALL_OW 120
44347: GO 44452
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44349: LD_ADDR_VAR 0 10
44353: PUSH
44354: LD_VAR 0 2
44358: PPUSH
44359: LD_INT 2
44361: PUSH
44362: LD_INT 30
44364: PUSH
44365: LD_INT 0
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PUSH
44372: LD_INT 30
44374: PUSH
44375: LD_INT 1
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: LIST
44386: PPUSH
44387: CALL_OW 72
44391: ST_TO_ADDR
// if depot then
44392: LD_VAR 0 10
44396: IFFALSE 44452
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44398: LD_ADDR_VAR 0 10
44402: PUSH
44403: LD_VAR 0 10
44407: PPUSH
44408: LD_VAR 0 3
44412: PPUSH
44413: CALL_OW 74
44417: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44418: LD_VAR 0 3
44422: PPUSH
44423: LD_VAR 0 10
44427: PPUSH
44428: CALL_OW 296
44432: PUSH
44433: LD_INT 10
44435: GREATER
44436: IFFALSE 44452
// ComStandNearbyBuilding ( unit , depot ) ;
44438: LD_VAR 0 3
44442: PPUSH
44443: LD_VAR 0 10
44447: PPUSH
44448: CALL 53052 0 2
// end ; end ; end ;
44452: LD_VAR 0 5
44456: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44457: LD_INT 0
44459: PPUSH
44460: PPUSH
44461: PPUSH
44462: PPUSH
// if not mc_bases then
44463: LD_EXP 93
44467: NOT
44468: IFFALSE 44472
// exit ;
44470: GO 44711
// for i = 1 to mc_bases do
44472: LD_ADDR_VAR 0 2
44476: PUSH
44477: DOUBLE
44478: LD_INT 1
44480: DEC
44481: ST_TO_ADDR
44482: LD_EXP 93
44486: PUSH
44487: FOR_TO
44488: IFFALSE 44709
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44490: LD_ADDR_VAR 0 4
44494: PUSH
44495: LD_EXP 93
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PPUSH
44506: LD_INT 21
44508: PUSH
44509: LD_INT 1
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PPUSH
44516: CALL_OW 72
44520: PUSH
44521: LD_EXP 122
44525: PUSH
44526: LD_VAR 0 2
44530: ARRAY
44531: UNION
44532: ST_TO_ADDR
// if not tmp then
44533: LD_VAR 0 4
44537: NOT
44538: IFFALSE 44542
// continue ;
44540: GO 44487
// for j in tmp do
44542: LD_ADDR_VAR 0 3
44546: PUSH
44547: LD_VAR 0 4
44551: PUSH
44552: FOR_IN
44553: IFFALSE 44705
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44555: LD_VAR 0 3
44559: PPUSH
44560: CALL_OW 110
44564: NOT
44565: PUSH
44566: LD_VAR 0 3
44570: PPUSH
44571: CALL_OW 314
44575: NOT
44576: AND
44577: PUSH
44578: LD_VAR 0 3
44582: PPUSH
44583: CALL_OW 311
44587: NOT
44588: AND
44589: PUSH
44590: LD_VAR 0 3
44594: PPUSH
44595: CALL_OW 310
44599: NOT
44600: AND
44601: PUSH
44602: LD_VAR 0 3
44606: PUSH
44607: LD_EXP 96
44611: PUSH
44612: LD_VAR 0 2
44616: ARRAY
44617: PUSH
44618: LD_INT 1
44620: ARRAY
44621: IN
44622: NOT
44623: AND
44624: PUSH
44625: LD_VAR 0 3
44629: PUSH
44630: LD_EXP 96
44634: PUSH
44635: LD_VAR 0 2
44639: ARRAY
44640: PUSH
44641: LD_INT 2
44643: ARRAY
44644: IN
44645: NOT
44646: AND
44647: PUSH
44648: LD_VAR 0 3
44652: PUSH
44653: LD_EXP 105
44657: PUSH
44658: LD_VAR 0 2
44662: ARRAY
44663: IN
44664: NOT
44665: AND
44666: IFFALSE 44703
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44668: LD_VAR 0 2
44672: PPUSH
44673: LD_EXP 93
44677: PUSH
44678: LD_VAR 0 2
44682: ARRAY
44683: PPUSH
44684: LD_VAR 0 3
44688: PPUSH
44689: LD_VAR 0 3
44693: PPUSH
44694: CALL_OW 257
44698: PPUSH
44699: CALL 43475 0 4
// end ;
44703: GO 44552
44705: POP
44706: POP
// end ;
44707: GO 44487
44709: POP
44710: POP
// end ;
44711: LD_VAR 0 1
44715: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44716: LD_INT 0
44718: PPUSH
44719: PPUSH
44720: PPUSH
44721: PPUSH
44722: PPUSH
44723: PPUSH
// if not mc_bases [ base ] then
44724: LD_EXP 93
44728: PUSH
44729: LD_VAR 0 1
44733: ARRAY
44734: NOT
44735: IFFALSE 44739
// exit ;
44737: GO 44921
// tmp := [ ] ;
44739: LD_ADDR_VAR 0 6
44743: PUSH
44744: EMPTY
44745: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44746: LD_ADDR_VAR 0 7
44750: PUSH
44751: LD_VAR 0 3
44755: PPUSH
44756: LD_INT 0
44758: PPUSH
44759: CALL_OW 517
44763: ST_TO_ADDR
// if not list then
44764: LD_VAR 0 7
44768: NOT
44769: IFFALSE 44773
// exit ;
44771: GO 44921
// for i = 1 to amount do
44773: LD_ADDR_VAR 0 5
44777: PUSH
44778: DOUBLE
44779: LD_INT 1
44781: DEC
44782: ST_TO_ADDR
44783: LD_VAR 0 2
44787: PUSH
44788: FOR_TO
44789: IFFALSE 44869
// begin x := rand ( 1 , list [ 1 ] ) ;
44791: LD_ADDR_VAR 0 8
44795: PUSH
44796: LD_INT 1
44798: PPUSH
44799: LD_VAR 0 7
44803: PUSH
44804: LD_INT 1
44806: ARRAY
44807: PPUSH
44808: CALL_OW 12
44812: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44813: LD_ADDR_VAR 0 6
44817: PUSH
44818: LD_VAR 0 6
44822: PPUSH
44823: LD_VAR 0 5
44827: PPUSH
44828: LD_VAR 0 7
44832: PUSH
44833: LD_INT 1
44835: ARRAY
44836: PUSH
44837: LD_VAR 0 8
44841: ARRAY
44842: PUSH
44843: LD_VAR 0 7
44847: PUSH
44848: LD_INT 2
44850: ARRAY
44851: PUSH
44852: LD_VAR 0 8
44856: ARRAY
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PPUSH
44862: CALL_OW 1
44866: ST_TO_ADDR
// end ;
44867: GO 44788
44869: POP
44870: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44871: LD_ADDR_EXP 106
44875: PUSH
44876: LD_EXP 106
44880: PPUSH
44881: LD_VAR 0 1
44885: PPUSH
44886: LD_VAR 0 6
44890: PPUSH
44891: CALL_OW 1
44895: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44896: LD_ADDR_EXP 108
44900: PUSH
44901: LD_EXP 108
44905: PPUSH
44906: LD_VAR 0 1
44910: PPUSH
44911: LD_VAR 0 3
44915: PPUSH
44916: CALL_OW 1
44920: ST_TO_ADDR
// end ;
44921: LD_VAR 0 4
44925: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44926: LD_INT 0
44928: PPUSH
// if not mc_bases [ base ] then
44929: LD_EXP 93
44933: PUSH
44934: LD_VAR 0 1
44938: ARRAY
44939: NOT
44940: IFFALSE 44944
// exit ;
44942: GO 44969
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44944: LD_ADDR_EXP 98
44948: PUSH
44949: LD_EXP 98
44953: PPUSH
44954: LD_VAR 0 1
44958: PPUSH
44959: LD_VAR 0 2
44963: PPUSH
44964: CALL_OW 1
44968: ST_TO_ADDR
// end ;
44969: LD_VAR 0 3
44973: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44974: LD_INT 0
44976: PPUSH
// if not mc_bases [ base ] then
44977: LD_EXP 93
44981: PUSH
44982: LD_VAR 0 1
44986: ARRAY
44987: NOT
44988: IFFALSE 44992
// exit ;
44990: GO 45029
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44992: LD_ADDR_EXP 98
44996: PUSH
44997: LD_EXP 98
45001: PPUSH
45002: LD_VAR 0 1
45006: PPUSH
45007: LD_EXP 98
45011: PUSH
45012: LD_VAR 0 1
45016: ARRAY
45017: PUSH
45018: LD_VAR 0 2
45022: UNION
45023: PPUSH
45024: CALL_OW 1
45028: ST_TO_ADDR
// end ;
45029: LD_VAR 0 3
45033: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45034: LD_INT 0
45036: PPUSH
// if not mc_bases [ base ] then
45037: LD_EXP 93
45041: PUSH
45042: LD_VAR 0 1
45046: ARRAY
45047: NOT
45048: IFFALSE 45052
// exit ;
45050: GO 45077
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45052: LD_ADDR_EXP 114
45056: PUSH
45057: LD_EXP 114
45061: PPUSH
45062: LD_VAR 0 1
45066: PPUSH
45067: LD_VAR 0 2
45071: PPUSH
45072: CALL_OW 1
45076: ST_TO_ADDR
// end ;
45077: LD_VAR 0 3
45081: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45082: LD_INT 0
45084: PPUSH
// if not mc_bases [ base ] then
45085: LD_EXP 93
45089: PUSH
45090: LD_VAR 0 1
45094: ARRAY
45095: NOT
45096: IFFALSE 45100
// exit ;
45098: GO 45137
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45100: LD_ADDR_EXP 114
45104: PUSH
45105: LD_EXP 114
45109: PPUSH
45110: LD_VAR 0 1
45114: PPUSH
45115: LD_EXP 114
45119: PUSH
45120: LD_VAR 0 1
45124: ARRAY
45125: PUSH
45126: LD_VAR 0 2
45130: ADD
45131: PPUSH
45132: CALL_OW 1
45136: ST_TO_ADDR
// end ;
45137: LD_VAR 0 3
45141: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45142: LD_INT 0
45144: PPUSH
// if not mc_bases [ base ] then
45145: LD_EXP 93
45149: PUSH
45150: LD_VAR 0 1
45154: ARRAY
45155: NOT
45156: IFFALSE 45160
// exit ;
45158: GO 45214
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45160: LD_ADDR_EXP 115
45164: PUSH
45165: LD_EXP 115
45169: PPUSH
45170: LD_VAR 0 1
45174: PPUSH
45175: LD_VAR 0 2
45179: PPUSH
45180: CALL_OW 1
45184: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45185: LD_ADDR_EXP 104
45189: PUSH
45190: LD_EXP 104
45194: PPUSH
45195: LD_VAR 0 1
45199: PPUSH
45200: LD_VAR 0 2
45204: PUSH
45205: LD_INT 0
45207: PLUS
45208: PPUSH
45209: CALL_OW 1
45213: ST_TO_ADDR
// end ;
45214: LD_VAR 0 3
45218: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45219: LD_INT 0
45221: PPUSH
// if not mc_bases [ base ] then
45222: LD_EXP 93
45226: PUSH
45227: LD_VAR 0 1
45231: ARRAY
45232: NOT
45233: IFFALSE 45237
// exit ;
45235: GO 45262
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45237: LD_ADDR_EXP 104
45241: PUSH
45242: LD_EXP 104
45246: PPUSH
45247: LD_VAR 0 1
45251: PPUSH
45252: LD_VAR 0 2
45256: PPUSH
45257: CALL_OW 1
45261: ST_TO_ADDR
// end ;
45262: LD_VAR 0 3
45266: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45267: LD_INT 0
45269: PPUSH
45270: PPUSH
45271: PPUSH
45272: PPUSH
// if not mc_bases [ base ] then
45273: LD_EXP 93
45277: PUSH
45278: LD_VAR 0 1
45282: ARRAY
45283: NOT
45284: IFFALSE 45288
// exit ;
45286: GO 45353
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45288: LD_ADDR_EXP 113
45292: PUSH
45293: LD_EXP 113
45297: PPUSH
45298: LD_VAR 0 1
45302: PUSH
45303: LD_EXP 113
45307: PUSH
45308: LD_VAR 0 1
45312: ARRAY
45313: PUSH
45314: LD_INT 1
45316: PLUS
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PPUSH
45322: LD_VAR 0 1
45326: PUSH
45327: LD_VAR 0 2
45331: PUSH
45332: LD_VAR 0 3
45336: PUSH
45337: LD_VAR 0 4
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: PPUSH
45348: CALL 56474 0 3
45352: ST_TO_ADDR
// end ;
45353: LD_VAR 0 5
45357: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45358: LD_INT 0
45360: PPUSH
// if not mc_bases [ base ] then
45361: LD_EXP 93
45365: PUSH
45366: LD_VAR 0 1
45370: ARRAY
45371: NOT
45372: IFFALSE 45376
// exit ;
45374: GO 45401
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45376: LD_ADDR_EXP 130
45380: PUSH
45381: LD_EXP 130
45385: PPUSH
45386: LD_VAR 0 1
45390: PPUSH
45391: LD_VAR 0 2
45395: PPUSH
45396: CALL_OW 1
45400: ST_TO_ADDR
// end ;
45401: LD_VAR 0 3
45405: RET
// export function MC_GetMinesField ( base ) ; begin
45406: LD_INT 0
45408: PPUSH
// result := mc_mines [ base ] ;
45409: LD_ADDR_VAR 0 2
45413: PUSH
45414: LD_EXP 106
45418: PUSH
45419: LD_VAR 0 1
45423: ARRAY
45424: ST_TO_ADDR
// end ;
45425: LD_VAR 0 2
45429: RET
// export function MC_GetProduceList ( base ) ; begin
45430: LD_INT 0
45432: PPUSH
// result := mc_produce [ base ] ;
45433: LD_ADDR_VAR 0 2
45437: PUSH
45438: LD_EXP 114
45442: PUSH
45443: LD_VAR 0 1
45447: ARRAY
45448: ST_TO_ADDR
// end ;
45449: LD_VAR 0 2
45453: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45454: LD_INT 0
45456: PPUSH
45457: PPUSH
// if not mc_bases then
45458: LD_EXP 93
45462: NOT
45463: IFFALSE 45467
// exit ;
45465: GO 45532
// if mc_bases [ base ] then
45467: LD_EXP 93
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: IFFALSE 45532
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45479: LD_ADDR_VAR 0 3
45483: PUSH
45484: LD_EXP 93
45488: PUSH
45489: LD_VAR 0 1
45493: ARRAY
45494: PPUSH
45495: LD_INT 30
45497: PUSH
45498: LD_VAR 0 2
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PPUSH
45507: CALL_OW 72
45511: ST_TO_ADDR
// if result then
45512: LD_VAR 0 3
45516: IFFALSE 45532
// result := result [ 1 ] ;
45518: LD_ADDR_VAR 0 3
45522: PUSH
45523: LD_VAR 0 3
45527: PUSH
45528: LD_INT 1
45530: ARRAY
45531: ST_TO_ADDR
// end ; end ;
45532: LD_VAR 0 3
45536: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45537: LD_INT 0
45539: PPUSH
45540: PPUSH
// if not mc_bases then
45541: LD_EXP 93
45545: NOT
45546: IFFALSE 45550
// exit ;
45548: GO 45595
// if mc_bases [ base ] then
45550: LD_EXP 93
45554: PUSH
45555: LD_VAR 0 1
45559: ARRAY
45560: IFFALSE 45595
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45562: LD_ADDR_VAR 0 3
45566: PUSH
45567: LD_EXP 93
45571: PUSH
45572: LD_VAR 0 1
45576: ARRAY
45577: PPUSH
45578: LD_INT 30
45580: PUSH
45581: LD_VAR 0 2
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PPUSH
45590: CALL_OW 72
45594: ST_TO_ADDR
// end ;
45595: LD_VAR 0 3
45599: RET
// export function MC_SetTame ( base , area ) ; begin
45600: LD_INT 0
45602: PPUSH
// if not mc_bases or not base then
45603: LD_EXP 93
45607: NOT
45608: PUSH
45609: LD_VAR 0 1
45613: NOT
45614: OR
45615: IFFALSE 45619
// exit ;
45617: GO 45644
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45619: LD_ADDR_EXP 121
45623: PUSH
45624: LD_EXP 121
45628: PPUSH
45629: LD_VAR 0 1
45633: PPUSH
45634: LD_VAR 0 2
45638: PPUSH
45639: CALL_OW 1
45643: ST_TO_ADDR
// end ;
45644: LD_VAR 0 3
45648: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45649: LD_INT 0
45651: PPUSH
45652: PPUSH
// if not mc_bases or not base then
45653: LD_EXP 93
45657: NOT
45658: PUSH
45659: LD_VAR 0 1
45663: NOT
45664: OR
45665: IFFALSE 45669
// exit ;
45667: GO 45771
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45669: LD_ADDR_VAR 0 4
45673: PUSH
45674: LD_EXP 93
45678: PUSH
45679: LD_VAR 0 1
45683: ARRAY
45684: PPUSH
45685: LD_INT 30
45687: PUSH
45688: LD_VAR 0 2
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PPUSH
45697: CALL_OW 72
45701: ST_TO_ADDR
// if not tmp then
45702: LD_VAR 0 4
45706: NOT
45707: IFFALSE 45711
// exit ;
45709: GO 45771
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45711: LD_ADDR_EXP 125
45715: PUSH
45716: LD_EXP 125
45720: PPUSH
45721: LD_VAR 0 1
45725: PPUSH
45726: LD_EXP 125
45730: PUSH
45731: LD_VAR 0 1
45735: ARRAY
45736: PPUSH
45737: LD_EXP 125
45741: PUSH
45742: LD_VAR 0 1
45746: ARRAY
45747: PUSH
45748: LD_INT 1
45750: PLUS
45751: PPUSH
45752: LD_VAR 0 4
45756: PUSH
45757: LD_INT 1
45759: ARRAY
45760: PPUSH
45761: CALL_OW 2
45765: PPUSH
45766: CALL_OW 1
45770: ST_TO_ADDR
// end ;
45771: LD_VAR 0 3
45775: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45776: LD_INT 0
45778: PPUSH
45779: PPUSH
// if not mc_bases or not base or not kinds then
45780: LD_EXP 93
45784: NOT
45785: PUSH
45786: LD_VAR 0 1
45790: NOT
45791: OR
45792: PUSH
45793: LD_VAR 0 2
45797: NOT
45798: OR
45799: IFFALSE 45803
// exit ;
45801: GO 45864
// for i in kinds do
45803: LD_ADDR_VAR 0 4
45807: PUSH
45808: LD_VAR 0 2
45812: PUSH
45813: FOR_IN
45814: IFFALSE 45862
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45816: LD_ADDR_EXP 127
45820: PUSH
45821: LD_EXP 127
45825: PPUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_EXP 127
45835: PUSH
45836: LD_VAR 0 1
45840: ARRAY
45841: PUSH
45842: LD_INT 1
45844: PLUS
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PPUSH
45850: LD_VAR 0 4
45854: PPUSH
45855: CALL 56474 0 3
45859: ST_TO_ADDR
45860: GO 45813
45862: POP
45863: POP
// end ;
45864: LD_VAR 0 3
45868: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45869: LD_INT 0
45871: PPUSH
// if not mc_bases or not base or not areas then
45872: LD_EXP 93
45876: NOT
45877: PUSH
45878: LD_VAR 0 1
45882: NOT
45883: OR
45884: PUSH
45885: LD_VAR 0 2
45889: NOT
45890: OR
45891: IFFALSE 45895
// exit ;
45893: GO 45920
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45895: LD_ADDR_EXP 111
45899: PUSH
45900: LD_EXP 111
45904: PPUSH
45905: LD_VAR 0 1
45909: PPUSH
45910: LD_VAR 0 2
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// end ;
45920: LD_VAR 0 3
45924: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45925: LD_INT 0
45927: PPUSH
// if not mc_bases or not base or not teleports_exit then
45928: LD_EXP 93
45932: NOT
45933: PUSH
45934: LD_VAR 0 1
45938: NOT
45939: OR
45940: PUSH
45941: LD_VAR 0 2
45945: NOT
45946: OR
45947: IFFALSE 45951
// exit ;
45949: GO 45976
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45951: LD_ADDR_EXP 128
45955: PUSH
45956: LD_EXP 128
45960: PPUSH
45961: LD_VAR 0 1
45965: PPUSH
45966: LD_VAR 0 2
45970: PPUSH
45971: CALL_OW 1
45975: ST_TO_ADDR
// end ;
45976: LD_VAR 0 3
45980: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45981: LD_INT 0
45983: PPUSH
45984: PPUSH
45985: PPUSH
// if not mc_bases or not base or not ext_list then
45986: LD_EXP 93
45990: NOT
45991: PUSH
45992: LD_VAR 0 1
45996: NOT
45997: OR
45998: PUSH
45999: LD_VAR 0 5
46003: NOT
46004: OR
46005: IFFALSE 46009
// exit ;
46007: GO 46182
// tmp := GetFacExtXYD ( x , y , d ) ;
46009: LD_ADDR_VAR 0 8
46013: PUSH
46014: LD_VAR 0 2
46018: PPUSH
46019: LD_VAR 0 3
46023: PPUSH
46024: LD_VAR 0 4
46028: PPUSH
46029: CALL 85861 0 3
46033: ST_TO_ADDR
// if not tmp then
46034: LD_VAR 0 8
46038: NOT
46039: IFFALSE 46043
// exit ;
46041: GO 46182
// for i in tmp do
46043: LD_ADDR_VAR 0 7
46047: PUSH
46048: LD_VAR 0 8
46052: PUSH
46053: FOR_IN
46054: IFFALSE 46180
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46056: LD_ADDR_EXP 98
46060: PUSH
46061: LD_EXP 98
46065: PPUSH
46066: LD_VAR 0 1
46070: PPUSH
46071: LD_EXP 98
46075: PUSH
46076: LD_VAR 0 1
46080: ARRAY
46081: PPUSH
46082: LD_EXP 98
46086: PUSH
46087: LD_VAR 0 1
46091: ARRAY
46092: PUSH
46093: LD_INT 1
46095: PLUS
46096: PPUSH
46097: LD_VAR 0 5
46101: PUSH
46102: LD_INT 1
46104: ARRAY
46105: PUSH
46106: LD_VAR 0 7
46110: PUSH
46111: LD_INT 1
46113: ARRAY
46114: PUSH
46115: LD_VAR 0 7
46119: PUSH
46120: LD_INT 2
46122: ARRAY
46123: PUSH
46124: LD_VAR 0 7
46128: PUSH
46129: LD_INT 3
46131: ARRAY
46132: PUSH
46133: EMPTY
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: PPUSH
46139: CALL_OW 2
46143: PPUSH
46144: CALL_OW 1
46148: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46149: LD_ADDR_VAR 0 5
46153: PUSH
46154: LD_VAR 0 5
46158: PPUSH
46159: LD_INT 1
46161: PPUSH
46162: CALL_OW 3
46166: ST_TO_ADDR
// if not ext_list then
46167: LD_VAR 0 5
46171: NOT
46172: IFFALSE 46178
// exit ;
46174: POP
46175: POP
46176: GO 46182
// end ;
46178: GO 46053
46180: POP
46181: POP
// end ;
46182: LD_VAR 0 6
46186: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46187: LD_INT 0
46189: PPUSH
// if not mc_bases or not base or not weapon_list then
46190: LD_EXP 93
46194: NOT
46195: PUSH
46196: LD_VAR 0 1
46200: NOT
46201: OR
46202: PUSH
46203: LD_VAR 0 2
46207: NOT
46208: OR
46209: IFFALSE 46213
// exit ;
46211: GO 46238
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46213: LD_ADDR_EXP 132
46217: PUSH
46218: LD_EXP 132
46222: PPUSH
46223: LD_VAR 0 1
46227: PPUSH
46228: LD_VAR 0 2
46232: PPUSH
46233: CALL_OW 1
46237: ST_TO_ADDR
// end ;
46238: LD_VAR 0 3
46242: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46243: LD_INT 0
46245: PPUSH
// if not mc_bases or not base or not tech_list then
46246: LD_EXP 93
46250: NOT
46251: PUSH
46252: LD_VAR 0 1
46256: NOT
46257: OR
46258: PUSH
46259: LD_VAR 0 2
46263: NOT
46264: OR
46265: IFFALSE 46269
// exit ;
46267: GO 46294
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46269: LD_ADDR_EXP 120
46273: PUSH
46274: LD_EXP 120
46278: PPUSH
46279: LD_VAR 0 1
46283: PPUSH
46284: LD_VAR 0 2
46288: PPUSH
46289: CALL_OW 1
46293: ST_TO_ADDR
// end ;
46294: LD_VAR 0 3
46298: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46299: LD_INT 0
46301: PPUSH
// if not mc_bases or not parking_area or not base then
46302: LD_EXP 93
46306: NOT
46307: PUSH
46308: LD_VAR 0 2
46312: NOT
46313: OR
46314: PUSH
46315: LD_VAR 0 1
46319: NOT
46320: OR
46321: IFFALSE 46325
// exit ;
46323: GO 46350
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46325: LD_ADDR_EXP 117
46329: PUSH
46330: LD_EXP 117
46334: PPUSH
46335: LD_VAR 0 1
46339: PPUSH
46340: LD_VAR 0 2
46344: PPUSH
46345: CALL_OW 1
46349: ST_TO_ADDR
// end ;
46350: LD_VAR 0 3
46354: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46355: LD_INT 0
46357: PPUSH
// if not mc_bases or not base or not scan_area then
46358: LD_EXP 93
46362: NOT
46363: PUSH
46364: LD_VAR 0 1
46368: NOT
46369: OR
46370: PUSH
46371: LD_VAR 0 2
46375: NOT
46376: OR
46377: IFFALSE 46381
// exit ;
46379: GO 46406
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46381: LD_ADDR_EXP 118
46385: PUSH
46386: LD_EXP 118
46390: PPUSH
46391: LD_VAR 0 1
46395: PPUSH
46396: LD_VAR 0 2
46400: PPUSH
46401: CALL_OW 1
46405: ST_TO_ADDR
// end ;
46406: LD_VAR 0 3
46410: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46411: LD_INT 0
46413: PPUSH
46414: PPUSH
// if not mc_bases or not base then
46415: LD_EXP 93
46419: NOT
46420: PUSH
46421: LD_VAR 0 1
46425: NOT
46426: OR
46427: IFFALSE 46431
// exit ;
46429: GO 46495
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46431: LD_ADDR_VAR 0 3
46435: PUSH
46436: LD_INT 1
46438: PUSH
46439: LD_INT 2
46441: PUSH
46442: LD_INT 3
46444: PUSH
46445: LD_INT 4
46447: PUSH
46448: LD_INT 11
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46458: LD_ADDR_EXP 120
46462: PUSH
46463: LD_EXP 120
46467: PPUSH
46468: LD_VAR 0 1
46472: PPUSH
46473: LD_EXP 120
46477: PUSH
46478: LD_VAR 0 1
46482: ARRAY
46483: PUSH
46484: LD_VAR 0 3
46488: DIFF
46489: PPUSH
46490: CALL_OW 1
46494: ST_TO_ADDR
// end ;
46495: LD_VAR 0 2
46499: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46500: LD_INT 0
46502: PPUSH
// result := mc_vehicles [ base ] ;
46503: LD_ADDR_VAR 0 3
46507: PUSH
46508: LD_EXP 112
46512: PUSH
46513: LD_VAR 0 1
46517: ARRAY
46518: ST_TO_ADDR
// if onlyCombat then
46519: LD_VAR 0 2
46523: IFFALSE 46701
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46525: LD_ADDR_VAR 0 3
46529: PUSH
46530: LD_VAR 0 3
46534: PUSH
46535: LD_VAR 0 3
46539: PPUSH
46540: LD_INT 2
46542: PUSH
46543: LD_INT 34
46545: PUSH
46546: LD_INT 12
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 34
46555: PUSH
46556: LD_INT 51
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PUSH
46563: LD_INT 34
46565: PUSH
46566: LD_EXP 73
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 34
46577: PUSH
46578: LD_INT 32
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: LD_INT 34
46587: PUSH
46588: LD_INT 13
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 34
46597: PUSH
46598: LD_INT 52
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 34
46607: PUSH
46608: LD_EXP 78
46612: PUSH
46613: EMPTY
46614: LIST
46615: LIST
46616: PUSH
46617: LD_INT 34
46619: PUSH
46620: LD_INT 14
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 34
46629: PUSH
46630: LD_INT 53
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 34
46639: PUSH
46640: LD_EXP 72
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: PUSH
46649: LD_INT 34
46651: PUSH
46652: LD_INT 31
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: PUSH
46659: LD_INT 34
46661: PUSH
46662: LD_INT 48
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: LD_INT 34
46671: PUSH
46672: LD_INT 8
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: PPUSH
46695: CALL_OW 72
46699: DIFF
46700: ST_TO_ADDR
// end ; end_of_file
46701: LD_VAR 0 3
46705: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46706: LD_INT 0
46708: PPUSH
46709: PPUSH
46710: PPUSH
// if not mc_bases or not skirmish then
46711: LD_EXP 93
46715: NOT
46716: PUSH
46717: LD_EXP 91
46721: NOT
46722: OR
46723: IFFALSE 46727
// exit ;
46725: GO 46892
// for i = 1 to mc_bases do
46727: LD_ADDR_VAR 0 4
46731: PUSH
46732: DOUBLE
46733: LD_INT 1
46735: DEC
46736: ST_TO_ADDR
46737: LD_EXP 93
46741: PUSH
46742: FOR_TO
46743: IFFALSE 46890
// begin if sci in mc_bases [ i ] then
46745: LD_VAR 0 2
46749: PUSH
46750: LD_EXP 93
46754: PUSH
46755: LD_VAR 0 4
46759: ARRAY
46760: IN
46761: IFFALSE 46888
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46763: LD_ADDR_EXP 122
46767: PUSH
46768: LD_EXP 122
46772: PPUSH
46773: LD_VAR 0 4
46777: PUSH
46778: LD_EXP 122
46782: PUSH
46783: LD_VAR 0 4
46787: ARRAY
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: PUSH
46793: EMPTY
46794: LIST
46795: LIST
46796: PPUSH
46797: LD_VAR 0 1
46801: PPUSH
46802: CALL 56474 0 3
46806: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46807: LD_ADDR_VAR 0 5
46811: PUSH
46812: LD_EXP 93
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PPUSH
46823: LD_INT 2
46825: PUSH
46826: LD_INT 30
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 30
46838: PUSH
46839: LD_INT 1
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: LIST
46850: PPUSH
46851: CALL_OW 72
46855: PPUSH
46856: LD_VAR 0 1
46860: PPUSH
46861: CALL_OW 74
46865: ST_TO_ADDR
// if tmp then
46866: LD_VAR 0 5
46870: IFFALSE 46886
// ComStandNearbyBuilding ( ape , tmp ) ;
46872: LD_VAR 0 1
46876: PPUSH
46877: LD_VAR 0 5
46881: PPUSH
46882: CALL 53052 0 2
// break ;
46886: GO 46890
// end ; end ;
46888: GO 46742
46890: POP
46891: POP
// end ;
46892: LD_VAR 0 3
46896: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46897: LD_INT 0
46899: PPUSH
46900: PPUSH
46901: PPUSH
// if not mc_bases or not skirmish then
46902: LD_EXP 93
46906: NOT
46907: PUSH
46908: LD_EXP 91
46912: NOT
46913: OR
46914: IFFALSE 46918
// exit ;
46916: GO 47007
// for i = 1 to mc_bases do
46918: LD_ADDR_VAR 0 4
46922: PUSH
46923: DOUBLE
46924: LD_INT 1
46926: DEC
46927: ST_TO_ADDR
46928: LD_EXP 93
46932: PUSH
46933: FOR_TO
46934: IFFALSE 47005
// begin if building in mc_busy_turret_list [ i ] then
46936: LD_VAR 0 1
46940: PUSH
46941: LD_EXP 103
46945: PUSH
46946: LD_VAR 0 4
46950: ARRAY
46951: IN
46952: IFFALSE 47003
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46954: LD_ADDR_VAR 0 5
46958: PUSH
46959: LD_EXP 103
46963: PUSH
46964: LD_VAR 0 4
46968: ARRAY
46969: PUSH
46970: LD_VAR 0 1
46974: DIFF
46975: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46976: LD_ADDR_EXP 103
46980: PUSH
46981: LD_EXP 103
46985: PPUSH
46986: LD_VAR 0 4
46990: PPUSH
46991: LD_VAR 0 5
46995: PPUSH
46996: CALL_OW 1
47000: ST_TO_ADDR
// break ;
47001: GO 47005
// end ; end ;
47003: GO 46933
47005: POP
47006: POP
// end ;
47007: LD_VAR 0 3
47011: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47012: LD_INT 0
47014: PPUSH
47015: PPUSH
47016: PPUSH
// if not mc_bases or not skirmish then
47017: LD_EXP 93
47021: NOT
47022: PUSH
47023: LD_EXP 91
47027: NOT
47028: OR
47029: IFFALSE 47033
// exit ;
47031: GO 47232
// for i = 1 to mc_bases do
47033: LD_ADDR_VAR 0 5
47037: PUSH
47038: DOUBLE
47039: LD_INT 1
47041: DEC
47042: ST_TO_ADDR
47043: LD_EXP 93
47047: PUSH
47048: FOR_TO
47049: IFFALSE 47230
// if building in mc_bases [ i ] then
47051: LD_VAR 0 1
47055: PUSH
47056: LD_EXP 93
47060: PUSH
47061: LD_VAR 0 5
47065: ARRAY
47066: IN
47067: IFFALSE 47228
// begin tmp := mc_bases [ i ] diff building ;
47069: LD_ADDR_VAR 0 6
47073: PUSH
47074: LD_EXP 93
47078: PUSH
47079: LD_VAR 0 5
47083: ARRAY
47084: PUSH
47085: LD_VAR 0 1
47089: DIFF
47090: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47091: LD_ADDR_EXP 93
47095: PUSH
47096: LD_EXP 93
47100: PPUSH
47101: LD_VAR 0 5
47105: PPUSH
47106: LD_VAR 0 6
47110: PPUSH
47111: CALL_OW 1
47115: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47116: LD_VAR 0 1
47120: PUSH
47121: LD_EXP 101
47125: PUSH
47126: LD_VAR 0 5
47130: ARRAY
47131: IN
47132: IFFALSE 47171
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47134: LD_ADDR_EXP 101
47138: PUSH
47139: LD_EXP 101
47143: PPUSH
47144: LD_VAR 0 5
47148: PPUSH
47149: LD_EXP 101
47153: PUSH
47154: LD_VAR 0 5
47158: ARRAY
47159: PUSH
47160: LD_VAR 0 1
47164: DIFF
47165: PPUSH
47166: CALL_OW 1
47170: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47171: LD_VAR 0 1
47175: PUSH
47176: LD_EXP 102
47180: PUSH
47181: LD_VAR 0 5
47185: ARRAY
47186: IN
47187: IFFALSE 47226
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47189: LD_ADDR_EXP 102
47193: PUSH
47194: LD_EXP 102
47198: PPUSH
47199: LD_VAR 0 5
47203: PPUSH
47204: LD_EXP 102
47208: PUSH
47209: LD_VAR 0 5
47213: ARRAY
47214: PUSH
47215: LD_VAR 0 1
47219: DIFF
47220: PPUSH
47221: CALL_OW 1
47225: ST_TO_ADDR
// break ;
47226: GO 47230
// end ;
47228: GO 47048
47230: POP
47231: POP
// end ;
47232: LD_VAR 0 4
47236: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47237: LD_INT 0
47239: PPUSH
47240: PPUSH
47241: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47242: LD_EXP 93
47246: NOT
47247: PUSH
47248: LD_EXP 91
47252: NOT
47253: OR
47254: PUSH
47255: LD_VAR 0 3
47259: PUSH
47260: LD_EXP 119
47264: IN
47265: NOT
47266: OR
47267: IFFALSE 47271
// exit ;
47269: GO 47394
// for i = 1 to mc_vehicles do
47271: LD_ADDR_VAR 0 6
47275: PUSH
47276: DOUBLE
47277: LD_INT 1
47279: DEC
47280: ST_TO_ADDR
47281: LD_EXP 112
47285: PUSH
47286: FOR_TO
47287: IFFALSE 47392
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47289: LD_VAR 0 2
47293: PUSH
47294: LD_EXP 112
47298: PUSH
47299: LD_VAR 0 6
47303: ARRAY
47304: IN
47305: PUSH
47306: LD_VAR 0 1
47310: PUSH
47311: LD_EXP 112
47315: PUSH
47316: LD_VAR 0 6
47320: ARRAY
47321: IN
47322: OR
47323: IFFALSE 47390
// begin tmp := mc_vehicles [ i ] diff old ;
47325: LD_ADDR_VAR 0 7
47329: PUSH
47330: LD_EXP 112
47334: PUSH
47335: LD_VAR 0 6
47339: ARRAY
47340: PUSH
47341: LD_VAR 0 2
47345: DIFF
47346: ST_TO_ADDR
// tmp := tmp diff new ;
47347: LD_ADDR_VAR 0 7
47351: PUSH
47352: LD_VAR 0 7
47356: PUSH
47357: LD_VAR 0 1
47361: DIFF
47362: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47363: LD_ADDR_EXP 112
47367: PUSH
47368: LD_EXP 112
47372: PPUSH
47373: LD_VAR 0 6
47377: PPUSH
47378: LD_VAR 0 7
47382: PPUSH
47383: CALL_OW 1
47387: ST_TO_ADDR
// break ;
47388: GO 47392
// end ;
47390: GO 47286
47392: POP
47393: POP
// end ;
47394: LD_VAR 0 5
47398: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47399: LD_INT 0
47401: PPUSH
47402: PPUSH
47403: PPUSH
47404: PPUSH
// if not mc_bases or not skirmish then
47405: LD_EXP 93
47409: NOT
47410: PUSH
47411: LD_EXP 91
47415: NOT
47416: OR
47417: IFFALSE 47421
// exit ;
47419: GO 47813
// side := GetSide ( vehicle ) ;
47421: LD_ADDR_VAR 0 5
47425: PUSH
47426: LD_VAR 0 1
47430: PPUSH
47431: CALL_OW 255
47435: ST_TO_ADDR
// for i = 1 to mc_bases do
47436: LD_ADDR_VAR 0 4
47440: PUSH
47441: DOUBLE
47442: LD_INT 1
47444: DEC
47445: ST_TO_ADDR
47446: LD_EXP 93
47450: PUSH
47451: FOR_TO
47452: IFFALSE 47811
// begin if factory in mc_bases [ i ] then
47454: LD_VAR 0 2
47458: PUSH
47459: LD_EXP 93
47463: PUSH
47464: LD_VAR 0 4
47468: ARRAY
47469: IN
47470: IFFALSE 47809
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47472: LD_EXP 115
47476: PUSH
47477: LD_VAR 0 4
47481: ARRAY
47482: PUSH
47483: LD_EXP 104
47487: PUSH
47488: LD_VAR 0 4
47492: ARRAY
47493: LESS
47494: PUSH
47495: LD_VAR 0 1
47499: PPUSH
47500: CALL_OW 264
47504: PUSH
47505: LD_INT 31
47507: PUSH
47508: LD_INT 32
47510: PUSH
47511: LD_INT 51
47513: PUSH
47514: LD_EXP 73
47518: PUSH
47519: LD_INT 12
47521: PUSH
47522: LD_INT 30
47524: PUSH
47525: LD_EXP 72
47529: PUSH
47530: LD_INT 11
47532: PUSH
47533: LD_INT 53
47535: PUSH
47536: LD_INT 14
47538: PUSH
47539: LD_EXP 76
47543: PUSH
47544: LD_INT 29
47546: PUSH
47547: LD_EXP 74
47551: PUSH
47552: LD_INT 13
47554: PUSH
47555: LD_INT 52
47557: PUSH
47558: LD_EXP 78
47562: PUSH
47563: LD_INT 48
47565: PUSH
47566: LD_INT 8
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: IN
47589: NOT
47590: AND
47591: IFFALSE 47639
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47593: LD_ADDR_EXP 115
47597: PUSH
47598: LD_EXP 115
47602: PPUSH
47603: LD_VAR 0 4
47607: PUSH
47608: LD_EXP 115
47612: PUSH
47613: LD_VAR 0 4
47617: ARRAY
47618: PUSH
47619: LD_INT 1
47621: PLUS
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PPUSH
47627: LD_VAR 0 1
47631: PPUSH
47632: CALL 56474 0 3
47636: ST_TO_ADDR
47637: GO 47683
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47639: LD_ADDR_EXP 112
47643: PUSH
47644: LD_EXP 112
47648: PPUSH
47649: LD_VAR 0 4
47653: PUSH
47654: LD_EXP 112
47658: PUSH
47659: LD_VAR 0 4
47663: ARRAY
47664: PUSH
47665: LD_INT 1
47667: PLUS
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PPUSH
47673: LD_VAR 0 1
47677: PPUSH
47678: CALL 56474 0 3
47682: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47683: LD_VAR 0 1
47687: PPUSH
47688: CALL_OW 263
47692: PUSH
47693: LD_INT 2
47695: EQUAL
47696: IFFALSE 47725
// begin repeat wait ( 0 0$3 ) ;
47698: LD_INT 105
47700: PPUSH
47701: CALL_OW 67
// Connect ( vehicle ) ;
47705: LD_VAR 0 1
47709: PPUSH
47710: CALL 59445 0 1
// until IsControledBy ( vehicle ) ;
47714: LD_VAR 0 1
47718: PPUSH
47719: CALL_OW 312
47723: IFFALSE 47698
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47725: LD_VAR 0 1
47729: PPUSH
47730: LD_EXP 117
47734: PUSH
47735: LD_VAR 0 4
47739: ARRAY
47740: PPUSH
47741: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47745: LD_VAR 0 1
47749: PPUSH
47750: CALL_OW 263
47754: PUSH
47755: LD_INT 1
47757: NONEQUAL
47758: IFFALSE 47762
// break ;
47760: GO 47811
// repeat wait ( 0 0$1 ) ;
47762: LD_INT 35
47764: PPUSH
47765: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47769: LD_VAR 0 1
47773: PPUSH
47774: LD_EXP 117
47778: PUSH
47779: LD_VAR 0 4
47783: ARRAY
47784: PPUSH
47785: CALL_OW 308
47789: IFFALSE 47762
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47791: LD_VAR 0 1
47795: PPUSH
47796: CALL_OW 311
47800: PPUSH
47801: CALL_OW 121
// exit ;
47805: POP
47806: POP
47807: GO 47813
// end ; end ;
47809: GO 47451
47811: POP
47812: POP
// end ;
47813: LD_VAR 0 3
47817: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47818: LD_INT 0
47820: PPUSH
47821: PPUSH
47822: PPUSH
47823: PPUSH
// if not mc_bases or not skirmish then
47824: LD_EXP 93
47828: NOT
47829: PUSH
47830: LD_EXP 91
47834: NOT
47835: OR
47836: IFFALSE 47840
// exit ;
47838: GO 48193
// repeat wait ( 0 0$1 ) ;
47840: LD_INT 35
47842: PPUSH
47843: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47847: LD_VAR 0 2
47851: PPUSH
47852: LD_VAR 0 3
47856: PPUSH
47857: CALL_OW 284
47861: IFFALSE 47840
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47863: LD_VAR 0 2
47867: PPUSH
47868: LD_VAR 0 3
47872: PPUSH
47873: CALL_OW 283
47877: PUSH
47878: LD_INT 4
47880: EQUAL
47881: IFFALSE 47885
// exit ;
47883: GO 48193
// for i = 1 to mc_bases do
47885: LD_ADDR_VAR 0 7
47889: PUSH
47890: DOUBLE
47891: LD_INT 1
47893: DEC
47894: ST_TO_ADDR
47895: LD_EXP 93
47899: PUSH
47900: FOR_TO
47901: IFFALSE 48191
// begin if mc_crates_area [ i ] then
47903: LD_EXP 111
47907: PUSH
47908: LD_VAR 0 7
47912: ARRAY
47913: IFFALSE 48024
// for j in mc_crates_area [ i ] do
47915: LD_ADDR_VAR 0 8
47919: PUSH
47920: LD_EXP 111
47924: PUSH
47925: LD_VAR 0 7
47929: ARRAY
47930: PUSH
47931: FOR_IN
47932: IFFALSE 48022
// if InArea ( x , y , j ) then
47934: LD_VAR 0 2
47938: PPUSH
47939: LD_VAR 0 3
47943: PPUSH
47944: LD_VAR 0 8
47948: PPUSH
47949: CALL_OW 309
47953: IFFALSE 48020
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47955: LD_ADDR_EXP 109
47959: PUSH
47960: LD_EXP 109
47964: PPUSH
47965: LD_VAR 0 7
47969: PUSH
47970: LD_EXP 109
47974: PUSH
47975: LD_VAR 0 7
47979: ARRAY
47980: PUSH
47981: LD_INT 1
47983: PLUS
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PPUSH
47989: LD_VAR 0 4
47993: PUSH
47994: LD_VAR 0 2
47998: PUSH
47999: LD_VAR 0 3
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: LIST
48008: PPUSH
48009: CALL 56474 0 3
48013: ST_TO_ADDR
// exit ;
48014: POP
48015: POP
48016: POP
48017: POP
48018: GO 48193
// end ;
48020: GO 47931
48022: POP
48023: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48024: LD_ADDR_VAR 0 9
48028: PUSH
48029: LD_EXP 93
48033: PUSH
48034: LD_VAR 0 7
48038: ARRAY
48039: PPUSH
48040: LD_INT 2
48042: PUSH
48043: LD_INT 30
48045: PUSH
48046: LD_INT 0
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 30
48055: PUSH
48056: LD_INT 1
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: PPUSH
48068: CALL_OW 72
48072: ST_TO_ADDR
// if not depot then
48073: LD_VAR 0 9
48077: NOT
48078: IFFALSE 48082
// continue ;
48080: GO 47900
// for j in depot do
48082: LD_ADDR_VAR 0 8
48086: PUSH
48087: LD_VAR 0 9
48091: PUSH
48092: FOR_IN
48093: IFFALSE 48187
// if GetDistUnitXY ( j , x , y ) < 30 then
48095: LD_VAR 0 8
48099: PPUSH
48100: LD_VAR 0 2
48104: PPUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: CALL_OW 297
48114: PUSH
48115: LD_INT 30
48117: LESS
48118: IFFALSE 48185
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48120: LD_ADDR_EXP 109
48124: PUSH
48125: LD_EXP 109
48129: PPUSH
48130: LD_VAR 0 7
48134: PUSH
48135: LD_EXP 109
48139: PUSH
48140: LD_VAR 0 7
48144: ARRAY
48145: PUSH
48146: LD_INT 1
48148: PLUS
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PPUSH
48154: LD_VAR 0 4
48158: PUSH
48159: LD_VAR 0 2
48163: PUSH
48164: LD_VAR 0 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: LIST
48173: PPUSH
48174: CALL 56474 0 3
48178: ST_TO_ADDR
// exit ;
48179: POP
48180: POP
48181: POP
48182: POP
48183: GO 48193
// end ;
48185: GO 48092
48187: POP
48188: POP
// end ;
48189: GO 47900
48191: POP
48192: POP
// end ;
48193: LD_VAR 0 6
48197: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48198: LD_INT 0
48200: PPUSH
48201: PPUSH
48202: PPUSH
48203: PPUSH
// if not mc_bases or not skirmish then
48204: LD_EXP 93
48208: NOT
48209: PUSH
48210: LD_EXP 91
48214: NOT
48215: OR
48216: IFFALSE 48220
// exit ;
48218: GO 48497
// side := GetSide ( lab ) ;
48220: LD_ADDR_VAR 0 4
48224: PUSH
48225: LD_VAR 0 2
48229: PPUSH
48230: CALL_OW 255
48234: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48235: LD_VAR 0 4
48239: PUSH
48240: LD_EXP 119
48244: IN
48245: NOT
48246: PUSH
48247: LD_EXP 120
48251: NOT
48252: OR
48253: PUSH
48254: LD_EXP 93
48258: NOT
48259: OR
48260: IFFALSE 48264
// exit ;
48262: GO 48497
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48264: LD_ADDR_EXP 120
48268: PUSH
48269: LD_EXP 120
48273: PPUSH
48274: LD_VAR 0 4
48278: PPUSH
48279: LD_EXP 120
48283: PUSH
48284: LD_VAR 0 4
48288: ARRAY
48289: PUSH
48290: LD_VAR 0 1
48294: DIFF
48295: PPUSH
48296: CALL_OW 1
48300: ST_TO_ADDR
// for i = 1 to mc_bases do
48301: LD_ADDR_VAR 0 5
48305: PUSH
48306: DOUBLE
48307: LD_INT 1
48309: DEC
48310: ST_TO_ADDR
48311: LD_EXP 93
48315: PUSH
48316: FOR_TO
48317: IFFALSE 48495
// begin if lab in mc_bases [ i ] then
48319: LD_VAR 0 2
48323: PUSH
48324: LD_EXP 93
48328: PUSH
48329: LD_VAR 0 5
48333: ARRAY
48334: IN
48335: IFFALSE 48493
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48337: LD_VAR 0 1
48341: PUSH
48342: LD_INT 11
48344: PUSH
48345: LD_INT 4
48347: PUSH
48348: LD_INT 3
48350: PUSH
48351: LD_INT 2
48353: PUSH
48354: EMPTY
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: IN
48360: PUSH
48361: LD_EXP 123
48365: PUSH
48366: LD_VAR 0 5
48370: ARRAY
48371: AND
48372: IFFALSE 48493
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48374: LD_ADDR_VAR 0 6
48378: PUSH
48379: LD_EXP 123
48383: PUSH
48384: LD_VAR 0 5
48388: ARRAY
48389: PUSH
48390: LD_INT 1
48392: ARRAY
48393: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48394: LD_ADDR_EXP 123
48398: PUSH
48399: LD_EXP 123
48403: PPUSH
48404: LD_VAR 0 5
48408: PPUSH
48409: EMPTY
48410: PPUSH
48411: CALL_OW 1
48415: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48416: LD_VAR 0 6
48420: PPUSH
48421: LD_INT 0
48423: PPUSH
48424: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48428: LD_VAR 0 6
48432: PPUSH
48433: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48437: LD_ADDR_EXP 122
48441: PUSH
48442: LD_EXP 122
48446: PPUSH
48447: LD_VAR 0 5
48451: PPUSH
48452: LD_EXP 122
48456: PUSH
48457: LD_VAR 0 5
48461: ARRAY
48462: PPUSH
48463: LD_INT 1
48465: PPUSH
48466: LD_VAR 0 6
48470: PPUSH
48471: CALL_OW 2
48475: PPUSH
48476: CALL_OW 1
48480: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48481: LD_VAR 0 5
48485: PPUSH
48486: LD_INT 112
48488: PPUSH
48489: CALL 25016 0 2
// end ; end ; end ;
48493: GO 48316
48495: POP
48496: POP
// end ;
48497: LD_VAR 0 3
48501: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48502: LD_INT 0
48504: PPUSH
48505: PPUSH
48506: PPUSH
48507: PPUSH
48508: PPUSH
48509: PPUSH
48510: PPUSH
48511: PPUSH
// if not mc_bases or not skirmish then
48512: LD_EXP 93
48516: NOT
48517: PUSH
48518: LD_EXP 91
48522: NOT
48523: OR
48524: IFFALSE 48528
// exit ;
48526: GO 49899
// for i = 1 to mc_bases do
48528: LD_ADDR_VAR 0 3
48532: PUSH
48533: DOUBLE
48534: LD_INT 1
48536: DEC
48537: ST_TO_ADDR
48538: LD_EXP 93
48542: PUSH
48543: FOR_TO
48544: IFFALSE 49897
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48546: LD_VAR 0 1
48550: PUSH
48551: LD_EXP 93
48555: PUSH
48556: LD_VAR 0 3
48560: ARRAY
48561: IN
48562: PUSH
48563: LD_VAR 0 1
48567: PUSH
48568: LD_EXP 100
48572: PUSH
48573: LD_VAR 0 3
48577: ARRAY
48578: IN
48579: OR
48580: PUSH
48581: LD_VAR 0 1
48585: PUSH
48586: LD_EXP 115
48590: PUSH
48591: LD_VAR 0 3
48595: ARRAY
48596: IN
48597: OR
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_EXP 112
48608: PUSH
48609: LD_VAR 0 3
48613: ARRAY
48614: IN
48615: OR
48616: PUSH
48617: LD_VAR 0 1
48621: PUSH
48622: LD_EXP 122
48626: PUSH
48627: LD_VAR 0 3
48631: ARRAY
48632: IN
48633: OR
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_EXP 123
48644: PUSH
48645: LD_VAR 0 3
48649: ARRAY
48650: IN
48651: OR
48652: IFFALSE 49895
// begin if un in mc_ape [ i ] then
48654: LD_VAR 0 1
48658: PUSH
48659: LD_EXP 122
48663: PUSH
48664: LD_VAR 0 3
48668: ARRAY
48669: IN
48670: IFFALSE 48709
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48672: LD_ADDR_EXP 122
48676: PUSH
48677: LD_EXP 122
48681: PPUSH
48682: LD_VAR 0 3
48686: PPUSH
48687: LD_EXP 122
48691: PUSH
48692: LD_VAR 0 3
48696: ARRAY
48697: PUSH
48698: LD_VAR 0 1
48702: DIFF
48703: PPUSH
48704: CALL_OW 1
48708: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48709: LD_VAR 0 1
48713: PUSH
48714: LD_EXP 123
48718: PUSH
48719: LD_VAR 0 3
48723: ARRAY
48724: IN
48725: IFFALSE 48749
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48727: LD_ADDR_EXP 123
48731: PUSH
48732: LD_EXP 123
48736: PPUSH
48737: LD_VAR 0 3
48741: PPUSH
48742: EMPTY
48743: PPUSH
48744: CALL_OW 1
48748: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48749: LD_VAR 0 1
48753: PPUSH
48754: CALL_OW 247
48758: PUSH
48759: LD_INT 2
48761: EQUAL
48762: PUSH
48763: LD_VAR 0 1
48767: PPUSH
48768: CALL_OW 110
48772: PUSH
48773: LD_INT 20
48775: EQUAL
48776: PUSH
48777: LD_VAR 0 1
48781: PUSH
48782: LD_EXP 115
48786: PUSH
48787: LD_VAR 0 3
48791: ARRAY
48792: IN
48793: OR
48794: PUSH
48795: LD_VAR 0 1
48799: PPUSH
48800: CALL_OW 264
48804: PUSH
48805: LD_INT 12
48807: PUSH
48808: LD_INT 51
48810: PUSH
48811: LD_EXP 73
48815: PUSH
48816: LD_INT 32
48818: PUSH
48819: LD_INT 13
48821: PUSH
48822: LD_INT 52
48824: PUSH
48825: LD_INT 31
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: IN
48837: OR
48838: AND
48839: IFFALSE 49147
// begin if un in mc_defender [ i ] then
48841: LD_VAR 0 1
48845: PUSH
48846: LD_EXP 115
48850: PUSH
48851: LD_VAR 0 3
48855: ARRAY
48856: IN
48857: IFFALSE 48896
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48859: LD_ADDR_EXP 115
48863: PUSH
48864: LD_EXP 115
48868: PPUSH
48869: LD_VAR 0 3
48873: PPUSH
48874: LD_EXP 115
48878: PUSH
48879: LD_VAR 0 3
48883: ARRAY
48884: PUSH
48885: LD_VAR 0 1
48889: DIFF
48890: PPUSH
48891: CALL_OW 1
48895: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48896: LD_ADDR_VAR 0 8
48900: PUSH
48901: LD_VAR 0 3
48905: PPUSH
48906: LD_INT 3
48908: PPUSH
48909: CALL 45537 0 2
48913: ST_TO_ADDR
// if fac then
48914: LD_VAR 0 8
48918: IFFALSE 49147
// begin for j in fac do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_VAR 0 8
48929: PUSH
48930: FOR_IN
48931: IFFALSE 49145
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48933: LD_ADDR_VAR 0 9
48937: PUSH
48938: LD_VAR 0 8
48942: PPUSH
48943: LD_VAR 0 1
48947: PPUSH
48948: CALL_OW 265
48952: PPUSH
48953: LD_VAR 0 1
48957: PPUSH
48958: CALL_OW 262
48962: PPUSH
48963: LD_VAR 0 1
48967: PPUSH
48968: CALL_OW 263
48972: PPUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 264
48982: PPUSH
48983: CALL 53970 0 5
48987: ST_TO_ADDR
// if components then
48988: LD_VAR 0 9
48992: IFFALSE 49143
// begin if GetWeapon ( un ) = ar_control_tower then
48994: LD_VAR 0 1
48998: PPUSH
48999: CALL_OW 264
49003: PUSH
49004: LD_INT 31
49006: EQUAL
49007: IFFALSE 49124
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49009: LD_VAR 0 1
49013: PPUSH
49014: CALL_OW 311
49018: PPUSH
49019: LD_INT 0
49021: PPUSH
49022: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49026: LD_ADDR_EXP 133
49030: PUSH
49031: LD_EXP 133
49035: PPUSH
49036: LD_VAR 0 3
49040: PPUSH
49041: LD_EXP 133
49045: PUSH
49046: LD_VAR 0 3
49050: ARRAY
49051: PUSH
49052: LD_VAR 0 1
49056: PPUSH
49057: CALL_OW 311
49061: DIFF
49062: PPUSH
49063: CALL_OW 1
49067: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49068: LD_ADDR_VAR 0 7
49072: PUSH
49073: LD_EXP 114
49077: PUSH
49078: LD_VAR 0 3
49082: ARRAY
49083: PPUSH
49084: LD_INT 1
49086: PPUSH
49087: LD_VAR 0 9
49091: PPUSH
49092: CALL_OW 2
49096: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49097: LD_ADDR_EXP 114
49101: PUSH
49102: LD_EXP 114
49106: PPUSH
49107: LD_VAR 0 3
49111: PPUSH
49112: LD_VAR 0 7
49116: PPUSH
49117: CALL_OW 1
49121: ST_TO_ADDR
// end else
49122: GO 49141
// MC_InsertProduceList ( i , [ components ] ) ;
49124: LD_VAR 0 3
49128: PPUSH
49129: LD_VAR 0 9
49133: PUSH
49134: EMPTY
49135: LIST
49136: PPUSH
49137: CALL 45082 0 2
// break ;
49141: GO 49145
// end ; end ;
49143: GO 48930
49145: POP
49146: POP
// end ; end ; if GetType ( un ) = unit_building then
49147: LD_VAR 0 1
49151: PPUSH
49152: CALL_OW 247
49156: PUSH
49157: LD_INT 3
49159: EQUAL
49160: IFFALSE 49563
// begin btype := GetBType ( un ) ;
49162: LD_ADDR_VAR 0 5
49166: PUSH
49167: LD_VAR 0 1
49171: PPUSH
49172: CALL_OW 266
49176: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49177: LD_VAR 0 5
49181: PUSH
49182: LD_INT 29
49184: PUSH
49185: LD_INT 30
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: IN
49192: IFFALSE 49265
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49194: LD_VAR 0 1
49198: PPUSH
49199: CALL_OW 250
49203: PPUSH
49204: LD_VAR 0 1
49208: PPUSH
49209: CALL_OW 251
49213: PPUSH
49214: LD_VAR 0 1
49218: PPUSH
49219: CALL_OW 255
49223: PPUSH
49224: CALL_OW 440
49228: NOT
49229: IFFALSE 49265
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49231: LD_VAR 0 1
49235: PPUSH
49236: CALL_OW 250
49240: PPUSH
49241: LD_VAR 0 1
49245: PPUSH
49246: CALL_OW 251
49250: PPUSH
49251: LD_VAR 0 1
49255: PPUSH
49256: CALL_OW 255
49260: PPUSH
49261: CALL_OW 441
// end ; if btype = b_warehouse then
49265: LD_VAR 0 5
49269: PUSH
49270: LD_INT 1
49272: EQUAL
49273: IFFALSE 49291
// begin btype := b_depot ;
49275: LD_ADDR_VAR 0 5
49279: PUSH
49280: LD_INT 0
49282: ST_TO_ADDR
// pos := 1 ;
49283: LD_ADDR_VAR 0 6
49287: PUSH
49288: LD_INT 1
49290: ST_TO_ADDR
// end ; if btype = b_factory then
49291: LD_VAR 0 5
49295: PUSH
49296: LD_INT 3
49298: EQUAL
49299: IFFALSE 49317
// begin btype := b_workshop ;
49301: LD_ADDR_VAR 0 5
49305: PUSH
49306: LD_INT 2
49308: ST_TO_ADDR
// pos := 1 ;
49309: LD_ADDR_VAR 0 6
49313: PUSH
49314: LD_INT 1
49316: ST_TO_ADDR
// end ; if btype = b_barracks then
49317: LD_VAR 0 5
49321: PUSH
49322: LD_INT 5
49324: EQUAL
49325: IFFALSE 49335
// btype := b_armoury ;
49327: LD_ADDR_VAR 0 5
49331: PUSH
49332: LD_INT 4
49334: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49335: LD_VAR 0 5
49339: PUSH
49340: LD_INT 7
49342: PUSH
49343: LD_INT 8
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: IN
49350: IFFALSE 49360
// btype := b_lab ;
49352: LD_ADDR_VAR 0 5
49356: PUSH
49357: LD_INT 6
49359: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49360: LD_ADDR_EXP 98
49364: PUSH
49365: LD_EXP 98
49369: PPUSH
49370: LD_VAR 0 3
49374: PUSH
49375: LD_EXP 98
49379: PUSH
49380: LD_VAR 0 3
49384: ARRAY
49385: PUSH
49386: LD_INT 1
49388: PLUS
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PPUSH
49394: LD_VAR 0 5
49398: PUSH
49399: LD_VAR 0 1
49403: PPUSH
49404: CALL_OW 250
49408: PUSH
49409: LD_VAR 0 1
49413: PPUSH
49414: CALL_OW 251
49418: PUSH
49419: LD_VAR 0 1
49423: PPUSH
49424: CALL_OW 254
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: LIST
49433: LIST
49434: PPUSH
49435: CALL 56474 0 3
49439: ST_TO_ADDR
// if pos = 1 then
49440: LD_VAR 0 6
49444: PUSH
49445: LD_INT 1
49447: EQUAL
49448: IFFALSE 49563
// begin tmp := mc_build_list [ i ] ;
49450: LD_ADDR_VAR 0 7
49454: PUSH
49455: LD_EXP 98
49459: PUSH
49460: LD_VAR 0 3
49464: ARRAY
49465: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49466: LD_VAR 0 7
49470: PPUSH
49471: LD_INT 2
49473: PUSH
49474: LD_INT 30
49476: PUSH
49477: LD_INT 0
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: PUSH
49484: LD_INT 30
49486: PUSH
49487: LD_INT 1
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: EMPTY
49495: LIST
49496: LIST
49497: LIST
49498: PPUSH
49499: CALL_OW 72
49503: IFFALSE 49513
// pos := 2 ;
49505: LD_ADDR_VAR 0 6
49509: PUSH
49510: LD_INT 2
49512: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49513: LD_ADDR_VAR 0 7
49517: PUSH
49518: LD_VAR 0 7
49522: PPUSH
49523: LD_VAR 0 6
49527: PPUSH
49528: LD_VAR 0 7
49532: PPUSH
49533: CALL 56800 0 3
49537: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49538: LD_ADDR_EXP 98
49542: PUSH
49543: LD_EXP 98
49547: PPUSH
49548: LD_VAR 0 3
49552: PPUSH
49553: LD_VAR 0 7
49557: PPUSH
49558: CALL_OW 1
49562: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49563: LD_VAR 0 1
49567: PUSH
49568: LD_EXP 93
49572: PUSH
49573: LD_VAR 0 3
49577: ARRAY
49578: IN
49579: IFFALSE 49618
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49581: LD_ADDR_EXP 93
49585: PUSH
49586: LD_EXP 93
49590: PPUSH
49591: LD_VAR 0 3
49595: PPUSH
49596: LD_EXP 93
49600: PUSH
49601: LD_VAR 0 3
49605: ARRAY
49606: PUSH
49607: LD_VAR 0 1
49611: DIFF
49612: PPUSH
49613: CALL_OW 1
49617: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49618: LD_VAR 0 1
49622: PUSH
49623: LD_EXP 100
49627: PUSH
49628: LD_VAR 0 3
49632: ARRAY
49633: IN
49634: IFFALSE 49673
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49636: LD_ADDR_EXP 100
49640: PUSH
49641: LD_EXP 100
49645: PPUSH
49646: LD_VAR 0 3
49650: PPUSH
49651: LD_EXP 100
49655: PUSH
49656: LD_VAR 0 3
49660: ARRAY
49661: PUSH
49662: LD_VAR 0 1
49666: DIFF
49667: PPUSH
49668: CALL_OW 1
49672: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49673: LD_VAR 0 1
49677: PUSH
49678: LD_EXP 112
49682: PUSH
49683: LD_VAR 0 3
49687: ARRAY
49688: IN
49689: IFFALSE 49728
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49691: LD_ADDR_EXP 112
49695: PUSH
49696: LD_EXP 112
49700: PPUSH
49701: LD_VAR 0 3
49705: PPUSH
49706: LD_EXP 112
49710: PUSH
49711: LD_VAR 0 3
49715: ARRAY
49716: PUSH
49717: LD_VAR 0 1
49721: DIFF
49722: PPUSH
49723: CALL_OW 1
49727: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49728: LD_VAR 0 1
49732: PUSH
49733: LD_EXP 115
49737: PUSH
49738: LD_VAR 0 3
49742: ARRAY
49743: IN
49744: IFFALSE 49783
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49746: LD_ADDR_EXP 115
49750: PUSH
49751: LD_EXP 115
49755: PPUSH
49756: LD_VAR 0 3
49760: PPUSH
49761: LD_EXP 115
49765: PUSH
49766: LD_VAR 0 3
49770: ARRAY
49771: PUSH
49772: LD_VAR 0 1
49776: DIFF
49777: PPUSH
49778: CALL_OW 1
49782: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49783: LD_VAR 0 1
49787: PUSH
49788: LD_EXP 102
49792: PUSH
49793: LD_VAR 0 3
49797: ARRAY
49798: IN
49799: IFFALSE 49838
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49801: LD_ADDR_EXP 102
49805: PUSH
49806: LD_EXP 102
49810: PPUSH
49811: LD_VAR 0 3
49815: PPUSH
49816: LD_EXP 102
49820: PUSH
49821: LD_VAR 0 3
49825: ARRAY
49826: PUSH
49827: LD_VAR 0 1
49831: DIFF
49832: PPUSH
49833: CALL_OW 1
49837: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49838: LD_VAR 0 1
49842: PUSH
49843: LD_EXP 101
49847: PUSH
49848: LD_VAR 0 3
49852: ARRAY
49853: IN
49854: IFFALSE 49893
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49856: LD_ADDR_EXP 101
49860: PUSH
49861: LD_EXP 101
49865: PPUSH
49866: LD_VAR 0 3
49870: PPUSH
49871: LD_EXP 101
49875: PUSH
49876: LD_VAR 0 3
49880: ARRAY
49881: PUSH
49882: LD_VAR 0 1
49886: DIFF
49887: PPUSH
49888: CALL_OW 1
49892: ST_TO_ADDR
// end ; break ;
49893: GO 49897
// end ;
49895: GO 48543
49897: POP
49898: POP
// end ;
49899: LD_VAR 0 2
49903: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49904: LD_INT 0
49906: PPUSH
49907: PPUSH
49908: PPUSH
// if not mc_bases or not skirmish then
49909: LD_EXP 93
49913: NOT
49914: PUSH
49915: LD_EXP 91
49919: NOT
49920: OR
49921: IFFALSE 49925
// exit ;
49923: GO 50140
// for i = 1 to mc_bases do
49925: LD_ADDR_VAR 0 3
49929: PUSH
49930: DOUBLE
49931: LD_INT 1
49933: DEC
49934: ST_TO_ADDR
49935: LD_EXP 93
49939: PUSH
49940: FOR_TO
49941: IFFALSE 50138
// begin if building in mc_construct_list [ i ] then
49943: LD_VAR 0 1
49947: PUSH
49948: LD_EXP 100
49952: PUSH
49953: LD_VAR 0 3
49957: ARRAY
49958: IN
49959: IFFALSE 50136
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49961: LD_ADDR_EXP 100
49965: PUSH
49966: LD_EXP 100
49970: PPUSH
49971: LD_VAR 0 3
49975: PPUSH
49976: LD_EXP 100
49980: PUSH
49981: LD_VAR 0 3
49985: ARRAY
49986: PUSH
49987: LD_VAR 0 1
49991: DIFF
49992: PPUSH
49993: CALL_OW 1
49997: ST_TO_ADDR
// if building in mc_lab [ i ] then
49998: LD_VAR 0 1
50002: PUSH
50003: LD_EXP 126
50007: PUSH
50008: LD_VAR 0 3
50012: ARRAY
50013: IN
50014: IFFALSE 50069
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50016: LD_ADDR_EXP 127
50020: PUSH
50021: LD_EXP 127
50025: PPUSH
50026: LD_VAR 0 3
50030: PPUSH
50031: LD_EXP 127
50035: PUSH
50036: LD_VAR 0 3
50040: ARRAY
50041: PPUSH
50042: LD_INT 1
50044: PPUSH
50045: LD_EXP 127
50049: PUSH
50050: LD_VAR 0 3
50054: ARRAY
50055: PPUSH
50056: LD_INT 0
50058: PPUSH
50059: CALL 55892 0 4
50063: PPUSH
50064: CALL_OW 1
50068: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50069: LD_VAR 0 1
50073: PUSH
50074: LD_EXP 93
50078: PUSH
50079: LD_VAR 0 3
50083: ARRAY
50084: IN
50085: NOT
50086: IFFALSE 50132
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50088: LD_ADDR_EXP 93
50092: PUSH
50093: LD_EXP 93
50097: PPUSH
50098: LD_VAR 0 3
50102: PUSH
50103: LD_EXP 93
50107: PUSH
50108: LD_VAR 0 3
50112: ARRAY
50113: PUSH
50114: LD_INT 1
50116: PLUS
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PPUSH
50122: LD_VAR 0 1
50126: PPUSH
50127: CALL 56474 0 3
50131: ST_TO_ADDR
// exit ;
50132: POP
50133: POP
50134: GO 50140
// end ; end ;
50136: GO 49940
50138: POP
50139: POP
// end ;
50140: LD_VAR 0 2
50144: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50145: LD_INT 0
50147: PPUSH
50148: PPUSH
50149: PPUSH
50150: PPUSH
50151: PPUSH
50152: PPUSH
50153: PPUSH
// if not mc_bases or not skirmish then
50154: LD_EXP 93
50158: NOT
50159: PUSH
50160: LD_EXP 91
50164: NOT
50165: OR
50166: IFFALSE 50170
// exit ;
50168: GO 50831
// for i = 1 to mc_bases do
50170: LD_ADDR_VAR 0 3
50174: PUSH
50175: DOUBLE
50176: LD_INT 1
50178: DEC
50179: ST_TO_ADDR
50180: LD_EXP 93
50184: PUSH
50185: FOR_TO
50186: IFFALSE 50829
// begin if building in mc_construct_list [ i ] then
50188: LD_VAR 0 1
50192: PUSH
50193: LD_EXP 100
50197: PUSH
50198: LD_VAR 0 3
50202: ARRAY
50203: IN
50204: IFFALSE 50827
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50206: LD_ADDR_EXP 100
50210: PUSH
50211: LD_EXP 100
50215: PPUSH
50216: LD_VAR 0 3
50220: PPUSH
50221: LD_EXP 100
50225: PUSH
50226: LD_VAR 0 3
50230: ARRAY
50231: PUSH
50232: LD_VAR 0 1
50236: DIFF
50237: PPUSH
50238: CALL_OW 1
50242: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50243: LD_ADDR_EXP 93
50247: PUSH
50248: LD_EXP 93
50252: PPUSH
50253: LD_VAR 0 3
50257: PUSH
50258: LD_EXP 93
50262: PUSH
50263: LD_VAR 0 3
50267: ARRAY
50268: PUSH
50269: LD_INT 1
50271: PLUS
50272: PUSH
50273: EMPTY
50274: LIST
50275: LIST
50276: PPUSH
50277: LD_VAR 0 1
50281: PPUSH
50282: CALL 56474 0 3
50286: ST_TO_ADDR
// btype := GetBType ( building ) ;
50287: LD_ADDR_VAR 0 5
50291: PUSH
50292: LD_VAR 0 1
50296: PPUSH
50297: CALL_OW 266
50301: ST_TO_ADDR
// side := GetSide ( building ) ;
50302: LD_ADDR_VAR 0 8
50306: PUSH
50307: LD_VAR 0 1
50311: PPUSH
50312: CALL_OW 255
50316: ST_TO_ADDR
// if btype = b_lab then
50317: LD_VAR 0 5
50321: PUSH
50322: LD_INT 6
50324: EQUAL
50325: IFFALSE 50375
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50327: LD_ADDR_EXP 126
50331: PUSH
50332: LD_EXP 126
50336: PPUSH
50337: LD_VAR 0 3
50341: PUSH
50342: LD_EXP 126
50346: PUSH
50347: LD_VAR 0 3
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: PPUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: CALL 56474 0 3
50370: ST_TO_ADDR
// exit ;
50371: POP
50372: POP
50373: GO 50831
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50375: LD_VAR 0 5
50379: PUSH
50380: LD_INT 0
50382: PUSH
50383: LD_INT 2
50385: PUSH
50386: LD_INT 4
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: LIST
50393: IN
50394: IFFALSE 50518
// begin if btype = b_armoury then
50396: LD_VAR 0 5
50400: PUSH
50401: LD_INT 4
50403: EQUAL
50404: IFFALSE 50414
// btype := b_barracks ;
50406: LD_ADDR_VAR 0 5
50410: PUSH
50411: LD_INT 5
50413: ST_TO_ADDR
// if btype = b_depot then
50414: LD_VAR 0 5
50418: PUSH
50419: LD_INT 0
50421: EQUAL
50422: IFFALSE 50432
// btype := b_warehouse ;
50424: LD_ADDR_VAR 0 5
50428: PUSH
50429: LD_INT 1
50431: ST_TO_ADDR
// if btype = b_workshop then
50432: LD_VAR 0 5
50436: PUSH
50437: LD_INT 2
50439: EQUAL
50440: IFFALSE 50450
// btype := b_factory ;
50442: LD_ADDR_VAR 0 5
50446: PUSH
50447: LD_INT 3
50449: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50450: LD_VAR 0 5
50454: PPUSH
50455: LD_VAR 0 8
50459: PPUSH
50460: CALL_OW 323
50464: PUSH
50465: LD_INT 1
50467: EQUAL
50468: IFFALSE 50514
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50470: LD_ADDR_EXP 125
50474: PUSH
50475: LD_EXP 125
50479: PPUSH
50480: LD_VAR 0 3
50484: PUSH
50485: LD_EXP 125
50489: PUSH
50490: LD_VAR 0 3
50494: ARRAY
50495: PUSH
50496: LD_INT 1
50498: PLUS
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: PPUSH
50504: LD_VAR 0 1
50508: PPUSH
50509: CALL 56474 0 3
50513: ST_TO_ADDR
// exit ;
50514: POP
50515: POP
50516: GO 50831
// end ; if btype in [ b_bunker , b_turret ] then
50518: LD_VAR 0 5
50522: PUSH
50523: LD_INT 32
50525: PUSH
50526: LD_INT 33
50528: PUSH
50529: EMPTY
50530: LIST
50531: LIST
50532: IN
50533: IFFALSE 50823
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50535: LD_ADDR_EXP 101
50539: PUSH
50540: LD_EXP 101
50544: PPUSH
50545: LD_VAR 0 3
50549: PUSH
50550: LD_EXP 101
50554: PUSH
50555: LD_VAR 0 3
50559: ARRAY
50560: PUSH
50561: LD_INT 1
50563: PLUS
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: PPUSH
50569: LD_VAR 0 1
50573: PPUSH
50574: CALL 56474 0 3
50578: ST_TO_ADDR
// if btype = b_bunker then
50579: LD_VAR 0 5
50583: PUSH
50584: LD_INT 32
50586: EQUAL
50587: IFFALSE 50823
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50589: LD_ADDR_EXP 102
50593: PUSH
50594: LD_EXP 102
50598: PPUSH
50599: LD_VAR 0 3
50603: PUSH
50604: LD_EXP 102
50608: PUSH
50609: LD_VAR 0 3
50613: ARRAY
50614: PUSH
50615: LD_INT 1
50617: PLUS
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: LD_VAR 0 1
50627: PPUSH
50628: CALL 56474 0 3
50632: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50633: LD_ADDR_VAR 0 6
50637: PUSH
50638: LD_EXP 93
50642: PUSH
50643: LD_VAR 0 3
50647: ARRAY
50648: PPUSH
50649: LD_INT 25
50651: PUSH
50652: LD_INT 1
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: LD_INT 54
50664: PUSH
50665: EMPTY
50666: LIST
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: PUSH
50672: EMPTY
50673: LIST
50674: LIST
50675: PPUSH
50676: CALL_OW 72
50680: ST_TO_ADDR
// if tmp then
50681: LD_VAR 0 6
50685: IFFALSE 50691
// exit ;
50687: POP
50688: POP
50689: GO 50831
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50691: LD_ADDR_VAR 0 6
50695: PUSH
50696: LD_EXP 93
50700: PUSH
50701: LD_VAR 0 3
50705: ARRAY
50706: PPUSH
50707: LD_INT 2
50709: PUSH
50710: LD_INT 30
50712: PUSH
50713: LD_INT 4
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 30
50722: PUSH
50723: LD_INT 5
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PUSH
50730: EMPTY
50731: LIST
50732: LIST
50733: LIST
50734: PPUSH
50735: CALL_OW 72
50739: ST_TO_ADDR
// if not tmp then
50740: LD_VAR 0 6
50744: NOT
50745: IFFALSE 50751
// exit ;
50747: POP
50748: POP
50749: GO 50831
// for j in tmp do
50751: LD_ADDR_VAR 0 4
50755: PUSH
50756: LD_VAR 0 6
50760: PUSH
50761: FOR_IN
50762: IFFALSE 50821
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50764: LD_ADDR_VAR 0 7
50768: PUSH
50769: LD_VAR 0 4
50773: PPUSH
50774: CALL_OW 313
50778: PPUSH
50779: LD_INT 25
50781: PUSH
50782: LD_INT 1
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PPUSH
50789: CALL_OW 72
50793: ST_TO_ADDR
// if units then
50794: LD_VAR 0 7
50798: IFFALSE 50819
// begin ComExitBuilding ( units [ 1 ] ) ;
50800: LD_VAR 0 7
50804: PUSH
50805: LD_INT 1
50807: ARRAY
50808: PPUSH
50809: CALL_OW 122
// exit ;
50813: POP
50814: POP
50815: POP
50816: POP
50817: GO 50831
// end ; end ;
50819: GO 50761
50821: POP
50822: POP
// end ; end ; exit ;
50823: POP
50824: POP
50825: GO 50831
// end ; end ;
50827: GO 50185
50829: POP
50830: POP
// end ;
50831: LD_VAR 0 2
50835: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50836: LD_INT 0
50838: PPUSH
50839: PPUSH
50840: PPUSH
50841: PPUSH
50842: PPUSH
50843: PPUSH
50844: PPUSH
// if not mc_bases or not skirmish then
50845: LD_EXP 93
50849: NOT
50850: PUSH
50851: LD_EXP 91
50855: NOT
50856: OR
50857: IFFALSE 50861
// exit ;
50859: GO 51126
// btype := GetBType ( building ) ;
50861: LD_ADDR_VAR 0 6
50865: PUSH
50866: LD_VAR 0 1
50870: PPUSH
50871: CALL_OW 266
50875: ST_TO_ADDR
// x := GetX ( building ) ;
50876: LD_ADDR_VAR 0 7
50880: PUSH
50881: LD_VAR 0 1
50885: PPUSH
50886: CALL_OW 250
50890: ST_TO_ADDR
// y := GetY ( building ) ;
50891: LD_ADDR_VAR 0 8
50895: PUSH
50896: LD_VAR 0 1
50900: PPUSH
50901: CALL_OW 251
50905: ST_TO_ADDR
// d := GetDir ( building ) ;
50906: LD_ADDR_VAR 0 9
50910: PUSH
50911: LD_VAR 0 1
50915: PPUSH
50916: CALL_OW 254
50920: ST_TO_ADDR
// for i = 1 to mc_bases do
50921: LD_ADDR_VAR 0 4
50925: PUSH
50926: DOUBLE
50927: LD_INT 1
50929: DEC
50930: ST_TO_ADDR
50931: LD_EXP 93
50935: PUSH
50936: FOR_TO
50937: IFFALSE 51124
// begin if not mc_build_list [ i ] then
50939: LD_EXP 98
50943: PUSH
50944: LD_VAR 0 4
50948: ARRAY
50949: NOT
50950: IFFALSE 50954
// continue ;
50952: GO 50936
// for j := 1 to mc_build_list [ i ] do
50954: LD_ADDR_VAR 0 5
50958: PUSH
50959: DOUBLE
50960: LD_INT 1
50962: DEC
50963: ST_TO_ADDR
50964: LD_EXP 98
50968: PUSH
50969: LD_VAR 0 4
50973: ARRAY
50974: PUSH
50975: FOR_TO
50976: IFFALSE 51120
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50978: LD_VAR 0 6
50982: PUSH
50983: LD_VAR 0 7
50987: PUSH
50988: LD_VAR 0 8
50992: PUSH
50993: LD_VAR 0 9
50997: PUSH
50998: EMPTY
50999: LIST
51000: LIST
51001: LIST
51002: LIST
51003: PPUSH
51004: LD_EXP 98
51008: PUSH
51009: LD_VAR 0 4
51013: ARRAY
51014: PUSH
51015: LD_VAR 0 5
51019: ARRAY
51020: PPUSH
51021: CALL 62656 0 2
51025: IFFALSE 51118
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51027: LD_ADDR_EXP 98
51031: PUSH
51032: LD_EXP 98
51036: PPUSH
51037: LD_VAR 0 4
51041: PPUSH
51042: LD_EXP 98
51046: PUSH
51047: LD_VAR 0 4
51051: ARRAY
51052: PPUSH
51053: LD_VAR 0 5
51057: PPUSH
51058: CALL_OW 3
51062: PPUSH
51063: CALL_OW 1
51067: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51068: LD_ADDR_EXP 100
51072: PUSH
51073: LD_EXP 100
51077: PPUSH
51078: LD_VAR 0 4
51082: PUSH
51083: LD_EXP 100
51087: PUSH
51088: LD_VAR 0 4
51092: ARRAY
51093: PUSH
51094: LD_INT 1
51096: PLUS
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PPUSH
51102: LD_VAR 0 1
51106: PPUSH
51107: CALL 56474 0 3
51111: ST_TO_ADDR
// exit ;
51112: POP
51113: POP
51114: POP
51115: POP
51116: GO 51126
// end ;
51118: GO 50975
51120: POP
51121: POP
// end ;
51122: GO 50936
51124: POP
51125: POP
// end ;
51126: LD_VAR 0 3
51130: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51131: LD_INT 0
51133: PPUSH
51134: PPUSH
51135: PPUSH
// if not mc_bases or not skirmish then
51136: LD_EXP 93
51140: NOT
51141: PUSH
51142: LD_EXP 91
51146: NOT
51147: OR
51148: IFFALSE 51152
// exit ;
51150: GO 51342
// for i = 1 to mc_bases do
51152: LD_ADDR_VAR 0 4
51156: PUSH
51157: DOUBLE
51158: LD_INT 1
51160: DEC
51161: ST_TO_ADDR
51162: LD_EXP 93
51166: PUSH
51167: FOR_TO
51168: IFFALSE 51255
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51170: LD_VAR 0 1
51174: PUSH
51175: LD_EXP 101
51179: PUSH
51180: LD_VAR 0 4
51184: ARRAY
51185: IN
51186: PUSH
51187: LD_VAR 0 1
51191: PUSH
51192: LD_EXP 102
51196: PUSH
51197: LD_VAR 0 4
51201: ARRAY
51202: IN
51203: NOT
51204: AND
51205: IFFALSE 51253
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51207: LD_ADDR_EXP 102
51211: PUSH
51212: LD_EXP 102
51216: PPUSH
51217: LD_VAR 0 4
51221: PUSH
51222: LD_EXP 102
51226: PUSH
51227: LD_VAR 0 4
51231: ARRAY
51232: PUSH
51233: LD_INT 1
51235: PLUS
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PPUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL 56474 0 3
51250: ST_TO_ADDR
// break ;
51251: GO 51255
// end ; end ;
51253: GO 51167
51255: POP
51256: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51257: LD_VAR 0 1
51261: PPUSH
51262: CALL_OW 257
51266: PUSH
51267: LD_EXP 119
51271: IN
51272: PUSH
51273: LD_VAR 0 1
51277: PPUSH
51278: CALL_OW 266
51282: PUSH
51283: LD_INT 5
51285: EQUAL
51286: AND
51287: PUSH
51288: LD_VAR 0 2
51292: PPUSH
51293: CALL_OW 110
51297: PUSH
51298: LD_INT 18
51300: NONEQUAL
51301: AND
51302: IFFALSE 51342
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51304: LD_VAR 0 2
51308: PPUSH
51309: CALL_OW 257
51313: PUSH
51314: LD_INT 5
51316: PUSH
51317: LD_INT 8
51319: PUSH
51320: LD_INT 9
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: LIST
51327: IN
51328: IFFALSE 51342
// SetClass ( unit , 1 ) ;
51330: LD_VAR 0 2
51334: PPUSH
51335: LD_INT 1
51337: PPUSH
51338: CALL_OW 336
// end ;
51342: LD_VAR 0 3
51346: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51347: LD_INT 0
51349: PPUSH
51350: PPUSH
// if not mc_bases or not skirmish then
51351: LD_EXP 93
51355: NOT
51356: PUSH
51357: LD_EXP 91
51361: NOT
51362: OR
51363: IFFALSE 51367
// exit ;
51365: GO 51483
// if GetLives ( abandoned_vehicle ) > 250 then
51367: LD_VAR 0 2
51371: PPUSH
51372: CALL_OW 256
51376: PUSH
51377: LD_INT 250
51379: GREATER
51380: IFFALSE 51384
// exit ;
51382: GO 51483
// for i = 1 to mc_bases do
51384: LD_ADDR_VAR 0 6
51388: PUSH
51389: DOUBLE
51390: LD_INT 1
51392: DEC
51393: ST_TO_ADDR
51394: LD_EXP 93
51398: PUSH
51399: FOR_TO
51400: IFFALSE 51481
// begin if driver in mc_bases [ i ] then
51402: LD_VAR 0 1
51406: PUSH
51407: LD_EXP 93
51411: PUSH
51412: LD_VAR 0 6
51416: ARRAY
51417: IN
51418: IFFALSE 51479
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51420: LD_VAR 0 1
51424: PPUSH
51425: LD_EXP 93
51429: PUSH
51430: LD_VAR 0 6
51434: ARRAY
51435: PPUSH
51436: LD_INT 2
51438: PUSH
51439: LD_INT 30
51441: PUSH
51442: LD_INT 0
51444: PUSH
51445: EMPTY
51446: LIST
51447: LIST
51448: PUSH
51449: LD_INT 30
51451: PUSH
51452: LD_INT 1
51454: PUSH
51455: EMPTY
51456: LIST
51457: LIST
51458: PUSH
51459: EMPTY
51460: LIST
51461: LIST
51462: LIST
51463: PPUSH
51464: CALL_OW 72
51468: PUSH
51469: LD_INT 1
51471: ARRAY
51472: PPUSH
51473: CALL 89092 0 2
// break ;
51477: GO 51481
// end ; end ;
51479: GO 51399
51481: POP
51482: POP
// end ; end_of_file
51483: LD_VAR 0 5
51487: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51488: LD_INT 0
51490: PPUSH
51491: PPUSH
// if exist_mode then
51492: LD_VAR 0 2
51496: IFFALSE 51521
// unit := CreateCharacter ( prefix & ident ) else
51498: LD_ADDR_VAR 0 5
51502: PUSH
51503: LD_VAR 0 3
51507: PUSH
51508: LD_VAR 0 1
51512: STR
51513: PPUSH
51514: CALL_OW 34
51518: ST_TO_ADDR
51519: GO 51536
// unit := NewCharacter ( ident ) ;
51521: LD_ADDR_VAR 0 5
51525: PUSH
51526: LD_VAR 0 1
51530: PPUSH
51531: CALL_OW 25
51535: ST_TO_ADDR
// result := unit ;
51536: LD_ADDR_VAR 0 4
51540: PUSH
51541: LD_VAR 0 5
51545: ST_TO_ADDR
// end ;
51546: LD_VAR 0 4
51550: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51551: LD_INT 0
51553: PPUSH
51554: PPUSH
// if not side or not nation then
51555: LD_VAR 0 1
51559: NOT
51560: PUSH
51561: LD_VAR 0 2
51565: NOT
51566: OR
51567: IFFALSE 51571
// exit ;
51569: GO 52339
// case nation of nation_american :
51571: LD_VAR 0 2
51575: PUSH
51576: LD_INT 1
51578: DOUBLE
51579: EQUAL
51580: IFTRUE 51584
51582: GO 51798
51584: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51585: LD_ADDR_VAR 0 4
51589: PUSH
51590: LD_INT 35
51592: PUSH
51593: LD_INT 45
51595: PUSH
51596: LD_INT 46
51598: PUSH
51599: LD_INT 47
51601: PUSH
51602: LD_INT 82
51604: PUSH
51605: LD_INT 83
51607: PUSH
51608: LD_INT 84
51610: PUSH
51611: LD_INT 85
51613: PUSH
51614: LD_INT 86
51616: PUSH
51617: LD_INT 1
51619: PUSH
51620: LD_INT 2
51622: PUSH
51623: LD_INT 6
51625: PUSH
51626: LD_INT 15
51628: PUSH
51629: LD_INT 16
51631: PUSH
51632: LD_INT 7
51634: PUSH
51635: LD_INT 12
51637: PUSH
51638: LD_INT 13
51640: PUSH
51641: LD_INT 10
51643: PUSH
51644: LD_INT 14
51646: PUSH
51647: LD_INT 20
51649: PUSH
51650: LD_INT 21
51652: PUSH
51653: LD_INT 22
51655: PUSH
51656: LD_INT 25
51658: PUSH
51659: LD_INT 32
51661: PUSH
51662: LD_INT 27
51664: PUSH
51665: LD_INT 36
51667: PUSH
51668: LD_INT 69
51670: PUSH
51671: LD_INT 39
51673: PUSH
51674: LD_INT 34
51676: PUSH
51677: LD_INT 40
51679: PUSH
51680: LD_INT 48
51682: PUSH
51683: LD_INT 49
51685: PUSH
51686: LD_INT 50
51688: PUSH
51689: LD_INT 51
51691: PUSH
51692: LD_INT 52
51694: PUSH
51695: LD_INT 53
51697: PUSH
51698: LD_INT 54
51700: PUSH
51701: LD_INT 55
51703: PUSH
51704: LD_INT 56
51706: PUSH
51707: LD_INT 57
51709: PUSH
51710: LD_INT 58
51712: PUSH
51713: LD_INT 59
51715: PUSH
51716: LD_INT 60
51718: PUSH
51719: LD_INT 61
51721: PUSH
51722: LD_INT 62
51724: PUSH
51725: LD_INT 80
51727: PUSH
51728: LD_INT 82
51730: PUSH
51731: LD_INT 83
51733: PUSH
51734: LD_INT 84
51736: PUSH
51737: LD_INT 85
51739: PUSH
51740: LD_INT 86
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: LIST
51747: LIST
51748: LIST
51749: LIST
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: LIST
51755: LIST
51756: LIST
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: LIST
51762: LIST
51763: LIST
51764: LIST
51765: LIST
51766: LIST
51767: LIST
51768: LIST
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: LIST
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: ST_TO_ADDR
51796: GO 52263
51798: LD_INT 2
51800: DOUBLE
51801: EQUAL
51802: IFTRUE 51806
51804: GO 52032
51806: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51807: LD_ADDR_VAR 0 4
51811: PUSH
51812: LD_INT 35
51814: PUSH
51815: LD_INT 45
51817: PUSH
51818: LD_INT 46
51820: PUSH
51821: LD_INT 47
51823: PUSH
51824: LD_INT 82
51826: PUSH
51827: LD_INT 83
51829: PUSH
51830: LD_INT 84
51832: PUSH
51833: LD_INT 85
51835: PUSH
51836: LD_INT 87
51838: PUSH
51839: LD_INT 70
51841: PUSH
51842: LD_INT 1
51844: PUSH
51845: LD_INT 11
51847: PUSH
51848: LD_INT 3
51850: PUSH
51851: LD_INT 4
51853: PUSH
51854: LD_INT 5
51856: PUSH
51857: LD_INT 6
51859: PUSH
51860: LD_INT 15
51862: PUSH
51863: LD_INT 18
51865: PUSH
51866: LD_INT 7
51868: PUSH
51869: LD_INT 17
51871: PUSH
51872: LD_INT 8
51874: PUSH
51875: LD_INT 20
51877: PUSH
51878: LD_INT 21
51880: PUSH
51881: LD_INT 22
51883: PUSH
51884: LD_INT 72
51886: PUSH
51887: LD_INT 26
51889: PUSH
51890: LD_INT 69
51892: PUSH
51893: LD_INT 39
51895: PUSH
51896: LD_INT 40
51898: PUSH
51899: LD_INT 41
51901: PUSH
51902: LD_INT 42
51904: PUSH
51905: LD_INT 43
51907: PUSH
51908: LD_INT 48
51910: PUSH
51911: LD_INT 49
51913: PUSH
51914: LD_INT 50
51916: PUSH
51917: LD_INT 51
51919: PUSH
51920: LD_INT 52
51922: PUSH
51923: LD_INT 53
51925: PUSH
51926: LD_INT 54
51928: PUSH
51929: LD_INT 55
51931: PUSH
51932: LD_INT 56
51934: PUSH
51935: LD_INT 60
51937: PUSH
51938: LD_INT 61
51940: PUSH
51941: LD_INT 62
51943: PUSH
51944: LD_INT 66
51946: PUSH
51947: LD_INT 67
51949: PUSH
51950: LD_INT 68
51952: PUSH
51953: LD_INT 81
51955: PUSH
51956: LD_INT 82
51958: PUSH
51959: LD_INT 83
51961: PUSH
51962: LD_INT 84
51964: PUSH
51965: LD_INT 85
51967: PUSH
51968: LD_INT 87
51970: PUSH
51971: LD_INT 88
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: LIST
51988: LIST
51989: LIST
51990: LIST
51991: LIST
51992: LIST
51993: LIST
51994: LIST
51995: LIST
51996: LIST
51997: LIST
51998: LIST
51999: LIST
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: LIST
52025: LIST
52026: LIST
52027: LIST
52028: LIST
52029: ST_TO_ADDR
52030: GO 52263
52032: LD_INT 3
52034: DOUBLE
52035: EQUAL
52036: IFTRUE 52040
52038: GO 52262
52040: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52041: LD_ADDR_VAR 0 4
52045: PUSH
52046: LD_INT 46
52048: PUSH
52049: LD_INT 47
52051: PUSH
52052: LD_INT 1
52054: PUSH
52055: LD_INT 2
52057: PUSH
52058: LD_INT 82
52060: PUSH
52061: LD_INT 83
52063: PUSH
52064: LD_INT 84
52066: PUSH
52067: LD_INT 85
52069: PUSH
52070: LD_INT 86
52072: PUSH
52073: LD_INT 11
52075: PUSH
52076: LD_INT 9
52078: PUSH
52079: LD_INT 20
52081: PUSH
52082: LD_INT 19
52084: PUSH
52085: LD_INT 21
52087: PUSH
52088: LD_INT 24
52090: PUSH
52091: LD_INT 22
52093: PUSH
52094: LD_INT 25
52096: PUSH
52097: LD_INT 28
52099: PUSH
52100: LD_INT 29
52102: PUSH
52103: LD_INT 30
52105: PUSH
52106: LD_INT 31
52108: PUSH
52109: LD_INT 37
52111: PUSH
52112: LD_INT 38
52114: PUSH
52115: LD_INT 32
52117: PUSH
52118: LD_INT 27
52120: PUSH
52121: LD_INT 33
52123: PUSH
52124: LD_INT 69
52126: PUSH
52127: LD_INT 39
52129: PUSH
52130: LD_INT 34
52132: PUSH
52133: LD_INT 40
52135: PUSH
52136: LD_INT 71
52138: PUSH
52139: LD_INT 23
52141: PUSH
52142: LD_INT 44
52144: PUSH
52145: LD_INT 48
52147: PUSH
52148: LD_INT 49
52150: PUSH
52151: LD_INT 50
52153: PUSH
52154: LD_INT 51
52156: PUSH
52157: LD_INT 52
52159: PUSH
52160: LD_INT 53
52162: PUSH
52163: LD_INT 54
52165: PUSH
52166: LD_INT 55
52168: PUSH
52169: LD_INT 56
52171: PUSH
52172: LD_INT 57
52174: PUSH
52175: LD_INT 58
52177: PUSH
52178: LD_INT 59
52180: PUSH
52181: LD_INT 63
52183: PUSH
52184: LD_INT 64
52186: PUSH
52187: LD_INT 65
52189: PUSH
52190: LD_INT 82
52192: PUSH
52193: LD_INT 83
52195: PUSH
52196: LD_INT 84
52198: PUSH
52199: LD_INT 85
52201: PUSH
52202: LD_INT 86
52204: PUSH
52205: EMPTY
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: LIST
52228: LIST
52229: LIST
52230: LIST
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: LIST
52240: LIST
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: LIST
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: LIST
52259: ST_TO_ADDR
52260: GO 52263
52262: POP
// if state > - 1 and state < 3 then
52263: LD_VAR 0 3
52267: PUSH
52268: LD_INT 1
52270: NEG
52271: GREATER
52272: PUSH
52273: LD_VAR 0 3
52277: PUSH
52278: LD_INT 3
52280: LESS
52281: AND
52282: IFFALSE 52339
// for i in result do
52284: LD_ADDR_VAR 0 5
52288: PUSH
52289: LD_VAR 0 4
52293: PUSH
52294: FOR_IN
52295: IFFALSE 52337
// if GetTech ( i , side ) <> state then
52297: LD_VAR 0 5
52301: PPUSH
52302: LD_VAR 0 1
52306: PPUSH
52307: CALL_OW 321
52311: PUSH
52312: LD_VAR 0 3
52316: NONEQUAL
52317: IFFALSE 52335
// result := result diff i ;
52319: LD_ADDR_VAR 0 4
52323: PUSH
52324: LD_VAR 0 4
52328: PUSH
52329: LD_VAR 0 5
52333: DIFF
52334: ST_TO_ADDR
52335: GO 52294
52337: POP
52338: POP
// end ;
52339: LD_VAR 0 4
52343: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52344: LD_INT 0
52346: PPUSH
52347: PPUSH
52348: PPUSH
// result := true ;
52349: LD_ADDR_VAR 0 3
52353: PUSH
52354: LD_INT 1
52356: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52357: LD_ADDR_VAR 0 5
52361: PUSH
52362: LD_VAR 0 2
52366: PPUSH
52367: CALL_OW 480
52371: ST_TO_ADDR
// if not tmp then
52372: LD_VAR 0 5
52376: NOT
52377: IFFALSE 52381
// exit ;
52379: GO 52430
// for i in tmp do
52381: LD_ADDR_VAR 0 4
52385: PUSH
52386: LD_VAR 0 5
52390: PUSH
52391: FOR_IN
52392: IFFALSE 52428
// if GetTech ( i , side ) <> state_researched then
52394: LD_VAR 0 4
52398: PPUSH
52399: LD_VAR 0 1
52403: PPUSH
52404: CALL_OW 321
52408: PUSH
52409: LD_INT 2
52411: NONEQUAL
52412: IFFALSE 52426
// begin result := false ;
52414: LD_ADDR_VAR 0 3
52418: PUSH
52419: LD_INT 0
52421: ST_TO_ADDR
// exit ;
52422: POP
52423: POP
52424: GO 52430
// end ;
52426: GO 52391
52428: POP
52429: POP
// end ;
52430: LD_VAR 0 3
52434: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52435: LD_INT 0
52437: PPUSH
52438: PPUSH
52439: PPUSH
52440: PPUSH
52441: PPUSH
52442: PPUSH
52443: PPUSH
52444: PPUSH
52445: PPUSH
52446: PPUSH
52447: PPUSH
52448: PPUSH
52449: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52450: LD_VAR 0 1
52454: NOT
52455: PUSH
52456: LD_VAR 0 1
52460: PPUSH
52461: CALL_OW 257
52465: PUSH
52466: LD_INT 9
52468: NONEQUAL
52469: OR
52470: IFFALSE 52474
// exit ;
52472: GO 53047
// side := GetSide ( unit ) ;
52474: LD_ADDR_VAR 0 9
52478: PUSH
52479: LD_VAR 0 1
52483: PPUSH
52484: CALL_OW 255
52488: ST_TO_ADDR
// tech_space := tech_spacanom ;
52489: LD_ADDR_VAR 0 12
52493: PUSH
52494: LD_INT 29
52496: ST_TO_ADDR
// tech_time := tech_taurad ;
52497: LD_ADDR_VAR 0 13
52501: PUSH
52502: LD_INT 28
52504: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52505: LD_ADDR_VAR 0 11
52509: PUSH
52510: LD_VAR 0 1
52514: PPUSH
52515: CALL_OW 310
52519: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52520: LD_VAR 0 11
52524: PPUSH
52525: CALL_OW 247
52529: PUSH
52530: LD_INT 2
52532: EQUAL
52533: IFFALSE 52537
// exit ;
52535: GO 53047
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52537: LD_ADDR_VAR 0 8
52541: PUSH
52542: LD_INT 81
52544: PUSH
52545: LD_VAR 0 9
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: PUSH
52554: LD_INT 3
52556: PUSH
52557: LD_INT 21
52559: PUSH
52560: LD_INT 3
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: PUSH
52571: EMPTY
52572: LIST
52573: LIST
52574: PPUSH
52575: CALL_OW 69
52579: ST_TO_ADDR
// if not tmp then
52580: LD_VAR 0 8
52584: NOT
52585: IFFALSE 52589
// exit ;
52587: GO 53047
// if in_unit then
52589: LD_VAR 0 11
52593: IFFALSE 52617
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52595: LD_ADDR_VAR 0 10
52599: PUSH
52600: LD_VAR 0 8
52604: PPUSH
52605: LD_VAR 0 11
52609: PPUSH
52610: CALL_OW 74
52614: ST_TO_ADDR
52615: GO 52637
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52617: LD_ADDR_VAR 0 10
52621: PUSH
52622: LD_VAR 0 8
52626: PPUSH
52627: LD_VAR 0 1
52631: PPUSH
52632: CALL_OW 74
52636: ST_TO_ADDR
// if not enemy then
52637: LD_VAR 0 10
52641: NOT
52642: IFFALSE 52646
// exit ;
52644: GO 53047
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52646: LD_VAR 0 11
52650: PUSH
52651: LD_VAR 0 11
52655: PPUSH
52656: LD_VAR 0 10
52660: PPUSH
52661: CALL_OW 296
52665: PUSH
52666: LD_INT 13
52668: GREATER
52669: AND
52670: PUSH
52671: LD_VAR 0 1
52675: PPUSH
52676: LD_VAR 0 10
52680: PPUSH
52681: CALL_OW 296
52685: PUSH
52686: LD_INT 12
52688: GREATER
52689: OR
52690: IFFALSE 52694
// exit ;
52692: GO 53047
// missile := [ 1 ] ;
52694: LD_ADDR_VAR 0 14
52698: PUSH
52699: LD_INT 1
52701: PUSH
52702: EMPTY
52703: LIST
52704: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52705: LD_VAR 0 9
52709: PPUSH
52710: LD_VAR 0 12
52714: PPUSH
52715: CALL_OW 325
52719: IFFALSE 52748
// missile := Insert ( missile , missile + 1 , 2 ) ;
52721: LD_ADDR_VAR 0 14
52725: PUSH
52726: LD_VAR 0 14
52730: PPUSH
52731: LD_VAR 0 14
52735: PUSH
52736: LD_INT 1
52738: PLUS
52739: PPUSH
52740: LD_INT 2
52742: PPUSH
52743: CALL_OW 2
52747: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52748: LD_VAR 0 9
52752: PPUSH
52753: LD_VAR 0 13
52757: PPUSH
52758: CALL_OW 325
52762: PUSH
52763: LD_VAR 0 10
52767: PPUSH
52768: CALL_OW 255
52772: PPUSH
52773: LD_VAR 0 13
52777: PPUSH
52778: CALL_OW 325
52782: NOT
52783: AND
52784: IFFALSE 52813
// missile := Insert ( missile , missile + 1 , 3 ) ;
52786: LD_ADDR_VAR 0 14
52790: PUSH
52791: LD_VAR 0 14
52795: PPUSH
52796: LD_VAR 0 14
52800: PUSH
52801: LD_INT 1
52803: PLUS
52804: PPUSH
52805: LD_INT 3
52807: PPUSH
52808: CALL_OW 2
52812: ST_TO_ADDR
// if missile < 2 then
52813: LD_VAR 0 14
52817: PUSH
52818: LD_INT 2
52820: LESS
52821: IFFALSE 52825
// exit ;
52823: GO 53047
// x := GetX ( enemy ) ;
52825: LD_ADDR_VAR 0 4
52829: PUSH
52830: LD_VAR 0 10
52834: PPUSH
52835: CALL_OW 250
52839: ST_TO_ADDR
// y := GetY ( enemy ) ;
52840: LD_ADDR_VAR 0 5
52844: PUSH
52845: LD_VAR 0 10
52849: PPUSH
52850: CALL_OW 251
52854: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52855: LD_ADDR_VAR 0 6
52859: PUSH
52860: LD_VAR 0 4
52864: PUSH
52865: LD_INT 1
52867: NEG
52868: PPUSH
52869: LD_INT 1
52871: PPUSH
52872: CALL_OW 12
52876: PLUS
52877: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52878: LD_ADDR_VAR 0 7
52882: PUSH
52883: LD_VAR 0 5
52887: PUSH
52888: LD_INT 1
52890: NEG
52891: PPUSH
52892: LD_INT 1
52894: PPUSH
52895: CALL_OW 12
52899: PLUS
52900: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52901: LD_VAR 0 6
52905: PPUSH
52906: LD_VAR 0 7
52910: PPUSH
52911: CALL_OW 488
52915: NOT
52916: IFFALSE 52938
// begin _x := x ;
52918: LD_ADDR_VAR 0 6
52922: PUSH
52923: LD_VAR 0 4
52927: ST_TO_ADDR
// _y := y ;
52928: LD_ADDR_VAR 0 7
52932: PUSH
52933: LD_VAR 0 5
52937: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_INT 1
52945: PPUSH
52946: LD_VAR 0 14
52950: PPUSH
52951: CALL_OW 12
52955: ST_TO_ADDR
// case i of 1 :
52956: LD_VAR 0 3
52960: PUSH
52961: LD_INT 1
52963: DOUBLE
52964: EQUAL
52965: IFTRUE 52969
52967: GO 52986
52969: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52970: LD_VAR 0 1
52974: PPUSH
52975: LD_VAR 0 10
52979: PPUSH
52980: CALL_OW 115
52984: GO 53047
52986: LD_INT 2
52988: DOUBLE
52989: EQUAL
52990: IFTRUE 52994
52992: GO 53016
52994: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52995: LD_VAR 0 1
52999: PPUSH
53000: LD_VAR 0 6
53004: PPUSH
53005: LD_VAR 0 7
53009: PPUSH
53010: CALL_OW 153
53014: GO 53047
53016: LD_INT 3
53018: DOUBLE
53019: EQUAL
53020: IFTRUE 53024
53022: GO 53046
53024: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53025: LD_VAR 0 1
53029: PPUSH
53030: LD_VAR 0 6
53034: PPUSH
53035: LD_VAR 0 7
53039: PPUSH
53040: CALL_OW 154
53044: GO 53047
53046: POP
// end ;
53047: LD_VAR 0 2
53051: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53052: LD_INT 0
53054: PPUSH
53055: PPUSH
53056: PPUSH
53057: PPUSH
53058: PPUSH
53059: PPUSH
// if not unit or not building then
53060: LD_VAR 0 1
53064: NOT
53065: PUSH
53066: LD_VAR 0 2
53070: NOT
53071: OR
53072: IFFALSE 53076
// exit ;
53074: GO 53234
// x := GetX ( building ) ;
53076: LD_ADDR_VAR 0 5
53080: PUSH
53081: LD_VAR 0 2
53085: PPUSH
53086: CALL_OW 250
53090: ST_TO_ADDR
// y := GetY ( building ) ;
53091: LD_ADDR_VAR 0 6
53095: PUSH
53096: LD_VAR 0 2
53100: PPUSH
53101: CALL_OW 251
53105: ST_TO_ADDR
// for i = 0 to 5 do
53106: LD_ADDR_VAR 0 4
53110: PUSH
53111: DOUBLE
53112: LD_INT 0
53114: DEC
53115: ST_TO_ADDR
53116: LD_INT 5
53118: PUSH
53119: FOR_TO
53120: IFFALSE 53232
// begin _x := ShiftX ( x , i , 3 ) ;
53122: LD_ADDR_VAR 0 7
53126: PUSH
53127: LD_VAR 0 5
53131: PPUSH
53132: LD_VAR 0 4
53136: PPUSH
53137: LD_INT 3
53139: PPUSH
53140: CALL_OW 272
53144: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53145: LD_ADDR_VAR 0 8
53149: PUSH
53150: LD_VAR 0 6
53154: PPUSH
53155: LD_VAR 0 4
53159: PPUSH
53160: LD_INT 3
53162: PPUSH
53163: CALL_OW 273
53167: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53168: LD_VAR 0 7
53172: PPUSH
53173: LD_VAR 0 8
53177: PPUSH
53178: CALL_OW 488
53182: NOT
53183: IFFALSE 53187
// continue ;
53185: GO 53119
// if HexInfo ( _x , _y ) = 0 then
53187: LD_VAR 0 7
53191: PPUSH
53192: LD_VAR 0 8
53196: PPUSH
53197: CALL_OW 428
53201: PUSH
53202: LD_INT 0
53204: EQUAL
53205: IFFALSE 53230
// begin ComMoveXY ( unit , _x , _y ) ;
53207: LD_VAR 0 1
53211: PPUSH
53212: LD_VAR 0 7
53216: PPUSH
53217: LD_VAR 0 8
53221: PPUSH
53222: CALL_OW 111
// exit ;
53226: POP
53227: POP
53228: GO 53234
// end ; end ;
53230: GO 53119
53232: POP
53233: POP
// end ;
53234: LD_VAR 0 3
53238: RET
// export function ScanBase ( side , base_area ) ; begin
53239: LD_INT 0
53241: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53242: LD_ADDR_VAR 0 3
53246: PUSH
53247: LD_VAR 0 2
53251: PPUSH
53252: LD_INT 81
53254: PUSH
53255: LD_VAR 0 1
53259: PUSH
53260: EMPTY
53261: LIST
53262: LIST
53263: PPUSH
53264: CALL_OW 70
53268: ST_TO_ADDR
// end ;
53269: LD_VAR 0 3
53273: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53274: LD_INT 0
53276: PPUSH
53277: PPUSH
53278: PPUSH
53279: PPUSH
// result := false ;
53280: LD_ADDR_VAR 0 2
53284: PUSH
53285: LD_INT 0
53287: ST_TO_ADDR
// side := GetSide ( unit ) ;
53288: LD_ADDR_VAR 0 3
53292: PUSH
53293: LD_VAR 0 1
53297: PPUSH
53298: CALL_OW 255
53302: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53303: LD_ADDR_VAR 0 4
53307: PUSH
53308: LD_VAR 0 1
53312: PPUSH
53313: CALL_OW 248
53317: ST_TO_ADDR
// case nat of 1 :
53318: LD_VAR 0 4
53322: PUSH
53323: LD_INT 1
53325: DOUBLE
53326: EQUAL
53327: IFTRUE 53331
53329: GO 53342
53331: POP
// tech := tech_lassight ; 2 :
53332: LD_ADDR_VAR 0 5
53336: PUSH
53337: LD_INT 12
53339: ST_TO_ADDR
53340: GO 53381
53342: LD_INT 2
53344: DOUBLE
53345: EQUAL
53346: IFTRUE 53350
53348: GO 53361
53350: POP
// tech := tech_mortar ; 3 :
53351: LD_ADDR_VAR 0 5
53355: PUSH
53356: LD_INT 41
53358: ST_TO_ADDR
53359: GO 53381
53361: LD_INT 3
53363: DOUBLE
53364: EQUAL
53365: IFTRUE 53369
53367: GO 53380
53369: POP
// tech := tech_bazooka ; end ;
53370: LD_ADDR_VAR 0 5
53374: PUSH
53375: LD_INT 44
53377: ST_TO_ADDR
53378: GO 53381
53380: POP
// if Researched ( side , tech ) then
53381: LD_VAR 0 3
53385: PPUSH
53386: LD_VAR 0 5
53390: PPUSH
53391: CALL_OW 325
53395: IFFALSE 53422
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53397: LD_ADDR_VAR 0 2
53401: PUSH
53402: LD_INT 5
53404: PUSH
53405: LD_INT 8
53407: PUSH
53408: LD_INT 9
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: PUSH
53416: LD_VAR 0 4
53420: ARRAY
53421: ST_TO_ADDR
// end ;
53422: LD_VAR 0 2
53426: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53427: LD_INT 0
53429: PPUSH
53430: PPUSH
53431: PPUSH
// if not mines then
53432: LD_VAR 0 2
53436: NOT
53437: IFFALSE 53441
// exit ;
53439: GO 53585
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53441: LD_ADDR_VAR 0 5
53445: PUSH
53446: LD_INT 81
53448: PUSH
53449: LD_VAR 0 1
53453: PUSH
53454: EMPTY
53455: LIST
53456: LIST
53457: PUSH
53458: LD_INT 3
53460: PUSH
53461: LD_INT 21
53463: PUSH
53464: LD_INT 3
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PPUSH
53479: CALL_OW 69
53483: ST_TO_ADDR
// for i in mines do
53484: LD_ADDR_VAR 0 4
53488: PUSH
53489: LD_VAR 0 2
53493: PUSH
53494: FOR_IN
53495: IFFALSE 53583
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53497: LD_VAR 0 4
53501: PUSH
53502: LD_INT 1
53504: ARRAY
53505: PPUSH
53506: LD_VAR 0 4
53510: PUSH
53511: LD_INT 2
53513: ARRAY
53514: PPUSH
53515: CALL_OW 458
53519: NOT
53520: IFFALSE 53524
// continue ;
53522: GO 53494
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53524: LD_VAR 0 4
53528: PUSH
53529: LD_INT 1
53531: ARRAY
53532: PPUSH
53533: LD_VAR 0 4
53537: PUSH
53538: LD_INT 2
53540: ARRAY
53541: PPUSH
53542: CALL_OW 428
53546: PUSH
53547: LD_VAR 0 5
53551: IN
53552: IFFALSE 53581
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53554: LD_VAR 0 4
53558: PUSH
53559: LD_INT 1
53561: ARRAY
53562: PPUSH
53563: LD_VAR 0 4
53567: PUSH
53568: LD_INT 2
53570: ARRAY
53571: PPUSH
53572: LD_VAR 0 1
53576: PPUSH
53577: CALL_OW 456
// end ;
53581: GO 53494
53583: POP
53584: POP
// end ;
53585: LD_VAR 0 3
53589: RET
// export function Count ( array ) ; var i ; begin
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
// result := 0 ;
53594: LD_ADDR_VAR 0 2
53598: PUSH
53599: LD_INT 0
53601: ST_TO_ADDR
// for i in array do
53602: LD_ADDR_VAR 0 3
53606: PUSH
53607: LD_VAR 0 1
53611: PUSH
53612: FOR_IN
53613: IFFALSE 53637
// if i then
53615: LD_VAR 0 3
53619: IFFALSE 53635
// result := result + 1 ;
53621: LD_ADDR_VAR 0 2
53625: PUSH
53626: LD_VAR 0 2
53630: PUSH
53631: LD_INT 1
53633: PLUS
53634: ST_TO_ADDR
53635: GO 53612
53637: POP
53638: POP
// end ;
53639: LD_VAR 0 2
53643: RET
// export function IsEmpty ( building ) ; begin
53644: LD_INT 0
53646: PPUSH
// if not building then
53647: LD_VAR 0 1
53651: NOT
53652: IFFALSE 53656
// exit ;
53654: GO 53699
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53656: LD_ADDR_VAR 0 2
53660: PUSH
53661: LD_VAR 0 1
53665: PUSH
53666: LD_INT 22
53668: PUSH
53669: LD_VAR 0 1
53673: PPUSH
53674: CALL_OW 255
53678: PUSH
53679: EMPTY
53680: LIST
53681: LIST
53682: PUSH
53683: LD_INT 58
53685: PUSH
53686: EMPTY
53687: LIST
53688: PUSH
53689: EMPTY
53690: LIST
53691: LIST
53692: PPUSH
53693: CALL_OW 69
53697: IN
53698: ST_TO_ADDR
// end ;
53699: LD_VAR 0 2
53703: RET
// export function IsNotFull ( building ) ; begin
53704: LD_INT 0
53706: PPUSH
// if not building then
53707: LD_VAR 0 1
53711: NOT
53712: IFFALSE 53716
// exit ;
53714: GO 53735
// result := UnitsInside ( building ) < 6 ;
53716: LD_ADDR_VAR 0 2
53720: PUSH
53721: LD_VAR 0 1
53725: PPUSH
53726: CALL_OW 313
53730: PUSH
53731: LD_INT 6
53733: LESS
53734: ST_TO_ADDR
// end ;
53735: LD_VAR 0 2
53739: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53740: LD_INT 0
53742: PPUSH
53743: PPUSH
53744: PPUSH
53745: PPUSH
// tmp := [ ] ;
53746: LD_ADDR_VAR 0 3
53750: PUSH
53751: EMPTY
53752: ST_TO_ADDR
// list := [ ] ;
53753: LD_ADDR_VAR 0 5
53757: PUSH
53758: EMPTY
53759: ST_TO_ADDR
// for i = 16 to 25 do
53760: LD_ADDR_VAR 0 4
53764: PUSH
53765: DOUBLE
53766: LD_INT 16
53768: DEC
53769: ST_TO_ADDR
53770: LD_INT 25
53772: PUSH
53773: FOR_TO
53774: IFFALSE 53847
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53776: LD_ADDR_VAR 0 3
53780: PUSH
53781: LD_VAR 0 3
53785: PUSH
53786: LD_INT 22
53788: PUSH
53789: LD_VAR 0 1
53793: PPUSH
53794: CALL_OW 255
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: PUSH
53803: LD_INT 91
53805: PUSH
53806: LD_VAR 0 1
53810: PUSH
53811: LD_INT 6
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: LIST
53818: PUSH
53819: LD_INT 30
53821: PUSH
53822: LD_VAR 0 4
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: LIST
53835: PUSH
53836: EMPTY
53837: LIST
53838: PPUSH
53839: CALL_OW 69
53843: ADD
53844: ST_TO_ADDR
53845: GO 53773
53847: POP
53848: POP
// for i = 1 to tmp do
53849: LD_ADDR_VAR 0 4
53853: PUSH
53854: DOUBLE
53855: LD_INT 1
53857: DEC
53858: ST_TO_ADDR
53859: LD_VAR 0 3
53863: PUSH
53864: FOR_TO
53865: IFFALSE 53953
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: LD_VAR 0 5
53876: PUSH
53877: LD_VAR 0 3
53881: PUSH
53882: LD_VAR 0 4
53886: ARRAY
53887: PPUSH
53888: CALL_OW 266
53892: PUSH
53893: LD_VAR 0 3
53897: PUSH
53898: LD_VAR 0 4
53902: ARRAY
53903: PPUSH
53904: CALL_OW 250
53908: PUSH
53909: LD_VAR 0 3
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: PPUSH
53920: CALL_OW 251
53924: PUSH
53925: LD_VAR 0 3
53929: PUSH
53930: LD_VAR 0 4
53934: ARRAY
53935: PPUSH
53936: CALL_OW 254
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: LIST
53945: LIST
53946: PUSH
53947: EMPTY
53948: LIST
53949: ADD
53950: ST_TO_ADDR
53951: GO 53864
53953: POP
53954: POP
// result := list ;
53955: LD_ADDR_VAR 0 2
53959: PUSH
53960: LD_VAR 0 5
53964: ST_TO_ADDR
// end ;
53965: LD_VAR 0 2
53969: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53970: LD_INT 0
53972: PPUSH
53973: PPUSH
53974: PPUSH
53975: PPUSH
53976: PPUSH
53977: PPUSH
53978: PPUSH
// if not factory then
53979: LD_VAR 0 1
53983: NOT
53984: IFFALSE 53988
// exit ;
53986: GO 54581
// if control = control_apeman then
53988: LD_VAR 0 4
53992: PUSH
53993: LD_INT 5
53995: EQUAL
53996: IFFALSE 54105
// begin tmp := UnitsInside ( factory ) ;
53998: LD_ADDR_VAR 0 8
54002: PUSH
54003: LD_VAR 0 1
54007: PPUSH
54008: CALL_OW 313
54012: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54013: LD_VAR 0 8
54017: PPUSH
54018: LD_INT 25
54020: PUSH
54021: LD_INT 12
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PPUSH
54028: CALL_OW 72
54032: NOT
54033: IFFALSE 54043
// control := control_manual ;
54035: LD_ADDR_VAR 0 4
54039: PUSH
54040: LD_INT 1
54042: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54043: LD_ADDR_VAR 0 8
54047: PUSH
54048: LD_VAR 0 1
54052: PPUSH
54053: CALL 53740 0 1
54057: ST_TO_ADDR
// if tmp then
54058: LD_VAR 0 8
54062: IFFALSE 54105
// begin for i in tmp do
54064: LD_ADDR_VAR 0 7
54068: PUSH
54069: LD_VAR 0 8
54073: PUSH
54074: FOR_IN
54075: IFFALSE 54103
// if i [ 1 ] = b_ext_radio then
54077: LD_VAR 0 7
54081: PUSH
54082: LD_INT 1
54084: ARRAY
54085: PUSH
54086: LD_INT 22
54088: EQUAL
54089: IFFALSE 54101
// begin control := control_remote ;
54091: LD_ADDR_VAR 0 4
54095: PUSH
54096: LD_INT 2
54098: ST_TO_ADDR
// break ;
54099: GO 54103
// end ;
54101: GO 54074
54103: POP
54104: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54105: LD_VAR 0 1
54109: PPUSH
54110: LD_VAR 0 2
54114: PPUSH
54115: LD_VAR 0 3
54119: PPUSH
54120: LD_VAR 0 4
54124: PPUSH
54125: LD_VAR 0 5
54129: PPUSH
54130: CALL_OW 448
54134: IFFALSE 54169
// begin result := [ chassis , engine , control , weapon ] ;
54136: LD_ADDR_VAR 0 6
54140: PUSH
54141: LD_VAR 0 2
54145: PUSH
54146: LD_VAR 0 3
54150: PUSH
54151: LD_VAR 0 4
54155: PUSH
54156: LD_VAR 0 5
54160: PUSH
54161: EMPTY
54162: LIST
54163: LIST
54164: LIST
54165: LIST
54166: ST_TO_ADDR
// exit ;
54167: GO 54581
// end ; _chassis := AvailableChassisList ( factory ) ;
54169: LD_ADDR_VAR 0 9
54173: PUSH
54174: LD_VAR 0 1
54178: PPUSH
54179: CALL_OW 475
54183: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54184: LD_ADDR_VAR 0 11
54188: PUSH
54189: LD_VAR 0 1
54193: PPUSH
54194: CALL_OW 476
54198: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54199: LD_ADDR_VAR 0 12
54203: PUSH
54204: LD_VAR 0 1
54208: PPUSH
54209: CALL_OW 477
54213: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54214: LD_ADDR_VAR 0 10
54218: PUSH
54219: LD_VAR 0 1
54223: PPUSH
54224: CALL_OW 478
54228: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54229: LD_VAR 0 9
54233: NOT
54234: PUSH
54235: LD_VAR 0 11
54239: NOT
54240: OR
54241: PUSH
54242: LD_VAR 0 12
54246: NOT
54247: OR
54248: PUSH
54249: LD_VAR 0 10
54253: NOT
54254: OR
54255: IFFALSE 54290
// begin result := [ chassis , engine , control , weapon ] ;
54257: LD_ADDR_VAR 0 6
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_VAR 0 3
54271: PUSH
54272: LD_VAR 0 4
54276: PUSH
54277: LD_VAR 0 5
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: LIST
54286: LIST
54287: ST_TO_ADDR
// exit ;
54288: GO 54581
// end ; if not chassis in _chassis then
54290: LD_VAR 0 2
54294: PUSH
54295: LD_VAR 0 9
54299: IN
54300: NOT
54301: IFFALSE 54327
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54303: LD_ADDR_VAR 0 2
54307: PUSH
54308: LD_VAR 0 9
54312: PUSH
54313: LD_INT 1
54315: PPUSH
54316: LD_VAR 0 9
54320: PPUSH
54321: CALL_OW 12
54325: ARRAY
54326: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54327: LD_VAR 0 2
54331: PPUSH
54332: LD_VAR 0 3
54336: PPUSH
54337: CALL 54586 0 2
54341: NOT
54342: IFFALSE 54401
// repeat engine := _engine [ 1 ] ;
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_VAR 0 11
54353: PUSH
54354: LD_INT 1
54356: ARRAY
54357: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54358: LD_ADDR_VAR 0 11
54362: PUSH
54363: LD_VAR 0 11
54367: PPUSH
54368: LD_INT 1
54370: PPUSH
54371: CALL_OW 3
54375: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54376: LD_VAR 0 2
54380: PPUSH
54381: LD_VAR 0 3
54385: PPUSH
54386: CALL 54586 0 2
54390: PUSH
54391: LD_VAR 0 11
54395: PUSH
54396: EMPTY
54397: EQUAL
54398: OR
54399: IFFALSE 54344
// if not control in _control then
54401: LD_VAR 0 4
54405: PUSH
54406: LD_VAR 0 12
54410: IN
54411: NOT
54412: IFFALSE 54438
// control := _control [ rand ( 1 , _control ) ] ;
54414: LD_ADDR_VAR 0 4
54418: PUSH
54419: LD_VAR 0 12
54423: PUSH
54424: LD_INT 1
54426: PPUSH
54427: LD_VAR 0 12
54431: PPUSH
54432: CALL_OW 12
54436: ARRAY
54437: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54438: LD_VAR 0 2
54442: PPUSH
54443: LD_VAR 0 5
54447: PPUSH
54448: CALL 54806 0 2
54452: NOT
54453: IFFALSE 54512
// repeat weapon := _weapon [ 1 ] ;
54455: LD_ADDR_VAR 0 5
54459: PUSH
54460: LD_VAR 0 10
54464: PUSH
54465: LD_INT 1
54467: ARRAY
54468: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54469: LD_ADDR_VAR 0 10
54473: PUSH
54474: LD_VAR 0 10
54478: PPUSH
54479: LD_INT 1
54481: PPUSH
54482: CALL_OW 3
54486: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54487: LD_VAR 0 2
54491: PPUSH
54492: LD_VAR 0 5
54496: PPUSH
54497: CALL 54806 0 2
54501: PUSH
54502: LD_VAR 0 10
54506: PUSH
54507: EMPTY
54508: EQUAL
54509: OR
54510: IFFALSE 54455
// result := [ ] ;
54512: LD_ADDR_VAR 0 6
54516: PUSH
54517: EMPTY
54518: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54519: LD_VAR 0 1
54523: PPUSH
54524: LD_VAR 0 2
54528: PPUSH
54529: LD_VAR 0 3
54533: PPUSH
54534: LD_VAR 0 4
54538: PPUSH
54539: LD_VAR 0 5
54543: PPUSH
54544: CALL_OW 448
54548: IFFALSE 54581
// result := [ chassis , engine , control , weapon ] ;
54550: LD_ADDR_VAR 0 6
54554: PUSH
54555: LD_VAR 0 2
54559: PUSH
54560: LD_VAR 0 3
54564: PUSH
54565: LD_VAR 0 4
54569: PUSH
54570: LD_VAR 0 5
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: LIST
54579: LIST
54580: ST_TO_ADDR
// end ;
54581: LD_VAR 0 6
54585: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54586: LD_INT 0
54588: PPUSH
// if not chassis or not engine then
54589: LD_VAR 0 1
54593: NOT
54594: PUSH
54595: LD_VAR 0 2
54599: NOT
54600: OR
54601: IFFALSE 54605
// exit ;
54603: GO 54801
// case engine of engine_solar :
54605: LD_VAR 0 2
54609: PUSH
54610: LD_INT 2
54612: DOUBLE
54613: EQUAL
54614: IFTRUE 54618
54616: GO 54656
54618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54619: LD_ADDR_VAR 0 3
54623: PUSH
54624: LD_INT 11
54626: PUSH
54627: LD_INT 12
54629: PUSH
54630: LD_INT 13
54632: PUSH
54633: LD_INT 14
54635: PUSH
54636: LD_INT 1
54638: PUSH
54639: LD_INT 2
54641: PUSH
54642: LD_INT 3
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: LIST
54649: LIST
54650: LIST
54651: LIST
54652: LIST
54653: ST_TO_ADDR
54654: GO 54785
54656: LD_INT 1
54658: DOUBLE
54659: EQUAL
54660: IFTRUE 54664
54662: GO 54726
54664: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54665: LD_ADDR_VAR 0 3
54669: PUSH
54670: LD_INT 11
54672: PUSH
54673: LD_INT 12
54675: PUSH
54676: LD_INT 13
54678: PUSH
54679: LD_INT 14
54681: PUSH
54682: LD_INT 1
54684: PUSH
54685: LD_INT 2
54687: PUSH
54688: LD_INT 3
54690: PUSH
54691: LD_INT 4
54693: PUSH
54694: LD_INT 5
54696: PUSH
54697: LD_INT 21
54699: PUSH
54700: LD_INT 23
54702: PUSH
54703: LD_INT 22
54705: PUSH
54706: LD_INT 24
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: LIST
54716: LIST
54717: LIST
54718: LIST
54719: LIST
54720: LIST
54721: LIST
54722: LIST
54723: ST_TO_ADDR
54724: GO 54785
54726: LD_INT 3
54728: DOUBLE
54729: EQUAL
54730: IFTRUE 54734
54732: GO 54784
54734: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54735: LD_ADDR_VAR 0 3
54739: PUSH
54740: LD_INT 13
54742: PUSH
54743: LD_INT 14
54745: PUSH
54746: LD_INT 2
54748: PUSH
54749: LD_INT 3
54751: PUSH
54752: LD_INT 4
54754: PUSH
54755: LD_INT 5
54757: PUSH
54758: LD_INT 21
54760: PUSH
54761: LD_INT 22
54763: PUSH
54764: LD_INT 23
54766: PUSH
54767: LD_INT 24
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: LIST
54776: LIST
54777: LIST
54778: LIST
54779: LIST
54780: LIST
54781: ST_TO_ADDR
54782: GO 54785
54784: POP
// result := ( chassis in result ) ;
54785: LD_ADDR_VAR 0 3
54789: PUSH
54790: LD_VAR 0 1
54794: PUSH
54795: LD_VAR 0 3
54799: IN
54800: ST_TO_ADDR
// end ;
54801: LD_VAR 0 3
54805: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54806: LD_INT 0
54808: PPUSH
// if not chassis or not weapon then
54809: LD_VAR 0 1
54813: NOT
54814: PUSH
54815: LD_VAR 0 2
54819: NOT
54820: OR
54821: IFFALSE 54825
// exit ;
54823: GO 55887
// case weapon of us_machine_gun :
54825: LD_VAR 0 2
54829: PUSH
54830: LD_INT 2
54832: DOUBLE
54833: EQUAL
54834: IFTRUE 54838
54836: GO 54868
54838: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54839: LD_ADDR_VAR 0 3
54843: PUSH
54844: LD_INT 1
54846: PUSH
54847: LD_INT 2
54849: PUSH
54850: LD_INT 3
54852: PUSH
54853: LD_INT 4
54855: PUSH
54856: LD_INT 5
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: LIST
54865: ST_TO_ADDR
54866: GO 55871
54868: LD_INT 3
54870: DOUBLE
54871: EQUAL
54872: IFTRUE 54876
54874: GO 54906
54876: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54877: LD_ADDR_VAR 0 3
54881: PUSH
54882: LD_INT 1
54884: PUSH
54885: LD_INT 2
54887: PUSH
54888: LD_INT 3
54890: PUSH
54891: LD_INT 4
54893: PUSH
54894: LD_INT 5
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: LIST
54902: LIST
54903: ST_TO_ADDR
54904: GO 55871
54906: LD_INT 11
54908: DOUBLE
54909: EQUAL
54910: IFTRUE 54914
54912: GO 54944
54914: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54915: LD_ADDR_VAR 0 3
54919: PUSH
54920: LD_INT 1
54922: PUSH
54923: LD_INT 2
54925: PUSH
54926: LD_INT 3
54928: PUSH
54929: LD_INT 4
54931: PUSH
54932: LD_INT 5
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: LIST
54939: LIST
54940: LIST
54941: ST_TO_ADDR
54942: GO 55871
54944: LD_INT 4
54946: DOUBLE
54947: EQUAL
54948: IFTRUE 54952
54950: GO 54978
54952: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54953: LD_ADDR_VAR 0 3
54957: PUSH
54958: LD_INT 2
54960: PUSH
54961: LD_INT 3
54963: PUSH
54964: LD_INT 4
54966: PUSH
54967: LD_INT 5
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: LIST
54974: LIST
54975: ST_TO_ADDR
54976: GO 55871
54978: LD_INT 5
54980: DOUBLE
54981: EQUAL
54982: IFTRUE 54986
54984: GO 55012
54986: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54987: LD_ADDR_VAR 0 3
54991: PUSH
54992: LD_INT 2
54994: PUSH
54995: LD_INT 3
54997: PUSH
54998: LD_INT 4
55000: PUSH
55001: LD_INT 5
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: LIST
55008: LIST
55009: ST_TO_ADDR
55010: GO 55871
55012: LD_INT 9
55014: DOUBLE
55015: EQUAL
55016: IFTRUE 55020
55018: GO 55046
55020: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55021: LD_ADDR_VAR 0 3
55025: PUSH
55026: LD_INT 2
55028: PUSH
55029: LD_INT 3
55031: PUSH
55032: LD_INT 4
55034: PUSH
55035: LD_INT 5
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: LIST
55042: LIST
55043: ST_TO_ADDR
55044: GO 55871
55046: LD_INT 7
55048: DOUBLE
55049: EQUAL
55050: IFTRUE 55054
55052: GO 55080
55054: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55055: LD_ADDR_VAR 0 3
55059: PUSH
55060: LD_INT 2
55062: PUSH
55063: LD_INT 3
55065: PUSH
55066: LD_INT 4
55068: PUSH
55069: LD_INT 5
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: LIST
55076: LIST
55077: ST_TO_ADDR
55078: GO 55871
55080: LD_INT 12
55082: DOUBLE
55083: EQUAL
55084: IFTRUE 55088
55086: GO 55114
55088: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55089: LD_ADDR_VAR 0 3
55093: PUSH
55094: LD_INT 2
55096: PUSH
55097: LD_INT 3
55099: PUSH
55100: LD_INT 4
55102: PUSH
55103: LD_INT 5
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: LIST
55110: LIST
55111: ST_TO_ADDR
55112: GO 55871
55114: LD_INT 13
55116: DOUBLE
55117: EQUAL
55118: IFTRUE 55122
55120: GO 55148
55122: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55123: LD_ADDR_VAR 0 3
55127: PUSH
55128: LD_INT 2
55130: PUSH
55131: LD_INT 3
55133: PUSH
55134: LD_INT 4
55136: PUSH
55137: LD_INT 5
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: LIST
55145: ST_TO_ADDR
55146: GO 55871
55148: LD_INT 14
55150: DOUBLE
55151: EQUAL
55152: IFTRUE 55156
55154: GO 55174
55156: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55157: LD_ADDR_VAR 0 3
55161: PUSH
55162: LD_INT 4
55164: PUSH
55165: LD_INT 5
55167: PUSH
55168: EMPTY
55169: LIST
55170: LIST
55171: ST_TO_ADDR
55172: GO 55871
55174: LD_INT 6
55176: DOUBLE
55177: EQUAL
55178: IFTRUE 55182
55180: GO 55200
55182: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55183: LD_ADDR_VAR 0 3
55187: PUSH
55188: LD_INT 4
55190: PUSH
55191: LD_INT 5
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: ST_TO_ADDR
55198: GO 55871
55200: LD_INT 10
55202: DOUBLE
55203: EQUAL
55204: IFTRUE 55208
55206: GO 55226
55208: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55209: LD_ADDR_VAR 0 3
55213: PUSH
55214: LD_INT 4
55216: PUSH
55217: LD_INT 5
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: ST_TO_ADDR
55224: GO 55871
55226: LD_INT 22
55228: DOUBLE
55229: EQUAL
55230: IFTRUE 55234
55232: GO 55260
55234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_INT 11
55242: PUSH
55243: LD_INT 12
55245: PUSH
55246: LD_INT 13
55248: PUSH
55249: LD_INT 14
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: ST_TO_ADDR
55258: GO 55871
55260: LD_INT 23
55262: DOUBLE
55263: EQUAL
55264: IFTRUE 55268
55266: GO 55294
55268: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55269: LD_ADDR_VAR 0 3
55273: PUSH
55274: LD_INT 11
55276: PUSH
55277: LD_INT 12
55279: PUSH
55280: LD_INT 13
55282: PUSH
55283: LD_INT 14
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: ST_TO_ADDR
55292: GO 55871
55294: LD_INT 24
55296: DOUBLE
55297: EQUAL
55298: IFTRUE 55302
55300: GO 55328
55302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55303: LD_ADDR_VAR 0 3
55307: PUSH
55308: LD_INT 11
55310: PUSH
55311: LD_INT 12
55313: PUSH
55314: LD_INT 13
55316: PUSH
55317: LD_INT 14
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: LIST
55325: ST_TO_ADDR
55326: GO 55871
55328: LD_INT 30
55330: DOUBLE
55331: EQUAL
55332: IFTRUE 55336
55334: GO 55362
55336: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55337: LD_ADDR_VAR 0 3
55341: PUSH
55342: LD_INT 11
55344: PUSH
55345: LD_INT 12
55347: PUSH
55348: LD_INT 13
55350: PUSH
55351: LD_INT 14
55353: PUSH
55354: EMPTY
55355: LIST
55356: LIST
55357: LIST
55358: LIST
55359: ST_TO_ADDR
55360: GO 55871
55362: LD_INT 25
55364: DOUBLE
55365: EQUAL
55366: IFTRUE 55370
55368: GO 55388
55370: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55371: LD_ADDR_VAR 0 3
55375: PUSH
55376: LD_INT 13
55378: PUSH
55379: LD_INT 14
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: ST_TO_ADDR
55386: GO 55871
55388: LD_INT 27
55390: DOUBLE
55391: EQUAL
55392: IFTRUE 55396
55394: GO 55414
55396: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55397: LD_ADDR_VAR 0 3
55401: PUSH
55402: LD_INT 13
55404: PUSH
55405: LD_INT 14
55407: PUSH
55408: EMPTY
55409: LIST
55410: LIST
55411: ST_TO_ADDR
55412: GO 55871
55414: LD_EXP 77
55418: DOUBLE
55419: EQUAL
55420: IFTRUE 55424
55422: GO 55450
55424: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55425: LD_ADDR_VAR 0 3
55429: PUSH
55430: LD_INT 11
55432: PUSH
55433: LD_INT 12
55435: PUSH
55436: LD_INT 13
55438: PUSH
55439: LD_INT 14
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: LIST
55446: LIST
55447: ST_TO_ADDR
55448: GO 55871
55450: LD_INT 28
55452: DOUBLE
55453: EQUAL
55454: IFTRUE 55458
55456: GO 55476
55458: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55459: LD_ADDR_VAR 0 3
55463: PUSH
55464: LD_INT 13
55466: PUSH
55467: LD_INT 14
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: ST_TO_ADDR
55474: GO 55871
55476: LD_INT 29
55478: DOUBLE
55479: EQUAL
55480: IFTRUE 55484
55482: GO 55502
55484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55485: LD_ADDR_VAR 0 3
55489: PUSH
55490: LD_INT 13
55492: PUSH
55493: LD_INT 14
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: ST_TO_ADDR
55500: GO 55871
55502: LD_INT 31
55504: DOUBLE
55505: EQUAL
55506: IFTRUE 55510
55508: GO 55528
55510: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55511: LD_ADDR_VAR 0 3
55515: PUSH
55516: LD_INT 13
55518: PUSH
55519: LD_INT 14
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: ST_TO_ADDR
55526: GO 55871
55528: LD_INT 26
55530: DOUBLE
55531: EQUAL
55532: IFTRUE 55536
55534: GO 55554
55536: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55537: LD_ADDR_VAR 0 3
55541: PUSH
55542: LD_INT 13
55544: PUSH
55545: LD_INT 14
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: ST_TO_ADDR
55552: GO 55871
55554: LD_INT 42
55556: DOUBLE
55557: EQUAL
55558: IFTRUE 55562
55560: GO 55588
55562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55563: LD_ADDR_VAR 0 3
55567: PUSH
55568: LD_INT 21
55570: PUSH
55571: LD_INT 22
55573: PUSH
55574: LD_INT 23
55576: PUSH
55577: LD_INT 24
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: LIST
55585: ST_TO_ADDR
55586: GO 55871
55588: LD_INT 43
55590: DOUBLE
55591: EQUAL
55592: IFTRUE 55596
55594: GO 55622
55596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55597: LD_ADDR_VAR 0 3
55601: PUSH
55602: LD_INT 21
55604: PUSH
55605: LD_INT 22
55607: PUSH
55608: LD_INT 23
55610: PUSH
55611: LD_INT 24
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: LIST
55619: ST_TO_ADDR
55620: GO 55871
55622: LD_INT 44
55624: DOUBLE
55625: EQUAL
55626: IFTRUE 55630
55628: GO 55656
55630: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55631: LD_ADDR_VAR 0 3
55635: PUSH
55636: LD_INT 21
55638: PUSH
55639: LD_INT 22
55641: PUSH
55642: LD_INT 23
55644: PUSH
55645: LD_INT 24
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: LIST
55652: LIST
55653: ST_TO_ADDR
55654: GO 55871
55656: LD_INT 45
55658: DOUBLE
55659: EQUAL
55660: IFTRUE 55664
55662: GO 55690
55664: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55665: LD_ADDR_VAR 0 3
55669: PUSH
55670: LD_INT 21
55672: PUSH
55673: LD_INT 22
55675: PUSH
55676: LD_INT 23
55678: PUSH
55679: LD_INT 24
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: LIST
55686: LIST
55687: ST_TO_ADDR
55688: GO 55871
55690: LD_INT 49
55692: DOUBLE
55693: EQUAL
55694: IFTRUE 55698
55696: GO 55724
55698: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55699: LD_ADDR_VAR 0 3
55703: PUSH
55704: LD_INT 21
55706: PUSH
55707: LD_INT 22
55709: PUSH
55710: LD_INT 23
55712: PUSH
55713: LD_INT 24
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: LIST
55720: LIST
55721: ST_TO_ADDR
55722: GO 55871
55724: LD_INT 51
55726: DOUBLE
55727: EQUAL
55728: IFTRUE 55732
55730: GO 55758
55732: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55733: LD_ADDR_VAR 0 3
55737: PUSH
55738: LD_INT 21
55740: PUSH
55741: LD_INT 22
55743: PUSH
55744: LD_INT 23
55746: PUSH
55747: LD_INT 24
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: LIST
55755: ST_TO_ADDR
55756: GO 55871
55758: LD_INT 52
55760: DOUBLE
55761: EQUAL
55762: IFTRUE 55766
55764: GO 55792
55766: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55767: LD_ADDR_VAR 0 3
55771: PUSH
55772: LD_INT 21
55774: PUSH
55775: LD_INT 22
55777: PUSH
55778: LD_INT 23
55780: PUSH
55781: LD_INT 24
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: LIST
55788: LIST
55789: ST_TO_ADDR
55790: GO 55871
55792: LD_INT 53
55794: DOUBLE
55795: EQUAL
55796: IFTRUE 55800
55798: GO 55818
55800: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55801: LD_ADDR_VAR 0 3
55805: PUSH
55806: LD_INT 23
55808: PUSH
55809: LD_INT 24
55811: PUSH
55812: EMPTY
55813: LIST
55814: LIST
55815: ST_TO_ADDR
55816: GO 55871
55818: LD_INT 46
55820: DOUBLE
55821: EQUAL
55822: IFTRUE 55826
55824: GO 55844
55826: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55827: LD_ADDR_VAR 0 3
55831: PUSH
55832: LD_INT 23
55834: PUSH
55835: LD_INT 24
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: ST_TO_ADDR
55842: GO 55871
55844: LD_INT 47
55846: DOUBLE
55847: EQUAL
55848: IFTRUE 55852
55850: GO 55870
55852: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55853: LD_ADDR_VAR 0 3
55857: PUSH
55858: LD_INT 23
55860: PUSH
55861: LD_INT 24
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: ST_TO_ADDR
55868: GO 55871
55870: POP
// result := ( chassis in result ) ;
55871: LD_ADDR_VAR 0 3
55875: PUSH
55876: LD_VAR 0 1
55880: PUSH
55881: LD_VAR 0 3
55885: IN
55886: ST_TO_ADDR
// end ;
55887: LD_VAR 0 3
55891: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55892: LD_INT 0
55894: PPUSH
55895: PPUSH
55896: PPUSH
55897: PPUSH
55898: PPUSH
55899: PPUSH
55900: PPUSH
// result := array ;
55901: LD_ADDR_VAR 0 5
55905: PUSH
55906: LD_VAR 0 1
55910: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55911: LD_VAR 0 1
55915: NOT
55916: PUSH
55917: LD_VAR 0 2
55921: NOT
55922: OR
55923: PUSH
55924: LD_VAR 0 3
55928: NOT
55929: OR
55930: PUSH
55931: LD_VAR 0 2
55935: PUSH
55936: LD_VAR 0 1
55940: GREATER
55941: OR
55942: PUSH
55943: LD_VAR 0 3
55947: PUSH
55948: LD_VAR 0 1
55952: GREATER
55953: OR
55954: IFFALSE 55958
// exit ;
55956: GO 56254
// if direction then
55958: LD_VAR 0 4
55962: IFFALSE 56026
// begin d := 1 ;
55964: LD_ADDR_VAR 0 9
55968: PUSH
55969: LD_INT 1
55971: ST_TO_ADDR
// if i_from > i_to then
55972: LD_VAR 0 2
55976: PUSH
55977: LD_VAR 0 3
55981: GREATER
55982: IFFALSE 56008
// length := ( array - i_from ) + i_to else
55984: LD_ADDR_VAR 0 11
55988: PUSH
55989: LD_VAR 0 1
55993: PUSH
55994: LD_VAR 0 2
55998: MINUS
55999: PUSH
56000: LD_VAR 0 3
56004: PLUS
56005: ST_TO_ADDR
56006: GO 56024
// length := i_to - i_from ;
56008: LD_ADDR_VAR 0 11
56012: PUSH
56013: LD_VAR 0 3
56017: PUSH
56018: LD_VAR 0 2
56022: MINUS
56023: ST_TO_ADDR
// end else
56024: GO 56087
// begin d := - 1 ;
56026: LD_ADDR_VAR 0 9
56030: PUSH
56031: LD_INT 1
56033: NEG
56034: ST_TO_ADDR
// if i_from > i_to then
56035: LD_VAR 0 2
56039: PUSH
56040: LD_VAR 0 3
56044: GREATER
56045: IFFALSE 56065
// length := i_from - i_to else
56047: LD_ADDR_VAR 0 11
56051: PUSH
56052: LD_VAR 0 2
56056: PUSH
56057: LD_VAR 0 3
56061: MINUS
56062: ST_TO_ADDR
56063: GO 56087
// length := ( array - i_to ) + i_from ;
56065: LD_ADDR_VAR 0 11
56069: PUSH
56070: LD_VAR 0 1
56074: PUSH
56075: LD_VAR 0 3
56079: MINUS
56080: PUSH
56081: LD_VAR 0 2
56085: PLUS
56086: ST_TO_ADDR
// end ; if not length then
56087: LD_VAR 0 11
56091: NOT
56092: IFFALSE 56096
// exit ;
56094: GO 56254
// tmp := array ;
56096: LD_ADDR_VAR 0 10
56100: PUSH
56101: LD_VAR 0 1
56105: ST_TO_ADDR
// for i = 1 to length do
56106: LD_ADDR_VAR 0 6
56110: PUSH
56111: DOUBLE
56112: LD_INT 1
56114: DEC
56115: ST_TO_ADDR
56116: LD_VAR 0 11
56120: PUSH
56121: FOR_TO
56122: IFFALSE 56242
// begin for j = 1 to array do
56124: LD_ADDR_VAR 0 7
56128: PUSH
56129: DOUBLE
56130: LD_INT 1
56132: DEC
56133: ST_TO_ADDR
56134: LD_VAR 0 1
56138: PUSH
56139: FOR_TO
56140: IFFALSE 56228
// begin k := j + d ;
56142: LD_ADDR_VAR 0 8
56146: PUSH
56147: LD_VAR 0 7
56151: PUSH
56152: LD_VAR 0 9
56156: PLUS
56157: ST_TO_ADDR
// if k > array then
56158: LD_VAR 0 8
56162: PUSH
56163: LD_VAR 0 1
56167: GREATER
56168: IFFALSE 56178
// k := 1 ;
56170: LD_ADDR_VAR 0 8
56174: PUSH
56175: LD_INT 1
56177: ST_TO_ADDR
// if not k then
56178: LD_VAR 0 8
56182: NOT
56183: IFFALSE 56195
// k := array ;
56185: LD_ADDR_VAR 0 8
56189: PUSH
56190: LD_VAR 0 1
56194: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56195: LD_ADDR_VAR 0 10
56199: PUSH
56200: LD_VAR 0 10
56204: PPUSH
56205: LD_VAR 0 8
56209: PPUSH
56210: LD_VAR 0 1
56214: PUSH
56215: LD_VAR 0 7
56219: ARRAY
56220: PPUSH
56221: CALL_OW 1
56225: ST_TO_ADDR
// end ;
56226: GO 56139
56228: POP
56229: POP
// array := tmp ;
56230: LD_ADDR_VAR 0 1
56234: PUSH
56235: LD_VAR 0 10
56239: ST_TO_ADDR
// end ;
56240: GO 56121
56242: POP
56243: POP
// result := array ;
56244: LD_ADDR_VAR 0 5
56248: PUSH
56249: LD_VAR 0 1
56253: ST_TO_ADDR
// end ;
56254: LD_VAR 0 5
56258: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56259: LD_INT 0
56261: PPUSH
56262: PPUSH
// result := 0 ;
56263: LD_ADDR_VAR 0 3
56267: PUSH
56268: LD_INT 0
56270: ST_TO_ADDR
// if not array or not value in array then
56271: LD_VAR 0 1
56275: NOT
56276: PUSH
56277: LD_VAR 0 2
56281: PUSH
56282: LD_VAR 0 1
56286: IN
56287: NOT
56288: OR
56289: IFFALSE 56293
// exit ;
56291: GO 56347
// for i = 1 to array do
56293: LD_ADDR_VAR 0 4
56297: PUSH
56298: DOUBLE
56299: LD_INT 1
56301: DEC
56302: ST_TO_ADDR
56303: LD_VAR 0 1
56307: PUSH
56308: FOR_TO
56309: IFFALSE 56345
// if value = array [ i ] then
56311: LD_VAR 0 2
56315: PUSH
56316: LD_VAR 0 1
56320: PUSH
56321: LD_VAR 0 4
56325: ARRAY
56326: EQUAL
56327: IFFALSE 56343
// begin result := i ;
56329: LD_ADDR_VAR 0 3
56333: PUSH
56334: LD_VAR 0 4
56338: ST_TO_ADDR
// exit ;
56339: POP
56340: POP
56341: GO 56347
// end ;
56343: GO 56308
56345: POP
56346: POP
// end ;
56347: LD_VAR 0 3
56351: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56352: LD_INT 0
56354: PPUSH
// vc_chassis := chassis ;
56355: LD_ADDR_OWVAR 37
56359: PUSH
56360: LD_VAR 0 1
56364: ST_TO_ADDR
// vc_engine := engine ;
56365: LD_ADDR_OWVAR 39
56369: PUSH
56370: LD_VAR 0 2
56374: ST_TO_ADDR
// vc_control := control ;
56375: LD_ADDR_OWVAR 38
56379: PUSH
56380: LD_VAR 0 3
56384: ST_TO_ADDR
// vc_weapon := weapon ;
56385: LD_ADDR_OWVAR 40
56389: PUSH
56390: LD_VAR 0 4
56394: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56395: LD_ADDR_OWVAR 41
56399: PUSH
56400: LD_VAR 0 5
56404: ST_TO_ADDR
// end ;
56405: LD_VAR 0 6
56409: RET
// export function WantPlant ( unit ) ; var task ; begin
56410: LD_INT 0
56412: PPUSH
56413: PPUSH
// result := false ;
56414: LD_ADDR_VAR 0 2
56418: PUSH
56419: LD_INT 0
56421: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56422: LD_ADDR_VAR 0 3
56426: PUSH
56427: LD_VAR 0 1
56431: PPUSH
56432: CALL_OW 437
56436: ST_TO_ADDR
// if task then
56437: LD_VAR 0 3
56441: IFFALSE 56469
// if task [ 1 ] [ 1 ] = p then
56443: LD_VAR 0 3
56447: PUSH
56448: LD_INT 1
56450: ARRAY
56451: PUSH
56452: LD_INT 1
56454: ARRAY
56455: PUSH
56456: LD_STRING p
56458: EQUAL
56459: IFFALSE 56469
// result := true ;
56461: LD_ADDR_VAR 0 2
56465: PUSH
56466: LD_INT 1
56468: ST_TO_ADDR
// end ;
56469: LD_VAR 0 2
56473: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56474: LD_INT 0
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
// if pos < 1 then
56480: LD_VAR 0 2
56484: PUSH
56485: LD_INT 1
56487: LESS
56488: IFFALSE 56492
// exit ;
56490: GO 56795
// if pos = 1 then
56492: LD_VAR 0 2
56496: PUSH
56497: LD_INT 1
56499: EQUAL
56500: IFFALSE 56533
// result := Replace ( arr , pos [ 1 ] , value ) else
56502: LD_ADDR_VAR 0 4
56506: PUSH
56507: LD_VAR 0 1
56511: PPUSH
56512: LD_VAR 0 2
56516: PUSH
56517: LD_INT 1
56519: ARRAY
56520: PPUSH
56521: LD_VAR 0 3
56525: PPUSH
56526: CALL_OW 1
56530: ST_TO_ADDR
56531: GO 56795
// begin tmp := arr ;
56533: LD_ADDR_VAR 0 6
56537: PUSH
56538: LD_VAR 0 1
56542: ST_TO_ADDR
// s_arr := [ tmp ] ;
56543: LD_ADDR_VAR 0 7
56547: PUSH
56548: LD_VAR 0 6
56552: PUSH
56553: EMPTY
56554: LIST
56555: ST_TO_ADDR
// for i = 1 to pos - 1 do
56556: LD_ADDR_VAR 0 5
56560: PUSH
56561: DOUBLE
56562: LD_INT 1
56564: DEC
56565: ST_TO_ADDR
56566: LD_VAR 0 2
56570: PUSH
56571: LD_INT 1
56573: MINUS
56574: PUSH
56575: FOR_TO
56576: IFFALSE 56621
// begin tmp := tmp [ pos [ i ] ] ;
56578: LD_ADDR_VAR 0 6
56582: PUSH
56583: LD_VAR 0 6
56587: PUSH
56588: LD_VAR 0 2
56592: PUSH
56593: LD_VAR 0 5
56597: ARRAY
56598: ARRAY
56599: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56600: LD_ADDR_VAR 0 7
56604: PUSH
56605: LD_VAR 0 7
56609: PUSH
56610: LD_VAR 0 6
56614: PUSH
56615: EMPTY
56616: LIST
56617: ADD
56618: ST_TO_ADDR
// end ;
56619: GO 56575
56621: POP
56622: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56623: LD_ADDR_VAR 0 6
56627: PUSH
56628: LD_VAR 0 6
56632: PPUSH
56633: LD_VAR 0 2
56637: PUSH
56638: LD_VAR 0 2
56642: ARRAY
56643: PPUSH
56644: LD_VAR 0 3
56648: PPUSH
56649: CALL_OW 1
56653: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56654: LD_ADDR_VAR 0 7
56658: PUSH
56659: LD_VAR 0 7
56663: PPUSH
56664: LD_VAR 0 7
56668: PPUSH
56669: LD_VAR 0 6
56673: PPUSH
56674: CALL_OW 1
56678: ST_TO_ADDR
// for i = s_arr downto 2 do
56679: LD_ADDR_VAR 0 5
56683: PUSH
56684: DOUBLE
56685: LD_VAR 0 7
56689: INC
56690: ST_TO_ADDR
56691: LD_INT 2
56693: PUSH
56694: FOR_DOWNTO
56695: IFFALSE 56779
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56697: LD_ADDR_VAR 0 6
56701: PUSH
56702: LD_VAR 0 7
56706: PUSH
56707: LD_VAR 0 5
56711: PUSH
56712: LD_INT 1
56714: MINUS
56715: ARRAY
56716: PPUSH
56717: LD_VAR 0 2
56721: PUSH
56722: LD_VAR 0 5
56726: PUSH
56727: LD_INT 1
56729: MINUS
56730: ARRAY
56731: PPUSH
56732: LD_VAR 0 7
56736: PUSH
56737: LD_VAR 0 5
56741: ARRAY
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56748: LD_ADDR_VAR 0 7
56752: PUSH
56753: LD_VAR 0 7
56757: PPUSH
56758: LD_VAR 0 5
56762: PUSH
56763: LD_INT 1
56765: MINUS
56766: PPUSH
56767: LD_VAR 0 6
56771: PPUSH
56772: CALL_OW 1
56776: ST_TO_ADDR
// end ;
56777: GO 56694
56779: POP
56780: POP
// result := s_arr [ 1 ] ;
56781: LD_ADDR_VAR 0 4
56785: PUSH
56786: LD_VAR 0 7
56790: PUSH
56791: LD_INT 1
56793: ARRAY
56794: ST_TO_ADDR
// end ; end ;
56795: LD_VAR 0 4
56799: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56800: LD_INT 0
56802: PPUSH
56803: PPUSH
// if not list then
56804: LD_VAR 0 1
56808: NOT
56809: IFFALSE 56813
// exit ;
56811: GO 56904
// i := list [ pos1 ] ;
56813: LD_ADDR_VAR 0 5
56817: PUSH
56818: LD_VAR 0 1
56822: PUSH
56823: LD_VAR 0 2
56827: ARRAY
56828: ST_TO_ADDR
// if not i then
56829: LD_VAR 0 5
56833: NOT
56834: IFFALSE 56838
// exit ;
56836: GO 56904
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56838: LD_ADDR_VAR 0 1
56842: PUSH
56843: LD_VAR 0 1
56847: PPUSH
56848: LD_VAR 0 2
56852: PPUSH
56853: LD_VAR 0 1
56857: PUSH
56858: LD_VAR 0 3
56862: ARRAY
56863: PPUSH
56864: CALL_OW 1
56868: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56869: LD_ADDR_VAR 0 1
56873: PUSH
56874: LD_VAR 0 1
56878: PPUSH
56879: LD_VAR 0 3
56883: PPUSH
56884: LD_VAR 0 5
56888: PPUSH
56889: CALL_OW 1
56893: ST_TO_ADDR
// result := list ;
56894: LD_ADDR_VAR 0 4
56898: PUSH
56899: LD_VAR 0 1
56903: ST_TO_ADDR
// end ;
56904: LD_VAR 0 4
56908: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56909: LD_INT 0
56911: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56912: LD_ADDR_VAR 0 5
56916: PUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: CALL_OW 250
56926: PPUSH
56927: LD_VAR 0 1
56931: PPUSH
56932: CALL_OW 251
56936: PPUSH
56937: LD_VAR 0 2
56941: PPUSH
56942: LD_VAR 0 3
56946: PPUSH
56947: LD_VAR 0 4
56951: PPUSH
56952: CALL 56962 0 5
56956: ST_TO_ADDR
// end ;
56957: LD_VAR 0 5
56961: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56962: LD_INT 0
56964: PPUSH
56965: PPUSH
56966: PPUSH
56967: PPUSH
// if not list then
56968: LD_VAR 0 3
56972: NOT
56973: IFFALSE 56977
// exit ;
56975: GO 57365
// result := [ ] ;
56977: LD_ADDR_VAR 0 6
56981: PUSH
56982: EMPTY
56983: ST_TO_ADDR
// for i in list do
56984: LD_ADDR_VAR 0 7
56988: PUSH
56989: LD_VAR 0 3
56993: PUSH
56994: FOR_IN
56995: IFFALSE 57197
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56997: LD_ADDR_VAR 0 9
57001: PUSH
57002: LD_VAR 0 7
57006: PPUSH
57007: LD_VAR 0 1
57011: PPUSH
57012: LD_VAR 0 2
57016: PPUSH
57017: CALL_OW 297
57021: ST_TO_ADDR
// if not result then
57022: LD_VAR 0 6
57026: NOT
57027: IFFALSE 57053
// result := [ [ i , tmp ] ] else
57029: LD_ADDR_VAR 0 6
57033: PUSH
57034: LD_VAR 0 7
57038: PUSH
57039: LD_VAR 0 9
57043: PUSH
57044: EMPTY
57045: LIST
57046: LIST
57047: PUSH
57048: EMPTY
57049: LIST
57050: ST_TO_ADDR
57051: GO 57195
// begin if result [ result ] [ 2 ] < tmp then
57053: LD_VAR 0 6
57057: PUSH
57058: LD_VAR 0 6
57062: ARRAY
57063: PUSH
57064: LD_INT 2
57066: ARRAY
57067: PUSH
57068: LD_VAR 0 9
57072: LESS
57073: IFFALSE 57115
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57075: LD_ADDR_VAR 0 6
57079: PUSH
57080: LD_VAR 0 6
57084: PPUSH
57085: LD_VAR 0 6
57089: PUSH
57090: LD_INT 1
57092: PLUS
57093: PPUSH
57094: LD_VAR 0 7
57098: PUSH
57099: LD_VAR 0 9
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PPUSH
57108: CALL_OW 2
57112: ST_TO_ADDR
57113: GO 57195
// for j = 1 to result do
57115: LD_ADDR_VAR 0 8
57119: PUSH
57120: DOUBLE
57121: LD_INT 1
57123: DEC
57124: ST_TO_ADDR
57125: LD_VAR 0 6
57129: PUSH
57130: FOR_TO
57131: IFFALSE 57193
// begin if tmp < result [ j ] [ 2 ] then
57133: LD_VAR 0 9
57137: PUSH
57138: LD_VAR 0 6
57142: PUSH
57143: LD_VAR 0 8
57147: ARRAY
57148: PUSH
57149: LD_INT 2
57151: ARRAY
57152: LESS
57153: IFFALSE 57191
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57155: LD_ADDR_VAR 0 6
57159: PUSH
57160: LD_VAR 0 6
57164: PPUSH
57165: LD_VAR 0 8
57169: PPUSH
57170: LD_VAR 0 7
57174: PUSH
57175: LD_VAR 0 9
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PPUSH
57184: CALL_OW 2
57188: ST_TO_ADDR
// break ;
57189: GO 57193
// end ; end ;
57191: GO 57130
57193: POP
57194: POP
// end ; end ;
57195: GO 56994
57197: POP
57198: POP
// if result and not asc then
57199: LD_VAR 0 6
57203: PUSH
57204: LD_VAR 0 4
57208: NOT
57209: AND
57210: IFFALSE 57285
// begin tmp := result ;
57212: LD_ADDR_VAR 0 9
57216: PUSH
57217: LD_VAR 0 6
57221: ST_TO_ADDR
// for i = tmp downto 1 do
57222: LD_ADDR_VAR 0 7
57226: PUSH
57227: DOUBLE
57228: LD_VAR 0 9
57232: INC
57233: ST_TO_ADDR
57234: LD_INT 1
57236: PUSH
57237: FOR_DOWNTO
57238: IFFALSE 57283
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57240: LD_ADDR_VAR 0 6
57244: PUSH
57245: LD_VAR 0 6
57249: PPUSH
57250: LD_VAR 0 9
57254: PUSH
57255: LD_VAR 0 7
57259: MINUS
57260: PUSH
57261: LD_INT 1
57263: PLUS
57264: PPUSH
57265: LD_VAR 0 9
57269: PUSH
57270: LD_VAR 0 7
57274: ARRAY
57275: PPUSH
57276: CALL_OW 1
57280: ST_TO_ADDR
57281: GO 57237
57283: POP
57284: POP
// end ; tmp := [ ] ;
57285: LD_ADDR_VAR 0 9
57289: PUSH
57290: EMPTY
57291: ST_TO_ADDR
// if mode then
57292: LD_VAR 0 5
57296: IFFALSE 57365
// begin for i = 1 to result do
57298: LD_ADDR_VAR 0 7
57302: PUSH
57303: DOUBLE
57304: LD_INT 1
57306: DEC
57307: ST_TO_ADDR
57308: LD_VAR 0 6
57312: PUSH
57313: FOR_TO
57314: IFFALSE 57353
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57316: LD_ADDR_VAR 0 9
57320: PUSH
57321: LD_VAR 0 9
57325: PPUSH
57326: LD_VAR 0 7
57330: PPUSH
57331: LD_VAR 0 6
57335: PUSH
57336: LD_VAR 0 7
57340: ARRAY
57341: PUSH
57342: LD_INT 1
57344: ARRAY
57345: PPUSH
57346: CALL_OW 1
57350: ST_TO_ADDR
57351: GO 57313
57353: POP
57354: POP
// result := tmp ;
57355: LD_ADDR_VAR 0 6
57359: PUSH
57360: LD_VAR 0 9
57364: ST_TO_ADDR
// end ; end ;
57365: LD_VAR 0 6
57369: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57370: LD_INT 0
57372: PPUSH
57373: PPUSH
57374: PPUSH
57375: PPUSH
57376: PPUSH
57377: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57378: LD_ADDR_VAR 0 5
57382: PUSH
57383: LD_INT 0
57385: PUSH
57386: LD_INT 0
57388: PUSH
57389: LD_INT 0
57391: PUSH
57392: EMPTY
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: LIST
57398: LIST
57399: ST_TO_ADDR
// if not x or not y then
57400: LD_VAR 0 2
57404: NOT
57405: PUSH
57406: LD_VAR 0 3
57410: NOT
57411: OR
57412: IFFALSE 57416
// exit ;
57414: GO 59068
// if not range then
57416: LD_VAR 0 4
57420: NOT
57421: IFFALSE 57431
// range := 10 ;
57423: LD_ADDR_VAR 0 4
57427: PUSH
57428: LD_INT 10
57430: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57431: LD_ADDR_VAR 0 8
57435: PUSH
57436: LD_INT 81
57438: PUSH
57439: LD_VAR 0 1
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: LD_INT 92
57450: PUSH
57451: LD_VAR 0 2
57455: PUSH
57456: LD_VAR 0 3
57460: PUSH
57461: LD_VAR 0 4
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 3
57474: PUSH
57475: LD_INT 21
57477: PUSH
57478: LD_INT 3
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: EMPTY
57486: LIST
57487: LIST
57488: PUSH
57489: EMPTY
57490: LIST
57491: LIST
57492: LIST
57493: PPUSH
57494: CALL_OW 69
57498: ST_TO_ADDR
// if not tmp then
57499: LD_VAR 0 8
57503: NOT
57504: IFFALSE 57508
// exit ;
57506: GO 59068
// for i in tmp do
57508: LD_ADDR_VAR 0 6
57512: PUSH
57513: LD_VAR 0 8
57517: PUSH
57518: FOR_IN
57519: IFFALSE 59043
// begin points := [ 0 , 0 , 0 ] ;
57521: LD_ADDR_VAR 0 9
57525: PUSH
57526: LD_INT 0
57528: PUSH
57529: LD_INT 0
57531: PUSH
57532: LD_INT 0
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: LIST
57539: ST_TO_ADDR
// bpoints := 1 ;
57540: LD_ADDR_VAR 0 10
57544: PUSH
57545: LD_INT 1
57547: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57548: LD_VAR 0 6
57552: PPUSH
57553: CALL_OW 247
57557: PUSH
57558: LD_INT 1
57560: DOUBLE
57561: EQUAL
57562: IFTRUE 57566
57564: GO 58144
57566: POP
// begin if GetClass ( i ) = 1 then
57567: LD_VAR 0 6
57571: PPUSH
57572: CALL_OW 257
57576: PUSH
57577: LD_INT 1
57579: EQUAL
57580: IFFALSE 57601
// points := [ 10 , 5 , 3 ] ;
57582: LD_ADDR_VAR 0 9
57586: PUSH
57587: LD_INT 10
57589: PUSH
57590: LD_INT 5
57592: PUSH
57593: LD_INT 3
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: LIST
57600: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57601: LD_VAR 0 6
57605: PPUSH
57606: CALL_OW 257
57610: PUSH
57611: LD_INT 2
57613: PUSH
57614: LD_INT 3
57616: PUSH
57617: LD_INT 4
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: LIST
57624: IN
57625: IFFALSE 57646
// points := [ 3 , 2 , 1 ] ;
57627: LD_ADDR_VAR 0 9
57631: PUSH
57632: LD_INT 3
57634: PUSH
57635: LD_INT 2
57637: PUSH
57638: LD_INT 1
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: LIST
57645: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57646: LD_VAR 0 6
57650: PPUSH
57651: CALL_OW 257
57655: PUSH
57656: LD_INT 5
57658: EQUAL
57659: IFFALSE 57680
// points := [ 130 , 5 , 2 ] ;
57661: LD_ADDR_VAR 0 9
57665: PUSH
57666: LD_INT 130
57668: PUSH
57669: LD_INT 5
57671: PUSH
57672: LD_INT 2
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: LIST
57679: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57680: LD_VAR 0 6
57684: PPUSH
57685: CALL_OW 257
57689: PUSH
57690: LD_INT 8
57692: EQUAL
57693: IFFALSE 57714
// points := [ 35 , 35 , 30 ] ;
57695: LD_ADDR_VAR 0 9
57699: PUSH
57700: LD_INT 35
57702: PUSH
57703: LD_INT 35
57705: PUSH
57706: LD_INT 30
57708: PUSH
57709: EMPTY
57710: LIST
57711: LIST
57712: LIST
57713: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57714: LD_VAR 0 6
57718: PPUSH
57719: CALL_OW 257
57723: PUSH
57724: LD_INT 9
57726: EQUAL
57727: IFFALSE 57748
// points := [ 20 , 55 , 40 ] ;
57729: LD_ADDR_VAR 0 9
57733: PUSH
57734: LD_INT 20
57736: PUSH
57737: LD_INT 55
57739: PUSH
57740: LD_INT 40
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: LIST
57747: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57748: LD_VAR 0 6
57752: PPUSH
57753: CALL_OW 257
57757: PUSH
57758: LD_INT 12
57760: PUSH
57761: LD_INT 16
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: IN
57768: IFFALSE 57789
// points := [ 5 , 3 , 2 ] ;
57770: LD_ADDR_VAR 0 9
57774: PUSH
57775: LD_INT 5
57777: PUSH
57778: LD_INT 3
57780: PUSH
57781: LD_INT 2
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: LIST
57788: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57789: LD_VAR 0 6
57793: PPUSH
57794: CALL_OW 257
57798: PUSH
57799: LD_INT 17
57801: EQUAL
57802: IFFALSE 57823
// points := [ 100 , 50 , 75 ] ;
57804: LD_ADDR_VAR 0 9
57808: PUSH
57809: LD_INT 100
57811: PUSH
57812: LD_INT 50
57814: PUSH
57815: LD_INT 75
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: LIST
57822: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57823: LD_VAR 0 6
57827: PPUSH
57828: CALL_OW 257
57832: PUSH
57833: LD_INT 15
57835: EQUAL
57836: IFFALSE 57857
// points := [ 10 , 5 , 3 ] ;
57838: LD_ADDR_VAR 0 9
57842: PUSH
57843: LD_INT 10
57845: PUSH
57846: LD_INT 5
57848: PUSH
57849: LD_INT 3
57851: PUSH
57852: EMPTY
57853: LIST
57854: LIST
57855: LIST
57856: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57857: LD_VAR 0 6
57861: PPUSH
57862: CALL_OW 257
57866: PUSH
57867: LD_INT 14
57869: EQUAL
57870: IFFALSE 57891
// points := [ 10 , 0 , 0 ] ;
57872: LD_ADDR_VAR 0 9
57876: PUSH
57877: LD_INT 10
57879: PUSH
57880: LD_INT 0
57882: PUSH
57883: LD_INT 0
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: LIST
57890: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57891: LD_VAR 0 6
57895: PPUSH
57896: CALL_OW 257
57900: PUSH
57901: LD_INT 11
57903: EQUAL
57904: IFFALSE 57925
// points := [ 30 , 10 , 5 ] ;
57906: LD_ADDR_VAR 0 9
57910: PUSH
57911: LD_INT 30
57913: PUSH
57914: LD_INT 10
57916: PUSH
57917: LD_INT 5
57919: PUSH
57920: EMPTY
57921: LIST
57922: LIST
57923: LIST
57924: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57925: LD_VAR 0 1
57929: PPUSH
57930: LD_INT 5
57932: PPUSH
57933: CALL_OW 321
57937: PUSH
57938: LD_INT 2
57940: EQUAL
57941: IFFALSE 57958
// bpoints := bpoints * 1.8 ;
57943: LD_ADDR_VAR 0 10
57947: PUSH
57948: LD_VAR 0 10
57952: PUSH
57953: LD_REAL  1.80000000000000E+0000
57956: MUL
57957: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57958: LD_VAR 0 6
57962: PPUSH
57963: CALL_OW 257
57967: PUSH
57968: LD_INT 1
57970: PUSH
57971: LD_INT 2
57973: PUSH
57974: LD_INT 3
57976: PUSH
57977: LD_INT 4
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: LIST
57984: LIST
57985: IN
57986: PUSH
57987: LD_VAR 0 1
57991: PPUSH
57992: LD_INT 51
57994: PPUSH
57995: CALL_OW 321
57999: PUSH
58000: LD_INT 2
58002: EQUAL
58003: AND
58004: IFFALSE 58021
// bpoints := bpoints * 1.2 ;
58006: LD_ADDR_VAR 0 10
58010: PUSH
58011: LD_VAR 0 10
58015: PUSH
58016: LD_REAL  1.20000000000000E+0000
58019: MUL
58020: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58021: LD_VAR 0 6
58025: PPUSH
58026: CALL_OW 257
58030: PUSH
58031: LD_INT 5
58033: PUSH
58034: LD_INT 7
58036: PUSH
58037: LD_INT 9
58039: PUSH
58040: EMPTY
58041: LIST
58042: LIST
58043: LIST
58044: IN
58045: PUSH
58046: LD_VAR 0 1
58050: PPUSH
58051: LD_INT 52
58053: PPUSH
58054: CALL_OW 321
58058: PUSH
58059: LD_INT 2
58061: EQUAL
58062: AND
58063: IFFALSE 58080
// bpoints := bpoints * 1.5 ;
58065: LD_ADDR_VAR 0 10
58069: PUSH
58070: LD_VAR 0 10
58074: PUSH
58075: LD_REAL  1.50000000000000E+0000
58078: MUL
58079: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58080: LD_VAR 0 1
58084: PPUSH
58085: LD_INT 66
58087: PPUSH
58088: CALL_OW 321
58092: PUSH
58093: LD_INT 2
58095: EQUAL
58096: IFFALSE 58113
// bpoints := bpoints * 1.1 ;
58098: LD_ADDR_VAR 0 10
58102: PUSH
58103: LD_VAR 0 10
58107: PUSH
58108: LD_REAL  1.10000000000000E+0000
58111: MUL
58112: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58113: LD_ADDR_VAR 0 10
58117: PUSH
58118: LD_VAR 0 10
58122: PUSH
58123: LD_VAR 0 6
58127: PPUSH
58128: LD_INT 1
58130: PPUSH
58131: CALL_OW 259
58135: PUSH
58136: LD_REAL  1.15000000000000E+0000
58139: MUL
58140: MUL
58141: ST_TO_ADDR
// end ; unit_vehicle :
58142: GO 58972
58144: LD_INT 2
58146: DOUBLE
58147: EQUAL
58148: IFTRUE 58152
58150: GO 58960
58152: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58153: LD_VAR 0 6
58157: PPUSH
58158: CALL_OW 264
58162: PUSH
58163: LD_INT 2
58165: PUSH
58166: LD_INT 42
58168: PUSH
58169: LD_INT 24
58171: PUSH
58172: EMPTY
58173: LIST
58174: LIST
58175: LIST
58176: IN
58177: IFFALSE 58198
// points := [ 25 , 5 , 3 ] ;
58179: LD_ADDR_VAR 0 9
58183: PUSH
58184: LD_INT 25
58186: PUSH
58187: LD_INT 5
58189: PUSH
58190: LD_INT 3
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: LIST
58197: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58198: LD_VAR 0 6
58202: PPUSH
58203: CALL_OW 264
58207: PUSH
58208: LD_INT 4
58210: PUSH
58211: LD_INT 43
58213: PUSH
58214: LD_INT 25
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: LIST
58221: IN
58222: IFFALSE 58243
// points := [ 40 , 15 , 5 ] ;
58224: LD_ADDR_VAR 0 9
58228: PUSH
58229: LD_INT 40
58231: PUSH
58232: LD_INT 15
58234: PUSH
58235: LD_INT 5
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: LIST
58242: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58243: LD_VAR 0 6
58247: PPUSH
58248: CALL_OW 264
58252: PUSH
58253: LD_INT 3
58255: PUSH
58256: LD_INT 23
58258: PUSH
58259: EMPTY
58260: LIST
58261: LIST
58262: IN
58263: IFFALSE 58284
// points := [ 7 , 25 , 8 ] ;
58265: LD_ADDR_VAR 0 9
58269: PUSH
58270: LD_INT 7
58272: PUSH
58273: LD_INT 25
58275: PUSH
58276: LD_INT 8
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58284: LD_VAR 0 6
58288: PPUSH
58289: CALL_OW 264
58293: PUSH
58294: LD_INT 5
58296: PUSH
58297: LD_INT 27
58299: PUSH
58300: LD_INT 44
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: LIST
58307: IN
58308: IFFALSE 58329
// points := [ 14 , 50 , 16 ] ;
58310: LD_ADDR_VAR 0 9
58314: PUSH
58315: LD_INT 14
58317: PUSH
58318: LD_INT 50
58320: PUSH
58321: LD_INT 16
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: LIST
58328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58329: LD_VAR 0 6
58333: PPUSH
58334: CALL_OW 264
58338: PUSH
58339: LD_INT 6
58341: PUSH
58342: LD_INT 46
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: IN
58349: IFFALSE 58370
// points := [ 32 , 120 , 70 ] ;
58351: LD_ADDR_VAR 0 9
58355: PUSH
58356: LD_INT 32
58358: PUSH
58359: LD_INT 120
58361: PUSH
58362: LD_INT 70
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: LIST
58369: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58370: LD_VAR 0 6
58374: PPUSH
58375: CALL_OW 264
58379: PUSH
58380: LD_INT 7
58382: PUSH
58383: LD_INT 28
58385: PUSH
58386: LD_INT 45
58388: PUSH
58389: LD_EXP 77
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: LIST
58398: LIST
58399: IN
58400: IFFALSE 58421
// points := [ 35 , 20 , 45 ] ;
58402: LD_ADDR_VAR 0 9
58406: PUSH
58407: LD_INT 35
58409: PUSH
58410: LD_INT 20
58412: PUSH
58413: LD_INT 45
58415: PUSH
58416: EMPTY
58417: LIST
58418: LIST
58419: LIST
58420: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58421: LD_VAR 0 6
58425: PPUSH
58426: CALL_OW 264
58430: PUSH
58431: LD_INT 47
58433: PUSH
58434: EMPTY
58435: LIST
58436: IN
58437: IFFALSE 58458
// points := [ 67 , 45 , 75 ] ;
58439: LD_ADDR_VAR 0 9
58443: PUSH
58444: LD_INT 67
58446: PUSH
58447: LD_INT 45
58449: PUSH
58450: LD_INT 75
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: LIST
58457: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58458: LD_VAR 0 6
58462: PPUSH
58463: CALL_OW 264
58467: PUSH
58468: LD_INT 26
58470: PUSH
58471: EMPTY
58472: LIST
58473: IN
58474: IFFALSE 58495
// points := [ 120 , 30 , 80 ] ;
58476: LD_ADDR_VAR 0 9
58480: PUSH
58481: LD_INT 120
58483: PUSH
58484: LD_INT 30
58486: PUSH
58487: LD_INT 80
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58495: LD_VAR 0 6
58499: PPUSH
58500: CALL_OW 264
58504: PUSH
58505: LD_INT 22
58507: PUSH
58508: EMPTY
58509: LIST
58510: IN
58511: IFFALSE 58532
// points := [ 40 , 1 , 1 ] ;
58513: LD_ADDR_VAR 0 9
58517: PUSH
58518: LD_INT 40
58520: PUSH
58521: LD_INT 1
58523: PUSH
58524: LD_INT 1
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: LIST
58531: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58532: LD_VAR 0 6
58536: PPUSH
58537: CALL_OW 264
58541: PUSH
58542: LD_INT 29
58544: PUSH
58545: EMPTY
58546: LIST
58547: IN
58548: IFFALSE 58569
// points := [ 70 , 200 , 400 ] ;
58550: LD_ADDR_VAR 0 9
58554: PUSH
58555: LD_INT 70
58557: PUSH
58558: LD_INT 200
58560: PUSH
58561: LD_INT 400
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: LIST
58568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58569: LD_VAR 0 6
58573: PPUSH
58574: CALL_OW 264
58578: PUSH
58579: LD_INT 14
58581: PUSH
58582: LD_INT 53
58584: PUSH
58585: EMPTY
58586: LIST
58587: LIST
58588: IN
58589: IFFALSE 58610
// points := [ 40 , 10 , 20 ] ;
58591: LD_ADDR_VAR 0 9
58595: PUSH
58596: LD_INT 40
58598: PUSH
58599: LD_INT 10
58601: PUSH
58602: LD_INT 20
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: LIST
58609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58610: LD_VAR 0 6
58614: PPUSH
58615: CALL_OW 264
58619: PUSH
58620: LD_INT 9
58622: PUSH
58623: EMPTY
58624: LIST
58625: IN
58626: IFFALSE 58647
// points := [ 5 , 70 , 20 ] ;
58628: LD_ADDR_VAR 0 9
58632: PUSH
58633: LD_INT 5
58635: PUSH
58636: LD_INT 70
58638: PUSH
58639: LD_INT 20
58641: PUSH
58642: EMPTY
58643: LIST
58644: LIST
58645: LIST
58646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58647: LD_VAR 0 6
58651: PPUSH
58652: CALL_OW 264
58656: PUSH
58657: LD_INT 10
58659: PUSH
58660: EMPTY
58661: LIST
58662: IN
58663: IFFALSE 58684
// points := [ 35 , 110 , 70 ] ;
58665: LD_ADDR_VAR 0 9
58669: PUSH
58670: LD_INT 35
58672: PUSH
58673: LD_INT 110
58675: PUSH
58676: LD_INT 70
58678: PUSH
58679: EMPTY
58680: LIST
58681: LIST
58682: LIST
58683: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58684: LD_VAR 0 6
58688: PPUSH
58689: CALL_OW 265
58693: PUSH
58694: LD_INT 25
58696: EQUAL
58697: IFFALSE 58718
// points := [ 80 , 65 , 100 ] ;
58699: LD_ADDR_VAR 0 9
58703: PUSH
58704: LD_INT 80
58706: PUSH
58707: LD_INT 65
58709: PUSH
58710: LD_INT 100
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: LIST
58717: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58718: LD_VAR 0 6
58722: PPUSH
58723: CALL_OW 263
58727: PUSH
58728: LD_INT 1
58730: EQUAL
58731: IFFALSE 58766
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58733: LD_ADDR_VAR 0 10
58737: PUSH
58738: LD_VAR 0 10
58742: PUSH
58743: LD_VAR 0 6
58747: PPUSH
58748: CALL_OW 311
58752: PPUSH
58753: LD_INT 3
58755: PPUSH
58756: CALL_OW 259
58760: PUSH
58761: LD_INT 4
58763: MUL
58764: MUL
58765: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58766: LD_VAR 0 6
58770: PPUSH
58771: CALL_OW 263
58775: PUSH
58776: LD_INT 2
58778: EQUAL
58779: IFFALSE 58830
// begin j := IsControledBy ( i ) ;
58781: LD_ADDR_VAR 0 7
58785: PUSH
58786: LD_VAR 0 6
58790: PPUSH
58791: CALL_OW 312
58795: ST_TO_ADDR
// if j then
58796: LD_VAR 0 7
58800: IFFALSE 58830
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58802: LD_ADDR_VAR 0 10
58806: PUSH
58807: LD_VAR 0 10
58811: PUSH
58812: LD_VAR 0 7
58816: PPUSH
58817: LD_INT 3
58819: PPUSH
58820: CALL_OW 259
58824: PUSH
58825: LD_INT 3
58827: MUL
58828: MUL
58829: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58830: LD_VAR 0 6
58834: PPUSH
58835: CALL_OW 264
58839: PUSH
58840: LD_INT 5
58842: PUSH
58843: LD_INT 6
58845: PUSH
58846: LD_INT 46
58848: PUSH
58849: LD_INT 44
58851: PUSH
58852: LD_INT 47
58854: PUSH
58855: LD_INT 45
58857: PUSH
58858: LD_INT 28
58860: PUSH
58861: LD_INT 7
58863: PUSH
58864: LD_INT 27
58866: PUSH
58867: LD_INT 29
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: LIST
58878: LIST
58879: LIST
58880: LIST
58881: IN
58882: PUSH
58883: LD_VAR 0 1
58887: PPUSH
58888: LD_INT 52
58890: PPUSH
58891: CALL_OW 321
58895: PUSH
58896: LD_INT 2
58898: EQUAL
58899: AND
58900: IFFALSE 58917
// bpoints := bpoints * 1.2 ;
58902: LD_ADDR_VAR 0 10
58906: PUSH
58907: LD_VAR 0 10
58911: PUSH
58912: LD_REAL  1.20000000000000E+0000
58915: MUL
58916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58917: LD_VAR 0 6
58921: PPUSH
58922: CALL_OW 264
58926: PUSH
58927: LD_INT 6
58929: PUSH
58930: LD_INT 46
58932: PUSH
58933: LD_INT 47
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: LIST
58940: IN
58941: IFFALSE 58958
// bpoints := bpoints * 1.2 ;
58943: LD_ADDR_VAR 0 10
58947: PUSH
58948: LD_VAR 0 10
58952: PUSH
58953: LD_REAL  1.20000000000000E+0000
58956: MUL
58957: ST_TO_ADDR
// end ; unit_building :
58958: GO 58972
58960: LD_INT 3
58962: DOUBLE
58963: EQUAL
58964: IFTRUE 58968
58966: GO 58971
58968: POP
// ; end ;
58969: GO 58972
58971: POP
// for j = 1 to 3 do
58972: LD_ADDR_VAR 0 7
58976: PUSH
58977: DOUBLE
58978: LD_INT 1
58980: DEC
58981: ST_TO_ADDR
58982: LD_INT 3
58984: PUSH
58985: FOR_TO
58986: IFFALSE 59039
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58988: LD_ADDR_VAR 0 5
58992: PUSH
58993: LD_VAR 0 5
58997: PPUSH
58998: LD_VAR 0 7
59002: PPUSH
59003: LD_VAR 0 5
59007: PUSH
59008: LD_VAR 0 7
59012: ARRAY
59013: PUSH
59014: LD_VAR 0 9
59018: PUSH
59019: LD_VAR 0 7
59023: ARRAY
59024: PUSH
59025: LD_VAR 0 10
59029: MUL
59030: PLUS
59031: PPUSH
59032: CALL_OW 1
59036: ST_TO_ADDR
59037: GO 58985
59039: POP
59040: POP
// end ;
59041: GO 57518
59043: POP
59044: POP
// result := Replace ( result , 4 , tmp ) ;
59045: LD_ADDR_VAR 0 5
59049: PUSH
59050: LD_VAR 0 5
59054: PPUSH
59055: LD_INT 4
59057: PPUSH
59058: LD_VAR 0 8
59062: PPUSH
59063: CALL_OW 1
59067: ST_TO_ADDR
// end ;
59068: LD_VAR 0 5
59072: RET
// export function DangerAtRange ( unit , range ) ; begin
59073: LD_INT 0
59075: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59076: LD_ADDR_VAR 0 3
59080: PUSH
59081: LD_VAR 0 1
59085: PPUSH
59086: CALL_OW 255
59090: PPUSH
59091: LD_VAR 0 1
59095: PPUSH
59096: CALL_OW 250
59100: PPUSH
59101: LD_VAR 0 1
59105: PPUSH
59106: CALL_OW 251
59110: PPUSH
59111: LD_VAR 0 2
59115: PPUSH
59116: CALL 57370 0 4
59120: ST_TO_ADDR
// end ;
59121: LD_VAR 0 3
59125: RET
// export function DangerInArea ( side , area ) ; begin
59126: LD_INT 0
59128: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59129: LD_ADDR_VAR 0 3
59133: PUSH
59134: LD_VAR 0 2
59138: PPUSH
59139: LD_INT 81
59141: PUSH
59142: LD_VAR 0 1
59146: PUSH
59147: EMPTY
59148: LIST
59149: LIST
59150: PPUSH
59151: CALL_OW 70
59155: ST_TO_ADDR
// end ;
59156: LD_VAR 0 3
59160: RET
// export function IsExtension ( b ) ; begin
59161: LD_INT 0
59163: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59164: LD_ADDR_VAR 0 2
59168: PUSH
59169: LD_VAR 0 1
59173: PUSH
59174: LD_INT 23
59176: PUSH
59177: LD_INT 20
59179: PUSH
59180: LD_INT 22
59182: PUSH
59183: LD_INT 17
59185: PUSH
59186: LD_INT 24
59188: PUSH
59189: LD_INT 21
59191: PUSH
59192: LD_INT 19
59194: PUSH
59195: LD_INT 16
59197: PUSH
59198: LD_INT 25
59200: PUSH
59201: LD_INT 18
59203: PUSH
59204: EMPTY
59205: LIST
59206: LIST
59207: LIST
59208: LIST
59209: LIST
59210: LIST
59211: LIST
59212: LIST
59213: LIST
59214: LIST
59215: IN
59216: ST_TO_ADDR
// end ;
59217: LD_VAR 0 2
59221: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59222: LD_INT 0
59224: PPUSH
59225: PPUSH
59226: PPUSH
// result := [ ] ;
59227: LD_ADDR_VAR 0 4
59231: PUSH
59232: EMPTY
59233: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59234: LD_ADDR_VAR 0 5
59238: PUSH
59239: LD_VAR 0 2
59243: PPUSH
59244: LD_INT 21
59246: PUSH
59247: LD_INT 3
59249: PUSH
59250: EMPTY
59251: LIST
59252: LIST
59253: PPUSH
59254: CALL_OW 70
59258: ST_TO_ADDR
// if not tmp then
59259: LD_VAR 0 5
59263: NOT
59264: IFFALSE 59268
// exit ;
59266: GO 59332
// if checkLink then
59268: LD_VAR 0 3
59272: IFFALSE 59322
// begin for i in tmp do
59274: LD_ADDR_VAR 0 6
59278: PUSH
59279: LD_VAR 0 5
59283: PUSH
59284: FOR_IN
59285: IFFALSE 59320
// if GetBase ( i ) <> base then
59287: LD_VAR 0 6
59291: PPUSH
59292: CALL_OW 274
59296: PUSH
59297: LD_VAR 0 1
59301: NONEQUAL
59302: IFFALSE 59318
// ComLinkToBase ( base , i ) ;
59304: LD_VAR 0 1
59308: PPUSH
59309: LD_VAR 0 6
59313: PPUSH
59314: CALL_OW 169
59318: GO 59284
59320: POP
59321: POP
// end ; result := tmp ;
59322: LD_ADDR_VAR 0 4
59326: PUSH
59327: LD_VAR 0 5
59331: ST_TO_ADDR
// end ;
59332: LD_VAR 0 4
59336: RET
// export function ComComplete ( units , b ) ; var i ; begin
59337: LD_INT 0
59339: PPUSH
59340: PPUSH
// if not units then
59341: LD_VAR 0 1
59345: NOT
59346: IFFALSE 59350
// exit ;
59348: GO 59440
// for i in units do
59350: LD_ADDR_VAR 0 4
59354: PUSH
59355: LD_VAR 0 1
59359: PUSH
59360: FOR_IN
59361: IFFALSE 59438
// if BuildingStatus ( b ) = bs_build then
59363: LD_VAR 0 2
59367: PPUSH
59368: CALL_OW 461
59372: PUSH
59373: LD_INT 1
59375: EQUAL
59376: IFFALSE 59436
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59378: LD_VAR 0 4
59382: PPUSH
59383: LD_STRING h
59385: PUSH
59386: LD_VAR 0 2
59390: PPUSH
59391: CALL_OW 250
59395: PUSH
59396: LD_VAR 0 2
59400: PPUSH
59401: CALL_OW 251
59405: PUSH
59406: LD_VAR 0 2
59410: PUSH
59411: LD_INT 0
59413: PUSH
59414: LD_INT 0
59416: PUSH
59417: LD_INT 0
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: LIST
59424: LIST
59425: LIST
59426: LIST
59427: LIST
59428: PUSH
59429: EMPTY
59430: LIST
59431: PPUSH
59432: CALL_OW 446
59436: GO 59360
59438: POP
59439: POP
// end ;
59440: LD_VAR 0 3
59444: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59445: LD_INT 0
59447: PPUSH
59448: PPUSH
59449: PPUSH
59450: PPUSH
59451: PPUSH
59452: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59453: LD_VAR 0 1
59457: NOT
59458: PUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: CALL_OW 263
59468: PUSH
59469: LD_INT 2
59471: NONEQUAL
59472: OR
59473: IFFALSE 59477
// exit ;
59475: GO 59793
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59477: LD_ADDR_VAR 0 6
59481: PUSH
59482: LD_INT 22
59484: PUSH
59485: LD_VAR 0 1
59489: PPUSH
59490: CALL_OW 255
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: LD_INT 2
59501: PUSH
59502: LD_INT 30
59504: PUSH
59505: LD_INT 36
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: PUSH
59512: LD_INT 34
59514: PUSH
59515: LD_INT 31
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: LIST
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PPUSH
59531: CALL_OW 69
59535: ST_TO_ADDR
// if not tmp then
59536: LD_VAR 0 6
59540: NOT
59541: IFFALSE 59545
// exit ;
59543: GO 59793
// result := [ ] ;
59545: LD_ADDR_VAR 0 2
59549: PUSH
59550: EMPTY
59551: ST_TO_ADDR
// for i in tmp do
59552: LD_ADDR_VAR 0 3
59556: PUSH
59557: LD_VAR 0 6
59561: PUSH
59562: FOR_IN
59563: IFFALSE 59634
// begin t := UnitsInside ( i ) ;
59565: LD_ADDR_VAR 0 4
59569: PUSH
59570: LD_VAR 0 3
59574: PPUSH
59575: CALL_OW 313
59579: ST_TO_ADDR
// if t then
59580: LD_VAR 0 4
59584: IFFALSE 59632
// for j in t do
59586: LD_ADDR_VAR 0 7
59590: PUSH
59591: LD_VAR 0 4
59595: PUSH
59596: FOR_IN
59597: IFFALSE 59630
// result := Replace ( result , result + 1 , j ) ;
59599: LD_ADDR_VAR 0 2
59603: PUSH
59604: LD_VAR 0 2
59608: PPUSH
59609: LD_VAR 0 2
59613: PUSH
59614: LD_INT 1
59616: PLUS
59617: PPUSH
59618: LD_VAR 0 7
59622: PPUSH
59623: CALL_OW 1
59627: ST_TO_ADDR
59628: GO 59596
59630: POP
59631: POP
// end ;
59632: GO 59562
59634: POP
59635: POP
// if not result then
59636: LD_VAR 0 2
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 59793
// mech := result [ 1 ] ;
59645: LD_ADDR_VAR 0 5
59649: PUSH
59650: LD_VAR 0 2
59654: PUSH
59655: LD_INT 1
59657: ARRAY
59658: ST_TO_ADDR
// if result > 1 then
59659: LD_VAR 0 2
59663: PUSH
59664: LD_INT 1
59666: GREATER
59667: IFFALSE 59779
// begin for i = 2 to result do
59669: LD_ADDR_VAR 0 3
59673: PUSH
59674: DOUBLE
59675: LD_INT 2
59677: DEC
59678: ST_TO_ADDR
59679: LD_VAR 0 2
59683: PUSH
59684: FOR_TO
59685: IFFALSE 59777
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59687: LD_ADDR_VAR 0 4
59691: PUSH
59692: LD_VAR 0 2
59696: PUSH
59697: LD_VAR 0 3
59701: ARRAY
59702: PPUSH
59703: LD_INT 3
59705: PPUSH
59706: CALL_OW 259
59710: PUSH
59711: LD_VAR 0 2
59715: PUSH
59716: LD_VAR 0 3
59720: ARRAY
59721: PPUSH
59722: CALL_OW 432
59726: MINUS
59727: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59728: LD_VAR 0 4
59732: PUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: LD_INT 3
59740: PPUSH
59741: CALL_OW 259
59745: PUSH
59746: LD_VAR 0 5
59750: PPUSH
59751: CALL_OW 432
59755: MINUS
59756: GREATEREQUAL
59757: IFFALSE 59775
// mech := result [ i ] ;
59759: LD_ADDR_VAR 0 5
59763: PUSH
59764: LD_VAR 0 2
59768: PUSH
59769: LD_VAR 0 3
59773: ARRAY
59774: ST_TO_ADDR
// end ;
59775: GO 59684
59777: POP
59778: POP
// end ; ComLinkTo ( vehicle , mech ) ;
59779: LD_VAR 0 1
59783: PPUSH
59784: LD_VAR 0 5
59788: PPUSH
59789: CALL_OW 135
// end ;
59793: LD_VAR 0 2
59797: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59798: LD_INT 0
59800: PPUSH
59801: PPUSH
59802: PPUSH
59803: PPUSH
59804: PPUSH
59805: PPUSH
59806: PPUSH
59807: PPUSH
59808: PPUSH
59809: PPUSH
59810: PPUSH
59811: PPUSH
59812: PPUSH
// result := [ ] ;
59813: LD_ADDR_VAR 0 7
59817: PUSH
59818: EMPTY
59819: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59820: LD_VAR 0 1
59824: PPUSH
59825: CALL_OW 266
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: LD_INT 1
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: IN
59840: NOT
59841: IFFALSE 59845
// exit ;
59843: GO 61479
// if name then
59845: LD_VAR 0 3
59849: IFFALSE 59865
// SetBName ( base_dep , name ) ;
59851: LD_VAR 0 1
59855: PPUSH
59856: LD_VAR 0 3
59860: PPUSH
59861: CALL_OW 500
// base := GetBase ( base_dep ) ;
59865: LD_ADDR_VAR 0 15
59869: PUSH
59870: LD_VAR 0 1
59874: PPUSH
59875: CALL_OW 274
59879: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59880: LD_ADDR_VAR 0 16
59884: PUSH
59885: LD_VAR 0 1
59889: PPUSH
59890: CALL_OW 255
59894: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59895: LD_ADDR_VAR 0 17
59899: PUSH
59900: LD_VAR 0 1
59904: PPUSH
59905: CALL_OW 248
59909: ST_TO_ADDR
// if sources then
59910: LD_VAR 0 5
59914: IFFALSE 59961
// for i = 1 to 3 do
59916: LD_ADDR_VAR 0 8
59920: PUSH
59921: DOUBLE
59922: LD_INT 1
59924: DEC
59925: ST_TO_ADDR
59926: LD_INT 3
59928: PUSH
59929: FOR_TO
59930: IFFALSE 59959
// AddResourceType ( base , i , sources [ i ] ) ;
59932: LD_VAR 0 15
59936: PPUSH
59937: LD_VAR 0 8
59941: PPUSH
59942: LD_VAR 0 5
59946: PUSH
59947: LD_VAR 0 8
59951: ARRAY
59952: PPUSH
59953: CALL_OW 276
59957: GO 59929
59959: POP
59960: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59961: LD_ADDR_VAR 0 18
59965: PUSH
59966: LD_VAR 0 15
59970: PPUSH
59971: LD_VAR 0 2
59975: PPUSH
59976: LD_INT 1
59978: PPUSH
59979: CALL 59222 0 3
59983: ST_TO_ADDR
// InitHc ;
59984: CALL_OW 19
// InitUc ;
59988: CALL_OW 18
// uc_side := side ;
59992: LD_ADDR_OWVAR 20
59996: PUSH
59997: LD_VAR 0 16
60001: ST_TO_ADDR
// uc_nation := nation ;
60002: LD_ADDR_OWVAR 21
60006: PUSH
60007: LD_VAR 0 17
60011: ST_TO_ADDR
// if buildings then
60012: LD_VAR 0 18
60016: IFFALSE 61338
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60018: LD_ADDR_VAR 0 19
60022: PUSH
60023: LD_VAR 0 18
60027: PPUSH
60028: LD_INT 2
60030: PUSH
60031: LD_INT 30
60033: PUSH
60034: LD_INT 29
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: LD_INT 30
60043: PUSH
60044: LD_INT 30
60046: PUSH
60047: EMPTY
60048: LIST
60049: LIST
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: PPUSH
60056: CALL_OW 72
60060: ST_TO_ADDR
// if tmp then
60061: LD_VAR 0 19
60065: IFFALSE 60113
// for i in tmp do
60067: LD_ADDR_VAR 0 8
60071: PUSH
60072: LD_VAR 0 19
60076: PUSH
60077: FOR_IN
60078: IFFALSE 60111
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60080: LD_VAR 0 8
60084: PPUSH
60085: CALL_OW 250
60089: PPUSH
60090: LD_VAR 0 8
60094: PPUSH
60095: CALL_OW 251
60099: PPUSH
60100: LD_VAR 0 16
60104: PPUSH
60105: CALL_OW 441
60109: GO 60077
60111: POP
60112: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60113: LD_VAR 0 18
60117: PPUSH
60118: LD_INT 2
60120: PUSH
60121: LD_INT 30
60123: PUSH
60124: LD_INT 32
60126: PUSH
60127: EMPTY
60128: LIST
60129: LIST
60130: PUSH
60131: LD_INT 30
60133: PUSH
60134: LD_INT 33
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: PUSH
60141: EMPTY
60142: LIST
60143: LIST
60144: LIST
60145: PPUSH
60146: CALL_OW 72
60150: IFFALSE 60238
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60152: LD_ADDR_VAR 0 8
60156: PUSH
60157: LD_VAR 0 18
60161: PPUSH
60162: LD_INT 2
60164: PUSH
60165: LD_INT 30
60167: PUSH
60168: LD_INT 32
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: PUSH
60175: LD_INT 30
60177: PUSH
60178: LD_INT 33
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: LIST
60189: PPUSH
60190: CALL_OW 72
60194: PUSH
60195: FOR_IN
60196: IFFALSE 60236
// begin if not GetBWeapon ( i ) then
60198: LD_VAR 0 8
60202: PPUSH
60203: CALL_OW 269
60207: NOT
60208: IFFALSE 60234
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60210: LD_VAR 0 8
60214: PPUSH
60215: LD_VAR 0 8
60219: PPUSH
60220: LD_VAR 0 2
60224: PPUSH
60225: CALL 61484 0 2
60229: PPUSH
60230: CALL_OW 431
// end ;
60234: GO 60195
60236: POP
60237: POP
// end ; for i = 1 to personel do
60238: LD_ADDR_VAR 0 8
60242: PUSH
60243: DOUBLE
60244: LD_INT 1
60246: DEC
60247: ST_TO_ADDR
60248: LD_VAR 0 6
60252: PUSH
60253: FOR_TO
60254: IFFALSE 61318
// begin if i > 4 then
60256: LD_VAR 0 8
60260: PUSH
60261: LD_INT 4
60263: GREATER
60264: IFFALSE 60268
// break ;
60266: GO 61318
// case i of 1 :
60268: LD_VAR 0 8
60272: PUSH
60273: LD_INT 1
60275: DOUBLE
60276: EQUAL
60277: IFTRUE 60281
60279: GO 60361
60281: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60282: LD_ADDR_VAR 0 12
60286: PUSH
60287: LD_VAR 0 18
60291: PPUSH
60292: LD_INT 22
60294: PUSH
60295: LD_VAR 0 16
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: LD_INT 58
60306: PUSH
60307: EMPTY
60308: LIST
60309: PUSH
60310: LD_INT 2
60312: PUSH
60313: LD_INT 30
60315: PUSH
60316: LD_INT 32
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: PUSH
60323: LD_INT 30
60325: PUSH
60326: LD_INT 4
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PUSH
60333: LD_INT 30
60335: PUSH
60336: LD_INT 5
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: LIST
60347: LIST
60348: PUSH
60349: EMPTY
60350: LIST
60351: LIST
60352: LIST
60353: PPUSH
60354: CALL_OW 72
60358: ST_TO_ADDR
60359: GO 60583
60361: LD_INT 2
60363: DOUBLE
60364: EQUAL
60365: IFTRUE 60369
60367: GO 60431
60369: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60370: LD_ADDR_VAR 0 12
60374: PUSH
60375: LD_VAR 0 18
60379: PPUSH
60380: LD_INT 22
60382: PUSH
60383: LD_VAR 0 16
60387: PUSH
60388: EMPTY
60389: LIST
60390: LIST
60391: PUSH
60392: LD_INT 2
60394: PUSH
60395: LD_INT 30
60397: PUSH
60398: LD_INT 0
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: PUSH
60405: LD_INT 30
60407: PUSH
60408: LD_INT 1
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: EMPTY
60416: LIST
60417: LIST
60418: LIST
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PPUSH
60424: CALL_OW 72
60428: ST_TO_ADDR
60429: GO 60583
60431: LD_INT 3
60433: DOUBLE
60434: EQUAL
60435: IFTRUE 60439
60437: GO 60501
60439: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60440: LD_ADDR_VAR 0 12
60444: PUSH
60445: LD_VAR 0 18
60449: PPUSH
60450: LD_INT 22
60452: PUSH
60453: LD_VAR 0 16
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: LD_INT 2
60464: PUSH
60465: LD_INT 30
60467: PUSH
60468: LD_INT 2
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: PUSH
60475: LD_INT 30
60477: PUSH
60478: LD_INT 3
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: LIST
60489: PUSH
60490: EMPTY
60491: LIST
60492: LIST
60493: PPUSH
60494: CALL_OW 72
60498: ST_TO_ADDR
60499: GO 60583
60501: LD_INT 4
60503: DOUBLE
60504: EQUAL
60505: IFTRUE 60509
60507: GO 60582
60509: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60510: LD_ADDR_VAR 0 12
60514: PUSH
60515: LD_VAR 0 18
60519: PPUSH
60520: LD_INT 22
60522: PUSH
60523: LD_VAR 0 16
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PUSH
60532: LD_INT 2
60534: PUSH
60535: LD_INT 30
60537: PUSH
60538: LD_INT 6
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: LD_INT 30
60547: PUSH
60548: LD_INT 7
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: PUSH
60555: LD_INT 30
60557: PUSH
60558: LD_INT 8
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: LIST
60569: LIST
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: PPUSH
60575: CALL_OW 72
60579: ST_TO_ADDR
60580: GO 60583
60582: POP
// if i = 1 then
60583: LD_VAR 0 8
60587: PUSH
60588: LD_INT 1
60590: EQUAL
60591: IFFALSE 60702
// begin tmp := [ ] ;
60593: LD_ADDR_VAR 0 19
60597: PUSH
60598: EMPTY
60599: ST_TO_ADDR
// for j in f do
60600: LD_ADDR_VAR 0 9
60604: PUSH
60605: LD_VAR 0 12
60609: PUSH
60610: FOR_IN
60611: IFFALSE 60684
// if GetBType ( j ) = b_bunker then
60613: LD_VAR 0 9
60617: PPUSH
60618: CALL_OW 266
60622: PUSH
60623: LD_INT 32
60625: EQUAL
60626: IFFALSE 60653
// tmp := Insert ( tmp , 1 , j ) else
60628: LD_ADDR_VAR 0 19
60632: PUSH
60633: LD_VAR 0 19
60637: PPUSH
60638: LD_INT 1
60640: PPUSH
60641: LD_VAR 0 9
60645: PPUSH
60646: CALL_OW 2
60650: ST_TO_ADDR
60651: GO 60682
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60653: LD_ADDR_VAR 0 19
60657: PUSH
60658: LD_VAR 0 19
60662: PPUSH
60663: LD_VAR 0 19
60667: PUSH
60668: LD_INT 1
60670: PLUS
60671: PPUSH
60672: LD_VAR 0 9
60676: PPUSH
60677: CALL_OW 2
60681: ST_TO_ADDR
60682: GO 60610
60684: POP
60685: POP
// if tmp then
60686: LD_VAR 0 19
60690: IFFALSE 60702
// f := tmp ;
60692: LD_ADDR_VAR 0 12
60696: PUSH
60697: LD_VAR 0 19
60701: ST_TO_ADDR
// end ; x := personel [ i ] ;
60702: LD_ADDR_VAR 0 13
60706: PUSH
60707: LD_VAR 0 6
60711: PUSH
60712: LD_VAR 0 8
60716: ARRAY
60717: ST_TO_ADDR
// if x = - 1 then
60718: LD_VAR 0 13
60722: PUSH
60723: LD_INT 1
60725: NEG
60726: EQUAL
60727: IFFALSE 60936
// begin for j in f do
60729: LD_ADDR_VAR 0 9
60733: PUSH
60734: LD_VAR 0 12
60738: PUSH
60739: FOR_IN
60740: IFFALSE 60932
// repeat InitHc ;
60742: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60746: LD_VAR 0 9
60750: PPUSH
60751: CALL_OW 266
60755: PUSH
60756: LD_INT 5
60758: EQUAL
60759: IFFALSE 60829
// begin if UnitsInside ( j ) < 3 then
60761: LD_VAR 0 9
60765: PPUSH
60766: CALL_OW 313
60770: PUSH
60771: LD_INT 3
60773: LESS
60774: IFFALSE 60810
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60776: LD_INT 0
60778: PPUSH
60779: LD_INT 5
60781: PUSH
60782: LD_INT 8
60784: PUSH
60785: LD_INT 9
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: PUSH
60793: LD_VAR 0 17
60797: ARRAY
60798: PPUSH
60799: LD_VAR 0 4
60803: PPUSH
60804: CALL_OW 380
60808: GO 60827
// PrepareHuman ( false , i , skill ) ;
60810: LD_INT 0
60812: PPUSH
60813: LD_VAR 0 8
60817: PPUSH
60818: LD_VAR 0 4
60822: PPUSH
60823: CALL_OW 380
// end else
60827: GO 60846
// PrepareHuman ( false , i , skill ) ;
60829: LD_INT 0
60831: PPUSH
60832: LD_VAR 0 8
60836: PPUSH
60837: LD_VAR 0 4
60841: PPUSH
60842: CALL_OW 380
// un := CreateHuman ;
60846: LD_ADDR_VAR 0 14
60850: PUSH
60851: CALL_OW 44
60855: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60856: LD_ADDR_VAR 0 7
60860: PUSH
60861: LD_VAR 0 7
60865: PPUSH
60866: LD_INT 1
60868: PPUSH
60869: LD_VAR 0 14
60873: PPUSH
60874: CALL_OW 2
60878: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60879: LD_VAR 0 14
60883: PPUSH
60884: LD_VAR 0 9
60888: PPUSH
60889: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60893: LD_VAR 0 9
60897: PPUSH
60898: CALL_OW 313
60902: PUSH
60903: LD_INT 6
60905: EQUAL
60906: PUSH
60907: LD_VAR 0 9
60911: PPUSH
60912: CALL_OW 266
60916: PUSH
60917: LD_INT 32
60919: PUSH
60920: LD_INT 31
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: IN
60927: OR
60928: IFFALSE 60742
60930: GO 60739
60932: POP
60933: POP
// end else
60934: GO 61316
// for j = 1 to x do
60936: LD_ADDR_VAR 0 9
60940: PUSH
60941: DOUBLE
60942: LD_INT 1
60944: DEC
60945: ST_TO_ADDR
60946: LD_VAR 0 13
60950: PUSH
60951: FOR_TO
60952: IFFALSE 61314
// begin InitHc ;
60954: CALL_OW 19
// if not f then
60958: LD_VAR 0 12
60962: NOT
60963: IFFALSE 61052
// begin PrepareHuman ( false , i , skill ) ;
60965: LD_INT 0
60967: PPUSH
60968: LD_VAR 0 8
60972: PPUSH
60973: LD_VAR 0 4
60977: PPUSH
60978: CALL_OW 380
// un := CreateHuman ;
60982: LD_ADDR_VAR 0 14
60986: PUSH
60987: CALL_OW 44
60991: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60992: LD_ADDR_VAR 0 7
60996: PUSH
60997: LD_VAR 0 7
61001: PPUSH
61002: LD_INT 1
61004: PPUSH
61005: LD_VAR 0 14
61009: PPUSH
61010: CALL_OW 2
61014: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61015: LD_VAR 0 14
61019: PPUSH
61020: LD_VAR 0 1
61024: PPUSH
61025: CALL_OW 250
61029: PPUSH
61030: LD_VAR 0 1
61034: PPUSH
61035: CALL_OW 251
61039: PPUSH
61040: LD_INT 10
61042: PPUSH
61043: LD_INT 0
61045: PPUSH
61046: CALL_OW 50
// continue ;
61050: GO 60951
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61052: LD_VAR 0 12
61056: PUSH
61057: LD_INT 1
61059: ARRAY
61060: PPUSH
61061: CALL_OW 313
61065: PUSH
61066: LD_VAR 0 12
61070: PUSH
61071: LD_INT 1
61073: ARRAY
61074: PPUSH
61075: CALL_OW 266
61079: PUSH
61080: LD_INT 32
61082: PUSH
61083: LD_INT 31
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: IN
61090: AND
61091: PUSH
61092: LD_VAR 0 12
61096: PUSH
61097: LD_INT 1
61099: ARRAY
61100: PPUSH
61101: CALL_OW 313
61105: PUSH
61106: LD_INT 6
61108: EQUAL
61109: OR
61110: IFFALSE 61130
// f := Delete ( f , 1 ) ;
61112: LD_ADDR_VAR 0 12
61116: PUSH
61117: LD_VAR 0 12
61121: PPUSH
61122: LD_INT 1
61124: PPUSH
61125: CALL_OW 3
61129: ST_TO_ADDR
// if not f then
61130: LD_VAR 0 12
61134: NOT
61135: IFFALSE 61153
// begin x := x + 2 ;
61137: LD_ADDR_VAR 0 13
61141: PUSH
61142: LD_VAR 0 13
61146: PUSH
61147: LD_INT 2
61149: PLUS
61150: ST_TO_ADDR
// continue ;
61151: GO 60951
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61153: LD_VAR 0 12
61157: PUSH
61158: LD_INT 1
61160: ARRAY
61161: PPUSH
61162: CALL_OW 266
61166: PUSH
61167: LD_INT 5
61169: EQUAL
61170: IFFALSE 61244
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61172: LD_VAR 0 12
61176: PUSH
61177: LD_INT 1
61179: ARRAY
61180: PPUSH
61181: CALL_OW 313
61185: PUSH
61186: LD_INT 3
61188: LESS
61189: IFFALSE 61225
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61191: LD_INT 0
61193: PPUSH
61194: LD_INT 5
61196: PUSH
61197: LD_INT 8
61199: PUSH
61200: LD_INT 9
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: LIST
61207: PUSH
61208: LD_VAR 0 17
61212: ARRAY
61213: PPUSH
61214: LD_VAR 0 4
61218: PPUSH
61219: CALL_OW 380
61223: GO 61242
// PrepareHuman ( false , i , skill ) ;
61225: LD_INT 0
61227: PPUSH
61228: LD_VAR 0 8
61232: PPUSH
61233: LD_VAR 0 4
61237: PPUSH
61238: CALL_OW 380
// end else
61242: GO 61261
// PrepareHuman ( false , i , skill ) ;
61244: LD_INT 0
61246: PPUSH
61247: LD_VAR 0 8
61251: PPUSH
61252: LD_VAR 0 4
61256: PPUSH
61257: CALL_OW 380
// un := CreateHuman ;
61261: LD_ADDR_VAR 0 14
61265: PUSH
61266: CALL_OW 44
61270: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61271: LD_ADDR_VAR 0 7
61275: PUSH
61276: LD_VAR 0 7
61280: PPUSH
61281: LD_INT 1
61283: PPUSH
61284: LD_VAR 0 14
61288: PPUSH
61289: CALL_OW 2
61293: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61294: LD_VAR 0 14
61298: PPUSH
61299: LD_VAR 0 12
61303: PUSH
61304: LD_INT 1
61306: ARRAY
61307: PPUSH
61308: CALL_OW 52
// end ;
61312: GO 60951
61314: POP
61315: POP
// end ;
61316: GO 60253
61318: POP
61319: POP
// result := result ^ buildings ;
61320: LD_ADDR_VAR 0 7
61324: PUSH
61325: LD_VAR 0 7
61329: PUSH
61330: LD_VAR 0 18
61334: ADD
61335: ST_TO_ADDR
// end else
61336: GO 61479
// begin for i = 1 to personel do
61338: LD_ADDR_VAR 0 8
61342: PUSH
61343: DOUBLE
61344: LD_INT 1
61346: DEC
61347: ST_TO_ADDR
61348: LD_VAR 0 6
61352: PUSH
61353: FOR_TO
61354: IFFALSE 61477
// begin if i > 4 then
61356: LD_VAR 0 8
61360: PUSH
61361: LD_INT 4
61363: GREATER
61364: IFFALSE 61368
// break ;
61366: GO 61477
// x := personel [ i ] ;
61368: LD_ADDR_VAR 0 13
61372: PUSH
61373: LD_VAR 0 6
61377: PUSH
61378: LD_VAR 0 8
61382: ARRAY
61383: ST_TO_ADDR
// if x = - 1 then
61384: LD_VAR 0 13
61388: PUSH
61389: LD_INT 1
61391: NEG
61392: EQUAL
61393: IFFALSE 61397
// continue ;
61395: GO 61353
// PrepareHuman ( false , i , skill ) ;
61397: LD_INT 0
61399: PPUSH
61400: LD_VAR 0 8
61404: PPUSH
61405: LD_VAR 0 4
61409: PPUSH
61410: CALL_OW 380
// un := CreateHuman ;
61414: LD_ADDR_VAR 0 14
61418: PUSH
61419: CALL_OW 44
61423: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61424: LD_VAR 0 14
61428: PPUSH
61429: LD_VAR 0 1
61433: PPUSH
61434: CALL_OW 250
61438: PPUSH
61439: LD_VAR 0 1
61443: PPUSH
61444: CALL_OW 251
61448: PPUSH
61449: LD_INT 10
61451: PPUSH
61452: LD_INT 0
61454: PPUSH
61455: CALL_OW 50
// result := result ^ un ;
61459: LD_ADDR_VAR 0 7
61463: PUSH
61464: LD_VAR 0 7
61468: PUSH
61469: LD_VAR 0 14
61473: ADD
61474: ST_TO_ADDR
// end ;
61475: GO 61353
61477: POP
61478: POP
// end ; end ;
61479: LD_VAR 0 7
61483: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61484: LD_INT 0
61486: PPUSH
61487: PPUSH
61488: PPUSH
61489: PPUSH
61490: PPUSH
61491: PPUSH
61492: PPUSH
61493: PPUSH
61494: PPUSH
61495: PPUSH
61496: PPUSH
61497: PPUSH
61498: PPUSH
61499: PPUSH
61500: PPUSH
61501: PPUSH
// result := false ;
61502: LD_ADDR_VAR 0 3
61506: PUSH
61507: LD_INT 0
61509: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61510: LD_VAR 0 1
61514: NOT
61515: PUSH
61516: LD_VAR 0 1
61520: PPUSH
61521: CALL_OW 266
61525: PUSH
61526: LD_INT 32
61528: PUSH
61529: LD_INT 33
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: IN
61536: NOT
61537: OR
61538: IFFALSE 61542
// exit ;
61540: GO 62651
// nat := GetNation ( tower ) ;
61542: LD_ADDR_VAR 0 12
61546: PUSH
61547: LD_VAR 0 1
61551: PPUSH
61552: CALL_OW 248
61556: ST_TO_ADDR
// side := GetSide ( tower ) ;
61557: LD_ADDR_VAR 0 16
61561: PUSH
61562: LD_VAR 0 1
61566: PPUSH
61567: CALL_OW 255
61571: ST_TO_ADDR
// x := GetX ( tower ) ;
61572: LD_ADDR_VAR 0 10
61576: PUSH
61577: LD_VAR 0 1
61581: PPUSH
61582: CALL_OW 250
61586: ST_TO_ADDR
// y := GetY ( tower ) ;
61587: LD_ADDR_VAR 0 11
61591: PUSH
61592: LD_VAR 0 1
61596: PPUSH
61597: CALL_OW 251
61601: ST_TO_ADDR
// if not x or not y then
61602: LD_VAR 0 10
61606: NOT
61607: PUSH
61608: LD_VAR 0 11
61612: NOT
61613: OR
61614: IFFALSE 61618
// exit ;
61616: GO 62651
// weapon := 0 ;
61618: LD_ADDR_VAR 0 18
61622: PUSH
61623: LD_INT 0
61625: ST_TO_ADDR
// fac_list := [ ] ;
61626: LD_ADDR_VAR 0 17
61630: PUSH
61631: EMPTY
61632: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61633: LD_ADDR_VAR 0 6
61637: PUSH
61638: LD_VAR 0 1
61642: PPUSH
61643: CALL_OW 274
61647: PPUSH
61648: LD_VAR 0 2
61652: PPUSH
61653: LD_INT 0
61655: PPUSH
61656: CALL 59222 0 3
61660: PPUSH
61661: LD_INT 30
61663: PUSH
61664: LD_INT 3
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PPUSH
61671: CALL_OW 72
61675: ST_TO_ADDR
// if not factories then
61676: LD_VAR 0 6
61680: NOT
61681: IFFALSE 61685
// exit ;
61683: GO 62651
// for i in factories do
61685: LD_ADDR_VAR 0 8
61689: PUSH
61690: LD_VAR 0 6
61694: PUSH
61695: FOR_IN
61696: IFFALSE 61721
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61698: LD_ADDR_VAR 0 17
61702: PUSH
61703: LD_VAR 0 17
61707: PUSH
61708: LD_VAR 0 8
61712: PPUSH
61713: CALL_OW 478
61717: UNION
61718: ST_TO_ADDR
61719: GO 61695
61721: POP
61722: POP
// if not fac_list then
61723: LD_VAR 0 17
61727: NOT
61728: IFFALSE 61732
// exit ;
61730: GO 62651
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61732: LD_ADDR_VAR 0 5
61736: PUSH
61737: LD_INT 4
61739: PUSH
61740: LD_INT 5
61742: PUSH
61743: LD_INT 9
61745: PUSH
61746: LD_INT 10
61748: PUSH
61749: LD_INT 6
61751: PUSH
61752: LD_INT 7
61754: PUSH
61755: LD_INT 11
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: PUSH
61767: LD_INT 27
61769: PUSH
61770: LD_INT 28
61772: PUSH
61773: LD_INT 26
61775: PUSH
61776: LD_INT 30
61778: PUSH
61779: EMPTY
61780: LIST
61781: LIST
61782: LIST
61783: LIST
61784: PUSH
61785: LD_INT 43
61787: PUSH
61788: LD_INT 44
61790: PUSH
61791: LD_INT 46
61793: PUSH
61794: LD_INT 45
61796: PUSH
61797: LD_INT 47
61799: PUSH
61800: LD_INT 49
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: LIST
61807: LIST
61808: LIST
61809: LIST
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: LIST
61815: PUSH
61816: LD_VAR 0 12
61820: ARRAY
61821: ST_TO_ADDR
// list := list isect fac_list ;
61822: LD_ADDR_VAR 0 5
61826: PUSH
61827: LD_VAR 0 5
61831: PUSH
61832: LD_VAR 0 17
61836: ISECT
61837: ST_TO_ADDR
// if not list then
61838: LD_VAR 0 5
61842: NOT
61843: IFFALSE 61847
// exit ;
61845: GO 62651
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61847: LD_VAR 0 12
61851: PUSH
61852: LD_INT 3
61854: EQUAL
61855: PUSH
61856: LD_INT 49
61858: PUSH
61859: LD_VAR 0 5
61863: IN
61864: AND
61865: PUSH
61866: LD_INT 31
61868: PPUSH
61869: LD_VAR 0 16
61873: PPUSH
61874: CALL_OW 321
61878: PUSH
61879: LD_INT 2
61881: EQUAL
61882: AND
61883: IFFALSE 61943
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61885: LD_INT 22
61887: PUSH
61888: LD_VAR 0 16
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 35
61899: PUSH
61900: LD_INT 49
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: PUSH
61907: LD_INT 91
61909: PUSH
61910: LD_VAR 0 1
61914: PUSH
61915: LD_INT 10
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: LIST
61922: PUSH
61923: EMPTY
61924: LIST
61925: LIST
61926: LIST
61927: PPUSH
61928: CALL_OW 69
61932: NOT
61933: IFFALSE 61943
// weapon := ru_time_lapser ;
61935: LD_ADDR_VAR 0 18
61939: PUSH
61940: LD_INT 49
61942: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61943: LD_VAR 0 12
61947: PUSH
61948: LD_INT 1
61950: PUSH
61951: LD_INT 2
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: IN
61958: PUSH
61959: LD_INT 11
61961: PUSH
61962: LD_VAR 0 5
61966: IN
61967: PUSH
61968: LD_INT 30
61970: PUSH
61971: LD_VAR 0 5
61975: IN
61976: OR
61977: AND
61978: PUSH
61979: LD_INT 6
61981: PPUSH
61982: LD_VAR 0 16
61986: PPUSH
61987: CALL_OW 321
61991: PUSH
61992: LD_INT 2
61994: EQUAL
61995: AND
61996: IFFALSE 62161
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61998: LD_INT 22
62000: PUSH
62001: LD_VAR 0 16
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PUSH
62010: LD_INT 2
62012: PUSH
62013: LD_INT 35
62015: PUSH
62016: LD_INT 11
62018: PUSH
62019: EMPTY
62020: LIST
62021: LIST
62022: PUSH
62023: LD_INT 35
62025: PUSH
62026: LD_INT 30
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 91
62040: PUSH
62041: LD_VAR 0 1
62045: PUSH
62046: LD_INT 18
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: LIST
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: LIST
62058: PPUSH
62059: CALL_OW 69
62063: NOT
62064: PUSH
62065: LD_INT 22
62067: PUSH
62068: LD_VAR 0 16
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 2
62079: PUSH
62080: LD_INT 30
62082: PUSH
62083: LD_INT 32
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: PUSH
62090: LD_INT 30
62092: PUSH
62093: LD_INT 33
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PUSH
62100: EMPTY
62101: LIST
62102: LIST
62103: LIST
62104: PUSH
62105: LD_INT 91
62107: PUSH
62108: LD_VAR 0 1
62112: PUSH
62113: LD_INT 12
62115: PUSH
62116: EMPTY
62117: LIST
62118: LIST
62119: LIST
62120: PUSH
62121: EMPTY
62122: LIST
62123: LIST
62124: LIST
62125: PUSH
62126: EMPTY
62127: LIST
62128: PPUSH
62129: CALL_OW 69
62133: PUSH
62134: LD_INT 2
62136: GREATER
62137: AND
62138: IFFALSE 62161
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62140: LD_ADDR_VAR 0 18
62144: PUSH
62145: LD_INT 11
62147: PUSH
62148: LD_INT 30
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: LD_VAR 0 12
62159: ARRAY
62160: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62161: LD_VAR 0 18
62165: NOT
62166: PUSH
62167: LD_INT 40
62169: PPUSH
62170: LD_VAR 0 16
62174: PPUSH
62175: CALL_OW 321
62179: PUSH
62180: LD_INT 2
62182: EQUAL
62183: AND
62184: PUSH
62185: LD_INT 7
62187: PUSH
62188: LD_VAR 0 5
62192: IN
62193: PUSH
62194: LD_INT 28
62196: PUSH
62197: LD_VAR 0 5
62201: IN
62202: OR
62203: PUSH
62204: LD_INT 45
62206: PUSH
62207: LD_VAR 0 5
62211: IN
62212: OR
62213: AND
62214: IFFALSE 62468
// begin hex := GetHexInfo ( x , y ) ;
62216: LD_ADDR_VAR 0 4
62220: PUSH
62221: LD_VAR 0 10
62225: PPUSH
62226: LD_VAR 0 11
62230: PPUSH
62231: CALL_OW 546
62235: ST_TO_ADDR
// if hex [ 1 ] then
62236: LD_VAR 0 4
62240: PUSH
62241: LD_INT 1
62243: ARRAY
62244: IFFALSE 62248
// exit ;
62246: GO 62651
// height := hex [ 2 ] ;
62248: LD_ADDR_VAR 0 15
62252: PUSH
62253: LD_VAR 0 4
62257: PUSH
62258: LD_INT 2
62260: ARRAY
62261: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62262: LD_ADDR_VAR 0 14
62266: PUSH
62267: LD_INT 0
62269: PUSH
62270: LD_INT 2
62272: PUSH
62273: LD_INT 3
62275: PUSH
62276: LD_INT 5
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: ST_TO_ADDR
// for i in tmp do
62285: LD_ADDR_VAR 0 8
62289: PUSH
62290: LD_VAR 0 14
62294: PUSH
62295: FOR_IN
62296: IFFALSE 62466
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62298: LD_ADDR_VAR 0 9
62302: PUSH
62303: LD_VAR 0 10
62307: PPUSH
62308: LD_VAR 0 8
62312: PPUSH
62313: LD_INT 5
62315: PPUSH
62316: CALL_OW 272
62320: PUSH
62321: LD_VAR 0 11
62325: PPUSH
62326: LD_VAR 0 8
62330: PPUSH
62331: LD_INT 5
62333: PPUSH
62334: CALL_OW 273
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62343: LD_VAR 0 9
62347: PUSH
62348: LD_INT 1
62350: ARRAY
62351: PPUSH
62352: LD_VAR 0 9
62356: PUSH
62357: LD_INT 2
62359: ARRAY
62360: PPUSH
62361: CALL_OW 488
62365: IFFALSE 62464
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62367: LD_ADDR_VAR 0 4
62371: PUSH
62372: LD_VAR 0 9
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PPUSH
62381: LD_VAR 0 9
62385: PUSH
62386: LD_INT 2
62388: ARRAY
62389: PPUSH
62390: CALL_OW 546
62394: ST_TO_ADDR
// if hex [ 1 ] then
62395: LD_VAR 0 4
62399: PUSH
62400: LD_INT 1
62402: ARRAY
62403: IFFALSE 62407
// continue ;
62405: GO 62295
// h := hex [ 2 ] ;
62407: LD_ADDR_VAR 0 13
62411: PUSH
62412: LD_VAR 0 4
62416: PUSH
62417: LD_INT 2
62419: ARRAY
62420: ST_TO_ADDR
// if h + 7 < height then
62421: LD_VAR 0 13
62425: PUSH
62426: LD_INT 7
62428: PLUS
62429: PUSH
62430: LD_VAR 0 15
62434: LESS
62435: IFFALSE 62464
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62437: LD_ADDR_VAR 0 18
62441: PUSH
62442: LD_INT 7
62444: PUSH
62445: LD_INT 28
62447: PUSH
62448: LD_INT 45
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: LIST
62455: PUSH
62456: LD_VAR 0 12
62460: ARRAY
62461: ST_TO_ADDR
// break ;
62462: GO 62466
// end ; end ; end ;
62464: GO 62295
62466: POP
62467: POP
// end ; if not weapon then
62468: LD_VAR 0 18
62472: NOT
62473: IFFALSE 62533
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62475: LD_ADDR_VAR 0 5
62479: PUSH
62480: LD_VAR 0 5
62484: PUSH
62485: LD_INT 11
62487: PUSH
62488: LD_INT 30
62490: PUSH
62491: LD_INT 49
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: LIST
62498: DIFF
62499: ST_TO_ADDR
// if not list then
62500: LD_VAR 0 5
62504: NOT
62505: IFFALSE 62509
// exit ;
62507: GO 62651
// weapon := list [ rand ( 1 , list ) ] ;
62509: LD_ADDR_VAR 0 18
62513: PUSH
62514: LD_VAR 0 5
62518: PUSH
62519: LD_INT 1
62521: PPUSH
62522: LD_VAR 0 5
62526: PPUSH
62527: CALL_OW 12
62531: ARRAY
62532: ST_TO_ADDR
// end ; if weapon then
62533: LD_VAR 0 18
62537: IFFALSE 62651
// begin tmp := CostOfWeapon ( weapon ) ;
62539: LD_ADDR_VAR 0 14
62543: PUSH
62544: LD_VAR 0 18
62548: PPUSH
62549: CALL_OW 451
62553: ST_TO_ADDR
// j := GetBase ( tower ) ;
62554: LD_ADDR_VAR 0 9
62558: PUSH
62559: LD_VAR 0 1
62563: PPUSH
62564: CALL_OW 274
62568: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62569: LD_VAR 0 9
62573: PPUSH
62574: LD_INT 1
62576: PPUSH
62577: CALL_OW 275
62581: PUSH
62582: LD_VAR 0 14
62586: PUSH
62587: LD_INT 1
62589: ARRAY
62590: GREATEREQUAL
62591: PUSH
62592: LD_VAR 0 9
62596: PPUSH
62597: LD_INT 2
62599: PPUSH
62600: CALL_OW 275
62604: PUSH
62605: LD_VAR 0 14
62609: PUSH
62610: LD_INT 2
62612: ARRAY
62613: GREATEREQUAL
62614: AND
62615: PUSH
62616: LD_VAR 0 9
62620: PPUSH
62621: LD_INT 3
62623: PPUSH
62624: CALL_OW 275
62628: PUSH
62629: LD_VAR 0 14
62633: PUSH
62634: LD_INT 3
62636: ARRAY
62637: GREATEREQUAL
62638: AND
62639: IFFALSE 62651
// result := weapon ;
62641: LD_ADDR_VAR 0 3
62645: PUSH
62646: LD_VAR 0 18
62650: ST_TO_ADDR
// end ; end ;
62651: LD_VAR 0 3
62655: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62656: LD_INT 0
62658: PPUSH
62659: PPUSH
// result := true ;
62660: LD_ADDR_VAR 0 3
62664: PUSH
62665: LD_INT 1
62667: ST_TO_ADDR
// if array1 = array2 then
62668: LD_VAR 0 1
62672: PUSH
62673: LD_VAR 0 2
62677: EQUAL
62678: IFFALSE 62738
// begin for i = 1 to array1 do
62680: LD_ADDR_VAR 0 4
62684: PUSH
62685: DOUBLE
62686: LD_INT 1
62688: DEC
62689: ST_TO_ADDR
62690: LD_VAR 0 1
62694: PUSH
62695: FOR_TO
62696: IFFALSE 62734
// if array1 [ i ] <> array2 [ i ] then
62698: LD_VAR 0 1
62702: PUSH
62703: LD_VAR 0 4
62707: ARRAY
62708: PUSH
62709: LD_VAR 0 2
62713: PUSH
62714: LD_VAR 0 4
62718: ARRAY
62719: NONEQUAL
62720: IFFALSE 62732
// begin result := false ;
62722: LD_ADDR_VAR 0 3
62726: PUSH
62727: LD_INT 0
62729: ST_TO_ADDR
// break ;
62730: GO 62734
// end ;
62732: GO 62695
62734: POP
62735: POP
// end else
62736: GO 62746
// result := false ;
62738: LD_ADDR_VAR 0 3
62742: PUSH
62743: LD_INT 0
62745: ST_TO_ADDR
// end ;
62746: LD_VAR 0 3
62750: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62751: LD_INT 0
62753: PPUSH
62754: PPUSH
// if not array1 or not array2 then
62755: LD_VAR 0 1
62759: NOT
62760: PUSH
62761: LD_VAR 0 2
62765: NOT
62766: OR
62767: IFFALSE 62771
// exit ;
62769: GO 62835
// result := true ;
62771: LD_ADDR_VAR 0 3
62775: PUSH
62776: LD_INT 1
62778: ST_TO_ADDR
// for i = 1 to array1 do
62779: LD_ADDR_VAR 0 4
62783: PUSH
62784: DOUBLE
62785: LD_INT 1
62787: DEC
62788: ST_TO_ADDR
62789: LD_VAR 0 1
62793: PUSH
62794: FOR_TO
62795: IFFALSE 62833
// if array1 [ i ] <> array2 [ i ] then
62797: LD_VAR 0 1
62801: PUSH
62802: LD_VAR 0 4
62806: ARRAY
62807: PUSH
62808: LD_VAR 0 2
62812: PUSH
62813: LD_VAR 0 4
62817: ARRAY
62818: NONEQUAL
62819: IFFALSE 62831
// begin result := false ;
62821: LD_ADDR_VAR 0 3
62825: PUSH
62826: LD_INT 0
62828: ST_TO_ADDR
// break ;
62829: GO 62833
// end ;
62831: GO 62794
62833: POP
62834: POP
// end ;
62835: LD_VAR 0 3
62839: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62840: LD_INT 0
62842: PPUSH
62843: PPUSH
62844: PPUSH
// pom := GetBase ( fac ) ;
62845: LD_ADDR_VAR 0 5
62849: PUSH
62850: LD_VAR 0 1
62854: PPUSH
62855: CALL_OW 274
62859: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62860: LD_ADDR_VAR 0 4
62864: PUSH
62865: LD_VAR 0 2
62869: PUSH
62870: LD_INT 1
62872: ARRAY
62873: PPUSH
62874: LD_VAR 0 2
62878: PUSH
62879: LD_INT 2
62881: ARRAY
62882: PPUSH
62883: LD_VAR 0 2
62887: PUSH
62888: LD_INT 3
62890: ARRAY
62891: PPUSH
62892: LD_VAR 0 2
62896: PUSH
62897: LD_INT 4
62899: ARRAY
62900: PPUSH
62901: CALL_OW 449
62905: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62906: LD_ADDR_VAR 0 3
62910: PUSH
62911: LD_VAR 0 5
62915: PPUSH
62916: LD_INT 1
62918: PPUSH
62919: CALL_OW 275
62923: PUSH
62924: LD_VAR 0 4
62928: PUSH
62929: LD_INT 1
62931: ARRAY
62932: GREATEREQUAL
62933: PUSH
62934: LD_VAR 0 5
62938: PPUSH
62939: LD_INT 2
62941: PPUSH
62942: CALL_OW 275
62946: PUSH
62947: LD_VAR 0 4
62951: PUSH
62952: LD_INT 2
62954: ARRAY
62955: GREATEREQUAL
62956: AND
62957: PUSH
62958: LD_VAR 0 5
62962: PPUSH
62963: LD_INT 3
62965: PPUSH
62966: CALL_OW 275
62970: PUSH
62971: LD_VAR 0 4
62975: PUSH
62976: LD_INT 3
62978: ARRAY
62979: GREATEREQUAL
62980: AND
62981: ST_TO_ADDR
// end ;
62982: LD_VAR 0 3
62986: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62987: LD_INT 0
62989: PPUSH
62990: PPUSH
62991: PPUSH
62992: PPUSH
// pom := GetBase ( building ) ;
62993: LD_ADDR_VAR 0 3
62997: PUSH
62998: LD_VAR 0 1
63002: PPUSH
63003: CALL_OW 274
63007: ST_TO_ADDR
// if not pom then
63008: LD_VAR 0 3
63012: NOT
63013: IFFALSE 63017
// exit ;
63015: GO 63187
// btype := GetBType ( building ) ;
63017: LD_ADDR_VAR 0 5
63021: PUSH
63022: LD_VAR 0 1
63026: PPUSH
63027: CALL_OW 266
63031: ST_TO_ADDR
// if btype = b_armoury then
63032: LD_VAR 0 5
63036: PUSH
63037: LD_INT 4
63039: EQUAL
63040: IFFALSE 63050
// btype := b_barracks ;
63042: LD_ADDR_VAR 0 5
63046: PUSH
63047: LD_INT 5
63049: ST_TO_ADDR
// if btype = b_depot then
63050: LD_VAR 0 5
63054: PUSH
63055: LD_INT 0
63057: EQUAL
63058: IFFALSE 63068
// btype := b_warehouse ;
63060: LD_ADDR_VAR 0 5
63064: PUSH
63065: LD_INT 1
63067: ST_TO_ADDR
// if btype = b_workshop then
63068: LD_VAR 0 5
63072: PUSH
63073: LD_INT 2
63075: EQUAL
63076: IFFALSE 63086
// btype := b_factory ;
63078: LD_ADDR_VAR 0 5
63082: PUSH
63083: LD_INT 3
63085: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63086: LD_ADDR_VAR 0 4
63090: PUSH
63091: LD_VAR 0 5
63095: PPUSH
63096: LD_VAR 0 1
63100: PPUSH
63101: CALL_OW 248
63105: PPUSH
63106: CALL_OW 450
63110: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63111: LD_ADDR_VAR 0 2
63115: PUSH
63116: LD_VAR 0 3
63120: PPUSH
63121: LD_INT 1
63123: PPUSH
63124: CALL_OW 275
63128: PUSH
63129: LD_VAR 0 4
63133: PUSH
63134: LD_INT 1
63136: ARRAY
63137: GREATEREQUAL
63138: PUSH
63139: LD_VAR 0 3
63143: PPUSH
63144: LD_INT 2
63146: PPUSH
63147: CALL_OW 275
63151: PUSH
63152: LD_VAR 0 4
63156: PUSH
63157: LD_INT 2
63159: ARRAY
63160: GREATEREQUAL
63161: AND
63162: PUSH
63163: LD_VAR 0 3
63167: PPUSH
63168: LD_INT 3
63170: PPUSH
63171: CALL_OW 275
63175: PUSH
63176: LD_VAR 0 4
63180: PUSH
63181: LD_INT 3
63183: ARRAY
63184: GREATEREQUAL
63185: AND
63186: ST_TO_ADDR
// end ;
63187: LD_VAR 0 2
63191: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63192: LD_INT 0
63194: PPUSH
63195: PPUSH
63196: PPUSH
// pom := GetBase ( building ) ;
63197: LD_ADDR_VAR 0 4
63201: PUSH
63202: LD_VAR 0 1
63206: PPUSH
63207: CALL_OW 274
63211: ST_TO_ADDR
// if not pom then
63212: LD_VAR 0 4
63216: NOT
63217: IFFALSE 63221
// exit ;
63219: GO 63322
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63221: LD_ADDR_VAR 0 5
63225: PUSH
63226: LD_VAR 0 2
63230: PPUSH
63231: LD_VAR 0 1
63235: PPUSH
63236: CALL_OW 248
63240: PPUSH
63241: CALL_OW 450
63245: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63246: LD_ADDR_VAR 0 3
63250: PUSH
63251: LD_VAR 0 4
63255: PPUSH
63256: LD_INT 1
63258: PPUSH
63259: CALL_OW 275
63263: PUSH
63264: LD_VAR 0 5
63268: PUSH
63269: LD_INT 1
63271: ARRAY
63272: GREATEREQUAL
63273: PUSH
63274: LD_VAR 0 4
63278: PPUSH
63279: LD_INT 2
63281: PPUSH
63282: CALL_OW 275
63286: PUSH
63287: LD_VAR 0 5
63291: PUSH
63292: LD_INT 2
63294: ARRAY
63295: GREATEREQUAL
63296: AND
63297: PUSH
63298: LD_VAR 0 4
63302: PPUSH
63303: LD_INT 3
63305: PPUSH
63306: CALL_OW 275
63310: PUSH
63311: LD_VAR 0 5
63315: PUSH
63316: LD_INT 3
63318: ARRAY
63319: GREATEREQUAL
63320: AND
63321: ST_TO_ADDR
// end ;
63322: LD_VAR 0 3
63326: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63327: LD_INT 0
63329: PPUSH
63330: PPUSH
63331: PPUSH
63332: PPUSH
63333: PPUSH
63334: PPUSH
63335: PPUSH
63336: PPUSH
63337: PPUSH
63338: PPUSH
63339: PPUSH
// result := false ;
63340: LD_ADDR_VAR 0 8
63344: PUSH
63345: LD_INT 0
63347: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63348: LD_VAR 0 5
63352: NOT
63353: PUSH
63354: LD_VAR 0 1
63358: NOT
63359: OR
63360: PUSH
63361: LD_VAR 0 2
63365: NOT
63366: OR
63367: PUSH
63368: LD_VAR 0 3
63372: NOT
63373: OR
63374: IFFALSE 63378
// exit ;
63376: GO 64192
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63378: LD_ADDR_VAR 0 14
63382: PUSH
63383: LD_VAR 0 1
63387: PPUSH
63388: LD_VAR 0 2
63392: PPUSH
63393: LD_VAR 0 3
63397: PPUSH
63398: LD_VAR 0 4
63402: PPUSH
63403: LD_VAR 0 5
63407: PUSH
63408: LD_INT 1
63410: ARRAY
63411: PPUSH
63412: CALL_OW 248
63416: PPUSH
63417: LD_INT 0
63419: PPUSH
63420: CALL 65429 0 6
63424: ST_TO_ADDR
// if not hexes then
63425: LD_VAR 0 14
63429: NOT
63430: IFFALSE 63434
// exit ;
63432: GO 64192
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63434: LD_ADDR_VAR 0 17
63438: PUSH
63439: LD_VAR 0 5
63443: PPUSH
63444: LD_INT 22
63446: PUSH
63447: LD_VAR 0 13
63451: PPUSH
63452: CALL_OW 255
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_INT 2
63463: PUSH
63464: LD_INT 30
63466: PUSH
63467: LD_INT 0
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PUSH
63474: LD_INT 30
63476: PUSH
63477: LD_INT 1
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: LIST
63488: PUSH
63489: EMPTY
63490: LIST
63491: LIST
63492: PPUSH
63493: CALL_OW 72
63497: ST_TO_ADDR
// for i = 1 to hexes do
63498: LD_ADDR_VAR 0 9
63502: PUSH
63503: DOUBLE
63504: LD_INT 1
63506: DEC
63507: ST_TO_ADDR
63508: LD_VAR 0 14
63512: PUSH
63513: FOR_TO
63514: IFFALSE 64190
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63516: LD_ADDR_VAR 0 13
63520: PUSH
63521: LD_VAR 0 14
63525: PUSH
63526: LD_VAR 0 9
63530: ARRAY
63531: PUSH
63532: LD_INT 1
63534: ARRAY
63535: PPUSH
63536: LD_VAR 0 14
63540: PUSH
63541: LD_VAR 0 9
63545: ARRAY
63546: PUSH
63547: LD_INT 2
63549: ARRAY
63550: PPUSH
63551: CALL_OW 428
63555: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63556: LD_VAR 0 14
63560: PUSH
63561: LD_VAR 0 9
63565: ARRAY
63566: PUSH
63567: LD_INT 1
63569: ARRAY
63570: PPUSH
63571: LD_VAR 0 14
63575: PUSH
63576: LD_VAR 0 9
63580: ARRAY
63581: PUSH
63582: LD_INT 2
63584: ARRAY
63585: PPUSH
63586: CALL_OW 351
63590: PUSH
63591: LD_VAR 0 14
63595: PUSH
63596: LD_VAR 0 9
63600: ARRAY
63601: PUSH
63602: LD_INT 1
63604: ARRAY
63605: PPUSH
63606: LD_VAR 0 14
63610: PUSH
63611: LD_VAR 0 9
63615: ARRAY
63616: PUSH
63617: LD_INT 2
63619: ARRAY
63620: PPUSH
63621: CALL_OW 488
63625: NOT
63626: OR
63627: PUSH
63628: LD_VAR 0 13
63632: PPUSH
63633: CALL_OW 247
63637: PUSH
63638: LD_INT 3
63640: EQUAL
63641: OR
63642: IFFALSE 63648
// exit ;
63644: POP
63645: POP
63646: GO 64192
// if not tmp then
63648: LD_VAR 0 13
63652: NOT
63653: IFFALSE 63657
// continue ;
63655: GO 63513
// result := true ;
63657: LD_ADDR_VAR 0 8
63661: PUSH
63662: LD_INT 1
63664: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63665: LD_VAR 0 6
63669: PUSH
63670: LD_VAR 0 13
63674: PPUSH
63675: CALL_OW 247
63679: PUSH
63680: LD_INT 2
63682: EQUAL
63683: AND
63684: PUSH
63685: LD_VAR 0 13
63689: PPUSH
63690: CALL_OW 263
63694: PUSH
63695: LD_INT 1
63697: EQUAL
63698: AND
63699: IFFALSE 63863
// begin if IsDrivenBy ( tmp ) then
63701: LD_VAR 0 13
63705: PPUSH
63706: CALL_OW 311
63710: IFFALSE 63714
// continue ;
63712: GO 63513
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63714: LD_VAR 0 6
63718: PPUSH
63719: LD_INT 3
63721: PUSH
63722: LD_INT 60
63724: PUSH
63725: EMPTY
63726: LIST
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 3
63734: PUSH
63735: LD_INT 55
63737: PUSH
63738: EMPTY
63739: LIST
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: PPUSH
63749: CALL_OW 72
63753: IFFALSE 63861
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63755: LD_ADDR_VAR 0 18
63759: PUSH
63760: LD_VAR 0 6
63764: PPUSH
63765: LD_INT 3
63767: PUSH
63768: LD_INT 60
63770: PUSH
63771: EMPTY
63772: LIST
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: LD_INT 3
63780: PUSH
63781: LD_INT 55
63783: PUSH
63784: EMPTY
63785: LIST
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PPUSH
63795: CALL_OW 72
63799: PUSH
63800: LD_INT 1
63802: ARRAY
63803: ST_TO_ADDR
// if IsInUnit ( driver ) then
63804: LD_VAR 0 18
63808: PPUSH
63809: CALL_OW 310
63813: IFFALSE 63824
// ComExit ( driver ) ;
63815: LD_VAR 0 18
63819: PPUSH
63820: CALL 88613 0 1
// AddComEnterUnit ( driver , tmp ) ;
63824: LD_VAR 0 18
63828: PPUSH
63829: LD_VAR 0 13
63833: PPUSH
63834: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63838: LD_VAR 0 18
63842: PPUSH
63843: LD_VAR 0 7
63847: PPUSH
63848: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63852: LD_VAR 0 18
63856: PPUSH
63857: CALL_OW 181
// end ; continue ;
63861: GO 63513
// end ; if not cleaners or not tmp in cleaners then
63863: LD_VAR 0 6
63867: NOT
63868: PUSH
63869: LD_VAR 0 13
63873: PUSH
63874: LD_VAR 0 6
63878: IN
63879: NOT
63880: OR
63881: IFFALSE 64188
// begin if dep then
63883: LD_VAR 0 17
63887: IFFALSE 64023
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63889: LD_ADDR_VAR 0 16
63893: PUSH
63894: LD_VAR 0 17
63898: PUSH
63899: LD_INT 1
63901: ARRAY
63902: PPUSH
63903: CALL_OW 250
63907: PPUSH
63908: LD_VAR 0 17
63912: PUSH
63913: LD_INT 1
63915: ARRAY
63916: PPUSH
63917: CALL_OW 254
63921: PPUSH
63922: LD_INT 5
63924: PPUSH
63925: CALL_OW 272
63929: PUSH
63930: LD_VAR 0 17
63934: PUSH
63935: LD_INT 1
63937: ARRAY
63938: PPUSH
63939: CALL_OW 251
63943: PPUSH
63944: LD_VAR 0 17
63948: PUSH
63949: LD_INT 1
63951: ARRAY
63952: PPUSH
63953: CALL_OW 254
63957: PPUSH
63958: LD_INT 5
63960: PPUSH
63961: CALL_OW 273
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63970: LD_VAR 0 16
63974: PUSH
63975: LD_INT 1
63977: ARRAY
63978: PPUSH
63979: LD_VAR 0 16
63983: PUSH
63984: LD_INT 2
63986: ARRAY
63987: PPUSH
63988: CALL_OW 488
63992: IFFALSE 64023
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63994: LD_VAR 0 13
63998: PPUSH
63999: LD_VAR 0 16
64003: PUSH
64004: LD_INT 1
64006: ARRAY
64007: PPUSH
64008: LD_VAR 0 16
64012: PUSH
64013: LD_INT 2
64015: ARRAY
64016: PPUSH
64017: CALL_OW 111
// continue ;
64021: GO 63513
// end ; end ; r := GetDir ( tmp ) ;
64023: LD_ADDR_VAR 0 15
64027: PUSH
64028: LD_VAR 0 13
64032: PPUSH
64033: CALL_OW 254
64037: ST_TO_ADDR
// if r = 5 then
64038: LD_VAR 0 15
64042: PUSH
64043: LD_INT 5
64045: EQUAL
64046: IFFALSE 64056
// r := 0 ;
64048: LD_ADDR_VAR 0 15
64052: PUSH
64053: LD_INT 0
64055: ST_TO_ADDR
// for j = r to 5 do
64056: LD_ADDR_VAR 0 10
64060: PUSH
64061: DOUBLE
64062: LD_VAR 0 15
64066: DEC
64067: ST_TO_ADDR
64068: LD_INT 5
64070: PUSH
64071: FOR_TO
64072: IFFALSE 64186
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64074: LD_ADDR_VAR 0 11
64078: PUSH
64079: LD_VAR 0 13
64083: PPUSH
64084: CALL_OW 250
64088: PPUSH
64089: LD_VAR 0 10
64093: PPUSH
64094: LD_INT 2
64096: PPUSH
64097: CALL_OW 272
64101: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64102: LD_ADDR_VAR 0 12
64106: PUSH
64107: LD_VAR 0 13
64111: PPUSH
64112: CALL_OW 251
64116: PPUSH
64117: LD_VAR 0 10
64121: PPUSH
64122: LD_INT 2
64124: PPUSH
64125: CALL_OW 273
64129: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64130: LD_VAR 0 11
64134: PPUSH
64135: LD_VAR 0 12
64139: PPUSH
64140: CALL_OW 488
64144: PUSH
64145: LD_VAR 0 11
64149: PPUSH
64150: LD_VAR 0 12
64154: PPUSH
64155: CALL_OW 428
64159: NOT
64160: AND
64161: IFFALSE 64184
// begin ComMoveXY ( tmp , _x , _y ) ;
64163: LD_VAR 0 13
64167: PPUSH
64168: LD_VAR 0 11
64172: PPUSH
64173: LD_VAR 0 12
64177: PPUSH
64178: CALL_OW 111
// break ;
64182: GO 64186
// end ; end ;
64184: GO 64071
64186: POP
64187: POP
// end ; end ;
64188: GO 63513
64190: POP
64191: POP
// end ;
64192: LD_VAR 0 8
64196: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64197: LD_INT 0
64199: PPUSH
// result := true ;
64200: LD_ADDR_VAR 0 3
64204: PUSH
64205: LD_INT 1
64207: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64208: LD_VAR 0 2
64212: PUSH
64213: LD_INT 24
64215: DOUBLE
64216: EQUAL
64217: IFTRUE 64227
64219: LD_INT 33
64221: DOUBLE
64222: EQUAL
64223: IFTRUE 64227
64225: GO 64252
64227: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64228: LD_ADDR_VAR 0 3
64232: PUSH
64233: LD_INT 32
64235: PPUSH
64236: LD_VAR 0 1
64240: PPUSH
64241: CALL_OW 321
64245: PUSH
64246: LD_INT 2
64248: EQUAL
64249: ST_TO_ADDR
64250: GO 64572
64252: LD_INT 20
64254: DOUBLE
64255: EQUAL
64256: IFTRUE 64260
64258: GO 64285
64260: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64261: LD_ADDR_VAR 0 3
64265: PUSH
64266: LD_INT 6
64268: PPUSH
64269: LD_VAR 0 1
64273: PPUSH
64274: CALL_OW 321
64278: PUSH
64279: LD_INT 2
64281: EQUAL
64282: ST_TO_ADDR
64283: GO 64572
64285: LD_INT 22
64287: DOUBLE
64288: EQUAL
64289: IFTRUE 64299
64291: LD_INT 36
64293: DOUBLE
64294: EQUAL
64295: IFTRUE 64299
64297: GO 64324
64299: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64300: LD_ADDR_VAR 0 3
64304: PUSH
64305: LD_INT 15
64307: PPUSH
64308: LD_VAR 0 1
64312: PPUSH
64313: CALL_OW 321
64317: PUSH
64318: LD_INT 2
64320: EQUAL
64321: ST_TO_ADDR
64322: GO 64572
64324: LD_INT 30
64326: DOUBLE
64327: EQUAL
64328: IFTRUE 64332
64330: GO 64357
64332: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64333: LD_ADDR_VAR 0 3
64337: PUSH
64338: LD_INT 20
64340: PPUSH
64341: LD_VAR 0 1
64345: PPUSH
64346: CALL_OW 321
64350: PUSH
64351: LD_INT 2
64353: EQUAL
64354: ST_TO_ADDR
64355: GO 64572
64357: LD_INT 28
64359: DOUBLE
64360: EQUAL
64361: IFTRUE 64371
64363: LD_INT 21
64365: DOUBLE
64366: EQUAL
64367: IFTRUE 64371
64369: GO 64396
64371: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64372: LD_ADDR_VAR 0 3
64376: PUSH
64377: LD_INT 21
64379: PPUSH
64380: LD_VAR 0 1
64384: PPUSH
64385: CALL_OW 321
64389: PUSH
64390: LD_INT 2
64392: EQUAL
64393: ST_TO_ADDR
64394: GO 64572
64396: LD_INT 16
64398: DOUBLE
64399: EQUAL
64400: IFTRUE 64404
64402: GO 64431
64404: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64405: LD_ADDR_VAR 0 3
64409: PUSH
64410: LD_EXP 84
64414: PPUSH
64415: LD_VAR 0 1
64419: PPUSH
64420: CALL_OW 321
64424: PUSH
64425: LD_INT 2
64427: EQUAL
64428: ST_TO_ADDR
64429: GO 64572
64431: LD_INT 19
64433: DOUBLE
64434: EQUAL
64435: IFTRUE 64445
64437: LD_INT 23
64439: DOUBLE
64440: EQUAL
64441: IFTRUE 64445
64443: GO 64472
64445: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64446: LD_ADDR_VAR 0 3
64450: PUSH
64451: LD_EXP 83
64455: PPUSH
64456: LD_VAR 0 1
64460: PPUSH
64461: CALL_OW 321
64465: PUSH
64466: LD_INT 2
64468: EQUAL
64469: ST_TO_ADDR
64470: GO 64572
64472: LD_INT 17
64474: DOUBLE
64475: EQUAL
64476: IFTRUE 64480
64478: GO 64505
64480: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64481: LD_ADDR_VAR 0 3
64485: PUSH
64486: LD_INT 39
64488: PPUSH
64489: LD_VAR 0 1
64493: PPUSH
64494: CALL_OW 321
64498: PUSH
64499: LD_INT 2
64501: EQUAL
64502: ST_TO_ADDR
64503: GO 64572
64505: LD_INT 18
64507: DOUBLE
64508: EQUAL
64509: IFTRUE 64513
64511: GO 64538
64513: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64514: LD_ADDR_VAR 0 3
64518: PUSH
64519: LD_INT 40
64521: PPUSH
64522: LD_VAR 0 1
64526: PPUSH
64527: CALL_OW 321
64531: PUSH
64532: LD_INT 2
64534: EQUAL
64535: ST_TO_ADDR
64536: GO 64572
64538: LD_INT 27
64540: DOUBLE
64541: EQUAL
64542: IFTRUE 64546
64544: GO 64571
64546: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64547: LD_ADDR_VAR 0 3
64551: PUSH
64552: LD_INT 35
64554: PPUSH
64555: LD_VAR 0 1
64559: PPUSH
64560: CALL_OW 321
64564: PUSH
64565: LD_INT 2
64567: EQUAL
64568: ST_TO_ADDR
64569: GO 64572
64571: POP
// end ;
64572: LD_VAR 0 3
64576: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64577: LD_INT 0
64579: PPUSH
64580: PPUSH
64581: PPUSH
64582: PPUSH
64583: PPUSH
64584: PPUSH
64585: PPUSH
64586: PPUSH
64587: PPUSH
64588: PPUSH
64589: PPUSH
// result := false ;
64590: LD_ADDR_VAR 0 6
64594: PUSH
64595: LD_INT 0
64597: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64598: LD_VAR 0 1
64602: NOT
64603: PUSH
64604: LD_VAR 0 1
64608: PPUSH
64609: CALL_OW 266
64613: PUSH
64614: LD_INT 0
64616: PUSH
64617: LD_INT 1
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: IN
64624: NOT
64625: OR
64626: PUSH
64627: LD_VAR 0 2
64631: NOT
64632: OR
64633: PUSH
64634: LD_VAR 0 5
64638: PUSH
64639: LD_INT 0
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: LD_INT 2
64647: PUSH
64648: LD_INT 3
64650: PUSH
64651: LD_INT 4
64653: PUSH
64654: LD_INT 5
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: IN
64665: NOT
64666: OR
64667: PUSH
64668: LD_VAR 0 3
64672: PPUSH
64673: LD_VAR 0 4
64677: PPUSH
64678: CALL_OW 488
64682: NOT
64683: OR
64684: IFFALSE 64688
// exit ;
64686: GO 65424
// side := GetSide ( depot ) ;
64688: LD_ADDR_VAR 0 9
64692: PUSH
64693: LD_VAR 0 1
64697: PPUSH
64698: CALL_OW 255
64702: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64703: LD_VAR 0 9
64707: PPUSH
64708: LD_VAR 0 2
64712: PPUSH
64713: CALL 64197 0 2
64717: NOT
64718: IFFALSE 64722
// exit ;
64720: GO 65424
// pom := GetBase ( depot ) ;
64722: LD_ADDR_VAR 0 10
64726: PUSH
64727: LD_VAR 0 1
64731: PPUSH
64732: CALL_OW 274
64736: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64737: LD_ADDR_VAR 0 11
64741: PUSH
64742: LD_VAR 0 2
64746: PPUSH
64747: LD_VAR 0 1
64751: PPUSH
64752: CALL_OW 248
64756: PPUSH
64757: CALL_OW 450
64761: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64762: LD_VAR 0 10
64766: PPUSH
64767: LD_INT 1
64769: PPUSH
64770: CALL_OW 275
64774: PUSH
64775: LD_VAR 0 11
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: GREATEREQUAL
64784: PUSH
64785: LD_VAR 0 10
64789: PPUSH
64790: LD_INT 2
64792: PPUSH
64793: CALL_OW 275
64797: PUSH
64798: LD_VAR 0 11
64802: PUSH
64803: LD_INT 2
64805: ARRAY
64806: GREATEREQUAL
64807: AND
64808: PUSH
64809: LD_VAR 0 10
64813: PPUSH
64814: LD_INT 3
64816: PPUSH
64817: CALL_OW 275
64821: PUSH
64822: LD_VAR 0 11
64826: PUSH
64827: LD_INT 3
64829: ARRAY
64830: GREATEREQUAL
64831: AND
64832: NOT
64833: IFFALSE 64837
// exit ;
64835: GO 65424
// if GetBType ( depot ) = b_depot then
64837: LD_VAR 0 1
64841: PPUSH
64842: CALL_OW 266
64846: PUSH
64847: LD_INT 0
64849: EQUAL
64850: IFFALSE 64862
// dist := 28 else
64852: LD_ADDR_VAR 0 14
64856: PUSH
64857: LD_INT 28
64859: ST_TO_ADDR
64860: GO 64870
// dist := 36 ;
64862: LD_ADDR_VAR 0 14
64866: PUSH
64867: LD_INT 36
64869: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64870: LD_VAR 0 1
64874: PPUSH
64875: LD_VAR 0 3
64879: PPUSH
64880: LD_VAR 0 4
64884: PPUSH
64885: CALL_OW 297
64889: PUSH
64890: LD_VAR 0 14
64894: GREATER
64895: IFFALSE 64899
// exit ;
64897: GO 65424
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64899: LD_ADDR_VAR 0 12
64903: PUSH
64904: LD_VAR 0 2
64908: PPUSH
64909: LD_VAR 0 3
64913: PPUSH
64914: LD_VAR 0 4
64918: PPUSH
64919: LD_VAR 0 5
64923: PPUSH
64924: LD_VAR 0 1
64928: PPUSH
64929: CALL_OW 248
64933: PPUSH
64934: LD_INT 0
64936: PPUSH
64937: CALL 65429 0 6
64941: ST_TO_ADDR
// if not hexes then
64942: LD_VAR 0 12
64946: NOT
64947: IFFALSE 64951
// exit ;
64949: GO 65424
// hex := GetHexInfo ( x , y ) ;
64951: LD_ADDR_VAR 0 15
64955: PUSH
64956: LD_VAR 0 3
64960: PPUSH
64961: LD_VAR 0 4
64965: PPUSH
64966: CALL_OW 546
64970: ST_TO_ADDR
// if hex [ 1 ] then
64971: LD_VAR 0 15
64975: PUSH
64976: LD_INT 1
64978: ARRAY
64979: IFFALSE 64983
// exit ;
64981: GO 65424
// height := hex [ 2 ] ;
64983: LD_ADDR_VAR 0 13
64987: PUSH
64988: LD_VAR 0 15
64992: PUSH
64993: LD_INT 2
64995: ARRAY
64996: ST_TO_ADDR
// for i = 1 to hexes do
64997: LD_ADDR_VAR 0 7
65001: PUSH
65002: DOUBLE
65003: LD_INT 1
65005: DEC
65006: ST_TO_ADDR
65007: LD_VAR 0 12
65011: PUSH
65012: FOR_TO
65013: IFFALSE 65343
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65015: LD_VAR 0 12
65019: PUSH
65020: LD_VAR 0 7
65024: ARRAY
65025: PUSH
65026: LD_INT 1
65028: ARRAY
65029: PPUSH
65030: LD_VAR 0 12
65034: PUSH
65035: LD_VAR 0 7
65039: ARRAY
65040: PUSH
65041: LD_INT 2
65043: ARRAY
65044: PPUSH
65045: CALL_OW 488
65049: NOT
65050: PUSH
65051: LD_VAR 0 12
65055: PUSH
65056: LD_VAR 0 7
65060: ARRAY
65061: PUSH
65062: LD_INT 1
65064: ARRAY
65065: PPUSH
65066: LD_VAR 0 12
65070: PUSH
65071: LD_VAR 0 7
65075: ARRAY
65076: PUSH
65077: LD_INT 2
65079: ARRAY
65080: PPUSH
65081: CALL_OW 428
65085: PUSH
65086: LD_INT 0
65088: GREATER
65089: OR
65090: PUSH
65091: LD_VAR 0 12
65095: PUSH
65096: LD_VAR 0 7
65100: ARRAY
65101: PUSH
65102: LD_INT 1
65104: ARRAY
65105: PPUSH
65106: LD_VAR 0 12
65110: PUSH
65111: LD_VAR 0 7
65115: ARRAY
65116: PUSH
65117: LD_INT 2
65119: ARRAY
65120: PPUSH
65121: CALL_OW 351
65125: OR
65126: IFFALSE 65132
// exit ;
65128: POP
65129: POP
65130: GO 65424
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65132: LD_ADDR_VAR 0 8
65136: PUSH
65137: LD_VAR 0 12
65141: PUSH
65142: LD_VAR 0 7
65146: ARRAY
65147: PUSH
65148: LD_INT 1
65150: ARRAY
65151: PPUSH
65152: LD_VAR 0 12
65156: PUSH
65157: LD_VAR 0 7
65161: ARRAY
65162: PUSH
65163: LD_INT 2
65165: ARRAY
65166: PPUSH
65167: CALL_OW 546
65171: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65172: LD_VAR 0 8
65176: PUSH
65177: LD_INT 1
65179: ARRAY
65180: PUSH
65181: LD_VAR 0 8
65185: PUSH
65186: LD_INT 2
65188: ARRAY
65189: PUSH
65190: LD_VAR 0 13
65194: PUSH
65195: LD_INT 2
65197: PLUS
65198: GREATER
65199: OR
65200: PUSH
65201: LD_VAR 0 8
65205: PUSH
65206: LD_INT 2
65208: ARRAY
65209: PUSH
65210: LD_VAR 0 13
65214: PUSH
65215: LD_INT 2
65217: MINUS
65218: LESS
65219: OR
65220: PUSH
65221: LD_VAR 0 8
65225: PUSH
65226: LD_INT 3
65228: ARRAY
65229: PUSH
65230: LD_INT 0
65232: PUSH
65233: LD_INT 8
65235: PUSH
65236: LD_INT 9
65238: PUSH
65239: LD_INT 10
65241: PUSH
65242: LD_INT 11
65244: PUSH
65245: LD_INT 12
65247: PUSH
65248: LD_INT 13
65250: PUSH
65251: LD_INT 16
65253: PUSH
65254: LD_INT 17
65256: PUSH
65257: LD_INT 18
65259: PUSH
65260: LD_INT 19
65262: PUSH
65263: LD_INT 20
65265: PUSH
65266: LD_INT 21
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: IN
65284: NOT
65285: OR
65286: PUSH
65287: LD_VAR 0 8
65291: PUSH
65292: LD_INT 5
65294: ARRAY
65295: NOT
65296: OR
65297: PUSH
65298: LD_VAR 0 8
65302: PUSH
65303: LD_INT 6
65305: ARRAY
65306: PUSH
65307: LD_INT 1
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: LD_INT 7
65315: PUSH
65316: LD_INT 9
65318: PUSH
65319: LD_INT 10
65321: PUSH
65322: LD_INT 11
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: IN
65333: NOT
65334: OR
65335: IFFALSE 65341
// exit ;
65337: POP
65338: POP
65339: GO 65424
// end ;
65341: GO 65012
65343: POP
65344: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65345: LD_VAR 0 9
65349: PPUSH
65350: LD_VAR 0 3
65354: PPUSH
65355: LD_VAR 0 4
65359: PPUSH
65360: LD_INT 20
65362: PPUSH
65363: CALL 57370 0 4
65367: PUSH
65368: LD_INT 4
65370: ARRAY
65371: IFFALSE 65375
// exit ;
65373: GO 65424
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65375: LD_VAR 0 2
65379: PUSH
65380: LD_INT 29
65382: PUSH
65383: LD_INT 30
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: IN
65390: PUSH
65391: LD_VAR 0 3
65395: PPUSH
65396: LD_VAR 0 4
65400: PPUSH
65401: LD_VAR 0 9
65405: PPUSH
65406: CALL_OW 440
65410: NOT
65411: AND
65412: IFFALSE 65416
// exit ;
65414: GO 65424
// result := true ;
65416: LD_ADDR_VAR 0 6
65420: PUSH
65421: LD_INT 1
65423: ST_TO_ADDR
// end ;
65424: LD_VAR 0 6
65428: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65429: LD_INT 0
65431: PPUSH
65432: PPUSH
65433: PPUSH
65434: PPUSH
65435: PPUSH
65436: PPUSH
65437: PPUSH
65438: PPUSH
65439: PPUSH
65440: PPUSH
65441: PPUSH
65442: PPUSH
65443: PPUSH
65444: PPUSH
65445: PPUSH
65446: PPUSH
65447: PPUSH
65448: PPUSH
65449: PPUSH
65450: PPUSH
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
65457: PPUSH
65458: PPUSH
65459: PPUSH
65460: PPUSH
65461: PPUSH
65462: PPUSH
65463: PPUSH
65464: PPUSH
65465: PPUSH
65466: PPUSH
65467: PPUSH
65468: PPUSH
65469: PPUSH
65470: PPUSH
65471: PPUSH
65472: PPUSH
65473: PPUSH
65474: PPUSH
65475: PPUSH
65476: PPUSH
65477: PPUSH
65478: PPUSH
65479: PPUSH
65480: PPUSH
65481: PPUSH
65482: PPUSH
65483: PPUSH
65484: PPUSH
65485: PPUSH
65486: PPUSH
65487: PPUSH
65488: PPUSH
// result = [ ] ;
65489: LD_ADDR_VAR 0 7
65493: PUSH
65494: EMPTY
65495: ST_TO_ADDR
// temp_list = [ ] ;
65496: LD_ADDR_VAR 0 9
65500: PUSH
65501: EMPTY
65502: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65503: LD_VAR 0 4
65507: PUSH
65508: LD_INT 0
65510: PUSH
65511: LD_INT 1
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 3
65519: PUSH
65520: LD_INT 4
65522: PUSH
65523: LD_INT 5
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: IN
65534: NOT
65535: PUSH
65536: LD_VAR 0 1
65540: PUSH
65541: LD_INT 0
65543: PUSH
65544: LD_INT 1
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: IN
65551: PUSH
65552: LD_VAR 0 5
65556: PUSH
65557: LD_INT 1
65559: PUSH
65560: LD_INT 2
65562: PUSH
65563: LD_INT 3
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: LIST
65570: IN
65571: NOT
65572: AND
65573: OR
65574: IFFALSE 65578
// exit ;
65576: GO 83969
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65578: LD_VAR 0 1
65582: PUSH
65583: LD_INT 6
65585: PUSH
65586: LD_INT 7
65588: PUSH
65589: LD_INT 8
65591: PUSH
65592: LD_INT 13
65594: PUSH
65595: LD_INT 12
65597: PUSH
65598: LD_INT 15
65600: PUSH
65601: LD_INT 11
65603: PUSH
65604: LD_INT 14
65606: PUSH
65607: LD_INT 10
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: IN
65621: IFFALSE 65631
// btype = b_lab ;
65623: LD_ADDR_VAR 0 1
65627: PUSH
65628: LD_INT 6
65630: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65631: LD_VAR 0 6
65635: PUSH
65636: LD_INT 0
65638: PUSH
65639: LD_INT 1
65641: PUSH
65642: LD_INT 2
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: LIST
65649: IN
65650: NOT
65651: PUSH
65652: LD_VAR 0 1
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 2
65665: PUSH
65666: LD_INT 3
65668: PUSH
65669: LD_INT 6
65671: PUSH
65672: LD_INT 36
65674: PUSH
65675: LD_INT 4
65677: PUSH
65678: LD_INT 5
65680: PUSH
65681: LD_INT 31
65683: PUSH
65684: LD_INT 32
65686: PUSH
65687: LD_INT 33
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: IN
65703: NOT
65704: PUSH
65705: LD_VAR 0 6
65709: PUSH
65710: LD_INT 1
65712: EQUAL
65713: AND
65714: OR
65715: PUSH
65716: LD_VAR 0 1
65720: PUSH
65721: LD_INT 2
65723: PUSH
65724: LD_INT 3
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: IN
65731: NOT
65732: PUSH
65733: LD_VAR 0 6
65737: PUSH
65738: LD_INT 2
65740: EQUAL
65741: AND
65742: OR
65743: IFFALSE 65753
// mode = 0 ;
65745: LD_ADDR_VAR 0 6
65749: PUSH
65750: LD_INT 0
65752: ST_TO_ADDR
// case mode of 0 :
65753: LD_VAR 0 6
65757: PUSH
65758: LD_INT 0
65760: DOUBLE
65761: EQUAL
65762: IFTRUE 65766
65764: GO 77219
65766: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65767: LD_ADDR_VAR 0 11
65771: PUSH
65772: LD_INT 0
65774: PUSH
65775: LD_INT 0
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 1
65787: NEG
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 1
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 1
65805: PUSH
65806: LD_INT 1
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 0
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 1
65825: NEG
65826: PUSH
65827: LD_INT 0
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PUSH
65834: LD_INT 1
65836: NEG
65837: PUSH
65838: LD_INT 1
65840: NEG
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 1
65848: NEG
65849: PUSH
65850: LD_INT 2
65852: NEG
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 0
65860: PUSH
65861: LD_INT 2
65863: NEG
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 1
65871: PUSH
65872: LD_INT 1
65874: NEG
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: LD_INT 2
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 2
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 1
65902: NEG
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 3
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 0
65923: PUSH
65924: LD_INT 3
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 1
65933: NEG
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65960: LD_ADDR_VAR 0 12
65964: PUSH
65965: LD_INT 0
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: LD_INT 1
65980: NEG
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 1
65988: PUSH
65989: LD_INT 0
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: PUSH
65999: LD_INT 1
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 0
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: NEG
66019: PUSH
66020: LD_INT 0
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 1
66029: NEG
66030: PUSH
66031: LD_INT 1
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 1
66041: PUSH
66042: LD_INT 1
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 2
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 2
66062: PUSH
66063: LD_INT 1
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 1
66072: NEG
66073: PUSH
66074: LD_INT 1
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PUSH
66081: LD_INT 2
66083: NEG
66084: PUSH
66085: LD_INT 0
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 2
66094: NEG
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 2
66106: NEG
66107: PUSH
66108: LD_INT 1
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 3
66117: NEG
66118: PUSH
66119: LD_INT 0
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 3
66128: NEG
66129: PUSH
66130: LD_INT 1
66132: NEG
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66156: LD_ADDR_VAR 0 13
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: LD_INT 0
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: LD_INT 1
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: LD_INT 0
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 1
66194: PUSH
66195: LD_INT 1
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 1
66214: NEG
66215: PUSH
66216: LD_INT 0
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: LD_INT 1
66225: NEG
66226: PUSH
66227: LD_INT 1
66229: NEG
66230: PUSH
66231: EMPTY
66232: LIST
66233: LIST
66234: PUSH
66235: LD_INT 1
66237: NEG
66238: PUSH
66239: LD_INT 2
66241: NEG
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 2
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 2
66259: PUSH
66260: LD_INT 2
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: LD_INT 1
66269: PUSH
66270: LD_INT 2
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 2
66279: NEG
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 2
66291: NEG
66292: PUSH
66293: LD_INT 2
66295: NEG
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 2
66303: NEG
66304: PUSH
66305: LD_INT 3
66307: NEG
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 3
66315: NEG
66316: PUSH
66317: LD_INT 2
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 3
66327: NEG
66328: PUSH
66329: LD_INT 3
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66355: LD_ADDR_VAR 0 14
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: LD_INT 1
66375: NEG
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 0
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 1
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: NEG
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 1
66436: NEG
66437: PUSH
66438: LD_INT 2
66440: NEG
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 0
66448: PUSH
66449: LD_INT 2
66451: NEG
66452: PUSH
66453: EMPTY
66454: LIST
66455: LIST
66456: PUSH
66457: LD_INT 1
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: LD_INT 2
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 0
66480: PUSH
66481: LD_INT 2
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: NEG
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 1
66501: NEG
66502: PUSH
66503: LD_INT 3
66505: NEG
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: LD_INT 3
66516: NEG
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 2
66527: NEG
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66551: LD_ADDR_VAR 0 15
66555: PUSH
66556: LD_INT 0
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: LD_INT 1
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PUSH
66611: LD_INT 0
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: LD_INT 1
66635: NEG
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: PUSH
66644: LD_INT 0
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: LD_INT 1
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 1
66663: NEG
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 2
66674: NEG
66675: PUSH
66676: LD_INT 0
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 2
66685: NEG
66686: PUSH
66687: LD_INT 1
66689: NEG
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 2
66697: PUSH
66698: LD_INT 1
66700: NEG
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 3
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 3
66718: PUSH
66719: LD_INT 1
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66744: LD_ADDR_VAR 0 16
66748: PUSH
66749: LD_INT 0
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: LD_INT 1
66764: NEG
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 1
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 2
66837: PUSH
66838: LD_INT 1
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 2
66847: PUSH
66848: LD_INT 2
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 1
66857: PUSH
66858: LD_INT 2
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: NEG
66868: PUSH
66869: LD_INT 1
66871: NEG
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: NEG
66880: PUSH
66881: LD_INT 2
66883: NEG
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 3
66891: PUSH
66892: LD_INT 2
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 3
66901: PUSH
66902: LD_INT 3
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 3
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66937: LD_ADDR_VAR 0 17
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: LD_INT 1
66957: NEG
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 1
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 1
66995: NEG
66996: PUSH
66997: LD_INT 0
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 1
67006: NEG
67007: PUSH
67008: LD_INT 1
67010: NEG
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 2
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 2
67072: PUSH
67073: LD_INT 2
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: NEG
67103: PUSH
67104: LD_INT 1
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: NEG
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: LD_INT 1
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 2
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67167: LD_ADDR_VAR 0 18
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: LD_INT 0
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: LD_INT 1
67187: NEG
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 1
67195: PUSH
67196: LD_INT 0
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: PUSH
67203: LD_INT 1
67205: PUSH
67206: LD_INT 1
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: EMPTY
67220: LIST
67221: LIST
67222: PUSH
67223: LD_INT 1
67225: NEG
67226: PUSH
67227: LD_INT 0
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: NEG
67237: PUSH
67238: LD_INT 1
67240: NEG
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: NEG
67249: PUSH
67250: LD_INT 2
67252: NEG
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 2
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 2
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 2
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: LD_INT 2
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 2
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 1
67332: NEG
67333: PUSH
67334: LD_INT 1
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 2
67343: NEG
67344: PUSH
67345: LD_INT 0
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: LD_INT 1
67358: NEG
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 2
67366: NEG
67367: PUSH
67368: LD_INT 2
67370: NEG
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67397: LD_ADDR_VAR 0 19
67401: PUSH
67402: LD_INT 0
67404: PUSH
67405: LD_INT 0
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: LD_INT 1
67417: NEG
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 1
67425: PUSH
67426: LD_INT 0
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 1
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 1
67455: NEG
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 1
67466: NEG
67467: PUSH
67468: LD_INT 1
67470: NEG
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: LD_INT 2
67482: NEG
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 2
67493: NEG
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: LD_INT 1
67504: NEG
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 2
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 2
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: LD_INT 2
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 0
67552: PUSH
67553: LD_INT 2
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 1
67562: NEG
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: LD_INT 0
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: LD_INT 1
67588: NEG
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 2
67596: NEG
67597: PUSH
67598: LD_INT 2
67600: NEG
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67627: LD_ADDR_VAR 0 20
67631: PUSH
67632: LD_INT 0
67634: PUSH
67635: LD_INT 0
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: LD_INT 1
67647: NEG
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: PUSH
67653: LD_INT 1
67655: PUSH
67656: LD_INT 0
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: LD_INT 1
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 1
67685: NEG
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: LD_INT 1
67700: NEG
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: LD_INT 2
67712: NEG
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: LD_INT 2
67723: NEG
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 1
67731: PUSH
67732: LD_INT 1
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 2
67742: PUSH
67743: LD_INT 0
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 2
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: PUSH
67763: LD_INT 2
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 1
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 0
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 1
67792: NEG
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: NEG
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: LD_INT 1
67818: NEG
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 2
67826: NEG
67827: PUSH
67828: LD_INT 2
67830: NEG
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67857: LD_ADDR_VAR 0 21
67861: PUSH
67862: LD_INT 0
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: LD_INT 1
67877: NEG
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: LD_INT 0
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 0
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 1
67915: NEG
67916: PUSH
67917: LD_INT 0
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: PUSH
67924: LD_INT 1
67926: NEG
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 2
67942: NEG
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 0
67950: PUSH
67951: LD_INT 2
67953: NEG
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: LD_INT 1
67964: NEG
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 2
67972: PUSH
67973: LD_INT 0
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 2
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 2
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 1
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 0
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 1
68022: NEG
68023: PUSH
68024: LD_INT 1
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 2
68033: NEG
68034: PUSH
68035: LD_INT 0
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: LD_INT 1
68048: NEG
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 2
68056: NEG
68057: PUSH
68058: LD_INT 2
68060: NEG
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68087: LD_ADDR_VAR 0 22
68091: PUSH
68092: LD_INT 0
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: LD_INT 0
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 1
68125: PUSH
68126: LD_INT 1
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: LD_INT 1
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: LD_INT 0
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 1
68156: NEG
68157: PUSH
68158: LD_INT 1
68160: NEG
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: LD_INT 2
68172: NEG
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 2
68183: NEG
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 1
68191: PUSH
68192: LD_INT 1
68194: NEG
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 2
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: EMPTY
68207: LIST
68208: LIST
68209: PUSH
68210: LD_INT 2
68212: PUSH
68213: LD_INT 1
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 2
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 1
68232: PUSH
68233: LD_INT 2
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 0
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: NEG
68253: PUSH
68254: LD_INT 1
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 2
68263: NEG
68264: PUSH
68265: LD_INT 0
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 2
68274: NEG
68275: PUSH
68276: LD_INT 1
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: NEG
68287: PUSH
68288: LD_INT 2
68290: NEG
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68317: LD_ADDR_VAR 0 23
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: LD_INT 1
68337: NEG
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 1
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: LD_INT 1
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 1
68375: NEG
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 1
68386: NEG
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 2
68402: NEG
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 1
68421: PUSH
68422: LD_INT 1
68424: NEG
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: PUSH
68433: LD_INT 0
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 2
68442: PUSH
68443: LD_INT 1
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 2
68452: PUSH
68453: LD_INT 2
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 1
68462: PUSH
68463: LD_INT 2
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 0
68472: PUSH
68473: LD_INT 2
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 1
68482: NEG
68483: PUSH
68484: LD_INT 1
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 2
68493: NEG
68494: PUSH
68495: LD_INT 0
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 2
68504: NEG
68505: PUSH
68506: LD_INT 1
68508: NEG
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 2
68516: NEG
68517: PUSH
68518: LD_INT 2
68520: NEG
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 2
68528: NEG
68529: PUSH
68530: LD_INT 3
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: LD_INT 3
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 1
68552: PUSH
68553: LD_INT 2
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 2
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68597: LD_ADDR_VAR 0 24
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 1
68625: PUSH
68626: LD_INT 0
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: LD_INT 1
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 0
68645: PUSH
68646: LD_INT 1
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: NEG
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 1
68666: NEG
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: NEG
68679: PUSH
68680: LD_INT 2
68682: NEG
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 0
68690: PUSH
68691: LD_INT 2
68693: NEG
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 1
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 2
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 2
68722: PUSH
68723: LD_INT 1
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 2
68732: PUSH
68733: LD_INT 2
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: LD_INT 2
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 0
68752: PUSH
68753: LD_INT 2
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: LD_INT 1
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: LD_INT 0
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 2
68784: NEG
68785: PUSH
68786: LD_INT 1
68788: NEG
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 2
68796: NEG
68797: PUSH
68798: LD_INT 2
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: LD_INT 2
68811: NEG
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 2
68819: PUSH
68820: LD_INT 1
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 3
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 3
68840: PUSH
68841: LD_INT 2
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68873: LD_ADDR_VAR 0 25
68877: PUSH
68878: LD_INT 0
68880: PUSH
68881: LD_INT 0
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 0
68890: PUSH
68891: LD_INT 1
68893: NEG
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 1
68901: PUSH
68902: LD_INT 0
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: LD_INT 1
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 0
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 1
68931: NEG
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 1
68942: NEG
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 1
68954: NEG
68955: PUSH
68956: LD_INT 2
68958: NEG
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 2
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: PUSH
68978: LD_INT 1
68980: NEG
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 2
68988: PUSH
68989: LD_INT 0
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 2
68998: PUSH
68999: LD_INT 1
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PUSH
69006: LD_INT 2
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: LD_INT 2
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: LD_INT 1
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: LD_INT 2
69049: NEG
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 2
69060: NEG
69061: PUSH
69062: LD_INT 1
69064: NEG
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: LD_INT 2
69072: NEG
69073: PUSH
69074: LD_INT 2
69076: NEG
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 3
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 3
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 2
69104: PUSH
69105: LD_INT 3
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: LD_INT 3
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69147: LD_ADDR_VAR 0 26
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 0
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: LD_INT 0
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 1
69185: PUSH
69186: LD_INT 1
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: LD_INT 1
69205: NEG
69206: PUSH
69207: LD_INT 0
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: LD_INT 2
69232: NEG
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: LD_INT 2
69243: NEG
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 1
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 2
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 2
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 2
69282: PUSH
69283: LD_INT 2
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: PUSH
69293: LD_INT 2
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 0
69302: PUSH
69303: LD_INT 2
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: LD_INT 1
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 2
69323: NEG
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: LD_INT 1
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 2
69346: NEG
69347: PUSH
69348: LD_INT 2
69350: NEG
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 2
69358: PUSH
69359: LD_INT 3
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: PUSH
69369: LD_INT 3
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 2
69389: NEG
69390: PUSH
69391: LD_INT 1
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69423: LD_ADDR_VAR 0 27
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 0
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: LD_INT 0
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 1
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 1
69504: NEG
69505: PUSH
69506: LD_INT 2
69508: NEG
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 0
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 1
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 2
69548: PUSH
69549: LD_INT 1
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: LD_INT 2
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: LD_INT 2
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: LD_INT 2
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 1
69588: NEG
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: NEG
69600: PUSH
69601: LD_INT 0
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 2
69622: NEG
69623: PUSH
69624: LD_INT 2
69626: NEG
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 1
69634: NEG
69635: PUSH
69636: LD_INT 2
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 2
69645: NEG
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 3
69656: NEG
69657: PUSH
69658: LD_INT 1
69660: NEG
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 3
69668: NEG
69669: PUSH
69670: LD_INT 2
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69703: LD_ADDR_VAR 0 28
69707: PUSH
69708: LD_INT 0
69710: PUSH
69711: LD_INT 0
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 0
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: LD_INT 0
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 1
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 1
69772: NEG
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: NEG
69785: PUSH
69786: LD_INT 2
69788: NEG
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: LD_INT 1
69810: NEG
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: PUSH
69829: LD_INT 1
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: LD_INT 2
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: LD_INT 2
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: LD_INT 1
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 2
69879: NEG
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 2
69890: NEG
69891: PUSH
69892: LD_INT 1
69894: NEG
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 2
69902: NEG
69903: PUSH
69904: LD_INT 2
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 2
69914: NEG
69915: PUSH
69916: LD_INT 3
69918: NEG
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 1
69926: NEG
69927: PUSH
69928: LD_INT 3
69930: NEG
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 3
69938: NEG
69939: PUSH
69940: LD_INT 1
69942: NEG
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 3
69950: NEG
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69985: LD_ADDR_VAR 0 29
69989: PUSH
69990: LD_INT 0
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 0
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 1
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: LD_INT 1
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: PUSH
70031: LD_INT 0
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 1
70043: NEG
70044: PUSH
70045: LD_INT 0
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: PUSH
70068: LD_INT 2
70070: NEG
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: LD_INT 2
70081: NEG
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 2
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 2
70110: PUSH
70111: LD_INT 1
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 1
70120: PUSH
70121: LD_INT 2
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 0
70130: PUSH
70131: LD_INT 2
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: PUSH
70138: LD_INT 1
70140: NEG
70141: PUSH
70142: LD_INT 1
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 2
70151: NEG
70152: PUSH
70153: LD_INT 1
70155: NEG
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 2
70163: NEG
70164: PUSH
70165: LD_INT 2
70167: NEG
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: LD_INT 3
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 2
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 3
70198: PUSH
70199: LD_INT 1
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: LD_INT 3
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 3
70229: NEG
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70264: LD_ADDR_VAR 0 30
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: LD_INT 0
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 1
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 1
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: NEG
70346: PUSH
70347: LD_INT 2
70349: NEG
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: LD_INT 2
70360: NEG
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: LD_INT 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: LD_INT 2
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: LD_INT 2
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 2
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: LD_INT 3
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: LD_INT 2
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 3
70476: PUSH
70477: LD_INT 2
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: LD_INT 3
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 2
70496: NEG
70497: PUSH
70498: LD_INT 1
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 3
70507: NEG
70508: PUSH
70509: LD_INT 1
70511: NEG
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70542: LD_ADDR_VAR 0 31
70546: PUSH
70547: LD_INT 0
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 0
70559: PUSH
70560: LD_INT 1
70562: NEG
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 1
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 0
70590: PUSH
70591: LD_INT 1
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 1
70600: NEG
70601: PUSH
70602: LD_INT 0
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 1
70611: NEG
70612: PUSH
70613: LD_INT 1
70615: NEG
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: LD_INT 2
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 1
70635: PUSH
70636: LD_INT 1
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 2
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 2
70666: PUSH
70667: LD_INT 2
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: LD_INT 2
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: LD_INT 2
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 1
70696: NEG
70697: PUSH
70698: LD_INT 1
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 2
70723: NEG
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 2
70731: NEG
70732: PUSH
70733: LD_INT 3
70735: NEG
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 2
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 3
70754: PUSH
70755: LD_INT 1
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 1
70764: PUSH
70765: LD_INT 3
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 1
70774: NEG
70775: PUSH
70776: LD_INT 2
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 3
70785: NEG
70786: PUSH
70787: LD_INT 2
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70820: LD_ADDR_VAR 0 32
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: LD_INT 0
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 0
70837: PUSH
70838: LD_INT 1
70840: NEG
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: LD_INT 0
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: LD_INT 1
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 0
70868: PUSH
70869: LD_INT 1
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 1
70878: NEG
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 1
70889: NEG
70890: PUSH
70891: LD_INT 1
70893: NEG
70894: PUSH
70895: EMPTY
70896: LIST
70897: LIST
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 0
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PUSH
70922: LD_INT 1
70924: PUSH
70925: LD_INT 1
70927: NEG
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: PUSH
70936: LD_INT 1
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 2
70945: PUSH
70946: LD_INT 2
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 1
70955: PUSH
70956: LD_INT 2
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 0
70965: PUSH
70966: LD_INT 2
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 2
70986: NEG
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 2
70997: NEG
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: NEG
71010: PUSH
71011: LD_INT 3
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: LD_INT 2
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: PUSH
71043: LD_INT 3
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 2
71052: NEG
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 3
71063: NEG
71064: PUSH
71065: LD_INT 1
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71098: LD_ADDR_VAR 0 33
71102: PUSH
71103: LD_INT 0
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: LD_INT 1
71118: NEG
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 1
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 1
71136: PUSH
71137: LD_INT 1
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 0
71146: PUSH
71147: LD_INT 1
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 1
71156: NEG
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 1
71167: NEG
71168: PUSH
71169: LD_INT 1
71171: NEG
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 1
71179: NEG
71180: PUSH
71181: LD_INT 2
71183: NEG
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: LD_INT 1
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: PUSH
71223: LD_INT 2
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: LD_INT 2
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 1
71242: NEG
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 2
71253: NEG
71254: PUSH
71255: LD_INT 0
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: LD_INT 1
71268: NEG
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: LD_INT 2
71276: NEG
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: LD_INT 3
71292: NEG
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 3
71311: PUSH
71312: LD_INT 1
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 1
71321: PUSH
71322: LD_INT 3
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 1
71331: NEG
71332: PUSH
71333: LD_INT 2
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 3
71342: NEG
71343: PUSH
71344: LD_INT 2
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71377: LD_ADDR_VAR 0 34
71381: PUSH
71382: LD_INT 0
71384: PUSH
71385: LD_INT 0
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 0
71394: PUSH
71395: LD_INT 1
71397: NEG
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 1
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: LD_INT 1
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: LD_INT 1
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: LD_INT 1
71435: NEG
71436: PUSH
71437: LD_INT 0
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 1
71446: NEG
71447: PUSH
71448: LD_INT 1
71450: NEG
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: LD_INT 2
71462: NEG
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 0
71470: PUSH
71471: LD_INT 2
71473: NEG
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 1
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 2
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 2
71502: PUSH
71503: LD_INT 2
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 1
71512: PUSH
71513: LD_INT 2
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 2
71533: NEG
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 2
71544: NEG
71545: PUSH
71546: LD_INT 1
71548: NEG
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 2
71556: NEG
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: NEG
71569: PUSH
71570: LD_INT 3
71572: NEG
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: LD_INT 2
71583: NEG
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 3
71591: PUSH
71592: LD_INT 2
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 2
71601: PUSH
71602: LD_INT 3
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 2
71611: NEG
71612: PUSH
71613: LD_INT 1
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 3
71622: NEG
71623: PUSH
71624: LD_INT 1
71626: NEG
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71657: LD_ADDR_VAR 0 35
71661: PUSH
71662: LD_INT 0
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: LD_INT 1
71677: NEG
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: LD_INT 0
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 1
71715: NEG
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 1
71726: NEG
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 2
71738: PUSH
71739: LD_INT 1
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 2
71748: NEG
71749: PUSH
71750: LD_INT 1
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71769: LD_ADDR_VAR 0 36
71773: PUSH
71774: LD_INT 0
71776: PUSH
71777: LD_INT 0
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: LD_INT 1
71789: NEG
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: PUSH
71808: LD_INT 1
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 0
71817: PUSH
71818: LD_INT 1
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 1
71827: NEG
71828: PUSH
71829: LD_INT 0
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: NEG
71839: PUSH
71840: LD_INT 1
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 2
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: PUSH
71863: LD_INT 2
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71881: LD_ADDR_VAR 0 37
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 1
71939: NEG
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: LD_INT 1
71965: NEG
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71993: LD_ADDR_VAR 0 38
71997: PUSH
71998: LD_INT 0
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 0
72010: PUSH
72011: LD_INT 1
72013: NEG
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 1
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: LD_INT 1
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: LD_INT 1
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 1
72051: NEG
72052: PUSH
72053: LD_INT 0
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 1
72062: NEG
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 2
72084: NEG
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72105: LD_ADDR_VAR 0 39
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: LD_INT 0
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 0
72122: PUSH
72123: LD_INT 1
72125: NEG
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: LD_INT 1
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: LD_INT 1
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 1
72163: NEG
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: LD_INT 1
72174: NEG
72175: PUSH
72176: LD_INT 1
72178: NEG
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: LD_INT 2
72190: NEG
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 1
72198: PUSH
72199: LD_INT 2
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72217: LD_ADDR_VAR 0 40
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: LD_INT 1
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 1
72275: NEG
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: LD_INT 1
72301: NEG
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72329: LD_ADDR_VAR 0 41
72333: PUSH
72334: LD_INT 0
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 1
72349: NEG
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 0
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 1
72398: NEG
72399: PUSH
72400: LD_INT 1
72402: NEG
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 1
72410: NEG
72411: PUSH
72412: LD_INT 2
72414: NEG
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: LD_INT 1
72425: NEG
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 2
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 2
72443: PUSH
72444: LD_INT 1
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 2
72453: PUSH
72454: LD_INT 2
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: LD_INT 2
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 2
72484: NEG
72485: PUSH
72486: LD_INT 0
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 2
72495: NEG
72496: PUSH
72497: LD_INT 1
72499: NEG
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 2
72507: NEG
72508: PUSH
72509: LD_INT 2
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 2
72519: NEG
72520: PUSH
72521: LD_INT 3
72523: NEG
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 2
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 3
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 3
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 3
72562: PUSH
72563: LD_INT 2
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 3
72572: PUSH
72573: LD_INT 3
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: PUSH
72583: LD_INT 3
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 2
72592: NEG
72593: PUSH
72594: LD_INT 1
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 3
72603: NEG
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 3
72614: NEG
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 3
72626: NEG
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 3
72638: NEG
72639: PUSH
72640: LD_INT 3
72642: NEG
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72679: LD_ADDR_VAR 0 42
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: NEG
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: LD_INT 2
72764: NEG
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: LD_INT 2
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 2
72794: PUSH
72795: LD_INT 1
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 2
72804: PUSH
72805: LD_INT 2
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 1
72814: PUSH
72815: LD_INT 2
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 0
72824: PUSH
72825: LD_INT 2
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 1
72834: NEG
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 2
72845: NEG
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 2
72857: NEG
72858: PUSH
72859: LD_INT 2
72861: NEG
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 3
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: LD_INT 3
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 0
72893: PUSH
72894: LD_INT 3
72896: NEG
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 1
72904: PUSH
72905: LD_INT 2
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 3
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 3
72925: PUSH
72926: LD_INT 3
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 2
72935: PUSH
72936: LD_INT 3
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: LD_INT 3
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 3
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 1
72965: NEG
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 3
72976: NEG
72977: PUSH
72978: LD_INT 2
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 3
72988: NEG
72989: PUSH
72990: LD_INT 3
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73029: LD_ADDR_VAR 0 43
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: LD_INT 1
73049: NEG
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 0
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: LD_INT 1
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 1
73087: NEG
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: LD_INT 1
73102: NEG
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: LD_INT 2
73114: NEG
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: LD_INT 2
73125: NEG
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 1
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 2
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 2
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 1
73164: PUSH
73165: LD_INT 2
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 0
73174: PUSH
73175: LD_INT 2
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 1
73184: NEG
73185: PUSH
73186: LD_INT 1
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 2
73195: NEG
73196: PUSH
73197: LD_INT 0
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 2
73206: NEG
73207: PUSH
73208: LD_INT 1
73210: NEG
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: LD_INT 3
73222: NEG
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 0
73230: PUSH
73231: LD_INT 3
73233: NEG
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 2
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 3
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 3
73273: PUSH
73274: LD_INT 1
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: LD_INT 3
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: LD_INT 3
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 2
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 3
73325: NEG
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 3
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73377: LD_ADDR_VAR 0 44
73381: PUSH
73382: LD_INT 0
73384: PUSH
73385: LD_INT 0
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 0
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 1
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: LD_INT 1
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: LD_INT 1
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: LD_INT 0
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 1
73446: NEG
73447: PUSH
73448: LD_INT 1
73450: NEG
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: LD_INT 2
73462: NEG
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 1
73470: PUSH
73471: LD_INT 1
73473: NEG
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 2
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: PUSH
73492: LD_INT 1
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 2
73501: PUSH
73502: LD_INT 2
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 1
73521: NEG
73522: PUSH
73523: LD_INT 1
73525: PUSH
73526: EMPTY
73527: LIST
73528: LIST
73529: PUSH
73530: LD_INT 2
73532: NEG
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 2
73543: NEG
73544: PUSH
73545: LD_INT 1
73547: NEG
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 2
73555: NEG
73556: PUSH
73557: LD_INT 2
73559: NEG
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 2
73567: NEG
73568: PUSH
73569: LD_INT 3
73571: NEG
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 2
73579: PUSH
73580: LD_INT 1
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 3
73590: PUSH
73591: LD_INT 0
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 3
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 3
73610: PUSH
73611: LD_INT 2
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 3
73620: PUSH
73621: LD_INT 3
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 2
73630: PUSH
73631: LD_INT 3
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 2
73640: NEG
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 3
73651: NEG
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 3
73662: NEG
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 3
73674: NEG
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 3
73686: NEG
73687: PUSH
73688: LD_INT 3
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73727: LD_ADDR_VAR 0 45
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: LD_INT 1
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 1
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 1
73785: NEG
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: NEG
73809: PUSH
73810: LD_INT 2
73812: NEG
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: LD_INT 2
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 2
73842: PUSH
73843: LD_INT 1
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 2
73852: PUSH
73853: LD_INT 2
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 1
73862: PUSH
73863: LD_INT 2
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 0
73872: PUSH
73873: LD_INT 2
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: NEG
73883: PUSH
73884: LD_INT 1
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: NEG
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 2
73905: NEG
73906: PUSH
73907: LD_INT 2
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: LD_INT 3
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: LD_INT 3
73933: NEG
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 0
73941: PUSH
73942: LD_INT 3
73944: NEG
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 3
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 3
73973: PUSH
73974: LD_INT 3
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 2
73983: PUSH
73984: LD_INT 3
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 1
73993: PUSH
73994: LD_INT 3
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: LD_INT 3
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: NEG
74014: PUSH
74015: LD_INT 2
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 3
74024: NEG
74025: PUSH
74026: LD_INT 2
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 3
74036: NEG
74037: PUSH
74038: LD_INT 3
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74077: LD_ADDR_VAR 0 46
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 1
74105: PUSH
74106: LD_INT 0
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 1
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: NEG
74147: PUSH
74148: LD_INT 1
74150: NEG
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: NEG
74159: PUSH
74160: LD_INT 2
74162: NEG
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 1
74181: PUSH
74182: LD_INT 1
74184: NEG
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 2
74192: PUSH
74193: LD_INT 0
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 2
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 2
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: NEG
74233: PUSH
74234: LD_INT 1
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 2
74243: NEG
74244: PUSH
74245: LD_INT 0
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 2
74254: NEG
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: LD_INT 3
74270: NEG
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 0
74278: PUSH
74279: LD_INT 3
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 2
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 3
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 3
74321: PUSH
74322: LD_INT 1
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 3
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: LD_INT 3
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: LD_INT 2
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 2
74362: NEG
74363: PUSH
74364: LD_INT 1
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 3
74373: NEG
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 3
74384: NEG
74385: PUSH
74386: LD_INT 1
74388: NEG
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74425: LD_ADDR_VAR 0 47
74429: PUSH
74430: LD_INT 0
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 0
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 1
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 1
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 0
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: LD_INT 1
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 1
74506: NEG
74507: PUSH
74508: LD_INT 2
74510: NEG
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 0
74518: PUSH
74519: LD_INT 2
74521: NEG
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 1
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 2
74540: NEG
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 2
74552: NEG
74553: PUSH
74554: LD_INT 2
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74576: LD_ADDR_VAR 0 48
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: LD_INT 1
74596: NEG
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 0
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 1
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 0
74624: PUSH
74625: LD_INT 1
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: LD_INT 0
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: NEG
74646: PUSH
74647: LD_INT 1
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: NEG
74658: PUSH
74659: LD_INT 2
74661: NEG
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 0
74669: PUSH
74670: LD_INT 2
74672: NEG
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: LD_INT 1
74683: NEG
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 2
74691: PUSH
74692: LD_INT 0
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: LD_INT 1
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: LIST
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: LIST
74722: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74723: LD_ADDR_VAR 0 49
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: PUSH
74752: LD_INT 0
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 1
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 1
74792: NEG
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 1
74804: PUSH
74805: LD_INT 1
74807: NEG
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 2
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 2
74825: PUSH
74826: LD_INT 1
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 2
74835: PUSH
74836: LD_INT 2
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: LD_INT 2
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74867: LD_ADDR_VAR 0 50
74871: PUSH
74872: LD_INT 0
74874: PUSH
74875: LD_INT 0
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 0
74884: PUSH
74885: LD_INT 1
74887: NEG
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 1
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: LD_INT 1
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: LD_INT 1
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 1
74925: NEG
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 1
74936: NEG
74937: PUSH
74938: LD_INT 1
74940: NEG
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 2
74948: PUSH
74949: LD_INT 1
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: LD_INT 2
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 2
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: LD_INT 2
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75011: LD_ADDR_VAR 0 51
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: LD_INT 0
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: LD_INT 1
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: LD_INT 1
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 1
75069: NEG
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 1
75080: NEG
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 1
75092: PUSH
75093: LD_INT 2
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 0
75102: PUSH
75103: LD_INT 2
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: LD_INT 1
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 2
75123: NEG
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 2
75134: NEG
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75158: LD_ADDR_VAR 0 52
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 1
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 0
75206: PUSH
75207: LD_INT 1
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 1
75216: NEG
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: LD_INT 1
75231: NEG
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 1
75239: NEG
75240: PUSH
75241: LD_INT 2
75243: NEG
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 2
75262: NEG
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: LD_INT 1
75277: NEG
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 2
75285: NEG
75286: PUSH
75287: LD_INT 2
75289: NEG
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: LIST
75299: LIST
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75309: LD_ADDR_VAR 0 53
75313: PUSH
75314: LD_INT 0
75316: PUSH
75317: LD_INT 0
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: LD_INT 1
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: PUSH
75338: LD_INT 0
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 1
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 1
75367: NEG
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 1
75378: NEG
75379: PUSH
75380: LD_INT 1
75382: NEG
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: LD_INT 2
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: LD_INT 2
75405: NEG
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: LD_INT 1
75416: NEG
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 2
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 2
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 2
75444: PUSH
75445: LD_INT 2
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 2
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 0
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 1
75474: NEG
75475: PUSH
75476: LD_INT 1
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 2
75485: NEG
75486: PUSH
75487: LD_INT 0
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 2
75496: NEG
75497: PUSH
75498: LD_INT 1
75500: NEG
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 2
75508: NEG
75509: PUSH
75510: LD_INT 2
75512: NEG
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75539: LD_ADDR_VAR 0 54
75543: PUSH
75544: LD_INT 0
75546: PUSH
75547: LD_INT 0
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 1
75559: NEG
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 1
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: PUSH
75578: LD_INT 1
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 1
75597: NEG
75598: PUSH
75599: LD_INT 0
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 1
75608: NEG
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 2
75624: NEG
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: LD_INT 2
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: PUSH
75644: LD_INT 1
75646: NEG
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 2
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: LD_INT 1
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 2
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 1
75684: PUSH
75685: LD_INT 2
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 0
75694: PUSH
75695: LD_INT 2
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 1
75704: NEG
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 2
75715: NEG
75716: PUSH
75717: LD_INT 0
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: LD_INT 2
75726: NEG
75727: PUSH
75728: LD_INT 1
75730: NEG
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 2
75738: NEG
75739: PUSH
75740: LD_INT 2
75742: NEG
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75769: LD_ADDR_VAR 0 55
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: PUSH
75798: LD_INT 0
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: LD_INT 1
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: NEG
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: LD_INT 2
75865: NEG
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: LD_INT 1
75873: PUSH
75874: LD_INT 1
75876: NEG
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 2
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 2
75894: PUSH
75895: LD_INT 1
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 2
75904: PUSH
75905: LD_INT 2
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 1
75914: PUSH
75915: LD_INT 2
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 0
75924: PUSH
75925: LD_INT 2
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 1
75934: NEG
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 2
75945: NEG
75946: PUSH
75947: LD_INT 0
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 2
75968: NEG
75969: PUSH
75970: LD_INT 2
75972: NEG
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75999: LD_ADDR_VAR 0 56
76003: PUSH
76004: LD_INT 0
76006: PUSH
76007: LD_INT 0
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 1
76027: PUSH
76028: LD_INT 0
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 1
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: LD_INT 1
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 1
76057: NEG
76058: PUSH
76059: LD_INT 0
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: LD_INT 1
76068: NEG
76069: PUSH
76070: LD_INT 1
76072: NEG
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: LD_INT 1
76080: NEG
76081: PUSH
76082: LD_INT 2
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: LD_INT 2
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: PUSH
76104: LD_INT 1
76106: NEG
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 2
76114: PUSH
76115: LD_INT 0
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 2
76124: PUSH
76125: LD_INT 1
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 2
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 1
76144: PUSH
76145: LD_INT 2
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 0
76154: PUSH
76155: LD_INT 2
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 1
76164: NEG
76165: PUSH
76166: LD_INT 1
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 2
76175: NEG
76176: PUSH
76177: LD_INT 0
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 2
76186: NEG
76187: PUSH
76188: LD_INT 1
76190: NEG
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 2
76198: NEG
76199: PUSH
76200: LD_INT 2
76202: NEG
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76229: LD_ADDR_VAR 0 57
76233: PUSH
76234: LD_INT 0
76236: PUSH
76237: LD_INT 0
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: LD_INT 0
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 1
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: LD_INT 1
76302: NEG
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 1
76310: NEG
76311: PUSH
76312: LD_INT 2
76314: NEG
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: LD_INT 2
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 1
76333: PUSH
76334: LD_INT 1
76336: NEG
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: LD_INT 2
76344: PUSH
76345: LD_INT 0
76347: PUSH
76348: EMPTY
76349: LIST
76350: LIST
76351: PUSH
76352: LD_INT 2
76354: PUSH
76355: LD_INT 1
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: PUSH
76362: LD_INT 2
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: PUSH
76375: LD_INT 2
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 0
76384: PUSH
76385: LD_INT 2
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 1
76394: NEG
76395: PUSH
76396: LD_INT 1
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 2
76405: NEG
76406: PUSH
76407: LD_INT 0
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 2
76416: NEG
76417: PUSH
76418: LD_INT 1
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76459: LD_ADDR_VAR 0 58
76463: PUSH
76464: LD_INT 0
76466: PUSH
76467: LD_INT 0
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: LD_INT 1
76479: NEG
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PUSH
76485: LD_INT 1
76487: PUSH
76488: LD_INT 0
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 1
76497: PUSH
76498: LD_INT 1
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 0
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 1
76517: NEG
76518: PUSH
76519: LD_INT 0
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 1
76528: NEG
76529: PUSH
76530: LD_INT 1
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: NEG
76541: PUSH
76542: LD_INT 2
76544: NEG
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: LD_INT 2
76555: NEG
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 1
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 2
76584: PUSH
76585: LD_INT 1
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 2
76594: PUSH
76595: LD_INT 2
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 1
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 0
76614: PUSH
76615: LD_INT 2
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: NEG
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 2
76635: NEG
76636: PUSH
76637: LD_INT 0
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 2
76646: NEG
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 2
76658: NEG
76659: PUSH
76660: LD_INT 2
76662: NEG
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76689: LD_ADDR_VAR 0 59
76693: PUSH
76694: LD_INT 0
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: LD_INT 0
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 1
76727: PUSH
76728: LD_INT 1
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 0
76737: PUSH
76738: LD_INT 1
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 1
76747: NEG
76748: PUSH
76749: LD_INT 0
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 1
76758: NEG
76759: PUSH
76760: LD_INT 1
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76777: LD_ADDR_VAR 0 60
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: LD_INT 0
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 0
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 0
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 1
76835: NEG
76836: PUSH
76837: LD_INT 0
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 1
76846: NEG
76847: PUSH
76848: LD_INT 1
76850: NEG
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76865: LD_ADDR_VAR 0 61
76869: PUSH
76870: LD_INT 0
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: LD_INT 1
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 1
76893: PUSH
76894: LD_INT 0
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: LD_INT 1
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 0
76913: PUSH
76914: LD_INT 1
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 1
76923: NEG
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 1
76934: NEG
76935: PUSH
76936: LD_INT 1
76938: NEG
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76953: LD_ADDR_VAR 0 62
76957: PUSH
76958: LD_INT 0
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: LD_INT 1
76973: NEG
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 1
76981: PUSH
76982: LD_INT 0
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: LD_INT 1
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: LD_INT 1
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 1
77011: NEG
77012: PUSH
77013: LD_INT 0
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: NEG
77023: PUSH
77024: LD_INT 1
77026: NEG
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77041: LD_ADDR_VAR 0 63
77045: PUSH
77046: LD_INT 0
77048: PUSH
77049: LD_INT 0
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 0
77058: PUSH
77059: LD_INT 1
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: PUSH
77070: LD_INT 0
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 1
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: LD_INT 1
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 1
77099: NEG
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 1
77110: NEG
77111: PUSH
77112: LD_INT 1
77114: NEG
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77129: LD_ADDR_VAR 0 64
77133: PUSH
77134: LD_INT 0
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 0
77146: PUSH
77147: LD_INT 1
77149: NEG
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 1
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: LD_INT 1
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: LD_INT 1
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 1
77187: NEG
77188: PUSH
77189: LD_INT 0
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: LD_INT 1
77202: NEG
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: ST_TO_ADDR
// end ; 1 :
77217: GO 83114
77219: LD_INT 1
77221: DOUBLE
77222: EQUAL
77223: IFTRUE 77227
77225: GO 79850
77227: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77228: LD_ADDR_VAR 0 11
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: LD_INT 3
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: LD_INT 3
77250: NEG
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: LD_INT 2
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: LIST
77271: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77272: LD_ADDR_VAR 0 12
77276: PUSH
77277: LD_INT 2
77279: PUSH
77280: LD_INT 1
77282: NEG
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 3
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: LIST
77312: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77313: LD_ADDR_VAR 0 13
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: LD_INT 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 3
77330: PUSH
77331: LD_INT 3
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 2
77340: PUSH
77341: LD_INT 3
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: LIST
77352: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77353: LD_ADDR_VAR 0 14
77357: PUSH
77358: LD_INT 1
77360: PUSH
77361: LD_INT 3
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 0
77370: PUSH
77371: LD_INT 3
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 1
77380: NEG
77381: PUSH
77382: LD_INT 2
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: LIST
77393: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77394: LD_ADDR_VAR 0 15
77398: PUSH
77399: LD_INT 2
77401: NEG
77402: PUSH
77403: LD_INT 1
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 3
77412: NEG
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 3
77423: NEG
77424: PUSH
77425: LD_INT 1
77427: NEG
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: LIST
77437: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77438: LD_ADDR_VAR 0 16
77442: PUSH
77443: LD_INT 2
77445: NEG
77446: PUSH
77447: LD_INT 3
77449: NEG
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 3
77457: NEG
77458: PUSH
77459: LD_INT 2
77461: NEG
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 3
77469: NEG
77470: PUSH
77471: LD_INT 3
77473: NEG
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: LIST
77483: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77484: LD_ADDR_VAR 0 17
77488: PUSH
77489: LD_INT 1
77491: NEG
77492: PUSH
77493: LD_INT 3
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 3
77506: NEG
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: LD_INT 2
77517: NEG
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: LIST
77527: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77528: LD_ADDR_VAR 0 18
77532: PUSH
77533: LD_INT 2
77535: PUSH
77536: LD_INT 1
77538: NEG
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 3
77546: PUSH
77547: LD_INT 0
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 3
77556: PUSH
77557: LD_INT 1
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: LIST
77568: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77569: LD_ADDR_VAR 0 19
77573: PUSH
77574: LD_INT 3
77576: PUSH
77577: LD_INT 2
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 3
77586: PUSH
77587: LD_INT 3
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 2
77596: PUSH
77597: LD_INT 3
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: LIST
77608: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77609: LD_ADDR_VAR 0 20
77613: PUSH
77614: LD_INT 1
77616: PUSH
77617: LD_INT 3
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: LD_INT 3
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 1
77636: NEG
77637: PUSH
77638: LD_INT 2
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: LIST
77649: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77650: LD_ADDR_VAR 0 21
77654: PUSH
77655: LD_INT 2
77657: NEG
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 3
77668: NEG
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 3
77679: NEG
77680: PUSH
77681: LD_INT 1
77683: NEG
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: LIST
77693: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77694: LD_ADDR_VAR 0 22
77698: PUSH
77699: LD_INT 2
77701: NEG
77702: PUSH
77703: LD_INT 3
77705: NEG
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 3
77713: NEG
77714: PUSH
77715: LD_INT 2
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 3
77725: NEG
77726: PUSH
77727: LD_INT 3
77729: NEG
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: LIST
77739: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77740: LD_ADDR_VAR 0 23
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 3
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: NEG
77759: PUSH
77760: LD_INT 4
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 1
77770: PUSH
77771: LD_INT 3
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: LIST
77783: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77784: LD_ADDR_VAR 0 24
77788: PUSH
77789: LD_INT 3
77791: PUSH
77792: LD_INT 0
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 3
77801: PUSH
77802: LD_INT 1
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 4
77812: PUSH
77813: LD_INT 1
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: LIST
77824: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77825: LD_ADDR_VAR 0 25
77829: PUSH
77830: LD_INT 3
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 4
77842: PUSH
77843: LD_INT 3
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 3
77852: PUSH
77853: LD_INT 4
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: LIST
77864: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77865: LD_ADDR_VAR 0 26
77869: PUSH
77870: LD_INT 0
77872: PUSH
77873: LD_INT 3
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 1
77882: PUSH
77883: LD_INT 4
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 3
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: LIST
77905: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77906: LD_ADDR_VAR 0 27
77910: PUSH
77911: LD_INT 3
77913: NEG
77914: PUSH
77915: LD_INT 0
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: LD_INT 1
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 4
77935: NEG
77936: PUSH
77937: LD_INT 1
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: LIST
77949: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77950: LD_ADDR_VAR 0 28
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: LD_INT 4
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 4
77981: NEG
77982: PUSH
77983: LD_INT 3
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: LIST
77995: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77996: LD_ADDR_VAR 0 29
78000: PUSH
78001: LD_INT 1
78003: NEG
78004: PUSH
78005: LD_INT 3
78007: NEG
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 0
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PUSH
78024: LD_INT 1
78026: PUSH
78027: LD_INT 2
78029: NEG
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: LD_INT 1
78037: NEG
78038: PUSH
78039: LD_INT 4
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: LD_INT 4
78052: NEG
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: LD_INT 3
78063: NEG
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 1
78071: NEG
78072: PUSH
78073: LD_INT 5
78075: NEG
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 0
78083: PUSH
78084: LD_INT 5
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: LD_INT 4
78097: NEG
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 1
78105: NEG
78106: PUSH
78107: LD_INT 6
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: LD_INT 6
78120: NEG
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: LD_INT 5
78131: NEG
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78151: LD_ADDR_VAR 0 30
78155: PUSH
78156: LD_INT 2
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 3
78169: PUSH
78170: LD_INT 0
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 3
78179: PUSH
78180: LD_INT 1
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 3
78189: PUSH
78190: LD_INT 1
78192: NEG
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: LD_INT 4
78200: PUSH
78201: LD_INT 0
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 4
78210: PUSH
78211: LD_INT 1
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 4
78220: PUSH
78221: LD_INT 1
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 5
78231: PUSH
78232: LD_INT 0
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 5
78241: PUSH
78242: LD_INT 1
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 5
78251: PUSH
78252: LD_INT 1
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 6
78262: PUSH
78263: LD_INT 0
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 6
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78294: LD_ADDR_VAR 0 31
78298: PUSH
78299: LD_INT 3
78301: PUSH
78302: LD_INT 2
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 3
78311: PUSH
78312: LD_INT 3
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 2
78321: PUSH
78322: LD_INT 3
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 4
78331: PUSH
78332: LD_INT 3
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 4
78341: PUSH
78342: LD_INT 4
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 3
78351: PUSH
78352: LD_INT 4
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 5
78361: PUSH
78362: LD_INT 4
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 5
78371: PUSH
78372: LD_INT 5
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 4
78381: PUSH
78382: LD_INT 5
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 6
78391: PUSH
78392: LD_INT 5
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 6
78401: PUSH
78402: LD_INT 6
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 5
78411: PUSH
78412: LD_INT 6
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78433: LD_ADDR_VAR 0 32
78437: PUSH
78438: LD_INT 1
78440: PUSH
78441: LD_INT 3
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: LD_INT 3
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 1
78460: NEG
78461: PUSH
78462: LD_INT 2
78464: PUSH
78465: EMPTY
78466: LIST
78467: LIST
78468: PUSH
78469: LD_INT 1
78471: PUSH
78472: LD_INT 4
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 0
78481: PUSH
78482: LD_INT 4
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: LD_INT 5
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: LD_INT 5
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: LD_INT 4
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 1
78533: PUSH
78534: LD_INT 6
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 0
78543: PUSH
78544: LD_INT 6
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: LD_INT 5
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: LIST
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78576: LD_ADDR_VAR 0 33
78580: PUSH
78581: LD_INT 2
78583: NEG
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 3
78594: NEG
78595: PUSH
78596: LD_INT 0
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 3
78605: NEG
78606: PUSH
78607: LD_INT 1
78609: NEG
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 3
78617: NEG
78618: PUSH
78619: LD_INT 1
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 4
78628: NEG
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 4
78639: NEG
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 4
78651: NEG
78652: PUSH
78653: LD_INT 1
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 5
78662: NEG
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 5
78673: NEG
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 5
78685: NEG
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 6
78696: NEG
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 6
78707: NEG
78708: PUSH
78709: LD_INT 1
78711: NEG
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78731: LD_ADDR_VAR 0 34
78735: PUSH
78736: LD_INT 2
78738: NEG
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 3
78750: NEG
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: LD_INT 3
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: LD_INT 4
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 4
78786: NEG
78787: PUSH
78788: LD_INT 3
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 4
78798: NEG
78799: PUSH
78800: LD_INT 4
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 5
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 5
78822: NEG
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 5
78834: NEG
78835: PUSH
78836: LD_INT 5
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 5
78846: NEG
78847: PUSH
78848: LD_INT 6
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 6
78858: NEG
78859: PUSH
78860: LD_INT 5
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 6
78870: NEG
78871: PUSH
78872: LD_INT 6
78874: NEG
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78894: LD_ADDR_VAR 0 41
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: LD_INT 2
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: LD_INT 3
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: LD_INT 2
78927: NEG
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: LIST
78937: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78938: LD_ADDR_VAR 0 42
78942: PUSH
78943: LD_INT 2
78945: PUSH
78946: LD_INT 0
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 2
78955: PUSH
78956: LD_INT 1
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 3
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: LIST
78978: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78979: LD_ADDR_VAR 0 43
78983: PUSH
78984: LD_INT 2
78986: PUSH
78987: LD_INT 2
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 3
78996: PUSH
78997: LD_INT 2
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 2
79006: PUSH
79007: LD_INT 3
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: LIST
79018: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79019: LD_ADDR_VAR 0 44
79023: PUSH
79024: LD_INT 0
79026: PUSH
79027: LD_INT 2
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 1
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 1
79046: NEG
79047: PUSH
79048: LD_INT 2
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: LIST
79059: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79060: LD_ADDR_VAR 0 45
79064: PUSH
79065: LD_INT 2
79067: NEG
79068: PUSH
79069: LD_INT 0
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 2
79078: NEG
79079: PUSH
79080: LD_INT 1
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 3
79089: NEG
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: LIST
79103: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79104: LD_ADDR_VAR 0 46
79108: PUSH
79109: LD_INT 2
79111: NEG
79112: PUSH
79113: LD_INT 2
79115: NEG
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 2
79123: NEG
79124: PUSH
79125: LD_INT 3
79127: NEG
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 3
79135: NEG
79136: PUSH
79137: LD_INT 2
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: LIST
79149: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79150: LD_ADDR_VAR 0 47
79154: PUSH
79155: LD_INT 2
79157: NEG
79158: PUSH
79159: LD_INT 3
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: LD_INT 3
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79183: LD_ADDR_VAR 0 48
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: LD_INT 2
79193: NEG
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 2
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79214: LD_ADDR_VAR 0 49
79218: PUSH
79219: LD_INT 3
79221: PUSH
79222: LD_INT 1
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: PUSH
79232: LD_INT 2
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79243: LD_ADDR_VAR 0 50
79247: PUSH
79248: LD_INT 2
79250: PUSH
79251: LD_INT 3
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 3
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79272: LD_ADDR_VAR 0 51
79276: PUSH
79277: LD_INT 1
79279: NEG
79280: PUSH
79281: LD_INT 2
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 2
79290: NEG
79291: PUSH
79292: LD_INT 1
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79303: LD_ADDR_VAR 0 52
79307: PUSH
79308: LD_INT 3
79310: NEG
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 3
79322: NEG
79323: PUSH
79324: LD_INT 2
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79336: LD_ADDR_VAR 0 53
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: LD_INT 3
79347: NEG
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 0
79355: PUSH
79356: LD_INT 3
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: LD_INT 2
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: LIST
79379: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79380: LD_ADDR_VAR 0 54
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 3
79398: PUSH
79399: LD_INT 0
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 3
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: LIST
79420: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79421: LD_ADDR_VAR 0 55
79425: PUSH
79426: LD_INT 3
79428: PUSH
79429: LD_INT 2
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 3
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 2
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: LIST
79460: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79461: LD_ADDR_VAR 0 56
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 0
79478: PUSH
79479: LD_INT 3
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: NEG
79489: PUSH
79490: LD_INT 2
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: LIST
79501: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79502: LD_ADDR_VAR 0 57
79506: PUSH
79507: LD_INT 2
79509: NEG
79510: PUSH
79511: LD_INT 1
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: NEG
79521: PUSH
79522: LD_INT 0
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 3
79531: NEG
79532: PUSH
79533: LD_INT 1
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: LIST
79545: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79546: LD_ADDR_VAR 0 58
79550: PUSH
79551: LD_INT 2
79553: NEG
79554: PUSH
79555: LD_INT 3
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 3
79565: NEG
79566: PUSH
79567: LD_INT 2
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 3
79577: NEG
79578: PUSH
79579: LD_INT 3
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: LIST
79591: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79592: LD_ADDR_VAR 0 59
79596: PUSH
79597: LD_INT 1
79599: NEG
79600: PUSH
79601: LD_INT 2
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 0
79611: PUSH
79612: LD_INT 2
79614: NEG
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: LD_INT 1
79625: NEG
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: LIST
79635: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79636: LD_ADDR_VAR 0 60
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: LD_INT 1
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 2
79654: PUSH
79655: LD_INT 0
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 2
79664: PUSH
79665: LD_INT 1
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79677: LD_ADDR_VAR 0 61
79681: PUSH
79682: LD_INT 2
79684: PUSH
79685: LD_INT 1
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 2
79694: PUSH
79695: LD_INT 2
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 1
79704: PUSH
79705: LD_INT 2
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: LIST
79716: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79717: LD_ADDR_VAR 0 62
79721: PUSH
79722: LD_INT 1
79724: PUSH
79725: LD_INT 2
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 0
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 1
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: LIST
79757: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79758: LD_ADDR_VAR 0 63
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 1
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 2
79776: NEG
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 2
79787: NEG
79788: PUSH
79789: LD_INT 1
79791: NEG
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: LIST
79801: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79802: LD_ADDR_VAR 0 64
79806: PUSH
79807: LD_INT 1
79809: NEG
79810: PUSH
79811: LD_INT 2
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: NEG
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: LD_INT 2
79837: NEG
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: LIST
79847: ST_TO_ADDR
// end ; 2 :
79848: GO 83114
79850: LD_INT 2
79852: DOUBLE
79853: EQUAL
79854: IFTRUE 79858
79856: GO 83113
79858: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79859: LD_ADDR_VAR 0 29
79863: PUSH
79864: LD_INT 4
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 4
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 5
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 5
79897: PUSH
79898: LD_INT 1
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 4
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 3
79917: PUSH
79918: LD_INT 0
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 3
79927: PUSH
79928: LD_INT 1
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 3
79938: PUSH
79939: LD_INT 2
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 5
79949: PUSH
79950: LD_INT 2
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: LD_INT 3
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: LD_INT 2
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 4
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 4
79989: PUSH
79990: LD_INT 4
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: LD_INT 4
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 4
80029: PUSH
80030: LD_INT 2
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: LD_INT 4
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: LD_INT 4
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 0
80059: PUSH
80060: LD_INT 3
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 4
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: LD_INT 5
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 5
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: LD_INT 4
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 1
80110: NEG
80111: PUSH
80112: LD_INT 3
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 2
80121: PUSH
80122: LD_INT 5
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 2
80131: NEG
80132: PUSH
80133: LD_INT 3
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: LD_INT 0
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 3
80153: NEG
80154: PUSH
80155: LD_INT 1
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: LD_INT 0
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: LD_INT 1
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 3
80187: NEG
80188: PUSH
80189: LD_INT 1
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 4
80198: NEG
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 4
80209: NEG
80210: PUSH
80211: LD_INT 1
80213: NEG
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 4
80221: NEG
80222: PUSH
80223: LD_INT 2
80225: NEG
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 2
80233: NEG
80234: PUSH
80235: LD_INT 2
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 4
80244: NEG
80245: PUSH
80246: LD_INT 4
80248: NEG
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 4
80256: NEG
80257: PUSH
80258: LD_INT 5
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 3
80268: NEG
80269: PUSH
80270: LD_INT 4
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 3
80280: NEG
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 4
80292: NEG
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 5
80304: NEG
80305: PUSH
80306: LD_INT 4
80308: NEG
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 5
80316: NEG
80317: PUSH
80318: LD_INT 5
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 3
80328: NEG
80329: PUSH
80330: LD_INT 5
80332: NEG
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 5
80340: NEG
80341: PUSH
80342: LD_INT 3
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80397: LD_ADDR_VAR 0 30
80401: PUSH
80402: LD_INT 4
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 4
80414: PUSH
80415: LD_INT 3
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 5
80424: PUSH
80425: LD_INT 4
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 5
80434: PUSH
80435: LD_INT 5
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 4
80444: PUSH
80445: LD_INT 5
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 3
80454: PUSH
80455: LD_INT 4
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 3
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 5
80474: PUSH
80475: LD_INT 3
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 3
80484: PUSH
80485: LD_INT 5
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: LD_INT 3
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 1
80514: PUSH
80515: LD_INT 3
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 1
80524: PUSH
80525: LD_INT 4
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: LD_INT 4
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: LD_INT 3
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: NEG
80556: PUSH
80557: LD_INT 2
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: PUSH
80567: LD_INT 4
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 2
80576: NEG
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 4
80587: NEG
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 4
80598: NEG
80599: PUSH
80600: LD_INT 1
80602: NEG
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 3
80610: NEG
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 3
80621: NEG
80622: PUSH
80623: LD_INT 1
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 4
80632: NEG
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 5
80643: NEG
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 5
80654: NEG
80655: PUSH
80656: LD_INT 1
80658: NEG
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 5
80666: NEG
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 3
80678: NEG
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 3
80689: NEG
80690: PUSH
80691: LD_INT 3
80693: NEG
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 3
80701: NEG
80702: PUSH
80703: LD_INT 4
80705: NEG
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 2
80713: NEG
80714: PUSH
80715: LD_INT 3
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 2
80725: NEG
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 3
80737: NEG
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 4
80749: NEG
80750: PUSH
80751: LD_INT 3
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 4
80761: NEG
80762: PUSH
80763: LD_INT 4
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 2
80773: NEG
80774: PUSH
80775: LD_INT 4
80777: NEG
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 4
80785: NEG
80786: PUSH
80787: LD_INT 2
80789: NEG
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 0
80797: PUSH
80798: LD_INT 4
80800: NEG
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 5
80811: NEG
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 4
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 3
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 4
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: LD_INT 5
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 2
80876: PUSH
80877: LD_INT 3
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 2
80887: NEG
80888: PUSH
80889: LD_INT 5
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80944: LD_ADDR_VAR 0 31
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: LD_INT 4
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: LD_INT 3
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 1
80971: PUSH
80972: LD_INT 4
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: LD_INT 5
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: LD_INT 5
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: NEG
81002: PUSH
81003: LD_INT 4
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 1
81012: NEG
81013: PUSH
81014: LD_INT 3
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 2
81023: PUSH
81024: LD_INT 5
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 2
81033: NEG
81034: PUSH
81035: LD_INT 3
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 3
81044: NEG
81045: PUSH
81046: LD_INT 0
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 3
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 2
81067: NEG
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: NEG
81079: PUSH
81080: LD_INT 1
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 3
81089: NEG
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 4
81100: NEG
81101: PUSH
81102: LD_INT 0
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 4
81111: NEG
81112: PUSH
81113: LD_INT 1
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 4
81123: NEG
81124: PUSH
81125: LD_INT 2
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 2
81135: NEG
81136: PUSH
81137: LD_INT 2
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 4
81146: NEG
81147: PUSH
81148: LD_INT 4
81150: NEG
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 4
81158: NEG
81159: PUSH
81160: LD_INT 5
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 3
81170: NEG
81171: PUSH
81172: LD_INT 4
81174: NEG
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 3
81182: NEG
81183: PUSH
81184: LD_INT 3
81186: NEG
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 4
81194: NEG
81195: PUSH
81196: LD_INT 3
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 5
81206: NEG
81207: PUSH
81208: LD_INT 4
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 5
81218: NEG
81219: PUSH
81220: LD_INT 5
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 3
81230: NEG
81231: PUSH
81232: LD_INT 5
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 5
81242: NEG
81243: PUSH
81244: LD_INT 3
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 0
81254: PUSH
81255: LD_INT 3
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 0
81265: PUSH
81266: LD_INT 4
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 1
81276: PUSH
81277: LD_INT 3
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 1
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: LD_INT 2
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: LD_INT 3
81313: NEG
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: LD_INT 4
81325: NEG
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: LD_INT 2
81336: NEG
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 2
81344: NEG
81345: PUSH
81346: LD_INT 4
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 4
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 4
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 5
81377: PUSH
81378: LD_INT 0
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 5
81387: PUSH
81388: LD_INT 1
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 4
81397: PUSH
81398: LD_INT 1
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 3
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 3
81417: PUSH
81418: LD_INT 1
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 3
81428: PUSH
81429: LD_INT 2
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 5
81439: PUSH
81440: LD_INT 2
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81494: LD_ADDR_VAR 0 32
81498: PUSH
81499: LD_INT 4
81501: NEG
81502: PUSH
81503: LD_INT 0
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 4
81512: NEG
81513: PUSH
81514: LD_INT 1
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 3
81524: NEG
81525: PUSH
81526: LD_INT 0
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 3
81535: NEG
81536: PUSH
81537: LD_INT 1
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 4
81546: NEG
81547: PUSH
81548: LD_INT 1
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 5
81557: NEG
81558: PUSH
81559: LD_INT 0
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 5
81568: NEG
81569: PUSH
81570: LD_INT 1
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 5
81580: NEG
81581: PUSH
81582: LD_INT 2
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 3
81592: NEG
81593: PUSH
81594: LD_INT 2
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 3
81603: NEG
81604: PUSH
81605: LD_INT 3
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 3
81615: NEG
81616: PUSH
81617: LD_INT 4
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 2
81627: NEG
81628: PUSH
81629: LD_INT 3
81631: NEG
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: LD_INT 2
81643: NEG
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 3
81651: NEG
81652: PUSH
81653: LD_INT 2
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 4
81663: NEG
81664: PUSH
81665: LD_INT 3
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 4
81675: NEG
81676: PUSH
81677: LD_INT 4
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: LD_INT 4
81691: NEG
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 4
81699: NEG
81700: PUSH
81701: LD_INT 2
81703: NEG
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: LD_INT 4
81714: NEG
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 0
81722: PUSH
81723: LD_INT 5
81725: NEG
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 1
81733: PUSH
81734: LD_INT 4
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: LD_INT 3
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: LD_INT 3
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 1
81766: NEG
81767: PUSH
81768: LD_INT 4
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 1
81778: NEG
81779: PUSH
81780: LD_INT 5
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: PUSH
81791: LD_INT 3
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: LD_INT 5
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 3
81813: PUSH
81814: LD_INT 0
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 3
81823: PUSH
81824: LD_INT 1
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 4
81834: PUSH
81835: LD_INT 0
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 4
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 3
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 2
81885: PUSH
81886: LD_INT 2
81888: NEG
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 4
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 4
81906: PUSH
81907: LD_INT 4
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 4
81916: PUSH
81917: LD_INT 3
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 5
81926: PUSH
81927: LD_INT 4
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 5
81936: PUSH
81937: LD_INT 5
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 4
81946: PUSH
81947: LD_INT 5
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 3
81956: PUSH
81957: LD_INT 4
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: PUSH
81967: LD_INT 3
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 5
81976: PUSH
81977: LD_INT 3
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 3
81986: PUSH
81987: LD_INT 5
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82041: LD_ADDR_VAR 0 33
82045: PUSH
82046: LD_INT 4
82048: NEG
82049: PUSH
82050: LD_INT 4
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 4
82060: NEG
82061: PUSH
82062: LD_INT 5
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 3
82072: NEG
82073: PUSH
82074: LD_INT 4
82076: NEG
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 3
82084: NEG
82085: PUSH
82086: LD_INT 3
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 4
82096: NEG
82097: PUSH
82098: LD_INT 3
82100: NEG
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 5
82108: NEG
82109: PUSH
82110: LD_INT 4
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 5
82120: NEG
82121: PUSH
82122: LD_INT 5
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 3
82132: NEG
82133: PUSH
82134: LD_INT 5
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 5
82144: NEG
82145: PUSH
82146: LD_INT 3
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 0
82156: PUSH
82157: LD_INT 3
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 0
82167: PUSH
82168: LD_INT 4
82170: NEG
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 1
82178: PUSH
82179: LD_INT 3
82181: NEG
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 1
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 0
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 3
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 1
82223: NEG
82224: PUSH
82225: LD_INT 4
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: LD_INT 2
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 2
82246: NEG
82247: PUSH
82248: LD_INT 4
82250: NEG
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 4
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 4
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 5
82279: PUSH
82280: LD_INT 0
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 5
82289: PUSH
82290: LD_INT 1
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 4
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 3
82309: PUSH
82310: LD_INT 0
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: LD_INT 1
82322: NEG
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 3
82330: PUSH
82331: LD_INT 2
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 5
82341: PUSH
82342: LD_INT 2
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: PUSH
82352: LD_INT 3
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 4
82371: PUSH
82372: LD_INT 3
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 4
82381: PUSH
82382: LD_INT 4
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 3
82391: PUSH
82392: LD_INT 4
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 2
82401: PUSH
82402: LD_INT 3
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 2
82411: PUSH
82412: LD_INT 2
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 4
82421: PUSH
82422: LD_INT 2
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 2
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: LD_INT 4
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 0
82451: PUSH
82452: LD_INT 3
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: PUSH
82462: LD_INT 4
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 1
82471: PUSH
82472: LD_INT 5
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 0
82481: PUSH
82482: LD_INT 5
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: LD_INT 4
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: NEG
82503: PUSH
82504: LD_INT 3
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: PUSH
82514: LD_INT 5
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 2
82523: NEG
82524: PUSH
82525: LD_INT 3
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82579: LD_ADDR_VAR 0 34
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: LD_INT 4
82589: NEG
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 5
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: LD_INT 4
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: LD_INT 3
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 0
82630: PUSH
82631: LD_INT 3
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 4
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 1
82653: NEG
82654: PUSH
82655: LD_INT 5
82657: NEG
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 2
82665: PUSH
82666: LD_INT 3
82668: NEG
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: PUSH
82674: LD_INT 2
82676: NEG
82677: PUSH
82678: LD_INT 5
82680: NEG
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 3
82688: PUSH
82689: LD_INT 0
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 3
82698: PUSH
82699: LD_INT 1
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 4
82709: PUSH
82710: LD_INT 0
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 4
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 3
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 2
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 2
82760: PUSH
82761: LD_INT 2
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 4
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 4
82781: PUSH
82782: LD_INT 4
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 4
82791: PUSH
82792: LD_INT 3
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 5
82801: PUSH
82802: LD_INT 4
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 5
82811: PUSH
82812: LD_INT 5
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 4
82821: PUSH
82822: LD_INT 5
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 3
82831: PUSH
82832: LD_INT 4
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 3
82841: PUSH
82842: LD_INT 3
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 5
82851: PUSH
82852: LD_INT 3
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 3
82861: PUSH
82862: LD_INT 5
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: LD_INT 3
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 0
82881: PUSH
82882: LD_INT 2
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: PUSH
82892: LD_INT 3
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 1
82901: PUSH
82902: LD_INT 4
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 0
82911: PUSH
82912: LD_INT 4
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 1
82921: NEG
82922: PUSH
82923: LD_INT 3
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 1
82932: NEG
82933: PUSH
82934: LD_INT 2
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 2
82943: PUSH
82944: LD_INT 4
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: NEG
82954: PUSH
82955: LD_INT 2
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 4
82964: NEG
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 4
82975: NEG
82976: PUSH
82977: LD_INT 1
82979: NEG
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 3
82987: NEG
82988: PUSH
82989: LD_INT 0
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 3
82998: NEG
82999: PUSH
83000: LD_INT 1
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 4
83009: NEG
83010: PUSH
83011: LD_INT 1
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 5
83020: NEG
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 5
83031: NEG
83032: PUSH
83033: LD_INT 1
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 5
83043: NEG
83044: PUSH
83045: LD_INT 2
83047: NEG
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 3
83055: NEG
83056: PUSH
83057: LD_INT 2
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: ST_TO_ADDR
// end ; end ;
83111: GO 83114
83113: POP
// case btype of b_depot , b_warehouse :
83114: LD_VAR 0 1
83118: PUSH
83119: LD_INT 0
83121: DOUBLE
83122: EQUAL
83123: IFTRUE 83133
83125: LD_INT 1
83127: DOUBLE
83128: EQUAL
83129: IFTRUE 83133
83131: GO 83334
83133: POP
// case nation of nation_american :
83134: LD_VAR 0 5
83138: PUSH
83139: LD_INT 1
83141: DOUBLE
83142: EQUAL
83143: IFTRUE 83147
83145: GO 83203
83147: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83148: LD_ADDR_VAR 0 9
83152: PUSH
83153: LD_VAR 0 11
83157: PUSH
83158: LD_VAR 0 12
83162: PUSH
83163: LD_VAR 0 13
83167: PUSH
83168: LD_VAR 0 14
83172: PUSH
83173: LD_VAR 0 15
83177: PUSH
83178: LD_VAR 0 16
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: PUSH
83191: LD_VAR 0 4
83195: PUSH
83196: LD_INT 1
83198: PLUS
83199: ARRAY
83200: ST_TO_ADDR
83201: GO 83332
83203: LD_INT 2
83205: DOUBLE
83206: EQUAL
83207: IFTRUE 83211
83209: GO 83267
83211: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83212: LD_ADDR_VAR 0 9
83216: PUSH
83217: LD_VAR 0 17
83221: PUSH
83222: LD_VAR 0 18
83226: PUSH
83227: LD_VAR 0 19
83231: PUSH
83232: LD_VAR 0 20
83236: PUSH
83237: LD_VAR 0 21
83241: PUSH
83242: LD_VAR 0 22
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: PUSH
83255: LD_VAR 0 4
83259: PUSH
83260: LD_INT 1
83262: PLUS
83263: ARRAY
83264: ST_TO_ADDR
83265: GO 83332
83267: LD_INT 3
83269: DOUBLE
83270: EQUAL
83271: IFTRUE 83275
83273: GO 83331
83275: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83276: LD_ADDR_VAR 0 9
83280: PUSH
83281: LD_VAR 0 23
83285: PUSH
83286: LD_VAR 0 24
83290: PUSH
83291: LD_VAR 0 25
83295: PUSH
83296: LD_VAR 0 26
83300: PUSH
83301: LD_VAR 0 27
83305: PUSH
83306: LD_VAR 0 28
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: PUSH
83319: LD_VAR 0 4
83323: PUSH
83324: LD_INT 1
83326: PLUS
83327: ARRAY
83328: ST_TO_ADDR
83329: GO 83332
83331: POP
83332: GO 83887
83334: LD_INT 2
83336: DOUBLE
83337: EQUAL
83338: IFTRUE 83348
83340: LD_INT 3
83342: DOUBLE
83343: EQUAL
83344: IFTRUE 83348
83346: GO 83404
83348: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83349: LD_ADDR_VAR 0 9
83353: PUSH
83354: LD_VAR 0 29
83358: PUSH
83359: LD_VAR 0 30
83363: PUSH
83364: LD_VAR 0 31
83368: PUSH
83369: LD_VAR 0 32
83373: PUSH
83374: LD_VAR 0 33
83378: PUSH
83379: LD_VAR 0 34
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: PUSH
83392: LD_VAR 0 4
83396: PUSH
83397: LD_INT 1
83399: PLUS
83400: ARRAY
83401: ST_TO_ADDR
83402: GO 83887
83404: LD_INT 16
83406: DOUBLE
83407: EQUAL
83408: IFTRUE 83466
83410: LD_INT 17
83412: DOUBLE
83413: EQUAL
83414: IFTRUE 83466
83416: LD_INT 18
83418: DOUBLE
83419: EQUAL
83420: IFTRUE 83466
83422: LD_INT 19
83424: DOUBLE
83425: EQUAL
83426: IFTRUE 83466
83428: LD_INT 22
83430: DOUBLE
83431: EQUAL
83432: IFTRUE 83466
83434: LD_INT 20
83436: DOUBLE
83437: EQUAL
83438: IFTRUE 83466
83440: LD_INT 21
83442: DOUBLE
83443: EQUAL
83444: IFTRUE 83466
83446: LD_INT 23
83448: DOUBLE
83449: EQUAL
83450: IFTRUE 83466
83452: LD_INT 24
83454: DOUBLE
83455: EQUAL
83456: IFTRUE 83466
83458: LD_INT 25
83460: DOUBLE
83461: EQUAL
83462: IFTRUE 83466
83464: GO 83522
83466: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83467: LD_ADDR_VAR 0 9
83471: PUSH
83472: LD_VAR 0 35
83476: PUSH
83477: LD_VAR 0 36
83481: PUSH
83482: LD_VAR 0 37
83486: PUSH
83487: LD_VAR 0 38
83491: PUSH
83492: LD_VAR 0 39
83496: PUSH
83497: LD_VAR 0 40
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: PUSH
83510: LD_VAR 0 4
83514: PUSH
83515: LD_INT 1
83517: PLUS
83518: ARRAY
83519: ST_TO_ADDR
83520: GO 83887
83522: LD_INT 6
83524: DOUBLE
83525: EQUAL
83526: IFTRUE 83578
83528: LD_INT 7
83530: DOUBLE
83531: EQUAL
83532: IFTRUE 83578
83534: LD_INT 8
83536: DOUBLE
83537: EQUAL
83538: IFTRUE 83578
83540: LD_INT 13
83542: DOUBLE
83543: EQUAL
83544: IFTRUE 83578
83546: LD_INT 12
83548: DOUBLE
83549: EQUAL
83550: IFTRUE 83578
83552: LD_INT 15
83554: DOUBLE
83555: EQUAL
83556: IFTRUE 83578
83558: LD_INT 11
83560: DOUBLE
83561: EQUAL
83562: IFTRUE 83578
83564: LD_INT 14
83566: DOUBLE
83567: EQUAL
83568: IFTRUE 83578
83570: LD_INT 10
83572: DOUBLE
83573: EQUAL
83574: IFTRUE 83578
83576: GO 83634
83578: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83579: LD_ADDR_VAR 0 9
83583: PUSH
83584: LD_VAR 0 41
83588: PUSH
83589: LD_VAR 0 42
83593: PUSH
83594: LD_VAR 0 43
83598: PUSH
83599: LD_VAR 0 44
83603: PUSH
83604: LD_VAR 0 45
83608: PUSH
83609: LD_VAR 0 46
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: PUSH
83622: LD_VAR 0 4
83626: PUSH
83627: LD_INT 1
83629: PLUS
83630: ARRAY
83631: ST_TO_ADDR
83632: GO 83887
83634: LD_INT 36
83636: DOUBLE
83637: EQUAL
83638: IFTRUE 83642
83640: GO 83698
83642: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83643: LD_ADDR_VAR 0 9
83647: PUSH
83648: LD_VAR 0 47
83652: PUSH
83653: LD_VAR 0 48
83657: PUSH
83658: LD_VAR 0 49
83662: PUSH
83663: LD_VAR 0 50
83667: PUSH
83668: LD_VAR 0 51
83672: PUSH
83673: LD_VAR 0 52
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: PUSH
83686: LD_VAR 0 4
83690: PUSH
83691: LD_INT 1
83693: PLUS
83694: ARRAY
83695: ST_TO_ADDR
83696: GO 83887
83698: LD_INT 4
83700: DOUBLE
83701: EQUAL
83702: IFTRUE 83724
83704: LD_INT 5
83706: DOUBLE
83707: EQUAL
83708: IFTRUE 83724
83710: LD_INT 34
83712: DOUBLE
83713: EQUAL
83714: IFTRUE 83724
83716: LD_INT 37
83718: DOUBLE
83719: EQUAL
83720: IFTRUE 83724
83722: GO 83780
83724: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83725: LD_ADDR_VAR 0 9
83729: PUSH
83730: LD_VAR 0 53
83734: PUSH
83735: LD_VAR 0 54
83739: PUSH
83740: LD_VAR 0 55
83744: PUSH
83745: LD_VAR 0 56
83749: PUSH
83750: LD_VAR 0 57
83754: PUSH
83755: LD_VAR 0 58
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: PUSH
83768: LD_VAR 0 4
83772: PUSH
83773: LD_INT 1
83775: PLUS
83776: ARRAY
83777: ST_TO_ADDR
83778: GO 83887
83780: LD_INT 31
83782: DOUBLE
83783: EQUAL
83784: IFTRUE 83830
83786: LD_INT 32
83788: DOUBLE
83789: EQUAL
83790: IFTRUE 83830
83792: LD_INT 33
83794: DOUBLE
83795: EQUAL
83796: IFTRUE 83830
83798: LD_INT 27
83800: DOUBLE
83801: EQUAL
83802: IFTRUE 83830
83804: LD_INT 26
83806: DOUBLE
83807: EQUAL
83808: IFTRUE 83830
83810: LD_INT 28
83812: DOUBLE
83813: EQUAL
83814: IFTRUE 83830
83816: LD_INT 29
83818: DOUBLE
83819: EQUAL
83820: IFTRUE 83830
83822: LD_INT 30
83824: DOUBLE
83825: EQUAL
83826: IFTRUE 83830
83828: GO 83886
83830: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83831: LD_ADDR_VAR 0 9
83835: PUSH
83836: LD_VAR 0 59
83840: PUSH
83841: LD_VAR 0 60
83845: PUSH
83846: LD_VAR 0 61
83850: PUSH
83851: LD_VAR 0 62
83855: PUSH
83856: LD_VAR 0 63
83860: PUSH
83861: LD_VAR 0 64
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: PUSH
83874: LD_VAR 0 4
83878: PUSH
83879: LD_INT 1
83881: PLUS
83882: ARRAY
83883: ST_TO_ADDR
83884: GO 83887
83886: POP
// temp_list2 = [ ] ;
83887: LD_ADDR_VAR 0 10
83891: PUSH
83892: EMPTY
83893: ST_TO_ADDR
// for i in temp_list do
83894: LD_ADDR_VAR 0 8
83898: PUSH
83899: LD_VAR 0 9
83903: PUSH
83904: FOR_IN
83905: IFFALSE 83957
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83907: LD_ADDR_VAR 0 10
83911: PUSH
83912: LD_VAR 0 10
83916: PUSH
83917: LD_VAR 0 8
83921: PUSH
83922: LD_INT 1
83924: ARRAY
83925: PUSH
83926: LD_VAR 0 2
83930: PLUS
83931: PUSH
83932: LD_VAR 0 8
83936: PUSH
83937: LD_INT 2
83939: ARRAY
83940: PUSH
83941: LD_VAR 0 3
83945: PLUS
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: EMPTY
83952: LIST
83953: ADD
83954: ST_TO_ADDR
83955: GO 83904
83957: POP
83958: POP
// result = temp_list2 ;
83959: LD_ADDR_VAR 0 7
83963: PUSH
83964: LD_VAR 0 10
83968: ST_TO_ADDR
// end ;
83969: LD_VAR 0 7
83973: RET
// export function EnemyInRange ( unit , dist ) ; begin
83974: LD_INT 0
83976: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83977: LD_ADDR_VAR 0 3
83981: PUSH
83982: LD_VAR 0 1
83986: PPUSH
83987: CALL_OW 255
83991: PPUSH
83992: LD_VAR 0 1
83996: PPUSH
83997: CALL_OW 250
84001: PPUSH
84002: LD_VAR 0 1
84006: PPUSH
84007: CALL_OW 251
84011: PPUSH
84012: LD_VAR 0 2
84016: PPUSH
84017: CALL 57370 0 4
84021: PUSH
84022: LD_INT 4
84024: ARRAY
84025: ST_TO_ADDR
// end ;
84026: LD_VAR 0 3
84030: RET
// export function PlayerSeeMe ( unit ) ; begin
84031: LD_INT 0
84033: PPUSH
// result := See ( your_side , unit ) ;
84034: LD_ADDR_VAR 0 2
84038: PUSH
84039: LD_OWVAR 2
84043: PPUSH
84044: LD_VAR 0 1
84048: PPUSH
84049: CALL_OW 292
84053: ST_TO_ADDR
// end ;
84054: LD_VAR 0 2
84058: RET
// export function ReverseDir ( unit ) ; begin
84059: LD_INT 0
84061: PPUSH
// if not unit then
84062: LD_VAR 0 1
84066: NOT
84067: IFFALSE 84071
// exit ;
84069: GO 84094
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84071: LD_ADDR_VAR 0 2
84075: PUSH
84076: LD_VAR 0 1
84080: PPUSH
84081: CALL_OW 254
84085: PUSH
84086: LD_INT 3
84088: PLUS
84089: PUSH
84090: LD_INT 6
84092: MOD
84093: ST_TO_ADDR
// end ;
84094: LD_VAR 0 2
84098: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84099: LD_INT 0
84101: PPUSH
84102: PPUSH
84103: PPUSH
84104: PPUSH
84105: PPUSH
// if not hexes then
84106: LD_VAR 0 2
84110: NOT
84111: IFFALSE 84115
// exit ;
84113: GO 84263
// dist := 9999 ;
84115: LD_ADDR_VAR 0 5
84119: PUSH
84120: LD_INT 9999
84122: ST_TO_ADDR
// for i = 1 to hexes do
84123: LD_ADDR_VAR 0 4
84127: PUSH
84128: DOUBLE
84129: LD_INT 1
84131: DEC
84132: ST_TO_ADDR
84133: LD_VAR 0 2
84137: PUSH
84138: FOR_TO
84139: IFFALSE 84251
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84141: LD_VAR 0 1
84145: PPUSH
84146: LD_VAR 0 2
84150: PUSH
84151: LD_VAR 0 4
84155: ARRAY
84156: PUSH
84157: LD_INT 1
84159: ARRAY
84160: PPUSH
84161: LD_VAR 0 2
84165: PUSH
84166: LD_VAR 0 4
84170: ARRAY
84171: PUSH
84172: LD_INT 2
84174: ARRAY
84175: PPUSH
84176: CALL_OW 297
84180: PUSH
84181: LD_VAR 0 5
84185: LESS
84186: IFFALSE 84249
// begin hex := hexes [ i ] ;
84188: LD_ADDR_VAR 0 7
84192: PUSH
84193: LD_VAR 0 2
84197: PUSH
84198: LD_VAR 0 4
84202: ARRAY
84203: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84204: LD_ADDR_VAR 0 5
84208: PUSH
84209: LD_VAR 0 1
84213: PPUSH
84214: LD_VAR 0 2
84218: PUSH
84219: LD_VAR 0 4
84223: ARRAY
84224: PUSH
84225: LD_INT 1
84227: ARRAY
84228: PPUSH
84229: LD_VAR 0 2
84233: PUSH
84234: LD_VAR 0 4
84238: ARRAY
84239: PUSH
84240: LD_INT 2
84242: ARRAY
84243: PPUSH
84244: CALL_OW 297
84248: ST_TO_ADDR
// end ; end ;
84249: GO 84138
84251: POP
84252: POP
// result := hex ;
84253: LD_ADDR_VAR 0 3
84257: PUSH
84258: LD_VAR 0 7
84262: ST_TO_ADDR
// end ;
84263: LD_VAR 0 3
84267: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84268: LD_INT 0
84270: PPUSH
84271: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84272: LD_VAR 0 1
84276: NOT
84277: PUSH
84278: LD_VAR 0 1
84282: PUSH
84283: LD_INT 21
84285: PUSH
84286: LD_INT 2
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 23
84295: PUSH
84296: LD_INT 2
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PPUSH
84307: CALL_OW 69
84311: IN
84312: NOT
84313: OR
84314: IFFALSE 84318
// exit ;
84316: GO 84365
// for i = 1 to 3 do
84318: LD_ADDR_VAR 0 3
84322: PUSH
84323: DOUBLE
84324: LD_INT 1
84326: DEC
84327: ST_TO_ADDR
84328: LD_INT 3
84330: PUSH
84331: FOR_TO
84332: IFFALSE 84363
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84334: LD_VAR 0 1
84338: PPUSH
84339: CALL_OW 250
84343: PPUSH
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 251
84353: PPUSH
84354: LD_INT 1
84356: PPUSH
84357: CALL_OW 453
84361: GO 84331
84363: POP
84364: POP
// end ;
84365: LD_VAR 0 2
84369: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84370: LD_INT 0
84372: PPUSH
84373: PPUSH
84374: PPUSH
84375: PPUSH
84376: PPUSH
84377: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84378: LD_VAR 0 1
84382: NOT
84383: PUSH
84384: LD_VAR 0 2
84388: NOT
84389: OR
84390: PUSH
84391: LD_VAR 0 1
84395: PPUSH
84396: CALL_OW 314
84400: OR
84401: IFFALSE 84405
// exit ;
84403: GO 84846
// x := GetX ( enemy_unit ) ;
84405: LD_ADDR_VAR 0 7
84409: PUSH
84410: LD_VAR 0 2
84414: PPUSH
84415: CALL_OW 250
84419: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84420: LD_ADDR_VAR 0 8
84424: PUSH
84425: LD_VAR 0 2
84429: PPUSH
84430: CALL_OW 251
84434: ST_TO_ADDR
// if not x or not y then
84435: LD_VAR 0 7
84439: NOT
84440: PUSH
84441: LD_VAR 0 8
84445: NOT
84446: OR
84447: IFFALSE 84451
// exit ;
84449: GO 84846
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84451: LD_ADDR_VAR 0 6
84455: PUSH
84456: LD_VAR 0 7
84460: PPUSH
84461: LD_INT 0
84463: PPUSH
84464: LD_INT 4
84466: PPUSH
84467: CALL_OW 272
84471: PUSH
84472: LD_VAR 0 8
84476: PPUSH
84477: LD_INT 0
84479: PPUSH
84480: LD_INT 4
84482: PPUSH
84483: CALL_OW 273
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_VAR 0 7
84496: PPUSH
84497: LD_INT 1
84499: PPUSH
84500: LD_INT 4
84502: PPUSH
84503: CALL_OW 272
84507: PUSH
84508: LD_VAR 0 8
84512: PPUSH
84513: LD_INT 1
84515: PPUSH
84516: LD_INT 4
84518: PPUSH
84519: CALL_OW 273
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_VAR 0 7
84532: PPUSH
84533: LD_INT 2
84535: PPUSH
84536: LD_INT 4
84538: PPUSH
84539: CALL_OW 272
84543: PUSH
84544: LD_VAR 0 8
84548: PPUSH
84549: LD_INT 2
84551: PPUSH
84552: LD_INT 4
84554: PPUSH
84555: CALL_OW 273
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_VAR 0 7
84568: PPUSH
84569: LD_INT 3
84571: PPUSH
84572: LD_INT 4
84574: PPUSH
84575: CALL_OW 272
84579: PUSH
84580: LD_VAR 0 8
84584: PPUSH
84585: LD_INT 3
84587: PPUSH
84588: LD_INT 4
84590: PPUSH
84591: CALL_OW 273
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_VAR 0 7
84604: PPUSH
84605: LD_INT 4
84607: PPUSH
84608: LD_INT 4
84610: PPUSH
84611: CALL_OW 272
84615: PUSH
84616: LD_VAR 0 8
84620: PPUSH
84621: LD_INT 4
84623: PPUSH
84624: LD_INT 4
84626: PPUSH
84627: CALL_OW 273
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_VAR 0 7
84640: PPUSH
84641: LD_INT 5
84643: PPUSH
84644: LD_INT 4
84646: PPUSH
84647: CALL_OW 272
84651: PUSH
84652: LD_VAR 0 8
84656: PPUSH
84657: LD_INT 5
84659: PPUSH
84660: LD_INT 4
84662: PPUSH
84663: CALL_OW 273
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: ST_TO_ADDR
// for i = tmp downto 1 do
84680: LD_ADDR_VAR 0 4
84684: PUSH
84685: DOUBLE
84686: LD_VAR 0 6
84690: INC
84691: ST_TO_ADDR
84692: LD_INT 1
84694: PUSH
84695: FOR_DOWNTO
84696: IFFALSE 84797
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84698: LD_VAR 0 6
84702: PUSH
84703: LD_VAR 0 4
84707: ARRAY
84708: PUSH
84709: LD_INT 1
84711: ARRAY
84712: PPUSH
84713: LD_VAR 0 6
84717: PUSH
84718: LD_VAR 0 4
84722: ARRAY
84723: PUSH
84724: LD_INT 2
84726: ARRAY
84727: PPUSH
84728: CALL_OW 488
84732: NOT
84733: PUSH
84734: LD_VAR 0 6
84738: PUSH
84739: LD_VAR 0 4
84743: ARRAY
84744: PUSH
84745: LD_INT 1
84747: ARRAY
84748: PPUSH
84749: LD_VAR 0 6
84753: PUSH
84754: LD_VAR 0 4
84758: ARRAY
84759: PUSH
84760: LD_INT 2
84762: ARRAY
84763: PPUSH
84764: CALL_OW 428
84768: PUSH
84769: LD_INT 0
84771: NONEQUAL
84772: OR
84773: IFFALSE 84795
// tmp := Delete ( tmp , i ) ;
84775: LD_ADDR_VAR 0 6
84779: PUSH
84780: LD_VAR 0 6
84784: PPUSH
84785: LD_VAR 0 4
84789: PPUSH
84790: CALL_OW 3
84794: ST_TO_ADDR
84795: GO 84695
84797: POP
84798: POP
// j := GetClosestHex ( unit , tmp ) ;
84799: LD_ADDR_VAR 0 5
84803: PUSH
84804: LD_VAR 0 1
84808: PPUSH
84809: LD_VAR 0 6
84813: PPUSH
84814: CALL 84099 0 2
84818: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84819: LD_VAR 0 1
84823: PPUSH
84824: LD_VAR 0 5
84828: PUSH
84829: LD_INT 1
84831: ARRAY
84832: PPUSH
84833: LD_VAR 0 5
84837: PUSH
84838: LD_INT 2
84840: ARRAY
84841: PPUSH
84842: CALL_OW 111
// end ;
84846: LD_VAR 0 3
84850: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84851: LD_INT 0
84853: PPUSH
84854: PPUSH
84855: PPUSH
// uc_side = 0 ;
84856: LD_ADDR_OWVAR 20
84860: PUSH
84861: LD_INT 0
84863: ST_TO_ADDR
// uc_nation = 0 ;
84864: LD_ADDR_OWVAR 21
84868: PUSH
84869: LD_INT 0
84871: ST_TO_ADDR
// InitHc_All ( ) ;
84872: CALL_OW 584
// InitVc ;
84876: CALL_OW 20
// if mastodonts then
84880: LD_VAR 0 6
84884: IFFALSE 84951
// for i = 1 to mastodonts do
84886: LD_ADDR_VAR 0 11
84890: PUSH
84891: DOUBLE
84892: LD_INT 1
84894: DEC
84895: ST_TO_ADDR
84896: LD_VAR 0 6
84900: PUSH
84901: FOR_TO
84902: IFFALSE 84949
// begin vc_chassis := 31 ;
84904: LD_ADDR_OWVAR 37
84908: PUSH
84909: LD_INT 31
84911: ST_TO_ADDR
// vc_control := control_rider ;
84912: LD_ADDR_OWVAR 38
84916: PUSH
84917: LD_INT 4
84919: ST_TO_ADDR
// animal := CreateVehicle ;
84920: LD_ADDR_VAR 0 12
84924: PUSH
84925: CALL_OW 45
84929: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84930: LD_VAR 0 12
84934: PPUSH
84935: LD_VAR 0 8
84939: PPUSH
84940: LD_INT 0
84942: PPUSH
84943: CALL 87139 0 3
// end ;
84947: GO 84901
84949: POP
84950: POP
// if horses then
84951: LD_VAR 0 5
84955: IFFALSE 85022
// for i = 1 to horses do
84957: LD_ADDR_VAR 0 11
84961: PUSH
84962: DOUBLE
84963: LD_INT 1
84965: DEC
84966: ST_TO_ADDR
84967: LD_VAR 0 5
84971: PUSH
84972: FOR_TO
84973: IFFALSE 85020
// begin hc_class := 21 ;
84975: LD_ADDR_OWVAR 28
84979: PUSH
84980: LD_INT 21
84982: ST_TO_ADDR
// hc_gallery :=  ;
84983: LD_ADDR_OWVAR 33
84987: PUSH
84988: LD_STRING 
84990: ST_TO_ADDR
// animal := CreateHuman ;
84991: LD_ADDR_VAR 0 12
84995: PUSH
84996: CALL_OW 44
85000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85001: LD_VAR 0 12
85005: PPUSH
85006: LD_VAR 0 8
85010: PPUSH
85011: LD_INT 0
85013: PPUSH
85014: CALL 87139 0 3
// end ;
85018: GO 84972
85020: POP
85021: POP
// if birds then
85022: LD_VAR 0 1
85026: IFFALSE 85093
// for i = 1 to birds do
85028: LD_ADDR_VAR 0 11
85032: PUSH
85033: DOUBLE
85034: LD_INT 1
85036: DEC
85037: ST_TO_ADDR
85038: LD_VAR 0 1
85042: PUSH
85043: FOR_TO
85044: IFFALSE 85091
// begin hc_class = 18 ;
85046: LD_ADDR_OWVAR 28
85050: PUSH
85051: LD_INT 18
85053: ST_TO_ADDR
// hc_gallery =  ;
85054: LD_ADDR_OWVAR 33
85058: PUSH
85059: LD_STRING 
85061: ST_TO_ADDR
// animal := CreateHuman ;
85062: LD_ADDR_VAR 0 12
85066: PUSH
85067: CALL_OW 44
85071: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85072: LD_VAR 0 12
85076: PPUSH
85077: LD_VAR 0 8
85081: PPUSH
85082: LD_INT 0
85084: PPUSH
85085: CALL 87139 0 3
// end ;
85089: GO 85043
85091: POP
85092: POP
// if tigers then
85093: LD_VAR 0 2
85097: IFFALSE 85181
// for i = 1 to tigers do
85099: LD_ADDR_VAR 0 11
85103: PUSH
85104: DOUBLE
85105: LD_INT 1
85107: DEC
85108: ST_TO_ADDR
85109: LD_VAR 0 2
85113: PUSH
85114: FOR_TO
85115: IFFALSE 85179
// begin hc_class = class_tiger ;
85117: LD_ADDR_OWVAR 28
85121: PUSH
85122: LD_INT 14
85124: ST_TO_ADDR
// hc_gallery =  ;
85125: LD_ADDR_OWVAR 33
85129: PUSH
85130: LD_STRING 
85132: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85133: LD_ADDR_OWVAR 35
85137: PUSH
85138: LD_INT 7
85140: NEG
85141: PPUSH
85142: LD_INT 7
85144: PPUSH
85145: CALL_OW 12
85149: ST_TO_ADDR
// animal := CreateHuman ;
85150: LD_ADDR_VAR 0 12
85154: PUSH
85155: CALL_OW 44
85159: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85160: LD_VAR 0 12
85164: PPUSH
85165: LD_VAR 0 8
85169: PPUSH
85170: LD_INT 0
85172: PPUSH
85173: CALL 87139 0 3
// end ;
85177: GO 85114
85179: POP
85180: POP
// if apemans then
85181: LD_VAR 0 3
85185: IFFALSE 85308
// for i = 1 to apemans do
85187: LD_ADDR_VAR 0 11
85191: PUSH
85192: DOUBLE
85193: LD_INT 1
85195: DEC
85196: ST_TO_ADDR
85197: LD_VAR 0 3
85201: PUSH
85202: FOR_TO
85203: IFFALSE 85306
// begin hc_class = class_apeman ;
85205: LD_ADDR_OWVAR 28
85209: PUSH
85210: LD_INT 12
85212: ST_TO_ADDR
// hc_gallery =  ;
85213: LD_ADDR_OWVAR 33
85217: PUSH
85218: LD_STRING 
85220: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85221: LD_ADDR_OWVAR 35
85225: PUSH
85226: LD_INT 2
85228: NEG
85229: PPUSH
85230: LD_INT 2
85232: PPUSH
85233: CALL_OW 12
85237: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85238: LD_ADDR_OWVAR 31
85242: PUSH
85243: LD_INT 1
85245: PPUSH
85246: LD_INT 3
85248: PPUSH
85249: CALL_OW 12
85253: PUSH
85254: LD_INT 1
85256: PPUSH
85257: LD_INT 3
85259: PPUSH
85260: CALL_OW 12
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: LD_INT 0
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: ST_TO_ADDR
// animal := CreateHuman ;
85277: LD_ADDR_VAR 0 12
85281: PUSH
85282: CALL_OW 44
85286: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85287: LD_VAR 0 12
85291: PPUSH
85292: LD_VAR 0 8
85296: PPUSH
85297: LD_INT 0
85299: PPUSH
85300: CALL 87139 0 3
// end ;
85304: GO 85202
85306: POP
85307: POP
// if enchidnas then
85308: LD_VAR 0 4
85312: IFFALSE 85379
// for i = 1 to enchidnas do
85314: LD_ADDR_VAR 0 11
85318: PUSH
85319: DOUBLE
85320: LD_INT 1
85322: DEC
85323: ST_TO_ADDR
85324: LD_VAR 0 4
85328: PUSH
85329: FOR_TO
85330: IFFALSE 85377
// begin hc_class = 13 ;
85332: LD_ADDR_OWVAR 28
85336: PUSH
85337: LD_INT 13
85339: ST_TO_ADDR
// hc_gallery =  ;
85340: LD_ADDR_OWVAR 33
85344: PUSH
85345: LD_STRING 
85347: ST_TO_ADDR
// animal := CreateHuman ;
85348: LD_ADDR_VAR 0 12
85352: PUSH
85353: CALL_OW 44
85357: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85358: LD_VAR 0 12
85362: PPUSH
85363: LD_VAR 0 8
85367: PPUSH
85368: LD_INT 0
85370: PPUSH
85371: CALL 87139 0 3
// end ;
85375: GO 85329
85377: POP
85378: POP
// if fishes then
85379: LD_VAR 0 7
85383: IFFALSE 85450
// for i = 1 to fishes do
85385: LD_ADDR_VAR 0 11
85389: PUSH
85390: DOUBLE
85391: LD_INT 1
85393: DEC
85394: ST_TO_ADDR
85395: LD_VAR 0 7
85399: PUSH
85400: FOR_TO
85401: IFFALSE 85448
// begin hc_class = 20 ;
85403: LD_ADDR_OWVAR 28
85407: PUSH
85408: LD_INT 20
85410: ST_TO_ADDR
// hc_gallery =  ;
85411: LD_ADDR_OWVAR 33
85415: PUSH
85416: LD_STRING 
85418: ST_TO_ADDR
// animal := CreateHuman ;
85419: LD_ADDR_VAR 0 12
85423: PUSH
85424: CALL_OW 44
85428: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85429: LD_VAR 0 12
85433: PPUSH
85434: LD_VAR 0 9
85438: PPUSH
85439: LD_INT 0
85441: PPUSH
85442: CALL 87139 0 3
// end ;
85446: GO 85400
85448: POP
85449: POP
// end ;
85450: LD_VAR 0 10
85454: RET
// export function WantHeal ( sci , unit ) ; begin
85455: LD_INT 0
85457: PPUSH
// if GetTaskList ( sci ) > 0 then
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL_OW 437
85467: PUSH
85468: LD_INT 0
85470: GREATER
85471: IFFALSE 85541
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85473: LD_VAR 0 1
85477: PPUSH
85478: CALL_OW 437
85482: PUSH
85483: LD_INT 1
85485: ARRAY
85486: PUSH
85487: LD_INT 1
85489: ARRAY
85490: PUSH
85491: LD_STRING l
85493: EQUAL
85494: PUSH
85495: LD_VAR 0 1
85499: PPUSH
85500: CALL_OW 437
85504: PUSH
85505: LD_INT 1
85507: ARRAY
85508: PUSH
85509: LD_INT 4
85511: ARRAY
85512: PUSH
85513: LD_VAR 0 2
85517: EQUAL
85518: AND
85519: IFFALSE 85531
// result := true else
85521: LD_ADDR_VAR 0 3
85525: PUSH
85526: LD_INT 1
85528: ST_TO_ADDR
85529: GO 85539
// result := false ;
85531: LD_ADDR_VAR 0 3
85535: PUSH
85536: LD_INT 0
85538: ST_TO_ADDR
// end else
85539: GO 85549
// result := false ;
85541: LD_ADDR_VAR 0 3
85545: PUSH
85546: LD_INT 0
85548: ST_TO_ADDR
// end ;
85549: LD_VAR 0 3
85553: RET
// export function HealTarget ( sci ) ; begin
85554: LD_INT 0
85556: PPUSH
// if not sci then
85557: LD_VAR 0 1
85561: NOT
85562: IFFALSE 85566
// exit ;
85564: GO 85631
// result := 0 ;
85566: LD_ADDR_VAR 0 2
85570: PUSH
85571: LD_INT 0
85573: ST_TO_ADDR
// if GetTaskList ( sci ) then
85574: LD_VAR 0 1
85578: PPUSH
85579: CALL_OW 437
85583: IFFALSE 85631
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85585: LD_VAR 0 1
85589: PPUSH
85590: CALL_OW 437
85594: PUSH
85595: LD_INT 1
85597: ARRAY
85598: PUSH
85599: LD_INT 1
85601: ARRAY
85602: PUSH
85603: LD_STRING l
85605: EQUAL
85606: IFFALSE 85631
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85608: LD_ADDR_VAR 0 2
85612: PUSH
85613: LD_VAR 0 1
85617: PPUSH
85618: CALL_OW 437
85622: PUSH
85623: LD_INT 1
85625: ARRAY
85626: PUSH
85627: LD_INT 4
85629: ARRAY
85630: ST_TO_ADDR
// end ;
85631: LD_VAR 0 2
85635: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85636: LD_INT 0
85638: PPUSH
85639: PPUSH
85640: PPUSH
85641: PPUSH
// if not base_units then
85642: LD_VAR 0 1
85646: NOT
85647: IFFALSE 85651
// exit ;
85649: GO 85738
// result := false ;
85651: LD_ADDR_VAR 0 2
85655: PUSH
85656: LD_INT 0
85658: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85659: LD_ADDR_VAR 0 5
85663: PUSH
85664: LD_VAR 0 1
85668: PPUSH
85669: LD_INT 21
85671: PUSH
85672: LD_INT 3
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PPUSH
85679: CALL_OW 72
85683: ST_TO_ADDR
// if not tmp then
85684: LD_VAR 0 5
85688: NOT
85689: IFFALSE 85693
// exit ;
85691: GO 85738
// for i in tmp do
85693: LD_ADDR_VAR 0 3
85697: PUSH
85698: LD_VAR 0 5
85702: PUSH
85703: FOR_IN
85704: IFFALSE 85736
// begin result := EnemyInRange ( i , 22 ) ;
85706: LD_ADDR_VAR 0 2
85710: PUSH
85711: LD_VAR 0 3
85715: PPUSH
85716: LD_INT 22
85718: PPUSH
85719: CALL 83974 0 2
85723: ST_TO_ADDR
// if result then
85724: LD_VAR 0 2
85728: IFFALSE 85734
// exit ;
85730: POP
85731: POP
85732: GO 85738
// end ;
85734: GO 85703
85736: POP
85737: POP
// end ;
85738: LD_VAR 0 2
85742: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85743: LD_INT 0
85745: PPUSH
85746: PPUSH
// if not units then
85747: LD_VAR 0 1
85751: NOT
85752: IFFALSE 85756
// exit ;
85754: GO 85826
// result := [ ] ;
85756: LD_ADDR_VAR 0 3
85760: PUSH
85761: EMPTY
85762: ST_TO_ADDR
// for i in units do
85763: LD_ADDR_VAR 0 4
85767: PUSH
85768: LD_VAR 0 1
85772: PUSH
85773: FOR_IN
85774: IFFALSE 85824
// if GetTag ( i ) = tag then
85776: LD_VAR 0 4
85780: PPUSH
85781: CALL_OW 110
85785: PUSH
85786: LD_VAR 0 2
85790: EQUAL
85791: IFFALSE 85822
// result := Replace ( result , result + 1 , i ) ;
85793: LD_ADDR_VAR 0 3
85797: PUSH
85798: LD_VAR 0 3
85802: PPUSH
85803: LD_VAR 0 3
85807: PUSH
85808: LD_INT 1
85810: PLUS
85811: PPUSH
85812: LD_VAR 0 4
85816: PPUSH
85817: CALL_OW 1
85821: ST_TO_ADDR
85822: GO 85773
85824: POP
85825: POP
// end ;
85826: LD_VAR 0 3
85830: RET
// export function IsDriver ( un ) ; begin
85831: LD_INT 0
85833: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85834: LD_ADDR_VAR 0 2
85838: PUSH
85839: LD_VAR 0 1
85843: PUSH
85844: LD_INT 55
85846: PUSH
85847: EMPTY
85848: LIST
85849: PPUSH
85850: CALL_OW 69
85854: IN
85855: ST_TO_ADDR
// end ;
85856: LD_VAR 0 2
85860: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85861: LD_INT 0
85863: PPUSH
85864: PPUSH
// list := [ ] ;
85865: LD_ADDR_VAR 0 5
85869: PUSH
85870: EMPTY
85871: ST_TO_ADDR
// case d of 0 :
85872: LD_VAR 0 3
85876: PUSH
85877: LD_INT 0
85879: DOUBLE
85880: EQUAL
85881: IFTRUE 85885
85883: GO 86018
85885: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85886: LD_ADDR_VAR 0 5
85890: PUSH
85891: LD_VAR 0 1
85895: PUSH
85896: LD_INT 4
85898: MINUS
85899: PUSH
85900: LD_VAR 0 2
85904: PUSH
85905: LD_INT 4
85907: MINUS
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: LIST
85916: PUSH
85917: LD_VAR 0 1
85921: PUSH
85922: LD_INT 3
85924: MINUS
85925: PUSH
85926: LD_VAR 0 2
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: LIST
85938: PUSH
85939: LD_VAR 0 1
85943: PUSH
85944: LD_INT 4
85946: PLUS
85947: PUSH
85948: LD_VAR 0 2
85952: PUSH
85953: LD_INT 4
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: LIST
85960: PUSH
85961: LD_VAR 0 1
85965: PUSH
85966: LD_INT 3
85968: PLUS
85969: PUSH
85970: LD_VAR 0 2
85974: PUSH
85975: LD_INT 3
85977: PLUS
85978: PUSH
85979: LD_INT 5
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: PUSH
85987: LD_VAR 0 1
85991: PUSH
85992: LD_VAR 0 2
85996: PUSH
85997: LD_INT 4
85999: PLUS
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: ST_TO_ADDR
// end ; 1 :
86016: GO 86716
86018: LD_INT 1
86020: DOUBLE
86021: EQUAL
86022: IFTRUE 86026
86024: GO 86159
86026: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86027: LD_ADDR_VAR 0 5
86031: PUSH
86032: LD_VAR 0 1
86036: PUSH
86037: LD_VAR 0 2
86041: PUSH
86042: LD_INT 4
86044: MINUS
86045: PUSH
86046: LD_INT 3
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: LIST
86053: PUSH
86054: LD_VAR 0 1
86058: PUSH
86059: LD_INT 3
86061: MINUS
86062: PUSH
86063: LD_VAR 0 2
86067: PUSH
86068: LD_INT 3
86070: MINUS
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: PUSH
86080: LD_VAR 0 1
86084: PUSH
86085: LD_INT 4
86087: MINUS
86088: PUSH
86089: LD_VAR 0 2
86093: PUSH
86094: LD_INT 1
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: LIST
86101: PUSH
86102: LD_VAR 0 1
86106: PUSH
86107: LD_VAR 0 2
86111: PUSH
86112: LD_INT 3
86114: PLUS
86115: PUSH
86116: LD_INT 0
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: LIST
86123: PUSH
86124: LD_VAR 0 1
86128: PUSH
86129: LD_INT 4
86131: PLUS
86132: PUSH
86133: LD_VAR 0 2
86137: PUSH
86138: LD_INT 4
86140: PLUS
86141: PUSH
86142: LD_INT 5
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: LIST
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: ST_TO_ADDR
// end ; 2 :
86157: GO 86716
86159: LD_INT 2
86161: DOUBLE
86162: EQUAL
86163: IFTRUE 86167
86165: GO 86296
86167: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86168: LD_ADDR_VAR 0 5
86172: PUSH
86173: LD_VAR 0 1
86177: PUSH
86178: LD_VAR 0 2
86182: PUSH
86183: LD_INT 3
86185: MINUS
86186: PUSH
86187: LD_INT 3
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: LIST
86194: PUSH
86195: LD_VAR 0 1
86199: PUSH
86200: LD_INT 4
86202: PLUS
86203: PUSH
86204: LD_VAR 0 2
86208: PUSH
86209: LD_INT 4
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: LIST
86216: PUSH
86217: LD_VAR 0 1
86221: PUSH
86222: LD_VAR 0 2
86226: PUSH
86227: LD_INT 4
86229: PLUS
86230: PUSH
86231: LD_INT 0
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: PUSH
86239: LD_VAR 0 1
86243: PUSH
86244: LD_INT 3
86246: MINUS
86247: PUSH
86248: LD_VAR 0 2
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: LIST
86260: PUSH
86261: LD_VAR 0 1
86265: PUSH
86266: LD_INT 4
86268: MINUS
86269: PUSH
86270: LD_VAR 0 2
86274: PUSH
86275: LD_INT 4
86277: MINUS
86278: PUSH
86279: LD_INT 2
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: LIST
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: ST_TO_ADDR
// end ; 3 :
86294: GO 86716
86296: LD_INT 3
86298: DOUBLE
86299: EQUAL
86300: IFTRUE 86304
86302: GO 86437
86304: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86305: LD_ADDR_VAR 0 5
86309: PUSH
86310: LD_VAR 0 1
86314: PUSH
86315: LD_INT 3
86317: PLUS
86318: PUSH
86319: LD_VAR 0 2
86323: PUSH
86324: LD_INT 4
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: LIST
86331: PUSH
86332: LD_VAR 0 1
86336: PUSH
86337: LD_INT 4
86339: PLUS
86340: PUSH
86341: LD_VAR 0 2
86345: PUSH
86346: LD_INT 4
86348: PLUS
86349: PUSH
86350: LD_INT 5
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: LIST
86357: PUSH
86358: LD_VAR 0 1
86362: PUSH
86363: LD_INT 4
86365: MINUS
86366: PUSH
86367: LD_VAR 0 2
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: LIST
86379: PUSH
86380: LD_VAR 0 1
86384: PUSH
86385: LD_VAR 0 2
86389: PUSH
86390: LD_INT 4
86392: MINUS
86393: PUSH
86394: LD_INT 3
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: LIST
86401: PUSH
86402: LD_VAR 0 1
86406: PUSH
86407: LD_INT 3
86409: MINUS
86410: PUSH
86411: LD_VAR 0 2
86415: PUSH
86416: LD_INT 3
86418: MINUS
86419: PUSH
86420: LD_INT 2
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: ST_TO_ADDR
// end ; 4 :
86435: GO 86716
86437: LD_INT 4
86439: DOUBLE
86440: EQUAL
86441: IFTRUE 86445
86443: GO 86578
86445: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86446: LD_ADDR_VAR 0 5
86450: PUSH
86451: LD_VAR 0 1
86455: PUSH
86456: LD_VAR 0 2
86460: PUSH
86461: LD_INT 4
86463: PLUS
86464: PUSH
86465: LD_INT 0
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: LIST
86472: PUSH
86473: LD_VAR 0 1
86477: PUSH
86478: LD_INT 3
86480: PLUS
86481: PUSH
86482: LD_VAR 0 2
86486: PUSH
86487: LD_INT 3
86489: PLUS
86490: PUSH
86491: LD_INT 5
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 4
86506: PLUS
86507: PUSH
86508: LD_VAR 0 2
86512: PUSH
86513: LD_INT 4
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: LIST
86520: PUSH
86521: LD_VAR 0 1
86525: PUSH
86526: LD_VAR 0 2
86530: PUSH
86531: LD_INT 3
86533: MINUS
86534: PUSH
86535: LD_INT 3
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: LIST
86542: PUSH
86543: LD_VAR 0 1
86547: PUSH
86548: LD_INT 4
86550: MINUS
86551: PUSH
86552: LD_VAR 0 2
86556: PUSH
86557: LD_INT 4
86559: MINUS
86560: PUSH
86561: LD_INT 2
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: LIST
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: ST_TO_ADDR
// end ; 5 :
86576: GO 86716
86578: LD_INT 5
86580: DOUBLE
86581: EQUAL
86582: IFTRUE 86586
86584: GO 86715
86586: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86587: LD_ADDR_VAR 0 5
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_INT 4
86599: MINUS
86600: PUSH
86601: LD_VAR 0 2
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: LIST
86613: PUSH
86614: LD_VAR 0 1
86618: PUSH
86619: LD_VAR 0 2
86623: PUSH
86624: LD_INT 4
86626: MINUS
86627: PUSH
86628: LD_INT 3
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: LIST
86635: PUSH
86636: LD_VAR 0 1
86640: PUSH
86641: LD_INT 4
86643: PLUS
86644: PUSH
86645: LD_VAR 0 2
86649: PUSH
86650: LD_INT 4
86652: PLUS
86653: PUSH
86654: LD_INT 5
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: LIST
86661: PUSH
86662: LD_VAR 0 1
86666: PUSH
86667: LD_INT 3
86669: PLUS
86670: PUSH
86671: LD_VAR 0 2
86675: PUSH
86676: LD_INT 4
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: LIST
86683: PUSH
86684: LD_VAR 0 1
86688: PUSH
86689: LD_VAR 0 2
86693: PUSH
86694: LD_INT 3
86696: PLUS
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: LIST
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: ST_TO_ADDR
// end ; end ;
86713: GO 86716
86715: POP
// result := list ;
86716: LD_ADDR_VAR 0 4
86720: PUSH
86721: LD_VAR 0 5
86725: ST_TO_ADDR
// end ;
86726: LD_VAR 0 4
86730: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86731: LD_INT 0
86733: PPUSH
86734: PPUSH
86735: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86736: LD_VAR 0 1
86740: NOT
86741: PUSH
86742: LD_VAR 0 2
86746: PUSH
86747: LD_INT 1
86749: PUSH
86750: LD_INT 2
86752: PUSH
86753: LD_INT 3
86755: PUSH
86756: LD_INT 4
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: IN
86765: NOT
86766: OR
86767: IFFALSE 86771
// exit ;
86769: GO 86863
// tmp := [ ] ;
86771: LD_ADDR_VAR 0 5
86775: PUSH
86776: EMPTY
86777: ST_TO_ADDR
// for i in units do
86778: LD_ADDR_VAR 0 4
86782: PUSH
86783: LD_VAR 0 1
86787: PUSH
86788: FOR_IN
86789: IFFALSE 86832
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86791: LD_ADDR_VAR 0 5
86795: PUSH
86796: LD_VAR 0 5
86800: PPUSH
86801: LD_VAR 0 5
86805: PUSH
86806: LD_INT 1
86808: PLUS
86809: PPUSH
86810: LD_VAR 0 4
86814: PPUSH
86815: LD_VAR 0 2
86819: PPUSH
86820: CALL_OW 259
86824: PPUSH
86825: CALL_OW 2
86829: ST_TO_ADDR
86830: GO 86788
86832: POP
86833: POP
// if not tmp then
86834: LD_VAR 0 5
86838: NOT
86839: IFFALSE 86843
// exit ;
86841: GO 86863
// result := SortListByListDesc ( units , tmp ) ;
86843: LD_ADDR_VAR 0 3
86847: PUSH
86848: LD_VAR 0 1
86852: PPUSH
86853: LD_VAR 0 5
86857: PPUSH
86858: CALL_OW 77
86862: ST_TO_ADDR
// end ;
86863: LD_VAR 0 3
86867: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86868: LD_INT 0
86870: PPUSH
86871: PPUSH
86872: PPUSH
// result := false ;
86873: LD_ADDR_VAR 0 3
86877: PUSH
86878: LD_INT 0
86880: ST_TO_ADDR
// x := GetX ( building ) ;
86881: LD_ADDR_VAR 0 4
86885: PUSH
86886: LD_VAR 0 2
86890: PPUSH
86891: CALL_OW 250
86895: ST_TO_ADDR
// y := GetY ( building ) ;
86896: LD_ADDR_VAR 0 5
86900: PUSH
86901: LD_VAR 0 2
86905: PPUSH
86906: CALL_OW 251
86910: ST_TO_ADDR
// if not building or not x or not y then
86911: LD_VAR 0 2
86915: NOT
86916: PUSH
86917: LD_VAR 0 4
86921: NOT
86922: OR
86923: PUSH
86924: LD_VAR 0 5
86928: NOT
86929: OR
86930: IFFALSE 86934
// exit ;
86932: GO 87026
// if GetTaskList ( unit ) then
86934: LD_VAR 0 1
86938: PPUSH
86939: CALL_OW 437
86943: IFFALSE 87026
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86945: LD_STRING e
86947: PUSH
86948: LD_VAR 0 1
86952: PPUSH
86953: CALL_OW 437
86957: PUSH
86958: LD_INT 1
86960: ARRAY
86961: PUSH
86962: LD_INT 1
86964: ARRAY
86965: EQUAL
86966: PUSH
86967: LD_VAR 0 4
86971: PUSH
86972: LD_VAR 0 1
86976: PPUSH
86977: CALL_OW 437
86981: PUSH
86982: LD_INT 1
86984: ARRAY
86985: PUSH
86986: LD_INT 2
86988: ARRAY
86989: EQUAL
86990: AND
86991: PUSH
86992: LD_VAR 0 5
86996: PUSH
86997: LD_VAR 0 1
87001: PPUSH
87002: CALL_OW 437
87006: PUSH
87007: LD_INT 1
87009: ARRAY
87010: PUSH
87011: LD_INT 3
87013: ARRAY
87014: EQUAL
87015: AND
87016: IFFALSE 87026
// result := true end ;
87018: LD_ADDR_VAR 0 3
87022: PUSH
87023: LD_INT 1
87025: ST_TO_ADDR
// end ;
87026: LD_VAR 0 3
87030: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87031: LD_INT 0
87033: PPUSH
// result := false ;
87034: LD_ADDR_VAR 0 4
87038: PUSH
87039: LD_INT 0
87041: ST_TO_ADDR
// if GetTaskList ( unit ) then
87042: LD_VAR 0 1
87046: PPUSH
87047: CALL_OW 437
87051: IFFALSE 87134
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87053: LD_STRING M
87055: PUSH
87056: LD_VAR 0 1
87060: PPUSH
87061: CALL_OW 437
87065: PUSH
87066: LD_INT 1
87068: ARRAY
87069: PUSH
87070: LD_INT 1
87072: ARRAY
87073: EQUAL
87074: PUSH
87075: LD_VAR 0 2
87079: PUSH
87080: LD_VAR 0 1
87084: PPUSH
87085: CALL_OW 437
87089: PUSH
87090: LD_INT 1
87092: ARRAY
87093: PUSH
87094: LD_INT 2
87096: ARRAY
87097: EQUAL
87098: AND
87099: PUSH
87100: LD_VAR 0 3
87104: PUSH
87105: LD_VAR 0 1
87109: PPUSH
87110: CALL_OW 437
87114: PUSH
87115: LD_INT 1
87117: ARRAY
87118: PUSH
87119: LD_INT 3
87121: ARRAY
87122: EQUAL
87123: AND
87124: IFFALSE 87134
// result := true ;
87126: LD_ADDR_VAR 0 4
87130: PUSH
87131: LD_INT 1
87133: ST_TO_ADDR
// end ; end ;
87134: LD_VAR 0 4
87138: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87139: LD_INT 0
87141: PPUSH
87142: PPUSH
87143: PPUSH
87144: PPUSH
// if not unit or not area then
87145: LD_VAR 0 1
87149: NOT
87150: PUSH
87151: LD_VAR 0 2
87155: NOT
87156: OR
87157: IFFALSE 87161
// exit ;
87159: GO 87325
// tmp := AreaToList ( area , i ) ;
87161: LD_ADDR_VAR 0 6
87165: PUSH
87166: LD_VAR 0 2
87170: PPUSH
87171: LD_VAR 0 5
87175: PPUSH
87176: CALL_OW 517
87180: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87181: LD_ADDR_VAR 0 5
87185: PUSH
87186: DOUBLE
87187: LD_INT 1
87189: DEC
87190: ST_TO_ADDR
87191: LD_VAR 0 6
87195: PUSH
87196: LD_INT 1
87198: ARRAY
87199: PUSH
87200: FOR_TO
87201: IFFALSE 87323
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87203: LD_ADDR_VAR 0 7
87207: PUSH
87208: LD_VAR 0 6
87212: PUSH
87213: LD_INT 1
87215: ARRAY
87216: PUSH
87217: LD_VAR 0 5
87221: ARRAY
87222: PUSH
87223: LD_VAR 0 6
87227: PUSH
87228: LD_INT 2
87230: ARRAY
87231: PUSH
87232: LD_VAR 0 5
87236: ARRAY
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87242: LD_VAR 0 7
87246: PUSH
87247: LD_INT 1
87249: ARRAY
87250: PPUSH
87251: LD_VAR 0 7
87255: PUSH
87256: LD_INT 2
87258: ARRAY
87259: PPUSH
87260: CALL_OW 428
87264: PUSH
87265: LD_INT 0
87267: EQUAL
87268: IFFALSE 87321
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87270: LD_VAR 0 1
87274: PPUSH
87275: LD_VAR 0 7
87279: PUSH
87280: LD_INT 1
87282: ARRAY
87283: PPUSH
87284: LD_VAR 0 7
87288: PUSH
87289: LD_INT 2
87291: ARRAY
87292: PPUSH
87293: LD_VAR 0 3
87297: PPUSH
87298: CALL_OW 48
// result := IsPlaced ( unit ) ;
87302: LD_ADDR_VAR 0 4
87306: PUSH
87307: LD_VAR 0 1
87311: PPUSH
87312: CALL_OW 305
87316: ST_TO_ADDR
// exit ;
87317: POP
87318: POP
87319: GO 87325
// end ; end ;
87321: GO 87200
87323: POP
87324: POP
// end ;
87325: LD_VAR 0 4
87329: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87330: LD_INT 0
87332: PPUSH
87333: PPUSH
87334: PPUSH
// if not side or side > 8 then
87335: LD_VAR 0 1
87339: NOT
87340: PUSH
87341: LD_VAR 0 1
87345: PUSH
87346: LD_INT 8
87348: GREATER
87349: OR
87350: IFFALSE 87354
// exit ;
87352: GO 87541
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87354: LD_ADDR_VAR 0 4
87358: PUSH
87359: LD_INT 22
87361: PUSH
87362: LD_VAR 0 1
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 21
87373: PUSH
87374: LD_INT 3
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PPUSH
87385: CALL_OW 69
87389: ST_TO_ADDR
// if not tmp then
87390: LD_VAR 0 4
87394: NOT
87395: IFFALSE 87399
// exit ;
87397: GO 87541
// enable_addtolog := true ;
87399: LD_ADDR_OWVAR 81
87403: PUSH
87404: LD_INT 1
87406: ST_TO_ADDR
// AddToLog ( [ ) ;
87407: LD_STRING [
87409: PPUSH
87410: CALL_OW 561
// for i in tmp do
87414: LD_ADDR_VAR 0 3
87418: PUSH
87419: LD_VAR 0 4
87423: PUSH
87424: FOR_IN
87425: IFFALSE 87532
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87427: LD_STRING [
87429: PUSH
87430: LD_VAR 0 3
87434: PPUSH
87435: CALL_OW 266
87439: STR
87440: PUSH
87441: LD_STRING , 
87443: STR
87444: PUSH
87445: LD_VAR 0 3
87449: PPUSH
87450: CALL_OW 250
87454: STR
87455: PUSH
87456: LD_STRING , 
87458: STR
87459: PUSH
87460: LD_VAR 0 3
87464: PPUSH
87465: CALL_OW 251
87469: STR
87470: PUSH
87471: LD_STRING , 
87473: STR
87474: PUSH
87475: LD_VAR 0 3
87479: PPUSH
87480: CALL_OW 254
87484: STR
87485: PUSH
87486: LD_STRING , 
87488: STR
87489: PUSH
87490: LD_VAR 0 3
87494: PPUSH
87495: LD_INT 1
87497: PPUSH
87498: CALL_OW 268
87502: STR
87503: PUSH
87504: LD_STRING , 
87506: STR
87507: PUSH
87508: LD_VAR 0 3
87512: PPUSH
87513: LD_INT 2
87515: PPUSH
87516: CALL_OW 268
87520: STR
87521: PUSH
87522: LD_STRING ],
87524: STR
87525: PPUSH
87526: CALL_OW 561
// end ;
87530: GO 87424
87532: POP
87533: POP
// AddToLog ( ]; ) ;
87534: LD_STRING ];
87536: PPUSH
87537: CALL_OW 561
// end ;
87541: LD_VAR 0 2
87545: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87546: LD_INT 0
87548: PPUSH
87549: PPUSH
87550: PPUSH
87551: PPUSH
87552: PPUSH
// if not area or not rate or not max then
87553: LD_VAR 0 1
87557: NOT
87558: PUSH
87559: LD_VAR 0 2
87563: NOT
87564: OR
87565: PUSH
87566: LD_VAR 0 4
87570: NOT
87571: OR
87572: IFFALSE 87576
// exit ;
87574: GO 87768
// while 1 do
87576: LD_INT 1
87578: IFFALSE 87768
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87580: LD_ADDR_VAR 0 9
87584: PUSH
87585: LD_VAR 0 1
87589: PPUSH
87590: LD_INT 1
87592: PPUSH
87593: CALL_OW 287
87597: PUSH
87598: LD_INT 10
87600: MUL
87601: ST_TO_ADDR
// r := rate / 10 ;
87602: LD_ADDR_VAR 0 7
87606: PUSH
87607: LD_VAR 0 2
87611: PUSH
87612: LD_INT 10
87614: DIVREAL
87615: ST_TO_ADDR
// time := 1 1$00 ;
87616: LD_ADDR_VAR 0 8
87620: PUSH
87621: LD_INT 2100
87623: ST_TO_ADDR
// if amount < min then
87624: LD_VAR 0 9
87628: PUSH
87629: LD_VAR 0 3
87633: LESS
87634: IFFALSE 87652
// r := r * 2 else
87636: LD_ADDR_VAR 0 7
87640: PUSH
87641: LD_VAR 0 7
87645: PUSH
87646: LD_INT 2
87648: MUL
87649: ST_TO_ADDR
87650: GO 87678
// if amount > max then
87652: LD_VAR 0 9
87656: PUSH
87657: LD_VAR 0 4
87661: GREATER
87662: IFFALSE 87678
// r := r / 2 ;
87664: LD_ADDR_VAR 0 7
87668: PUSH
87669: LD_VAR 0 7
87673: PUSH
87674: LD_INT 2
87676: DIVREAL
87677: ST_TO_ADDR
// time := time / r ;
87678: LD_ADDR_VAR 0 8
87682: PUSH
87683: LD_VAR 0 8
87687: PUSH
87688: LD_VAR 0 7
87692: DIVREAL
87693: ST_TO_ADDR
// if time < 0 then
87694: LD_VAR 0 8
87698: PUSH
87699: LD_INT 0
87701: LESS
87702: IFFALSE 87719
// time := time * - 1 ;
87704: LD_ADDR_VAR 0 8
87708: PUSH
87709: LD_VAR 0 8
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: MUL
87718: ST_TO_ADDR
// wait ( time ) ;
87719: LD_VAR 0 8
87723: PPUSH
87724: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87728: LD_INT 35
87730: PPUSH
87731: LD_INT 875
87733: PPUSH
87734: CALL_OW 12
87738: PPUSH
87739: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87743: LD_INT 1
87745: PPUSH
87746: LD_INT 5
87748: PPUSH
87749: CALL_OW 12
87753: PPUSH
87754: LD_VAR 0 1
87758: PPUSH
87759: LD_INT 1
87761: PPUSH
87762: CALL_OW 55
// end ;
87766: GO 87576
// end ;
87768: LD_VAR 0 5
87772: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87773: LD_INT 0
87775: PPUSH
87776: PPUSH
87777: PPUSH
87778: PPUSH
87779: PPUSH
87780: PPUSH
87781: PPUSH
87782: PPUSH
// if not turrets or not factories then
87783: LD_VAR 0 1
87787: NOT
87788: PUSH
87789: LD_VAR 0 2
87793: NOT
87794: OR
87795: IFFALSE 87799
// exit ;
87797: GO 88106
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87799: LD_ADDR_VAR 0 10
87803: PUSH
87804: LD_INT 5
87806: PUSH
87807: LD_INT 6
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: LD_INT 4
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 3
87826: PUSH
87827: LD_INT 5
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 24
87841: PUSH
87842: LD_INT 25
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 23
87851: PUSH
87852: LD_INT 27
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: PUSH
87863: LD_INT 42
87865: PUSH
87866: LD_INT 43
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 44
87875: PUSH
87876: LD_INT 46
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 45
87885: PUSH
87886: LD_INT 47
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: LIST
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: LIST
87902: ST_TO_ADDR
// result := [ ] ;
87903: LD_ADDR_VAR 0 3
87907: PUSH
87908: EMPTY
87909: ST_TO_ADDR
// for i in turrets do
87910: LD_ADDR_VAR 0 4
87914: PUSH
87915: LD_VAR 0 1
87919: PUSH
87920: FOR_IN
87921: IFFALSE 88104
// begin nat := GetNation ( i ) ;
87923: LD_ADDR_VAR 0 7
87927: PUSH
87928: LD_VAR 0 4
87932: PPUSH
87933: CALL_OW 248
87937: ST_TO_ADDR
// weapon := 0 ;
87938: LD_ADDR_VAR 0 8
87942: PUSH
87943: LD_INT 0
87945: ST_TO_ADDR
// if not nat then
87946: LD_VAR 0 7
87950: NOT
87951: IFFALSE 87955
// continue ;
87953: GO 87920
// for j in list [ nat ] do
87955: LD_ADDR_VAR 0 5
87959: PUSH
87960: LD_VAR 0 10
87964: PUSH
87965: LD_VAR 0 7
87969: ARRAY
87970: PUSH
87971: FOR_IN
87972: IFFALSE 88013
// if GetBWeapon ( i ) = j [ 1 ] then
87974: LD_VAR 0 4
87978: PPUSH
87979: CALL_OW 269
87983: PUSH
87984: LD_VAR 0 5
87988: PUSH
87989: LD_INT 1
87991: ARRAY
87992: EQUAL
87993: IFFALSE 88011
// begin weapon := j [ 2 ] ;
87995: LD_ADDR_VAR 0 8
87999: PUSH
88000: LD_VAR 0 5
88004: PUSH
88005: LD_INT 2
88007: ARRAY
88008: ST_TO_ADDR
// break ;
88009: GO 88013
// end ;
88011: GO 87971
88013: POP
88014: POP
// if not weapon then
88015: LD_VAR 0 8
88019: NOT
88020: IFFALSE 88024
// continue ;
88022: GO 87920
// for k in factories do
88024: LD_ADDR_VAR 0 6
88028: PUSH
88029: LD_VAR 0 2
88033: PUSH
88034: FOR_IN
88035: IFFALSE 88100
// begin weapons := AvailableWeaponList ( k ) ;
88037: LD_ADDR_VAR 0 9
88041: PUSH
88042: LD_VAR 0 6
88046: PPUSH
88047: CALL_OW 478
88051: ST_TO_ADDR
// if not weapons then
88052: LD_VAR 0 9
88056: NOT
88057: IFFALSE 88061
// continue ;
88059: GO 88034
// if weapon in weapons then
88061: LD_VAR 0 8
88065: PUSH
88066: LD_VAR 0 9
88070: IN
88071: IFFALSE 88098
// begin result := [ i , weapon ] ;
88073: LD_ADDR_VAR 0 3
88077: PUSH
88078: LD_VAR 0 4
88082: PUSH
88083: LD_VAR 0 8
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: ST_TO_ADDR
// exit ;
88092: POP
88093: POP
88094: POP
88095: POP
88096: GO 88106
// end ; end ;
88098: GO 88034
88100: POP
88101: POP
// end ;
88102: GO 87920
88104: POP
88105: POP
// end ;
88106: LD_VAR 0 3
88110: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88111: LD_INT 0
88113: PPUSH
// if not side or side > 8 then
88114: LD_VAR 0 3
88118: NOT
88119: PUSH
88120: LD_VAR 0 3
88124: PUSH
88125: LD_INT 8
88127: GREATER
88128: OR
88129: IFFALSE 88133
// exit ;
88131: GO 88192
// if not range then
88133: LD_VAR 0 4
88137: NOT
88138: IFFALSE 88149
// range := - 12 ;
88140: LD_ADDR_VAR 0 4
88144: PUSH
88145: LD_INT 12
88147: NEG
88148: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88149: LD_VAR 0 1
88153: PPUSH
88154: LD_VAR 0 2
88158: PPUSH
88159: LD_VAR 0 3
88163: PPUSH
88164: LD_VAR 0 4
88168: PPUSH
88169: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88173: LD_VAR 0 1
88177: PPUSH
88178: LD_VAR 0 2
88182: PPUSH
88183: LD_VAR 0 3
88187: PPUSH
88188: CALL_OW 331
// end ;
88192: LD_VAR 0 5
88196: RET
// export function Video ( mode ) ; begin
88197: LD_INT 0
88199: PPUSH
// ingame_video = mode ;
88200: LD_ADDR_OWVAR 52
88204: PUSH
88205: LD_VAR 0 1
88209: ST_TO_ADDR
// interface_hidden = mode ;
88210: LD_ADDR_OWVAR 54
88214: PUSH
88215: LD_VAR 0 1
88219: ST_TO_ADDR
// end ;
88220: LD_VAR 0 2
88224: RET
// export function Join ( array , element ) ; begin
88225: LD_INT 0
88227: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88228: LD_ADDR_VAR 0 3
88232: PUSH
88233: LD_VAR 0 1
88237: PPUSH
88238: LD_VAR 0 1
88242: PUSH
88243: LD_INT 1
88245: PLUS
88246: PPUSH
88247: LD_VAR 0 2
88251: PPUSH
88252: CALL_OW 1
88256: ST_TO_ADDR
// end ;
88257: LD_VAR 0 3
88261: RET
// export function JoinUnion ( array , element ) ; begin
88262: LD_INT 0
88264: PPUSH
// result := array union element ;
88265: LD_ADDR_VAR 0 3
88269: PUSH
88270: LD_VAR 0 1
88274: PUSH
88275: LD_VAR 0 2
88279: UNION
88280: ST_TO_ADDR
// end ;
88281: LD_VAR 0 3
88285: RET
// export function GetBehemoths ( side ) ; begin
88286: LD_INT 0
88288: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88289: LD_ADDR_VAR 0 2
88293: PUSH
88294: LD_INT 22
88296: PUSH
88297: LD_VAR 0 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 31
88308: PUSH
88309: LD_INT 25
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PPUSH
88320: CALL_OW 69
88324: ST_TO_ADDR
// end ;
88325: LD_VAR 0 2
88329: RET
// export function Shuffle ( array ) ; var i , index ; begin
88330: LD_INT 0
88332: PPUSH
88333: PPUSH
88334: PPUSH
// result := [ ] ;
88335: LD_ADDR_VAR 0 2
88339: PUSH
88340: EMPTY
88341: ST_TO_ADDR
// if not array then
88342: LD_VAR 0 1
88346: NOT
88347: IFFALSE 88351
// exit ;
88349: GO 88450
// Randomize ;
88351: CALL_OW 10
// for i = array downto 1 do
88355: LD_ADDR_VAR 0 3
88359: PUSH
88360: DOUBLE
88361: LD_VAR 0 1
88365: INC
88366: ST_TO_ADDR
88367: LD_INT 1
88369: PUSH
88370: FOR_DOWNTO
88371: IFFALSE 88448
// begin index := rand ( 1 , array ) ;
88373: LD_ADDR_VAR 0 4
88377: PUSH
88378: LD_INT 1
88380: PPUSH
88381: LD_VAR 0 1
88385: PPUSH
88386: CALL_OW 12
88390: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88391: LD_ADDR_VAR 0 2
88395: PUSH
88396: LD_VAR 0 2
88400: PPUSH
88401: LD_VAR 0 2
88405: PUSH
88406: LD_INT 1
88408: PLUS
88409: PPUSH
88410: LD_VAR 0 1
88414: PUSH
88415: LD_VAR 0 4
88419: ARRAY
88420: PPUSH
88421: CALL_OW 2
88425: ST_TO_ADDR
// array := Delete ( array , index ) ;
88426: LD_ADDR_VAR 0 1
88430: PUSH
88431: LD_VAR 0 1
88435: PPUSH
88436: LD_VAR 0 4
88440: PPUSH
88441: CALL_OW 3
88445: ST_TO_ADDR
// end ;
88446: GO 88370
88448: POP
88449: POP
// end ;
88450: LD_VAR 0 2
88454: RET
// export function GetBaseMaterials ( base ) ; begin
88455: LD_INT 0
88457: PPUSH
// result := [ 0 , 0 , 0 ] ;
88458: LD_ADDR_VAR 0 2
88462: PUSH
88463: LD_INT 0
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: LIST
88476: ST_TO_ADDR
// if not base then
88477: LD_VAR 0 1
88481: NOT
88482: IFFALSE 88486
// exit ;
88484: GO 88535
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88486: LD_ADDR_VAR 0 2
88490: PUSH
88491: LD_VAR 0 1
88495: PPUSH
88496: LD_INT 1
88498: PPUSH
88499: CALL_OW 275
88503: PUSH
88504: LD_VAR 0 1
88508: PPUSH
88509: LD_INT 2
88511: PPUSH
88512: CALL_OW 275
88516: PUSH
88517: LD_VAR 0 1
88521: PPUSH
88522: LD_INT 3
88524: PPUSH
88525: CALL_OW 275
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: LIST
88534: ST_TO_ADDR
// end ;
88535: LD_VAR 0 2
88539: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88540: LD_INT 0
88542: PPUSH
88543: PPUSH
// result := array ;
88544: LD_ADDR_VAR 0 3
88548: PUSH
88549: LD_VAR 0 1
88553: ST_TO_ADDR
// if size > 0 then
88554: LD_VAR 0 2
88558: PUSH
88559: LD_INT 0
88561: GREATER
88562: IFFALSE 88608
// for i := array downto size do
88564: LD_ADDR_VAR 0 4
88568: PUSH
88569: DOUBLE
88570: LD_VAR 0 1
88574: INC
88575: ST_TO_ADDR
88576: LD_VAR 0 2
88580: PUSH
88581: FOR_DOWNTO
88582: IFFALSE 88606
// result := Delete ( result , result ) ;
88584: LD_ADDR_VAR 0 3
88588: PUSH
88589: LD_VAR 0 3
88593: PPUSH
88594: LD_VAR 0 3
88598: PPUSH
88599: CALL_OW 3
88603: ST_TO_ADDR
88604: GO 88581
88606: POP
88607: POP
// end ;
88608: LD_VAR 0 3
88612: RET
// export function ComExit ( unit ) ; var tmp ; begin
88613: LD_INT 0
88615: PPUSH
88616: PPUSH
// if not IsInUnit ( unit ) then
88617: LD_VAR 0 1
88621: PPUSH
88622: CALL_OW 310
88626: NOT
88627: IFFALSE 88631
// exit ;
88629: GO 88691
// tmp := IsInUnit ( unit ) ;
88631: LD_ADDR_VAR 0 3
88635: PUSH
88636: LD_VAR 0 1
88640: PPUSH
88641: CALL_OW 310
88645: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88646: LD_VAR 0 3
88650: PPUSH
88651: CALL_OW 247
88655: PUSH
88656: LD_INT 2
88658: EQUAL
88659: IFFALSE 88672
// ComExitVehicle ( unit ) else
88661: LD_VAR 0 1
88665: PPUSH
88666: CALL_OW 121
88670: GO 88681
// ComExitBuilding ( unit ) ;
88672: LD_VAR 0 1
88676: PPUSH
88677: CALL_OW 122
// result := tmp ;
88681: LD_ADDR_VAR 0 2
88685: PUSH
88686: LD_VAR 0 3
88690: ST_TO_ADDR
// end ;
88691: LD_VAR 0 2
88695: RET
// export function ComExitAll ( units ) ; var i ; begin
88696: LD_INT 0
88698: PPUSH
88699: PPUSH
// if not units then
88700: LD_VAR 0 1
88704: NOT
88705: IFFALSE 88709
// exit ;
88707: GO 88735
// for i in units do
88709: LD_ADDR_VAR 0 3
88713: PUSH
88714: LD_VAR 0 1
88718: PUSH
88719: FOR_IN
88720: IFFALSE 88733
// ComExit ( i ) ;
88722: LD_VAR 0 3
88726: PPUSH
88727: CALL 88613 0 1
88731: GO 88719
88733: POP
88734: POP
// end ;
88735: LD_VAR 0 2
88739: RET
// export function ResetHc ; begin
88740: LD_INT 0
88742: PPUSH
// InitHc ;
88743: CALL_OW 19
// hc_importance := 0 ;
88747: LD_ADDR_OWVAR 32
88751: PUSH
88752: LD_INT 0
88754: ST_TO_ADDR
// end ;
88755: LD_VAR 0 1
88759: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88760: LD_INT 0
88762: PPUSH
88763: PPUSH
88764: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88765: LD_ADDR_VAR 0 6
88769: PUSH
88770: LD_VAR 0 1
88774: PUSH
88775: LD_VAR 0 3
88779: PLUS
88780: PUSH
88781: LD_INT 2
88783: DIV
88784: ST_TO_ADDR
// if _x < 0 then
88785: LD_VAR 0 6
88789: PUSH
88790: LD_INT 0
88792: LESS
88793: IFFALSE 88810
// _x := _x * - 1 ;
88795: LD_ADDR_VAR 0 6
88799: PUSH
88800: LD_VAR 0 6
88804: PUSH
88805: LD_INT 1
88807: NEG
88808: MUL
88809: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88810: LD_ADDR_VAR 0 7
88814: PUSH
88815: LD_VAR 0 2
88819: PUSH
88820: LD_VAR 0 4
88824: PLUS
88825: PUSH
88826: LD_INT 2
88828: DIV
88829: ST_TO_ADDR
// if _y < 0 then
88830: LD_VAR 0 7
88834: PUSH
88835: LD_INT 0
88837: LESS
88838: IFFALSE 88855
// _y := _y * - 1 ;
88840: LD_ADDR_VAR 0 7
88844: PUSH
88845: LD_VAR 0 7
88849: PUSH
88850: LD_INT 1
88852: NEG
88853: MUL
88854: ST_TO_ADDR
// result := [ _x , _y ] ;
88855: LD_ADDR_VAR 0 5
88859: PUSH
88860: LD_VAR 0 6
88864: PUSH
88865: LD_VAR 0 7
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: ST_TO_ADDR
// end ;
88874: LD_VAR 0 5
88878: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88879: LD_INT 0
88881: PPUSH
88882: PPUSH
88883: PPUSH
88884: PPUSH
// task := GetTaskList ( unit ) ;
88885: LD_ADDR_VAR 0 7
88889: PUSH
88890: LD_VAR 0 1
88894: PPUSH
88895: CALL_OW 437
88899: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88900: LD_VAR 0 7
88904: NOT
88905: PUSH
88906: LD_VAR 0 1
88910: PPUSH
88911: LD_VAR 0 2
88915: PPUSH
88916: CALL_OW 308
88920: NOT
88921: AND
88922: IFFALSE 88926
// exit ;
88924: GO 89044
// if IsInArea ( unit , area ) then
88926: LD_VAR 0 1
88930: PPUSH
88931: LD_VAR 0 2
88935: PPUSH
88936: CALL_OW 308
88940: IFFALSE 88958
// begin ComMoveToArea ( unit , goAway ) ;
88942: LD_VAR 0 1
88946: PPUSH
88947: LD_VAR 0 3
88951: PPUSH
88952: CALL_OW 113
// exit ;
88956: GO 89044
// end ; if task [ 1 ] [ 1 ] <> M then
88958: LD_VAR 0 7
88962: PUSH
88963: LD_INT 1
88965: ARRAY
88966: PUSH
88967: LD_INT 1
88969: ARRAY
88970: PUSH
88971: LD_STRING M
88973: NONEQUAL
88974: IFFALSE 88978
// exit ;
88976: GO 89044
// x := task [ 1 ] [ 2 ] ;
88978: LD_ADDR_VAR 0 5
88982: PUSH
88983: LD_VAR 0 7
88987: PUSH
88988: LD_INT 1
88990: ARRAY
88991: PUSH
88992: LD_INT 2
88994: ARRAY
88995: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88996: LD_ADDR_VAR 0 6
89000: PUSH
89001: LD_VAR 0 7
89005: PUSH
89006: LD_INT 1
89008: ARRAY
89009: PUSH
89010: LD_INT 3
89012: ARRAY
89013: ST_TO_ADDR
// if InArea ( x , y , area ) then
89014: LD_VAR 0 5
89018: PPUSH
89019: LD_VAR 0 6
89023: PPUSH
89024: LD_VAR 0 2
89028: PPUSH
89029: CALL_OW 309
89033: IFFALSE 89044
// ComStop ( unit ) ;
89035: LD_VAR 0 1
89039: PPUSH
89040: CALL_OW 141
// end ;
89044: LD_VAR 0 4
89048: RET
// export function Abs ( value ) ; begin
89049: LD_INT 0
89051: PPUSH
// result := value ;
89052: LD_ADDR_VAR 0 2
89056: PUSH
89057: LD_VAR 0 1
89061: ST_TO_ADDR
// if value < 0 then
89062: LD_VAR 0 1
89066: PUSH
89067: LD_INT 0
89069: LESS
89070: IFFALSE 89087
// result := value * - 1 ;
89072: LD_ADDR_VAR 0 2
89076: PUSH
89077: LD_VAR 0 1
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: MUL
89086: ST_TO_ADDR
// end ;
89087: LD_VAR 0 2
89091: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89092: LD_INT 0
89094: PPUSH
89095: PPUSH
89096: PPUSH
89097: PPUSH
89098: PPUSH
89099: PPUSH
89100: PPUSH
89101: PPUSH
// if not unit or not building then
89102: LD_VAR 0 1
89106: NOT
89107: PUSH
89108: LD_VAR 0 2
89112: NOT
89113: OR
89114: IFFALSE 89118
// exit ;
89116: GO 89344
// x := GetX ( building ) ;
89118: LD_ADDR_VAR 0 4
89122: PUSH
89123: LD_VAR 0 2
89127: PPUSH
89128: CALL_OW 250
89132: ST_TO_ADDR
// y := GetY ( building ) ;
89133: LD_ADDR_VAR 0 6
89137: PUSH
89138: LD_VAR 0 2
89142: PPUSH
89143: CALL_OW 251
89147: ST_TO_ADDR
// d := GetDir ( building ) ;
89148: LD_ADDR_VAR 0 8
89152: PUSH
89153: LD_VAR 0 2
89157: PPUSH
89158: CALL_OW 254
89162: ST_TO_ADDR
// r := 4 ;
89163: LD_ADDR_VAR 0 9
89167: PUSH
89168: LD_INT 4
89170: ST_TO_ADDR
// for i := 1 to 5 do
89171: LD_ADDR_VAR 0 10
89175: PUSH
89176: DOUBLE
89177: LD_INT 1
89179: DEC
89180: ST_TO_ADDR
89181: LD_INT 5
89183: PUSH
89184: FOR_TO
89185: IFFALSE 89342
// begin _x := ShiftX ( x , d , r + i ) ;
89187: LD_ADDR_VAR 0 5
89191: PUSH
89192: LD_VAR 0 4
89196: PPUSH
89197: LD_VAR 0 8
89201: PPUSH
89202: LD_VAR 0 9
89206: PUSH
89207: LD_VAR 0 10
89211: PLUS
89212: PPUSH
89213: CALL_OW 272
89217: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89218: LD_ADDR_VAR 0 7
89222: PUSH
89223: LD_VAR 0 6
89227: PPUSH
89228: LD_VAR 0 8
89232: PPUSH
89233: LD_VAR 0 9
89237: PUSH
89238: LD_VAR 0 10
89242: PLUS
89243: PPUSH
89244: CALL_OW 273
89248: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89249: LD_VAR 0 5
89253: PPUSH
89254: LD_VAR 0 7
89258: PPUSH
89259: CALL_OW 488
89263: PUSH
89264: LD_VAR 0 5
89268: PPUSH
89269: LD_VAR 0 7
89273: PPUSH
89274: CALL_OW 428
89278: PPUSH
89279: CALL_OW 247
89283: PUSH
89284: LD_INT 3
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: IN
89294: NOT
89295: AND
89296: IFFALSE 89340
// begin ComMoveXY ( unit , _x , _y ) ;
89298: LD_VAR 0 1
89302: PPUSH
89303: LD_VAR 0 5
89307: PPUSH
89308: LD_VAR 0 7
89312: PPUSH
89313: CALL_OW 111
// result := [ _x , _y ] ;
89317: LD_ADDR_VAR 0 3
89321: PUSH
89322: LD_VAR 0 5
89326: PUSH
89327: LD_VAR 0 7
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: ST_TO_ADDR
// exit ;
89336: POP
89337: POP
89338: GO 89344
// end ; end ;
89340: GO 89184
89342: POP
89343: POP
// end ;
89344: LD_VAR 0 3
89348: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89349: LD_INT 0
89351: PPUSH
89352: PPUSH
89353: PPUSH
// result := 0 ;
89354: LD_ADDR_VAR 0 3
89358: PUSH
89359: LD_INT 0
89361: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89362: LD_VAR 0 1
89366: PUSH
89367: LD_INT 0
89369: LESS
89370: PUSH
89371: LD_VAR 0 1
89375: PUSH
89376: LD_INT 8
89378: GREATER
89379: OR
89380: PUSH
89381: LD_VAR 0 2
89385: PUSH
89386: LD_INT 0
89388: LESS
89389: OR
89390: PUSH
89391: LD_VAR 0 2
89395: PUSH
89396: LD_INT 8
89398: GREATER
89399: OR
89400: IFFALSE 89404
// exit ;
89402: GO 89479
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89404: LD_ADDR_VAR 0 4
89408: PUSH
89409: LD_INT 22
89411: PUSH
89412: LD_VAR 0 2
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PPUSH
89421: CALL_OW 69
89425: PUSH
89426: FOR_IN
89427: IFFALSE 89477
// begin un := UnitShoot ( i ) ;
89429: LD_ADDR_VAR 0 5
89433: PUSH
89434: LD_VAR 0 4
89438: PPUSH
89439: CALL_OW 504
89443: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89444: LD_VAR 0 5
89448: PPUSH
89449: CALL_OW 255
89453: PUSH
89454: LD_VAR 0 1
89458: EQUAL
89459: IFFALSE 89475
// begin result := un ;
89461: LD_ADDR_VAR 0 3
89465: PUSH
89466: LD_VAR 0 5
89470: ST_TO_ADDR
// exit ;
89471: POP
89472: POP
89473: GO 89479
// end ; end ;
89475: GO 89426
89477: POP
89478: POP
// end ;
89479: LD_VAR 0 3
89483: RET
// export function GetCargoBay ( units ) ; begin
89484: LD_INT 0
89486: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89487: LD_ADDR_VAR 0 2
89491: PUSH
89492: LD_VAR 0 1
89496: PPUSH
89497: LD_INT 2
89499: PUSH
89500: LD_INT 34
89502: PUSH
89503: LD_INT 12
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 34
89512: PUSH
89513: LD_INT 51
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 34
89522: PUSH
89523: LD_INT 32
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 34
89532: PUSH
89533: LD_EXP 73
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: PPUSH
89549: CALL_OW 72
89553: ST_TO_ADDR
// end ;
89554: LD_VAR 0 2
89558: RET
// export function Negate ( value ) ; begin
89559: LD_INT 0
89561: PPUSH
// result := not value ;
89562: LD_ADDR_VAR 0 2
89566: PUSH
89567: LD_VAR 0 1
89571: NOT
89572: ST_TO_ADDR
// end ;
89573: LD_VAR 0 2
89577: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89578: LD_INT 0
89580: PPUSH
// if x1 = x2 then
89581: LD_VAR 0 1
89585: PUSH
89586: LD_VAR 0 3
89590: EQUAL
89591: IFFALSE 89625
// begin if y1 > y2 then
89593: LD_VAR 0 2
89597: PUSH
89598: LD_VAR 0 4
89602: GREATER
89603: IFFALSE 89615
// result := 0 else
89605: LD_ADDR_VAR 0 5
89609: PUSH
89610: LD_INT 0
89612: ST_TO_ADDR
89613: GO 89623
// result := 3 ;
89615: LD_ADDR_VAR 0 5
89619: PUSH
89620: LD_INT 3
89622: ST_TO_ADDR
// exit ;
89623: GO 89711
// end ; if y1 = y2 then
89625: LD_VAR 0 2
89629: PUSH
89630: LD_VAR 0 4
89634: EQUAL
89635: IFFALSE 89669
// begin if x1 > x2 then
89637: LD_VAR 0 1
89641: PUSH
89642: LD_VAR 0 3
89646: GREATER
89647: IFFALSE 89659
// result := 1 else
89649: LD_ADDR_VAR 0 5
89653: PUSH
89654: LD_INT 1
89656: ST_TO_ADDR
89657: GO 89667
// result := 4 ;
89659: LD_ADDR_VAR 0 5
89663: PUSH
89664: LD_INT 4
89666: ST_TO_ADDR
// exit ;
89667: GO 89711
// end ; if x1 > x2 and y1 > y2 then
89669: LD_VAR 0 1
89673: PUSH
89674: LD_VAR 0 3
89678: GREATER
89679: PUSH
89680: LD_VAR 0 2
89684: PUSH
89685: LD_VAR 0 4
89689: GREATER
89690: AND
89691: IFFALSE 89703
// result := 2 else
89693: LD_ADDR_VAR 0 5
89697: PUSH
89698: LD_INT 2
89700: ST_TO_ADDR
89701: GO 89711
// result := 5 ;
89703: LD_ADDR_VAR 0 5
89707: PUSH
89708: LD_INT 5
89710: ST_TO_ADDR
// end ;
89711: LD_VAR 0 5
89715: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89716: LD_INT 0
89718: PPUSH
89719: PPUSH
// if not driver or not IsInUnit ( driver ) then
89720: LD_VAR 0 1
89724: NOT
89725: PUSH
89726: LD_VAR 0 1
89730: PPUSH
89731: CALL_OW 310
89735: NOT
89736: OR
89737: IFFALSE 89741
// exit ;
89739: GO 89831
// vehicle := IsInUnit ( driver ) ;
89741: LD_ADDR_VAR 0 3
89745: PUSH
89746: LD_VAR 0 1
89750: PPUSH
89751: CALL_OW 310
89755: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89756: LD_VAR 0 1
89760: PPUSH
89761: LD_STRING \
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: LD_INT 0
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: LD_INT 0
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: PUSH
89791: LD_STRING E
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: LD_VAR 0 3
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: LD_INT 0
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PPUSH
89827: CALL_OW 446
// end ;
89831: LD_VAR 0 2
89835: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89836: LD_INT 0
89838: PPUSH
89839: PPUSH
// if not driver or not IsInUnit ( driver ) then
89840: LD_VAR 0 1
89844: NOT
89845: PUSH
89846: LD_VAR 0 1
89850: PPUSH
89851: CALL_OW 310
89855: NOT
89856: OR
89857: IFFALSE 89861
// exit ;
89859: GO 89951
// vehicle := IsInUnit ( driver ) ;
89861: LD_ADDR_VAR 0 3
89865: PUSH
89866: LD_VAR 0 1
89870: PPUSH
89871: CALL_OW 310
89875: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89876: LD_VAR 0 1
89880: PPUSH
89881: LD_STRING \
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: LD_INT 0
89889: PUSH
89890: LD_INT 0
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: PUSH
89911: LD_STRING E
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 0
89919: PUSH
89920: LD_VAR 0 3
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PPUSH
89947: CALL_OW 447
// end ;
89951: LD_VAR 0 2
89955: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89956: LD_INT 0
89958: PPUSH
89959: PPUSH
89960: PPUSH
// tmp := [ ] ;
89961: LD_ADDR_VAR 0 5
89965: PUSH
89966: EMPTY
89967: ST_TO_ADDR
// for i in units do
89968: LD_ADDR_VAR 0 4
89972: PUSH
89973: LD_VAR 0 1
89977: PUSH
89978: FOR_IN
89979: IFFALSE 90017
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89981: LD_ADDR_VAR 0 5
89985: PUSH
89986: LD_VAR 0 5
89990: PPUSH
89991: LD_VAR 0 5
89995: PUSH
89996: LD_INT 1
89998: PLUS
89999: PPUSH
90000: LD_VAR 0 4
90004: PPUSH
90005: CALL_OW 256
90009: PPUSH
90010: CALL_OW 2
90014: ST_TO_ADDR
90015: GO 89978
90017: POP
90018: POP
// if not tmp then
90019: LD_VAR 0 5
90023: NOT
90024: IFFALSE 90028
// exit ;
90026: GO 90076
// if asc then
90028: LD_VAR 0 2
90032: IFFALSE 90056
// result := SortListByListAsc ( units , tmp ) else
90034: LD_ADDR_VAR 0 3
90038: PUSH
90039: LD_VAR 0 1
90043: PPUSH
90044: LD_VAR 0 5
90048: PPUSH
90049: CALL_OW 76
90053: ST_TO_ADDR
90054: GO 90076
// result := SortListByListDesc ( units , tmp ) ;
90056: LD_ADDR_VAR 0 3
90060: PUSH
90061: LD_VAR 0 1
90065: PPUSH
90066: LD_VAR 0 5
90070: PPUSH
90071: CALL_OW 77
90075: ST_TO_ADDR
// end ;
90076: LD_VAR 0 3
90080: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90081: LD_INT 0
90083: PPUSH
90084: PPUSH
// task := GetTaskList ( mech ) ;
90085: LD_ADDR_VAR 0 4
90089: PUSH
90090: LD_VAR 0 1
90094: PPUSH
90095: CALL_OW 437
90099: ST_TO_ADDR
// if not task then
90100: LD_VAR 0 4
90104: NOT
90105: IFFALSE 90109
// exit ;
90107: GO 90151
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90109: LD_ADDR_VAR 0 3
90113: PUSH
90114: LD_VAR 0 4
90118: PUSH
90119: LD_INT 1
90121: ARRAY
90122: PUSH
90123: LD_INT 1
90125: ARRAY
90126: PUSH
90127: LD_STRING r
90129: EQUAL
90130: PUSH
90131: LD_VAR 0 4
90135: PUSH
90136: LD_INT 1
90138: ARRAY
90139: PUSH
90140: LD_INT 4
90142: ARRAY
90143: PUSH
90144: LD_VAR 0 2
90148: EQUAL
90149: AND
90150: ST_TO_ADDR
// end ;
90151: LD_VAR 0 3
90155: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90156: LD_INT 0
90158: PPUSH
// SetDir ( unit , d ) ;
90159: LD_VAR 0 1
90163: PPUSH
90164: LD_VAR 0 4
90168: PPUSH
90169: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90173: LD_VAR 0 1
90177: PPUSH
90178: LD_VAR 0 2
90182: PPUSH
90183: LD_VAR 0 3
90187: PPUSH
90188: LD_VAR 0 5
90192: PPUSH
90193: CALL_OW 48
// end ;
90197: LD_VAR 0 6
90201: RET
// export function ToNaturalNumber ( number ) ; begin
90202: LD_INT 0
90204: PPUSH
// result := number div 1 ;
90205: LD_ADDR_VAR 0 2
90209: PUSH
90210: LD_VAR 0 1
90214: PUSH
90215: LD_INT 1
90217: DIV
90218: ST_TO_ADDR
// if number < 0 then
90219: LD_VAR 0 1
90223: PUSH
90224: LD_INT 0
90226: LESS
90227: IFFALSE 90237
// result := 0 ;
90229: LD_ADDR_VAR 0 2
90233: PUSH
90234: LD_INT 0
90236: ST_TO_ADDR
// end ;
90237: LD_VAR 0 2
90241: RET
// export function SortByClass ( units , class ) ; var un ; begin
90242: LD_INT 0
90244: PPUSH
90245: PPUSH
// if not units or not class then
90246: LD_VAR 0 1
90250: NOT
90251: PUSH
90252: LD_VAR 0 2
90256: NOT
90257: OR
90258: IFFALSE 90262
// exit ;
90260: GO 90357
// result := [ ] ;
90262: LD_ADDR_VAR 0 3
90266: PUSH
90267: EMPTY
90268: ST_TO_ADDR
// for un in units do
90269: LD_ADDR_VAR 0 4
90273: PUSH
90274: LD_VAR 0 1
90278: PUSH
90279: FOR_IN
90280: IFFALSE 90355
// if GetClass ( un ) = class then
90282: LD_VAR 0 4
90286: PPUSH
90287: CALL_OW 257
90291: PUSH
90292: LD_VAR 0 2
90296: EQUAL
90297: IFFALSE 90324
// result := Insert ( result , 1 , un ) else
90299: LD_ADDR_VAR 0 3
90303: PUSH
90304: LD_VAR 0 3
90308: PPUSH
90309: LD_INT 1
90311: PPUSH
90312: LD_VAR 0 4
90316: PPUSH
90317: CALL_OW 2
90321: ST_TO_ADDR
90322: GO 90353
// result := Replace ( result , result + 1 , un ) ;
90324: LD_ADDR_VAR 0 3
90328: PUSH
90329: LD_VAR 0 3
90333: PPUSH
90334: LD_VAR 0 3
90338: PUSH
90339: LD_INT 1
90341: PLUS
90342: PPUSH
90343: LD_VAR 0 4
90347: PPUSH
90348: CALL_OW 1
90352: ST_TO_ADDR
90353: GO 90279
90355: POP
90356: POP
// end ;
90357: LD_VAR 0 3
90361: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
90362: LD_INT 0
90364: PPUSH
90365: PPUSH
90366: PPUSH
90367: PPUSH
90368: PPUSH
90369: PPUSH
90370: PPUSH
// result := [ ] ;
90371: LD_ADDR_VAR 0 4
90375: PUSH
90376: EMPTY
90377: ST_TO_ADDR
// if x - r < 0 then
90378: LD_VAR 0 1
90382: PUSH
90383: LD_VAR 0 3
90387: MINUS
90388: PUSH
90389: LD_INT 0
90391: LESS
90392: IFFALSE 90404
// min_x := 0 else
90394: LD_ADDR_VAR 0 8
90398: PUSH
90399: LD_INT 0
90401: ST_TO_ADDR
90402: GO 90420
// min_x := x - r ;
90404: LD_ADDR_VAR 0 8
90408: PUSH
90409: LD_VAR 0 1
90413: PUSH
90414: LD_VAR 0 3
90418: MINUS
90419: ST_TO_ADDR
// if y - r < 0 then
90420: LD_VAR 0 2
90424: PUSH
90425: LD_VAR 0 3
90429: MINUS
90430: PUSH
90431: LD_INT 0
90433: LESS
90434: IFFALSE 90446
// min_y := 0 else
90436: LD_ADDR_VAR 0 7
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
90444: GO 90462
// min_y := y - r ;
90446: LD_ADDR_VAR 0 7
90450: PUSH
90451: LD_VAR 0 2
90455: PUSH
90456: LD_VAR 0 3
90460: MINUS
90461: ST_TO_ADDR
// max_x := x + r ;
90462: LD_ADDR_VAR 0 9
90466: PUSH
90467: LD_VAR 0 1
90471: PUSH
90472: LD_VAR 0 3
90476: PLUS
90477: ST_TO_ADDR
// max_y := y + r ;
90478: LD_ADDR_VAR 0 10
90482: PUSH
90483: LD_VAR 0 2
90487: PUSH
90488: LD_VAR 0 3
90492: PLUS
90493: ST_TO_ADDR
// for _x = min_x to max_x do
90494: LD_ADDR_VAR 0 5
90498: PUSH
90499: DOUBLE
90500: LD_VAR 0 8
90504: DEC
90505: ST_TO_ADDR
90506: LD_VAR 0 9
90510: PUSH
90511: FOR_TO
90512: IFFALSE 90613
// for _y = min_y to max_y do
90514: LD_ADDR_VAR 0 6
90518: PUSH
90519: DOUBLE
90520: LD_VAR 0 7
90524: DEC
90525: ST_TO_ADDR
90526: LD_VAR 0 10
90530: PUSH
90531: FOR_TO
90532: IFFALSE 90609
// begin if not ValidHex ( _x , _y ) then
90534: LD_VAR 0 5
90538: PPUSH
90539: LD_VAR 0 6
90543: PPUSH
90544: CALL_OW 488
90548: NOT
90549: IFFALSE 90553
// continue ;
90551: GO 90531
// if GetResourceTypeXY ( _x , _y ) then
90553: LD_VAR 0 5
90557: PPUSH
90558: LD_VAR 0 6
90562: PPUSH
90563: CALL_OW 283
90567: IFFALSE 90607
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
90569: LD_ADDR_VAR 0 4
90573: PUSH
90574: LD_VAR 0 4
90578: PPUSH
90579: LD_VAR 0 4
90583: PUSH
90584: LD_INT 1
90586: PLUS
90587: PPUSH
90588: LD_VAR 0 5
90592: PUSH
90593: LD_VAR 0 6
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PPUSH
90602: CALL_OW 1
90606: ST_TO_ADDR
// end ;
90607: GO 90531
90609: POP
90610: POP
90611: GO 90511
90613: POP
90614: POP
// end ;
90615: LD_VAR 0 4
90619: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
90620: LD_INT 0
90622: PPUSH
90623: PPUSH
90624: PPUSH
90625: PPUSH
90626: PPUSH
90627: PPUSH
// if not units then
90628: LD_VAR 0 1
90632: NOT
90633: IFFALSE 90637
// exit ;
90635: GO 91038
// result := UnitFilter ( units , [ f_ok ] ) ;
90637: LD_ADDR_VAR 0 3
90641: PUSH
90642: LD_VAR 0 1
90646: PPUSH
90647: LD_INT 50
90649: PUSH
90650: EMPTY
90651: LIST
90652: PPUSH
90653: CALL_OW 72
90657: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
90658: LD_ADDR_VAR 0 7
90662: PUSH
90663: LD_VAR 0 1
90667: PUSH
90668: LD_INT 1
90670: ARRAY
90671: PPUSH
90672: CALL_OW 255
90676: ST_TO_ADDR
// if not result then
90677: LD_VAR 0 3
90681: NOT
90682: IFFALSE 90686
// exit ;
90684: GO 91038
// for i in result do
90686: LD_ADDR_VAR 0 4
90690: PUSH
90691: LD_VAR 0 3
90695: PUSH
90696: FOR_IN
90697: IFFALSE 91036
// begin tag := GetTag ( i ) + 1 ;
90699: LD_ADDR_VAR 0 8
90703: PUSH
90704: LD_VAR 0 4
90708: PPUSH
90709: CALL_OW 110
90713: PUSH
90714: LD_INT 1
90716: PLUS
90717: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
90718: LD_ADDR_VAR 0 6
90722: PUSH
90723: LD_VAR 0 4
90727: PPUSH
90728: CALL_OW 250
90732: PPUSH
90733: LD_VAR 0 4
90737: PPUSH
90738: CALL_OW 251
90742: PPUSH
90743: LD_INT 6
90745: PPUSH
90746: CALL 90362 0 3
90750: ST_TO_ADDR
// if cr then
90751: LD_VAR 0 6
90755: IFFALSE 90794
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
90757: LD_VAR 0 4
90761: PPUSH
90762: LD_VAR 0 6
90766: PUSH
90767: LD_INT 1
90769: ARRAY
90770: PUSH
90771: LD_INT 1
90773: ARRAY
90774: PPUSH
90775: LD_VAR 0 6
90779: PUSH
90780: LD_INT 1
90782: ARRAY
90783: PUSH
90784: LD_INT 2
90786: ARRAY
90787: PPUSH
90788: CALL_OW 116
90792: GO 91034
// if path > tag then
90794: LD_VAR 0 2
90798: PUSH
90799: LD_VAR 0 8
90803: GREATER
90804: IFFALSE 90982
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_INT 81
90813: PUSH
90814: LD_VAR 0 7
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 91
90825: PUSH
90826: LD_VAR 0 4
90830: PUSH
90831: LD_INT 12
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: LIST
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PPUSH
90843: CALL_OW 69
90847: ST_TO_ADDR
// if enemy then
90848: LD_VAR 0 5
90852: IFFALSE 90880
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
90854: LD_VAR 0 4
90858: PPUSH
90859: LD_VAR 0 5
90863: PPUSH
90864: LD_VAR 0 4
90868: PPUSH
90869: CALL_OW 74
90873: PPUSH
90874: CALL_OW 115
90878: GO 90980
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
90880: LD_VAR 0 4
90884: PPUSH
90885: LD_VAR 0 2
90889: PUSH
90890: LD_VAR 0 8
90894: ARRAY
90895: PUSH
90896: LD_INT 1
90898: ARRAY
90899: PPUSH
90900: LD_VAR 0 2
90904: PUSH
90905: LD_VAR 0 8
90909: ARRAY
90910: PUSH
90911: LD_INT 2
90913: ARRAY
90914: PPUSH
90915: CALL_OW 297
90919: PUSH
90920: LD_INT 6
90922: GREATER
90923: IFFALSE 90966
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
90925: LD_VAR 0 4
90929: PPUSH
90930: LD_VAR 0 2
90934: PUSH
90935: LD_VAR 0 8
90939: ARRAY
90940: PUSH
90941: LD_INT 1
90943: ARRAY
90944: PPUSH
90945: LD_VAR 0 2
90949: PUSH
90950: LD_VAR 0 8
90954: ARRAY
90955: PUSH
90956: LD_INT 2
90958: ARRAY
90959: PPUSH
90960: CALL_OW 114
90964: GO 90980
// SetTag ( i , tag ) ;
90966: LD_VAR 0 4
90970: PPUSH
90971: LD_VAR 0 8
90975: PPUSH
90976: CALL_OW 109
// end else
90980: GO 91034
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
90982: LD_ADDR_VAR 0 5
90986: PUSH
90987: LD_INT 81
90989: PUSH
90990: LD_VAR 0 7
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PPUSH
90999: CALL_OW 69
91003: ST_TO_ADDR
// if enemy then
91004: LD_VAR 0 5
91008: IFFALSE 91034
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91010: LD_VAR 0 4
91014: PPUSH
91015: LD_VAR 0 5
91019: PPUSH
91020: LD_VAR 0 4
91024: PPUSH
91025: CALL_OW 74
91029: PPUSH
91030: CALL_OW 115
// end ; end ;
91034: GO 90696
91036: POP
91037: POP
// end ; end_of_file end_of_file
91038: LD_VAR 0 3
91042: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91043: LD_INT 0
91045: PPUSH
// if p2 = 100 then
91046: LD_VAR 0 2
91050: PUSH
91051: LD_INT 100
91053: EQUAL
91054: IFFALSE 92057
// begin if not StreamModeActive then
91056: LD_EXP 137
91060: NOT
91061: IFFALSE 91071
// StreamModeActive := true ;
91063: LD_ADDR_EXP 137
91067: PUSH
91068: LD_INT 1
91070: ST_TO_ADDR
// if p3 = 0 then
91071: LD_VAR 0 3
91075: PUSH
91076: LD_INT 0
91078: EQUAL
91079: IFFALSE 91085
// InitStreamMode ;
91081: CALL 92217 0 0
// if p3 = 1 then
91085: LD_VAR 0 3
91089: PUSH
91090: LD_INT 1
91092: EQUAL
91093: IFFALSE 91103
// sRocket := true ;
91095: LD_ADDR_EXP 142
91099: PUSH
91100: LD_INT 1
91102: ST_TO_ADDR
// if p3 = 2 then
91103: LD_VAR 0 3
91107: PUSH
91108: LD_INT 2
91110: EQUAL
91111: IFFALSE 91121
// sSpeed := true ;
91113: LD_ADDR_EXP 141
91117: PUSH
91118: LD_INT 1
91120: ST_TO_ADDR
// if p3 = 3 then
91121: LD_VAR 0 3
91125: PUSH
91126: LD_INT 3
91128: EQUAL
91129: IFFALSE 91139
// sEngine := true ;
91131: LD_ADDR_EXP 143
91135: PUSH
91136: LD_INT 1
91138: ST_TO_ADDR
// if p3 = 4 then
91139: LD_VAR 0 3
91143: PUSH
91144: LD_INT 4
91146: EQUAL
91147: IFFALSE 91157
// sSpec := true ;
91149: LD_ADDR_EXP 140
91153: PUSH
91154: LD_INT 1
91156: ST_TO_ADDR
// if p3 = 5 then
91157: LD_VAR 0 3
91161: PUSH
91162: LD_INT 5
91164: EQUAL
91165: IFFALSE 91175
// sLevel := true ;
91167: LD_ADDR_EXP 144
91171: PUSH
91172: LD_INT 1
91174: ST_TO_ADDR
// if p3 = 6 then
91175: LD_VAR 0 3
91179: PUSH
91180: LD_INT 6
91182: EQUAL
91183: IFFALSE 91193
// sArmoury := true ;
91185: LD_ADDR_EXP 145
91189: PUSH
91190: LD_INT 1
91192: ST_TO_ADDR
// if p3 = 7 then
91193: LD_VAR 0 3
91197: PUSH
91198: LD_INT 7
91200: EQUAL
91201: IFFALSE 91211
// sRadar := true ;
91203: LD_ADDR_EXP 146
91207: PUSH
91208: LD_INT 1
91210: ST_TO_ADDR
// if p3 = 8 then
91211: LD_VAR 0 3
91215: PUSH
91216: LD_INT 8
91218: EQUAL
91219: IFFALSE 91229
// sBunker := true ;
91221: LD_ADDR_EXP 147
91225: PUSH
91226: LD_INT 1
91228: ST_TO_ADDR
// if p3 = 9 then
91229: LD_VAR 0 3
91233: PUSH
91234: LD_INT 9
91236: EQUAL
91237: IFFALSE 91247
// sHack := true ;
91239: LD_ADDR_EXP 148
91243: PUSH
91244: LD_INT 1
91246: ST_TO_ADDR
// if p3 = 10 then
91247: LD_VAR 0 3
91251: PUSH
91252: LD_INT 10
91254: EQUAL
91255: IFFALSE 91265
// sFire := true ;
91257: LD_ADDR_EXP 149
91261: PUSH
91262: LD_INT 1
91264: ST_TO_ADDR
// if p3 = 11 then
91265: LD_VAR 0 3
91269: PUSH
91270: LD_INT 11
91272: EQUAL
91273: IFFALSE 91283
// sRefresh := true ;
91275: LD_ADDR_EXP 150
91279: PUSH
91280: LD_INT 1
91282: ST_TO_ADDR
// if p3 = 12 then
91283: LD_VAR 0 3
91287: PUSH
91288: LD_INT 12
91290: EQUAL
91291: IFFALSE 91301
// sExp := true ;
91293: LD_ADDR_EXP 151
91297: PUSH
91298: LD_INT 1
91300: ST_TO_ADDR
// if p3 = 13 then
91301: LD_VAR 0 3
91305: PUSH
91306: LD_INT 13
91308: EQUAL
91309: IFFALSE 91319
// sDepot := true ;
91311: LD_ADDR_EXP 152
91315: PUSH
91316: LD_INT 1
91318: ST_TO_ADDR
// if p3 = 14 then
91319: LD_VAR 0 3
91323: PUSH
91324: LD_INT 14
91326: EQUAL
91327: IFFALSE 91337
// sFlag := true ;
91329: LD_ADDR_EXP 153
91333: PUSH
91334: LD_INT 1
91336: ST_TO_ADDR
// if p3 = 15 then
91337: LD_VAR 0 3
91341: PUSH
91342: LD_INT 15
91344: EQUAL
91345: IFFALSE 91355
// sKamikadze := true ;
91347: LD_ADDR_EXP 161
91351: PUSH
91352: LD_INT 1
91354: ST_TO_ADDR
// if p3 = 16 then
91355: LD_VAR 0 3
91359: PUSH
91360: LD_INT 16
91362: EQUAL
91363: IFFALSE 91373
// sTroll := true ;
91365: LD_ADDR_EXP 162
91369: PUSH
91370: LD_INT 1
91372: ST_TO_ADDR
// if p3 = 17 then
91373: LD_VAR 0 3
91377: PUSH
91378: LD_INT 17
91380: EQUAL
91381: IFFALSE 91391
// sSlow := true ;
91383: LD_ADDR_EXP 163
91387: PUSH
91388: LD_INT 1
91390: ST_TO_ADDR
// if p3 = 18 then
91391: LD_VAR 0 3
91395: PUSH
91396: LD_INT 18
91398: EQUAL
91399: IFFALSE 91409
// sLack := true ;
91401: LD_ADDR_EXP 164
91405: PUSH
91406: LD_INT 1
91408: ST_TO_ADDR
// if p3 = 19 then
91409: LD_VAR 0 3
91413: PUSH
91414: LD_INT 19
91416: EQUAL
91417: IFFALSE 91427
// sTank := true ;
91419: LD_ADDR_EXP 166
91423: PUSH
91424: LD_INT 1
91426: ST_TO_ADDR
// if p3 = 20 then
91427: LD_VAR 0 3
91431: PUSH
91432: LD_INT 20
91434: EQUAL
91435: IFFALSE 91445
// sRemote := true ;
91437: LD_ADDR_EXP 167
91441: PUSH
91442: LD_INT 1
91444: ST_TO_ADDR
// if p3 = 21 then
91445: LD_VAR 0 3
91449: PUSH
91450: LD_INT 21
91452: EQUAL
91453: IFFALSE 91463
// sPowell := true ;
91455: LD_ADDR_EXP 168
91459: PUSH
91460: LD_INT 1
91462: ST_TO_ADDR
// if p3 = 22 then
91463: LD_VAR 0 3
91467: PUSH
91468: LD_INT 22
91470: EQUAL
91471: IFFALSE 91481
// sTeleport := true ;
91473: LD_ADDR_EXP 171
91477: PUSH
91478: LD_INT 1
91480: ST_TO_ADDR
// if p3 = 23 then
91481: LD_VAR 0 3
91485: PUSH
91486: LD_INT 23
91488: EQUAL
91489: IFFALSE 91499
// sOilTower := true ;
91491: LD_ADDR_EXP 173
91495: PUSH
91496: LD_INT 1
91498: ST_TO_ADDR
// if p3 = 24 then
91499: LD_VAR 0 3
91503: PUSH
91504: LD_INT 24
91506: EQUAL
91507: IFFALSE 91517
// sShovel := true ;
91509: LD_ADDR_EXP 174
91513: PUSH
91514: LD_INT 1
91516: ST_TO_ADDR
// if p3 = 25 then
91517: LD_VAR 0 3
91521: PUSH
91522: LD_INT 25
91524: EQUAL
91525: IFFALSE 91535
// sSheik := true ;
91527: LD_ADDR_EXP 175
91531: PUSH
91532: LD_INT 1
91534: ST_TO_ADDR
// if p3 = 26 then
91535: LD_VAR 0 3
91539: PUSH
91540: LD_INT 26
91542: EQUAL
91543: IFFALSE 91553
// sEarthquake := true ;
91545: LD_ADDR_EXP 177
91549: PUSH
91550: LD_INT 1
91552: ST_TO_ADDR
// if p3 = 27 then
91553: LD_VAR 0 3
91557: PUSH
91558: LD_INT 27
91560: EQUAL
91561: IFFALSE 91571
// sAI := true ;
91563: LD_ADDR_EXP 178
91567: PUSH
91568: LD_INT 1
91570: ST_TO_ADDR
// if p3 = 28 then
91571: LD_VAR 0 3
91575: PUSH
91576: LD_INT 28
91578: EQUAL
91579: IFFALSE 91589
// sCargo := true ;
91581: LD_ADDR_EXP 181
91585: PUSH
91586: LD_INT 1
91588: ST_TO_ADDR
// if p3 = 29 then
91589: LD_VAR 0 3
91593: PUSH
91594: LD_INT 29
91596: EQUAL
91597: IFFALSE 91607
// sDLaser := true ;
91599: LD_ADDR_EXP 182
91603: PUSH
91604: LD_INT 1
91606: ST_TO_ADDR
// if p3 = 30 then
91607: LD_VAR 0 3
91611: PUSH
91612: LD_INT 30
91614: EQUAL
91615: IFFALSE 91625
// sExchange := true ;
91617: LD_ADDR_EXP 183
91621: PUSH
91622: LD_INT 1
91624: ST_TO_ADDR
// if p3 = 31 then
91625: LD_VAR 0 3
91629: PUSH
91630: LD_INT 31
91632: EQUAL
91633: IFFALSE 91643
// sFac := true ;
91635: LD_ADDR_EXP 184
91639: PUSH
91640: LD_INT 1
91642: ST_TO_ADDR
// if p3 = 32 then
91643: LD_VAR 0 3
91647: PUSH
91648: LD_INT 32
91650: EQUAL
91651: IFFALSE 91661
// sPower := true ;
91653: LD_ADDR_EXP 185
91657: PUSH
91658: LD_INT 1
91660: ST_TO_ADDR
// if p3 = 33 then
91661: LD_VAR 0 3
91665: PUSH
91666: LD_INT 33
91668: EQUAL
91669: IFFALSE 91679
// sRandom := true ;
91671: LD_ADDR_EXP 186
91675: PUSH
91676: LD_INT 1
91678: ST_TO_ADDR
// if p3 = 34 then
91679: LD_VAR 0 3
91683: PUSH
91684: LD_INT 34
91686: EQUAL
91687: IFFALSE 91697
// sShield := true ;
91689: LD_ADDR_EXP 187
91693: PUSH
91694: LD_INT 1
91696: ST_TO_ADDR
// if p3 = 35 then
91697: LD_VAR 0 3
91701: PUSH
91702: LD_INT 35
91704: EQUAL
91705: IFFALSE 91715
// sTime := true ;
91707: LD_ADDR_EXP 188
91711: PUSH
91712: LD_INT 1
91714: ST_TO_ADDR
// if p3 = 36 then
91715: LD_VAR 0 3
91719: PUSH
91720: LD_INT 36
91722: EQUAL
91723: IFFALSE 91733
// sTools := true ;
91725: LD_ADDR_EXP 189
91729: PUSH
91730: LD_INT 1
91732: ST_TO_ADDR
// if p3 = 101 then
91733: LD_VAR 0 3
91737: PUSH
91738: LD_INT 101
91740: EQUAL
91741: IFFALSE 91751
// sSold := true ;
91743: LD_ADDR_EXP 154
91747: PUSH
91748: LD_INT 1
91750: ST_TO_ADDR
// if p3 = 102 then
91751: LD_VAR 0 3
91755: PUSH
91756: LD_INT 102
91758: EQUAL
91759: IFFALSE 91769
// sDiff := true ;
91761: LD_ADDR_EXP 155
91765: PUSH
91766: LD_INT 1
91768: ST_TO_ADDR
// if p3 = 103 then
91769: LD_VAR 0 3
91773: PUSH
91774: LD_INT 103
91776: EQUAL
91777: IFFALSE 91787
// sFog := true ;
91779: LD_ADDR_EXP 158
91783: PUSH
91784: LD_INT 1
91786: ST_TO_ADDR
// if p3 = 104 then
91787: LD_VAR 0 3
91791: PUSH
91792: LD_INT 104
91794: EQUAL
91795: IFFALSE 91805
// sReset := true ;
91797: LD_ADDR_EXP 159
91801: PUSH
91802: LD_INT 1
91804: ST_TO_ADDR
// if p3 = 105 then
91805: LD_VAR 0 3
91809: PUSH
91810: LD_INT 105
91812: EQUAL
91813: IFFALSE 91823
// sSun := true ;
91815: LD_ADDR_EXP 160
91819: PUSH
91820: LD_INT 1
91822: ST_TO_ADDR
// if p3 = 106 then
91823: LD_VAR 0 3
91827: PUSH
91828: LD_INT 106
91830: EQUAL
91831: IFFALSE 91841
// sTiger := true ;
91833: LD_ADDR_EXP 156
91837: PUSH
91838: LD_INT 1
91840: ST_TO_ADDR
// if p3 = 107 then
91841: LD_VAR 0 3
91845: PUSH
91846: LD_INT 107
91848: EQUAL
91849: IFFALSE 91859
// sBomb := true ;
91851: LD_ADDR_EXP 157
91855: PUSH
91856: LD_INT 1
91858: ST_TO_ADDR
// if p3 = 108 then
91859: LD_VAR 0 3
91863: PUSH
91864: LD_INT 108
91866: EQUAL
91867: IFFALSE 91877
// sWound := true ;
91869: LD_ADDR_EXP 165
91873: PUSH
91874: LD_INT 1
91876: ST_TO_ADDR
// if p3 = 109 then
91877: LD_VAR 0 3
91881: PUSH
91882: LD_INT 109
91884: EQUAL
91885: IFFALSE 91895
// sBetray := true ;
91887: LD_ADDR_EXP 169
91891: PUSH
91892: LD_INT 1
91894: ST_TO_ADDR
// if p3 = 110 then
91895: LD_VAR 0 3
91899: PUSH
91900: LD_INT 110
91902: EQUAL
91903: IFFALSE 91913
// sContamin := true ;
91905: LD_ADDR_EXP 170
91909: PUSH
91910: LD_INT 1
91912: ST_TO_ADDR
// if p3 = 111 then
91913: LD_VAR 0 3
91917: PUSH
91918: LD_INT 111
91920: EQUAL
91921: IFFALSE 91931
// sOil := true ;
91923: LD_ADDR_EXP 172
91927: PUSH
91928: LD_INT 1
91930: ST_TO_ADDR
// if p3 = 112 then
91931: LD_VAR 0 3
91935: PUSH
91936: LD_INT 112
91938: EQUAL
91939: IFFALSE 91949
// sStu := true ;
91941: LD_ADDR_EXP 176
91945: PUSH
91946: LD_INT 1
91948: ST_TO_ADDR
// if p3 = 113 then
91949: LD_VAR 0 3
91953: PUSH
91954: LD_INT 113
91956: EQUAL
91957: IFFALSE 91967
// sBazooka := true ;
91959: LD_ADDR_EXP 179
91963: PUSH
91964: LD_INT 1
91966: ST_TO_ADDR
// if p3 = 114 then
91967: LD_VAR 0 3
91971: PUSH
91972: LD_INT 114
91974: EQUAL
91975: IFFALSE 91985
// sMortar := true ;
91977: LD_ADDR_EXP 180
91981: PUSH
91982: LD_INT 1
91984: ST_TO_ADDR
// if p3 = 115 then
91985: LD_VAR 0 3
91989: PUSH
91990: LD_INT 115
91992: EQUAL
91993: IFFALSE 92003
// sRanger := true ;
91995: LD_ADDR_EXP 190
91999: PUSH
92000: LD_INT 1
92002: ST_TO_ADDR
// if p3 = 116 then
92003: LD_VAR 0 3
92007: PUSH
92008: LD_INT 116
92010: EQUAL
92011: IFFALSE 92021
// sComputer := true ;
92013: LD_ADDR_EXP 191
92017: PUSH
92018: LD_INT 1
92020: ST_TO_ADDR
// if p3 = 117 then
92021: LD_VAR 0 3
92025: PUSH
92026: LD_INT 117
92028: EQUAL
92029: IFFALSE 92039
// s30 := true ;
92031: LD_ADDR_EXP 192
92035: PUSH
92036: LD_INT 1
92038: ST_TO_ADDR
// if p3 = 118 then
92039: LD_VAR 0 3
92043: PUSH
92044: LD_INT 118
92046: EQUAL
92047: IFFALSE 92057
// s60 := true ;
92049: LD_ADDR_EXP 193
92053: PUSH
92054: LD_INT 1
92056: ST_TO_ADDR
// end ; if p2 = 101 then
92057: LD_VAR 0 2
92061: PUSH
92062: LD_INT 101
92064: EQUAL
92065: IFFALSE 92193
// begin case p3 of 1 :
92067: LD_VAR 0 3
92071: PUSH
92072: LD_INT 1
92074: DOUBLE
92075: EQUAL
92076: IFTRUE 92080
92078: GO 92087
92080: POP
// hHackUnlimitedResources ; 2 :
92081: CALL 103789 0 0
92085: GO 92193
92087: LD_INT 2
92089: DOUBLE
92090: EQUAL
92091: IFTRUE 92095
92093: GO 92102
92095: POP
// hHackSetLevel10 ; 3 :
92096: CALL 103922 0 0
92100: GO 92193
92102: LD_INT 3
92104: DOUBLE
92105: EQUAL
92106: IFTRUE 92110
92108: GO 92117
92110: POP
// hHackSetLevel10YourUnits ; 4 :
92111: CALL 104007 0 0
92115: GO 92193
92117: LD_INT 4
92119: DOUBLE
92120: EQUAL
92121: IFTRUE 92125
92123: GO 92132
92125: POP
// hHackInvincible ; 5 :
92126: CALL 104455 0 0
92130: GO 92193
92132: LD_INT 5
92134: DOUBLE
92135: EQUAL
92136: IFTRUE 92140
92138: GO 92147
92140: POP
// hHackInvisible ; 6 :
92141: CALL 104566 0 0
92145: GO 92193
92147: LD_INT 6
92149: DOUBLE
92150: EQUAL
92151: IFTRUE 92155
92153: GO 92162
92155: POP
// hHackChangeYourSide ; 7 :
92156: CALL 104623 0 0
92160: GO 92193
92162: LD_INT 7
92164: DOUBLE
92165: EQUAL
92166: IFTRUE 92170
92168: GO 92177
92170: POP
// hHackChangeUnitSide ; 8 :
92171: CALL 104665 0 0
92175: GO 92193
92177: LD_INT 8
92179: DOUBLE
92180: EQUAL
92181: IFTRUE 92185
92183: GO 92192
92185: POP
// hHackFog ; end ;
92186: CALL 104766 0 0
92190: GO 92193
92192: POP
// end ; end ;
92193: LD_VAR 0 7
92197: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
92198: GO 92200
92200: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92201: LD_STRING initStreamRollete();
92203: PPUSH
92204: CALL_OW 559
// InitStreamMode ;
92208: CALL 92217 0 0
// DefineStreamItems ( ) ;
92212: CALL 92681 0 0
// end ;
92216: END
// function InitStreamMode ; begin
92217: LD_INT 0
92219: PPUSH
// streamModeActive := false ;
92220: LD_ADDR_EXP 137
92224: PUSH
92225: LD_INT 0
92227: ST_TO_ADDR
// normalCounter := 36 ;
92228: LD_ADDR_EXP 138
92232: PUSH
92233: LD_INT 36
92235: ST_TO_ADDR
// hardcoreCounter := 16 ;
92236: LD_ADDR_EXP 139
92240: PUSH
92241: LD_INT 16
92243: ST_TO_ADDR
// sRocket := false ;
92244: LD_ADDR_EXP 142
92248: PUSH
92249: LD_INT 0
92251: ST_TO_ADDR
// sSpeed := false ;
92252: LD_ADDR_EXP 141
92256: PUSH
92257: LD_INT 0
92259: ST_TO_ADDR
// sEngine := false ;
92260: LD_ADDR_EXP 143
92264: PUSH
92265: LD_INT 0
92267: ST_TO_ADDR
// sSpec := false ;
92268: LD_ADDR_EXP 140
92272: PUSH
92273: LD_INT 0
92275: ST_TO_ADDR
// sLevel := false ;
92276: LD_ADDR_EXP 144
92280: PUSH
92281: LD_INT 0
92283: ST_TO_ADDR
// sArmoury := false ;
92284: LD_ADDR_EXP 145
92288: PUSH
92289: LD_INT 0
92291: ST_TO_ADDR
// sRadar := false ;
92292: LD_ADDR_EXP 146
92296: PUSH
92297: LD_INT 0
92299: ST_TO_ADDR
// sBunker := false ;
92300: LD_ADDR_EXP 147
92304: PUSH
92305: LD_INT 0
92307: ST_TO_ADDR
// sHack := false ;
92308: LD_ADDR_EXP 148
92312: PUSH
92313: LD_INT 0
92315: ST_TO_ADDR
// sFire := false ;
92316: LD_ADDR_EXP 149
92320: PUSH
92321: LD_INT 0
92323: ST_TO_ADDR
// sRefresh := false ;
92324: LD_ADDR_EXP 150
92328: PUSH
92329: LD_INT 0
92331: ST_TO_ADDR
// sExp := false ;
92332: LD_ADDR_EXP 151
92336: PUSH
92337: LD_INT 0
92339: ST_TO_ADDR
// sDepot := false ;
92340: LD_ADDR_EXP 152
92344: PUSH
92345: LD_INT 0
92347: ST_TO_ADDR
// sFlag := false ;
92348: LD_ADDR_EXP 153
92352: PUSH
92353: LD_INT 0
92355: ST_TO_ADDR
// sKamikadze := false ;
92356: LD_ADDR_EXP 161
92360: PUSH
92361: LD_INT 0
92363: ST_TO_ADDR
// sTroll := false ;
92364: LD_ADDR_EXP 162
92368: PUSH
92369: LD_INT 0
92371: ST_TO_ADDR
// sSlow := false ;
92372: LD_ADDR_EXP 163
92376: PUSH
92377: LD_INT 0
92379: ST_TO_ADDR
// sLack := false ;
92380: LD_ADDR_EXP 164
92384: PUSH
92385: LD_INT 0
92387: ST_TO_ADDR
// sTank := false ;
92388: LD_ADDR_EXP 166
92392: PUSH
92393: LD_INT 0
92395: ST_TO_ADDR
// sRemote := false ;
92396: LD_ADDR_EXP 167
92400: PUSH
92401: LD_INT 0
92403: ST_TO_ADDR
// sPowell := false ;
92404: LD_ADDR_EXP 168
92408: PUSH
92409: LD_INT 0
92411: ST_TO_ADDR
// sTeleport := false ;
92412: LD_ADDR_EXP 171
92416: PUSH
92417: LD_INT 0
92419: ST_TO_ADDR
// sOilTower := false ;
92420: LD_ADDR_EXP 173
92424: PUSH
92425: LD_INT 0
92427: ST_TO_ADDR
// sShovel := false ;
92428: LD_ADDR_EXP 174
92432: PUSH
92433: LD_INT 0
92435: ST_TO_ADDR
// sSheik := false ;
92436: LD_ADDR_EXP 175
92440: PUSH
92441: LD_INT 0
92443: ST_TO_ADDR
// sEarthquake := false ;
92444: LD_ADDR_EXP 177
92448: PUSH
92449: LD_INT 0
92451: ST_TO_ADDR
// sAI := false ;
92452: LD_ADDR_EXP 178
92456: PUSH
92457: LD_INT 0
92459: ST_TO_ADDR
// sCargo := false ;
92460: LD_ADDR_EXP 181
92464: PUSH
92465: LD_INT 0
92467: ST_TO_ADDR
// sDLaser := false ;
92468: LD_ADDR_EXP 182
92472: PUSH
92473: LD_INT 0
92475: ST_TO_ADDR
// sExchange := false ;
92476: LD_ADDR_EXP 183
92480: PUSH
92481: LD_INT 0
92483: ST_TO_ADDR
// sFac := false ;
92484: LD_ADDR_EXP 184
92488: PUSH
92489: LD_INT 0
92491: ST_TO_ADDR
// sPower := false ;
92492: LD_ADDR_EXP 185
92496: PUSH
92497: LD_INT 0
92499: ST_TO_ADDR
// sRandom := false ;
92500: LD_ADDR_EXP 186
92504: PUSH
92505: LD_INT 0
92507: ST_TO_ADDR
// sShield := false ;
92508: LD_ADDR_EXP 187
92512: PUSH
92513: LD_INT 0
92515: ST_TO_ADDR
// sTime := false ;
92516: LD_ADDR_EXP 188
92520: PUSH
92521: LD_INT 0
92523: ST_TO_ADDR
// sTools := false ;
92524: LD_ADDR_EXP 189
92528: PUSH
92529: LD_INT 0
92531: ST_TO_ADDR
// sSold := false ;
92532: LD_ADDR_EXP 154
92536: PUSH
92537: LD_INT 0
92539: ST_TO_ADDR
// sDiff := false ;
92540: LD_ADDR_EXP 155
92544: PUSH
92545: LD_INT 0
92547: ST_TO_ADDR
// sFog := false ;
92548: LD_ADDR_EXP 158
92552: PUSH
92553: LD_INT 0
92555: ST_TO_ADDR
// sReset := false ;
92556: LD_ADDR_EXP 159
92560: PUSH
92561: LD_INT 0
92563: ST_TO_ADDR
// sSun := false ;
92564: LD_ADDR_EXP 160
92568: PUSH
92569: LD_INT 0
92571: ST_TO_ADDR
// sTiger := false ;
92572: LD_ADDR_EXP 156
92576: PUSH
92577: LD_INT 0
92579: ST_TO_ADDR
// sBomb := false ;
92580: LD_ADDR_EXP 157
92584: PUSH
92585: LD_INT 0
92587: ST_TO_ADDR
// sWound := false ;
92588: LD_ADDR_EXP 165
92592: PUSH
92593: LD_INT 0
92595: ST_TO_ADDR
// sBetray := false ;
92596: LD_ADDR_EXP 169
92600: PUSH
92601: LD_INT 0
92603: ST_TO_ADDR
// sContamin := false ;
92604: LD_ADDR_EXP 170
92608: PUSH
92609: LD_INT 0
92611: ST_TO_ADDR
// sOil := false ;
92612: LD_ADDR_EXP 172
92616: PUSH
92617: LD_INT 0
92619: ST_TO_ADDR
// sStu := false ;
92620: LD_ADDR_EXP 176
92624: PUSH
92625: LD_INT 0
92627: ST_TO_ADDR
// sBazooka := false ;
92628: LD_ADDR_EXP 179
92632: PUSH
92633: LD_INT 0
92635: ST_TO_ADDR
// sMortar := false ;
92636: LD_ADDR_EXP 180
92640: PUSH
92641: LD_INT 0
92643: ST_TO_ADDR
// sRanger := false ;
92644: LD_ADDR_EXP 190
92648: PUSH
92649: LD_INT 0
92651: ST_TO_ADDR
// sComputer := false ;
92652: LD_ADDR_EXP 191
92656: PUSH
92657: LD_INT 0
92659: ST_TO_ADDR
// s30 := false ;
92660: LD_ADDR_EXP 192
92664: PUSH
92665: LD_INT 0
92667: ST_TO_ADDR
// s60 := false ;
92668: LD_ADDR_EXP 193
92672: PUSH
92673: LD_INT 0
92675: ST_TO_ADDR
// end ;
92676: LD_VAR 0 1
92680: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
92681: LD_INT 0
92683: PPUSH
92684: PPUSH
92685: PPUSH
92686: PPUSH
92687: PPUSH
// result := [ ] ;
92688: LD_ADDR_VAR 0 1
92692: PUSH
92693: EMPTY
92694: ST_TO_ADDR
// if campaign_id = 1 then
92695: LD_OWVAR 69
92699: PUSH
92700: LD_INT 1
92702: EQUAL
92703: IFFALSE 95869
// begin case mission_number of 1 :
92705: LD_OWVAR 70
92709: PUSH
92710: LD_INT 1
92712: DOUBLE
92713: EQUAL
92714: IFTRUE 92718
92716: GO 92794
92718: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92719: LD_ADDR_VAR 0 1
92723: PUSH
92724: LD_INT 2
92726: PUSH
92727: LD_INT 4
92729: PUSH
92730: LD_INT 11
92732: PUSH
92733: LD_INT 12
92735: PUSH
92736: LD_INT 15
92738: PUSH
92739: LD_INT 16
92741: PUSH
92742: LD_INT 22
92744: PUSH
92745: LD_INT 23
92747: PUSH
92748: LD_INT 26
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 101
92764: PUSH
92765: LD_INT 102
92767: PUSH
92768: LD_INT 106
92770: PUSH
92771: LD_INT 116
92773: PUSH
92774: LD_INT 117
92776: PUSH
92777: LD_INT 118
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: ST_TO_ADDR
92792: GO 95867
92794: LD_INT 2
92796: DOUBLE
92797: EQUAL
92798: IFTRUE 92802
92800: GO 92886
92802: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92803: LD_ADDR_VAR 0 1
92807: PUSH
92808: LD_INT 2
92810: PUSH
92811: LD_INT 4
92813: PUSH
92814: LD_INT 11
92816: PUSH
92817: LD_INT 12
92819: PUSH
92820: LD_INT 15
92822: PUSH
92823: LD_INT 16
92825: PUSH
92826: LD_INT 22
92828: PUSH
92829: LD_INT 23
92831: PUSH
92832: LD_INT 26
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: PUSH
92846: LD_INT 101
92848: PUSH
92849: LD_INT 102
92851: PUSH
92852: LD_INT 105
92854: PUSH
92855: LD_INT 106
92857: PUSH
92858: LD_INT 108
92860: PUSH
92861: LD_INT 116
92863: PUSH
92864: LD_INT 117
92866: PUSH
92867: LD_INT 118
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: ST_TO_ADDR
92884: GO 95867
92886: LD_INT 3
92888: DOUBLE
92889: EQUAL
92890: IFTRUE 92894
92892: GO 92982
92894: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92895: LD_ADDR_VAR 0 1
92899: PUSH
92900: LD_INT 2
92902: PUSH
92903: LD_INT 4
92905: PUSH
92906: LD_INT 5
92908: PUSH
92909: LD_INT 11
92911: PUSH
92912: LD_INT 12
92914: PUSH
92915: LD_INT 15
92917: PUSH
92918: LD_INT 16
92920: PUSH
92921: LD_INT 22
92923: PUSH
92924: LD_INT 26
92926: PUSH
92927: LD_INT 36
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 101
92944: PUSH
92945: LD_INT 102
92947: PUSH
92948: LD_INT 105
92950: PUSH
92951: LD_INT 106
92953: PUSH
92954: LD_INT 108
92956: PUSH
92957: LD_INT 116
92959: PUSH
92960: LD_INT 117
92962: PUSH
92963: LD_INT 118
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: ST_TO_ADDR
92980: GO 95867
92982: LD_INT 4
92984: DOUBLE
92985: EQUAL
92986: IFTRUE 92990
92988: GO 93086
92990: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92991: LD_ADDR_VAR 0 1
92995: PUSH
92996: LD_INT 2
92998: PUSH
92999: LD_INT 4
93001: PUSH
93002: LD_INT 5
93004: PUSH
93005: LD_INT 8
93007: PUSH
93008: LD_INT 11
93010: PUSH
93011: LD_INT 12
93013: PUSH
93014: LD_INT 15
93016: PUSH
93017: LD_INT 16
93019: PUSH
93020: LD_INT 22
93022: PUSH
93023: LD_INT 23
93025: PUSH
93026: LD_INT 26
93028: PUSH
93029: LD_INT 36
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 101
93048: PUSH
93049: LD_INT 102
93051: PUSH
93052: LD_INT 105
93054: PUSH
93055: LD_INT 106
93057: PUSH
93058: LD_INT 108
93060: PUSH
93061: LD_INT 116
93063: PUSH
93064: LD_INT 117
93066: PUSH
93067: LD_INT 118
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: ST_TO_ADDR
93084: GO 95867
93086: LD_INT 5
93088: DOUBLE
93089: EQUAL
93090: IFTRUE 93094
93092: GO 93206
93094: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93095: LD_ADDR_VAR 0 1
93099: PUSH
93100: LD_INT 2
93102: PUSH
93103: LD_INT 4
93105: PUSH
93106: LD_INT 5
93108: PUSH
93109: LD_INT 6
93111: PUSH
93112: LD_INT 8
93114: PUSH
93115: LD_INT 11
93117: PUSH
93118: LD_INT 12
93120: PUSH
93121: LD_INT 15
93123: PUSH
93124: LD_INT 16
93126: PUSH
93127: LD_INT 22
93129: PUSH
93130: LD_INT 23
93132: PUSH
93133: LD_INT 25
93135: PUSH
93136: LD_INT 26
93138: PUSH
93139: LD_INT 36
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: PUSH
93158: LD_INT 101
93160: PUSH
93161: LD_INT 102
93163: PUSH
93164: LD_INT 105
93166: PUSH
93167: LD_INT 106
93169: PUSH
93170: LD_INT 108
93172: PUSH
93173: LD_INT 109
93175: PUSH
93176: LD_INT 112
93178: PUSH
93179: LD_INT 116
93181: PUSH
93182: LD_INT 117
93184: PUSH
93185: LD_INT 118
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: ST_TO_ADDR
93204: GO 95867
93206: LD_INT 6
93208: DOUBLE
93209: EQUAL
93210: IFTRUE 93214
93212: GO 93346
93214: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93215: LD_ADDR_VAR 0 1
93219: PUSH
93220: LD_INT 2
93222: PUSH
93223: LD_INT 4
93225: PUSH
93226: LD_INT 5
93228: PUSH
93229: LD_INT 6
93231: PUSH
93232: LD_INT 8
93234: PUSH
93235: LD_INT 11
93237: PUSH
93238: LD_INT 12
93240: PUSH
93241: LD_INT 15
93243: PUSH
93244: LD_INT 16
93246: PUSH
93247: LD_INT 20
93249: PUSH
93250: LD_INT 21
93252: PUSH
93253: LD_INT 22
93255: PUSH
93256: LD_INT 23
93258: PUSH
93259: LD_INT 25
93261: PUSH
93262: LD_INT 26
93264: PUSH
93265: LD_INT 30
93267: PUSH
93268: LD_INT 31
93270: PUSH
93271: LD_INT 32
93273: PUSH
93274: LD_INT 36
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 101
93300: PUSH
93301: LD_INT 102
93303: PUSH
93304: LD_INT 105
93306: PUSH
93307: LD_INT 106
93309: PUSH
93310: LD_INT 108
93312: PUSH
93313: LD_INT 109
93315: PUSH
93316: LD_INT 112
93318: PUSH
93319: LD_INT 116
93321: PUSH
93322: LD_INT 117
93324: PUSH
93325: LD_INT 118
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: ST_TO_ADDR
93344: GO 95867
93346: LD_INT 7
93348: DOUBLE
93349: EQUAL
93350: IFTRUE 93354
93352: GO 93466
93354: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93355: LD_ADDR_VAR 0 1
93359: PUSH
93360: LD_INT 2
93362: PUSH
93363: LD_INT 4
93365: PUSH
93366: LD_INT 5
93368: PUSH
93369: LD_INT 7
93371: PUSH
93372: LD_INT 11
93374: PUSH
93375: LD_INT 12
93377: PUSH
93378: LD_INT 15
93380: PUSH
93381: LD_INT 16
93383: PUSH
93384: LD_INT 20
93386: PUSH
93387: LD_INT 21
93389: PUSH
93390: LD_INT 22
93392: PUSH
93393: LD_INT 23
93395: PUSH
93396: LD_INT 25
93398: PUSH
93399: LD_INT 26
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 101
93420: PUSH
93421: LD_INT 102
93423: PUSH
93424: LD_INT 103
93426: PUSH
93427: LD_INT 105
93429: PUSH
93430: LD_INT 106
93432: PUSH
93433: LD_INT 108
93435: PUSH
93436: LD_INT 112
93438: PUSH
93439: LD_INT 116
93441: PUSH
93442: LD_INT 117
93444: PUSH
93445: LD_INT 118
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: ST_TO_ADDR
93464: GO 95867
93466: LD_INT 8
93468: DOUBLE
93469: EQUAL
93470: IFTRUE 93474
93472: GO 93614
93474: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93475: LD_ADDR_VAR 0 1
93479: PUSH
93480: LD_INT 2
93482: PUSH
93483: LD_INT 4
93485: PUSH
93486: LD_INT 5
93488: PUSH
93489: LD_INT 6
93491: PUSH
93492: LD_INT 7
93494: PUSH
93495: LD_INT 8
93497: PUSH
93498: LD_INT 11
93500: PUSH
93501: LD_INT 12
93503: PUSH
93504: LD_INT 15
93506: PUSH
93507: LD_INT 16
93509: PUSH
93510: LD_INT 20
93512: PUSH
93513: LD_INT 21
93515: PUSH
93516: LD_INT 22
93518: PUSH
93519: LD_INT 23
93521: PUSH
93522: LD_INT 25
93524: PUSH
93525: LD_INT 26
93527: PUSH
93528: LD_INT 30
93530: PUSH
93531: LD_INT 31
93533: PUSH
93534: LD_INT 32
93536: PUSH
93537: LD_INT 36
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: PUSH
93562: LD_INT 101
93564: PUSH
93565: LD_INT 102
93567: PUSH
93568: LD_INT 103
93570: PUSH
93571: LD_INT 105
93573: PUSH
93574: LD_INT 106
93576: PUSH
93577: LD_INT 108
93579: PUSH
93580: LD_INT 109
93582: PUSH
93583: LD_INT 112
93585: PUSH
93586: LD_INT 116
93588: PUSH
93589: LD_INT 117
93591: PUSH
93592: LD_INT 118
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: ST_TO_ADDR
93612: GO 95867
93614: LD_INT 9
93616: DOUBLE
93617: EQUAL
93618: IFTRUE 93622
93620: GO 93770
93622: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93623: LD_ADDR_VAR 0 1
93627: PUSH
93628: LD_INT 2
93630: PUSH
93631: LD_INT 4
93633: PUSH
93634: LD_INT 5
93636: PUSH
93637: LD_INT 6
93639: PUSH
93640: LD_INT 7
93642: PUSH
93643: LD_INT 8
93645: PUSH
93646: LD_INT 11
93648: PUSH
93649: LD_INT 12
93651: PUSH
93652: LD_INT 15
93654: PUSH
93655: LD_INT 16
93657: PUSH
93658: LD_INT 20
93660: PUSH
93661: LD_INT 21
93663: PUSH
93664: LD_INT 22
93666: PUSH
93667: LD_INT 23
93669: PUSH
93670: LD_INT 25
93672: PUSH
93673: LD_INT 26
93675: PUSH
93676: LD_INT 28
93678: PUSH
93679: LD_INT 30
93681: PUSH
93682: LD_INT 31
93684: PUSH
93685: LD_INT 32
93687: PUSH
93688: LD_INT 36
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 101
93716: PUSH
93717: LD_INT 102
93719: PUSH
93720: LD_INT 103
93722: PUSH
93723: LD_INT 105
93725: PUSH
93726: LD_INT 106
93728: PUSH
93729: LD_INT 108
93731: PUSH
93732: LD_INT 109
93734: PUSH
93735: LD_INT 112
93737: PUSH
93738: LD_INT 114
93740: PUSH
93741: LD_INT 116
93743: PUSH
93744: LD_INT 117
93746: PUSH
93747: LD_INT 118
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: ST_TO_ADDR
93768: GO 95867
93770: LD_INT 10
93772: DOUBLE
93773: EQUAL
93774: IFTRUE 93778
93776: GO 93974
93778: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93779: LD_ADDR_VAR 0 1
93783: PUSH
93784: LD_INT 2
93786: PUSH
93787: LD_INT 4
93789: PUSH
93790: LD_INT 5
93792: PUSH
93793: LD_INT 6
93795: PUSH
93796: LD_INT 7
93798: PUSH
93799: LD_INT 8
93801: PUSH
93802: LD_INT 9
93804: PUSH
93805: LD_INT 10
93807: PUSH
93808: LD_INT 11
93810: PUSH
93811: LD_INT 12
93813: PUSH
93814: LD_INT 13
93816: PUSH
93817: LD_INT 14
93819: PUSH
93820: LD_INT 15
93822: PUSH
93823: LD_INT 16
93825: PUSH
93826: LD_INT 17
93828: PUSH
93829: LD_INT 18
93831: PUSH
93832: LD_INT 19
93834: PUSH
93835: LD_INT 20
93837: PUSH
93838: LD_INT 21
93840: PUSH
93841: LD_INT 22
93843: PUSH
93844: LD_INT 23
93846: PUSH
93847: LD_INT 24
93849: PUSH
93850: LD_INT 25
93852: PUSH
93853: LD_INT 26
93855: PUSH
93856: LD_INT 28
93858: PUSH
93859: LD_INT 30
93861: PUSH
93862: LD_INT 31
93864: PUSH
93865: LD_INT 32
93867: PUSH
93868: LD_INT 36
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 101
93904: PUSH
93905: LD_INT 102
93907: PUSH
93908: LD_INT 103
93910: PUSH
93911: LD_INT 104
93913: PUSH
93914: LD_INT 105
93916: PUSH
93917: LD_INT 106
93919: PUSH
93920: LD_INT 107
93922: PUSH
93923: LD_INT 108
93925: PUSH
93926: LD_INT 109
93928: PUSH
93929: LD_INT 110
93931: PUSH
93932: LD_INT 111
93934: PUSH
93935: LD_INT 112
93937: PUSH
93938: LD_INT 114
93940: PUSH
93941: LD_INT 116
93943: PUSH
93944: LD_INT 117
93946: PUSH
93947: LD_INT 118
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: ST_TO_ADDR
93972: GO 95867
93974: LD_INT 11
93976: DOUBLE
93977: EQUAL
93978: IFTRUE 93982
93980: GO 94186
93982: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93983: LD_ADDR_VAR 0 1
93987: PUSH
93988: LD_INT 2
93990: PUSH
93991: LD_INT 3
93993: PUSH
93994: LD_INT 4
93996: PUSH
93997: LD_INT 5
93999: PUSH
94000: LD_INT 6
94002: PUSH
94003: LD_INT 7
94005: PUSH
94006: LD_INT 8
94008: PUSH
94009: LD_INT 9
94011: PUSH
94012: LD_INT 10
94014: PUSH
94015: LD_INT 11
94017: PUSH
94018: LD_INT 12
94020: PUSH
94021: LD_INT 13
94023: PUSH
94024: LD_INT 14
94026: PUSH
94027: LD_INT 15
94029: PUSH
94030: LD_INT 16
94032: PUSH
94033: LD_INT 17
94035: PUSH
94036: LD_INT 18
94038: PUSH
94039: LD_INT 19
94041: PUSH
94042: LD_INT 20
94044: PUSH
94045: LD_INT 21
94047: PUSH
94048: LD_INT 22
94050: PUSH
94051: LD_INT 23
94053: PUSH
94054: LD_INT 24
94056: PUSH
94057: LD_INT 25
94059: PUSH
94060: LD_INT 26
94062: PUSH
94063: LD_INT 28
94065: PUSH
94066: LD_INT 30
94068: PUSH
94069: LD_INT 31
94071: PUSH
94072: LD_INT 32
94074: PUSH
94075: LD_INT 34
94077: PUSH
94078: LD_INT 36
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 101
94116: PUSH
94117: LD_INT 102
94119: PUSH
94120: LD_INT 103
94122: PUSH
94123: LD_INT 104
94125: PUSH
94126: LD_INT 105
94128: PUSH
94129: LD_INT 106
94131: PUSH
94132: LD_INT 107
94134: PUSH
94135: LD_INT 108
94137: PUSH
94138: LD_INT 109
94140: PUSH
94141: LD_INT 110
94143: PUSH
94144: LD_INT 111
94146: PUSH
94147: LD_INT 112
94149: PUSH
94150: LD_INT 114
94152: PUSH
94153: LD_INT 116
94155: PUSH
94156: LD_INT 117
94158: PUSH
94159: LD_INT 118
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: ST_TO_ADDR
94184: GO 95867
94186: LD_INT 12
94188: DOUBLE
94189: EQUAL
94190: IFTRUE 94194
94192: GO 94414
94194: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94195: LD_ADDR_VAR 0 1
94199: PUSH
94200: LD_INT 1
94202: PUSH
94203: LD_INT 2
94205: PUSH
94206: LD_INT 3
94208: PUSH
94209: LD_INT 4
94211: PUSH
94212: LD_INT 5
94214: PUSH
94215: LD_INT 6
94217: PUSH
94218: LD_INT 7
94220: PUSH
94221: LD_INT 8
94223: PUSH
94224: LD_INT 9
94226: PUSH
94227: LD_INT 10
94229: PUSH
94230: LD_INT 11
94232: PUSH
94233: LD_INT 12
94235: PUSH
94236: LD_INT 13
94238: PUSH
94239: LD_INT 14
94241: PUSH
94242: LD_INT 15
94244: PUSH
94245: LD_INT 16
94247: PUSH
94248: LD_INT 17
94250: PUSH
94251: LD_INT 18
94253: PUSH
94254: LD_INT 19
94256: PUSH
94257: LD_INT 20
94259: PUSH
94260: LD_INT 21
94262: PUSH
94263: LD_INT 22
94265: PUSH
94266: LD_INT 23
94268: PUSH
94269: LD_INT 24
94271: PUSH
94272: LD_INT 25
94274: PUSH
94275: LD_INT 26
94277: PUSH
94278: LD_INT 27
94280: PUSH
94281: LD_INT 28
94283: PUSH
94284: LD_INT 30
94286: PUSH
94287: LD_INT 31
94289: PUSH
94290: LD_INT 32
94292: PUSH
94293: LD_INT 33
94295: PUSH
94296: LD_INT 34
94298: PUSH
94299: LD_INT 36
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 101
94340: PUSH
94341: LD_INT 102
94343: PUSH
94344: LD_INT 103
94346: PUSH
94347: LD_INT 104
94349: PUSH
94350: LD_INT 105
94352: PUSH
94353: LD_INT 106
94355: PUSH
94356: LD_INT 107
94358: PUSH
94359: LD_INT 108
94361: PUSH
94362: LD_INT 109
94364: PUSH
94365: LD_INT 110
94367: PUSH
94368: LD_INT 111
94370: PUSH
94371: LD_INT 112
94373: PUSH
94374: LD_INT 113
94376: PUSH
94377: LD_INT 114
94379: PUSH
94380: LD_INT 116
94382: PUSH
94383: LD_INT 117
94385: PUSH
94386: LD_INT 118
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: ST_TO_ADDR
94412: GO 95867
94414: LD_INT 13
94416: DOUBLE
94417: EQUAL
94418: IFTRUE 94422
94420: GO 94630
94422: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94423: LD_ADDR_VAR 0 1
94427: PUSH
94428: LD_INT 1
94430: PUSH
94431: LD_INT 2
94433: PUSH
94434: LD_INT 3
94436: PUSH
94437: LD_INT 4
94439: PUSH
94440: LD_INT 5
94442: PUSH
94443: LD_INT 8
94445: PUSH
94446: LD_INT 9
94448: PUSH
94449: LD_INT 10
94451: PUSH
94452: LD_INT 11
94454: PUSH
94455: LD_INT 12
94457: PUSH
94458: LD_INT 14
94460: PUSH
94461: LD_INT 15
94463: PUSH
94464: LD_INT 16
94466: PUSH
94467: LD_INT 17
94469: PUSH
94470: LD_INT 18
94472: PUSH
94473: LD_INT 19
94475: PUSH
94476: LD_INT 20
94478: PUSH
94479: LD_INT 21
94481: PUSH
94482: LD_INT 22
94484: PUSH
94485: LD_INT 23
94487: PUSH
94488: LD_INT 24
94490: PUSH
94491: LD_INT 25
94493: PUSH
94494: LD_INT 26
94496: PUSH
94497: LD_INT 27
94499: PUSH
94500: LD_INT 28
94502: PUSH
94503: LD_INT 30
94505: PUSH
94506: LD_INT 31
94508: PUSH
94509: LD_INT 32
94511: PUSH
94512: LD_INT 33
94514: PUSH
94515: LD_INT 34
94517: PUSH
94518: LD_INT 36
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: PUSH
94554: LD_INT 101
94556: PUSH
94557: LD_INT 102
94559: PUSH
94560: LD_INT 103
94562: PUSH
94563: LD_INT 104
94565: PUSH
94566: LD_INT 105
94568: PUSH
94569: LD_INT 106
94571: PUSH
94572: LD_INT 107
94574: PUSH
94575: LD_INT 108
94577: PUSH
94578: LD_INT 109
94580: PUSH
94581: LD_INT 110
94583: PUSH
94584: LD_INT 111
94586: PUSH
94587: LD_INT 112
94589: PUSH
94590: LD_INT 113
94592: PUSH
94593: LD_INT 114
94595: PUSH
94596: LD_INT 116
94598: PUSH
94599: LD_INT 117
94601: PUSH
94602: LD_INT 118
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: ST_TO_ADDR
94628: GO 95867
94630: LD_INT 14
94632: DOUBLE
94633: EQUAL
94634: IFTRUE 94638
94636: GO 94862
94638: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94639: LD_ADDR_VAR 0 1
94643: PUSH
94644: LD_INT 1
94646: PUSH
94647: LD_INT 2
94649: PUSH
94650: LD_INT 3
94652: PUSH
94653: LD_INT 4
94655: PUSH
94656: LD_INT 5
94658: PUSH
94659: LD_INT 6
94661: PUSH
94662: LD_INT 7
94664: PUSH
94665: LD_INT 8
94667: PUSH
94668: LD_INT 9
94670: PUSH
94671: LD_INT 10
94673: PUSH
94674: LD_INT 11
94676: PUSH
94677: LD_INT 12
94679: PUSH
94680: LD_INT 13
94682: PUSH
94683: LD_INT 14
94685: PUSH
94686: LD_INT 15
94688: PUSH
94689: LD_INT 16
94691: PUSH
94692: LD_INT 17
94694: PUSH
94695: LD_INT 18
94697: PUSH
94698: LD_INT 19
94700: PUSH
94701: LD_INT 20
94703: PUSH
94704: LD_INT 21
94706: PUSH
94707: LD_INT 22
94709: PUSH
94710: LD_INT 23
94712: PUSH
94713: LD_INT 24
94715: PUSH
94716: LD_INT 25
94718: PUSH
94719: LD_INT 26
94721: PUSH
94722: LD_INT 27
94724: PUSH
94725: LD_INT 28
94727: PUSH
94728: LD_INT 29
94730: PUSH
94731: LD_INT 30
94733: PUSH
94734: LD_INT 31
94736: PUSH
94737: LD_INT 32
94739: PUSH
94740: LD_INT 33
94742: PUSH
94743: LD_INT 34
94745: PUSH
94746: LD_INT 36
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 101
94788: PUSH
94789: LD_INT 102
94791: PUSH
94792: LD_INT 103
94794: PUSH
94795: LD_INT 104
94797: PUSH
94798: LD_INT 105
94800: PUSH
94801: LD_INT 106
94803: PUSH
94804: LD_INT 107
94806: PUSH
94807: LD_INT 108
94809: PUSH
94810: LD_INT 109
94812: PUSH
94813: LD_INT 110
94815: PUSH
94816: LD_INT 111
94818: PUSH
94819: LD_INT 112
94821: PUSH
94822: LD_INT 113
94824: PUSH
94825: LD_INT 114
94827: PUSH
94828: LD_INT 116
94830: PUSH
94831: LD_INT 117
94833: PUSH
94834: LD_INT 118
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: ST_TO_ADDR
94860: GO 95867
94862: LD_INT 15
94864: DOUBLE
94865: EQUAL
94866: IFTRUE 94870
94868: GO 95094
94870: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94871: LD_ADDR_VAR 0 1
94875: PUSH
94876: LD_INT 1
94878: PUSH
94879: LD_INT 2
94881: PUSH
94882: LD_INT 3
94884: PUSH
94885: LD_INT 4
94887: PUSH
94888: LD_INT 5
94890: PUSH
94891: LD_INT 6
94893: PUSH
94894: LD_INT 7
94896: PUSH
94897: LD_INT 8
94899: PUSH
94900: LD_INT 9
94902: PUSH
94903: LD_INT 10
94905: PUSH
94906: LD_INT 11
94908: PUSH
94909: LD_INT 12
94911: PUSH
94912: LD_INT 13
94914: PUSH
94915: LD_INT 14
94917: PUSH
94918: LD_INT 15
94920: PUSH
94921: LD_INT 16
94923: PUSH
94924: LD_INT 17
94926: PUSH
94927: LD_INT 18
94929: PUSH
94930: LD_INT 19
94932: PUSH
94933: LD_INT 20
94935: PUSH
94936: LD_INT 21
94938: PUSH
94939: LD_INT 22
94941: PUSH
94942: LD_INT 23
94944: PUSH
94945: LD_INT 24
94947: PUSH
94948: LD_INT 25
94950: PUSH
94951: LD_INT 26
94953: PUSH
94954: LD_INT 27
94956: PUSH
94957: LD_INT 28
94959: PUSH
94960: LD_INT 29
94962: PUSH
94963: LD_INT 30
94965: PUSH
94966: LD_INT 31
94968: PUSH
94969: LD_INT 32
94971: PUSH
94972: LD_INT 33
94974: PUSH
94975: LD_INT 34
94977: PUSH
94978: LD_INT 36
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 101
95020: PUSH
95021: LD_INT 102
95023: PUSH
95024: LD_INT 103
95026: PUSH
95027: LD_INT 104
95029: PUSH
95030: LD_INT 105
95032: PUSH
95033: LD_INT 106
95035: PUSH
95036: LD_INT 107
95038: PUSH
95039: LD_INT 108
95041: PUSH
95042: LD_INT 109
95044: PUSH
95045: LD_INT 110
95047: PUSH
95048: LD_INT 111
95050: PUSH
95051: LD_INT 112
95053: PUSH
95054: LD_INT 113
95056: PUSH
95057: LD_INT 114
95059: PUSH
95060: LD_INT 116
95062: PUSH
95063: LD_INT 117
95065: PUSH
95066: LD_INT 118
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: ST_TO_ADDR
95092: GO 95867
95094: LD_INT 16
95096: DOUBLE
95097: EQUAL
95098: IFTRUE 95102
95100: GO 95238
95102: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95103: LD_ADDR_VAR 0 1
95107: PUSH
95108: LD_INT 2
95110: PUSH
95111: LD_INT 4
95113: PUSH
95114: LD_INT 5
95116: PUSH
95117: LD_INT 7
95119: PUSH
95120: LD_INT 11
95122: PUSH
95123: LD_INT 12
95125: PUSH
95126: LD_INT 15
95128: PUSH
95129: LD_INT 16
95131: PUSH
95132: LD_INT 20
95134: PUSH
95135: LD_INT 21
95137: PUSH
95138: LD_INT 22
95140: PUSH
95141: LD_INT 23
95143: PUSH
95144: LD_INT 25
95146: PUSH
95147: LD_INT 26
95149: PUSH
95150: LD_INT 30
95152: PUSH
95153: LD_INT 31
95155: PUSH
95156: LD_INT 32
95158: PUSH
95159: LD_INT 33
95161: PUSH
95162: LD_INT 34
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 101
95188: PUSH
95189: LD_INT 102
95191: PUSH
95192: LD_INT 103
95194: PUSH
95195: LD_INT 106
95197: PUSH
95198: LD_INT 108
95200: PUSH
95201: LD_INT 112
95203: PUSH
95204: LD_INT 113
95206: PUSH
95207: LD_INT 114
95209: PUSH
95210: LD_INT 116
95212: PUSH
95213: LD_INT 117
95215: PUSH
95216: LD_INT 118
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: ST_TO_ADDR
95236: GO 95867
95238: LD_INT 17
95240: DOUBLE
95241: EQUAL
95242: IFTRUE 95246
95244: GO 95470
95246: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95247: LD_ADDR_VAR 0 1
95251: PUSH
95252: LD_INT 1
95254: PUSH
95255: LD_INT 2
95257: PUSH
95258: LD_INT 3
95260: PUSH
95261: LD_INT 4
95263: PUSH
95264: LD_INT 5
95266: PUSH
95267: LD_INT 6
95269: PUSH
95270: LD_INT 7
95272: PUSH
95273: LD_INT 8
95275: PUSH
95276: LD_INT 9
95278: PUSH
95279: LD_INT 10
95281: PUSH
95282: LD_INT 11
95284: PUSH
95285: LD_INT 12
95287: PUSH
95288: LD_INT 13
95290: PUSH
95291: LD_INT 14
95293: PUSH
95294: LD_INT 15
95296: PUSH
95297: LD_INT 16
95299: PUSH
95300: LD_INT 17
95302: PUSH
95303: LD_INT 18
95305: PUSH
95306: LD_INT 19
95308: PUSH
95309: LD_INT 20
95311: PUSH
95312: LD_INT 21
95314: PUSH
95315: LD_INT 22
95317: PUSH
95318: LD_INT 23
95320: PUSH
95321: LD_INT 24
95323: PUSH
95324: LD_INT 25
95326: PUSH
95327: LD_INT 26
95329: PUSH
95330: LD_INT 27
95332: PUSH
95333: LD_INT 28
95335: PUSH
95336: LD_INT 29
95338: PUSH
95339: LD_INT 30
95341: PUSH
95342: LD_INT 31
95344: PUSH
95345: LD_INT 32
95347: PUSH
95348: LD_INT 33
95350: PUSH
95351: LD_INT 34
95353: PUSH
95354: LD_INT 36
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: PUSH
95394: LD_INT 101
95396: PUSH
95397: LD_INT 102
95399: PUSH
95400: LD_INT 103
95402: PUSH
95403: LD_INT 104
95405: PUSH
95406: LD_INT 105
95408: PUSH
95409: LD_INT 106
95411: PUSH
95412: LD_INT 107
95414: PUSH
95415: LD_INT 108
95417: PUSH
95418: LD_INT 109
95420: PUSH
95421: LD_INT 110
95423: PUSH
95424: LD_INT 111
95426: PUSH
95427: LD_INT 112
95429: PUSH
95430: LD_INT 113
95432: PUSH
95433: LD_INT 114
95435: PUSH
95436: LD_INT 116
95438: PUSH
95439: LD_INT 117
95441: PUSH
95442: LD_INT 118
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: ST_TO_ADDR
95468: GO 95867
95470: LD_INT 18
95472: DOUBLE
95473: EQUAL
95474: IFTRUE 95478
95476: GO 95626
95478: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95479: LD_ADDR_VAR 0 1
95483: PUSH
95484: LD_INT 2
95486: PUSH
95487: LD_INT 4
95489: PUSH
95490: LD_INT 5
95492: PUSH
95493: LD_INT 7
95495: PUSH
95496: LD_INT 11
95498: PUSH
95499: LD_INT 12
95501: PUSH
95502: LD_INT 15
95504: PUSH
95505: LD_INT 16
95507: PUSH
95508: LD_INT 20
95510: PUSH
95511: LD_INT 21
95513: PUSH
95514: LD_INT 22
95516: PUSH
95517: LD_INT 23
95519: PUSH
95520: LD_INT 25
95522: PUSH
95523: LD_INT 26
95525: PUSH
95526: LD_INT 30
95528: PUSH
95529: LD_INT 31
95531: PUSH
95532: LD_INT 32
95534: PUSH
95535: LD_INT 33
95537: PUSH
95538: LD_INT 34
95540: PUSH
95541: LD_INT 35
95543: PUSH
95544: LD_INT 36
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: PUSH
95570: LD_INT 101
95572: PUSH
95573: LD_INT 102
95575: PUSH
95576: LD_INT 103
95578: PUSH
95579: LD_INT 106
95581: PUSH
95582: LD_INT 108
95584: PUSH
95585: LD_INT 112
95587: PUSH
95588: LD_INT 113
95590: PUSH
95591: LD_INT 114
95593: PUSH
95594: LD_INT 115
95596: PUSH
95597: LD_INT 116
95599: PUSH
95600: LD_INT 117
95602: PUSH
95603: LD_INT 118
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: ST_TO_ADDR
95624: GO 95867
95626: LD_INT 19
95628: DOUBLE
95629: EQUAL
95630: IFTRUE 95634
95632: GO 95866
95634: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95635: LD_ADDR_VAR 0 1
95639: PUSH
95640: LD_INT 1
95642: PUSH
95643: LD_INT 2
95645: PUSH
95646: LD_INT 3
95648: PUSH
95649: LD_INT 4
95651: PUSH
95652: LD_INT 5
95654: PUSH
95655: LD_INT 6
95657: PUSH
95658: LD_INT 7
95660: PUSH
95661: LD_INT 8
95663: PUSH
95664: LD_INT 9
95666: PUSH
95667: LD_INT 10
95669: PUSH
95670: LD_INT 11
95672: PUSH
95673: LD_INT 12
95675: PUSH
95676: LD_INT 13
95678: PUSH
95679: LD_INT 14
95681: PUSH
95682: LD_INT 15
95684: PUSH
95685: LD_INT 16
95687: PUSH
95688: LD_INT 17
95690: PUSH
95691: LD_INT 18
95693: PUSH
95694: LD_INT 19
95696: PUSH
95697: LD_INT 20
95699: PUSH
95700: LD_INT 21
95702: PUSH
95703: LD_INT 22
95705: PUSH
95706: LD_INT 23
95708: PUSH
95709: LD_INT 24
95711: PUSH
95712: LD_INT 25
95714: PUSH
95715: LD_INT 26
95717: PUSH
95718: LD_INT 27
95720: PUSH
95721: LD_INT 28
95723: PUSH
95724: LD_INT 29
95726: PUSH
95727: LD_INT 30
95729: PUSH
95730: LD_INT 31
95732: PUSH
95733: LD_INT 32
95735: PUSH
95736: LD_INT 33
95738: PUSH
95739: LD_INT 34
95741: PUSH
95742: LD_INT 35
95744: PUSH
95745: LD_INT 36
95747: PUSH
95748: EMPTY
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 101
95788: PUSH
95789: LD_INT 102
95791: PUSH
95792: LD_INT 103
95794: PUSH
95795: LD_INT 104
95797: PUSH
95798: LD_INT 105
95800: PUSH
95801: LD_INT 106
95803: PUSH
95804: LD_INT 107
95806: PUSH
95807: LD_INT 108
95809: PUSH
95810: LD_INT 109
95812: PUSH
95813: LD_INT 110
95815: PUSH
95816: LD_INT 111
95818: PUSH
95819: LD_INT 112
95821: PUSH
95822: LD_INT 113
95824: PUSH
95825: LD_INT 114
95827: PUSH
95828: LD_INT 115
95830: PUSH
95831: LD_INT 116
95833: PUSH
95834: LD_INT 117
95836: PUSH
95837: LD_INT 118
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: ST_TO_ADDR
95864: GO 95867
95866: POP
// end else
95867: GO 96098
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95869: LD_ADDR_VAR 0 1
95873: PUSH
95874: LD_INT 1
95876: PUSH
95877: LD_INT 2
95879: PUSH
95880: LD_INT 3
95882: PUSH
95883: LD_INT 4
95885: PUSH
95886: LD_INT 5
95888: PUSH
95889: LD_INT 6
95891: PUSH
95892: LD_INT 7
95894: PUSH
95895: LD_INT 8
95897: PUSH
95898: LD_INT 9
95900: PUSH
95901: LD_INT 10
95903: PUSH
95904: LD_INT 11
95906: PUSH
95907: LD_INT 12
95909: PUSH
95910: LD_INT 13
95912: PUSH
95913: LD_INT 14
95915: PUSH
95916: LD_INT 15
95918: PUSH
95919: LD_INT 16
95921: PUSH
95922: LD_INT 17
95924: PUSH
95925: LD_INT 18
95927: PUSH
95928: LD_INT 19
95930: PUSH
95931: LD_INT 20
95933: PUSH
95934: LD_INT 21
95936: PUSH
95937: LD_INT 22
95939: PUSH
95940: LD_INT 23
95942: PUSH
95943: LD_INT 24
95945: PUSH
95946: LD_INT 25
95948: PUSH
95949: LD_INT 26
95951: PUSH
95952: LD_INT 27
95954: PUSH
95955: LD_INT 28
95957: PUSH
95958: LD_INT 29
95960: PUSH
95961: LD_INT 30
95963: PUSH
95964: LD_INT 31
95966: PUSH
95967: LD_INT 32
95969: PUSH
95970: LD_INT 33
95972: PUSH
95973: LD_INT 34
95975: PUSH
95976: LD_INT 35
95978: PUSH
95979: LD_INT 36
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: PUSH
96020: LD_INT 101
96022: PUSH
96023: LD_INT 102
96025: PUSH
96026: LD_INT 103
96028: PUSH
96029: LD_INT 104
96031: PUSH
96032: LD_INT 105
96034: PUSH
96035: LD_INT 106
96037: PUSH
96038: LD_INT 107
96040: PUSH
96041: LD_INT 108
96043: PUSH
96044: LD_INT 109
96046: PUSH
96047: LD_INT 110
96049: PUSH
96050: LD_INT 111
96052: PUSH
96053: LD_INT 112
96055: PUSH
96056: LD_INT 113
96058: PUSH
96059: LD_INT 114
96061: PUSH
96062: LD_INT 115
96064: PUSH
96065: LD_INT 116
96067: PUSH
96068: LD_INT 117
96070: PUSH
96071: LD_INT 118
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: ST_TO_ADDR
// if result then
96098: LD_VAR 0 1
96102: IFFALSE 96391
// begin normal :=  ;
96104: LD_ADDR_VAR 0 3
96108: PUSH
96109: LD_STRING 
96111: ST_TO_ADDR
// hardcore :=  ;
96112: LD_ADDR_VAR 0 4
96116: PUSH
96117: LD_STRING 
96119: ST_TO_ADDR
// for i = 1 to normalCounter do
96120: LD_ADDR_VAR 0 5
96124: PUSH
96125: DOUBLE
96126: LD_INT 1
96128: DEC
96129: ST_TO_ADDR
96130: LD_EXP 138
96134: PUSH
96135: FOR_TO
96136: IFFALSE 96237
// begin tmp := 0 ;
96138: LD_ADDR_VAR 0 2
96142: PUSH
96143: LD_STRING 0
96145: ST_TO_ADDR
// if result [ 1 ] then
96146: LD_VAR 0 1
96150: PUSH
96151: LD_INT 1
96153: ARRAY
96154: IFFALSE 96219
// if result [ 1 ] [ 1 ] = i then
96156: LD_VAR 0 1
96160: PUSH
96161: LD_INT 1
96163: ARRAY
96164: PUSH
96165: LD_INT 1
96167: ARRAY
96168: PUSH
96169: LD_VAR 0 5
96173: EQUAL
96174: IFFALSE 96219
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96176: LD_ADDR_VAR 0 1
96180: PUSH
96181: LD_VAR 0 1
96185: PPUSH
96186: LD_INT 1
96188: PPUSH
96189: LD_VAR 0 1
96193: PUSH
96194: LD_INT 1
96196: ARRAY
96197: PPUSH
96198: LD_INT 1
96200: PPUSH
96201: CALL_OW 3
96205: PPUSH
96206: CALL_OW 1
96210: ST_TO_ADDR
// tmp := 1 ;
96211: LD_ADDR_VAR 0 2
96215: PUSH
96216: LD_STRING 1
96218: ST_TO_ADDR
// end ; normal := normal & tmp ;
96219: LD_ADDR_VAR 0 3
96223: PUSH
96224: LD_VAR 0 3
96228: PUSH
96229: LD_VAR 0 2
96233: STR
96234: ST_TO_ADDR
// end ;
96235: GO 96135
96237: POP
96238: POP
// for i = 1 to hardcoreCounter do
96239: LD_ADDR_VAR 0 5
96243: PUSH
96244: DOUBLE
96245: LD_INT 1
96247: DEC
96248: ST_TO_ADDR
96249: LD_EXP 139
96253: PUSH
96254: FOR_TO
96255: IFFALSE 96360
// begin tmp := 0 ;
96257: LD_ADDR_VAR 0 2
96261: PUSH
96262: LD_STRING 0
96264: ST_TO_ADDR
// if result [ 2 ] then
96265: LD_VAR 0 1
96269: PUSH
96270: LD_INT 2
96272: ARRAY
96273: IFFALSE 96342
// if result [ 2 ] [ 1 ] = 100 + i then
96275: LD_VAR 0 1
96279: PUSH
96280: LD_INT 2
96282: ARRAY
96283: PUSH
96284: LD_INT 1
96286: ARRAY
96287: PUSH
96288: LD_INT 100
96290: PUSH
96291: LD_VAR 0 5
96295: PLUS
96296: EQUAL
96297: IFFALSE 96342
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96299: LD_ADDR_VAR 0 1
96303: PUSH
96304: LD_VAR 0 1
96308: PPUSH
96309: LD_INT 2
96311: PPUSH
96312: LD_VAR 0 1
96316: PUSH
96317: LD_INT 2
96319: ARRAY
96320: PPUSH
96321: LD_INT 1
96323: PPUSH
96324: CALL_OW 3
96328: PPUSH
96329: CALL_OW 1
96333: ST_TO_ADDR
// tmp := 1 ;
96334: LD_ADDR_VAR 0 2
96338: PUSH
96339: LD_STRING 1
96341: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96342: LD_ADDR_VAR 0 4
96346: PUSH
96347: LD_VAR 0 4
96351: PUSH
96352: LD_VAR 0 2
96356: STR
96357: ST_TO_ADDR
// end ;
96358: GO 96254
96360: POP
96361: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
96362: LD_STRING getStreamItemsFromMission("
96364: PUSH
96365: LD_VAR 0 3
96369: STR
96370: PUSH
96371: LD_STRING ","
96373: STR
96374: PUSH
96375: LD_VAR 0 4
96379: STR
96380: PUSH
96381: LD_STRING ")
96383: STR
96384: PPUSH
96385: CALL_OW 559
// end else
96389: GO 96398
// ToLua ( getStreamItemsFromMission("","") ) ;
96391: LD_STRING getStreamItemsFromMission("","")
96393: PPUSH
96394: CALL_OW 559
// end ;
96398: LD_VAR 0 1
96402: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96403: LD_EXP 137
96407: PUSH
96408: LD_EXP 142
96412: AND
96413: IFFALSE 96537
96415: GO 96417
96417: DISABLE
96418: LD_INT 0
96420: PPUSH
96421: PPUSH
// begin enable ;
96422: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96423: LD_ADDR_VAR 0 2
96427: PUSH
96428: LD_INT 22
96430: PUSH
96431: LD_OWVAR 2
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_INT 2
96442: PUSH
96443: LD_INT 34
96445: PUSH
96446: LD_INT 7
96448: PUSH
96449: EMPTY
96450: LIST
96451: LIST
96452: PUSH
96453: LD_INT 34
96455: PUSH
96456: LD_INT 45
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: PUSH
96463: LD_INT 34
96465: PUSH
96466: LD_INT 28
96468: PUSH
96469: EMPTY
96470: LIST
96471: LIST
96472: PUSH
96473: LD_INT 34
96475: PUSH
96476: LD_INT 47
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PPUSH
96494: CALL_OW 69
96498: ST_TO_ADDR
// if not tmp then
96499: LD_VAR 0 2
96503: NOT
96504: IFFALSE 96508
// exit ;
96506: GO 96537
// for i in tmp do
96508: LD_ADDR_VAR 0 1
96512: PUSH
96513: LD_VAR 0 2
96517: PUSH
96518: FOR_IN
96519: IFFALSE 96535
// begin SetLives ( i , 0 ) ;
96521: LD_VAR 0 1
96525: PPUSH
96526: LD_INT 0
96528: PPUSH
96529: CALL_OW 234
// end ;
96533: GO 96518
96535: POP
96536: POP
// end ;
96537: PPOPN 2
96539: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96540: LD_EXP 137
96544: PUSH
96545: LD_EXP 143
96549: AND
96550: IFFALSE 96634
96552: GO 96554
96554: DISABLE
96555: LD_INT 0
96557: PPUSH
96558: PPUSH
// begin enable ;
96559: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96560: LD_ADDR_VAR 0 2
96564: PUSH
96565: LD_INT 22
96567: PUSH
96568: LD_OWVAR 2
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 32
96579: PUSH
96580: LD_INT 3
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PPUSH
96591: CALL_OW 69
96595: ST_TO_ADDR
// if not tmp then
96596: LD_VAR 0 2
96600: NOT
96601: IFFALSE 96605
// exit ;
96603: GO 96634
// for i in tmp do
96605: LD_ADDR_VAR 0 1
96609: PUSH
96610: LD_VAR 0 2
96614: PUSH
96615: FOR_IN
96616: IFFALSE 96632
// begin SetLives ( i , 0 ) ;
96618: LD_VAR 0 1
96622: PPUSH
96623: LD_INT 0
96625: PPUSH
96626: CALL_OW 234
// end ;
96630: GO 96615
96632: POP
96633: POP
// end ;
96634: PPOPN 2
96636: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96637: LD_EXP 137
96641: PUSH
96642: LD_EXP 140
96646: AND
96647: IFFALSE 96740
96649: GO 96651
96651: DISABLE
96652: LD_INT 0
96654: PPUSH
// begin enable ;
96655: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96656: LD_ADDR_VAR 0 1
96660: PUSH
96661: LD_INT 22
96663: PUSH
96664: LD_OWVAR 2
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 2
96675: PUSH
96676: LD_INT 25
96678: PUSH
96679: LD_INT 5
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 25
96688: PUSH
96689: LD_INT 9
96691: PUSH
96692: EMPTY
96693: LIST
96694: LIST
96695: PUSH
96696: LD_INT 25
96698: PUSH
96699: LD_INT 8
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: PPUSH
96716: CALL_OW 69
96720: PUSH
96721: FOR_IN
96722: IFFALSE 96738
// begin SetClass ( i , 1 ) ;
96724: LD_VAR 0 1
96728: PPUSH
96729: LD_INT 1
96731: PPUSH
96732: CALL_OW 336
// end ;
96736: GO 96721
96738: POP
96739: POP
// end ;
96740: PPOPN 1
96742: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96743: LD_EXP 137
96747: PUSH
96748: LD_EXP 141
96752: AND
96753: PUSH
96754: LD_OWVAR 65
96758: PUSH
96759: LD_INT 7
96761: LESS
96762: AND
96763: IFFALSE 96777
96765: GO 96767
96767: DISABLE
// begin enable ;
96768: ENABLE
// game_speed := 7 ;
96769: LD_ADDR_OWVAR 65
96773: PUSH
96774: LD_INT 7
96776: ST_TO_ADDR
// end ;
96777: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96778: LD_EXP 137
96782: PUSH
96783: LD_EXP 144
96787: AND
96788: IFFALSE 96990
96790: GO 96792
96792: DISABLE
96793: LD_INT 0
96795: PPUSH
96796: PPUSH
96797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96798: LD_ADDR_VAR 0 3
96802: PUSH
96803: LD_INT 81
96805: PUSH
96806: LD_OWVAR 2
96810: PUSH
96811: EMPTY
96812: LIST
96813: LIST
96814: PUSH
96815: LD_INT 21
96817: PUSH
96818: LD_INT 1
96820: PUSH
96821: EMPTY
96822: LIST
96823: LIST
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PPUSH
96829: CALL_OW 69
96833: ST_TO_ADDR
// if not tmp then
96834: LD_VAR 0 3
96838: NOT
96839: IFFALSE 96843
// exit ;
96841: GO 96990
// if tmp > 5 then
96843: LD_VAR 0 3
96847: PUSH
96848: LD_INT 5
96850: GREATER
96851: IFFALSE 96863
// k := 5 else
96853: LD_ADDR_VAR 0 2
96857: PUSH
96858: LD_INT 5
96860: ST_TO_ADDR
96861: GO 96873
// k := tmp ;
96863: LD_ADDR_VAR 0 2
96867: PUSH
96868: LD_VAR 0 3
96872: ST_TO_ADDR
// for i := 1 to k do
96873: LD_ADDR_VAR 0 1
96877: PUSH
96878: DOUBLE
96879: LD_INT 1
96881: DEC
96882: ST_TO_ADDR
96883: LD_VAR 0 2
96887: PUSH
96888: FOR_TO
96889: IFFALSE 96988
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96891: LD_VAR 0 3
96895: PUSH
96896: LD_VAR 0 1
96900: ARRAY
96901: PPUSH
96902: LD_VAR 0 1
96906: PUSH
96907: LD_INT 4
96909: MOD
96910: PUSH
96911: LD_INT 1
96913: PLUS
96914: PPUSH
96915: CALL_OW 259
96919: PUSH
96920: LD_INT 10
96922: LESS
96923: IFFALSE 96986
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96925: LD_VAR 0 3
96929: PUSH
96930: LD_VAR 0 1
96934: ARRAY
96935: PPUSH
96936: LD_VAR 0 1
96940: PUSH
96941: LD_INT 4
96943: MOD
96944: PUSH
96945: LD_INT 1
96947: PLUS
96948: PPUSH
96949: LD_VAR 0 3
96953: PUSH
96954: LD_VAR 0 1
96958: ARRAY
96959: PPUSH
96960: LD_VAR 0 1
96964: PUSH
96965: LD_INT 4
96967: MOD
96968: PUSH
96969: LD_INT 1
96971: PLUS
96972: PPUSH
96973: CALL_OW 259
96977: PUSH
96978: LD_INT 1
96980: PLUS
96981: PPUSH
96982: CALL_OW 237
96986: GO 96888
96988: POP
96989: POP
// end ;
96990: PPOPN 3
96992: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96993: LD_EXP 137
96997: PUSH
96998: LD_EXP 145
97002: AND
97003: IFFALSE 97023
97005: GO 97007
97007: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97008: LD_INT 4
97010: PPUSH
97011: LD_OWVAR 2
97015: PPUSH
97016: LD_INT 0
97018: PPUSH
97019: CALL_OW 324
97023: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97024: LD_EXP 137
97028: PUSH
97029: LD_EXP 174
97033: AND
97034: IFFALSE 97054
97036: GO 97038
97038: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97039: LD_INT 19
97041: PPUSH
97042: LD_OWVAR 2
97046: PPUSH
97047: LD_INT 0
97049: PPUSH
97050: CALL_OW 324
97054: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97055: LD_EXP 137
97059: PUSH
97060: LD_EXP 146
97064: AND
97065: IFFALSE 97167
97067: GO 97069
97069: DISABLE
97070: LD_INT 0
97072: PPUSH
97073: PPUSH
// begin enable ;
97074: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97075: LD_ADDR_VAR 0 2
97079: PUSH
97080: LD_INT 22
97082: PUSH
97083: LD_OWVAR 2
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 2
97094: PUSH
97095: LD_INT 34
97097: PUSH
97098: LD_INT 11
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 34
97107: PUSH
97108: LD_INT 30
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: LIST
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PPUSH
97124: CALL_OW 69
97128: ST_TO_ADDR
// if not tmp then
97129: LD_VAR 0 2
97133: NOT
97134: IFFALSE 97138
// exit ;
97136: GO 97167
// for i in tmp do
97138: LD_ADDR_VAR 0 1
97142: PUSH
97143: LD_VAR 0 2
97147: PUSH
97148: FOR_IN
97149: IFFALSE 97165
// begin SetLives ( i , 0 ) ;
97151: LD_VAR 0 1
97155: PPUSH
97156: LD_INT 0
97158: PPUSH
97159: CALL_OW 234
// end ;
97163: GO 97148
97165: POP
97166: POP
// end ;
97167: PPOPN 2
97169: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97170: LD_EXP 137
97174: PUSH
97175: LD_EXP 147
97179: AND
97180: IFFALSE 97200
97182: GO 97184
97184: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97185: LD_INT 32
97187: PPUSH
97188: LD_OWVAR 2
97192: PPUSH
97193: LD_INT 0
97195: PPUSH
97196: CALL_OW 324
97200: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97201: LD_EXP 137
97205: PUSH
97206: LD_EXP 148
97210: AND
97211: IFFALSE 97392
97213: GO 97215
97215: DISABLE
97216: LD_INT 0
97218: PPUSH
97219: PPUSH
97220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97221: LD_ADDR_VAR 0 2
97225: PUSH
97226: LD_INT 22
97228: PUSH
97229: LD_OWVAR 2
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 33
97240: PUSH
97241: LD_INT 3
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: PPUSH
97252: CALL_OW 69
97256: ST_TO_ADDR
// if not tmp then
97257: LD_VAR 0 2
97261: NOT
97262: IFFALSE 97266
// exit ;
97264: GO 97392
// side := 0 ;
97266: LD_ADDR_VAR 0 3
97270: PUSH
97271: LD_INT 0
97273: ST_TO_ADDR
// for i := 1 to 8 do
97274: LD_ADDR_VAR 0 1
97278: PUSH
97279: DOUBLE
97280: LD_INT 1
97282: DEC
97283: ST_TO_ADDR
97284: LD_INT 8
97286: PUSH
97287: FOR_TO
97288: IFFALSE 97336
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97290: LD_OWVAR 2
97294: PUSH
97295: LD_VAR 0 1
97299: NONEQUAL
97300: PUSH
97301: LD_OWVAR 2
97305: PPUSH
97306: LD_VAR 0 1
97310: PPUSH
97311: CALL_OW 81
97315: PUSH
97316: LD_INT 2
97318: EQUAL
97319: AND
97320: IFFALSE 97334
// begin side := i ;
97322: LD_ADDR_VAR 0 3
97326: PUSH
97327: LD_VAR 0 1
97331: ST_TO_ADDR
// break ;
97332: GO 97336
// end ;
97334: GO 97287
97336: POP
97337: POP
// if not side then
97338: LD_VAR 0 3
97342: NOT
97343: IFFALSE 97347
// exit ;
97345: GO 97392
// for i := 1 to tmp do
97347: LD_ADDR_VAR 0 1
97351: PUSH
97352: DOUBLE
97353: LD_INT 1
97355: DEC
97356: ST_TO_ADDR
97357: LD_VAR 0 2
97361: PUSH
97362: FOR_TO
97363: IFFALSE 97390
// if Prob ( 60 ) then
97365: LD_INT 60
97367: PPUSH
97368: CALL_OW 13
97372: IFFALSE 97388
// SetSide ( i , side ) ;
97374: LD_VAR 0 1
97378: PPUSH
97379: LD_VAR 0 3
97383: PPUSH
97384: CALL_OW 235
97388: GO 97362
97390: POP
97391: POP
// end ;
97392: PPOPN 3
97394: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97395: LD_EXP 137
97399: PUSH
97400: LD_EXP 150
97404: AND
97405: IFFALSE 97524
97407: GO 97409
97409: DISABLE
97410: LD_INT 0
97412: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97413: LD_ADDR_VAR 0 1
97417: PUSH
97418: LD_INT 22
97420: PUSH
97421: LD_OWVAR 2
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 21
97432: PUSH
97433: LD_INT 1
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 3
97442: PUSH
97443: LD_INT 23
97445: PUSH
97446: LD_INT 0
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: LIST
97461: PPUSH
97462: CALL_OW 69
97466: PUSH
97467: FOR_IN
97468: IFFALSE 97522
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97470: LD_VAR 0 1
97474: PPUSH
97475: CALL_OW 257
97479: PUSH
97480: LD_INT 1
97482: PUSH
97483: LD_INT 2
97485: PUSH
97486: LD_INT 3
97488: PUSH
97489: LD_INT 4
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: IN
97498: IFFALSE 97520
// SetClass ( un , rand ( 1 , 4 ) ) ;
97500: LD_VAR 0 1
97504: PPUSH
97505: LD_INT 1
97507: PPUSH
97508: LD_INT 4
97510: PPUSH
97511: CALL_OW 12
97515: PPUSH
97516: CALL_OW 336
97520: GO 97467
97522: POP
97523: POP
// end ;
97524: PPOPN 1
97526: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97527: LD_EXP 137
97531: PUSH
97532: LD_EXP 149
97536: AND
97537: IFFALSE 97616
97539: GO 97541
97541: DISABLE
97542: LD_INT 0
97544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97545: LD_ADDR_VAR 0 1
97549: PUSH
97550: LD_INT 22
97552: PUSH
97553: LD_OWVAR 2
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: PUSH
97562: LD_INT 21
97564: PUSH
97565: LD_INT 3
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PPUSH
97576: CALL_OW 69
97580: ST_TO_ADDR
// if not tmp then
97581: LD_VAR 0 1
97585: NOT
97586: IFFALSE 97590
// exit ;
97588: GO 97616
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97590: LD_VAR 0 1
97594: PUSH
97595: LD_INT 1
97597: PPUSH
97598: LD_VAR 0 1
97602: PPUSH
97603: CALL_OW 12
97607: ARRAY
97608: PPUSH
97609: LD_INT 100
97611: PPUSH
97612: CALL_OW 234
// end ;
97616: PPOPN 1
97618: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97619: LD_EXP 137
97623: PUSH
97624: LD_EXP 151
97628: AND
97629: IFFALSE 97727
97631: GO 97633
97633: DISABLE
97634: LD_INT 0
97636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97637: LD_ADDR_VAR 0 1
97641: PUSH
97642: LD_INT 22
97644: PUSH
97645: LD_OWVAR 2
97649: PUSH
97650: EMPTY
97651: LIST
97652: LIST
97653: PUSH
97654: LD_INT 21
97656: PUSH
97657: LD_INT 1
97659: PUSH
97660: EMPTY
97661: LIST
97662: LIST
97663: PUSH
97664: EMPTY
97665: LIST
97666: LIST
97667: PPUSH
97668: CALL_OW 69
97672: ST_TO_ADDR
// if not tmp then
97673: LD_VAR 0 1
97677: NOT
97678: IFFALSE 97682
// exit ;
97680: GO 97727
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97682: LD_VAR 0 1
97686: PUSH
97687: LD_INT 1
97689: PPUSH
97690: LD_VAR 0 1
97694: PPUSH
97695: CALL_OW 12
97699: ARRAY
97700: PPUSH
97701: LD_INT 1
97703: PPUSH
97704: LD_INT 4
97706: PPUSH
97707: CALL_OW 12
97711: PPUSH
97712: LD_INT 3000
97714: PPUSH
97715: LD_INT 9000
97717: PPUSH
97718: CALL_OW 12
97722: PPUSH
97723: CALL_OW 492
// end ;
97727: PPOPN 1
97729: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97730: LD_EXP 137
97734: PUSH
97735: LD_EXP 152
97739: AND
97740: IFFALSE 97760
97742: GO 97744
97744: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97745: LD_INT 1
97747: PPUSH
97748: LD_OWVAR 2
97752: PPUSH
97753: LD_INT 0
97755: PPUSH
97756: CALL_OW 324
97760: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97761: LD_EXP 137
97765: PUSH
97766: LD_EXP 153
97770: AND
97771: IFFALSE 97854
97773: GO 97775
97775: DISABLE
97776: LD_INT 0
97778: PPUSH
97779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97780: LD_ADDR_VAR 0 2
97784: PUSH
97785: LD_INT 22
97787: PUSH
97788: LD_OWVAR 2
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 21
97799: PUSH
97800: LD_INT 3
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PPUSH
97811: CALL_OW 69
97815: ST_TO_ADDR
// if not tmp then
97816: LD_VAR 0 2
97820: NOT
97821: IFFALSE 97825
// exit ;
97823: GO 97854
// for i in tmp do
97825: LD_ADDR_VAR 0 1
97829: PUSH
97830: LD_VAR 0 2
97834: PUSH
97835: FOR_IN
97836: IFFALSE 97852
// SetBLevel ( i , 10 ) ;
97838: LD_VAR 0 1
97842: PPUSH
97843: LD_INT 10
97845: PPUSH
97846: CALL_OW 241
97850: GO 97835
97852: POP
97853: POP
// end ;
97854: PPOPN 2
97856: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97857: LD_EXP 137
97861: PUSH
97862: LD_EXP 154
97866: AND
97867: IFFALSE 97978
97869: GO 97871
97871: DISABLE
97872: LD_INT 0
97874: PPUSH
97875: PPUSH
97876: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97877: LD_ADDR_VAR 0 3
97881: PUSH
97882: LD_INT 22
97884: PUSH
97885: LD_OWVAR 2
97889: PUSH
97890: EMPTY
97891: LIST
97892: LIST
97893: PUSH
97894: LD_INT 25
97896: PUSH
97897: LD_INT 1
97899: PUSH
97900: EMPTY
97901: LIST
97902: LIST
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PPUSH
97908: CALL_OW 69
97912: ST_TO_ADDR
// if not tmp then
97913: LD_VAR 0 3
97917: NOT
97918: IFFALSE 97922
// exit ;
97920: GO 97978
// un := tmp [ rand ( 1 , tmp ) ] ;
97922: LD_ADDR_VAR 0 2
97926: PUSH
97927: LD_VAR 0 3
97931: PUSH
97932: LD_INT 1
97934: PPUSH
97935: LD_VAR 0 3
97939: PPUSH
97940: CALL_OW 12
97944: ARRAY
97945: ST_TO_ADDR
// if Crawls ( un ) then
97946: LD_VAR 0 2
97950: PPUSH
97951: CALL_OW 318
97955: IFFALSE 97966
// ComWalk ( un ) ;
97957: LD_VAR 0 2
97961: PPUSH
97962: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97966: LD_VAR 0 2
97970: PPUSH
97971: LD_INT 5
97973: PPUSH
97974: CALL_OW 336
// end ;
97978: PPOPN 3
97980: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97981: LD_EXP 137
97985: PUSH
97986: LD_EXP 155
97990: AND
97991: PUSH
97992: LD_OWVAR 67
97996: PUSH
97997: LD_INT 4
97999: LESS
98000: AND
98001: IFFALSE 98020
98003: GO 98005
98005: DISABLE
// begin Difficulty := Difficulty + 1 ;
98006: LD_ADDR_OWVAR 67
98010: PUSH
98011: LD_OWVAR 67
98015: PUSH
98016: LD_INT 1
98018: PLUS
98019: ST_TO_ADDR
// end ;
98020: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98021: LD_EXP 137
98025: PUSH
98026: LD_EXP 156
98030: AND
98031: IFFALSE 98134
98033: GO 98035
98035: DISABLE
98036: LD_INT 0
98038: PPUSH
// begin for i := 1 to 5 do
98039: LD_ADDR_VAR 0 1
98043: PUSH
98044: DOUBLE
98045: LD_INT 1
98047: DEC
98048: ST_TO_ADDR
98049: LD_INT 5
98051: PUSH
98052: FOR_TO
98053: IFFALSE 98132
// begin uc_nation := nation_nature ;
98055: LD_ADDR_OWVAR 21
98059: PUSH
98060: LD_INT 0
98062: ST_TO_ADDR
// uc_side := 0 ;
98063: LD_ADDR_OWVAR 20
98067: PUSH
98068: LD_INT 0
98070: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98071: LD_ADDR_OWVAR 29
98075: PUSH
98076: LD_INT 12
98078: PUSH
98079: LD_INT 12
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: ST_TO_ADDR
// hc_agressivity := 20 ;
98086: LD_ADDR_OWVAR 35
98090: PUSH
98091: LD_INT 20
98093: ST_TO_ADDR
// hc_class := class_tiger ;
98094: LD_ADDR_OWVAR 28
98098: PUSH
98099: LD_INT 14
98101: ST_TO_ADDR
// hc_gallery :=  ;
98102: LD_ADDR_OWVAR 33
98106: PUSH
98107: LD_STRING 
98109: ST_TO_ADDR
// hc_name :=  ;
98110: LD_ADDR_OWVAR 26
98114: PUSH
98115: LD_STRING 
98117: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98118: CALL_OW 44
98122: PPUSH
98123: LD_INT 0
98125: PPUSH
98126: CALL_OW 51
// end ;
98130: GO 98052
98132: POP
98133: POP
// end ;
98134: PPOPN 1
98136: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98137: LD_EXP 137
98141: PUSH
98142: LD_EXP 157
98146: AND
98147: IFFALSE 98156
98149: GO 98151
98151: DISABLE
// StreamSibBomb ;
98152: CALL 98157 0 0
98156: END
// export function StreamSibBomb ; var i , x , y ; begin
98157: LD_INT 0
98159: PPUSH
98160: PPUSH
98161: PPUSH
98162: PPUSH
// result := false ;
98163: LD_ADDR_VAR 0 1
98167: PUSH
98168: LD_INT 0
98170: ST_TO_ADDR
// for i := 1 to 16 do
98171: LD_ADDR_VAR 0 2
98175: PUSH
98176: DOUBLE
98177: LD_INT 1
98179: DEC
98180: ST_TO_ADDR
98181: LD_INT 16
98183: PUSH
98184: FOR_TO
98185: IFFALSE 98384
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98187: LD_ADDR_VAR 0 3
98191: PUSH
98192: LD_INT 10
98194: PUSH
98195: LD_INT 20
98197: PUSH
98198: LD_INT 30
98200: PUSH
98201: LD_INT 40
98203: PUSH
98204: LD_INT 50
98206: PUSH
98207: LD_INT 60
98209: PUSH
98210: LD_INT 70
98212: PUSH
98213: LD_INT 80
98215: PUSH
98216: LD_INT 90
98218: PUSH
98219: LD_INT 100
98221: PUSH
98222: LD_INT 110
98224: PUSH
98225: LD_INT 120
98227: PUSH
98228: LD_INT 130
98230: PUSH
98231: LD_INT 140
98233: PUSH
98234: LD_INT 150
98236: PUSH
98237: EMPTY
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: PUSH
98254: LD_INT 1
98256: PPUSH
98257: LD_INT 15
98259: PPUSH
98260: CALL_OW 12
98264: ARRAY
98265: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98266: LD_ADDR_VAR 0 4
98270: PUSH
98271: LD_INT 10
98273: PUSH
98274: LD_INT 20
98276: PUSH
98277: LD_INT 30
98279: PUSH
98280: LD_INT 40
98282: PUSH
98283: LD_INT 50
98285: PUSH
98286: LD_INT 60
98288: PUSH
98289: LD_INT 70
98291: PUSH
98292: LD_INT 80
98294: PUSH
98295: LD_INT 90
98297: PUSH
98298: LD_INT 100
98300: PUSH
98301: LD_INT 110
98303: PUSH
98304: LD_INT 120
98306: PUSH
98307: LD_INT 130
98309: PUSH
98310: LD_INT 140
98312: PUSH
98313: LD_INT 150
98315: PUSH
98316: EMPTY
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: PUSH
98333: LD_INT 1
98335: PPUSH
98336: LD_INT 15
98338: PPUSH
98339: CALL_OW 12
98343: ARRAY
98344: ST_TO_ADDR
// if ValidHex ( x , y ) then
98345: LD_VAR 0 3
98349: PPUSH
98350: LD_VAR 0 4
98354: PPUSH
98355: CALL_OW 488
98359: IFFALSE 98382
// begin result := [ x , y ] ;
98361: LD_ADDR_VAR 0 1
98365: PUSH
98366: LD_VAR 0 3
98370: PUSH
98371: LD_VAR 0 4
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: ST_TO_ADDR
// break ;
98380: GO 98384
// end ; end ;
98382: GO 98184
98384: POP
98385: POP
// if result then
98386: LD_VAR 0 1
98390: IFFALSE 98450
// begin ToLua ( playSibBomb() ) ;
98392: LD_STRING playSibBomb()
98394: PPUSH
98395: CALL_OW 559
// wait ( 0 0$14 ) ;
98399: LD_INT 490
98401: PPUSH
98402: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98406: LD_VAR 0 1
98410: PUSH
98411: LD_INT 1
98413: ARRAY
98414: PPUSH
98415: LD_VAR 0 1
98419: PUSH
98420: LD_INT 2
98422: ARRAY
98423: PPUSH
98424: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98428: LD_VAR 0 1
98432: PUSH
98433: LD_INT 1
98435: ARRAY
98436: PPUSH
98437: LD_VAR 0 1
98441: PUSH
98442: LD_INT 2
98444: ARRAY
98445: PPUSH
98446: CALL_OW 429
// end ; end ;
98450: LD_VAR 0 1
98454: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98455: LD_EXP 137
98459: PUSH
98460: LD_EXP 159
98464: AND
98465: IFFALSE 98477
98467: GO 98469
98469: DISABLE
// YouLost (  ) ;
98470: LD_STRING 
98472: PPUSH
98473: CALL_OW 104
98477: END
// every 0 0$1 trigger StreamModeActive and sFog do
98478: LD_EXP 137
98482: PUSH
98483: LD_EXP 158
98487: AND
98488: IFFALSE 98502
98490: GO 98492
98492: DISABLE
// FogOff ( your_side ) ;
98493: LD_OWVAR 2
98497: PPUSH
98498: CALL_OW 344
98502: END
// every 0 0$1 trigger StreamModeActive and sSun do
98503: LD_EXP 137
98507: PUSH
98508: LD_EXP 160
98512: AND
98513: IFFALSE 98541
98515: GO 98517
98517: DISABLE
// begin solar_recharge_percent := 0 ;
98518: LD_ADDR_OWVAR 79
98522: PUSH
98523: LD_INT 0
98525: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98526: LD_INT 10500
98528: PPUSH
98529: CALL_OW 67
// solar_recharge_percent := 100 ;
98533: LD_ADDR_OWVAR 79
98537: PUSH
98538: LD_INT 100
98540: ST_TO_ADDR
// end ;
98541: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98542: LD_EXP 137
98546: PUSH
98547: LD_EXP 161
98551: AND
98552: IFFALSE 98791
98554: GO 98556
98556: DISABLE
98557: LD_INT 0
98559: PPUSH
98560: PPUSH
98561: PPUSH
// begin tmp := [ ] ;
98562: LD_ADDR_VAR 0 3
98566: PUSH
98567: EMPTY
98568: ST_TO_ADDR
// for i := 1 to 6 do
98569: LD_ADDR_VAR 0 1
98573: PUSH
98574: DOUBLE
98575: LD_INT 1
98577: DEC
98578: ST_TO_ADDR
98579: LD_INT 6
98581: PUSH
98582: FOR_TO
98583: IFFALSE 98688
// begin uc_nation := nation_nature ;
98585: LD_ADDR_OWVAR 21
98589: PUSH
98590: LD_INT 0
98592: ST_TO_ADDR
// uc_side := 0 ;
98593: LD_ADDR_OWVAR 20
98597: PUSH
98598: LD_INT 0
98600: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98601: LD_ADDR_OWVAR 29
98605: PUSH
98606: LD_INT 12
98608: PUSH
98609: LD_INT 12
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: ST_TO_ADDR
// hc_agressivity := 20 ;
98616: LD_ADDR_OWVAR 35
98620: PUSH
98621: LD_INT 20
98623: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98624: LD_ADDR_OWVAR 28
98628: PUSH
98629: LD_INT 17
98631: ST_TO_ADDR
// hc_gallery :=  ;
98632: LD_ADDR_OWVAR 33
98636: PUSH
98637: LD_STRING 
98639: ST_TO_ADDR
// hc_name :=  ;
98640: LD_ADDR_OWVAR 26
98644: PUSH
98645: LD_STRING 
98647: ST_TO_ADDR
// un := CreateHuman ;
98648: LD_ADDR_VAR 0 2
98652: PUSH
98653: CALL_OW 44
98657: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98658: LD_VAR 0 2
98662: PPUSH
98663: LD_INT 1
98665: PPUSH
98666: CALL_OW 51
// tmp := tmp ^ un ;
98670: LD_ADDR_VAR 0 3
98674: PUSH
98675: LD_VAR 0 3
98679: PUSH
98680: LD_VAR 0 2
98684: ADD
98685: ST_TO_ADDR
// end ;
98686: GO 98582
98688: POP
98689: POP
// repeat wait ( 0 0$1 ) ;
98690: LD_INT 35
98692: PPUSH
98693: CALL_OW 67
// for un in tmp do
98697: LD_ADDR_VAR 0 2
98701: PUSH
98702: LD_VAR 0 3
98706: PUSH
98707: FOR_IN
98708: IFFALSE 98782
// begin if IsDead ( un ) then
98710: LD_VAR 0 2
98714: PPUSH
98715: CALL_OW 301
98719: IFFALSE 98739
// begin tmp := tmp diff un ;
98721: LD_ADDR_VAR 0 3
98725: PUSH
98726: LD_VAR 0 3
98730: PUSH
98731: LD_VAR 0 2
98735: DIFF
98736: ST_TO_ADDR
// continue ;
98737: GO 98707
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98739: LD_VAR 0 2
98743: PPUSH
98744: LD_INT 3
98746: PUSH
98747: LD_INT 22
98749: PUSH
98750: LD_INT 0
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PUSH
98757: EMPTY
98758: LIST
98759: LIST
98760: PPUSH
98761: CALL_OW 69
98765: PPUSH
98766: LD_VAR 0 2
98770: PPUSH
98771: CALL_OW 74
98775: PPUSH
98776: CALL_OW 115
// end ;
98780: GO 98707
98782: POP
98783: POP
// until not tmp ;
98784: LD_VAR 0 3
98788: NOT
98789: IFFALSE 98690
// end ;
98791: PPOPN 3
98793: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98794: LD_EXP 137
98798: PUSH
98799: LD_EXP 162
98803: AND
98804: IFFALSE 98858
98806: GO 98808
98808: DISABLE
// begin ToLua ( displayTroll(); ) ;
98809: LD_STRING displayTroll();
98811: PPUSH
98812: CALL_OW 559
// wait ( 3 3$00 ) ;
98816: LD_INT 6300
98818: PPUSH
98819: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98823: LD_STRING hideTroll();
98825: PPUSH
98826: CALL_OW 559
// wait ( 1 1$00 ) ;
98830: LD_INT 2100
98832: PPUSH
98833: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98837: LD_STRING displayTroll();
98839: PPUSH
98840: CALL_OW 559
// wait ( 1 1$00 ) ;
98844: LD_INT 2100
98846: PPUSH
98847: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98851: LD_STRING hideTroll();
98853: PPUSH
98854: CALL_OW 559
// end ;
98858: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98859: LD_EXP 137
98863: PUSH
98864: LD_EXP 163
98868: AND
98869: IFFALSE 98932
98871: GO 98873
98873: DISABLE
98874: LD_INT 0
98876: PPUSH
// begin p := 0 ;
98877: LD_ADDR_VAR 0 1
98881: PUSH
98882: LD_INT 0
98884: ST_TO_ADDR
// repeat game_speed := 1 ;
98885: LD_ADDR_OWVAR 65
98889: PUSH
98890: LD_INT 1
98892: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98893: LD_INT 35
98895: PPUSH
98896: CALL_OW 67
// p := p + 1 ;
98900: LD_ADDR_VAR 0 1
98904: PUSH
98905: LD_VAR 0 1
98909: PUSH
98910: LD_INT 1
98912: PLUS
98913: ST_TO_ADDR
// until p >= 60 ;
98914: LD_VAR 0 1
98918: PUSH
98919: LD_INT 60
98921: GREATEREQUAL
98922: IFFALSE 98885
// game_speed := 4 ;
98924: LD_ADDR_OWVAR 65
98928: PUSH
98929: LD_INT 4
98931: ST_TO_ADDR
// end ;
98932: PPOPN 1
98934: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98935: LD_EXP 137
98939: PUSH
98940: LD_EXP 164
98944: AND
98945: IFFALSE 99091
98947: GO 98949
98949: DISABLE
98950: LD_INT 0
98952: PPUSH
98953: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98954: LD_ADDR_VAR 0 1
98958: PUSH
98959: LD_INT 22
98961: PUSH
98962: LD_OWVAR 2
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: LD_INT 2
98973: PUSH
98974: LD_INT 30
98976: PUSH
98977: LD_INT 0
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PUSH
98984: LD_INT 30
98986: PUSH
98987: LD_INT 1
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: LIST
98998: PUSH
98999: EMPTY
99000: LIST
99001: LIST
99002: PPUSH
99003: CALL_OW 69
99007: ST_TO_ADDR
// if not depot then
99008: LD_VAR 0 1
99012: NOT
99013: IFFALSE 99017
// exit ;
99015: GO 99091
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99017: LD_ADDR_VAR 0 2
99021: PUSH
99022: LD_VAR 0 1
99026: PUSH
99027: LD_INT 1
99029: PPUSH
99030: LD_VAR 0 1
99034: PPUSH
99035: CALL_OW 12
99039: ARRAY
99040: PPUSH
99041: CALL_OW 274
99045: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99046: LD_VAR 0 2
99050: PPUSH
99051: LD_INT 1
99053: PPUSH
99054: LD_INT 0
99056: PPUSH
99057: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99061: LD_VAR 0 2
99065: PPUSH
99066: LD_INT 2
99068: PPUSH
99069: LD_INT 0
99071: PPUSH
99072: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99076: LD_VAR 0 2
99080: PPUSH
99081: LD_INT 3
99083: PPUSH
99084: LD_INT 0
99086: PPUSH
99087: CALL_OW 277
// end ;
99091: PPOPN 2
99093: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99094: LD_EXP 137
99098: PUSH
99099: LD_EXP 165
99103: AND
99104: IFFALSE 99201
99106: GO 99108
99108: DISABLE
99109: LD_INT 0
99111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99112: LD_ADDR_VAR 0 1
99116: PUSH
99117: LD_INT 22
99119: PUSH
99120: LD_OWVAR 2
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 21
99131: PUSH
99132: LD_INT 1
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 3
99141: PUSH
99142: LD_INT 23
99144: PUSH
99145: LD_INT 0
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: EMPTY
99153: LIST
99154: LIST
99155: PUSH
99156: EMPTY
99157: LIST
99158: LIST
99159: LIST
99160: PPUSH
99161: CALL_OW 69
99165: ST_TO_ADDR
// if not tmp then
99166: LD_VAR 0 1
99170: NOT
99171: IFFALSE 99175
// exit ;
99173: GO 99201
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99175: LD_VAR 0 1
99179: PUSH
99180: LD_INT 1
99182: PPUSH
99183: LD_VAR 0 1
99187: PPUSH
99188: CALL_OW 12
99192: ARRAY
99193: PPUSH
99194: LD_INT 200
99196: PPUSH
99197: CALL_OW 234
// end ;
99201: PPOPN 1
99203: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99204: LD_EXP 137
99208: PUSH
99209: LD_EXP 166
99213: AND
99214: IFFALSE 99293
99216: GO 99218
99218: DISABLE
99219: LD_INT 0
99221: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99222: LD_ADDR_VAR 0 1
99226: PUSH
99227: LD_INT 22
99229: PUSH
99230: LD_OWVAR 2
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PUSH
99239: LD_INT 21
99241: PUSH
99242: LD_INT 2
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PPUSH
99253: CALL_OW 69
99257: ST_TO_ADDR
// if not tmp then
99258: LD_VAR 0 1
99262: NOT
99263: IFFALSE 99267
// exit ;
99265: GO 99293
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99267: LD_VAR 0 1
99271: PUSH
99272: LD_INT 1
99274: PPUSH
99275: LD_VAR 0 1
99279: PPUSH
99280: CALL_OW 12
99284: ARRAY
99285: PPUSH
99286: LD_INT 60
99288: PPUSH
99289: CALL_OW 234
// end ;
99293: PPOPN 1
99295: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99296: LD_EXP 137
99300: PUSH
99301: LD_EXP 167
99305: AND
99306: IFFALSE 99405
99308: GO 99310
99310: DISABLE
99311: LD_INT 0
99313: PPUSH
99314: PPUSH
// begin enable ;
99315: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99316: LD_ADDR_VAR 0 1
99320: PUSH
99321: LD_INT 22
99323: PUSH
99324: LD_OWVAR 2
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: LD_INT 61
99335: PUSH
99336: EMPTY
99337: LIST
99338: PUSH
99339: LD_INT 33
99341: PUSH
99342: LD_INT 2
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: ST_TO_ADDR
// if not tmp then
99359: LD_VAR 0 1
99363: NOT
99364: IFFALSE 99368
// exit ;
99366: GO 99405
// for i in tmp do
99368: LD_ADDR_VAR 0 2
99372: PUSH
99373: LD_VAR 0 1
99377: PUSH
99378: FOR_IN
99379: IFFALSE 99403
// if IsControledBy ( i ) then
99381: LD_VAR 0 2
99385: PPUSH
99386: CALL_OW 312
99390: IFFALSE 99401
// ComUnlink ( i ) ;
99392: LD_VAR 0 2
99396: PPUSH
99397: CALL_OW 136
99401: GO 99378
99403: POP
99404: POP
// end ;
99405: PPOPN 2
99407: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99408: LD_EXP 137
99412: PUSH
99413: LD_EXP 168
99417: AND
99418: IFFALSE 99558
99420: GO 99422
99422: DISABLE
99423: LD_INT 0
99425: PPUSH
99426: PPUSH
// begin ToLua ( displayPowell(); ) ;
99427: LD_STRING displayPowell();
99429: PPUSH
99430: CALL_OW 559
// uc_side := 0 ;
99434: LD_ADDR_OWVAR 20
99438: PUSH
99439: LD_INT 0
99441: ST_TO_ADDR
// uc_nation := 2 ;
99442: LD_ADDR_OWVAR 21
99446: PUSH
99447: LD_INT 2
99449: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99450: LD_ADDR_OWVAR 37
99454: PUSH
99455: LD_INT 14
99457: ST_TO_ADDR
// vc_engine := engine_siberite ;
99458: LD_ADDR_OWVAR 39
99462: PUSH
99463: LD_INT 3
99465: ST_TO_ADDR
// vc_control := control_apeman ;
99466: LD_ADDR_OWVAR 38
99470: PUSH
99471: LD_INT 5
99473: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99474: LD_ADDR_OWVAR 40
99478: PUSH
99479: LD_INT 29
99481: ST_TO_ADDR
// un := CreateVehicle ;
99482: LD_ADDR_VAR 0 2
99486: PUSH
99487: CALL_OW 45
99491: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99492: LD_VAR 0 2
99496: PPUSH
99497: LD_INT 1
99499: PPUSH
99500: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99504: LD_INT 35
99506: PPUSH
99507: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99511: LD_VAR 0 2
99515: PPUSH
99516: LD_INT 22
99518: PUSH
99519: LD_OWVAR 2
99523: PUSH
99524: EMPTY
99525: LIST
99526: LIST
99527: PPUSH
99528: CALL_OW 69
99532: PPUSH
99533: LD_VAR 0 2
99537: PPUSH
99538: CALL_OW 74
99542: PPUSH
99543: CALL_OW 115
// until IsDead ( un ) ;
99547: LD_VAR 0 2
99551: PPUSH
99552: CALL_OW 301
99556: IFFALSE 99504
// end ;
99558: PPOPN 2
99560: END
// every 0 0$1 trigger StreamModeActive and sStu do
99561: LD_EXP 137
99565: PUSH
99566: LD_EXP 176
99570: AND
99571: IFFALSE 99587
99573: GO 99575
99575: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99576: LD_STRING displayStucuk();
99578: PPUSH
99579: CALL_OW 559
// ResetFog ;
99583: CALL_OW 335
// end ;
99587: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99588: LD_EXP 137
99592: PUSH
99593: LD_EXP 169
99597: AND
99598: IFFALSE 99739
99600: GO 99602
99602: DISABLE
99603: LD_INT 0
99605: PPUSH
99606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99607: LD_ADDR_VAR 0 2
99611: PUSH
99612: LD_INT 22
99614: PUSH
99615: LD_OWVAR 2
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: PUSH
99624: LD_INT 21
99626: PUSH
99627: LD_INT 1
99629: PUSH
99630: EMPTY
99631: LIST
99632: LIST
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: PPUSH
99638: CALL_OW 69
99642: ST_TO_ADDR
// if not tmp then
99643: LD_VAR 0 2
99647: NOT
99648: IFFALSE 99652
// exit ;
99650: GO 99739
// un := tmp [ rand ( 1 , tmp ) ] ;
99652: LD_ADDR_VAR 0 1
99656: PUSH
99657: LD_VAR 0 2
99661: PUSH
99662: LD_INT 1
99664: PPUSH
99665: LD_VAR 0 2
99669: PPUSH
99670: CALL_OW 12
99674: ARRAY
99675: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99676: LD_VAR 0 1
99680: PPUSH
99681: LD_INT 0
99683: PPUSH
99684: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99688: LD_VAR 0 1
99692: PPUSH
99693: LD_OWVAR 3
99697: PUSH
99698: LD_VAR 0 1
99702: DIFF
99703: PPUSH
99704: LD_VAR 0 1
99708: PPUSH
99709: CALL_OW 74
99713: PPUSH
99714: CALL_OW 115
// wait ( 0 0$20 ) ;
99718: LD_INT 700
99720: PPUSH
99721: CALL_OW 67
// SetSide ( un , your_side ) ;
99725: LD_VAR 0 1
99729: PPUSH
99730: LD_OWVAR 2
99734: PPUSH
99735: CALL_OW 235
// end ;
99739: PPOPN 2
99741: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99742: LD_EXP 137
99746: PUSH
99747: LD_EXP 170
99751: AND
99752: IFFALSE 99858
99754: GO 99756
99756: DISABLE
99757: LD_INT 0
99759: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99760: LD_ADDR_VAR 0 1
99764: PUSH
99765: LD_INT 22
99767: PUSH
99768: LD_OWVAR 2
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 2
99779: PUSH
99780: LD_INT 30
99782: PUSH
99783: LD_INT 0
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: PUSH
99790: LD_INT 30
99792: PUSH
99793: LD_INT 1
99795: PUSH
99796: EMPTY
99797: LIST
99798: LIST
99799: PUSH
99800: EMPTY
99801: LIST
99802: LIST
99803: LIST
99804: PUSH
99805: EMPTY
99806: LIST
99807: LIST
99808: PPUSH
99809: CALL_OW 69
99813: ST_TO_ADDR
// if not depot then
99814: LD_VAR 0 1
99818: NOT
99819: IFFALSE 99823
// exit ;
99821: GO 99858
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99823: LD_VAR 0 1
99827: PUSH
99828: LD_INT 1
99830: ARRAY
99831: PPUSH
99832: CALL_OW 250
99836: PPUSH
99837: LD_VAR 0 1
99841: PUSH
99842: LD_INT 1
99844: ARRAY
99845: PPUSH
99846: CALL_OW 251
99850: PPUSH
99851: LD_INT 70
99853: PPUSH
99854: CALL_OW 495
// end ;
99858: PPOPN 1
99860: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99861: LD_EXP 137
99865: PUSH
99866: LD_EXP 171
99870: AND
99871: IFFALSE 100082
99873: GO 99875
99875: DISABLE
99876: LD_INT 0
99878: PPUSH
99879: PPUSH
99880: PPUSH
99881: PPUSH
99882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99883: LD_ADDR_VAR 0 5
99887: PUSH
99888: LD_INT 22
99890: PUSH
99891: LD_OWVAR 2
99895: PUSH
99896: EMPTY
99897: LIST
99898: LIST
99899: PUSH
99900: LD_INT 21
99902: PUSH
99903: LD_INT 1
99905: PUSH
99906: EMPTY
99907: LIST
99908: LIST
99909: PUSH
99910: EMPTY
99911: LIST
99912: LIST
99913: PPUSH
99914: CALL_OW 69
99918: ST_TO_ADDR
// if not tmp then
99919: LD_VAR 0 5
99923: NOT
99924: IFFALSE 99928
// exit ;
99926: GO 100082
// for i in tmp do
99928: LD_ADDR_VAR 0 1
99932: PUSH
99933: LD_VAR 0 5
99937: PUSH
99938: FOR_IN
99939: IFFALSE 100080
// begin d := rand ( 0 , 5 ) ;
99941: LD_ADDR_VAR 0 4
99945: PUSH
99946: LD_INT 0
99948: PPUSH
99949: LD_INT 5
99951: PPUSH
99952: CALL_OW 12
99956: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99957: LD_ADDR_VAR 0 2
99961: PUSH
99962: LD_VAR 0 1
99966: PPUSH
99967: CALL_OW 250
99971: PPUSH
99972: LD_VAR 0 4
99976: PPUSH
99977: LD_INT 3
99979: PPUSH
99980: LD_INT 12
99982: PPUSH
99983: CALL_OW 12
99987: PPUSH
99988: CALL_OW 272
99992: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99993: LD_ADDR_VAR 0 3
99997: PUSH
99998: LD_VAR 0 1
100002: PPUSH
100003: CALL_OW 251
100007: PPUSH
100008: LD_VAR 0 4
100012: PPUSH
100013: LD_INT 3
100015: PPUSH
100016: LD_INT 12
100018: PPUSH
100019: CALL_OW 12
100023: PPUSH
100024: CALL_OW 273
100028: ST_TO_ADDR
// if ValidHex ( x , y ) then
100029: LD_VAR 0 2
100033: PPUSH
100034: LD_VAR 0 3
100038: PPUSH
100039: CALL_OW 488
100043: IFFALSE 100078
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100045: LD_VAR 0 1
100049: PPUSH
100050: LD_VAR 0 2
100054: PPUSH
100055: LD_VAR 0 3
100059: PPUSH
100060: LD_INT 3
100062: PPUSH
100063: LD_INT 6
100065: PPUSH
100066: CALL_OW 12
100070: PPUSH
100071: LD_INT 1
100073: PPUSH
100074: CALL_OW 483
// end ;
100078: GO 99938
100080: POP
100081: POP
// end ;
100082: PPOPN 5
100084: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100085: LD_EXP 137
100089: PUSH
100090: LD_EXP 172
100094: AND
100095: IFFALSE 100189
100097: GO 100099
100099: DISABLE
100100: LD_INT 0
100102: PPUSH
100103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100104: LD_ADDR_VAR 0 2
100108: PUSH
100109: LD_INT 22
100111: PUSH
100112: LD_OWVAR 2
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: PUSH
100121: LD_INT 32
100123: PUSH
100124: LD_INT 1
100126: PUSH
100127: EMPTY
100128: LIST
100129: LIST
100130: PUSH
100131: LD_INT 21
100133: PUSH
100134: LD_INT 2
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: LIST
100145: PPUSH
100146: CALL_OW 69
100150: ST_TO_ADDR
// if not tmp then
100151: LD_VAR 0 2
100155: NOT
100156: IFFALSE 100160
// exit ;
100158: GO 100189
// for i in tmp do
100160: LD_ADDR_VAR 0 1
100164: PUSH
100165: LD_VAR 0 2
100169: PUSH
100170: FOR_IN
100171: IFFALSE 100187
// SetFuel ( i , 0 ) ;
100173: LD_VAR 0 1
100177: PPUSH
100178: LD_INT 0
100180: PPUSH
100181: CALL_OW 240
100185: GO 100170
100187: POP
100188: POP
// end ;
100189: PPOPN 2
100191: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100192: LD_EXP 137
100196: PUSH
100197: LD_EXP 173
100201: AND
100202: IFFALSE 100268
100204: GO 100206
100206: DISABLE
100207: LD_INT 0
100209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100210: LD_ADDR_VAR 0 1
100214: PUSH
100215: LD_INT 22
100217: PUSH
100218: LD_OWVAR 2
100222: PUSH
100223: EMPTY
100224: LIST
100225: LIST
100226: PUSH
100227: LD_INT 30
100229: PUSH
100230: LD_INT 29
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PPUSH
100241: CALL_OW 69
100245: ST_TO_ADDR
// if not tmp then
100246: LD_VAR 0 1
100250: NOT
100251: IFFALSE 100255
// exit ;
100253: GO 100268
// DestroyUnit ( tmp [ 1 ] ) ;
100255: LD_VAR 0 1
100259: PUSH
100260: LD_INT 1
100262: ARRAY
100263: PPUSH
100264: CALL_OW 65
// end ;
100268: PPOPN 1
100270: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100271: LD_EXP 137
100275: PUSH
100276: LD_EXP 175
100280: AND
100281: IFFALSE 100410
100283: GO 100285
100285: DISABLE
100286: LD_INT 0
100288: PPUSH
// begin uc_side := 0 ;
100289: LD_ADDR_OWVAR 20
100293: PUSH
100294: LD_INT 0
100296: ST_TO_ADDR
// uc_nation := nation_arabian ;
100297: LD_ADDR_OWVAR 21
100301: PUSH
100302: LD_INT 2
100304: ST_TO_ADDR
// hc_gallery :=  ;
100305: LD_ADDR_OWVAR 33
100309: PUSH
100310: LD_STRING 
100312: ST_TO_ADDR
// hc_name :=  ;
100313: LD_ADDR_OWVAR 26
100317: PUSH
100318: LD_STRING 
100320: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100321: LD_INT 1
100323: PPUSH
100324: LD_INT 11
100326: PPUSH
100327: LD_INT 10
100329: PPUSH
100330: CALL_OW 380
// un := CreateHuman ;
100334: LD_ADDR_VAR 0 1
100338: PUSH
100339: CALL_OW 44
100343: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100344: LD_VAR 0 1
100348: PPUSH
100349: LD_INT 1
100351: PPUSH
100352: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100356: LD_INT 35
100358: PPUSH
100359: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100363: LD_VAR 0 1
100367: PPUSH
100368: LD_INT 22
100370: PUSH
100371: LD_OWVAR 2
100375: PUSH
100376: EMPTY
100377: LIST
100378: LIST
100379: PPUSH
100380: CALL_OW 69
100384: PPUSH
100385: LD_VAR 0 1
100389: PPUSH
100390: CALL_OW 74
100394: PPUSH
100395: CALL_OW 115
// until IsDead ( un ) ;
100399: LD_VAR 0 1
100403: PPUSH
100404: CALL_OW 301
100408: IFFALSE 100356
// end ;
100410: PPOPN 1
100412: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100413: LD_EXP 137
100417: PUSH
100418: LD_EXP 177
100422: AND
100423: IFFALSE 100435
100425: GO 100427
100427: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100428: LD_STRING earthquake(getX(game), 0, 32)
100430: PPUSH
100431: CALL_OW 559
100435: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100436: LD_EXP 137
100440: PUSH
100441: LD_EXP 178
100445: AND
100446: IFFALSE 100537
100448: GO 100450
100450: DISABLE
100451: LD_INT 0
100453: PPUSH
// begin enable ;
100454: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100455: LD_ADDR_VAR 0 1
100459: PUSH
100460: LD_INT 22
100462: PUSH
100463: LD_OWVAR 2
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: PUSH
100472: LD_INT 21
100474: PUSH
100475: LD_INT 2
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: LD_INT 33
100484: PUSH
100485: LD_INT 3
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: PUSH
100492: EMPTY
100493: LIST
100494: LIST
100495: LIST
100496: PPUSH
100497: CALL_OW 69
100501: ST_TO_ADDR
// if not tmp then
100502: LD_VAR 0 1
100506: NOT
100507: IFFALSE 100511
// exit ;
100509: GO 100537
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100511: LD_VAR 0 1
100515: PUSH
100516: LD_INT 1
100518: PPUSH
100519: LD_VAR 0 1
100523: PPUSH
100524: CALL_OW 12
100528: ARRAY
100529: PPUSH
100530: LD_INT 1
100532: PPUSH
100533: CALL_OW 234
// end ;
100537: PPOPN 1
100539: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100540: LD_EXP 137
100544: PUSH
100545: LD_EXP 179
100549: AND
100550: IFFALSE 100691
100552: GO 100554
100554: DISABLE
100555: LD_INT 0
100557: PPUSH
100558: PPUSH
100559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100560: LD_ADDR_VAR 0 3
100564: PUSH
100565: LD_INT 22
100567: PUSH
100568: LD_OWVAR 2
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: PUSH
100577: LD_INT 25
100579: PUSH
100580: LD_INT 1
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: PPUSH
100591: CALL_OW 69
100595: ST_TO_ADDR
// if not tmp then
100596: LD_VAR 0 3
100600: NOT
100601: IFFALSE 100605
// exit ;
100603: GO 100691
// un := tmp [ rand ( 1 , tmp ) ] ;
100605: LD_ADDR_VAR 0 2
100609: PUSH
100610: LD_VAR 0 3
100614: PUSH
100615: LD_INT 1
100617: PPUSH
100618: LD_VAR 0 3
100622: PPUSH
100623: CALL_OW 12
100627: ARRAY
100628: ST_TO_ADDR
// if Crawls ( un ) then
100629: LD_VAR 0 2
100633: PPUSH
100634: CALL_OW 318
100638: IFFALSE 100649
// ComWalk ( un ) ;
100640: LD_VAR 0 2
100644: PPUSH
100645: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100649: LD_VAR 0 2
100653: PPUSH
100654: LD_INT 9
100656: PPUSH
100657: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100661: LD_INT 28
100663: PPUSH
100664: LD_OWVAR 2
100668: PPUSH
100669: LD_INT 2
100671: PPUSH
100672: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100676: LD_INT 29
100678: PPUSH
100679: LD_OWVAR 2
100683: PPUSH
100684: LD_INT 2
100686: PPUSH
100687: CALL_OW 322
// end ;
100691: PPOPN 3
100693: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100694: LD_EXP 137
100698: PUSH
100699: LD_EXP 180
100703: AND
100704: IFFALSE 100815
100706: GO 100708
100708: DISABLE
100709: LD_INT 0
100711: PPUSH
100712: PPUSH
100713: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100714: LD_ADDR_VAR 0 3
100718: PUSH
100719: LD_INT 22
100721: PUSH
100722: LD_OWVAR 2
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 25
100733: PUSH
100734: LD_INT 1
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: EMPTY
100742: LIST
100743: LIST
100744: PPUSH
100745: CALL_OW 69
100749: ST_TO_ADDR
// if not tmp then
100750: LD_VAR 0 3
100754: NOT
100755: IFFALSE 100759
// exit ;
100757: GO 100815
// un := tmp [ rand ( 1 , tmp ) ] ;
100759: LD_ADDR_VAR 0 2
100763: PUSH
100764: LD_VAR 0 3
100768: PUSH
100769: LD_INT 1
100771: PPUSH
100772: LD_VAR 0 3
100776: PPUSH
100777: CALL_OW 12
100781: ARRAY
100782: ST_TO_ADDR
// if Crawls ( un ) then
100783: LD_VAR 0 2
100787: PPUSH
100788: CALL_OW 318
100792: IFFALSE 100803
// ComWalk ( un ) ;
100794: LD_VAR 0 2
100798: PPUSH
100799: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100803: LD_VAR 0 2
100807: PPUSH
100808: LD_INT 8
100810: PPUSH
100811: CALL_OW 336
// end ;
100815: PPOPN 3
100817: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100818: LD_EXP 137
100822: PUSH
100823: LD_EXP 181
100827: AND
100828: IFFALSE 100972
100830: GO 100832
100832: DISABLE
100833: LD_INT 0
100835: PPUSH
100836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100837: LD_ADDR_VAR 0 2
100841: PUSH
100842: LD_INT 22
100844: PUSH
100845: LD_OWVAR 2
100849: PUSH
100850: EMPTY
100851: LIST
100852: LIST
100853: PUSH
100854: LD_INT 21
100856: PUSH
100857: LD_INT 2
100859: PUSH
100860: EMPTY
100861: LIST
100862: LIST
100863: PUSH
100864: LD_INT 2
100866: PUSH
100867: LD_INT 34
100869: PUSH
100870: LD_INT 12
100872: PUSH
100873: EMPTY
100874: LIST
100875: LIST
100876: PUSH
100877: LD_INT 34
100879: PUSH
100880: LD_INT 51
100882: PUSH
100883: EMPTY
100884: LIST
100885: LIST
100886: PUSH
100887: LD_INT 34
100889: PUSH
100890: LD_INT 32
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: LIST
100901: LIST
100902: PUSH
100903: EMPTY
100904: LIST
100905: LIST
100906: LIST
100907: PPUSH
100908: CALL_OW 69
100912: ST_TO_ADDR
// if not tmp then
100913: LD_VAR 0 2
100917: NOT
100918: IFFALSE 100922
// exit ;
100920: GO 100972
// for i in tmp do
100922: LD_ADDR_VAR 0 1
100926: PUSH
100927: LD_VAR 0 2
100931: PUSH
100932: FOR_IN
100933: IFFALSE 100970
// if GetCargo ( i , mat_artifact ) = 0 then
100935: LD_VAR 0 1
100939: PPUSH
100940: LD_INT 4
100942: PPUSH
100943: CALL_OW 289
100947: PUSH
100948: LD_INT 0
100950: EQUAL
100951: IFFALSE 100968
// SetCargo ( i , mat_siberit , 100 ) ;
100953: LD_VAR 0 1
100957: PPUSH
100958: LD_INT 3
100960: PPUSH
100961: LD_INT 100
100963: PPUSH
100964: CALL_OW 290
100968: GO 100932
100970: POP
100971: POP
// end ;
100972: PPOPN 2
100974: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100975: LD_EXP 137
100979: PUSH
100980: LD_EXP 182
100984: AND
100985: IFFALSE 101168
100987: GO 100989
100989: DISABLE
100990: LD_INT 0
100992: PPUSH
100993: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100994: LD_ADDR_VAR 0 2
100998: PUSH
100999: LD_INT 22
101001: PUSH
101002: LD_OWVAR 2
101006: PUSH
101007: EMPTY
101008: LIST
101009: LIST
101010: PPUSH
101011: CALL_OW 69
101015: ST_TO_ADDR
// if not tmp then
101016: LD_VAR 0 2
101020: NOT
101021: IFFALSE 101025
// exit ;
101023: GO 101168
// for i := 1 to 2 do
101025: LD_ADDR_VAR 0 1
101029: PUSH
101030: DOUBLE
101031: LD_INT 1
101033: DEC
101034: ST_TO_ADDR
101035: LD_INT 2
101037: PUSH
101038: FOR_TO
101039: IFFALSE 101166
// begin uc_side := your_side ;
101041: LD_ADDR_OWVAR 20
101045: PUSH
101046: LD_OWVAR 2
101050: ST_TO_ADDR
// uc_nation := nation_american ;
101051: LD_ADDR_OWVAR 21
101055: PUSH
101056: LD_INT 1
101058: ST_TO_ADDR
// vc_chassis := us_morphling ;
101059: LD_ADDR_OWVAR 37
101063: PUSH
101064: LD_INT 5
101066: ST_TO_ADDR
// vc_engine := engine_siberite ;
101067: LD_ADDR_OWVAR 39
101071: PUSH
101072: LD_INT 3
101074: ST_TO_ADDR
// vc_control := control_computer ;
101075: LD_ADDR_OWVAR 38
101079: PUSH
101080: LD_INT 3
101082: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101083: LD_ADDR_OWVAR 40
101087: PUSH
101088: LD_INT 10
101090: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101091: LD_VAR 0 2
101095: PUSH
101096: LD_INT 1
101098: ARRAY
101099: PPUSH
101100: CALL_OW 310
101104: NOT
101105: IFFALSE 101152
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101107: CALL_OW 45
101111: PPUSH
101112: LD_VAR 0 2
101116: PUSH
101117: LD_INT 1
101119: ARRAY
101120: PPUSH
101121: CALL_OW 250
101125: PPUSH
101126: LD_VAR 0 2
101130: PUSH
101131: LD_INT 1
101133: ARRAY
101134: PPUSH
101135: CALL_OW 251
101139: PPUSH
101140: LD_INT 12
101142: PPUSH
101143: LD_INT 1
101145: PPUSH
101146: CALL_OW 50
101150: GO 101164
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101152: CALL_OW 45
101156: PPUSH
101157: LD_INT 1
101159: PPUSH
101160: CALL_OW 51
// end ;
101164: GO 101038
101166: POP
101167: POP
// end ;
101168: PPOPN 2
101170: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101171: LD_EXP 137
101175: PUSH
101176: LD_EXP 183
101180: AND
101181: IFFALSE 101403
101183: GO 101185
101185: DISABLE
101186: LD_INT 0
101188: PPUSH
101189: PPUSH
101190: PPUSH
101191: PPUSH
101192: PPUSH
101193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101194: LD_ADDR_VAR 0 6
101198: PUSH
101199: LD_INT 22
101201: PUSH
101202: LD_OWVAR 2
101206: PUSH
101207: EMPTY
101208: LIST
101209: LIST
101210: PUSH
101211: LD_INT 21
101213: PUSH
101214: LD_INT 1
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PUSH
101221: LD_INT 3
101223: PUSH
101224: LD_INT 23
101226: PUSH
101227: LD_INT 0
101229: PUSH
101230: EMPTY
101231: LIST
101232: LIST
101233: PUSH
101234: EMPTY
101235: LIST
101236: LIST
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: LIST
101242: PPUSH
101243: CALL_OW 69
101247: ST_TO_ADDR
// if not tmp then
101248: LD_VAR 0 6
101252: NOT
101253: IFFALSE 101257
// exit ;
101255: GO 101403
// s1 := rand ( 1 , 4 ) ;
101257: LD_ADDR_VAR 0 2
101261: PUSH
101262: LD_INT 1
101264: PPUSH
101265: LD_INT 4
101267: PPUSH
101268: CALL_OW 12
101272: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101273: LD_ADDR_VAR 0 4
101277: PUSH
101278: LD_VAR 0 6
101282: PUSH
101283: LD_INT 1
101285: ARRAY
101286: PPUSH
101287: LD_VAR 0 2
101291: PPUSH
101292: CALL_OW 259
101296: ST_TO_ADDR
// if s1 = 1 then
101297: LD_VAR 0 2
101301: PUSH
101302: LD_INT 1
101304: EQUAL
101305: IFFALSE 101325
// s2 := rand ( 2 , 4 ) else
101307: LD_ADDR_VAR 0 3
101311: PUSH
101312: LD_INT 2
101314: PPUSH
101315: LD_INT 4
101317: PPUSH
101318: CALL_OW 12
101322: ST_TO_ADDR
101323: GO 101333
// s2 := 1 ;
101325: LD_ADDR_VAR 0 3
101329: PUSH
101330: LD_INT 1
101332: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101333: LD_ADDR_VAR 0 5
101337: PUSH
101338: LD_VAR 0 6
101342: PUSH
101343: LD_INT 1
101345: ARRAY
101346: PPUSH
101347: LD_VAR 0 3
101351: PPUSH
101352: CALL_OW 259
101356: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101357: LD_VAR 0 6
101361: PUSH
101362: LD_INT 1
101364: ARRAY
101365: PPUSH
101366: LD_VAR 0 2
101370: PPUSH
101371: LD_VAR 0 5
101375: PPUSH
101376: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101380: LD_VAR 0 6
101384: PUSH
101385: LD_INT 1
101387: ARRAY
101388: PPUSH
101389: LD_VAR 0 3
101393: PPUSH
101394: LD_VAR 0 4
101398: PPUSH
101399: CALL_OW 237
// end ;
101403: PPOPN 6
101405: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101406: LD_EXP 137
101410: PUSH
101411: LD_EXP 184
101415: AND
101416: IFFALSE 101495
101418: GO 101420
101420: DISABLE
101421: LD_INT 0
101423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101424: LD_ADDR_VAR 0 1
101428: PUSH
101429: LD_INT 22
101431: PUSH
101432: LD_OWVAR 2
101436: PUSH
101437: EMPTY
101438: LIST
101439: LIST
101440: PUSH
101441: LD_INT 30
101443: PUSH
101444: LD_INT 3
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: PUSH
101451: EMPTY
101452: LIST
101453: LIST
101454: PPUSH
101455: CALL_OW 69
101459: ST_TO_ADDR
// if not tmp then
101460: LD_VAR 0 1
101464: NOT
101465: IFFALSE 101469
// exit ;
101467: GO 101495
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101469: LD_VAR 0 1
101473: PUSH
101474: LD_INT 1
101476: PPUSH
101477: LD_VAR 0 1
101481: PPUSH
101482: CALL_OW 12
101486: ARRAY
101487: PPUSH
101488: LD_INT 1
101490: PPUSH
101491: CALL_OW 234
// end ;
101495: PPOPN 1
101497: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101498: LD_EXP 137
101502: PUSH
101503: LD_EXP 185
101507: AND
101508: IFFALSE 101620
101510: GO 101512
101512: DISABLE
101513: LD_INT 0
101515: PPUSH
101516: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101517: LD_ADDR_VAR 0 2
101521: PUSH
101522: LD_INT 22
101524: PUSH
101525: LD_OWVAR 2
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PUSH
101534: LD_INT 2
101536: PUSH
101537: LD_INT 30
101539: PUSH
101540: LD_INT 27
101542: PUSH
101543: EMPTY
101544: LIST
101545: LIST
101546: PUSH
101547: LD_INT 30
101549: PUSH
101550: LD_INT 26
101552: PUSH
101553: EMPTY
101554: LIST
101555: LIST
101556: PUSH
101557: LD_INT 30
101559: PUSH
101560: LD_INT 28
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: PUSH
101573: EMPTY
101574: LIST
101575: LIST
101576: PPUSH
101577: CALL_OW 69
101581: ST_TO_ADDR
// if not tmp then
101582: LD_VAR 0 2
101586: NOT
101587: IFFALSE 101591
// exit ;
101589: GO 101620
// for i in tmp do
101591: LD_ADDR_VAR 0 1
101595: PUSH
101596: LD_VAR 0 2
101600: PUSH
101601: FOR_IN
101602: IFFALSE 101618
// SetLives ( i , 1 ) ;
101604: LD_VAR 0 1
101608: PPUSH
101609: LD_INT 1
101611: PPUSH
101612: CALL_OW 234
101616: GO 101601
101618: POP
101619: POP
// end ;
101620: PPOPN 2
101622: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101623: LD_EXP 137
101627: PUSH
101628: LD_EXP 186
101632: AND
101633: IFFALSE 101920
101635: GO 101637
101637: DISABLE
101638: LD_INT 0
101640: PPUSH
101641: PPUSH
101642: PPUSH
// begin i := rand ( 1 , 7 ) ;
101643: LD_ADDR_VAR 0 1
101647: PUSH
101648: LD_INT 1
101650: PPUSH
101651: LD_INT 7
101653: PPUSH
101654: CALL_OW 12
101658: ST_TO_ADDR
// case i of 1 :
101659: LD_VAR 0 1
101663: PUSH
101664: LD_INT 1
101666: DOUBLE
101667: EQUAL
101668: IFTRUE 101672
101670: GO 101682
101672: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101673: LD_STRING earthquake(getX(game), 0, 32)
101675: PPUSH
101676: CALL_OW 559
101680: GO 101920
101682: LD_INT 2
101684: DOUBLE
101685: EQUAL
101686: IFTRUE 101690
101688: GO 101704
101690: POP
// begin ToLua ( displayStucuk(); ) ;
101691: LD_STRING displayStucuk();
101693: PPUSH
101694: CALL_OW 559
// ResetFog ;
101698: CALL_OW 335
// end ; 3 :
101702: GO 101920
101704: LD_INT 3
101706: DOUBLE
101707: EQUAL
101708: IFTRUE 101712
101710: GO 101816
101712: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101713: LD_ADDR_VAR 0 2
101717: PUSH
101718: LD_INT 22
101720: PUSH
101721: LD_OWVAR 2
101725: PUSH
101726: EMPTY
101727: LIST
101728: LIST
101729: PUSH
101730: LD_INT 25
101732: PUSH
101733: LD_INT 1
101735: PUSH
101736: EMPTY
101737: LIST
101738: LIST
101739: PUSH
101740: EMPTY
101741: LIST
101742: LIST
101743: PPUSH
101744: CALL_OW 69
101748: ST_TO_ADDR
// if not tmp then
101749: LD_VAR 0 2
101753: NOT
101754: IFFALSE 101758
// exit ;
101756: GO 101920
// un := tmp [ rand ( 1 , tmp ) ] ;
101758: LD_ADDR_VAR 0 3
101762: PUSH
101763: LD_VAR 0 2
101767: PUSH
101768: LD_INT 1
101770: PPUSH
101771: LD_VAR 0 2
101775: PPUSH
101776: CALL_OW 12
101780: ARRAY
101781: ST_TO_ADDR
// if Crawls ( un ) then
101782: LD_VAR 0 3
101786: PPUSH
101787: CALL_OW 318
101791: IFFALSE 101802
// ComWalk ( un ) ;
101793: LD_VAR 0 3
101797: PPUSH
101798: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101802: LD_VAR 0 3
101806: PPUSH
101807: LD_INT 8
101809: PPUSH
101810: CALL_OW 336
// end ; 4 :
101814: GO 101920
101816: LD_INT 4
101818: DOUBLE
101819: EQUAL
101820: IFTRUE 101824
101822: GO 101898
101824: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101825: LD_ADDR_VAR 0 2
101829: PUSH
101830: LD_INT 22
101832: PUSH
101833: LD_OWVAR 2
101837: PUSH
101838: EMPTY
101839: LIST
101840: LIST
101841: PUSH
101842: LD_INT 30
101844: PUSH
101845: LD_INT 29
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: PPUSH
101856: CALL_OW 69
101860: ST_TO_ADDR
// if not tmp then
101861: LD_VAR 0 2
101865: NOT
101866: IFFALSE 101870
// exit ;
101868: GO 101920
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101870: LD_VAR 0 2
101874: PUSH
101875: LD_INT 1
101877: ARRAY
101878: PPUSH
101879: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101883: LD_VAR 0 2
101887: PUSH
101888: LD_INT 1
101890: ARRAY
101891: PPUSH
101892: CALL_OW 65
// end ; 5 .. 7 :
101896: GO 101920
101898: LD_INT 5
101900: DOUBLE
101901: GREATEREQUAL
101902: IFFALSE 101910
101904: LD_INT 7
101906: DOUBLE
101907: LESSEQUAL
101908: IFTRUE 101912
101910: GO 101919
101912: POP
// StreamSibBomb ; end ;
101913: CALL 98157 0 0
101917: GO 101920
101919: POP
// end ;
101920: PPOPN 3
101922: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101923: LD_EXP 137
101927: PUSH
101928: LD_EXP 187
101932: AND
101933: IFFALSE 102089
101935: GO 101937
101937: DISABLE
101938: LD_INT 0
101940: PPUSH
101941: PPUSH
101942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101943: LD_ADDR_VAR 0 2
101947: PUSH
101948: LD_INT 81
101950: PUSH
101951: LD_OWVAR 2
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PUSH
101960: LD_INT 2
101962: PUSH
101963: LD_INT 21
101965: PUSH
101966: LD_INT 1
101968: PUSH
101969: EMPTY
101970: LIST
101971: LIST
101972: PUSH
101973: LD_INT 21
101975: PUSH
101976: LD_INT 2
101978: PUSH
101979: EMPTY
101980: LIST
101981: LIST
101982: PUSH
101983: EMPTY
101984: LIST
101985: LIST
101986: LIST
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PPUSH
101992: CALL_OW 69
101996: ST_TO_ADDR
// if not tmp then
101997: LD_VAR 0 2
102001: NOT
102002: IFFALSE 102006
// exit ;
102004: GO 102089
// p := 0 ;
102006: LD_ADDR_VAR 0 3
102010: PUSH
102011: LD_INT 0
102013: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102014: LD_INT 35
102016: PPUSH
102017: CALL_OW 67
// p := p + 1 ;
102021: LD_ADDR_VAR 0 3
102025: PUSH
102026: LD_VAR 0 3
102030: PUSH
102031: LD_INT 1
102033: PLUS
102034: ST_TO_ADDR
// for i in tmp do
102035: LD_ADDR_VAR 0 1
102039: PUSH
102040: LD_VAR 0 2
102044: PUSH
102045: FOR_IN
102046: IFFALSE 102077
// if GetLives ( i ) < 1000 then
102048: LD_VAR 0 1
102052: PPUSH
102053: CALL_OW 256
102057: PUSH
102058: LD_INT 1000
102060: LESS
102061: IFFALSE 102075
// SetLives ( i , 1000 ) ;
102063: LD_VAR 0 1
102067: PPUSH
102068: LD_INT 1000
102070: PPUSH
102071: CALL_OW 234
102075: GO 102045
102077: POP
102078: POP
// until p > 20 ;
102079: LD_VAR 0 3
102083: PUSH
102084: LD_INT 20
102086: GREATER
102087: IFFALSE 102014
// end ;
102089: PPOPN 3
102091: END
// every 0 0$1 trigger StreamModeActive and sTime do
102092: LD_EXP 137
102096: PUSH
102097: LD_EXP 188
102101: AND
102102: IFFALSE 102137
102104: GO 102106
102106: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102107: LD_INT 28
102109: PPUSH
102110: LD_OWVAR 2
102114: PPUSH
102115: LD_INT 2
102117: PPUSH
102118: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102122: LD_INT 30
102124: PPUSH
102125: LD_OWVAR 2
102129: PPUSH
102130: LD_INT 2
102132: PPUSH
102133: CALL_OW 322
// end ;
102137: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102138: LD_EXP 137
102142: PUSH
102143: LD_EXP 189
102147: AND
102148: IFFALSE 102269
102150: GO 102152
102152: DISABLE
102153: LD_INT 0
102155: PPUSH
102156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102157: LD_ADDR_VAR 0 2
102161: PUSH
102162: LD_INT 22
102164: PUSH
102165: LD_OWVAR 2
102169: PUSH
102170: EMPTY
102171: LIST
102172: LIST
102173: PUSH
102174: LD_INT 21
102176: PUSH
102177: LD_INT 1
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: PUSH
102184: LD_INT 3
102186: PUSH
102187: LD_INT 23
102189: PUSH
102190: LD_INT 0
102192: PUSH
102193: EMPTY
102194: LIST
102195: LIST
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: LIST
102205: PPUSH
102206: CALL_OW 69
102210: ST_TO_ADDR
// if not tmp then
102211: LD_VAR 0 2
102215: NOT
102216: IFFALSE 102220
// exit ;
102218: GO 102269
// for i in tmp do
102220: LD_ADDR_VAR 0 1
102224: PUSH
102225: LD_VAR 0 2
102229: PUSH
102230: FOR_IN
102231: IFFALSE 102267
// begin if Crawls ( i ) then
102233: LD_VAR 0 1
102237: PPUSH
102238: CALL_OW 318
102242: IFFALSE 102253
// ComWalk ( i ) ;
102244: LD_VAR 0 1
102248: PPUSH
102249: CALL_OW 138
// SetClass ( i , 2 ) ;
102253: LD_VAR 0 1
102257: PPUSH
102258: LD_INT 2
102260: PPUSH
102261: CALL_OW 336
// end ;
102265: GO 102230
102267: POP
102268: POP
// end ;
102269: PPOPN 2
102271: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102272: LD_EXP 137
102276: PUSH
102277: LD_EXP 190
102281: AND
102282: IFFALSE 102570
102284: GO 102286
102286: DISABLE
102287: LD_INT 0
102289: PPUSH
102290: PPUSH
102291: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102292: LD_OWVAR 2
102296: PPUSH
102297: LD_INT 9
102299: PPUSH
102300: LD_INT 1
102302: PPUSH
102303: LD_INT 1
102305: PPUSH
102306: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102310: LD_INT 9
102312: PPUSH
102313: LD_OWVAR 2
102317: PPUSH
102318: CALL_OW 343
// uc_side := 9 ;
102322: LD_ADDR_OWVAR 20
102326: PUSH
102327: LD_INT 9
102329: ST_TO_ADDR
// uc_nation := 2 ;
102330: LD_ADDR_OWVAR 21
102334: PUSH
102335: LD_INT 2
102337: ST_TO_ADDR
// hc_name := Dark Warrior ;
102338: LD_ADDR_OWVAR 26
102342: PUSH
102343: LD_STRING Dark Warrior
102345: ST_TO_ADDR
// hc_gallery :=  ;
102346: LD_ADDR_OWVAR 33
102350: PUSH
102351: LD_STRING 
102353: ST_TO_ADDR
// hc_noskilllimit := true ;
102354: LD_ADDR_OWVAR 76
102358: PUSH
102359: LD_INT 1
102361: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102362: LD_ADDR_OWVAR 31
102366: PUSH
102367: LD_INT 30
102369: PUSH
102370: LD_INT 30
102372: PUSH
102373: LD_INT 30
102375: PUSH
102376: LD_INT 30
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: LIST
102383: LIST
102384: ST_TO_ADDR
// un := CreateHuman ;
102385: LD_ADDR_VAR 0 3
102389: PUSH
102390: CALL_OW 44
102394: ST_TO_ADDR
// hc_noskilllimit := false ;
102395: LD_ADDR_OWVAR 76
102399: PUSH
102400: LD_INT 0
102402: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102403: LD_VAR 0 3
102407: PPUSH
102408: LD_INT 1
102410: PPUSH
102411: CALL_OW 51
// ToLua ( playRanger() ) ;
102415: LD_STRING playRanger()
102417: PPUSH
102418: CALL_OW 559
// p := 0 ;
102422: LD_ADDR_VAR 0 2
102426: PUSH
102427: LD_INT 0
102429: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102430: LD_INT 35
102432: PPUSH
102433: CALL_OW 67
// p := p + 1 ;
102437: LD_ADDR_VAR 0 2
102441: PUSH
102442: LD_VAR 0 2
102446: PUSH
102447: LD_INT 1
102449: PLUS
102450: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102451: LD_VAR 0 3
102455: PPUSH
102456: CALL_OW 256
102460: PUSH
102461: LD_INT 1000
102463: LESS
102464: IFFALSE 102478
// SetLives ( un , 1000 ) ;
102466: LD_VAR 0 3
102470: PPUSH
102471: LD_INT 1000
102473: PPUSH
102474: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102478: LD_VAR 0 3
102482: PPUSH
102483: LD_INT 81
102485: PUSH
102486: LD_OWVAR 2
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PUSH
102495: LD_INT 91
102497: PUSH
102498: LD_VAR 0 3
102502: PUSH
102503: LD_INT 30
102505: PUSH
102506: EMPTY
102507: LIST
102508: LIST
102509: LIST
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PPUSH
102515: CALL_OW 69
102519: PPUSH
102520: LD_VAR 0 3
102524: PPUSH
102525: CALL_OW 74
102529: PPUSH
102530: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102534: LD_VAR 0 2
102538: PUSH
102539: LD_INT 80
102541: GREATER
102542: PUSH
102543: LD_VAR 0 3
102547: PPUSH
102548: CALL_OW 301
102552: OR
102553: IFFALSE 102430
// if un then
102555: LD_VAR 0 3
102559: IFFALSE 102570
// RemoveUnit ( un ) ;
102561: LD_VAR 0 3
102565: PPUSH
102566: CALL_OW 64
// end ;
102570: PPOPN 3
102572: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102573: LD_EXP 191
102577: IFFALSE 102693
102579: GO 102581
102581: DISABLE
102582: LD_INT 0
102584: PPUSH
102585: PPUSH
102586: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102587: LD_ADDR_VAR 0 2
102591: PUSH
102592: LD_INT 81
102594: PUSH
102595: LD_OWVAR 2
102599: PUSH
102600: EMPTY
102601: LIST
102602: LIST
102603: PUSH
102604: LD_INT 21
102606: PUSH
102607: LD_INT 1
102609: PUSH
102610: EMPTY
102611: LIST
102612: LIST
102613: PUSH
102614: EMPTY
102615: LIST
102616: LIST
102617: PPUSH
102618: CALL_OW 69
102622: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102623: LD_STRING playComputer()
102625: PPUSH
102626: CALL_OW 559
// if not tmp then
102630: LD_VAR 0 2
102634: NOT
102635: IFFALSE 102639
// exit ;
102637: GO 102693
// for i in tmp do
102639: LD_ADDR_VAR 0 1
102643: PUSH
102644: LD_VAR 0 2
102648: PUSH
102649: FOR_IN
102650: IFFALSE 102691
// for j := 1 to 4 do
102652: LD_ADDR_VAR 0 3
102656: PUSH
102657: DOUBLE
102658: LD_INT 1
102660: DEC
102661: ST_TO_ADDR
102662: LD_INT 4
102664: PUSH
102665: FOR_TO
102666: IFFALSE 102687
// SetSkill ( i , j , 10 ) ;
102668: LD_VAR 0 1
102672: PPUSH
102673: LD_VAR 0 3
102677: PPUSH
102678: LD_INT 10
102680: PPUSH
102681: CALL_OW 237
102685: GO 102665
102687: POP
102688: POP
102689: GO 102649
102691: POP
102692: POP
// end ;
102693: PPOPN 3
102695: END
// every 0 0$1 trigger s30 do var i , tmp ;
102696: LD_EXP 192
102700: IFFALSE 102769
102702: GO 102704
102704: DISABLE
102705: LD_INT 0
102707: PPUSH
102708: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102709: LD_ADDR_VAR 0 2
102713: PUSH
102714: LD_INT 22
102716: PUSH
102717: LD_OWVAR 2
102721: PUSH
102722: EMPTY
102723: LIST
102724: LIST
102725: PPUSH
102726: CALL_OW 69
102730: ST_TO_ADDR
// if not tmp then
102731: LD_VAR 0 2
102735: NOT
102736: IFFALSE 102740
// exit ;
102738: GO 102769
// for i in tmp do
102740: LD_ADDR_VAR 0 1
102744: PUSH
102745: LD_VAR 0 2
102749: PUSH
102750: FOR_IN
102751: IFFALSE 102767
// SetLives ( i , 300 ) ;
102753: LD_VAR 0 1
102757: PPUSH
102758: LD_INT 300
102760: PPUSH
102761: CALL_OW 234
102765: GO 102750
102767: POP
102768: POP
// end ;
102769: PPOPN 2
102771: END
// every 0 0$1 trigger s60 do var i , tmp ;
102772: LD_EXP 193
102776: IFFALSE 102845
102778: GO 102780
102780: DISABLE
102781: LD_INT 0
102783: PPUSH
102784: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102785: LD_ADDR_VAR 0 2
102789: PUSH
102790: LD_INT 22
102792: PUSH
102793: LD_OWVAR 2
102797: PUSH
102798: EMPTY
102799: LIST
102800: LIST
102801: PPUSH
102802: CALL_OW 69
102806: ST_TO_ADDR
// if not tmp then
102807: LD_VAR 0 2
102811: NOT
102812: IFFALSE 102816
// exit ;
102814: GO 102845
// for i in tmp do
102816: LD_ADDR_VAR 0 1
102820: PUSH
102821: LD_VAR 0 2
102825: PUSH
102826: FOR_IN
102827: IFFALSE 102843
// SetLives ( i , 600 ) ;
102829: LD_VAR 0 1
102833: PPUSH
102834: LD_INT 600
102836: PPUSH
102837: CALL_OW 234
102841: GO 102826
102843: POP
102844: POP
// end ;
102845: PPOPN 2
102847: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102848: LD_INT 0
102850: PPUSH
// case cmd of 301 :
102851: LD_VAR 0 1
102855: PUSH
102856: LD_INT 301
102858: DOUBLE
102859: EQUAL
102860: IFTRUE 102864
102862: GO 102896
102864: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102865: LD_VAR 0 6
102869: PPUSH
102870: LD_VAR 0 7
102874: PPUSH
102875: LD_VAR 0 8
102879: PPUSH
102880: LD_VAR 0 4
102884: PPUSH
102885: LD_VAR 0 5
102889: PPUSH
102890: CALL 104097 0 5
102894: GO 103017
102896: LD_INT 302
102898: DOUBLE
102899: EQUAL
102900: IFTRUE 102904
102902: GO 102941
102904: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102905: LD_VAR 0 6
102909: PPUSH
102910: LD_VAR 0 7
102914: PPUSH
102915: LD_VAR 0 8
102919: PPUSH
102920: LD_VAR 0 9
102924: PPUSH
102925: LD_VAR 0 4
102929: PPUSH
102930: LD_VAR 0 5
102934: PPUSH
102935: CALL 104188 0 6
102939: GO 103017
102941: LD_INT 303
102943: DOUBLE
102944: EQUAL
102945: IFTRUE 102949
102947: GO 102986
102949: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102950: LD_VAR 0 6
102954: PPUSH
102955: LD_VAR 0 7
102959: PPUSH
102960: LD_VAR 0 8
102964: PPUSH
102965: LD_VAR 0 9
102969: PPUSH
102970: LD_VAR 0 4
102974: PPUSH
102975: LD_VAR 0 5
102979: PPUSH
102980: CALL 103022 0 6
102984: GO 103017
102986: LD_INT 304
102988: DOUBLE
102989: EQUAL
102990: IFTRUE 102994
102992: GO 103016
102994: POP
// hHackTeleport ( unit , x , y ) ; end ;
102995: LD_VAR 0 2
102999: PPUSH
103000: LD_VAR 0 4
103004: PPUSH
103005: LD_VAR 0 5
103009: PPUSH
103010: CALL 104781 0 3
103014: GO 103017
103016: POP
// end ;
103017: LD_VAR 0 12
103021: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103022: LD_INT 0
103024: PPUSH
103025: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103026: LD_VAR 0 1
103030: PUSH
103031: LD_INT 1
103033: LESS
103034: PUSH
103035: LD_VAR 0 1
103039: PUSH
103040: LD_INT 3
103042: GREATER
103043: OR
103044: PUSH
103045: LD_VAR 0 5
103049: PPUSH
103050: LD_VAR 0 6
103054: PPUSH
103055: CALL_OW 428
103059: OR
103060: IFFALSE 103064
// exit ;
103062: GO 103784
// uc_side := your_side ;
103064: LD_ADDR_OWVAR 20
103068: PUSH
103069: LD_OWVAR 2
103073: ST_TO_ADDR
// uc_nation := nation ;
103074: LD_ADDR_OWVAR 21
103078: PUSH
103079: LD_VAR 0 1
103083: ST_TO_ADDR
// bc_level = 1 ;
103084: LD_ADDR_OWVAR 43
103088: PUSH
103089: LD_INT 1
103091: ST_TO_ADDR
// case btype of 1 :
103092: LD_VAR 0 2
103096: PUSH
103097: LD_INT 1
103099: DOUBLE
103100: EQUAL
103101: IFTRUE 103105
103103: GO 103116
103105: POP
// bc_type := b_depot ; 2 :
103106: LD_ADDR_OWVAR 42
103110: PUSH
103111: LD_INT 0
103113: ST_TO_ADDR
103114: GO 103728
103116: LD_INT 2
103118: DOUBLE
103119: EQUAL
103120: IFTRUE 103124
103122: GO 103135
103124: POP
// bc_type := b_warehouse ; 3 :
103125: LD_ADDR_OWVAR 42
103129: PUSH
103130: LD_INT 1
103132: ST_TO_ADDR
103133: GO 103728
103135: LD_INT 3
103137: DOUBLE
103138: EQUAL
103139: IFTRUE 103143
103141: GO 103154
103143: POP
// bc_type := b_lab ; 4 .. 9 :
103144: LD_ADDR_OWVAR 42
103148: PUSH
103149: LD_INT 6
103151: ST_TO_ADDR
103152: GO 103728
103154: LD_INT 4
103156: DOUBLE
103157: GREATEREQUAL
103158: IFFALSE 103166
103160: LD_INT 9
103162: DOUBLE
103163: LESSEQUAL
103164: IFTRUE 103168
103166: GO 103220
103168: POP
// begin bc_type := b_lab_half ;
103169: LD_ADDR_OWVAR 42
103173: PUSH
103174: LD_INT 7
103176: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103177: LD_ADDR_OWVAR 44
103181: PUSH
103182: LD_INT 10
103184: PUSH
103185: LD_INT 11
103187: PUSH
103188: LD_INT 12
103190: PUSH
103191: LD_INT 15
103193: PUSH
103194: LD_INT 14
103196: PUSH
103197: LD_INT 13
103199: PUSH
103200: EMPTY
103201: LIST
103202: LIST
103203: LIST
103204: LIST
103205: LIST
103206: LIST
103207: PUSH
103208: LD_VAR 0 2
103212: PUSH
103213: LD_INT 3
103215: MINUS
103216: ARRAY
103217: ST_TO_ADDR
// end ; 10 .. 13 :
103218: GO 103728
103220: LD_INT 10
103222: DOUBLE
103223: GREATEREQUAL
103224: IFFALSE 103232
103226: LD_INT 13
103228: DOUBLE
103229: LESSEQUAL
103230: IFTRUE 103234
103232: GO 103311
103234: POP
// begin bc_type := b_lab_full ;
103235: LD_ADDR_OWVAR 42
103239: PUSH
103240: LD_INT 8
103242: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103243: LD_ADDR_OWVAR 44
103247: PUSH
103248: LD_INT 10
103250: PUSH
103251: LD_INT 12
103253: PUSH
103254: LD_INT 14
103256: PUSH
103257: LD_INT 13
103259: PUSH
103260: EMPTY
103261: LIST
103262: LIST
103263: LIST
103264: LIST
103265: PUSH
103266: LD_VAR 0 2
103270: PUSH
103271: LD_INT 9
103273: MINUS
103274: ARRAY
103275: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103276: LD_ADDR_OWVAR 45
103280: PUSH
103281: LD_INT 11
103283: PUSH
103284: LD_INT 15
103286: PUSH
103287: LD_INT 12
103289: PUSH
103290: LD_INT 15
103292: PUSH
103293: EMPTY
103294: LIST
103295: LIST
103296: LIST
103297: LIST
103298: PUSH
103299: LD_VAR 0 2
103303: PUSH
103304: LD_INT 9
103306: MINUS
103307: ARRAY
103308: ST_TO_ADDR
// end ; 14 :
103309: GO 103728
103311: LD_INT 14
103313: DOUBLE
103314: EQUAL
103315: IFTRUE 103319
103317: GO 103330
103319: POP
// bc_type := b_workshop ; 15 :
103320: LD_ADDR_OWVAR 42
103324: PUSH
103325: LD_INT 2
103327: ST_TO_ADDR
103328: GO 103728
103330: LD_INT 15
103332: DOUBLE
103333: EQUAL
103334: IFTRUE 103338
103336: GO 103349
103338: POP
// bc_type := b_factory ; 16 :
103339: LD_ADDR_OWVAR 42
103343: PUSH
103344: LD_INT 3
103346: ST_TO_ADDR
103347: GO 103728
103349: LD_INT 16
103351: DOUBLE
103352: EQUAL
103353: IFTRUE 103357
103355: GO 103368
103357: POP
// bc_type := b_ext_gun ; 17 :
103358: LD_ADDR_OWVAR 42
103362: PUSH
103363: LD_INT 17
103365: ST_TO_ADDR
103366: GO 103728
103368: LD_INT 17
103370: DOUBLE
103371: EQUAL
103372: IFTRUE 103376
103374: GO 103404
103376: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103377: LD_ADDR_OWVAR 42
103381: PUSH
103382: LD_INT 19
103384: PUSH
103385: LD_INT 23
103387: PUSH
103388: LD_INT 19
103390: PUSH
103391: EMPTY
103392: LIST
103393: LIST
103394: LIST
103395: PUSH
103396: LD_VAR 0 1
103400: ARRAY
103401: ST_TO_ADDR
103402: GO 103728
103404: LD_INT 18
103406: DOUBLE
103407: EQUAL
103408: IFTRUE 103412
103410: GO 103423
103412: POP
// bc_type := b_ext_radar ; 19 :
103413: LD_ADDR_OWVAR 42
103417: PUSH
103418: LD_INT 20
103420: ST_TO_ADDR
103421: GO 103728
103423: LD_INT 19
103425: DOUBLE
103426: EQUAL
103427: IFTRUE 103431
103429: GO 103442
103431: POP
// bc_type := b_ext_radio ; 20 :
103432: LD_ADDR_OWVAR 42
103436: PUSH
103437: LD_INT 22
103439: ST_TO_ADDR
103440: GO 103728
103442: LD_INT 20
103444: DOUBLE
103445: EQUAL
103446: IFTRUE 103450
103448: GO 103461
103450: POP
// bc_type := b_ext_siberium ; 21 :
103451: LD_ADDR_OWVAR 42
103455: PUSH
103456: LD_INT 21
103458: ST_TO_ADDR
103459: GO 103728
103461: LD_INT 21
103463: DOUBLE
103464: EQUAL
103465: IFTRUE 103469
103467: GO 103480
103469: POP
// bc_type := b_ext_computer ; 22 :
103470: LD_ADDR_OWVAR 42
103474: PUSH
103475: LD_INT 24
103477: ST_TO_ADDR
103478: GO 103728
103480: LD_INT 22
103482: DOUBLE
103483: EQUAL
103484: IFTRUE 103488
103486: GO 103499
103488: POP
// bc_type := b_ext_track ; 23 :
103489: LD_ADDR_OWVAR 42
103493: PUSH
103494: LD_INT 16
103496: ST_TO_ADDR
103497: GO 103728
103499: LD_INT 23
103501: DOUBLE
103502: EQUAL
103503: IFTRUE 103507
103505: GO 103518
103507: POP
// bc_type := b_ext_laser ; 24 :
103508: LD_ADDR_OWVAR 42
103512: PUSH
103513: LD_INT 25
103515: ST_TO_ADDR
103516: GO 103728
103518: LD_INT 24
103520: DOUBLE
103521: EQUAL
103522: IFTRUE 103526
103524: GO 103537
103526: POP
// bc_type := b_control_tower ; 25 :
103527: LD_ADDR_OWVAR 42
103531: PUSH
103532: LD_INT 36
103534: ST_TO_ADDR
103535: GO 103728
103537: LD_INT 25
103539: DOUBLE
103540: EQUAL
103541: IFTRUE 103545
103543: GO 103556
103545: POP
// bc_type := b_breastwork ; 26 :
103546: LD_ADDR_OWVAR 42
103550: PUSH
103551: LD_INT 31
103553: ST_TO_ADDR
103554: GO 103728
103556: LD_INT 26
103558: DOUBLE
103559: EQUAL
103560: IFTRUE 103564
103562: GO 103575
103564: POP
// bc_type := b_bunker ; 27 :
103565: LD_ADDR_OWVAR 42
103569: PUSH
103570: LD_INT 32
103572: ST_TO_ADDR
103573: GO 103728
103575: LD_INT 27
103577: DOUBLE
103578: EQUAL
103579: IFTRUE 103583
103581: GO 103594
103583: POP
// bc_type := b_turret ; 28 :
103584: LD_ADDR_OWVAR 42
103588: PUSH
103589: LD_INT 33
103591: ST_TO_ADDR
103592: GO 103728
103594: LD_INT 28
103596: DOUBLE
103597: EQUAL
103598: IFTRUE 103602
103600: GO 103613
103602: POP
// bc_type := b_armoury ; 29 :
103603: LD_ADDR_OWVAR 42
103607: PUSH
103608: LD_INT 4
103610: ST_TO_ADDR
103611: GO 103728
103613: LD_INT 29
103615: DOUBLE
103616: EQUAL
103617: IFTRUE 103621
103619: GO 103632
103621: POP
// bc_type := b_barracks ; 30 :
103622: LD_ADDR_OWVAR 42
103626: PUSH
103627: LD_INT 5
103629: ST_TO_ADDR
103630: GO 103728
103632: LD_INT 30
103634: DOUBLE
103635: EQUAL
103636: IFTRUE 103640
103638: GO 103651
103640: POP
// bc_type := b_solar_power ; 31 :
103641: LD_ADDR_OWVAR 42
103645: PUSH
103646: LD_INT 27
103648: ST_TO_ADDR
103649: GO 103728
103651: LD_INT 31
103653: DOUBLE
103654: EQUAL
103655: IFTRUE 103659
103657: GO 103670
103659: POP
// bc_type := b_oil_power ; 32 :
103660: LD_ADDR_OWVAR 42
103664: PUSH
103665: LD_INT 26
103667: ST_TO_ADDR
103668: GO 103728
103670: LD_INT 32
103672: DOUBLE
103673: EQUAL
103674: IFTRUE 103678
103676: GO 103689
103678: POP
// bc_type := b_siberite_power ; 33 :
103679: LD_ADDR_OWVAR 42
103683: PUSH
103684: LD_INT 28
103686: ST_TO_ADDR
103687: GO 103728
103689: LD_INT 33
103691: DOUBLE
103692: EQUAL
103693: IFTRUE 103697
103695: GO 103708
103697: POP
// bc_type := b_oil_mine ; 34 :
103698: LD_ADDR_OWVAR 42
103702: PUSH
103703: LD_INT 29
103705: ST_TO_ADDR
103706: GO 103728
103708: LD_INT 34
103710: DOUBLE
103711: EQUAL
103712: IFTRUE 103716
103714: GO 103727
103716: POP
// bc_type := b_siberite_mine ; end ;
103717: LD_ADDR_OWVAR 42
103721: PUSH
103722: LD_INT 30
103724: ST_TO_ADDR
103725: GO 103728
103727: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103728: LD_ADDR_VAR 0 8
103732: PUSH
103733: LD_VAR 0 5
103737: PPUSH
103738: LD_VAR 0 6
103742: PPUSH
103743: LD_VAR 0 3
103747: PPUSH
103748: CALL_OW 47
103752: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103753: LD_OWVAR 42
103757: PUSH
103758: LD_INT 32
103760: PUSH
103761: LD_INT 33
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: IN
103768: IFFALSE 103784
// PlaceWeaponTurret ( b , weapon ) ;
103770: LD_VAR 0 8
103774: PPUSH
103775: LD_VAR 0 4
103779: PPUSH
103780: CALL_OW 431
// end ;
103784: LD_VAR 0 7
103788: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103789: LD_INT 0
103791: PPUSH
103792: PPUSH
103793: PPUSH
103794: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103795: LD_ADDR_VAR 0 4
103799: PUSH
103800: LD_INT 22
103802: PUSH
103803: LD_OWVAR 2
103807: PUSH
103808: EMPTY
103809: LIST
103810: LIST
103811: PUSH
103812: LD_INT 2
103814: PUSH
103815: LD_INT 30
103817: PUSH
103818: LD_INT 0
103820: PUSH
103821: EMPTY
103822: LIST
103823: LIST
103824: PUSH
103825: LD_INT 30
103827: PUSH
103828: LD_INT 1
103830: PUSH
103831: EMPTY
103832: LIST
103833: LIST
103834: PUSH
103835: EMPTY
103836: LIST
103837: LIST
103838: LIST
103839: PUSH
103840: EMPTY
103841: LIST
103842: LIST
103843: PPUSH
103844: CALL_OW 69
103848: ST_TO_ADDR
// if not tmp then
103849: LD_VAR 0 4
103853: NOT
103854: IFFALSE 103858
// exit ;
103856: GO 103917
// for i in tmp do
103858: LD_ADDR_VAR 0 2
103862: PUSH
103863: LD_VAR 0 4
103867: PUSH
103868: FOR_IN
103869: IFFALSE 103915
// for j = 1 to 3 do
103871: LD_ADDR_VAR 0 3
103875: PUSH
103876: DOUBLE
103877: LD_INT 1
103879: DEC
103880: ST_TO_ADDR
103881: LD_INT 3
103883: PUSH
103884: FOR_TO
103885: IFFALSE 103911
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103887: LD_VAR 0 2
103891: PPUSH
103892: CALL_OW 274
103896: PPUSH
103897: LD_VAR 0 3
103901: PPUSH
103902: LD_INT 99999
103904: PPUSH
103905: CALL_OW 277
103909: GO 103884
103911: POP
103912: POP
103913: GO 103868
103915: POP
103916: POP
// end ;
103917: LD_VAR 0 1
103921: RET
// export function hHackSetLevel10 ; var i , j ; begin
103922: LD_INT 0
103924: PPUSH
103925: PPUSH
103926: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103927: LD_ADDR_VAR 0 2
103931: PUSH
103932: LD_INT 21
103934: PUSH
103935: LD_INT 1
103937: PUSH
103938: EMPTY
103939: LIST
103940: LIST
103941: PPUSH
103942: CALL_OW 69
103946: PUSH
103947: FOR_IN
103948: IFFALSE 104000
// if IsSelected ( i ) then
103950: LD_VAR 0 2
103954: PPUSH
103955: CALL_OW 306
103959: IFFALSE 103998
// begin for j := 1 to 4 do
103961: LD_ADDR_VAR 0 3
103965: PUSH
103966: DOUBLE
103967: LD_INT 1
103969: DEC
103970: ST_TO_ADDR
103971: LD_INT 4
103973: PUSH
103974: FOR_TO
103975: IFFALSE 103996
// SetSkill ( i , j , 10 ) ;
103977: LD_VAR 0 2
103981: PPUSH
103982: LD_VAR 0 3
103986: PPUSH
103987: LD_INT 10
103989: PPUSH
103990: CALL_OW 237
103994: GO 103974
103996: POP
103997: POP
// end ;
103998: GO 103947
104000: POP
104001: POP
// end ;
104002: LD_VAR 0 1
104006: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104007: LD_INT 0
104009: PPUSH
104010: PPUSH
104011: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104012: LD_ADDR_VAR 0 2
104016: PUSH
104017: LD_INT 22
104019: PUSH
104020: LD_OWVAR 2
104024: PUSH
104025: EMPTY
104026: LIST
104027: LIST
104028: PUSH
104029: LD_INT 21
104031: PUSH
104032: LD_INT 1
104034: PUSH
104035: EMPTY
104036: LIST
104037: LIST
104038: PUSH
104039: EMPTY
104040: LIST
104041: LIST
104042: PPUSH
104043: CALL_OW 69
104047: PUSH
104048: FOR_IN
104049: IFFALSE 104090
// begin for j := 1 to 4 do
104051: LD_ADDR_VAR 0 3
104055: PUSH
104056: DOUBLE
104057: LD_INT 1
104059: DEC
104060: ST_TO_ADDR
104061: LD_INT 4
104063: PUSH
104064: FOR_TO
104065: IFFALSE 104086
// SetSkill ( i , j , 10 ) ;
104067: LD_VAR 0 2
104071: PPUSH
104072: LD_VAR 0 3
104076: PPUSH
104077: LD_INT 10
104079: PPUSH
104080: CALL_OW 237
104084: GO 104064
104086: POP
104087: POP
// end ;
104088: GO 104048
104090: POP
104091: POP
// end ;
104092: LD_VAR 0 1
104096: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104097: LD_INT 0
104099: PPUSH
// uc_side := your_side ;
104100: LD_ADDR_OWVAR 20
104104: PUSH
104105: LD_OWVAR 2
104109: ST_TO_ADDR
// uc_nation := nation ;
104110: LD_ADDR_OWVAR 21
104114: PUSH
104115: LD_VAR 0 1
104119: ST_TO_ADDR
// InitHc ;
104120: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104124: LD_INT 0
104126: PPUSH
104127: LD_VAR 0 2
104131: PPUSH
104132: LD_VAR 0 3
104136: PPUSH
104137: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104141: LD_VAR 0 4
104145: PPUSH
104146: LD_VAR 0 5
104150: PPUSH
104151: CALL_OW 428
104155: PUSH
104156: LD_INT 0
104158: EQUAL
104159: IFFALSE 104183
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104161: CALL_OW 44
104165: PPUSH
104166: LD_VAR 0 4
104170: PPUSH
104171: LD_VAR 0 5
104175: PPUSH
104176: LD_INT 1
104178: PPUSH
104179: CALL_OW 48
// end ;
104183: LD_VAR 0 6
104187: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104188: LD_INT 0
104190: PPUSH
104191: PPUSH
// uc_side := your_side ;
104192: LD_ADDR_OWVAR 20
104196: PUSH
104197: LD_OWVAR 2
104201: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104202: LD_VAR 0 1
104206: PUSH
104207: LD_INT 1
104209: PUSH
104210: LD_INT 2
104212: PUSH
104213: LD_INT 3
104215: PUSH
104216: LD_INT 4
104218: PUSH
104219: LD_INT 5
104221: PUSH
104222: EMPTY
104223: LIST
104224: LIST
104225: LIST
104226: LIST
104227: LIST
104228: IN
104229: IFFALSE 104241
// uc_nation := nation_american else
104231: LD_ADDR_OWVAR 21
104235: PUSH
104236: LD_INT 1
104238: ST_TO_ADDR
104239: GO 104284
// if chassis in [ 11 , 12 , 13 , 14 ] then
104241: LD_VAR 0 1
104245: PUSH
104246: LD_INT 11
104248: PUSH
104249: LD_INT 12
104251: PUSH
104252: LD_INT 13
104254: PUSH
104255: LD_INT 14
104257: PUSH
104258: EMPTY
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: IN
104264: IFFALSE 104276
// uc_nation := nation_arabian else
104266: LD_ADDR_OWVAR 21
104270: PUSH
104271: LD_INT 2
104273: ST_TO_ADDR
104274: GO 104284
// uc_nation := nation_russian ;
104276: LD_ADDR_OWVAR 21
104280: PUSH
104281: LD_INT 3
104283: ST_TO_ADDR
// vc_chassis := chassis ;
104284: LD_ADDR_OWVAR 37
104288: PUSH
104289: LD_VAR 0 1
104293: ST_TO_ADDR
// vc_engine := engine ;
104294: LD_ADDR_OWVAR 39
104298: PUSH
104299: LD_VAR 0 2
104303: ST_TO_ADDR
// vc_control := control ;
104304: LD_ADDR_OWVAR 38
104308: PUSH
104309: LD_VAR 0 3
104313: ST_TO_ADDR
// vc_weapon := weapon ;
104314: LD_ADDR_OWVAR 40
104318: PUSH
104319: LD_VAR 0 4
104323: ST_TO_ADDR
// un := CreateVehicle ;
104324: LD_ADDR_VAR 0 8
104328: PUSH
104329: CALL_OW 45
104333: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104334: LD_VAR 0 8
104338: PPUSH
104339: LD_INT 0
104341: PPUSH
104342: LD_INT 5
104344: PPUSH
104345: CALL_OW 12
104349: PPUSH
104350: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104354: LD_VAR 0 8
104358: PPUSH
104359: LD_VAR 0 5
104363: PPUSH
104364: LD_VAR 0 6
104368: PPUSH
104369: LD_INT 1
104371: PPUSH
104372: CALL_OW 48
// end ;
104376: LD_VAR 0 7
104380: RET
// export hInvincible ; every 1 do
104381: GO 104383
104383: DISABLE
// hInvincible := [ ] ;
104384: LD_ADDR_EXP 194
104388: PUSH
104389: EMPTY
104390: ST_TO_ADDR
104391: END
// every 10 do var i ;
104392: GO 104394
104394: DISABLE
104395: LD_INT 0
104397: PPUSH
// begin enable ;
104398: ENABLE
// if not hInvincible then
104399: LD_EXP 194
104403: NOT
104404: IFFALSE 104408
// exit ;
104406: GO 104452
// for i in hInvincible do
104408: LD_ADDR_VAR 0 1
104412: PUSH
104413: LD_EXP 194
104417: PUSH
104418: FOR_IN
104419: IFFALSE 104450
// if GetLives ( i ) < 1000 then
104421: LD_VAR 0 1
104425: PPUSH
104426: CALL_OW 256
104430: PUSH
104431: LD_INT 1000
104433: LESS
104434: IFFALSE 104448
// SetLives ( i , 1000 ) ;
104436: LD_VAR 0 1
104440: PPUSH
104441: LD_INT 1000
104443: PPUSH
104444: CALL_OW 234
104448: GO 104418
104450: POP
104451: POP
// end ;
104452: PPOPN 1
104454: END
// export function hHackInvincible ; var i ; begin
104455: LD_INT 0
104457: PPUSH
104458: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104459: LD_ADDR_VAR 0 2
104463: PUSH
104464: LD_INT 2
104466: PUSH
104467: LD_INT 21
104469: PUSH
104470: LD_INT 1
104472: PUSH
104473: EMPTY
104474: LIST
104475: LIST
104476: PUSH
104477: LD_INT 21
104479: PUSH
104480: LD_INT 2
104482: PUSH
104483: EMPTY
104484: LIST
104485: LIST
104486: PUSH
104487: EMPTY
104488: LIST
104489: LIST
104490: LIST
104491: PPUSH
104492: CALL_OW 69
104496: PUSH
104497: FOR_IN
104498: IFFALSE 104559
// if IsSelected ( i ) then
104500: LD_VAR 0 2
104504: PPUSH
104505: CALL_OW 306
104509: IFFALSE 104557
// begin if i in hInvincible then
104511: LD_VAR 0 2
104515: PUSH
104516: LD_EXP 194
104520: IN
104521: IFFALSE 104541
// hInvincible := hInvincible diff i else
104523: LD_ADDR_EXP 194
104527: PUSH
104528: LD_EXP 194
104532: PUSH
104533: LD_VAR 0 2
104537: DIFF
104538: ST_TO_ADDR
104539: GO 104557
// hInvincible := hInvincible union i ;
104541: LD_ADDR_EXP 194
104545: PUSH
104546: LD_EXP 194
104550: PUSH
104551: LD_VAR 0 2
104555: UNION
104556: ST_TO_ADDR
// end ;
104557: GO 104497
104559: POP
104560: POP
// end ;
104561: LD_VAR 0 1
104565: RET
// export function hHackInvisible ; var i , j ; begin
104566: LD_INT 0
104568: PPUSH
104569: PPUSH
104570: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104571: LD_ADDR_VAR 0 2
104575: PUSH
104576: LD_INT 21
104578: PUSH
104579: LD_INT 1
104581: PUSH
104582: EMPTY
104583: LIST
104584: LIST
104585: PPUSH
104586: CALL_OW 69
104590: PUSH
104591: FOR_IN
104592: IFFALSE 104616
// if IsSelected ( i ) then
104594: LD_VAR 0 2
104598: PPUSH
104599: CALL_OW 306
104603: IFFALSE 104614
// ComForceInvisible ( i ) ;
104605: LD_VAR 0 2
104609: PPUSH
104610: CALL_OW 496
104614: GO 104591
104616: POP
104617: POP
// end ;
104618: LD_VAR 0 1
104622: RET
// export function hHackChangeYourSide ; begin
104623: LD_INT 0
104625: PPUSH
// if your_side = 8 then
104626: LD_OWVAR 2
104630: PUSH
104631: LD_INT 8
104633: EQUAL
104634: IFFALSE 104646
// your_side := 0 else
104636: LD_ADDR_OWVAR 2
104640: PUSH
104641: LD_INT 0
104643: ST_TO_ADDR
104644: GO 104660
// your_side := your_side + 1 ;
104646: LD_ADDR_OWVAR 2
104650: PUSH
104651: LD_OWVAR 2
104655: PUSH
104656: LD_INT 1
104658: PLUS
104659: ST_TO_ADDR
// end ;
104660: LD_VAR 0 1
104664: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104665: LD_INT 0
104667: PPUSH
104668: PPUSH
104669: PPUSH
// for i in all_units do
104670: LD_ADDR_VAR 0 2
104674: PUSH
104675: LD_OWVAR 3
104679: PUSH
104680: FOR_IN
104681: IFFALSE 104759
// if IsSelected ( i ) then
104683: LD_VAR 0 2
104687: PPUSH
104688: CALL_OW 306
104692: IFFALSE 104757
// begin j := GetSide ( i ) ;
104694: LD_ADDR_VAR 0 3
104698: PUSH
104699: LD_VAR 0 2
104703: PPUSH
104704: CALL_OW 255
104708: ST_TO_ADDR
// if j = 8 then
104709: LD_VAR 0 3
104713: PUSH
104714: LD_INT 8
104716: EQUAL
104717: IFFALSE 104729
// j := 0 else
104719: LD_ADDR_VAR 0 3
104723: PUSH
104724: LD_INT 0
104726: ST_TO_ADDR
104727: GO 104743
// j := j + 1 ;
104729: LD_ADDR_VAR 0 3
104733: PUSH
104734: LD_VAR 0 3
104738: PUSH
104739: LD_INT 1
104741: PLUS
104742: ST_TO_ADDR
// SetSide ( i , j ) ;
104743: LD_VAR 0 2
104747: PPUSH
104748: LD_VAR 0 3
104752: PPUSH
104753: CALL_OW 235
// end ;
104757: GO 104680
104759: POP
104760: POP
// end ;
104761: LD_VAR 0 1
104765: RET
// export function hHackFog ; begin
104766: LD_INT 0
104768: PPUSH
// FogOff ( true ) ;
104769: LD_INT 1
104771: PPUSH
104772: CALL_OW 344
// end ;
104776: LD_VAR 0 1
104780: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104781: LD_INT 0
104783: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104784: LD_VAR 0 1
104788: PPUSH
104789: LD_VAR 0 2
104793: PPUSH
104794: LD_VAR 0 3
104798: PPUSH
104799: LD_INT 1
104801: PPUSH
104802: LD_INT 1
104804: PPUSH
104805: CALL_OW 483
// CenterOnXY ( x , y ) ;
104809: LD_VAR 0 2
104813: PPUSH
104814: LD_VAR 0 3
104818: PPUSH
104819: CALL_OW 84
// end ; end_of_file
104823: LD_VAR 0 4
104827: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
104828: LD_INT 0
104830: PPUSH
104831: PPUSH
104832: PPUSH
104833: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104834: LD_VAR 0 1
104838: PPUSH
104839: CALL_OW 264
104843: PUSH
104844: LD_EXP 76
104848: EQUAL
104849: IFFALSE 104921
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104851: LD_INT 68
104853: PPUSH
104854: LD_VAR 0 1
104858: PPUSH
104859: CALL_OW 255
104863: PPUSH
104864: CALL_OW 321
104868: PUSH
104869: LD_INT 2
104871: EQUAL
104872: IFFALSE 104884
// eff := 70 else
104874: LD_ADDR_VAR 0 4
104878: PUSH
104879: LD_INT 70
104881: ST_TO_ADDR
104882: GO 104892
// eff := 30 ;
104884: LD_ADDR_VAR 0 4
104888: PUSH
104889: LD_INT 30
104891: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104892: LD_VAR 0 1
104896: PPUSH
104897: CALL_OW 250
104901: PPUSH
104902: LD_VAR 0 1
104906: PPUSH
104907: CALL_OW 251
104911: PPUSH
104912: LD_VAR 0 4
104916: PPUSH
104917: CALL_OW 495
// end ; end ;
104921: LD_VAR 0 2
104925: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104926: LD_INT 0
104928: PPUSH
// end ;
104929: LD_VAR 0 4
104933: RET
// export function SOS_Command ( cmd ) ; begin
104934: LD_INT 0
104936: PPUSH
// end ;
104937: LD_VAR 0 2
104941: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
104942: LD_INT 0
104944: PPUSH
// end ;
104945: LD_VAR 0 6
104949: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
104950: LD_INT 0
104952: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
104953: LD_VAR 0 1
104957: PUSH
104958: LD_INT 250
104960: EQUAL
104961: PUSH
104962: LD_VAR 0 2
104966: PPUSH
104967: CALL_OW 264
104971: PUSH
104972: LD_EXP 79
104976: EQUAL
104977: AND
104978: IFFALSE 104999
// MinerPlaceMine ( unit , x , y ) ;
104980: LD_VAR 0 2
104984: PPUSH
104985: LD_VAR 0 4
104989: PPUSH
104990: LD_VAR 0 5
104994: PPUSH
104995: CALL 107348 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
104999: LD_VAR 0 1
105003: PUSH
105004: LD_INT 251
105006: EQUAL
105007: PUSH
105008: LD_VAR 0 2
105012: PPUSH
105013: CALL_OW 264
105017: PUSH
105018: LD_EXP 79
105022: EQUAL
105023: AND
105024: IFFALSE 105045
// MinerDetonateMine ( unit , x , y ) ;
105026: LD_VAR 0 2
105030: PPUSH
105031: LD_VAR 0 4
105035: PPUSH
105036: LD_VAR 0 5
105040: PPUSH
105041: CALL 107625 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105045: LD_VAR 0 1
105049: PUSH
105050: LD_INT 252
105052: EQUAL
105053: PUSH
105054: LD_VAR 0 2
105058: PPUSH
105059: CALL_OW 264
105063: PUSH
105064: LD_EXP 79
105068: EQUAL
105069: AND
105070: IFFALSE 105091
// MinerCreateMinefield ( unit , x , y ) ;
105072: LD_VAR 0 2
105076: PPUSH
105077: LD_VAR 0 4
105081: PPUSH
105082: LD_VAR 0 5
105086: PPUSH
105087: CALL 108042 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105091: LD_VAR 0 1
105095: PUSH
105096: LD_INT 253
105098: EQUAL
105099: PUSH
105100: LD_VAR 0 2
105104: PPUSH
105105: CALL_OW 257
105109: PUSH
105110: LD_INT 5
105112: EQUAL
105113: AND
105114: IFFALSE 105135
// ComBinocular ( unit , x , y ) ;
105116: LD_VAR 0 2
105120: PPUSH
105121: LD_VAR 0 4
105125: PPUSH
105126: LD_VAR 0 5
105130: PPUSH
105131: CALL 108413 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105135: LD_VAR 0 1
105139: PUSH
105140: LD_INT 254
105142: EQUAL
105143: PUSH
105144: LD_VAR 0 2
105148: PPUSH
105149: CALL_OW 264
105153: PUSH
105154: LD_EXP 74
105158: EQUAL
105159: AND
105160: PUSH
105161: LD_VAR 0 3
105165: PPUSH
105166: CALL_OW 263
105170: PUSH
105171: LD_INT 3
105173: EQUAL
105174: AND
105175: IFFALSE 105191
// HackDestroyVehicle ( unit , selectedUnit ) ;
105177: LD_VAR 0 2
105181: PPUSH
105182: LD_VAR 0 3
105186: PPUSH
105187: CALL 106708 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105191: LD_VAR 0 1
105195: PUSH
105196: LD_INT 255
105198: EQUAL
105199: PUSH
105200: LD_VAR 0 2
105204: PPUSH
105205: CALL_OW 264
105209: PUSH
105210: LD_INT 14
105212: PUSH
105213: LD_INT 53
105215: PUSH
105216: EMPTY
105217: LIST
105218: LIST
105219: IN
105220: AND
105221: PUSH
105222: LD_VAR 0 4
105226: PPUSH
105227: LD_VAR 0 5
105231: PPUSH
105232: CALL_OW 488
105236: AND
105237: IFFALSE 105261
// CutTreeXYR ( unit , x , y , 12 ) ;
105239: LD_VAR 0 2
105243: PPUSH
105244: LD_VAR 0 4
105248: PPUSH
105249: LD_VAR 0 5
105253: PPUSH
105254: LD_INT 12
105256: PPUSH
105257: CALL 105274 0 4
// end ;
105261: LD_VAR 0 6
105265: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
105266: LD_INT 0
105268: PPUSH
// end ;
105269: LD_VAR 0 4
105273: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105274: LD_INT 0
105276: PPUSH
105277: PPUSH
105278: PPUSH
105279: PPUSH
105280: PPUSH
105281: PPUSH
105282: PPUSH
105283: PPUSH
105284: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
105285: LD_VAR 0 1
105289: NOT
105290: PUSH
105291: LD_VAR 0 2
105295: PPUSH
105296: LD_VAR 0 3
105300: PPUSH
105301: CALL_OW 488
105305: NOT
105306: OR
105307: PUSH
105308: LD_VAR 0 4
105312: NOT
105313: OR
105314: IFFALSE 105318
// exit ;
105316: GO 105658
// list := [ ] ;
105318: LD_ADDR_VAR 0 13
105322: PUSH
105323: EMPTY
105324: ST_TO_ADDR
// if x - r < 0 then
105325: LD_VAR 0 2
105329: PUSH
105330: LD_VAR 0 4
105334: MINUS
105335: PUSH
105336: LD_INT 0
105338: LESS
105339: IFFALSE 105351
// min_x := 0 else
105341: LD_ADDR_VAR 0 7
105345: PUSH
105346: LD_INT 0
105348: ST_TO_ADDR
105349: GO 105367
// min_x := x - r ;
105351: LD_ADDR_VAR 0 7
105355: PUSH
105356: LD_VAR 0 2
105360: PUSH
105361: LD_VAR 0 4
105365: MINUS
105366: ST_TO_ADDR
// if y - r < 0 then
105367: LD_VAR 0 3
105371: PUSH
105372: LD_VAR 0 4
105376: MINUS
105377: PUSH
105378: LD_INT 0
105380: LESS
105381: IFFALSE 105393
// min_y := 0 else
105383: LD_ADDR_VAR 0 8
105387: PUSH
105388: LD_INT 0
105390: ST_TO_ADDR
105391: GO 105409
// min_y := y - r ;
105393: LD_ADDR_VAR 0 8
105397: PUSH
105398: LD_VAR 0 3
105402: PUSH
105403: LD_VAR 0 4
105407: MINUS
105408: ST_TO_ADDR
// max_x := x + r ;
105409: LD_ADDR_VAR 0 9
105413: PUSH
105414: LD_VAR 0 2
105418: PUSH
105419: LD_VAR 0 4
105423: PLUS
105424: ST_TO_ADDR
// max_y := y + r ;
105425: LD_ADDR_VAR 0 10
105429: PUSH
105430: LD_VAR 0 3
105434: PUSH
105435: LD_VAR 0 4
105439: PLUS
105440: ST_TO_ADDR
// for _x = min_x to max_x do
105441: LD_ADDR_VAR 0 11
105445: PUSH
105446: DOUBLE
105447: LD_VAR 0 7
105451: DEC
105452: ST_TO_ADDR
105453: LD_VAR 0 9
105457: PUSH
105458: FOR_TO
105459: IFFALSE 105576
// for _y = min_y to max_y do
105461: LD_ADDR_VAR 0 12
105465: PUSH
105466: DOUBLE
105467: LD_VAR 0 8
105471: DEC
105472: ST_TO_ADDR
105473: LD_VAR 0 10
105477: PUSH
105478: FOR_TO
105479: IFFALSE 105572
// begin if not ValidHex ( _x , _y ) then
105481: LD_VAR 0 11
105485: PPUSH
105486: LD_VAR 0 12
105490: PPUSH
105491: CALL_OW 488
105495: NOT
105496: IFFALSE 105500
// continue ;
105498: GO 105478
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
105500: LD_VAR 0 11
105504: PPUSH
105505: LD_VAR 0 12
105509: PPUSH
105510: CALL_OW 351
105514: PUSH
105515: LD_VAR 0 11
105519: PPUSH
105520: LD_VAR 0 12
105524: PPUSH
105525: CALL_OW 554
105529: AND
105530: IFFALSE 105570
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
105532: LD_ADDR_VAR 0 13
105536: PUSH
105537: LD_VAR 0 13
105541: PPUSH
105542: LD_VAR 0 13
105546: PUSH
105547: LD_INT 1
105549: PLUS
105550: PPUSH
105551: LD_VAR 0 11
105555: PUSH
105556: LD_VAR 0 12
105560: PUSH
105561: EMPTY
105562: LIST
105563: LIST
105564: PPUSH
105565: CALL_OW 2
105569: ST_TO_ADDR
// end ;
105570: GO 105478
105572: POP
105573: POP
105574: GO 105458
105576: POP
105577: POP
// if not list then
105578: LD_VAR 0 13
105582: NOT
105583: IFFALSE 105587
// exit ;
105585: GO 105658
// for i in list do
105587: LD_ADDR_VAR 0 6
105591: PUSH
105592: LD_VAR 0 13
105596: PUSH
105597: FOR_IN
105598: IFFALSE 105656
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
105600: LD_VAR 0 1
105604: PPUSH
105605: LD_STRING M
105607: PUSH
105608: LD_VAR 0 6
105612: PUSH
105613: LD_INT 1
105615: ARRAY
105616: PUSH
105617: LD_VAR 0 6
105621: PUSH
105622: LD_INT 2
105624: ARRAY
105625: PUSH
105626: LD_INT 0
105628: PUSH
105629: LD_INT 0
105631: PUSH
105632: LD_INT 0
105634: PUSH
105635: LD_INT 0
105637: PUSH
105638: EMPTY
105639: LIST
105640: LIST
105641: LIST
105642: LIST
105643: LIST
105644: LIST
105645: LIST
105646: PUSH
105647: EMPTY
105648: LIST
105649: PPUSH
105650: CALL_OW 447
105654: GO 105597
105656: POP
105657: POP
// end ;
105658: LD_VAR 0 5
105662: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
105663: LD_EXP 197
105667: NOT
105668: IFFALSE 105718
105670: GO 105672
105672: DISABLE
// begin initHack := true ;
105673: LD_ADDR_EXP 197
105677: PUSH
105678: LD_INT 1
105680: ST_TO_ADDR
// hackTanks := [ ] ;
105681: LD_ADDR_EXP 198
105685: PUSH
105686: EMPTY
105687: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
105688: LD_ADDR_EXP 199
105692: PUSH
105693: EMPTY
105694: ST_TO_ADDR
// hackLimit := 3 ;
105695: LD_ADDR_EXP 200
105699: PUSH
105700: LD_INT 3
105702: ST_TO_ADDR
// hackDist := 12 ;
105703: LD_ADDR_EXP 201
105707: PUSH
105708: LD_INT 12
105710: ST_TO_ADDR
// hackCounter := [ ] ;
105711: LD_ADDR_EXP 202
105715: PUSH
105716: EMPTY
105717: ST_TO_ADDR
// end ;
105718: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
105719: LD_EXP 197
105723: PUSH
105724: LD_INT 34
105726: PUSH
105727: LD_EXP 74
105731: PUSH
105732: EMPTY
105733: LIST
105734: LIST
105735: PPUSH
105736: CALL_OW 69
105740: AND
105741: IFFALSE 105996
105743: GO 105745
105745: DISABLE
105746: LD_INT 0
105748: PPUSH
105749: PPUSH
// begin enable ;
105750: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
105751: LD_ADDR_VAR 0 1
105755: PUSH
105756: LD_INT 34
105758: PUSH
105759: LD_EXP 74
105763: PUSH
105764: EMPTY
105765: LIST
105766: LIST
105767: PPUSH
105768: CALL_OW 69
105772: PUSH
105773: FOR_IN
105774: IFFALSE 105994
// begin if not i in hackTanks then
105776: LD_VAR 0 1
105780: PUSH
105781: LD_EXP 198
105785: IN
105786: NOT
105787: IFFALSE 105870
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
105789: LD_ADDR_EXP 198
105793: PUSH
105794: LD_EXP 198
105798: PPUSH
105799: LD_EXP 198
105803: PUSH
105804: LD_INT 1
105806: PLUS
105807: PPUSH
105808: LD_VAR 0 1
105812: PPUSH
105813: CALL_OW 1
105817: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
105818: LD_ADDR_EXP 199
105822: PUSH
105823: LD_EXP 199
105827: PPUSH
105828: LD_EXP 199
105832: PUSH
105833: LD_INT 1
105835: PLUS
105836: PPUSH
105837: EMPTY
105838: PPUSH
105839: CALL_OW 1
105843: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
105844: LD_ADDR_EXP 202
105848: PUSH
105849: LD_EXP 202
105853: PPUSH
105854: LD_EXP 202
105858: PUSH
105859: LD_INT 1
105861: PLUS
105862: PPUSH
105863: EMPTY
105864: PPUSH
105865: CALL_OW 1
105869: ST_TO_ADDR
// end ; if not IsOk ( i ) then
105870: LD_VAR 0 1
105874: PPUSH
105875: CALL_OW 302
105879: NOT
105880: IFFALSE 105893
// begin HackUnlinkAll ( i ) ;
105882: LD_VAR 0 1
105886: PPUSH
105887: CALL 105999 0 1
// continue ;
105891: GO 105773
// end ; HackCheckCapturedStatus ( i ) ;
105893: LD_VAR 0 1
105897: PPUSH
105898: CALL 106442 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
105902: LD_ADDR_VAR 0 2
105906: PUSH
105907: LD_INT 81
105909: PUSH
105910: LD_VAR 0 1
105914: PPUSH
105915: CALL_OW 255
105919: PUSH
105920: EMPTY
105921: LIST
105922: LIST
105923: PUSH
105924: LD_INT 33
105926: PUSH
105927: LD_INT 3
105929: PUSH
105930: EMPTY
105931: LIST
105932: LIST
105933: PUSH
105934: LD_INT 91
105936: PUSH
105937: LD_VAR 0 1
105941: PUSH
105942: LD_EXP 201
105946: PUSH
105947: EMPTY
105948: LIST
105949: LIST
105950: LIST
105951: PUSH
105952: LD_INT 50
105954: PUSH
105955: EMPTY
105956: LIST
105957: PUSH
105958: EMPTY
105959: LIST
105960: LIST
105961: LIST
105962: LIST
105963: PPUSH
105964: CALL_OW 69
105968: ST_TO_ADDR
// if not tmp then
105969: LD_VAR 0 2
105973: NOT
105974: IFFALSE 105978
// continue ;
105976: GO 105773
// HackLink ( i , tmp ) ;
105978: LD_VAR 0 1
105982: PPUSH
105983: LD_VAR 0 2
105987: PPUSH
105988: CALL 106135 0 2
// end ;
105992: GO 105773
105994: POP
105995: POP
// end ;
105996: PPOPN 2
105998: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105999: LD_INT 0
106001: PPUSH
106002: PPUSH
106003: PPUSH
// if not hack in hackTanks then
106004: LD_VAR 0 1
106008: PUSH
106009: LD_EXP 198
106013: IN
106014: NOT
106015: IFFALSE 106019
// exit ;
106017: GO 106130
// index := GetElementIndex ( hackTanks , hack ) ;
106019: LD_ADDR_VAR 0 4
106023: PUSH
106024: LD_EXP 198
106028: PPUSH
106029: LD_VAR 0 1
106033: PPUSH
106034: CALL 56259 0 2
106038: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106039: LD_EXP 199
106043: PUSH
106044: LD_VAR 0 4
106048: ARRAY
106049: IFFALSE 106130
// begin for i in hackTanksCaptured [ index ] do
106051: LD_ADDR_VAR 0 3
106055: PUSH
106056: LD_EXP 199
106060: PUSH
106061: LD_VAR 0 4
106065: ARRAY
106066: PUSH
106067: FOR_IN
106068: IFFALSE 106094
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106070: LD_VAR 0 3
106074: PUSH
106075: LD_INT 1
106077: ARRAY
106078: PPUSH
106079: LD_VAR 0 3
106083: PUSH
106084: LD_INT 2
106086: ARRAY
106087: PPUSH
106088: CALL_OW 235
106092: GO 106067
106094: POP
106095: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106096: LD_ADDR_EXP 199
106100: PUSH
106101: LD_EXP 199
106105: PPUSH
106106: LD_VAR 0 4
106110: PPUSH
106111: EMPTY
106112: PPUSH
106113: CALL_OW 1
106117: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
106118: LD_VAR 0 1
106122: PPUSH
106123: LD_INT 0
106125: PPUSH
106126: CALL_OW 505
// end ; end ;
106130: LD_VAR 0 2
106134: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
106135: LD_INT 0
106137: PPUSH
106138: PPUSH
106139: PPUSH
// if not hack in hackTanks or not vehicles then
106140: LD_VAR 0 1
106144: PUSH
106145: LD_EXP 198
106149: IN
106150: NOT
106151: PUSH
106152: LD_VAR 0 2
106156: NOT
106157: OR
106158: IFFALSE 106162
// exit ;
106160: GO 106437
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
106162: LD_ADDR_VAR 0 2
106166: PUSH
106167: LD_VAR 0 1
106171: PPUSH
106172: LD_VAR 0 2
106176: PPUSH
106177: LD_INT 1
106179: PPUSH
106180: LD_INT 1
106182: PPUSH
106183: CALL 56909 0 4
106187: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
106188: LD_ADDR_VAR 0 5
106192: PUSH
106193: LD_EXP 198
106197: PPUSH
106198: LD_VAR 0 1
106202: PPUSH
106203: CALL 56259 0 2
106207: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
106208: LD_EXP 199
106212: PUSH
106213: LD_VAR 0 5
106217: ARRAY
106218: PUSH
106219: LD_EXP 200
106223: LESS
106224: IFFALSE 106413
// begin for i := 1 to vehicles do
106226: LD_ADDR_VAR 0 4
106230: PUSH
106231: DOUBLE
106232: LD_INT 1
106234: DEC
106235: ST_TO_ADDR
106236: LD_VAR 0 2
106240: PUSH
106241: FOR_TO
106242: IFFALSE 106411
// begin if hackTanksCaptured [ index ] = hackLimit then
106244: LD_EXP 199
106248: PUSH
106249: LD_VAR 0 5
106253: ARRAY
106254: PUSH
106255: LD_EXP 200
106259: EQUAL
106260: IFFALSE 106264
// break ;
106262: GO 106411
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
106264: LD_ADDR_EXP 202
106268: PUSH
106269: LD_EXP 202
106273: PPUSH
106274: LD_VAR 0 5
106278: PPUSH
106279: LD_EXP 202
106283: PUSH
106284: LD_VAR 0 5
106288: ARRAY
106289: PUSH
106290: LD_INT 1
106292: PLUS
106293: PPUSH
106294: CALL_OW 1
106298: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
106299: LD_ADDR_EXP 199
106303: PUSH
106304: LD_EXP 199
106308: PPUSH
106309: LD_VAR 0 5
106313: PUSH
106314: LD_EXP 199
106318: PUSH
106319: LD_VAR 0 5
106323: ARRAY
106324: PUSH
106325: LD_INT 1
106327: PLUS
106328: PUSH
106329: EMPTY
106330: LIST
106331: LIST
106332: PPUSH
106333: LD_VAR 0 2
106337: PUSH
106338: LD_VAR 0 4
106342: ARRAY
106343: PUSH
106344: LD_VAR 0 2
106348: PUSH
106349: LD_VAR 0 4
106353: ARRAY
106354: PPUSH
106355: CALL_OW 255
106359: PUSH
106360: EMPTY
106361: LIST
106362: LIST
106363: PPUSH
106364: CALL 56474 0 3
106368: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
106369: LD_VAR 0 2
106373: PUSH
106374: LD_VAR 0 4
106378: ARRAY
106379: PPUSH
106380: LD_VAR 0 1
106384: PPUSH
106385: CALL_OW 255
106389: PPUSH
106390: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
106394: LD_VAR 0 2
106398: PUSH
106399: LD_VAR 0 4
106403: ARRAY
106404: PPUSH
106405: CALL_OW 141
// end ;
106409: GO 106241
106411: POP
106412: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106413: LD_VAR 0 1
106417: PPUSH
106418: LD_EXP 199
106422: PUSH
106423: LD_VAR 0 5
106427: ARRAY
106428: PUSH
106429: LD_INT 0
106431: PLUS
106432: PPUSH
106433: CALL_OW 505
// end ;
106437: LD_VAR 0 3
106441: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
106442: LD_INT 0
106444: PPUSH
106445: PPUSH
106446: PPUSH
106447: PPUSH
// if not hack in hackTanks then
106448: LD_VAR 0 1
106452: PUSH
106453: LD_EXP 198
106457: IN
106458: NOT
106459: IFFALSE 106463
// exit ;
106461: GO 106703
// index := GetElementIndex ( hackTanks , hack ) ;
106463: LD_ADDR_VAR 0 4
106467: PUSH
106468: LD_EXP 198
106472: PPUSH
106473: LD_VAR 0 1
106477: PPUSH
106478: CALL 56259 0 2
106482: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
106483: LD_ADDR_VAR 0 3
106487: PUSH
106488: DOUBLE
106489: LD_EXP 199
106493: PUSH
106494: LD_VAR 0 4
106498: ARRAY
106499: INC
106500: ST_TO_ADDR
106501: LD_INT 1
106503: PUSH
106504: FOR_DOWNTO
106505: IFFALSE 106677
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
106507: LD_ADDR_VAR 0 5
106511: PUSH
106512: LD_EXP 199
106516: PUSH
106517: LD_VAR 0 4
106521: ARRAY
106522: PUSH
106523: LD_VAR 0 3
106527: ARRAY
106528: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
106529: LD_VAR 0 5
106533: PUSH
106534: LD_INT 1
106536: ARRAY
106537: PPUSH
106538: CALL_OW 302
106542: NOT
106543: PUSH
106544: LD_VAR 0 5
106548: PUSH
106549: LD_INT 1
106551: ARRAY
106552: PPUSH
106553: CALL_OW 255
106557: PUSH
106558: LD_VAR 0 1
106562: PPUSH
106563: CALL_OW 255
106567: NONEQUAL
106568: OR
106569: IFFALSE 106675
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
106571: LD_VAR 0 5
106575: PUSH
106576: LD_INT 1
106578: ARRAY
106579: PPUSH
106580: CALL_OW 305
106584: PUSH
106585: LD_VAR 0 5
106589: PUSH
106590: LD_INT 1
106592: ARRAY
106593: PPUSH
106594: CALL_OW 255
106598: PUSH
106599: LD_VAR 0 1
106603: PPUSH
106604: CALL_OW 255
106608: EQUAL
106609: AND
106610: IFFALSE 106634
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
106612: LD_VAR 0 5
106616: PUSH
106617: LD_INT 1
106619: ARRAY
106620: PPUSH
106621: LD_VAR 0 5
106625: PUSH
106626: LD_INT 2
106628: ARRAY
106629: PPUSH
106630: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
106634: LD_ADDR_EXP 199
106638: PUSH
106639: LD_EXP 199
106643: PPUSH
106644: LD_VAR 0 4
106648: PPUSH
106649: LD_EXP 199
106653: PUSH
106654: LD_VAR 0 4
106658: ARRAY
106659: PPUSH
106660: LD_VAR 0 3
106664: PPUSH
106665: CALL_OW 3
106669: PPUSH
106670: CALL_OW 1
106674: ST_TO_ADDR
// end ; end ;
106675: GO 106504
106677: POP
106678: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106679: LD_VAR 0 1
106683: PPUSH
106684: LD_EXP 199
106688: PUSH
106689: LD_VAR 0 4
106693: ARRAY
106694: PUSH
106695: LD_INT 0
106697: PLUS
106698: PPUSH
106699: CALL_OW 505
// end ;
106703: LD_VAR 0 2
106707: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
106708: LD_INT 0
106710: PPUSH
106711: PPUSH
106712: PPUSH
106713: PPUSH
// if not hack in hackTanks then
106714: LD_VAR 0 1
106718: PUSH
106719: LD_EXP 198
106723: IN
106724: NOT
106725: IFFALSE 106729
// exit ;
106727: GO 106814
// index := GetElementIndex ( hackTanks , hack ) ;
106729: LD_ADDR_VAR 0 5
106733: PUSH
106734: LD_EXP 198
106738: PPUSH
106739: LD_VAR 0 1
106743: PPUSH
106744: CALL 56259 0 2
106748: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
106749: LD_ADDR_VAR 0 4
106753: PUSH
106754: DOUBLE
106755: LD_INT 1
106757: DEC
106758: ST_TO_ADDR
106759: LD_EXP 199
106763: PUSH
106764: LD_VAR 0 5
106768: ARRAY
106769: PUSH
106770: FOR_TO
106771: IFFALSE 106812
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
106773: LD_EXP 199
106777: PUSH
106778: LD_VAR 0 5
106782: ARRAY
106783: PUSH
106784: LD_VAR 0 4
106788: ARRAY
106789: PUSH
106790: LD_INT 1
106792: ARRAY
106793: PUSH
106794: LD_VAR 0 2
106798: EQUAL
106799: IFFALSE 106810
// KillUnit ( vehicle ) ;
106801: LD_VAR 0 2
106805: PPUSH
106806: CALL_OW 66
106810: GO 106770
106812: POP
106813: POP
// end ;
106814: LD_VAR 0 3
106818: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
106819: LD_EXP 203
106823: NOT
106824: IFFALSE 106859
106826: GO 106828
106828: DISABLE
// begin initMiner := true ;
106829: LD_ADDR_EXP 203
106833: PUSH
106834: LD_INT 1
106836: ST_TO_ADDR
// minersList := [ ] ;
106837: LD_ADDR_EXP 204
106841: PUSH
106842: EMPTY
106843: ST_TO_ADDR
// minerMinesList := [ ] ;
106844: LD_ADDR_EXP 205
106848: PUSH
106849: EMPTY
106850: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
106851: LD_ADDR_EXP 206
106855: PUSH
106856: LD_INT 5
106858: ST_TO_ADDR
// end ;
106859: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
106860: LD_EXP 203
106864: PUSH
106865: LD_INT 34
106867: PUSH
106868: LD_EXP 79
106872: PUSH
106873: EMPTY
106874: LIST
106875: LIST
106876: PPUSH
106877: CALL_OW 69
106881: AND
106882: IFFALSE 107345
106884: GO 106886
106886: DISABLE
106887: LD_INT 0
106889: PPUSH
106890: PPUSH
106891: PPUSH
106892: PPUSH
// begin enable ;
106893: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
106894: LD_ADDR_VAR 0 1
106898: PUSH
106899: LD_INT 34
106901: PUSH
106902: LD_EXP 79
106906: PUSH
106907: EMPTY
106908: LIST
106909: LIST
106910: PPUSH
106911: CALL_OW 69
106915: PUSH
106916: FOR_IN
106917: IFFALSE 106989
// begin if not i in minersList then
106919: LD_VAR 0 1
106923: PUSH
106924: LD_EXP 204
106928: IN
106929: NOT
106930: IFFALSE 106987
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
106932: LD_ADDR_EXP 204
106936: PUSH
106937: LD_EXP 204
106941: PPUSH
106942: LD_EXP 204
106946: PUSH
106947: LD_INT 1
106949: PLUS
106950: PPUSH
106951: LD_VAR 0 1
106955: PPUSH
106956: CALL_OW 1
106960: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
106961: LD_ADDR_EXP 205
106965: PUSH
106966: LD_EXP 205
106970: PPUSH
106971: LD_EXP 205
106975: PUSH
106976: LD_INT 1
106978: PLUS
106979: PPUSH
106980: EMPTY
106981: PPUSH
106982: CALL_OW 1
106986: ST_TO_ADDR
// end end ;
106987: GO 106916
106989: POP
106990: POP
// for i := minerMinesList downto 1 do
106991: LD_ADDR_VAR 0 1
106995: PUSH
106996: DOUBLE
106997: LD_EXP 205
107001: INC
107002: ST_TO_ADDR
107003: LD_INT 1
107005: PUSH
107006: FOR_DOWNTO
107007: IFFALSE 107343
// begin if IsLive ( minersList [ i ] ) then
107009: LD_EXP 204
107013: PUSH
107014: LD_VAR 0 1
107018: ARRAY
107019: PPUSH
107020: CALL_OW 300
107024: IFFALSE 107052
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107026: LD_EXP 204
107030: PUSH
107031: LD_VAR 0 1
107035: ARRAY
107036: PPUSH
107037: LD_EXP 205
107041: PUSH
107042: LD_VAR 0 1
107046: ARRAY
107047: PPUSH
107048: CALL_OW 505
// if not minerMinesList [ i ] then
107052: LD_EXP 205
107056: PUSH
107057: LD_VAR 0 1
107061: ARRAY
107062: NOT
107063: IFFALSE 107067
// continue ;
107065: GO 107006
// for j := minerMinesList [ i ] downto 1 do
107067: LD_ADDR_VAR 0 2
107071: PUSH
107072: DOUBLE
107073: LD_EXP 205
107077: PUSH
107078: LD_VAR 0 1
107082: ARRAY
107083: INC
107084: ST_TO_ADDR
107085: LD_INT 1
107087: PUSH
107088: FOR_DOWNTO
107089: IFFALSE 107339
// begin side := GetSide ( minersList [ i ] ) ;
107091: LD_ADDR_VAR 0 3
107095: PUSH
107096: LD_EXP 204
107100: PUSH
107101: LD_VAR 0 1
107105: ARRAY
107106: PPUSH
107107: CALL_OW 255
107111: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
107112: LD_ADDR_VAR 0 4
107116: PUSH
107117: LD_EXP 205
107121: PUSH
107122: LD_VAR 0 1
107126: ARRAY
107127: PUSH
107128: LD_VAR 0 2
107132: ARRAY
107133: PUSH
107134: LD_INT 1
107136: ARRAY
107137: PPUSH
107138: LD_EXP 205
107142: PUSH
107143: LD_VAR 0 1
107147: ARRAY
107148: PUSH
107149: LD_VAR 0 2
107153: ARRAY
107154: PUSH
107155: LD_INT 2
107157: ARRAY
107158: PPUSH
107159: CALL_OW 428
107163: ST_TO_ADDR
// if not tmp then
107164: LD_VAR 0 4
107168: NOT
107169: IFFALSE 107173
// continue ;
107171: GO 107088
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
107173: LD_VAR 0 4
107177: PUSH
107178: LD_INT 81
107180: PUSH
107181: LD_VAR 0 3
107185: PUSH
107186: EMPTY
107187: LIST
107188: LIST
107189: PPUSH
107190: CALL_OW 69
107194: IN
107195: PUSH
107196: LD_EXP 205
107200: PUSH
107201: LD_VAR 0 1
107205: ARRAY
107206: PUSH
107207: LD_VAR 0 2
107211: ARRAY
107212: PUSH
107213: LD_INT 1
107215: ARRAY
107216: PPUSH
107217: LD_EXP 205
107221: PUSH
107222: LD_VAR 0 1
107226: ARRAY
107227: PUSH
107228: LD_VAR 0 2
107232: ARRAY
107233: PUSH
107234: LD_INT 2
107236: ARRAY
107237: PPUSH
107238: CALL_OW 458
107242: AND
107243: IFFALSE 107337
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
107245: LD_EXP 205
107249: PUSH
107250: LD_VAR 0 1
107254: ARRAY
107255: PUSH
107256: LD_VAR 0 2
107260: ARRAY
107261: PUSH
107262: LD_INT 1
107264: ARRAY
107265: PPUSH
107266: LD_EXP 205
107270: PUSH
107271: LD_VAR 0 1
107275: ARRAY
107276: PUSH
107277: LD_VAR 0 2
107281: ARRAY
107282: PUSH
107283: LD_INT 2
107285: ARRAY
107286: PPUSH
107287: LD_VAR 0 3
107291: PPUSH
107292: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
107296: LD_ADDR_EXP 205
107300: PUSH
107301: LD_EXP 205
107305: PPUSH
107306: LD_VAR 0 1
107310: PPUSH
107311: LD_EXP 205
107315: PUSH
107316: LD_VAR 0 1
107320: ARRAY
107321: PPUSH
107322: LD_VAR 0 2
107326: PPUSH
107327: CALL_OW 3
107331: PPUSH
107332: CALL_OW 1
107336: ST_TO_ADDR
// end ; end ;
107337: GO 107088
107339: POP
107340: POP
// end ;
107341: GO 107006
107343: POP
107344: POP
// end ;
107345: PPOPN 4
107347: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
107348: LD_INT 0
107350: PPUSH
107351: PPUSH
// result := false ;
107352: LD_ADDR_VAR 0 4
107356: PUSH
107357: LD_INT 0
107359: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
107360: LD_VAR 0 1
107364: PPUSH
107365: CALL_OW 264
107369: PUSH
107370: LD_EXP 79
107374: EQUAL
107375: NOT
107376: IFFALSE 107380
// exit ;
107378: GO 107620
// index := GetElementIndex ( minersList , unit ) ;
107380: LD_ADDR_VAR 0 5
107384: PUSH
107385: LD_EXP 204
107389: PPUSH
107390: LD_VAR 0 1
107394: PPUSH
107395: CALL 56259 0 2
107399: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
107400: LD_EXP 205
107404: PUSH
107405: LD_VAR 0 5
107409: ARRAY
107410: PUSH
107411: LD_EXP 206
107415: GREATEREQUAL
107416: IFFALSE 107420
// exit ;
107418: GO 107620
// ComMoveXY ( unit , x , y ) ;
107420: LD_VAR 0 1
107424: PPUSH
107425: LD_VAR 0 2
107429: PPUSH
107430: LD_VAR 0 3
107434: PPUSH
107435: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107439: LD_INT 35
107441: PPUSH
107442: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
107446: LD_VAR 0 1
107450: PPUSH
107451: LD_VAR 0 2
107455: PPUSH
107456: LD_VAR 0 3
107460: PPUSH
107461: CALL 87031 0 3
107465: NOT
107466: PUSH
107467: LD_VAR 0 1
107471: PPUSH
107472: CALL_OW 314
107476: AND
107477: IFFALSE 107481
// exit ;
107479: GO 107620
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
107481: LD_VAR 0 2
107485: PPUSH
107486: LD_VAR 0 3
107490: PPUSH
107491: CALL_OW 428
107495: PUSH
107496: LD_VAR 0 1
107500: EQUAL
107501: PUSH
107502: LD_VAR 0 1
107506: PPUSH
107507: CALL_OW 314
107511: NOT
107512: AND
107513: IFFALSE 107439
// PlaySoundXY ( x , y , PlantMine ) ;
107515: LD_VAR 0 2
107519: PPUSH
107520: LD_VAR 0 3
107524: PPUSH
107525: LD_STRING PlantMine
107527: PPUSH
107528: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
107532: LD_VAR 0 2
107536: PPUSH
107537: LD_VAR 0 3
107541: PPUSH
107542: LD_VAR 0 1
107546: PPUSH
107547: CALL_OW 255
107551: PPUSH
107552: LD_INT 0
107554: PPUSH
107555: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
107559: LD_ADDR_EXP 205
107563: PUSH
107564: LD_EXP 205
107568: PPUSH
107569: LD_VAR 0 5
107573: PUSH
107574: LD_EXP 205
107578: PUSH
107579: LD_VAR 0 5
107583: ARRAY
107584: PUSH
107585: LD_INT 1
107587: PLUS
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PPUSH
107593: LD_VAR 0 2
107597: PUSH
107598: LD_VAR 0 3
107602: PUSH
107603: EMPTY
107604: LIST
107605: LIST
107606: PPUSH
107607: CALL 56474 0 3
107611: ST_TO_ADDR
// result := true ;
107612: LD_ADDR_VAR 0 4
107616: PUSH
107617: LD_INT 1
107619: ST_TO_ADDR
// end ;
107620: LD_VAR 0 4
107624: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
107625: LD_INT 0
107627: PPUSH
107628: PPUSH
107629: PPUSH
// if not unit in minersList then
107630: LD_VAR 0 1
107634: PUSH
107635: LD_EXP 204
107639: IN
107640: NOT
107641: IFFALSE 107645
// exit ;
107643: GO 108037
// index := GetElementIndex ( minersList , unit ) ;
107645: LD_ADDR_VAR 0 6
107649: PUSH
107650: LD_EXP 204
107654: PPUSH
107655: LD_VAR 0 1
107659: PPUSH
107660: CALL 56259 0 2
107664: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
107665: LD_ADDR_VAR 0 5
107669: PUSH
107670: DOUBLE
107671: LD_EXP 205
107675: PUSH
107676: LD_VAR 0 6
107680: ARRAY
107681: INC
107682: ST_TO_ADDR
107683: LD_INT 1
107685: PUSH
107686: FOR_DOWNTO
107687: IFFALSE 107848
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
107689: LD_EXP 205
107693: PUSH
107694: LD_VAR 0 6
107698: ARRAY
107699: PUSH
107700: LD_VAR 0 5
107704: ARRAY
107705: PUSH
107706: LD_INT 1
107708: ARRAY
107709: PUSH
107710: LD_VAR 0 2
107714: EQUAL
107715: PUSH
107716: LD_EXP 205
107720: PUSH
107721: LD_VAR 0 6
107725: ARRAY
107726: PUSH
107727: LD_VAR 0 5
107731: ARRAY
107732: PUSH
107733: LD_INT 2
107735: ARRAY
107736: PUSH
107737: LD_VAR 0 3
107741: EQUAL
107742: AND
107743: IFFALSE 107846
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107745: LD_EXP 205
107749: PUSH
107750: LD_VAR 0 6
107754: ARRAY
107755: PUSH
107756: LD_VAR 0 5
107760: ARRAY
107761: PUSH
107762: LD_INT 1
107764: ARRAY
107765: PPUSH
107766: LD_EXP 205
107770: PUSH
107771: LD_VAR 0 6
107775: ARRAY
107776: PUSH
107777: LD_VAR 0 5
107781: ARRAY
107782: PUSH
107783: LD_INT 2
107785: ARRAY
107786: PPUSH
107787: LD_VAR 0 1
107791: PPUSH
107792: CALL_OW 255
107796: PPUSH
107797: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107801: LD_ADDR_EXP 205
107805: PUSH
107806: LD_EXP 205
107810: PPUSH
107811: LD_VAR 0 6
107815: PPUSH
107816: LD_EXP 205
107820: PUSH
107821: LD_VAR 0 6
107825: ARRAY
107826: PPUSH
107827: LD_VAR 0 5
107831: PPUSH
107832: CALL_OW 3
107836: PPUSH
107837: CALL_OW 1
107841: ST_TO_ADDR
// exit ;
107842: POP
107843: POP
107844: GO 108037
// end ; end ;
107846: GO 107686
107848: POP
107849: POP
// for i := minerMinesList [ index ] downto 1 do
107850: LD_ADDR_VAR 0 5
107854: PUSH
107855: DOUBLE
107856: LD_EXP 205
107860: PUSH
107861: LD_VAR 0 6
107865: ARRAY
107866: INC
107867: ST_TO_ADDR
107868: LD_INT 1
107870: PUSH
107871: FOR_DOWNTO
107872: IFFALSE 108035
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
107874: LD_EXP 205
107878: PUSH
107879: LD_VAR 0 6
107883: ARRAY
107884: PUSH
107885: LD_VAR 0 5
107889: ARRAY
107890: PUSH
107891: LD_INT 1
107893: ARRAY
107894: PPUSH
107895: LD_EXP 205
107899: PUSH
107900: LD_VAR 0 6
107904: ARRAY
107905: PUSH
107906: LD_VAR 0 5
107910: ARRAY
107911: PUSH
107912: LD_INT 2
107914: ARRAY
107915: PPUSH
107916: LD_VAR 0 2
107920: PPUSH
107921: LD_VAR 0 3
107925: PPUSH
107926: CALL_OW 298
107930: PUSH
107931: LD_INT 6
107933: LESS
107934: IFFALSE 108033
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107936: LD_EXP 205
107940: PUSH
107941: LD_VAR 0 6
107945: ARRAY
107946: PUSH
107947: LD_VAR 0 5
107951: ARRAY
107952: PUSH
107953: LD_INT 1
107955: ARRAY
107956: PPUSH
107957: LD_EXP 205
107961: PUSH
107962: LD_VAR 0 6
107966: ARRAY
107967: PUSH
107968: LD_VAR 0 5
107972: ARRAY
107973: PUSH
107974: LD_INT 2
107976: ARRAY
107977: PPUSH
107978: LD_VAR 0 1
107982: PPUSH
107983: CALL_OW 255
107987: PPUSH
107988: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107992: LD_ADDR_EXP 205
107996: PUSH
107997: LD_EXP 205
108001: PPUSH
108002: LD_VAR 0 6
108006: PPUSH
108007: LD_EXP 205
108011: PUSH
108012: LD_VAR 0 6
108016: ARRAY
108017: PPUSH
108018: LD_VAR 0 5
108022: PPUSH
108023: CALL_OW 3
108027: PPUSH
108028: CALL_OW 1
108032: ST_TO_ADDR
// end ; end ;
108033: GO 107871
108035: POP
108036: POP
// end ;
108037: LD_VAR 0 4
108041: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108042: LD_INT 0
108044: PPUSH
108045: PPUSH
108046: PPUSH
108047: PPUSH
108048: PPUSH
108049: PPUSH
108050: PPUSH
108051: PPUSH
108052: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108053: LD_VAR 0 1
108057: PPUSH
108058: CALL_OW 264
108062: PUSH
108063: LD_EXP 79
108067: EQUAL
108068: NOT
108069: PUSH
108070: LD_VAR 0 1
108074: PUSH
108075: LD_EXP 204
108079: IN
108080: NOT
108081: OR
108082: IFFALSE 108086
// exit ;
108084: GO 108408
// index := GetElementIndex ( minersList , unit ) ;
108086: LD_ADDR_VAR 0 6
108090: PUSH
108091: LD_EXP 204
108095: PPUSH
108096: LD_VAR 0 1
108100: PPUSH
108101: CALL 56259 0 2
108105: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108106: LD_ADDR_VAR 0 8
108110: PUSH
108111: LD_EXP 206
108115: PUSH
108116: LD_EXP 205
108120: PUSH
108121: LD_VAR 0 6
108125: ARRAY
108126: MINUS
108127: ST_TO_ADDR
// if not minesFreeAmount then
108128: LD_VAR 0 8
108132: NOT
108133: IFFALSE 108137
// exit ;
108135: GO 108408
// tmp := [ ] ;
108137: LD_ADDR_VAR 0 7
108141: PUSH
108142: EMPTY
108143: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
108144: LD_ADDR_VAR 0 5
108148: PUSH
108149: DOUBLE
108150: LD_INT 1
108152: DEC
108153: ST_TO_ADDR
108154: LD_VAR 0 8
108158: PUSH
108159: FOR_TO
108160: IFFALSE 108355
// begin _d := rand ( 0 , 5 ) ;
108162: LD_ADDR_VAR 0 11
108166: PUSH
108167: LD_INT 0
108169: PPUSH
108170: LD_INT 5
108172: PPUSH
108173: CALL_OW 12
108177: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
108178: LD_ADDR_VAR 0 12
108182: PUSH
108183: LD_INT 2
108185: PPUSH
108186: LD_INT 6
108188: PPUSH
108189: CALL_OW 12
108193: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
108194: LD_ADDR_VAR 0 9
108198: PUSH
108199: LD_VAR 0 2
108203: PPUSH
108204: LD_VAR 0 11
108208: PPUSH
108209: LD_VAR 0 12
108213: PPUSH
108214: CALL_OW 272
108218: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
108219: LD_ADDR_VAR 0 10
108223: PUSH
108224: LD_VAR 0 3
108228: PPUSH
108229: LD_VAR 0 11
108233: PPUSH
108234: LD_VAR 0 12
108238: PPUSH
108239: CALL_OW 273
108243: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
108244: LD_VAR 0 9
108248: PPUSH
108249: LD_VAR 0 10
108253: PPUSH
108254: CALL_OW 488
108258: PUSH
108259: LD_VAR 0 9
108263: PUSH
108264: LD_VAR 0 10
108268: PUSH
108269: EMPTY
108270: LIST
108271: LIST
108272: PUSH
108273: LD_VAR 0 7
108277: IN
108278: NOT
108279: AND
108280: PUSH
108281: LD_VAR 0 9
108285: PPUSH
108286: LD_VAR 0 10
108290: PPUSH
108291: CALL_OW 458
108295: NOT
108296: AND
108297: IFFALSE 108339
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
108299: LD_ADDR_VAR 0 7
108303: PUSH
108304: LD_VAR 0 7
108308: PPUSH
108309: LD_VAR 0 7
108313: PUSH
108314: LD_INT 1
108316: PLUS
108317: PPUSH
108318: LD_VAR 0 9
108322: PUSH
108323: LD_VAR 0 10
108327: PUSH
108328: EMPTY
108329: LIST
108330: LIST
108331: PPUSH
108332: CALL_OW 1
108336: ST_TO_ADDR
108337: GO 108353
// i := i - 1 ;
108339: LD_ADDR_VAR 0 5
108343: PUSH
108344: LD_VAR 0 5
108348: PUSH
108349: LD_INT 1
108351: MINUS
108352: ST_TO_ADDR
// end ;
108353: GO 108159
108355: POP
108356: POP
// for i in tmp do
108357: LD_ADDR_VAR 0 5
108361: PUSH
108362: LD_VAR 0 7
108366: PUSH
108367: FOR_IN
108368: IFFALSE 108406
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
108370: LD_VAR 0 1
108374: PPUSH
108375: LD_VAR 0 5
108379: PUSH
108380: LD_INT 1
108382: ARRAY
108383: PPUSH
108384: LD_VAR 0 5
108388: PUSH
108389: LD_INT 2
108391: ARRAY
108392: PPUSH
108393: CALL 107348 0 3
108397: NOT
108398: IFFALSE 108404
// exit ;
108400: POP
108401: POP
108402: GO 108408
108404: GO 108367
108406: POP
108407: POP
// end ;
108408: LD_VAR 0 4
108412: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
108413: LD_INT 0
108415: PPUSH
108416: PPUSH
108417: PPUSH
108418: PPUSH
108419: PPUSH
108420: PPUSH
108421: PPUSH
// if not GetClass ( unit ) = class_sniper then
108422: LD_VAR 0 1
108426: PPUSH
108427: CALL_OW 257
108431: PUSH
108432: LD_INT 5
108434: EQUAL
108435: NOT
108436: IFFALSE 108440
// exit ;
108438: GO 108828
// dist := 8 ;
108440: LD_ADDR_VAR 0 5
108444: PUSH
108445: LD_INT 8
108447: ST_TO_ADDR
// viewRange := 12 ;
108448: LD_ADDR_VAR 0 7
108452: PUSH
108453: LD_INT 12
108455: ST_TO_ADDR
// side := GetSide ( unit ) ;
108456: LD_ADDR_VAR 0 6
108460: PUSH
108461: LD_VAR 0 1
108465: PPUSH
108466: CALL_OW 255
108470: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
108471: LD_INT 61
108473: PPUSH
108474: LD_VAR 0 6
108478: PPUSH
108479: CALL_OW 321
108483: PUSH
108484: LD_INT 2
108486: EQUAL
108487: IFFALSE 108497
// viewRange := 16 ;
108489: LD_ADDR_VAR 0 7
108493: PUSH
108494: LD_INT 16
108496: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
108497: LD_VAR 0 1
108501: PPUSH
108502: LD_VAR 0 2
108506: PPUSH
108507: LD_VAR 0 3
108511: PPUSH
108512: CALL_OW 297
108516: PUSH
108517: LD_VAR 0 5
108521: GREATER
108522: IFFALSE 108601
// begin ComMoveXY ( unit , x , y ) ;
108524: LD_VAR 0 1
108528: PPUSH
108529: LD_VAR 0 2
108533: PPUSH
108534: LD_VAR 0 3
108538: PPUSH
108539: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108543: LD_INT 35
108545: PPUSH
108546: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
108550: LD_VAR 0 1
108554: PPUSH
108555: LD_VAR 0 2
108559: PPUSH
108560: LD_VAR 0 3
108564: PPUSH
108565: CALL 87031 0 3
108569: NOT
108570: IFFALSE 108574
// exit ;
108572: GO 108828
// until GetDistUnitXY ( unit , x , y ) < dist ;
108574: LD_VAR 0 1
108578: PPUSH
108579: LD_VAR 0 2
108583: PPUSH
108584: LD_VAR 0 3
108588: PPUSH
108589: CALL_OW 297
108593: PUSH
108594: LD_VAR 0 5
108598: LESS
108599: IFFALSE 108543
// end ; ComTurnXY ( unit , x , y ) ;
108601: LD_VAR 0 1
108605: PPUSH
108606: LD_VAR 0 2
108610: PPUSH
108611: LD_VAR 0 3
108615: PPUSH
108616: CALL_OW 118
// wait ( 5 ) ;
108620: LD_INT 5
108622: PPUSH
108623: CALL_OW 67
// _d := GetDir ( unit ) ;
108627: LD_ADDR_VAR 0 10
108631: PUSH
108632: LD_VAR 0 1
108636: PPUSH
108637: CALL_OW 254
108641: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
108642: LD_ADDR_VAR 0 8
108646: PUSH
108647: LD_VAR 0 1
108651: PPUSH
108652: CALL_OW 250
108656: PPUSH
108657: LD_VAR 0 10
108661: PPUSH
108662: LD_VAR 0 5
108666: PPUSH
108667: CALL_OW 272
108671: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
108672: LD_ADDR_VAR 0 9
108676: PUSH
108677: LD_VAR 0 1
108681: PPUSH
108682: CALL_OW 251
108686: PPUSH
108687: LD_VAR 0 10
108691: PPUSH
108692: LD_VAR 0 5
108696: PPUSH
108697: CALL_OW 273
108701: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108702: LD_VAR 0 8
108706: PPUSH
108707: LD_VAR 0 9
108711: PPUSH
108712: CALL_OW 488
108716: NOT
108717: IFFALSE 108721
// exit ;
108719: GO 108828
// ComAnimCustom ( unit , 1 ) ;
108721: LD_VAR 0 1
108725: PPUSH
108726: LD_INT 1
108728: PPUSH
108729: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
108733: LD_VAR 0 8
108737: PPUSH
108738: LD_VAR 0 9
108742: PPUSH
108743: LD_VAR 0 6
108747: PPUSH
108748: LD_VAR 0 7
108752: PPUSH
108753: CALL_OW 330
// repeat wait ( 1 ) ;
108757: LD_INT 1
108759: PPUSH
108760: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
108764: LD_VAR 0 1
108768: PPUSH
108769: CALL_OW 316
108773: PUSH
108774: LD_VAR 0 1
108778: PPUSH
108779: CALL_OW 314
108783: OR
108784: PUSH
108785: LD_VAR 0 1
108789: PPUSH
108790: CALL_OW 302
108794: NOT
108795: OR
108796: PUSH
108797: LD_VAR 0 1
108801: PPUSH
108802: CALL_OW 301
108806: OR
108807: IFFALSE 108757
// RemoveSeeing ( _x , _y , side ) ;
108809: LD_VAR 0 8
108813: PPUSH
108814: LD_VAR 0 9
108818: PPUSH
108819: LD_VAR 0 6
108823: PPUSH
108824: CALL_OW 331
// end ; end_of_file
108828: LD_VAR 0 4
108832: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
108833: LD_INT 0
108835: PPUSH
108836: PPUSH
108837: PPUSH
108838: PPUSH
108839: PPUSH
108840: PPUSH
108841: PPUSH
108842: PPUSH
108843: PPUSH
108844: PPUSH
108845: PPUSH
108846: PPUSH
108847: PPUSH
108848: PPUSH
108849: PPUSH
108850: PPUSH
108851: PPUSH
108852: PPUSH
108853: PPUSH
108854: PPUSH
108855: PPUSH
108856: PPUSH
108857: PPUSH
108858: PPUSH
108859: PPUSH
108860: PPUSH
108861: PPUSH
108862: PPUSH
108863: PPUSH
108864: PPUSH
108865: PPUSH
108866: PPUSH
108867: PPUSH
108868: PPUSH
// if not list then
108869: LD_VAR 0 1
108873: NOT
108874: IFFALSE 108878
// exit ;
108876: GO 113537
// base := list [ 1 ] ;
108878: LD_ADDR_VAR 0 3
108882: PUSH
108883: LD_VAR 0 1
108887: PUSH
108888: LD_INT 1
108890: ARRAY
108891: ST_TO_ADDR
// group := list [ 2 ] ;
108892: LD_ADDR_VAR 0 4
108896: PUSH
108897: LD_VAR 0 1
108901: PUSH
108902: LD_INT 2
108904: ARRAY
108905: ST_TO_ADDR
// path := list [ 3 ] ;
108906: LD_ADDR_VAR 0 5
108910: PUSH
108911: LD_VAR 0 1
108915: PUSH
108916: LD_INT 3
108918: ARRAY
108919: ST_TO_ADDR
// flags := list [ 4 ] ;
108920: LD_ADDR_VAR 0 6
108924: PUSH
108925: LD_VAR 0 1
108929: PUSH
108930: LD_INT 4
108932: ARRAY
108933: ST_TO_ADDR
// mined := [ ] ;
108934: LD_ADDR_VAR 0 27
108938: PUSH
108939: EMPTY
108940: ST_TO_ADDR
// bombed := [ ] ;
108941: LD_ADDR_VAR 0 28
108945: PUSH
108946: EMPTY
108947: ST_TO_ADDR
// healers := [ ] ;
108948: LD_ADDR_VAR 0 31
108952: PUSH
108953: EMPTY
108954: ST_TO_ADDR
// to_heal := [ ] ;
108955: LD_ADDR_VAR 0 30
108959: PUSH
108960: EMPTY
108961: ST_TO_ADDR
// repairs := [ ] ;
108962: LD_ADDR_VAR 0 33
108966: PUSH
108967: EMPTY
108968: ST_TO_ADDR
// to_repair := [ ] ;
108969: LD_ADDR_VAR 0 32
108973: PUSH
108974: EMPTY
108975: ST_TO_ADDR
// if not group or not path then
108976: LD_VAR 0 4
108980: NOT
108981: PUSH
108982: LD_VAR 0 5
108986: NOT
108987: OR
108988: IFFALSE 108992
// exit ;
108990: GO 113537
// side := GetSide ( group [ 1 ] ) ;
108992: LD_ADDR_VAR 0 35
108996: PUSH
108997: LD_VAR 0 4
109001: PUSH
109002: LD_INT 1
109004: ARRAY
109005: PPUSH
109006: CALL_OW 255
109010: ST_TO_ADDR
// if flags then
109011: LD_VAR 0 6
109015: IFFALSE 109159
// begin f_ignore_area := flags [ 1 ] ;
109017: LD_ADDR_VAR 0 17
109021: PUSH
109022: LD_VAR 0 6
109026: PUSH
109027: LD_INT 1
109029: ARRAY
109030: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109031: LD_ADDR_VAR 0 18
109035: PUSH
109036: LD_VAR 0 6
109040: PUSH
109041: LD_INT 2
109043: ARRAY
109044: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109045: LD_ADDR_VAR 0 19
109049: PUSH
109050: LD_VAR 0 6
109054: PUSH
109055: LD_INT 3
109057: ARRAY
109058: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109059: LD_ADDR_VAR 0 20
109063: PUSH
109064: LD_VAR 0 6
109068: PUSH
109069: LD_INT 4
109071: ARRAY
109072: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109073: LD_ADDR_VAR 0 21
109077: PUSH
109078: LD_VAR 0 6
109082: PUSH
109083: LD_INT 5
109085: ARRAY
109086: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109087: LD_ADDR_VAR 0 22
109091: PUSH
109092: LD_VAR 0 6
109096: PUSH
109097: LD_INT 6
109099: ARRAY
109100: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109101: LD_ADDR_VAR 0 23
109105: PUSH
109106: LD_VAR 0 6
109110: PUSH
109111: LD_INT 7
109113: ARRAY
109114: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
109115: LD_ADDR_VAR 0 24
109119: PUSH
109120: LD_VAR 0 6
109124: PUSH
109125: LD_INT 8
109127: ARRAY
109128: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
109129: LD_ADDR_VAR 0 25
109133: PUSH
109134: LD_VAR 0 6
109138: PUSH
109139: LD_INT 9
109141: ARRAY
109142: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
109143: LD_ADDR_VAR 0 26
109147: PUSH
109148: LD_VAR 0 6
109152: PUSH
109153: LD_INT 10
109155: ARRAY
109156: ST_TO_ADDR
// end else
109157: GO 109239
// begin f_ignore_area := false ;
109159: LD_ADDR_VAR 0 17
109163: PUSH
109164: LD_INT 0
109166: ST_TO_ADDR
// f_capture := false ;
109167: LD_ADDR_VAR 0 18
109171: PUSH
109172: LD_INT 0
109174: ST_TO_ADDR
// f_ignore_civ := false ;
109175: LD_ADDR_VAR 0 19
109179: PUSH
109180: LD_INT 0
109182: ST_TO_ADDR
// f_murder := false ;
109183: LD_ADDR_VAR 0 20
109187: PUSH
109188: LD_INT 0
109190: ST_TO_ADDR
// f_mines := false ;
109191: LD_ADDR_VAR 0 21
109195: PUSH
109196: LD_INT 0
109198: ST_TO_ADDR
// f_repair := false ;
109199: LD_ADDR_VAR 0 22
109203: PUSH
109204: LD_INT 0
109206: ST_TO_ADDR
// f_heal := false ;
109207: LD_ADDR_VAR 0 23
109211: PUSH
109212: LD_INT 0
109214: ST_TO_ADDR
// f_spacetime := false ;
109215: LD_ADDR_VAR 0 24
109219: PUSH
109220: LD_INT 0
109222: ST_TO_ADDR
// f_attack_depot := false ;
109223: LD_ADDR_VAR 0 25
109227: PUSH
109228: LD_INT 0
109230: ST_TO_ADDR
// f_crawl := false ;
109231: LD_ADDR_VAR 0 26
109235: PUSH
109236: LD_INT 0
109238: ST_TO_ADDR
// end ; if f_heal then
109239: LD_VAR 0 23
109243: IFFALSE 109270
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
109245: LD_ADDR_VAR 0 31
109249: PUSH
109250: LD_VAR 0 4
109254: PPUSH
109255: LD_INT 25
109257: PUSH
109258: LD_INT 4
109260: PUSH
109261: EMPTY
109262: LIST
109263: LIST
109264: PPUSH
109265: CALL_OW 72
109269: ST_TO_ADDR
// if f_repair then
109270: LD_VAR 0 22
109274: IFFALSE 109301
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
109276: LD_ADDR_VAR 0 33
109280: PUSH
109281: LD_VAR 0 4
109285: PPUSH
109286: LD_INT 25
109288: PUSH
109289: LD_INT 3
109291: PUSH
109292: EMPTY
109293: LIST
109294: LIST
109295: PPUSH
109296: CALL_OW 72
109300: ST_TO_ADDR
// units_path := [ ] ;
109301: LD_ADDR_VAR 0 16
109305: PUSH
109306: EMPTY
109307: ST_TO_ADDR
// for i = 1 to group do
109308: LD_ADDR_VAR 0 7
109312: PUSH
109313: DOUBLE
109314: LD_INT 1
109316: DEC
109317: ST_TO_ADDR
109318: LD_VAR 0 4
109322: PUSH
109323: FOR_TO
109324: IFFALSE 109353
// units_path := Replace ( units_path , i , path ) ;
109326: LD_ADDR_VAR 0 16
109330: PUSH
109331: LD_VAR 0 16
109335: PPUSH
109336: LD_VAR 0 7
109340: PPUSH
109341: LD_VAR 0 5
109345: PPUSH
109346: CALL_OW 1
109350: ST_TO_ADDR
109351: GO 109323
109353: POP
109354: POP
// repeat for i = group downto 1 do
109355: LD_ADDR_VAR 0 7
109359: PUSH
109360: DOUBLE
109361: LD_VAR 0 4
109365: INC
109366: ST_TO_ADDR
109367: LD_INT 1
109369: PUSH
109370: FOR_DOWNTO
109371: IFFALSE 113493
// begin wait ( 5 ) ;
109373: LD_INT 5
109375: PPUSH
109376: CALL_OW 67
// tmp := [ ] ;
109380: LD_ADDR_VAR 0 14
109384: PUSH
109385: EMPTY
109386: ST_TO_ADDR
// attacking := false ;
109387: LD_ADDR_VAR 0 29
109391: PUSH
109392: LD_INT 0
109394: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
109395: LD_VAR 0 4
109399: PUSH
109400: LD_VAR 0 7
109404: ARRAY
109405: PPUSH
109406: CALL_OW 301
109410: PUSH
109411: LD_VAR 0 4
109415: PUSH
109416: LD_VAR 0 7
109420: ARRAY
109421: NOT
109422: OR
109423: IFFALSE 109532
// begin if GetType ( group [ i ] ) = unit_human then
109425: LD_VAR 0 4
109429: PUSH
109430: LD_VAR 0 7
109434: ARRAY
109435: PPUSH
109436: CALL_OW 247
109440: PUSH
109441: LD_INT 1
109443: EQUAL
109444: IFFALSE 109490
// begin to_heal := to_heal diff group [ i ] ;
109446: LD_ADDR_VAR 0 30
109450: PUSH
109451: LD_VAR 0 30
109455: PUSH
109456: LD_VAR 0 4
109460: PUSH
109461: LD_VAR 0 7
109465: ARRAY
109466: DIFF
109467: ST_TO_ADDR
// healers := healers diff group [ i ] ;
109468: LD_ADDR_VAR 0 31
109472: PUSH
109473: LD_VAR 0 31
109477: PUSH
109478: LD_VAR 0 4
109482: PUSH
109483: LD_VAR 0 7
109487: ARRAY
109488: DIFF
109489: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
109490: LD_ADDR_VAR 0 4
109494: PUSH
109495: LD_VAR 0 4
109499: PPUSH
109500: LD_VAR 0 7
109504: PPUSH
109505: CALL_OW 3
109509: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
109510: LD_ADDR_VAR 0 16
109514: PUSH
109515: LD_VAR 0 16
109519: PPUSH
109520: LD_VAR 0 7
109524: PPUSH
109525: CALL_OW 3
109529: ST_TO_ADDR
// continue ;
109530: GO 109370
// end ; if f_repair then
109532: LD_VAR 0 22
109536: IFFALSE 110025
// begin if GetType ( group [ i ] ) = unit_vehicle then
109538: LD_VAR 0 4
109542: PUSH
109543: LD_VAR 0 7
109547: ARRAY
109548: PPUSH
109549: CALL_OW 247
109553: PUSH
109554: LD_INT 2
109556: EQUAL
109557: IFFALSE 109747
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
109559: LD_VAR 0 4
109563: PUSH
109564: LD_VAR 0 7
109568: ARRAY
109569: PPUSH
109570: CALL_OW 256
109574: PUSH
109575: LD_INT 700
109577: LESS
109578: PUSH
109579: LD_VAR 0 4
109583: PUSH
109584: LD_VAR 0 7
109588: ARRAY
109589: PUSH
109590: LD_VAR 0 32
109594: IN
109595: NOT
109596: AND
109597: IFFALSE 109621
// to_repair := to_repair union group [ i ] ;
109599: LD_ADDR_VAR 0 32
109603: PUSH
109604: LD_VAR 0 32
109608: PUSH
109609: LD_VAR 0 4
109613: PUSH
109614: LD_VAR 0 7
109618: ARRAY
109619: UNION
109620: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
109621: LD_VAR 0 4
109625: PUSH
109626: LD_VAR 0 7
109630: ARRAY
109631: PPUSH
109632: CALL_OW 256
109636: PUSH
109637: LD_INT 1000
109639: EQUAL
109640: PUSH
109641: LD_VAR 0 4
109645: PUSH
109646: LD_VAR 0 7
109650: ARRAY
109651: PUSH
109652: LD_VAR 0 32
109656: IN
109657: AND
109658: IFFALSE 109682
// to_repair := to_repair diff group [ i ] ;
109660: LD_ADDR_VAR 0 32
109664: PUSH
109665: LD_VAR 0 32
109669: PUSH
109670: LD_VAR 0 4
109674: PUSH
109675: LD_VAR 0 7
109679: ARRAY
109680: DIFF
109681: ST_TO_ADDR
// if group [ i ] in to_repair then
109682: LD_VAR 0 4
109686: PUSH
109687: LD_VAR 0 7
109691: ARRAY
109692: PUSH
109693: LD_VAR 0 32
109697: IN
109698: IFFALSE 109745
// begin if not IsInArea ( group [ i ] , f_repair ) then
109700: LD_VAR 0 4
109704: PUSH
109705: LD_VAR 0 7
109709: ARRAY
109710: PPUSH
109711: LD_VAR 0 22
109715: PPUSH
109716: CALL_OW 308
109720: NOT
109721: IFFALSE 109743
// ComMoveToArea ( group [ i ] , f_repair ) ;
109723: LD_VAR 0 4
109727: PUSH
109728: LD_VAR 0 7
109732: ARRAY
109733: PPUSH
109734: LD_VAR 0 22
109738: PPUSH
109739: CALL_OW 113
// continue ;
109743: GO 109370
// end ; end else
109745: GO 110025
// if group [ i ] in repairs then
109747: LD_VAR 0 4
109751: PUSH
109752: LD_VAR 0 7
109756: ARRAY
109757: PUSH
109758: LD_VAR 0 33
109762: IN
109763: IFFALSE 110025
// begin if IsInUnit ( group [ i ] ) then
109765: LD_VAR 0 4
109769: PUSH
109770: LD_VAR 0 7
109774: ARRAY
109775: PPUSH
109776: CALL_OW 310
109780: IFFALSE 109848
// begin z := IsInUnit ( group [ i ] ) ;
109782: LD_ADDR_VAR 0 13
109786: PUSH
109787: LD_VAR 0 4
109791: PUSH
109792: LD_VAR 0 7
109796: ARRAY
109797: PPUSH
109798: CALL_OW 310
109802: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
109803: LD_VAR 0 13
109807: PUSH
109808: LD_VAR 0 32
109812: IN
109813: PUSH
109814: LD_VAR 0 13
109818: PPUSH
109819: LD_VAR 0 22
109823: PPUSH
109824: CALL_OW 308
109828: AND
109829: IFFALSE 109846
// ComExitVehicle ( group [ i ] ) ;
109831: LD_VAR 0 4
109835: PUSH
109836: LD_VAR 0 7
109840: ARRAY
109841: PPUSH
109842: CALL_OW 121
// end else
109846: GO 110025
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
109848: LD_ADDR_VAR 0 13
109852: PUSH
109853: LD_VAR 0 4
109857: PPUSH
109858: LD_INT 95
109860: PUSH
109861: LD_VAR 0 22
109865: PUSH
109866: EMPTY
109867: LIST
109868: LIST
109869: PUSH
109870: LD_INT 58
109872: PUSH
109873: EMPTY
109874: LIST
109875: PUSH
109876: EMPTY
109877: LIST
109878: LIST
109879: PPUSH
109880: CALL_OW 72
109884: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
109885: LD_VAR 0 4
109889: PUSH
109890: LD_VAR 0 7
109894: ARRAY
109895: PPUSH
109896: CALL_OW 314
109900: NOT
109901: IFFALSE 110023
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
109903: LD_ADDR_VAR 0 10
109907: PUSH
109908: LD_VAR 0 13
109912: PPUSH
109913: LD_VAR 0 4
109917: PUSH
109918: LD_VAR 0 7
109922: ARRAY
109923: PPUSH
109924: CALL_OW 74
109928: ST_TO_ADDR
// if not x then
109929: LD_VAR 0 10
109933: NOT
109934: IFFALSE 109938
// continue ;
109936: GO 109370
// if GetLives ( x ) < 1000 then
109938: LD_VAR 0 10
109942: PPUSH
109943: CALL_OW 256
109947: PUSH
109948: LD_INT 1000
109950: LESS
109951: IFFALSE 109975
// ComRepairVehicle ( group [ i ] , x ) else
109953: LD_VAR 0 4
109957: PUSH
109958: LD_VAR 0 7
109962: ARRAY
109963: PPUSH
109964: LD_VAR 0 10
109968: PPUSH
109969: CALL_OW 129
109973: GO 110023
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
109975: LD_VAR 0 23
109979: PUSH
109980: LD_VAR 0 4
109984: PUSH
109985: LD_VAR 0 7
109989: ARRAY
109990: PPUSH
109991: CALL_OW 256
109995: PUSH
109996: LD_INT 1000
109998: LESS
109999: AND
110000: NOT
110001: IFFALSE 110023
// ComEnterUnit ( group [ i ] , x ) ;
110003: LD_VAR 0 4
110007: PUSH
110008: LD_VAR 0 7
110012: ARRAY
110013: PPUSH
110014: LD_VAR 0 10
110018: PPUSH
110019: CALL_OW 120
// end ; continue ;
110023: GO 109370
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110025: LD_VAR 0 23
110029: PUSH
110030: LD_VAR 0 4
110034: PUSH
110035: LD_VAR 0 7
110039: ARRAY
110040: PPUSH
110041: CALL_OW 247
110045: PUSH
110046: LD_INT 1
110048: EQUAL
110049: AND
110050: IFFALSE 110528
// begin if group [ i ] in healers then
110052: LD_VAR 0 4
110056: PUSH
110057: LD_VAR 0 7
110061: ARRAY
110062: PUSH
110063: LD_VAR 0 31
110067: IN
110068: IFFALSE 110341
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110070: LD_VAR 0 4
110074: PUSH
110075: LD_VAR 0 7
110079: ARRAY
110080: PPUSH
110081: LD_VAR 0 23
110085: PPUSH
110086: CALL_OW 308
110090: NOT
110091: PUSH
110092: LD_VAR 0 4
110096: PUSH
110097: LD_VAR 0 7
110101: ARRAY
110102: PPUSH
110103: CALL_OW 314
110107: NOT
110108: AND
110109: IFFALSE 110133
// ComMoveToArea ( group [ i ] , f_heal ) else
110111: LD_VAR 0 4
110115: PUSH
110116: LD_VAR 0 7
110120: ARRAY
110121: PPUSH
110122: LD_VAR 0 23
110126: PPUSH
110127: CALL_OW 113
110131: GO 110339
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
110133: LD_VAR 0 4
110137: PUSH
110138: LD_VAR 0 7
110142: ARRAY
110143: PPUSH
110144: CALL 85554 0 1
110148: PPUSH
110149: CALL_OW 256
110153: PUSH
110154: LD_INT 1000
110156: EQUAL
110157: IFFALSE 110176
// ComStop ( group [ i ] ) else
110159: LD_VAR 0 4
110163: PUSH
110164: LD_VAR 0 7
110168: ARRAY
110169: PPUSH
110170: CALL_OW 141
110174: GO 110339
// if not HasTask ( group [ i ] ) and to_heal then
110176: LD_VAR 0 4
110180: PUSH
110181: LD_VAR 0 7
110185: ARRAY
110186: PPUSH
110187: CALL_OW 314
110191: NOT
110192: PUSH
110193: LD_VAR 0 30
110197: AND
110198: IFFALSE 110339
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
110200: LD_ADDR_VAR 0 13
110204: PUSH
110205: LD_VAR 0 30
110209: PPUSH
110210: LD_INT 3
110212: PUSH
110213: LD_INT 54
110215: PUSH
110216: EMPTY
110217: LIST
110218: PUSH
110219: EMPTY
110220: LIST
110221: LIST
110222: PPUSH
110223: CALL_OW 72
110227: PPUSH
110228: LD_VAR 0 4
110232: PUSH
110233: LD_VAR 0 7
110237: ARRAY
110238: PPUSH
110239: CALL_OW 74
110243: ST_TO_ADDR
// if z then
110244: LD_VAR 0 13
110248: IFFALSE 110339
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
110250: LD_INT 91
110252: PUSH
110253: LD_VAR 0 13
110257: PUSH
110258: LD_INT 10
110260: PUSH
110261: EMPTY
110262: LIST
110263: LIST
110264: LIST
110265: PUSH
110266: LD_INT 81
110268: PUSH
110269: LD_VAR 0 13
110273: PPUSH
110274: CALL_OW 255
110278: PUSH
110279: EMPTY
110280: LIST
110281: LIST
110282: PUSH
110283: EMPTY
110284: LIST
110285: LIST
110286: PPUSH
110287: CALL_OW 69
110291: PUSH
110292: LD_INT 0
110294: EQUAL
110295: IFFALSE 110319
// ComHeal ( group [ i ] , z ) else
110297: LD_VAR 0 4
110301: PUSH
110302: LD_VAR 0 7
110306: ARRAY
110307: PPUSH
110308: LD_VAR 0 13
110312: PPUSH
110313: CALL_OW 128
110317: GO 110339
// ComMoveToArea ( group [ i ] , f_heal ) ;
110319: LD_VAR 0 4
110323: PUSH
110324: LD_VAR 0 7
110328: ARRAY
110329: PPUSH
110330: LD_VAR 0 23
110334: PPUSH
110335: CALL_OW 113
// end ; continue ;
110339: GO 109370
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
110341: LD_VAR 0 4
110345: PUSH
110346: LD_VAR 0 7
110350: ARRAY
110351: PPUSH
110352: CALL_OW 256
110356: PUSH
110357: LD_INT 700
110359: LESS
110360: PUSH
110361: LD_VAR 0 4
110365: PUSH
110366: LD_VAR 0 7
110370: ARRAY
110371: PUSH
110372: LD_VAR 0 30
110376: IN
110377: NOT
110378: AND
110379: IFFALSE 110403
// to_heal := to_heal union group [ i ] ;
110381: LD_ADDR_VAR 0 30
110385: PUSH
110386: LD_VAR 0 30
110390: PUSH
110391: LD_VAR 0 4
110395: PUSH
110396: LD_VAR 0 7
110400: ARRAY
110401: UNION
110402: ST_TO_ADDR
// if group [ i ] in to_heal then
110403: LD_VAR 0 4
110407: PUSH
110408: LD_VAR 0 7
110412: ARRAY
110413: PUSH
110414: LD_VAR 0 30
110418: IN
110419: IFFALSE 110528
// begin if GetLives ( group [ i ] ) = 1000 then
110421: LD_VAR 0 4
110425: PUSH
110426: LD_VAR 0 7
110430: ARRAY
110431: PPUSH
110432: CALL_OW 256
110436: PUSH
110437: LD_INT 1000
110439: EQUAL
110440: IFFALSE 110466
// to_heal := to_heal diff group [ i ] else
110442: LD_ADDR_VAR 0 30
110446: PUSH
110447: LD_VAR 0 30
110451: PUSH
110452: LD_VAR 0 4
110456: PUSH
110457: LD_VAR 0 7
110461: ARRAY
110462: DIFF
110463: ST_TO_ADDR
110464: GO 110528
// begin if not IsInArea ( group [ i ] , to_heal ) then
110466: LD_VAR 0 4
110470: PUSH
110471: LD_VAR 0 7
110475: ARRAY
110476: PPUSH
110477: LD_VAR 0 30
110481: PPUSH
110482: CALL_OW 308
110486: NOT
110487: IFFALSE 110511
// ComMoveToArea ( group [ i ] , f_heal ) else
110489: LD_VAR 0 4
110493: PUSH
110494: LD_VAR 0 7
110498: ARRAY
110499: PPUSH
110500: LD_VAR 0 23
110504: PPUSH
110505: CALL_OW 113
110509: GO 110526
// ComHold ( group [ i ] ) ;
110511: LD_VAR 0 4
110515: PUSH
110516: LD_VAR 0 7
110520: ARRAY
110521: PPUSH
110522: CALL_OW 140
// continue ;
110526: GO 109370
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
110528: LD_VAR 0 4
110532: PUSH
110533: LD_VAR 0 7
110537: ARRAY
110538: PPUSH
110539: LD_INT 10
110541: PPUSH
110542: CALL 83974 0 2
110546: NOT
110547: PUSH
110548: LD_VAR 0 16
110552: PUSH
110553: LD_VAR 0 7
110557: ARRAY
110558: PUSH
110559: EMPTY
110560: EQUAL
110561: NOT
110562: AND
110563: IFFALSE 110829
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
110565: LD_VAR 0 4
110569: PUSH
110570: LD_VAR 0 7
110574: ARRAY
110575: PPUSH
110576: CALL_OW 262
110580: PUSH
110581: LD_INT 1
110583: PUSH
110584: LD_INT 2
110586: PUSH
110587: EMPTY
110588: LIST
110589: LIST
110590: IN
110591: IFFALSE 110632
// if GetFuel ( group [ i ] ) < 10 then
110593: LD_VAR 0 4
110597: PUSH
110598: LD_VAR 0 7
110602: ARRAY
110603: PPUSH
110604: CALL_OW 261
110608: PUSH
110609: LD_INT 10
110611: LESS
110612: IFFALSE 110632
// SetFuel ( group [ i ] , 12 ) ;
110614: LD_VAR 0 4
110618: PUSH
110619: LD_VAR 0 7
110623: ARRAY
110624: PPUSH
110625: LD_INT 12
110627: PPUSH
110628: CALL_OW 240
// if units_path [ i ] then
110632: LD_VAR 0 16
110636: PUSH
110637: LD_VAR 0 7
110641: ARRAY
110642: IFFALSE 110827
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
110644: LD_VAR 0 4
110648: PUSH
110649: LD_VAR 0 7
110653: ARRAY
110654: PPUSH
110655: LD_VAR 0 16
110659: PUSH
110660: LD_VAR 0 7
110664: ARRAY
110665: PUSH
110666: LD_INT 1
110668: ARRAY
110669: PUSH
110670: LD_INT 1
110672: ARRAY
110673: PPUSH
110674: LD_VAR 0 16
110678: PUSH
110679: LD_VAR 0 7
110683: ARRAY
110684: PUSH
110685: LD_INT 1
110687: ARRAY
110688: PUSH
110689: LD_INT 2
110691: ARRAY
110692: PPUSH
110693: CALL_OW 297
110697: PUSH
110698: LD_INT 6
110700: GREATER
110701: IFFALSE 110776
// begin if not HasTask ( group [ i ] ) then
110703: LD_VAR 0 4
110707: PUSH
110708: LD_VAR 0 7
110712: ARRAY
110713: PPUSH
110714: CALL_OW 314
110718: NOT
110719: IFFALSE 110774
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
110721: LD_VAR 0 4
110725: PUSH
110726: LD_VAR 0 7
110730: ARRAY
110731: PPUSH
110732: LD_VAR 0 16
110736: PUSH
110737: LD_VAR 0 7
110741: ARRAY
110742: PUSH
110743: LD_INT 1
110745: ARRAY
110746: PUSH
110747: LD_INT 1
110749: ARRAY
110750: PPUSH
110751: LD_VAR 0 16
110755: PUSH
110756: LD_VAR 0 7
110760: ARRAY
110761: PUSH
110762: LD_INT 1
110764: ARRAY
110765: PUSH
110766: LD_INT 2
110768: ARRAY
110769: PPUSH
110770: CALL_OW 114
// end else
110774: GO 110827
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
110776: LD_ADDR_VAR 0 15
110780: PUSH
110781: LD_VAR 0 16
110785: PUSH
110786: LD_VAR 0 7
110790: ARRAY
110791: PPUSH
110792: LD_INT 1
110794: PPUSH
110795: CALL_OW 3
110799: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
110800: LD_ADDR_VAR 0 16
110804: PUSH
110805: LD_VAR 0 16
110809: PPUSH
110810: LD_VAR 0 7
110814: PPUSH
110815: LD_VAR 0 15
110819: PPUSH
110820: CALL_OW 1
110824: ST_TO_ADDR
// continue ;
110825: GO 109370
// end ; end ; end else
110827: GO 113491
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
110829: LD_ADDR_VAR 0 14
110833: PUSH
110834: LD_INT 81
110836: PUSH
110837: LD_VAR 0 4
110841: PUSH
110842: LD_VAR 0 7
110846: ARRAY
110847: PPUSH
110848: CALL_OW 255
110852: PUSH
110853: EMPTY
110854: LIST
110855: LIST
110856: PPUSH
110857: CALL_OW 69
110861: ST_TO_ADDR
// if not tmp then
110862: LD_VAR 0 14
110866: NOT
110867: IFFALSE 110871
// continue ;
110869: GO 109370
// if f_ignore_area then
110871: LD_VAR 0 17
110875: IFFALSE 110963
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
110877: LD_ADDR_VAR 0 15
110881: PUSH
110882: LD_VAR 0 14
110886: PPUSH
110887: LD_INT 3
110889: PUSH
110890: LD_INT 92
110892: PUSH
110893: LD_VAR 0 17
110897: PUSH
110898: LD_INT 1
110900: ARRAY
110901: PUSH
110902: LD_VAR 0 17
110906: PUSH
110907: LD_INT 2
110909: ARRAY
110910: PUSH
110911: LD_VAR 0 17
110915: PUSH
110916: LD_INT 3
110918: ARRAY
110919: PUSH
110920: EMPTY
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: PUSH
110926: EMPTY
110927: LIST
110928: LIST
110929: PPUSH
110930: CALL_OW 72
110934: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110935: LD_VAR 0 14
110939: PUSH
110940: LD_VAR 0 15
110944: DIFF
110945: IFFALSE 110963
// tmp := tmp diff tmp2 ;
110947: LD_ADDR_VAR 0 14
110951: PUSH
110952: LD_VAR 0 14
110956: PUSH
110957: LD_VAR 0 15
110961: DIFF
110962: ST_TO_ADDR
// end ; if not f_murder then
110963: LD_VAR 0 20
110967: NOT
110968: IFFALSE 111026
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
110970: LD_ADDR_VAR 0 15
110974: PUSH
110975: LD_VAR 0 14
110979: PPUSH
110980: LD_INT 3
110982: PUSH
110983: LD_INT 50
110985: PUSH
110986: EMPTY
110987: LIST
110988: PUSH
110989: EMPTY
110990: LIST
110991: LIST
110992: PPUSH
110993: CALL_OW 72
110997: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110998: LD_VAR 0 14
111002: PUSH
111003: LD_VAR 0 15
111007: DIFF
111008: IFFALSE 111026
// tmp := tmp diff tmp2 ;
111010: LD_ADDR_VAR 0 14
111014: PUSH
111015: LD_VAR 0 14
111019: PUSH
111020: LD_VAR 0 15
111024: DIFF
111025: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111026: LD_ADDR_VAR 0 14
111030: PUSH
111031: LD_VAR 0 4
111035: PUSH
111036: LD_VAR 0 7
111040: ARRAY
111041: PPUSH
111042: LD_VAR 0 14
111046: PPUSH
111047: LD_INT 1
111049: PPUSH
111050: LD_INT 1
111052: PPUSH
111053: CALL 56909 0 4
111057: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111058: LD_VAR 0 4
111062: PUSH
111063: LD_VAR 0 7
111067: ARRAY
111068: PPUSH
111069: CALL_OW 257
111073: PUSH
111074: LD_INT 1
111076: EQUAL
111077: IFFALSE 111525
// begin if WantPlant ( group [ i ] ) then
111079: LD_VAR 0 4
111083: PUSH
111084: LD_VAR 0 7
111088: ARRAY
111089: PPUSH
111090: CALL 56410 0 1
111094: IFFALSE 111098
// continue ;
111096: GO 109370
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111098: LD_VAR 0 18
111102: PUSH
111103: LD_VAR 0 4
111107: PUSH
111108: LD_VAR 0 7
111112: ARRAY
111113: PPUSH
111114: CALL_OW 310
111118: NOT
111119: AND
111120: PUSH
111121: LD_VAR 0 14
111125: PUSH
111126: LD_INT 1
111128: ARRAY
111129: PUSH
111130: LD_VAR 0 14
111134: PPUSH
111135: LD_INT 21
111137: PUSH
111138: LD_INT 2
111140: PUSH
111141: EMPTY
111142: LIST
111143: LIST
111144: PUSH
111145: LD_INT 58
111147: PUSH
111148: EMPTY
111149: LIST
111150: PUSH
111151: EMPTY
111152: LIST
111153: LIST
111154: PPUSH
111155: CALL_OW 72
111159: IN
111160: AND
111161: IFFALSE 111197
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
111163: LD_VAR 0 4
111167: PUSH
111168: LD_VAR 0 7
111172: ARRAY
111173: PPUSH
111174: LD_VAR 0 14
111178: PUSH
111179: LD_INT 1
111181: ARRAY
111182: PPUSH
111183: CALL_OW 120
// attacking := true ;
111187: LD_ADDR_VAR 0 29
111191: PUSH
111192: LD_INT 1
111194: ST_TO_ADDR
// continue ;
111195: GO 109370
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
111197: LD_VAR 0 26
111201: PUSH
111202: LD_VAR 0 4
111206: PUSH
111207: LD_VAR 0 7
111211: ARRAY
111212: PPUSH
111213: CALL_OW 257
111217: PUSH
111218: LD_INT 1
111220: EQUAL
111221: AND
111222: PUSH
111223: LD_VAR 0 4
111227: PUSH
111228: LD_VAR 0 7
111232: ARRAY
111233: PPUSH
111234: CALL_OW 256
111238: PUSH
111239: LD_INT 800
111241: LESS
111242: AND
111243: PUSH
111244: LD_VAR 0 4
111248: PUSH
111249: LD_VAR 0 7
111253: ARRAY
111254: PPUSH
111255: CALL_OW 318
111259: NOT
111260: AND
111261: IFFALSE 111278
// ComCrawl ( group [ i ] ) ;
111263: LD_VAR 0 4
111267: PUSH
111268: LD_VAR 0 7
111272: ARRAY
111273: PPUSH
111274: CALL_OW 137
// if f_mines then
111278: LD_VAR 0 21
111282: IFFALSE 111525
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
111284: LD_VAR 0 14
111288: PUSH
111289: LD_INT 1
111291: ARRAY
111292: PPUSH
111293: CALL_OW 247
111297: PUSH
111298: LD_INT 3
111300: EQUAL
111301: PUSH
111302: LD_VAR 0 14
111306: PUSH
111307: LD_INT 1
111309: ARRAY
111310: PUSH
111311: LD_VAR 0 27
111315: IN
111316: NOT
111317: AND
111318: IFFALSE 111525
// begin x := GetX ( tmp [ 1 ] ) ;
111320: LD_ADDR_VAR 0 10
111324: PUSH
111325: LD_VAR 0 14
111329: PUSH
111330: LD_INT 1
111332: ARRAY
111333: PPUSH
111334: CALL_OW 250
111338: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
111339: LD_ADDR_VAR 0 11
111343: PUSH
111344: LD_VAR 0 14
111348: PUSH
111349: LD_INT 1
111351: ARRAY
111352: PPUSH
111353: CALL_OW 251
111357: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
111358: LD_ADDR_VAR 0 12
111362: PUSH
111363: LD_VAR 0 4
111367: PUSH
111368: LD_VAR 0 7
111372: ARRAY
111373: PPUSH
111374: CALL 84059 0 1
111378: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
111379: LD_VAR 0 4
111383: PUSH
111384: LD_VAR 0 7
111388: ARRAY
111389: PPUSH
111390: LD_VAR 0 10
111394: PPUSH
111395: LD_VAR 0 11
111399: PPUSH
111400: LD_VAR 0 14
111404: PUSH
111405: LD_INT 1
111407: ARRAY
111408: PPUSH
111409: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
111413: LD_VAR 0 4
111417: PUSH
111418: LD_VAR 0 7
111422: ARRAY
111423: PPUSH
111424: LD_VAR 0 10
111428: PPUSH
111429: LD_VAR 0 12
111433: PPUSH
111434: LD_INT 7
111436: PPUSH
111437: CALL_OW 272
111441: PPUSH
111442: LD_VAR 0 11
111446: PPUSH
111447: LD_VAR 0 12
111451: PPUSH
111452: LD_INT 7
111454: PPUSH
111455: CALL_OW 273
111459: PPUSH
111460: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
111464: LD_VAR 0 4
111468: PUSH
111469: LD_VAR 0 7
111473: ARRAY
111474: PPUSH
111475: LD_INT 71
111477: PPUSH
111478: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
111482: LD_ADDR_VAR 0 27
111486: PUSH
111487: LD_VAR 0 27
111491: PPUSH
111492: LD_VAR 0 27
111496: PUSH
111497: LD_INT 1
111499: PLUS
111500: PPUSH
111501: LD_VAR 0 14
111505: PUSH
111506: LD_INT 1
111508: ARRAY
111509: PPUSH
111510: CALL_OW 1
111514: ST_TO_ADDR
// attacking := true ;
111515: LD_ADDR_VAR 0 29
111519: PUSH
111520: LD_INT 1
111522: ST_TO_ADDR
// continue ;
111523: GO 109370
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
111525: LD_VAR 0 4
111529: PUSH
111530: LD_VAR 0 7
111534: ARRAY
111535: PPUSH
111536: CALL_OW 257
111540: PUSH
111541: LD_INT 17
111543: EQUAL
111544: PUSH
111545: LD_VAR 0 4
111549: PUSH
111550: LD_VAR 0 7
111554: ARRAY
111555: PPUSH
111556: CALL_OW 110
111560: PUSH
111561: LD_INT 71
111563: EQUAL
111564: NOT
111565: AND
111566: IFFALSE 111712
// begin attacking := false ;
111568: LD_ADDR_VAR 0 29
111572: PUSH
111573: LD_INT 0
111575: ST_TO_ADDR
// k := 5 ;
111576: LD_ADDR_VAR 0 9
111580: PUSH
111581: LD_INT 5
111583: ST_TO_ADDR
// if tmp < k then
111584: LD_VAR 0 14
111588: PUSH
111589: LD_VAR 0 9
111593: LESS
111594: IFFALSE 111606
// k := tmp ;
111596: LD_ADDR_VAR 0 9
111600: PUSH
111601: LD_VAR 0 14
111605: ST_TO_ADDR
// for j = 1 to k do
111606: LD_ADDR_VAR 0 8
111610: PUSH
111611: DOUBLE
111612: LD_INT 1
111614: DEC
111615: ST_TO_ADDR
111616: LD_VAR 0 9
111620: PUSH
111621: FOR_TO
111622: IFFALSE 111710
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
111624: LD_VAR 0 14
111628: PUSH
111629: LD_VAR 0 8
111633: ARRAY
111634: PUSH
111635: LD_VAR 0 14
111639: PPUSH
111640: LD_INT 58
111642: PUSH
111643: EMPTY
111644: LIST
111645: PPUSH
111646: CALL_OW 72
111650: IN
111651: NOT
111652: IFFALSE 111708
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111654: LD_VAR 0 4
111658: PUSH
111659: LD_VAR 0 7
111663: ARRAY
111664: PPUSH
111665: LD_VAR 0 14
111669: PUSH
111670: LD_VAR 0 8
111674: ARRAY
111675: PPUSH
111676: CALL_OW 115
// attacking := true ;
111680: LD_ADDR_VAR 0 29
111684: PUSH
111685: LD_INT 1
111687: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
111688: LD_VAR 0 4
111692: PUSH
111693: LD_VAR 0 7
111697: ARRAY
111698: PPUSH
111699: LD_INT 71
111701: PPUSH
111702: CALL_OW 109
// continue ;
111706: GO 111621
// end ; end ;
111708: GO 111621
111710: POP
111711: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
111712: LD_VAR 0 4
111716: PUSH
111717: LD_VAR 0 7
111721: ARRAY
111722: PPUSH
111723: CALL_OW 257
111727: PUSH
111728: LD_INT 8
111730: EQUAL
111731: PUSH
111732: LD_VAR 0 4
111736: PUSH
111737: LD_VAR 0 7
111741: ARRAY
111742: PPUSH
111743: CALL_OW 264
111747: PUSH
111748: LD_INT 28
111750: PUSH
111751: LD_INT 45
111753: PUSH
111754: LD_INT 7
111756: PUSH
111757: LD_INT 47
111759: PUSH
111760: EMPTY
111761: LIST
111762: LIST
111763: LIST
111764: LIST
111765: IN
111766: OR
111767: IFFALSE 112023
// begin attacking := false ;
111769: LD_ADDR_VAR 0 29
111773: PUSH
111774: LD_INT 0
111776: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
111777: LD_VAR 0 14
111781: PUSH
111782: LD_INT 1
111784: ARRAY
111785: PPUSH
111786: CALL_OW 266
111790: PUSH
111791: LD_INT 32
111793: PUSH
111794: LD_INT 31
111796: PUSH
111797: LD_INT 33
111799: PUSH
111800: LD_INT 4
111802: PUSH
111803: LD_INT 5
111805: PUSH
111806: EMPTY
111807: LIST
111808: LIST
111809: LIST
111810: LIST
111811: LIST
111812: IN
111813: IFFALSE 111999
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
111815: LD_ADDR_VAR 0 9
111819: PUSH
111820: LD_VAR 0 14
111824: PUSH
111825: LD_INT 1
111827: ARRAY
111828: PPUSH
111829: CALL_OW 266
111833: PPUSH
111834: LD_VAR 0 14
111838: PUSH
111839: LD_INT 1
111841: ARRAY
111842: PPUSH
111843: CALL_OW 250
111847: PPUSH
111848: LD_VAR 0 14
111852: PUSH
111853: LD_INT 1
111855: ARRAY
111856: PPUSH
111857: CALL_OW 251
111861: PPUSH
111862: LD_VAR 0 14
111866: PUSH
111867: LD_INT 1
111869: ARRAY
111870: PPUSH
111871: CALL_OW 254
111875: PPUSH
111876: LD_VAR 0 14
111880: PUSH
111881: LD_INT 1
111883: ARRAY
111884: PPUSH
111885: CALL_OW 248
111889: PPUSH
111890: LD_INT 0
111892: PPUSH
111893: CALL 65429 0 6
111897: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
111898: LD_ADDR_VAR 0 8
111902: PUSH
111903: LD_VAR 0 4
111907: PUSH
111908: LD_VAR 0 7
111912: ARRAY
111913: PPUSH
111914: LD_VAR 0 9
111918: PPUSH
111919: CALL 84099 0 2
111923: ST_TO_ADDR
// if j then
111924: LD_VAR 0 8
111928: IFFALSE 111997
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
111930: LD_VAR 0 8
111934: PUSH
111935: LD_INT 1
111937: ARRAY
111938: PPUSH
111939: LD_VAR 0 8
111943: PUSH
111944: LD_INT 2
111946: ARRAY
111947: PPUSH
111948: CALL_OW 488
111952: IFFALSE 111997
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
111954: LD_VAR 0 4
111958: PUSH
111959: LD_VAR 0 7
111963: ARRAY
111964: PPUSH
111965: LD_VAR 0 8
111969: PUSH
111970: LD_INT 1
111972: ARRAY
111973: PPUSH
111974: LD_VAR 0 8
111978: PUSH
111979: LD_INT 2
111981: ARRAY
111982: PPUSH
111983: CALL_OW 116
// attacking := true ;
111987: LD_ADDR_VAR 0 29
111991: PUSH
111992: LD_INT 1
111994: ST_TO_ADDR
// continue ;
111995: GO 109370
// end ; end else
111997: GO 112023
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111999: LD_VAR 0 4
112003: PUSH
112004: LD_VAR 0 7
112008: ARRAY
112009: PPUSH
112010: LD_VAR 0 14
112014: PUSH
112015: LD_INT 1
112017: ARRAY
112018: PPUSH
112019: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112023: LD_VAR 0 4
112027: PUSH
112028: LD_VAR 0 7
112032: ARRAY
112033: PPUSH
112034: CALL_OW 265
112038: PUSH
112039: LD_INT 11
112041: EQUAL
112042: IFFALSE 112320
// begin k := 10 ;
112044: LD_ADDR_VAR 0 9
112048: PUSH
112049: LD_INT 10
112051: ST_TO_ADDR
// x := 0 ;
112052: LD_ADDR_VAR 0 10
112056: PUSH
112057: LD_INT 0
112059: ST_TO_ADDR
// if tmp < k then
112060: LD_VAR 0 14
112064: PUSH
112065: LD_VAR 0 9
112069: LESS
112070: IFFALSE 112082
// k := tmp ;
112072: LD_ADDR_VAR 0 9
112076: PUSH
112077: LD_VAR 0 14
112081: ST_TO_ADDR
// for j = k downto 1 do
112082: LD_ADDR_VAR 0 8
112086: PUSH
112087: DOUBLE
112088: LD_VAR 0 9
112092: INC
112093: ST_TO_ADDR
112094: LD_INT 1
112096: PUSH
112097: FOR_DOWNTO
112098: IFFALSE 112173
// begin if GetType ( tmp [ j ] ) = unit_human then
112100: LD_VAR 0 14
112104: PUSH
112105: LD_VAR 0 8
112109: ARRAY
112110: PPUSH
112111: CALL_OW 247
112115: PUSH
112116: LD_INT 1
112118: EQUAL
112119: IFFALSE 112171
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
112121: LD_VAR 0 4
112125: PUSH
112126: LD_VAR 0 7
112130: ARRAY
112131: PPUSH
112132: LD_VAR 0 14
112136: PUSH
112137: LD_VAR 0 8
112141: ARRAY
112142: PPUSH
112143: CALL 84370 0 2
// x := tmp [ j ] ;
112147: LD_ADDR_VAR 0 10
112151: PUSH
112152: LD_VAR 0 14
112156: PUSH
112157: LD_VAR 0 8
112161: ARRAY
112162: ST_TO_ADDR
// attacking := true ;
112163: LD_ADDR_VAR 0 29
112167: PUSH
112168: LD_INT 1
112170: ST_TO_ADDR
// end ; end ;
112171: GO 112097
112173: POP
112174: POP
// if not x then
112175: LD_VAR 0 10
112179: NOT
112180: IFFALSE 112320
// begin attacking := true ;
112182: LD_ADDR_VAR 0 29
112186: PUSH
112187: LD_INT 1
112189: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
112190: LD_VAR 0 4
112194: PUSH
112195: LD_VAR 0 7
112199: ARRAY
112200: PPUSH
112201: CALL_OW 250
112205: PPUSH
112206: LD_VAR 0 4
112210: PUSH
112211: LD_VAR 0 7
112215: ARRAY
112216: PPUSH
112217: CALL_OW 251
112221: PPUSH
112222: CALL_OW 546
112226: PUSH
112227: LD_INT 2
112229: ARRAY
112230: PUSH
112231: LD_VAR 0 14
112235: PUSH
112236: LD_INT 1
112238: ARRAY
112239: PPUSH
112240: CALL_OW 250
112244: PPUSH
112245: LD_VAR 0 14
112249: PUSH
112250: LD_INT 1
112252: ARRAY
112253: PPUSH
112254: CALL_OW 251
112258: PPUSH
112259: CALL_OW 546
112263: PUSH
112264: LD_INT 2
112266: ARRAY
112267: EQUAL
112268: IFFALSE 112296
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
112270: LD_VAR 0 4
112274: PUSH
112275: LD_VAR 0 7
112279: ARRAY
112280: PPUSH
112281: LD_VAR 0 14
112285: PUSH
112286: LD_INT 1
112288: ARRAY
112289: PPUSH
112290: CALL 84370 0 2
112294: GO 112320
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112296: LD_VAR 0 4
112300: PUSH
112301: LD_VAR 0 7
112305: ARRAY
112306: PPUSH
112307: LD_VAR 0 14
112311: PUSH
112312: LD_INT 1
112314: ARRAY
112315: PPUSH
112316: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
112320: LD_VAR 0 4
112324: PUSH
112325: LD_VAR 0 7
112329: ARRAY
112330: PPUSH
112331: CALL_OW 264
112335: PUSH
112336: LD_INT 29
112338: EQUAL
112339: IFFALSE 112705
// begin if WantsToAttack ( group [ i ] ) in bombed then
112341: LD_VAR 0 4
112345: PUSH
112346: LD_VAR 0 7
112350: ARRAY
112351: PPUSH
112352: CALL_OW 319
112356: PUSH
112357: LD_VAR 0 28
112361: IN
112362: IFFALSE 112366
// continue ;
112364: GO 109370
// k := 8 ;
112366: LD_ADDR_VAR 0 9
112370: PUSH
112371: LD_INT 8
112373: ST_TO_ADDR
// x := 0 ;
112374: LD_ADDR_VAR 0 10
112378: PUSH
112379: LD_INT 0
112381: ST_TO_ADDR
// if tmp < k then
112382: LD_VAR 0 14
112386: PUSH
112387: LD_VAR 0 9
112391: LESS
112392: IFFALSE 112404
// k := tmp ;
112394: LD_ADDR_VAR 0 9
112398: PUSH
112399: LD_VAR 0 14
112403: ST_TO_ADDR
// for j = 1 to k do
112404: LD_ADDR_VAR 0 8
112408: PUSH
112409: DOUBLE
112410: LD_INT 1
112412: DEC
112413: ST_TO_ADDR
112414: LD_VAR 0 9
112418: PUSH
112419: FOR_TO
112420: IFFALSE 112552
// begin if GetType ( tmp [ j ] ) = unit_building then
112422: LD_VAR 0 14
112426: PUSH
112427: LD_VAR 0 8
112431: ARRAY
112432: PPUSH
112433: CALL_OW 247
112437: PUSH
112438: LD_INT 3
112440: EQUAL
112441: IFFALSE 112550
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
112443: LD_VAR 0 14
112447: PUSH
112448: LD_VAR 0 8
112452: ARRAY
112453: PUSH
112454: LD_VAR 0 28
112458: IN
112459: NOT
112460: PUSH
112461: LD_VAR 0 14
112465: PUSH
112466: LD_VAR 0 8
112470: ARRAY
112471: PPUSH
112472: CALL_OW 313
112476: AND
112477: IFFALSE 112550
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112479: LD_VAR 0 4
112483: PUSH
112484: LD_VAR 0 7
112488: ARRAY
112489: PPUSH
112490: LD_VAR 0 14
112494: PUSH
112495: LD_VAR 0 8
112499: ARRAY
112500: PPUSH
112501: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
112505: LD_ADDR_VAR 0 28
112509: PUSH
112510: LD_VAR 0 28
112514: PPUSH
112515: LD_VAR 0 28
112519: PUSH
112520: LD_INT 1
112522: PLUS
112523: PPUSH
112524: LD_VAR 0 14
112528: PUSH
112529: LD_VAR 0 8
112533: ARRAY
112534: PPUSH
112535: CALL_OW 1
112539: ST_TO_ADDR
// attacking := true ;
112540: LD_ADDR_VAR 0 29
112544: PUSH
112545: LD_INT 1
112547: ST_TO_ADDR
// break ;
112548: GO 112552
// end ; end ;
112550: GO 112419
112552: POP
112553: POP
// if not attacking and f_attack_depot then
112554: LD_VAR 0 29
112558: NOT
112559: PUSH
112560: LD_VAR 0 25
112564: AND
112565: IFFALSE 112660
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112567: LD_ADDR_VAR 0 13
112571: PUSH
112572: LD_VAR 0 14
112576: PPUSH
112577: LD_INT 2
112579: PUSH
112580: LD_INT 30
112582: PUSH
112583: LD_INT 0
112585: PUSH
112586: EMPTY
112587: LIST
112588: LIST
112589: PUSH
112590: LD_INT 30
112592: PUSH
112593: LD_INT 1
112595: PUSH
112596: EMPTY
112597: LIST
112598: LIST
112599: PUSH
112600: EMPTY
112601: LIST
112602: LIST
112603: LIST
112604: PPUSH
112605: CALL_OW 72
112609: ST_TO_ADDR
// if z then
112610: LD_VAR 0 13
112614: IFFALSE 112660
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
112616: LD_VAR 0 4
112620: PUSH
112621: LD_VAR 0 7
112625: ARRAY
112626: PPUSH
112627: LD_VAR 0 13
112631: PPUSH
112632: LD_VAR 0 4
112636: PUSH
112637: LD_VAR 0 7
112641: ARRAY
112642: PPUSH
112643: CALL_OW 74
112647: PPUSH
112648: CALL_OW 115
// attacking := true ;
112652: LD_ADDR_VAR 0 29
112656: PUSH
112657: LD_INT 1
112659: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
112660: LD_VAR 0 4
112664: PUSH
112665: LD_VAR 0 7
112669: ARRAY
112670: PPUSH
112671: CALL_OW 256
112675: PUSH
112676: LD_INT 500
112678: LESS
112679: IFFALSE 112705
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112681: LD_VAR 0 4
112685: PUSH
112686: LD_VAR 0 7
112690: ARRAY
112691: PPUSH
112692: LD_VAR 0 14
112696: PUSH
112697: LD_INT 1
112699: ARRAY
112700: PPUSH
112701: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
112705: LD_VAR 0 4
112709: PUSH
112710: LD_VAR 0 7
112714: ARRAY
112715: PPUSH
112716: CALL_OW 264
112720: PUSH
112721: LD_INT 49
112723: EQUAL
112724: IFFALSE 112845
// begin if not HasTask ( group [ i ] ) then
112726: LD_VAR 0 4
112730: PUSH
112731: LD_VAR 0 7
112735: ARRAY
112736: PPUSH
112737: CALL_OW 314
112741: NOT
112742: IFFALSE 112845
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
112744: LD_ADDR_VAR 0 9
112748: PUSH
112749: LD_INT 81
112751: PUSH
112752: LD_VAR 0 4
112756: PUSH
112757: LD_VAR 0 7
112761: ARRAY
112762: PPUSH
112763: CALL_OW 255
112767: PUSH
112768: EMPTY
112769: LIST
112770: LIST
112771: PPUSH
112772: CALL_OW 69
112776: PPUSH
112777: LD_VAR 0 4
112781: PUSH
112782: LD_VAR 0 7
112786: ARRAY
112787: PPUSH
112788: CALL_OW 74
112792: ST_TO_ADDR
// if k then
112793: LD_VAR 0 9
112797: IFFALSE 112845
// if GetDistUnits ( group [ i ] , k ) > 10 then
112799: LD_VAR 0 4
112803: PUSH
112804: LD_VAR 0 7
112808: ARRAY
112809: PPUSH
112810: LD_VAR 0 9
112814: PPUSH
112815: CALL_OW 296
112819: PUSH
112820: LD_INT 10
112822: GREATER
112823: IFFALSE 112845
// ComMoveUnit ( group [ i ] , k ) ;
112825: LD_VAR 0 4
112829: PUSH
112830: LD_VAR 0 7
112834: ARRAY
112835: PPUSH
112836: LD_VAR 0 9
112840: PPUSH
112841: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
112845: LD_VAR 0 4
112849: PUSH
112850: LD_VAR 0 7
112854: ARRAY
112855: PPUSH
112856: CALL_OW 256
112860: PUSH
112861: LD_INT 250
112863: LESS
112864: PUSH
112865: LD_VAR 0 4
112869: PUSH
112870: LD_VAR 0 7
112874: ARRAY
112875: PUSH
112876: LD_INT 21
112878: PUSH
112879: LD_INT 2
112881: PUSH
112882: EMPTY
112883: LIST
112884: LIST
112885: PUSH
112886: LD_INT 23
112888: PUSH
112889: LD_INT 2
112891: PUSH
112892: EMPTY
112893: LIST
112894: LIST
112895: PUSH
112896: EMPTY
112897: LIST
112898: LIST
112899: PPUSH
112900: CALL_OW 69
112904: IN
112905: AND
112906: IFFALSE 113031
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
112908: LD_ADDR_VAR 0 9
112912: PUSH
112913: LD_OWVAR 3
112917: PUSH
112918: LD_VAR 0 4
112922: PUSH
112923: LD_VAR 0 7
112927: ARRAY
112928: DIFF
112929: PPUSH
112930: LD_VAR 0 4
112934: PUSH
112935: LD_VAR 0 7
112939: ARRAY
112940: PPUSH
112941: CALL_OW 74
112945: ST_TO_ADDR
// if not k then
112946: LD_VAR 0 9
112950: NOT
112951: IFFALSE 112955
// continue ;
112953: GO 109370
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
112955: LD_VAR 0 9
112959: PUSH
112960: LD_INT 81
112962: PUSH
112963: LD_VAR 0 4
112967: PUSH
112968: LD_VAR 0 7
112972: ARRAY
112973: PPUSH
112974: CALL_OW 255
112978: PUSH
112979: EMPTY
112980: LIST
112981: LIST
112982: PPUSH
112983: CALL_OW 69
112987: IN
112988: PUSH
112989: LD_VAR 0 9
112993: PPUSH
112994: LD_VAR 0 4
112998: PUSH
112999: LD_VAR 0 7
113003: ARRAY
113004: PPUSH
113005: CALL_OW 296
113009: PUSH
113010: LD_INT 5
113012: LESS
113013: AND
113014: IFFALSE 113031
// ComAutodestruct ( group [ i ] ) ;
113016: LD_VAR 0 4
113020: PUSH
113021: LD_VAR 0 7
113025: ARRAY
113026: PPUSH
113027: CALL 84268 0 1
// end ; if f_attack_depot then
113031: LD_VAR 0 25
113035: IFFALSE 113147
// begin k := 6 ;
113037: LD_ADDR_VAR 0 9
113041: PUSH
113042: LD_INT 6
113044: ST_TO_ADDR
// if tmp < k then
113045: LD_VAR 0 14
113049: PUSH
113050: LD_VAR 0 9
113054: LESS
113055: IFFALSE 113067
// k := tmp ;
113057: LD_ADDR_VAR 0 9
113061: PUSH
113062: LD_VAR 0 14
113066: ST_TO_ADDR
// for j = 1 to k do
113067: LD_ADDR_VAR 0 8
113071: PUSH
113072: DOUBLE
113073: LD_INT 1
113075: DEC
113076: ST_TO_ADDR
113077: LD_VAR 0 9
113081: PUSH
113082: FOR_TO
113083: IFFALSE 113145
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113085: LD_VAR 0 8
113089: PPUSH
113090: CALL_OW 266
113094: PUSH
113095: LD_INT 0
113097: PUSH
113098: LD_INT 1
113100: PUSH
113101: EMPTY
113102: LIST
113103: LIST
113104: IN
113105: IFFALSE 113143
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113107: LD_VAR 0 4
113111: PUSH
113112: LD_VAR 0 7
113116: ARRAY
113117: PPUSH
113118: LD_VAR 0 14
113122: PUSH
113123: LD_VAR 0 8
113127: ARRAY
113128: PPUSH
113129: CALL_OW 115
// attacking := true ;
113133: LD_ADDR_VAR 0 29
113137: PUSH
113138: LD_INT 1
113140: ST_TO_ADDR
// break ;
113141: GO 113145
// end ;
113143: GO 113082
113145: POP
113146: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
113147: LD_VAR 0 4
113151: PUSH
113152: LD_VAR 0 7
113156: ARRAY
113157: PPUSH
113158: CALL_OW 302
113162: PUSH
113163: LD_VAR 0 29
113167: NOT
113168: AND
113169: IFFALSE 113491
// begin if GetTag ( group [ i ] ) = 71 then
113171: LD_VAR 0 4
113175: PUSH
113176: LD_VAR 0 7
113180: ARRAY
113181: PPUSH
113182: CALL_OW 110
113186: PUSH
113187: LD_INT 71
113189: EQUAL
113190: IFFALSE 113231
// begin if HasTask ( group [ i ] ) then
113192: LD_VAR 0 4
113196: PUSH
113197: LD_VAR 0 7
113201: ARRAY
113202: PPUSH
113203: CALL_OW 314
113207: IFFALSE 113213
// continue else
113209: GO 109370
113211: GO 113231
// SetTag ( group [ i ] , 0 ) ;
113213: LD_VAR 0 4
113217: PUSH
113218: LD_VAR 0 7
113222: ARRAY
113223: PPUSH
113224: LD_INT 0
113226: PPUSH
113227: CALL_OW 109
// end ; k := 8 ;
113231: LD_ADDR_VAR 0 9
113235: PUSH
113236: LD_INT 8
113238: ST_TO_ADDR
// x := 0 ;
113239: LD_ADDR_VAR 0 10
113243: PUSH
113244: LD_INT 0
113246: ST_TO_ADDR
// if tmp < k then
113247: LD_VAR 0 14
113251: PUSH
113252: LD_VAR 0 9
113256: LESS
113257: IFFALSE 113269
// k := tmp ;
113259: LD_ADDR_VAR 0 9
113263: PUSH
113264: LD_VAR 0 14
113268: ST_TO_ADDR
// for j = 1 to k do
113269: LD_ADDR_VAR 0 8
113273: PUSH
113274: DOUBLE
113275: LD_INT 1
113277: DEC
113278: ST_TO_ADDR
113279: LD_VAR 0 9
113283: PUSH
113284: FOR_TO
113285: IFFALSE 113383
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
113287: LD_VAR 0 14
113291: PUSH
113292: LD_VAR 0 8
113296: ARRAY
113297: PPUSH
113298: CALL_OW 247
113302: PUSH
113303: LD_INT 1
113305: EQUAL
113306: PUSH
113307: LD_VAR 0 14
113311: PUSH
113312: LD_VAR 0 8
113316: ARRAY
113317: PPUSH
113318: CALL_OW 256
113322: PUSH
113323: LD_INT 250
113325: LESS
113326: PUSH
113327: LD_VAR 0 20
113331: AND
113332: PUSH
113333: LD_VAR 0 20
113337: NOT
113338: PUSH
113339: LD_VAR 0 14
113343: PUSH
113344: LD_VAR 0 8
113348: ARRAY
113349: PPUSH
113350: CALL_OW 256
113354: PUSH
113355: LD_INT 250
113357: GREATEREQUAL
113358: AND
113359: OR
113360: AND
113361: IFFALSE 113381
// begin x := tmp [ j ] ;
113363: LD_ADDR_VAR 0 10
113367: PUSH
113368: LD_VAR 0 14
113372: PUSH
113373: LD_VAR 0 8
113377: ARRAY
113378: ST_TO_ADDR
// break ;
113379: GO 113383
// end ;
113381: GO 113284
113383: POP
113384: POP
// if x then
113385: LD_VAR 0 10
113389: IFFALSE 113413
// ComAttackUnit ( group [ i ] , x ) else
113391: LD_VAR 0 4
113395: PUSH
113396: LD_VAR 0 7
113400: ARRAY
113401: PPUSH
113402: LD_VAR 0 10
113406: PPUSH
113407: CALL_OW 115
113411: GO 113437
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113413: LD_VAR 0 4
113417: PUSH
113418: LD_VAR 0 7
113422: ARRAY
113423: PPUSH
113424: LD_VAR 0 14
113428: PUSH
113429: LD_INT 1
113431: ARRAY
113432: PPUSH
113433: CALL_OW 115
// if not HasTask ( group [ i ] ) then
113437: LD_VAR 0 4
113441: PUSH
113442: LD_VAR 0 7
113446: ARRAY
113447: PPUSH
113448: CALL_OW 314
113452: NOT
113453: IFFALSE 113491
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
113455: LD_VAR 0 4
113459: PUSH
113460: LD_VAR 0 7
113464: ARRAY
113465: PPUSH
113466: LD_VAR 0 14
113470: PPUSH
113471: LD_VAR 0 4
113475: PUSH
113476: LD_VAR 0 7
113480: ARRAY
113481: PPUSH
113482: CALL_OW 74
113486: PPUSH
113487: CALL_OW 115
// end ; end ; end ;
113491: GO 109370
113493: POP
113494: POP
// wait ( 0 0$2 ) ;
113495: LD_INT 70
113497: PPUSH
113498: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
113502: LD_VAR 0 4
113506: NOT
113507: PUSH
113508: LD_VAR 0 4
113512: PUSH
113513: EMPTY
113514: EQUAL
113515: OR
113516: PUSH
113517: LD_INT 81
113519: PUSH
113520: LD_VAR 0 35
113524: PUSH
113525: EMPTY
113526: LIST
113527: LIST
113528: PPUSH
113529: CALL_OW 69
113533: NOT
113534: OR
113535: IFFALSE 109355
// end ;
113537: LD_VAR 0 2
113541: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
113542: LD_INT 0
113544: PPUSH
113545: PPUSH
113546: PPUSH
113547: PPUSH
113548: PPUSH
113549: PPUSH
// if not base or not mc_bases [ base ] or not solds then
113550: LD_VAR 0 1
113554: NOT
113555: PUSH
113556: LD_EXP 93
113560: PUSH
113561: LD_VAR 0 1
113565: ARRAY
113566: NOT
113567: OR
113568: PUSH
113569: LD_VAR 0 2
113573: NOT
113574: OR
113575: IFFALSE 113579
// exit ;
113577: GO 114133
// side := mc_sides [ base ] ;
113579: LD_ADDR_VAR 0 6
113583: PUSH
113584: LD_EXP 119
113588: PUSH
113589: LD_VAR 0 1
113593: ARRAY
113594: ST_TO_ADDR
// if not side then
113595: LD_VAR 0 6
113599: NOT
113600: IFFALSE 113604
// exit ;
113602: GO 114133
// for i in solds do
113604: LD_ADDR_VAR 0 7
113608: PUSH
113609: LD_VAR 0 2
113613: PUSH
113614: FOR_IN
113615: IFFALSE 113676
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
113617: LD_VAR 0 7
113621: PPUSH
113622: CALL_OW 310
113626: PPUSH
113627: CALL_OW 266
113631: PUSH
113632: LD_INT 32
113634: PUSH
113635: LD_INT 31
113637: PUSH
113638: EMPTY
113639: LIST
113640: LIST
113641: IN
113642: IFFALSE 113662
// solds := solds diff i else
113644: LD_ADDR_VAR 0 2
113648: PUSH
113649: LD_VAR 0 2
113653: PUSH
113654: LD_VAR 0 7
113658: DIFF
113659: ST_TO_ADDR
113660: GO 113674
// SetTag ( i , 18 ) ;
113662: LD_VAR 0 7
113666: PPUSH
113667: LD_INT 18
113669: PPUSH
113670: CALL_OW 109
113674: GO 113614
113676: POP
113677: POP
// if not solds then
113678: LD_VAR 0 2
113682: NOT
113683: IFFALSE 113687
// exit ;
113685: GO 114133
// repeat wait ( 0 0$2 ) ;
113687: LD_INT 70
113689: PPUSH
113690: CALL_OW 67
// enemy := mc_scan [ base ] ;
113694: LD_ADDR_VAR 0 4
113698: PUSH
113699: LD_EXP 116
113703: PUSH
113704: LD_VAR 0 1
113708: ARRAY
113709: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113710: LD_EXP 93
113714: PUSH
113715: LD_VAR 0 1
113719: ARRAY
113720: NOT
113721: PUSH
113722: LD_EXP 93
113726: PUSH
113727: LD_VAR 0 1
113731: ARRAY
113732: PUSH
113733: EMPTY
113734: EQUAL
113735: OR
113736: IFFALSE 113773
// begin for i in solds do
113738: LD_ADDR_VAR 0 7
113742: PUSH
113743: LD_VAR 0 2
113747: PUSH
113748: FOR_IN
113749: IFFALSE 113762
// ComStop ( i ) ;
113751: LD_VAR 0 7
113755: PPUSH
113756: CALL_OW 141
113760: GO 113748
113762: POP
113763: POP
// solds := [ ] ;
113764: LD_ADDR_VAR 0 2
113768: PUSH
113769: EMPTY
113770: ST_TO_ADDR
// exit ;
113771: GO 114133
// end ; for i in solds do
113773: LD_ADDR_VAR 0 7
113777: PUSH
113778: LD_VAR 0 2
113782: PUSH
113783: FOR_IN
113784: IFFALSE 114105
// begin if IsInUnit ( i ) then
113786: LD_VAR 0 7
113790: PPUSH
113791: CALL_OW 310
113795: IFFALSE 113806
// ComExitBuilding ( i ) ;
113797: LD_VAR 0 7
113801: PPUSH
113802: CALL_OW 122
// if GetLives ( i ) > 500 then
113806: LD_VAR 0 7
113810: PPUSH
113811: CALL_OW 256
113815: PUSH
113816: LD_INT 500
113818: GREATER
113819: IFFALSE 113872
// begin e := NearestUnitToUnit ( enemy , i ) ;
113821: LD_ADDR_VAR 0 5
113825: PUSH
113826: LD_VAR 0 4
113830: PPUSH
113831: LD_VAR 0 7
113835: PPUSH
113836: CALL_OW 74
113840: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
113841: LD_VAR 0 7
113845: PPUSH
113846: LD_VAR 0 5
113850: PPUSH
113851: CALL_OW 250
113855: PPUSH
113856: LD_VAR 0 5
113860: PPUSH
113861: CALL_OW 251
113865: PPUSH
113866: CALL_OW 114
// end else
113870: GO 114103
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
113872: LD_VAR 0 7
113876: PPUSH
113877: LD_EXP 93
113881: PUSH
113882: LD_VAR 0 1
113886: ARRAY
113887: PPUSH
113888: LD_INT 2
113890: PUSH
113891: LD_INT 30
113893: PUSH
113894: LD_INT 0
113896: PUSH
113897: EMPTY
113898: LIST
113899: LIST
113900: PUSH
113901: LD_INT 30
113903: PUSH
113904: LD_INT 1
113906: PUSH
113907: EMPTY
113908: LIST
113909: LIST
113910: PUSH
113911: LD_INT 30
113913: PUSH
113914: LD_INT 6
113916: PUSH
113917: EMPTY
113918: LIST
113919: LIST
113920: PUSH
113921: EMPTY
113922: LIST
113923: LIST
113924: LIST
113925: LIST
113926: PPUSH
113927: CALL_OW 72
113931: PPUSH
113932: LD_VAR 0 7
113936: PPUSH
113937: CALL_OW 74
113941: PPUSH
113942: CALL_OW 296
113946: PUSH
113947: LD_INT 10
113949: GREATER
113950: IFFALSE 114103
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
113952: LD_ADDR_VAR 0 8
113956: PUSH
113957: LD_EXP 93
113961: PUSH
113962: LD_VAR 0 1
113966: ARRAY
113967: PPUSH
113968: LD_INT 2
113970: PUSH
113971: LD_INT 30
113973: PUSH
113974: LD_INT 0
113976: PUSH
113977: EMPTY
113978: LIST
113979: LIST
113980: PUSH
113981: LD_INT 30
113983: PUSH
113984: LD_INT 1
113986: PUSH
113987: EMPTY
113988: LIST
113989: LIST
113990: PUSH
113991: LD_INT 30
113993: PUSH
113994: LD_INT 6
113996: PUSH
113997: EMPTY
113998: LIST
113999: LIST
114000: PUSH
114001: EMPTY
114002: LIST
114003: LIST
114004: LIST
114005: LIST
114006: PPUSH
114007: CALL_OW 72
114011: PPUSH
114012: LD_VAR 0 7
114016: PPUSH
114017: CALL_OW 74
114021: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114022: LD_VAR 0 7
114026: PPUSH
114027: LD_VAR 0 8
114031: PPUSH
114032: CALL_OW 250
114036: PPUSH
114037: LD_INT 3
114039: PPUSH
114040: LD_INT 5
114042: PPUSH
114043: CALL_OW 272
114047: PPUSH
114048: LD_VAR 0 8
114052: PPUSH
114053: CALL_OW 251
114057: PPUSH
114058: LD_INT 3
114060: PPUSH
114061: LD_INT 5
114063: PPUSH
114064: CALL_OW 273
114068: PPUSH
114069: CALL_OW 111
// SetTag ( i , 0 ) ;
114073: LD_VAR 0 7
114077: PPUSH
114078: LD_INT 0
114080: PPUSH
114081: CALL_OW 109
// solds := solds diff i ;
114085: LD_ADDR_VAR 0 2
114089: PUSH
114090: LD_VAR 0 2
114094: PUSH
114095: LD_VAR 0 7
114099: DIFF
114100: ST_TO_ADDR
// continue ;
114101: GO 113783
// end ; end ;
114103: GO 113783
114105: POP
114106: POP
// until not solds or not enemy ;
114107: LD_VAR 0 2
114111: NOT
114112: PUSH
114113: LD_VAR 0 4
114117: NOT
114118: OR
114119: IFFALSE 113687
// MC_Reset ( base , 18 ) ;
114121: LD_VAR 0 1
114125: PPUSH
114126: LD_INT 18
114128: PPUSH
114129: CALL 25016 0 2
// end ;
114133: LD_VAR 0 3
114137: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
114138: LD_INT 0
114140: PPUSH
114141: PPUSH
114142: PPUSH
114143: PPUSH
114144: PPUSH
114145: PPUSH
114146: PPUSH
114147: PPUSH
114148: PPUSH
114149: PPUSH
114150: PPUSH
114151: PPUSH
114152: PPUSH
114153: PPUSH
114154: PPUSH
114155: PPUSH
114156: PPUSH
114157: PPUSH
114158: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
114159: LD_ADDR_VAR 0 12
114163: PUSH
114164: LD_EXP 93
114168: PUSH
114169: LD_VAR 0 1
114173: ARRAY
114174: PPUSH
114175: LD_INT 25
114177: PUSH
114178: LD_INT 3
114180: PUSH
114181: EMPTY
114182: LIST
114183: LIST
114184: PPUSH
114185: CALL_OW 72
114189: ST_TO_ADDR
// if mc_remote_driver [ base ] then
114190: LD_EXP 133
114194: PUSH
114195: LD_VAR 0 1
114199: ARRAY
114200: IFFALSE 114224
// mechs := mechs diff mc_remote_driver [ base ] ;
114202: LD_ADDR_VAR 0 12
114206: PUSH
114207: LD_VAR 0 12
114211: PUSH
114212: LD_EXP 133
114216: PUSH
114217: LD_VAR 0 1
114221: ARRAY
114222: DIFF
114223: ST_TO_ADDR
// for i in mechs do
114224: LD_ADDR_VAR 0 4
114228: PUSH
114229: LD_VAR 0 12
114233: PUSH
114234: FOR_IN
114235: IFFALSE 114270
// if GetTag ( i ) > 0 then
114237: LD_VAR 0 4
114241: PPUSH
114242: CALL_OW 110
114246: PUSH
114247: LD_INT 0
114249: GREATER
114250: IFFALSE 114268
// mechs := mechs diff i ;
114252: LD_ADDR_VAR 0 12
114256: PUSH
114257: LD_VAR 0 12
114261: PUSH
114262: LD_VAR 0 4
114266: DIFF
114267: ST_TO_ADDR
114268: GO 114234
114270: POP
114271: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114272: LD_ADDR_VAR 0 8
114276: PUSH
114277: LD_EXP 93
114281: PUSH
114282: LD_VAR 0 1
114286: ARRAY
114287: PPUSH
114288: LD_INT 2
114290: PUSH
114291: LD_INT 25
114293: PUSH
114294: LD_INT 1
114296: PUSH
114297: EMPTY
114298: LIST
114299: LIST
114300: PUSH
114301: LD_INT 25
114303: PUSH
114304: LD_INT 5
114306: PUSH
114307: EMPTY
114308: LIST
114309: LIST
114310: PUSH
114311: LD_INT 25
114313: PUSH
114314: LD_INT 8
114316: PUSH
114317: EMPTY
114318: LIST
114319: LIST
114320: PUSH
114321: LD_INT 25
114323: PUSH
114324: LD_INT 9
114326: PUSH
114327: EMPTY
114328: LIST
114329: LIST
114330: PUSH
114331: EMPTY
114332: LIST
114333: LIST
114334: LIST
114335: LIST
114336: LIST
114337: PPUSH
114338: CALL_OW 72
114342: ST_TO_ADDR
// if not defenders and not solds then
114343: LD_VAR 0 2
114347: NOT
114348: PUSH
114349: LD_VAR 0 8
114353: NOT
114354: AND
114355: IFFALSE 114359
// exit ;
114357: GO 116129
// depot_under_attack := false ;
114359: LD_ADDR_VAR 0 16
114363: PUSH
114364: LD_INT 0
114366: ST_TO_ADDR
// sold_defenders := [ ] ;
114367: LD_ADDR_VAR 0 17
114371: PUSH
114372: EMPTY
114373: ST_TO_ADDR
// if mechs then
114374: LD_VAR 0 12
114378: IFFALSE 114531
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
114380: LD_ADDR_VAR 0 4
114384: PUSH
114385: LD_VAR 0 2
114389: PPUSH
114390: LD_INT 21
114392: PUSH
114393: LD_INT 2
114395: PUSH
114396: EMPTY
114397: LIST
114398: LIST
114399: PPUSH
114400: CALL_OW 72
114404: PUSH
114405: FOR_IN
114406: IFFALSE 114529
// begin if GetTag ( i ) <> 20 then
114408: LD_VAR 0 4
114412: PPUSH
114413: CALL_OW 110
114417: PUSH
114418: LD_INT 20
114420: NONEQUAL
114421: IFFALSE 114435
// SetTag ( i , 20 ) ;
114423: LD_VAR 0 4
114427: PPUSH
114428: LD_INT 20
114430: PPUSH
114431: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
114435: LD_VAR 0 4
114439: PPUSH
114440: CALL_OW 263
114444: PUSH
114445: LD_INT 1
114447: EQUAL
114448: PUSH
114449: LD_VAR 0 4
114453: PPUSH
114454: CALL_OW 311
114458: NOT
114459: AND
114460: IFFALSE 114527
// begin un := mechs [ 1 ] ;
114462: LD_ADDR_VAR 0 10
114466: PUSH
114467: LD_VAR 0 12
114471: PUSH
114472: LD_INT 1
114474: ARRAY
114475: ST_TO_ADDR
// ComExit ( un ) ;
114476: LD_VAR 0 10
114480: PPUSH
114481: CALL 88613 0 1
// AddComEnterUnit ( un , i ) ;
114485: LD_VAR 0 10
114489: PPUSH
114490: LD_VAR 0 4
114494: PPUSH
114495: CALL_OW 180
// SetTag ( un , 19 ) ;
114499: LD_VAR 0 10
114503: PPUSH
114504: LD_INT 19
114506: PPUSH
114507: CALL_OW 109
// mechs := mechs diff un ;
114511: LD_ADDR_VAR 0 12
114515: PUSH
114516: LD_VAR 0 12
114520: PUSH
114521: LD_VAR 0 10
114525: DIFF
114526: ST_TO_ADDR
// end ; end ;
114527: GO 114405
114529: POP
114530: POP
// if solds then
114531: LD_VAR 0 8
114535: IFFALSE 114594
// for i in solds do
114537: LD_ADDR_VAR 0 4
114541: PUSH
114542: LD_VAR 0 8
114546: PUSH
114547: FOR_IN
114548: IFFALSE 114592
// if not GetTag ( i ) then
114550: LD_VAR 0 4
114554: PPUSH
114555: CALL_OW 110
114559: NOT
114560: IFFALSE 114590
// begin defenders := defenders union i ;
114562: LD_ADDR_VAR 0 2
114566: PUSH
114567: LD_VAR 0 2
114571: PUSH
114572: LD_VAR 0 4
114576: UNION
114577: ST_TO_ADDR
// SetTag ( i , 18 ) ;
114578: LD_VAR 0 4
114582: PPUSH
114583: LD_INT 18
114585: PPUSH
114586: CALL_OW 109
// end ;
114590: GO 114547
114592: POP
114593: POP
// repeat wait ( 0 0$2 ) ;
114594: LD_INT 70
114596: PPUSH
114597: CALL_OW 67
// enemy := mc_scan [ base ] ;
114601: LD_ADDR_VAR 0 21
114605: PUSH
114606: LD_EXP 116
114610: PUSH
114611: LD_VAR 0 1
114615: ARRAY
114616: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114617: LD_EXP 93
114621: PUSH
114622: LD_VAR 0 1
114626: ARRAY
114627: NOT
114628: PUSH
114629: LD_EXP 93
114633: PUSH
114634: LD_VAR 0 1
114638: ARRAY
114639: PUSH
114640: EMPTY
114641: EQUAL
114642: OR
114643: IFFALSE 114680
// begin for i in defenders do
114645: LD_ADDR_VAR 0 4
114649: PUSH
114650: LD_VAR 0 2
114654: PUSH
114655: FOR_IN
114656: IFFALSE 114669
// ComStop ( i ) ;
114658: LD_VAR 0 4
114662: PPUSH
114663: CALL_OW 141
114667: GO 114655
114669: POP
114670: POP
// defenders := [ ] ;
114671: LD_ADDR_VAR 0 2
114675: PUSH
114676: EMPTY
114677: ST_TO_ADDR
// exit ;
114678: GO 116129
// end ; for i in defenders do
114680: LD_ADDR_VAR 0 4
114684: PUSH
114685: LD_VAR 0 2
114689: PUSH
114690: FOR_IN
114691: IFFALSE 115589
// begin e := NearestUnitToUnit ( enemy , i ) ;
114693: LD_ADDR_VAR 0 13
114697: PUSH
114698: LD_VAR 0 21
114702: PPUSH
114703: LD_VAR 0 4
114707: PPUSH
114708: CALL_OW 74
114712: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114713: LD_ADDR_VAR 0 7
114717: PUSH
114718: LD_EXP 93
114722: PUSH
114723: LD_VAR 0 1
114727: ARRAY
114728: PPUSH
114729: LD_INT 2
114731: PUSH
114732: LD_INT 30
114734: PUSH
114735: LD_INT 0
114737: PUSH
114738: EMPTY
114739: LIST
114740: LIST
114741: PUSH
114742: LD_INT 30
114744: PUSH
114745: LD_INT 1
114747: PUSH
114748: EMPTY
114749: LIST
114750: LIST
114751: PUSH
114752: EMPTY
114753: LIST
114754: LIST
114755: LIST
114756: PPUSH
114757: CALL_OW 72
114761: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
114762: LD_ADDR_VAR 0 16
114766: PUSH
114767: LD_VAR 0 7
114771: NOT
114772: PUSH
114773: LD_VAR 0 7
114777: PPUSH
114778: LD_INT 3
114780: PUSH
114781: LD_INT 24
114783: PUSH
114784: LD_INT 600
114786: PUSH
114787: EMPTY
114788: LIST
114789: LIST
114790: PUSH
114791: EMPTY
114792: LIST
114793: LIST
114794: PPUSH
114795: CALL_OW 72
114799: OR
114800: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
114801: LD_VAR 0 4
114805: PPUSH
114806: CALL_OW 247
114810: PUSH
114811: LD_INT 2
114813: DOUBLE
114814: EQUAL
114815: IFTRUE 114819
114817: GO 115215
114819: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
114820: LD_VAR 0 4
114824: PPUSH
114825: CALL_OW 256
114829: PUSH
114830: LD_INT 1000
114832: EQUAL
114833: PUSH
114834: LD_VAR 0 4
114838: PPUSH
114839: LD_VAR 0 13
114843: PPUSH
114844: CALL_OW 296
114848: PUSH
114849: LD_INT 40
114851: LESS
114852: PUSH
114853: LD_VAR 0 13
114857: PPUSH
114858: LD_EXP 118
114862: PUSH
114863: LD_VAR 0 1
114867: ARRAY
114868: PPUSH
114869: CALL_OW 308
114873: OR
114874: AND
114875: IFFALSE 114997
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
114877: LD_VAR 0 4
114881: PPUSH
114882: CALL_OW 262
114886: PUSH
114887: LD_INT 1
114889: EQUAL
114890: PUSH
114891: LD_VAR 0 4
114895: PPUSH
114896: CALL_OW 261
114900: PUSH
114901: LD_INT 30
114903: LESS
114904: AND
114905: PUSH
114906: LD_VAR 0 7
114910: AND
114911: IFFALSE 114981
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
114913: LD_VAR 0 4
114917: PPUSH
114918: LD_VAR 0 7
114922: PPUSH
114923: LD_VAR 0 4
114927: PPUSH
114928: CALL_OW 74
114932: PPUSH
114933: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
114937: LD_VAR 0 4
114941: PPUSH
114942: LD_VAR 0 7
114946: PPUSH
114947: LD_VAR 0 4
114951: PPUSH
114952: CALL_OW 74
114956: PPUSH
114957: CALL_OW 296
114961: PUSH
114962: LD_INT 6
114964: LESS
114965: IFFALSE 114979
// SetFuel ( i , 100 ) ;
114967: LD_VAR 0 4
114971: PPUSH
114972: LD_INT 100
114974: PPUSH
114975: CALL_OW 240
// end else
114979: GO 114995
// ComAttackUnit ( i , e ) ;
114981: LD_VAR 0 4
114985: PPUSH
114986: LD_VAR 0 13
114990: PPUSH
114991: CALL_OW 115
// end else
114995: GO 115098
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114997: LD_VAR 0 13
115001: PPUSH
115002: LD_EXP 118
115006: PUSH
115007: LD_VAR 0 1
115011: ARRAY
115012: PPUSH
115013: CALL_OW 308
115017: NOT
115018: PUSH
115019: LD_VAR 0 4
115023: PPUSH
115024: LD_VAR 0 13
115028: PPUSH
115029: CALL_OW 296
115033: PUSH
115034: LD_INT 40
115036: GREATEREQUAL
115037: AND
115038: PUSH
115039: LD_VAR 0 4
115043: PPUSH
115044: CALL_OW 256
115048: PUSH
115049: LD_INT 650
115051: LESSEQUAL
115052: OR
115053: PUSH
115054: LD_VAR 0 4
115058: PPUSH
115059: LD_EXP 117
115063: PUSH
115064: LD_VAR 0 1
115068: ARRAY
115069: PPUSH
115070: CALL_OW 308
115074: NOT
115075: AND
115076: IFFALSE 115098
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115078: LD_VAR 0 4
115082: PPUSH
115083: LD_EXP 117
115087: PUSH
115088: LD_VAR 0 1
115092: ARRAY
115093: PPUSH
115094: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115098: LD_VAR 0 4
115102: PPUSH
115103: CALL_OW 256
115107: PUSH
115108: LD_INT 1000
115110: LESS
115111: PUSH
115112: LD_VAR 0 4
115116: PPUSH
115117: CALL_OW 263
115121: PUSH
115122: LD_INT 1
115124: EQUAL
115125: AND
115126: PUSH
115127: LD_VAR 0 4
115131: PPUSH
115132: CALL_OW 311
115136: AND
115137: PUSH
115138: LD_VAR 0 4
115142: PPUSH
115143: LD_EXP 117
115147: PUSH
115148: LD_VAR 0 1
115152: ARRAY
115153: PPUSH
115154: CALL_OW 308
115158: AND
115159: IFFALSE 115213
// begin mech := IsDrivenBy ( i ) ;
115161: LD_ADDR_VAR 0 9
115165: PUSH
115166: LD_VAR 0 4
115170: PPUSH
115171: CALL_OW 311
115175: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
115176: LD_VAR 0 9
115180: PPUSH
115181: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
115185: LD_VAR 0 9
115189: PPUSH
115190: LD_VAR 0 4
115194: PPUSH
115195: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
115199: LD_VAR 0 9
115203: PPUSH
115204: LD_VAR 0 4
115208: PPUSH
115209: CALL_OW 180
// end ; end ; unit_human :
115213: GO 115560
115215: LD_INT 1
115217: DOUBLE
115218: EQUAL
115219: IFTRUE 115223
115221: GO 115559
115223: POP
// begin b := IsInUnit ( i ) ;
115224: LD_ADDR_VAR 0 18
115228: PUSH
115229: LD_VAR 0 4
115233: PPUSH
115234: CALL_OW 310
115238: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
115239: LD_ADDR_VAR 0 19
115243: PUSH
115244: LD_VAR 0 18
115248: NOT
115249: PUSH
115250: LD_VAR 0 18
115254: PPUSH
115255: CALL_OW 266
115259: PUSH
115260: LD_INT 32
115262: PUSH
115263: LD_INT 31
115265: PUSH
115266: EMPTY
115267: LIST
115268: LIST
115269: IN
115270: OR
115271: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
115272: LD_VAR 0 18
115276: PPUSH
115277: CALL_OW 266
115281: PUSH
115282: LD_INT 5
115284: EQUAL
115285: PUSH
115286: LD_VAR 0 4
115290: PPUSH
115291: CALL_OW 257
115295: PUSH
115296: LD_INT 1
115298: PUSH
115299: LD_INT 2
115301: PUSH
115302: LD_INT 3
115304: PUSH
115305: LD_INT 4
115307: PUSH
115308: EMPTY
115309: LIST
115310: LIST
115311: LIST
115312: LIST
115313: IN
115314: AND
115315: IFFALSE 115352
// begin class := AllowSpecClass ( i ) ;
115317: LD_ADDR_VAR 0 20
115321: PUSH
115322: LD_VAR 0 4
115326: PPUSH
115327: CALL 53274 0 1
115331: ST_TO_ADDR
// if class then
115332: LD_VAR 0 20
115336: IFFALSE 115352
// ComChangeProfession ( i , class ) ;
115338: LD_VAR 0 4
115342: PPUSH
115343: LD_VAR 0 20
115347: PPUSH
115348: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
115352: LD_VAR 0 16
115356: PUSH
115357: LD_VAR 0 2
115361: PPUSH
115362: LD_INT 21
115364: PUSH
115365: LD_INT 2
115367: PUSH
115368: EMPTY
115369: LIST
115370: LIST
115371: PPUSH
115372: CALL_OW 72
115376: PUSH
115377: LD_INT 1
115379: LESSEQUAL
115380: OR
115381: PUSH
115382: LD_VAR 0 19
115386: AND
115387: PUSH
115388: LD_VAR 0 4
115392: PUSH
115393: LD_VAR 0 17
115397: IN
115398: NOT
115399: AND
115400: IFFALSE 115493
// begin if b then
115402: LD_VAR 0 18
115406: IFFALSE 115455
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
115408: LD_VAR 0 18
115412: PPUSH
115413: LD_VAR 0 21
115417: PPUSH
115418: LD_VAR 0 18
115422: PPUSH
115423: CALL_OW 74
115427: PPUSH
115428: CALL_OW 296
115432: PUSH
115433: LD_INT 10
115435: LESS
115436: PUSH
115437: LD_VAR 0 18
115441: PPUSH
115442: CALL_OW 461
115446: PUSH
115447: LD_INT 7
115449: NONEQUAL
115450: AND
115451: IFFALSE 115455
// continue ;
115453: GO 114690
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
115455: LD_ADDR_VAR 0 17
115459: PUSH
115460: LD_VAR 0 17
115464: PPUSH
115465: LD_VAR 0 17
115469: PUSH
115470: LD_INT 1
115472: PLUS
115473: PPUSH
115474: LD_VAR 0 4
115478: PPUSH
115479: CALL_OW 1
115483: ST_TO_ADDR
// ComExitBuilding ( i ) ;
115484: LD_VAR 0 4
115488: PPUSH
115489: CALL_OW 122
// end ; if sold_defenders then
115493: LD_VAR 0 17
115497: IFFALSE 115557
// if i in sold_defenders then
115499: LD_VAR 0 4
115503: PUSH
115504: LD_VAR 0 17
115508: IN
115509: IFFALSE 115557
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
115511: LD_VAR 0 4
115515: PPUSH
115516: CALL_OW 314
115520: NOT
115521: PUSH
115522: LD_VAR 0 4
115526: PPUSH
115527: LD_VAR 0 13
115531: PPUSH
115532: CALL_OW 296
115536: PUSH
115537: LD_INT 30
115539: LESS
115540: AND
115541: IFFALSE 115557
// ComAttackUnit ( i , e ) ;
115543: LD_VAR 0 4
115547: PPUSH
115548: LD_VAR 0 13
115552: PPUSH
115553: CALL_OW 115
// end ; end ; end ;
115557: GO 115560
115559: POP
// if IsDead ( i ) then
115560: LD_VAR 0 4
115564: PPUSH
115565: CALL_OW 301
115569: IFFALSE 115587
// defenders := defenders diff i ;
115571: LD_ADDR_VAR 0 2
115575: PUSH
115576: LD_VAR 0 2
115580: PUSH
115581: LD_VAR 0 4
115585: DIFF
115586: ST_TO_ADDR
// end ;
115587: GO 114690
115589: POP
115590: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
115591: LD_VAR 0 21
115595: NOT
115596: PUSH
115597: LD_VAR 0 2
115601: NOT
115602: OR
115603: PUSH
115604: LD_EXP 93
115608: PUSH
115609: LD_VAR 0 1
115613: ARRAY
115614: NOT
115615: OR
115616: IFFALSE 114594
// MC_Reset ( base , 18 ) ;
115618: LD_VAR 0 1
115622: PPUSH
115623: LD_INT 18
115625: PPUSH
115626: CALL 25016 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115630: LD_ADDR_VAR 0 2
115634: PUSH
115635: LD_VAR 0 2
115639: PUSH
115640: LD_VAR 0 2
115644: PPUSH
115645: LD_INT 2
115647: PUSH
115648: LD_INT 25
115650: PUSH
115651: LD_INT 1
115653: PUSH
115654: EMPTY
115655: LIST
115656: LIST
115657: PUSH
115658: LD_INT 25
115660: PUSH
115661: LD_INT 5
115663: PUSH
115664: EMPTY
115665: LIST
115666: LIST
115667: PUSH
115668: LD_INT 25
115670: PUSH
115671: LD_INT 8
115673: PUSH
115674: EMPTY
115675: LIST
115676: LIST
115677: PUSH
115678: LD_INT 25
115680: PUSH
115681: LD_INT 9
115683: PUSH
115684: EMPTY
115685: LIST
115686: LIST
115687: PUSH
115688: EMPTY
115689: LIST
115690: LIST
115691: LIST
115692: LIST
115693: LIST
115694: PPUSH
115695: CALL_OW 72
115699: DIFF
115700: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
115701: LD_VAR 0 21
115705: NOT
115706: PUSH
115707: LD_VAR 0 2
115711: PPUSH
115712: LD_INT 21
115714: PUSH
115715: LD_INT 2
115717: PUSH
115718: EMPTY
115719: LIST
115720: LIST
115721: PPUSH
115722: CALL_OW 72
115726: AND
115727: IFFALSE 116065
// begin tmp := FilterByTag ( defenders , 19 ) ;
115729: LD_ADDR_VAR 0 11
115733: PUSH
115734: LD_VAR 0 2
115738: PPUSH
115739: LD_INT 19
115741: PPUSH
115742: CALL 85743 0 2
115746: ST_TO_ADDR
// if tmp then
115747: LD_VAR 0 11
115751: IFFALSE 115821
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
115753: LD_ADDR_VAR 0 11
115757: PUSH
115758: LD_VAR 0 11
115762: PPUSH
115763: LD_INT 25
115765: PUSH
115766: LD_INT 3
115768: PUSH
115769: EMPTY
115770: LIST
115771: LIST
115772: PPUSH
115773: CALL_OW 72
115777: ST_TO_ADDR
// if tmp then
115778: LD_VAR 0 11
115782: IFFALSE 115821
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
115784: LD_ADDR_EXP 105
115788: PUSH
115789: LD_EXP 105
115793: PPUSH
115794: LD_VAR 0 1
115798: PPUSH
115799: LD_EXP 105
115803: PUSH
115804: LD_VAR 0 1
115808: ARRAY
115809: PUSH
115810: LD_VAR 0 11
115814: UNION
115815: PPUSH
115816: CALL_OW 1
115820: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
115821: LD_VAR 0 1
115825: PPUSH
115826: LD_INT 19
115828: PPUSH
115829: CALL 25016 0 2
// repeat wait ( 0 0$1 ) ;
115833: LD_INT 35
115835: PPUSH
115836: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115840: LD_EXP 93
115844: PUSH
115845: LD_VAR 0 1
115849: ARRAY
115850: NOT
115851: PUSH
115852: LD_EXP 93
115856: PUSH
115857: LD_VAR 0 1
115861: ARRAY
115862: PUSH
115863: EMPTY
115864: EQUAL
115865: OR
115866: IFFALSE 115903
// begin for i in defenders do
115868: LD_ADDR_VAR 0 4
115872: PUSH
115873: LD_VAR 0 2
115877: PUSH
115878: FOR_IN
115879: IFFALSE 115892
// ComStop ( i ) ;
115881: LD_VAR 0 4
115885: PPUSH
115886: CALL_OW 141
115890: GO 115878
115892: POP
115893: POP
// defenders := [ ] ;
115894: LD_ADDR_VAR 0 2
115898: PUSH
115899: EMPTY
115900: ST_TO_ADDR
// exit ;
115901: GO 116129
// end ; for i in defenders do
115903: LD_ADDR_VAR 0 4
115907: PUSH
115908: LD_VAR 0 2
115912: PUSH
115913: FOR_IN
115914: IFFALSE 116003
// begin if not IsInArea ( i , mc_parking [ base ] ) then
115916: LD_VAR 0 4
115920: PPUSH
115921: LD_EXP 117
115925: PUSH
115926: LD_VAR 0 1
115930: ARRAY
115931: PPUSH
115932: CALL_OW 308
115936: NOT
115937: IFFALSE 115961
// ComMoveToArea ( i , mc_parking [ base ] ) else
115939: LD_VAR 0 4
115943: PPUSH
115944: LD_EXP 117
115948: PUSH
115949: LD_VAR 0 1
115953: ARRAY
115954: PPUSH
115955: CALL_OW 113
115959: GO 116001
// if GetControl ( i ) = control_manual then
115961: LD_VAR 0 4
115965: PPUSH
115966: CALL_OW 263
115970: PUSH
115971: LD_INT 1
115973: EQUAL
115974: IFFALSE 116001
// if IsDrivenBy ( i ) then
115976: LD_VAR 0 4
115980: PPUSH
115981: CALL_OW 311
115985: IFFALSE 116001
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
115987: LD_VAR 0 4
115991: PPUSH
115992: CALL_OW 311
115996: PPUSH
115997: CALL_OW 121
// end ;
116001: GO 115913
116003: POP
116004: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116005: LD_VAR 0 2
116009: PPUSH
116010: LD_INT 95
116012: PUSH
116013: LD_EXP 117
116017: PUSH
116018: LD_VAR 0 1
116022: ARRAY
116023: PUSH
116024: EMPTY
116025: LIST
116026: LIST
116027: PPUSH
116028: CALL_OW 72
116032: PUSH
116033: LD_VAR 0 2
116037: EQUAL
116038: PUSH
116039: LD_EXP 116
116043: PUSH
116044: LD_VAR 0 1
116048: ARRAY
116049: OR
116050: PUSH
116051: LD_EXP 93
116055: PUSH
116056: LD_VAR 0 1
116060: ARRAY
116061: NOT
116062: OR
116063: IFFALSE 115833
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116065: LD_ADDR_EXP 115
116069: PUSH
116070: LD_EXP 115
116074: PPUSH
116075: LD_VAR 0 1
116079: PPUSH
116080: LD_VAR 0 2
116084: PPUSH
116085: LD_INT 21
116087: PUSH
116088: LD_INT 2
116090: PUSH
116091: EMPTY
116092: LIST
116093: LIST
116094: PPUSH
116095: CALL_OW 72
116099: PPUSH
116100: CALL_OW 1
116104: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116105: LD_VAR 0 1
116109: PPUSH
116110: LD_INT 19
116112: PPUSH
116113: CALL 25016 0 2
// MC_Reset ( base , 20 ) ;
116117: LD_VAR 0 1
116121: PPUSH
116122: LD_INT 20
116124: PPUSH
116125: CALL 25016 0 2
// end ; end_of_file
116129: LD_VAR 0 3
116133: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
116134: LD_VAR 0 1
116138: PUSH
116139: LD_INT 200
116141: DOUBLE
116142: GREATEREQUAL
116143: IFFALSE 116151
116145: LD_INT 299
116147: DOUBLE
116148: LESSEQUAL
116149: IFTRUE 116153
116151: GO 116185
116153: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
116154: LD_VAR 0 1
116158: PPUSH
116159: LD_VAR 0 2
116163: PPUSH
116164: LD_VAR 0 3
116168: PPUSH
116169: LD_VAR 0 4
116173: PPUSH
116174: LD_VAR 0 5
116178: PPUSH
116179: CALL 104950 0 5
116183: GO 116262
116185: LD_INT 300
116187: DOUBLE
116188: GREATEREQUAL
116189: IFFALSE 116197
116191: LD_INT 399
116193: DOUBLE
116194: LESSEQUAL
116195: IFTRUE 116199
116197: GO 116261
116199: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
116200: LD_VAR 0 1
116204: PPUSH
116205: LD_VAR 0 2
116209: PPUSH
116210: LD_VAR 0 3
116214: PPUSH
116215: LD_VAR 0 4
116219: PPUSH
116220: LD_VAR 0 5
116224: PPUSH
116225: LD_VAR 0 6
116229: PPUSH
116230: LD_VAR 0 7
116234: PPUSH
116235: LD_VAR 0 8
116239: PPUSH
116240: LD_VAR 0 9
116244: PPUSH
116245: LD_VAR 0 10
116249: PPUSH
116250: LD_VAR 0 11
116254: PPUSH
116255: CALL 102848 0 11
116259: GO 116262
116261: POP
// end ;
116262: PPOPN 11
116264: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
116265: LD_VAR 0 1
116269: PPUSH
116270: LD_VAR 0 2
116274: PPUSH
116275: LD_VAR 0 3
116279: PPUSH
116280: LD_VAR 0 4
116284: PPUSH
116285: LD_VAR 0 5
116289: PPUSH
116290: CALL 104942 0 5
// end ; end_of_file
116294: PPOPN 5
116296: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
116297: LD_VAR 0 1
116301: PPUSH
116302: LD_VAR 0 2
116306: PPUSH
116307: LD_VAR 0 3
116311: PPUSH
116312: LD_VAR 0 4
116316: PPUSH
116317: LD_VAR 0 5
116321: PPUSH
116322: LD_VAR 0 6
116326: PPUSH
116327: CALL 91043 0 6
// end ;
116331: PPOPN 6
116333: END
