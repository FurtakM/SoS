// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20794 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22959 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 116
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 117
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44324 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45384 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45477 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 121
 338: PUSH
 339: LD_EXP 121
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44642 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44827 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45384 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45477 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44642 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44827 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45257 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44324 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45384 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45477 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 121
 826: PUSH
 827: LD_EXP 121
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44642 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44827 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45384 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45477 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45795 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45589 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44642 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44827 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45208 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 51053 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 51053 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 51053 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 51053 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 51053 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 51053 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 51053 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 51053 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 51053 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 51053 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 51053 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 51053 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 51053 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 51053 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 51053 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 51053 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 51053 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 51053 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 51053 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 51053 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 51053 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 51053 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 51053 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 51053 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 51053 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 51053 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 51053 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 51053 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 51053 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 51053 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 51053 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 51053 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 51053 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 51053 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 55877 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 55877 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 55877 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 55877 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 55877 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 55877 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 55877 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 55877 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 55877 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 55877 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 55877 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 55877 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 55877 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 5
4442: PPUSH
4443: LD_INT 267
4445: PPUSH
4446: LD_INT 226
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 55877 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 55877 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 51053 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 51053 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 51053 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 51053 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 51053 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 51053 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 51053 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 51053 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 51053 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 51053 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 92
5426: PUSH
5427: LD_EXP 92
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 46108 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44690 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44690 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 46108 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 46108 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 111
5909: PUSH
5910: LD_EXP 111
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 111
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44690 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59318 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 92
6683: PUSH
6684: LD_EXP 92
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 51053 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59318 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 92
7213: PUSH
7214: LD_EXP 92
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 46108 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44690 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44690 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 46108 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 46108 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 111
7862: PUSH
7863: LD_EXP 111
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 111
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59318 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 92
8824: PUSH
8825: LD_EXP 92
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 87375 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 87436 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 87436 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 46108 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44690 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44690 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44690 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 46108 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 46108 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 111
9864: PUSH
9865: LD_EXP 111
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 111
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44690 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 48101 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50435 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49503 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 58856 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49744 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47797 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47417 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 47007 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46845 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46620 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46505 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50696 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 50912 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46314 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 101987 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21036 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21036 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21036 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21036 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 84001 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 84001 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 84001 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 84001 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$50 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1750
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 87605 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 87605 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 87605 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// class_mastodont := 31 ;
20765: LD_ADDR_EXP 88
20769: PUSH
20770: LD_INT 31
20772: ST_TO_ADDR
// class_horse := 21 ;
20773: LD_ADDR_EXP 89
20777: PUSH
20778: LD_INT 21
20780: ST_TO_ADDR
// end ;
20781: LD_VAR 0 1
20785: RET
// every 1 do
20786: GO 20788
20788: DISABLE
// InitGlobalVariables ; end_of_file
20789: CALL 20634 0 0
20793: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20794: LD_INT 0
20796: PPUSH
20797: PPUSH
// skirmish := false ;
20798: LD_ADDR_EXP 90
20802: PUSH
20803: LD_INT 0
20805: ST_TO_ADDR
// debug_mc := false ;
20806: LD_ADDR_EXP 91
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// mc_bases := [ ] ;
20814: LD_ADDR_EXP 92
20818: PUSH
20819: EMPTY
20820: ST_TO_ADDR
// mc_sides := [ ] ;
20821: LD_ADDR_EXP 118
20825: PUSH
20826: EMPTY
20827: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20828: LD_ADDR_EXP 93
20832: PUSH
20833: EMPTY
20834: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20835: LD_ADDR_EXP 94
20839: PUSH
20840: EMPTY
20841: ST_TO_ADDR
// mc_need_heal := [ ] ;
20842: LD_ADDR_EXP 95
20846: PUSH
20847: EMPTY
20848: ST_TO_ADDR
// mc_healers := [ ] ;
20849: LD_ADDR_EXP 96
20853: PUSH
20854: EMPTY
20855: ST_TO_ADDR
// mc_build_list := [ ] ;
20856: LD_ADDR_EXP 97
20860: PUSH
20861: EMPTY
20862: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20863: LD_ADDR_EXP 124
20867: PUSH
20868: EMPTY
20869: ST_TO_ADDR
// mc_builders := [ ] ;
20870: LD_ADDR_EXP 98
20874: PUSH
20875: EMPTY
20876: ST_TO_ADDR
// mc_construct_list := [ ] ;
20877: LD_ADDR_EXP 99
20881: PUSH
20882: EMPTY
20883: ST_TO_ADDR
// mc_turret_list := [ ] ;
20884: LD_ADDR_EXP 100
20888: PUSH
20889: EMPTY
20890: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20891: LD_ADDR_EXP 101
20895: PUSH
20896: EMPTY
20897: ST_TO_ADDR
// mc_miners := [ ] ;
20898: LD_ADDR_EXP 106
20902: PUSH
20903: EMPTY
20904: ST_TO_ADDR
// mc_mines := [ ] ;
20905: LD_ADDR_EXP 105
20909: PUSH
20910: EMPTY
20911: ST_TO_ADDR
// mc_minefields := [ ] ;
20912: LD_ADDR_EXP 107
20916: PUSH
20917: EMPTY
20918: ST_TO_ADDR
// mc_crates := [ ] ;
20919: LD_ADDR_EXP 108
20923: PUSH
20924: EMPTY
20925: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20926: LD_ADDR_EXP 109
20930: PUSH
20931: EMPTY
20932: ST_TO_ADDR
// mc_crates_area := [ ] ;
20933: LD_ADDR_EXP 110
20937: PUSH
20938: EMPTY
20939: ST_TO_ADDR
// mc_vehicles := [ ] ;
20940: LD_ADDR_EXP 111
20944: PUSH
20945: EMPTY
20946: ST_TO_ADDR
// mc_attack := [ ] ;
20947: LD_ADDR_EXP 112
20951: PUSH
20952: EMPTY
20953: ST_TO_ADDR
// mc_produce := [ ] ;
20954: LD_ADDR_EXP 113
20958: PUSH
20959: EMPTY
20960: ST_TO_ADDR
// mc_defender := [ ] ;
20961: LD_ADDR_EXP 114
20965: PUSH
20966: EMPTY
20967: ST_TO_ADDR
// mc_parking := [ ] ;
20968: LD_ADDR_EXP 116
20972: PUSH
20973: EMPTY
20974: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20975: LD_ADDR_EXP 102
20979: PUSH
20980: EMPTY
20981: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20982: LD_ADDR_EXP 104
20986: PUSH
20987: EMPTY
20988: ST_TO_ADDR
// mc_scan := [ ] ;
20989: LD_ADDR_EXP 115
20993: PUSH
20994: EMPTY
20995: ST_TO_ADDR
// mc_scan_area := [ ] ;
20996: LD_ADDR_EXP 117
21000: PUSH
21001: EMPTY
21002: ST_TO_ADDR
// mc_tech := [ ] ;
21003: LD_ADDR_EXP 119
21007: PUSH
21008: EMPTY
21009: ST_TO_ADDR
// mc_class := [ ] ;
21010: LD_ADDR_EXP 133
21014: PUSH
21015: EMPTY
21016: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21017: LD_ADDR_EXP 134
21021: PUSH
21022: EMPTY
21023: ST_TO_ADDR
// mc_is_defending := [ ] ;
21024: LD_ADDR_EXP 135
21028: PUSH
21029: EMPTY
21030: ST_TO_ADDR
// end ;
21031: LD_VAR 0 1
21035: RET
// export function MC_Kill ( base ) ; begin
21036: LD_INT 0
21038: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21039: LD_ADDR_EXP 92
21043: PUSH
21044: LD_EXP 92
21048: PPUSH
21049: LD_VAR 0 1
21053: PPUSH
21054: EMPTY
21055: PPUSH
21056: CALL_OW 1
21060: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21061: LD_ADDR_EXP 93
21065: PUSH
21066: LD_EXP 93
21070: PPUSH
21071: LD_VAR 0 1
21075: PPUSH
21076: EMPTY
21077: PPUSH
21078: CALL_OW 1
21082: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21083: LD_ADDR_EXP 94
21087: PUSH
21088: LD_EXP 94
21092: PPUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: EMPTY
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21105: LD_ADDR_EXP 95
21109: PUSH
21110: LD_EXP 95
21114: PPUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: EMPTY
21121: PPUSH
21122: CALL_OW 1
21126: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21127: LD_ADDR_EXP 96
21131: PUSH
21132: LD_EXP 96
21136: PPUSH
21137: LD_VAR 0 1
21141: PPUSH
21142: EMPTY
21143: PPUSH
21144: CALL_OW 1
21148: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21149: LD_ADDR_EXP 97
21153: PUSH
21154: LD_EXP 97
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: EMPTY
21165: PPUSH
21166: CALL_OW 1
21170: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21171: LD_ADDR_EXP 98
21175: PUSH
21176: LD_EXP 98
21180: PPUSH
21181: LD_VAR 0 1
21185: PPUSH
21186: EMPTY
21187: PPUSH
21188: CALL_OW 1
21192: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21193: LD_ADDR_EXP 99
21197: PUSH
21198: LD_EXP 99
21202: PPUSH
21203: LD_VAR 0 1
21207: PPUSH
21208: EMPTY
21209: PPUSH
21210: CALL_OW 1
21214: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21215: LD_ADDR_EXP 100
21219: PUSH
21220: LD_EXP 100
21224: PPUSH
21225: LD_VAR 0 1
21229: PPUSH
21230: EMPTY
21231: PPUSH
21232: CALL_OW 1
21236: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21237: LD_ADDR_EXP 101
21241: PUSH
21242: LD_EXP 101
21246: PPUSH
21247: LD_VAR 0 1
21251: PPUSH
21252: EMPTY
21253: PPUSH
21254: CALL_OW 1
21258: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21259: LD_ADDR_EXP 102
21263: PUSH
21264: LD_EXP 102
21268: PPUSH
21269: LD_VAR 0 1
21273: PPUSH
21274: EMPTY
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21281: LD_ADDR_EXP 103
21285: PUSH
21286: LD_EXP 103
21290: PPUSH
21291: LD_VAR 0 1
21295: PPUSH
21296: LD_INT 0
21298: PPUSH
21299: CALL_OW 1
21303: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21304: LD_ADDR_EXP 104
21308: PUSH
21309: LD_EXP 104
21313: PPUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: EMPTY
21320: PPUSH
21321: CALL_OW 1
21325: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21326: LD_ADDR_EXP 105
21330: PUSH
21331: LD_EXP 105
21335: PPUSH
21336: LD_VAR 0 1
21340: PPUSH
21341: EMPTY
21342: PPUSH
21343: CALL_OW 1
21347: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21348: LD_ADDR_EXP 106
21352: PUSH
21353: LD_EXP 106
21357: PPUSH
21358: LD_VAR 0 1
21362: PPUSH
21363: EMPTY
21364: PPUSH
21365: CALL_OW 1
21369: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21370: LD_ADDR_EXP 107
21374: PUSH
21375: LD_EXP 107
21379: PPUSH
21380: LD_VAR 0 1
21384: PPUSH
21385: EMPTY
21386: PPUSH
21387: CALL_OW 1
21391: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21392: LD_ADDR_EXP 108
21396: PUSH
21397: LD_EXP 108
21401: PPUSH
21402: LD_VAR 0 1
21406: PPUSH
21407: EMPTY
21408: PPUSH
21409: CALL_OW 1
21413: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21414: LD_ADDR_EXP 109
21418: PUSH
21419: LD_EXP 109
21423: PPUSH
21424: LD_VAR 0 1
21428: PPUSH
21429: EMPTY
21430: PPUSH
21431: CALL_OW 1
21435: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21436: LD_ADDR_EXP 110
21440: PUSH
21441: LD_EXP 110
21445: PPUSH
21446: LD_VAR 0 1
21450: PPUSH
21451: EMPTY
21452: PPUSH
21453: CALL_OW 1
21457: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21458: LD_ADDR_EXP 111
21462: PUSH
21463: LD_EXP 111
21467: PPUSH
21468: LD_VAR 0 1
21472: PPUSH
21473: EMPTY
21474: PPUSH
21475: CALL_OW 1
21479: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21480: LD_ADDR_EXP 112
21484: PUSH
21485: LD_EXP 112
21489: PPUSH
21490: LD_VAR 0 1
21494: PPUSH
21495: EMPTY
21496: PPUSH
21497: CALL_OW 1
21501: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21502: LD_ADDR_EXP 113
21506: PUSH
21507: LD_EXP 113
21511: PPUSH
21512: LD_VAR 0 1
21516: PPUSH
21517: EMPTY
21518: PPUSH
21519: CALL_OW 1
21523: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21524: LD_ADDR_EXP 114
21528: PUSH
21529: LD_EXP 114
21533: PPUSH
21534: LD_VAR 0 1
21538: PPUSH
21539: EMPTY
21540: PPUSH
21541: CALL_OW 1
21545: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21546: LD_ADDR_EXP 115
21550: PUSH
21551: LD_EXP 115
21555: PPUSH
21556: LD_VAR 0 1
21560: PPUSH
21561: EMPTY
21562: PPUSH
21563: CALL_OW 1
21567: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21568: LD_ADDR_EXP 116
21572: PUSH
21573: LD_EXP 116
21577: PPUSH
21578: LD_VAR 0 1
21582: PPUSH
21583: EMPTY
21584: PPUSH
21585: CALL_OW 1
21589: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21590: LD_ADDR_EXP 117
21594: PUSH
21595: LD_EXP 117
21599: PPUSH
21600: LD_VAR 0 1
21604: PPUSH
21605: EMPTY
21606: PPUSH
21607: CALL_OW 1
21611: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21612: LD_ADDR_EXP 119
21616: PUSH
21617: LD_EXP 119
21621: PPUSH
21622: LD_VAR 0 1
21626: PPUSH
21627: EMPTY
21628: PPUSH
21629: CALL_OW 1
21633: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21634: LD_ADDR_EXP 121
21638: PUSH
21639: LD_EXP 121
21643: PPUSH
21644: LD_VAR 0 1
21648: PPUSH
21649: EMPTY
21650: PPUSH
21651: CALL_OW 1
21655: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21656: LD_ADDR_EXP 122
21660: PUSH
21661: LD_EXP 122
21665: PPUSH
21666: LD_VAR 0 1
21670: PPUSH
21671: EMPTY
21672: PPUSH
21673: CALL_OW 1
21677: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21678: LD_ADDR_EXP 123
21682: PUSH
21683: LD_EXP 123
21687: PPUSH
21688: LD_VAR 0 1
21692: PPUSH
21693: EMPTY
21694: PPUSH
21695: CALL_OW 1
21699: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21700: LD_ADDR_EXP 124
21704: PUSH
21705: LD_EXP 124
21709: PPUSH
21710: LD_VAR 0 1
21714: PPUSH
21715: EMPTY
21716: PPUSH
21717: CALL_OW 1
21721: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21722: LD_ADDR_EXP 125
21726: PUSH
21727: LD_EXP 125
21731: PPUSH
21732: LD_VAR 0 1
21736: PPUSH
21737: EMPTY
21738: PPUSH
21739: CALL_OW 1
21743: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21744: LD_ADDR_EXP 126
21748: PUSH
21749: LD_EXP 126
21753: PPUSH
21754: LD_VAR 0 1
21758: PPUSH
21759: EMPTY
21760: PPUSH
21761: CALL_OW 1
21765: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21766: LD_ADDR_EXP 127
21770: PUSH
21771: LD_EXP 127
21775: PPUSH
21776: LD_VAR 0 1
21780: PPUSH
21781: EMPTY
21782: PPUSH
21783: CALL_OW 1
21787: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21788: LD_ADDR_EXP 128
21792: PUSH
21793: LD_EXP 128
21797: PPUSH
21798: LD_VAR 0 1
21802: PPUSH
21803: EMPTY
21804: PPUSH
21805: CALL_OW 1
21809: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21810: LD_ADDR_EXP 129
21814: PUSH
21815: LD_EXP 129
21819: PPUSH
21820: LD_VAR 0 1
21824: PPUSH
21825: EMPTY
21826: PPUSH
21827: CALL_OW 1
21831: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21832: LD_ADDR_EXP 130
21836: PUSH
21837: LD_EXP 130
21841: PPUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: EMPTY
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21854: LD_ADDR_EXP 131
21858: PUSH
21859: LD_EXP 131
21863: PPUSH
21864: LD_VAR 0 1
21868: PPUSH
21869: EMPTY
21870: PPUSH
21871: CALL_OW 1
21875: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21876: LD_ADDR_EXP 132
21880: PUSH
21881: LD_EXP 132
21885: PPUSH
21886: LD_VAR 0 1
21890: PPUSH
21891: EMPTY
21892: PPUSH
21893: CALL_OW 1
21897: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21898: LD_ADDR_EXP 133
21902: PUSH
21903: LD_EXP 133
21907: PPUSH
21908: LD_VAR 0 1
21912: PPUSH
21913: EMPTY
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21920: LD_ADDR_EXP 134
21924: PUSH
21925: LD_EXP 134
21929: PPUSH
21930: LD_VAR 0 1
21934: PPUSH
21935: LD_INT 0
21937: PPUSH
21938: CALL_OW 1
21942: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
21943: LD_ADDR_EXP 135
21947: PUSH
21948: LD_EXP 135
21952: PPUSH
21953: LD_VAR 0 1
21957: PPUSH
21958: LD_INT 0
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// end ;
21966: LD_VAR 0 2
21970: RET
// export function MC_Add ( side , units ) ; var base ; begin
21971: LD_INT 0
21973: PPUSH
21974: PPUSH
// base := mc_bases + 1 ;
21975: LD_ADDR_VAR 0 4
21979: PUSH
21980: LD_EXP 92
21984: PUSH
21985: LD_INT 1
21987: PLUS
21988: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21989: LD_ADDR_EXP 118
21993: PUSH
21994: LD_EXP 118
21998: PPUSH
21999: LD_VAR 0 4
22003: PPUSH
22004: LD_VAR 0 1
22008: PPUSH
22009: CALL_OW 1
22013: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22014: LD_ADDR_EXP 92
22018: PUSH
22019: LD_EXP 92
22023: PPUSH
22024: LD_VAR 0 4
22028: PPUSH
22029: LD_VAR 0 2
22033: PPUSH
22034: CALL_OW 1
22038: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22039: LD_ADDR_EXP 93
22043: PUSH
22044: LD_EXP 93
22048: PPUSH
22049: LD_VAR 0 4
22053: PPUSH
22054: EMPTY
22055: PPUSH
22056: CALL_OW 1
22060: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22061: LD_ADDR_EXP 94
22065: PUSH
22066: LD_EXP 94
22070: PPUSH
22071: LD_VAR 0 4
22075: PPUSH
22076: EMPTY
22077: PPUSH
22078: CALL_OW 1
22082: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22083: LD_ADDR_EXP 95
22087: PUSH
22088: LD_EXP 95
22092: PPUSH
22093: LD_VAR 0 4
22097: PPUSH
22098: EMPTY
22099: PPUSH
22100: CALL_OW 1
22104: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22105: LD_ADDR_EXP 96
22109: PUSH
22110: LD_EXP 96
22114: PPUSH
22115: LD_VAR 0 4
22119: PPUSH
22120: EMPTY
22121: PPUSH
22122: CALL_OW 1
22126: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22127: LD_ADDR_EXP 97
22131: PUSH
22132: LD_EXP 97
22136: PPUSH
22137: LD_VAR 0 4
22141: PPUSH
22142: EMPTY
22143: PPUSH
22144: CALL_OW 1
22148: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22149: LD_ADDR_EXP 98
22153: PUSH
22154: LD_EXP 98
22158: PPUSH
22159: LD_VAR 0 4
22163: PPUSH
22164: EMPTY
22165: PPUSH
22166: CALL_OW 1
22170: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22171: LD_ADDR_EXP 99
22175: PUSH
22176: LD_EXP 99
22180: PPUSH
22181: LD_VAR 0 4
22185: PPUSH
22186: EMPTY
22187: PPUSH
22188: CALL_OW 1
22192: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22193: LD_ADDR_EXP 100
22197: PUSH
22198: LD_EXP 100
22202: PPUSH
22203: LD_VAR 0 4
22207: PPUSH
22208: EMPTY
22209: PPUSH
22210: CALL_OW 1
22214: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22215: LD_ADDR_EXP 101
22219: PUSH
22220: LD_EXP 101
22224: PPUSH
22225: LD_VAR 0 4
22229: PPUSH
22230: EMPTY
22231: PPUSH
22232: CALL_OW 1
22236: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22237: LD_ADDR_EXP 102
22241: PUSH
22242: LD_EXP 102
22246: PPUSH
22247: LD_VAR 0 4
22251: PPUSH
22252: EMPTY
22253: PPUSH
22254: CALL_OW 1
22258: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22259: LD_ADDR_EXP 103
22263: PUSH
22264: LD_EXP 103
22268: PPUSH
22269: LD_VAR 0 4
22273: PPUSH
22274: LD_INT 0
22276: PPUSH
22277: CALL_OW 1
22281: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22282: LD_ADDR_EXP 104
22286: PUSH
22287: LD_EXP 104
22291: PPUSH
22292: LD_VAR 0 4
22296: PPUSH
22297: EMPTY
22298: PPUSH
22299: CALL_OW 1
22303: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22304: LD_ADDR_EXP 105
22308: PUSH
22309: LD_EXP 105
22313: PPUSH
22314: LD_VAR 0 4
22318: PPUSH
22319: EMPTY
22320: PPUSH
22321: CALL_OW 1
22325: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22326: LD_ADDR_EXP 106
22330: PUSH
22331: LD_EXP 106
22335: PPUSH
22336: LD_VAR 0 4
22340: PPUSH
22341: EMPTY
22342: PPUSH
22343: CALL_OW 1
22347: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22348: LD_ADDR_EXP 107
22352: PUSH
22353: LD_EXP 107
22357: PPUSH
22358: LD_VAR 0 4
22362: PPUSH
22363: EMPTY
22364: PPUSH
22365: CALL_OW 1
22369: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22370: LD_ADDR_EXP 108
22374: PUSH
22375: LD_EXP 108
22379: PPUSH
22380: LD_VAR 0 4
22384: PPUSH
22385: EMPTY
22386: PPUSH
22387: CALL_OW 1
22391: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22392: LD_ADDR_EXP 109
22396: PUSH
22397: LD_EXP 109
22401: PPUSH
22402: LD_VAR 0 4
22406: PPUSH
22407: EMPTY
22408: PPUSH
22409: CALL_OW 1
22413: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22414: LD_ADDR_EXP 110
22418: PUSH
22419: LD_EXP 110
22423: PPUSH
22424: LD_VAR 0 4
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22436: LD_ADDR_EXP 111
22440: PUSH
22441: LD_EXP 111
22445: PPUSH
22446: LD_VAR 0 4
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22458: LD_ADDR_EXP 112
22462: PUSH
22463: LD_EXP 112
22467: PPUSH
22468: LD_VAR 0 4
22472: PPUSH
22473: EMPTY
22474: PPUSH
22475: CALL_OW 1
22479: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22480: LD_ADDR_EXP 113
22484: PUSH
22485: LD_EXP 113
22489: PPUSH
22490: LD_VAR 0 4
22494: PPUSH
22495: EMPTY
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22502: LD_ADDR_EXP 114
22506: PUSH
22507: LD_EXP 114
22511: PPUSH
22512: LD_VAR 0 4
22516: PPUSH
22517: EMPTY
22518: PPUSH
22519: CALL_OW 1
22523: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22524: LD_ADDR_EXP 115
22528: PUSH
22529: LD_EXP 115
22533: PPUSH
22534: LD_VAR 0 4
22538: PPUSH
22539: EMPTY
22540: PPUSH
22541: CALL_OW 1
22545: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22546: LD_ADDR_EXP 116
22550: PUSH
22551: LD_EXP 116
22555: PPUSH
22556: LD_VAR 0 4
22560: PPUSH
22561: EMPTY
22562: PPUSH
22563: CALL_OW 1
22567: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22568: LD_ADDR_EXP 117
22572: PUSH
22573: LD_EXP 117
22577: PPUSH
22578: LD_VAR 0 4
22582: PPUSH
22583: EMPTY
22584: PPUSH
22585: CALL_OW 1
22589: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22590: LD_ADDR_EXP 119
22594: PUSH
22595: LD_EXP 119
22599: PPUSH
22600: LD_VAR 0 4
22604: PPUSH
22605: EMPTY
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22612: LD_ADDR_EXP 121
22616: PUSH
22617: LD_EXP 121
22621: PPUSH
22622: LD_VAR 0 4
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22634: LD_ADDR_EXP 122
22638: PUSH
22639: LD_EXP 122
22643: PPUSH
22644: LD_VAR 0 4
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22656: LD_ADDR_EXP 123
22660: PUSH
22661: LD_EXP 123
22665: PPUSH
22666: LD_VAR 0 4
22670: PPUSH
22671: EMPTY
22672: PPUSH
22673: CALL_OW 1
22677: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22678: LD_ADDR_EXP 124
22682: PUSH
22683: LD_EXP 124
22687: PPUSH
22688: LD_VAR 0 4
22692: PPUSH
22693: EMPTY
22694: PPUSH
22695: CALL_OW 1
22699: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22700: LD_ADDR_EXP 125
22704: PUSH
22705: LD_EXP 125
22709: PPUSH
22710: LD_VAR 0 4
22714: PPUSH
22715: EMPTY
22716: PPUSH
22717: CALL_OW 1
22721: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22722: LD_ADDR_EXP 126
22726: PUSH
22727: LD_EXP 126
22731: PPUSH
22732: LD_VAR 0 4
22736: PPUSH
22737: EMPTY
22738: PPUSH
22739: CALL_OW 1
22743: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22744: LD_ADDR_EXP 127
22748: PUSH
22749: LD_EXP 127
22753: PPUSH
22754: LD_VAR 0 4
22758: PPUSH
22759: EMPTY
22760: PPUSH
22761: CALL_OW 1
22765: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22766: LD_ADDR_EXP 128
22770: PUSH
22771: LD_EXP 128
22775: PPUSH
22776: LD_VAR 0 4
22780: PPUSH
22781: EMPTY
22782: PPUSH
22783: CALL_OW 1
22787: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22788: LD_ADDR_EXP 129
22792: PUSH
22793: LD_EXP 129
22797: PPUSH
22798: LD_VAR 0 4
22802: PPUSH
22803: EMPTY
22804: PPUSH
22805: CALL_OW 1
22809: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22810: LD_ADDR_EXP 130
22814: PUSH
22815: LD_EXP 130
22819: PPUSH
22820: LD_VAR 0 4
22824: PPUSH
22825: EMPTY
22826: PPUSH
22827: CALL_OW 1
22831: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22832: LD_ADDR_EXP 131
22836: PUSH
22837: LD_EXP 131
22841: PPUSH
22842: LD_VAR 0 4
22846: PPUSH
22847: EMPTY
22848: PPUSH
22849: CALL_OW 1
22853: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22854: LD_ADDR_EXP 132
22858: PUSH
22859: LD_EXP 132
22863: PPUSH
22864: LD_VAR 0 4
22868: PPUSH
22869: EMPTY
22870: PPUSH
22871: CALL_OW 1
22875: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22876: LD_ADDR_EXP 133
22880: PUSH
22881: LD_EXP 133
22885: PPUSH
22886: LD_VAR 0 4
22890: PPUSH
22891: EMPTY
22892: PPUSH
22893: CALL_OW 1
22897: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22898: LD_ADDR_EXP 134
22902: PUSH
22903: LD_EXP 134
22907: PPUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_INT 0
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22921: LD_ADDR_EXP 135
22925: PUSH
22926: LD_EXP 135
22930: PPUSH
22931: LD_VAR 0 4
22935: PPUSH
22936: LD_INT 0
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
// result := base ;
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_VAR 0 4
22953: ST_TO_ADDR
// end ;
22954: LD_VAR 0 3
22958: RET
// export function MC_Start ( ) ; var i ; begin
22959: LD_INT 0
22961: PPUSH
22962: PPUSH
// for i = 1 to mc_bases do
22963: LD_ADDR_VAR 0 2
22967: PUSH
22968: DOUBLE
22969: LD_INT 1
22971: DEC
22972: ST_TO_ADDR
22973: LD_EXP 92
22977: PUSH
22978: FOR_TO
22979: IFFALSE 24056
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22981: LD_ADDR_EXP 92
22985: PUSH
22986: LD_EXP 92
22990: PPUSH
22991: LD_VAR 0 2
22995: PPUSH
22996: LD_EXP 92
23000: PUSH
23001: LD_VAR 0 2
23005: ARRAY
23006: PUSH
23007: LD_INT 0
23009: DIFF
23010: PPUSH
23011: CALL_OW 1
23015: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23016: LD_ADDR_EXP 93
23020: PUSH
23021: LD_EXP 93
23025: PPUSH
23026: LD_VAR 0 2
23030: PPUSH
23031: EMPTY
23032: PPUSH
23033: CALL_OW 1
23037: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23038: LD_ADDR_EXP 94
23042: PUSH
23043: LD_EXP 94
23047: PPUSH
23048: LD_VAR 0 2
23052: PPUSH
23053: EMPTY
23054: PPUSH
23055: CALL_OW 1
23059: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23060: LD_ADDR_EXP 95
23064: PUSH
23065: LD_EXP 95
23069: PPUSH
23070: LD_VAR 0 2
23074: PPUSH
23075: EMPTY
23076: PPUSH
23077: CALL_OW 1
23081: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23082: LD_ADDR_EXP 96
23086: PUSH
23087: LD_EXP 96
23091: PPUSH
23092: LD_VAR 0 2
23096: PPUSH
23097: EMPTY
23098: PUSH
23099: EMPTY
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 1
23109: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23110: LD_ADDR_EXP 97
23114: PUSH
23115: LD_EXP 97
23119: PPUSH
23120: LD_VAR 0 2
23124: PPUSH
23125: EMPTY
23126: PPUSH
23127: CALL_OW 1
23131: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23132: LD_ADDR_EXP 124
23136: PUSH
23137: LD_EXP 124
23141: PPUSH
23142: LD_VAR 0 2
23146: PPUSH
23147: EMPTY
23148: PPUSH
23149: CALL_OW 1
23153: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23154: LD_ADDR_EXP 98
23158: PUSH
23159: LD_EXP 98
23163: PPUSH
23164: LD_VAR 0 2
23168: PPUSH
23169: EMPTY
23170: PPUSH
23171: CALL_OW 1
23175: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23176: LD_ADDR_EXP 99
23180: PUSH
23181: LD_EXP 99
23185: PPUSH
23186: LD_VAR 0 2
23190: PPUSH
23191: EMPTY
23192: PPUSH
23193: CALL_OW 1
23197: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23198: LD_ADDR_EXP 100
23202: PUSH
23203: LD_EXP 100
23207: PPUSH
23208: LD_VAR 0 2
23212: PPUSH
23213: LD_EXP 92
23217: PUSH
23218: LD_VAR 0 2
23222: ARRAY
23223: PPUSH
23224: LD_INT 2
23226: PUSH
23227: LD_INT 30
23229: PUSH
23230: LD_INT 32
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: PUSH
23237: LD_INT 30
23239: PUSH
23240: LD_INT 33
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: EMPTY
23248: LIST
23249: LIST
23250: LIST
23251: PPUSH
23252: CALL_OW 72
23256: PPUSH
23257: CALL_OW 1
23261: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23262: LD_ADDR_EXP 101
23266: PUSH
23267: LD_EXP 101
23271: PPUSH
23272: LD_VAR 0 2
23276: PPUSH
23277: LD_EXP 92
23281: PUSH
23282: LD_VAR 0 2
23286: ARRAY
23287: PPUSH
23288: LD_INT 2
23290: PUSH
23291: LD_INT 30
23293: PUSH
23294: LD_INT 32
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: PUSH
23301: LD_INT 30
23303: PUSH
23304: LD_INT 31
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: LIST
23315: PUSH
23316: LD_INT 58
23318: PUSH
23319: EMPTY
23320: LIST
23321: PUSH
23322: EMPTY
23323: LIST
23324: LIST
23325: PPUSH
23326: CALL_OW 72
23330: PPUSH
23331: CALL_OW 1
23335: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23336: LD_ADDR_EXP 102
23340: PUSH
23341: LD_EXP 102
23345: PPUSH
23346: LD_VAR 0 2
23350: PPUSH
23351: EMPTY
23352: PPUSH
23353: CALL_OW 1
23357: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23358: LD_ADDR_EXP 106
23362: PUSH
23363: LD_EXP 106
23367: PPUSH
23368: LD_VAR 0 2
23372: PPUSH
23373: EMPTY
23374: PPUSH
23375: CALL_OW 1
23379: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23380: LD_ADDR_EXP 105
23384: PUSH
23385: LD_EXP 105
23389: PPUSH
23390: LD_VAR 0 2
23394: PPUSH
23395: EMPTY
23396: PPUSH
23397: CALL_OW 1
23401: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23402: LD_ADDR_EXP 107
23406: PUSH
23407: LD_EXP 107
23411: PPUSH
23412: LD_VAR 0 2
23416: PPUSH
23417: EMPTY
23418: PPUSH
23419: CALL_OW 1
23423: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23424: LD_ADDR_EXP 108
23428: PUSH
23429: LD_EXP 108
23433: PPUSH
23434: LD_VAR 0 2
23438: PPUSH
23439: EMPTY
23440: PPUSH
23441: CALL_OW 1
23445: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23446: LD_ADDR_EXP 109
23450: PUSH
23451: LD_EXP 109
23455: PPUSH
23456: LD_VAR 0 2
23460: PPUSH
23461: EMPTY
23462: PPUSH
23463: CALL_OW 1
23467: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23468: LD_ADDR_EXP 110
23472: PUSH
23473: LD_EXP 110
23477: PPUSH
23478: LD_VAR 0 2
23482: PPUSH
23483: EMPTY
23484: PPUSH
23485: CALL_OW 1
23489: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23490: LD_ADDR_EXP 111
23494: PUSH
23495: LD_EXP 111
23499: PPUSH
23500: LD_VAR 0 2
23504: PPUSH
23505: EMPTY
23506: PPUSH
23507: CALL_OW 1
23511: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23512: LD_ADDR_EXP 112
23516: PUSH
23517: LD_EXP 112
23521: PPUSH
23522: LD_VAR 0 2
23526: PPUSH
23527: EMPTY
23528: PPUSH
23529: CALL_OW 1
23533: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23534: LD_ADDR_EXP 113
23538: PUSH
23539: LD_EXP 113
23543: PPUSH
23544: LD_VAR 0 2
23548: PPUSH
23549: EMPTY
23550: PPUSH
23551: CALL_OW 1
23555: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23556: LD_ADDR_EXP 114
23560: PUSH
23561: LD_EXP 114
23565: PPUSH
23566: LD_VAR 0 2
23570: PPUSH
23571: EMPTY
23572: PPUSH
23573: CALL_OW 1
23577: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23578: LD_ADDR_EXP 103
23582: PUSH
23583: LD_EXP 103
23587: PPUSH
23588: LD_VAR 0 2
23592: PPUSH
23593: LD_INT 0
23595: PPUSH
23596: CALL_OW 1
23600: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23601: LD_ADDR_EXP 116
23605: PUSH
23606: LD_EXP 116
23610: PPUSH
23611: LD_VAR 0 2
23615: PPUSH
23616: LD_INT 0
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23624: LD_ADDR_EXP 104
23628: PUSH
23629: LD_EXP 104
23633: PPUSH
23634: LD_VAR 0 2
23638: PPUSH
23639: EMPTY
23640: PPUSH
23641: CALL_OW 1
23645: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23646: LD_ADDR_EXP 115
23650: PUSH
23651: LD_EXP 115
23655: PPUSH
23656: LD_VAR 0 2
23660: PPUSH
23661: LD_INT 0
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23669: LD_ADDR_EXP 117
23673: PUSH
23674: LD_EXP 117
23678: PPUSH
23679: LD_VAR 0 2
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23691: LD_ADDR_EXP 120
23695: PUSH
23696: LD_EXP 120
23700: PPUSH
23701: LD_VAR 0 2
23705: PPUSH
23706: LD_INT 0
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23714: LD_ADDR_EXP 121
23718: PUSH
23719: LD_EXP 121
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: EMPTY
23730: PPUSH
23731: CALL_OW 1
23735: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23736: LD_ADDR_EXP 122
23740: PUSH
23741: LD_EXP 122
23745: PPUSH
23746: LD_VAR 0 2
23750: PPUSH
23751: EMPTY
23752: PPUSH
23753: CALL_OW 1
23757: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23758: LD_ADDR_EXP 123
23762: PUSH
23763: LD_EXP 123
23767: PPUSH
23768: LD_VAR 0 2
23772: PPUSH
23773: EMPTY
23774: PPUSH
23775: CALL_OW 1
23779: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23780: LD_ADDR_EXP 125
23784: PUSH
23785: LD_EXP 125
23789: PPUSH
23790: LD_VAR 0 2
23794: PPUSH
23795: LD_EXP 92
23799: PUSH
23800: LD_VAR 0 2
23804: ARRAY
23805: PPUSH
23806: LD_INT 2
23808: PUSH
23809: LD_INT 30
23811: PUSH
23812: LD_INT 6
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: PUSH
23819: LD_INT 30
23821: PUSH
23822: LD_INT 7
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 30
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: LIST
23843: LIST
23844: PPUSH
23845: CALL_OW 72
23849: PPUSH
23850: CALL_OW 1
23854: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23855: LD_ADDR_EXP 126
23859: PUSH
23860: LD_EXP 126
23864: PPUSH
23865: LD_VAR 0 2
23869: PPUSH
23870: EMPTY
23871: PPUSH
23872: CALL_OW 1
23876: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23877: LD_ADDR_EXP 127
23881: PUSH
23882: LD_EXP 127
23886: PPUSH
23887: LD_VAR 0 2
23891: PPUSH
23892: EMPTY
23893: PPUSH
23894: CALL_OW 1
23898: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23899: LD_ADDR_EXP 128
23903: PUSH
23904: LD_EXP 128
23908: PPUSH
23909: LD_VAR 0 2
23913: PPUSH
23914: EMPTY
23915: PPUSH
23916: CALL_OW 1
23920: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23921: LD_ADDR_EXP 129
23925: PUSH
23926: LD_EXP 129
23930: PPUSH
23931: LD_VAR 0 2
23935: PPUSH
23936: EMPTY
23937: PPUSH
23938: CALL_OW 1
23942: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23943: LD_ADDR_EXP 130
23947: PUSH
23948: LD_EXP 130
23952: PPUSH
23953: LD_VAR 0 2
23957: PPUSH
23958: EMPTY
23959: PPUSH
23960: CALL_OW 1
23964: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23965: LD_ADDR_EXP 131
23969: PUSH
23970: LD_EXP 131
23974: PPUSH
23975: LD_VAR 0 2
23979: PPUSH
23980: EMPTY
23981: PPUSH
23982: CALL_OW 1
23986: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23987: LD_ADDR_EXP 132
23991: PUSH
23992: LD_EXP 132
23996: PPUSH
23997: LD_VAR 0 2
24001: PPUSH
24002: EMPTY
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24009: LD_ADDR_EXP 133
24013: PUSH
24014: LD_EXP 133
24018: PPUSH
24019: LD_VAR 0 2
24023: PPUSH
24024: EMPTY
24025: PPUSH
24026: CALL_OW 1
24030: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24031: LD_ADDR_EXP 134
24035: PUSH
24036: LD_EXP 134
24040: PPUSH
24041: LD_VAR 0 2
24045: PPUSH
24046: LD_INT 0
24048: PPUSH
24049: CALL_OW 1
24053: ST_TO_ADDR
// end ;
24054: GO 22978
24056: POP
24057: POP
// MC_InitSides ( ) ;
24058: CALL 24344 0 0
// MC_InitResearch ( ) ;
24062: CALL 24083 0 0
// CustomInitMacro ( ) ;
24066: CALL 217 0 0
// skirmish := true ;
24070: LD_ADDR_EXP 90
24074: PUSH
24075: LD_INT 1
24077: ST_TO_ADDR
// end ;
24078: LD_VAR 0 1
24082: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24083: LD_INT 0
24085: PPUSH
24086: PPUSH
24087: PPUSH
24088: PPUSH
24089: PPUSH
24090: PPUSH
// if not mc_bases then
24091: LD_EXP 92
24095: NOT
24096: IFFALSE 24100
// exit ;
24098: GO 24339
// for i = 1 to 8 do
24100: LD_ADDR_VAR 0 2
24104: PUSH
24105: DOUBLE
24106: LD_INT 1
24108: DEC
24109: ST_TO_ADDR
24110: LD_INT 8
24112: PUSH
24113: FOR_TO
24114: IFFALSE 24140
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24116: LD_ADDR_EXP 119
24120: PUSH
24121: LD_EXP 119
24125: PPUSH
24126: LD_VAR 0 2
24130: PPUSH
24131: EMPTY
24132: PPUSH
24133: CALL_OW 1
24137: ST_TO_ADDR
24138: GO 24113
24140: POP
24141: POP
// tmp := [ ] ;
24142: LD_ADDR_VAR 0 5
24146: PUSH
24147: EMPTY
24148: ST_TO_ADDR
// for i = 1 to mc_sides do
24149: LD_ADDR_VAR 0 2
24153: PUSH
24154: DOUBLE
24155: LD_INT 1
24157: DEC
24158: ST_TO_ADDR
24159: LD_EXP 118
24163: PUSH
24164: FOR_TO
24165: IFFALSE 24223
// if not mc_sides [ i ] in tmp then
24167: LD_EXP 118
24171: PUSH
24172: LD_VAR 0 2
24176: ARRAY
24177: PUSH
24178: LD_VAR 0 5
24182: IN
24183: NOT
24184: IFFALSE 24221
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24186: LD_ADDR_VAR 0 5
24190: PUSH
24191: LD_VAR 0 5
24195: PPUSH
24196: LD_VAR 0 5
24200: PUSH
24201: LD_INT 1
24203: PLUS
24204: PPUSH
24205: LD_EXP 118
24209: PUSH
24210: LD_VAR 0 2
24214: ARRAY
24215: PPUSH
24216: CALL_OW 2
24220: ST_TO_ADDR
24221: GO 24164
24223: POP
24224: POP
// if not tmp then
24225: LD_VAR 0 5
24229: NOT
24230: IFFALSE 24234
// exit ;
24232: GO 24339
// for j in tmp do
24234: LD_ADDR_VAR 0 3
24238: PUSH
24239: LD_VAR 0 5
24243: PUSH
24244: FOR_IN
24245: IFFALSE 24337
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24247: LD_ADDR_VAR 0 6
24251: PUSH
24252: LD_INT 22
24254: PUSH
24255: LD_VAR 0 3
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PPUSH
24264: CALL_OW 69
24268: ST_TO_ADDR
// if not un then
24269: LD_VAR 0 6
24273: NOT
24274: IFFALSE 24278
// continue ;
24276: GO 24244
// nation := GetNation ( un [ 1 ] ) ;
24278: LD_ADDR_VAR 0 4
24282: PUSH
24283: LD_VAR 0 6
24287: PUSH
24288: LD_INT 1
24290: ARRAY
24291: PPUSH
24292: CALL_OW 248
24296: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24297: LD_ADDR_EXP 119
24301: PUSH
24302: LD_EXP 119
24306: PPUSH
24307: LD_VAR 0 3
24311: PPUSH
24312: LD_VAR 0 3
24316: PPUSH
24317: LD_VAR 0 4
24321: PPUSH
24322: LD_INT 1
24324: PPUSH
24325: CALL 51116 0 3
24329: PPUSH
24330: CALL_OW 1
24334: ST_TO_ADDR
// end ;
24335: GO 24244
24337: POP
24338: POP
// end ;
24339: LD_VAR 0 1
24343: RET
// export function MC_InitSides ( ) ; var i ; begin
24344: LD_INT 0
24346: PPUSH
24347: PPUSH
// if not mc_bases then
24348: LD_EXP 92
24352: NOT
24353: IFFALSE 24357
// exit ;
24355: GO 24431
// for i = 1 to mc_bases do
24357: LD_ADDR_VAR 0 2
24361: PUSH
24362: DOUBLE
24363: LD_INT 1
24365: DEC
24366: ST_TO_ADDR
24367: LD_EXP 92
24371: PUSH
24372: FOR_TO
24373: IFFALSE 24429
// if mc_bases [ i ] then
24375: LD_EXP 92
24379: PUSH
24380: LD_VAR 0 2
24384: ARRAY
24385: IFFALSE 24427
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24387: LD_ADDR_EXP 118
24391: PUSH
24392: LD_EXP 118
24396: PPUSH
24397: LD_VAR 0 2
24401: PPUSH
24402: LD_EXP 92
24406: PUSH
24407: LD_VAR 0 2
24411: ARRAY
24412: PUSH
24413: LD_INT 1
24415: ARRAY
24416: PPUSH
24417: CALL_OW 255
24421: PPUSH
24422: CALL_OW 1
24426: ST_TO_ADDR
24427: GO 24372
24429: POP
24430: POP
// end ;
24431: LD_VAR 0 1
24435: RET
// every 0 0$03 trigger skirmish do
24436: LD_EXP 90
24440: IFFALSE 24594
24442: GO 24444
24444: DISABLE
// begin enable ;
24445: ENABLE
// MC_CheckBuildings ( ) ;
24446: CALL 29092 0 0
// MC_CheckPeopleLife ( ) ;
24450: CALL 29217 0 0
// RaiseSailEvent ( 100 ) ;
24454: LD_INT 100
24456: PPUSH
24457: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24461: LD_INT 103
24463: PPUSH
24464: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24468: LD_INT 104
24470: PPUSH
24471: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24475: LD_INT 105
24477: PPUSH
24478: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24482: LD_INT 106
24484: PPUSH
24485: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24489: LD_INT 107
24491: PPUSH
24492: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24496: LD_INT 108
24498: PPUSH
24499: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24503: LD_INT 109
24505: PPUSH
24506: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24510: LD_INT 110
24512: PPUSH
24513: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24517: LD_INT 111
24519: PPUSH
24520: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24524: LD_INT 112
24526: PPUSH
24527: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24531: LD_INT 113
24533: PPUSH
24534: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24538: LD_INT 120
24540: PPUSH
24541: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24545: LD_INT 121
24547: PPUSH
24548: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24552: LD_INT 122
24554: PPUSH
24555: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24559: LD_INT 123
24561: PPUSH
24562: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24566: LD_INT 124
24568: PPUSH
24569: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24573: LD_INT 125
24575: PPUSH
24576: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24580: LD_INT 126
24582: PPUSH
24583: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24587: LD_INT 200
24589: PPUSH
24590: CALL_OW 427
// end ;
24594: END
// on SailEvent ( event ) do begin if event < 100 then
24595: LD_VAR 0 1
24599: PUSH
24600: LD_INT 100
24602: LESS
24603: IFFALSE 24614
// CustomEvent ( event ) ;
24605: LD_VAR 0 1
24609: PPUSH
24610: CALL 10417 0 1
// if event = 100 then
24614: LD_VAR 0 1
24618: PUSH
24619: LD_INT 100
24621: EQUAL
24622: IFFALSE 24628
// MC_ClassManager ( ) ;
24624: CALL 25020 0 0
// if event = 101 then
24628: LD_VAR 0 1
24632: PUSH
24633: LD_INT 101
24635: EQUAL
24636: IFFALSE 24642
// MC_RepairBuildings ( ) ;
24638: CALL 29802 0 0
// if event = 102 then
24642: LD_VAR 0 1
24646: PUSH
24647: LD_INT 102
24649: EQUAL
24650: IFFALSE 24656
// MC_Heal ( ) ;
24652: CALL 30687 0 0
// if event = 103 then
24656: LD_VAR 0 1
24660: PUSH
24661: LD_INT 103
24663: EQUAL
24664: IFFALSE 24670
// MC_Build ( ) ;
24666: CALL 31109 0 0
// if event = 104 then
24670: LD_VAR 0 1
24674: PUSH
24675: LD_INT 104
24677: EQUAL
24678: IFFALSE 24684
// MC_TurretWeapon ( ) ;
24680: CALL 32750 0 0
// if event = 105 then
24684: LD_VAR 0 1
24688: PUSH
24689: LD_INT 105
24691: EQUAL
24692: IFFALSE 24698
// MC_BuildUpgrade ( ) ;
24694: CALL 32301 0 0
// if event = 106 then
24698: LD_VAR 0 1
24702: PUSH
24703: LD_INT 106
24705: EQUAL
24706: IFFALSE 24712
// MC_PlantMines ( ) ;
24708: CALL 33180 0 0
// if event = 107 then
24712: LD_VAR 0 1
24716: PUSH
24717: LD_INT 107
24719: EQUAL
24720: IFFALSE 24726
// MC_CollectCrates ( ) ;
24722: CALL 33971 0 0
// if event = 108 then
24726: LD_VAR 0 1
24730: PUSH
24731: LD_INT 108
24733: EQUAL
24734: IFFALSE 24740
// MC_LinkRemoteControl ( ) ;
24736: CALL 35747 0 0
// if event = 109 then
24740: LD_VAR 0 1
24744: PUSH
24745: LD_INT 109
24747: EQUAL
24748: IFFALSE 24754
// MC_ProduceVehicle ( ) ;
24750: CALL 35928 0 0
// if event = 110 then
24754: LD_VAR 0 1
24758: PUSH
24759: LD_INT 110
24761: EQUAL
24762: IFFALSE 24768
// MC_SendAttack ( ) ;
24764: CALL 36394 0 0
// if event = 111 then
24768: LD_VAR 0 1
24772: PUSH
24773: LD_INT 111
24775: EQUAL
24776: IFFALSE 24782
// MC_Defend ( ) ;
24778: CALL 36502 0 0
// if event = 112 then
24782: LD_VAR 0 1
24786: PUSH
24787: LD_INT 112
24789: EQUAL
24790: IFFALSE 24796
// MC_Research ( ) ;
24792: CALL 37224 0 0
// if event = 113 then
24796: LD_VAR 0 1
24800: PUSH
24801: LD_INT 113
24803: EQUAL
24804: IFFALSE 24810
// MC_MinesTrigger ( ) ;
24806: CALL 38338 0 0
// if event = 120 then
24810: LD_VAR 0 1
24814: PUSH
24815: LD_INT 120
24817: EQUAL
24818: IFFALSE 24824
// MC_RepairVehicle ( ) ;
24820: CALL 38437 0 0
// if event = 121 then
24824: LD_VAR 0 1
24828: PUSH
24829: LD_INT 121
24831: EQUAL
24832: IFFALSE 24838
// MC_TameApe ( ) ;
24834: CALL 39167 0 0
// if event = 122 then
24838: LD_VAR 0 1
24842: PUSH
24843: LD_INT 122
24845: EQUAL
24846: IFFALSE 24852
// MC_ChangeApeClass ( ) ;
24848: CALL 39996 0 0
// if event = 123 then
24852: LD_VAR 0 1
24856: PUSH
24857: LD_INT 123
24859: EQUAL
24860: IFFALSE 24866
// MC_Bazooka ( ) ;
24862: CALL 40646 0 0
// if event = 124 then
24866: LD_VAR 0 1
24870: PUSH
24871: LD_INT 124
24873: EQUAL
24874: IFFALSE 24880
// MC_TeleportExit ( ) ;
24876: CALL 40844 0 0
// if event = 125 then
24880: LD_VAR 0 1
24884: PUSH
24885: LD_INT 125
24887: EQUAL
24888: IFFALSE 24894
// MC_Deposits ( ) ;
24890: CALL 41491 0 0
// if event = 126 then
24894: LD_VAR 0 1
24898: PUSH
24899: LD_INT 126
24901: EQUAL
24902: IFFALSE 24908
// MC_RemoteDriver ( ) ;
24904: CALL 42116 0 0
// if event = 200 then
24908: LD_VAR 0 1
24912: PUSH
24913: LD_INT 200
24915: EQUAL
24916: IFFALSE 24922
// MC_Idle ( ) ;
24918: CALL 44065 0 0
// end ;
24922: PPOPN 1
24924: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24925: LD_INT 0
24927: PPUSH
24928: PPUSH
// if not mc_bases [ base ] or not tag then
24929: LD_EXP 92
24933: PUSH
24934: LD_VAR 0 1
24938: ARRAY
24939: NOT
24940: PUSH
24941: LD_VAR 0 2
24945: NOT
24946: OR
24947: IFFALSE 24951
// exit ;
24949: GO 25015
// for i in mc_bases [ base ] union mc_ape [ base ] do
24951: LD_ADDR_VAR 0 4
24955: PUSH
24956: LD_EXP 92
24960: PUSH
24961: LD_VAR 0 1
24965: ARRAY
24966: PUSH
24967: LD_EXP 121
24971: PUSH
24972: LD_VAR 0 1
24976: ARRAY
24977: UNION
24978: PUSH
24979: FOR_IN
24980: IFFALSE 25013
// if GetTag ( i ) = tag then
24982: LD_VAR 0 4
24986: PPUSH
24987: CALL_OW 110
24991: PUSH
24992: LD_VAR 0 2
24996: EQUAL
24997: IFFALSE 25011
// SetTag ( i , 0 ) ;
24999: LD_VAR 0 4
25003: PPUSH
25004: LD_INT 0
25006: PPUSH
25007: CALL_OW 109
25011: GO 24979
25013: POP
25014: POP
// end ;
25015: LD_VAR 0 3
25019: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25020: LD_INT 0
25022: PPUSH
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
25029: PPUSH
// if not mc_bases then
25030: LD_EXP 92
25034: NOT
25035: IFFALSE 25039
// exit ;
25037: GO 25497
// for i = 1 to mc_bases do
25039: LD_ADDR_VAR 0 2
25043: PUSH
25044: DOUBLE
25045: LD_INT 1
25047: DEC
25048: ST_TO_ADDR
25049: LD_EXP 92
25053: PUSH
25054: FOR_TO
25055: IFFALSE 25495
// begin tmp := MC_ClassCheckReq ( i ) ;
25057: LD_ADDR_VAR 0 4
25061: PUSH
25062: LD_VAR 0 2
25066: PPUSH
25067: CALL 25502 0 1
25071: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25072: LD_ADDR_EXP 133
25076: PUSH
25077: LD_EXP 133
25081: PPUSH
25082: LD_VAR 0 2
25086: PPUSH
25087: LD_VAR 0 4
25091: PPUSH
25092: CALL_OW 1
25096: ST_TO_ADDR
// if not tmp then
25097: LD_VAR 0 4
25101: NOT
25102: IFFALSE 25106
// continue ;
25104: GO 25054
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25106: LD_ADDR_VAR 0 6
25110: PUSH
25111: LD_EXP 92
25115: PUSH
25116: LD_VAR 0 2
25120: ARRAY
25121: PPUSH
25122: LD_INT 2
25124: PUSH
25125: LD_INT 30
25127: PUSH
25128: LD_INT 4
25130: PUSH
25131: EMPTY
25132: LIST
25133: LIST
25134: PUSH
25135: LD_INT 30
25137: PUSH
25138: LD_INT 5
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: PPUSH
25150: CALL_OW 72
25154: PUSH
25155: LD_EXP 92
25159: PUSH
25160: LD_VAR 0 2
25164: ARRAY
25165: PPUSH
25166: LD_INT 2
25168: PUSH
25169: LD_INT 30
25171: PUSH
25172: LD_INT 0
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: LD_INT 30
25181: PUSH
25182: LD_INT 1
25184: PUSH
25185: EMPTY
25186: LIST
25187: LIST
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: LIST
25193: PPUSH
25194: CALL_OW 72
25198: PUSH
25199: LD_EXP 92
25203: PUSH
25204: LD_VAR 0 2
25208: ARRAY
25209: PPUSH
25210: LD_INT 30
25212: PUSH
25213: LD_INT 3
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: PPUSH
25220: CALL_OW 72
25224: PUSH
25225: LD_EXP 92
25229: PUSH
25230: LD_VAR 0 2
25234: ARRAY
25235: PPUSH
25236: LD_INT 2
25238: PUSH
25239: LD_INT 30
25241: PUSH
25242: LD_INT 6
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: PUSH
25249: LD_INT 30
25251: PUSH
25252: LD_INT 7
25254: PUSH
25255: EMPTY
25256: LIST
25257: LIST
25258: PUSH
25259: LD_INT 30
25261: PUSH
25262: LD_INT 8
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: PPUSH
25275: CALL_OW 72
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: LIST
25284: LIST
25285: ST_TO_ADDR
// for j = 1 to 4 do
25286: LD_ADDR_VAR 0 3
25290: PUSH
25291: DOUBLE
25292: LD_INT 1
25294: DEC
25295: ST_TO_ADDR
25296: LD_INT 4
25298: PUSH
25299: FOR_TO
25300: IFFALSE 25491
// begin if not tmp [ j ] then
25302: LD_VAR 0 4
25306: PUSH
25307: LD_VAR 0 3
25311: ARRAY
25312: NOT
25313: IFFALSE 25317
// continue ;
25315: GO 25299
// for p in tmp [ j ] do
25317: LD_ADDR_VAR 0 5
25321: PUSH
25322: LD_VAR 0 4
25326: PUSH
25327: LD_VAR 0 3
25331: ARRAY
25332: PUSH
25333: FOR_IN
25334: IFFALSE 25487
// begin if not b [ j ] then
25336: LD_VAR 0 6
25340: PUSH
25341: LD_VAR 0 3
25345: ARRAY
25346: NOT
25347: IFFALSE 25351
// break ;
25349: GO 25487
// e := 0 ;
25351: LD_ADDR_VAR 0 7
25355: PUSH
25356: LD_INT 0
25358: ST_TO_ADDR
// for k in b [ j ] do
25359: LD_ADDR_VAR 0 8
25363: PUSH
25364: LD_VAR 0 6
25368: PUSH
25369: LD_VAR 0 3
25373: ARRAY
25374: PUSH
25375: FOR_IN
25376: IFFALSE 25403
// if IsNotFull ( k ) then
25378: LD_VAR 0 8
25382: PPUSH
25383: CALL 53265 0 1
25387: IFFALSE 25401
// begin e := k ;
25389: LD_ADDR_VAR 0 7
25393: PUSH
25394: LD_VAR 0 8
25398: ST_TO_ADDR
// break ;
25399: GO 25403
// end ;
25401: GO 25375
25403: POP
25404: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25405: LD_VAR 0 7
25409: PUSH
25410: LD_VAR 0 5
25414: PPUSH
25415: LD_VAR 0 7
25419: PPUSH
25420: CALL 86018 0 2
25424: NOT
25425: AND
25426: IFFALSE 25485
// begin if IsInUnit ( p ) then
25428: LD_VAR 0 5
25432: PPUSH
25433: CALL_OW 310
25437: IFFALSE 25448
// ComExitBuilding ( p ) ;
25439: LD_VAR 0 5
25443: PPUSH
25444: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25448: LD_VAR 0 5
25452: PPUSH
25453: LD_VAR 0 7
25457: PPUSH
25458: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25462: LD_VAR 0 5
25466: PPUSH
25467: LD_VAR 0 3
25471: PPUSH
25472: CALL_OW 183
// AddComExitBuilding ( p ) ;
25476: LD_VAR 0 5
25480: PPUSH
25481: CALL_OW 182
// end ; end ;
25485: GO 25333
25487: POP
25488: POP
// end ;
25489: GO 25299
25491: POP
25492: POP
// end ;
25493: GO 25054
25495: POP
25496: POP
// end ;
25497: LD_VAR 0 1
25501: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25502: LD_INT 0
25504: PPUSH
25505: PPUSH
25506: PPUSH
25507: PPUSH
25508: PPUSH
25509: PPUSH
25510: PPUSH
25511: PPUSH
25512: PPUSH
25513: PPUSH
25514: PPUSH
25515: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25516: LD_VAR 0 1
25520: NOT
25521: PUSH
25522: LD_EXP 92
25526: PUSH
25527: LD_VAR 0 1
25531: ARRAY
25532: NOT
25533: OR
25534: PUSH
25535: LD_EXP 92
25539: PUSH
25540: LD_VAR 0 1
25544: ARRAY
25545: PPUSH
25546: LD_INT 2
25548: PUSH
25549: LD_INT 30
25551: PUSH
25552: LD_INT 0
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: LD_INT 30
25561: PUSH
25562: LD_INT 1
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: LIST
25573: PPUSH
25574: CALL_OW 72
25578: NOT
25579: OR
25580: IFFALSE 25584
// exit ;
25582: GO 29087
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25584: LD_ADDR_VAR 0 4
25588: PUSH
25589: LD_EXP 92
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: LD_INT 2
25602: PUSH
25603: LD_INT 25
25605: PUSH
25606: LD_INT 1
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 25
25615: PUSH
25616: LD_INT 2
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 25
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 25
25635: PUSH
25636: LD_INT 4
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 25
25645: PUSH
25646: LD_INT 5
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 25
25655: PUSH
25656: LD_INT 8
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 25
25665: PUSH
25666: LD_INT 9
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: PPUSH
25683: CALL_OW 72
25687: ST_TO_ADDR
// if not tmp then
25688: LD_VAR 0 4
25692: NOT
25693: IFFALSE 25697
// exit ;
25695: GO 29087
// for i in tmp do
25697: LD_ADDR_VAR 0 3
25701: PUSH
25702: LD_VAR 0 4
25706: PUSH
25707: FOR_IN
25708: IFFALSE 25739
// if GetTag ( i ) then
25710: LD_VAR 0 3
25714: PPUSH
25715: CALL_OW 110
25719: IFFALSE 25737
// tmp := tmp diff i ;
25721: LD_ADDR_VAR 0 4
25725: PUSH
25726: LD_VAR 0 4
25730: PUSH
25731: LD_VAR 0 3
25735: DIFF
25736: ST_TO_ADDR
25737: GO 25707
25739: POP
25740: POP
// if not tmp then
25741: LD_VAR 0 4
25745: NOT
25746: IFFALSE 25750
// exit ;
25748: GO 29087
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25750: LD_ADDR_VAR 0 5
25754: PUSH
25755: LD_EXP 92
25759: PUSH
25760: LD_VAR 0 1
25764: ARRAY
25765: PPUSH
25766: LD_INT 2
25768: PUSH
25769: LD_INT 25
25771: PUSH
25772: LD_INT 1
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: LD_INT 25
25781: PUSH
25782: LD_INT 5
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: PUSH
25789: LD_INT 25
25791: PUSH
25792: LD_INT 8
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: LD_INT 25
25801: PUSH
25802: LD_INT 9
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: PPUSH
25816: CALL_OW 72
25820: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25821: LD_ADDR_VAR 0 6
25825: PUSH
25826: LD_EXP 92
25830: PUSH
25831: LD_VAR 0 1
25835: ARRAY
25836: PPUSH
25837: LD_INT 25
25839: PUSH
25840: LD_INT 2
25842: PUSH
25843: EMPTY
25844: LIST
25845: LIST
25846: PPUSH
25847: CALL_OW 72
25851: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25852: LD_ADDR_VAR 0 7
25856: PUSH
25857: LD_EXP 92
25861: PUSH
25862: LD_VAR 0 1
25866: ARRAY
25867: PPUSH
25868: LD_INT 25
25870: PUSH
25871: LD_INT 3
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 72
25882: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25883: LD_ADDR_VAR 0 8
25887: PUSH
25888: LD_EXP 92
25892: PUSH
25893: LD_VAR 0 1
25897: ARRAY
25898: PPUSH
25899: LD_INT 25
25901: PUSH
25902: LD_INT 4
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PUSH
25909: LD_INT 24
25911: PUSH
25912: LD_INT 251
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PPUSH
25923: CALL_OW 72
25927: ST_TO_ADDR
// if mc_scan [ base ] then
25928: LD_EXP 115
25932: PUSH
25933: LD_VAR 0 1
25937: ARRAY
25938: IFFALSE 26399
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25940: LD_ADDR_EXP 134
25944: PUSH
25945: LD_EXP 134
25949: PPUSH
25950: LD_VAR 0 1
25954: PPUSH
25955: LD_INT 4
25957: PPUSH
25958: CALL_OW 1
25962: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25963: LD_ADDR_VAR 0 12
25967: PUSH
25968: LD_EXP 92
25972: PUSH
25973: LD_VAR 0 1
25977: ARRAY
25978: PPUSH
25979: LD_INT 2
25981: PUSH
25982: LD_INT 30
25984: PUSH
25985: LD_INT 4
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: LD_INT 30
25994: PUSH
25995: LD_INT 5
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: LIST
26006: PPUSH
26007: CALL_OW 72
26011: ST_TO_ADDR
// if not b then
26012: LD_VAR 0 12
26016: NOT
26017: IFFALSE 26021
// exit ;
26019: GO 29087
// p := [ ] ;
26021: LD_ADDR_VAR 0 11
26025: PUSH
26026: EMPTY
26027: ST_TO_ADDR
// if sci >= 2 then
26028: LD_VAR 0 8
26032: PUSH
26033: LD_INT 2
26035: GREATEREQUAL
26036: IFFALSE 26067
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26038: LD_ADDR_VAR 0 8
26042: PUSH
26043: LD_VAR 0 8
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PUSH
26052: LD_VAR 0 8
26056: PUSH
26057: LD_INT 2
26059: ARRAY
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: ST_TO_ADDR
26065: GO 26128
// if sci = 1 then
26067: LD_VAR 0 8
26071: PUSH
26072: LD_INT 1
26074: EQUAL
26075: IFFALSE 26096
// sci := [ sci [ 1 ] ] else
26077: LD_ADDR_VAR 0 8
26081: PUSH
26082: LD_VAR 0 8
26086: PUSH
26087: LD_INT 1
26089: ARRAY
26090: PUSH
26091: EMPTY
26092: LIST
26093: ST_TO_ADDR
26094: GO 26128
// if sci = 0 then
26096: LD_VAR 0 8
26100: PUSH
26101: LD_INT 0
26103: EQUAL
26104: IFFALSE 26128
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26106: LD_ADDR_VAR 0 11
26110: PUSH
26111: LD_VAR 0 4
26115: PPUSH
26116: LD_INT 4
26118: PPUSH
26119: CALL 85881 0 2
26123: PUSH
26124: LD_INT 1
26126: ARRAY
26127: ST_TO_ADDR
// if eng > 4 then
26128: LD_VAR 0 6
26132: PUSH
26133: LD_INT 4
26135: GREATER
26136: IFFALSE 26182
// for i = eng downto 4 do
26138: LD_ADDR_VAR 0 3
26142: PUSH
26143: DOUBLE
26144: LD_VAR 0 6
26148: INC
26149: ST_TO_ADDR
26150: LD_INT 4
26152: PUSH
26153: FOR_DOWNTO
26154: IFFALSE 26180
// eng := eng diff eng [ i ] ;
26156: LD_ADDR_VAR 0 6
26160: PUSH
26161: LD_VAR 0 6
26165: PUSH
26166: LD_VAR 0 6
26170: PUSH
26171: LD_VAR 0 3
26175: ARRAY
26176: DIFF
26177: ST_TO_ADDR
26178: GO 26153
26180: POP
26181: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26182: LD_ADDR_VAR 0 4
26186: PUSH
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 5
26196: PUSH
26197: LD_VAR 0 6
26201: UNION
26202: PUSH
26203: LD_VAR 0 7
26207: UNION
26208: PUSH
26209: LD_VAR 0 8
26213: UNION
26214: DIFF
26215: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26216: LD_ADDR_VAR 0 13
26220: PUSH
26221: LD_EXP 92
26225: PUSH
26226: LD_VAR 0 1
26230: ARRAY
26231: PPUSH
26232: LD_INT 2
26234: PUSH
26235: LD_INT 30
26237: PUSH
26238: LD_INT 32
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 30
26247: PUSH
26248: LD_INT 31
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: LIST
26259: PPUSH
26260: CALL_OW 72
26264: PUSH
26265: LD_EXP 92
26269: PUSH
26270: LD_VAR 0 1
26274: ARRAY
26275: PPUSH
26276: LD_INT 2
26278: PUSH
26279: LD_INT 30
26281: PUSH
26282: LD_INT 4
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: PUSH
26289: LD_INT 30
26291: PUSH
26292: LD_INT 5
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: LIST
26303: PPUSH
26304: CALL_OW 72
26308: PUSH
26309: LD_INT 6
26311: MUL
26312: PLUS
26313: ST_TO_ADDR
// if bcount < tmp then
26314: LD_VAR 0 13
26318: PUSH
26319: LD_VAR 0 4
26323: LESS
26324: IFFALSE 26370
// for i = tmp downto bcount do
26326: LD_ADDR_VAR 0 3
26330: PUSH
26331: DOUBLE
26332: LD_VAR 0 4
26336: INC
26337: ST_TO_ADDR
26338: LD_VAR 0 13
26342: PUSH
26343: FOR_DOWNTO
26344: IFFALSE 26368
// tmp := Delete ( tmp , tmp ) ;
26346: LD_ADDR_VAR 0 4
26350: PUSH
26351: LD_VAR 0 4
26355: PPUSH
26356: LD_VAR 0 4
26360: PPUSH
26361: CALL_OW 3
26365: ST_TO_ADDR
26366: GO 26343
26368: POP
26369: POP
// result := [ tmp , 0 , 0 , p ] ;
26370: LD_ADDR_VAR 0 2
26374: PUSH
26375: LD_VAR 0 4
26379: PUSH
26380: LD_INT 0
26382: PUSH
26383: LD_INT 0
26385: PUSH
26386: LD_VAR 0 11
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: LIST
26395: LIST
26396: ST_TO_ADDR
// exit ;
26397: GO 29087
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26399: LD_EXP 92
26403: PUSH
26404: LD_VAR 0 1
26408: ARRAY
26409: PPUSH
26410: LD_INT 2
26412: PUSH
26413: LD_INT 30
26415: PUSH
26416: LD_INT 6
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: LD_INT 30
26425: PUSH
26426: LD_INT 7
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 30
26435: PUSH
26436: LD_INT 8
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 72
26453: NOT
26454: PUSH
26455: LD_EXP 92
26459: PUSH
26460: LD_VAR 0 1
26464: ARRAY
26465: PPUSH
26466: LD_INT 30
26468: PUSH
26469: LD_INT 3
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PPUSH
26476: CALL_OW 72
26480: NOT
26481: AND
26482: IFFALSE 26554
// begin if eng = tmp then
26484: LD_VAR 0 6
26488: PUSH
26489: LD_VAR 0 4
26493: EQUAL
26494: IFFALSE 26498
// exit ;
26496: GO 29087
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26498: LD_ADDR_EXP 134
26502: PUSH
26503: LD_EXP 134
26507: PPUSH
26508: LD_VAR 0 1
26512: PPUSH
26513: LD_INT 1
26515: PPUSH
26516: CALL_OW 1
26520: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26521: LD_ADDR_VAR 0 2
26525: PUSH
26526: LD_INT 0
26528: PUSH
26529: LD_VAR 0 4
26533: PUSH
26534: LD_VAR 0 6
26538: DIFF
26539: PUSH
26540: LD_INT 0
26542: PUSH
26543: LD_INT 0
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: ST_TO_ADDR
// exit ;
26552: GO 29087
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26554: LD_EXP 119
26558: PUSH
26559: LD_EXP 118
26563: PUSH
26564: LD_VAR 0 1
26568: ARRAY
26569: ARRAY
26570: PUSH
26571: LD_EXP 92
26575: PUSH
26576: LD_VAR 0 1
26580: ARRAY
26581: PPUSH
26582: LD_INT 2
26584: PUSH
26585: LD_INT 30
26587: PUSH
26588: LD_INT 6
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 30
26597: PUSH
26598: LD_INT 7
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 30
26607: PUSH
26608: LD_INT 8
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: LIST
26619: LIST
26620: PPUSH
26621: CALL_OW 72
26625: AND
26626: PUSH
26627: LD_EXP 92
26631: PUSH
26632: LD_VAR 0 1
26636: ARRAY
26637: PPUSH
26638: LD_INT 30
26640: PUSH
26641: LD_INT 3
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PPUSH
26648: CALL_OW 72
26652: NOT
26653: AND
26654: IFFALSE 26868
// begin if sci >= 6 then
26656: LD_VAR 0 8
26660: PUSH
26661: LD_INT 6
26663: GREATEREQUAL
26664: IFFALSE 26668
// exit ;
26666: GO 29087
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26668: LD_ADDR_EXP 134
26672: PUSH
26673: LD_EXP 134
26677: PPUSH
26678: LD_VAR 0 1
26682: PPUSH
26683: LD_INT 2
26685: PPUSH
26686: CALL_OW 1
26690: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26691: LD_ADDR_VAR 0 9
26695: PUSH
26696: LD_VAR 0 4
26700: PUSH
26701: LD_VAR 0 8
26705: DIFF
26706: PPUSH
26707: LD_INT 4
26709: PPUSH
26710: CALL 85881 0 2
26714: ST_TO_ADDR
// p := [ ] ;
26715: LD_ADDR_VAR 0 11
26719: PUSH
26720: EMPTY
26721: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26722: LD_VAR 0 8
26726: PUSH
26727: LD_INT 6
26729: LESS
26730: PUSH
26731: LD_VAR 0 9
26735: PUSH
26736: LD_INT 6
26738: GREATER
26739: AND
26740: IFFALSE 26821
// begin for i = 1 to 6 - sci do
26742: LD_ADDR_VAR 0 3
26746: PUSH
26747: DOUBLE
26748: LD_INT 1
26750: DEC
26751: ST_TO_ADDR
26752: LD_INT 6
26754: PUSH
26755: LD_VAR 0 8
26759: MINUS
26760: PUSH
26761: FOR_TO
26762: IFFALSE 26817
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26764: LD_ADDR_VAR 0 11
26768: PUSH
26769: LD_VAR 0 11
26773: PPUSH
26774: LD_VAR 0 11
26778: PUSH
26779: LD_INT 1
26781: PLUS
26782: PPUSH
26783: LD_VAR 0 9
26787: PUSH
26788: LD_INT 1
26790: ARRAY
26791: PPUSH
26792: CALL_OW 2
26796: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26797: LD_ADDR_VAR 0 9
26801: PUSH
26802: LD_VAR 0 9
26806: PPUSH
26807: LD_INT 1
26809: PPUSH
26810: CALL_OW 3
26814: ST_TO_ADDR
// end ;
26815: GO 26761
26817: POP
26818: POP
// end else
26819: GO 26841
// if sort then
26821: LD_VAR 0 9
26825: IFFALSE 26841
// p := sort [ 1 ] ;
26827: LD_ADDR_VAR 0 11
26831: PUSH
26832: LD_VAR 0 9
26836: PUSH
26837: LD_INT 1
26839: ARRAY
26840: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26841: LD_ADDR_VAR 0 2
26845: PUSH
26846: LD_INT 0
26848: PUSH
26849: LD_INT 0
26851: PUSH
26852: LD_INT 0
26854: PUSH
26855: LD_VAR 0 11
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: LIST
26865: ST_TO_ADDR
// exit ;
26866: GO 29087
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26868: LD_EXP 119
26872: PUSH
26873: LD_EXP 118
26877: PUSH
26878: LD_VAR 0 1
26882: ARRAY
26883: ARRAY
26884: PUSH
26885: LD_EXP 92
26889: PUSH
26890: LD_VAR 0 1
26894: ARRAY
26895: PPUSH
26896: LD_INT 2
26898: PUSH
26899: LD_INT 30
26901: PUSH
26902: LD_INT 6
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: LD_INT 30
26911: PUSH
26912: LD_INT 7
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: LD_INT 30
26921: PUSH
26922: LD_INT 8
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: PPUSH
26935: CALL_OW 72
26939: AND
26940: PUSH
26941: LD_EXP 92
26945: PUSH
26946: LD_VAR 0 1
26950: ARRAY
26951: PPUSH
26952: LD_INT 30
26954: PUSH
26955: LD_INT 3
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PPUSH
26962: CALL_OW 72
26966: AND
26967: IFFALSE 27701
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26969: LD_ADDR_EXP 134
26973: PUSH
26974: LD_EXP 134
26978: PPUSH
26979: LD_VAR 0 1
26983: PPUSH
26984: LD_INT 3
26986: PPUSH
26987: CALL_OW 1
26991: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26992: LD_ADDR_VAR 0 2
26996: PUSH
26997: LD_INT 0
26999: PUSH
27000: LD_INT 0
27002: PUSH
27003: LD_INT 0
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: ST_TO_ADDR
// if not eng then
27015: LD_VAR 0 6
27019: NOT
27020: IFFALSE 27083
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27022: LD_ADDR_VAR 0 11
27026: PUSH
27027: LD_VAR 0 4
27031: PPUSH
27032: LD_INT 2
27034: PPUSH
27035: CALL 85881 0 2
27039: PUSH
27040: LD_INT 1
27042: ARRAY
27043: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27044: LD_ADDR_VAR 0 2
27048: PUSH
27049: LD_VAR 0 2
27053: PPUSH
27054: LD_INT 2
27056: PPUSH
27057: LD_VAR 0 11
27061: PPUSH
27062: CALL_OW 1
27066: ST_TO_ADDR
// tmp := tmp diff p ;
27067: LD_ADDR_VAR 0 4
27071: PUSH
27072: LD_VAR 0 4
27076: PUSH
27077: LD_VAR 0 11
27081: DIFF
27082: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27083: LD_VAR 0 4
27087: PUSH
27088: LD_VAR 0 8
27092: PUSH
27093: LD_INT 6
27095: LESS
27096: AND
27097: IFFALSE 27285
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27099: LD_ADDR_VAR 0 9
27103: PUSH
27104: LD_VAR 0 4
27108: PUSH
27109: LD_VAR 0 8
27113: PUSH
27114: LD_VAR 0 7
27118: UNION
27119: DIFF
27120: PPUSH
27121: LD_INT 4
27123: PPUSH
27124: CALL 85881 0 2
27128: ST_TO_ADDR
// p := [ ] ;
27129: LD_ADDR_VAR 0 11
27133: PUSH
27134: EMPTY
27135: ST_TO_ADDR
// if sort then
27136: LD_VAR 0 9
27140: IFFALSE 27256
// for i = 1 to 6 - sci do
27142: LD_ADDR_VAR 0 3
27146: PUSH
27147: DOUBLE
27148: LD_INT 1
27150: DEC
27151: ST_TO_ADDR
27152: LD_INT 6
27154: PUSH
27155: LD_VAR 0 8
27159: MINUS
27160: PUSH
27161: FOR_TO
27162: IFFALSE 27254
// begin if i = sort then
27164: LD_VAR 0 3
27168: PUSH
27169: LD_VAR 0 9
27173: EQUAL
27174: IFFALSE 27178
// break ;
27176: GO 27254
// if GetClass ( i ) = 4 then
27178: LD_VAR 0 3
27182: PPUSH
27183: CALL_OW 257
27187: PUSH
27188: LD_INT 4
27190: EQUAL
27191: IFFALSE 27195
// continue ;
27193: GO 27161
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27195: LD_ADDR_VAR 0 11
27199: PUSH
27200: LD_VAR 0 11
27204: PPUSH
27205: LD_VAR 0 11
27209: PUSH
27210: LD_INT 1
27212: PLUS
27213: PPUSH
27214: LD_VAR 0 9
27218: PUSH
27219: LD_VAR 0 3
27223: ARRAY
27224: PPUSH
27225: CALL_OW 2
27229: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27230: LD_ADDR_VAR 0 4
27234: PUSH
27235: LD_VAR 0 4
27239: PUSH
27240: LD_VAR 0 9
27244: PUSH
27245: LD_VAR 0 3
27249: ARRAY
27250: DIFF
27251: ST_TO_ADDR
// end ;
27252: GO 27161
27254: POP
27255: POP
// if p then
27256: LD_VAR 0 11
27260: IFFALSE 27285
// result := Replace ( result , 4 , p ) ;
27262: LD_ADDR_VAR 0 2
27266: PUSH
27267: LD_VAR 0 2
27271: PPUSH
27272: LD_INT 4
27274: PPUSH
27275: LD_VAR 0 11
27279: PPUSH
27280: CALL_OW 1
27284: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27285: LD_VAR 0 4
27289: PUSH
27290: LD_VAR 0 7
27294: PUSH
27295: LD_INT 6
27297: LESS
27298: AND
27299: IFFALSE 27487
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27301: LD_ADDR_VAR 0 9
27305: PUSH
27306: LD_VAR 0 4
27310: PUSH
27311: LD_VAR 0 8
27315: PUSH
27316: LD_VAR 0 7
27320: UNION
27321: DIFF
27322: PPUSH
27323: LD_INT 3
27325: PPUSH
27326: CALL 85881 0 2
27330: ST_TO_ADDR
// p := [ ] ;
27331: LD_ADDR_VAR 0 11
27335: PUSH
27336: EMPTY
27337: ST_TO_ADDR
// if sort then
27338: LD_VAR 0 9
27342: IFFALSE 27458
// for i = 1 to 6 - mech do
27344: LD_ADDR_VAR 0 3
27348: PUSH
27349: DOUBLE
27350: LD_INT 1
27352: DEC
27353: ST_TO_ADDR
27354: LD_INT 6
27356: PUSH
27357: LD_VAR 0 7
27361: MINUS
27362: PUSH
27363: FOR_TO
27364: IFFALSE 27456
// begin if i = sort then
27366: LD_VAR 0 3
27370: PUSH
27371: LD_VAR 0 9
27375: EQUAL
27376: IFFALSE 27380
// break ;
27378: GO 27456
// if GetClass ( i ) = 3 then
27380: LD_VAR 0 3
27384: PPUSH
27385: CALL_OW 257
27389: PUSH
27390: LD_INT 3
27392: EQUAL
27393: IFFALSE 27397
// continue ;
27395: GO 27363
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27397: LD_ADDR_VAR 0 11
27401: PUSH
27402: LD_VAR 0 11
27406: PPUSH
27407: LD_VAR 0 11
27411: PUSH
27412: LD_INT 1
27414: PLUS
27415: PPUSH
27416: LD_VAR 0 9
27420: PUSH
27421: LD_VAR 0 3
27425: ARRAY
27426: PPUSH
27427: CALL_OW 2
27431: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27432: LD_ADDR_VAR 0 4
27436: PUSH
27437: LD_VAR 0 4
27441: PUSH
27442: LD_VAR 0 9
27446: PUSH
27447: LD_VAR 0 3
27451: ARRAY
27452: DIFF
27453: ST_TO_ADDR
// end ;
27454: GO 27363
27456: POP
27457: POP
// if p then
27458: LD_VAR 0 11
27462: IFFALSE 27487
// result := Replace ( result , 3 , p ) ;
27464: LD_ADDR_VAR 0 2
27468: PUSH
27469: LD_VAR 0 2
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: LD_VAR 0 11
27481: PPUSH
27482: CALL_OW 1
27486: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27487: LD_VAR 0 4
27491: PUSH
27492: LD_INT 6
27494: GREATER
27495: PUSH
27496: LD_VAR 0 6
27500: PUSH
27501: LD_INT 6
27503: LESS
27504: AND
27505: IFFALSE 27699
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27507: LD_ADDR_VAR 0 9
27511: PUSH
27512: LD_VAR 0 4
27516: PUSH
27517: LD_VAR 0 8
27521: PUSH
27522: LD_VAR 0 7
27526: UNION
27527: PUSH
27528: LD_VAR 0 6
27532: UNION
27533: DIFF
27534: PPUSH
27535: LD_INT 2
27537: PPUSH
27538: CALL 85881 0 2
27542: ST_TO_ADDR
// p := [ ] ;
27543: LD_ADDR_VAR 0 11
27547: PUSH
27548: EMPTY
27549: ST_TO_ADDR
// if sort then
27550: LD_VAR 0 9
27554: IFFALSE 27670
// for i = 1 to 6 - eng do
27556: LD_ADDR_VAR 0 3
27560: PUSH
27561: DOUBLE
27562: LD_INT 1
27564: DEC
27565: ST_TO_ADDR
27566: LD_INT 6
27568: PUSH
27569: LD_VAR 0 6
27573: MINUS
27574: PUSH
27575: FOR_TO
27576: IFFALSE 27668
// begin if i = sort then
27578: LD_VAR 0 3
27582: PUSH
27583: LD_VAR 0 9
27587: EQUAL
27588: IFFALSE 27592
// break ;
27590: GO 27668
// if GetClass ( i ) = 2 then
27592: LD_VAR 0 3
27596: PPUSH
27597: CALL_OW 257
27601: PUSH
27602: LD_INT 2
27604: EQUAL
27605: IFFALSE 27609
// continue ;
27607: GO 27575
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27609: LD_ADDR_VAR 0 11
27613: PUSH
27614: LD_VAR 0 11
27618: PPUSH
27619: LD_VAR 0 11
27623: PUSH
27624: LD_INT 1
27626: PLUS
27627: PPUSH
27628: LD_VAR 0 9
27632: PUSH
27633: LD_VAR 0 3
27637: ARRAY
27638: PPUSH
27639: CALL_OW 2
27643: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27644: LD_ADDR_VAR 0 4
27648: PUSH
27649: LD_VAR 0 4
27653: PUSH
27654: LD_VAR 0 9
27658: PUSH
27659: LD_VAR 0 3
27663: ARRAY
27664: DIFF
27665: ST_TO_ADDR
// end ;
27666: GO 27575
27668: POP
27669: POP
// if p then
27670: LD_VAR 0 11
27674: IFFALSE 27699
// result := Replace ( result , 2 , p ) ;
27676: LD_ADDR_VAR 0 2
27680: PUSH
27681: LD_VAR 0 2
27685: PPUSH
27686: LD_INT 2
27688: PPUSH
27689: LD_VAR 0 11
27693: PPUSH
27694: CALL_OW 1
27698: ST_TO_ADDR
// end ; exit ;
27699: GO 29087
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27701: LD_EXP 119
27705: PUSH
27706: LD_EXP 118
27710: PUSH
27711: LD_VAR 0 1
27715: ARRAY
27716: ARRAY
27717: NOT
27718: PUSH
27719: LD_EXP 92
27723: PUSH
27724: LD_VAR 0 1
27728: ARRAY
27729: PPUSH
27730: LD_INT 30
27732: PUSH
27733: LD_INT 3
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PPUSH
27740: CALL_OW 72
27744: AND
27745: PUSH
27746: LD_EXP 97
27750: PUSH
27751: LD_VAR 0 1
27755: ARRAY
27756: AND
27757: IFFALSE 28365
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27759: LD_ADDR_EXP 134
27763: PUSH
27764: LD_EXP 134
27768: PPUSH
27769: LD_VAR 0 1
27773: PPUSH
27774: LD_INT 5
27776: PPUSH
27777: CALL_OW 1
27781: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27782: LD_ADDR_VAR 0 2
27786: PUSH
27787: LD_INT 0
27789: PUSH
27790: LD_INT 0
27792: PUSH
27793: LD_INT 0
27795: PUSH
27796: LD_INT 0
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: LIST
27803: LIST
27804: ST_TO_ADDR
// if sci > 1 then
27805: LD_VAR 0 8
27809: PUSH
27810: LD_INT 1
27812: GREATER
27813: IFFALSE 27841
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27815: LD_ADDR_VAR 0 4
27819: PUSH
27820: LD_VAR 0 4
27824: PUSH
27825: LD_VAR 0 8
27829: PUSH
27830: LD_VAR 0 8
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: DIFF
27839: DIFF
27840: ST_TO_ADDR
// if tmp and not sci then
27841: LD_VAR 0 4
27845: PUSH
27846: LD_VAR 0 8
27850: NOT
27851: AND
27852: IFFALSE 27921
// begin sort := SortBySkill ( tmp , 4 ) ;
27854: LD_ADDR_VAR 0 9
27858: PUSH
27859: LD_VAR 0 4
27863: PPUSH
27864: LD_INT 4
27866: PPUSH
27867: CALL 85881 0 2
27871: ST_TO_ADDR
// if sort then
27872: LD_VAR 0 9
27876: IFFALSE 27892
// p := sort [ 1 ] ;
27878: LD_ADDR_VAR 0 11
27882: PUSH
27883: LD_VAR 0 9
27887: PUSH
27888: LD_INT 1
27890: ARRAY
27891: ST_TO_ADDR
// if p then
27892: LD_VAR 0 11
27896: IFFALSE 27921
// result := Replace ( result , 4 , p ) ;
27898: LD_ADDR_VAR 0 2
27902: PUSH
27903: LD_VAR 0 2
27907: PPUSH
27908: LD_INT 4
27910: PPUSH
27911: LD_VAR 0 11
27915: PPUSH
27916: CALL_OW 1
27920: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27921: LD_ADDR_VAR 0 4
27925: PUSH
27926: LD_VAR 0 4
27930: PUSH
27931: LD_VAR 0 7
27935: DIFF
27936: ST_TO_ADDR
// if tmp and mech < 6 then
27937: LD_VAR 0 4
27941: PUSH
27942: LD_VAR 0 7
27946: PUSH
27947: LD_INT 6
27949: LESS
27950: AND
27951: IFFALSE 28139
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27953: LD_ADDR_VAR 0 9
27957: PUSH
27958: LD_VAR 0 4
27962: PUSH
27963: LD_VAR 0 8
27967: PUSH
27968: LD_VAR 0 7
27972: UNION
27973: DIFF
27974: PPUSH
27975: LD_INT 3
27977: PPUSH
27978: CALL 85881 0 2
27982: ST_TO_ADDR
// p := [ ] ;
27983: LD_ADDR_VAR 0 11
27987: PUSH
27988: EMPTY
27989: ST_TO_ADDR
// if sort then
27990: LD_VAR 0 9
27994: IFFALSE 28110
// for i = 1 to 6 - mech do
27996: LD_ADDR_VAR 0 3
28000: PUSH
28001: DOUBLE
28002: LD_INT 1
28004: DEC
28005: ST_TO_ADDR
28006: LD_INT 6
28008: PUSH
28009: LD_VAR 0 7
28013: MINUS
28014: PUSH
28015: FOR_TO
28016: IFFALSE 28108
// begin if i = sort then
28018: LD_VAR 0 3
28022: PUSH
28023: LD_VAR 0 9
28027: EQUAL
28028: IFFALSE 28032
// break ;
28030: GO 28108
// if GetClass ( i ) = 3 then
28032: LD_VAR 0 3
28036: PPUSH
28037: CALL_OW 257
28041: PUSH
28042: LD_INT 3
28044: EQUAL
28045: IFFALSE 28049
// continue ;
28047: GO 28015
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28049: LD_ADDR_VAR 0 11
28053: PUSH
28054: LD_VAR 0 11
28058: PPUSH
28059: LD_VAR 0 11
28063: PUSH
28064: LD_INT 1
28066: PLUS
28067: PPUSH
28068: LD_VAR 0 9
28072: PUSH
28073: LD_VAR 0 3
28077: ARRAY
28078: PPUSH
28079: CALL_OW 2
28083: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28084: LD_ADDR_VAR 0 4
28088: PUSH
28089: LD_VAR 0 4
28093: PUSH
28094: LD_VAR 0 9
28098: PUSH
28099: LD_VAR 0 3
28103: ARRAY
28104: DIFF
28105: ST_TO_ADDR
// end ;
28106: GO 28015
28108: POP
28109: POP
// if p then
28110: LD_VAR 0 11
28114: IFFALSE 28139
// result := Replace ( result , 3 , p ) ;
28116: LD_ADDR_VAR 0 2
28120: PUSH
28121: LD_VAR 0 2
28125: PPUSH
28126: LD_INT 3
28128: PPUSH
28129: LD_VAR 0 11
28133: PPUSH
28134: CALL_OW 1
28138: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28139: LD_ADDR_VAR 0 4
28143: PUSH
28144: LD_VAR 0 4
28148: PUSH
28149: LD_VAR 0 6
28153: DIFF
28154: ST_TO_ADDR
// if tmp and eng < 6 then
28155: LD_VAR 0 4
28159: PUSH
28160: LD_VAR 0 6
28164: PUSH
28165: LD_INT 6
28167: LESS
28168: AND
28169: IFFALSE 28363
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28171: LD_ADDR_VAR 0 9
28175: PUSH
28176: LD_VAR 0 4
28180: PUSH
28181: LD_VAR 0 8
28185: PUSH
28186: LD_VAR 0 7
28190: UNION
28191: PUSH
28192: LD_VAR 0 6
28196: UNION
28197: DIFF
28198: PPUSH
28199: LD_INT 2
28201: PPUSH
28202: CALL 85881 0 2
28206: ST_TO_ADDR
// p := [ ] ;
28207: LD_ADDR_VAR 0 11
28211: PUSH
28212: EMPTY
28213: ST_TO_ADDR
// if sort then
28214: LD_VAR 0 9
28218: IFFALSE 28334
// for i = 1 to 6 - eng do
28220: LD_ADDR_VAR 0 3
28224: PUSH
28225: DOUBLE
28226: LD_INT 1
28228: DEC
28229: ST_TO_ADDR
28230: LD_INT 6
28232: PUSH
28233: LD_VAR 0 6
28237: MINUS
28238: PUSH
28239: FOR_TO
28240: IFFALSE 28332
// begin if i = sort then
28242: LD_VAR 0 3
28246: PUSH
28247: LD_VAR 0 9
28251: EQUAL
28252: IFFALSE 28256
// break ;
28254: GO 28332
// if GetClass ( i ) = 2 then
28256: LD_VAR 0 3
28260: PPUSH
28261: CALL_OW 257
28265: PUSH
28266: LD_INT 2
28268: EQUAL
28269: IFFALSE 28273
// continue ;
28271: GO 28239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28273: LD_ADDR_VAR 0 11
28277: PUSH
28278: LD_VAR 0 11
28282: PPUSH
28283: LD_VAR 0 11
28287: PUSH
28288: LD_INT 1
28290: PLUS
28291: PPUSH
28292: LD_VAR 0 9
28296: PUSH
28297: LD_VAR 0 3
28301: ARRAY
28302: PPUSH
28303: CALL_OW 2
28307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28308: LD_ADDR_VAR 0 4
28312: PUSH
28313: LD_VAR 0 4
28317: PUSH
28318: LD_VAR 0 9
28322: PUSH
28323: LD_VAR 0 3
28327: ARRAY
28328: DIFF
28329: ST_TO_ADDR
// end ;
28330: GO 28239
28332: POP
28333: POP
// if p then
28334: LD_VAR 0 11
28338: IFFALSE 28363
// result := Replace ( result , 2 , p ) ;
28340: LD_ADDR_VAR 0 2
28344: PUSH
28345: LD_VAR 0 2
28349: PPUSH
28350: LD_INT 2
28352: PPUSH
28353: LD_VAR 0 11
28357: PPUSH
28358: CALL_OW 1
28362: ST_TO_ADDR
// end ; exit ;
28363: GO 29087
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28365: LD_EXP 119
28369: PUSH
28370: LD_EXP 118
28374: PUSH
28375: LD_VAR 0 1
28379: ARRAY
28380: ARRAY
28381: NOT
28382: PUSH
28383: LD_EXP 92
28387: PUSH
28388: LD_VAR 0 1
28392: ARRAY
28393: PPUSH
28394: LD_INT 30
28396: PUSH
28397: LD_INT 3
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PPUSH
28404: CALL_OW 72
28408: AND
28409: PUSH
28410: LD_EXP 97
28414: PUSH
28415: LD_VAR 0 1
28419: ARRAY
28420: NOT
28421: AND
28422: IFFALSE 29087
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28424: LD_ADDR_EXP 134
28428: PUSH
28429: LD_EXP 134
28433: PPUSH
28434: LD_VAR 0 1
28438: PPUSH
28439: LD_INT 6
28441: PPUSH
28442: CALL_OW 1
28446: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28447: LD_ADDR_VAR 0 2
28451: PUSH
28452: LD_INT 0
28454: PUSH
28455: LD_INT 0
28457: PUSH
28458: LD_INT 0
28460: PUSH
28461: LD_INT 0
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: ST_TO_ADDR
// if sci >= 1 then
28470: LD_VAR 0 8
28474: PUSH
28475: LD_INT 1
28477: GREATEREQUAL
28478: IFFALSE 28500
// tmp := tmp diff sci [ 1 ] ;
28480: LD_ADDR_VAR 0 4
28484: PUSH
28485: LD_VAR 0 4
28489: PUSH
28490: LD_VAR 0 8
28494: PUSH
28495: LD_INT 1
28497: ARRAY
28498: DIFF
28499: ST_TO_ADDR
// if tmp and not sci then
28500: LD_VAR 0 4
28504: PUSH
28505: LD_VAR 0 8
28509: NOT
28510: AND
28511: IFFALSE 28580
// begin sort := SortBySkill ( tmp , 4 ) ;
28513: LD_ADDR_VAR 0 9
28517: PUSH
28518: LD_VAR 0 4
28522: PPUSH
28523: LD_INT 4
28525: PPUSH
28526: CALL 85881 0 2
28530: ST_TO_ADDR
// if sort then
28531: LD_VAR 0 9
28535: IFFALSE 28551
// p := sort [ 1 ] ;
28537: LD_ADDR_VAR 0 11
28541: PUSH
28542: LD_VAR 0 9
28546: PUSH
28547: LD_INT 1
28549: ARRAY
28550: ST_TO_ADDR
// if p then
28551: LD_VAR 0 11
28555: IFFALSE 28580
// result := Replace ( result , 4 , p ) ;
28557: LD_ADDR_VAR 0 2
28561: PUSH
28562: LD_VAR 0 2
28566: PPUSH
28567: LD_INT 4
28569: PPUSH
28570: LD_VAR 0 11
28574: PPUSH
28575: CALL_OW 1
28579: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28580: LD_ADDR_VAR 0 4
28584: PUSH
28585: LD_VAR 0 4
28589: PUSH
28590: LD_VAR 0 7
28594: DIFF
28595: ST_TO_ADDR
// if tmp and mech < 6 then
28596: LD_VAR 0 4
28600: PUSH
28601: LD_VAR 0 7
28605: PUSH
28606: LD_INT 6
28608: LESS
28609: AND
28610: IFFALSE 28792
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28612: LD_ADDR_VAR 0 9
28616: PUSH
28617: LD_VAR 0 4
28621: PUSH
28622: LD_VAR 0 7
28626: DIFF
28627: PPUSH
28628: LD_INT 3
28630: PPUSH
28631: CALL 85881 0 2
28635: ST_TO_ADDR
// p := [ ] ;
28636: LD_ADDR_VAR 0 11
28640: PUSH
28641: EMPTY
28642: ST_TO_ADDR
// if sort then
28643: LD_VAR 0 9
28647: IFFALSE 28763
// for i = 1 to 6 - mech do
28649: LD_ADDR_VAR 0 3
28653: PUSH
28654: DOUBLE
28655: LD_INT 1
28657: DEC
28658: ST_TO_ADDR
28659: LD_INT 6
28661: PUSH
28662: LD_VAR 0 7
28666: MINUS
28667: PUSH
28668: FOR_TO
28669: IFFALSE 28761
// begin if i = sort then
28671: LD_VAR 0 3
28675: PUSH
28676: LD_VAR 0 9
28680: EQUAL
28681: IFFALSE 28685
// break ;
28683: GO 28761
// if GetClass ( i ) = 3 then
28685: LD_VAR 0 3
28689: PPUSH
28690: CALL_OW 257
28694: PUSH
28695: LD_INT 3
28697: EQUAL
28698: IFFALSE 28702
// continue ;
28700: GO 28668
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28702: LD_ADDR_VAR 0 11
28706: PUSH
28707: LD_VAR 0 11
28711: PPUSH
28712: LD_VAR 0 11
28716: PUSH
28717: LD_INT 1
28719: PLUS
28720: PPUSH
28721: LD_VAR 0 9
28725: PUSH
28726: LD_VAR 0 3
28730: ARRAY
28731: PPUSH
28732: CALL_OW 2
28736: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28737: LD_ADDR_VAR 0 4
28741: PUSH
28742: LD_VAR 0 4
28746: PUSH
28747: LD_VAR 0 9
28751: PUSH
28752: LD_VAR 0 3
28756: ARRAY
28757: DIFF
28758: ST_TO_ADDR
// end ;
28759: GO 28668
28761: POP
28762: POP
// if p then
28763: LD_VAR 0 11
28767: IFFALSE 28792
// result := Replace ( result , 3 , p ) ;
28769: LD_ADDR_VAR 0 2
28773: PUSH
28774: LD_VAR 0 2
28778: PPUSH
28779: LD_INT 3
28781: PPUSH
28782: LD_VAR 0 11
28786: PPUSH
28787: CALL_OW 1
28791: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28792: LD_ADDR_VAR 0 4
28796: PUSH
28797: LD_VAR 0 4
28801: PUSH
28802: LD_VAR 0 6
28806: DIFF
28807: ST_TO_ADDR
// if tmp and eng < 4 then
28808: LD_VAR 0 4
28812: PUSH
28813: LD_VAR 0 6
28817: PUSH
28818: LD_INT 4
28820: LESS
28821: AND
28822: IFFALSE 29012
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28824: LD_ADDR_VAR 0 9
28828: PUSH
28829: LD_VAR 0 4
28833: PUSH
28834: LD_VAR 0 7
28838: PUSH
28839: LD_VAR 0 6
28843: UNION
28844: DIFF
28845: PPUSH
28846: LD_INT 2
28848: PPUSH
28849: CALL 85881 0 2
28853: ST_TO_ADDR
// p := [ ] ;
28854: LD_ADDR_VAR 0 11
28858: PUSH
28859: EMPTY
28860: ST_TO_ADDR
// if sort then
28861: LD_VAR 0 9
28865: IFFALSE 28981
// for i = 1 to 4 - eng do
28867: LD_ADDR_VAR 0 3
28871: PUSH
28872: DOUBLE
28873: LD_INT 1
28875: DEC
28876: ST_TO_ADDR
28877: LD_INT 4
28879: PUSH
28880: LD_VAR 0 6
28884: MINUS
28885: PUSH
28886: FOR_TO
28887: IFFALSE 28979
// begin if i = sort then
28889: LD_VAR 0 3
28893: PUSH
28894: LD_VAR 0 9
28898: EQUAL
28899: IFFALSE 28903
// break ;
28901: GO 28979
// if GetClass ( i ) = 2 then
28903: LD_VAR 0 3
28907: PPUSH
28908: CALL_OW 257
28912: PUSH
28913: LD_INT 2
28915: EQUAL
28916: IFFALSE 28920
// continue ;
28918: GO 28886
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28920: LD_ADDR_VAR 0 11
28924: PUSH
28925: LD_VAR 0 11
28929: PPUSH
28930: LD_VAR 0 11
28934: PUSH
28935: LD_INT 1
28937: PLUS
28938: PPUSH
28939: LD_VAR 0 9
28943: PUSH
28944: LD_VAR 0 3
28948: ARRAY
28949: PPUSH
28950: CALL_OW 2
28954: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28955: LD_ADDR_VAR 0 4
28959: PUSH
28960: LD_VAR 0 4
28964: PUSH
28965: LD_VAR 0 9
28969: PUSH
28970: LD_VAR 0 3
28974: ARRAY
28975: DIFF
28976: ST_TO_ADDR
// end ;
28977: GO 28886
28979: POP
28980: POP
// if p then
28981: LD_VAR 0 11
28985: IFFALSE 29010
// result := Replace ( result , 2 , p ) ;
28987: LD_ADDR_VAR 0 2
28991: PUSH
28992: LD_VAR 0 2
28996: PPUSH
28997: LD_INT 2
28999: PPUSH
29000: LD_VAR 0 11
29004: PPUSH
29005: CALL_OW 1
29009: ST_TO_ADDR
// end else
29010: GO 29056
// for i = eng downto 5 do
29012: LD_ADDR_VAR 0 3
29016: PUSH
29017: DOUBLE
29018: LD_VAR 0 6
29022: INC
29023: ST_TO_ADDR
29024: LD_INT 5
29026: PUSH
29027: FOR_DOWNTO
29028: IFFALSE 29054
// tmp := tmp union eng [ i ] ;
29030: LD_ADDR_VAR 0 4
29034: PUSH
29035: LD_VAR 0 4
29039: PUSH
29040: LD_VAR 0 6
29044: PUSH
29045: LD_VAR 0 3
29049: ARRAY
29050: UNION
29051: ST_TO_ADDR
29052: GO 29027
29054: POP
29055: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29056: LD_ADDR_VAR 0 2
29060: PUSH
29061: LD_VAR 0 2
29065: PPUSH
29066: LD_INT 1
29068: PPUSH
29069: LD_VAR 0 4
29073: PUSH
29074: LD_VAR 0 5
29078: DIFF
29079: PPUSH
29080: CALL_OW 1
29084: ST_TO_ADDR
// exit ;
29085: GO 29087
// end ; end ;
29087: LD_VAR 0 2
29091: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29092: LD_INT 0
29094: PPUSH
29095: PPUSH
29096: PPUSH
// if not mc_bases then
29097: LD_EXP 92
29101: NOT
29102: IFFALSE 29106
// exit ;
29104: GO 29212
// for i = 1 to mc_bases do
29106: LD_ADDR_VAR 0 2
29110: PUSH
29111: DOUBLE
29112: LD_INT 1
29114: DEC
29115: ST_TO_ADDR
29116: LD_EXP 92
29120: PUSH
29121: FOR_TO
29122: IFFALSE 29203
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29124: LD_ADDR_VAR 0 3
29128: PUSH
29129: LD_EXP 92
29133: PUSH
29134: LD_VAR 0 2
29138: ARRAY
29139: PPUSH
29140: LD_INT 21
29142: PUSH
29143: LD_INT 3
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 3
29152: PUSH
29153: LD_INT 24
29155: PUSH
29156: LD_INT 1000
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PPUSH
29171: CALL_OW 72
29175: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29176: LD_ADDR_EXP 93
29180: PUSH
29181: LD_EXP 93
29185: PPUSH
29186: LD_VAR 0 2
29190: PPUSH
29191: LD_VAR 0 3
29195: PPUSH
29196: CALL_OW 1
29200: ST_TO_ADDR
// end ;
29201: GO 29121
29203: POP
29204: POP
// RaiseSailEvent ( 101 ) ;
29205: LD_INT 101
29207: PPUSH
29208: CALL_OW 427
// end ;
29212: LD_VAR 0 1
29216: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29217: LD_INT 0
29219: PPUSH
29220: PPUSH
29221: PPUSH
29222: PPUSH
29223: PPUSH
29224: PPUSH
29225: PPUSH
// if not mc_bases then
29226: LD_EXP 92
29230: NOT
29231: IFFALSE 29235
// exit ;
29233: GO 29797
// for i = 1 to mc_bases do
29235: LD_ADDR_VAR 0 2
29239: PUSH
29240: DOUBLE
29241: LD_INT 1
29243: DEC
29244: ST_TO_ADDR
29245: LD_EXP 92
29249: PUSH
29250: FOR_TO
29251: IFFALSE 29788
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29253: LD_ADDR_VAR 0 5
29257: PUSH
29258: LD_EXP 92
29262: PUSH
29263: LD_VAR 0 2
29267: ARRAY
29268: PUSH
29269: LD_EXP 121
29273: PUSH
29274: LD_VAR 0 2
29278: ARRAY
29279: UNION
29280: PPUSH
29281: LD_INT 21
29283: PUSH
29284: LD_INT 1
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 1
29293: PUSH
29294: LD_INT 3
29296: PUSH
29297: LD_INT 54
29299: PUSH
29300: EMPTY
29301: LIST
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 3
29309: PUSH
29310: LD_INT 24
29312: PUSH
29313: LD_INT 1000
29315: PUSH
29316: EMPTY
29317: LIST
29318: LIST
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: LIST
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PPUSH
29333: CALL_OW 72
29337: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29338: LD_ADDR_VAR 0 6
29342: PUSH
29343: LD_EXP 92
29347: PUSH
29348: LD_VAR 0 2
29352: ARRAY
29353: PPUSH
29354: LD_INT 21
29356: PUSH
29357: LD_INT 1
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: LD_INT 3
29369: PUSH
29370: LD_INT 54
29372: PUSH
29373: EMPTY
29374: LIST
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 3
29382: PUSH
29383: LD_INT 24
29385: PUSH
29386: LD_INT 250
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: LIST
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PPUSH
29406: CALL_OW 72
29410: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29411: LD_ADDR_VAR 0 7
29415: PUSH
29416: LD_VAR 0 5
29420: PUSH
29421: LD_VAR 0 6
29425: DIFF
29426: ST_TO_ADDR
// if not need_heal_1 then
29427: LD_VAR 0 6
29431: NOT
29432: IFFALSE 29465
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29434: LD_ADDR_EXP 95
29438: PUSH
29439: LD_EXP 95
29443: PPUSH
29444: LD_VAR 0 2
29448: PUSH
29449: LD_INT 1
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PPUSH
29456: EMPTY
29457: PPUSH
29458: CALL 55999 0 3
29462: ST_TO_ADDR
29463: GO 29535
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29465: LD_ADDR_EXP 95
29469: PUSH
29470: LD_EXP 95
29474: PPUSH
29475: LD_VAR 0 2
29479: PUSH
29480: LD_INT 1
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PPUSH
29487: LD_EXP 95
29491: PUSH
29492: LD_VAR 0 2
29496: ARRAY
29497: PUSH
29498: LD_INT 1
29500: ARRAY
29501: PPUSH
29502: LD_INT 3
29504: PUSH
29505: LD_INT 24
29507: PUSH
29508: LD_INT 1000
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PPUSH
29519: CALL_OW 72
29523: PUSH
29524: LD_VAR 0 6
29528: UNION
29529: PPUSH
29530: CALL 55999 0 3
29534: ST_TO_ADDR
// if not need_heal_2 then
29535: LD_VAR 0 7
29539: NOT
29540: IFFALSE 29573
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29542: LD_ADDR_EXP 95
29546: PUSH
29547: LD_EXP 95
29551: PPUSH
29552: LD_VAR 0 2
29556: PUSH
29557: LD_INT 2
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PPUSH
29564: EMPTY
29565: PPUSH
29566: CALL 55999 0 3
29570: ST_TO_ADDR
29571: GO 29605
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29573: LD_ADDR_EXP 95
29577: PUSH
29578: LD_EXP 95
29582: PPUSH
29583: LD_VAR 0 2
29587: PUSH
29588: LD_INT 2
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PPUSH
29595: LD_VAR 0 7
29599: PPUSH
29600: CALL 55999 0 3
29604: ST_TO_ADDR
// if need_heal_2 then
29605: LD_VAR 0 7
29609: IFFALSE 29770
// for j in need_heal_2 do
29611: LD_ADDR_VAR 0 3
29615: PUSH
29616: LD_VAR 0 7
29620: PUSH
29621: FOR_IN
29622: IFFALSE 29768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29624: LD_ADDR_VAR 0 5
29628: PUSH
29629: LD_EXP 92
29633: PUSH
29634: LD_VAR 0 2
29638: ARRAY
29639: PPUSH
29640: LD_INT 2
29642: PUSH
29643: LD_INT 30
29645: PUSH
29646: LD_INT 6
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: LD_INT 30
29655: PUSH
29656: LD_INT 7
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 30
29665: PUSH
29666: LD_INT 8
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 30
29675: PUSH
29676: LD_INT 0
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 30
29685: PUSH
29686: LD_INT 1
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: PPUSH
29701: CALL_OW 72
29705: ST_TO_ADDR
// if tmp then
29706: LD_VAR 0 5
29710: IFFALSE 29766
// begin k := NearestUnitToUnit ( tmp , j ) ;
29712: LD_ADDR_VAR 0 4
29716: PUSH
29717: LD_VAR 0 5
29721: PPUSH
29722: LD_VAR 0 3
29726: PPUSH
29727: CALL_OW 74
29731: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29732: LD_VAR 0 3
29736: PPUSH
29737: LD_VAR 0 4
29741: PPUSH
29742: CALL_OW 296
29746: PUSH
29747: LD_INT 5
29749: GREATER
29750: IFFALSE 29766
// ComMoveToNearbyEntrance ( j , k ) ;
29752: LD_VAR 0 3
29756: PPUSH
29757: LD_VAR 0 4
29761: PPUSH
29762: CALL 88242 0 2
// end ; end ;
29766: GO 29621
29768: POP
29769: POP
// if not need_heal_1 and not need_heal_2 then
29770: LD_VAR 0 6
29774: NOT
29775: PUSH
29776: LD_VAR 0 7
29780: NOT
29781: AND
29782: IFFALSE 29786
// continue ;
29784: GO 29250
// end ;
29786: GO 29250
29788: POP
29789: POP
// RaiseSailEvent ( 102 ) ;
29790: LD_INT 102
29792: PPUSH
29793: CALL_OW 427
// end ;
29797: LD_VAR 0 1
29801: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29802: LD_INT 0
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
// if not mc_bases then
29812: LD_EXP 92
29816: NOT
29817: IFFALSE 29821
// exit ;
29819: GO 30682
// for i = 1 to mc_bases do
29821: LD_ADDR_VAR 0 2
29825: PUSH
29826: DOUBLE
29827: LD_INT 1
29829: DEC
29830: ST_TO_ADDR
29831: LD_EXP 92
29835: PUSH
29836: FOR_TO
29837: IFFALSE 30680
// begin if not mc_building_need_repair [ i ] then
29839: LD_EXP 93
29843: PUSH
29844: LD_VAR 0 2
29848: ARRAY
29849: NOT
29850: IFFALSE 30037
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29852: LD_ADDR_VAR 0 6
29856: PUSH
29857: LD_EXP 111
29861: PUSH
29862: LD_VAR 0 2
29866: ARRAY
29867: PPUSH
29868: LD_INT 3
29870: PUSH
29871: LD_INT 24
29873: PUSH
29874: LD_INT 1000
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 2
29887: PUSH
29888: LD_INT 34
29890: PUSH
29891: LD_INT 13
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 34
29900: PUSH
29901: LD_INT 52
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 34
29910: PUSH
29911: LD_EXP 78
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PPUSH
29930: CALL_OW 72
29934: ST_TO_ADDR
// if cranes then
29935: LD_VAR 0 6
29939: IFFALSE 30001
// for j in cranes do
29941: LD_ADDR_VAR 0 3
29945: PUSH
29946: LD_VAR 0 6
29950: PUSH
29951: FOR_IN
29952: IFFALSE 29999
// if not IsInArea ( j , mc_parking [ i ] ) then
29954: LD_VAR 0 3
29958: PPUSH
29959: LD_EXP 116
29963: PUSH
29964: LD_VAR 0 2
29968: ARRAY
29969: PPUSH
29970: CALL_OW 308
29974: NOT
29975: IFFALSE 29997
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29977: LD_VAR 0 3
29981: PPUSH
29982: LD_EXP 116
29986: PUSH
29987: LD_VAR 0 2
29991: ARRAY
29992: PPUSH
29993: CALL_OW 113
29997: GO 29951
29999: POP
30000: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30001: LD_ADDR_EXP 94
30005: PUSH
30006: LD_EXP 94
30010: PPUSH
30011: LD_VAR 0 2
30015: PPUSH
30016: EMPTY
30017: PPUSH
30018: CALL_OW 1
30022: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30023: LD_VAR 0 2
30027: PPUSH
30028: LD_INT 101
30030: PPUSH
30031: CALL 24925 0 2
// continue ;
30035: GO 29836
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30037: LD_ADDR_EXP 98
30041: PUSH
30042: LD_EXP 98
30046: PPUSH
30047: LD_VAR 0 2
30051: PPUSH
30052: EMPTY
30053: PPUSH
30054: CALL_OW 1
30058: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30059: LD_VAR 0 2
30063: PPUSH
30064: LD_INT 103
30066: PPUSH
30067: CALL 24925 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30071: LD_ADDR_VAR 0 5
30075: PUSH
30076: LD_EXP 92
30080: PUSH
30081: LD_VAR 0 2
30085: ARRAY
30086: PUSH
30087: LD_EXP 121
30091: PUSH
30092: LD_VAR 0 2
30096: ARRAY
30097: UNION
30098: PPUSH
30099: LD_INT 2
30101: PUSH
30102: LD_INT 25
30104: PUSH
30105: LD_INT 2
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 25
30114: PUSH
30115: LD_INT 16
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: PUSH
30127: EMPTY
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: PUSH
30135: LD_EXP 95
30139: PUSH
30140: LD_VAR 0 2
30144: ARRAY
30145: PUSH
30146: LD_INT 1
30148: ARRAY
30149: PUSH
30150: LD_EXP 95
30154: PUSH
30155: LD_VAR 0 2
30159: ARRAY
30160: PUSH
30161: LD_INT 2
30163: ARRAY
30164: UNION
30165: DIFF
30166: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30167: LD_ADDR_VAR 0 6
30171: PUSH
30172: LD_EXP 111
30176: PUSH
30177: LD_VAR 0 2
30181: ARRAY
30182: PPUSH
30183: LD_INT 2
30185: PUSH
30186: LD_INT 34
30188: PUSH
30189: LD_INT 13
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PUSH
30196: LD_INT 34
30198: PUSH
30199: LD_INT 52
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: LD_INT 34
30208: PUSH
30209: LD_EXP 78
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: PPUSH
30224: CALL_OW 72
30228: ST_TO_ADDR
// if cranes then
30229: LD_VAR 0 6
30233: IFFALSE 30369
// begin for j in cranes do
30235: LD_ADDR_VAR 0 3
30239: PUSH
30240: LD_VAR 0 6
30244: PUSH
30245: FOR_IN
30246: IFFALSE 30367
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30248: LD_VAR 0 3
30252: PPUSH
30253: CALL_OW 256
30257: PUSH
30258: LD_INT 1000
30260: EQUAL
30261: PUSH
30262: LD_VAR 0 3
30266: PPUSH
30267: CALL_OW 314
30271: NOT
30272: AND
30273: IFFALSE 30307
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30275: LD_VAR 0 3
30279: PPUSH
30280: LD_EXP 93
30284: PUSH
30285: LD_VAR 0 2
30289: ARRAY
30290: PPUSH
30291: LD_VAR 0 3
30295: PPUSH
30296: CALL_OW 74
30300: PPUSH
30301: CALL_OW 130
30305: GO 30365
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30307: LD_VAR 0 3
30311: PPUSH
30312: CALL_OW 256
30316: PUSH
30317: LD_INT 500
30319: LESS
30320: PUSH
30321: LD_VAR 0 3
30325: PPUSH
30326: LD_EXP 116
30330: PUSH
30331: LD_VAR 0 2
30335: ARRAY
30336: PPUSH
30337: CALL_OW 308
30341: NOT
30342: AND
30343: IFFALSE 30365
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30345: LD_VAR 0 3
30349: PPUSH
30350: LD_EXP 116
30354: PUSH
30355: LD_VAR 0 2
30359: ARRAY
30360: PPUSH
30361: CALL_OW 113
// end ;
30365: GO 30245
30367: POP
30368: POP
// end ; if tmp > 3 then
30369: LD_VAR 0 5
30373: PUSH
30374: LD_INT 3
30376: GREATER
30377: IFFALSE 30397
// tmp := ShrinkArray ( tmp , 4 ) ;
30379: LD_ADDR_VAR 0 5
30383: PUSH
30384: LD_VAR 0 5
30388: PPUSH
30389: LD_INT 4
30391: PPUSH
30392: CALL 87690 0 2
30396: ST_TO_ADDR
// if not tmp then
30397: LD_VAR 0 5
30401: NOT
30402: IFFALSE 30406
// continue ;
30404: GO 29836
// for j in tmp do
30406: LD_ADDR_VAR 0 3
30410: PUSH
30411: LD_VAR 0 5
30415: PUSH
30416: FOR_IN
30417: IFFALSE 30676
// begin if IsInUnit ( j ) then
30419: LD_VAR 0 3
30423: PPUSH
30424: CALL_OW 310
30428: IFFALSE 30439
// ComExitBuilding ( j ) ;
30430: LD_VAR 0 3
30434: PPUSH
30435: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30439: LD_VAR 0 3
30443: PUSH
30444: LD_EXP 94
30448: PUSH
30449: LD_VAR 0 2
30453: ARRAY
30454: IN
30455: NOT
30456: IFFALSE 30514
// begin SetTag ( j , 101 ) ;
30458: LD_VAR 0 3
30462: PPUSH
30463: LD_INT 101
30465: PPUSH
30466: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30470: LD_ADDR_EXP 94
30474: PUSH
30475: LD_EXP 94
30479: PPUSH
30480: LD_VAR 0 2
30484: PUSH
30485: LD_EXP 94
30489: PUSH
30490: LD_VAR 0 2
30494: ARRAY
30495: PUSH
30496: LD_INT 1
30498: PLUS
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PPUSH
30504: LD_VAR 0 3
30508: PPUSH
30509: CALL 55999 0 3
30513: ST_TO_ADDR
// end ; wait ( 1 ) ;
30514: LD_INT 1
30516: PPUSH
30517: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30521: LD_ADDR_VAR 0 7
30525: PUSH
30526: LD_EXP 93
30530: PUSH
30531: LD_VAR 0 2
30535: ARRAY
30536: ST_TO_ADDR
// if mc_scan [ i ] then
30537: LD_EXP 115
30541: PUSH
30542: LD_VAR 0 2
30546: ARRAY
30547: IFFALSE 30609
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30549: LD_ADDR_VAR 0 7
30553: PUSH
30554: LD_EXP 93
30558: PUSH
30559: LD_VAR 0 2
30563: ARRAY
30564: PPUSH
30565: LD_INT 3
30567: PUSH
30568: LD_INT 30
30570: PUSH
30571: LD_INT 32
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 30
30580: PUSH
30581: LD_INT 33
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 30
30590: PUSH
30591: LD_INT 31
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: PPUSH
30604: CALL_OW 72
30608: ST_TO_ADDR
// if not to_repair_tmp then
30609: LD_VAR 0 7
30613: NOT
30614: IFFALSE 30618
// continue ;
30616: GO 30416
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30618: LD_ADDR_VAR 0 8
30622: PUSH
30623: LD_VAR 0 7
30627: PPUSH
30628: LD_VAR 0 3
30632: PPUSH
30633: CALL_OW 74
30637: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30638: LD_VAR 0 8
30642: PPUSH
30643: LD_INT 16
30645: PPUSH
30646: CALL 58592 0 2
30650: PUSH
30651: LD_INT 4
30653: ARRAY
30654: PUSH
30655: LD_INT 10
30657: LESS
30658: IFFALSE 30674
// ComRepairBuilding ( j , to_repair ) ;
30660: LD_VAR 0 3
30664: PPUSH
30665: LD_VAR 0 8
30669: PPUSH
30670: CALL_OW 130
// end ;
30674: GO 30416
30676: POP
30677: POP
// end ;
30678: GO 29836
30680: POP
30681: POP
// end ;
30682: LD_VAR 0 1
30686: RET
// export function MC_Heal ; var i , j , tmp ; begin
30687: LD_INT 0
30689: PPUSH
30690: PPUSH
30691: PPUSH
30692: PPUSH
// if not mc_bases then
30693: LD_EXP 92
30697: NOT
30698: IFFALSE 30702
// exit ;
30700: GO 31104
// for i = 1 to mc_bases do
30702: LD_ADDR_VAR 0 2
30706: PUSH
30707: DOUBLE
30708: LD_INT 1
30710: DEC
30711: ST_TO_ADDR
30712: LD_EXP 92
30716: PUSH
30717: FOR_TO
30718: IFFALSE 31102
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30720: LD_EXP 95
30724: PUSH
30725: LD_VAR 0 2
30729: ARRAY
30730: PUSH
30731: LD_INT 1
30733: ARRAY
30734: NOT
30735: PUSH
30736: LD_EXP 95
30740: PUSH
30741: LD_VAR 0 2
30745: ARRAY
30746: PUSH
30747: LD_INT 2
30749: ARRAY
30750: NOT
30751: AND
30752: IFFALSE 30790
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30754: LD_ADDR_EXP 96
30758: PUSH
30759: LD_EXP 96
30763: PPUSH
30764: LD_VAR 0 2
30768: PPUSH
30769: EMPTY
30770: PPUSH
30771: CALL_OW 1
30775: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30776: LD_VAR 0 2
30780: PPUSH
30781: LD_INT 102
30783: PPUSH
30784: CALL 24925 0 2
// continue ;
30788: GO 30717
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30790: LD_ADDR_VAR 0 4
30794: PUSH
30795: LD_EXP 92
30799: PUSH
30800: LD_VAR 0 2
30804: ARRAY
30805: PPUSH
30806: LD_INT 25
30808: PUSH
30809: LD_INT 4
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PPUSH
30816: CALL_OW 72
30820: ST_TO_ADDR
// if not tmp then
30821: LD_VAR 0 4
30825: NOT
30826: IFFALSE 30830
// continue ;
30828: GO 30717
// if mc_taming [ i ] then
30830: LD_EXP 123
30834: PUSH
30835: LD_VAR 0 2
30839: ARRAY
30840: IFFALSE 30864
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30842: LD_ADDR_EXP 123
30846: PUSH
30847: LD_EXP 123
30851: PPUSH
30852: LD_VAR 0 2
30856: PPUSH
30857: EMPTY
30858: PPUSH
30859: CALL_OW 1
30863: ST_TO_ADDR
// for j in tmp do
30864: LD_ADDR_VAR 0 3
30868: PUSH
30869: LD_VAR 0 4
30873: PUSH
30874: FOR_IN
30875: IFFALSE 31098
// begin if IsInUnit ( j ) then
30877: LD_VAR 0 3
30881: PPUSH
30882: CALL_OW 310
30886: IFFALSE 30897
// ComExitBuilding ( j ) ;
30888: LD_VAR 0 3
30892: PPUSH
30893: CALL_OW 122
// if not j in mc_healers [ i ] then
30897: LD_VAR 0 3
30901: PUSH
30902: LD_EXP 96
30906: PUSH
30907: LD_VAR 0 2
30911: ARRAY
30912: IN
30913: NOT
30914: IFFALSE 30960
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30916: LD_ADDR_EXP 96
30920: PUSH
30921: LD_EXP 96
30925: PPUSH
30926: LD_VAR 0 2
30930: PUSH
30931: LD_EXP 96
30935: PUSH
30936: LD_VAR 0 2
30940: ARRAY
30941: PUSH
30942: LD_INT 1
30944: PLUS
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PPUSH
30950: LD_VAR 0 3
30954: PPUSH
30955: CALL 55999 0 3
30959: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30960: LD_VAR 0 3
30964: PPUSH
30965: CALL_OW 110
30969: PUSH
30970: LD_INT 102
30972: NONEQUAL
30973: IFFALSE 30987
// SetTag ( j , 102 ) ;
30975: LD_VAR 0 3
30979: PPUSH
30980: LD_INT 102
30982: PPUSH
30983: CALL_OW 109
// Wait ( 3 ) ;
30987: LD_INT 3
30989: PPUSH
30990: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30994: LD_EXP 95
30998: PUSH
30999: LD_VAR 0 2
31003: ARRAY
31004: PUSH
31005: LD_INT 1
31007: ARRAY
31008: IFFALSE 31040
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31010: LD_VAR 0 3
31014: PPUSH
31015: LD_EXP 95
31019: PUSH
31020: LD_VAR 0 2
31024: ARRAY
31025: PUSH
31026: LD_INT 1
31028: ARRAY
31029: PUSH
31030: LD_INT 1
31032: ARRAY
31033: PPUSH
31034: CALL_OW 128
31038: GO 31096
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31040: LD_VAR 0 3
31044: PPUSH
31045: CALL_OW 314
31049: NOT
31050: PUSH
31051: LD_EXP 95
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: PUSH
31062: LD_INT 2
31064: ARRAY
31065: AND
31066: IFFALSE 31096
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31068: LD_VAR 0 3
31072: PPUSH
31073: LD_EXP 95
31077: PUSH
31078: LD_VAR 0 2
31082: ARRAY
31083: PUSH
31084: LD_INT 2
31086: ARRAY
31087: PUSH
31088: LD_INT 1
31090: ARRAY
31091: PPUSH
31092: CALL_OW 128
// end ;
31096: GO 30874
31098: POP
31099: POP
// end ;
31100: GO 30717
31102: POP
31103: POP
// end ;
31104: LD_VAR 0 1
31108: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31109: LD_INT 0
31111: PPUSH
31112: PPUSH
31113: PPUSH
31114: PPUSH
31115: PPUSH
// if not mc_bases then
31116: LD_EXP 92
31120: NOT
31121: IFFALSE 31125
// exit ;
31123: GO 32296
// for i = 1 to mc_bases do
31125: LD_ADDR_VAR 0 2
31129: PUSH
31130: DOUBLE
31131: LD_INT 1
31133: DEC
31134: ST_TO_ADDR
31135: LD_EXP 92
31139: PUSH
31140: FOR_TO
31141: IFFALSE 32294
// begin if mc_scan [ i ] then
31143: LD_EXP 115
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: IFFALSE 31157
// continue ;
31155: GO 31140
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31157: LD_EXP 97
31161: PUSH
31162: LD_VAR 0 2
31166: ARRAY
31167: NOT
31168: PUSH
31169: LD_EXP 99
31173: PUSH
31174: LD_VAR 0 2
31178: ARRAY
31179: NOT
31180: AND
31181: PUSH
31182: LD_EXP 98
31186: PUSH
31187: LD_VAR 0 2
31191: ARRAY
31192: AND
31193: IFFALSE 31231
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31195: LD_ADDR_EXP 98
31199: PUSH
31200: LD_EXP 98
31204: PPUSH
31205: LD_VAR 0 2
31209: PPUSH
31210: EMPTY
31211: PPUSH
31212: CALL_OW 1
31216: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31217: LD_VAR 0 2
31221: PPUSH
31222: LD_INT 103
31224: PPUSH
31225: CALL 24925 0 2
// continue ;
31229: GO 31140
// end ; if mc_construct_list [ i ] then
31231: LD_EXP 99
31235: PUSH
31236: LD_VAR 0 2
31240: ARRAY
31241: IFFALSE 31461
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31243: LD_ADDR_VAR 0 4
31247: PUSH
31248: LD_EXP 92
31252: PUSH
31253: LD_VAR 0 2
31257: ARRAY
31258: PPUSH
31259: LD_INT 25
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PPUSH
31269: CALL_OW 72
31273: PUSH
31274: LD_EXP 94
31278: PUSH
31279: LD_VAR 0 2
31283: ARRAY
31284: DIFF
31285: ST_TO_ADDR
// if not tmp then
31286: LD_VAR 0 4
31290: NOT
31291: IFFALSE 31295
// continue ;
31293: GO 31140
// for j in tmp do
31295: LD_ADDR_VAR 0 3
31299: PUSH
31300: LD_VAR 0 4
31304: PUSH
31305: FOR_IN
31306: IFFALSE 31457
// begin if not mc_builders [ i ] then
31308: LD_EXP 98
31312: PUSH
31313: LD_VAR 0 2
31317: ARRAY
31318: NOT
31319: IFFALSE 31377
// begin SetTag ( j , 103 ) ;
31321: LD_VAR 0 3
31325: PPUSH
31326: LD_INT 103
31328: PPUSH
31329: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31333: LD_ADDR_EXP 98
31337: PUSH
31338: LD_EXP 98
31342: PPUSH
31343: LD_VAR 0 2
31347: PUSH
31348: LD_EXP 98
31352: PUSH
31353: LD_VAR 0 2
31357: ARRAY
31358: PUSH
31359: LD_INT 1
31361: PLUS
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PPUSH
31367: LD_VAR 0 3
31371: PPUSH
31372: CALL 55999 0 3
31376: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31377: LD_VAR 0 3
31381: PPUSH
31382: CALL_OW 310
31386: IFFALSE 31397
// ComExitBuilding ( j ) ;
31388: LD_VAR 0 3
31392: PPUSH
31393: CALL_OW 122
// wait ( 3 ) ;
31397: LD_INT 3
31399: PPUSH
31400: CALL_OW 67
// if not mc_construct_list [ i ] then
31404: LD_EXP 99
31408: PUSH
31409: LD_VAR 0 2
31413: ARRAY
31414: NOT
31415: IFFALSE 31419
// break ;
31417: GO 31457
// if not HasTask ( j ) then
31419: LD_VAR 0 3
31423: PPUSH
31424: CALL_OW 314
31428: NOT
31429: IFFALSE 31455
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31431: LD_VAR 0 3
31435: PPUSH
31436: LD_EXP 99
31440: PUSH
31441: LD_VAR 0 2
31445: ARRAY
31446: PUSH
31447: LD_INT 1
31449: ARRAY
31450: PPUSH
31451: CALL 58856 0 2
// end ;
31455: GO 31305
31457: POP
31458: POP
// end else
31459: GO 32292
// if mc_build_list [ i ] then
31461: LD_EXP 97
31465: PUSH
31466: LD_VAR 0 2
31470: ARRAY
31471: IFFALSE 32292
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31473: LD_ADDR_VAR 0 5
31477: PUSH
31478: LD_EXP 92
31482: PUSH
31483: LD_VAR 0 2
31487: ARRAY
31488: PPUSH
31489: LD_INT 2
31491: PUSH
31492: LD_INT 30
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 30
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: LIST
31516: PPUSH
31517: CALL_OW 72
31521: ST_TO_ADDR
// if depot then
31522: LD_VAR 0 5
31526: IFFALSE 31544
// depot := depot [ 1 ] else
31528: LD_ADDR_VAR 0 5
31532: PUSH
31533: LD_VAR 0 5
31537: PUSH
31538: LD_INT 1
31540: ARRAY
31541: ST_TO_ADDR
31542: GO 31552
// depot := 0 ;
31544: LD_ADDR_VAR 0 5
31548: PUSH
31549: LD_INT 0
31551: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31552: LD_EXP 97
31556: PUSH
31557: LD_VAR 0 2
31561: ARRAY
31562: PUSH
31563: LD_INT 1
31565: ARRAY
31566: PUSH
31567: LD_INT 1
31569: ARRAY
31570: PPUSH
31571: CALL 58680 0 1
31575: PUSH
31576: LD_EXP 92
31580: PUSH
31581: LD_VAR 0 2
31585: ARRAY
31586: PPUSH
31587: LD_INT 2
31589: PUSH
31590: LD_INT 30
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 30
31602: PUSH
31603: LD_INT 3
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: PPUSH
31615: CALL_OW 72
31619: NOT
31620: AND
31621: IFFALSE 31726
// begin for j = 1 to mc_build_list [ i ] do
31623: LD_ADDR_VAR 0 3
31627: PUSH
31628: DOUBLE
31629: LD_INT 1
31631: DEC
31632: ST_TO_ADDR
31633: LD_EXP 97
31637: PUSH
31638: LD_VAR 0 2
31642: ARRAY
31643: PUSH
31644: FOR_TO
31645: IFFALSE 31724
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31647: LD_EXP 97
31651: PUSH
31652: LD_VAR 0 2
31656: ARRAY
31657: PUSH
31658: LD_VAR 0 3
31662: ARRAY
31663: PUSH
31664: LD_INT 1
31666: ARRAY
31667: PUSH
31668: LD_INT 2
31670: EQUAL
31671: IFFALSE 31722
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31673: LD_ADDR_EXP 97
31677: PUSH
31678: LD_EXP 97
31682: PPUSH
31683: LD_VAR 0 2
31687: PPUSH
31688: LD_EXP 97
31692: PUSH
31693: LD_VAR 0 2
31697: ARRAY
31698: PPUSH
31699: LD_VAR 0 3
31703: PPUSH
31704: LD_INT 1
31706: PPUSH
31707: LD_INT 0
31709: PPUSH
31710: CALL 55417 0 4
31714: PPUSH
31715: CALL_OW 1
31719: ST_TO_ADDR
// break ;
31720: GO 31724
// end ;
31722: GO 31644
31724: POP
31725: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31726: LD_EXP 97
31730: PUSH
31731: LD_VAR 0 2
31735: ARRAY
31736: PUSH
31737: LD_INT 1
31739: ARRAY
31740: PUSH
31741: LD_INT 1
31743: ARRAY
31744: PUSH
31745: LD_INT 0
31747: EQUAL
31748: PUSH
31749: LD_VAR 0 5
31753: PUSH
31754: LD_VAR 0 5
31758: PPUSH
31759: LD_EXP 97
31763: PUSH
31764: LD_VAR 0 2
31768: ARRAY
31769: PUSH
31770: LD_INT 1
31772: ARRAY
31773: PUSH
31774: LD_INT 1
31776: ARRAY
31777: PPUSH
31778: LD_EXP 97
31782: PUSH
31783: LD_VAR 0 2
31787: ARRAY
31788: PUSH
31789: LD_INT 1
31791: ARRAY
31792: PUSH
31793: LD_INT 2
31795: ARRAY
31796: PPUSH
31797: LD_EXP 97
31801: PUSH
31802: LD_VAR 0 2
31806: ARRAY
31807: PUSH
31808: LD_INT 1
31810: ARRAY
31811: PUSH
31812: LD_INT 3
31814: ARRAY
31815: PPUSH
31816: LD_EXP 97
31820: PUSH
31821: LD_VAR 0 2
31825: ARRAY
31826: PUSH
31827: LD_INT 1
31829: ARRAY
31830: PUSH
31831: LD_INT 4
31833: ARRAY
31834: PPUSH
31835: CALL 63747 0 5
31839: AND
31840: OR
31841: IFFALSE 32122
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31843: LD_ADDR_VAR 0 4
31847: PUSH
31848: LD_EXP 92
31852: PUSH
31853: LD_VAR 0 2
31857: ARRAY
31858: PPUSH
31859: LD_INT 25
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PPUSH
31869: CALL_OW 72
31873: PUSH
31874: LD_EXP 94
31878: PUSH
31879: LD_VAR 0 2
31883: ARRAY
31884: DIFF
31885: ST_TO_ADDR
// if not tmp then
31886: LD_VAR 0 4
31890: NOT
31891: IFFALSE 31895
// continue ;
31893: GO 31140
// for j in tmp do
31895: LD_ADDR_VAR 0 3
31899: PUSH
31900: LD_VAR 0 4
31904: PUSH
31905: FOR_IN
31906: IFFALSE 32118
// begin if not mc_builders [ i ] then
31908: LD_EXP 98
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: NOT
31919: IFFALSE 31977
// begin SetTag ( j , 103 ) ;
31921: LD_VAR 0 3
31925: PPUSH
31926: LD_INT 103
31928: PPUSH
31929: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31933: LD_ADDR_EXP 98
31937: PUSH
31938: LD_EXP 98
31942: PPUSH
31943: LD_VAR 0 2
31947: PUSH
31948: LD_EXP 98
31952: PUSH
31953: LD_VAR 0 2
31957: ARRAY
31958: PUSH
31959: LD_INT 1
31961: PLUS
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PPUSH
31967: LD_VAR 0 3
31971: PPUSH
31972: CALL 55999 0 3
31976: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31977: LD_VAR 0 3
31981: PPUSH
31982: CALL_OW 310
31986: IFFALSE 31997
// ComExitBuilding ( j ) ;
31988: LD_VAR 0 3
31992: PPUSH
31993: CALL_OW 122
// wait ( 3 ) ;
31997: LD_INT 3
31999: PPUSH
32000: CALL_OW 67
// if not mc_build_list [ i ] then
32004: LD_EXP 97
32008: PUSH
32009: LD_VAR 0 2
32013: ARRAY
32014: NOT
32015: IFFALSE 32019
// break ;
32017: GO 32118
// if not HasTask ( j ) then
32019: LD_VAR 0 3
32023: PPUSH
32024: CALL_OW 314
32028: NOT
32029: IFFALSE 32116
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32031: LD_VAR 0 3
32035: PPUSH
32036: LD_EXP 97
32040: PUSH
32041: LD_VAR 0 2
32045: ARRAY
32046: PUSH
32047: LD_INT 1
32049: ARRAY
32050: PUSH
32051: LD_INT 1
32053: ARRAY
32054: PPUSH
32055: LD_EXP 97
32059: PUSH
32060: LD_VAR 0 2
32064: ARRAY
32065: PUSH
32066: LD_INT 1
32068: ARRAY
32069: PUSH
32070: LD_INT 2
32072: ARRAY
32073: PPUSH
32074: LD_EXP 97
32078: PUSH
32079: LD_VAR 0 2
32083: ARRAY
32084: PUSH
32085: LD_INT 1
32087: ARRAY
32088: PUSH
32089: LD_INT 3
32091: ARRAY
32092: PPUSH
32093: LD_EXP 97
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: PUSH
32104: LD_INT 1
32106: ARRAY
32107: PUSH
32108: LD_INT 4
32110: ARRAY
32111: PPUSH
32112: CALL_OW 145
// end ;
32116: GO 31905
32118: POP
32119: POP
// end else
32120: GO 32292
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32122: LD_EXP 92
32126: PUSH
32127: LD_VAR 0 2
32131: ARRAY
32132: PPUSH
32133: LD_EXP 97
32137: PUSH
32138: LD_VAR 0 2
32142: ARRAY
32143: PUSH
32144: LD_INT 1
32146: ARRAY
32147: PUSH
32148: LD_INT 1
32150: ARRAY
32151: PPUSH
32152: LD_EXP 97
32156: PUSH
32157: LD_VAR 0 2
32161: ARRAY
32162: PUSH
32163: LD_INT 1
32165: ARRAY
32166: PUSH
32167: LD_INT 2
32169: ARRAY
32170: PPUSH
32171: LD_EXP 97
32175: PUSH
32176: LD_VAR 0 2
32180: ARRAY
32181: PUSH
32182: LD_INT 1
32184: ARRAY
32185: PUSH
32186: LD_INT 3
32188: ARRAY
32189: PPUSH
32190: LD_EXP 97
32194: PUSH
32195: LD_VAR 0 2
32199: ARRAY
32200: PUSH
32201: LD_INT 1
32203: ARRAY
32204: PUSH
32205: LD_INT 4
32207: ARRAY
32208: PPUSH
32209: LD_EXP 92
32213: PUSH
32214: LD_VAR 0 2
32218: ARRAY
32219: PPUSH
32220: LD_INT 21
32222: PUSH
32223: LD_INT 3
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PPUSH
32230: CALL_OW 72
32234: PPUSH
32235: EMPTY
32236: PPUSH
32237: CALL 62877 0 7
32241: NOT
32242: IFFALSE 32292
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32244: LD_ADDR_EXP 97
32248: PUSH
32249: LD_EXP 97
32253: PPUSH
32254: LD_VAR 0 2
32258: PPUSH
32259: LD_EXP 97
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PPUSH
32270: LD_INT 1
32272: PPUSH
32273: LD_INT 1
32275: NEG
32276: PPUSH
32277: LD_INT 0
32279: PPUSH
32280: CALL 55417 0 4
32284: PPUSH
32285: CALL_OW 1
32289: ST_TO_ADDR
// continue ;
32290: GO 31140
// end ; end ; end ;
32292: GO 31140
32294: POP
32295: POP
// end ;
32296: LD_VAR 0 1
32300: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32301: LD_INT 0
32303: PPUSH
32304: PPUSH
32305: PPUSH
32306: PPUSH
32307: PPUSH
32308: PPUSH
// if not mc_bases then
32309: LD_EXP 92
32313: NOT
32314: IFFALSE 32318
// exit ;
32316: GO 32745
// for i = 1 to mc_bases do
32318: LD_ADDR_VAR 0 2
32322: PUSH
32323: DOUBLE
32324: LD_INT 1
32326: DEC
32327: ST_TO_ADDR
32328: LD_EXP 92
32332: PUSH
32333: FOR_TO
32334: IFFALSE 32743
// begin tmp := mc_build_upgrade [ i ] ;
32336: LD_ADDR_VAR 0 4
32340: PUSH
32341: LD_EXP 124
32345: PUSH
32346: LD_VAR 0 2
32350: ARRAY
32351: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32352: LD_ADDR_VAR 0 6
32356: PUSH
32357: LD_EXP 125
32361: PUSH
32362: LD_VAR 0 2
32366: ARRAY
32367: PPUSH
32368: LD_INT 2
32370: PUSH
32371: LD_INT 30
32373: PUSH
32374: LD_INT 6
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 30
32383: PUSH
32384: LD_INT 7
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: LIST
32395: PPUSH
32396: CALL_OW 72
32400: ST_TO_ADDR
// if not tmp and not lab then
32401: LD_VAR 0 4
32405: NOT
32406: PUSH
32407: LD_VAR 0 6
32411: NOT
32412: AND
32413: IFFALSE 32417
// continue ;
32415: GO 32333
// if tmp then
32417: LD_VAR 0 4
32421: IFFALSE 32541
// for j in tmp do
32423: LD_ADDR_VAR 0 3
32427: PUSH
32428: LD_VAR 0 4
32432: PUSH
32433: FOR_IN
32434: IFFALSE 32539
// begin if UpgradeCost ( j ) then
32436: LD_VAR 0 3
32440: PPUSH
32441: CALL 62537 0 1
32445: IFFALSE 32537
// begin ComUpgrade ( j ) ;
32447: LD_VAR 0 3
32451: PPUSH
32452: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32456: LD_ADDR_EXP 124
32460: PUSH
32461: LD_EXP 124
32465: PPUSH
32466: LD_VAR 0 2
32470: PPUSH
32471: LD_EXP 124
32475: PUSH
32476: LD_VAR 0 2
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 3
32486: DIFF
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32493: LD_ADDR_EXP 99
32497: PUSH
32498: LD_EXP 99
32502: PPUSH
32503: LD_VAR 0 2
32507: PUSH
32508: LD_EXP 99
32512: PUSH
32513: LD_VAR 0 2
32517: ARRAY
32518: PUSH
32519: LD_INT 1
32521: PLUS
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PPUSH
32527: LD_VAR 0 3
32531: PPUSH
32532: CALL 55999 0 3
32536: ST_TO_ADDR
// end ; end ;
32537: GO 32433
32539: POP
32540: POP
// if not lab or not mc_lab_upgrade [ i ] then
32541: LD_VAR 0 6
32545: NOT
32546: PUSH
32547: LD_EXP 126
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: NOT
32558: OR
32559: IFFALSE 32563
// continue ;
32561: GO 32333
// for j in lab do
32563: LD_ADDR_VAR 0 3
32567: PUSH
32568: LD_VAR 0 6
32572: PUSH
32573: FOR_IN
32574: IFFALSE 32739
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32576: LD_VAR 0 3
32580: PPUSH
32581: CALL_OW 266
32585: PUSH
32586: LD_INT 6
32588: PUSH
32589: LD_INT 7
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: IN
32596: PUSH
32597: LD_VAR 0 3
32601: PPUSH
32602: CALL_OW 461
32606: PUSH
32607: LD_INT 1
32609: NONEQUAL
32610: AND
32611: IFFALSE 32737
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32613: LD_VAR 0 3
32617: PPUSH
32618: LD_EXP 126
32622: PUSH
32623: LD_VAR 0 2
32627: ARRAY
32628: PUSH
32629: LD_INT 1
32631: ARRAY
32632: PPUSH
32633: CALL 62742 0 2
32637: IFFALSE 32737
// begin ComCancel ( j ) ;
32639: LD_VAR 0 3
32643: PPUSH
32644: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32648: LD_VAR 0 3
32652: PPUSH
32653: LD_EXP 126
32657: PUSH
32658: LD_VAR 0 2
32662: ARRAY
32663: PUSH
32664: LD_INT 1
32666: ARRAY
32667: PPUSH
32668: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32672: LD_VAR 0 3
32676: PUSH
32677: LD_EXP 99
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: IN
32688: NOT
32689: IFFALSE 32735
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32691: LD_ADDR_EXP 99
32695: PUSH
32696: LD_EXP 99
32700: PPUSH
32701: LD_VAR 0 2
32705: PUSH
32706: LD_EXP 99
32710: PUSH
32711: LD_VAR 0 2
32715: ARRAY
32716: PUSH
32717: LD_INT 1
32719: PLUS
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PPUSH
32725: LD_VAR 0 3
32729: PPUSH
32730: CALL 55999 0 3
32734: ST_TO_ADDR
// break ;
32735: GO 32739
// end ; end ; end ;
32737: GO 32573
32739: POP
32740: POP
// end ;
32741: GO 32333
32743: POP
32744: POP
// end ;
32745: LD_VAR 0 1
32749: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32750: LD_INT 0
32752: PPUSH
32753: PPUSH
32754: PPUSH
32755: PPUSH
32756: PPUSH
32757: PPUSH
32758: PPUSH
32759: PPUSH
32760: PPUSH
// if not mc_bases then
32761: LD_EXP 92
32765: NOT
32766: IFFALSE 32770
// exit ;
32768: GO 33175
// for i = 1 to mc_bases do
32770: LD_ADDR_VAR 0 2
32774: PUSH
32775: DOUBLE
32776: LD_INT 1
32778: DEC
32779: ST_TO_ADDR
32780: LD_EXP 92
32784: PUSH
32785: FOR_TO
32786: IFFALSE 33173
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32788: LD_EXP 100
32792: PUSH
32793: LD_VAR 0 2
32797: ARRAY
32798: NOT
32799: PUSH
32800: LD_EXP 92
32804: PUSH
32805: LD_VAR 0 2
32809: ARRAY
32810: PPUSH
32811: LD_INT 30
32813: PUSH
32814: LD_INT 3
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PPUSH
32821: CALL_OW 72
32825: NOT
32826: OR
32827: IFFALSE 32831
// continue ;
32829: GO 32785
// busy := false ;
32831: LD_ADDR_VAR 0 8
32835: PUSH
32836: LD_INT 0
32838: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32839: LD_ADDR_VAR 0 4
32843: PUSH
32844: LD_EXP 92
32848: PUSH
32849: LD_VAR 0 2
32853: ARRAY
32854: PPUSH
32855: LD_INT 30
32857: PUSH
32858: LD_INT 3
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PPUSH
32865: CALL_OW 72
32869: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32870: LD_ADDR_VAR 0 6
32874: PUSH
32875: LD_EXP 100
32879: PUSH
32880: LD_VAR 0 2
32884: ARRAY
32885: PPUSH
32886: LD_INT 2
32888: PUSH
32889: LD_INT 30
32891: PUSH
32892: LD_INT 32
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 30
32901: PUSH
32902: LD_INT 33
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: PPUSH
32914: CALL_OW 72
32918: ST_TO_ADDR
// if not t then
32919: LD_VAR 0 6
32923: NOT
32924: IFFALSE 32928
// continue ;
32926: GO 32785
// for j in tmp do
32928: LD_ADDR_VAR 0 3
32932: PUSH
32933: LD_VAR 0 4
32937: PUSH
32938: FOR_IN
32939: IFFALSE 32969
// if not BuildingStatus ( j ) = bs_idle then
32941: LD_VAR 0 3
32945: PPUSH
32946: CALL_OW 461
32950: PUSH
32951: LD_INT 2
32953: EQUAL
32954: NOT
32955: IFFALSE 32967
// begin busy := true ;
32957: LD_ADDR_VAR 0 8
32961: PUSH
32962: LD_INT 1
32964: ST_TO_ADDR
// break ;
32965: GO 32969
// end ;
32967: GO 32938
32969: POP
32970: POP
// if busy then
32971: LD_VAR 0 8
32975: IFFALSE 32979
// continue ;
32977: GO 32785
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32979: LD_ADDR_VAR 0 7
32983: PUSH
32984: LD_VAR 0 6
32988: PPUSH
32989: LD_INT 35
32991: PUSH
32992: LD_INT 0
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PPUSH
32999: CALL_OW 72
33003: ST_TO_ADDR
// if tw then
33004: LD_VAR 0 7
33008: IFFALSE 33085
// begin tw := tw [ 1 ] ;
33010: LD_ADDR_VAR 0 7
33014: PUSH
33015: LD_VAR 0 7
33019: PUSH
33020: LD_INT 1
33022: ARRAY
33023: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33024: LD_ADDR_VAR 0 9
33028: PUSH
33029: LD_VAR 0 7
33033: PPUSH
33034: LD_EXP 117
33038: PUSH
33039: LD_VAR 0 2
33043: ARRAY
33044: PPUSH
33045: CALL 61004 0 2
33049: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33050: LD_EXP 131
33054: PUSH
33055: LD_VAR 0 2
33059: ARRAY
33060: IFFALSE 33083
// if not weapon in mc_allowed_tower_weapons [ i ] then
33062: LD_VAR 0 9
33066: PUSH
33067: LD_EXP 131
33071: PUSH
33072: LD_VAR 0 2
33076: ARRAY
33077: IN
33078: NOT
33079: IFFALSE 33083
// continue ;
33081: GO 32785
// end else
33083: GO 33148
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33085: LD_ADDR_VAR 0 5
33089: PUSH
33090: LD_EXP 100
33094: PUSH
33095: LD_VAR 0 2
33099: ARRAY
33100: PPUSH
33101: LD_VAR 0 4
33105: PPUSH
33106: CALL 86923 0 2
33110: ST_TO_ADDR
// if not tmp2 then
33111: LD_VAR 0 5
33115: NOT
33116: IFFALSE 33120
// continue ;
33118: GO 32785
// tw := tmp2 [ 1 ] ;
33120: LD_ADDR_VAR 0 7
33124: PUSH
33125: LD_VAR 0 5
33129: PUSH
33130: LD_INT 1
33132: ARRAY
33133: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33134: LD_ADDR_VAR 0 9
33138: PUSH
33139: LD_VAR 0 5
33143: PUSH
33144: LD_INT 2
33146: ARRAY
33147: ST_TO_ADDR
// end ; if not weapon then
33148: LD_VAR 0 9
33152: NOT
33153: IFFALSE 33157
// continue ;
33155: GO 32785
// ComPlaceWeapon ( tw , weapon ) ;
33157: LD_VAR 0 7
33161: PPUSH
33162: LD_VAR 0 9
33166: PPUSH
33167: CALL_OW 148
// end ;
33171: GO 32785
33173: POP
33174: POP
// end ;
33175: LD_VAR 0 1
33179: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33180: LD_INT 0
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
// if not mc_bases then
33189: LD_EXP 92
33193: NOT
33194: IFFALSE 33198
// exit ;
33196: GO 33966
// for i = 1 to mc_bases do
33198: LD_ADDR_VAR 0 2
33202: PUSH
33203: DOUBLE
33204: LD_INT 1
33206: DEC
33207: ST_TO_ADDR
33208: LD_EXP 92
33212: PUSH
33213: FOR_TO
33214: IFFALSE 33964
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33216: LD_EXP 105
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: NOT
33227: PUSH
33228: LD_EXP 105
33232: PUSH
33233: LD_VAR 0 2
33237: ARRAY
33238: PUSH
33239: LD_EXP 106
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: EQUAL
33250: OR
33251: PUSH
33252: LD_EXP 115
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: OR
33263: IFFALSE 33267
// continue ;
33265: GO 33213
// if mc_miners [ i ] then
33267: LD_EXP 106
33271: PUSH
33272: LD_VAR 0 2
33276: ARRAY
33277: IFFALSE 33651
// begin for j = mc_miners [ i ] downto 1 do
33279: LD_ADDR_VAR 0 3
33283: PUSH
33284: DOUBLE
33285: LD_EXP 106
33289: PUSH
33290: LD_VAR 0 2
33294: ARRAY
33295: INC
33296: ST_TO_ADDR
33297: LD_INT 1
33299: PUSH
33300: FOR_DOWNTO
33301: IFFALSE 33649
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33303: LD_EXP 106
33307: PUSH
33308: LD_VAR 0 2
33312: ARRAY
33313: PUSH
33314: LD_VAR 0 3
33318: ARRAY
33319: PPUSH
33320: CALL_OW 301
33324: PUSH
33325: LD_EXP 106
33329: PUSH
33330: LD_VAR 0 2
33334: ARRAY
33335: PUSH
33336: LD_VAR 0 3
33340: ARRAY
33341: PPUSH
33342: CALL_OW 257
33346: PUSH
33347: LD_INT 1
33349: NONEQUAL
33350: OR
33351: IFFALSE 33414
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33353: LD_ADDR_VAR 0 5
33357: PUSH
33358: LD_EXP 106
33362: PUSH
33363: LD_VAR 0 2
33367: ARRAY
33368: PUSH
33369: LD_EXP 106
33373: PUSH
33374: LD_VAR 0 2
33378: ARRAY
33379: PUSH
33380: LD_VAR 0 3
33384: ARRAY
33385: DIFF
33386: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33387: LD_ADDR_EXP 106
33391: PUSH
33392: LD_EXP 106
33396: PPUSH
33397: LD_VAR 0 2
33401: PPUSH
33402: LD_VAR 0 5
33406: PPUSH
33407: CALL_OW 1
33411: ST_TO_ADDR
// continue ;
33412: GO 33300
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33414: LD_EXP 106
33418: PUSH
33419: LD_VAR 0 2
33423: ARRAY
33424: PUSH
33425: LD_VAR 0 3
33429: ARRAY
33430: PPUSH
33431: CALL_OW 257
33435: PUSH
33436: LD_INT 1
33438: EQUAL
33439: PUSH
33440: LD_EXP 106
33444: PUSH
33445: LD_VAR 0 2
33449: ARRAY
33450: PUSH
33451: LD_VAR 0 3
33455: ARRAY
33456: PPUSH
33457: CALL_OW 459
33461: NOT
33462: AND
33463: PUSH
33464: LD_EXP 106
33468: PUSH
33469: LD_VAR 0 2
33473: ARRAY
33474: PUSH
33475: LD_VAR 0 3
33479: ARRAY
33480: PPUSH
33481: CALL_OW 314
33485: NOT
33486: AND
33487: IFFALSE 33647
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33489: LD_EXP 106
33493: PUSH
33494: LD_VAR 0 2
33498: ARRAY
33499: PUSH
33500: LD_VAR 0 3
33504: ARRAY
33505: PPUSH
33506: CALL_OW 310
33510: IFFALSE 33533
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33512: LD_EXP 106
33516: PUSH
33517: LD_VAR 0 2
33521: ARRAY
33522: PUSH
33523: LD_VAR 0 3
33527: ARRAY
33528: PPUSH
33529: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33533: LD_EXP 106
33537: PUSH
33538: LD_VAR 0 2
33542: ARRAY
33543: PUSH
33544: LD_VAR 0 3
33548: ARRAY
33549: PPUSH
33550: CALL_OW 314
33554: NOT
33555: IFFALSE 33647
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33557: LD_ADDR_VAR 0 7
33561: PUSH
33562: LD_INT 1
33564: PPUSH
33565: LD_EXP 105
33569: PUSH
33570: LD_VAR 0 2
33574: ARRAY
33575: PPUSH
33576: CALL_OW 12
33580: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33581: LD_EXP 106
33585: PUSH
33586: LD_VAR 0 2
33590: ARRAY
33591: PUSH
33592: LD_VAR 0 3
33596: ARRAY
33597: PPUSH
33598: LD_EXP 105
33602: PUSH
33603: LD_VAR 0 2
33607: ARRAY
33608: PUSH
33609: LD_VAR 0 7
33613: ARRAY
33614: PUSH
33615: LD_INT 1
33617: ARRAY
33618: PPUSH
33619: LD_EXP 105
33623: PUSH
33624: LD_VAR 0 2
33628: ARRAY
33629: PUSH
33630: LD_VAR 0 7
33634: ARRAY
33635: PUSH
33636: LD_INT 2
33638: ARRAY
33639: PPUSH
33640: LD_INT 0
33642: PPUSH
33643: CALL_OW 193
// end ; end ; end ;
33647: GO 33300
33649: POP
33650: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33651: LD_ADDR_VAR 0 5
33655: PUSH
33656: LD_EXP 92
33660: PUSH
33661: LD_VAR 0 2
33665: ARRAY
33666: PPUSH
33667: LD_INT 2
33669: PUSH
33670: LD_INT 30
33672: PUSH
33673: LD_INT 4
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 30
33682: PUSH
33683: LD_INT 5
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 30
33692: PUSH
33693: LD_INT 32
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: PPUSH
33706: CALL_OW 72
33710: ST_TO_ADDR
// if not tmp then
33711: LD_VAR 0 5
33715: NOT
33716: IFFALSE 33720
// continue ;
33718: GO 33213
// list := [ ] ;
33720: LD_ADDR_VAR 0 6
33724: PUSH
33725: EMPTY
33726: ST_TO_ADDR
// for j in tmp do
33727: LD_ADDR_VAR 0 3
33731: PUSH
33732: LD_VAR 0 5
33736: PUSH
33737: FOR_IN
33738: IFFALSE 33807
// begin for k in UnitsInside ( j ) do
33740: LD_ADDR_VAR 0 4
33744: PUSH
33745: LD_VAR 0 3
33749: PPUSH
33750: CALL_OW 313
33754: PUSH
33755: FOR_IN
33756: IFFALSE 33803
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33758: LD_VAR 0 4
33762: PPUSH
33763: CALL_OW 257
33767: PUSH
33768: LD_INT 1
33770: EQUAL
33771: PUSH
33772: LD_VAR 0 4
33776: PPUSH
33777: CALL_OW 459
33781: NOT
33782: AND
33783: IFFALSE 33801
// list := list ^ k ;
33785: LD_ADDR_VAR 0 6
33789: PUSH
33790: LD_VAR 0 6
33794: PUSH
33795: LD_VAR 0 4
33799: ADD
33800: ST_TO_ADDR
33801: GO 33755
33803: POP
33804: POP
// end ;
33805: GO 33737
33807: POP
33808: POP
// list := list diff mc_miners [ i ] ;
33809: LD_ADDR_VAR 0 6
33813: PUSH
33814: LD_VAR 0 6
33818: PUSH
33819: LD_EXP 106
33823: PUSH
33824: LD_VAR 0 2
33828: ARRAY
33829: DIFF
33830: ST_TO_ADDR
// if not list then
33831: LD_VAR 0 6
33835: NOT
33836: IFFALSE 33840
// continue ;
33838: GO 33213
// k := mc_mines [ i ] - mc_miners [ i ] ;
33840: LD_ADDR_VAR 0 4
33844: PUSH
33845: LD_EXP 105
33849: PUSH
33850: LD_VAR 0 2
33854: ARRAY
33855: PUSH
33856: LD_EXP 106
33860: PUSH
33861: LD_VAR 0 2
33865: ARRAY
33866: MINUS
33867: ST_TO_ADDR
// if k > list then
33868: LD_VAR 0 4
33872: PUSH
33873: LD_VAR 0 6
33877: GREATER
33878: IFFALSE 33890
// k := list ;
33880: LD_ADDR_VAR 0 4
33884: PUSH
33885: LD_VAR 0 6
33889: ST_TO_ADDR
// for j = 1 to k do
33890: LD_ADDR_VAR 0 3
33894: PUSH
33895: DOUBLE
33896: LD_INT 1
33898: DEC
33899: ST_TO_ADDR
33900: LD_VAR 0 4
33904: PUSH
33905: FOR_TO
33906: IFFALSE 33960
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33908: LD_ADDR_EXP 106
33912: PUSH
33913: LD_EXP 106
33917: PPUSH
33918: LD_VAR 0 2
33922: PUSH
33923: LD_EXP 106
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: PLUS
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PPUSH
33942: LD_VAR 0 6
33946: PUSH
33947: LD_VAR 0 3
33951: ARRAY
33952: PPUSH
33953: CALL 55999 0 3
33957: ST_TO_ADDR
33958: GO 33905
33960: POP
33961: POP
// end ;
33962: GO 33213
33964: POP
33965: POP
// end ;
33966: LD_VAR 0 1
33970: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33971: LD_INT 0
33973: PPUSH
33974: PPUSH
33975: PPUSH
33976: PPUSH
33977: PPUSH
33978: PPUSH
33979: PPUSH
33980: PPUSH
33981: PPUSH
33982: PPUSH
// if not mc_bases then
33983: LD_EXP 92
33987: NOT
33988: IFFALSE 33992
// exit ;
33990: GO 35742
// for i = 1 to mc_bases do
33992: LD_ADDR_VAR 0 2
33996: PUSH
33997: DOUBLE
33998: LD_INT 1
34000: DEC
34001: ST_TO_ADDR
34002: LD_EXP 92
34006: PUSH
34007: FOR_TO
34008: IFFALSE 35740
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34010: LD_EXP 92
34014: PUSH
34015: LD_VAR 0 2
34019: ARRAY
34020: NOT
34021: PUSH
34022: LD_EXP 99
34026: PUSH
34027: LD_VAR 0 2
34031: ARRAY
34032: OR
34033: IFFALSE 34037
// continue ;
34035: GO 34007
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34037: LD_EXP 108
34041: PUSH
34042: LD_VAR 0 2
34046: ARRAY
34047: NOT
34048: PUSH
34049: LD_EXP 109
34053: PUSH
34054: LD_VAR 0 2
34058: ARRAY
34059: AND
34060: IFFALSE 34098
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34062: LD_ADDR_EXP 109
34066: PUSH
34067: LD_EXP 109
34071: PPUSH
34072: LD_VAR 0 2
34076: PPUSH
34077: EMPTY
34078: PPUSH
34079: CALL_OW 1
34083: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34084: LD_VAR 0 2
34088: PPUSH
34089: LD_INT 107
34091: PPUSH
34092: CALL 24925 0 2
// continue ;
34096: GO 34007
// end ; target := [ ] ;
34098: LD_ADDR_VAR 0 6
34102: PUSH
34103: EMPTY
34104: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34105: LD_ADDR_VAR 0 3
34109: PUSH
34110: DOUBLE
34111: LD_EXP 108
34115: PUSH
34116: LD_VAR 0 2
34120: ARRAY
34121: INC
34122: ST_TO_ADDR
34123: LD_INT 1
34125: PUSH
34126: FOR_DOWNTO
34127: IFFALSE 34387
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34129: LD_EXP 108
34133: PUSH
34134: LD_VAR 0 2
34138: ARRAY
34139: PUSH
34140: LD_VAR 0 3
34144: ARRAY
34145: PUSH
34146: LD_INT 2
34148: ARRAY
34149: PPUSH
34150: LD_EXP 108
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PUSH
34161: LD_VAR 0 3
34165: ARRAY
34166: PUSH
34167: LD_INT 3
34169: ARRAY
34170: PPUSH
34171: CALL_OW 488
34175: PUSH
34176: LD_EXP 108
34180: PUSH
34181: LD_VAR 0 2
34185: ARRAY
34186: PUSH
34187: LD_VAR 0 3
34191: ARRAY
34192: PUSH
34193: LD_INT 2
34195: ARRAY
34196: PPUSH
34197: LD_EXP 108
34201: PUSH
34202: LD_VAR 0 2
34206: ARRAY
34207: PUSH
34208: LD_VAR 0 3
34212: ARRAY
34213: PUSH
34214: LD_INT 3
34216: ARRAY
34217: PPUSH
34218: CALL_OW 284
34222: PUSH
34223: LD_INT 0
34225: EQUAL
34226: AND
34227: IFFALSE 34282
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34229: LD_ADDR_VAR 0 5
34233: PUSH
34234: LD_EXP 108
34238: PUSH
34239: LD_VAR 0 2
34243: ARRAY
34244: PPUSH
34245: LD_VAR 0 3
34249: PPUSH
34250: CALL_OW 3
34254: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34255: LD_ADDR_EXP 108
34259: PUSH
34260: LD_EXP 108
34264: PPUSH
34265: LD_VAR 0 2
34269: PPUSH
34270: LD_VAR 0 5
34274: PPUSH
34275: CALL_OW 1
34279: ST_TO_ADDR
// continue ;
34280: GO 34126
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34282: LD_EXP 92
34286: PUSH
34287: LD_VAR 0 2
34291: ARRAY
34292: PUSH
34293: LD_INT 1
34295: ARRAY
34296: PPUSH
34297: CALL_OW 255
34301: PPUSH
34302: LD_EXP 108
34306: PUSH
34307: LD_VAR 0 2
34311: ARRAY
34312: PUSH
34313: LD_VAR 0 3
34317: ARRAY
34318: PUSH
34319: LD_INT 2
34321: ARRAY
34322: PPUSH
34323: LD_EXP 108
34327: PUSH
34328: LD_VAR 0 2
34332: ARRAY
34333: PUSH
34334: LD_VAR 0 3
34338: ARRAY
34339: PUSH
34340: LD_INT 3
34342: ARRAY
34343: PPUSH
34344: LD_INT 30
34346: PPUSH
34347: CALL 56895 0 4
34351: PUSH
34352: LD_INT 4
34354: ARRAY
34355: PUSH
34356: LD_INT 0
34358: EQUAL
34359: IFFALSE 34385
// begin target := mc_crates [ i ] [ j ] ;
34361: LD_ADDR_VAR 0 6
34365: PUSH
34366: LD_EXP 108
34370: PUSH
34371: LD_VAR 0 2
34375: ARRAY
34376: PUSH
34377: LD_VAR 0 3
34381: ARRAY
34382: ST_TO_ADDR
// break ;
34383: GO 34387
// end ; end ;
34385: GO 34126
34387: POP
34388: POP
// if not target then
34389: LD_VAR 0 6
34393: NOT
34394: IFFALSE 34398
// continue ;
34396: GO 34007
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34398: LD_ADDR_VAR 0 7
34402: PUSH
34403: LD_EXP 111
34407: PUSH
34408: LD_VAR 0 2
34412: ARRAY
34413: PPUSH
34414: LD_INT 2
34416: PUSH
34417: LD_INT 3
34419: PUSH
34420: LD_INT 58
34422: PUSH
34423: EMPTY
34424: LIST
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 61
34432: PUSH
34433: EMPTY
34434: LIST
34435: PUSH
34436: LD_INT 33
34438: PUSH
34439: LD_INT 5
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 33
34448: PUSH
34449: LD_INT 3
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 2
34465: PUSH
34466: LD_INT 34
34468: PUSH
34469: LD_INT 32
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 34
34478: PUSH
34479: LD_INT 51
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 34
34488: PUSH
34489: LD_INT 12
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PPUSH
34506: CALL_OW 72
34510: ST_TO_ADDR
// if not cargo then
34511: LD_VAR 0 7
34515: NOT
34516: IFFALSE 35159
// begin if mc_crates_collector [ i ] < 5 then
34518: LD_EXP 109
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 5
34531: LESS
34532: IFFALSE 34898
// begin if mc_ape [ i ] then
34534: LD_EXP 121
34538: PUSH
34539: LD_VAR 0 2
34543: ARRAY
34544: IFFALSE 34591
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34546: LD_ADDR_VAR 0 5
34550: PUSH
34551: LD_EXP 121
34555: PUSH
34556: LD_VAR 0 2
34560: ARRAY
34561: PPUSH
34562: LD_INT 25
34564: PUSH
34565: LD_INT 16
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 24
34574: PUSH
34575: LD_INT 750
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PPUSH
34586: CALL_OW 72
34590: ST_TO_ADDR
// if not tmp then
34591: LD_VAR 0 5
34595: NOT
34596: IFFALSE 34643
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34598: LD_ADDR_VAR 0 5
34602: PUSH
34603: LD_EXP 92
34607: PUSH
34608: LD_VAR 0 2
34612: ARRAY
34613: PPUSH
34614: LD_INT 25
34616: PUSH
34617: LD_INT 2
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 24
34626: PUSH
34627: LD_INT 750
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PPUSH
34638: CALL_OW 72
34642: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34643: LD_EXP 121
34647: PUSH
34648: LD_VAR 0 2
34652: ARRAY
34653: PUSH
34654: LD_EXP 92
34658: PUSH
34659: LD_VAR 0 2
34663: ARRAY
34664: PPUSH
34665: LD_INT 25
34667: PUSH
34668: LD_INT 2
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 24
34677: PUSH
34678: LD_INT 750
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PPUSH
34689: CALL_OW 72
34693: AND
34694: PUSH
34695: LD_VAR 0 5
34699: PUSH
34700: LD_INT 5
34702: LESS
34703: AND
34704: IFFALSE 34786
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34706: LD_ADDR_VAR 0 3
34710: PUSH
34711: LD_EXP 92
34715: PUSH
34716: LD_VAR 0 2
34720: ARRAY
34721: PPUSH
34722: LD_INT 25
34724: PUSH
34725: LD_INT 2
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 24
34734: PUSH
34735: LD_INT 750
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PPUSH
34746: CALL_OW 72
34750: PUSH
34751: FOR_IN
34752: IFFALSE 34784
// begin tmp := tmp union j ;
34754: LD_ADDR_VAR 0 5
34758: PUSH
34759: LD_VAR 0 5
34763: PUSH
34764: LD_VAR 0 3
34768: UNION
34769: ST_TO_ADDR
// if tmp >= 5 then
34770: LD_VAR 0 5
34774: PUSH
34775: LD_INT 5
34777: GREATEREQUAL
34778: IFFALSE 34782
// break ;
34780: GO 34784
// end ;
34782: GO 34751
34784: POP
34785: POP
// end ; if not tmp then
34786: LD_VAR 0 5
34790: NOT
34791: IFFALSE 34795
// continue ;
34793: GO 34007
// for j in tmp do
34795: LD_ADDR_VAR 0 3
34799: PUSH
34800: LD_VAR 0 5
34804: PUSH
34805: FOR_IN
34806: IFFALSE 34896
// if not GetTag ( j ) then
34808: LD_VAR 0 3
34812: PPUSH
34813: CALL_OW 110
34817: NOT
34818: IFFALSE 34894
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34820: LD_ADDR_EXP 109
34824: PUSH
34825: LD_EXP 109
34829: PPUSH
34830: LD_VAR 0 2
34834: PUSH
34835: LD_EXP 109
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PUSH
34846: LD_INT 1
34848: PLUS
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PPUSH
34854: LD_VAR 0 3
34858: PPUSH
34859: CALL 55999 0 3
34863: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34864: LD_VAR 0 3
34868: PPUSH
34869: LD_INT 107
34871: PPUSH
34872: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34876: LD_EXP 109
34880: PUSH
34881: LD_VAR 0 2
34885: ARRAY
34886: PUSH
34887: LD_INT 5
34889: GREATEREQUAL
34890: IFFALSE 34894
// break ;
34892: GO 34896
// end ;
34894: GO 34805
34896: POP
34897: POP
// end ; if mc_crates_collector [ i ] and target then
34898: LD_EXP 109
34902: PUSH
34903: LD_VAR 0 2
34907: ARRAY
34908: PUSH
34909: LD_VAR 0 6
34913: AND
34914: IFFALSE 35157
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34916: LD_EXP 109
34920: PUSH
34921: LD_VAR 0 2
34925: ARRAY
34926: PUSH
34927: LD_VAR 0 6
34931: PUSH
34932: LD_INT 1
34934: ARRAY
34935: LESS
34936: IFFALSE 34956
// tmp := mc_crates_collector [ i ] else
34938: LD_ADDR_VAR 0 5
34942: PUSH
34943: LD_EXP 109
34947: PUSH
34948: LD_VAR 0 2
34952: ARRAY
34953: ST_TO_ADDR
34954: GO 34970
// tmp := target [ 1 ] ;
34956: LD_ADDR_VAR 0 5
34960: PUSH
34961: LD_VAR 0 6
34965: PUSH
34966: LD_INT 1
34968: ARRAY
34969: ST_TO_ADDR
// k := 0 ;
34970: LD_ADDR_VAR 0 4
34974: PUSH
34975: LD_INT 0
34977: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34978: LD_ADDR_VAR 0 3
34982: PUSH
34983: LD_EXP 109
34987: PUSH
34988: LD_VAR 0 2
34992: ARRAY
34993: PUSH
34994: FOR_IN
34995: IFFALSE 35155
// begin k := k + 1 ;
34997: LD_ADDR_VAR 0 4
35001: PUSH
35002: LD_VAR 0 4
35006: PUSH
35007: LD_INT 1
35009: PLUS
35010: ST_TO_ADDR
// if k > tmp then
35011: LD_VAR 0 4
35015: PUSH
35016: LD_VAR 0 5
35020: GREATER
35021: IFFALSE 35025
// break ;
35023: GO 35155
// if not GetClass ( j ) in [ 2 , 16 ] then
35025: LD_VAR 0 3
35029: PPUSH
35030: CALL_OW 257
35034: PUSH
35035: LD_INT 2
35037: PUSH
35038: LD_INT 16
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: IN
35045: NOT
35046: IFFALSE 35099
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35048: LD_ADDR_EXP 109
35052: PUSH
35053: LD_EXP 109
35057: PPUSH
35058: LD_VAR 0 2
35062: PPUSH
35063: LD_EXP 109
35067: PUSH
35068: LD_VAR 0 2
35072: ARRAY
35073: PUSH
35074: LD_VAR 0 3
35078: DIFF
35079: PPUSH
35080: CALL_OW 1
35084: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35085: LD_VAR 0 3
35089: PPUSH
35090: LD_INT 0
35092: PPUSH
35093: CALL_OW 109
// continue ;
35097: GO 34994
// end ; if IsInUnit ( j ) then
35099: LD_VAR 0 3
35103: PPUSH
35104: CALL_OW 310
35108: IFFALSE 35119
// ComExitBuilding ( j ) ;
35110: LD_VAR 0 3
35114: PPUSH
35115: CALL_OW 122
// wait ( 3 ) ;
35119: LD_INT 3
35121: PPUSH
35122: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35126: LD_VAR 0 3
35130: PPUSH
35131: LD_VAR 0 6
35135: PUSH
35136: LD_INT 2
35138: ARRAY
35139: PPUSH
35140: LD_VAR 0 6
35144: PUSH
35145: LD_INT 3
35147: ARRAY
35148: PPUSH
35149: CALL_OW 117
// end ;
35153: GO 34994
35155: POP
35156: POP
// end ; end else
35157: GO 35738
// begin for j in cargo do
35159: LD_ADDR_VAR 0 3
35163: PUSH
35164: LD_VAR 0 7
35168: PUSH
35169: FOR_IN
35170: IFFALSE 35736
// begin if GetTag ( j ) <> 0 then
35172: LD_VAR 0 3
35176: PPUSH
35177: CALL_OW 110
35181: PUSH
35182: LD_INT 0
35184: NONEQUAL
35185: IFFALSE 35189
// continue ;
35187: GO 35169
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35189: LD_VAR 0 3
35193: PPUSH
35194: CALL_OW 256
35198: PUSH
35199: LD_INT 1000
35201: LESS
35202: PUSH
35203: LD_VAR 0 3
35207: PPUSH
35208: LD_EXP 116
35212: PUSH
35213: LD_VAR 0 2
35217: ARRAY
35218: PPUSH
35219: CALL_OW 308
35223: NOT
35224: AND
35225: IFFALSE 35247
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35227: LD_VAR 0 3
35231: PPUSH
35232: LD_EXP 116
35236: PUSH
35237: LD_VAR 0 2
35241: ARRAY
35242: PPUSH
35243: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35247: LD_VAR 0 3
35251: PPUSH
35252: CALL_OW 256
35256: PUSH
35257: LD_INT 1000
35259: LESS
35260: PUSH
35261: LD_VAR 0 3
35265: PPUSH
35266: LD_EXP 116
35270: PUSH
35271: LD_VAR 0 2
35275: ARRAY
35276: PPUSH
35277: CALL_OW 308
35281: AND
35282: IFFALSE 35286
// continue ;
35284: GO 35169
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35286: LD_VAR 0 3
35290: PPUSH
35291: CALL_OW 262
35295: PUSH
35296: LD_INT 2
35298: EQUAL
35299: PUSH
35300: LD_VAR 0 3
35304: PPUSH
35305: CALL_OW 261
35309: PUSH
35310: LD_INT 15
35312: LESS
35313: AND
35314: IFFALSE 35318
// continue ;
35316: GO 35169
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35318: LD_VAR 0 3
35322: PPUSH
35323: CALL_OW 262
35327: PUSH
35328: LD_INT 1
35330: EQUAL
35331: PUSH
35332: LD_VAR 0 3
35336: PPUSH
35337: CALL_OW 261
35341: PUSH
35342: LD_INT 10
35344: LESS
35345: AND
35346: IFFALSE 35675
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35348: LD_ADDR_VAR 0 8
35352: PUSH
35353: LD_EXP 92
35357: PUSH
35358: LD_VAR 0 2
35362: ARRAY
35363: PPUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 30
35369: PUSH
35370: LD_INT 0
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 30
35379: PUSH
35380: LD_INT 1
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: LIST
35391: PPUSH
35392: CALL_OW 72
35396: ST_TO_ADDR
// if not depot then
35397: LD_VAR 0 8
35401: NOT
35402: IFFALSE 35406
// continue ;
35404: GO 35169
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35406: LD_VAR 0 3
35410: PPUSH
35411: LD_VAR 0 8
35415: PPUSH
35416: LD_VAR 0 3
35420: PPUSH
35421: CALL_OW 74
35425: PPUSH
35426: CALL_OW 296
35430: PUSH
35431: LD_INT 6
35433: LESS
35434: IFFALSE 35450
// SetFuel ( j , 100 ) else
35436: LD_VAR 0 3
35440: PPUSH
35441: LD_INT 100
35443: PPUSH
35444: CALL_OW 240
35448: GO 35675
// if GetFuel ( j ) = 0 then
35450: LD_VAR 0 3
35454: PPUSH
35455: CALL_OW 261
35459: PUSH
35460: LD_INT 0
35462: EQUAL
35463: IFFALSE 35675
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35465: LD_ADDR_EXP 111
35469: PUSH
35470: LD_EXP 111
35474: PPUSH
35475: LD_VAR 0 2
35479: PPUSH
35480: LD_EXP 111
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PUSH
35491: LD_VAR 0 3
35495: DIFF
35496: PPUSH
35497: CALL_OW 1
35501: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35502: LD_VAR 0 3
35506: PPUSH
35507: CALL_OW 263
35511: PUSH
35512: LD_INT 1
35514: EQUAL
35515: IFFALSE 35531
// ComExitVehicle ( IsInUnit ( j ) ) ;
35517: LD_VAR 0 3
35521: PPUSH
35522: CALL_OW 310
35526: PPUSH
35527: CALL_OW 121
// if GetControl ( j ) = control_remote then
35531: LD_VAR 0 3
35535: PPUSH
35536: CALL_OW 263
35540: PUSH
35541: LD_INT 2
35543: EQUAL
35544: IFFALSE 35555
// ComUnlink ( j ) ;
35546: LD_VAR 0 3
35550: PPUSH
35551: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35555: LD_ADDR_VAR 0 9
35559: PUSH
35560: LD_VAR 0 2
35564: PPUSH
35565: LD_INT 3
35567: PPUSH
35568: CALL 45145 0 2
35572: ST_TO_ADDR
// if fac then
35573: LD_VAR 0 9
35577: IFFALSE 35673
// begin for k in fac do
35579: LD_ADDR_VAR 0 4
35583: PUSH
35584: LD_VAR 0 9
35588: PUSH
35589: FOR_IN
35590: IFFALSE 35671
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35592: LD_ADDR_VAR 0 10
35596: PUSH
35597: LD_VAR 0 9
35601: PPUSH
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 265
35611: PPUSH
35612: LD_VAR 0 3
35616: PPUSH
35617: CALL_OW 262
35621: PPUSH
35622: LD_VAR 0 3
35626: PPUSH
35627: CALL_OW 263
35631: PPUSH
35632: LD_VAR 0 3
35636: PPUSH
35637: CALL_OW 264
35641: PPUSH
35642: CALL 53531 0 5
35646: ST_TO_ADDR
// if components then
35647: LD_VAR 0 10
35651: IFFALSE 35669
// begin MC_InsertProduceList ( i , components ) ;
35653: LD_VAR 0 2
35657: PPUSH
35658: LD_VAR 0 10
35662: PPUSH
35663: CALL 44690 0 2
// break ;
35667: GO 35671
// end ; end ;
35669: GO 35589
35671: POP
35672: POP
// end ; continue ;
35673: GO 35169
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35675: LD_VAR 0 3
35679: PPUSH
35680: LD_INT 1
35682: PPUSH
35683: CALL_OW 289
35687: PUSH
35688: LD_INT 100
35690: LESS
35691: PUSH
35692: LD_VAR 0 3
35696: PPUSH
35697: CALL_OW 314
35701: NOT
35702: AND
35703: IFFALSE 35732
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35705: LD_VAR 0 3
35709: PPUSH
35710: LD_VAR 0 6
35714: PUSH
35715: LD_INT 2
35717: ARRAY
35718: PPUSH
35719: LD_VAR 0 6
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PPUSH
35728: CALL_OW 117
// break ;
35732: GO 35736
// end ;
35734: GO 35169
35736: POP
35737: POP
// end ; end ;
35738: GO 34007
35740: POP
35741: POP
// end ;
35742: LD_VAR 0 1
35746: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35747: LD_INT 0
35749: PPUSH
35750: PPUSH
35751: PPUSH
35752: PPUSH
// if not mc_bases then
35753: LD_EXP 92
35757: NOT
35758: IFFALSE 35762
// exit ;
35760: GO 35923
// for i = 1 to mc_bases do
35762: LD_ADDR_VAR 0 2
35766: PUSH
35767: DOUBLE
35768: LD_INT 1
35770: DEC
35771: ST_TO_ADDR
35772: LD_EXP 92
35776: PUSH
35777: FOR_TO
35778: IFFALSE 35921
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35780: LD_ADDR_VAR 0 4
35784: PUSH
35785: LD_EXP 111
35789: PUSH
35790: LD_VAR 0 2
35794: ARRAY
35795: PUSH
35796: LD_EXP 114
35800: PUSH
35801: LD_VAR 0 2
35805: ARRAY
35806: UNION
35807: PPUSH
35808: LD_INT 33
35810: PUSH
35811: LD_INT 2
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PPUSH
35818: CALL_OW 72
35822: ST_TO_ADDR
// if tmp then
35823: LD_VAR 0 4
35827: IFFALSE 35919
// for j in tmp do
35829: LD_ADDR_VAR 0 3
35833: PUSH
35834: LD_VAR 0 4
35838: PUSH
35839: FOR_IN
35840: IFFALSE 35917
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35842: LD_VAR 0 3
35846: PPUSH
35847: CALL_OW 312
35851: NOT
35852: PUSH
35853: LD_VAR 0 3
35857: PPUSH
35858: CALL_OW 256
35862: PUSH
35863: LD_INT 250
35865: GREATEREQUAL
35866: AND
35867: IFFALSE 35880
// Connect ( j ) else
35869: LD_VAR 0 3
35873: PPUSH
35874: CALL 58964 0 1
35878: GO 35915
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35880: LD_VAR 0 3
35884: PPUSH
35885: CALL_OW 256
35889: PUSH
35890: LD_INT 250
35892: LESS
35893: PUSH
35894: LD_VAR 0 3
35898: PPUSH
35899: CALL_OW 312
35903: AND
35904: IFFALSE 35915
// ComUnlink ( j ) ;
35906: LD_VAR 0 3
35910: PPUSH
35911: CALL_OW 136
35915: GO 35839
35917: POP
35918: POP
// end ;
35919: GO 35777
35921: POP
35922: POP
// end ;
35923: LD_VAR 0 1
35927: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35928: LD_INT 0
35930: PPUSH
35931: PPUSH
35932: PPUSH
35933: PPUSH
35934: PPUSH
// if not mc_bases then
35935: LD_EXP 92
35939: NOT
35940: IFFALSE 35944
// exit ;
35942: GO 36389
// for i = 1 to mc_bases do
35944: LD_ADDR_VAR 0 2
35948: PUSH
35949: DOUBLE
35950: LD_INT 1
35952: DEC
35953: ST_TO_ADDR
35954: LD_EXP 92
35958: PUSH
35959: FOR_TO
35960: IFFALSE 36387
// begin if not mc_produce [ i ] then
35962: LD_EXP 113
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: NOT
35973: IFFALSE 35977
// continue ;
35975: GO 35959
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35977: LD_ADDR_VAR 0 5
35981: PUSH
35982: LD_EXP 92
35986: PUSH
35987: LD_VAR 0 2
35991: ARRAY
35992: PPUSH
35993: LD_INT 30
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PPUSH
36003: CALL_OW 72
36007: ST_TO_ADDR
// if not fac then
36008: LD_VAR 0 5
36012: NOT
36013: IFFALSE 36017
// continue ;
36015: GO 35959
// for j in fac do
36017: LD_ADDR_VAR 0 3
36021: PUSH
36022: LD_VAR 0 5
36026: PUSH
36027: FOR_IN
36028: IFFALSE 36383
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36030: LD_VAR 0 3
36034: PPUSH
36035: CALL_OW 461
36039: PUSH
36040: LD_INT 2
36042: NONEQUAL
36043: PUSH
36044: LD_VAR 0 3
36048: PPUSH
36049: LD_INT 15
36051: PPUSH
36052: CALL 58592 0 2
36056: PUSH
36057: LD_INT 4
36059: ARRAY
36060: OR
36061: IFFALSE 36065
// continue ;
36063: GO 36027
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36065: LD_VAR 0 3
36069: PPUSH
36070: LD_EXP 113
36074: PUSH
36075: LD_VAR 0 2
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: PUSH
36085: LD_INT 1
36087: ARRAY
36088: PPUSH
36089: LD_EXP 113
36093: PUSH
36094: LD_VAR 0 2
36098: ARRAY
36099: PUSH
36100: LD_INT 1
36102: ARRAY
36103: PUSH
36104: LD_INT 2
36106: ARRAY
36107: PPUSH
36108: LD_EXP 113
36112: PUSH
36113: LD_VAR 0 2
36117: ARRAY
36118: PUSH
36119: LD_INT 1
36121: ARRAY
36122: PUSH
36123: LD_INT 3
36125: ARRAY
36126: PPUSH
36127: LD_EXP 113
36131: PUSH
36132: LD_VAR 0 2
36136: ARRAY
36137: PUSH
36138: LD_INT 1
36140: ARRAY
36141: PUSH
36142: LD_INT 4
36144: ARRAY
36145: PPUSH
36146: CALL_OW 448
36150: PUSH
36151: LD_VAR 0 3
36155: PPUSH
36156: LD_EXP 113
36160: PUSH
36161: LD_VAR 0 2
36165: ARRAY
36166: PUSH
36167: LD_INT 1
36169: ARRAY
36170: PUSH
36171: LD_INT 1
36173: ARRAY
36174: PUSH
36175: LD_EXP 113
36179: PUSH
36180: LD_VAR 0 2
36184: ARRAY
36185: PUSH
36186: LD_INT 1
36188: ARRAY
36189: PUSH
36190: LD_INT 2
36192: ARRAY
36193: PUSH
36194: LD_EXP 113
36198: PUSH
36199: LD_VAR 0 2
36203: ARRAY
36204: PUSH
36205: LD_INT 1
36207: ARRAY
36208: PUSH
36209: LD_INT 3
36211: ARRAY
36212: PUSH
36213: LD_EXP 113
36217: PUSH
36218: LD_VAR 0 2
36222: ARRAY
36223: PUSH
36224: LD_INT 1
36226: ARRAY
36227: PUSH
36228: LD_INT 4
36230: ARRAY
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: PPUSH
36238: CALL 62390 0 2
36242: AND
36243: IFFALSE 36381
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36245: LD_VAR 0 3
36249: PPUSH
36250: LD_EXP 113
36254: PUSH
36255: LD_VAR 0 2
36259: ARRAY
36260: PUSH
36261: LD_INT 1
36263: ARRAY
36264: PUSH
36265: LD_INT 1
36267: ARRAY
36268: PPUSH
36269: LD_EXP 113
36273: PUSH
36274: LD_VAR 0 2
36278: ARRAY
36279: PUSH
36280: LD_INT 1
36282: ARRAY
36283: PUSH
36284: LD_INT 2
36286: ARRAY
36287: PPUSH
36288: LD_EXP 113
36292: PUSH
36293: LD_VAR 0 2
36297: ARRAY
36298: PUSH
36299: LD_INT 1
36301: ARRAY
36302: PUSH
36303: LD_INT 3
36305: ARRAY
36306: PPUSH
36307: LD_EXP 113
36311: PUSH
36312: LD_VAR 0 2
36316: ARRAY
36317: PUSH
36318: LD_INT 1
36320: ARRAY
36321: PUSH
36322: LD_INT 4
36324: ARRAY
36325: PPUSH
36326: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36330: LD_ADDR_VAR 0 4
36334: PUSH
36335: LD_EXP 113
36339: PUSH
36340: LD_VAR 0 2
36344: ARRAY
36345: PPUSH
36346: LD_INT 1
36348: PPUSH
36349: CALL_OW 3
36353: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36354: LD_ADDR_EXP 113
36358: PUSH
36359: LD_EXP 113
36363: PPUSH
36364: LD_VAR 0 2
36368: PPUSH
36369: LD_VAR 0 4
36373: PPUSH
36374: CALL_OW 1
36378: ST_TO_ADDR
// break ;
36379: GO 36383
// end ; end ;
36381: GO 36027
36383: POP
36384: POP
// end ;
36385: GO 35959
36387: POP
36388: POP
// end ;
36389: LD_VAR 0 1
36393: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36394: LD_INT 0
36396: PPUSH
36397: PPUSH
36398: PPUSH
// if not mc_bases then
36399: LD_EXP 92
36403: NOT
36404: IFFALSE 36408
// exit ;
36406: GO 36497
// for i = 1 to mc_bases do
36408: LD_ADDR_VAR 0 2
36412: PUSH
36413: DOUBLE
36414: LD_INT 1
36416: DEC
36417: ST_TO_ADDR
36418: LD_EXP 92
36422: PUSH
36423: FOR_TO
36424: IFFALSE 36495
// begin if mc_attack [ i ] then
36426: LD_EXP 112
36430: PUSH
36431: LD_VAR 0 2
36435: ARRAY
36436: IFFALSE 36493
// begin tmp := mc_attack [ i ] [ 1 ] ;
36438: LD_ADDR_VAR 0 3
36442: PUSH
36443: LD_EXP 112
36447: PUSH
36448: LD_VAR 0 2
36452: ARRAY
36453: PUSH
36454: LD_INT 1
36456: ARRAY
36457: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36458: LD_ADDR_EXP 112
36462: PUSH
36463: LD_EXP 112
36467: PPUSH
36468: LD_VAR 0 2
36472: PPUSH
36473: EMPTY
36474: PPUSH
36475: CALL_OW 1
36479: ST_TO_ADDR
// Attack ( tmp ) ;
36480: LD_VAR 0 3
36484: PPUSH
36485: CALL 105896 0 1
// exit ;
36489: POP
36490: POP
36491: GO 36497
// end ; end ;
36493: GO 36423
36495: POP
36496: POP
// end ;
36497: LD_VAR 0 1
36501: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36502: LD_INT 0
36504: PPUSH
36505: PPUSH
36506: PPUSH
36507: PPUSH
36508: PPUSH
36509: PPUSH
36510: PPUSH
// if not mc_bases then
36511: LD_EXP 92
36515: NOT
36516: IFFALSE 36520
// exit ;
36518: GO 37219
// for i = 1 to mc_bases do
36520: LD_ADDR_VAR 0 2
36524: PUSH
36525: DOUBLE
36526: LD_INT 1
36528: DEC
36529: ST_TO_ADDR
36530: LD_EXP 92
36534: PUSH
36535: FOR_TO
36536: IFFALSE 37217
// begin if not mc_bases [ i ] then
36538: LD_EXP 92
36542: PUSH
36543: LD_VAR 0 2
36547: ARRAY
36548: NOT
36549: IFFALSE 36553
// continue ;
36551: GO 36535
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36553: LD_ADDR_VAR 0 7
36557: PUSH
36558: LD_EXP 92
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PUSH
36569: LD_INT 1
36571: ARRAY
36572: PPUSH
36573: CALL 52835 0 1
36577: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36578: LD_ADDR_EXP 115
36582: PUSH
36583: LD_EXP 115
36587: PPUSH
36588: LD_VAR 0 2
36592: PPUSH
36593: LD_EXP 92
36597: PUSH
36598: LD_VAR 0 2
36602: ARRAY
36603: PUSH
36604: LD_INT 1
36606: ARRAY
36607: PPUSH
36608: CALL_OW 255
36612: PPUSH
36613: LD_EXP 117
36617: PUSH
36618: LD_VAR 0 2
36622: ARRAY
36623: PPUSH
36624: CALL 52800 0 2
36628: PPUSH
36629: CALL_OW 1
36633: ST_TO_ADDR
// if not mc_scan [ i ] then
36634: LD_EXP 115
36638: PUSH
36639: LD_VAR 0 2
36643: ARRAY
36644: NOT
36645: IFFALSE 36823
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36647: LD_ADDR_VAR 0 4
36651: PUSH
36652: LD_EXP 92
36656: PUSH
36657: LD_VAR 0 2
36661: ARRAY
36662: PPUSH
36663: LD_INT 2
36665: PUSH
36666: LD_INT 25
36668: PUSH
36669: LD_INT 5
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 25
36678: PUSH
36679: LD_INT 8
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 25
36688: PUSH
36689: LD_INT 9
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: PPUSH
36702: CALL_OW 72
36706: ST_TO_ADDR
// if not tmp then
36707: LD_VAR 0 4
36711: NOT
36712: IFFALSE 36716
// continue ;
36714: GO 36535
// for j in tmp do
36716: LD_ADDR_VAR 0 3
36720: PUSH
36721: LD_VAR 0 4
36725: PUSH
36726: FOR_IN
36727: IFFALSE 36798
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36729: LD_VAR 0 3
36733: PPUSH
36734: CALL_OW 310
36738: PPUSH
36739: CALL_OW 266
36743: PUSH
36744: LD_INT 5
36746: EQUAL
36747: PUSH
36748: LD_VAR 0 3
36752: PPUSH
36753: CALL_OW 257
36757: PUSH
36758: LD_INT 1
36760: EQUAL
36761: AND
36762: PUSH
36763: LD_VAR 0 3
36767: PPUSH
36768: CALL_OW 459
36772: NOT
36773: AND
36774: PUSH
36775: LD_VAR 0 7
36779: AND
36780: IFFALSE 36796
// ComChangeProfession ( j , class ) ;
36782: LD_VAR 0 3
36786: PPUSH
36787: LD_VAR 0 7
36791: PPUSH
36792: CALL_OW 123
36796: GO 36726
36798: POP
36799: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36800: LD_ADDR_EXP 135
36804: PUSH
36805: LD_EXP 135
36809: PPUSH
36810: LD_VAR 0 2
36814: PPUSH
36815: LD_INT 0
36817: PPUSH
36818: CALL_OW 1
36822: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36823: LD_EXP 115
36827: PUSH
36828: LD_VAR 0 2
36832: ARRAY
36833: PUSH
36834: LD_EXP 135
36838: PUSH
36839: LD_VAR 0 2
36843: ARRAY
36844: NOT
36845: AND
36846: PUSH
36847: LD_EXP 114
36851: PUSH
36852: LD_VAR 0 2
36856: ARRAY
36857: NOT
36858: AND
36859: PUSH
36860: LD_EXP 92
36864: PUSH
36865: LD_VAR 0 2
36869: ARRAY
36870: PPUSH
36871: LD_INT 30
36873: PUSH
36874: LD_INT 32
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PPUSH
36881: CALL_OW 72
36885: NOT
36886: AND
36887: PUSH
36888: LD_EXP 92
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: PPUSH
36899: LD_INT 2
36901: PUSH
36902: LD_INT 30
36904: PUSH
36905: LD_INT 4
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 30
36914: PUSH
36915: LD_INT 5
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: LIST
36926: PPUSH
36927: CALL_OW 72
36931: NOT
36932: AND
36933: IFFALSE 37088
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36935: LD_ADDR_VAR 0 4
36939: PUSH
36940: LD_EXP 92
36944: PUSH
36945: LD_VAR 0 2
36949: ARRAY
36950: PPUSH
36951: LD_INT 2
36953: PUSH
36954: LD_INT 25
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 25
36966: PUSH
36967: LD_INT 5
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 25
36976: PUSH
36977: LD_INT 8
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 25
36986: PUSH
36987: LD_INT 9
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: PPUSH
37001: CALL_OW 72
37005: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37006: LD_ADDR_VAR 0 4
37010: PUSH
37011: LD_VAR 0 4
37015: PUSH
37016: LD_VAR 0 4
37020: PPUSH
37021: LD_INT 18
37023: PPUSH
37024: CALL 84893 0 2
37028: DIFF
37029: ST_TO_ADDR
// if tmp then
37030: LD_VAR 0 4
37034: IFFALSE 37088
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37036: LD_ADDR_EXP 135
37040: PUSH
37041: LD_EXP 135
37045: PPUSH
37046: LD_VAR 0 2
37050: PPUSH
37051: LD_INT 1
37053: PPUSH
37054: CALL_OW 1
37058: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
37059: LD_VAR 0 2
37063: PPUSH
37064: LD_VAR 0 4
37068: PPUSH
37069: LD_EXP 117
37073: PUSH
37074: LD_VAR 0 2
37078: ARRAY
37079: PPUSH
37080: CALL 110605 0 3
// exit ;
37084: POP
37085: POP
37086: GO 37219
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37088: LD_EXP 115
37092: PUSH
37093: LD_VAR 0 2
37097: ARRAY
37098: PUSH
37099: LD_EXP 135
37103: PUSH
37104: LD_VAR 0 2
37108: ARRAY
37109: NOT
37110: AND
37111: PUSH
37112: LD_EXP 114
37116: PUSH
37117: LD_VAR 0 2
37121: ARRAY
37122: AND
37123: IFFALSE 37215
// begin tmp := mc_defender [ i ] ;
37125: LD_ADDR_VAR 0 4
37129: PUSH
37130: LD_EXP 114
37134: PUSH
37135: LD_VAR 0 2
37139: ARRAY
37140: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37141: LD_ADDR_EXP 114
37145: PUSH
37146: LD_EXP 114
37150: PPUSH
37151: LD_VAR 0 2
37155: PPUSH
37156: EMPTY
37157: PPUSH
37158: CALL_OW 1
37162: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37163: LD_ADDR_EXP 135
37167: PUSH
37168: LD_EXP 135
37172: PPUSH
37173: LD_VAR 0 2
37177: PPUSH
37178: LD_INT 1
37180: PPUSH
37181: CALL_OW 1
37185: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
37186: LD_VAR 0 2
37190: PPUSH
37191: LD_VAR 0 4
37195: PPUSH
37196: LD_EXP 115
37200: PUSH
37201: LD_VAR 0 2
37205: ARRAY
37206: PPUSH
37207: CALL 111166 0 3
// exit ;
37211: POP
37212: POP
37213: GO 37219
// end ; end ;
37215: GO 36535
37217: POP
37218: POP
// end ;
37219: LD_VAR 0 1
37223: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37224: LD_INT 0
37226: PPUSH
37227: PPUSH
37228: PPUSH
37229: PPUSH
37230: PPUSH
37231: PPUSH
37232: PPUSH
37233: PPUSH
37234: PPUSH
37235: PPUSH
37236: PPUSH
// if not mc_bases then
37237: LD_EXP 92
37241: NOT
37242: IFFALSE 37246
// exit ;
37244: GO 38333
// for i = 1 to mc_bases do
37246: LD_ADDR_VAR 0 2
37250: PUSH
37251: DOUBLE
37252: LD_INT 1
37254: DEC
37255: ST_TO_ADDR
37256: LD_EXP 92
37260: PUSH
37261: FOR_TO
37262: IFFALSE 38331
// begin tmp := mc_lab [ i ] ;
37264: LD_ADDR_VAR 0 6
37268: PUSH
37269: LD_EXP 125
37273: PUSH
37274: LD_VAR 0 2
37278: ARRAY
37279: ST_TO_ADDR
// if not tmp then
37280: LD_VAR 0 6
37284: NOT
37285: IFFALSE 37289
// continue ;
37287: GO 37261
// idle_lab := 0 ;
37289: LD_ADDR_VAR 0 11
37293: PUSH
37294: LD_INT 0
37296: ST_TO_ADDR
// for j in tmp do
37297: LD_ADDR_VAR 0 3
37301: PUSH
37302: LD_VAR 0 6
37306: PUSH
37307: FOR_IN
37308: IFFALSE 38327
// begin researching := false ;
37310: LD_ADDR_VAR 0 10
37314: PUSH
37315: LD_INT 0
37317: ST_TO_ADDR
// side := GetSide ( j ) ;
37318: LD_ADDR_VAR 0 4
37322: PUSH
37323: LD_VAR 0 3
37327: PPUSH
37328: CALL_OW 255
37332: ST_TO_ADDR
// if not mc_tech [ side ] then
37333: LD_EXP 119
37337: PUSH
37338: LD_VAR 0 4
37342: ARRAY
37343: NOT
37344: IFFALSE 37348
// continue ;
37346: GO 37307
// if BuildingStatus ( j ) = bs_idle then
37348: LD_VAR 0 3
37352: PPUSH
37353: CALL_OW 461
37357: PUSH
37358: LD_INT 2
37360: EQUAL
37361: IFFALSE 37549
// begin if idle_lab and UnitsInside ( j ) < 6 then
37363: LD_VAR 0 11
37367: PUSH
37368: LD_VAR 0 3
37372: PPUSH
37373: CALL_OW 313
37377: PUSH
37378: LD_INT 6
37380: LESS
37381: AND
37382: IFFALSE 37453
// begin tmp2 := UnitsInside ( idle_lab ) ;
37384: LD_ADDR_VAR 0 9
37388: PUSH
37389: LD_VAR 0 11
37393: PPUSH
37394: CALL_OW 313
37398: ST_TO_ADDR
// if tmp2 then
37399: LD_VAR 0 9
37403: IFFALSE 37445
// for x in tmp2 do
37405: LD_ADDR_VAR 0 7
37409: PUSH
37410: LD_VAR 0 9
37414: PUSH
37415: FOR_IN
37416: IFFALSE 37443
// begin ComExitBuilding ( x ) ;
37418: LD_VAR 0 7
37422: PPUSH
37423: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37427: LD_VAR 0 7
37431: PPUSH
37432: LD_VAR 0 3
37436: PPUSH
37437: CALL_OW 180
// end ;
37441: GO 37415
37443: POP
37444: POP
// idle_lab := 0 ;
37445: LD_ADDR_VAR 0 11
37449: PUSH
37450: LD_INT 0
37452: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37453: LD_ADDR_VAR 0 5
37457: PUSH
37458: LD_EXP 119
37462: PUSH
37463: LD_VAR 0 4
37467: ARRAY
37468: PUSH
37469: FOR_IN
37470: IFFALSE 37530
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37472: LD_VAR 0 3
37476: PPUSH
37477: LD_VAR 0 5
37481: PPUSH
37482: CALL_OW 430
37486: PUSH
37487: LD_VAR 0 4
37491: PPUSH
37492: LD_VAR 0 5
37496: PPUSH
37497: CALL 51905 0 2
37501: AND
37502: IFFALSE 37528
// begin researching := true ;
37504: LD_ADDR_VAR 0 10
37508: PUSH
37509: LD_INT 1
37511: ST_TO_ADDR
// ComResearch ( j , t ) ;
37512: LD_VAR 0 3
37516: PPUSH
37517: LD_VAR 0 5
37521: PPUSH
37522: CALL_OW 124
// break ;
37526: GO 37530
// end ;
37528: GO 37469
37530: POP
37531: POP
// if not researching then
37532: LD_VAR 0 10
37536: NOT
37537: IFFALSE 37549
// idle_lab := j ;
37539: LD_ADDR_VAR 0 11
37543: PUSH
37544: LD_VAR 0 3
37548: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37549: LD_VAR 0 3
37553: PPUSH
37554: CALL_OW 461
37558: PUSH
37559: LD_INT 10
37561: EQUAL
37562: IFFALSE 38150
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37564: LD_EXP 121
37568: PUSH
37569: LD_VAR 0 2
37573: ARRAY
37574: NOT
37575: PUSH
37576: LD_EXP 122
37580: PUSH
37581: LD_VAR 0 2
37585: ARRAY
37586: NOT
37587: AND
37588: PUSH
37589: LD_EXP 119
37593: PUSH
37594: LD_VAR 0 4
37598: ARRAY
37599: PUSH
37600: LD_INT 1
37602: GREATER
37603: AND
37604: IFFALSE 37735
// begin ComCancel ( j ) ;
37606: LD_VAR 0 3
37610: PPUSH
37611: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37615: LD_ADDR_EXP 119
37619: PUSH
37620: LD_EXP 119
37624: PPUSH
37625: LD_VAR 0 4
37629: PPUSH
37630: LD_EXP 119
37634: PUSH
37635: LD_VAR 0 4
37639: ARRAY
37640: PPUSH
37641: LD_EXP 119
37645: PUSH
37646: LD_VAR 0 4
37650: ARRAY
37651: PUSH
37652: LD_INT 1
37654: MINUS
37655: PPUSH
37656: LD_EXP 119
37660: PUSH
37661: LD_VAR 0 4
37665: ARRAY
37666: PPUSH
37667: LD_INT 0
37669: PPUSH
37670: CALL 55417 0 4
37674: PPUSH
37675: CALL_OW 1
37679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37680: LD_ADDR_EXP 119
37684: PUSH
37685: LD_EXP 119
37689: PPUSH
37690: LD_VAR 0 4
37694: PPUSH
37695: LD_EXP 119
37699: PUSH
37700: LD_VAR 0 4
37704: ARRAY
37705: PPUSH
37706: LD_EXP 119
37710: PUSH
37711: LD_VAR 0 4
37715: ARRAY
37716: PPUSH
37717: LD_INT 1
37719: PPUSH
37720: LD_INT 0
37722: PPUSH
37723: CALL 55417 0 4
37727: PPUSH
37728: CALL_OW 1
37732: ST_TO_ADDR
// continue ;
37733: GO 37307
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37735: LD_EXP 121
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PUSH
37746: LD_EXP 122
37750: PUSH
37751: LD_VAR 0 2
37755: ARRAY
37756: NOT
37757: AND
37758: IFFALSE 37885
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37760: LD_ADDR_EXP 122
37764: PUSH
37765: LD_EXP 122
37769: PPUSH
37770: LD_VAR 0 2
37774: PUSH
37775: LD_EXP 122
37779: PUSH
37780: LD_VAR 0 2
37784: ARRAY
37785: PUSH
37786: LD_INT 1
37788: PLUS
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PPUSH
37794: LD_EXP 121
37798: PUSH
37799: LD_VAR 0 2
37803: ARRAY
37804: PUSH
37805: LD_INT 1
37807: ARRAY
37808: PPUSH
37809: CALL 55999 0 3
37813: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37814: LD_EXP 121
37818: PUSH
37819: LD_VAR 0 2
37823: ARRAY
37824: PUSH
37825: LD_INT 1
37827: ARRAY
37828: PPUSH
37829: LD_INT 112
37831: PPUSH
37832: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37836: LD_ADDR_VAR 0 9
37840: PUSH
37841: LD_EXP 121
37845: PUSH
37846: LD_VAR 0 2
37850: ARRAY
37851: PPUSH
37852: LD_INT 1
37854: PPUSH
37855: CALL_OW 3
37859: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37860: LD_ADDR_EXP 121
37864: PUSH
37865: LD_EXP 121
37869: PPUSH
37870: LD_VAR 0 2
37874: PPUSH
37875: LD_VAR 0 9
37879: PPUSH
37880: CALL_OW 1
37884: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37885: LD_EXP 121
37889: PUSH
37890: LD_VAR 0 2
37894: ARRAY
37895: PUSH
37896: LD_EXP 122
37900: PUSH
37901: LD_VAR 0 2
37905: ARRAY
37906: AND
37907: PUSH
37908: LD_EXP 122
37912: PUSH
37913: LD_VAR 0 2
37917: ARRAY
37918: PUSH
37919: LD_INT 1
37921: ARRAY
37922: PPUSH
37923: CALL_OW 310
37927: NOT
37928: AND
37929: PUSH
37930: LD_VAR 0 3
37934: PPUSH
37935: CALL_OW 313
37939: PUSH
37940: LD_INT 6
37942: EQUAL
37943: AND
37944: IFFALSE 38000
// begin tmp2 := UnitsInside ( j ) ;
37946: LD_ADDR_VAR 0 9
37950: PUSH
37951: LD_VAR 0 3
37955: PPUSH
37956: CALL_OW 313
37960: ST_TO_ADDR
// if tmp2 = 6 then
37961: LD_VAR 0 9
37965: PUSH
37966: LD_INT 6
37968: EQUAL
37969: IFFALSE 38000
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37971: LD_VAR 0 9
37975: PUSH
37976: LD_INT 1
37978: ARRAY
37979: PPUSH
37980: LD_INT 112
37982: PPUSH
37983: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37987: LD_VAR 0 9
37991: PUSH
37992: LD_INT 1
37994: ARRAY
37995: PPUSH
37996: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38000: LD_EXP 122
38004: PUSH
38005: LD_VAR 0 2
38009: ARRAY
38010: PUSH
38011: LD_EXP 122
38015: PUSH
38016: LD_VAR 0 2
38020: ARRAY
38021: PUSH
38022: LD_INT 1
38024: ARRAY
38025: PPUSH
38026: CALL_OW 314
38030: NOT
38031: AND
38032: PUSH
38033: LD_EXP 122
38037: PUSH
38038: LD_VAR 0 2
38042: ARRAY
38043: PUSH
38044: LD_INT 1
38046: ARRAY
38047: PPUSH
38048: CALL_OW 310
38052: NOT
38053: AND
38054: IFFALSE 38080
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38056: LD_EXP 122
38060: PUSH
38061: LD_VAR 0 2
38065: ARRAY
38066: PUSH
38067: LD_INT 1
38069: ARRAY
38070: PPUSH
38071: LD_VAR 0 3
38075: PPUSH
38076: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38080: LD_EXP 122
38084: PUSH
38085: LD_VAR 0 2
38089: ARRAY
38090: PUSH
38091: LD_INT 1
38093: ARRAY
38094: PPUSH
38095: CALL_OW 310
38099: PUSH
38100: LD_EXP 122
38104: PUSH
38105: LD_VAR 0 2
38109: ARRAY
38110: PUSH
38111: LD_INT 1
38113: ARRAY
38114: PPUSH
38115: CALL_OW 310
38119: PPUSH
38120: CALL_OW 461
38124: PUSH
38125: LD_INT 3
38127: NONEQUAL
38128: AND
38129: IFFALSE 38150
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38131: LD_EXP 122
38135: PUSH
38136: LD_VAR 0 2
38140: ARRAY
38141: PUSH
38142: LD_INT 1
38144: ARRAY
38145: PPUSH
38146: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38150: LD_VAR 0 3
38154: PPUSH
38155: CALL_OW 461
38159: PUSH
38160: LD_INT 6
38162: EQUAL
38163: PUSH
38164: LD_VAR 0 6
38168: PUSH
38169: LD_INT 1
38171: GREATER
38172: AND
38173: IFFALSE 38325
// begin sci := [ ] ;
38175: LD_ADDR_VAR 0 8
38179: PUSH
38180: EMPTY
38181: ST_TO_ADDR
// for x in ( tmp diff j ) do
38182: LD_ADDR_VAR 0 7
38186: PUSH
38187: LD_VAR 0 6
38191: PUSH
38192: LD_VAR 0 3
38196: DIFF
38197: PUSH
38198: FOR_IN
38199: IFFALSE 38251
// begin if sci = 6 then
38201: LD_VAR 0 8
38205: PUSH
38206: LD_INT 6
38208: EQUAL
38209: IFFALSE 38213
// break ;
38211: GO 38251
// if BuildingStatus ( x ) = bs_idle then
38213: LD_VAR 0 7
38217: PPUSH
38218: CALL_OW 461
38222: PUSH
38223: LD_INT 2
38225: EQUAL
38226: IFFALSE 38249
// sci := sci ^ UnitsInside ( x ) ;
38228: LD_ADDR_VAR 0 8
38232: PUSH
38233: LD_VAR 0 8
38237: PUSH
38238: LD_VAR 0 7
38242: PPUSH
38243: CALL_OW 313
38247: ADD
38248: ST_TO_ADDR
// end ;
38249: GO 38198
38251: POP
38252: POP
// if not sci then
38253: LD_VAR 0 8
38257: NOT
38258: IFFALSE 38262
// continue ;
38260: GO 37307
// for x in sci do
38262: LD_ADDR_VAR 0 7
38266: PUSH
38267: LD_VAR 0 8
38271: PUSH
38272: FOR_IN
38273: IFFALSE 38323
// if IsInUnit ( x ) and not HasTask ( x ) then
38275: LD_VAR 0 7
38279: PPUSH
38280: CALL_OW 310
38284: PUSH
38285: LD_VAR 0 7
38289: PPUSH
38290: CALL_OW 314
38294: NOT
38295: AND
38296: IFFALSE 38321
// begin ComExitBuilding ( x ) ;
38298: LD_VAR 0 7
38302: PPUSH
38303: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38307: LD_VAR 0 7
38311: PPUSH
38312: LD_VAR 0 3
38316: PPUSH
38317: CALL_OW 180
// end ;
38321: GO 38272
38323: POP
38324: POP
// end ; end ;
38325: GO 37307
38327: POP
38328: POP
// end ;
38329: GO 37261
38331: POP
38332: POP
// end ;
38333: LD_VAR 0 1
38337: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38338: LD_INT 0
38340: PPUSH
38341: PPUSH
// if not mc_bases then
38342: LD_EXP 92
38346: NOT
38347: IFFALSE 38351
// exit ;
38349: GO 38432
// for i = 1 to mc_bases do
38351: LD_ADDR_VAR 0 2
38355: PUSH
38356: DOUBLE
38357: LD_INT 1
38359: DEC
38360: ST_TO_ADDR
38361: LD_EXP 92
38365: PUSH
38366: FOR_TO
38367: IFFALSE 38430
// if mc_mines [ i ] and mc_miners [ i ] then
38369: LD_EXP 105
38373: PUSH
38374: LD_VAR 0 2
38378: ARRAY
38379: PUSH
38380: LD_EXP 106
38384: PUSH
38385: LD_VAR 0 2
38389: ARRAY
38390: AND
38391: IFFALSE 38428
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38393: LD_EXP 106
38397: PUSH
38398: LD_VAR 0 2
38402: ARRAY
38403: PUSH
38404: LD_INT 1
38406: ARRAY
38407: PPUSH
38408: CALL_OW 255
38412: PPUSH
38413: LD_EXP 105
38417: PUSH
38418: LD_VAR 0 2
38422: ARRAY
38423: PPUSH
38424: CALL 52988 0 2
38428: GO 38366
38430: POP
38431: POP
// end ;
38432: LD_VAR 0 1
38436: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38437: LD_INT 0
38439: PPUSH
38440: PPUSH
38441: PPUSH
38442: PPUSH
38443: PPUSH
38444: PPUSH
38445: PPUSH
38446: PPUSH
// if not mc_bases or not mc_parking then
38447: LD_EXP 92
38451: NOT
38452: PUSH
38453: LD_EXP 116
38457: NOT
38458: OR
38459: IFFALSE 38463
// exit ;
38461: GO 39162
// for i = 1 to mc_bases do
38463: LD_ADDR_VAR 0 2
38467: PUSH
38468: DOUBLE
38469: LD_INT 1
38471: DEC
38472: ST_TO_ADDR
38473: LD_EXP 92
38477: PUSH
38478: FOR_TO
38479: IFFALSE 39160
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38481: LD_EXP 92
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: NOT
38492: PUSH
38493: LD_EXP 116
38497: PUSH
38498: LD_VAR 0 2
38502: ARRAY
38503: NOT
38504: OR
38505: IFFALSE 38509
// continue ;
38507: GO 38478
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38509: LD_ADDR_VAR 0 5
38513: PUSH
38514: LD_EXP 92
38518: PUSH
38519: LD_VAR 0 2
38523: ARRAY
38524: PUSH
38525: LD_INT 1
38527: ARRAY
38528: PPUSH
38529: CALL_OW 255
38533: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38534: LD_ADDR_VAR 0 6
38538: PUSH
38539: LD_EXP 92
38543: PUSH
38544: LD_VAR 0 2
38548: ARRAY
38549: PPUSH
38550: LD_INT 30
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PPUSH
38560: CALL_OW 72
38564: ST_TO_ADDR
// if not fac then
38565: LD_VAR 0 6
38569: NOT
38570: IFFALSE 38621
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38572: LD_ADDR_VAR 0 6
38576: PUSH
38577: LD_EXP 92
38581: PUSH
38582: LD_VAR 0 2
38586: ARRAY
38587: PPUSH
38588: LD_INT 2
38590: PUSH
38591: LD_INT 30
38593: PUSH
38594: LD_INT 0
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 30
38603: PUSH
38604: LD_INT 1
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: LIST
38615: PPUSH
38616: CALL_OW 72
38620: ST_TO_ADDR
// if not fac then
38621: LD_VAR 0 6
38625: NOT
38626: IFFALSE 38630
// continue ;
38628: GO 38478
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38630: LD_ADDR_VAR 0 7
38634: PUSH
38635: LD_EXP 116
38639: PUSH
38640: LD_VAR 0 2
38644: ARRAY
38645: PPUSH
38646: LD_INT 22
38648: PUSH
38649: LD_VAR 0 5
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 21
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 3
38670: PUSH
38671: LD_INT 24
38673: PUSH
38674: LD_INT 1000
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: LIST
38689: PPUSH
38690: CALL_OW 70
38694: ST_TO_ADDR
// for j in fac do
38695: LD_ADDR_VAR 0 3
38699: PUSH
38700: LD_VAR 0 6
38704: PUSH
38705: FOR_IN
38706: IFFALSE 38787
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38708: LD_ADDR_VAR 0 7
38712: PUSH
38713: LD_VAR 0 7
38717: PUSH
38718: LD_INT 22
38720: PUSH
38721: LD_VAR 0 5
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 91
38732: PUSH
38733: LD_VAR 0 3
38737: PUSH
38738: LD_INT 15
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: LIST
38745: PUSH
38746: LD_INT 21
38748: PUSH
38749: LD_INT 2
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 3
38758: PUSH
38759: LD_INT 24
38761: PUSH
38762: LD_INT 1000
38764: PUSH
38765: EMPTY
38766: LIST
38767: LIST
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: PPUSH
38779: CALL_OW 69
38783: UNION
38784: ST_TO_ADDR
38785: GO 38705
38787: POP
38788: POP
// if not vehs then
38789: LD_VAR 0 7
38793: NOT
38794: IFFALSE 38820
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38796: LD_ADDR_EXP 104
38800: PUSH
38801: LD_EXP 104
38805: PPUSH
38806: LD_VAR 0 2
38810: PPUSH
38811: EMPTY
38812: PPUSH
38813: CALL_OW 1
38817: ST_TO_ADDR
// continue ;
38818: GO 38478
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38820: LD_ADDR_VAR 0 8
38824: PUSH
38825: LD_EXP 92
38829: PUSH
38830: LD_VAR 0 2
38834: ARRAY
38835: PPUSH
38836: LD_INT 30
38838: PUSH
38839: LD_INT 3
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PPUSH
38846: CALL_OW 72
38850: ST_TO_ADDR
// if tmp then
38851: LD_VAR 0 8
38855: IFFALSE 38958
// begin for j in tmp do
38857: LD_ADDR_VAR 0 3
38861: PUSH
38862: LD_VAR 0 8
38866: PUSH
38867: FOR_IN
38868: IFFALSE 38956
// for k in UnitsInside ( j ) do
38870: LD_ADDR_VAR 0 4
38874: PUSH
38875: LD_VAR 0 3
38879: PPUSH
38880: CALL_OW 313
38884: PUSH
38885: FOR_IN
38886: IFFALSE 38952
// if k then
38888: LD_VAR 0 4
38892: IFFALSE 38950
// if not k in mc_repair_vehicle [ i ] then
38894: LD_VAR 0 4
38898: PUSH
38899: LD_EXP 104
38903: PUSH
38904: LD_VAR 0 2
38908: ARRAY
38909: IN
38910: NOT
38911: IFFALSE 38950
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38913: LD_ADDR_EXP 104
38917: PUSH
38918: LD_EXP 104
38922: PPUSH
38923: LD_VAR 0 2
38927: PPUSH
38928: LD_EXP 104
38932: PUSH
38933: LD_VAR 0 2
38937: ARRAY
38938: PUSH
38939: LD_VAR 0 4
38943: UNION
38944: PPUSH
38945: CALL_OW 1
38949: ST_TO_ADDR
38950: GO 38885
38952: POP
38953: POP
38954: GO 38867
38956: POP
38957: POP
// end ; if not mc_repair_vehicle [ i ] then
38958: LD_EXP 104
38962: PUSH
38963: LD_VAR 0 2
38967: ARRAY
38968: NOT
38969: IFFALSE 38973
// continue ;
38971: GO 38478
// for j in mc_repair_vehicle [ i ] do
38973: LD_ADDR_VAR 0 3
38977: PUSH
38978: LD_EXP 104
38982: PUSH
38983: LD_VAR 0 2
38987: ARRAY
38988: PUSH
38989: FOR_IN
38990: IFFALSE 39156
// begin if GetClass ( j ) <> 3 then
38992: LD_VAR 0 3
38996: PPUSH
38997: CALL_OW 257
39001: PUSH
39002: LD_INT 3
39004: NONEQUAL
39005: IFFALSE 39046
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39007: LD_ADDR_EXP 104
39011: PUSH
39012: LD_EXP 104
39016: PPUSH
39017: LD_VAR 0 2
39021: PPUSH
39022: LD_EXP 104
39026: PUSH
39027: LD_VAR 0 2
39031: ARRAY
39032: PUSH
39033: LD_VAR 0 3
39037: DIFF
39038: PPUSH
39039: CALL_OW 1
39043: ST_TO_ADDR
// continue ;
39044: GO 38989
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39046: LD_VAR 0 3
39050: PPUSH
39051: CALL_OW 311
39055: NOT
39056: PUSH
39057: LD_VAR 0 3
39061: PUSH
39062: LD_EXP 95
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_INT 1
39075: ARRAY
39076: IN
39077: NOT
39078: AND
39079: PUSH
39080: LD_VAR 0 3
39084: PUSH
39085: LD_EXP 95
39089: PUSH
39090: LD_VAR 0 2
39094: ARRAY
39095: PUSH
39096: LD_INT 2
39098: ARRAY
39099: IN
39100: NOT
39101: AND
39102: IFFALSE 39154
// begin if IsInUnit ( j ) then
39104: LD_VAR 0 3
39108: PPUSH
39109: CALL_OW 310
39113: IFFALSE 39124
// ComExitBuilding ( j ) ;
39115: LD_VAR 0 3
39119: PPUSH
39120: CALL_OW 122
// if not HasTask ( j ) then
39124: LD_VAR 0 3
39128: PPUSH
39129: CALL_OW 314
39133: NOT
39134: IFFALSE 39154
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
39136: LD_VAR 0 3
39140: PPUSH
39141: LD_VAR 0 7
39145: PUSH
39146: LD_INT 1
39148: ARRAY
39149: PPUSH
39150: CALL_OW 189
// end ; end ;
39154: GO 38989
39156: POP
39157: POP
// end ;
39158: GO 38478
39160: POP
39161: POP
// end ;
39162: LD_VAR 0 1
39166: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39167: LD_INT 0
39169: PPUSH
39170: PPUSH
39171: PPUSH
39172: PPUSH
39173: PPUSH
39174: PPUSH
39175: PPUSH
39176: PPUSH
39177: PPUSH
39178: PPUSH
39179: PPUSH
// if not mc_bases then
39180: LD_EXP 92
39184: NOT
39185: IFFALSE 39189
// exit ;
39187: GO 39991
// for i = 1 to mc_bases do
39189: LD_ADDR_VAR 0 2
39193: PUSH
39194: DOUBLE
39195: LD_INT 1
39197: DEC
39198: ST_TO_ADDR
39199: LD_EXP 92
39203: PUSH
39204: FOR_TO
39205: IFFALSE 39989
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39207: LD_EXP 120
39211: PUSH
39212: LD_VAR 0 2
39216: ARRAY
39217: NOT
39218: PUSH
39219: LD_EXP 95
39223: PUSH
39224: LD_VAR 0 2
39228: ARRAY
39229: PUSH
39230: LD_INT 1
39232: ARRAY
39233: OR
39234: PUSH
39235: LD_EXP 95
39239: PUSH
39240: LD_VAR 0 2
39244: ARRAY
39245: PUSH
39246: LD_INT 2
39248: ARRAY
39249: OR
39250: PUSH
39251: LD_EXP 118
39255: PUSH
39256: LD_VAR 0 2
39260: ARRAY
39261: PPUSH
39262: LD_INT 1
39264: PPUSH
39265: CALL_OW 325
39269: NOT
39270: OR
39271: PUSH
39272: LD_EXP 115
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: OR
39283: IFFALSE 39287
// continue ;
39285: GO 39204
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39287: LD_ADDR_VAR 0 8
39291: PUSH
39292: LD_EXP 92
39296: PUSH
39297: LD_VAR 0 2
39301: ARRAY
39302: PPUSH
39303: LD_INT 25
39305: PUSH
39306: LD_INT 4
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 50
39315: PUSH
39316: EMPTY
39317: LIST
39318: PUSH
39319: LD_INT 3
39321: PUSH
39322: LD_INT 60
39324: PUSH
39325: EMPTY
39326: LIST
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: PPUSH
39337: CALL_OW 72
39341: PUSH
39342: LD_EXP 96
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: DIFF
39353: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39354: LD_ADDR_VAR 0 9
39358: PUSH
39359: LD_EXP 92
39363: PUSH
39364: LD_VAR 0 2
39368: ARRAY
39369: PPUSH
39370: LD_INT 2
39372: PUSH
39373: LD_INT 30
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 30
39385: PUSH
39386: LD_INT 1
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: LIST
39397: PPUSH
39398: CALL_OW 72
39402: ST_TO_ADDR
// if not tmp or not dep then
39403: LD_VAR 0 8
39407: NOT
39408: PUSH
39409: LD_VAR 0 9
39413: NOT
39414: OR
39415: IFFALSE 39419
// continue ;
39417: GO 39204
// side := GetSide ( tmp [ 1 ] ) ;
39419: LD_ADDR_VAR 0 11
39423: PUSH
39424: LD_VAR 0 8
39428: PUSH
39429: LD_INT 1
39431: ARRAY
39432: PPUSH
39433: CALL_OW 255
39437: ST_TO_ADDR
// dep := dep [ 1 ] ;
39438: LD_ADDR_VAR 0 9
39442: PUSH
39443: LD_VAR 0 9
39447: PUSH
39448: LD_INT 1
39450: ARRAY
39451: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39452: LD_ADDR_VAR 0 7
39456: PUSH
39457: LD_EXP 120
39461: PUSH
39462: LD_VAR 0 2
39466: ARRAY
39467: PPUSH
39468: LD_INT 22
39470: PUSH
39471: LD_INT 0
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 25
39480: PUSH
39481: LD_INT 12
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PPUSH
39492: CALL_OW 70
39496: PUSH
39497: LD_INT 22
39499: PUSH
39500: LD_INT 0
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 25
39509: PUSH
39510: LD_INT 12
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 91
39519: PUSH
39520: LD_VAR 0 9
39524: PUSH
39525: LD_INT 20
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: LIST
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: LIST
39537: PPUSH
39538: CALL_OW 69
39542: UNION
39543: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39544: LD_ADDR_VAR 0 10
39548: PUSH
39549: LD_EXP 120
39553: PUSH
39554: LD_VAR 0 2
39558: ARRAY
39559: PPUSH
39560: LD_INT 81
39562: PUSH
39563: LD_VAR 0 11
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PPUSH
39572: CALL_OW 70
39576: ST_TO_ADDR
// if not apes or danger_at_area then
39577: LD_VAR 0 7
39581: NOT
39582: PUSH
39583: LD_VAR 0 10
39587: OR
39588: IFFALSE 39638
// begin if mc_taming [ i ] then
39590: LD_EXP 123
39594: PUSH
39595: LD_VAR 0 2
39599: ARRAY
39600: IFFALSE 39636
// begin MC_Reset ( i , 121 ) ;
39602: LD_VAR 0 2
39606: PPUSH
39607: LD_INT 121
39609: PPUSH
39610: CALL 24925 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39614: LD_ADDR_EXP 123
39618: PUSH
39619: LD_EXP 123
39623: PPUSH
39624: LD_VAR 0 2
39628: PPUSH
39629: EMPTY
39630: PPUSH
39631: CALL_OW 1
39635: ST_TO_ADDR
// end ; continue ;
39636: GO 39204
// end ; for j in tmp do
39638: LD_ADDR_VAR 0 3
39642: PUSH
39643: LD_VAR 0 8
39647: PUSH
39648: FOR_IN
39649: IFFALSE 39985
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39651: LD_VAR 0 3
39655: PUSH
39656: LD_EXP 123
39660: PUSH
39661: LD_VAR 0 2
39665: ARRAY
39666: IN
39667: NOT
39668: PUSH
39669: LD_EXP 123
39673: PUSH
39674: LD_VAR 0 2
39678: ARRAY
39679: PUSH
39680: LD_INT 3
39682: LESS
39683: AND
39684: IFFALSE 39742
// begin SetTag ( j , 121 ) ;
39686: LD_VAR 0 3
39690: PPUSH
39691: LD_INT 121
39693: PPUSH
39694: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39698: LD_ADDR_EXP 123
39702: PUSH
39703: LD_EXP 123
39707: PPUSH
39708: LD_VAR 0 2
39712: PUSH
39713: LD_EXP 123
39717: PUSH
39718: LD_VAR 0 2
39722: ARRAY
39723: PUSH
39724: LD_INT 1
39726: PLUS
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PPUSH
39732: LD_VAR 0 3
39736: PPUSH
39737: CALL 55999 0 3
39741: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39742: LD_VAR 0 3
39746: PUSH
39747: LD_EXP 123
39751: PUSH
39752: LD_VAR 0 2
39756: ARRAY
39757: IN
39758: IFFALSE 39983
// begin if GetClass ( j ) <> 4 then
39760: LD_VAR 0 3
39764: PPUSH
39765: CALL_OW 257
39769: PUSH
39770: LD_INT 4
39772: NONEQUAL
39773: IFFALSE 39826
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39775: LD_ADDR_EXP 123
39779: PUSH
39780: LD_EXP 123
39784: PPUSH
39785: LD_VAR 0 2
39789: PPUSH
39790: LD_EXP 123
39794: PUSH
39795: LD_VAR 0 2
39799: ARRAY
39800: PUSH
39801: LD_VAR 0 3
39805: DIFF
39806: PPUSH
39807: CALL_OW 1
39811: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39812: LD_VAR 0 3
39816: PPUSH
39817: LD_INT 0
39819: PPUSH
39820: CALL_OW 109
// continue ;
39824: GO 39648
// end ; if IsInUnit ( j ) then
39826: LD_VAR 0 3
39830: PPUSH
39831: CALL_OW 310
39835: IFFALSE 39846
// ComExitBuilding ( j ) ;
39837: LD_VAR 0 3
39841: PPUSH
39842: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39846: LD_ADDR_VAR 0 6
39850: PUSH
39851: LD_VAR 0 7
39855: PPUSH
39856: LD_VAR 0 3
39860: PPUSH
39861: CALL_OW 74
39865: ST_TO_ADDR
// if not ape then
39866: LD_VAR 0 6
39870: NOT
39871: IFFALSE 39875
// break ;
39873: GO 39985
// x := GetX ( ape ) ;
39875: LD_ADDR_VAR 0 4
39879: PUSH
39880: LD_VAR 0 6
39884: PPUSH
39885: CALL_OW 250
39889: ST_TO_ADDR
// y := GetY ( ape ) ;
39890: LD_ADDR_VAR 0 5
39894: PUSH
39895: LD_VAR 0 6
39899: PPUSH
39900: CALL_OW 251
39904: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39905: LD_VAR 0 4
39909: PPUSH
39910: LD_VAR 0 5
39914: PPUSH
39915: CALL_OW 488
39919: NOT
39920: PUSH
39921: LD_VAR 0 11
39925: PPUSH
39926: LD_VAR 0 4
39930: PPUSH
39931: LD_VAR 0 5
39935: PPUSH
39936: LD_INT 20
39938: PPUSH
39939: CALL 56895 0 4
39943: PUSH
39944: LD_INT 4
39946: ARRAY
39947: OR
39948: IFFALSE 39952
// break ;
39950: GO 39985
// if not HasTask ( j ) then
39952: LD_VAR 0 3
39956: PPUSH
39957: CALL_OW 314
39961: NOT
39962: IFFALSE 39983
// ComTameXY ( j , x , y ) ;
39964: LD_VAR 0 3
39968: PPUSH
39969: LD_VAR 0 4
39973: PPUSH
39974: LD_VAR 0 5
39978: PPUSH
39979: CALL_OW 131
// end ; end ;
39983: GO 39648
39985: POP
39986: POP
// end ;
39987: GO 39204
39989: POP
39990: POP
// end ;
39991: LD_VAR 0 1
39995: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39996: LD_INT 0
39998: PPUSH
39999: PPUSH
40000: PPUSH
40001: PPUSH
40002: PPUSH
40003: PPUSH
40004: PPUSH
40005: PPUSH
// if not mc_bases then
40006: LD_EXP 92
40010: NOT
40011: IFFALSE 40015
// exit ;
40013: GO 40641
// for i = 1 to mc_bases do
40015: LD_ADDR_VAR 0 2
40019: PUSH
40020: DOUBLE
40021: LD_INT 1
40023: DEC
40024: ST_TO_ADDR
40025: LD_EXP 92
40029: PUSH
40030: FOR_TO
40031: IFFALSE 40639
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40033: LD_EXP 121
40037: PUSH
40038: LD_VAR 0 2
40042: ARRAY
40043: NOT
40044: PUSH
40045: LD_EXP 121
40049: PUSH
40050: LD_VAR 0 2
40054: ARRAY
40055: PPUSH
40056: LD_INT 25
40058: PUSH
40059: LD_INT 12
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PPUSH
40066: CALL_OW 72
40070: NOT
40071: OR
40072: IFFALSE 40076
// continue ;
40074: GO 40030
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40076: LD_ADDR_VAR 0 5
40080: PUSH
40081: LD_EXP 121
40085: PUSH
40086: LD_VAR 0 2
40090: ARRAY
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: CALL_OW 255
40100: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40101: LD_VAR 0 5
40105: PPUSH
40106: LD_INT 2
40108: PPUSH
40109: CALL_OW 325
40113: IFFALSE 40366
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40115: LD_ADDR_VAR 0 4
40119: PUSH
40120: LD_EXP 121
40124: PUSH
40125: LD_VAR 0 2
40129: ARRAY
40130: PPUSH
40131: LD_INT 25
40133: PUSH
40134: LD_INT 16
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PPUSH
40141: CALL_OW 72
40145: ST_TO_ADDR
// if tmp < 6 then
40146: LD_VAR 0 4
40150: PUSH
40151: LD_INT 6
40153: LESS
40154: IFFALSE 40366
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40156: LD_ADDR_VAR 0 6
40160: PUSH
40161: LD_EXP 92
40165: PUSH
40166: LD_VAR 0 2
40170: ARRAY
40171: PPUSH
40172: LD_INT 2
40174: PUSH
40175: LD_INT 30
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 30
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: LIST
40199: PPUSH
40200: CALL_OW 72
40204: ST_TO_ADDR
// if depot then
40205: LD_VAR 0 6
40209: IFFALSE 40366
// begin selected := 0 ;
40211: LD_ADDR_VAR 0 7
40215: PUSH
40216: LD_INT 0
40218: ST_TO_ADDR
// for j in depot do
40219: LD_ADDR_VAR 0 3
40223: PUSH
40224: LD_VAR 0 6
40228: PUSH
40229: FOR_IN
40230: IFFALSE 40261
// begin if UnitsInside ( j ) < 6 then
40232: LD_VAR 0 3
40236: PPUSH
40237: CALL_OW 313
40241: PUSH
40242: LD_INT 6
40244: LESS
40245: IFFALSE 40259
// begin selected := j ;
40247: LD_ADDR_VAR 0 7
40251: PUSH
40252: LD_VAR 0 3
40256: ST_TO_ADDR
// break ;
40257: GO 40261
// end ; end ;
40259: GO 40229
40261: POP
40262: POP
// if selected then
40263: LD_VAR 0 7
40267: IFFALSE 40366
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40269: LD_ADDR_VAR 0 3
40273: PUSH
40274: LD_EXP 121
40278: PUSH
40279: LD_VAR 0 2
40283: ARRAY
40284: PPUSH
40285: LD_INT 25
40287: PUSH
40288: LD_INT 12
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PPUSH
40295: CALL_OW 72
40299: PUSH
40300: FOR_IN
40301: IFFALSE 40364
// if not HasTask ( j ) then
40303: LD_VAR 0 3
40307: PPUSH
40308: CALL_OW 314
40312: NOT
40313: IFFALSE 40362
// begin if not IsInUnit ( j ) then
40315: LD_VAR 0 3
40319: PPUSH
40320: CALL_OW 310
40324: NOT
40325: IFFALSE 40341
// ComEnterUnit ( j , selected ) ;
40327: LD_VAR 0 3
40331: PPUSH
40332: LD_VAR 0 7
40336: PPUSH
40337: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40341: LD_VAR 0 3
40345: PPUSH
40346: LD_INT 16
40348: PPUSH
40349: CALL_OW 183
// AddComExitBuilding ( j ) ;
40353: LD_VAR 0 3
40357: PPUSH
40358: CALL_OW 182
// end ;
40362: GO 40300
40364: POP
40365: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40366: LD_VAR 0 5
40370: PPUSH
40371: LD_INT 11
40373: PPUSH
40374: CALL_OW 325
40378: IFFALSE 40637
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40380: LD_ADDR_VAR 0 4
40384: PUSH
40385: LD_EXP 121
40389: PUSH
40390: LD_VAR 0 2
40394: ARRAY
40395: PPUSH
40396: LD_INT 25
40398: PUSH
40399: LD_INT 16
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PPUSH
40406: CALL_OW 72
40410: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40411: LD_VAR 0 4
40415: PUSH
40416: LD_INT 6
40418: GREATEREQUAL
40419: PUSH
40420: LD_VAR 0 5
40424: PPUSH
40425: LD_INT 2
40427: PPUSH
40428: CALL_OW 325
40432: NOT
40433: OR
40434: IFFALSE 40637
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40436: LD_ADDR_VAR 0 8
40440: PUSH
40441: LD_EXP 92
40445: PUSH
40446: LD_VAR 0 2
40450: ARRAY
40451: PPUSH
40452: LD_INT 2
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 4
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 30
40467: PUSH
40468: LD_INT 5
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: PPUSH
40480: CALL_OW 72
40484: ST_TO_ADDR
// if barracks then
40485: LD_VAR 0 8
40489: IFFALSE 40637
// begin selected := 0 ;
40491: LD_ADDR_VAR 0 7
40495: PUSH
40496: LD_INT 0
40498: ST_TO_ADDR
// for j in barracks do
40499: LD_ADDR_VAR 0 3
40503: PUSH
40504: LD_VAR 0 8
40508: PUSH
40509: FOR_IN
40510: IFFALSE 40541
// begin if UnitsInside ( j ) < 6 then
40512: LD_VAR 0 3
40516: PPUSH
40517: CALL_OW 313
40521: PUSH
40522: LD_INT 6
40524: LESS
40525: IFFALSE 40539
// begin selected := j ;
40527: LD_ADDR_VAR 0 7
40531: PUSH
40532: LD_VAR 0 3
40536: ST_TO_ADDR
// break ;
40537: GO 40541
// end ; end ;
40539: GO 40509
40541: POP
40542: POP
// if selected then
40543: LD_VAR 0 7
40547: IFFALSE 40637
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40549: LD_ADDR_VAR 0 3
40553: PUSH
40554: LD_EXP 121
40558: PUSH
40559: LD_VAR 0 2
40563: ARRAY
40564: PPUSH
40565: LD_INT 25
40567: PUSH
40568: LD_INT 12
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PPUSH
40575: CALL_OW 72
40579: PUSH
40580: FOR_IN
40581: IFFALSE 40635
// if not IsInUnit ( j ) and not HasTask ( j ) then
40583: LD_VAR 0 3
40587: PPUSH
40588: CALL_OW 310
40592: NOT
40593: PUSH
40594: LD_VAR 0 3
40598: PPUSH
40599: CALL_OW 314
40603: NOT
40604: AND
40605: IFFALSE 40633
// begin ComEnterUnit ( j , selected ) ;
40607: LD_VAR 0 3
40611: PPUSH
40612: LD_VAR 0 7
40616: PPUSH
40617: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40621: LD_VAR 0 3
40625: PPUSH
40626: LD_INT 15
40628: PPUSH
40629: CALL_OW 183
// end ;
40633: GO 40580
40635: POP
40636: POP
// end ; end ; end ; end ; end ;
40637: GO 40030
40639: POP
40640: POP
// end ;
40641: LD_VAR 0 1
40645: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40646: LD_INT 0
40648: PPUSH
40649: PPUSH
40650: PPUSH
40651: PPUSH
// if not mc_bases then
40652: LD_EXP 92
40656: NOT
40657: IFFALSE 40661
// exit ;
40659: GO 40839
// for i = 1 to mc_bases do
40661: LD_ADDR_VAR 0 2
40665: PUSH
40666: DOUBLE
40667: LD_INT 1
40669: DEC
40670: ST_TO_ADDR
40671: LD_EXP 92
40675: PUSH
40676: FOR_TO
40677: IFFALSE 40837
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40679: LD_ADDR_VAR 0 4
40683: PUSH
40684: LD_EXP 92
40688: PUSH
40689: LD_VAR 0 2
40693: ARRAY
40694: PPUSH
40695: LD_INT 25
40697: PUSH
40698: LD_INT 9
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PPUSH
40705: CALL_OW 72
40709: ST_TO_ADDR
// if not tmp then
40710: LD_VAR 0 4
40714: NOT
40715: IFFALSE 40719
// continue ;
40717: GO 40676
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40719: LD_EXP 118
40723: PUSH
40724: LD_VAR 0 2
40728: ARRAY
40729: PPUSH
40730: LD_INT 29
40732: PPUSH
40733: CALL_OW 325
40737: NOT
40738: PUSH
40739: LD_EXP 118
40743: PUSH
40744: LD_VAR 0 2
40748: ARRAY
40749: PPUSH
40750: LD_INT 28
40752: PPUSH
40753: CALL_OW 325
40757: NOT
40758: AND
40759: IFFALSE 40763
// continue ;
40761: GO 40676
// for j in tmp do
40763: LD_ADDR_VAR 0 3
40767: PUSH
40768: LD_VAR 0 4
40772: PUSH
40773: FOR_IN
40774: IFFALSE 40833
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40776: LD_VAR 0 3
40780: PUSH
40781: LD_EXP 95
40785: PUSH
40786: LD_VAR 0 2
40790: ARRAY
40791: PUSH
40792: LD_INT 1
40794: ARRAY
40795: IN
40796: NOT
40797: PUSH
40798: LD_VAR 0 3
40802: PUSH
40803: LD_EXP 95
40807: PUSH
40808: LD_VAR 0 2
40812: ARRAY
40813: PUSH
40814: LD_INT 2
40816: ARRAY
40817: IN
40818: NOT
40819: AND
40820: IFFALSE 40831
// ComSpaceTimeShoot ( j ) ;
40822: LD_VAR 0 3
40826: PPUSH
40827: CALL 51996 0 1
40831: GO 40773
40833: POP
40834: POP
// end ;
40835: GO 40676
40837: POP
40838: POP
// end ;
40839: LD_VAR 0 1
40843: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40844: LD_INT 0
40846: PPUSH
40847: PPUSH
40848: PPUSH
40849: PPUSH
40850: PPUSH
40851: PPUSH
40852: PPUSH
40853: PPUSH
40854: PPUSH
// if not mc_bases then
40855: LD_EXP 92
40859: NOT
40860: IFFALSE 40864
// exit ;
40862: GO 41486
// for i = 1 to mc_bases do
40864: LD_ADDR_VAR 0 2
40868: PUSH
40869: DOUBLE
40870: LD_INT 1
40872: DEC
40873: ST_TO_ADDR
40874: LD_EXP 92
40878: PUSH
40879: FOR_TO
40880: IFFALSE 41484
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40882: LD_EXP 127
40886: PUSH
40887: LD_VAR 0 2
40891: ARRAY
40892: NOT
40893: PUSH
40894: LD_INT 38
40896: PPUSH
40897: LD_EXP 118
40901: PUSH
40902: LD_VAR 0 2
40906: ARRAY
40907: PPUSH
40908: CALL_OW 321
40912: PUSH
40913: LD_INT 2
40915: NONEQUAL
40916: OR
40917: IFFALSE 40921
// continue ;
40919: GO 40879
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40921: LD_ADDR_VAR 0 8
40925: PUSH
40926: LD_EXP 92
40930: PUSH
40931: LD_VAR 0 2
40935: ARRAY
40936: PPUSH
40937: LD_INT 30
40939: PUSH
40940: LD_INT 34
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PPUSH
40947: CALL_OW 72
40951: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40952: LD_ADDR_VAR 0 9
40956: PUSH
40957: LD_EXP 92
40961: PUSH
40962: LD_VAR 0 2
40966: ARRAY
40967: PPUSH
40968: LD_INT 25
40970: PUSH
40971: LD_INT 4
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PPUSH
40978: CALL_OW 72
40982: PPUSH
40983: LD_INT 0
40985: PPUSH
40986: CALL 84893 0 2
40990: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40991: LD_VAR 0 9
40995: NOT
40996: PUSH
40997: LD_VAR 0 8
41001: NOT
41002: OR
41003: PUSH
41004: LD_EXP 92
41008: PUSH
41009: LD_VAR 0 2
41013: ARRAY
41014: PPUSH
41015: LD_INT 124
41017: PPUSH
41018: CALL 84893 0 2
41022: OR
41023: IFFALSE 41027
// continue ;
41025: GO 40879
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41027: LD_EXP 128
41031: PUSH
41032: LD_VAR 0 2
41036: ARRAY
41037: PUSH
41038: LD_EXP 127
41042: PUSH
41043: LD_VAR 0 2
41047: ARRAY
41048: LESS
41049: PUSH
41050: LD_EXP 128
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PUSH
41061: LD_VAR 0 8
41065: LESS
41066: AND
41067: IFFALSE 41482
// begin tmp := sci [ 1 ] ;
41069: LD_ADDR_VAR 0 7
41073: PUSH
41074: LD_VAR 0 9
41078: PUSH
41079: LD_INT 1
41081: ARRAY
41082: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41083: LD_VAR 0 7
41087: PPUSH
41088: LD_INT 124
41090: PPUSH
41091: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41095: LD_ADDR_VAR 0 3
41099: PUSH
41100: DOUBLE
41101: LD_EXP 127
41105: PUSH
41106: LD_VAR 0 2
41110: ARRAY
41111: INC
41112: ST_TO_ADDR
41113: LD_EXP 127
41117: PUSH
41118: LD_VAR 0 2
41122: ARRAY
41123: PUSH
41124: FOR_DOWNTO
41125: IFFALSE 41468
// begin if IsInUnit ( tmp ) then
41127: LD_VAR 0 7
41131: PPUSH
41132: CALL_OW 310
41136: IFFALSE 41147
// ComExitBuilding ( tmp ) ;
41138: LD_VAR 0 7
41142: PPUSH
41143: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41147: LD_INT 35
41149: PPUSH
41150: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41154: LD_VAR 0 7
41158: PPUSH
41159: CALL_OW 310
41163: NOT
41164: PUSH
41165: LD_VAR 0 7
41169: PPUSH
41170: CALL_OW 314
41174: NOT
41175: AND
41176: IFFALSE 41147
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41178: LD_ADDR_VAR 0 6
41182: PUSH
41183: LD_VAR 0 7
41187: PPUSH
41188: CALL_OW 250
41192: PUSH
41193: LD_VAR 0 7
41197: PPUSH
41198: CALL_OW 251
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41207: LD_INT 35
41209: PPUSH
41210: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41214: LD_ADDR_VAR 0 4
41218: PUSH
41219: LD_EXP 127
41223: PUSH
41224: LD_VAR 0 2
41228: ARRAY
41229: PUSH
41230: LD_VAR 0 3
41234: ARRAY
41235: PUSH
41236: LD_INT 1
41238: ARRAY
41239: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41240: LD_ADDR_VAR 0 5
41244: PUSH
41245: LD_EXP 127
41249: PUSH
41250: LD_VAR 0 2
41254: ARRAY
41255: PUSH
41256: LD_VAR 0 3
41260: ARRAY
41261: PUSH
41262: LD_INT 2
41264: ARRAY
41265: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41266: LD_VAR 0 7
41270: PPUSH
41271: LD_INT 10
41273: PPUSH
41274: CALL 58592 0 2
41278: PUSH
41279: LD_INT 4
41281: ARRAY
41282: IFFALSE 41320
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41284: LD_VAR 0 7
41288: PPUSH
41289: LD_VAR 0 6
41293: PUSH
41294: LD_INT 1
41296: ARRAY
41297: PPUSH
41298: LD_VAR 0 6
41302: PUSH
41303: LD_INT 2
41305: ARRAY
41306: PPUSH
41307: CALL_OW 111
// wait ( 0 0$10 ) ;
41311: LD_INT 350
41313: PPUSH
41314: CALL_OW 67
// end else
41318: GO 41346
// begin ComMoveXY ( tmp , x , y ) ;
41320: LD_VAR 0 7
41324: PPUSH
41325: LD_VAR 0 4
41329: PPUSH
41330: LD_VAR 0 5
41334: PPUSH
41335: CALL_OW 111
// wait ( 0 0$3 ) ;
41339: LD_INT 105
41341: PPUSH
41342: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41346: LD_VAR 0 7
41350: PPUSH
41351: LD_VAR 0 4
41355: PPUSH
41356: LD_VAR 0 5
41360: PPUSH
41361: CALL_OW 307
41365: IFFALSE 41207
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41367: LD_VAR 0 7
41371: PPUSH
41372: LD_VAR 0 4
41376: PPUSH
41377: LD_VAR 0 5
41381: PPUSH
41382: LD_VAR 0 8
41386: PUSH
41387: LD_VAR 0 3
41391: ARRAY
41392: PPUSH
41393: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41397: LD_INT 35
41399: PPUSH
41400: CALL_OW 67
// until not HasTask ( tmp ) ;
41404: LD_VAR 0 7
41408: PPUSH
41409: CALL_OW 314
41413: NOT
41414: IFFALSE 41397
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41416: LD_ADDR_EXP 128
41420: PUSH
41421: LD_EXP 128
41425: PPUSH
41426: LD_VAR 0 2
41430: PUSH
41431: LD_EXP 128
41435: PUSH
41436: LD_VAR 0 2
41440: ARRAY
41441: PUSH
41442: LD_INT 1
41444: PLUS
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PPUSH
41450: LD_VAR 0 8
41454: PUSH
41455: LD_VAR 0 3
41459: ARRAY
41460: PPUSH
41461: CALL 55999 0 3
41465: ST_TO_ADDR
// end ;
41466: GO 41124
41468: POP
41469: POP
// MC_Reset ( i , 124 ) ;
41470: LD_VAR 0 2
41474: PPUSH
41475: LD_INT 124
41477: PPUSH
41478: CALL 24925 0 2
// end ; end ;
41482: GO 40879
41484: POP
41485: POP
// end ;
41486: LD_VAR 0 1
41490: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41491: LD_INT 0
41493: PPUSH
41494: PPUSH
41495: PPUSH
// if not mc_bases then
41496: LD_EXP 92
41500: NOT
41501: IFFALSE 41505
// exit ;
41503: GO 42111
// for i = 1 to mc_bases do
41505: LD_ADDR_VAR 0 2
41509: PUSH
41510: DOUBLE
41511: LD_INT 1
41513: DEC
41514: ST_TO_ADDR
41515: LD_EXP 92
41519: PUSH
41520: FOR_TO
41521: IFFALSE 42109
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41523: LD_ADDR_VAR 0 3
41527: PUSH
41528: LD_EXP 92
41532: PUSH
41533: LD_VAR 0 2
41537: ARRAY
41538: PPUSH
41539: LD_INT 25
41541: PUSH
41542: LD_INT 4
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PPUSH
41549: CALL_OW 72
41553: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41554: LD_VAR 0 3
41558: NOT
41559: PUSH
41560: LD_EXP 129
41564: PUSH
41565: LD_VAR 0 2
41569: ARRAY
41570: NOT
41571: OR
41572: PUSH
41573: LD_EXP 92
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: PPUSH
41584: LD_INT 2
41586: PUSH
41587: LD_INT 30
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 30
41599: PUSH
41600: LD_INT 1
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: LIST
41611: PPUSH
41612: CALL_OW 72
41616: NOT
41617: OR
41618: IFFALSE 41668
// begin if mc_deposits_finder [ i ] then
41620: LD_EXP 130
41624: PUSH
41625: LD_VAR 0 2
41629: ARRAY
41630: IFFALSE 41666
// begin MC_Reset ( i , 125 ) ;
41632: LD_VAR 0 2
41636: PPUSH
41637: LD_INT 125
41639: PPUSH
41640: CALL 24925 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41644: LD_ADDR_EXP 130
41648: PUSH
41649: LD_EXP 130
41653: PPUSH
41654: LD_VAR 0 2
41658: PPUSH
41659: EMPTY
41660: PPUSH
41661: CALL_OW 1
41665: ST_TO_ADDR
// end ; continue ;
41666: GO 41520
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41668: LD_EXP 129
41672: PUSH
41673: LD_VAR 0 2
41677: ARRAY
41678: PUSH
41679: LD_INT 1
41681: ARRAY
41682: PUSH
41683: LD_INT 3
41685: ARRAY
41686: PUSH
41687: LD_INT 1
41689: EQUAL
41690: PUSH
41691: LD_INT 20
41693: PPUSH
41694: LD_EXP 118
41698: PUSH
41699: LD_VAR 0 2
41703: ARRAY
41704: PPUSH
41705: CALL_OW 321
41709: PUSH
41710: LD_INT 2
41712: NONEQUAL
41713: AND
41714: IFFALSE 41764
// begin if mc_deposits_finder [ i ] then
41716: LD_EXP 130
41720: PUSH
41721: LD_VAR 0 2
41725: ARRAY
41726: IFFALSE 41762
// begin MC_Reset ( i , 125 ) ;
41728: LD_VAR 0 2
41732: PPUSH
41733: LD_INT 125
41735: PPUSH
41736: CALL 24925 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41740: LD_ADDR_EXP 130
41744: PUSH
41745: LD_EXP 130
41749: PPUSH
41750: LD_VAR 0 2
41754: PPUSH
41755: EMPTY
41756: PPUSH
41757: CALL_OW 1
41761: ST_TO_ADDR
// end ; continue ;
41762: GO 41520
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41764: LD_EXP 129
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PUSH
41775: LD_INT 1
41777: ARRAY
41778: PUSH
41779: LD_INT 1
41781: ARRAY
41782: PPUSH
41783: LD_EXP 129
41787: PUSH
41788: LD_VAR 0 2
41792: ARRAY
41793: PUSH
41794: LD_INT 1
41796: ARRAY
41797: PUSH
41798: LD_INT 2
41800: ARRAY
41801: PPUSH
41802: LD_EXP 118
41806: PUSH
41807: LD_VAR 0 2
41811: ARRAY
41812: PPUSH
41813: CALL_OW 440
41817: IFFALSE 41860
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41819: LD_ADDR_EXP 129
41823: PUSH
41824: LD_EXP 129
41828: PPUSH
41829: LD_VAR 0 2
41833: PPUSH
41834: LD_EXP 129
41838: PUSH
41839: LD_VAR 0 2
41843: ARRAY
41844: PPUSH
41845: LD_INT 1
41847: PPUSH
41848: CALL_OW 3
41852: PPUSH
41853: CALL_OW 1
41857: ST_TO_ADDR
41858: GO 42107
// begin if not mc_deposits_finder [ i ] then
41860: LD_EXP 130
41864: PUSH
41865: LD_VAR 0 2
41869: ARRAY
41870: NOT
41871: IFFALSE 41923
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41873: LD_ADDR_EXP 130
41877: PUSH
41878: LD_EXP 130
41882: PPUSH
41883: LD_VAR 0 2
41887: PPUSH
41888: LD_VAR 0 3
41892: PUSH
41893: LD_INT 1
41895: ARRAY
41896: PUSH
41897: EMPTY
41898: LIST
41899: PPUSH
41900: CALL_OW 1
41904: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41905: LD_VAR 0 3
41909: PUSH
41910: LD_INT 1
41912: ARRAY
41913: PPUSH
41914: LD_INT 125
41916: PPUSH
41917: CALL_OW 109
// end else
41921: GO 42107
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41923: LD_EXP 130
41927: PUSH
41928: LD_VAR 0 2
41932: ARRAY
41933: PUSH
41934: LD_INT 1
41936: ARRAY
41937: PPUSH
41938: CALL_OW 310
41942: IFFALSE 41965
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41944: LD_EXP 130
41948: PUSH
41949: LD_VAR 0 2
41953: ARRAY
41954: PUSH
41955: LD_INT 1
41957: ARRAY
41958: PPUSH
41959: CALL_OW 122
41963: GO 42107
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41965: LD_EXP 130
41969: PUSH
41970: LD_VAR 0 2
41974: ARRAY
41975: PUSH
41976: LD_INT 1
41978: ARRAY
41979: PPUSH
41980: CALL_OW 314
41984: NOT
41985: PUSH
41986: LD_EXP 130
41990: PUSH
41991: LD_VAR 0 2
41995: ARRAY
41996: PUSH
41997: LD_INT 1
41999: ARRAY
42000: PPUSH
42001: LD_EXP 129
42005: PUSH
42006: LD_VAR 0 2
42010: ARRAY
42011: PUSH
42012: LD_INT 1
42014: ARRAY
42015: PUSH
42016: LD_INT 1
42018: ARRAY
42019: PPUSH
42020: LD_EXP 129
42024: PUSH
42025: LD_VAR 0 2
42029: ARRAY
42030: PUSH
42031: LD_INT 1
42033: ARRAY
42034: PUSH
42035: LD_INT 2
42037: ARRAY
42038: PPUSH
42039: CALL_OW 297
42043: PUSH
42044: LD_INT 6
42046: GREATER
42047: AND
42048: IFFALSE 42107
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42050: LD_EXP 130
42054: PUSH
42055: LD_VAR 0 2
42059: ARRAY
42060: PUSH
42061: LD_INT 1
42063: ARRAY
42064: PPUSH
42065: LD_EXP 129
42069: PUSH
42070: LD_VAR 0 2
42074: ARRAY
42075: PUSH
42076: LD_INT 1
42078: ARRAY
42079: PUSH
42080: LD_INT 1
42082: ARRAY
42083: PPUSH
42084: LD_EXP 129
42088: PUSH
42089: LD_VAR 0 2
42093: ARRAY
42094: PUSH
42095: LD_INT 1
42097: ARRAY
42098: PUSH
42099: LD_INT 2
42101: ARRAY
42102: PPUSH
42103: CALL_OW 111
// end ; end ; end ;
42107: GO 41520
42109: POP
42110: POP
// end ;
42111: LD_VAR 0 1
42115: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42116: LD_INT 0
42118: PPUSH
42119: PPUSH
42120: PPUSH
42121: PPUSH
42122: PPUSH
42123: PPUSH
42124: PPUSH
42125: PPUSH
42126: PPUSH
42127: PPUSH
42128: PPUSH
// if not mc_bases then
42129: LD_EXP 92
42133: NOT
42134: IFFALSE 42138
// exit ;
42136: GO 43078
// for i = 1 to mc_bases do
42138: LD_ADDR_VAR 0 2
42142: PUSH
42143: DOUBLE
42144: LD_INT 1
42146: DEC
42147: ST_TO_ADDR
42148: LD_EXP 92
42152: PUSH
42153: FOR_TO
42154: IFFALSE 43076
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42156: LD_EXP 92
42160: PUSH
42161: LD_VAR 0 2
42165: ARRAY
42166: NOT
42167: PUSH
42168: LD_EXP 115
42172: PUSH
42173: LD_VAR 0 2
42177: ARRAY
42178: OR
42179: IFFALSE 42183
// continue ;
42181: GO 42153
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42183: LD_ADDR_VAR 0 7
42187: PUSH
42188: LD_EXP 92
42192: PUSH
42193: LD_VAR 0 2
42197: ARRAY
42198: PUSH
42199: LD_INT 1
42201: ARRAY
42202: PPUSH
42203: CALL_OW 248
42207: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42208: LD_VAR 0 7
42212: PUSH
42213: LD_INT 3
42215: EQUAL
42216: PUSH
42217: LD_EXP 111
42221: PUSH
42222: LD_VAR 0 2
42226: ARRAY
42227: PUSH
42228: LD_EXP 114
42232: PUSH
42233: LD_VAR 0 2
42237: ARRAY
42238: UNION
42239: PPUSH
42240: LD_INT 33
42242: PUSH
42243: LD_INT 2
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PPUSH
42250: CALL_OW 72
42254: NOT
42255: OR
42256: IFFALSE 42260
// continue ;
42258: GO 42153
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42260: LD_ADDR_VAR 0 9
42264: PUSH
42265: LD_EXP 92
42269: PUSH
42270: LD_VAR 0 2
42274: ARRAY
42275: PPUSH
42276: LD_INT 30
42278: PUSH
42279: LD_INT 36
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PPUSH
42286: CALL_OW 72
42290: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42291: LD_ADDR_VAR 0 10
42295: PUSH
42296: LD_EXP 111
42300: PUSH
42301: LD_VAR 0 2
42305: ARRAY
42306: PPUSH
42307: LD_INT 34
42309: PUSH
42310: LD_INT 31
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PPUSH
42317: CALL_OW 72
42321: ST_TO_ADDR
// if not cts and not mcts then
42322: LD_VAR 0 9
42326: NOT
42327: PUSH
42328: LD_VAR 0 10
42332: NOT
42333: AND
42334: IFFALSE 42338
// continue ;
42336: GO 42153
// x := cts ;
42338: LD_ADDR_VAR 0 11
42342: PUSH
42343: LD_VAR 0 9
42347: ST_TO_ADDR
// if not x then
42348: LD_VAR 0 11
42352: NOT
42353: IFFALSE 42365
// x := mcts ;
42355: LD_ADDR_VAR 0 11
42359: PUSH
42360: LD_VAR 0 10
42364: ST_TO_ADDR
// if not x then
42365: LD_VAR 0 11
42369: NOT
42370: IFFALSE 42374
// continue ;
42372: GO 42153
// if mc_remote_driver [ i ] then
42374: LD_EXP 132
42378: PUSH
42379: LD_VAR 0 2
42383: ARRAY
42384: IFFALSE 42771
// for j in mc_remote_driver [ i ] do
42386: LD_ADDR_VAR 0 3
42390: PUSH
42391: LD_EXP 132
42395: PUSH
42396: LD_VAR 0 2
42400: ARRAY
42401: PUSH
42402: FOR_IN
42403: IFFALSE 42769
// begin if GetClass ( j ) <> 3 then
42405: LD_VAR 0 3
42409: PPUSH
42410: CALL_OW 257
42414: PUSH
42415: LD_INT 3
42417: NONEQUAL
42418: IFFALSE 42471
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42420: LD_ADDR_EXP 132
42424: PUSH
42425: LD_EXP 132
42429: PPUSH
42430: LD_VAR 0 2
42434: PPUSH
42435: LD_EXP 132
42439: PUSH
42440: LD_VAR 0 2
42444: ARRAY
42445: PUSH
42446: LD_VAR 0 3
42450: DIFF
42451: PPUSH
42452: CALL_OW 1
42456: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42457: LD_VAR 0 3
42461: PPUSH
42462: LD_INT 0
42464: PPUSH
42465: CALL_OW 109
// continue ;
42469: GO 42402
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42471: LD_EXP 111
42475: PUSH
42476: LD_VAR 0 2
42480: ARRAY
42481: PPUSH
42482: LD_INT 34
42484: PUSH
42485: LD_INT 31
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 58
42494: PUSH
42495: EMPTY
42496: LIST
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PPUSH
42502: CALL_OW 72
42506: PUSH
42507: LD_VAR 0 3
42511: PPUSH
42512: CALL 84981 0 1
42516: NOT
42517: AND
42518: IFFALSE 42589
// begin if IsInUnit ( j ) then
42520: LD_VAR 0 3
42524: PPUSH
42525: CALL_OW 310
42529: IFFALSE 42540
// ComExitBuilding ( j ) ;
42531: LD_VAR 0 3
42535: PPUSH
42536: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42540: LD_VAR 0 3
42544: PPUSH
42545: LD_EXP 111
42549: PUSH
42550: LD_VAR 0 2
42554: ARRAY
42555: PPUSH
42556: LD_INT 34
42558: PUSH
42559: LD_INT 31
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 58
42568: PUSH
42569: EMPTY
42570: LIST
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PPUSH
42576: CALL_OW 72
42580: PUSH
42581: LD_INT 1
42583: ARRAY
42584: PPUSH
42585: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42589: LD_VAR 0 3
42593: PPUSH
42594: CALL_OW 310
42598: NOT
42599: PUSH
42600: LD_VAR 0 3
42604: PPUSH
42605: CALL_OW 310
42609: PPUSH
42610: CALL_OW 266
42614: PUSH
42615: LD_INT 36
42617: NONEQUAL
42618: PUSH
42619: LD_VAR 0 3
42623: PPUSH
42624: CALL 84981 0 1
42628: NOT
42629: AND
42630: OR
42631: IFFALSE 42767
// begin if IsInUnit ( j ) then
42633: LD_VAR 0 3
42637: PPUSH
42638: CALL_OW 310
42642: IFFALSE 42653
// ComExitBuilding ( j ) ;
42644: LD_VAR 0 3
42648: PPUSH
42649: CALL_OW 122
// ct := 0 ;
42653: LD_ADDR_VAR 0 8
42657: PUSH
42658: LD_INT 0
42660: ST_TO_ADDR
// for k in x do
42661: LD_ADDR_VAR 0 4
42665: PUSH
42666: LD_VAR 0 11
42670: PUSH
42671: FOR_IN
42672: IFFALSE 42745
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42674: LD_VAR 0 4
42678: PPUSH
42679: CALL_OW 264
42683: PUSH
42684: LD_INT 31
42686: EQUAL
42687: PUSH
42688: LD_VAR 0 4
42692: PPUSH
42693: CALL_OW 311
42697: NOT
42698: AND
42699: PUSH
42700: LD_VAR 0 4
42704: PPUSH
42705: CALL_OW 266
42709: PUSH
42710: LD_INT 36
42712: EQUAL
42713: PUSH
42714: LD_VAR 0 4
42718: PPUSH
42719: CALL_OW 313
42723: PUSH
42724: LD_INT 3
42726: LESS
42727: AND
42728: OR
42729: IFFALSE 42743
// begin ct := k ;
42731: LD_ADDR_VAR 0 8
42735: PUSH
42736: LD_VAR 0 4
42740: ST_TO_ADDR
// break ;
42741: GO 42745
// end ;
42743: GO 42671
42745: POP
42746: POP
// if ct then
42747: LD_VAR 0 8
42751: IFFALSE 42767
// ComEnterUnit ( j , ct ) ;
42753: LD_VAR 0 3
42757: PPUSH
42758: LD_VAR 0 8
42762: PPUSH
42763: CALL_OW 120
// end ; end ;
42767: GO 42402
42769: POP
42770: POP
// places := 0 ;
42771: LD_ADDR_VAR 0 5
42775: PUSH
42776: LD_INT 0
42778: ST_TO_ADDR
// for j = 1 to x do
42779: LD_ADDR_VAR 0 3
42783: PUSH
42784: DOUBLE
42785: LD_INT 1
42787: DEC
42788: ST_TO_ADDR
42789: LD_VAR 0 11
42793: PUSH
42794: FOR_TO
42795: IFFALSE 42871
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42797: LD_VAR 0 11
42801: PUSH
42802: LD_VAR 0 3
42806: ARRAY
42807: PPUSH
42808: CALL_OW 264
42812: PUSH
42813: LD_INT 31
42815: EQUAL
42816: IFFALSE 42834
// places := places + 1 else
42818: LD_ADDR_VAR 0 5
42822: PUSH
42823: LD_VAR 0 5
42827: PUSH
42828: LD_INT 1
42830: PLUS
42831: ST_TO_ADDR
42832: GO 42869
// if GetBType ( x [ j ] ) = b_control_tower then
42834: LD_VAR 0 11
42838: PUSH
42839: LD_VAR 0 3
42843: ARRAY
42844: PPUSH
42845: CALL_OW 266
42849: PUSH
42850: LD_INT 36
42852: EQUAL
42853: IFFALSE 42869
// places := places + 3 ;
42855: LD_ADDR_VAR 0 5
42859: PUSH
42860: LD_VAR 0 5
42864: PUSH
42865: LD_INT 3
42867: PLUS
42868: ST_TO_ADDR
42869: GO 42794
42871: POP
42872: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42873: LD_VAR 0 5
42877: PUSH
42878: LD_INT 0
42880: EQUAL
42881: PUSH
42882: LD_VAR 0 5
42886: PUSH
42887: LD_EXP 132
42891: PUSH
42892: LD_VAR 0 2
42896: ARRAY
42897: LESSEQUAL
42898: OR
42899: IFFALSE 42903
// continue ;
42901: GO 42153
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42903: LD_ADDR_VAR 0 6
42907: PUSH
42908: LD_EXP 92
42912: PUSH
42913: LD_VAR 0 2
42917: ARRAY
42918: PPUSH
42919: LD_INT 25
42921: PUSH
42922: LD_INT 3
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PPUSH
42929: CALL_OW 72
42933: PUSH
42934: LD_EXP 132
42938: PUSH
42939: LD_VAR 0 2
42943: ARRAY
42944: DIFF
42945: PPUSH
42946: LD_INT 3
42948: PPUSH
42949: CALL 85881 0 2
42953: ST_TO_ADDR
// for j in tmp do
42954: LD_ADDR_VAR 0 3
42958: PUSH
42959: LD_VAR 0 6
42963: PUSH
42964: FOR_IN
42965: IFFALSE 43000
// if GetTag ( j ) > 0 then
42967: LD_VAR 0 3
42971: PPUSH
42972: CALL_OW 110
42976: PUSH
42977: LD_INT 0
42979: GREATER
42980: IFFALSE 42998
// tmp := tmp diff j ;
42982: LD_ADDR_VAR 0 6
42986: PUSH
42987: LD_VAR 0 6
42991: PUSH
42992: LD_VAR 0 3
42996: DIFF
42997: ST_TO_ADDR
42998: GO 42964
43000: POP
43001: POP
// if not tmp then
43002: LD_VAR 0 6
43006: NOT
43007: IFFALSE 43011
// continue ;
43009: GO 42153
// if places then
43011: LD_VAR 0 5
43015: IFFALSE 43074
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43017: LD_ADDR_EXP 132
43021: PUSH
43022: LD_EXP 132
43026: PPUSH
43027: LD_VAR 0 2
43031: PPUSH
43032: LD_EXP 132
43036: PUSH
43037: LD_VAR 0 2
43041: ARRAY
43042: PUSH
43043: LD_VAR 0 6
43047: PUSH
43048: LD_INT 1
43050: ARRAY
43051: UNION
43052: PPUSH
43053: CALL_OW 1
43057: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43058: LD_VAR 0 6
43062: PUSH
43063: LD_INT 1
43065: ARRAY
43066: PPUSH
43067: LD_INT 126
43069: PPUSH
43070: CALL_OW 109
// end ; end ;
43074: GO 42153
43076: POP
43077: POP
// end ;
43078: LD_VAR 0 1
43082: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43083: LD_INT 0
43085: PPUSH
43086: PPUSH
43087: PPUSH
43088: PPUSH
43089: PPUSH
43090: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43091: LD_VAR 0 1
43095: NOT
43096: PUSH
43097: LD_VAR 0 2
43101: NOT
43102: OR
43103: PUSH
43104: LD_VAR 0 3
43108: NOT
43109: OR
43110: PUSH
43111: LD_VAR 0 4
43115: PUSH
43116: LD_INT 1
43118: PUSH
43119: LD_INT 2
43121: PUSH
43122: LD_INT 3
43124: PUSH
43125: LD_INT 4
43127: PUSH
43128: LD_INT 5
43130: PUSH
43131: LD_INT 8
43133: PUSH
43134: LD_INT 9
43136: PUSH
43137: LD_INT 15
43139: PUSH
43140: LD_INT 16
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: LIST
43147: LIST
43148: LIST
43149: LIST
43150: LIST
43151: LIST
43152: LIST
43153: IN
43154: NOT
43155: OR
43156: IFFALSE 43160
// exit ;
43158: GO 44060
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43160: LD_ADDR_VAR 0 2
43164: PUSH
43165: LD_VAR 0 2
43169: PPUSH
43170: LD_INT 21
43172: PUSH
43173: LD_INT 3
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PUSH
43180: LD_INT 24
43182: PUSH
43183: LD_INT 250
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PPUSH
43194: CALL_OW 72
43198: ST_TO_ADDR
// case class of 1 , 15 :
43199: LD_VAR 0 4
43203: PUSH
43204: LD_INT 1
43206: DOUBLE
43207: EQUAL
43208: IFTRUE 43218
43210: LD_INT 15
43212: DOUBLE
43213: EQUAL
43214: IFTRUE 43218
43216: GO 43303
43218: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43219: LD_ADDR_VAR 0 8
43223: PUSH
43224: LD_VAR 0 2
43228: PPUSH
43229: LD_INT 2
43231: PUSH
43232: LD_INT 30
43234: PUSH
43235: LD_INT 32
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 30
43244: PUSH
43245: LD_INT 31
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: LIST
43256: PPUSH
43257: CALL_OW 72
43261: PUSH
43262: LD_VAR 0 2
43266: PPUSH
43267: LD_INT 2
43269: PUSH
43270: LD_INT 30
43272: PUSH
43273: LD_INT 4
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 30
43282: PUSH
43283: LD_INT 5
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: LIST
43294: PPUSH
43295: CALL_OW 72
43299: ADD
43300: ST_TO_ADDR
43301: GO 43549
43303: LD_INT 2
43305: DOUBLE
43306: EQUAL
43307: IFTRUE 43317
43309: LD_INT 16
43311: DOUBLE
43312: EQUAL
43313: IFTRUE 43317
43315: GO 43363
43317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43318: LD_ADDR_VAR 0 8
43322: PUSH
43323: LD_VAR 0 2
43327: PPUSH
43328: LD_INT 2
43330: PUSH
43331: LD_INT 30
43333: PUSH
43334: LD_INT 0
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 30
43343: PUSH
43344: LD_INT 1
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: LIST
43355: PPUSH
43356: CALL_OW 72
43360: ST_TO_ADDR
43361: GO 43549
43363: LD_INT 3
43365: DOUBLE
43366: EQUAL
43367: IFTRUE 43371
43369: GO 43417
43371: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43372: LD_ADDR_VAR 0 8
43376: PUSH
43377: LD_VAR 0 2
43381: PPUSH
43382: LD_INT 2
43384: PUSH
43385: LD_INT 30
43387: PUSH
43388: LD_INT 2
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 30
43397: PUSH
43398: LD_INT 3
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: LIST
43409: PPUSH
43410: CALL_OW 72
43414: ST_TO_ADDR
43415: GO 43549
43417: LD_INT 4
43419: DOUBLE
43420: EQUAL
43421: IFTRUE 43425
43423: GO 43482
43425: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43426: LD_ADDR_VAR 0 8
43430: PUSH
43431: LD_VAR 0 2
43435: PPUSH
43436: LD_INT 2
43438: PUSH
43439: LD_INT 30
43441: PUSH
43442: LD_INT 6
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 30
43451: PUSH
43452: LD_INT 7
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 30
43461: PUSH
43462: LD_INT 8
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: LIST
43473: LIST
43474: PPUSH
43475: CALL_OW 72
43479: ST_TO_ADDR
43480: GO 43549
43482: LD_INT 5
43484: DOUBLE
43485: EQUAL
43486: IFTRUE 43502
43488: LD_INT 8
43490: DOUBLE
43491: EQUAL
43492: IFTRUE 43502
43494: LD_INT 9
43496: DOUBLE
43497: EQUAL
43498: IFTRUE 43502
43500: GO 43548
43502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43503: LD_ADDR_VAR 0 8
43507: PUSH
43508: LD_VAR 0 2
43512: PPUSH
43513: LD_INT 2
43515: PUSH
43516: LD_INT 30
43518: PUSH
43519: LD_INT 4
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 30
43528: PUSH
43529: LD_INT 5
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: LIST
43540: PPUSH
43541: CALL_OW 72
43545: ST_TO_ADDR
43546: GO 43549
43548: POP
// if not tmp then
43549: LD_VAR 0 8
43553: NOT
43554: IFFALSE 43558
// exit ;
43556: GO 44060
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43558: LD_VAR 0 4
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: LD_INT 15
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: IN
43573: PUSH
43574: LD_EXP 101
43578: PUSH
43579: LD_VAR 0 1
43583: ARRAY
43584: AND
43585: IFFALSE 43741
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43587: LD_ADDR_VAR 0 9
43591: PUSH
43592: LD_EXP 101
43596: PUSH
43597: LD_VAR 0 1
43601: ARRAY
43602: PUSH
43603: LD_INT 1
43605: ARRAY
43606: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43607: LD_VAR 0 9
43611: PUSH
43612: LD_EXP 102
43616: PUSH
43617: LD_VAR 0 1
43621: ARRAY
43622: IN
43623: NOT
43624: IFFALSE 43739
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43626: LD_ADDR_EXP 102
43630: PUSH
43631: LD_EXP 102
43635: PPUSH
43636: LD_VAR 0 1
43640: PUSH
43641: LD_EXP 102
43645: PUSH
43646: LD_VAR 0 1
43650: ARRAY
43651: PUSH
43652: LD_INT 1
43654: PLUS
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PPUSH
43660: LD_VAR 0 9
43664: PPUSH
43665: CALL 55999 0 3
43669: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43670: LD_ADDR_EXP 101
43674: PUSH
43675: LD_EXP 101
43679: PPUSH
43680: LD_VAR 0 1
43684: PPUSH
43685: LD_EXP 101
43689: PUSH
43690: LD_VAR 0 1
43694: ARRAY
43695: PUSH
43696: LD_VAR 0 9
43700: DIFF
43701: PPUSH
43702: CALL_OW 1
43706: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43707: LD_VAR 0 3
43711: PPUSH
43712: LD_EXP 102
43716: PUSH
43717: LD_VAR 0 1
43721: ARRAY
43722: PUSH
43723: LD_EXP 102
43727: PUSH
43728: LD_VAR 0 1
43732: ARRAY
43733: ARRAY
43734: PPUSH
43735: CALL_OW 120
// end ; exit ;
43739: GO 44060
// end ; if tmp > 1 then
43741: LD_VAR 0 8
43745: PUSH
43746: LD_INT 1
43748: GREATER
43749: IFFALSE 43853
// for i = 2 to tmp do
43751: LD_ADDR_VAR 0 6
43755: PUSH
43756: DOUBLE
43757: LD_INT 2
43759: DEC
43760: ST_TO_ADDR
43761: LD_VAR 0 8
43765: PUSH
43766: FOR_TO
43767: IFFALSE 43851
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43769: LD_VAR 0 8
43773: PUSH
43774: LD_VAR 0 6
43778: ARRAY
43779: PPUSH
43780: CALL_OW 461
43784: PUSH
43785: LD_INT 6
43787: EQUAL
43788: IFFALSE 43849
// begin x := tmp [ i ] ;
43790: LD_ADDR_VAR 0 9
43794: PUSH
43795: LD_VAR 0 8
43799: PUSH
43800: LD_VAR 0 6
43804: ARRAY
43805: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43806: LD_ADDR_VAR 0 8
43810: PUSH
43811: LD_VAR 0 8
43815: PPUSH
43816: LD_VAR 0 6
43820: PPUSH
43821: CALL_OW 3
43825: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43826: LD_ADDR_VAR 0 8
43830: PUSH
43831: LD_VAR 0 8
43835: PPUSH
43836: LD_INT 1
43838: PPUSH
43839: LD_VAR 0 9
43843: PPUSH
43844: CALL_OW 2
43848: ST_TO_ADDR
// end ;
43849: GO 43766
43851: POP
43852: POP
// for i in tmp do
43853: LD_ADDR_VAR 0 6
43857: PUSH
43858: LD_VAR 0 8
43862: PUSH
43863: FOR_IN
43864: IFFALSE 43933
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43866: LD_VAR 0 6
43870: PPUSH
43871: CALL_OW 313
43875: PUSH
43876: LD_INT 6
43878: LESS
43879: PUSH
43880: LD_VAR 0 6
43884: PPUSH
43885: CALL_OW 266
43889: PUSH
43890: LD_INT 31
43892: PUSH
43893: LD_INT 32
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: IN
43900: NOT
43901: AND
43902: PUSH
43903: LD_VAR 0 6
43907: PPUSH
43908: CALL_OW 313
43912: PUSH
43913: LD_INT 0
43915: EQUAL
43916: OR
43917: IFFALSE 43931
// begin j := i ;
43919: LD_ADDR_VAR 0 7
43923: PUSH
43924: LD_VAR 0 6
43928: ST_TO_ADDR
// break ;
43929: GO 43933
// end ; end ;
43931: GO 43863
43933: POP
43934: POP
// if j then
43935: LD_VAR 0 7
43939: IFFALSE 43957
// ComEnterUnit ( unit , j ) else
43941: LD_VAR 0 3
43945: PPUSH
43946: LD_VAR 0 7
43950: PPUSH
43951: CALL_OW 120
43955: GO 44060
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43957: LD_ADDR_VAR 0 10
43961: PUSH
43962: LD_VAR 0 2
43966: PPUSH
43967: LD_INT 2
43969: PUSH
43970: LD_INT 30
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 30
43982: PUSH
43983: LD_INT 1
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: LIST
43994: PPUSH
43995: CALL_OW 72
43999: ST_TO_ADDR
// if depot then
44000: LD_VAR 0 10
44004: IFFALSE 44060
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44006: LD_ADDR_VAR 0 10
44010: PUSH
44011: LD_VAR 0 10
44015: PPUSH
44016: LD_VAR 0 3
44020: PPUSH
44021: CALL_OW 74
44025: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44026: LD_VAR 0 3
44030: PPUSH
44031: LD_VAR 0 10
44035: PPUSH
44036: CALL_OW 296
44040: PUSH
44041: LD_INT 10
44043: GREATER
44044: IFFALSE 44060
// ComStandNearbyBuilding ( unit , depot ) ;
44046: LD_VAR 0 3
44050: PPUSH
44051: LD_VAR 0 10
44055: PPUSH
44056: CALL 52613 0 2
// end ; end ; end ;
44060: LD_VAR 0 5
44064: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44065: LD_INT 0
44067: PPUSH
44068: PPUSH
44069: PPUSH
44070: PPUSH
// if not mc_bases then
44071: LD_EXP 92
44075: NOT
44076: IFFALSE 44080
// exit ;
44078: GO 44319
// for i = 1 to mc_bases do
44080: LD_ADDR_VAR 0 2
44084: PUSH
44085: DOUBLE
44086: LD_INT 1
44088: DEC
44089: ST_TO_ADDR
44090: LD_EXP 92
44094: PUSH
44095: FOR_TO
44096: IFFALSE 44317
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44098: LD_ADDR_VAR 0 4
44102: PUSH
44103: LD_EXP 92
44107: PUSH
44108: LD_VAR 0 2
44112: ARRAY
44113: PPUSH
44114: LD_INT 21
44116: PUSH
44117: LD_INT 1
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PPUSH
44124: CALL_OW 72
44128: PUSH
44129: LD_EXP 121
44133: PUSH
44134: LD_VAR 0 2
44138: ARRAY
44139: UNION
44140: ST_TO_ADDR
// if not tmp then
44141: LD_VAR 0 4
44145: NOT
44146: IFFALSE 44150
// continue ;
44148: GO 44095
// for j in tmp do
44150: LD_ADDR_VAR 0 3
44154: PUSH
44155: LD_VAR 0 4
44159: PUSH
44160: FOR_IN
44161: IFFALSE 44313
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44163: LD_VAR 0 3
44167: PPUSH
44168: CALL_OW 110
44172: NOT
44173: PUSH
44174: LD_VAR 0 3
44178: PPUSH
44179: CALL_OW 314
44183: NOT
44184: AND
44185: PUSH
44186: LD_VAR 0 3
44190: PPUSH
44191: CALL_OW 311
44195: NOT
44196: AND
44197: PUSH
44198: LD_VAR 0 3
44202: PPUSH
44203: CALL_OW 310
44207: NOT
44208: AND
44209: PUSH
44210: LD_VAR 0 3
44214: PUSH
44215: LD_EXP 95
44219: PUSH
44220: LD_VAR 0 2
44224: ARRAY
44225: PUSH
44226: LD_INT 1
44228: ARRAY
44229: IN
44230: NOT
44231: AND
44232: PUSH
44233: LD_VAR 0 3
44237: PUSH
44238: LD_EXP 95
44242: PUSH
44243: LD_VAR 0 2
44247: ARRAY
44248: PUSH
44249: LD_INT 2
44251: ARRAY
44252: IN
44253: NOT
44254: AND
44255: PUSH
44256: LD_VAR 0 3
44260: PUSH
44261: LD_EXP 104
44265: PUSH
44266: LD_VAR 0 2
44270: ARRAY
44271: IN
44272: NOT
44273: AND
44274: IFFALSE 44311
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44276: LD_VAR 0 2
44280: PPUSH
44281: LD_EXP 92
44285: PUSH
44286: LD_VAR 0 2
44290: ARRAY
44291: PPUSH
44292: LD_VAR 0 3
44296: PPUSH
44297: LD_VAR 0 3
44301: PPUSH
44302: CALL_OW 257
44306: PPUSH
44307: CALL 43083 0 4
// end ;
44311: GO 44160
44313: POP
44314: POP
// end ;
44315: GO 44095
44317: POP
44318: POP
// end ;
44319: LD_VAR 0 1
44323: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44324: LD_INT 0
44326: PPUSH
44327: PPUSH
44328: PPUSH
44329: PPUSH
44330: PPUSH
44331: PPUSH
// if not mc_bases [ base ] then
44332: LD_EXP 92
44336: PUSH
44337: LD_VAR 0 1
44341: ARRAY
44342: NOT
44343: IFFALSE 44347
// exit ;
44345: GO 44529
// tmp := [ ] ;
44347: LD_ADDR_VAR 0 6
44351: PUSH
44352: EMPTY
44353: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44354: LD_ADDR_VAR 0 7
44358: PUSH
44359: LD_VAR 0 3
44363: PPUSH
44364: LD_INT 0
44366: PPUSH
44367: CALL_OW 517
44371: ST_TO_ADDR
// if not list then
44372: LD_VAR 0 7
44376: NOT
44377: IFFALSE 44381
// exit ;
44379: GO 44529
// for i = 1 to amount do
44381: LD_ADDR_VAR 0 5
44385: PUSH
44386: DOUBLE
44387: LD_INT 1
44389: DEC
44390: ST_TO_ADDR
44391: LD_VAR 0 2
44395: PUSH
44396: FOR_TO
44397: IFFALSE 44477
// begin x := rand ( 1 , list [ 1 ] ) ;
44399: LD_ADDR_VAR 0 8
44403: PUSH
44404: LD_INT 1
44406: PPUSH
44407: LD_VAR 0 7
44411: PUSH
44412: LD_INT 1
44414: ARRAY
44415: PPUSH
44416: CALL_OW 12
44420: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44421: LD_ADDR_VAR 0 6
44425: PUSH
44426: LD_VAR 0 6
44430: PPUSH
44431: LD_VAR 0 5
44435: PPUSH
44436: LD_VAR 0 7
44440: PUSH
44441: LD_INT 1
44443: ARRAY
44444: PUSH
44445: LD_VAR 0 8
44449: ARRAY
44450: PUSH
44451: LD_VAR 0 7
44455: PUSH
44456: LD_INT 2
44458: ARRAY
44459: PUSH
44460: LD_VAR 0 8
44464: ARRAY
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PPUSH
44470: CALL_OW 1
44474: ST_TO_ADDR
// end ;
44475: GO 44396
44477: POP
44478: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44479: LD_ADDR_EXP 105
44483: PUSH
44484: LD_EXP 105
44488: PPUSH
44489: LD_VAR 0 1
44493: PPUSH
44494: LD_VAR 0 6
44498: PPUSH
44499: CALL_OW 1
44503: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44504: LD_ADDR_EXP 107
44508: PUSH
44509: LD_EXP 107
44513: PPUSH
44514: LD_VAR 0 1
44518: PPUSH
44519: LD_VAR 0 3
44523: PPUSH
44524: CALL_OW 1
44528: ST_TO_ADDR
// end ;
44529: LD_VAR 0 4
44533: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44534: LD_INT 0
44536: PPUSH
// if not mc_bases [ base ] then
44537: LD_EXP 92
44541: PUSH
44542: LD_VAR 0 1
44546: ARRAY
44547: NOT
44548: IFFALSE 44552
// exit ;
44550: GO 44577
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44552: LD_ADDR_EXP 97
44556: PUSH
44557: LD_EXP 97
44561: PPUSH
44562: LD_VAR 0 1
44566: PPUSH
44567: LD_VAR 0 2
44571: PPUSH
44572: CALL_OW 1
44576: ST_TO_ADDR
// end ;
44577: LD_VAR 0 3
44581: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44582: LD_INT 0
44584: PPUSH
// if not mc_bases [ base ] then
44585: LD_EXP 92
44589: PUSH
44590: LD_VAR 0 1
44594: ARRAY
44595: NOT
44596: IFFALSE 44600
// exit ;
44598: GO 44637
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44600: LD_ADDR_EXP 97
44604: PUSH
44605: LD_EXP 97
44609: PPUSH
44610: LD_VAR 0 1
44614: PPUSH
44615: LD_EXP 97
44619: PUSH
44620: LD_VAR 0 1
44624: ARRAY
44625: PUSH
44626: LD_VAR 0 2
44630: UNION
44631: PPUSH
44632: CALL_OW 1
44636: ST_TO_ADDR
// end ;
44637: LD_VAR 0 3
44641: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44642: LD_INT 0
44644: PPUSH
// if not mc_bases [ base ] then
44645: LD_EXP 92
44649: PUSH
44650: LD_VAR 0 1
44654: ARRAY
44655: NOT
44656: IFFALSE 44660
// exit ;
44658: GO 44685
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44660: LD_ADDR_EXP 113
44664: PUSH
44665: LD_EXP 113
44669: PPUSH
44670: LD_VAR 0 1
44674: PPUSH
44675: LD_VAR 0 2
44679: PPUSH
44680: CALL_OW 1
44684: ST_TO_ADDR
// end ;
44685: LD_VAR 0 3
44689: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44690: LD_INT 0
44692: PPUSH
// if not mc_bases [ base ] then
44693: LD_EXP 92
44697: PUSH
44698: LD_VAR 0 1
44702: ARRAY
44703: NOT
44704: IFFALSE 44708
// exit ;
44706: GO 44745
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44708: LD_ADDR_EXP 113
44712: PUSH
44713: LD_EXP 113
44717: PPUSH
44718: LD_VAR 0 1
44722: PPUSH
44723: LD_EXP 113
44727: PUSH
44728: LD_VAR 0 1
44732: ARRAY
44733: PUSH
44734: LD_VAR 0 2
44738: ADD
44739: PPUSH
44740: CALL_OW 1
44744: ST_TO_ADDR
// end ;
44745: LD_VAR 0 3
44749: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44750: LD_INT 0
44752: PPUSH
// if not mc_bases [ base ] then
44753: LD_EXP 92
44757: PUSH
44758: LD_VAR 0 1
44762: ARRAY
44763: NOT
44764: IFFALSE 44768
// exit ;
44766: GO 44822
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44768: LD_ADDR_EXP 114
44772: PUSH
44773: LD_EXP 114
44777: PPUSH
44778: LD_VAR 0 1
44782: PPUSH
44783: LD_VAR 0 2
44787: PPUSH
44788: CALL_OW 1
44792: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44793: LD_ADDR_EXP 103
44797: PUSH
44798: LD_EXP 103
44802: PPUSH
44803: LD_VAR 0 1
44807: PPUSH
44808: LD_VAR 0 2
44812: PUSH
44813: LD_INT 0
44815: PLUS
44816: PPUSH
44817: CALL_OW 1
44821: ST_TO_ADDR
// end ;
44822: LD_VAR 0 3
44826: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44827: LD_INT 0
44829: PPUSH
// if not mc_bases [ base ] then
44830: LD_EXP 92
44834: PUSH
44835: LD_VAR 0 1
44839: ARRAY
44840: NOT
44841: IFFALSE 44845
// exit ;
44843: GO 44870
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44845: LD_ADDR_EXP 103
44849: PUSH
44850: LD_EXP 103
44854: PPUSH
44855: LD_VAR 0 1
44859: PPUSH
44860: LD_VAR 0 2
44864: PPUSH
44865: CALL_OW 1
44869: ST_TO_ADDR
// end ;
44870: LD_VAR 0 3
44874: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44875: LD_INT 0
44877: PPUSH
44878: PPUSH
44879: PPUSH
44880: PPUSH
// if not mc_bases [ base ] then
44881: LD_EXP 92
44885: PUSH
44886: LD_VAR 0 1
44890: ARRAY
44891: NOT
44892: IFFALSE 44896
// exit ;
44894: GO 44961
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44896: LD_ADDR_EXP 112
44900: PUSH
44901: LD_EXP 112
44905: PPUSH
44906: LD_VAR 0 1
44910: PUSH
44911: LD_EXP 112
44915: PUSH
44916: LD_VAR 0 1
44920: ARRAY
44921: PUSH
44922: LD_INT 1
44924: PLUS
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PPUSH
44930: LD_VAR 0 1
44934: PUSH
44935: LD_VAR 0 2
44939: PUSH
44940: LD_VAR 0 3
44944: PUSH
44945: LD_VAR 0 4
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: PPUSH
44956: CALL 55999 0 3
44960: ST_TO_ADDR
// end ;
44961: LD_VAR 0 5
44965: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44966: LD_INT 0
44968: PPUSH
// if not mc_bases [ base ] then
44969: LD_EXP 92
44973: PUSH
44974: LD_VAR 0 1
44978: ARRAY
44979: NOT
44980: IFFALSE 44984
// exit ;
44982: GO 45009
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44984: LD_ADDR_EXP 129
44988: PUSH
44989: LD_EXP 129
44993: PPUSH
44994: LD_VAR 0 1
44998: PPUSH
44999: LD_VAR 0 2
45003: PPUSH
45004: CALL_OW 1
45008: ST_TO_ADDR
// end ;
45009: LD_VAR 0 3
45013: RET
// export function MC_GetMinesField ( base ) ; begin
45014: LD_INT 0
45016: PPUSH
// result := mc_mines [ base ] ;
45017: LD_ADDR_VAR 0 2
45021: PUSH
45022: LD_EXP 105
45026: PUSH
45027: LD_VAR 0 1
45031: ARRAY
45032: ST_TO_ADDR
// end ;
45033: LD_VAR 0 2
45037: RET
// export function MC_GetProduceList ( base ) ; begin
45038: LD_INT 0
45040: PPUSH
// result := mc_produce [ base ] ;
45041: LD_ADDR_VAR 0 2
45045: PUSH
45046: LD_EXP 113
45050: PUSH
45051: LD_VAR 0 1
45055: ARRAY
45056: ST_TO_ADDR
// end ;
45057: LD_VAR 0 2
45061: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45062: LD_INT 0
45064: PPUSH
45065: PPUSH
// if not mc_bases then
45066: LD_EXP 92
45070: NOT
45071: IFFALSE 45075
// exit ;
45073: GO 45140
// if mc_bases [ base ] then
45075: LD_EXP 92
45079: PUSH
45080: LD_VAR 0 1
45084: ARRAY
45085: IFFALSE 45140
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45087: LD_ADDR_VAR 0 3
45091: PUSH
45092: LD_EXP 92
45096: PUSH
45097: LD_VAR 0 1
45101: ARRAY
45102: PPUSH
45103: LD_INT 30
45105: PUSH
45106: LD_VAR 0 2
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PPUSH
45115: CALL_OW 72
45119: ST_TO_ADDR
// if result then
45120: LD_VAR 0 3
45124: IFFALSE 45140
// result := result [ 1 ] ;
45126: LD_ADDR_VAR 0 3
45130: PUSH
45131: LD_VAR 0 3
45135: PUSH
45136: LD_INT 1
45138: ARRAY
45139: ST_TO_ADDR
// end ; end ;
45140: LD_VAR 0 3
45144: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45145: LD_INT 0
45147: PPUSH
45148: PPUSH
// if not mc_bases then
45149: LD_EXP 92
45153: NOT
45154: IFFALSE 45158
// exit ;
45156: GO 45203
// if mc_bases [ base ] then
45158: LD_EXP 92
45162: PUSH
45163: LD_VAR 0 1
45167: ARRAY
45168: IFFALSE 45203
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45170: LD_ADDR_VAR 0 3
45174: PUSH
45175: LD_EXP 92
45179: PUSH
45180: LD_VAR 0 1
45184: ARRAY
45185: PPUSH
45186: LD_INT 30
45188: PUSH
45189: LD_VAR 0 2
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PPUSH
45198: CALL_OW 72
45202: ST_TO_ADDR
// end ;
45203: LD_VAR 0 3
45207: RET
// export function MC_SetTame ( base , area ) ; begin
45208: LD_INT 0
45210: PPUSH
// if not mc_bases or not base then
45211: LD_EXP 92
45215: NOT
45216: PUSH
45217: LD_VAR 0 1
45221: NOT
45222: OR
45223: IFFALSE 45227
// exit ;
45225: GO 45252
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45227: LD_ADDR_EXP 120
45231: PUSH
45232: LD_EXP 120
45236: PPUSH
45237: LD_VAR 0 1
45241: PPUSH
45242: LD_VAR 0 2
45246: PPUSH
45247: CALL_OW 1
45251: ST_TO_ADDR
// end ;
45252: LD_VAR 0 3
45256: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45257: LD_INT 0
45259: PPUSH
45260: PPUSH
// if not mc_bases or not base then
45261: LD_EXP 92
45265: NOT
45266: PUSH
45267: LD_VAR 0 1
45271: NOT
45272: OR
45273: IFFALSE 45277
// exit ;
45275: GO 45379
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45277: LD_ADDR_VAR 0 4
45281: PUSH
45282: LD_EXP 92
45286: PUSH
45287: LD_VAR 0 1
45291: ARRAY
45292: PPUSH
45293: LD_INT 30
45295: PUSH
45296: LD_VAR 0 2
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PPUSH
45305: CALL_OW 72
45309: ST_TO_ADDR
// if not tmp then
45310: LD_VAR 0 4
45314: NOT
45315: IFFALSE 45319
// exit ;
45317: GO 45379
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45319: LD_ADDR_EXP 124
45323: PUSH
45324: LD_EXP 124
45328: PPUSH
45329: LD_VAR 0 1
45333: PPUSH
45334: LD_EXP 124
45338: PUSH
45339: LD_VAR 0 1
45343: ARRAY
45344: PPUSH
45345: LD_EXP 124
45349: PUSH
45350: LD_VAR 0 1
45354: ARRAY
45355: PUSH
45356: LD_INT 1
45358: PLUS
45359: PPUSH
45360: LD_VAR 0 4
45364: PUSH
45365: LD_INT 1
45367: ARRAY
45368: PPUSH
45369: CALL_OW 2
45373: PPUSH
45374: CALL_OW 1
45378: ST_TO_ADDR
// end ;
45379: LD_VAR 0 3
45383: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45384: LD_INT 0
45386: PPUSH
45387: PPUSH
// if not mc_bases or not base or not kinds then
45388: LD_EXP 92
45392: NOT
45393: PUSH
45394: LD_VAR 0 1
45398: NOT
45399: OR
45400: PUSH
45401: LD_VAR 0 2
45405: NOT
45406: OR
45407: IFFALSE 45411
// exit ;
45409: GO 45472
// for i in kinds do
45411: LD_ADDR_VAR 0 4
45415: PUSH
45416: LD_VAR 0 2
45420: PUSH
45421: FOR_IN
45422: IFFALSE 45470
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45424: LD_ADDR_EXP 126
45428: PUSH
45429: LD_EXP 126
45433: PPUSH
45434: LD_VAR 0 1
45438: PUSH
45439: LD_EXP 126
45443: PUSH
45444: LD_VAR 0 1
45448: ARRAY
45449: PUSH
45450: LD_INT 1
45452: PLUS
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PPUSH
45458: LD_VAR 0 4
45462: PPUSH
45463: CALL 55999 0 3
45467: ST_TO_ADDR
45468: GO 45421
45470: POP
45471: POP
// end ;
45472: LD_VAR 0 3
45476: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45477: LD_INT 0
45479: PPUSH
// if not mc_bases or not base or not areas then
45480: LD_EXP 92
45484: NOT
45485: PUSH
45486: LD_VAR 0 1
45490: NOT
45491: OR
45492: PUSH
45493: LD_VAR 0 2
45497: NOT
45498: OR
45499: IFFALSE 45503
// exit ;
45501: GO 45528
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45503: LD_ADDR_EXP 110
45507: PUSH
45508: LD_EXP 110
45512: PPUSH
45513: LD_VAR 0 1
45517: PPUSH
45518: LD_VAR 0 2
45522: PPUSH
45523: CALL_OW 1
45527: ST_TO_ADDR
// end ;
45528: LD_VAR 0 3
45532: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45533: LD_INT 0
45535: PPUSH
// if not mc_bases or not base or not teleports_exit then
45536: LD_EXP 92
45540: NOT
45541: PUSH
45542: LD_VAR 0 1
45546: NOT
45547: OR
45548: PUSH
45549: LD_VAR 0 2
45553: NOT
45554: OR
45555: IFFALSE 45559
// exit ;
45557: GO 45584
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45559: LD_ADDR_EXP 127
45563: PUSH
45564: LD_EXP 127
45568: PPUSH
45569: LD_VAR 0 1
45573: PPUSH
45574: LD_VAR 0 2
45578: PPUSH
45579: CALL_OW 1
45583: ST_TO_ADDR
// end ;
45584: LD_VAR 0 3
45588: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45589: LD_INT 0
45591: PPUSH
45592: PPUSH
45593: PPUSH
// if not mc_bases or not base or not ext_list then
45594: LD_EXP 92
45598: NOT
45599: PUSH
45600: LD_VAR 0 1
45604: NOT
45605: OR
45606: PUSH
45607: LD_VAR 0 5
45611: NOT
45612: OR
45613: IFFALSE 45617
// exit ;
45615: GO 45790
// tmp := GetFacExtXYD ( x , y , d ) ;
45617: LD_ADDR_VAR 0 8
45621: PUSH
45622: LD_VAR 0 2
45626: PPUSH
45627: LD_VAR 0 3
45631: PPUSH
45632: LD_VAR 0 4
45636: PPUSH
45637: CALL 85011 0 3
45641: ST_TO_ADDR
// if not tmp then
45642: LD_VAR 0 8
45646: NOT
45647: IFFALSE 45651
// exit ;
45649: GO 45790
// for i in tmp do
45651: LD_ADDR_VAR 0 7
45655: PUSH
45656: LD_VAR 0 8
45660: PUSH
45661: FOR_IN
45662: IFFALSE 45788
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45664: LD_ADDR_EXP 97
45668: PUSH
45669: LD_EXP 97
45673: PPUSH
45674: LD_VAR 0 1
45678: PPUSH
45679: LD_EXP 97
45683: PUSH
45684: LD_VAR 0 1
45688: ARRAY
45689: PPUSH
45690: LD_EXP 97
45694: PUSH
45695: LD_VAR 0 1
45699: ARRAY
45700: PUSH
45701: LD_INT 1
45703: PLUS
45704: PPUSH
45705: LD_VAR 0 5
45709: PUSH
45710: LD_INT 1
45712: ARRAY
45713: PUSH
45714: LD_VAR 0 7
45718: PUSH
45719: LD_INT 1
45721: ARRAY
45722: PUSH
45723: LD_VAR 0 7
45727: PUSH
45728: LD_INT 2
45730: ARRAY
45731: PUSH
45732: LD_VAR 0 7
45736: PUSH
45737: LD_INT 3
45739: ARRAY
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: PPUSH
45747: CALL_OW 2
45751: PPUSH
45752: CALL_OW 1
45756: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45757: LD_ADDR_VAR 0 5
45761: PUSH
45762: LD_VAR 0 5
45766: PPUSH
45767: LD_INT 1
45769: PPUSH
45770: CALL_OW 3
45774: ST_TO_ADDR
// if not ext_list then
45775: LD_VAR 0 5
45779: NOT
45780: IFFALSE 45786
// exit ;
45782: POP
45783: POP
45784: GO 45790
// end ;
45786: GO 45661
45788: POP
45789: POP
// end ;
45790: LD_VAR 0 6
45794: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45795: LD_INT 0
45797: PPUSH
// if not mc_bases or not base or not weapon_list then
45798: LD_EXP 92
45802: NOT
45803: PUSH
45804: LD_VAR 0 1
45808: NOT
45809: OR
45810: PUSH
45811: LD_VAR 0 2
45815: NOT
45816: OR
45817: IFFALSE 45821
// exit ;
45819: GO 45846
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45821: LD_ADDR_EXP 131
45825: PUSH
45826: LD_EXP 131
45830: PPUSH
45831: LD_VAR 0 1
45835: PPUSH
45836: LD_VAR 0 2
45840: PPUSH
45841: CALL_OW 1
45845: ST_TO_ADDR
// end ;
45846: LD_VAR 0 3
45850: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45851: LD_INT 0
45853: PPUSH
// if not mc_bases or not base or not tech_list then
45854: LD_EXP 92
45858: NOT
45859: PUSH
45860: LD_VAR 0 1
45864: NOT
45865: OR
45866: PUSH
45867: LD_VAR 0 2
45871: NOT
45872: OR
45873: IFFALSE 45877
// exit ;
45875: GO 45902
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45877: LD_ADDR_EXP 119
45881: PUSH
45882: LD_EXP 119
45886: PPUSH
45887: LD_VAR 0 1
45891: PPUSH
45892: LD_VAR 0 2
45896: PPUSH
45897: CALL_OW 1
45901: ST_TO_ADDR
// end ;
45902: LD_VAR 0 3
45906: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45907: LD_INT 0
45909: PPUSH
// if not mc_bases or not parking_area or not base then
45910: LD_EXP 92
45914: NOT
45915: PUSH
45916: LD_VAR 0 2
45920: NOT
45921: OR
45922: PUSH
45923: LD_VAR 0 1
45927: NOT
45928: OR
45929: IFFALSE 45933
// exit ;
45931: GO 45958
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45933: LD_ADDR_EXP 116
45937: PUSH
45938: LD_EXP 116
45942: PPUSH
45943: LD_VAR 0 1
45947: PPUSH
45948: LD_VAR 0 2
45952: PPUSH
45953: CALL_OW 1
45957: ST_TO_ADDR
// end ;
45958: LD_VAR 0 3
45962: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45963: LD_INT 0
45965: PPUSH
// if not mc_bases or not base or not scan_area then
45966: LD_EXP 92
45970: NOT
45971: PUSH
45972: LD_VAR 0 1
45976: NOT
45977: OR
45978: PUSH
45979: LD_VAR 0 2
45983: NOT
45984: OR
45985: IFFALSE 45989
// exit ;
45987: GO 46014
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45989: LD_ADDR_EXP 117
45993: PUSH
45994: LD_EXP 117
45998: PPUSH
45999: LD_VAR 0 1
46003: PPUSH
46004: LD_VAR 0 2
46008: PPUSH
46009: CALL_OW 1
46013: ST_TO_ADDR
// end ;
46014: LD_VAR 0 3
46018: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46019: LD_INT 0
46021: PPUSH
46022: PPUSH
// if not mc_bases or not base then
46023: LD_EXP 92
46027: NOT
46028: PUSH
46029: LD_VAR 0 1
46033: NOT
46034: OR
46035: IFFALSE 46039
// exit ;
46037: GO 46103
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46039: LD_ADDR_VAR 0 3
46043: PUSH
46044: LD_INT 1
46046: PUSH
46047: LD_INT 2
46049: PUSH
46050: LD_INT 3
46052: PUSH
46053: LD_INT 4
46055: PUSH
46056: LD_INT 11
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46066: LD_ADDR_EXP 119
46070: PUSH
46071: LD_EXP 119
46075: PPUSH
46076: LD_VAR 0 1
46080: PPUSH
46081: LD_EXP 119
46085: PUSH
46086: LD_VAR 0 1
46090: ARRAY
46091: PUSH
46092: LD_VAR 0 3
46096: DIFF
46097: PPUSH
46098: CALL_OW 1
46102: ST_TO_ADDR
// end ;
46103: LD_VAR 0 2
46107: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46108: LD_INT 0
46110: PPUSH
// result := mc_vehicles [ base ] ;
46111: LD_ADDR_VAR 0 3
46115: PUSH
46116: LD_EXP 111
46120: PUSH
46121: LD_VAR 0 1
46125: ARRAY
46126: ST_TO_ADDR
// if onlyCombat then
46127: LD_VAR 0 2
46131: IFFALSE 46309
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46133: LD_ADDR_VAR 0 3
46137: PUSH
46138: LD_VAR 0 3
46142: PUSH
46143: LD_VAR 0 3
46147: PPUSH
46148: LD_INT 2
46150: PUSH
46151: LD_INT 34
46153: PUSH
46154: LD_INT 12
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 34
46163: PUSH
46164: LD_INT 51
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 34
46173: PUSH
46174: LD_EXP 73
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 34
46185: PUSH
46186: LD_INT 32
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: PUSH
46193: LD_INT 34
46195: PUSH
46196: LD_INT 13
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 34
46205: PUSH
46206: LD_INT 52
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 34
46215: PUSH
46216: LD_EXP 78
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 34
46227: PUSH
46228: LD_INT 14
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 34
46237: PUSH
46238: LD_INT 53
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 34
46247: PUSH
46248: LD_EXP 72
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 34
46259: PUSH
46260: LD_INT 31
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 34
46269: PUSH
46270: LD_INT 48
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 34
46279: PUSH
46280: LD_INT 8
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: LIST
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: PPUSH
46303: CALL_OW 72
46307: DIFF
46308: ST_TO_ADDR
// end ; end_of_file
46309: LD_VAR 0 3
46313: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46314: LD_INT 0
46316: PPUSH
46317: PPUSH
46318: PPUSH
// if not mc_bases or not skirmish then
46319: LD_EXP 92
46323: NOT
46324: PUSH
46325: LD_EXP 90
46329: NOT
46330: OR
46331: IFFALSE 46335
// exit ;
46333: GO 46500
// for i = 1 to mc_bases do
46335: LD_ADDR_VAR 0 4
46339: PUSH
46340: DOUBLE
46341: LD_INT 1
46343: DEC
46344: ST_TO_ADDR
46345: LD_EXP 92
46349: PUSH
46350: FOR_TO
46351: IFFALSE 46498
// begin if sci in mc_bases [ i ] then
46353: LD_VAR 0 2
46357: PUSH
46358: LD_EXP 92
46362: PUSH
46363: LD_VAR 0 4
46367: ARRAY
46368: IN
46369: IFFALSE 46496
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46371: LD_ADDR_EXP 121
46375: PUSH
46376: LD_EXP 121
46380: PPUSH
46381: LD_VAR 0 4
46385: PUSH
46386: LD_EXP 121
46390: PUSH
46391: LD_VAR 0 4
46395: ARRAY
46396: PUSH
46397: LD_INT 1
46399: PLUS
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PPUSH
46405: LD_VAR 0 1
46409: PPUSH
46410: CALL 55999 0 3
46414: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46415: LD_ADDR_VAR 0 5
46419: PUSH
46420: LD_EXP 92
46424: PUSH
46425: LD_VAR 0 4
46429: ARRAY
46430: PPUSH
46431: LD_INT 2
46433: PUSH
46434: LD_INT 30
46436: PUSH
46437: LD_INT 0
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: PUSH
46444: LD_INT 30
46446: PUSH
46447: LD_INT 1
46449: PUSH
46450: EMPTY
46451: LIST
46452: LIST
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: PPUSH
46459: CALL_OW 72
46463: PPUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 74
46473: ST_TO_ADDR
// if tmp then
46474: LD_VAR 0 5
46478: IFFALSE 46494
// ComStandNearbyBuilding ( ape , tmp ) ;
46480: LD_VAR 0 1
46484: PPUSH
46485: LD_VAR 0 5
46489: PPUSH
46490: CALL 52613 0 2
// break ;
46494: GO 46498
// end ; end ;
46496: GO 46350
46498: POP
46499: POP
// end ;
46500: LD_VAR 0 3
46504: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46505: LD_INT 0
46507: PPUSH
46508: PPUSH
46509: PPUSH
// if not mc_bases or not skirmish then
46510: LD_EXP 92
46514: NOT
46515: PUSH
46516: LD_EXP 90
46520: NOT
46521: OR
46522: IFFALSE 46526
// exit ;
46524: GO 46615
// for i = 1 to mc_bases do
46526: LD_ADDR_VAR 0 4
46530: PUSH
46531: DOUBLE
46532: LD_INT 1
46534: DEC
46535: ST_TO_ADDR
46536: LD_EXP 92
46540: PUSH
46541: FOR_TO
46542: IFFALSE 46613
// begin if building in mc_busy_turret_list [ i ] then
46544: LD_VAR 0 1
46548: PUSH
46549: LD_EXP 102
46553: PUSH
46554: LD_VAR 0 4
46558: ARRAY
46559: IN
46560: IFFALSE 46611
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46562: LD_ADDR_VAR 0 5
46566: PUSH
46567: LD_EXP 102
46571: PUSH
46572: LD_VAR 0 4
46576: ARRAY
46577: PUSH
46578: LD_VAR 0 1
46582: DIFF
46583: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46584: LD_ADDR_EXP 102
46588: PUSH
46589: LD_EXP 102
46593: PPUSH
46594: LD_VAR 0 4
46598: PPUSH
46599: LD_VAR 0 5
46603: PPUSH
46604: CALL_OW 1
46608: ST_TO_ADDR
// break ;
46609: GO 46613
// end ; end ;
46611: GO 46541
46613: POP
46614: POP
// end ;
46615: LD_VAR 0 3
46619: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46620: LD_INT 0
46622: PPUSH
46623: PPUSH
46624: PPUSH
// if not mc_bases or not skirmish then
46625: LD_EXP 92
46629: NOT
46630: PUSH
46631: LD_EXP 90
46635: NOT
46636: OR
46637: IFFALSE 46641
// exit ;
46639: GO 46840
// for i = 1 to mc_bases do
46641: LD_ADDR_VAR 0 5
46645: PUSH
46646: DOUBLE
46647: LD_INT 1
46649: DEC
46650: ST_TO_ADDR
46651: LD_EXP 92
46655: PUSH
46656: FOR_TO
46657: IFFALSE 46838
// if building in mc_bases [ i ] then
46659: LD_VAR 0 1
46663: PUSH
46664: LD_EXP 92
46668: PUSH
46669: LD_VAR 0 5
46673: ARRAY
46674: IN
46675: IFFALSE 46836
// begin tmp := mc_bases [ i ] diff building ;
46677: LD_ADDR_VAR 0 6
46681: PUSH
46682: LD_EXP 92
46686: PUSH
46687: LD_VAR 0 5
46691: ARRAY
46692: PUSH
46693: LD_VAR 0 1
46697: DIFF
46698: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46699: LD_ADDR_EXP 92
46703: PUSH
46704: LD_EXP 92
46708: PPUSH
46709: LD_VAR 0 5
46713: PPUSH
46714: LD_VAR 0 6
46718: PPUSH
46719: CALL_OW 1
46723: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46724: LD_VAR 0 1
46728: PUSH
46729: LD_EXP 100
46733: PUSH
46734: LD_VAR 0 5
46738: ARRAY
46739: IN
46740: IFFALSE 46779
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46742: LD_ADDR_EXP 100
46746: PUSH
46747: LD_EXP 100
46751: PPUSH
46752: LD_VAR 0 5
46756: PPUSH
46757: LD_EXP 100
46761: PUSH
46762: LD_VAR 0 5
46766: ARRAY
46767: PUSH
46768: LD_VAR 0 1
46772: DIFF
46773: PPUSH
46774: CALL_OW 1
46778: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46779: LD_VAR 0 1
46783: PUSH
46784: LD_EXP 101
46788: PUSH
46789: LD_VAR 0 5
46793: ARRAY
46794: IN
46795: IFFALSE 46834
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46797: LD_ADDR_EXP 101
46801: PUSH
46802: LD_EXP 101
46806: PPUSH
46807: LD_VAR 0 5
46811: PPUSH
46812: LD_EXP 101
46816: PUSH
46817: LD_VAR 0 5
46821: ARRAY
46822: PUSH
46823: LD_VAR 0 1
46827: DIFF
46828: PPUSH
46829: CALL_OW 1
46833: ST_TO_ADDR
// break ;
46834: GO 46838
// end ;
46836: GO 46656
46838: POP
46839: POP
// end ;
46840: LD_VAR 0 4
46844: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46845: LD_INT 0
46847: PPUSH
46848: PPUSH
46849: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46850: LD_EXP 92
46854: NOT
46855: PUSH
46856: LD_EXP 90
46860: NOT
46861: OR
46862: PUSH
46863: LD_VAR 0 3
46867: PUSH
46868: LD_EXP 118
46872: IN
46873: NOT
46874: OR
46875: IFFALSE 46879
// exit ;
46877: GO 47002
// for i = 1 to mc_vehicles do
46879: LD_ADDR_VAR 0 6
46883: PUSH
46884: DOUBLE
46885: LD_INT 1
46887: DEC
46888: ST_TO_ADDR
46889: LD_EXP 111
46893: PUSH
46894: FOR_TO
46895: IFFALSE 47000
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46897: LD_VAR 0 2
46901: PUSH
46902: LD_EXP 111
46906: PUSH
46907: LD_VAR 0 6
46911: ARRAY
46912: IN
46913: PUSH
46914: LD_VAR 0 1
46918: PUSH
46919: LD_EXP 111
46923: PUSH
46924: LD_VAR 0 6
46928: ARRAY
46929: IN
46930: OR
46931: IFFALSE 46998
// begin tmp := mc_vehicles [ i ] diff old ;
46933: LD_ADDR_VAR 0 7
46937: PUSH
46938: LD_EXP 111
46942: PUSH
46943: LD_VAR 0 6
46947: ARRAY
46948: PUSH
46949: LD_VAR 0 2
46953: DIFF
46954: ST_TO_ADDR
// tmp := tmp diff new ;
46955: LD_ADDR_VAR 0 7
46959: PUSH
46960: LD_VAR 0 7
46964: PUSH
46965: LD_VAR 0 1
46969: DIFF
46970: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46971: LD_ADDR_EXP 111
46975: PUSH
46976: LD_EXP 111
46980: PPUSH
46981: LD_VAR 0 6
46985: PPUSH
46986: LD_VAR 0 7
46990: PPUSH
46991: CALL_OW 1
46995: ST_TO_ADDR
// break ;
46996: GO 47000
// end ;
46998: GO 46894
47000: POP
47001: POP
// end ;
47002: LD_VAR 0 5
47006: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47007: LD_INT 0
47009: PPUSH
47010: PPUSH
47011: PPUSH
47012: PPUSH
// if not mc_bases or not skirmish then
47013: LD_EXP 92
47017: NOT
47018: PUSH
47019: LD_EXP 90
47023: NOT
47024: OR
47025: IFFALSE 47029
// exit ;
47027: GO 47412
// side := GetSide ( vehicle ) ;
47029: LD_ADDR_VAR 0 5
47033: PUSH
47034: LD_VAR 0 1
47038: PPUSH
47039: CALL_OW 255
47043: ST_TO_ADDR
// for i = 1 to mc_bases do
47044: LD_ADDR_VAR 0 4
47048: PUSH
47049: DOUBLE
47050: LD_INT 1
47052: DEC
47053: ST_TO_ADDR
47054: LD_EXP 92
47058: PUSH
47059: FOR_TO
47060: IFFALSE 47410
// begin if factory in mc_bases [ i ] then
47062: LD_VAR 0 2
47066: PUSH
47067: LD_EXP 92
47071: PUSH
47072: LD_VAR 0 4
47076: ARRAY
47077: IN
47078: IFFALSE 47408
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47080: LD_EXP 114
47084: PUSH
47085: LD_VAR 0 4
47089: ARRAY
47090: PUSH
47091: LD_EXP 103
47095: PUSH
47096: LD_VAR 0 4
47100: ARRAY
47101: LESS
47102: PUSH
47103: LD_VAR 0 1
47107: PPUSH
47108: CALL_OW 264
47112: PUSH
47113: LD_INT 31
47115: PUSH
47116: LD_INT 32
47118: PUSH
47119: LD_INT 51
47121: PUSH
47122: LD_EXP 73
47126: PUSH
47127: LD_INT 12
47129: PUSH
47130: LD_INT 30
47132: PUSH
47133: LD_EXP 72
47137: PUSH
47138: LD_INT 11
47140: PUSH
47141: LD_INT 53
47143: PUSH
47144: LD_INT 14
47146: PUSH
47147: LD_EXP 76
47151: PUSH
47152: LD_INT 29
47154: PUSH
47155: LD_EXP 74
47159: PUSH
47160: LD_INT 13
47162: PUSH
47163: LD_INT 52
47165: PUSH
47166: LD_EXP 78
47170: PUSH
47171: LD_INT 48
47173: PUSH
47174: LD_INT 8
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: IN
47197: NOT
47198: AND
47199: IFFALSE 47247
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47201: LD_ADDR_EXP 114
47205: PUSH
47206: LD_EXP 114
47210: PPUSH
47211: LD_VAR 0 4
47215: PUSH
47216: LD_EXP 114
47220: PUSH
47221: LD_VAR 0 4
47225: ARRAY
47226: PUSH
47227: LD_INT 1
47229: PLUS
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PPUSH
47235: LD_VAR 0 1
47239: PPUSH
47240: CALL 55999 0 3
47244: ST_TO_ADDR
47245: GO 47291
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47247: LD_ADDR_EXP 111
47251: PUSH
47252: LD_EXP 111
47256: PPUSH
47257: LD_VAR 0 4
47261: PUSH
47262: LD_EXP 111
47266: PUSH
47267: LD_VAR 0 4
47271: ARRAY
47272: PUSH
47273: LD_INT 1
47275: PLUS
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PPUSH
47281: LD_VAR 0 1
47285: PPUSH
47286: CALL 55999 0 3
47290: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47291: LD_VAR 0 1
47295: PPUSH
47296: CALL_OW 263
47300: PUSH
47301: LD_INT 2
47303: EQUAL
47304: IFFALSE 47324
// begin repeat wait ( 0 0$1 ) ;
47306: LD_INT 35
47308: PPUSH
47309: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47313: LD_VAR 0 1
47317: PPUSH
47318: CALL_OW 312
47322: IFFALSE 47306
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47324: LD_VAR 0 1
47328: PPUSH
47329: LD_EXP 116
47333: PUSH
47334: LD_VAR 0 4
47338: ARRAY
47339: PPUSH
47340: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47344: LD_VAR 0 1
47348: PPUSH
47349: CALL_OW 263
47353: PUSH
47354: LD_INT 1
47356: NONEQUAL
47357: IFFALSE 47361
// break ;
47359: GO 47410
// repeat wait ( 0 0$1 ) ;
47361: LD_INT 35
47363: PPUSH
47364: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47368: LD_VAR 0 1
47372: PPUSH
47373: LD_EXP 116
47377: PUSH
47378: LD_VAR 0 4
47382: ARRAY
47383: PPUSH
47384: CALL_OW 308
47388: IFFALSE 47361
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47390: LD_VAR 0 1
47394: PPUSH
47395: CALL_OW 311
47399: PPUSH
47400: CALL_OW 121
// exit ;
47404: POP
47405: POP
47406: GO 47412
// end ; end ;
47408: GO 47059
47410: POP
47411: POP
// end ;
47412: LD_VAR 0 3
47416: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47417: LD_INT 0
47419: PPUSH
47420: PPUSH
47421: PPUSH
47422: PPUSH
// if not mc_bases or not skirmish then
47423: LD_EXP 92
47427: NOT
47428: PUSH
47429: LD_EXP 90
47433: NOT
47434: OR
47435: IFFALSE 47439
// exit ;
47437: GO 47792
// repeat wait ( 0 0$1 ) ;
47439: LD_INT 35
47441: PPUSH
47442: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47446: LD_VAR 0 2
47450: PPUSH
47451: LD_VAR 0 3
47455: PPUSH
47456: CALL_OW 284
47460: IFFALSE 47439
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47462: LD_VAR 0 2
47466: PPUSH
47467: LD_VAR 0 3
47471: PPUSH
47472: CALL_OW 283
47476: PUSH
47477: LD_INT 4
47479: EQUAL
47480: IFFALSE 47484
// exit ;
47482: GO 47792
// for i = 1 to mc_bases do
47484: LD_ADDR_VAR 0 7
47488: PUSH
47489: DOUBLE
47490: LD_INT 1
47492: DEC
47493: ST_TO_ADDR
47494: LD_EXP 92
47498: PUSH
47499: FOR_TO
47500: IFFALSE 47790
// begin if mc_crates_area [ i ] then
47502: LD_EXP 110
47506: PUSH
47507: LD_VAR 0 7
47511: ARRAY
47512: IFFALSE 47623
// for j in mc_crates_area [ i ] do
47514: LD_ADDR_VAR 0 8
47518: PUSH
47519: LD_EXP 110
47523: PUSH
47524: LD_VAR 0 7
47528: ARRAY
47529: PUSH
47530: FOR_IN
47531: IFFALSE 47621
// if InArea ( x , y , j ) then
47533: LD_VAR 0 2
47537: PPUSH
47538: LD_VAR 0 3
47542: PPUSH
47543: LD_VAR 0 8
47547: PPUSH
47548: CALL_OW 309
47552: IFFALSE 47619
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47554: LD_ADDR_EXP 108
47558: PUSH
47559: LD_EXP 108
47563: PPUSH
47564: LD_VAR 0 7
47568: PUSH
47569: LD_EXP 108
47573: PUSH
47574: LD_VAR 0 7
47578: ARRAY
47579: PUSH
47580: LD_INT 1
47582: PLUS
47583: PUSH
47584: EMPTY
47585: LIST
47586: LIST
47587: PPUSH
47588: LD_VAR 0 4
47592: PUSH
47593: LD_VAR 0 2
47597: PUSH
47598: LD_VAR 0 3
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: LIST
47607: PPUSH
47608: CALL 55999 0 3
47612: ST_TO_ADDR
// exit ;
47613: POP
47614: POP
47615: POP
47616: POP
47617: GO 47792
// end ;
47619: GO 47530
47621: POP
47622: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47623: LD_ADDR_VAR 0 9
47627: PUSH
47628: LD_EXP 92
47632: PUSH
47633: LD_VAR 0 7
47637: ARRAY
47638: PPUSH
47639: LD_INT 2
47641: PUSH
47642: LD_INT 30
47644: PUSH
47645: LD_INT 0
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: PUSH
47652: LD_INT 30
47654: PUSH
47655: LD_INT 1
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: LIST
47666: PPUSH
47667: CALL_OW 72
47671: ST_TO_ADDR
// if not depot then
47672: LD_VAR 0 9
47676: NOT
47677: IFFALSE 47681
// continue ;
47679: GO 47499
// for j in depot do
47681: LD_ADDR_VAR 0 8
47685: PUSH
47686: LD_VAR 0 9
47690: PUSH
47691: FOR_IN
47692: IFFALSE 47786
// if GetDistUnitXY ( j , x , y ) < 30 then
47694: LD_VAR 0 8
47698: PPUSH
47699: LD_VAR 0 2
47703: PPUSH
47704: LD_VAR 0 3
47708: PPUSH
47709: CALL_OW 297
47713: PUSH
47714: LD_INT 30
47716: LESS
47717: IFFALSE 47784
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47719: LD_ADDR_EXP 108
47723: PUSH
47724: LD_EXP 108
47728: PPUSH
47729: LD_VAR 0 7
47733: PUSH
47734: LD_EXP 108
47738: PUSH
47739: LD_VAR 0 7
47743: ARRAY
47744: PUSH
47745: LD_INT 1
47747: PLUS
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PPUSH
47753: LD_VAR 0 4
47757: PUSH
47758: LD_VAR 0 2
47762: PUSH
47763: LD_VAR 0 3
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: LIST
47772: PPUSH
47773: CALL 55999 0 3
47777: ST_TO_ADDR
// exit ;
47778: POP
47779: POP
47780: POP
47781: POP
47782: GO 47792
// end ;
47784: GO 47691
47786: POP
47787: POP
// end ;
47788: GO 47499
47790: POP
47791: POP
// end ;
47792: LD_VAR 0 6
47796: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
47801: PPUSH
47802: PPUSH
// if not mc_bases or not skirmish then
47803: LD_EXP 92
47807: NOT
47808: PUSH
47809: LD_EXP 90
47813: NOT
47814: OR
47815: IFFALSE 47819
// exit ;
47817: GO 48096
// side := GetSide ( lab ) ;
47819: LD_ADDR_VAR 0 4
47823: PUSH
47824: LD_VAR 0 2
47828: PPUSH
47829: CALL_OW 255
47833: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47834: LD_VAR 0 4
47838: PUSH
47839: LD_EXP 118
47843: IN
47844: NOT
47845: PUSH
47846: LD_EXP 119
47850: NOT
47851: OR
47852: PUSH
47853: LD_EXP 92
47857: NOT
47858: OR
47859: IFFALSE 47863
// exit ;
47861: GO 48096
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47863: LD_ADDR_EXP 119
47867: PUSH
47868: LD_EXP 119
47872: PPUSH
47873: LD_VAR 0 4
47877: PPUSH
47878: LD_EXP 119
47882: PUSH
47883: LD_VAR 0 4
47887: ARRAY
47888: PUSH
47889: LD_VAR 0 1
47893: DIFF
47894: PPUSH
47895: CALL_OW 1
47899: ST_TO_ADDR
// for i = 1 to mc_bases do
47900: LD_ADDR_VAR 0 5
47904: PUSH
47905: DOUBLE
47906: LD_INT 1
47908: DEC
47909: ST_TO_ADDR
47910: LD_EXP 92
47914: PUSH
47915: FOR_TO
47916: IFFALSE 48094
// begin if lab in mc_bases [ i ] then
47918: LD_VAR 0 2
47922: PUSH
47923: LD_EXP 92
47927: PUSH
47928: LD_VAR 0 5
47932: ARRAY
47933: IN
47934: IFFALSE 48092
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47936: LD_VAR 0 1
47940: PUSH
47941: LD_INT 11
47943: PUSH
47944: LD_INT 4
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 2
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: IN
47959: PUSH
47960: LD_EXP 122
47964: PUSH
47965: LD_VAR 0 5
47969: ARRAY
47970: AND
47971: IFFALSE 48092
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47973: LD_ADDR_VAR 0 6
47977: PUSH
47978: LD_EXP 122
47982: PUSH
47983: LD_VAR 0 5
47987: ARRAY
47988: PUSH
47989: LD_INT 1
47991: ARRAY
47992: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47993: LD_ADDR_EXP 122
47997: PUSH
47998: LD_EXP 122
48002: PPUSH
48003: LD_VAR 0 5
48007: PPUSH
48008: EMPTY
48009: PPUSH
48010: CALL_OW 1
48014: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48015: LD_VAR 0 6
48019: PPUSH
48020: LD_INT 0
48022: PPUSH
48023: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48027: LD_VAR 0 6
48031: PPUSH
48032: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48036: LD_ADDR_EXP 121
48040: PUSH
48041: LD_EXP 121
48045: PPUSH
48046: LD_VAR 0 5
48050: PPUSH
48051: LD_EXP 121
48055: PUSH
48056: LD_VAR 0 5
48060: ARRAY
48061: PPUSH
48062: LD_INT 1
48064: PPUSH
48065: LD_VAR 0 6
48069: PPUSH
48070: CALL_OW 2
48074: PPUSH
48075: CALL_OW 1
48079: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48080: LD_VAR 0 5
48084: PPUSH
48085: LD_INT 112
48087: PPUSH
48088: CALL 24925 0 2
// end ; end ; end ;
48092: GO 47915
48094: POP
48095: POP
// end ;
48096: LD_VAR 0 3
48100: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48101: LD_INT 0
48103: PPUSH
48104: PPUSH
48105: PPUSH
48106: PPUSH
48107: PPUSH
48108: PPUSH
48109: PPUSH
48110: PPUSH
// if not mc_bases or not skirmish then
48111: LD_EXP 92
48115: NOT
48116: PUSH
48117: LD_EXP 90
48121: NOT
48122: OR
48123: IFFALSE 48127
// exit ;
48125: GO 49498
// for i = 1 to mc_bases do
48127: LD_ADDR_VAR 0 3
48131: PUSH
48132: DOUBLE
48133: LD_INT 1
48135: DEC
48136: ST_TO_ADDR
48137: LD_EXP 92
48141: PUSH
48142: FOR_TO
48143: IFFALSE 49496
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48145: LD_VAR 0 1
48149: PUSH
48150: LD_EXP 92
48154: PUSH
48155: LD_VAR 0 3
48159: ARRAY
48160: IN
48161: PUSH
48162: LD_VAR 0 1
48166: PUSH
48167: LD_EXP 99
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: IN
48178: OR
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: LD_EXP 114
48189: PUSH
48190: LD_VAR 0 3
48194: ARRAY
48195: IN
48196: OR
48197: PUSH
48198: LD_VAR 0 1
48202: PUSH
48203: LD_EXP 111
48207: PUSH
48208: LD_VAR 0 3
48212: ARRAY
48213: IN
48214: OR
48215: PUSH
48216: LD_VAR 0 1
48220: PUSH
48221: LD_EXP 121
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: IN
48232: OR
48233: PUSH
48234: LD_VAR 0 1
48238: PUSH
48239: LD_EXP 122
48243: PUSH
48244: LD_VAR 0 3
48248: ARRAY
48249: IN
48250: OR
48251: IFFALSE 49494
// begin if un in mc_ape [ i ] then
48253: LD_VAR 0 1
48257: PUSH
48258: LD_EXP 121
48262: PUSH
48263: LD_VAR 0 3
48267: ARRAY
48268: IN
48269: IFFALSE 48308
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48271: LD_ADDR_EXP 121
48275: PUSH
48276: LD_EXP 121
48280: PPUSH
48281: LD_VAR 0 3
48285: PPUSH
48286: LD_EXP 121
48290: PUSH
48291: LD_VAR 0 3
48295: ARRAY
48296: PUSH
48297: LD_VAR 0 1
48301: DIFF
48302: PPUSH
48303: CALL_OW 1
48307: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48308: LD_VAR 0 1
48312: PUSH
48313: LD_EXP 122
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: IN
48324: IFFALSE 48348
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48326: LD_ADDR_EXP 122
48330: PUSH
48331: LD_EXP 122
48335: PPUSH
48336: LD_VAR 0 3
48340: PPUSH
48341: EMPTY
48342: PPUSH
48343: CALL_OW 1
48347: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48348: LD_VAR 0 1
48352: PPUSH
48353: CALL_OW 247
48357: PUSH
48358: LD_INT 2
48360: EQUAL
48361: PUSH
48362: LD_VAR 0 1
48366: PPUSH
48367: CALL_OW 110
48371: PUSH
48372: LD_INT 20
48374: EQUAL
48375: PUSH
48376: LD_VAR 0 1
48380: PUSH
48381: LD_EXP 114
48385: PUSH
48386: LD_VAR 0 3
48390: ARRAY
48391: IN
48392: OR
48393: PUSH
48394: LD_VAR 0 1
48398: PPUSH
48399: CALL_OW 264
48403: PUSH
48404: LD_INT 12
48406: PUSH
48407: LD_INT 51
48409: PUSH
48410: LD_EXP 73
48414: PUSH
48415: LD_INT 32
48417: PUSH
48418: LD_INT 13
48420: PUSH
48421: LD_INT 52
48423: PUSH
48424: LD_INT 31
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: IN
48436: OR
48437: AND
48438: IFFALSE 48746
// begin if un in mc_defender [ i ] then
48440: LD_VAR 0 1
48444: PUSH
48445: LD_EXP 114
48449: PUSH
48450: LD_VAR 0 3
48454: ARRAY
48455: IN
48456: IFFALSE 48495
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48458: LD_ADDR_EXP 114
48462: PUSH
48463: LD_EXP 114
48467: PPUSH
48468: LD_VAR 0 3
48472: PPUSH
48473: LD_EXP 114
48477: PUSH
48478: LD_VAR 0 3
48482: ARRAY
48483: PUSH
48484: LD_VAR 0 1
48488: DIFF
48489: PPUSH
48490: CALL_OW 1
48494: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48495: LD_ADDR_VAR 0 8
48499: PUSH
48500: LD_VAR 0 3
48504: PPUSH
48505: LD_INT 3
48507: PPUSH
48508: CALL 45145 0 2
48512: ST_TO_ADDR
// if fac then
48513: LD_VAR 0 8
48517: IFFALSE 48746
// begin for j in fac do
48519: LD_ADDR_VAR 0 4
48523: PUSH
48524: LD_VAR 0 8
48528: PUSH
48529: FOR_IN
48530: IFFALSE 48744
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48532: LD_ADDR_VAR 0 9
48536: PUSH
48537: LD_VAR 0 8
48541: PPUSH
48542: LD_VAR 0 1
48546: PPUSH
48547: CALL_OW 265
48551: PPUSH
48552: LD_VAR 0 1
48556: PPUSH
48557: CALL_OW 262
48561: PPUSH
48562: LD_VAR 0 1
48566: PPUSH
48567: CALL_OW 263
48571: PPUSH
48572: LD_VAR 0 1
48576: PPUSH
48577: CALL_OW 264
48581: PPUSH
48582: CALL 53531 0 5
48586: ST_TO_ADDR
// if components then
48587: LD_VAR 0 9
48591: IFFALSE 48742
// begin if GetWeapon ( un ) = ar_control_tower then
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 264
48602: PUSH
48603: LD_INT 31
48605: EQUAL
48606: IFFALSE 48723
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 311
48617: PPUSH
48618: LD_INT 0
48620: PPUSH
48621: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48625: LD_ADDR_EXP 132
48629: PUSH
48630: LD_EXP 132
48634: PPUSH
48635: LD_VAR 0 3
48639: PPUSH
48640: LD_EXP 132
48644: PUSH
48645: LD_VAR 0 3
48649: ARRAY
48650: PUSH
48651: LD_VAR 0 1
48655: PPUSH
48656: CALL_OW 311
48660: DIFF
48661: PPUSH
48662: CALL_OW 1
48666: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48667: LD_ADDR_VAR 0 7
48671: PUSH
48672: LD_EXP 113
48676: PUSH
48677: LD_VAR 0 3
48681: ARRAY
48682: PPUSH
48683: LD_INT 1
48685: PPUSH
48686: LD_VAR 0 9
48690: PPUSH
48691: CALL_OW 2
48695: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48696: LD_ADDR_EXP 113
48700: PUSH
48701: LD_EXP 113
48705: PPUSH
48706: LD_VAR 0 3
48710: PPUSH
48711: LD_VAR 0 7
48715: PPUSH
48716: CALL_OW 1
48720: ST_TO_ADDR
// end else
48721: GO 48740
// MC_InsertProduceList ( i , [ components ] ) ;
48723: LD_VAR 0 3
48727: PPUSH
48728: LD_VAR 0 9
48732: PUSH
48733: EMPTY
48734: LIST
48735: PPUSH
48736: CALL 44690 0 2
// break ;
48740: GO 48744
// end ; end ;
48742: GO 48529
48744: POP
48745: POP
// end ; end ; if GetType ( un ) = unit_building then
48746: LD_VAR 0 1
48750: PPUSH
48751: CALL_OW 247
48755: PUSH
48756: LD_INT 3
48758: EQUAL
48759: IFFALSE 49162
// begin btype := GetBType ( un ) ;
48761: LD_ADDR_VAR 0 5
48765: PUSH
48766: LD_VAR 0 1
48770: PPUSH
48771: CALL_OW 266
48775: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48776: LD_VAR 0 5
48780: PUSH
48781: LD_INT 29
48783: PUSH
48784: LD_INT 30
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: IN
48791: IFFALSE 48864
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48793: LD_VAR 0 1
48797: PPUSH
48798: CALL_OW 250
48802: PPUSH
48803: LD_VAR 0 1
48807: PPUSH
48808: CALL_OW 251
48812: PPUSH
48813: LD_VAR 0 1
48817: PPUSH
48818: CALL_OW 255
48822: PPUSH
48823: CALL_OW 440
48827: NOT
48828: IFFALSE 48864
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48830: LD_VAR 0 1
48834: PPUSH
48835: CALL_OW 250
48839: PPUSH
48840: LD_VAR 0 1
48844: PPUSH
48845: CALL_OW 251
48849: PPUSH
48850: LD_VAR 0 1
48854: PPUSH
48855: CALL_OW 255
48859: PPUSH
48860: CALL_OW 441
// end ; if btype = b_warehouse then
48864: LD_VAR 0 5
48868: PUSH
48869: LD_INT 1
48871: EQUAL
48872: IFFALSE 48890
// begin btype := b_depot ;
48874: LD_ADDR_VAR 0 5
48878: PUSH
48879: LD_INT 0
48881: ST_TO_ADDR
// pos := 1 ;
48882: LD_ADDR_VAR 0 6
48886: PUSH
48887: LD_INT 1
48889: ST_TO_ADDR
// end ; if btype = b_factory then
48890: LD_VAR 0 5
48894: PUSH
48895: LD_INT 3
48897: EQUAL
48898: IFFALSE 48916
// begin btype := b_workshop ;
48900: LD_ADDR_VAR 0 5
48904: PUSH
48905: LD_INT 2
48907: ST_TO_ADDR
// pos := 1 ;
48908: LD_ADDR_VAR 0 6
48912: PUSH
48913: LD_INT 1
48915: ST_TO_ADDR
// end ; if btype = b_barracks then
48916: LD_VAR 0 5
48920: PUSH
48921: LD_INT 5
48923: EQUAL
48924: IFFALSE 48934
// btype := b_armoury ;
48926: LD_ADDR_VAR 0 5
48930: PUSH
48931: LD_INT 4
48933: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48934: LD_VAR 0 5
48938: PUSH
48939: LD_INT 7
48941: PUSH
48942: LD_INT 8
48944: PUSH
48945: EMPTY
48946: LIST
48947: LIST
48948: IN
48949: IFFALSE 48959
// btype := b_lab ;
48951: LD_ADDR_VAR 0 5
48955: PUSH
48956: LD_INT 6
48958: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48959: LD_ADDR_EXP 97
48963: PUSH
48964: LD_EXP 97
48968: PPUSH
48969: LD_VAR 0 3
48973: PUSH
48974: LD_EXP 97
48978: PUSH
48979: LD_VAR 0 3
48983: ARRAY
48984: PUSH
48985: LD_INT 1
48987: PLUS
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PPUSH
48993: LD_VAR 0 5
48997: PUSH
48998: LD_VAR 0 1
49002: PPUSH
49003: CALL_OW 250
49007: PUSH
49008: LD_VAR 0 1
49012: PPUSH
49013: CALL_OW 251
49017: PUSH
49018: LD_VAR 0 1
49022: PPUSH
49023: CALL_OW 254
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: LIST
49032: LIST
49033: PPUSH
49034: CALL 55999 0 3
49038: ST_TO_ADDR
// if pos = 1 then
49039: LD_VAR 0 6
49043: PUSH
49044: LD_INT 1
49046: EQUAL
49047: IFFALSE 49162
// begin tmp := mc_build_list [ i ] ;
49049: LD_ADDR_VAR 0 7
49053: PUSH
49054: LD_EXP 97
49058: PUSH
49059: LD_VAR 0 3
49063: ARRAY
49064: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49065: LD_VAR 0 7
49069: PPUSH
49070: LD_INT 2
49072: PUSH
49073: LD_INT 30
49075: PUSH
49076: LD_INT 0
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 30
49085: PUSH
49086: LD_INT 1
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: LIST
49097: PPUSH
49098: CALL_OW 72
49102: IFFALSE 49112
// pos := 2 ;
49104: LD_ADDR_VAR 0 6
49108: PUSH
49109: LD_INT 2
49111: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49112: LD_ADDR_VAR 0 7
49116: PUSH
49117: LD_VAR 0 7
49121: PPUSH
49122: LD_VAR 0 6
49126: PPUSH
49127: LD_VAR 0 7
49131: PPUSH
49132: CALL 56325 0 3
49136: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49137: LD_ADDR_EXP 97
49141: PUSH
49142: LD_EXP 97
49146: PPUSH
49147: LD_VAR 0 3
49151: PPUSH
49152: LD_VAR 0 7
49156: PPUSH
49157: CALL_OW 1
49161: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49162: LD_VAR 0 1
49166: PUSH
49167: LD_EXP 92
49171: PUSH
49172: LD_VAR 0 3
49176: ARRAY
49177: IN
49178: IFFALSE 49217
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49180: LD_ADDR_EXP 92
49184: PUSH
49185: LD_EXP 92
49189: PPUSH
49190: LD_VAR 0 3
49194: PPUSH
49195: LD_EXP 92
49199: PUSH
49200: LD_VAR 0 3
49204: ARRAY
49205: PUSH
49206: LD_VAR 0 1
49210: DIFF
49211: PPUSH
49212: CALL_OW 1
49216: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49217: LD_VAR 0 1
49221: PUSH
49222: LD_EXP 99
49226: PUSH
49227: LD_VAR 0 3
49231: ARRAY
49232: IN
49233: IFFALSE 49272
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49235: LD_ADDR_EXP 99
49239: PUSH
49240: LD_EXP 99
49244: PPUSH
49245: LD_VAR 0 3
49249: PPUSH
49250: LD_EXP 99
49254: PUSH
49255: LD_VAR 0 3
49259: ARRAY
49260: PUSH
49261: LD_VAR 0 1
49265: DIFF
49266: PPUSH
49267: CALL_OW 1
49271: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49272: LD_VAR 0 1
49276: PUSH
49277: LD_EXP 111
49281: PUSH
49282: LD_VAR 0 3
49286: ARRAY
49287: IN
49288: IFFALSE 49327
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49290: LD_ADDR_EXP 111
49294: PUSH
49295: LD_EXP 111
49299: PPUSH
49300: LD_VAR 0 3
49304: PPUSH
49305: LD_EXP 111
49309: PUSH
49310: LD_VAR 0 3
49314: ARRAY
49315: PUSH
49316: LD_VAR 0 1
49320: DIFF
49321: PPUSH
49322: CALL_OW 1
49326: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49327: LD_VAR 0 1
49331: PUSH
49332: LD_EXP 114
49336: PUSH
49337: LD_VAR 0 3
49341: ARRAY
49342: IN
49343: IFFALSE 49382
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49345: LD_ADDR_EXP 114
49349: PUSH
49350: LD_EXP 114
49354: PPUSH
49355: LD_VAR 0 3
49359: PPUSH
49360: LD_EXP 114
49364: PUSH
49365: LD_VAR 0 3
49369: ARRAY
49370: PUSH
49371: LD_VAR 0 1
49375: DIFF
49376: PPUSH
49377: CALL_OW 1
49381: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49382: LD_VAR 0 1
49386: PUSH
49387: LD_EXP 101
49391: PUSH
49392: LD_VAR 0 3
49396: ARRAY
49397: IN
49398: IFFALSE 49437
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49400: LD_ADDR_EXP 101
49404: PUSH
49405: LD_EXP 101
49409: PPUSH
49410: LD_VAR 0 3
49414: PPUSH
49415: LD_EXP 101
49419: PUSH
49420: LD_VAR 0 3
49424: ARRAY
49425: PUSH
49426: LD_VAR 0 1
49430: DIFF
49431: PPUSH
49432: CALL_OW 1
49436: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49437: LD_VAR 0 1
49441: PUSH
49442: LD_EXP 100
49446: PUSH
49447: LD_VAR 0 3
49451: ARRAY
49452: IN
49453: IFFALSE 49492
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49455: LD_ADDR_EXP 100
49459: PUSH
49460: LD_EXP 100
49464: PPUSH
49465: LD_VAR 0 3
49469: PPUSH
49470: LD_EXP 100
49474: PUSH
49475: LD_VAR 0 3
49479: ARRAY
49480: PUSH
49481: LD_VAR 0 1
49485: DIFF
49486: PPUSH
49487: CALL_OW 1
49491: ST_TO_ADDR
// end ; break ;
49492: GO 49496
// end ;
49494: GO 48142
49496: POP
49497: POP
// end ;
49498: LD_VAR 0 2
49502: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49503: LD_INT 0
49505: PPUSH
49506: PPUSH
49507: PPUSH
// if not mc_bases or not skirmish then
49508: LD_EXP 92
49512: NOT
49513: PUSH
49514: LD_EXP 90
49518: NOT
49519: OR
49520: IFFALSE 49524
// exit ;
49522: GO 49739
// for i = 1 to mc_bases do
49524: LD_ADDR_VAR 0 3
49528: PUSH
49529: DOUBLE
49530: LD_INT 1
49532: DEC
49533: ST_TO_ADDR
49534: LD_EXP 92
49538: PUSH
49539: FOR_TO
49540: IFFALSE 49737
// begin if building in mc_construct_list [ i ] then
49542: LD_VAR 0 1
49546: PUSH
49547: LD_EXP 99
49551: PUSH
49552: LD_VAR 0 3
49556: ARRAY
49557: IN
49558: IFFALSE 49735
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49560: LD_ADDR_EXP 99
49564: PUSH
49565: LD_EXP 99
49569: PPUSH
49570: LD_VAR 0 3
49574: PPUSH
49575: LD_EXP 99
49579: PUSH
49580: LD_VAR 0 3
49584: ARRAY
49585: PUSH
49586: LD_VAR 0 1
49590: DIFF
49591: PPUSH
49592: CALL_OW 1
49596: ST_TO_ADDR
// if building in mc_lab [ i ] then
49597: LD_VAR 0 1
49601: PUSH
49602: LD_EXP 125
49606: PUSH
49607: LD_VAR 0 3
49611: ARRAY
49612: IN
49613: IFFALSE 49668
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49615: LD_ADDR_EXP 126
49619: PUSH
49620: LD_EXP 126
49624: PPUSH
49625: LD_VAR 0 3
49629: PPUSH
49630: LD_EXP 126
49634: PUSH
49635: LD_VAR 0 3
49639: ARRAY
49640: PPUSH
49641: LD_INT 1
49643: PPUSH
49644: LD_EXP 126
49648: PUSH
49649: LD_VAR 0 3
49653: ARRAY
49654: PPUSH
49655: LD_INT 0
49657: PPUSH
49658: CALL 55417 0 4
49662: PPUSH
49663: CALL_OW 1
49667: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49668: LD_VAR 0 1
49672: PUSH
49673: LD_EXP 92
49677: PUSH
49678: LD_VAR 0 3
49682: ARRAY
49683: IN
49684: NOT
49685: IFFALSE 49731
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49687: LD_ADDR_EXP 92
49691: PUSH
49692: LD_EXP 92
49696: PPUSH
49697: LD_VAR 0 3
49701: PUSH
49702: LD_EXP 92
49706: PUSH
49707: LD_VAR 0 3
49711: ARRAY
49712: PUSH
49713: LD_INT 1
49715: PLUS
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PPUSH
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL 55999 0 3
49730: ST_TO_ADDR
// exit ;
49731: POP
49732: POP
49733: GO 49739
// end ; end ;
49735: GO 49539
49737: POP
49738: POP
// end ;
49739: LD_VAR 0 2
49743: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49744: LD_INT 0
49746: PPUSH
49747: PPUSH
49748: PPUSH
49749: PPUSH
49750: PPUSH
49751: PPUSH
49752: PPUSH
// if not mc_bases or not skirmish then
49753: LD_EXP 92
49757: NOT
49758: PUSH
49759: LD_EXP 90
49763: NOT
49764: OR
49765: IFFALSE 49769
// exit ;
49767: GO 50430
// for i = 1 to mc_bases do
49769: LD_ADDR_VAR 0 3
49773: PUSH
49774: DOUBLE
49775: LD_INT 1
49777: DEC
49778: ST_TO_ADDR
49779: LD_EXP 92
49783: PUSH
49784: FOR_TO
49785: IFFALSE 50428
// begin if building in mc_construct_list [ i ] then
49787: LD_VAR 0 1
49791: PUSH
49792: LD_EXP 99
49796: PUSH
49797: LD_VAR 0 3
49801: ARRAY
49802: IN
49803: IFFALSE 50426
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49805: LD_ADDR_EXP 99
49809: PUSH
49810: LD_EXP 99
49814: PPUSH
49815: LD_VAR 0 3
49819: PPUSH
49820: LD_EXP 99
49824: PUSH
49825: LD_VAR 0 3
49829: ARRAY
49830: PUSH
49831: LD_VAR 0 1
49835: DIFF
49836: PPUSH
49837: CALL_OW 1
49841: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49842: LD_ADDR_EXP 92
49846: PUSH
49847: LD_EXP 92
49851: PPUSH
49852: LD_VAR 0 3
49856: PUSH
49857: LD_EXP 92
49861: PUSH
49862: LD_VAR 0 3
49866: ARRAY
49867: PUSH
49868: LD_INT 1
49870: PLUS
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PPUSH
49876: LD_VAR 0 1
49880: PPUSH
49881: CALL 55999 0 3
49885: ST_TO_ADDR
// btype := GetBType ( building ) ;
49886: LD_ADDR_VAR 0 5
49890: PUSH
49891: LD_VAR 0 1
49895: PPUSH
49896: CALL_OW 266
49900: ST_TO_ADDR
// side := GetSide ( building ) ;
49901: LD_ADDR_VAR 0 8
49905: PUSH
49906: LD_VAR 0 1
49910: PPUSH
49911: CALL_OW 255
49915: ST_TO_ADDR
// if btype = b_lab then
49916: LD_VAR 0 5
49920: PUSH
49921: LD_INT 6
49923: EQUAL
49924: IFFALSE 49974
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49926: LD_ADDR_EXP 125
49930: PUSH
49931: LD_EXP 125
49935: PPUSH
49936: LD_VAR 0 3
49940: PUSH
49941: LD_EXP 125
49945: PUSH
49946: LD_VAR 0 3
49950: ARRAY
49951: PUSH
49952: LD_INT 1
49954: PLUS
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PPUSH
49960: LD_VAR 0 1
49964: PPUSH
49965: CALL 55999 0 3
49969: ST_TO_ADDR
// exit ;
49970: POP
49971: POP
49972: GO 50430
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49974: LD_VAR 0 5
49978: PUSH
49979: LD_INT 0
49981: PUSH
49982: LD_INT 2
49984: PUSH
49985: LD_INT 4
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: LIST
49992: IN
49993: IFFALSE 50117
// begin if btype = b_armoury then
49995: LD_VAR 0 5
49999: PUSH
50000: LD_INT 4
50002: EQUAL
50003: IFFALSE 50013
// btype := b_barracks ;
50005: LD_ADDR_VAR 0 5
50009: PUSH
50010: LD_INT 5
50012: ST_TO_ADDR
// if btype = b_depot then
50013: LD_VAR 0 5
50017: PUSH
50018: LD_INT 0
50020: EQUAL
50021: IFFALSE 50031
// btype := b_warehouse ;
50023: LD_ADDR_VAR 0 5
50027: PUSH
50028: LD_INT 1
50030: ST_TO_ADDR
// if btype = b_workshop then
50031: LD_VAR 0 5
50035: PUSH
50036: LD_INT 2
50038: EQUAL
50039: IFFALSE 50049
// btype := b_factory ;
50041: LD_ADDR_VAR 0 5
50045: PUSH
50046: LD_INT 3
50048: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50049: LD_VAR 0 5
50053: PPUSH
50054: LD_VAR 0 8
50058: PPUSH
50059: CALL_OW 323
50063: PUSH
50064: LD_INT 1
50066: EQUAL
50067: IFFALSE 50113
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50069: LD_ADDR_EXP 124
50073: PUSH
50074: LD_EXP 124
50078: PPUSH
50079: LD_VAR 0 3
50083: PUSH
50084: LD_EXP 124
50088: PUSH
50089: LD_VAR 0 3
50093: ARRAY
50094: PUSH
50095: LD_INT 1
50097: PLUS
50098: PUSH
50099: EMPTY
50100: LIST
50101: LIST
50102: PPUSH
50103: LD_VAR 0 1
50107: PPUSH
50108: CALL 55999 0 3
50112: ST_TO_ADDR
// exit ;
50113: POP
50114: POP
50115: GO 50430
// end ; if btype in [ b_bunker , b_turret ] then
50117: LD_VAR 0 5
50121: PUSH
50122: LD_INT 32
50124: PUSH
50125: LD_INT 33
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: IN
50132: IFFALSE 50422
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50134: LD_ADDR_EXP 100
50138: PUSH
50139: LD_EXP 100
50143: PPUSH
50144: LD_VAR 0 3
50148: PUSH
50149: LD_EXP 100
50153: PUSH
50154: LD_VAR 0 3
50158: ARRAY
50159: PUSH
50160: LD_INT 1
50162: PLUS
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PPUSH
50168: LD_VAR 0 1
50172: PPUSH
50173: CALL 55999 0 3
50177: ST_TO_ADDR
// if btype = b_bunker then
50178: LD_VAR 0 5
50182: PUSH
50183: LD_INT 32
50185: EQUAL
50186: IFFALSE 50422
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50188: LD_ADDR_EXP 101
50192: PUSH
50193: LD_EXP 101
50197: PPUSH
50198: LD_VAR 0 3
50202: PUSH
50203: LD_EXP 101
50207: PUSH
50208: LD_VAR 0 3
50212: ARRAY
50213: PUSH
50214: LD_INT 1
50216: PLUS
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: PPUSH
50222: LD_VAR 0 1
50226: PPUSH
50227: CALL 55999 0 3
50231: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50232: LD_ADDR_VAR 0 6
50236: PUSH
50237: LD_EXP 92
50241: PUSH
50242: LD_VAR 0 3
50246: ARRAY
50247: PPUSH
50248: LD_INT 25
50250: PUSH
50251: LD_INT 1
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 3
50260: PUSH
50261: LD_INT 54
50263: PUSH
50264: EMPTY
50265: LIST
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: CALL_OW 72
50279: ST_TO_ADDR
// if tmp then
50280: LD_VAR 0 6
50284: IFFALSE 50290
// exit ;
50286: POP
50287: POP
50288: GO 50430
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50290: LD_ADDR_VAR 0 6
50294: PUSH
50295: LD_EXP 92
50299: PUSH
50300: LD_VAR 0 3
50304: ARRAY
50305: PPUSH
50306: LD_INT 2
50308: PUSH
50309: LD_INT 30
50311: PUSH
50312: LD_INT 4
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PUSH
50319: LD_INT 30
50321: PUSH
50322: LD_INT 5
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: EMPTY
50330: LIST
50331: LIST
50332: LIST
50333: PPUSH
50334: CALL_OW 72
50338: ST_TO_ADDR
// if not tmp then
50339: LD_VAR 0 6
50343: NOT
50344: IFFALSE 50350
// exit ;
50346: POP
50347: POP
50348: GO 50430
// for j in tmp do
50350: LD_ADDR_VAR 0 4
50354: PUSH
50355: LD_VAR 0 6
50359: PUSH
50360: FOR_IN
50361: IFFALSE 50420
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50363: LD_ADDR_VAR 0 7
50367: PUSH
50368: LD_VAR 0 4
50372: PPUSH
50373: CALL_OW 313
50377: PPUSH
50378: LD_INT 25
50380: PUSH
50381: LD_INT 1
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: PPUSH
50388: CALL_OW 72
50392: ST_TO_ADDR
// if units then
50393: LD_VAR 0 7
50397: IFFALSE 50418
// begin ComExitBuilding ( units [ 1 ] ) ;
50399: LD_VAR 0 7
50403: PUSH
50404: LD_INT 1
50406: ARRAY
50407: PPUSH
50408: CALL_OW 122
// exit ;
50412: POP
50413: POP
50414: POP
50415: POP
50416: GO 50430
// end ; end ;
50418: GO 50360
50420: POP
50421: POP
// end ; end ; exit ;
50422: POP
50423: POP
50424: GO 50430
// end ; end ;
50426: GO 49784
50428: POP
50429: POP
// end ;
50430: LD_VAR 0 2
50434: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50435: LD_INT 0
50437: PPUSH
50438: PPUSH
50439: PPUSH
50440: PPUSH
50441: PPUSH
50442: PPUSH
50443: PPUSH
// if not mc_bases or not skirmish then
50444: LD_EXP 92
50448: NOT
50449: PUSH
50450: LD_EXP 90
50454: NOT
50455: OR
50456: IFFALSE 50460
// exit ;
50458: GO 50691
// btype := GetBType ( building ) ;
50460: LD_ADDR_VAR 0 6
50464: PUSH
50465: LD_VAR 0 1
50469: PPUSH
50470: CALL_OW 266
50474: ST_TO_ADDR
// x := GetX ( building ) ;
50475: LD_ADDR_VAR 0 7
50479: PUSH
50480: LD_VAR 0 1
50484: PPUSH
50485: CALL_OW 250
50489: ST_TO_ADDR
// y := GetY ( building ) ;
50490: LD_ADDR_VAR 0 8
50494: PUSH
50495: LD_VAR 0 1
50499: PPUSH
50500: CALL_OW 251
50504: ST_TO_ADDR
// d := GetDir ( building ) ;
50505: LD_ADDR_VAR 0 9
50509: PUSH
50510: LD_VAR 0 1
50514: PPUSH
50515: CALL_OW 254
50519: ST_TO_ADDR
// for i = 1 to mc_bases do
50520: LD_ADDR_VAR 0 4
50524: PUSH
50525: DOUBLE
50526: LD_INT 1
50528: DEC
50529: ST_TO_ADDR
50530: LD_EXP 92
50534: PUSH
50535: FOR_TO
50536: IFFALSE 50689
// begin if not mc_build_list [ i ] then
50538: LD_EXP 97
50542: PUSH
50543: LD_VAR 0 4
50547: ARRAY
50548: NOT
50549: IFFALSE 50553
// continue ;
50551: GO 50535
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50553: LD_VAR 0 6
50557: PUSH
50558: LD_VAR 0 7
50562: PUSH
50563: LD_VAR 0 8
50567: PUSH
50568: LD_VAR 0 9
50572: PUSH
50573: EMPTY
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: PPUSH
50579: LD_EXP 97
50583: PUSH
50584: LD_VAR 0 4
50588: ARRAY
50589: PUSH
50590: LD_INT 1
50592: ARRAY
50593: PPUSH
50594: CALL 62206 0 2
50598: IFFALSE 50687
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50600: LD_ADDR_EXP 97
50604: PUSH
50605: LD_EXP 97
50609: PPUSH
50610: LD_VAR 0 4
50614: PPUSH
50615: LD_EXP 97
50619: PUSH
50620: LD_VAR 0 4
50624: ARRAY
50625: PPUSH
50626: LD_INT 1
50628: PPUSH
50629: CALL_OW 3
50633: PPUSH
50634: CALL_OW 1
50638: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50639: LD_ADDR_EXP 99
50643: PUSH
50644: LD_EXP 99
50648: PPUSH
50649: LD_VAR 0 4
50653: PUSH
50654: LD_EXP 99
50658: PUSH
50659: LD_VAR 0 4
50663: ARRAY
50664: PUSH
50665: LD_INT 1
50667: PLUS
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PPUSH
50673: LD_VAR 0 1
50677: PPUSH
50678: CALL 55999 0 3
50682: ST_TO_ADDR
// exit ;
50683: POP
50684: POP
50685: GO 50691
// end ; end ;
50687: GO 50535
50689: POP
50690: POP
// end ;
50691: LD_VAR 0 3
50695: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50696: LD_INT 0
50698: PPUSH
50699: PPUSH
50700: PPUSH
// if not mc_bases or not skirmish then
50701: LD_EXP 92
50705: NOT
50706: PUSH
50707: LD_EXP 90
50711: NOT
50712: OR
50713: IFFALSE 50717
// exit ;
50715: GO 50907
// for i = 1 to mc_bases do
50717: LD_ADDR_VAR 0 4
50721: PUSH
50722: DOUBLE
50723: LD_INT 1
50725: DEC
50726: ST_TO_ADDR
50727: LD_EXP 92
50731: PUSH
50732: FOR_TO
50733: IFFALSE 50820
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50735: LD_VAR 0 1
50739: PUSH
50740: LD_EXP 100
50744: PUSH
50745: LD_VAR 0 4
50749: ARRAY
50750: IN
50751: PUSH
50752: LD_VAR 0 1
50756: PUSH
50757: LD_EXP 101
50761: PUSH
50762: LD_VAR 0 4
50766: ARRAY
50767: IN
50768: NOT
50769: AND
50770: IFFALSE 50818
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50772: LD_ADDR_EXP 101
50776: PUSH
50777: LD_EXP 101
50781: PPUSH
50782: LD_VAR 0 4
50786: PUSH
50787: LD_EXP 101
50791: PUSH
50792: LD_VAR 0 4
50796: ARRAY
50797: PUSH
50798: LD_INT 1
50800: PLUS
50801: PUSH
50802: EMPTY
50803: LIST
50804: LIST
50805: PPUSH
50806: LD_VAR 0 1
50810: PPUSH
50811: CALL 55999 0 3
50815: ST_TO_ADDR
// break ;
50816: GO 50820
// end ; end ;
50818: GO 50732
50820: POP
50821: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50822: LD_VAR 0 1
50826: PPUSH
50827: CALL_OW 257
50831: PUSH
50832: LD_EXP 118
50836: IN
50837: PUSH
50838: LD_VAR 0 1
50842: PPUSH
50843: CALL_OW 266
50847: PUSH
50848: LD_INT 5
50850: EQUAL
50851: AND
50852: PUSH
50853: LD_VAR 0 2
50857: PPUSH
50858: CALL_OW 110
50862: PUSH
50863: LD_INT 18
50865: NONEQUAL
50866: AND
50867: IFFALSE 50907
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50869: LD_VAR 0 2
50873: PPUSH
50874: CALL_OW 257
50878: PUSH
50879: LD_INT 5
50881: PUSH
50882: LD_INT 8
50884: PUSH
50885: LD_INT 9
50887: PUSH
50888: EMPTY
50889: LIST
50890: LIST
50891: LIST
50892: IN
50893: IFFALSE 50907
// SetClass ( unit , 1 ) ;
50895: LD_VAR 0 2
50899: PPUSH
50900: LD_INT 1
50902: PPUSH
50903: CALL_OW 336
// end ;
50907: LD_VAR 0 3
50911: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50912: LD_INT 0
50914: PPUSH
50915: PPUSH
// if not mc_bases or not skirmish then
50916: LD_EXP 92
50920: NOT
50921: PUSH
50922: LD_EXP 90
50926: NOT
50927: OR
50928: IFFALSE 50932
// exit ;
50930: GO 51048
// if GetLives ( abandoned_vehicle ) > 250 then
50932: LD_VAR 0 2
50936: PPUSH
50937: CALL_OW 256
50941: PUSH
50942: LD_INT 250
50944: GREATER
50945: IFFALSE 50949
// exit ;
50947: GO 51048
// for i = 1 to mc_bases do
50949: LD_ADDR_VAR 0 6
50953: PUSH
50954: DOUBLE
50955: LD_INT 1
50957: DEC
50958: ST_TO_ADDR
50959: LD_EXP 92
50963: PUSH
50964: FOR_TO
50965: IFFALSE 51046
// begin if driver in mc_bases [ i ] then
50967: LD_VAR 0 1
50971: PUSH
50972: LD_EXP 92
50976: PUSH
50977: LD_VAR 0 6
50981: ARRAY
50982: IN
50983: IFFALSE 51044
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50985: LD_VAR 0 1
50989: PPUSH
50990: LD_EXP 92
50994: PUSH
50995: LD_VAR 0 6
50999: ARRAY
51000: PPUSH
51001: LD_INT 2
51003: PUSH
51004: LD_INT 30
51006: PUSH
51007: LD_INT 0
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: PUSH
51014: LD_INT 30
51016: PUSH
51017: LD_INT 1
51019: PUSH
51020: EMPTY
51021: LIST
51022: LIST
51023: PUSH
51024: EMPTY
51025: LIST
51026: LIST
51027: LIST
51028: PPUSH
51029: CALL_OW 72
51033: PUSH
51034: LD_INT 1
51036: ARRAY
51037: PPUSH
51038: CALL 88242 0 2
// break ;
51042: GO 51046
// end ; end ;
51044: GO 50964
51046: POP
51047: POP
// end ; end_of_file
51048: LD_VAR 0 5
51052: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51053: LD_INT 0
51055: PPUSH
51056: PPUSH
// if exist_mode then
51057: LD_VAR 0 2
51061: IFFALSE 51086
// unit := CreateCharacter ( prefix & ident ) else
51063: LD_ADDR_VAR 0 5
51067: PUSH
51068: LD_VAR 0 3
51072: PUSH
51073: LD_VAR 0 1
51077: STR
51078: PPUSH
51079: CALL_OW 34
51083: ST_TO_ADDR
51084: GO 51101
// unit := NewCharacter ( ident ) ;
51086: LD_ADDR_VAR 0 5
51090: PUSH
51091: LD_VAR 0 1
51095: PPUSH
51096: CALL_OW 25
51100: ST_TO_ADDR
// result := unit ;
51101: LD_ADDR_VAR 0 4
51105: PUSH
51106: LD_VAR 0 5
51110: ST_TO_ADDR
// end ;
51111: LD_VAR 0 4
51115: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51116: LD_INT 0
51118: PPUSH
51119: PPUSH
// if not side or not nation then
51120: LD_VAR 0 1
51124: NOT
51125: PUSH
51126: LD_VAR 0 2
51130: NOT
51131: OR
51132: IFFALSE 51136
// exit ;
51134: GO 51900
// case nation of nation_american :
51136: LD_VAR 0 2
51140: PUSH
51141: LD_INT 1
51143: DOUBLE
51144: EQUAL
51145: IFTRUE 51149
51147: GO 51363
51149: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51150: LD_ADDR_VAR 0 4
51154: PUSH
51155: LD_INT 35
51157: PUSH
51158: LD_INT 45
51160: PUSH
51161: LD_INT 46
51163: PUSH
51164: LD_INT 47
51166: PUSH
51167: LD_INT 82
51169: PUSH
51170: LD_INT 83
51172: PUSH
51173: LD_INT 84
51175: PUSH
51176: LD_INT 85
51178: PUSH
51179: LD_INT 86
51181: PUSH
51182: LD_INT 1
51184: PUSH
51185: LD_INT 2
51187: PUSH
51188: LD_INT 6
51190: PUSH
51191: LD_INT 15
51193: PUSH
51194: LD_INT 16
51196: PUSH
51197: LD_INT 7
51199: PUSH
51200: LD_INT 12
51202: PUSH
51203: LD_INT 13
51205: PUSH
51206: LD_INT 10
51208: PUSH
51209: LD_INT 14
51211: PUSH
51212: LD_INT 20
51214: PUSH
51215: LD_INT 21
51217: PUSH
51218: LD_INT 22
51220: PUSH
51221: LD_INT 25
51223: PUSH
51224: LD_INT 32
51226: PUSH
51227: LD_INT 27
51229: PUSH
51230: LD_INT 36
51232: PUSH
51233: LD_INT 69
51235: PUSH
51236: LD_INT 39
51238: PUSH
51239: LD_INT 34
51241: PUSH
51242: LD_INT 40
51244: PUSH
51245: LD_INT 48
51247: PUSH
51248: LD_INT 49
51250: PUSH
51251: LD_INT 50
51253: PUSH
51254: LD_INT 51
51256: PUSH
51257: LD_INT 52
51259: PUSH
51260: LD_INT 53
51262: PUSH
51263: LD_INT 54
51265: PUSH
51266: LD_INT 55
51268: PUSH
51269: LD_INT 56
51271: PUSH
51272: LD_INT 57
51274: PUSH
51275: LD_INT 58
51277: PUSH
51278: LD_INT 59
51280: PUSH
51281: LD_INT 60
51283: PUSH
51284: LD_INT 61
51286: PUSH
51287: LD_INT 62
51289: PUSH
51290: LD_INT 80
51292: PUSH
51293: LD_INT 82
51295: PUSH
51296: LD_INT 83
51298: PUSH
51299: LD_INT 84
51301: PUSH
51302: LD_INT 85
51304: PUSH
51305: LD_INT 86
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: LIST
51312: LIST
51313: LIST
51314: LIST
51315: LIST
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: LIST
51321: LIST
51322: LIST
51323: LIST
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: LIST
51348: LIST
51349: LIST
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: LIST
51358: LIST
51359: LIST
51360: ST_TO_ADDR
51361: GO 51824
51363: LD_INT 2
51365: DOUBLE
51366: EQUAL
51367: IFTRUE 51371
51369: GO 51593
51371: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51372: LD_ADDR_VAR 0 4
51376: PUSH
51377: LD_INT 35
51379: PUSH
51380: LD_INT 45
51382: PUSH
51383: LD_INT 46
51385: PUSH
51386: LD_INT 47
51388: PUSH
51389: LD_INT 82
51391: PUSH
51392: LD_INT 83
51394: PUSH
51395: LD_INT 84
51397: PUSH
51398: LD_INT 85
51400: PUSH
51401: LD_INT 87
51403: PUSH
51404: LD_INT 70
51406: PUSH
51407: LD_INT 1
51409: PUSH
51410: LD_INT 11
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: LD_INT 4
51418: PUSH
51419: LD_INT 5
51421: PUSH
51422: LD_INT 6
51424: PUSH
51425: LD_INT 15
51427: PUSH
51428: LD_INT 18
51430: PUSH
51431: LD_INT 7
51433: PUSH
51434: LD_INT 17
51436: PUSH
51437: LD_INT 8
51439: PUSH
51440: LD_INT 20
51442: PUSH
51443: LD_INT 21
51445: PUSH
51446: LD_INT 22
51448: PUSH
51449: LD_INT 72
51451: PUSH
51452: LD_INT 26
51454: PUSH
51455: LD_INT 69
51457: PUSH
51458: LD_INT 39
51460: PUSH
51461: LD_INT 40
51463: PUSH
51464: LD_INT 41
51466: PUSH
51467: LD_INT 42
51469: PUSH
51470: LD_INT 43
51472: PUSH
51473: LD_INT 48
51475: PUSH
51476: LD_INT 49
51478: PUSH
51479: LD_INT 50
51481: PUSH
51482: LD_INT 51
51484: PUSH
51485: LD_INT 52
51487: PUSH
51488: LD_INT 53
51490: PUSH
51491: LD_INT 54
51493: PUSH
51494: LD_INT 55
51496: PUSH
51497: LD_INT 56
51499: PUSH
51500: LD_INT 60
51502: PUSH
51503: LD_INT 61
51505: PUSH
51506: LD_INT 62
51508: PUSH
51509: LD_INT 66
51511: PUSH
51512: LD_INT 67
51514: PUSH
51515: LD_INT 68
51517: PUSH
51518: LD_INT 81
51520: PUSH
51521: LD_INT 82
51523: PUSH
51524: LD_INT 83
51526: PUSH
51527: LD_INT 84
51529: PUSH
51530: LD_INT 85
51532: PUSH
51533: LD_INT 87
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: LIST
51547: LIST
51548: LIST
51549: LIST
51550: LIST
51551: LIST
51552: LIST
51553: LIST
51554: LIST
51555: LIST
51556: LIST
51557: LIST
51558: LIST
51559: LIST
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: LIST
51567: LIST
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: LIST
51575: LIST
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: LIST
51582: LIST
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: LIST
51589: LIST
51590: ST_TO_ADDR
51591: GO 51824
51593: LD_INT 3
51595: DOUBLE
51596: EQUAL
51597: IFTRUE 51601
51599: GO 51823
51601: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51602: LD_ADDR_VAR 0 4
51606: PUSH
51607: LD_INT 46
51609: PUSH
51610: LD_INT 47
51612: PUSH
51613: LD_INT 1
51615: PUSH
51616: LD_INT 2
51618: PUSH
51619: LD_INT 82
51621: PUSH
51622: LD_INT 83
51624: PUSH
51625: LD_INT 84
51627: PUSH
51628: LD_INT 85
51630: PUSH
51631: LD_INT 86
51633: PUSH
51634: LD_INT 11
51636: PUSH
51637: LD_INT 9
51639: PUSH
51640: LD_INT 20
51642: PUSH
51643: LD_INT 19
51645: PUSH
51646: LD_INT 21
51648: PUSH
51649: LD_INT 24
51651: PUSH
51652: LD_INT 22
51654: PUSH
51655: LD_INT 25
51657: PUSH
51658: LD_INT 28
51660: PUSH
51661: LD_INT 29
51663: PUSH
51664: LD_INT 30
51666: PUSH
51667: LD_INT 31
51669: PUSH
51670: LD_INT 37
51672: PUSH
51673: LD_INT 38
51675: PUSH
51676: LD_INT 32
51678: PUSH
51679: LD_INT 27
51681: PUSH
51682: LD_INT 33
51684: PUSH
51685: LD_INT 69
51687: PUSH
51688: LD_INT 39
51690: PUSH
51691: LD_INT 34
51693: PUSH
51694: LD_INT 40
51696: PUSH
51697: LD_INT 71
51699: PUSH
51700: LD_INT 23
51702: PUSH
51703: LD_INT 44
51705: PUSH
51706: LD_INT 48
51708: PUSH
51709: LD_INT 49
51711: PUSH
51712: LD_INT 50
51714: PUSH
51715: LD_INT 51
51717: PUSH
51718: LD_INT 52
51720: PUSH
51721: LD_INT 53
51723: PUSH
51724: LD_INT 54
51726: PUSH
51727: LD_INT 55
51729: PUSH
51730: LD_INT 56
51732: PUSH
51733: LD_INT 57
51735: PUSH
51736: LD_INT 58
51738: PUSH
51739: LD_INT 59
51741: PUSH
51742: LD_INT 63
51744: PUSH
51745: LD_INT 64
51747: PUSH
51748: LD_INT 65
51750: PUSH
51751: LD_INT 82
51753: PUSH
51754: LD_INT 83
51756: PUSH
51757: LD_INT 84
51759: PUSH
51760: LD_INT 85
51762: PUSH
51763: LD_INT 86
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: LIST
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: LIST
51796: LIST
51797: LIST
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: LIST
51806: LIST
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: LIST
51812: LIST
51813: LIST
51814: LIST
51815: LIST
51816: LIST
51817: LIST
51818: LIST
51819: LIST
51820: ST_TO_ADDR
51821: GO 51824
51823: POP
// if state > - 1 and state < 3 then
51824: LD_VAR 0 3
51828: PUSH
51829: LD_INT 1
51831: NEG
51832: GREATER
51833: PUSH
51834: LD_VAR 0 3
51838: PUSH
51839: LD_INT 3
51841: LESS
51842: AND
51843: IFFALSE 51900
// for i in result do
51845: LD_ADDR_VAR 0 5
51849: PUSH
51850: LD_VAR 0 4
51854: PUSH
51855: FOR_IN
51856: IFFALSE 51898
// if GetTech ( i , side ) <> state then
51858: LD_VAR 0 5
51862: PPUSH
51863: LD_VAR 0 1
51867: PPUSH
51868: CALL_OW 321
51872: PUSH
51873: LD_VAR 0 3
51877: NONEQUAL
51878: IFFALSE 51896
// result := result diff i ;
51880: LD_ADDR_VAR 0 4
51884: PUSH
51885: LD_VAR 0 4
51889: PUSH
51890: LD_VAR 0 5
51894: DIFF
51895: ST_TO_ADDR
51896: GO 51855
51898: POP
51899: POP
// end ;
51900: LD_VAR 0 4
51904: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51905: LD_INT 0
51907: PPUSH
51908: PPUSH
51909: PPUSH
// result := true ;
51910: LD_ADDR_VAR 0 3
51914: PUSH
51915: LD_INT 1
51917: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51918: LD_ADDR_VAR 0 5
51922: PUSH
51923: LD_VAR 0 2
51927: PPUSH
51928: CALL_OW 480
51932: ST_TO_ADDR
// if not tmp then
51933: LD_VAR 0 5
51937: NOT
51938: IFFALSE 51942
// exit ;
51940: GO 51991
// for i in tmp do
51942: LD_ADDR_VAR 0 4
51946: PUSH
51947: LD_VAR 0 5
51951: PUSH
51952: FOR_IN
51953: IFFALSE 51989
// if GetTech ( i , side ) <> state_researched then
51955: LD_VAR 0 4
51959: PPUSH
51960: LD_VAR 0 1
51964: PPUSH
51965: CALL_OW 321
51969: PUSH
51970: LD_INT 2
51972: NONEQUAL
51973: IFFALSE 51987
// begin result := false ;
51975: LD_ADDR_VAR 0 3
51979: PUSH
51980: LD_INT 0
51982: ST_TO_ADDR
// exit ;
51983: POP
51984: POP
51985: GO 51991
// end ;
51987: GO 51952
51989: POP
51990: POP
// end ;
51991: LD_VAR 0 3
51995: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51996: LD_INT 0
51998: PPUSH
51999: PPUSH
52000: PPUSH
52001: PPUSH
52002: PPUSH
52003: PPUSH
52004: PPUSH
52005: PPUSH
52006: PPUSH
52007: PPUSH
52008: PPUSH
52009: PPUSH
52010: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52011: LD_VAR 0 1
52015: NOT
52016: PUSH
52017: LD_VAR 0 1
52021: PPUSH
52022: CALL_OW 257
52026: PUSH
52027: LD_INT 9
52029: NONEQUAL
52030: OR
52031: IFFALSE 52035
// exit ;
52033: GO 52608
// side := GetSide ( unit ) ;
52035: LD_ADDR_VAR 0 9
52039: PUSH
52040: LD_VAR 0 1
52044: PPUSH
52045: CALL_OW 255
52049: ST_TO_ADDR
// tech_space := tech_spacanom ;
52050: LD_ADDR_VAR 0 12
52054: PUSH
52055: LD_INT 29
52057: ST_TO_ADDR
// tech_time := tech_taurad ;
52058: LD_ADDR_VAR 0 13
52062: PUSH
52063: LD_INT 28
52065: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52066: LD_ADDR_VAR 0 11
52070: PUSH
52071: LD_VAR 0 1
52075: PPUSH
52076: CALL_OW 310
52080: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52081: LD_VAR 0 11
52085: PPUSH
52086: CALL_OW 247
52090: PUSH
52091: LD_INT 2
52093: EQUAL
52094: IFFALSE 52098
// exit ;
52096: GO 52608
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52098: LD_ADDR_VAR 0 8
52102: PUSH
52103: LD_INT 81
52105: PUSH
52106: LD_VAR 0 9
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 3
52117: PUSH
52118: LD_INT 21
52120: PUSH
52121: LD_INT 3
52123: PUSH
52124: EMPTY
52125: LIST
52126: LIST
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: PUSH
52132: EMPTY
52133: LIST
52134: LIST
52135: PPUSH
52136: CALL_OW 69
52140: ST_TO_ADDR
// if not tmp then
52141: LD_VAR 0 8
52145: NOT
52146: IFFALSE 52150
// exit ;
52148: GO 52608
// if in_unit then
52150: LD_VAR 0 11
52154: IFFALSE 52178
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52156: LD_ADDR_VAR 0 10
52160: PUSH
52161: LD_VAR 0 8
52165: PPUSH
52166: LD_VAR 0 11
52170: PPUSH
52171: CALL_OW 74
52175: ST_TO_ADDR
52176: GO 52198
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52178: LD_ADDR_VAR 0 10
52182: PUSH
52183: LD_VAR 0 8
52187: PPUSH
52188: LD_VAR 0 1
52192: PPUSH
52193: CALL_OW 74
52197: ST_TO_ADDR
// if not enemy then
52198: LD_VAR 0 10
52202: NOT
52203: IFFALSE 52207
// exit ;
52205: GO 52608
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52207: LD_VAR 0 11
52211: PUSH
52212: LD_VAR 0 11
52216: PPUSH
52217: LD_VAR 0 10
52221: PPUSH
52222: CALL_OW 296
52226: PUSH
52227: LD_INT 13
52229: GREATER
52230: AND
52231: PUSH
52232: LD_VAR 0 1
52236: PPUSH
52237: LD_VAR 0 10
52241: PPUSH
52242: CALL_OW 296
52246: PUSH
52247: LD_INT 12
52249: GREATER
52250: OR
52251: IFFALSE 52255
// exit ;
52253: GO 52608
// missile := [ 1 ] ;
52255: LD_ADDR_VAR 0 14
52259: PUSH
52260: LD_INT 1
52262: PUSH
52263: EMPTY
52264: LIST
52265: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52266: LD_VAR 0 9
52270: PPUSH
52271: LD_VAR 0 12
52275: PPUSH
52276: CALL_OW 325
52280: IFFALSE 52309
// missile := Insert ( missile , missile + 1 , 2 ) ;
52282: LD_ADDR_VAR 0 14
52286: PUSH
52287: LD_VAR 0 14
52291: PPUSH
52292: LD_VAR 0 14
52296: PUSH
52297: LD_INT 1
52299: PLUS
52300: PPUSH
52301: LD_INT 2
52303: PPUSH
52304: CALL_OW 2
52308: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52309: LD_VAR 0 9
52313: PPUSH
52314: LD_VAR 0 13
52318: PPUSH
52319: CALL_OW 325
52323: PUSH
52324: LD_VAR 0 10
52328: PPUSH
52329: CALL_OW 255
52333: PPUSH
52334: LD_VAR 0 13
52338: PPUSH
52339: CALL_OW 325
52343: NOT
52344: AND
52345: IFFALSE 52374
// missile := Insert ( missile , missile + 1 , 3 ) ;
52347: LD_ADDR_VAR 0 14
52351: PUSH
52352: LD_VAR 0 14
52356: PPUSH
52357: LD_VAR 0 14
52361: PUSH
52362: LD_INT 1
52364: PLUS
52365: PPUSH
52366: LD_INT 3
52368: PPUSH
52369: CALL_OW 2
52373: ST_TO_ADDR
// if missile < 2 then
52374: LD_VAR 0 14
52378: PUSH
52379: LD_INT 2
52381: LESS
52382: IFFALSE 52386
// exit ;
52384: GO 52608
// x := GetX ( enemy ) ;
52386: LD_ADDR_VAR 0 4
52390: PUSH
52391: LD_VAR 0 10
52395: PPUSH
52396: CALL_OW 250
52400: ST_TO_ADDR
// y := GetY ( enemy ) ;
52401: LD_ADDR_VAR 0 5
52405: PUSH
52406: LD_VAR 0 10
52410: PPUSH
52411: CALL_OW 251
52415: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52416: LD_ADDR_VAR 0 6
52420: PUSH
52421: LD_VAR 0 4
52425: PUSH
52426: LD_INT 1
52428: NEG
52429: PPUSH
52430: LD_INT 1
52432: PPUSH
52433: CALL_OW 12
52437: PLUS
52438: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52439: LD_ADDR_VAR 0 7
52443: PUSH
52444: LD_VAR 0 5
52448: PUSH
52449: LD_INT 1
52451: NEG
52452: PPUSH
52453: LD_INT 1
52455: PPUSH
52456: CALL_OW 12
52460: PLUS
52461: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52462: LD_VAR 0 6
52466: PPUSH
52467: LD_VAR 0 7
52471: PPUSH
52472: CALL_OW 488
52476: NOT
52477: IFFALSE 52499
// begin _x := x ;
52479: LD_ADDR_VAR 0 6
52483: PUSH
52484: LD_VAR 0 4
52488: ST_TO_ADDR
// _y := y ;
52489: LD_ADDR_VAR 0 7
52493: PUSH
52494: LD_VAR 0 5
52498: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52499: LD_ADDR_VAR 0 3
52503: PUSH
52504: LD_INT 1
52506: PPUSH
52507: LD_VAR 0 14
52511: PPUSH
52512: CALL_OW 12
52516: ST_TO_ADDR
// case i of 1 :
52517: LD_VAR 0 3
52521: PUSH
52522: LD_INT 1
52524: DOUBLE
52525: EQUAL
52526: IFTRUE 52530
52528: GO 52547
52530: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52531: LD_VAR 0 1
52535: PPUSH
52536: LD_VAR 0 10
52540: PPUSH
52541: CALL_OW 115
52545: GO 52608
52547: LD_INT 2
52549: DOUBLE
52550: EQUAL
52551: IFTRUE 52555
52553: GO 52577
52555: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52556: LD_VAR 0 1
52560: PPUSH
52561: LD_VAR 0 6
52565: PPUSH
52566: LD_VAR 0 7
52570: PPUSH
52571: CALL_OW 153
52575: GO 52608
52577: LD_INT 3
52579: DOUBLE
52580: EQUAL
52581: IFTRUE 52585
52583: GO 52607
52585: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52586: LD_VAR 0 1
52590: PPUSH
52591: LD_VAR 0 6
52595: PPUSH
52596: LD_VAR 0 7
52600: PPUSH
52601: CALL_OW 154
52605: GO 52608
52607: POP
// end ;
52608: LD_VAR 0 2
52612: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52613: LD_INT 0
52615: PPUSH
52616: PPUSH
52617: PPUSH
52618: PPUSH
52619: PPUSH
52620: PPUSH
// if not unit or not building then
52621: LD_VAR 0 1
52625: NOT
52626: PUSH
52627: LD_VAR 0 2
52631: NOT
52632: OR
52633: IFFALSE 52637
// exit ;
52635: GO 52795
// x := GetX ( building ) ;
52637: LD_ADDR_VAR 0 5
52641: PUSH
52642: LD_VAR 0 2
52646: PPUSH
52647: CALL_OW 250
52651: ST_TO_ADDR
// y := GetY ( building ) ;
52652: LD_ADDR_VAR 0 6
52656: PUSH
52657: LD_VAR 0 2
52661: PPUSH
52662: CALL_OW 251
52666: ST_TO_ADDR
// for i = 0 to 5 do
52667: LD_ADDR_VAR 0 4
52671: PUSH
52672: DOUBLE
52673: LD_INT 0
52675: DEC
52676: ST_TO_ADDR
52677: LD_INT 5
52679: PUSH
52680: FOR_TO
52681: IFFALSE 52793
// begin _x := ShiftX ( x , i , 3 ) ;
52683: LD_ADDR_VAR 0 7
52687: PUSH
52688: LD_VAR 0 5
52692: PPUSH
52693: LD_VAR 0 4
52697: PPUSH
52698: LD_INT 3
52700: PPUSH
52701: CALL_OW 272
52705: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52706: LD_ADDR_VAR 0 8
52710: PUSH
52711: LD_VAR 0 6
52715: PPUSH
52716: LD_VAR 0 4
52720: PPUSH
52721: LD_INT 3
52723: PPUSH
52724: CALL_OW 273
52728: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52729: LD_VAR 0 7
52733: PPUSH
52734: LD_VAR 0 8
52738: PPUSH
52739: CALL_OW 488
52743: NOT
52744: IFFALSE 52748
// continue ;
52746: GO 52680
// if HexInfo ( _x , _y ) = 0 then
52748: LD_VAR 0 7
52752: PPUSH
52753: LD_VAR 0 8
52757: PPUSH
52758: CALL_OW 428
52762: PUSH
52763: LD_INT 0
52765: EQUAL
52766: IFFALSE 52791
// begin ComMoveXY ( unit , _x , _y ) ;
52768: LD_VAR 0 1
52772: PPUSH
52773: LD_VAR 0 7
52777: PPUSH
52778: LD_VAR 0 8
52782: PPUSH
52783: CALL_OW 111
// exit ;
52787: POP
52788: POP
52789: GO 52795
// end ; end ;
52791: GO 52680
52793: POP
52794: POP
// end ;
52795: LD_VAR 0 3
52799: RET
// export function ScanBase ( side , base_area ) ; begin
52800: LD_INT 0
52802: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52803: LD_ADDR_VAR 0 3
52807: PUSH
52808: LD_VAR 0 2
52812: PPUSH
52813: LD_INT 81
52815: PUSH
52816: LD_VAR 0 1
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: PPUSH
52825: CALL_OW 70
52829: ST_TO_ADDR
// end ;
52830: LD_VAR 0 3
52834: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52835: LD_INT 0
52837: PPUSH
52838: PPUSH
52839: PPUSH
52840: PPUSH
// result := false ;
52841: LD_ADDR_VAR 0 2
52845: PUSH
52846: LD_INT 0
52848: ST_TO_ADDR
// side := GetSide ( unit ) ;
52849: LD_ADDR_VAR 0 3
52853: PUSH
52854: LD_VAR 0 1
52858: PPUSH
52859: CALL_OW 255
52863: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52864: LD_ADDR_VAR 0 4
52868: PUSH
52869: LD_VAR 0 1
52873: PPUSH
52874: CALL_OW 248
52878: ST_TO_ADDR
// case nat of 1 :
52879: LD_VAR 0 4
52883: PUSH
52884: LD_INT 1
52886: DOUBLE
52887: EQUAL
52888: IFTRUE 52892
52890: GO 52903
52892: POP
// tech := tech_lassight ; 2 :
52893: LD_ADDR_VAR 0 5
52897: PUSH
52898: LD_INT 12
52900: ST_TO_ADDR
52901: GO 52942
52903: LD_INT 2
52905: DOUBLE
52906: EQUAL
52907: IFTRUE 52911
52909: GO 52922
52911: POP
// tech := tech_mortar ; 3 :
52912: LD_ADDR_VAR 0 5
52916: PUSH
52917: LD_INT 41
52919: ST_TO_ADDR
52920: GO 52942
52922: LD_INT 3
52924: DOUBLE
52925: EQUAL
52926: IFTRUE 52930
52928: GO 52941
52930: POP
// tech := tech_bazooka ; end ;
52931: LD_ADDR_VAR 0 5
52935: PUSH
52936: LD_INT 44
52938: ST_TO_ADDR
52939: GO 52942
52941: POP
// if Researched ( side , tech ) then
52942: LD_VAR 0 3
52946: PPUSH
52947: LD_VAR 0 5
52951: PPUSH
52952: CALL_OW 325
52956: IFFALSE 52983
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52958: LD_ADDR_VAR 0 2
52962: PUSH
52963: LD_INT 5
52965: PUSH
52966: LD_INT 8
52968: PUSH
52969: LD_INT 9
52971: PUSH
52972: EMPTY
52973: LIST
52974: LIST
52975: LIST
52976: PUSH
52977: LD_VAR 0 4
52981: ARRAY
52982: ST_TO_ADDR
// end ;
52983: LD_VAR 0 2
52987: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52988: LD_INT 0
52990: PPUSH
52991: PPUSH
52992: PPUSH
// if not mines then
52993: LD_VAR 0 2
52997: NOT
52998: IFFALSE 53002
// exit ;
53000: GO 53146
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53002: LD_ADDR_VAR 0 5
53006: PUSH
53007: LD_INT 81
53009: PUSH
53010: LD_VAR 0 1
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: PUSH
53019: LD_INT 3
53021: PUSH
53022: LD_INT 21
53024: PUSH
53025: LD_INT 3
53027: PUSH
53028: EMPTY
53029: LIST
53030: LIST
53031: PUSH
53032: EMPTY
53033: LIST
53034: LIST
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: PPUSH
53040: CALL_OW 69
53044: ST_TO_ADDR
// for i in mines do
53045: LD_ADDR_VAR 0 4
53049: PUSH
53050: LD_VAR 0 2
53054: PUSH
53055: FOR_IN
53056: IFFALSE 53144
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53058: LD_VAR 0 4
53062: PUSH
53063: LD_INT 1
53065: ARRAY
53066: PPUSH
53067: LD_VAR 0 4
53071: PUSH
53072: LD_INT 2
53074: ARRAY
53075: PPUSH
53076: CALL_OW 458
53080: NOT
53081: IFFALSE 53085
// continue ;
53083: GO 53055
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53085: LD_VAR 0 4
53089: PUSH
53090: LD_INT 1
53092: ARRAY
53093: PPUSH
53094: LD_VAR 0 4
53098: PUSH
53099: LD_INT 2
53101: ARRAY
53102: PPUSH
53103: CALL_OW 428
53107: PUSH
53108: LD_VAR 0 5
53112: IN
53113: IFFALSE 53142
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53115: LD_VAR 0 4
53119: PUSH
53120: LD_INT 1
53122: ARRAY
53123: PPUSH
53124: LD_VAR 0 4
53128: PUSH
53129: LD_INT 2
53131: ARRAY
53132: PPUSH
53133: LD_VAR 0 1
53137: PPUSH
53138: CALL_OW 456
// end ;
53142: GO 53055
53144: POP
53145: POP
// end ;
53146: LD_VAR 0 3
53150: RET
// export function Count ( array ) ; var i ; begin
53151: LD_INT 0
53153: PPUSH
53154: PPUSH
// result := 0 ;
53155: LD_ADDR_VAR 0 2
53159: PUSH
53160: LD_INT 0
53162: ST_TO_ADDR
// for i in array do
53163: LD_ADDR_VAR 0 3
53167: PUSH
53168: LD_VAR 0 1
53172: PUSH
53173: FOR_IN
53174: IFFALSE 53198
// if i then
53176: LD_VAR 0 3
53180: IFFALSE 53196
// result := result + 1 ;
53182: LD_ADDR_VAR 0 2
53186: PUSH
53187: LD_VAR 0 2
53191: PUSH
53192: LD_INT 1
53194: PLUS
53195: ST_TO_ADDR
53196: GO 53173
53198: POP
53199: POP
// end ;
53200: LD_VAR 0 2
53204: RET
// export function IsEmpty ( building ) ; begin
53205: LD_INT 0
53207: PPUSH
// if not building then
53208: LD_VAR 0 1
53212: NOT
53213: IFFALSE 53217
// exit ;
53215: GO 53260
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53217: LD_ADDR_VAR 0 2
53221: PUSH
53222: LD_VAR 0 1
53226: PUSH
53227: LD_INT 22
53229: PUSH
53230: LD_VAR 0 1
53234: PPUSH
53235: CALL_OW 255
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: PUSH
53244: LD_INT 58
53246: PUSH
53247: EMPTY
53248: LIST
53249: PUSH
53250: EMPTY
53251: LIST
53252: LIST
53253: PPUSH
53254: CALL_OW 69
53258: IN
53259: ST_TO_ADDR
// end ;
53260: LD_VAR 0 2
53264: RET
// export function IsNotFull ( building ) ; begin
53265: LD_INT 0
53267: PPUSH
// if not building then
53268: LD_VAR 0 1
53272: NOT
53273: IFFALSE 53277
// exit ;
53275: GO 53296
// result := UnitsInside ( building ) < 6 ;
53277: LD_ADDR_VAR 0 2
53281: PUSH
53282: LD_VAR 0 1
53286: PPUSH
53287: CALL_OW 313
53291: PUSH
53292: LD_INT 6
53294: LESS
53295: ST_TO_ADDR
// end ;
53296: LD_VAR 0 2
53300: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53301: LD_INT 0
53303: PPUSH
53304: PPUSH
53305: PPUSH
53306: PPUSH
// tmp := [ ] ;
53307: LD_ADDR_VAR 0 3
53311: PUSH
53312: EMPTY
53313: ST_TO_ADDR
// list := [ ] ;
53314: LD_ADDR_VAR 0 5
53318: PUSH
53319: EMPTY
53320: ST_TO_ADDR
// for i = 16 to 25 do
53321: LD_ADDR_VAR 0 4
53325: PUSH
53326: DOUBLE
53327: LD_INT 16
53329: DEC
53330: ST_TO_ADDR
53331: LD_INT 25
53333: PUSH
53334: FOR_TO
53335: IFFALSE 53408
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53337: LD_ADDR_VAR 0 3
53341: PUSH
53342: LD_VAR 0 3
53346: PUSH
53347: LD_INT 22
53349: PUSH
53350: LD_VAR 0 1
53354: PPUSH
53355: CALL_OW 255
53359: PUSH
53360: EMPTY
53361: LIST
53362: LIST
53363: PUSH
53364: LD_INT 91
53366: PUSH
53367: LD_VAR 0 1
53371: PUSH
53372: LD_INT 6
53374: PUSH
53375: EMPTY
53376: LIST
53377: LIST
53378: LIST
53379: PUSH
53380: LD_INT 30
53382: PUSH
53383: LD_VAR 0 4
53387: PUSH
53388: EMPTY
53389: LIST
53390: LIST
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: LIST
53396: PUSH
53397: EMPTY
53398: LIST
53399: PPUSH
53400: CALL_OW 69
53404: ADD
53405: ST_TO_ADDR
53406: GO 53334
53408: POP
53409: POP
// for i = 1 to tmp do
53410: LD_ADDR_VAR 0 4
53414: PUSH
53415: DOUBLE
53416: LD_INT 1
53418: DEC
53419: ST_TO_ADDR
53420: LD_VAR 0 3
53424: PUSH
53425: FOR_TO
53426: IFFALSE 53514
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53428: LD_ADDR_VAR 0 5
53432: PUSH
53433: LD_VAR 0 5
53437: PUSH
53438: LD_VAR 0 3
53442: PUSH
53443: LD_VAR 0 4
53447: ARRAY
53448: PPUSH
53449: CALL_OW 266
53453: PUSH
53454: LD_VAR 0 3
53458: PUSH
53459: LD_VAR 0 4
53463: ARRAY
53464: PPUSH
53465: CALL_OW 250
53469: PUSH
53470: LD_VAR 0 3
53474: PUSH
53475: LD_VAR 0 4
53479: ARRAY
53480: PPUSH
53481: CALL_OW 251
53485: PUSH
53486: LD_VAR 0 3
53490: PUSH
53491: LD_VAR 0 4
53495: ARRAY
53496: PPUSH
53497: CALL_OW 254
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: LIST
53506: LIST
53507: PUSH
53508: EMPTY
53509: LIST
53510: ADD
53511: ST_TO_ADDR
53512: GO 53425
53514: POP
53515: POP
// result := list ;
53516: LD_ADDR_VAR 0 2
53520: PUSH
53521: LD_VAR 0 5
53525: ST_TO_ADDR
// end ;
53526: LD_VAR 0 2
53530: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53531: LD_INT 0
53533: PPUSH
53534: PPUSH
53535: PPUSH
53536: PPUSH
53537: PPUSH
53538: PPUSH
53539: PPUSH
// if not factory then
53540: LD_VAR 0 1
53544: NOT
53545: IFFALSE 53549
// exit ;
53547: GO 54142
// if control = control_apeman then
53549: LD_VAR 0 4
53553: PUSH
53554: LD_INT 5
53556: EQUAL
53557: IFFALSE 53666
// begin tmp := UnitsInside ( factory ) ;
53559: LD_ADDR_VAR 0 8
53563: PUSH
53564: LD_VAR 0 1
53568: PPUSH
53569: CALL_OW 313
53573: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53574: LD_VAR 0 8
53578: PPUSH
53579: LD_INT 25
53581: PUSH
53582: LD_INT 12
53584: PUSH
53585: EMPTY
53586: LIST
53587: LIST
53588: PPUSH
53589: CALL_OW 72
53593: NOT
53594: IFFALSE 53604
// control := control_manual ;
53596: LD_ADDR_VAR 0 4
53600: PUSH
53601: LD_INT 1
53603: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53604: LD_ADDR_VAR 0 8
53608: PUSH
53609: LD_VAR 0 1
53613: PPUSH
53614: CALL 53301 0 1
53618: ST_TO_ADDR
// if tmp then
53619: LD_VAR 0 8
53623: IFFALSE 53666
// begin for i in tmp do
53625: LD_ADDR_VAR 0 7
53629: PUSH
53630: LD_VAR 0 8
53634: PUSH
53635: FOR_IN
53636: IFFALSE 53664
// if i [ 1 ] = b_ext_radio then
53638: LD_VAR 0 7
53642: PUSH
53643: LD_INT 1
53645: ARRAY
53646: PUSH
53647: LD_INT 22
53649: EQUAL
53650: IFFALSE 53662
// begin control := control_remote ;
53652: LD_ADDR_VAR 0 4
53656: PUSH
53657: LD_INT 2
53659: ST_TO_ADDR
// break ;
53660: GO 53664
// end ;
53662: GO 53635
53664: POP
53665: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53666: LD_VAR 0 1
53670: PPUSH
53671: LD_VAR 0 2
53675: PPUSH
53676: LD_VAR 0 3
53680: PPUSH
53681: LD_VAR 0 4
53685: PPUSH
53686: LD_VAR 0 5
53690: PPUSH
53691: CALL_OW 448
53695: IFFALSE 53730
// begin result := [ chassis , engine , control , weapon ] ;
53697: LD_ADDR_VAR 0 6
53701: PUSH
53702: LD_VAR 0 2
53706: PUSH
53707: LD_VAR 0 3
53711: PUSH
53712: LD_VAR 0 4
53716: PUSH
53717: LD_VAR 0 5
53721: PUSH
53722: EMPTY
53723: LIST
53724: LIST
53725: LIST
53726: LIST
53727: ST_TO_ADDR
// exit ;
53728: GO 54142
// end ; _chassis := AvailableChassisList ( factory ) ;
53730: LD_ADDR_VAR 0 9
53734: PUSH
53735: LD_VAR 0 1
53739: PPUSH
53740: CALL_OW 475
53744: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53745: LD_ADDR_VAR 0 11
53749: PUSH
53750: LD_VAR 0 1
53754: PPUSH
53755: CALL_OW 476
53759: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53760: LD_ADDR_VAR 0 12
53764: PUSH
53765: LD_VAR 0 1
53769: PPUSH
53770: CALL_OW 477
53774: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53775: LD_ADDR_VAR 0 10
53779: PUSH
53780: LD_VAR 0 1
53784: PPUSH
53785: CALL_OW 478
53789: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53790: LD_VAR 0 9
53794: NOT
53795: PUSH
53796: LD_VAR 0 11
53800: NOT
53801: OR
53802: PUSH
53803: LD_VAR 0 12
53807: NOT
53808: OR
53809: PUSH
53810: LD_VAR 0 10
53814: NOT
53815: OR
53816: IFFALSE 53851
// begin result := [ chassis , engine , control , weapon ] ;
53818: LD_ADDR_VAR 0 6
53822: PUSH
53823: LD_VAR 0 2
53827: PUSH
53828: LD_VAR 0 3
53832: PUSH
53833: LD_VAR 0 4
53837: PUSH
53838: LD_VAR 0 5
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: LIST
53848: ST_TO_ADDR
// exit ;
53849: GO 54142
// end ; if not chassis in _chassis then
53851: LD_VAR 0 2
53855: PUSH
53856: LD_VAR 0 9
53860: IN
53861: NOT
53862: IFFALSE 53888
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53864: LD_ADDR_VAR 0 2
53868: PUSH
53869: LD_VAR 0 9
53873: PUSH
53874: LD_INT 1
53876: PPUSH
53877: LD_VAR 0 9
53881: PPUSH
53882: CALL_OW 12
53886: ARRAY
53887: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53888: LD_VAR 0 2
53892: PPUSH
53893: LD_VAR 0 3
53897: PPUSH
53898: CALL 54147 0 2
53902: NOT
53903: IFFALSE 53962
// repeat engine := _engine [ 1 ] ;
53905: LD_ADDR_VAR 0 3
53909: PUSH
53910: LD_VAR 0 11
53914: PUSH
53915: LD_INT 1
53917: ARRAY
53918: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53919: LD_ADDR_VAR 0 11
53923: PUSH
53924: LD_VAR 0 11
53928: PPUSH
53929: LD_INT 1
53931: PPUSH
53932: CALL_OW 3
53936: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53937: LD_VAR 0 2
53941: PPUSH
53942: LD_VAR 0 3
53946: PPUSH
53947: CALL 54147 0 2
53951: PUSH
53952: LD_VAR 0 11
53956: PUSH
53957: EMPTY
53958: EQUAL
53959: OR
53960: IFFALSE 53905
// if not control in _control then
53962: LD_VAR 0 4
53966: PUSH
53967: LD_VAR 0 12
53971: IN
53972: NOT
53973: IFFALSE 53999
// control := _control [ rand ( 1 , _control ) ] ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_VAR 0 12
53984: PUSH
53985: LD_INT 1
53987: PPUSH
53988: LD_VAR 0 12
53992: PPUSH
53993: CALL_OW 12
53997: ARRAY
53998: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53999: LD_VAR 0 2
54003: PPUSH
54004: LD_VAR 0 5
54008: PPUSH
54009: CALL 54367 0 2
54013: NOT
54014: IFFALSE 54073
// repeat weapon := _weapon [ 1 ] ;
54016: LD_ADDR_VAR 0 5
54020: PUSH
54021: LD_VAR 0 10
54025: PUSH
54026: LD_INT 1
54028: ARRAY
54029: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54030: LD_ADDR_VAR 0 10
54034: PUSH
54035: LD_VAR 0 10
54039: PPUSH
54040: LD_INT 1
54042: PPUSH
54043: CALL_OW 3
54047: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54048: LD_VAR 0 2
54052: PPUSH
54053: LD_VAR 0 5
54057: PPUSH
54058: CALL 54367 0 2
54062: PUSH
54063: LD_VAR 0 10
54067: PUSH
54068: EMPTY
54069: EQUAL
54070: OR
54071: IFFALSE 54016
// result := [ ] ;
54073: LD_ADDR_VAR 0 6
54077: PUSH
54078: EMPTY
54079: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54080: LD_VAR 0 1
54084: PPUSH
54085: LD_VAR 0 2
54089: PPUSH
54090: LD_VAR 0 3
54094: PPUSH
54095: LD_VAR 0 4
54099: PPUSH
54100: LD_VAR 0 5
54104: PPUSH
54105: CALL_OW 448
54109: IFFALSE 54142
// result := [ chassis , engine , control , weapon ] ;
54111: LD_ADDR_VAR 0 6
54115: PUSH
54116: LD_VAR 0 2
54120: PUSH
54121: LD_VAR 0 3
54125: PUSH
54126: LD_VAR 0 4
54130: PUSH
54131: LD_VAR 0 5
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: LIST
54140: LIST
54141: ST_TO_ADDR
// end ;
54142: LD_VAR 0 6
54146: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54147: LD_INT 0
54149: PPUSH
// if not chassis or not engine then
54150: LD_VAR 0 1
54154: NOT
54155: PUSH
54156: LD_VAR 0 2
54160: NOT
54161: OR
54162: IFFALSE 54166
// exit ;
54164: GO 54362
// case engine of engine_solar :
54166: LD_VAR 0 2
54170: PUSH
54171: LD_INT 2
54173: DOUBLE
54174: EQUAL
54175: IFTRUE 54179
54177: GO 54217
54179: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54180: LD_ADDR_VAR 0 3
54184: PUSH
54185: LD_INT 11
54187: PUSH
54188: LD_INT 12
54190: PUSH
54191: LD_INT 13
54193: PUSH
54194: LD_INT 14
54196: PUSH
54197: LD_INT 1
54199: PUSH
54200: LD_INT 2
54202: PUSH
54203: LD_INT 3
54205: PUSH
54206: EMPTY
54207: LIST
54208: LIST
54209: LIST
54210: LIST
54211: LIST
54212: LIST
54213: LIST
54214: ST_TO_ADDR
54215: GO 54346
54217: LD_INT 1
54219: DOUBLE
54220: EQUAL
54221: IFTRUE 54225
54223: GO 54287
54225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 11
54233: PUSH
54234: LD_INT 12
54236: PUSH
54237: LD_INT 13
54239: PUSH
54240: LD_INT 14
54242: PUSH
54243: LD_INT 1
54245: PUSH
54246: LD_INT 2
54248: PUSH
54249: LD_INT 3
54251: PUSH
54252: LD_INT 4
54254: PUSH
54255: LD_INT 5
54257: PUSH
54258: LD_INT 21
54260: PUSH
54261: LD_INT 23
54263: PUSH
54264: LD_INT 22
54266: PUSH
54267: LD_INT 24
54269: PUSH
54270: EMPTY
54271: LIST
54272: LIST
54273: LIST
54274: LIST
54275: LIST
54276: LIST
54277: LIST
54278: LIST
54279: LIST
54280: LIST
54281: LIST
54282: LIST
54283: LIST
54284: ST_TO_ADDR
54285: GO 54346
54287: LD_INT 3
54289: DOUBLE
54290: EQUAL
54291: IFTRUE 54295
54293: GO 54345
54295: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54296: LD_ADDR_VAR 0 3
54300: PUSH
54301: LD_INT 13
54303: PUSH
54304: LD_INT 14
54306: PUSH
54307: LD_INT 2
54309: PUSH
54310: LD_INT 3
54312: PUSH
54313: LD_INT 4
54315: PUSH
54316: LD_INT 5
54318: PUSH
54319: LD_INT 21
54321: PUSH
54322: LD_INT 22
54324: PUSH
54325: LD_INT 23
54327: PUSH
54328: LD_INT 24
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: LIST
54338: LIST
54339: LIST
54340: LIST
54341: LIST
54342: ST_TO_ADDR
54343: GO 54346
54345: POP
// result := ( chassis in result ) ;
54346: LD_ADDR_VAR 0 3
54350: PUSH
54351: LD_VAR 0 1
54355: PUSH
54356: LD_VAR 0 3
54360: IN
54361: ST_TO_ADDR
// end ;
54362: LD_VAR 0 3
54366: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54367: LD_INT 0
54369: PPUSH
// if not chassis or not weapon then
54370: LD_VAR 0 1
54374: NOT
54375: PUSH
54376: LD_VAR 0 2
54380: NOT
54381: OR
54382: IFFALSE 54386
// exit ;
54384: GO 55412
// case weapon of us_machine_gun :
54386: LD_VAR 0 2
54390: PUSH
54391: LD_INT 2
54393: DOUBLE
54394: EQUAL
54395: IFTRUE 54399
54397: GO 54429
54399: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54400: LD_ADDR_VAR 0 3
54404: PUSH
54405: LD_INT 1
54407: PUSH
54408: LD_INT 2
54410: PUSH
54411: LD_INT 3
54413: PUSH
54414: LD_INT 4
54416: PUSH
54417: LD_INT 5
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: LIST
54424: LIST
54425: LIST
54426: ST_TO_ADDR
54427: GO 55396
54429: LD_INT 3
54431: DOUBLE
54432: EQUAL
54433: IFTRUE 54437
54435: GO 54467
54437: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54438: LD_ADDR_VAR 0 3
54442: PUSH
54443: LD_INT 1
54445: PUSH
54446: LD_INT 2
54448: PUSH
54449: LD_INT 3
54451: PUSH
54452: LD_INT 4
54454: PUSH
54455: LD_INT 5
54457: PUSH
54458: EMPTY
54459: LIST
54460: LIST
54461: LIST
54462: LIST
54463: LIST
54464: ST_TO_ADDR
54465: GO 55396
54467: LD_INT 11
54469: DOUBLE
54470: EQUAL
54471: IFTRUE 54475
54473: GO 54505
54475: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54476: LD_ADDR_VAR 0 3
54480: PUSH
54481: LD_INT 1
54483: PUSH
54484: LD_INT 2
54486: PUSH
54487: LD_INT 3
54489: PUSH
54490: LD_INT 4
54492: PUSH
54493: LD_INT 5
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: LIST
54500: LIST
54501: LIST
54502: ST_TO_ADDR
54503: GO 55396
54505: LD_INT 4
54507: DOUBLE
54508: EQUAL
54509: IFTRUE 54513
54511: GO 54539
54513: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54514: LD_ADDR_VAR 0 3
54518: PUSH
54519: LD_INT 2
54521: PUSH
54522: LD_INT 3
54524: PUSH
54525: LD_INT 4
54527: PUSH
54528: LD_INT 5
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: LIST
54535: LIST
54536: ST_TO_ADDR
54537: GO 55396
54539: LD_INT 5
54541: DOUBLE
54542: EQUAL
54543: IFTRUE 54547
54545: GO 54573
54547: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54548: LD_ADDR_VAR 0 3
54552: PUSH
54553: LD_INT 2
54555: PUSH
54556: LD_INT 3
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: LD_INT 5
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: ST_TO_ADDR
54571: GO 55396
54573: LD_INT 9
54575: DOUBLE
54576: EQUAL
54577: IFTRUE 54581
54579: GO 54607
54581: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54582: LD_ADDR_VAR 0 3
54586: PUSH
54587: LD_INT 2
54589: PUSH
54590: LD_INT 3
54592: PUSH
54593: LD_INT 4
54595: PUSH
54596: LD_INT 5
54598: PUSH
54599: EMPTY
54600: LIST
54601: LIST
54602: LIST
54603: LIST
54604: ST_TO_ADDR
54605: GO 55396
54607: LD_INT 7
54609: DOUBLE
54610: EQUAL
54611: IFTRUE 54615
54613: GO 54641
54615: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54616: LD_ADDR_VAR 0 3
54620: PUSH
54621: LD_INT 2
54623: PUSH
54624: LD_INT 3
54626: PUSH
54627: LD_INT 4
54629: PUSH
54630: LD_INT 5
54632: PUSH
54633: EMPTY
54634: LIST
54635: LIST
54636: LIST
54637: LIST
54638: ST_TO_ADDR
54639: GO 55396
54641: LD_INT 12
54643: DOUBLE
54644: EQUAL
54645: IFTRUE 54649
54647: GO 54675
54649: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54650: LD_ADDR_VAR 0 3
54654: PUSH
54655: LD_INT 2
54657: PUSH
54658: LD_INT 3
54660: PUSH
54661: LD_INT 4
54663: PUSH
54664: LD_INT 5
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: LIST
54671: LIST
54672: ST_TO_ADDR
54673: GO 55396
54675: LD_INT 13
54677: DOUBLE
54678: EQUAL
54679: IFTRUE 54683
54681: GO 54709
54683: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54684: LD_ADDR_VAR 0 3
54688: PUSH
54689: LD_INT 2
54691: PUSH
54692: LD_INT 3
54694: PUSH
54695: LD_INT 4
54697: PUSH
54698: LD_INT 5
54700: PUSH
54701: EMPTY
54702: LIST
54703: LIST
54704: LIST
54705: LIST
54706: ST_TO_ADDR
54707: GO 55396
54709: LD_INT 14
54711: DOUBLE
54712: EQUAL
54713: IFTRUE 54717
54715: GO 54735
54717: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54718: LD_ADDR_VAR 0 3
54722: PUSH
54723: LD_INT 4
54725: PUSH
54726: LD_INT 5
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: ST_TO_ADDR
54733: GO 55396
54735: LD_INT 6
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54761
54743: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54744: LD_ADDR_VAR 0 3
54748: PUSH
54749: LD_INT 4
54751: PUSH
54752: LD_INT 5
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: ST_TO_ADDR
54759: GO 55396
54761: LD_INT 10
54763: DOUBLE
54764: EQUAL
54765: IFTRUE 54769
54767: GO 54787
54769: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54770: LD_ADDR_VAR 0 3
54774: PUSH
54775: LD_INT 4
54777: PUSH
54778: LD_INT 5
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: ST_TO_ADDR
54785: GO 55396
54787: LD_INT 22
54789: DOUBLE
54790: EQUAL
54791: IFTRUE 54795
54793: GO 54821
54795: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54796: LD_ADDR_VAR 0 3
54800: PUSH
54801: LD_INT 11
54803: PUSH
54804: LD_INT 12
54806: PUSH
54807: LD_INT 13
54809: PUSH
54810: LD_INT 14
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: LIST
54817: LIST
54818: ST_TO_ADDR
54819: GO 55396
54821: LD_INT 23
54823: DOUBLE
54824: EQUAL
54825: IFTRUE 54829
54827: GO 54855
54829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54830: LD_ADDR_VAR 0 3
54834: PUSH
54835: LD_INT 11
54837: PUSH
54838: LD_INT 12
54840: PUSH
54841: LD_INT 13
54843: PUSH
54844: LD_INT 14
54846: PUSH
54847: EMPTY
54848: LIST
54849: LIST
54850: LIST
54851: LIST
54852: ST_TO_ADDR
54853: GO 55396
54855: LD_INT 24
54857: DOUBLE
54858: EQUAL
54859: IFTRUE 54863
54861: GO 54889
54863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54864: LD_ADDR_VAR 0 3
54868: PUSH
54869: LD_INT 11
54871: PUSH
54872: LD_INT 12
54874: PUSH
54875: LD_INT 13
54877: PUSH
54878: LD_INT 14
54880: PUSH
54881: EMPTY
54882: LIST
54883: LIST
54884: LIST
54885: LIST
54886: ST_TO_ADDR
54887: GO 55396
54889: LD_INT 30
54891: DOUBLE
54892: EQUAL
54893: IFTRUE 54897
54895: GO 54923
54897: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54898: LD_ADDR_VAR 0 3
54902: PUSH
54903: LD_INT 11
54905: PUSH
54906: LD_INT 12
54908: PUSH
54909: LD_INT 13
54911: PUSH
54912: LD_INT 14
54914: PUSH
54915: EMPTY
54916: LIST
54917: LIST
54918: LIST
54919: LIST
54920: ST_TO_ADDR
54921: GO 55396
54923: LD_INT 25
54925: DOUBLE
54926: EQUAL
54927: IFTRUE 54931
54929: GO 54949
54931: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54932: LD_ADDR_VAR 0 3
54936: PUSH
54937: LD_INT 13
54939: PUSH
54940: LD_INT 14
54942: PUSH
54943: EMPTY
54944: LIST
54945: LIST
54946: ST_TO_ADDR
54947: GO 55396
54949: LD_INT 27
54951: DOUBLE
54952: EQUAL
54953: IFTRUE 54957
54955: GO 54975
54957: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54958: LD_ADDR_VAR 0 3
54962: PUSH
54963: LD_INT 13
54965: PUSH
54966: LD_INT 14
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: ST_TO_ADDR
54973: GO 55396
54975: LD_INT 28
54977: DOUBLE
54978: EQUAL
54979: IFTRUE 54983
54981: GO 55001
54983: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54984: LD_ADDR_VAR 0 3
54988: PUSH
54989: LD_INT 13
54991: PUSH
54992: LD_INT 14
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: ST_TO_ADDR
54999: GO 55396
55001: LD_INT 29
55003: DOUBLE
55004: EQUAL
55005: IFTRUE 55009
55007: GO 55027
55009: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55010: LD_ADDR_VAR 0 3
55014: PUSH
55015: LD_INT 13
55017: PUSH
55018: LD_INT 14
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: ST_TO_ADDR
55025: GO 55396
55027: LD_INT 31
55029: DOUBLE
55030: EQUAL
55031: IFTRUE 55035
55033: GO 55053
55035: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55036: LD_ADDR_VAR 0 3
55040: PUSH
55041: LD_INT 13
55043: PUSH
55044: LD_INT 14
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: ST_TO_ADDR
55051: GO 55396
55053: LD_INT 26
55055: DOUBLE
55056: EQUAL
55057: IFTRUE 55061
55059: GO 55079
55061: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55062: LD_ADDR_VAR 0 3
55066: PUSH
55067: LD_INT 13
55069: PUSH
55070: LD_INT 14
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: ST_TO_ADDR
55077: GO 55396
55079: LD_INT 42
55081: DOUBLE
55082: EQUAL
55083: IFTRUE 55087
55085: GO 55113
55087: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55088: LD_ADDR_VAR 0 3
55092: PUSH
55093: LD_INT 21
55095: PUSH
55096: LD_INT 22
55098: PUSH
55099: LD_INT 23
55101: PUSH
55102: LD_INT 24
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: LIST
55109: LIST
55110: ST_TO_ADDR
55111: GO 55396
55113: LD_INT 43
55115: DOUBLE
55116: EQUAL
55117: IFTRUE 55121
55119: GO 55147
55121: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55122: LD_ADDR_VAR 0 3
55126: PUSH
55127: LD_INT 21
55129: PUSH
55130: LD_INT 22
55132: PUSH
55133: LD_INT 23
55135: PUSH
55136: LD_INT 24
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: LIST
55144: ST_TO_ADDR
55145: GO 55396
55147: LD_INT 44
55149: DOUBLE
55150: EQUAL
55151: IFTRUE 55155
55153: GO 55181
55155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55156: LD_ADDR_VAR 0 3
55160: PUSH
55161: LD_INT 21
55163: PUSH
55164: LD_INT 22
55166: PUSH
55167: LD_INT 23
55169: PUSH
55170: LD_INT 24
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: LIST
55177: LIST
55178: ST_TO_ADDR
55179: GO 55396
55181: LD_INT 45
55183: DOUBLE
55184: EQUAL
55185: IFTRUE 55189
55187: GO 55215
55189: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55190: LD_ADDR_VAR 0 3
55194: PUSH
55195: LD_INT 21
55197: PUSH
55198: LD_INT 22
55200: PUSH
55201: LD_INT 23
55203: PUSH
55204: LD_INT 24
55206: PUSH
55207: EMPTY
55208: LIST
55209: LIST
55210: LIST
55211: LIST
55212: ST_TO_ADDR
55213: GO 55396
55215: LD_INT 49
55217: DOUBLE
55218: EQUAL
55219: IFTRUE 55223
55221: GO 55249
55223: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55224: LD_ADDR_VAR 0 3
55228: PUSH
55229: LD_INT 21
55231: PUSH
55232: LD_INT 22
55234: PUSH
55235: LD_INT 23
55237: PUSH
55238: LD_INT 24
55240: PUSH
55241: EMPTY
55242: LIST
55243: LIST
55244: LIST
55245: LIST
55246: ST_TO_ADDR
55247: GO 55396
55249: LD_INT 51
55251: DOUBLE
55252: EQUAL
55253: IFTRUE 55257
55255: GO 55283
55257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55258: LD_ADDR_VAR 0 3
55262: PUSH
55263: LD_INT 21
55265: PUSH
55266: LD_INT 22
55268: PUSH
55269: LD_INT 23
55271: PUSH
55272: LD_INT 24
55274: PUSH
55275: EMPTY
55276: LIST
55277: LIST
55278: LIST
55279: LIST
55280: ST_TO_ADDR
55281: GO 55396
55283: LD_INT 52
55285: DOUBLE
55286: EQUAL
55287: IFTRUE 55291
55289: GO 55317
55291: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55292: LD_ADDR_VAR 0 3
55296: PUSH
55297: LD_INT 21
55299: PUSH
55300: LD_INT 22
55302: PUSH
55303: LD_INT 23
55305: PUSH
55306: LD_INT 24
55308: PUSH
55309: EMPTY
55310: LIST
55311: LIST
55312: LIST
55313: LIST
55314: ST_TO_ADDR
55315: GO 55396
55317: LD_INT 53
55319: DOUBLE
55320: EQUAL
55321: IFTRUE 55325
55323: GO 55343
55325: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55326: LD_ADDR_VAR 0 3
55330: PUSH
55331: LD_INT 23
55333: PUSH
55334: LD_INT 24
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: ST_TO_ADDR
55341: GO 55396
55343: LD_INT 46
55345: DOUBLE
55346: EQUAL
55347: IFTRUE 55351
55349: GO 55369
55351: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55352: LD_ADDR_VAR 0 3
55356: PUSH
55357: LD_INT 23
55359: PUSH
55360: LD_INT 24
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: ST_TO_ADDR
55367: GO 55396
55369: LD_INT 47
55371: DOUBLE
55372: EQUAL
55373: IFTRUE 55377
55375: GO 55395
55377: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55378: LD_ADDR_VAR 0 3
55382: PUSH
55383: LD_INT 23
55385: PUSH
55386: LD_INT 24
55388: PUSH
55389: EMPTY
55390: LIST
55391: LIST
55392: ST_TO_ADDR
55393: GO 55396
55395: POP
// result := ( chassis in result ) ;
55396: LD_ADDR_VAR 0 3
55400: PUSH
55401: LD_VAR 0 1
55405: PUSH
55406: LD_VAR 0 3
55410: IN
55411: ST_TO_ADDR
// end ;
55412: LD_VAR 0 3
55416: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55417: LD_INT 0
55419: PPUSH
55420: PPUSH
55421: PPUSH
55422: PPUSH
55423: PPUSH
55424: PPUSH
55425: PPUSH
// result := array ;
55426: LD_ADDR_VAR 0 5
55430: PUSH
55431: LD_VAR 0 1
55435: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55436: LD_VAR 0 1
55440: NOT
55441: PUSH
55442: LD_VAR 0 2
55446: NOT
55447: OR
55448: PUSH
55449: LD_VAR 0 3
55453: NOT
55454: OR
55455: PUSH
55456: LD_VAR 0 2
55460: PUSH
55461: LD_VAR 0 1
55465: GREATER
55466: OR
55467: PUSH
55468: LD_VAR 0 3
55472: PUSH
55473: LD_VAR 0 1
55477: GREATER
55478: OR
55479: IFFALSE 55483
// exit ;
55481: GO 55779
// if direction then
55483: LD_VAR 0 4
55487: IFFALSE 55551
// begin d := 1 ;
55489: LD_ADDR_VAR 0 9
55493: PUSH
55494: LD_INT 1
55496: ST_TO_ADDR
// if i_from > i_to then
55497: LD_VAR 0 2
55501: PUSH
55502: LD_VAR 0 3
55506: GREATER
55507: IFFALSE 55533
// length := ( array - i_from ) + i_to else
55509: LD_ADDR_VAR 0 11
55513: PUSH
55514: LD_VAR 0 1
55518: PUSH
55519: LD_VAR 0 2
55523: MINUS
55524: PUSH
55525: LD_VAR 0 3
55529: PLUS
55530: ST_TO_ADDR
55531: GO 55549
// length := i_to - i_from ;
55533: LD_ADDR_VAR 0 11
55537: PUSH
55538: LD_VAR 0 3
55542: PUSH
55543: LD_VAR 0 2
55547: MINUS
55548: ST_TO_ADDR
// end else
55549: GO 55612
// begin d := - 1 ;
55551: LD_ADDR_VAR 0 9
55555: PUSH
55556: LD_INT 1
55558: NEG
55559: ST_TO_ADDR
// if i_from > i_to then
55560: LD_VAR 0 2
55564: PUSH
55565: LD_VAR 0 3
55569: GREATER
55570: IFFALSE 55590
// length := i_from - i_to else
55572: LD_ADDR_VAR 0 11
55576: PUSH
55577: LD_VAR 0 2
55581: PUSH
55582: LD_VAR 0 3
55586: MINUS
55587: ST_TO_ADDR
55588: GO 55612
// length := ( array - i_to ) + i_from ;
55590: LD_ADDR_VAR 0 11
55594: PUSH
55595: LD_VAR 0 1
55599: PUSH
55600: LD_VAR 0 3
55604: MINUS
55605: PUSH
55606: LD_VAR 0 2
55610: PLUS
55611: ST_TO_ADDR
// end ; if not length then
55612: LD_VAR 0 11
55616: NOT
55617: IFFALSE 55621
// exit ;
55619: GO 55779
// tmp := array ;
55621: LD_ADDR_VAR 0 10
55625: PUSH
55626: LD_VAR 0 1
55630: ST_TO_ADDR
// for i = 1 to length do
55631: LD_ADDR_VAR 0 6
55635: PUSH
55636: DOUBLE
55637: LD_INT 1
55639: DEC
55640: ST_TO_ADDR
55641: LD_VAR 0 11
55645: PUSH
55646: FOR_TO
55647: IFFALSE 55767
// begin for j = 1 to array do
55649: LD_ADDR_VAR 0 7
55653: PUSH
55654: DOUBLE
55655: LD_INT 1
55657: DEC
55658: ST_TO_ADDR
55659: LD_VAR 0 1
55663: PUSH
55664: FOR_TO
55665: IFFALSE 55753
// begin k := j + d ;
55667: LD_ADDR_VAR 0 8
55671: PUSH
55672: LD_VAR 0 7
55676: PUSH
55677: LD_VAR 0 9
55681: PLUS
55682: ST_TO_ADDR
// if k > array then
55683: LD_VAR 0 8
55687: PUSH
55688: LD_VAR 0 1
55692: GREATER
55693: IFFALSE 55703
// k := 1 ;
55695: LD_ADDR_VAR 0 8
55699: PUSH
55700: LD_INT 1
55702: ST_TO_ADDR
// if not k then
55703: LD_VAR 0 8
55707: NOT
55708: IFFALSE 55720
// k := array ;
55710: LD_ADDR_VAR 0 8
55714: PUSH
55715: LD_VAR 0 1
55719: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55720: LD_ADDR_VAR 0 10
55724: PUSH
55725: LD_VAR 0 10
55729: PPUSH
55730: LD_VAR 0 8
55734: PPUSH
55735: LD_VAR 0 1
55739: PUSH
55740: LD_VAR 0 7
55744: ARRAY
55745: PPUSH
55746: CALL_OW 1
55750: ST_TO_ADDR
// end ;
55751: GO 55664
55753: POP
55754: POP
// array := tmp ;
55755: LD_ADDR_VAR 0 1
55759: PUSH
55760: LD_VAR 0 10
55764: ST_TO_ADDR
// end ;
55765: GO 55646
55767: POP
55768: POP
// result := array ;
55769: LD_ADDR_VAR 0 5
55773: PUSH
55774: LD_VAR 0 1
55778: ST_TO_ADDR
// end ;
55779: LD_VAR 0 5
55783: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55784: LD_INT 0
55786: PPUSH
55787: PPUSH
// result := 0 ;
55788: LD_ADDR_VAR 0 3
55792: PUSH
55793: LD_INT 0
55795: ST_TO_ADDR
// if not array or not value in array then
55796: LD_VAR 0 1
55800: NOT
55801: PUSH
55802: LD_VAR 0 2
55806: PUSH
55807: LD_VAR 0 1
55811: IN
55812: NOT
55813: OR
55814: IFFALSE 55818
// exit ;
55816: GO 55872
// for i = 1 to array do
55818: LD_ADDR_VAR 0 4
55822: PUSH
55823: DOUBLE
55824: LD_INT 1
55826: DEC
55827: ST_TO_ADDR
55828: LD_VAR 0 1
55832: PUSH
55833: FOR_TO
55834: IFFALSE 55870
// if value = array [ i ] then
55836: LD_VAR 0 2
55840: PUSH
55841: LD_VAR 0 1
55845: PUSH
55846: LD_VAR 0 4
55850: ARRAY
55851: EQUAL
55852: IFFALSE 55868
// begin result := i ;
55854: LD_ADDR_VAR 0 3
55858: PUSH
55859: LD_VAR 0 4
55863: ST_TO_ADDR
// exit ;
55864: POP
55865: POP
55866: GO 55872
// end ;
55868: GO 55833
55870: POP
55871: POP
// end ;
55872: LD_VAR 0 3
55876: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55877: LD_INT 0
55879: PPUSH
// vc_chassis := chassis ;
55880: LD_ADDR_OWVAR 37
55884: PUSH
55885: LD_VAR 0 1
55889: ST_TO_ADDR
// vc_engine := engine ;
55890: LD_ADDR_OWVAR 39
55894: PUSH
55895: LD_VAR 0 2
55899: ST_TO_ADDR
// vc_control := control ;
55900: LD_ADDR_OWVAR 38
55904: PUSH
55905: LD_VAR 0 3
55909: ST_TO_ADDR
// vc_weapon := weapon ;
55910: LD_ADDR_OWVAR 40
55914: PUSH
55915: LD_VAR 0 4
55919: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55920: LD_ADDR_OWVAR 41
55924: PUSH
55925: LD_VAR 0 5
55929: ST_TO_ADDR
// end ;
55930: LD_VAR 0 6
55934: RET
// export function WantPlant ( unit ) ; var task ; begin
55935: LD_INT 0
55937: PPUSH
55938: PPUSH
// result := false ;
55939: LD_ADDR_VAR 0 2
55943: PUSH
55944: LD_INT 0
55946: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55947: LD_ADDR_VAR 0 3
55951: PUSH
55952: LD_VAR 0 1
55956: PPUSH
55957: CALL_OW 437
55961: ST_TO_ADDR
// if task then
55962: LD_VAR 0 3
55966: IFFALSE 55994
// if task [ 1 ] [ 1 ] = p then
55968: LD_VAR 0 3
55972: PUSH
55973: LD_INT 1
55975: ARRAY
55976: PUSH
55977: LD_INT 1
55979: ARRAY
55980: PUSH
55981: LD_STRING p
55983: EQUAL
55984: IFFALSE 55994
// result := true ;
55986: LD_ADDR_VAR 0 2
55990: PUSH
55991: LD_INT 1
55993: ST_TO_ADDR
// end ;
55994: LD_VAR 0 2
55998: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55999: LD_INT 0
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
// if pos < 1 then
56005: LD_VAR 0 2
56009: PUSH
56010: LD_INT 1
56012: LESS
56013: IFFALSE 56017
// exit ;
56015: GO 56320
// if pos = 1 then
56017: LD_VAR 0 2
56021: PUSH
56022: LD_INT 1
56024: EQUAL
56025: IFFALSE 56058
// result := Replace ( arr , pos [ 1 ] , value ) else
56027: LD_ADDR_VAR 0 4
56031: PUSH
56032: LD_VAR 0 1
56036: PPUSH
56037: LD_VAR 0 2
56041: PUSH
56042: LD_INT 1
56044: ARRAY
56045: PPUSH
56046: LD_VAR 0 3
56050: PPUSH
56051: CALL_OW 1
56055: ST_TO_ADDR
56056: GO 56320
// begin tmp := arr ;
56058: LD_ADDR_VAR 0 6
56062: PUSH
56063: LD_VAR 0 1
56067: ST_TO_ADDR
// s_arr := [ tmp ] ;
56068: LD_ADDR_VAR 0 7
56072: PUSH
56073: LD_VAR 0 6
56077: PUSH
56078: EMPTY
56079: LIST
56080: ST_TO_ADDR
// for i = 1 to pos - 1 do
56081: LD_ADDR_VAR 0 5
56085: PUSH
56086: DOUBLE
56087: LD_INT 1
56089: DEC
56090: ST_TO_ADDR
56091: LD_VAR 0 2
56095: PUSH
56096: LD_INT 1
56098: MINUS
56099: PUSH
56100: FOR_TO
56101: IFFALSE 56146
// begin tmp := tmp [ pos [ i ] ] ;
56103: LD_ADDR_VAR 0 6
56107: PUSH
56108: LD_VAR 0 6
56112: PUSH
56113: LD_VAR 0 2
56117: PUSH
56118: LD_VAR 0 5
56122: ARRAY
56123: ARRAY
56124: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56125: LD_ADDR_VAR 0 7
56129: PUSH
56130: LD_VAR 0 7
56134: PUSH
56135: LD_VAR 0 6
56139: PUSH
56140: EMPTY
56141: LIST
56142: ADD
56143: ST_TO_ADDR
// end ;
56144: GO 56100
56146: POP
56147: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56148: LD_ADDR_VAR 0 6
56152: PUSH
56153: LD_VAR 0 6
56157: PPUSH
56158: LD_VAR 0 2
56162: PUSH
56163: LD_VAR 0 2
56167: ARRAY
56168: PPUSH
56169: LD_VAR 0 3
56173: PPUSH
56174: CALL_OW 1
56178: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56179: LD_ADDR_VAR 0 7
56183: PUSH
56184: LD_VAR 0 7
56188: PPUSH
56189: LD_VAR 0 7
56193: PPUSH
56194: LD_VAR 0 6
56198: PPUSH
56199: CALL_OW 1
56203: ST_TO_ADDR
// for i = s_arr downto 2 do
56204: LD_ADDR_VAR 0 5
56208: PUSH
56209: DOUBLE
56210: LD_VAR 0 7
56214: INC
56215: ST_TO_ADDR
56216: LD_INT 2
56218: PUSH
56219: FOR_DOWNTO
56220: IFFALSE 56304
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56222: LD_ADDR_VAR 0 6
56226: PUSH
56227: LD_VAR 0 7
56231: PUSH
56232: LD_VAR 0 5
56236: PUSH
56237: LD_INT 1
56239: MINUS
56240: ARRAY
56241: PPUSH
56242: LD_VAR 0 2
56246: PUSH
56247: LD_VAR 0 5
56251: PUSH
56252: LD_INT 1
56254: MINUS
56255: ARRAY
56256: PPUSH
56257: LD_VAR 0 7
56261: PUSH
56262: LD_VAR 0 5
56266: ARRAY
56267: PPUSH
56268: CALL_OW 1
56272: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56273: LD_ADDR_VAR 0 7
56277: PUSH
56278: LD_VAR 0 7
56282: PPUSH
56283: LD_VAR 0 5
56287: PUSH
56288: LD_INT 1
56290: MINUS
56291: PPUSH
56292: LD_VAR 0 6
56296: PPUSH
56297: CALL_OW 1
56301: ST_TO_ADDR
// end ;
56302: GO 56219
56304: POP
56305: POP
// result := s_arr [ 1 ] ;
56306: LD_ADDR_VAR 0 4
56310: PUSH
56311: LD_VAR 0 7
56315: PUSH
56316: LD_INT 1
56318: ARRAY
56319: ST_TO_ADDR
// end ; end ;
56320: LD_VAR 0 4
56324: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56325: LD_INT 0
56327: PPUSH
56328: PPUSH
// if not list then
56329: LD_VAR 0 1
56333: NOT
56334: IFFALSE 56338
// exit ;
56336: GO 56429
// i := list [ pos1 ] ;
56338: LD_ADDR_VAR 0 5
56342: PUSH
56343: LD_VAR 0 1
56347: PUSH
56348: LD_VAR 0 2
56352: ARRAY
56353: ST_TO_ADDR
// if not i then
56354: LD_VAR 0 5
56358: NOT
56359: IFFALSE 56363
// exit ;
56361: GO 56429
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56363: LD_ADDR_VAR 0 1
56367: PUSH
56368: LD_VAR 0 1
56372: PPUSH
56373: LD_VAR 0 2
56377: PPUSH
56378: LD_VAR 0 1
56382: PUSH
56383: LD_VAR 0 3
56387: ARRAY
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56394: LD_ADDR_VAR 0 1
56398: PUSH
56399: LD_VAR 0 1
56403: PPUSH
56404: LD_VAR 0 3
56408: PPUSH
56409: LD_VAR 0 5
56413: PPUSH
56414: CALL_OW 1
56418: ST_TO_ADDR
// result := list ;
56419: LD_ADDR_VAR 0 4
56423: PUSH
56424: LD_VAR 0 1
56428: ST_TO_ADDR
// end ;
56429: LD_VAR 0 4
56433: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56434: LD_INT 0
56436: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56437: LD_ADDR_VAR 0 5
56441: PUSH
56442: LD_VAR 0 1
56446: PPUSH
56447: CALL_OW 250
56451: PPUSH
56452: LD_VAR 0 1
56456: PPUSH
56457: CALL_OW 251
56461: PPUSH
56462: LD_VAR 0 2
56466: PPUSH
56467: LD_VAR 0 3
56471: PPUSH
56472: LD_VAR 0 4
56476: PPUSH
56477: CALL 56487 0 5
56481: ST_TO_ADDR
// end ;
56482: LD_VAR 0 5
56486: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56487: LD_INT 0
56489: PPUSH
56490: PPUSH
56491: PPUSH
56492: PPUSH
// if not list then
56493: LD_VAR 0 3
56497: NOT
56498: IFFALSE 56502
// exit ;
56500: GO 56890
// result := [ ] ;
56502: LD_ADDR_VAR 0 6
56506: PUSH
56507: EMPTY
56508: ST_TO_ADDR
// for i in list do
56509: LD_ADDR_VAR 0 7
56513: PUSH
56514: LD_VAR 0 3
56518: PUSH
56519: FOR_IN
56520: IFFALSE 56722
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56522: LD_ADDR_VAR 0 9
56526: PUSH
56527: LD_VAR 0 7
56531: PPUSH
56532: LD_VAR 0 1
56536: PPUSH
56537: LD_VAR 0 2
56541: PPUSH
56542: CALL_OW 297
56546: ST_TO_ADDR
// if not result then
56547: LD_VAR 0 6
56551: NOT
56552: IFFALSE 56578
// result := [ [ i , tmp ] ] else
56554: LD_ADDR_VAR 0 6
56558: PUSH
56559: LD_VAR 0 7
56563: PUSH
56564: LD_VAR 0 9
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: PUSH
56573: EMPTY
56574: LIST
56575: ST_TO_ADDR
56576: GO 56720
// begin if result [ result ] [ 2 ] < tmp then
56578: LD_VAR 0 6
56582: PUSH
56583: LD_VAR 0 6
56587: ARRAY
56588: PUSH
56589: LD_INT 2
56591: ARRAY
56592: PUSH
56593: LD_VAR 0 9
56597: LESS
56598: IFFALSE 56640
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56600: LD_ADDR_VAR 0 6
56604: PUSH
56605: LD_VAR 0 6
56609: PPUSH
56610: LD_VAR 0 6
56614: PUSH
56615: LD_INT 1
56617: PLUS
56618: PPUSH
56619: LD_VAR 0 7
56623: PUSH
56624: LD_VAR 0 9
56628: PUSH
56629: EMPTY
56630: LIST
56631: LIST
56632: PPUSH
56633: CALL_OW 2
56637: ST_TO_ADDR
56638: GO 56720
// for j = 1 to result do
56640: LD_ADDR_VAR 0 8
56644: PUSH
56645: DOUBLE
56646: LD_INT 1
56648: DEC
56649: ST_TO_ADDR
56650: LD_VAR 0 6
56654: PUSH
56655: FOR_TO
56656: IFFALSE 56718
// begin if tmp < result [ j ] [ 2 ] then
56658: LD_VAR 0 9
56662: PUSH
56663: LD_VAR 0 6
56667: PUSH
56668: LD_VAR 0 8
56672: ARRAY
56673: PUSH
56674: LD_INT 2
56676: ARRAY
56677: LESS
56678: IFFALSE 56716
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56680: LD_ADDR_VAR 0 6
56684: PUSH
56685: LD_VAR 0 6
56689: PPUSH
56690: LD_VAR 0 8
56694: PPUSH
56695: LD_VAR 0 7
56699: PUSH
56700: LD_VAR 0 9
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: PPUSH
56709: CALL_OW 2
56713: ST_TO_ADDR
// break ;
56714: GO 56718
// end ; end ;
56716: GO 56655
56718: POP
56719: POP
// end ; end ;
56720: GO 56519
56722: POP
56723: POP
// if result and not asc then
56724: LD_VAR 0 6
56728: PUSH
56729: LD_VAR 0 4
56733: NOT
56734: AND
56735: IFFALSE 56810
// begin tmp := result ;
56737: LD_ADDR_VAR 0 9
56741: PUSH
56742: LD_VAR 0 6
56746: ST_TO_ADDR
// for i = tmp downto 1 do
56747: LD_ADDR_VAR 0 7
56751: PUSH
56752: DOUBLE
56753: LD_VAR 0 9
56757: INC
56758: ST_TO_ADDR
56759: LD_INT 1
56761: PUSH
56762: FOR_DOWNTO
56763: IFFALSE 56808
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56765: LD_ADDR_VAR 0 6
56769: PUSH
56770: LD_VAR 0 6
56774: PPUSH
56775: LD_VAR 0 9
56779: PUSH
56780: LD_VAR 0 7
56784: MINUS
56785: PUSH
56786: LD_INT 1
56788: PLUS
56789: PPUSH
56790: LD_VAR 0 9
56794: PUSH
56795: LD_VAR 0 7
56799: ARRAY
56800: PPUSH
56801: CALL_OW 1
56805: ST_TO_ADDR
56806: GO 56762
56808: POP
56809: POP
// end ; tmp := [ ] ;
56810: LD_ADDR_VAR 0 9
56814: PUSH
56815: EMPTY
56816: ST_TO_ADDR
// if mode then
56817: LD_VAR 0 5
56821: IFFALSE 56890
// begin for i = 1 to result do
56823: LD_ADDR_VAR 0 7
56827: PUSH
56828: DOUBLE
56829: LD_INT 1
56831: DEC
56832: ST_TO_ADDR
56833: LD_VAR 0 6
56837: PUSH
56838: FOR_TO
56839: IFFALSE 56878
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56841: LD_ADDR_VAR 0 9
56845: PUSH
56846: LD_VAR 0 9
56850: PPUSH
56851: LD_VAR 0 7
56855: PPUSH
56856: LD_VAR 0 6
56860: PUSH
56861: LD_VAR 0 7
56865: ARRAY
56866: PUSH
56867: LD_INT 1
56869: ARRAY
56870: PPUSH
56871: CALL_OW 1
56875: ST_TO_ADDR
56876: GO 56838
56878: POP
56879: POP
// result := tmp ;
56880: LD_ADDR_VAR 0 6
56884: PUSH
56885: LD_VAR 0 9
56889: ST_TO_ADDR
// end ; end ;
56890: LD_VAR 0 6
56894: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56895: LD_INT 0
56897: PPUSH
56898: PPUSH
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56903: LD_ADDR_VAR 0 5
56907: PUSH
56908: LD_INT 0
56910: PUSH
56911: LD_INT 0
56913: PUSH
56914: LD_INT 0
56916: PUSH
56917: EMPTY
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: LIST
56923: LIST
56924: ST_TO_ADDR
// if not x or not y then
56925: LD_VAR 0 2
56929: NOT
56930: PUSH
56931: LD_VAR 0 3
56935: NOT
56936: OR
56937: IFFALSE 56941
// exit ;
56939: GO 58587
// if not range then
56941: LD_VAR 0 4
56945: NOT
56946: IFFALSE 56956
// range := 10 ;
56948: LD_ADDR_VAR 0 4
56952: PUSH
56953: LD_INT 10
56955: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56956: LD_ADDR_VAR 0 8
56960: PUSH
56961: LD_INT 81
56963: PUSH
56964: LD_VAR 0 1
56968: PUSH
56969: EMPTY
56970: LIST
56971: LIST
56972: PUSH
56973: LD_INT 92
56975: PUSH
56976: LD_VAR 0 2
56980: PUSH
56981: LD_VAR 0 3
56985: PUSH
56986: LD_VAR 0 4
56990: PUSH
56991: EMPTY
56992: LIST
56993: LIST
56994: LIST
56995: LIST
56996: PUSH
56997: LD_INT 3
56999: PUSH
57000: LD_INT 21
57002: PUSH
57003: LD_INT 3
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: PUSH
57010: EMPTY
57011: LIST
57012: LIST
57013: PUSH
57014: EMPTY
57015: LIST
57016: LIST
57017: LIST
57018: PPUSH
57019: CALL_OW 69
57023: ST_TO_ADDR
// if not tmp then
57024: LD_VAR 0 8
57028: NOT
57029: IFFALSE 57033
// exit ;
57031: GO 58587
// for i in tmp do
57033: LD_ADDR_VAR 0 6
57037: PUSH
57038: LD_VAR 0 8
57042: PUSH
57043: FOR_IN
57044: IFFALSE 58562
// begin points := [ 0 , 0 , 0 ] ;
57046: LD_ADDR_VAR 0 9
57050: PUSH
57051: LD_INT 0
57053: PUSH
57054: LD_INT 0
57056: PUSH
57057: LD_INT 0
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: LIST
57064: ST_TO_ADDR
// bpoints := 1 ;
57065: LD_ADDR_VAR 0 10
57069: PUSH
57070: LD_INT 1
57072: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57073: LD_VAR 0 6
57077: PPUSH
57078: CALL_OW 247
57082: PUSH
57083: LD_INT 1
57085: DOUBLE
57086: EQUAL
57087: IFTRUE 57091
57089: GO 57669
57091: POP
// begin if GetClass ( i ) = 1 then
57092: LD_VAR 0 6
57096: PPUSH
57097: CALL_OW 257
57101: PUSH
57102: LD_INT 1
57104: EQUAL
57105: IFFALSE 57126
// points := [ 10 , 5 , 3 ] ;
57107: LD_ADDR_VAR 0 9
57111: PUSH
57112: LD_INT 10
57114: PUSH
57115: LD_INT 5
57117: PUSH
57118: LD_INT 3
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: LIST
57125: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57126: LD_VAR 0 6
57130: PPUSH
57131: CALL_OW 257
57135: PUSH
57136: LD_INT 2
57138: PUSH
57139: LD_INT 3
57141: PUSH
57142: LD_INT 4
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: LIST
57149: IN
57150: IFFALSE 57171
// points := [ 3 , 2 , 1 ] ;
57152: LD_ADDR_VAR 0 9
57156: PUSH
57157: LD_INT 3
57159: PUSH
57160: LD_INT 2
57162: PUSH
57163: LD_INT 1
57165: PUSH
57166: EMPTY
57167: LIST
57168: LIST
57169: LIST
57170: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57171: LD_VAR 0 6
57175: PPUSH
57176: CALL_OW 257
57180: PUSH
57181: LD_INT 5
57183: EQUAL
57184: IFFALSE 57205
// points := [ 130 , 5 , 2 ] ;
57186: LD_ADDR_VAR 0 9
57190: PUSH
57191: LD_INT 130
57193: PUSH
57194: LD_INT 5
57196: PUSH
57197: LD_INT 2
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: LIST
57204: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57205: LD_VAR 0 6
57209: PPUSH
57210: CALL_OW 257
57214: PUSH
57215: LD_INT 8
57217: EQUAL
57218: IFFALSE 57239
// points := [ 35 , 35 , 30 ] ;
57220: LD_ADDR_VAR 0 9
57224: PUSH
57225: LD_INT 35
57227: PUSH
57228: LD_INT 35
57230: PUSH
57231: LD_INT 30
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: LIST
57238: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57239: LD_VAR 0 6
57243: PPUSH
57244: CALL_OW 257
57248: PUSH
57249: LD_INT 9
57251: EQUAL
57252: IFFALSE 57273
// points := [ 20 , 55 , 40 ] ;
57254: LD_ADDR_VAR 0 9
57258: PUSH
57259: LD_INT 20
57261: PUSH
57262: LD_INT 55
57264: PUSH
57265: LD_INT 40
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: LIST
57272: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57273: LD_VAR 0 6
57277: PPUSH
57278: CALL_OW 257
57282: PUSH
57283: LD_INT 12
57285: PUSH
57286: LD_INT 16
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: IN
57293: IFFALSE 57314
// points := [ 5 , 3 , 2 ] ;
57295: LD_ADDR_VAR 0 9
57299: PUSH
57300: LD_INT 5
57302: PUSH
57303: LD_INT 3
57305: PUSH
57306: LD_INT 2
57308: PUSH
57309: EMPTY
57310: LIST
57311: LIST
57312: LIST
57313: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57314: LD_VAR 0 6
57318: PPUSH
57319: CALL_OW 257
57323: PUSH
57324: LD_INT 17
57326: EQUAL
57327: IFFALSE 57348
// points := [ 100 , 50 , 75 ] ;
57329: LD_ADDR_VAR 0 9
57333: PUSH
57334: LD_INT 100
57336: PUSH
57337: LD_INT 50
57339: PUSH
57340: LD_INT 75
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: LIST
57347: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57348: LD_VAR 0 6
57352: PPUSH
57353: CALL_OW 257
57357: PUSH
57358: LD_INT 15
57360: EQUAL
57361: IFFALSE 57382
// points := [ 10 , 5 , 3 ] ;
57363: LD_ADDR_VAR 0 9
57367: PUSH
57368: LD_INT 10
57370: PUSH
57371: LD_INT 5
57373: PUSH
57374: LD_INT 3
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: LIST
57381: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57382: LD_VAR 0 6
57386: PPUSH
57387: CALL_OW 257
57391: PUSH
57392: LD_INT 14
57394: EQUAL
57395: IFFALSE 57416
// points := [ 10 , 0 , 0 ] ;
57397: LD_ADDR_VAR 0 9
57401: PUSH
57402: LD_INT 10
57404: PUSH
57405: LD_INT 0
57407: PUSH
57408: LD_INT 0
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: LIST
57415: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57416: LD_VAR 0 6
57420: PPUSH
57421: CALL_OW 257
57425: PUSH
57426: LD_INT 11
57428: EQUAL
57429: IFFALSE 57450
// points := [ 30 , 10 , 5 ] ;
57431: LD_ADDR_VAR 0 9
57435: PUSH
57436: LD_INT 30
57438: PUSH
57439: LD_INT 10
57441: PUSH
57442: LD_INT 5
57444: PUSH
57445: EMPTY
57446: LIST
57447: LIST
57448: LIST
57449: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57450: LD_VAR 0 1
57454: PPUSH
57455: LD_INT 5
57457: PPUSH
57458: CALL_OW 321
57462: PUSH
57463: LD_INT 2
57465: EQUAL
57466: IFFALSE 57483
// bpoints := bpoints * 1.8 ;
57468: LD_ADDR_VAR 0 10
57472: PUSH
57473: LD_VAR 0 10
57477: PUSH
57478: LD_REAL  1.80000000000000E+0000
57481: MUL
57482: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57483: LD_VAR 0 6
57487: PPUSH
57488: CALL_OW 257
57492: PUSH
57493: LD_INT 1
57495: PUSH
57496: LD_INT 2
57498: PUSH
57499: LD_INT 3
57501: PUSH
57502: LD_INT 4
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: LIST
57509: LIST
57510: IN
57511: PUSH
57512: LD_VAR 0 1
57516: PPUSH
57517: LD_INT 51
57519: PPUSH
57520: CALL_OW 321
57524: PUSH
57525: LD_INT 2
57527: EQUAL
57528: AND
57529: IFFALSE 57546
// bpoints := bpoints * 1.2 ;
57531: LD_ADDR_VAR 0 10
57535: PUSH
57536: LD_VAR 0 10
57540: PUSH
57541: LD_REAL  1.20000000000000E+0000
57544: MUL
57545: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57546: LD_VAR 0 6
57550: PPUSH
57551: CALL_OW 257
57555: PUSH
57556: LD_INT 5
57558: PUSH
57559: LD_INT 7
57561: PUSH
57562: LD_INT 9
57564: PUSH
57565: EMPTY
57566: LIST
57567: LIST
57568: LIST
57569: IN
57570: PUSH
57571: LD_VAR 0 1
57575: PPUSH
57576: LD_INT 52
57578: PPUSH
57579: CALL_OW 321
57583: PUSH
57584: LD_INT 2
57586: EQUAL
57587: AND
57588: IFFALSE 57605
// bpoints := bpoints * 1.5 ;
57590: LD_ADDR_VAR 0 10
57594: PUSH
57595: LD_VAR 0 10
57599: PUSH
57600: LD_REAL  1.50000000000000E+0000
57603: MUL
57604: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57605: LD_VAR 0 1
57609: PPUSH
57610: LD_INT 66
57612: PPUSH
57613: CALL_OW 321
57617: PUSH
57618: LD_INT 2
57620: EQUAL
57621: IFFALSE 57638
// bpoints := bpoints * 1.1 ;
57623: LD_ADDR_VAR 0 10
57627: PUSH
57628: LD_VAR 0 10
57632: PUSH
57633: LD_REAL  1.10000000000000E+0000
57636: MUL
57637: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57638: LD_ADDR_VAR 0 10
57642: PUSH
57643: LD_VAR 0 10
57647: PUSH
57648: LD_VAR 0 6
57652: PPUSH
57653: LD_INT 1
57655: PPUSH
57656: CALL_OW 259
57660: PUSH
57661: LD_REAL  1.15000000000000E+0000
57664: MUL
57665: MUL
57666: ST_TO_ADDR
// end ; unit_vehicle :
57667: GO 58491
57669: LD_INT 2
57671: DOUBLE
57672: EQUAL
57673: IFTRUE 57677
57675: GO 58479
57677: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57678: LD_VAR 0 6
57682: PPUSH
57683: CALL_OW 264
57687: PUSH
57688: LD_INT 2
57690: PUSH
57691: LD_INT 42
57693: PUSH
57694: LD_INT 24
57696: PUSH
57697: EMPTY
57698: LIST
57699: LIST
57700: LIST
57701: IN
57702: IFFALSE 57723
// points := [ 25 , 5 , 3 ] ;
57704: LD_ADDR_VAR 0 9
57708: PUSH
57709: LD_INT 25
57711: PUSH
57712: LD_INT 5
57714: PUSH
57715: LD_INT 3
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: LIST
57722: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57723: LD_VAR 0 6
57727: PPUSH
57728: CALL_OW 264
57732: PUSH
57733: LD_INT 4
57735: PUSH
57736: LD_INT 43
57738: PUSH
57739: LD_INT 25
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: LIST
57746: IN
57747: IFFALSE 57768
// points := [ 40 , 15 , 5 ] ;
57749: LD_ADDR_VAR 0 9
57753: PUSH
57754: LD_INT 40
57756: PUSH
57757: LD_INT 15
57759: PUSH
57760: LD_INT 5
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: LIST
57767: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57768: LD_VAR 0 6
57772: PPUSH
57773: CALL_OW 264
57777: PUSH
57778: LD_INT 3
57780: PUSH
57781: LD_INT 23
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: IN
57788: IFFALSE 57809
// points := [ 7 , 25 , 8 ] ;
57790: LD_ADDR_VAR 0 9
57794: PUSH
57795: LD_INT 7
57797: PUSH
57798: LD_INT 25
57800: PUSH
57801: LD_INT 8
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: LIST
57808: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57809: LD_VAR 0 6
57813: PPUSH
57814: CALL_OW 264
57818: PUSH
57819: LD_INT 5
57821: PUSH
57822: LD_INT 27
57824: PUSH
57825: LD_INT 44
57827: PUSH
57828: EMPTY
57829: LIST
57830: LIST
57831: LIST
57832: IN
57833: IFFALSE 57854
// points := [ 14 , 50 , 16 ] ;
57835: LD_ADDR_VAR 0 9
57839: PUSH
57840: LD_INT 14
57842: PUSH
57843: LD_INT 50
57845: PUSH
57846: LD_INT 16
57848: PUSH
57849: EMPTY
57850: LIST
57851: LIST
57852: LIST
57853: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57854: LD_VAR 0 6
57858: PPUSH
57859: CALL_OW 264
57863: PUSH
57864: LD_INT 6
57866: PUSH
57867: LD_INT 46
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: IN
57874: IFFALSE 57895
// points := [ 32 , 120 , 70 ] ;
57876: LD_ADDR_VAR 0 9
57880: PUSH
57881: LD_INT 32
57883: PUSH
57884: LD_INT 120
57886: PUSH
57887: LD_INT 70
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: LIST
57894: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57895: LD_VAR 0 6
57899: PPUSH
57900: CALL_OW 264
57904: PUSH
57905: LD_INT 7
57907: PUSH
57908: LD_INT 28
57910: PUSH
57911: LD_INT 45
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: LIST
57918: IN
57919: IFFALSE 57940
// points := [ 35 , 20 , 45 ] ;
57921: LD_ADDR_VAR 0 9
57925: PUSH
57926: LD_INT 35
57928: PUSH
57929: LD_INT 20
57931: PUSH
57932: LD_INT 45
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: LIST
57939: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57940: LD_VAR 0 6
57944: PPUSH
57945: CALL_OW 264
57949: PUSH
57950: LD_INT 47
57952: PUSH
57953: EMPTY
57954: LIST
57955: IN
57956: IFFALSE 57977
// points := [ 67 , 45 , 75 ] ;
57958: LD_ADDR_VAR 0 9
57962: PUSH
57963: LD_INT 67
57965: PUSH
57966: LD_INT 45
57968: PUSH
57969: LD_INT 75
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: LIST
57976: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57977: LD_VAR 0 6
57981: PPUSH
57982: CALL_OW 264
57986: PUSH
57987: LD_INT 26
57989: PUSH
57990: EMPTY
57991: LIST
57992: IN
57993: IFFALSE 58014
// points := [ 120 , 30 , 80 ] ;
57995: LD_ADDR_VAR 0 9
57999: PUSH
58000: LD_INT 120
58002: PUSH
58003: LD_INT 30
58005: PUSH
58006: LD_INT 80
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: LIST
58013: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58014: LD_VAR 0 6
58018: PPUSH
58019: CALL_OW 264
58023: PUSH
58024: LD_INT 22
58026: PUSH
58027: EMPTY
58028: LIST
58029: IN
58030: IFFALSE 58051
// points := [ 40 , 1 , 1 ] ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_INT 40
58039: PUSH
58040: LD_INT 1
58042: PUSH
58043: LD_INT 1
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: LIST
58050: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58051: LD_VAR 0 6
58055: PPUSH
58056: CALL_OW 264
58060: PUSH
58061: LD_INT 29
58063: PUSH
58064: EMPTY
58065: LIST
58066: IN
58067: IFFALSE 58088
// points := [ 70 , 200 , 400 ] ;
58069: LD_ADDR_VAR 0 9
58073: PUSH
58074: LD_INT 70
58076: PUSH
58077: LD_INT 200
58079: PUSH
58080: LD_INT 400
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: LIST
58087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58088: LD_VAR 0 6
58092: PPUSH
58093: CALL_OW 264
58097: PUSH
58098: LD_INT 14
58100: PUSH
58101: LD_INT 53
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: IN
58108: IFFALSE 58129
// points := [ 40 , 10 , 20 ] ;
58110: LD_ADDR_VAR 0 9
58114: PUSH
58115: LD_INT 40
58117: PUSH
58118: LD_INT 10
58120: PUSH
58121: LD_INT 20
58123: PUSH
58124: EMPTY
58125: LIST
58126: LIST
58127: LIST
58128: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58129: LD_VAR 0 6
58133: PPUSH
58134: CALL_OW 264
58138: PUSH
58139: LD_INT 9
58141: PUSH
58142: EMPTY
58143: LIST
58144: IN
58145: IFFALSE 58166
// points := [ 5 , 70 , 20 ] ;
58147: LD_ADDR_VAR 0 9
58151: PUSH
58152: LD_INT 5
58154: PUSH
58155: LD_INT 70
58157: PUSH
58158: LD_INT 20
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: LIST
58165: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58166: LD_VAR 0 6
58170: PPUSH
58171: CALL_OW 264
58175: PUSH
58176: LD_INT 10
58178: PUSH
58179: EMPTY
58180: LIST
58181: IN
58182: IFFALSE 58203
// points := [ 35 , 110 , 70 ] ;
58184: LD_ADDR_VAR 0 9
58188: PUSH
58189: LD_INT 35
58191: PUSH
58192: LD_INT 110
58194: PUSH
58195: LD_INT 70
58197: PUSH
58198: EMPTY
58199: LIST
58200: LIST
58201: LIST
58202: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58203: LD_VAR 0 6
58207: PPUSH
58208: CALL_OW 265
58212: PUSH
58213: LD_INT 25
58215: EQUAL
58216: IFFALSE 58237
// points := [ 80 , 65 , 100 ] ;
58218: LD_ADDR_VAR 0 9
58222: PUSH
58223: LD_INT 80
58225: PUSH
58226: LD_INT 65
58228: PUSH
58229: LD_INT 100
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58237: LD_VAR 0 6
58241: PPUSH
58242: CALL_OW 263
58246: PUSH
58247: LD_INT 1
58249: EQUAL
58250: IFFALSE 58285
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58252: LD_ADDR_VAR 0 10
58256: PUSH
58257: LD_VAR 0 10
58261: PUSH
58262: LD_VAR 0 6
58266: PPUSH
58267: CALL_OW 311
58271: PPUSH
58272: LD_INT 3
58274: PPUSH
58275: CALL_OW 259
58279: PUSH
58280: LD_INT 4
58282: MUL
58283: MUL
58284: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58285: LD_VAR 0 6
58289: PPUSH
58290: CALL_OW 263
58294: PUSH
58295: LD_INT 2
58297: EQUAL
58298: IFFALSE 58349
// begin j := IsControledBy ( i ) ;
58300: LD_ADDR_VAR 0 7
58304: PUSH
58305: LD_VAR 0 6
58309: PPUSH
58310: CALL_OW 312
58314: ST_TO_ADDR
// if j then
58315: LD_VAR 0 7
58319: IFFALSE 58349
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58321: LD_ADDR_VAR 0 10
58325: PUSH
58326: LD_VAR 0 10
58330: PUSH
58331: LD_VAR 0 7
58335: PPUSH
58336: LD_INT 3
58338: PPUSH
58339: CALL_OW 259
58343: PUSH
58344: LD_INT 3
58346: MUL
58347: MUL
58348: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58349: LD_VAR 0 6
58353: PPUSH
58354: CALL_OW 264
58358: PUSH
58359: LD_INT 5
58361: PUSH
58362: LD_INT 6
58364: PUSH
58365: LD_INT 46
58367: PUSH
58368: LD_INT 44
58370: PUSH
58371: LD_INT 47
58373: PUSH
58374: LD_INT 45
58376: PUSH
58377: LD_INT 28
58379: PUSH
58380: LD_INT 7
58382: PUSH
58383: LD_INT 27
58385: PUSH
58386: LD_INT 29
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: LIST
58393: LIST
58394: LIST
58395: LIST
58396: LIST
58397: LIST
58398: LIST
58399: LIST
58400: IN
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: LD_INT 52
58409: PPUSH
58410: CALL_OW 321
58414: PUSH
58415: LD_INT 2
58417: EQUAL
58418: AND
58419: IFFALSE 58436
// bpoints := bpoints * 1.2 ;
58421: LD_ADDR_VAR 0 10
58425: PUSH
58426: LD_VAR 0 10
58430: PUSH
58431: LD_REAL  1.20000000000000E+0000
58434: MUL
58435: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58436: LD_VAR 0 6
58440: PPUSH
58441: CALL_OW 264
58445: PUSH
58446: LD_INT 6
58448: PUSH
58449: LD_INT 46
58451: PUSH
58452: LD_INT 47
58454: PUSH
58455: EMPTY
58456: LIST
58457: LIST
58458: LIST
58459: IN
58460: IFFALSE 58477
// bpoints := bpoints * 1.2 ;
58462: LD_ADDR_VAR 0 10
58466: PUSH
58467: LD_VAR 0 10
58471: PUSH
58472: LD_REAL  1.20000000000000E+0000
58475: MUL
58476: ST_TO_ADDR
// end ; unit_building :
58477: GO 58491
58479: LD_INT 3
58481: DOUBLE
58482: EQUAL
58483: IFTRUE 58487
58485: GO 58490
58487: POP
// ; end ;
58488: GO 58491
58490: POP
// for j = 1 to 3 do
58491: LD_ADDR_VAR 0 7
58495: PUSH
58496: DOUBLE
58497: LD_INT 1
58499: DEC
58500: ST_TO_ADDR
58501: LD_INT 3
58503: PUSH
58504: FOR_TO
58505: IFFALSE 58558
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58507: LD_ADDR_VAR 0 5
58511: PUSH
58512: LD_VAR 0 5
58516: PPUSH
58517: LD_VAR 0 7
58521: PPUSH
58522: LD_VAR 0 5
58526: PUSH
58527: LD_VAR 0 7
58531: ARRAY
58532: PUSH
58533: LD_VAR 0 9
58537: PUSH
58538: LD_VAR 0 7
58542: ARRAY
58543: PUSH
58544: LD_VAR 0 10
58548: MUL
58549: PLUS
58550: PPUSH
58551: CALL_OW 1
58555: ST_TO_ADDR
58556: GO 58504
58558: POP
58559: POP
// end ;
58560: GO 57043
58562: POP
58563: POP
// result := Replace ( result , 4 , tmp ) ;
58564: LD_ADDR_VAR 0 5
58568: PUSH
58569: LD_VAR 0 5
58573: PPUSH
58574: LD_INT 4
58576: PPUSH
58577: LD_VAR 0 8
58581: PPUSH
58582: CALL_OW 1
58586: ST_TO_ADDR
// end ;
58587: LD_VAR 0 5
58591: RET
// export function DangerAtRange ( unit , range ) ; begin
58592: LD_INT 0
58594: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58595: LD_ADDR_VAR 0 3
58599: PUSH
58600: LD_VAR 0 1
58604: PPUSH
58605: CALL_OW 255
58609: PPUSH
58610: LD_VAR 0 1
58614: PPUSH
58615: CALL_OW 250
58619: PPUSH
58620: LD_VAR 0 1
58624: PPUSH
58625: CALL_OW 251
58629: PPUSH
58630: LD_VAR 0 2
58634: PPUSH
58635: CALL 56895 0 4
58639: ST_TO_ADDR
// end ;
58640: LD_VAR 0 3
58644: RET
// export function DangerInArea ( side , area ) ; begin
58645: LD_INT 0
58647: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58648: LD_ADDR_VAR 0 3
58652: PUSH
58653: LD_VAR 0 2
58657: PPUSH
58658: LD_INT 81
58660: PUSH
58661: LD_VAR 0 1
58665: PUSH
58666: EMPTY
58667: LIST
58668: LIST
58669: PPUSH
58670: CALL_OW 70
58674: ST_TO_ADDR
// end ;
58675: LD_VAR 0 3
58679: RET
// export function IsExtension ( b ) ; begin
58680: LD_INT 0
58682: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58683: LD_ADDR_VAR 0 2
58687: PUSH
58688: LD_VAR 0 1
58692: PUSH
58693: LD_INT 23
58695: PUSH
58696: LD_INT 20
58698: PUSH
58699: LD_INT 22
58701: PUSH
58702: LD_INT 17
58704: PUSH
58705: LD_INT 24
58707: PUSH
58708: LD_INT 21
58710: PUSH
58711: LD_INT 19
58713: PUSH
58714: LD_INT 16
58716: PUSH
58717: LD_INT 25
58719: PUSH
58720: LD_INT 18
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: LIST
58727: LIST
58728: LIST
58729: LIST
58730: LIST
58731: LIST
58732: LIST
58733: LIST
58734: IN
58735: ST_TO_ADDR
// end ;
58736: LD_VAR 0 2
58740: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
58741: LD_INT 0
58743: PPUSH
58744: PPUSH
58745: PPUSH
// result := [ ] ;
58746: LD_ADDR_VAR 0 4
58750: PUSH
58751: EMPTY
58752: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58753: LD_ADDR_VAR 0 5
58757: PUSH
58758: LD_VAR 0 2
58762: PPUSH
58763: LD_INT 21
58765: PUSH
58766: LD_INT 3
58768: PUSH
58769: EMPTY
58770: LIST
58771: LIST
58772: PPUSH
58773: CALL_OW 70
58777: ST_TO_ADDR
// if not tmp then
58778: LD_VAR 0 5
58782: NOT
58783: IFFALSE 58787
// exit ;
58785: GO 58851
// if checkLink then
58787: LD_VAR 0 3
58791: IFFALSE 58841
// begin for i in tmp do
58793: LD_ADDR_VAR 0 6
58797: PUSH
58798: LD_VAR 0 5
58802: PUSH
58803: FOR_IN
58804: IFFALSE 58839
// if GetBase ( i ) <> base then
58806: LD_VAR 0 6
58810: PPUSH
58811: CALL_OW 274
58815: PUSH
58816: LD_VAR 0 1
58820: NONEQUAL
58821: IFFALSE 58837
// ComLinkToBase ( base , i ) ;
58823: LD_VAR 0 1
58827: PPUSH
58828: LD_VAR 0 6
58832: PPUSH
58833: CALL_OW 169
58837: GO 58803
58839: POP
58840: POP
// end ; result := tmp ;
58841: LD_ADDR_VAR 0 4
58845: PUSH
58846: LD_VAR 0 5
58850: ST_TO_ADDR
// end ;
58851: LD_VAR 0 4
58855: RET
// export function ComComplete ( units , b ) ; var i ; begin
58856: LD_INT 0
58858: PPUSH
58859: PPUSH
// if not units then
58860: LD_VAR 0 1
58864: NOT
58865: IFFALSE 58869
// exit ;
58867: GO 58959
// for i in units do
58869: LD_ADDR_VAR 0 4
58873: PUSH
58874: LD_VAR 0 1
58878: PUSH
58879: FOR_IN
58880: IFFALSE 58957
// if BuildingStatus ( b ) = bs_build then
58882: LD_VAR 0 2
58886: PPUSH
58887: CALL_OW 461
58891: PUSH
58892: LD_INT 1
58894: EQUAL
58895: IFFALSE 58955
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58897: LD_VAR 0 4
58901: PPUSH
58902: LD_STRING h
58904: PUSH
58905: LD_VAR 0 2
58909: PPUSH
58910: CALL_OW 250
58914: PUSH
58915: LD_VAR 0 2
58919: PPUSH
58920: CALL_OW 251
58924: PUSH
58925: LD_VAR 0 2
58929: PUSH
58930: LD_INT 0
58932: PUSH
58933: LD_INT 0
58935: PUSH
58936: LD_INT 0
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: LIST
58943: LIST
58944: LIST
58945: LIST
58946: LIST
58947: PUSH
58948: EMPTY
58949: LIST
58950: PPUSH
58951: CALL_OW 446
58955: GO 58879
58957: POP
58958: POP
// end ;
58959: LD_VAR 0 3
58963: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58964: LD_INT 0
58966: PPUSH
58967: PPUSH
58968: PPUSH
58969: PPUSH
58970: PPUSH
58971: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58972: LD_VAR 0 1
58976: NOT
58977: PUSH
58978: LD_VAR 0 1
58982: PPUSH
58983: CALL_OW 263
58987: PUSH
58988: LD_INT 2
58990: EQUAL
58991: NOT
58992: OR
58993: IFFALSE 58997
// exit ;
58995: GO 59313
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58997: LD_ADDR_VAR 0 6
59001: PUSH
59002: LD_INT 22
59004: PUSH
59005: LD_VAR 0 1
59009: PPUSH
59010: CALL_OW 255
59014: PUSH
59015: EMPTY
59016: LIST
59017: LIST
59018: PUSH
59019: LD_INT 2
59021: PUSH
59022: LD_INT 30
59024: PUSH
59025: LD_INT 36
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: PUSH
59032: LD_INT 34
59034: PUSH
59035: LD_INT 31
59037: PUSH
59038: EMPTY
59039: LIST
59040: LIST
59041: PUSH
59042: EMPTY
59043: LIST
59044: LIST
59045: LIST
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PPUSH
59051: CALL_OW 69
59055: ST_TO_ADDR
// if not tmp then
59056: LD_VAR 0 6
59060: NOT
59061: IFFALSE 59065
// exit ;
59063: GO 59313
// result := [ ] ;
59065: LD_ADDR_VAR 0 2
59069: PUSH
59070: EMPTY
59071: ST_TO_ADDR
// for i in tmp do
59072: LD_ADDR_VAR 0 3
59076: PUSH
59077: LD_VAR 0 6
59081: PUSH
59082: FOR_IN
59083: IFFALSE 59154
// begin t := UnitsInside ( i ) ;
59085: LD_ADDR_VAR 0 4
59089: PUSH
59090: LD_VAR 0 3
59094: PPUSH
59095: CALL_OW 313
59099: ST_TO_ADDR
// if t then
59100: LD_VAR 0 4
59104: IFFALSE 59152
// for j in t do
59106: LD_ADDR_VAR 0 7
59110: PUSH
59111: LD_VAR 0 4
59115: PUSH
59116: FOR_IN
59117: IFFALSE 59150
// result := Insert ( result , result + 1 , j ) ;
59119: LD_ADDR_VAR 0 2
59123: PUSH
59124: LD_VAR 0 2
59128: PPUSH
59129: LD_VAR 0 2
59133: PUSH
59134: LD_INT 1
59136: PLUS
59137: PPUSH
59138: LD_VAR 0 7
59142: PPUSH
59143: CALL_OW 2
59147: ST_TO_ADDR
59148: GO 59116
59150: POP
59151: POP
// end ;
59152: GO 59082
59154: POP
59155: POP
// if not result then
59156: LD_VAR 0 2
59160: NOT
59161: IFFALSE 59165
// exit ;
59163: GO 59313
// mech := result [ 1 ] ;
59165: LD_ADDR_VAR 0 5
59169: PUSH
59170: LD_VAR 0 2
59174: PUSH
59175: LD_INT 1
59177: ARRAY
59178: ST_TO_ADDR
// if result > 1 then
59179: LD_VAR 0 2
59183: PUSH
59184: LD_INT 1
59186: GREATER
59187: IFFALSE 59299
// for i = 2 to result do
59189: LD_ADDR_VAR 0 3
59193: PUSH
59194: DOUBLE
59195: LD_INT 2
59197: DEC
59198: ST_TO_ADDR
59199: LD_VAR 0 2
59203: PUSH
59204: FOR_TO
59205: IFFALSE 59297
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59207: LD_ADDR_VAR 0 4
59211: PUSH
59212: LD_VAR 0 2
59216: PUSH
59217: LD_VAR 0 3
59221: ARRAY
59222: PPUSH
59223: LD_INT 3
59225: PPUSH
59226: CALL_OW 259
59230: PUSH
59231: LD_VAR 0 2
59235: PUSH
59236: LD_VAR 0 3
59240: ARRAY
59241: PPUSH
59242: CALL_OW 432
59246: MINUS
59247: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59248: LD_VAR 0 4
59252: PUSH
59253: LD_VAR 0 5
59257: PPUSH
59258: LD_INT 3
59260: PPUSH
59261: CALL_OW 259
59265: PUSH
59266: LD_VAR 0 5
59270: PPUSH
59271: CALL_OW 432
59275: MINUS
59276: GREATEREQUAL
59277: IFFALSE 59295
// mech := result [ i ] ;
59279: LD_ADDR_VAR 0 5
59283: PUSH
59284: LD_VAR 0 2
59288: PUSH
59289: LD_VAR 0 3
59293: ARRAY
59294: ST_TO_ADDR
// end ;
59295: GO 59204
59297: POP
59298: POP
// ComLinkTo ( vehicle , mech ) ;
59299: LD_VAR 0 1
59303: PPUSH
59304: LD_VAR 0 5
59308: PPUSH
59309: CALL_OW 135
// end ;
59313: LD_VAR 0 2
59317: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59318: LD_INT 0
59320: PPUSH
59321: PPUSH
59322: PPUSH
59323: PPUSH
59324: PPUSH
59325: PPUSH
59326: PPUSH
59327: PPUSH
59328: PPUSH
59329: PPUSH
59330: PPUSH
59331: PPUSH
59332: PPUSH
// result := [ ] ;
59333: LD_ADDR_VAR 0 7
59337: PUSH
59338: EMPTY
59339: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59340: LD_VAR 0 1
59344: PPUSH
59345: CALL_OW 266
59349: PUSH
59350: LD_INT 0
59352: PUSH
59353: LD_INT 1
59355: PUSH
59356: EMPTY
59357: LIST
59358: LIST
59359: IN
59360: NOT
59361: IFFALSE 59365
// exit ;
59363: GO 60999
// if name then
59365: LD_VAR 0 3
59369: IFFALSE 59385
// SetBName ( base_dep , name ) ;
59371: LD_VAR 0 1
59375: PPUSH
59376: LD_VAR 0 3
59380: PPUSH
59381: CALL_OW 500
// base := GetBase ( base_dep ) ;
59385: LD_ADDR_VAR 0 15
59389: PUSH
59390: LD_VAR 0 1
59394: PPUSH
59395: CALL_OW 274
59399: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59400: LD_ADDR_VAR 0 16
59404: PUSH
59405: LD_VAR 0 1
59409: PPUSH
59410: CALL_OW 255
59414: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59415: LD_ADDR_VAR 0 17
59419: PUSH
59420: LD_VAR 0 1
59424: PPUSH
59425: CALL_OW 248
59429: ST_TO_ADDR
// if sources then
59430: LD_VAR 0 5
59434: IFFALSE 59481
// for i = 1 to 3 do
59436: LD_ADDR_VAR 0 8
59440: PUSH
59441: DOUBLE
59442: LD_INT 1
59444: DEC
59445: ST_TO_ADDR
59446: LD_INT 3
59448: PUSH
59449: FOR_TO
59450: IFFALSE 59479
// AddResourceType ( base , i , sources [ i ] ) ;
59452: LD_VAR 0 15
59456: PPUSH
59457: LD_VAR 0 8
59461: PPUSH
59462: LD_VAR 0 5
59466: PUSH
59467: LD_VAR 0 8
59471: ARRAY
59472: PPUSH
59473: CALL_OW 276
59477: GO 59449
59479: POP
59480: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59481: LD_ADDR_VAR 0 18
59485: PUSH
59486: LD_VAR 0 15
59490: PPUSH
59491: LD_VAR 0 2
59495: PPUSH
59496: LD_INT 1
59498: PPUSH
59499: CALL 58741 0 3
59503: ST_TO_ADDR
// InitHc ;
59504: CALL_OW 19
// InitUc ;
59508: CALL_OW 18
// uc_side := side ;
59512: LD_ADDR_OWVAR 20
59516: PUSH
59517: LD_VAR 0 16
59521: ST_TO_ADDR
// uc_nation := nation ;
59522: LD_ADDR_OWVAR 21
59526: PUSH
59527: LD_VAR 0 17
59531: ST_TO_ADDR
// if buildings then
59532: LD_VAR 0 18
59536: IFFALSE 60858
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59538: LD_ADDR_VAR 0 19
59542: PUSH
59543: LD_VAR 0 18
59547: PPUSH
59548: LD_INT 2
59550: PUSH
59551: LD_INT 30
59553: PUSH
59554: LD_INT 29
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: PUSH
59561: LD_INT 30
59563: PUSH
59564: LD_INT 30
59566: PUSH
59567: EMPTY
59568: LIST
59569: LIST
59570: PUSH
59571: EMPTY
59572: LIST
59573: LIST
59574: LIST
59575: PPUSH
59576: CALL_OW 72
59580: ST_TO_ADDR
// if tmp then
59581: LD_VAR 0 19
59585: IFFALSE 59633
// for i in tmp do
59587: LD_ADDR_VAR 0 8
59591: PUSH
59592: LD_VAR 0 19
59596: PUSH
59597: FOR_IN
59598: IFFALSE 59631
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59600: LD_VAR 0 8
59604: PPUSH
59605: CALL_OW 250
59609: PPUSH
59610: LD_VAR 0 8
59614: PPUSH
59615: CALL_OW 251
59619: PPUSH
59620: LD_VAR 0 16
59624: PPUSH
59625: CALL_OW 441
59629: GO 59597
59631: POP
59632: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59633: LD_VAR 0 18
59637: PPUSH
59638: LD_INT 2
59640: PUSH
59641: LD_INT 30
59643: PUSH
59644: LD_INT 32
59646: PUSH
59647: EMPTY
59648: LIST
59649: LIST
59650: PUSH
59651: LD_INT 30
59653: PUSH
59654: LD_INT 33
59656: PUSH
59657: EMPTY
59658: LIST
59659: LIST
59660: PUSH
59661: EMPTY
59662: LIST
59663: LIST
59664: LIST
59665: PPUSH
59666: CALL_OW 72
59670: IFFALSE 59758
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59672: LD_ADDR_VAR 0 8
59676: PUSH
59677: LD_VAR 0 18
59681: PPUSH
59682: LD_INT 2
59684: PUSH
59685: LD_INT 30
59687: PUSH
59688: LD_INT 32
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: LD_INT 30
59697: PUSH
59698: LD_INT 33
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: PPUSH
59710: CALL_OW 72
59714: PUSH
59715: FOR_IN
59716: IFFALSE 59756
// begin if not GetBWeapon ( i ) then
59718: LD_VAR 0 8
59722: PPUSH
59723: CALL_OW 269
59727: NOT
59728: IFFALSE 59754
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59730: LD_VAR 0 8
59734: PPUSH
59735: LD_VAR 0 8
59739: PPUSH
59740: LD_VAR 0 2
59744: PPUSH
59745: CALL 61004 0 2
59749: PPUSH
59750: CALL_OW 431
// end ;
59754: GO 59715
59756: POP
59757: POP
// end ; for i = 1 to personel do
59758: LD_ADDR_VAR 0 8
59762: PUSH
59763: DOUBLE
59764: LD_INT 1
59766: DEC
59767: ST_TO_ADDR
59768: LD_VAR 0 6
59772: PUSH
59773: FOR_TO
59774: IFFALSE 60838
// begin if i > 4 then
59776: LD_VAR 0 8
59780: PUSH
59781: LD_INT 4
59783: GREATER
59784: IFFALSE 59788
// break ;
59786: GO 60838
// case i of 1 :
59788: LD_VAR 0 8
59792: PUSH
59793: LD_INT 1
59795: DOUBLE
59796: EQUAL
59797: IFTRUE 59801
59799: GO 59881
59801: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59802: LD_ADDR_VAR 0 12
59806: PUSH
59807: LD_VAR 0 18
59811: PPUSH
59812: LD_INT 22
59814: PUSH
59815: LD_VAR 0 16
59819: PUSH
59820: EMPTY
59821: LIST
59822: LIST
59823: PUSH
59824: LD_INT 58
59826: PUSH
59827: EMPTY
59828: LIST
59829: PUSH
59830: LD_INT 2
59832: PUSH
59833: LD_INT 30
59835: PUSH
59836: LD_INT 32
59838: PUSH
59839: EMPTY
59840: LIST
59841: LIST
59842: PUSH
59843: LD_INT 30
59845: PUSH
59846: LD_INT 4
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 30
59855: PUSH
59856: LD_INT 5
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: LIST
59868: PUSH
59869: EMPTY
59870: LIST
59871: LIST
59872: LIST
59873: PPUSH
59874: CALL_OW 72
59878: ST_TO_ADDR
59879: GO 60103
59881: LD_INT 2
59883: DOUBLE
59884: EQUAL
59885: IFTRUE 59889
59887: GO 59951
59889: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59890: LD_ADDR_VAR 0 12
59894: PUSH
59895: LD_VAR 0 18
59899: PPUSH
59900: LD_INT 22
59902: PUSH
59903: LD_VAR 0 16
59907: PUSH
59908: EMPTY
59909: LIST
59910: LIST
59911: PUSH
59912: LD_INT 2
59914: PUSH
59915: LD_INT 30
59917: PUSH
59918: LD_INT 0
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 30
59927: PUSH
59928: LD_INT 1
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: LIST
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: PPUSH
59944: CALL_OW 72
59948: ST_TO_ADDR
59949: GO 60103
59951: LD_INT 3
59953: DOUBLE
59954: EQUAL
59955: IFTRUE 59959
59957: GO 60021
59959: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59960: LD_ADDR_VAR 0 12
59964: PUSH
59965: LD_VAR 0 18
59969: PPUSH
59970: LD_INT 22
59972: PUSH
59973: LD_VAR 0 16
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: PUSH
59982: LD_INT 2
59984: PUSH
59985: LD_INT 30
59987: PUSH
59988: LD_INT 2
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: PUSH
59995: LD_INT 30
59997: PUSH
59998: LD_INT 3
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: LIST
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PPUSH
60014: CALL_OW 72
60018: ST_TO_ADDR
60019: GO 60103
60021: LD_INT 4
60023: DOUBLE
60024: EQUAL
60025: IFTRUE 60029
60027: GO 60102
60029: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60030: LD_ADDR_VAR 0 12
60034: PUSH
60035: LD_VAR 0 18
60039: PPUSH
60040: LD_INT 22
60042: PUSH
60043: LD_VAR 0 16
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PUSH
60052: LD_INT 2
60054: PUSH
60055: LD_INT 30
60057: PUSH
60058: LD_INT 6
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: PUSH
60065: LD_INT 30
60067: PUSH
60068: LD_INT 7
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PUSH
60075: LD_INT 30
60077: PUSH
60078: LD_INT 8
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: PUSH
60085: EMPTY
60086: LIST
60087: LIST
60088: LIST
60089: LIST
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: PPUSH
60095: CALL_OW 72
60099: ST_TO_ADDR
60100: GO 60103
60102: POP
// if i = 1 then
60103: LD_VAR 0 8
60107: PUSH
60108: LD_INT 1
60110: EQUAL
60111: IFFALSE 60222
// begin tmp := [ ] ;
60113: LD_ADDR_VAR 0 19
60117: PUSH
60118: EMPTY
60119: ST_TO_ADDR
// for j in f do
60120: LD_ADDR_VAR 0 9
60124: PUSH
60125: LD_VAR 0 12
60129: PUSH
60130: FOR_IN
60131: IFFALSE 60204
// if GetBType ( j ) = b_bunker then
60133: LD_VAR 0 9
60137: PPUSH
60138: CALL_OW 266
60142: PUSH
60143: LD_INT 32
60145: EQUAL
60146: IFFALSE 60173
// tmp := Insert ( tmp , 1 , j ) else
60148: LD_ADDR_VAR 0 19
60152: PUSH
60153: LD_VAR 0 19
60157: PPUSH
60158: LD_INT 1
60160: PPUSH
60161: LD_VAR 0 9
60165: PPUSH
60166: CALL_OW 2
60170: ST_TO_ADDR
60171: GO 60202
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60173: LD_ADDR_VAR 0 19
60177: PUSH
60178: LD_VAR 0 19
60182: PPUSH
60183: LD_VAR 0 19
60187: PUSH
60188: LD_INT 1
60190: PLUS
60191: PPUSH
60192: LD_VAR 0 9
60196: PPUSH
60197: CALL_OW 2
60201: ST_TO_ADDR
60202: GO 60130
60204: POP
60205: POP
// if tmp then
60206: LD_VAR 0 19
60210: IFFALSE 60222
// f := tmp ;
60212: LD_ADDR_VAR 0 12
60216: PUSH
60217: LD_VAR 0 19
60221: ST_TO_ADDR
// end ; x := personel [ i ] ;
60222: LD_ADDR_VAR 0 13
60226: PUSH
60227: LD_VAR 0 6
60231: PUSH
60232: LD_VAR 0 8
60236: ARRAY
60237: ST_TO_ADDR
// if x = - 1 then
60238: LD_VAR 0 13
60242: PUSH
60243: LD_INT 1
60245: NEG
60246: EQUAL
60247: IFFALSE 60456
// begin for j in f do
60249: LD_ADDR_VAR 0 9
60253: PUSH
60254: LD_VAR 0 12
60258: PUSH
60259: FOR_IN
60260: IFFALSE 60452
// repeat InitHc ;
60262: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60266: LD_VAR 0 9
60270: PPUSH
60271: CALL_OW 266
60275: PUSH
60276: LD_INT 5
60278: EQUAL
60279: IFFALSE 60349
// begin if UnitsInside ( j ) < 3 then
60281: LD_VAR 0 9
60285: PPUSH
60286: CALL_OW 313
60290: PUSH
60291: LD_INT 3
60293: LESS
60294: IFFALSE 60330
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60296: LD_INT 0
60298: PPUSH
60299: LD_INT 5
60301: PUSH
60302: LD_INT 8
60304: PUSH
60305: LD_INT 9
60307: PUSH
60308: EMPTY
60309: LIST
60310: LIST
60311: LIST
60312: PUSH
60313: LD_VAR 0 17
60317: ARRAY
60318: PPUSH
60319: LD_VAR 0 4
60323: PPUSH
60324: CALL_OW 380
60328: GO 60347
// PrepareHuman ( false , i , skill ) ;
60330: LD_INT 0
60332: PPUSH
60333: LD_VAR 0 8
60337: PPUSH
60338: LD_VAR 0 4
60342: PPUSH
60343: CALL_OW 380
// end else
60347: GO 60366
// PrepareHuman ( false , i , skill ) ;
60349: LD_INT 0
60351: PPUSH
60352: LD_VAR 0 8
60356: PPUSH
60357: LD_VAR 0 4
60361: PPUSH
60362: CALL_OW 380
// un := CreateHuman ;
60366: LD_ADDR_VAR 0 14
60370: PUSH
60371: CALL_OW 44
60375: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60376: LD_ADDR_VAR 0 7
60380: PUSH
60381: LD_VAR 0 7
60385: PPUSH
60386: LD_INT 1
60388: PPUSH
60389: LD_VAR 0 14
60393: PPUSH
60394: CALL_OW 2
60398: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60399: LD_VAR 0 14
60403: PPUSH
60404: LD_VAR 0 9
60408: PPUSH
60409: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60413: LD_VAR 0 9
60417: PPUSH
60418: CALL_OW 313
60422: PUSH
60423: LD_INT 6
60425: EQUAL
60426: PUSH
60427: LD_VAR 0 9
60431: PPUSH
60432: CALL_OW 266
60436: PUSH
60437: LD_INT 32
60439: PUSH
60440: LD_INT 31
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: IN
60447: OR
60448: IFFALSE 60262
60450: GO 60259
60452: POP
60453: POP
// end else
60454: GO 60836
// for j = 1 to x do
60456: LD_ADDR_VAR 0 9
60460: PUSH
60461: DOUBLE
60462: LD_INT 1
60464: DEC
60465: ST_TO_ADDR
60466: LD_VAR 0 13
60470: PUSH
60471: FOR_TO
60472: IFFALSE 60834
// begin InitHc ;
60474: CALL_OW 19
// if not f then
60478: LD_VAR 0 12
60482: NOT
60483: IFFALSE 60572
// begin PrepareHuman ( false , i , skill ) ;
60485: LD_INT 0
60487: PPUSH
60488: LD_VAR 0 8
60492: PPUSH
60493: LD_VAR 0 4
60497: PPUSH
60498: CALL_OW 380
// un := CreateHuman ;
60502: LD_ADDR_VAR 0 14
60506: PUSH
60507: CALL_OW 44
60511: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60512: LD_ADDR_VAR 0 7
60516: PUSH
60517: LD_VAR 0 7
60521: PPUSH
60522: LD_INT 1
60524: PPUSH
60525: LD_VAR 0 14
60529: PPUSH
60530: CALL_OW 2
60534: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60535: LD_VAR 0 14
60539: PPUSH
60540: LD_VAR 0 1
60544: PPUSH
60545: CALL_OW 250
60549: PPUSH
60550: LD_VAR 0 1
60554: PPUSH
60555: CALL_OW 251
60559: PPUSH
60560: LD_INT 10
60562: PPUSH
60563: LD_INT 0
60565: PPUSH
60566: CALL_OW 50
// continue ;
60570: GO 60471
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60572: LD_VAR 0 12
60576: PUSH
60577: LD_INT 1
60579: ARRAY
60580: PPUSH
60581: CALL_OW 313
60585: PUSH
60586: LD_VAR 0 12
60590: PUSH
60591: LD_INT 1
60593: ARRAY
60594: PPUSH
60595: CALL_OW 266
60599: PUSH
60600: LD_INT 32
60602: PUSH
60603: LD_INT 31
60605: PUSH
60606: EMPTY
60607: LIST
60608: LIST
60609: IN
60610: AND
60611: PUSH
60612: LD_VAR 0 12
60616: PUSH
60617: LD_INT 1
60619: ARRAY
60620: PPUSH
60621: CALL_OW 313
60625: PUSH
60626: LD_INT 6
60628: EQUAL
60629: OR
60630: IFFALSE 60650
// f := Delete ( f , 1 ) ;
60632: LD_ADDR_VAR 0 12
60636: PUSH
60637: LD_VAR 0 12
60641: PPUSH
60642: LD_INT 1
60644: PPUSH
60645: CALL_OW 3
60649: ST_TO_ADDR
// if not f then
60650: LD_VAR 0 12
60654: NOT
60655: IFFALSE 60673
// begin x := x + 2 ;
60657: LD_ADDR_VAR 0 13
60661: PUSH
60662: LD_VAR 0 13
60666: PUSH
60667: LD_INT 2
60669: PLUS
60670: ST_TO_ADDR
// continue ;
60671: GO 60471
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60673: LD_VAR 0 12
60677: PUSH
60678: LD_INT 1
60680: ARRAY
60681: PPUSH
60682: CALL_OW 266
60686: PUSH
60687: LD_INT 5
60689: EQUAL
60690: IFFALSE 60764
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60692: LD_VAR 0 12
60696: PUSH
60697: LD_INT 1
60699: ARRAY
60700: PPUSH
60701: CALL_OW 313
60705: PUSH
60706: LD_INT 3
60708: LESS
60709: IFFALSE 60745
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60711: LD_INT 0
60713: PPUSH
60714: LD_INT 5
60716: PUSH
60717: LD_INT 8
60719: PUSH
60720: LD_INT 9
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: PUSH
60728: LD_VAR 0 17
60732: ARRAY
60733: PPUSH
60734: LD_VAR 0 4
60738: PPUSH
60739: CALL_OW 380
60743: GO 60762
// PrepareHuman ( false , i , skill ) ;
60745: LD_INT 0
60747: PPUSH
60748: LD_VAR 0 8
60752: PPUSH
60753: LD_VAR 0 4
60757: PPUSH
60758: CALL_OW 380
// end else
60762: GO 60781
// PrepareHuman ( false , i , skill ) ;
60764: LD_INT 0
60766: PPUSH
60767: LD_VAR 0 8
60771: PPUSH
60772: LD_VAR 0 4
60776: PPUSH
60777: CALL_OW 380
// un := CreateHuman ;
60781: LD_ADDR_VAR 0 14
60785: PUSH
60786: CALL_OW 44
60790: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60791: LD_ADDR_VAR 0 7
60795: PUSH
60796: LD_VAR 0 7
60800: PPUSH
60801: LD_INT 1
60803: PPUSH
60804: LD_VAR 0 14
60808: PPUSH
60809: CALL_OW 2
60813: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60814: LD_VAR 0 14
60818: PPUSH
60819: LD_VAR 0 12
60823: PUSH
60824: LD_INT 1
60826: ARRAY
60827: PPUSH
60828: CALL_OW 52
// end ;
60832: GO 60471
60834: POP
60835: POP
// end ;
60836: GO 59773
60838: POP
60839: POP
// result := result ^ buildings ;
60840: LD_ADDR_VAR 0 7
60844: PUSH
60845: LD_VAR 0 7
60849: PUSH
60850: LD_VAR 0 18
60854: ADD
60855: ST_TO_ADDR
// end else
60856: GO 60999
// begin for i = 1 to personel do
60858: LD_ADDR_VAR 0 8
60862: PUSH
60863: DOUBLE
60864: LD_INT 1
60866: DEC
60867: ST_TO_ADDR
60868: LD_VAR 0 6
60872: PUSH
60873: FOR_TO
60874: IFFALSE 60997
// begin if i > 4 then
60876: LD_VAR 0 8
60880: PUSH
60881: LD_INT 4
60883: GREATER
60884: IFFALSE 60888
// break ;
60886: GO 60997
// x := personel [ i ] ;
60888: LD_ADDR_VAR 0 13
60892: PUSH
60893: LD_VAR 0 6
60897: PUSH
60898: LD_VAR 0 8
60902: ARRAY
60903: ST_TO_ADDR
// if x = - 1 then
60904: LD_VAR 0 13
60908: PUSH
60909: LD_INT 1
60911: NEG
60912: EQUAL
60913: IFFALSE 60917
// continue ;
60915: GO 60873
// PrepareHuman ( false , i , skill ) ;
60917: LD_INT 0
60919: PPUSH
60920: LD_VAR 0 8
60924: PPUSH
60925: LD_VAR 0 4
60929: PPUSH
60930: CALL_OW 380
// un := CreateHuman ;
60934: LD_ADDR_VAR 0 14
60938: PUSH
60939: CALL_OW 44
60943: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60944: LD_VAR 0 14
60948: PPUSH
60949: LD_VAR 0 1
60953: PPUSH
60954: CALL_OW 250
60958: PPUSH
60959: LD_VAR 0 1
60963: PPUSH
60964: CALL_OW 251
60968: PPUSH
60969: LD_INT 10
60971: PPUSH
60972: LD_INT 0
60974: PPUSH
60975: CALL_OW 50
// result := result ^ un ;
60979: LD_ADDR_VAR 0 7
60983: PUSH
60984: LD_VAR 0 7
60988: PUSH
60989: LD_VAR 0 14
60993: ADD
60994: ST_TO_ADDR
// end ;
60995: GO 60873
60997: POP
60998: POP
// end ; end ;
60999: LD_VAR 0 7
61003: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61004: LD_INT 0
61006: PPUSH
61007: PPUSH
61008: PPUSH
61009: PPUSH
61010: PPUSH
61011: PPUSH
61012: PPUSH
61013: PPUSH
61014: PPUSH
61015: PPUSH
61016: PPUSH
61017: PPUSH
61018: PPUSH
61019: PPUSH
61020: PPUSH
61021: PPUSH
// result := false ;
61022: LD_ADDR_VAR 0 3
61026: PUSH
61027: LD_INT 0
61029: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61030: LD_VAR 0 1
61034: NOT
61035: PUSH
61036: LD_VAR 0 1
61040: PPUSH
61041: CALL_OW 266
61045: PUSH
61046: LD_INT 32
61048: PUSH
61049: LD_INT 33
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: IN
61056: NOT
61057: OR
61058: IFFALSE 61062
// exit ;
61060: GO 62201
// nat := GetNation ( tower ) ;
61062: LD_ADDR_VAR 0 12
61066: PUSH
61067: LD_VAR 0 1
61071: PPUSH
61072: CALL_OW 248
61076: ST_TO_ADDR
// side := GetSide ( tower ) ;
61077: LD_ADDR_VAR 0 16
61081: PUSH
61082: LD_VAR 0 1
61086: PPUSH
61087: CALL_OW 255
61091: ST_TO_ADDR
// x := GetX ( tower ) ;
61092: LD_ADDR_VAR 0 10
61096: PUSH
61097: LD_VAR 0 1
61101: PPUSH
61102: CALL_OW 250
61106: ST_TO_ADDR
// y := GetY ( tower ) ;
61107: LD_ADDR_VAR 0 11
61111: PUSH
61112: LD_VAR 0 1
61116: PPUSH
61117: CALL_OW 251
61121: ST_TO_ADDR
// if not x or not y then
61122: LD_VAR 0 10
61126: NOT
61127: PUSH
61128: LD_VAR 0 11
61132: NOT
61133: OR
61134: IFFALSE 61138
// exit ;
61136: GO 62201
// weapon := 0 ;
61138: LD_ADDR_VAR 0 18
61142: PUSH
61143: LD_INT 0
61145: ST_TO_ADDR
// fac_list := [ ] ;
61146: LD_ADDR_VAR 0 17
61150: PUSH
61151: EMPTY
61152: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61153: LD_ADDR_VAR 0 6
61157: PUSH
61158: LD_VAR 0 1
61162: PPUSH
61163: CALL_OW 274
61167: PPUSH
61168: LD_VAR 0 2
61172: PPUSH
61173: LD_INT 0
61175: PPUSH
61176: CALL 58741 0 3
61180: PPUSH
61181: LD_INT 30
61183: PUSH
61184: LD_INT 3
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PPUSH
61191: CALL_OW 72
61195: ST_TO_ADDR
// if not factories then
61196: LD_VAR 0 6
61200: NOT
61201: IFFALSE 61205
// exit ;
61203: GO 62201
// for i in factories do
61205: LD_ADDR_VAR 0 8
61209: PUSH
61210: LD_VAR 0 6
61214: PUSH
61215: FOR_IN
61216: IFFALSE 61241
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61218: LD_ADDR_VAR 0 17
61222: PUSH
61223: LD_VAR 0 17
61227: PUSH
61228: LD_VAR 0 8
61232: PPUSH
61233: CALL_OW 478
61237: UNION
61238: ST_TO_ADDR
61239: GO 61215
61241: POP
61242: POP
// if not fac_list then
61243: LD_VAR 0 17
61247: NOT
61248: IFFALSE 61252
// exit ;
61250: GO 62201
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61252: LD_ADDR_VAR 0 5
61256: PUSH
61257: LD_INT 4
61259: PUSH
61260: LD_INT 5
61262: PUSH
61263: LD_INT 9
61265: PUSH
61266: LD_INT 10
61268: PUSH
61269: LD_INT 6
61271: PUSH
61272: LD_INT 7
61274: PUSH
61275: LD_INT 11
61277: PUSH
61278: EMPTY
61279: LIST
61280: LIST
61281: LIST
61282: LIST
61283: LIST
61284: LIST
61285: LIST
61286: PUSH
61287: LD_INT 27
61289: PUSH
61290: LD_INT 28
61292: PUSH
61293: LD_INT 26
61295: PUSH
61296: LD_INT 30
61298: PUSH
61299: EMPTY
61300: LIST
61301: LIST
61302: LIST
61303: LIST
61304: PUSH
61305: LD_INT 43
61307: PUSH
61308: LD_INT 44
61310: PUSH
61311: LD_INT 46
61313: PUSH
61314: LD_INT 45
61316: PUSH
61317: LD_INT 47
61319: PUSH
61320: LD_INT 49
61322: PUSH
61323: EMPTY
61324: LIST
61325: LIST
61326: LIST
61327: LIST
61328: LIST
61329: LIST
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: LIST
61335: PUSH
61336: LD_VAR 0 12
61340: ARRAY
61341: ST_TO_ADDR
// for i in list do
61342: LD_ADDR_VAR 0 8
61346: PUSH
61347: LD_VAR 0 5
61351: PUSH
61352: FOR_IN
61353: IFFALSE 61386
// if not i in fac_list then
61355: LD_VAR 0 8
61359: PUSH
61360: LD_VAR 0 17
61364: IN
61365: NOT
61366: IFFALSE 61384
// list := list diff i ;
61368: LD_ADDR_VAR 0 5
61372: PUSH
61373: LD_VAR 0 5
61377: PUSH
61378: LD_VAR 0 8
61382: DIFF
61383: ST_TO_ADDR
61384: GO 61352
61386: POP
61387: POP
// if not list then
61388: LD_VAR 0 5
61392: NOT
61393: IFFALSE 61397
// exit ;
61395: GO 62201
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61397: LD_VAR 0 12
61401: PUSH
61402: LD_INT 3
61404: EQUAL
61405: PUSH
61406: LD_INT 49
61408: PUSH
61409: LD_VAR 0 5
61413: IN
61414: AND
61415: PUSH
61416: LD_INT 31
61418: PPUSH
61419: LD_VAR 0 16
61423: PPUSH
61424: CALL_OW 321
61428: PUSH
61429: LD_INT 2
61431: EQUAL
61432: AND
61433: IFFALSE 61493
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61435: LD_INT 22
61437: PUSH
61438: LD_VAR 0 16
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: PUSH
61447: LD_INT 35
61449: PUSH
61450: LD_INT 49
61452: PUSH
61453: EMPTY
61454: LIST
61455: LIST
61456: PUSH
61457: LD_INT 91
61459: PUSH
61460: LD_VAR 0 1
61464: PUSH
61465: LD_INT 10
61467: PUSH
61468: EMPTY
61469: LIST
61470: LIST
61471: LIST
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: LIST
61477: PPUSH
61478: CALL_OW 69
61482: NOT
61483: IFFALSE 61493
// weapon := ru_time_lapser ;
61485: LD_ADDR_VAR 0 18
61489: PUSH
61490: LD_INT 49
61492: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61493: LD_VAR 0 12
61497: PUSH
61498: LD_INT 1
61500: PUSH
61501: LD_INT 2
61503: PUSH
61504: EMPTY
61505: LIST
61506: LIST
61507: IN
61508: PUSH
61509: LD_INT 11
61511: PUSH
61512: LD_VAR 0 5
61516: IN
61517: PUSH
61518: LD_INT 30
61520: PUSH
61521: LD_VAR 0 5
61525: IN
61526: OR
61527: AND
61528: PUSH
61529: LD_INT 6
61531: PPUSH
61532: LD_VAR 0 16
61536: PPUSH
61537: CALL_OW 321
61541: PUSH
61542: LD_INT 2
61544: EQUAL
61545: AND
61546: IFFALSE 61711
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61548: LD_INT 22
61550: PUSH
61551: LD_VAR 0 16
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 2
61562: PUSH
61563: LD_INT 35
61565: PUSH
61566: LD_INT 11
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: LD_INT 35
61575: PUSH
61576: LD_INT 30
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: LIST
61587: PUSH
61588: LD_INT 91
61590: PUSH
61591: LD_VAR 0 1
61595: PUSH
61596: LD_INT 18
61598: PUSH
61599: EMPTY
61600: LIST
61601: LIST
61602: LIST
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: LIST
61608: PPUSH
61609: CALL_OW 69
61613: NOT
61614: PUSH
61615: LD_INT 22
61617: PUSH
61618: LD_VAR 0 16
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: PUSH
61627: LD_INT 2
61629: PUSH
61630: LD_INT 30
61632: PUSH
61633: LD_INT 32
61635: PUSH
61636: EMPTY
61637: LIST
61638: LIST
61639: PUSH
61640: LD_INT 30
61642: PUSH
61643: LD_INT 33
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: LIST
61654: PUSH
61655: LD_INT 91
61657: PUSH
61658: LD_VAR 0 1
61662: PUSH
61663: LD_INT 12
61665: PUSH
61666: EMPTY
61667: LIST
61668: LIST
61669: LIST
61670: PUSH
61671: EMPTY
61672: LIST
61673: LIST
61674: LIST
61675: PUSH
61676: EMPTY
61677: LIST
61678: PPUSH
61679: CALL_OW 69
61683: PUSH
61684: LD_INT 2
61686: GREATER
61687: AND
61688: IFFALSE 61711
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61690: LD_ADDR_VAR 0 18
61694: PUSH
61695: LD_INT 11
61697: PUSH
61698: LD_INT 30
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: PUSH
61705: LD_VAR 0 12
61709: ARRAY
61710: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61711: LD_VAR 0 18
61715: NOT
61716: PUSH
61717: LD_INT 40
61719: PPUSH
61720: LD_VAR 0 16
61724: PPUSH
61725: CALL_OW 321
61729: PUSH
61730: LD_INT 2
61732: EQUAL
61733: AND
61734: PUSH
61735: LD_INT 7
61737: PUSH
61738: LD_VAR 0 5
61742: IN
61743: PUSH
61744: LD_INT 28
61746: PUSH
61747: LD_VAR 0 5
61751: IN
61752: OR
61753: PUSH
61754: LD_INT 45
61756: PUSH
61757: LD_VAR 0 5
61761: IN
61762: OR
61763: AND
61764: IFFALSE 62018
// begin hex := GetHexInfo ( x , y ) ;
61766: LD_ADDR_VAR 0 4
61770: PUSH
61771: LD_VAR 0 10
61775: PPUSH
61776: LD_VAR 0 11
61780: PPUSH
61781: CALL_OW 546
61785: ST_TO_ADDR
// if hex [ 1 ] then
61786: LD_VAR 0 4
61790: PUSH
61791: LD_INT 1
61793: ARRAY
61794: IFFALSE 61798
// exit ;
61796: GO 62201
// height := hex [ 2 ] ;
61798: LD_ADDR_VAR 0 15
61802: PUSH
61803: LD_VAR 0 4
61807: PUSH
61808: LD_INT 2
61810: ARRAY
61811: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61812: LD_ADDR_VAR 0 14
61816: PUSH
61817: LD_INT 0
61819: PUSH
61820: LD_INT 2
61822: PUSH
61823: LD_INT 3
61825: PUSH
61826: LD_INT 5
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: LIST
61833: LIST
61834: ST_TO_ADDR
// for i in tmp do
61835: LD_ADDR_VAR 0 8
61839: PUSH
61840: LD_VAR 0 14
61844: PUSH
61845: FOR_IN
61846: IFFALSE 62016
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61848: LD_ADDR_VAR 0 9
61852: PUSH
61853: LD_VAR 0 10
61857: PPUSH
61858: LD_VAR 0 8
61862: PPUSH
61863: LD_INT 5
61865: PPUSH
61866: CALL_OW 272
61870: PUSH
61871: LD_VAR 0 11
61875: PPUSH
61876: LD_VAR 0 8
61880: PPUSH
61881: LD_INT 5
61883: PPUSH
61884: CALL_OW 273
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61893: LD_VAR 0 9
61897: PUSH
61898: LD_INT 1
61900: ARRAY
61901: PPUSH
61902: LD_VAR 0 9
61906: PUSH
61907: LD_INT 2
61909: ARRAY
61910: PPUSH
61911: CALL_OW 488
61915: IFFALSE 62014
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61917: LD_ADDR_VAR 0 4
61921: PUSH
61922: LD_VAR 0 9
61926: PUSH
61927: LD_INT 1
61929: ARRAY
61930: PPUSH
61931: LD_VAR 0 9
61935: PUSH
61936: LD_INT 2
61938: ARRAY
61939: PPUSH
61940: CALL_OW 546
61944: ST_TO_ADDR
// if hex [ 1 ] then
61945: LD_VAR 0 4
61949: PUSH
61950: LD_INT 1
61952: ARRAY
61953: IFFALSE 61957
// continue ;
61955: GO 61845
// h := hex [ 2 ] ;
61957: LD_ADDR_VAR 0 13
61961: PUSH
61962: LD_VAR 0 4
61966: PUSH
61967: LD_INT 2
61969: ARRAY
61970: ST_TO_ADDR
// if h + 7 < height then
61971: LD_VAR 0 13
61975: PUSH
61976: LD_INT 7
61978: PLUS
61979: PUSH
61980: LD_VAR 0 15
61984: LESS
61985: IFFALSE 62014
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61987: LD_ADDR_VAR 0 18
61991: PUSH
61992: LD_INT 7
61994: PUSH
61995: LD_INT 28
61997: PUSH
61998: LD_INT 45
62000: PUSH
62001: EMPTY
62002: LIST
62003: LIST
62004: LIST
62005: PUSH
62006: LD_VAR 0 12
62010: ARRAY
62011: ST_TO_ADDR
// break ;
62012: GO 62016
// end ; end ; end ;
62014: GO 61845
62016: POP
62017: POP
// end ; if not weapon then
62018: LD_VAR 0 18
62022: NOT
62023: IFFALSE 62083
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62025: LD_ADDR_VAR 0 5
62029: PUSH
62030: LD_VAR 0 5
62034: PUSH
62035: LD_INT 11
62037: PUSH
62038: LD_INT 30
62040: PUSH
62041: LD_INT 49
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: LIST
62048: DIFF
62049: ST_TO_ADDR
// if not list then
62050: LD_VAR 0 5
62054: NOT
62055: IFFALSE 62059
// exit ;
62057: GO 62201
// weapon := list [ rand ( 1 , list ) ] ;
62059: LD_ADDR_VAR 0 18
62063: PUSH
62064: LD_VAR 0 5
62068: PUSH
62069: LD_INT 1
62071: PPUSH
62072: LD_VAR 0 5
62076: PPUSH
62077: CALL_OW 12
62081: ARRAY
62082: ST_TO_ADDR
// end ; if weapon then
62083: LD_VAR 0 18
62087: IFFALSE 62201
// begin tmp := CostOfWeapon ( weapon ) ;
62089: LD_ADDR_VAR 0 14
62093: PUSH
62094: LD_VAR 0 18
62098: PPUSH
62099: CALL_OW 451
62103: ST_TO_ADDR
// j := GetBase ( tower ) ;
62104: LD_ADDR_VAR 0 9
62108: PUSH
62109: LD_VAR 0 1
62113: PPUSH
62114: CALL_OW 274
62118: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62119: LD_VAR 0 9
62123: PPUSH
62124: LD_INT 1
62126: PPUSH
62127: CALL_OW 275
62131: PUSH
62132: LD_VAR 0 14
62136: PUSH
62137: LD_INT 1
62139: ARRAY
62140: GREATEREQUAL
62141: PUSH
62142: LD_VAR 0 9
62146: PPUSH
62147: LD_INT 2
62149: PPUSH
62150: CALL_OW 275
62154: PUSH
62155: LD_VAR 0 14
62159: PUSH
62160: LD_INT 2
62162: ARRAY
62163: GREATEREQUAL
62164: AND
62165: PUSH
62166: LD_VAR 0 9
62170: PPUSH
62171: LD_INT 3
62173: PPUSH
62174: CALL_OW 275
62178: PUSH
62179: LD_VAR 0 14
62183: PUSH
62184: LD_INT 3
62186: ARRAY
62187: GREATEREQUAL
62188: AND
62189: IFFALSE 62201
// result := weapon ;
62191: LD_ADDR_VAR 0 3
62195: PUSH
62196: LD_VAR 0 18
62200: ST_TO_ADDR
// end ; end ;
62201: LD_VAR 0 3
62205: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62206: LD_INT 0
62208: PPUSH
62209: PPUSH
// result := true ;
62210: LD_ADDR_VAR 0 3
62214: PUSH
62215: LD_INT 1
62217: ST_TO_ADDR
// if array1 = array2 then
62218: LD_VAR 0 1
62222: PUSH
62223: LD_VAR 0 2
62227: EQUAL
62228: IFFALSE 62288
// begin for i = 1 to array1 do
62230: LD_ADDR_VAR 0 4
62234: PUSH
62235: DOUBLE
62236: LD_INT 1
62238: DEC
62239: ST_TO_ADDR
62240: LD_VAR 0 1
62244: PUSH
62245: FOR_TO
62246: IFFALSE 62284
// if array1 [ i ] <> array2 [ i ] then
62248: LD_VAR 0 1
62252: PUSH
62253: LD_VAR 0 4
62257: ARRAY
62258: PUSH
62259: LD_VAR 0 2
62263: PUSH
62264: LD_VAR 0 4
62268: ARRAY
62269: NONEQUAL
62270: IFFALSE 62282
// begin result := false ;
62272: LD_ADDR_VAR 0 3
62276: PUSH
62277: LD_INT 0
62279: ST_TO_ADDR
// break ;
62280: GO 62284
// end ;
62282: GO 62245
62284: POP
62285: POP
// end else
62286: GO 62296
// result := false ;
62288: LD_ADDR_VAR 0 3
62292: PUSH
62293: LD_INT 0
62295: ST_TO_ADDR
// end ;
62296: LD_VAR 0 3
62300: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62301: LD_INT 0
62303: PPUSH
62304: PPUSH
// if not array1 or not array2 then
62305: LD_VAR 0 1
62309: NOT
62310: PUSH
62311: LD_VAR 0 2
62315: NOT
62316: OR
62317: IFFALSE 62321
// exit ;
62319: GO 62385
// result := true ;
62321: LD_ADDR_VAR 0 3
62325: PUSH
62326: LD_INT 1
62328: ST_TO_ADDR
// for i = 1 to array1 do
62329: LD_ADDR_VAR 0 4
62333: PUSH
62334: DOUBLE
62335: LD_INT 1
62337: DEC
62338: ST_TO_ADDR
62339: LD_VAR 0 1
62343: PUSH
62344: FOR_TO
62345: IFFALSE 62383
// if array1 [ i ] <> array2 [ i ] then
62347: LD_VAR 0 1
62351: PUSH
62352: LD_VAR 0 4
62356: ARRAY
62357: PUSH
62358: LD_VAR 0 2
62362: PUSH
62363: LD_VAR 0 4
62367: ARRAY
62368: NONEQUAL
62369: IFFALSE 62381
// begin result := false ;
62371: LD_ADDR_VAR 0 3
62375: PUSH
62376: LD_INT 0
62378: ST_TO_ADDR
// break ;
62379: GO 62383
// end ;
62381: GO 62344
62383: POP
62384: POP
// end ;
62385: LD_VAR 0 3
62389: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62390: LD_INT 0
62392: PPUSH
62393: PPUSH
62394: PPUSH
// pom := GetBase ( fac ) ;
62395: LD_ADDR_VAR 0 5
62399: PUSH
62400: LD_VAR 0 1
62404: PPUSH
62405: CALL_OW 274
62409: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62410: LD_ADDR_VAR 0 4
62414: PUSH
62415: LD_VAR 0 2
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PPUSH
62424: LD_VAR 0 2
62428: PUSH
62429: LD_INT 2
62431: ARRAY
62432: PPUSH
62433: LD_VAR 0 2
62437: PUSH
62438: LD_INT 3
62440: ARRAY
62441: PPUSH
62442: LD_VAR 0 2
62446: PUSH
62447: LD_INT 4
62449: ARRAY
62450: PPUSH
62451: CALL_OW 449
62455: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62456: LD_ADDR_VAR 0 3
62460: PUSH
62461: LD_VAR 0 5
62465: PPUSH
62466: LD_INT 1
62468: PPUSH
62469: CALL_OW 275
62473: PUSH
62474: LD_VAR 0 4
62478: PUSH
62479: LD_INT 1
62481: ARRAY
62482: GREATEREQUAL
62483: PUSH
62484: LD_VAR 0 5
62488: PPUSH
62489: LD_INT 2
62491: PPUSH
62492: CALL_OW 275
62496: PUSH
62497: LD_VAR 0 4
62501: PUSH
62502: LD_INT 2
62504: ARRAY
62505: GREATEREQUAL
62506: AND
62507: PUSH
62508: LD_VAR 0 5
62512: PPUSH
62513: LD_INT 3
62515: PPUSH
62516: CALL_OW 275
62520: PUSH
62521: LD_VAR 0 4
62525: PUSH
62526: LD_INT 3
62528: ARRAY
62529: GREATEREQUAL
62530: AND
62531: ST_TO_ADDR
// end ;
62532: LD_VAR 0 3
62536: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62537: LD_INT 0
62539: PPUSH
62540: PPUSH
62541: PPUSH
62542: PPUSH
// pom := GetBase ( building ) ;
62543: LD_ADDR_VAR 0 3
62547: PUSH
62548: LD_VAR 0 1
62552: PPUSH
62553: CALL_OW 274
62557: ST_TO_ADDR
// if not pom then
62558: LD_VAR 0 3
62562: NOT
62563: IFFALSE 62567
// exit ;
62565: GO 62737
// btype := GetBType ( building ) ;
62567: LD_ADDR_VAR 0 5
62571: PUSH
62572: LD_VAR 0 1
62576: PPUSH
62577: CALL_OW 266
62581: ST_TO_ADDR
// if btype = b_armoury then
62582: LD_VAR 0 5
62586: PUSH
62587: LD_INT 4
62589: EQUAL
62590: IFFALSE 62600
// btype := b_barracks ;
62592: LD_ADDR_VAR 0 5
62596: PUSH
62597: LD_INT 5
62599: ST_TO_ADDR
// if btype = b_depot then
62600: LD_VAR 0 5
62604: PUSH
62605: LD_INT 0
62607: EQUAL
62608: IFFALSE 62618
// btype := b_warehouse ;
62610: LD_ADDR_VAR 0 5
62614: PUSH
62615: LD_INT 1
62617: ST_TO_ADDR
// if btype = b_workshop then
62618: LD_VAR 0 5
62622: PUSH
62623: LD_INT 2
62625: EQUAL
62626: IFFALSE 62636
// btype := b_factory ;
62628: LD_ADDR_VAR 0 5
62632: PUSH
62633: LD_INT 3
62635: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62636: LD_ADDR_VAR 0 4
62640: PUSH
62641: LD_VAR 0 5
62645: PPUSH
62646: LD_VAR 0 1
62650: PPUSH
62651: CALL_OW 248
62655: PPUSH
62656: CALL_OW 450
62660: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62661: LD_ADDR_VAR 0 2
62665: PUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_INT 1
62673: PPUSH
62674: CALL_OW 275
62678: PUSH
62679: LD_VAR 0 4
62683: PUSH
62684: LD_INT 1
62686: ARRAY
62687: GREATEREQUAL
62688: PUSH
62689: LD_VAR 0 3
62693: PPUSH
62694: LD_INT 2
62696: PPUSH
62697: CALL_OW 275
62701: PUSH
62702: LD_VAR 0 4
62706: PUSH
62707: LD_INT 2
62709: ARRAY
62710: GREATEREQUAL
62711: AND
62712: PUSH
62713: LD_VAR 0 3
62717: PPUSH
62718: LD_INT 3
62720: PPUSH
62721: CALL_OW 275
62725: PUSH
62726: LD_VAR 0 4
62730: PUSH
62731: LD_INT 3
62733: ARRAY
62734: GREATEREQUAL
62735: AND
62736: ST_TO_ADDR
// end ;
62737: LD_VAR 0 2
62741: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62742: LD_INT 0
62744: PPUSH
62745: PPUSH
62746: PPUSH
// pom := GetBase ( building ) ;
62747: LD_ADDR_VAR 0 4
62751: PUSH
62752: LD_VAR 0 1
62756: PPUSH
62757: CALL_OW 274
62761: ST_TO_ADDR
// if not pom then
62762: LD_VAR 0 4
62766: NOT
62767: IFFALSE 62771
// exit ;
62769: GO 62872
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62771: LD_ADDR_VAR 0 5
62775: PUSH
62776: LD_VAR 0 2
62780: PPUSH
62781: LD_VAR 0 1
62785: PPUSH
62786: CALL_OW 248
62790: PPUSH
62791: CALL_OW 450
62795: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62796: LD_ADDR_VAR 0 3
62800: PUSH
62801: LD_VAR 0 4
62805: PPUSH
62806: LD_INT 1
62808: PPUSH
62809: CALL_OW 275
62813: PUSH
62814: LD_VAR 0 5
62818: PUSH
62819: LD_INT 1
62821: ARRAY
62822: GREATEREQUAL
62823: PUSH
62824: LD_VAR 0 4
62828: PPUSH
62829: LD_INT 2
62831: PPUSH
62832: CALL_OW 275
62836: PUSH
62837: LD_VAR 0 5
62841: PUSH
62842: LD_INT 2
62844: ARRAY
62845: GREATEREQUAL
62846: AND
62847: PUSH
62848: LD_VAR 0 4
62852: PPUSH
62853: LD_INT 3
62855: PPUSH
62856: CALL_OW 275
62860: PUSH
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 3
62868: ARRAY
62869: GREATEREQUAL
62870: AND
62871: ST_TO_ADDR
// end ;
62872: LD_VAR 0 3
62876: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
62877: LD_INT 0
62879: PPUSH
62880: PPUSH
62881: PPUSH
62882: PPUSH
62883: PPUSH
62884: PPUSH
62885: PPUSH
62886: PPUSH
62887: PPUSH
62888: PPUSH
62889: PPUSH
// result := false ;
62890: LD_ADDR_VAR 0 8
62894: PUSH
62895: LD_INT 0
62897: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
62898: LD_VAR 0 5
62902: NOT
62903: PUSH
62904: LD_VAR 0 1
62908: NOT
62909: OR
62910: PUSH
62911: LD_VAR 0 2
62915: NOT
62916: OR
62917: PUSH
62918: LD_VAR 0 3
62922: NOT
62923: OR
62924: IFFALSE 62928
// exit ;
62926: GO 63742
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
62928: LD_ADDR_VAR 0 14
62932: PUSH
62933: LD_VAR 0 1
62937: PPUSH
62938: LD_VAR 0 2
62942: PPUSH
62943: LD_VAR 0 3
62947: PPUSH
62948: LD_VAR 0 4
62952: PPUSH
62953: LD_VAR 0 5
62957: PUSH
62958: LD_INT 1
62960: ARRAY
62961: PPUSH
62962: CALL_OW 248
62966: PPUSH
62967: LD_INT 0
62969: PPUSH
62970: CALL 64579 0 6
62974: ST_TO_ADDR
// if not hexes then
62975: LD_VAR 0 14
62979: NOT
62980: IFFALSE 62984
// exit ;
62982: GO 63742
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62984: LD_ADDR_VAR 0 17
62988: PUSH
62989: LD_VAR 0 5
62993: PPUSH
62994: LD_INT 22
62996: PUSH
62997: LD_VAR 0 13
63001: PPUSH
63002: CALL_OW 255
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 2
63013: PUSH
63014: LD_INT 30
63016: PUSH
63017: LD_INT 0
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: LD_INT 30
63026: PUSH
63027: LD_INT 1
63029: PUSH
63030: EMPTY
63031: LIST
63032: LIST
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: LIST
63038: PUSH
63039: EMPTY
63040: LIST
63041: LIST
63042: PPUSH
63043: CALL_OW 72
63047: ST_TO_ADDR
// for i = 1 to hexes do
63048: LD_ADDR_VAR 0 9
63052: PUSH
63053: DOUBLE
63054: LD_INT 1
63056: DEC
63057: ST_TO_ADDR
63058: LD_VAR 0 14
63062: PUSH
63063: FOR_TO
63064: IFFALSE 63740
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63066: LD_ADDR_VAR 0 13
63070: PUSH
63071: LD_VAR 0 14
63075: PUSH
63076: LD_VAR 0 9
63080: ARRAY
63081: PUSH
63082: LD_INT 1
63084: ARRAY
63085: PPUSH
63086: LD_VAR 0 14
63090: PUSH
63091: LD_VAR 0 9
63095: ARRAY
63096: PUSH
63097: LD_INT 2
63099: ARRAY
63100: PPUSH
63101: CALL_OW 428
63105: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63106: LD_VAR 0 14
63110: PUSH
63111: LD_VAR 0 9
63115: ARRAY
63116: PUSH
63117: LD_INT 1
63119: ARRAY
63120: PPUSH
63121: LD_VAR 0 14
63125: PUSH
63126: LD_VAR 0 9
63130: ARRAY
63131: PUSH
63132: LD_INT 2
63134: ARRAY
63135: PPUSH
63136: CALL_OW 351
63140: PUSH
63141: LD_VAR 0 14
63145: PUSH
63146: LD_VAR 0 9
63150: ARRAY
63151: PUSH
63152: LD_INT 1
63154: ARRAY
63155: PPUSH
63156: LD_VAR 0 14
63160: PUSH
63161: LD_VAR 0 9
63165: ARRAY
63166: PUSH
63167: LD_INT 2
63169: ARRAY
63170: PPUSH
63171: CALL_OW 488
63175: NOT
63176: OR
63177: PUSH
63178: LD_VAR 0 13
63182: PPUSH
63183: CALL_OW 247
63187: PUSH
63188: LD_INT 3
63190: EQUAL
63191: OR
63192: IFFALSE 63198
// exit ;
63194: POP
63195: POP
63196: GO 63742
// if not tmp then
63198: LD_VAR 0 13
63202: NOT
63203: IFFALSE 63207
// continue ;
63205: GO 63063
// result := true ;
63207: LD_ADDR_VAR 0 8
63211: PUSH
63212: LD_INT 1
63214: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63215: LD_VAR 0 6
63219: PUSH
63220: LD_VAR 0 13
63224: PPUSH
63225: CALL_OW 247
63229: PUSH
63230: LD_INT 2
63232: EQUAL
63233: AND
63234: PUSH
63235: LD_VAR 0 13
63239: PPUSH
63240: CALL_OW 263
63244: PUSH
63245: LD_INT 1
63247: EQUAL
63248: AND
63249: IFFALSE 63413
// begin if IsDrivenBy ( tmp ) then
63251: LD_VAR 0 13
63255: PPUSH
63256: CALL_OW 311
63260: IFFALSE 63264
// continue ;
63262: GO 63063
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63264: LD_VAR 0 6
63268: PPUSH
63269: LD_INT 3
63271: PUSH
63272: LD_INT 60
63274: PUSH
63275: EMPTY
63276: LIST
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 3
63284: PUSH
63285: LD_INT 55
63287: PUSH
63288: EMPTY
63289: LIST
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PUSH
63295: EMPTY
63296: LIST
63297: LIST
63298: PPUSH
63299: CALL_OW 72
63303: IFFALSE 63411
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63305: LD_ADDR_VAR 0 18
63309: PUSH
63310: LD_VAR 0 6
63314: PPUSH
63315: LD_INT 3
63317: PUSH
63318: LD_INT 60
63320: PUSH
63321: EMPTY
63322: LIST
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: PUSH
63328: LD_INT 3
63330: PUSH
63331: LD_INT 55
63333: PUSH
63334: EMPTY
63335: LIST
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: PUSH
63341: EMPTY
63342: LIST
63343: LIST
63344: PPUSH
63345: CALL_OW 72
63349: PUSH
63350: LD_INT 1
63352: ARRAY
63353: ST_TO_ADDR
// if IsInUnit ( driver ) then
63354: LD_VAR 0 18
63358: PPUSH
63359: CALL_OW 310
63363: IFFALSE 63374
// ComExit ( driver ) ;
63365: LD_VAR 0 18
63369: PPUSH
63370: CALL 87763 0 1
// AddComEnterUnit ( driver , tmp ) ;
63374: LD_VAR 0 18
63378: PPUSH
63379: LD_VAR 0 13
63383: PPUSH
63384: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63388: LD_VAR 0 18
63392: PPUSH
63393: LD_VAR 0 7
63397: PPUSH
63398: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63402: LD_VAR 0 18
63406: PPUSH
63407: CALL_OW 181
// end ; continue ;
63411: GO 63063
// end ; if not cleaners or not tmp in cleaners then
63413: LD_VAR 0 6
63417: NOT
63418: PUSH
63419: LD_VAR 0 13
63423: PUSH
63424: LD_VAR 0 6
63428: IN
63429: NOT
63430: OR
63431: IFFALSE 63738
// begin if dep then
63433: LD_VAR 0 17
63437: IFFALSE 63573
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63439: LD_ADDR_VAR 0 16
63443: PUSH
63444: LD_VAR 0 17
63448: PUSH
63449: LD_INT 1
63451: ARRAY
63452: PPUSH
63453: CALL_OW 250
63457: PPUSH
63458: LD_VAR 0 17
63462: PUSH
63463: LD_INT 1
63465: ARRAY
63466: PPUSH
63467: CALL_OW 254
63471: PPUSH
63472: LD_INT 5
63474: PPUSH
63475: CALL_OW 272
63479: PUSH
63480: LD_VAR 0 17
63484: PUSH
63485: LD_INT 1
63487: ARRAY
63488: PPUSH
63489: CALL_OW 251
63493: PPUSH
63494: LD_VAR 0 17
63498: PUSH
63499: LD_INT 1
63501: ARRAY
63502: PPUSH
63503: CALL_OW 254
63507: PPUSH
63508: LD_INT 5
63510: PPUSH
63511: CALL_OW 273
63515: PUSH
63516: EMPTY
63517: LIST
63518: LIST
63519: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63520: LD_VAR 0 16
63524: PUSH
63525: LD_INT 1
63527: ARRAY
63528: PPUSH
63529: LD_VAR 0 16
63533: PUSH
63534: LD_INT 2
63536: ARRAY
63537: PPUSH
63538: CALL_OW 488
63542: IFFALSE 63573
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63544: LD_VAR 0 13
63548: PPUSH
63549: LD_VAR 0 16
63553: PUSH
63554: LD_INT 1
63556: ARRAY
63557: PPUSH
63558: LD_VAR 0 16
63562: PUSH
63563: LD_INT 2
63565: ARRAY
63566: PPUSH
63567: CALL_OW 111
// continue ;
63571: GO 63063
// end ; end ; r := GetDir ( tmp ) ;
63573: LD_ADDR_VAR 0 15
63577: PUSH
63578: LD_VAR 0 13
63582: PPUSH
63583: CALL_OW 254
63587: ST_TO_ADDR
// if r = 5 then
63588: LD_VAR 0 15
63592: PUSH
63593: LD_INT 5
63595: EQUAL
63596: IFFALSE 63606
// r := 0 ;
63598: LD_ADDR_VAR 0 15
63602: PUSH
63603: LD_INT 0
63605: ST_TO_ADDR
// for j = r to 5 do
63606: LD_ADDR_VAR 0 10
63610: PUSH
63611: DOUBLE
63612: LD_VAR 0 15
63616: DEC
63617: ST_TO_ADDR
63618: LD_INT 5
63620: PUSH
63621: FOR_TO
63622: IFFALSE 63736
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63624: LD_ADDR_VAR 0 11
63628: PUSH
63629: LD_VAR 0 13
63633: PPUSH
63634: CALL_OW 250
63638: PPUSH
63639: LD_VAR 0 10
63643: PPUSH
63644: LD_INT 2
63646: PPUSH
63647: CALL_OW 272
63651: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63652: LD_ADDR_VAR 0 12
63656: PUSH
63657: LD_VAR 0 13
63661: PPUSH
63662: CALL_OW 251
63666: PPUSH
63667: LD_VAR 0 10
63671: PPUSH
63672: LD_INT 2
63674: PPUSH
63675: CALL_OW 273
63679: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63680: LD_VAR 0 11
63684: PPUSH
63685: LD_VAR 0 12
63689: PPUSH
63690: CALL_OW 488
63694: PUSH
63695: LD_VAR 0 11
63699: PPUSH
63700: LD_VAR 0 12
63704: PPUSH
63705: CALL_OW 428
63709: NOT
63710: AND
63711: IFFALSE 63734
// begin ComMoveXY ( tmp , _x , _y ) ;
63713: LD_VAR 0 13
63717: PPUSH
63718: LD_VAR 0 11
63722: PPUSH
63723: LD_VAR 0 12
63727: PPUSH
63728: CALL_OW 111
// break ;
63732: GO 63736
// end ; end ;
63734: GO 63621
63736: POP
63737: POP
// end ; end ;
63738: GO 63063
63740: POP
63741: POP
// end ;
63742: LD_VAR 0 8
63746: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63747: LD_INT 0
63749: PPUSH
63750: PPUSH
63751: PPUSH
63752: PPUSH
63753: PPUSH
63754: PPUSH
63755: PPUSH
63756: PPUSH
63757: PPUSH
63758: PPUSH
// result := false ;
63759: LD_ADDR_VAR 0 6
63763: PUSH
63764: LD_INT 0
63766: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63767: LD_VAR 0 1
63771: NOT
63772: PUSH
63773: LD_VAR 0 1
63777: PPUSH
63778: CALL_OW 266
63782: PUSH
63783: LD_INT 0
63785: PUSH
63786: LD_INT 1
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: IN
63793: NOT
63794: OR
63795: PUSH
63796: LD_VAR 0 2
63800: NOT
63801: OR
63802: PUSH
63803: LD_VAR 0 5
63807: PUSH
63808: LD_INT 0
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: LD_INT 2
63816: PUSH
63817: LD_INT 3
63819: PUSH
63820: LD_INT 4
63822: PUSH
63823: LD_INT 5
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: IN
63834: NOT
63835: OR
63836: PUSH
63837: LD_VAR 0 3
63841: PPUSH
63842: LD_VAR 0 4
63846: PPUSH
63847: CALL_OW 488
63851: NOT
63852: OR
63853: IFFALSE 63857
// exit ;
63855: GO 64574
// pom := GetBase ( depot ) ;
63857: LD_ADDR_VAR 0 10
63861: PUSH
63862: LD_VAR 0 1
63866: PPUSH
63867: CALL_OW 274
63871: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63872: LD_ADDR_VAR 0 11
63876: PUSH
63877: LD_VAR 0 2
63881: PPUSH
63882: LD_VAR 0 1
63886: PPUSH
63887: CALL_OW 248
63891: PPUSH
63892: CALL_OW 450
63896: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63897: LD_VAR 0 10
63901: PPUSH
63902: LD_INT 1
63904: PPUSH
63905: CALL_OW 275
63909: PUSH
63910: LD_VAR 0 11
63914: PUSH
63915: LD_INT 1
63917: ARRAY
63918: GREATEREQUAL
63919: PUSH
63920: LD_VAR 0 10
63924: PPUSH
63925: LD_INT 2
63927: PPUSH
63928: CALL_OW 275
63932: PUSH
63933: LD_VAR 0 11
63937: PUSH
63938: LD_INT 2
63940: ARRAY
63941: GREATEREQUAL
63942: AND
63943: PUSH
63944: LD_VAR 0 10
63948: PPUSH
63949: LD_INT 3
63951: PPUSH
63952: CALL_OW 275
63956: PUSH
63957: LD_VAR 0 11
63961: PUSH
63962: LD_INT 3
63964: ARRAY
63965: GREATEREQUAL
63966: AND
63967: NOT
63968: IFFALSE 63972
// exit ;
63970: GO 64574
// if GetBType ( depot ) = b_depot then
63972: LD_VAR 0 1
63976: PPUSH
63977: CALL_OW 266
63981: PUSH
63982: LD_INT 0
63984: EQUAL
63985: IFFALSE 63997
// dist := 28 else
63987: LD_ADDR_VAR 0 14
63991: PUSH
63992: LD_INT 28
63994: ST_TO_ADDR
63995: GO 64005
// dist := 36 ;
63997: LD_ADDR_VAR 0 14
64001: PUSH
64002: LD_INT 36
64004: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64005: LD_VAR 0 1
64009: PPUSH
64010: LD_VAR 0 3
64014: PPUSH
64015: LD_VAR 0 4
64019: PPUSH
64020: CALL_OW 297
64024: PUSH
64025: LD_VAR 0 14
64029: GREATER
64030: IFFALSE 64034
// exit ;
64032: GO 64574
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64034: LD_ADDR_VAR 0 12
64038: PUSH
64039: LD_VAR 0 2
64043: PPUSH
64044: LD_VAR 0 3
64048: PPUSH
64049: LD_VAR 0 4
64053: PPUSH
64054: LD_VAR 0 5
64058: PPUSH
64059: LD_VAR 0 1
64063: PPUSH
64064: CALL_OW 248
64068: PPUSH
64069: LD_INT 0
64071: PPUSH
64072: CALL 64579 0 6
64076: ST_TO_ADDR
// if not hexes then
64077: LD_VAR 0 12
64081: NOT
64082: IFFALSE 64086
// exit ;
64084: GO 64574
// hex := GetHexInfo ( x , y ) ;
64086: LD_ADDR_VAR 0 15
64090: PUSH
64091: LD_VAR 0 3
64095: PPUSH
64096: LD_VAR 0 4
64100: PPUSH
64101: CALL_OW 546
64105: ST_TO_ADDR
// if hex [ 1 ] then
64106: LD_VAR 0 15
64110: PUSH
64111: LD_INT 1
64113: ARRAY
64114: IFFALSE 64118
// exit ;
64116: GO 64574
// height := hex [ 2 ] ;
64118: LD_ADDR_VAR 0 13
64122: PUSH
64123: LD_VAR 0 15
64127: PUSH
64128: LD_INT 2
64130: ARRAY
64131: ST_TO_ADDR
// for i = 1 to hexes do
64132: LD_ADDR_VAR 0 7
64136: PUSH
64137: DOUBLE
64138: LD_INT 1
64140: DEC
64141: ST_TO_ADDR
64142: LD_VAR 0 12
64146: PUSH
64147: FOR_TO
64148: IFFALSE 64478
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64150: LD_VAR 0 12
64154: PUSH
64155: LD_VAR 0 7
64159: ARRAY
64160: PUSH
64161: LD_INT 1
64163: ARRAY
64164: PPUSH
64165: LD_VAR 0 12
64169: PUSH
64170: LD_VAR 0 7
64174: ARRAY
64175: PUSH
64176: LD_INT 2
64178: ARRAY
64179: PPUSH
64180: CALL_OW 488
64184: NOT
64185: PUSH
64186: LD_VAR 0 12
64190: PUSH
64191: LD_VAR 0 7
64195: ARRAY
64196: PUSH
64197: LD_INT 1
64199: ARRAY
64200: PPUSH
64201: LD_VAR 0 12
64205: PUSH
64206: LD_VAR 0 7
64210: ARRAY
64211: PUSH
64212: LD_INT 2
64214: ARRAY
64215: PPUSH
64216: CALL_OW 428
64220: PUSH
64221: LD_INT 0
64223: GREATER
64224: OR
64225: PUSH
64226: LD_VAR 0 12
64230: PUSH
64231: LD_VAR 0 7
64235: ARRAY
64236: PUSH
64237: LD_INT 1
64239: ARRAY
64240: PPUSH
64241: LD_VAR 0 12
64245: PUSH
64246: LD_VAR 0 7
64250: ARRAY
64251: PUSH
64252: LD_INT 2
64254: ARRAY
64255: PPUSH
64256: CALL_OW 351
64260: OR
64261: IFFALSE 64267
// exit ;
64263: POP
64264: POP
64265: GO 64574
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64267: LD_ADDR_VAR 0 8
64271: PUSH
64272: LD_VAR 0 12
64276: PUSH
64277: LD_VAR 0 7
64281: ARRAY
64282: PUSH
64283: LD_INT 1
64285: ARRAY
64286: PPUSH
64287: LD_VAR 0 12
64291: PUSH
64292: LD_VAR 0 7
64296: ARRAY
64297: PUSH
64298: LD_INT 2
64300: ARRAY
64301: PPUSH
64302: CALL_OW 546
64306: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64307: LD_VAR 0 8
64311: PUSH
64312: LD_INT 1
64314: ARRAY
64315: PUSH
64316: LD_VAR 0 8
64320: PUSH
64321: LD_INT 2
64323: ARRAY
64324: PUSH
64325: LD_VAR 0 13
64329: PUSH
64330: LD_INT 2
64332: PLUS
64333: GREATER
64334: OR
64335: PUSH
64336: LD_VAR 0 8
64340: PUSH
64341: LD_INT 2
64343: ARRAY
64344: PUSH
64345: LD_VAR 0 13
64349: PUSH
64350: LD_INT 2
64352: MINUS
64353: LESS
64354: OR
64355: PUSH
64356: LD_VAR 0 8
64360: PUSH
64361: LD_INT 3
64363: ARRAY
64364: PUSH
64365: LD_INT 0
64367: PUSH
64368: LD_INT 8
64370: PUSH
64371: LD_INT 9
64373: PUSH
64374: LD_INT 10
64376: PUSH
64377: LD_INT 11
64379: PUSH
64380: LD_INT 12
64382: PUSH
64383: LD_INT 13
64385: PUSH
64386: LD_INT 16
64388: PUSH
64389: LD_INT 17
64391: PUSH
64392: LD_INT 18
64394: PUSH
64395: LD_INT 19
64397: PUSH
64398: LD_INT 20
64400: PUSH
64401: LD_INT 21
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: IN
64419: NOT
64420: OR
64421: PUSH
64422: LD_VAR 0 8
64426: PUSH
64427: LD_INT 5
64429: ARRAY
64430: NOT
64431: OR
64432: PUSH
64433: LD_VAR 0 8
64437: PUSH
64438: LD_INT 6
64440: ARRAY
64441: PUSH
64442: LD_INT 1
64444: PUSH
64445: LD_INT 2
64447: PUSH
64448: LD_INT 7
64450: PUSH
64451: LD_INT 9
64453: PUSH
64454: LD_INT 10
64456: PUSH
64457: LD_INT 11
64459: PUSH
64460: EMPTY
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: IN
64468: NOT
64469: OR
64470: IFFALSE 64476
// exit ;
64472: POP
64473: POP
64474: GO 64574
// end ;
64476: GO 64147
64478: POP
64479: POP
// side := GetSide ( depot ) ;
64480: LD_ADDR_VAR 0 9
64484: PUSH
64485: LD_VAR 0 1
64489: PPUSH
64490: CALL_OW 255
64494: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64495: LD_VAR 0 9
64499: PPUSH
64500: LD_VAR 0 3
64504: PPUSH
64505: LD_VAR 0 4
64509: PPUSH
64510: LD_INT 20
64512: PPUSH
64513: CALL 56895 0 4
64517: PUSH
64518: LD_INT 4
64520: ARRAY
64521: IFFALSE 64525
// exit ;
64523: GO 64574
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64525: LD_VAR 0 2
64529: PUSH
64530: LD_INT 29
64532: PUSH
64533: LD_INT 30
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: IN
64540: PUSH
64541: LD_VAR 0 3
64545: PPUSH
64546: LD_VAR 0 4
64550: PPUSH
64551: LD_VAR 0 9
64555: PPUSH
64556: CALL_OW 440
64560: NOT
64561: AND
64562: IFFALSE 64566
// exit ;
64564: GO 64574
// result := true ;
64566: LD_ADDR_VAR 0 6
64570: PUSH
64571: LD_INT 1
64573: ST_TO_ADDR
// end ;
64574: LD_VAR 0 6
64578: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
64579: LD_INT 0
64581: PPUSH
64582: PPUSH
64583: PPUSH
64584: PPUSH
64585: PPUSH
64586: PPUSH
64587: PPUSH
64588: PPUSH
64589: PPUSH
64590: PPUSH
64591: PPUSH
64592: PPUSH
64593: PPUSH
64594: PPUSH
64595: PPUSH
64596: PPUSH
64597: PPUSH
64598: PPUSH
64599: PPUSH
64600: PPUSH
64601: PPUSH
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
64606: PPUSH
64607: PPUSH
64608: PPUSH
64609: PPUSH
64610: PPUSH
64611: PPUSH
64612: PPUSH
64613: PPUSH
64614: PPUSH
64615: PPUSH
64616: PPUSH
64617: PPUSH
64618: PPUSH
64619: PPUSH
64620: PPUSH
64621: PPUSH
64622: PPUSH
64623: PPUSH
64624: PPUSH
64625: PPUSH
64626: PPUSH
64627: PPUSH
64628: PPUSH
64629: PPUSH
64630: PPUSH
64631: PPUSH
64632: PPUSH
64633: PPUSH
64634: PPUSH
64635: PPUSH
64636: PPUSH
64637: PPUSH
64638: PPUSH
// result = [ ] ;
64639: LD_ADDR_VAR 0 7
64643: PUSH
64644: EMPTY
64645: ST_TO_ADDR
// temp_list = [ ] ;
64646: LD_ADDR_VAR 0 9
64650: PUSH
64651: EMPTY
64652: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64653: LD_VAR 0 4
64657: PUSH
64658: LD_INT 0
64660: PUSH
64661: LD_INT 1
64663: PUSH
64664: LD_INT 2
64666: PUSH
64667: LD_INT 3
64669: PUSH
64670: LD_INT 4
64672: PUSH
64673: LD_INT 5
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: IN
64684: NOT
64685: PUSH
64686: LD_VAR 0 1
64690: PUSH
64691: LD_INT 0
64693: PUSH
64694: LD_INT 1
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: IN
64701: PUSH
64702: LD_VAR 0 5
64706: PUSH
64707: LD_INT 1
64709: PUSH
64710: LD_INT 2
64712: PUSH
64713: LD_INT 3
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: LIST
64720: IN
64721: NOT
64722: AND
64723: OR
64724: IFFALSE 64728
// exit ;
64726: GO 83119
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64728: LD_VAR 0 1
64732: PUSH
64733: LD_INT 6
64735: PUSH
64736: LD_INT 7
64738: PUSH
64739: LD_INT 8
64741: PUSH
64742: LD_INT 13
64744: PUSH
64745: LD_INT 12
64747: PUSH
64748: LD_INT 15
64750: PUSH
64751: LD_INT 11
64753: PUSH
64754: LD_INT 14
64756: PUSH
64757: LD_INT 10
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: IN
64771: IFFALSE 64781
// btype = b_lab ;
64773: LD_ADDR_VAR 0 1
64777: PUSH
64778: LD_INT 6
64780: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64781: LD_VAR 0 6
64785: PUSH
64786: LD_INT 0
64788: PUSH
64789: LD_INT 1
64791: PUSH
64792: LD_INT 2
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: LIST
64799: IN
64800: NOT
64801: PUSH
64802: LD_VAR 0 1
64806: PUSH
64807: LD_INT 0
64809: PUSH
64810: LD_INT 1
64812: PUSH
64813: LD_INT 2
64815: PUSH
64816: LD_INT 3
64818: PUSH
64819: LD_INT 6
64821: PUSH
64822: LD_INT 36
64824: PUSH
64825: LD_INT 4
64827: PUSH
64828: LD_INT 5
64830: PUSH
64831: LD_INT 31
64833: PUSH
64834: LD_INT 32
64836: PUSH
64837: LD_INT 33
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: LIST
64848: LIST
64849: LIST
64850: LIST
64851: LIST
64852: IN
64853: NOT
64854: PUSH
64855: LD_VAR 0 6
64859: PUSH
64860: LD_INT 1
64862: EQUAL
64863: AND
64864: OR
64865: PUSH
64866: LD_VAR 0 1
64870: PUSH
64871: LD_INT 2
64873: PUSH
64874: LD_INT 3
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: IN
64881: NOT
64882: PUSH
64883: LD_VAR 0 6
64887: PUSH
64888: LD_INT 2
64890: EQUAL
64891: AND
64892: OR
64893: IFFALSE 64903
// mode = 0 ;
64895: LD_ADDR_VAR 0 6
64899: PUSH
64900: LD_INT 0
64902: ST_TO_ADDR
// case mode of 0 :
64903: LD_VAR 0 6
64907: PUSH
64908: LD_INT 0
64910: DOUBLE
64911: EQUAL
64912: IFTRUE 64916
64914: GO 76369
64916: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64917: LD_ADDR_VAR 0 11
64921: PUSH
64922: LD_INT 0
64924: PUSH
64925: LD_INT 0
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 0
64934: PUSH
64935: LD_INT 1
64937: NEG
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: PUSH
64943: LD_INT 1
64945: PUSH
64946: LD_INT 0
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 1
64955: PUSH
64956: LD_INT 1
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 0
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 1
64975: NEG
64976: PUSH
64977: LD_INT 0
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PUSH
64984: LD_INT 1
64986: NEG
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 1
64998: NEG
64999: PUSH
65000: LD_INT 2
65002: NEG
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: LD_INT 2
65013: NEG
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 1
65021: PUSH
65022: LD_INT 1
65024: NEG
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 1
65032: PUSH
65033: LD_INT 2
65035: PUSH
65036: EMPTY
65037: LIST
65038: LIST
65039: PUSH
65040: LD_INT 0
65042: PUSH
65043: LD_INT 2
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 1
65052: NEG
65053: PUSH
65054: LD_INT 1
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 1
65063: PUSH
65064: LD_INT 3
65066: PUSH
65067: EMPTY
65068: LIST
65069: LIST
65070: PUSH
65071: LD_INT 0
65073: PUSH
65074: LD_INT 3
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 1
65083: NEG
65084: PUSH
65085: LD_INT 2
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: LIST
65101: LIST
65102: LIST
65103: LIST
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: LIST
65109: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65110: LD_ADDR_VAR 0 12
65114: PUSH
65115: LD_INT 0
65117: PUSH
65118: LD_INT 0
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PUSH
65125: LD_INT 0
65127: PUSH
65128: LD_INT 1
65130: NEG
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 1
65138: PUSH
65139: LD_INT 0
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 1
65148: PUSH
65149: LD_INT 1
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: LD_INT 0
65158: PUSH
65159: LD_INT 1
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 1
65168: NEG
65169: PUSH
65170: LD_INT 0
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 1
65179: NEG
65180: PUSH
65181: LD_INT 1
65183: NEG
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: LD_INT 1
65191: PUSH
65192: LD_INT 1
65194: NEG
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 2
65202: PUSH
65203: LD_INT 0
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 2
65212: PUSH
65213: LD_INT 1
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: LD_INT 1
65222: NEG
65223: PUSH
65224: LD_INT 1
65226: PUSH
65227: EMPTY
65228: LIST
65229: LIST
65230: PUSH
65231: LD_INT 2
65233: NEG
65234: PUSH
65235: LD_INT 0
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PUSH
65242: LD_INT 2
65244: NEG
65245: PUSH
65246: LD_INT 1
65248: NEG
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PUSH
65254: LD_INT 2
65256: NEG
65257: PUSH
65258: LD_INT 1
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 3
65267: NEG
65268: PUSH
65269: LD_INT 0
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 3
65278: NEG
65279: PUSH
65280: LD_INT 1
65282: NEG
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65306: LD_ADDR_VAR 0 13
65310: PUSH
65311: LD_INT 0
65313: PUSH
65314: LD_INT 0
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: LD_INT 1
65326: NEG
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: LD_INT 1
65334: PUSH
65335: LD_INT 0
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 1
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 0
65354: PUSH
65355: LD_INT 1
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: LD_INT 1
65364: NEG
65365: PUSH
65366: LD_INT 0
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PUSH
65373: LD_INT 1
65375: NEG
65376: PUSH
65377: LD_INT 1
65379: NEG
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PUSH
65385: LD_INT 1
65387: NEG
65388: PUSH
65389: LD_INT 2
65391: NEG
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 2
65399: PUSH
65400: LD_INT 1
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 2
65409: PUSH
65410: LD_INT 2
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 1
65419: PUSH
65420: LD_INT 2
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 2
65429: NEG
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 2
65441: NEG
65442: PUSH
65443: LD_INT 2
65445: NEG
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 2
65453: NEG
65454: PUSH
65455: LD_INT 3
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 3
65465: NEG
65466: PUSH
65467: LD_INT 2
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 3
65477: NEG
65478: PUSH
65479: LD_INT 3
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65505: LD_ADDR_VAR 0 14
65509: PUSH
65510: LD_INT 0
65512: PUSH
65513: LD_INT 0
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: LD_INT 1
65525: NEG
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 1
65533: PUSH
65534: LD_INT 0
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 1
65543: PUSH
65544: LD_INT 1
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 0
65553: PUSH
65554: LD_INT 1
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 1
65563: NEG
65564: PUSH
65565: LD_INT 0
65567: PUSH
65568: EMPTY
65569: LIST
65570: LIST
65571: PUSH
65572: LD_INT 1
65574: NEG
65575: PUSH
65576: LD_INT 1
65578: NEG
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 1
65586: NEG
65587: PUSH
65588: LD_INT 2
65590: NEG
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 0
65598: PUSH
65599: LD_INT 2
65601: NEG
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: LD_INT 1
65609: PUSH
65610: LD_INT 1
65612: NEG
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 1
65620: PUSH
65621: LD_INT 2
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 0
65630: PUSH
65631: LD_INT 2
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: LD_INT 1
65640: NEG
65641: PUSH
65642: LD_INT 1
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 1
65651: NEG
65652: PUSH
65653: LD_INT 3
65655: NEG
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: PUSH
65661: LD_INT 0
65663: PUSH
65664: LD_INT 3
65666: NEG
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: LD_INT 1
65674: PUSH
65675: LD_INT 2
65677: NEG
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65701: LD_ADDR_VAR 0 15
65705: PUSH
65706: LD_INT 0
65708: PUSH
65709: LD_INT 0
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PUSH
65716: LD_INT 0
65718: PUSH
65719: LD_INT 1
65721: NEG
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: LD_INT 0
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: LD_INT 1
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 0
65749: PUSH
65750: LD_INT 1
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: LD_INT 0
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 1
65770: NEG
65771: PUSH
65772: LD_INT 1
65774: NEG
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 1
65782: PUSH
65783: LD_INT 1
65785: NEG
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 2
65793: PUSH
65794: LD_INT 0
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 2
65803: PUSH
65804: LD_INT 1
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 1
65813: NEG
65814: PUSH
65815: LD_INT 1
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: LD_INT 2
65824: NEG
65825: PUSH
65826: LD_INT 0
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 2
65835: NEG
65836: PUSH
65837: LD_INT 1
65839: NEG
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 2
65847: PUSH
65848: LD_INT 1
65850: NEG
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 3
65858: PUSH
65859: LD_INT 0
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 3
65868: PUSH
65869: LD_INT 1
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65894: LD_ADDR_VAR 0 16
65898: PUSH
65899: LD_INT 0
65901: PUSH
65902: LD_INT 0
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: LD_INT 0
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: PUSH
65923: LD_INT 0
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: PUSH
65930: LD_INT 1
65932: PUSH
65933: LD_INT 1
65935: PUSH
65936: EMPTY
65937: LIST
65938: LIST
65939: PUSH
65940: LD_INT 0
65942: PUSH
65943: LD_INT 1
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PUSH
65950: LD_INT 1
65952: NEG
65953: PUSH
65954: LD_INT 0
65956: PUSH
65957: EMPTY
65958: LIST
65959: LIST
65960: PUSH
65961: LD_INT 1
65963: NEG
65964: PUSH
65965: LD_INT 1
65967: NEG
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 1
65975: NEG
65976: PUSH
65977: LD_INT 2
65979: NEG
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 2
65987: PUSH
65988: LD_INT 1
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 2
65997: PUSH
65998: LD_INT 2
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 1
66007: PUSH
66008: LD_INT 2
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: NEG
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 2
66029: NEG
66030: PUSH
66031: LD_INT 2
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 3
66041: PUSH
66042: LD_INT 2
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 3
66051: PUSH
66052: LD_INT 3
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 2
66061: PUSH
66062: LD_INT 3
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: LIST
66083: LIST
66084: LIST
66085: LIST
66086: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66087: LD_ADDR_VAR 0 17
66091: PUSH
66092: LD_INT 0
66094: PUSH
66095: LD_INT 0
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: LD_INT 0
66104: PUSH
66105: LD_INT 1
66107: NEG
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: LD_INT 0
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 1
66125: PUSH
66126: LD_INT 1
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 0
66135: PUSH
66136: LD_INT 1
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: LD_INT 1
66145: NEG
66146: PUSH
66147: LD_INT 0
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 1
66156: NEG
66157: PUSH
66158: LD_INT 1
66160: NEG
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 1
66168: NEG
66169: PUSH
66170: LD_INT 2
66172: NEG
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 0
66180: PUSH
66181: LD_INT 2
66183: NEG
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 1
66191: PUSH
66192: LD_INT 1
66194: NEG
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 2
66202: PUSH
66203: LD_INT 0
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PUSH
66210: LD_INT 2
66212: PUSH
66213: LD_INT 1
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 2
66222: PUSH
66223: LD_INT 2
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: LD_INT 2
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: NEG
66253: PUSH
66254: LD_INT 1
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 2
66263: NEG
66264: PUSH
66265: LD_INT 0
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 2
66274: NEG
66275: PUSH
66276: LD_INT 1
66278: NEG
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 2
66286: NEG
66287: PUSH
66288: LD_INT 2
66290: NEG
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66317: LD_ADDR_VAR 0 18
66321: PUSH
66322: LD_INT 0
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 0
66334: PUSH
66335: LD_INT 1
66337: NEG
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 1
66345: PUSH
66346: LD_INT 0
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: PUSH
66353: LD_INT 1
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: LD_INT 1
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: PUSH
66373: LD_INT 1
66375: NEG
66376: PUSH
66377: LD_INT 0
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: LD_INT 1
66390: NEG
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 1
66398: NEG
66399: PUSH
66400: LD_INT 2
66402: NEG
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 1
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 2
66432: PUSH
66433: LD_INT 0
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 1
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 2
66452: PUSH
66453: LD_INT 2
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 1
66462: PUSH
66463: LD_INT 2
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: LD_INT 2
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 1
66482: NEG
66483: PUSH
66484: LD_INT 1
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 2
66493: NEG
66494: PUSH
66495: LD_INT 0
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 2
66504: NEG
66505: PUSH
66506: LD_INT 1
66508: NEG
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 2
66516: NEG
66517: PUSH
66518: LD_INT 2
66520: NEG
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66547: LD_ADDR_VAR 0 19
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: LD_INT 0
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 0
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 1
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 1
66585: PUSH
66586: LD_INT 1
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 0
66595: PUSH
66596: LD_INT 1
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 1
66605: NEG
66606: PUSH
66607: LD_INT 0
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 1
66616: NEG
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 1
66628: NEG
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 0
66640: PUSH
66641: LD_INT 2
66643: NEG
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 1
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 2
66662: PUSH
66663: LD_INT 0
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 2
66672: PUSH
66673: LD_INT 1
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 2
66682: PUSH
66683: LD_INT 2
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 1
66692: PUSH
66693: LD_INT 2
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 0
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 1
66712: NEG
66713: PUSH
66714: LD_INT 1
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 2
66723: NEG
66724: PUSH
66725: LD_INT 0
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 2
66734: NEG
66735: PUSH
66736: LD_INT 1
66738: NEG
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 2
66746: NEG
66747: PUSH
66748: LD_INT 2
66750: NEG
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66777: LD_ADDR_VAR 0 20
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 0
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: LD_INT 1
66797: NEG
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 0
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 1
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: EMPTY
66830: LIST
66831: LIST
66832: PUSH
66833: LD_INT 1
66835: NEG
66836: PUSH
66837: LD_INT 0
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 1
66846: NEG
66847: PUSH
66848: LD_INT 1
66850: NEG
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 1
66858: NEG
66859: PUSH
66860: LD_INT 2
66862: NEG
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 0
66870: PUSH
66871: LD_INT 2
66873: NEG
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 1
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: LD_INT 0
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 2
66902: PUSH
66903: LD_INT 1
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 2
66912: PUSH
66913: LD_INT 2
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: LD_INT 2
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: LD_INT 2
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 1
66942: NEG
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 2
66953: NEG
66954: PUSH
66955: LD_INT 0
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 2
66964: NEG
66965: PUSH
66966: LD_INT 1
66968: NEG
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 2
66976: NEG
66977: PUSH
66978: LD_INT 2
66980: NEG
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67007: LD_ADDR_VAR 0 21
67011: PUSH
67012: LD_INT 0
67014: PUSH
67015: LD_INT 0
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 0
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: PUSH
67036: LD_INT 0
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: PUSH
67043: LD_INT 1
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: PUSH
67063: LD_INT 1
67065: NEG
67066: PUSH
67067: LD_INT 0
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: PUSH
67074: LD_INT 1
67076: NEG
67077: PUSH
67078: LD_INT 1
67080: NEG
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 1
67088: NEG
67089: PUSH
67090: LD_INT 2
67092: NEG
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 0
67100: PUSH
67101: LD_INT 2
67103: NEG
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 1
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 2
67122: PUSH
67123: LD_INT 0
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 2
67132: PUSH
67133: LD_INT 1
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 2
67142: PUSH
67143: LD_INT 2
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 1
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: LD_INT 2
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 1
67172: NEG
67173: PUSH
67174: LD_INT 1
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 2
67183: NEG
67184: PUSH
67185: LD_INT 0
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 2
67194: NEG
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 2
67206: NEG
67207: PUSH
67208: LD_INT 2
67210: NEG
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67237: LD_ADDR_VAR 0 22
67241: PUSH
67242: LD_INT 0
67244: PUSH
67245: LD_INT 0
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 0
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 1
67265: PUSH
67266: LD_INT 0
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: PUSH
67276: LD_INT 1
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: LD_INT 1
67288: PUSH
67289: EMPTY
67290: LIST
67291: LIST
67292: PUSH
67293: LD_INT 1
67295: NEG
67296: PUSH
67297: LD_INT 0
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 1
67306: NEG
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: LD_INT 2
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 0
67330: PUSH
67331: LD_INT 2
67333: NEG
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: LD_INT 1
67344: NEG
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 2
67352: PUSH
67353: LD_INT 0
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 2
67362: PUSH
67363: LD_INT 1
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 2
67372: PUSH
67373: LD_INT 2
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 1
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 0
67392: PUSH
67393: LD_INT 2
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 2
67413: NEG
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 2
67424: NEG
67425: PUSH
67426: LD_INT 1
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 2
67436: NEG
67437: PUSH
67438: LD_INT 2
67440: NEG
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67467: LD_ADDR_VAR 0 23
67471: PUSH
67472: LD_INT 0
67474: PUSH
67475: LD_INT 0
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 0
67484: PUSH
67485: LD_INT 1
67487: NEG
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 1
67495: PUSH
67496: LD_INT 0
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 1
67505: PUSH
67506: LD_INT 1
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 1
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 1
67525: NEG
67526: PUSH
67527: LD_INT 0
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: LD_INT 1
67540: NEG
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 1
67548: NEG
67549: PUSH
67550: LD_INT 2
67552: NEG
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 2
67582: PUSH
67583: LD_INT 0
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 2
67592: PUSH
67593: LD_INT 1
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 2
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 0
67622: PUSH
67623: LD_INT 2
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 1
67632: NEG
67633: PUSH
67634: LD_INT 1
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 2
67643: NEG
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 2
67654: NEG
67655: PUSH
67656: LD_INT 1
67658: NEG
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 2
67666: NEG
67667: PUSH
67668: LD_INT 2
67670: NEG
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: LD_INT 3
67682: NEG
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: LD_INT 3
67694: NEG
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: PUSH
67703: LD_INT 2
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 2
67713: PUSH
67714: LD_INT 1
67716: NEG
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67747: LD_ADDR_VAR 0 24
67751: PUSH
67752: LD_INT 0
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: LD_INT 1
67767: NEG
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 1
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 1
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: LD_INT 0
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 1
67828: NEG
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 0
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PUSH
67849: LD_INT 1
67851: PUSH
67852: LD_INT 1
67854: NEG
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 2
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 2
67872: PUSH
67873: LD_INT 1
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: LD_INT 2
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 2
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 0
67902: PUSH
67903: LD_INT 2
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 1
67912: NEG
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 2
67923: NEG
67924: PUSH
67925: LD_INT 0
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 2
67934: NEG
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: LD_INT 2
67946: NEG
67947: PUSH
67948: LD_INT 2
67950: NEG
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 1
67958: PUSH
67959: LD_INT 2
67961: NEG
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: PUSH
67967: LD_INT 2
67969: PUSH
67970: LD_INT 1
67972: NEG
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 3
67980: PUSH
67981: LD_INT 1
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 3
67990: PUSH
67991: LD_INT 2
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68023: LD_ADDR_VAR 0 25
68027: PUSH
68028: LD_INT 0
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 0
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 1
68051: PUSH
68052: LD_INT 0
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 1
68061: PUSH
68062: LD_INT 1
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 0
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 1
68081: NEG
68082: PUSH
68083: LD_INT 0
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 1
68092: NEG
68093: PUSH
68094: LD_INT 1
68096: NEG
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 1
68104: NEG
68105: PUSH
68106: LD_INT 2
68108: NEG
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 0
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 1
68127: PUSH
68128: LD_INT 1
68130: NEG
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 2
68138: PUSH
68139: LD_INT 0
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 2
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 2
68158: PUSH
68159: LD_INT 2
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: LD_INT 2
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 1
68188: NEG
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 2
68199: NEG
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 2
68210: NEG
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 2
68222: NEG
68223: PUSH
68224: LD_INT 2
68226: NEG
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 3
68234: PUSH
68235: LD_INT 1
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 3
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: LD_INT 3
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 1
68264: PUSH
68265: LD_INT 3
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68297: LD_ADDR_VAR 0 26
68301: PUSH
68302: LD_INT 0
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 0
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 1
68325: PUSH
68326: LD_INT 0
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: LD_INT 1
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: NEG
68379: PUSH
68380: LD_INT 2
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: LD_INT 2
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 1
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 2
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 2
68422: PUSH
68423: LD_INT 1
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: PUSH
68433: LD_INT 2
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 1
68442: PUSH
68443: LD_INT 2
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 0
68452: PUSH
68453: LD_INT 2
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 1
68462: NEG
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 2
68473: NEG
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: NEG
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 2
68496: NEG
68497: PUSH
68498: LD_INT 2
68500: NEG
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 2
68508: PUSH
68509: LD_INT 3
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: LD_INT 3
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 1
68528: NEG
68529: PUSH
68530: LD_INT 2
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 2
68539: NEG
68540: PUSH
68541: LD_INT 1
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68573: LD_ADDR_VAR 0 27
68577: PUSH
68578: LD_INT 0
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 0
68590: PUSH
68591: LD_INT 1
68593: NEG
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: PUSH
68599: LD_INT 1
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 1
68611: PUSH
68612: LD_INT 1
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 0
68621: PUSH
68622: LD_INT 1
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 1
68631: NEG
68632: PUSH
68633: LD_INT 0
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 1
68642: NEG
68643: PUSH
68644: LD_INT 1
68646: NEG
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 1
68654: NEG
68655: PUSH
68656: LD_INT 2
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 0
68666: PUSH
68667: LD_INT 2
68669: NEG
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: LD_INT 1
68677: PUSH
68678: LD_INT 1
68680: NEG
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 2
68688: PUSH
68689: LD_INT 0
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 2
68698: PUSH
68699: LD_INT 1
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: LD_INT 2
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 1
68718: PUSH
68719: LD_INT 2
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 0
68728: PUSH
68729: LD_INT 2
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 1
68738: NEG
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 2
68749: NEG
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 2
68760: NEG
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 2
68772: NEG
68773: PUSH
68774: LD_INT 2
68776: NEG
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 1
68784: NEG
68785: PUSH
68786: LD_INT 2
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 3
68806: NEG
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 3
68818: NEG
68819: PUSH
68820: LD_INT 2
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68853: LD_ADDR_VAR 0 28
68857: PUSH
68858: LD_INT 0
68860: PUSH
68861: LD_INT 0
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 1
68881: PUSH
68882: LD_INT 0
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 1
68891: PUSH
68892: LD_INT 1
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 0
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 1
68911: NEG
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 1
68922: NEG
68923: PUSH
68924: LD_INT 1
68926: NEG
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 1
68934: NEG
68935: PUSH
68936: LD_INT 2
68938: NEG
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 0
68946: PUSH
68947: LD_INT 2
68949: NEG
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 1
68957: PUSH
68958: LD_INT 1
68960: NEG
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 2
68968: PUSH
68969: LD_INT 0
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 2
68978: PUSH
68979: LD_INT 1
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 2
68988: PUSH
68989: LD_INT 2
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 1
68998: PUSH
68999: LD_INT 2
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PUSH
69006: LD_INT 0
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 1
69018: NEG
69019: PUSH
69020: LD_INT 1
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 2
69029: NEG
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: NEG
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 2
69052: NEG
69053: PUSH
69054: LD_INT 2
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 2
69064: NEG
69065: PUSH
69066: LD_INT 3
69068: NEG
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: LD_INT 3
69080: NEG
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 3
69088: NEG
69089: PUSH
69090: LD_INT 1
69092: NEG
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PUSH
69098: LD_INT 3
69100: NEG
69101: PUSH
69102: LD_INT 2
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69135: LD_ADDR_VAR 0 29
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 1
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 0
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: NEG
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 1
69208: NEG
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 2
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 2
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: LD_INT 1
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 1
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 1
69290: NEG
69291: PUSH
69292: LD_INT 1
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 2
69313: NEG
69314: PUSH
69315: LD_INT 2
69317: NEG
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 2
69325: NEG
69326: PUSH
69327: LD_INT 3
69329: NEG
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: PUSH
69335: LD_INT 2
69337: PUSH
69338: LD_INT 1
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 3
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 1
69358: PUSH
69359: LD_INT 3
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: LD_INT 2
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 3
69379: NEG
69380: PUSH
69381: LD_INT 2
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69414: LD_ADDR_VAR 0 30
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: LD_INT 1
69487: NEG
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 2
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: LD_INT 2
69510: NEG
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: LD_INT 1
69521: NEG
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 2
69580: NEG
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 2
69591: NEG
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 3
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 1
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 3
69626: PUSH
69627: LD_INT 2
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 2
69636: PUSH
69637: LD_INT 3
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: LD_INT 2
69646: NEG
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 3
69657: NEG
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69692: LD_ADDR_VAR 0 31
69696: PUSH
69697: LD_INT 0
69699: PUSH
69700: LD_INT 0
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: LD_INT 1
69712: NEG
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 1
69720: PUSH
69721: LD_INT 0
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: LD_INT 1
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 1
69750: NEG
69751: PUSH
69752: LD_INT 0
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 1
69765: NEG
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 1
69773: NEG
69774: PUSH
69775: LD_INT 2
69777: NEG
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 1
69785: PUSH
69786: LD_INT 1
69788: NEG
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 2
69796: PUSH
69797: LD_INT 0
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 2
69806: PUSH
69807: LD_INT 1
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: LD_INT 2
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 1
69826: PUSH
69827: LD_INT 2
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 0
69836: PUSH
69837: LD_INT 2
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: NEG
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: LD_INT 1
69861: NEG
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 2
69869: NEG
69870: PUSH
69871: LD_INT 2
69873: NEG
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 2
69881: NEG
69882: PUSH
69883: LD_INT 3
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 3
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 1
69914: PUSH
69915: LD_INT 3
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: NEG
69925: PUSH
69926: LD_INT 2
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: NEG
69936: PUSH
69937: LD_INT 2
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69970: LD_ADDR_VAR 0 32
69974: PUSH
69975: LD_INT 0
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: LD_INT 1
69990: NEG
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 1
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 1
70008: PUSH
70009: LD_INT 1
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: LD_INT 1
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 1
70028: NEG
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: LD_INT 1
70043: NEG
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 1
70051: NEG
70052: PUSH
70053: LD_INT 2
70055: NEG
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 0
70063: PUSH
70064: LD_INT 2
70066: NEG
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 2
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 2
70095: PUSH
70096: LD_INT 2
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 1
70105: PUSH
70106: LD_INT 2
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 0
70115: PUSH
70116: LD_INT 2
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 1
70125: NEG
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 2
70136: NEG
70137: PUSH
70138: LD_INT 0
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 2
70147: NEG
70148: PUSH
70149: LD_INT 1
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 1
70159: NEG
70160: PUSH
70161: LD_INT 3
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 1
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 3
70182: PUSH
70183: LD_INT 2
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 3
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 2
70202: NEG
70203: PUSH
70204: LD_INT 1
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 3
70213: NEG
70214: PUSH
70215: LD_INT 1
70217: NEG
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70248: LD_ADDR_VAR 0 33
70252: PUSH
70253: LD_INT 0
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: LD_INT 1
70268: NEG
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 1
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 1
70286: PUSH
70287: LD_INT 1
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 1
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 1
70306: NEG
70307: PUSH
70308: LD_INT 0
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: NEG
70318: PUSH
70319: LD_INT 1
70321: NEG
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 1
70329: NEG
70330: PUSH
70331: LD_INT 2
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 1
70344: NEG
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 2
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 2
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: LD_INT 2
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: LD_INT 2
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: LD_INT 1
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 2
70403: NEG
70404: PUSH
70405: LD_INT 0
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 2
70414: NEG
70415: PUSH
70416: LD_INT 1
70418: NEG
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PUSH
70424: LD_INT 2
70426: NEG
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 2
70438: NEG
70439: PUSH
70440: LD_INT 3
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 3
70461: PUSH
70462: LD_INT 1
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: PUSH
70472: LD_INT 3
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 1
70481: NEG
70482: PUSH
70483: LD_INT 2
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 3
70492: NEG
70493: PUSH
70494: LD_INT 2
70496: NEG
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70527: LD_ADDR_VAR 0 34
70531: PUSH
70532: LD_INT 0
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PUSH
70542: LD_INT 0
70544: PUSH
70545: LD_INT 1
70547: NEG
70548: PUSH
70549: EMPTY
70550: LIST
70551: LIST
70552: PUSH
70553: LD_INT 1
70555: PUSH
70556: LD_INT 0
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: LD_INT 1
70565: PUSH
70566: LD_INT 1
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: PUSH
70583: LD_INT 1
70585: NEG
70586: PUSH
70587: LD_INT 0
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 1
70596: NEG
70597: PUSH
70598: LD_INT 1
70600: NEG
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 1
70608: NEG
70609: PUSH
70610: LD_INT 2
70612: NEG
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 0
70620: PUSH
70621: LD_INT 2
70623: NEG
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: PUSH
70632: LD_INT 1
70634: NEG
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 2
70642: PUSH
70643: LD_INT 1
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 2
70652: PUSH
70653: LD_INT 2
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: LD_INT 2
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 2
70683: NEG
70684: PUSH
70685: LD_INT 0
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 2
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: NEG
70707: PUSH
70708: LD_INT 2
70710: NEG
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 1
70718: NEG
70719: PUSH
70720: LD_INT 3
70722: NEG
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 1
70730: PUSH
70731: LD_INT 2
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 3
70741: PUSH
70742: LD_INT 2
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 2
70751: PUSH
70752: LD_INT 3
70754: PUSH
70755: EMPTY
70756: LIST
70757: LIST
70758: PUSH
70759: LD_INT 2
70761: NEG
70762: PUSH
70763: LD_INT 1
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 3
70772: NEG
70773: PUSH
70774: LD_INT 1
70776: NEG
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70807: LD_ADDR_VAR 0 35
70811: PUSH
70812: LD_INT 0
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 1
70827: NEG
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 1
70835: PUSH
70836: LD_INT 0
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 0
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: LD_INT 0
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: LD_INT 1
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 1
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 2
70898: NEG
70899: PUSH
70900: LD_INT 1
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: EMPTY
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70919: LD_ADDR_VAR 0 36
70923: PUSH
70924: LD_INT 0
70926: PUSH
70927: LD_INT 0
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 0
70936: PUSH
70937: LD_INT 1
70939: NEG
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: LD_INT 0
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: LD_INT 1
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 0
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 1
70977: NEG
70978: PUSH
70979: LD_INT 0
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: LD_INT 1
70988: NEG
70989: PUSH
70990: LD_INT 1
70992: NEG
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 1
71000: NEG
71001: PUSH
71002: LD_INT 2
71004: NEG
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 1
71012: PUSH
71013: LD_INT 2
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71031: LD_ADDR_VAR 0 37
71035: PUSH
71036: LD_INT 0
71038: PUSH
71039: LD_INT 0
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 0
71048: PUSH
71049: LD_INT 1
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 1
71059: PUSH
71060: LD_INT 0
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 1
71069: PUSH
71070: LD_INT 1
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 0
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: NEG
71090: PUSH
71091: LD_INT 0
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: LD_INT 1
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: PUSH
71113: LD_INT 1
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 1
71123: NEG
71124: PUSH
71125: LD_INT 1
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71143: LD_ADDR_VAR 0 38
71147: PUSH
71148: LD_INT 0
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: LD_INT 1
71163: NEG
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 0
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 1
71201: NEG
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 1
71212: NEG
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 2
71224: PUSH
71225: LD_INT 1
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 2
71234: NEG
71235: PUSH
71236: LD_INT 1
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71255: LD_ADDR_VAR 0 39
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: LD_INT 0
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: LD_INT 1
71275: NEG
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 1
71283: PUSH
71284: LD_INT 0
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: PUSH
71294: LD_INT 1
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 0
71303: PUSH
71304: LD_INT 1
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 1
71313: NEG
71314: PUSH
71315: LD_INT 0
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: LD_INT 1
71324: NEG
71325: PUSH
71326: LD_INT 1
71328: NEG
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 1
71336: NEG
71337: PUSH
71338: LD_INT 2
71340: NEG
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 1
71348: PUSH
71349: LD_INT 2
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71367: LD_ADDR_VAR 0 40
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: LD_INT 0
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: PUSH
71382: LD_INT 0
71384: PUSH
71385: LD_INT 1
71387: NEG
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 1
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 1
71405: PUSH
71406: LD_INT 1
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 0
71415: PUSH
71416: LD_INT 1
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 1
71425: NEG
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: LD_INT 1
71440: NEG
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 1
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: LD_INT 1
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71479: LD_ADDR_VAR 0 41
71483: PUSH
71484: LD_INT 0
71486: PUSH
71487: LD_INT 0
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 0
71496: PUSH
71497: LD_INT 1
71499: NEG
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 1
71507: PUSH
71508: LD_INT 0
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 0
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: LD_INT 0
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 1
71548: NEG
71549: PUSH
71550: LD_INT 1
71552: NEG
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 1
71560: NEG
71561: PUSH
71562: LD_INT 2
71564: NEG
71565: PUSH
71566: EMPTY
71567: LIST
71568: LIST
71569: PUSH
71570: LD_INT 1
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 2
71583: PUSH
71584: LD_INT 0
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 2
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 2
71603: PUSH
71604: LD_INT 2
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: LD_INT 2
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: LD_INT 1
71623: NEG
71624: PUSH
71625: LD_INT 1
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 2
71634: NEG
71635: PUSH
71636: LD_INT 0
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 2
71645: NEG
71646: PUSH
71647: LD_INT 1
71649: NEG
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PUSH
71655: LD_INT 2
71657: NEG
71658: PUSH
71659: LD_INT 2
71661: NEG
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 2
71669: NEG
71670: PUSH
71671: LD_INT 3
71673: NEG
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 2
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 3
71692: PUSH
71693: LD_INT 0
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 3
71702: PUSH
71703: LD_INT 1
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 3
71712: PUSH
71713: LD_INT 2
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 3
71722: PUSH
71723: LD_INT 3
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 2
71732: PUSH
71733: LD_INT 3
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 2
71742: NEG
71743: PUSH
71744: LD_INT 1
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 3
71753: NEG
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 3
71764: NEG
71765: PUSH
71766: LD_INT 1
71768: NEG
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 3
71776: NEG
71777: PUSH
71778: LD_INT 2
71780: NEG
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: PUSH
71786: LD_INT 3
71788: NEG
71789: PUSH
71790: LD_INT 3
71792: NEG
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71829: LD_ADDR_VAR 0 42
71833: PUSH
71834: LD_INT 0
71836: PUSH
71837: LD_INT 0
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 1
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 1
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 0
71877: PUSH
71878: LD_INT 1
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: PUSH
71885: LD_INT 1
71887: NEG
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: LD_INT 1
71902: NEG
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: NEG
71911: PUSH
71912: LD_INT 2
71914: NEG
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 0
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 1
71933: PUSH
71934: LD_INT 1
71936: NEG
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 2
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 2
71954: PUSH
71955: LD_INT 2
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 1
71964: PUSH
71965: LD_INT 2
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 2
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 1
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: NEG
71996: PUSH
71997: LD_INT 1
71999: NEG
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 2
72007: NEG
72008: PUSH
72009: LD_INT 2
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 2
72019: NEG
72020: PUSH
72021: LD_INT 3
72023: NEG
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: LD_INT 3
72035: NEG
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 0
72043: PUSH
72044: LD_INT 3
72046: NEG
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 1
72054: PUSH
72055: LD_INT 2
72057: NEG
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 3
72065: PUSH
72066: LD_INT 2
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 3
72075: PUSH
72076: LD_INT 3
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 2
72085: PUSH
72086: LD_INT 3
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 1
72095: PUSH
72096: LD_INT 3
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 0
72105: PUSH
72106: LD_INT 3
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 1
72115: NEG
72116: PUSH
72117: LD_INT 2
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 3
72126: NEG
72127: PUSH
72128: LD_INT 2
72130: NEG
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 3
72138: NEG
72139: PUSH
72140: LD_INT 3
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72179: LD_ADDR_VAR 0 43
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 0
72196: PUSH
72197: LD_INT 1
72199: NEG
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 1
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 1
72248: NEG
72249: PUSH
72250: LD_INT 1
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 1
72260: NEG
72261: PUSH
72262: LD_INT 2
72264: NEG
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 0
72272: PUSH
72273: LD_INT 2
72275: NEG
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: PUSH
72284: LD_INT 1
72286: NEG
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 2
72294: PUSH
72295: LD_INT 0
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 2
72304: PUSH
72305: LD_INT 1
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 1
72314: PUSH
72315: LD_INT 2
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 0
72324: PUSH
72325: LD_INT 2
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 1
72334: NEG
72335: PUSH
72336: LD_INT 1
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 2
72345: NEG
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: LD_INT 1
72360: NEG
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 1
72368: NEG
72369: PUSH
72370: LD_INT 3
72372: NEG
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: LD_INT 3
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 1
72391: PUSH
72392: LD_INT 2
72394: NEG
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PUSH
72400: LD_INT 2
72402: PUSH
72403: LD_INT 1
72405: NEG
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: LD_INT 3
72413: PUSH
72414: LD_INT 0
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: PUSH
72421: LD_INT 3
72423: PUSH
72424: LD_INT 1
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 1
72433: PUSH
72434: LD_INT 3
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 0
72443: PUSH
72444: LD_INT 3
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: LD_INT 2
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: LD_INT 2
72464: NEG
72465: PUSH
72466: LD_INT 1
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 3
72475: NEG
72476: PUSH
72477: LD_INT 0
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 3
72486: NEG
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: LIST
72515: LIST
72516: LIST
72517: LIST
72518: LIST
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72527: LD_ADDR_VAR 0 44
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 0
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 0
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: LD_INT 1
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: LD_INT 1
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: LD_INT 0
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 1
72608: NEG
72609: PUSH
72610: LD_INT 2
72612: NEG
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 1
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 2
72631: PUSH
72632: LD_INT 0
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 2
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 2
72651: PUSH
72652: LD_INT 2
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 1
72661: PUSH
72662: LD_INT 2
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: LD_INT 1
72671: NEG
72672: PUSH
72673: LD_INT 1
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 2
72682: NEG
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: PUSH
72691: LD_INT 2
72693: NEG
72694: PUSH
72695: LD_INT 1
72697: NEG
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 2
72705: NEG
72706: PUSH
72707: LD_INT 2
72709: NEG
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 2
72717: NEG
72718: PUSH
72719: LD_INT 3
72721: NEG
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 2
72729: PUSH
72730: LD_INT 1
72732: NEG
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 3
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 3
72750: PUSH
72751: LD_INT 1
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 3
72760: PUSH
72761: LD_INT 2
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 3
72770: PUSH
72771: LD_INT 3
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 2
72780: PUSH
72781: LD_INT 3
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 2
72790: NEG
72791: PUSH
72792: LD_INT 1
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 3
72801: NEG
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 3
72812: NEG
72813: PUSH
72814: LD_INT 1
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 3
72824: NEG
72825: PUSH
72826: LD_INT 2
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 3
72836: NEG
72837: PUSH
72838: LD_INT 3
72840: NEG
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: LIST
72867: LIST
72868: LIST
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72877: LD_ADDR_VAR 0 45
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 0
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: PUSH
72906: LD_INT 0
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 1
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 0
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: LD_INT 0
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 1
72946: NEG
72947: PUSH
72948: LD_INT 1
72950: NEG
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 1
72958: NEG
72959: PUSH
72960: LD_INT 2
72962: NEG
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: LD_INT 2
72973: NEG
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: LD_INT 1
72984: NEG
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 2
72992: PUSH
72993: LD_INT 1
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: LD_INT 2
73002: PUSH
73003: LD_INT 2
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 1
73012: PUSH
73013: LD_INT 2
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 0
73022: PUSH
73023: LD_INT 2
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: NEG
73044: PUSH
73045: LD_INT 1
73047: NEG
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 2
73055: NEG
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 2
73067: NEG
73068: PUSH
73069: LD_INT 3
73071: NEG
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 1
73079: NEG
73080: PUSH
73081: LD_INT 3
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: LD_INT 3
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 1
73102: PUSH
73103: LD_INT 2
73105: NEG
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 3
73113: PUSH
73114: LD_INT 2
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: LD_INT 3
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 2
73133: PUSH
73134: LD_INT 3
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 1
73143: PUSH
73144: LD_INT 3
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 0
73153: PUSH
73154: LD_INT 3
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 1
73163: NEG
73164: PUSH
73165: LD_INT 2
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 3
73174: NEG
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 3
73186: NEG
73187: PUSH
73188: LD_INT 3
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73227: LD_ADDR_VAR 0 46
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 0
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: LD_INT 1
73247: NEG
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: LD_INT 0
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 1
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 0
73275: PUSH
73276: LD_INT 1
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 1
73285: NEG
73286: PUSH
73287: LD_INT 0
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: PUSH
73294: LD_INT 1
73296: NEG
73297: PUSH
73298: LD_INT 1
73300: NEG
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 1
73308: NEG
73309: PUSH
73310: LD_INT 2
73312: NEG
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 0
73320: PUSH
73321: LD_INT 2
73323: NEG
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: LD_INT 1
73334: NEG
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: PUSH
73343: LD_INT 0
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 2
73352: PUSH
73353: LD_INT 1
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: LD_INT 2
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 0
73372: PUSH
73373: LD_INT 2
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 1
73382: NEG
73383: PUSH
73384: LD_INT 1
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 2
73393: NEG
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 2
73404: NEG
73405: PUSH
73406: LD_INT 1
73408: NEG
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 1
73416: NEG
73417: PUSH
73418: LD_INT 3
73420: NEG
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: LD_INT 0
73428: PUSH
73429: LD_INT 3
73431: NEG
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: LD_INT 2
73442: NEG
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 2
73450: PUSH
73451: LD_INT 1
73453: NEG
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: LD_INT 3
73461: PUSH
73462: LD_INT 0
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: PUSH
73469: LD_INT 3
73471: PUSH
73472: LD_INT 1
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 1
73481: PUSH
73482: LD_INT 3
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: LD_INT 3
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 1
73501: NEG
73502: PUSH
73503: LD_INT 2
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 2
73512: NEG
73513: PUSH
73514: LD_INT 1
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PUSH
73521: LD_INT 3
73523: NEG
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 3
73534: NEG
73535: PUSH
73536: LD_INT 1
73538: NEG
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73575: LD_ADDR_VAR 0 47
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 0
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: LD_INT 0
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: LD_INT 1
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 0
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: NEG
73634: PUSH
73635: LD_INT 0
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 1
73644: NEG
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 1
73656: NEG
73657: PUSH
73658: LD_INT 2
73660: NEG
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 0
73668: PUSH
73669: LD_INT 2
73671: NEG
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 1
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 2
73690: NEG
73691: PUSH
73692: LD_INT 1
73694: NEG
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 2
73702: NEG
73703: PUSH
73704: LD_INT 2
73706: NEG
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73726: LD_ADDR_VAR 0 48
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: LD_INT 0
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 0
73743: PUSH
73744: LD_INT 1
73746: NEG
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 1
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: LD_INT 1
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 0
73774: PUSH
73775: LD_INT 1
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: NEG
73785: PUSH
73786: LD_INT 0
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 1
73795: NEG
73796: PUSH
73797: LD_INT 1
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 1
73807: NEG
73808: PUSH
73809: LD_INT 2
73811: NEG
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: LD_INT 2
73822: NEG
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: LD_INT 1
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 2
73841: PUSH
73842: LD_INT 0
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 2
73851: PUSH
73852: LD_INT 1
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73873: LD_ADDR_VAR 0 49
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: LD_INT 0
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 0
73890: PUSH
73891: LD_INT 1
73893: NEG
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 1
73911: PUSH
73912: LD_INT 1
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: LD_INT 1
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 1
73931: NEG
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 1
73942: NEG
73943: PUSH
73944: LD_INT 1
73946: NEG
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 1
73954: PUSH
73955: LD_INT 1
73957: NEG
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 2
73965: PUSH
73966: LD_INT 0
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 2
73975: PUSH
73976: LD_INT 1
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 2
73985: PUSH
73986: LD_INT 2
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 1
73995: PUSH
73996: LD_INT 2
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74017: LD_ADDR_VAR 0 50
74021: PUSH
74022: LD_INT 0
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: LD_INT 1
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 1
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: LD_INT 1
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 1
74075: NEG
74076: PUSH
74077: LD_INT 0
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: NEG
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: PUSH
74099: LD_INT 1
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 2
74108: PUSH
74109: LD_INT 2
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: LD_INT 2
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 0
74128: PUSH
74129: LD_INT 2
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 1
74138: NEG
74139: PUSH
74140: LD_INT 1
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: LIST
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: LIST
74157: LIST
74158: LIST
74159: LIST
74160: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74161: LD_ADDR_VAR 0 51
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: LD_INT 0
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 0
74178: PUSH
74179: LD_INT 1
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 0
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 1
74199: PUSH
74200: LD_INT 1
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 0
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: NEG
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: LD_INT 1
74234: NEG
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 1
74242: PUSH
74243: LD_INT 2
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: LD_INT 2
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: LD_INT 1
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 2
74273: NEG
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 2
74284: NEG
74285: PUSH
74286: LD_INT 1
74288: NEG
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74308: LD_ADDR_VAR 0 52
74312: PUSH
74313: LD_INT 0
74315: PUSH
74316: LD_INT 0
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 0
74325: PUSH
74326: LD_INT 1
74328: NEG
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: LD_INT 0
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 0
74356: PUSH
74357: LD_INT 1
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: LD_INT 0
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 1
74377: NEG
74378: PUSH
74379: LD_INT 1
74381: NEG
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 1
74389: NEG
74390: PUSH
74391: LD_INT 2
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 1
74401: NEG
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 2
74412: NEG
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 2
74423: NEG
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 2
74435: NEG
74436: PUSH
74437: LD_INT 2
74439: NEG
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: LIST
74449: LIST
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74459: LD_ADDR_VAR 0 53
74463: PUSH
74464: LD_INT 0
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 0
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: LD_INT 0
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: LD_INT 1
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: NEG
74518: PUSH
74519: LD_INT 0
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 1
74540: NEG
74541: PUSH
74542: LD_INT 2
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: LD_INT 2
74555: NEG
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: LD_INT 1
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 2
74574: PUSH
74575: LD_INT 0
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: LD_INT 1
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 2
74594: PUSH
74595: LD_INT 2
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 2
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: LD_INT 2
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 1
74624: NEG
74625: PUSH
74626: LD_INT 1
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 2
74635: NEG
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 2
74646: NEG
74647: PUSH
74648: LD_INT 1
74650: NEG
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 2
74658: NEG
74659: PUSH
74660: LD_INT 2
74662: NEG
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74689: LD_ADDR_VAR 0 54
74693: PUSH
74694: LD_INT 0
74696: PUSH
74697: LD_INT 0
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 0
74706: PUSH
74707: LD_INT 1
74709: NEG
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 1
74717: PUSH
74718: LD_INT 0
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 1
74727: PUSH
74728: LD_INT 1
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 0
74737: PUSH
74738: LD_INT 1
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 1
74747: NEG
74748: PUSH
74749: LD_INT 0
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 1
74758: NEG
74759: PUSH
74760: LD_INT 1
74762: NEG
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 1
74770: NEG
74771: PUSH
74772: LD_INT 2
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: LD_INT 2
74785: NEG
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 2
74804: PUSH
74805: LD_INT 0
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 2
74814: PUSH
74815: LD_INT 1
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 2
74824: PUSH
74825: LD_INT 2
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 2
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: LD_INT 2
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: NEG
74855: PUSH
74856: LD_INT 1
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 2
74865: NEG
74866: PUSH
74867: LD_INT 0
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 2
74876: NEG
74877: PUSH
74878: LD_INT 1
74880: NEG
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: PUSH
74886: LD_INT 2
74888: NEG
74889: PUSH
74890: LD_INT 2
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: LIST
74905: LIST
74906: LIST
74907: LIST
74908: LIST
74909: LIST
74910: LIST
74911: LIST
74912: LIST
74913: LIST
74914: LIST
74915: LIST
74916: LIST
74917: LIST
74918: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74919: LD_ADDR_VAR 0 55
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 1
74947: PUSH
74948: LD_INT 0
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: PUSH
74958: LD_INT 1
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 0
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 1
74977: NEG
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: LD_INT 2
75004: NEG
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 1
75023: PUSH
75024: LD_INT 1
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 2
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 2
75044: PUSH
75045: LD_INT 1
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 2
75054: PUSH
75055: LD_INT 2
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 1
75064: PUSH
75065: LD_INT 2
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: LD_INT 2
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: LD_INT 1
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 2
75095: NEG
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 2
75106: NEG
75107: PUSH
75108: LD_INT 1
75110: NEG
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 2
75118: NEG
75119: PUSH
75120: LD_INT 2
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75149: LD_ADDR_VAR 0 56
75153: PUSH
75154: LD_INT 0
75156: PUSH
75157: LD_INT 0
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: LD_INT 1
75169: NEG
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 1
75177: PUSH
75178: LD_INT 0
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 1
75187: PUSH
75188: LD_INT 1
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 0
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 1
75207: NEG
75208: PUSH
75209: LD_INT 0
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: NEG
75219: PUSH
75220: LD_INT 1
75222: NEG
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: LD_INT 1
75230: NEG
75231: PUSH
75232: LD_INT 2
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: LD_INT 2
75245: NEG
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 1
75253: PUSH
75254: LD_INT 1
75256: NEG
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: LD_INT 2
75264: PUSH
75265: LD_INT 0
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 2
75274: PUSH
75275: LD_INT 1
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 2
75284: PUSH
75285: LD_INT 2
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: LD_INT 1
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 0
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 1
75314: NEG
75315: PUSH
75316: LD_INT 1
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: LD_INT 0
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 2
75336: NEG
75337: PUSH
75338: LD_INT 1
75340: NEG
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 2
75348: NEG
75349: PUSH
75350: LD_INT 2
75352: NEG
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75379: LD_ADDR_VAR 0 57
75383: PUSH
75384: LD_INT 0
75386: PUSH
75387: LD_INT 0
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: LD_INT 1
75399: NEG
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 1
75407: PUSH
75408: LD_INT 0
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 1
75417: PUSH
75418: LD_INT 1
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: LD_INT 1
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: LD_INT 0
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 1
75460: NEG
75461: PUSH
75462: LD_INT 2
75464: NEG
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 0
75472: PUSH
75473: LD_INT 2
75475: NEG
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: LD_INT 2
75494: PUSH
75495: LD_INT 0
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 2
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 2
75514: PUSH
75515: LD_INT 2
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PUSH
75522: LD_INT 1
75524: PUSH
75525: LD_INT 2
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 0
75534: PUSH
75535: LD_INT 2
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: LD_INT 1
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 2
75555: NEG
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 2
75566: NEG
75567: PUSH
75568: LD_INT 1
75570: NEG
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 2
75578: NEG
75579: PUSH
75580: LD_INT 2
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75609: LD_ADDR_VAR 0 58
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: LD_INT 0
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: LD_INT 1
75629: NEG
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: LD_INT 1
75637: PUSH
75638: LD_INT 0
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: LD_INT 1
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: LD_INT 0
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 1
75678: NEG
75679: PUSH
75680: LD_INT 1
75682: NEG
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 1
75690: NEG
75691: PUSH
75692: LD_INT 2
75694: NEG
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 0
75702: PUSH
75703: LD_INT 2
75705: NEG
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 2
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 2
75734: PUSH
75735: LD_INT 1
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 2
75744: PUSH
75745: LD_INT 2
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: PUSH
75755: LD_INT 2
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 0
75764: PUSH
75765: LD_INT 2
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 1
75774: NEG
75775: PUSH
75776: LD_INT 1
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 2
75785: NEG
75786: PUSH
75787: LD_INT 0
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 2
75796: NEG
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 2
75808: NEG
75809: PUSH
75810: LD_INT 2
75812: NEG
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: LIST
75822: LIST
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75839: LD_ADDR_VAR 0 59
75843: PUSH
75844: LD_INT 0
75846: PUSH
75847: LD_INT 0
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: LD_INT 0
75856: PUSH
75857: LD_INT 1
75859: NEG
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 1
75867: PUSH
75868: LD_INT 0
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 1
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 1
75908: NEG
75909: PUSH
75910: LD_INT 1
75912: NEG
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75927: LD_ADDR_VAR 0 60
75931: PUSH
75932: LD_INT 0
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 0
75944: PUSH
75945: LD_INT 1
75947: NEG
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 1
75955: PUSH
75956: LD_INT 0
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 1
75965: PUSH
75966: LD_INT 1
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 0
75975: PUSH
75976: LD_INT 1
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 1
75985: NEG
75986: PUSH
75987: LD_INT 0
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 1
75996: NEG
75997: PUSH
75998: LD_INT 1
76000: NEG
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76015: LD_ADDR_VAR 0 61
76019: PUSH
76020: LD_INT 0
76022: PUSH
76023: LD_INT 0
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 1
76043: PUSH
76044: LD_INT 0
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 1
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 0
76063: PUSH
76064: LD_INT 1
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 1
76073: NEG
76074: PUSH
76075: LD_INT 0
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PUSH
76082: LD_INT 1
76084: NEG
76085: PUSH
76086: LD_INT 1
76088: NEG
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76103: LD_ADDR_VAR 0 62
76107: PUSH
76108: LD_INT 0
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: LD_INT 1
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 1
76131: PUSH
76132: LD_INT 0
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: LD_INT 1
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 0
76151: PUSH
76152: LD_INT 1
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 1
76161: NEG
76162: PUSH
76163: LD_INT 0
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 1
76172: NEG
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76191: LD_ADDR_VAR 0 63
76195: PUSH
76196: LD_INT 0
76198: PUSH
76199: LD_INT 0
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 0
76208: PUSH
76209: LD_INT 1
76211: NEG
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 1
76219: PUSH
76220: LD_INT 0
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 1
76229: PUSH
76230: LD_INT 1
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 0
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: LD_INT 0
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 1
76260: NEG
76261: PUSH
76262: LD_INT 1
76264: NEG
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: LIST
76278: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76279: LD_ADDR_VAR 0 64
76283: PUSH
76284: LD_INT 0
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 0
76296: PUSH
76297: LD_INT 1
76299: NEG
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: PUSH
76305: LD_INT 1
76307: PUSH
76308: LD_INT 0
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 1
76317: PUSH
76318: LD_INT 1
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: LD_INT 1
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 1
76348: NEG
76349: PUSH
76350: LD_INT 1
76352: NEG
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: LIST
76362: LIST
76363: LIST
76364: LIST
76365: LIST
76366: ST_TO_ADDR
// end ; 1 :
76367: GO 82264
76369: LD_INT 1
76371: DOUBLE
76372: EQUAL
76373: IFTRUE 76377
76375: GO 79000
76377: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76378: LD_ADDR_VAR 0 11
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: LD_INT 3
76389: NEG
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 3
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 2
76411: NEG
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: LIST
76421: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76422: LD_ADDR_VAR 0 12
76426: PUSH
76427: LD_INT 2
76429: PUSH
76430: LD_INT 1
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 3
76440: PUSH
76441: LD_INT 0
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 3
76450: PUSH
76451: LD_INT 1
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: LIST
76462: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76463: LD_ADDR_VAR 0 13
76467: PUSH
76468: LD_INT 3
76470: PUSH
76471: LD_INT 2
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 3
76480: PUSH
76481: LD_INT 3
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: LD_INT 2
76490: PUSH
76491: LD_INT 3
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: LIST
76502: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76503: LD_ADDR_VAR 0 14
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: LD_INT 3
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 0
76520: PUSH
76521: LD_INT 3
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 1
76530: NEG
76531: PUSH
76532: LD_INT 2
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: LIST
76543: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76544: LD_ADDR_VAR 0 15
76548: PUSH
76549: LD_INT 2
76551: NEG
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 3
76562: NEG
76563: PUSH
76564: LD_INT 0
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 3
76573: NEG
76574: PUSH
76575: LD_INT 1
76577: NEG
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: LIST
76587: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76588: LD_ADDR_VAR 0 16
76592: PUSH
76593: LD_INT 2
76595: NEG
76596: PUSH
76597: LD_INT 3
76599: NEG
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 3
76607: NEG
76608: PUSH
76609: LD_INT 2
76611: NEG
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: LD_INT 3
76619: NEG
76620: PUSH
76621: LD_INT 3
76623: NEG
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: LIST
76633: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76634: LD_ADDR_VAR 0 17
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: LD_INT 3
76645: NEG
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 0
76653: PUSH
76654: LD_INT 3
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 1
76664: PUSH
76665: LD_INT 2
76667: NEG
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: LIST
76677: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76678: LD_ADDR_VAR 0 18
76682: PUSH
76683: LD_INT 2
76685: PUSH
76686: LD_INT 1
76688: NEG
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 3
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 3
76706: PUSH
76707: LD_INT 1
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: LIST
76718: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76719: LD_ADDR_VAR 0 19
76723: PUSH
76724: LD_INT 3
76726: PUSH
76727: LD_INT 2
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 3
76736: PUSH
76737: LD_INT 3
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 2
76746: PUSH
76747: LD_INT 3
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: LIST
76758: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76759: LD_ADDR_VAR 0 20
76763: PUSH
76764: LD_INT 1
76766: PUSH
76767: LD_INT 3
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: LD_INT 3
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 1
76786: NEG
76787: PUSH
76788: LD_INT 2
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: LIST
76799: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76800: LD_ADDR_VAR 0 21
76804: PUSH
76805: LD_INT 2
76807: NEG
76808: PUSH
76809: LD_INT 1
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 3
76818: NEG
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: LIST
76843: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76844: LD_ADDR_VAR 0 22
76848: PUSH
76849: LD_INT 2
76851: NEG
76852: PUSH
76853: LD_INT 3
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 3
76863: NEG
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 3
76875: NEG
76876: PUSH
76877: LD_INT 3
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76890: LD_ADDR_VAR 0 23
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: LD_INT 3
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: LD_INT 4
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 1
76920: PUSH
76921: LD_INT 3
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: LIST
76933: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76934: LD_ADDR_VAR 0 24
76938: PUSH
76939: LD_INT 3
76941: PUSH
76942: LD_INT 0
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 3
76951: PUSH
76952: LD_INT 1
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 4
76962: PUSH
76963: LD_INT 1
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: LIST
76974: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76975: LD_ADDR_VAR 0 25
76979: PUSH
76980: LD_INT 3
76982: PUSH
76983: LD_INT 3
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 4
76992: PUSH
76993: LD_INT 3
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 3
77002: PUSH
77003: LD_INT 4
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: LIST
77014: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77015: LD_ADDR_VAR 0 26
77019: PUSH
77020: LD_INT 0
77022: PUSH
77023: LD_INT 3
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: LD_INT 4
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 1
77042: NEG
77043: PUSH
77044: LD_INT 3
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77056: LD_ADDR_VAR 0 27
77060: PUSH
77061: LD_INT 3
77063: NEG
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: LD_INT 3
77074: NEG
77075: PUSH
77076: LD_INT 1
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 4
77085: NEG
77086: PUSH
77087: LD_INT 1
77089: NEG
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: LIST
77099: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77100: LD_ADDR_VAR 0 28
77104: PUSH
77105: LD_INT 3
77107: NEG
77108: PUSH
77109: LD_INT 3
77111: NEG
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 3
77119: NEG
77120: PUSH
77121: LD_INT 4
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 4
77131: NEG
77132: PUSH
77133: LD_INT 3
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: LIST
77145: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77146: LD_ADDR_VAR 0 29
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: LD_INT 3
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 0
77165: PUSH
77166: LD_INT 3
77168: NEG
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: LD_INT 2
77179: NEG
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 1
77187: NEG
77188: PUSH
77189: LD_INT 4
77191: NEG
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: LD_INT 4
77202: NEG
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: LD_INT 1
77210: PUSH
77211: LD_INT 3
77213: NEG
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: LD_INT 1
77221: NEG
77222: PUSH
77223: LD_INT 5
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 0
77233: PUSH
77234: LD_INT 5
77236: NEG
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 1
77244: PUSH
77245: LD_INT 4
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 1
77255: NEG
77256: PUSH
77257: LD_INT 6
77259: NEG
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 0
77267: PUSH
77268: LD_INT 6
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: LD_INT 5
77281: NEG
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77301: LD_ADDR_VAR 0 30
77305: PUSH
77306: LD_INT 2
77308: PUSH
77309: LD_INT 1
77311: NEG
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PUSH
77317: LD_INT 3
77319: PUSH
77320: LD_INT 0
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 3
77329: PUSH
77330: LD_INT 1
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 3
77339: PUSH
77340: LD_INT 1
77342: NEG
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 4
77350: PUSH
77351: LD_INT 0
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 4
77360: PUSH
77361: LD_INT 1
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 4
77370: PUSH
77371: LD_INT 1
77373: NEG
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 5
77381: PUSH
77382: LD_INT 0
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 5
77391: PUSH
77392: LD_INT 1
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 5
77401: PUSH
77402: LD_INT 1
77404: NEG
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 6
77412: PUSH
77413: LD_INT 0
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 6
77422: PUSH
77423: LD_INT 1
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77444: LD_ADDR_VAR 0 31
77448: PUSH
77449: LD_INT 3
77451: PUSH
77452: LD_INT 2
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 3
77461: PUSH
77462: LD_INT 3
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: LD_INT 2
77471: PUSH
77472: LD_INT 3
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 4
77481: PUSH
77482: LD_INT 3
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 4
77491: PUSH
77492: LD_INT 4
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 3
77501: PUSH
77502: LD_INT 4
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 5
77511: PUSH
77512: LD_INT 4
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 5
77521: PUSH
77522: LD_INT 5
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 4
77531: PUSH
77532: LD_INT 5
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 6
77541: PUSH
77542: LD_INT 5
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 6
77551: PUSH
77552: LD_INT 6
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 5
77561: PUSH
77562: LD_INT 6
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77583: LD_ADDR_VAR 0 32
77587: PUSH
77588: LD_INT 1
77590: PUSH
77591: LD_INT 3
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 3
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 1
77610: NEG
77611: PUSH
77612: LD_INT 2
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 1
77621: PUSH
77622: LD_INT 4
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 0
77631: PUSH
77632: LD_INT 4
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 1
77641: NEG
77642: PUSH
77643: LD_INT 3
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 1
77652: PUSH
77653: LD_INT 5
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: LD_INT 5
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 1
77672: NEG
77673: PUSH
77674: LD_INT 4
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 1
77683: PUSH
77684: LD_INT 6
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 0
77693: PUSH
77694: LD_INT 6
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 1
77703: NEG
77704: PUSH
77705: LD_INT 5
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77726: LD_ADDR_VAR 0 33
77730: PUSH
77731: LD_INT 2
77733: NEG
77734: PUSH
77735: LD_INT 1
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 3
77744: NEG
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 3
77755: NEG
77756: PUSH
77757: LD_INT 1
77759: NEG
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 3
77767: NEG
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 4
77778: NEG
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 4
77789: NEG
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 4
77801: NEG
77802: PUSH
77803: LD_INT 1
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 5
77812: NEG
77813: PUSH
77814: LD_INT 0
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 5
77823: NEG
77824: PUSH
77825: LD_INT 1
77827: NEG
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 5
77835: NEG
77836: PUSH
77837: LD_INT 1
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 6
77846: NEG
77847: PUSH
77848: LD_INT 0
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 6
77857: NEG
77858: PUSH
77859: LD_INT 1
77861: NEG
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77881: LD_ADDR_VAR 0 34
77885: PUSH
77886: LD_INT 2
77888: NEG
77889: PUSH
77890: LD_INT 3
77892: NEG
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: LD_INT 2
77904: NEG
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: LD_INT 3
77912: NEG
77913: PUSH
77914: LD_INT 3
77916: NEG
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: LD_INT 4
77928: NEG
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 4
77936: NEG
77937: PUSH
77938: LD_INT 3
77940: NEG
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: LD_INT 4
77948: NEG
77949: PUSH
77950: LD_INT 4
77952: NEG
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 4
77960: NEG
77961: PUSH
77962: LD_INT 5
77964: NEG
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 5
77972: NEG
77973: PUSH
77974: LD_INT 4
77976: NEG
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 5
77984: NEG
77985: PUSH
77986: LD_INT 5
77988: NEG
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 5
77996: NEG
77997: PUSH
77998: LD_INT 6
78000: NEG
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 6
78008: NEG
78009: PUSH
78010: LD_INT 5
78012: NEG
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 6
78020: NEG
78021: PUSH
78022: LD_INT 6
78024: NEG
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: LIST
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78044: LD_ADDR_VAR 0 41
78048: PUSH
78049: LD_INT 0
78051: PUSH
78052: LD_INT 2
78054: NEG
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 1
78062: NEG
78063: PUSH
78064: LD_INT 3
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: LD_INT 2
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: LIST
78087: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78088: LD_ADDR_VAR 0 42
78092: PUSH
78093: LD_INT 2
78095: PUSH
78096: LD_INT 0
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: PUSH
78114: LD_INT 3
78116: PUSH
78117: LD_INT 1
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: LIST
78128: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78129: LD_ADDR_VAR 0 43
78133: PUSH
78134: LD_INT 2
78136: PUSH
78137: LD_INT 2
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 3
78146: PUSH
78147: LD_INT 2
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 2
78156: PUSH
78157: LD_INT 3
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: LIST
78168: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78169: LD_ADDR_VAR 0 44
78173: PUSH
78174: LD_INT 0
78176: PUSH
78177: LD_INT 2
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: LD_INT 3
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: NEG
78197: PUSH
78198: LD_INT 2
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: LIST
78209: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78210: LD_ADDR_VAR 0 45
78214: PUSH
78215: LD_INT 2
78217: NEG
78218: PUSH
78219: LD_INT 0
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 2
78228: NEG
78229: PUSH
78230: LD_INT 1
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: PUSH
78237: LD_INT 3
78239: NEG
78240: PUSH
78241: LD_INT 1
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: LIST
78253: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78254: LD_ADDR_VAR 0 46
78258: PUSH
78259: LD_INT 2
78261: NEG
78262: PUSH
78263: LD_INT 2
78265: NEG
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 2
78273: NEG
78274: PUSH
78275: LD_INT 3
78277: NEG
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 3
78285: NEG
78286: PUSH
78287: LD_INT 2
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: LIST
78299: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78300: LD_ADDR_VAR 0 47
78304: PUSH
78305: LD_INT 2
78307: NEG
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 1
78319: NEG
78320: PUSH
78321: LD_INT 3
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78333: LD_ADDR_VAR 0 48
78337: PUSH
78338: LD_INT 1
78340: PUSH
78341: LD_INT 2
78343: NEG
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 2
78351: PUSH
78352: LD_INT 1
78354: NEG
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78364: LD_ADDR_VAR 0 49
78368: PUSH
78369: LD_INT 3
78371: PUSH
78372: LD_INT 1
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 3
78381: PUSH
78382: LD_INT 2
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78393: LD_ADDR_VAR 0 50
78397: PUSH
78398: LD_INT 2
78400: PUSH
78401: LD_INT 3
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78422: LD_ADDR_VAR 0 51
78426: PUSH
78427: LD_INT 1
78429: NEG
78430: PUSH
78431: LD_INT 2
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: LD_INT 1
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78453: LD_ADDR_VAR 0 52
78457: PUSH
78458: LD_INT 3
78460: NEG
78461: PUSH
78462: LD_INT 1
78464: NEG
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 3
78472: NEG
78473: PUSH
78474: LD_INT 2
78476: NEG
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78486: LD_ADDR_VAR 0 53
78490: PUSH
78491: LD_INT 1
78493: NEG
78494: PUSH
78495: LD_INT 3
78497: NEG
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: LD_INT 0
78505: PUSH
78506: LD_INT 3
78508: NEG
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: LD_INT 1
78516: PUSH
78517: LD_INT 2
78519: NEG
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: LIST
78529: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78530: LD_ADDR_VAR 0 54
78534: PUSH
78535: LD_INT 2
78537: PUSH
78538: LD_INT 1
78540: NEG
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 3
78548: PUSH
78549: LD_INT 0
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 3
78558: PUSH
78559: LD_INT 1
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: LIST
78570: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78571: LD_ADDR_VAR 0 55
78575: PUSH
78576: LD_INT 3
78578: PUSH
78579: LD_INT 2
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 3
78588: PUSH
78589: LD_INT 3
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 2
78598: PUSH
78599: LD_INT 3
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: LIST
78610: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78611: LD_ADDR_VAR 0 56
78615: PUSH
78616: LD_INT 1
78618: PUSH
78619: LD_INT 3
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: LD_INT 3
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: NEG
78639: PUSH
78640: LD_INT 2
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: LIST
78651: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78652: LD_ADDR_VAR 0 57
78656: PUSH
78657: LD_INT 2
78659: NEG
78660: PUSH
78661: LD_INT 1
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 3
78670: NEG
78671: PUSH
78672: LD_INT 0
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 3
78681: NEG
78682: PUSH
78683: LD_INT 1
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78696: LD_ADDR_VAR 0 58
78700: PUSH
78701: LD_INT 2
78703: NEG
78704: PUSH
78705: LD_INT 3
78707: NEG
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 3
78715: NEG
78716: PUSH
78717: LD_INT 2
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 3
78727: NEG
78728: PUSH
78729: LD_INT 3
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: LIST
78741: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78742: LD_ADDR_VAR 0 59
78746: PUSH
78747: LD_INT 1
78749: NEG
78750: PUSH
78751: LD_INT 2
78753: NEG
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 0
78761: PUSH
78762: LD_INT 2
78764: NEG
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 1
78772: PUSH
78773: LD_INT 1
78775: NEG
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: LIST
78785: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78786: LD_ADDR_VAR 0 60
78790: PUSH
78791: LD_INT 1
78793: PUSH
78794: LD_INT 1
78796: NEG
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 2
78804: PUSH
78805: LD_INT 0
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: LD_INT 2
78814: PUSH
78815: LD_INT 1
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: LIST
78826: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78827: LD_ADDR_VAR 0 61
78831: PUSH
78832: LD_INT 2
78834: PUSH
78835: LD_INT 1
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 2
78844: PUSH
78845: LD_INT 2
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: LD_INT 2
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: LIST
78866: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78867: LD_ADDR_VAR 0 62
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: LD_INT 2
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: LD_INT 2
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 1
78894: NEG
78895: PUSH
78896: LD_INT 1
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: LIST
78907: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78908: LD_ADDR_VAR 0 63
78912: PUSH
78913: LD_INT 1
78915: NEG
78916: PUSH
78917: LD_INT 1
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 2
78926: NEG
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 2
78937: NEG
78938: PUSH
78939: LD_INT 1
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: LIST
78951: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78952: LD_ADDR_VAR 0 64
78956: PUSH
78957: LD_INT 1
78959: NEG
78960: PUSH
78961: LD_INT 2
78963: NEG
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 2
78971: NEG
78972: PUSH
78973: LD_INT 1
78975: NEG
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 2
78983: NEG
78984: PUSH
78985: LD_INT 2
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: LIST
78997: ST_TO_ADDR
// end ; 2 :
78998: GO 82264
79000: LD_INT 2
79002: DOUBLE
79003: EQUAL
79004: IFTRUE 79008
79006: GO 82263
79008: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79009: LD_ADDR_VAR 0 29
79013: PUSH
79014: LD_INT 4
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: LD_INT 1
79029: NEG
79030: PUSH
79031: EMPTY
79032: LIST
79033: LIST
79034: PUSH
79035: LD_INT 5
79037: PUSH
79038: LD_INT 0
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 5
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 4
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 3
79067: PUSH
79068: LD_INT 0
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 3
79077: PUSH
79078: LD_INT 1
79080: NEG
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 3
79088: PUSH
79089: LD_INT 2
79091: NEG
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 5
79099: PUSH
79100: LD_INT 2
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 3
79109: PUSH
79110: LD_INT 3
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 3
79119: PUSH
79120: LD_INT 2
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 4
79129: PUSH
79130: LD_INT 3
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 4
79139: PUSH
79140: LD_INT 4
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 3
79149: PUSH
79150: LD_INT 4
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 2
79159: PUSH
79160: LD_INT 3
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: LD_INT 2
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 4
79179: PUSH
79180: LD_INT 2
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 2
79189: PUSH
79190: LD_INT 4
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 0
79199: PUSH
79200: LD_INT 4
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: LD_INT 3
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 1
79219: PUSH
79220: LD_INT 4
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: LD_INT 5
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 0
79239: PUSH
79240: LD_INT 5
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 1
79249: NEG
79250: PUSH
79251: LD_INT 4
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: NEG
79261: PUSH
79262: LD_INT 3
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 2
79271: PUSH
79272: LD_INT 5
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 2
79281: NEG
79282: PUSH
79283: LD_INT 3
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 3
79292: NEG
79293: PUSH
79294: LD_INT 0
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 3
79303: NEG
79304: PUSH
79305: LD_INT 1
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 2
79315: NEG
79316: PUSH
79317: LD_INT 0
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 2
79326: NEG
79327: PUSH
79328: LD_INT 1
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 3
79337: NEG
79338: PUSH
79339: LD_INT 1
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 4
79348: NEG
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 4
79359: NEG
79360: PUSH
79361: LD_INT 1
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 4
79371: NEG
79372: PUSH
79373: LD_INT 2
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 2
79383: NEG
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 4
79394: NEG
79395: PUSH
79396: LD_INT 4
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 4
79406: NEG
79407: PUSH
79408: LD_INT 5
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 3
79418: NEG
79419: PUSH
79420: LD_INT 4
79422: NEG
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 3
79430: NEG
79431: PUSH
79432: LD_INT 3
79434: NEG
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 4
79442: NEG
79443: PUSH
79444: LD_INT 3
79446: NEG
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 5
79454: NEG
79455: PUSH
79456: LD_INT 4
79458: NEG
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 5
79466: NEG
79467: PUSH
79468: LD_INT 5
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 3
79478: NEG
79479: PUSH
79480: LD_INT 5
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 5
79490: NEG
79491: PUSH
79492: LD_INT 3
79494: NEG
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79547: LD_ADDR_VAR 0 30
79551: PUSH
79552: LD_INT 4
79554: PUSH
79555: LD_INT 4
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 4
79564: PUSH
79565: LD_INT 3
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 5
79574: PUSH
79575: LD_INT 4
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 5
79584: PUSH
79585: LD_INT 5
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 4
79594: PUSH
79595: LD_INT 5
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 3
79604: PUSH
79605: LD_INT 4
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 3
79614: PUSH
79615: LD_INT 3
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 5
79624: PUSH
79625: LD_INT 3
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 3
79634: PUSH
79635: LD_INT 5
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 3
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: LD_INT 2
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 1
79664: PUSH
79665: LD_INT 3
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: PUSH
79675: LD_INT 4
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: LD_INT 4
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 1
79694: NEG
79695: PUSH
79696: LD_INT 3
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 1
79705: NEG
79706: PUSH
79707: LD_INT 2
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: LD_INT 2
79716: PUSH
79717: LD_INT 4
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 2
79726: NEG
79727: PUSH
79728: LD_INT 2
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 4
79737: NEG
79738: PUSH
79739: LD_INT 0
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 4
79748: NEG
79749: PUSH
79750: LD_INT 1
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 3
79760: NEG
79761: PUSH
79762: LD_INT 0
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 3
79771: NEG
79772: PUSH
79773: LD_INT 1
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 4
79782: NEG
79783: PUSH
79784: LD_INT 1
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 5
79793: NEG
79794: PUSH
79795: LD_INT 0
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 5
79804: NEG
79805: PUSH
79806: LD_INT 1
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 5
79816: NEG
79817: PUSH
79818: LD_INT 2
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 3
79828: NEG
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 3
79839: NEG
79840: PUSH
79841: LD_INT 3
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 3
79851: NEG
79852: PUSH
79853: LD_INT 4
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: NEG
79864: PUSH
79865: LD_INT 3
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 2
79875: NEG
79876: PUSH
79877: LD_INT 2
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 3
79887: NEG
79888: PUSH
79889: LD_INT 2
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 4
79899: NEG
79900: PUSH
79901: LD_INT 3
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 4
79911: NEG
79912: PUSH
79913: LD_INT 4
79915: NEG
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 2
79923: NEG
79924: PUSH
79925: LD_INT 4
79927: NEG
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 4
79935: NEG
79936: PUSH
79937: LD_INT 2
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: LD_INT 4
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 0
79958: PUSH
79959: LD_INT 5
79961: NEG
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 1
79969: PUSH
79970: LD_INT 4
79972: NEG
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 1
79980: PUSH
79981: LD_INT 3
79983: NEG
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 0
79991: PUSH
79992: LD_INT 3
79994: NEG
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 1
80002: NEG
80003: PUSH
80004: LD_INT 4
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: LD_INT 5
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 2
80026: PUSH
80027: LD_INT 3
80029: NEG
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 2
80037: NEG
80038: PUSH
80039: LD_INT 5
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: LIST
80051: LIST
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80094: LD_ADDR_VAR 0 31
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: LD_INT 4
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: LD_INT 3
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: LD_INT 4
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: LD_INT 5
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 0
80141: PUSH
80142: LD_INT 5
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 4
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: NEG
80163: PUSH
80164: LD_INT 3
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 2
80173: PUSH
80174: LD_INT 5
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 2
80183: NEG
80184: PUSH
80185: LD_INT 3
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 3
80194: NEG
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 3
80205: NEG
80206: PUSH
80207: LD_INT 1
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 2
80217: NEG
80218: PUSH
80219: LD_INT 0
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 3
80239: NEG
80240: PUSH
80241: LD_INT 1
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 4
80250: NEG
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 4
80261: NEG
80262: PUSH
80263: LD_INT 1
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 4
80273: NEG
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 2
80285: NEG
80286: PUSH
80287: LD_INT 2
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 4
80296: NEG
80297: PUSH
80298: LD_INT 4
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 4
80308: NEG
80309: PUSH
80310: LD_INT 5
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 3
80320: NEG
80321: PUSH
80322: LD_INT 4
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 3
80332: NEG
80333: PUSH
80334: LD_INT 3
80336: NEG
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 4
80344: NEG
80345: PUSH
80346: LD_INT 3
80348: NEG
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: LD_INT 5
80356: NEG
80357: PUSH
80358: LD_INT 4
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 5
80368: NEG
80369: PUSH
80370: LD_INT 5
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 3
80380: NEG
80381: PUSH
80382: LD_INT 5
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 5
80392: NEG
80393: PUSH
80394: LD_INT 3
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 0
80404: PUSH
80405: LD_INT 3
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 0
80415: PUSH
80416: LD_INT 4
80418: NEG
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 1
80426: PUSH
80427: LD_INT 3
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 1
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 0
80448: PUSH
80449: LD_INT 2
80451: NEG
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: LD_INT 3
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 1
80471: NEG
80472: PUSH
80473: LD_INT 4
80475: NEG
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 2
80483: PUSH
80484: LD_INT 2
80486: NEG
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 2
80494: NEG
80495: PUSH
80496: LD_INT 4
80498: NEG
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 4
80506: PUSH
80507: LD_INT 0
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 4
80516: PUSH
80517: LD_INT 1
80519: NEG
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 5
80527: PUSH
80528: LD_INT 0
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 5
80537: PUSH
80538: LD_INT 1
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 4
80547: PUSH
80548: LD_INT 1
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 3
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 3
80567: PUSH
80568: LD_INT 1
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 3
80578: PUSH
80579: LD_INT 2
80581: NEG
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PUSH
80587: LD_INT 5
80589: PUSH
80590: LD_INT 2
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80644: LD_ADDR_VAR 0 32
80648: PUSH
80649: LD_INT 4
80651: NEG
80652: PUSH
80653: LD_INT 0
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 4
80662: NEG
80663: PUSH
80664: LD_INT 1
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 3
80674: NEG
80675: PUSH
80676: LD_INT 0
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 3
80685: NEG
80686: PUSH
80687: LD_INT 1
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 4
80696: NEG
80697: PUSH
80698: LD_INT 1
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 5
80707: NEG
80708: PUSH
80709: LD_INT 0
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 5
80718: NEG
80719: PUSH
80720: LD_INT 1
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 5
80730: NEG
80731: PUSH
80732: LD_INT 2
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: LD_INT 2
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 3
80753: NEG
80754: PUSH
80755: LD_INT 3
80757: NEG
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 3
80765: NEG
80766: PUSH
80767: LD_INT 4
80769: NEG
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: NEG
80778: PUSH
80779: LD_INT 3
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 2
80789: NEG
80790: PUSH
80791: LD_INT 2
80793: NEG
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 3
80801: NEG
80802: PUSH
80803: LD_INT 2
80805: NEG
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 4
80813: NEG
80814: PUSH
80815: LD_INT 3
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 4
80825: NEG
80826: PUSH
80827: LD_INT 4
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 2
80837: NEG
80838: PUSH
80839: LD_INT 4
80841: NEG
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 4
80849: NEG
80850: PUSH
80851: LD_INT 2
80853: NEG
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 0
80861: PUSH
80862: LD_INT 4
80864: NEG
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: LD_INT 5
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: LD_INT 4
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: LD_INT 3
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 0
80905: PUSH
80906: LD_INT 3
80908: NEG
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: LD_INT 4
80920: NEG
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 1
80928: NEG
80929: PUSH
80930: LD_INT 5
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 2
80940: PUSH
80941: LD_INT 3
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 2
80951: NEG
80952: PUSH
80953: LD_INT 5
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 3
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 3
80973: PUSH
80974: LD_INT 1
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 4
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 4
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 3
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PUSH
81012: LD_INT 2
81014: PUSH
81015: LD_INT 0
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: PUSH
81025: LD_INT 1
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 2
81035: PUSH
81036: LD_INT 2
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 4
81046: PUSH
81047: LD_INT 2
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 4
81056: PUSH
81057: LD_INT 4
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 4
81066: PUSH
81067: LD_INT 3
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 5
81076: PUSH
81077: LD_INT 4
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 5
81086: PUSH
81087: LD_INT 5
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 4
81096: PUSH
81097: LD_INT 5
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 3
81106: PUSH
81107: LD_INT 4
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 3
81116: PUSH
81117: LD_INT 3
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 5
81126: PUSH
81127: LD_INT 3
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 3
81136: PUSH
81137: LD_INT 5
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81191: LD_ADDR_VAR 0 33
81195: PUSH
81196: LD_INT 4
81198: NEG
81199: PUSH
81200: LD_INT 4
81202: NEG
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 4
81210: NEG
81211: PUSH
81212: LD_INT 5
81214: NEG
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 3
81222: NEG
81223: PUSH
81224: LD_INT 4
81226: NEG
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 3
81234: NEG
81235: PUSH
81236: LD_INT 3
81238: NEG
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 4
81246: NEG
81247: PUSH
81248: LD_INT 3
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 5
81258: NEG
81259: PUSH
81260: LD_INT 4
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 5
81270: NEG
81271: PUSH
81272: LD_INT 5
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 3
81282: NEG
81283: PUSH
81284: LD_INT 5
81286: NEG
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 5
81294: NEG
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: LD_INT 3
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 0
81317: PUSH
81318: LD_INT 4
81320: NEG
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 1
81328: PUSH
81329: LD_INT 3
81331: NEG
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: LD_INT 2
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: LD_INT 2
81353: NEG
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: PUSH
81363: LD_INT 3
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 1
81373: NEG
81374: PUSH
81375: LD_INT 4
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 2
81385: PUSH
81386: LD_INT 2
81388: NEG
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: LD_INT 4
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 4
81408: PUSH
81409: LD_INT 0
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 4
81418: PUSH
81419: LD_INT 1
81421: NEG
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 5
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 5
81439: PUSH
81440: LD_INT 1
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 4
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 3
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 3
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 3
81480: PUSH
81481: LD_INT 2
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 5
81491: PUSH
81492: LD_INT 2
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 3
81501: PUSH
81502: LD_INT 3
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 3
81511: PUSH
81512: LD_INT 2
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 4
81521: PUSH
81522: LD_INT 3
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 4
81531: PUSH
81532: LD_INT 4
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 3
81541: PUSH
81542: LD_INT 4
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 3
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 2
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 4
81571: PUSH
81572: LD_INT 2
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 2
81581: PUSH
81582: LD_INT 4
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: LD_INT 4
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: LD_INT 3
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: LD_INT 4
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 1
81621: PUSH
81622: LD_INT 5
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: LD_INT 5
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 1
81641: NEG
81642: PUSH
81643: LD_INT 4
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 1
81652: NEG
81653: PUSH
81654: LD_INT 3
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 2
81663: PUSH
81664: LD_INT 5
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 2
81673: NEG
81674: PUSH
81675: LD_INT 3
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81729: LD_ADDR_VAR 0 34
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 4
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 0
81747: PUSH
81748: LD_INT 5
81750: NEG
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 1
81758: PUSH
81759: LD_INT 4
81761: NEG
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 1
81769: PUSH
81770: LD_INT 3
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 0
81780: PUSH
81781: LD_INT 3
81783: NEG
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 1
81791: NEG
81792: PUSH
81793: LD_INT 4
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 1
81803: NEG
81804: PUSH
81805: LD_INT 5
81807: NEG
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 2
81815: PUSH
81816: LD_INT 3
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 2
81826: NEG
81827: PUSH
81828: LD_INT 5
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 3
81838: PUSH
81839: LD_INT 0
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 3
81848: PUSH
81849: LD_INT 1
81851: NEG
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 4
81859: PUSH
81860: LD_INT 0
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 4
81869: PUSH
81870: LD_INT 1
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 3
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 2
81910: PUSH
81911: LD_INT 2
81913: NEG
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 4
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 4
81931: PUSH
81932: LD_INT 4
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 4
81941: PUSH
81942: LD_INT 3
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 5
81951: PUSH
81952: LD_INT 4
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 5
81961: PUSH
81962: LD_INT 5
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 4
81971: PUSH
81972: LD_INT 5
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 3
81981: PUSH
81982: LD_INT 4
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 3
81991: PUSH
81992: LD_INT 3
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 5
82001: PUSH
82002: LD_INT 3
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 3
82011: PUSH
82012: LD_INT 5
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: LD_INT 3
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 0
82031: PUSH
82032: LD_INT 2
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: LD_INT 3
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: LD_INT 4
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 4
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 1
82071: NEG
82072: PUSH
82073: LD_INT 3
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: LD_INT 2
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: LD_INT 4
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 2
82103: NEG
82104: PUSH
82105: LD_INT 2
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 4
82114: NEG
82115: PUSH
82116: LD_INT 0
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 4
82125: NEG
82126: PUSH
82127: LD_INT 1
82129: NEG
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 3
82137: NEG
82138: PUSH
82139: LD_INT 0
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 3
82148: NEG
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 4
82159: NEG
82160: PUSH
82161: LD_INT 1
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 5
82170: NEG
82171: PUSH
82172: LD_INT 0
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 5
82181: NEG
82182: PUSH
82183: LD_INT 1
82185: NEG
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: LD_INT 5
82193: NEG
82194: PUSH
82195: LD_INT 2
82197: NEG
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PUSH
82203: LD_INT 3
82205: NEG
82206: PUSH
82207: LD_INT 2
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: ST_TO_ADDR
// end ; end ;
82261: GO 82264
82263: POP
// case btype of b_depot , b_warehouse :
82264: LD_VAR 0 1
82268: PUSH
82269: LD_INT 0
82271: DOUBLE
82272: EQUAL
82273: IFTRUE 82283
82275: LD_INT 1
82277: DOUBLE
82278: EQUAL
82279: IFTRUE 82283
82281: GO 82484
82283: POP
// case nation of nation_american :
82284: LD_VAR 0 5
82288: PUSH
82289: LD_INT 1
82291: DOUBLE
82292: EQUAL
82293: IFTRUE 82297
82295: GO 82353
82297: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82298: LD_ADDR_VAR 0 9
82302: PUSH
82303: LD_VAR 0 11
82307: PUSH
82308: LD_VAR 0 12
82312: PUSH
82313: LD_VAR 0 13
82317: PUSH
82318: LD_VAR 0 14
82322: PUSH
82323: LD_VAR 0 15
82327: PUSH
82328: LD_VAR 0 16
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: PUSH
82341: LD_VAR 0 4
82345: PUSH
82346: LD_INT 1
82348: PLUS
82349: ARRAY
82350: ST_TO_ADDR
82351: GO 82482
82353: LD_INT 2
82355: DOUBLE
82356: EQUAL
82357: IFTRUE 82361
82359: GO 82417
82361: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
82362: LD_ADDR_VAR 0 9
82366: PUSH
82367: LD_VAR 0 17
82371: PUSH
82372: LD_VAR 0 18
82376: PUSH
82377: LD_VAR 0 19
82381: PUSH
82382: LD_VAR 0 20
82386: PUSH
82387: LD_VAR 0 21
82391: PUSH
82392: LD_VAR 0 22
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: PUSH
82405: LD_VAR 0 4
82409: PUSH
82410: LD_INT 1
82412: PLUS
82413: ARRAY
82414: ST_TO_ADDR
82415: GO 82482
82417: LD_INT 3
82419: DOUBLE
82420: EQUAL
82421: IFTRUE 82425
82423: GO 82481
82425: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82426: LD_ADDR_VAR 0 9
82430: PUSH
82431: LD_VAR 0 23
82435: PUSH
82436: LD_VAR 0 24
82440: PUSH
82441: LD_VAR 0 25
82445: PUSH
82446: LD_VAR 0 26
82450: PUSH
82451: LD_VAR 0 27
82455: PUSH
82456: LD_VAR 0 28
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: PUSH
82469: LD_VAR 0 4
82473: PUSH
82474: LD_INT 1
82476: PLUS
82477: ARRAY
82478: ST_TO_ADDR
82479: GO 82482
82481: POP
82482: GO 83037
82484: LD_INT 2
82486: DOUBLE
82487: EQUAL
82488: IFTRUE 82498
82490: LD_INT 3
82492: DOUBLE
82493: EQUAL
82494: IFTRUE 82498
82496: GO 82554
82498: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82499: LD_ADDR_VAR 0 9
82503: PUSH
82504: LD_VAR 0 29
82508: PUSH
82509: LD_VAR 0 30
82513: PUSH
82514: LD_VAR 0 31
82518: PUSH
82519: LD_VAR 0 32
82523: PUSH
82524: LD_VAR 0 33
82528: PUSH
82529: LD_VAR 0 34
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: PUSH
82542: LD_VAR 0 4
82546: PUSH
82547: LD_INT 1
82549: PLUS
82550: ARRAY
82551: ST_TO_ADDR
82552: GO 83037
82554: LD_INT 16
82556: DOUBLE
82557: EQUAL
82558: IFTRUE 82616
82560: LD_INT 17
82562: DOUBLE
82563: EQUAL
82564: IFTRUE 82616
82566: LD_INT 18
82568: DOUBLE
82569: EQUAL
82570: IFTRUE 82616
82572: LD_INT 19
82574: DOUBLE
82575: EQUAL
82576: IFTRUE 82616
82578: LD_INT 22
82580: DOUBLE
82581: EQUAL
82582: IFTRUE 82616
82584: LD_INT 20
82586: DOUBLE
82587: EQUAL
82588: IFTRUE 82616
82590: LD_INT 21
82592: DOUBLE
82593: EQUAL
82594: IFTRUE 82616
82596: LD_INT 23
82598: DOUBLE
82599: EQUAL
82600: IFTRUE 82616
82602: LD_INT 24
82604: DOUBLE
82605: EQUAL
82606: IFTRUE 82616
82608: LD_INT 25
82610: DOUBLE
82611: EQUAL
82612: IFTRUE 82616
82614: GO 82672
82616: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82617: LD_ADDR_VAR 0 9
82621: PUSH
82622: LD_VAR 0 35
82626: PUSH
82627: LD_VAR 0 36
82631: PUSH
82632: LD_VAR 0 37
82636: PUSH
82637: LD_VAR 0 38
82641: PUSH
82642: LD_VAR 0 39
82646: PUSH
82647: LD_VAR 0 40
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: PUSH
82660: LD_VAR 0 4
82664: PUSH
82665: LD_INT 1
82667: PLUS
82668: ARRAY
82669: ST_TO_ADDR
82670: GO 83037
82672: LD_INT 6
82674: DOUBLE
82675: EQUAL
82676: IFTRUE 82728
82678: LD_INT 7
82680: DOUBLE
82681: EQUAL
82682: IFTRUE 82728
82684: LD_INT 8
82686: DOUBLE
82687: EQUAL
82688: IFTRUE 82728
82690: LD_INT 13
82692: DOUBLE
82693: EQUAL
82694: IFTRUE 82728
82696: LD_INT 12
82698: DOUBLE
82699: EQUAL
82700: IFTRUE 82728
82702: LD_INT 15
82704: DOUBLE
82705: EQUAL
82706: IFTRUE 82728
82708: LD_INT 11
82710: DOUBLE
82711: EQUAL
82712: IFTRUE 82728
82714: LD_INT 14
82716: DOUBLE
82717: EQUAL
82718: IFTRUE 82728
82720: LD_INT 10
82722: DOUBLE
82723: EQUAL
82724: IFTRUE 82728
82726: GO 82784
82728: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82729: LD_ADDR_VAR 0 9
82733: PUSH
82734: LD_VAR 0 41
82738: PUSH
82739: LD_VAR 0 42
82743: PUSH
82744: LD_VAR 0 43
82748: PUSH
82749: LD_VAR 0 44
82753: PUSH
82754: LD_VAR 0 45
82758: PUSH
82759: LD_VAR 0 46
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: PUSH
82772: LD_VAR 0 4
82776: PUSH
82777: LD_INT 1
82779: PLUS
82780: ARRAY
82781: ST_TO_ADDR
82782: GO 83037
82784: LD_INT 36
82786: DOUBLE
82787: EQUAL
82788: IFTRUE 82792
82790: GO 82848
82792: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82793: LD_ADDR_VAR 0 9
82797: PUSH
82798: LD_VAR 0 47
82802: PUSH
82803: LD_VAR 0 48
82807: PUSH
82808: LD_VAR 0 49
82812: PUSH
82813: LD_VAR 0 50
82817: PUSH
82818: LD_VAR 0 51
82822: PUSH
82823: LD_VAR 0 52
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: PUSH
82836: LD_VAR 0 4
82840: PUSH
82841: LD_INT 1
82843: PLUS
82844: ARRAY
82845: ST_TO_ADDR
82846: GO 83037
82848: LD_INT 4
82850: DOUBLE
82851: EQUAL
82852: IFTRUE 82874
82854: LD_INT 5
82856: DOUBLE
82857: EQUAL
82858: IFTRUE 82874
82860: LD_INT 34
82862: DOUBLE
82863: EQUAL
82864: IFTRUE 82874
82866: LD_INT 37
82868: DOUBLE
82869: EQUAL
82870: IFTRUE 82874
82872: GO 82930
82874: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82875: LD_ADDR_VAR 0 9
82879: PUSH
82880: LD_VAR 0 53
82884: PUSH
82885: LD_VAR 0 54
82889: PUSH
82890: LD_VAR 0 55
82894: PUSH
82895: LD_VAR 0 56
82899: PUSH
82900: LD_VAR 0 57
82904: PUSH
82905: LD_VAR 0 58
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: PUSH
82918: LD_VAR 0 4
82922: PUSH
82923: LD_INT 1
82925: PLUS
82926: ARRAY
82927: ST_TO_ADDR
82928: GO 83037
82930: LD_INT 31
82932: DOUBLE
82933: EQUAL
82934: IFTRUE 82980
82936: LD_INT 32
82938: DOUBLE
82939: EQUAL
82940: IFTRUE 82980
82942: LD_INT 33
82944: DOUBLE
82945: EQUAL
82946: IFTRUE 82980
82948: LD_INT 27
82950: DOUBLE
82951: EQUAL
82952: IFTRUE 82980
82954: LD_INT 26
82956: DOUBLE
82957: EQUAL
82958: IFTRUE 82980
82960: LD_INT 28
82962: DOUBLE
82963: EQUAL
82964: IFTRUE 82980
82966: LD_INT 29
82968: DOUBLE
82969: EQUAL
82970: IFTRUE 82980
82972: LD_INT 30
82974: DOUBLE
82975: EQUAL
82976: IFTRUE 82980
82978: GO 83036
82980: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82981: LD_ADDR_VAR 0 9
82985: PUSH
82986: LD_VAR 0 59
82990: PUSH
82991: LD_VAR 0 60
82995: PUSH
82996: LD_VAR 0 61
83000: PUSH
83001: LD_VAR 0 62
83005: PUSH
83006: LD_VAR 0 63
83010: PUSH
83011: LD_VAR 0 64
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: PUSH
83024: LD_VAR 0 4
83028: PUSH
83029: LD_INT 1
83031: PLUS
83032: ARRAY
83033: ST_TO_ADDR
83034: GO 83037
83036: POP
// temp_list2 = [ ] ;
83037: LD_ADDR_VAR 0 10
83041: PUSH
83042: EMPTY
83043: ST_TO_ADDR
// for i in temp_list do
83044: LD_ADDR_VAR 0 8
83048: PUSH
83049: LD_VAR 0 9
83053: PUSH
83054: FOR_IN
83055: IFFALSE 83107
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83057: LD_ADDR_VAR 0 10
83061: PUSH
83062: LD_VAR 0 10
83066: PUSH
83067: LD_VAR 0 8
83071: PUSH
83072: LD_INT 1
83074: ARRAY
83075: PUSH
83076: LD_VAR 0 2
83080: PLUS
83081: PUSH
83082: LD_VAR 0 8
83086: PUSH
83087: LD_INT 2
83089: ARRAY
83090: PUSH
83091: LD_VAR 0 3
83095: PLUS
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: EMPTY
83102: LIST
83103: ADD
83104: ST_TO_ADDR
83105: GO 83054
83107: POP
83108: POP
// result = temp_list2 ;
83109: LD_ADDR_VAR 0 7
83113: PUSH
83114: LD_VAR 0 10
83118: ST_TO_ADDR
// end ;
83119: LD_VAR 0 7
83123: RET
// export function EnemyInRange ( unit , dist ) ; begin
83124: LD_INT 0
83126: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83127: LD_ADDR_VAR 0 3
83131: PUSH
83132: LD_VAR 0 1
83136: PPUSH
83137: CALL_OW 255
83141: PPUSH
83142: LD_VAR 0 1
83146: PPUSH
83147: CALL_OW 250
83151: PPUSH
83152: LD_VAR 0 1
83156: PPUSH
83157: CALL_OW 251
83161: PPUSH
83162: LD_VAR 0 2
83166: PPUSH
83167: CALL 56895 0 4
83171: PUSH
83172: LD_INT 4
83174: ARRAY
83175: ST_TO_ADDR
// end ;
83176: LD_VAR 0 3
83180: RET
// export function PlayerSeeMe ( unit ) ; begin
83181: LD_INT 0
83183: PPUSH
// result := See ( your_side , unit ) ;
83184: LD_ADDR_VAR 0 2
83188: PUSH
83189: LD_OWVAR 2
83193: PPUSH
83194: LD_VAR 0 1
83198: PPUSH
83199: CALL_OW 292
83203: ST_TO_ADDR
// end ;
83204: LD_VAR 0 2
83208: RET
// export function ReverseDir ( unit ) ; begin
83209: LD_INT 0
83211: PPUSH
// if not unit then
83212: LD_VAR 0 1
83216: NOT
83217: IFFALSE 83221
// exit ;
83219: GO 83244
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83221: LD_ADDR_VAR 0 2
83225: PUSH
83226: LD_VAR 0 1
83230: PPUSH
83231: CALL_OW 254
83235: PUSH
83236: LD_INT 3
83238: PLUS
83239: PUSH
83240: LD_INT 6
83242: MOD
83243: ST_TO_ADDR
// end ;
83244: LD_VAR 0 2
83248: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83249: LD_INT 0
83251: PPUSH
83252: PPUSH
83253: PPUSH
83254: PPUSH
83255: PPUSH
// if not hexes then
83256: LD_VAR 0 2
83260: NOT
83261: IFFALSE 83265
// exit ;
83263: GO 83413
// dist := 9999 ;
83265: LD_ADDR_VAR 0 5
83269: PUSH
83270: LD_INT 9999
83272: ST_TO_ADDR
// for i = 1 to hexes do
83273: LD_ADDR_VAR 0 4
83277: PUSH
83278: DOUBLE
83279: LD_INT 1
83281: DEC
83282: ST_TO_ADDR
83283: LD_VAR 0 2
83287: PUSH
83288: FOR_TO
83289: IFFALSE 83401
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83291: LD_VAR 0 1
83295: PPUSH
83296: LD_VAR 0 2
83300: PUSH
83301: LD_VAR 0 4
83305: ARRAY
83306: PUSH
83307: LD_INT 1
83309: ARRAY
83310: PPUSH
83311: LD_VAR 0 2
83315: PUSH
83316: LD_VAR 0 4
83320: ARRAY
83321: PUSH
83322: LD_INT 2
83324: ARRAY
83325: PPUSH
83326: CALL_OW 297
83330: PUSH
83331: LD_VAR 0 5
83335: LESS
83336: IFFALSE 83399
// begin hex := hexes [ i ] ;
83338: LD_ADDR_VAR 0 7
83342: PUSH
83343: LD_VAR 0 2
83347: PUSH
83348: LD_VAR 0 4
83352: ARRAY
83353: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83354: LD_ADDR_VAR 0 5
83358: PUSH
83359: LD_VAR 0 1
83363: PPUSH
83364: LD_VAR 0 2
83368: PUSH
83369: LD_VAR 0 4
83373: ARRAY
83374: PUSH
83375: LD_INT 1
83377: ARRAY
83378: PPUSH
83379: LD_VAR 0 2
83383: PUSH
83384: LD_VAR 0 4
83388: ARRAY
83389: PUSH
83390: LD_INT 2
83392: ARRAY
83393: PPUSH
83394: CALL_OW 297
83398: ST_TO_ADDR
// end ; end ;
83399: GO 83288
83401: POP
83402: POP
// result := hex ;
83403: LD_ADDR_VAR 0 3
83407: PUSH
83408: LD_VAR 0 7
83412: ST_TO_ADDR
// end ;
83413: LD_VAR 0 3
83417: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83418: LD_INT 0
83420: PPUSH
83421: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83422: LD_VAR 0 1
83426: NOT
83427: PUSH
83428: LD_VAR 0 1
83432: PUSH
83433: LD_INT 21
83435: PUSH
83436: LD_INT 2
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 23
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PPUSH
83457: CALL_OW 69
83461: IN
83462: NOT
83463: OR
83464: IFFALSE 83468
// exit ;
83466: GO 83515
// for i = 1 to 3 do
83468: LD_ADDR_VAR 0 3
83472: PUSH
83473: DOUBLE
83474: LD_INT 1
83476: DEC
83477: ST_TO_ADDR
83478: LD_INT 3
83480: PUSH
83481: FOR_TO
83482: IFFALSE 83513
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83484: LD_VAR 0 1
83488: PPUSH
83489: CALL_OW 250
83493: PPUSH
83494: LD_VAR 0 1
83498: PPUSH
83499: CALL_OW 251
83503: PPUSH
83504: LD_INT 1
83506: PPUSH
83507: CALL_OW 453
83511: GO 83481
83513: POP
83514: POP
// end ;
83515: LD_VAR 0 2
83519: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83520: LD_INT 0
83522: PPUSH
83523: PPUSH
83524: PPUSH
83525: PPUSH
83526: PPUSH
83527: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83528: LD_VAR 0 1
83532: NOT
83533: PUSH
83534: LD_VAR 0 2
83538: NOT
83539: OR
83540: PUSH
83541: LD_VAR 0 1
83545: PPUSH
83546: CALL_OW 314
83550: OR
83551: IFFALSE 83555
// exit ;
83553: GO 83996
// x := GetX ( enemy_unit ) ;
83555: LD_ADDR_VAR 0 7
83559: PUSH
83560: LD_VAR 0 2
83564: PPUSH
83565: CALL_OW 250
83569: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83570: LD_ADDR_VAR 0 8
83574: PUSH
83575: LD_VAR 0 2
83579: PPUSH
83580: CALL_OW 251
83584: ST_TO_ADDR
// if not x or not y then
83585: LD_VAR 0 7
83589: NOT
83590: PUSH
83591: LD_VAR 0 8
83595: NOT
83596: OR
83597: IFFALSE 83601
// exit ;
83599: GO 83996
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83601: LD_ADDR_VAR 0 6
83605: PUSH
83606: LD_VAR 0 7
83610: PPUSH
83611: LD_INT 0
83613: PPUSH
83614: LD_INT 4
83616: PPUSH
83617: CALL_OW 272
83621: PUSH
83622: LD_VAR 0 8
83626: PPUSH
83627: LD_INT 0
83629: PPUSH
83630: LD_INT 4
83632: PPUSH
83633: CALL_OW 273
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_VAR 0 7
83646: PPUSH
83647: LD_INT 1
83649: PPUSH
83650: LD_INT 4
83652: PPUSH
83653: CALL_OW 272
83657: PUSH
83658: LD_VAR 0 8
83662: PPUSH
83663: LD_INT 1
83665: PPUSH
83666: LD_INT 4
83668: PPUSH
83669: CALL_OW 273
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PUSH
83678: LD_VAR 0 7
83682: PPUSH
83683: LD_INT 2
83685: PPUSH
83686: LD_INT 4
83688: PPUSH
83689: CALL_OW 272
83693: PUSH
83694: LD_VAR 0 8
83698: PPUSH
83699: LD_INT 2
83701: PPUSH
83702: LD_INT 4
83704: PPUSH
83705: CALL_OW 273
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_VAR 0 7
83718: PPUSH
83719: LD_INT 3
83721: PPUSH
83722: LD_INT 4
83724: PPUSH
83725: CALL_OW 272
83729: PUSH
83730: LD_VAR 0 8
83734: PPUSH
83735: LD_INT 3
83737: PPUSH
83738: LD_INT 4
83740: PPUSH
83741: CALL_OW 273
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_VAR 0 7
83754: PPUSH
83755: LD_INT 4
83757: PPUSH
83758: LD_INT 4
83760: PPUSH
83761: CALL_OW 272
83765: PUSH
83766: LD_VAR 0 8
83770: PPUSH
83771: LD_INT 4
83773: PPUSH
83774: LD_INT 4
83776: PPUSH
83777: CALL_OW 273
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_VAR 0 7
83790: PPUSH
83791: LD_INT 5
83793: PPUSH
83794: LD_INT 4
83796: PPUSH
83797: CALL_OW 272
83801: PUSH
83802: LD_VAR 0 8
83806: PPUSH
83807: LD_INT 5
83809: PPUSH
83810: LD_INT 4
83812: PPUSH
83813: CALL_OW 273
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: ST_TO_ADDR
// for i = tmp downto 1 do
83830: LD_ADDR_VAR 0 4
83834: PUSH
83835: DOUBLE
83836: LD_VAR 0 6
83840: INC
83841: ST_TO_ADDR
83842: LD_INT 1
83844: PUSH
83845: FOR_DOWNTO
83846: IFFALSE 83947
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83848: LD_VAR 0 6
83852: PUSH
83853: LD_VAR 0 4
83857: ARRAY
83858: PUSH
83859: LD_INT 1
83861: ARRAY
83862: PPUSH
83863: LD_VAR 0 6
83867: PUSH
83868: LD_VAR 0 4
83872: ARRAY
83873: PUSH
83874: LD_INT 2
83876: ARRAY
83877: PPUSH
83878: CALL_OW 488
83882: NOT
83883: PUSH
83884: LD_VAR 0 6
83888: PUSH
83889: LD_VAR 0 4
83893: ARRAY
83894: PUSH
83895: LD_INT 1
83897: ARRAY
83898: PPUSH
83899: LD_VAR 0 6
83903: PUSH
83904: LD_VAR 0 4
83908: ARRAY
83909: PUSH
83910: LD_INT 2
83912: ARRAY
83913: PPUSH
83914: CALL_OW 428
83918: PUSH
83919: LD_INT 0
83921: NONEQUAL
83922: OR
83923: IFFALSE 83945
// tmp := Delete ( tmp , i ) ;
83925: LD_ADDR_VAR 0 6
83929: PUSH
83930: LD_VAR 0 6
83934: PPUSH
83935: LD_VAR 0 4
83939: PPUSH
83940: CALL_OW 3
83944: ST_TO_ADDR
83945: GO 83845
83947: POP
83948: POP
// j := GetClosestHex ( unit , tmp ) ;
83949: LD_ADDR_VAR 0 5
83953: PUSH
83954: LD_VAR 0 1
83958: PPUSH
83959: LD_VAR 0 6
83963: PPUSH
83964: CALL 83249 0 2
83968: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83969: LD_VAR 0 1
83973: PPUSH
83974: LD_VAR 0 5
83978: PUSH
83979: LD_INT 1
83981: ARRAY
83982: PPUSH
83983: LD_VAR 0 5
83987: PUSH
83988: LD_INT 2
83990: ARRAY
83991: PPUSH
83992: CALL_OW 111
// end ;
83996: LD_VAR 0 3
84000: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84001: LD_INT 0
84003: PPUSH
84004: PPUSH
84005: PPUSH
// uc_side = 0 ;
84006: LD_ADDR_OWVAR 20
84010: PUSH
84011: LD_INT 0
84013: ST_TO_ADDR
// uc_nation = 0 ;
84014: LD_ADDR_OWVAR 21
84018: PUSH
84019: LD_INT 0
84021: ST_TO_ADDR
// InitHc_All ( ) ;
84022: CALL_OW 584
// InitVc ;
84026: CALL_OW 20
// if mastodonts then
84030: LD_VAR 0 6
84034: IFFALSE 84101
// for i = 1 to mastodonts do
84036: LD_ADDR_VAR 0 11
84040: PUSH
84041: DOUBLE
84042: LD_INT 1
84044: DEC
84045: ST_TO_ADDR
84046: LD_VAR 0 6
84050: PUSH
84051: FOR_TO
84052: IFFALSE 84099
// begin vc_chassis := 31 ;
84054: LD_ADDR_OWVAR 37
84058: PUSH
84059: LD_INT 31
84061: ST_TO_ADDR
// vc_control := control_rider ;
84062: LD_ADDR_OWVAR 38
84066: PUSH
84067: LD_INT 4
84069: ST_TO_ADDR
// animal := CreateVehicle ;
84070: LD_ADDR_VAR 0 12
84074: PUSH
84075: CALL_OW 45
84079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84080: LD_VAR 0 12
84084: PPUSH
84085: LD_VAR 0 8
84089: PPUSH
84090: LD_INT 0
84092: PPUSH
84093: CALL 86289 0 3
// end ;
84097: GO 84051
84099: POP
84100: POP
// if horses then
84101: LD_VAR 0 5
84105: IFFALSE 84172
// for i = 1 to horses do
84107: LD_ADDR_VAR 0 11
84111: PUSH
84112: DOUBLE
84113: LD_INT 1
84115: DEC
84116: ST_TO_ADDR
84117: LD_VAR 0 5
84121: PUSH
84122: FOR_TO
84123: IFFALSE 84170
// begin hc_class := 21 ;
84125: LD_ADDR_OWVAR 28
84129: PUSH
84130: LD_INT 21
84132: ST_TO_ADDR
// hc_gallery :=  ;
84133: LD_ADDR_OWVAR 33
84137: PUSH
84138: LD_STRING 
84140: ST_TO_ADDR
// animal := CreateHuman ;
84141: LD_ADDR_VAR 0 12
84145: PUSH
84146: CALL_OW 44
84150: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84151: LD_VAR 0 12
84155: PPUSH
84156: LD_VAR 0 8
84160: PPUSH
84161: LD_INT 0
84163: PPUSH
84164: CALL 86289 0 3
// end ;
84168: GO 84122
84170: POP
84171: POP
// if birds then
84172: LD_VAR 0 1
84176: IFFALSE 84243
// for i = 1 to birds do
84178: LD_ADDR_VAR 0 11
84182: PUSH
84183: DOUBLE
84184: LD_INT 1
84186: DEC
84187: ST_TO_ADDR
84188: LD_VAR 0 1
84192: PUSH
84193: FOR_TO
84194: IFFALSE 84241
// begin hc_class = 18 ;
84196: LD_ADDR_OWVAR 28
84200: PUSH
84201: LD_INT 18
84203: ST_TO_ADDR
// hc_gallery =  ;
84204: LD_ADDR_OWVAR 33
84208: PUSH
84209: LD_STRING 
84211: ST_TO_ADDR
// animal := CreateHuman ;
84212: LD_ADDR_VAR 0 12
84216: PUSH
84217: CALL_OW 44
84221: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84222: LD_VAR 0 12
84226: PPUSH
84227: LD_VAR 0 8
84231: PPUSH
84232: LD_INT 0
84234: PPUSH
84235: CALL 86289 0 3
// end ;
84239: GO 84193
84241: POP
84242: POP
// if tigers then
84243: LD_VAR 0 2
84247: IFFALSE 84331
// for i = 1 to tigers do
84249: LD_ADDR_VAR 0 11
84253: PUSH
84254: DOUBLE
84255: LD_INT 1
84257: DEC
84258: ST_TO_ADDR
84259: LD_VAR 0 2
84263: PUSH
84264: FOR_TO
84265: IFFALSE 84329
// begin hc_class = class_tiger ;
84267: LD_ADDR_OWVAR 28
84271: PUSH
84272: LD_INT 14
84274: ST_TO_ADDR
// hc_gallery =  ;
84275: LD_ADDR_OWVAR 33
84279: PUSH
84280: LD_STRING 
84282: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84283: LD_ADDR_OWVAR 35
84287: PUSH
84288: LD_INT 7
84290: NEG
84291: PPUSH
84292: LD_INT 7
84294: PPUSH
84295: CALL_OW 12
84299: ST_TO_ADDR
// animal := CreateHuman ;
84300: LD_ADDR_VAR 0 12
84304: PUSH
84305: CALL_OW 44
84309: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84310: LD_VAR 0 12
84314: PPUSH
84315: LD_VAR 0 8
84319: PPUSH
84320: LD_INT 0
84322: PPUSH
84323: CALL 86289 0 3
// end ;
84327: GO 84264
84329: POP
84330: POP
// if apemans then
84331: LD_VAR 0 3
84335: IFFALSE 84458
// for i = 1 to apemans do
84337: LD_ADDR_VAR 0 11
84341: PUSH
84342: DOUBLE
84343: LD_INT 1
84345: DEC
84346: ST_TO_ADDR
84347: LD_VAR 0 3
84351: PUSH
84352: FOR_TO
84353: IFFALSE 84456
// begin hc_class = class_apeman ;
84355: LD_ADDR_OWVAR 28
84359: PUSH
84360: LD_INT 12
84362: ST_TO_ADDR
// hc_gallery =  ;
84363: LD_ADDR_OWVAR 33
84367: PUSH
84368: LD_STRING 
84370: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84371: LD_ADDR_OWVAR 35
84375: PUSH
84376: LD_INT 5
84378: NEG
84379: PPUSH
84380: LD_INT 5
84382: PPUSH
84383: CALL_OW 12
84387: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84388: LD_ADDR_OWVAR 31
84392: PUSH
84393: LD_INT 1
84395: PPUSH
84396: LD_INT 3
84398: PPUSH
84399: CALL_OW 12
84403: PUSH
84404: LD_INT 1
84406: PPUSH
84407: LD_INT 3
84409: PPUSH
84410: CALL_OW 12
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: LD_INT 0
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: ST_TO_ADDR
// animal := CreateHuman ;
84427: LD_ADDR_VAR 0 12
84431: PUSH
84432: CALL_OW 44
84436: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84437: LD_VAR 0 12
84441: PPUSH
84442: LD_VAR 0 8
84446: PPUSH
84447: LD_INT 0
84449: PPUSH
84450: CALL 86289 0 3
// end ;
84454: GO 84352
84456: POP
84457: POP
// if enchidnas then
84458: LD_VAR 0 4
84462: IFFALSE 84529
// for i = 1 to enchidnas do
84464: LD_ADDR_VAR 0 11
84468: PUSH
84469: DOUBLE
84470: LD_INT 1
84472: DEC
84473: ST_TO_ADDR
84474: LD_VAR 0 4
84478: PUSH
84479: FOR_TO
84480: IFFALSE 84527
// begin hc_class = 13 ;
84482: LD_ADDR_OWVAR 28
84486: PUSH
84487: LD_INT 13
84489: ST_TO_ADDR
// hc_gallery =  ;
84490: LD_ADDR_OWVAR 33
84494: PUSH
84495: LD_STRING 
84497: ST_TO_ADDR
// animal := CreateHuman ;
84498: LD_ADDR_VAR 0 12
84502: PUSH
84503: CALL_OW 44
84507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84508: LD_VAR 0 12
84512: PPUSH
84513: LD_VAR 0 8
84517: PPUSH
84518: LD_INT 0
84520: PPUSH
84521: CALL 86289 0 3
// end ;
84525: GO 84479
84527: POP
84528: POP
// if fishes then
84529: LD_VAR 0 7
84533: IFFALSE 84600
// for i = 1 to fishes do
84535: LD_ADDR_VAR 0 11
84539: PUSH
84540: DOUBLE
84541: LD_INT 1
84543: DEC
84544: ST_TO_ADDR
84545: LD_VAR 0 7
84549: PUSH
84550: FOR_TO
84551: IFFALSE 84598
// begin hc_class = 20 ;
84553: LD_ADDR_OWVAR 28
84557: PUSH
84558: LD_INT 20
84560: ST_TO_ADDR
// hc_gallery =  ;
84561: LD_ADDR_OWVAR 33
84565: PUSH
84566: LD_STRING 
84568: ST_TO_ADDR
// animal := CreateHuman ;
84569: LD_ADDR_VAR 0 12
84573: PUSH
84574: CALL_OW 44
84578: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84579: LD_VAR 0 12
84583: PPUSH
84584: LD_VAR 0 9
84588: PPUSH
84589: LD_INT 0
84591: PPUSH
84592: CALL 86289 0 3
// end ;
84596: GO 84550
84598: POP
84599: POP
// end ;
84600: LD_VAR 0 10
84604: RET
// export function WantHeal ( sci , unit ) ; begin
84605: LD_INT 0
84607: PPUSH
// if GetTaskList ( sci ) > 0 then
84608: LD_VAR 0 1
84612: PPUSH
84613: CALL_OW 437
84617: PUSH
84618: LD_INT 0
84620: GREATER
84621: IFFALSE 84691
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84623: LD_VAR 0 1
84627: PPUSH
84628: CALL_OW 437
84632: PUSH
84633: LD_INT 1
84635: ARRAY
84636: PUSH
84637: LD_INT 1
84639: ARRAY
84640: PUSH
84641: LD_STRING l
84643: EQUAL
84644: PUSH
84645: LD_VAR 0 1
84649: PPUSH
84650: CALL_OW 437
84654: PUSH
84655: LD_INT 1
84657: ARRAY
84658: PUSH
84659: LD_INT 4
84661: ARRAY
84662: PUSH
84663: LD_VAR 0 2
84667: EQUAL
84668: AND
84669: IFFALSE 84681
// result := true else
84671: LD_ADDR_VAR 0 3
84675: PUSH
84676: LD_INT 1
84678: ST_TO_ADDR
84679: GO 84689
// result := false ;
84681: LD_ADDR_VAR 0 3
84685: PUSH
84686: LD_INT 0
84688: ST_TO_ADDR
// end else
84689: GO 84699
// result := false ;
84691: LD_ADDR_VAR 0 3
84695: PUSH
84696: LD_INT 0
84698: ST_TO_ADDR
// end ;
84699: LD_VAR 0 3
84703: RET
// export function HealTarget ( sci ) ; begin
84704: LD_INT 0
84706: PPUSH
// if not sci then
84707: LD_VAR 0 1
84711: NOT
84712: IFFALSE 84716
// exit ;
84714: GO 84781
// result := 0 ;
84716: LD_ADDR_VAR 0 2
84720: PUSH
84721: LD_INT 0
84723: ST_TO_ADDR
// if GetTaskList ( sci ) then
84724: LD_VAR 0 1
84728: PPUSH
84729: CALL_OW 437
84733: IFFALSE 84781
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84735: LD_VAR 0 1
84739: PPUSH
84740: CALL_OW 437
84744: PUSH
84745: LD_INT 1
84747: ARRAY
84748: PUSH
84749: LD_INT 1
84751: ARRAY
84752: PUSH
84753: LD_STRING l
84755: EQUAL
84756: IFFALSE 84781
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84758: LD_ADDR_VAR 0 2
84762: PUSH
84763: LD_VAR 0 1
84767: PPUSH
84768: CALL_OW 437
84772: PUSH
84773: LD_INT 1
84775: ARRAY
84776: PUSH
84777: LD_INT 4
84779: ARRAY
84780: ST_TO_ADDR
// end ;
84781: LD_VAR 0 2
84785: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84786: LD_INT 0
84788: PPUSH
84789: PPUSH
84790: PPUSH
84791: PPUSH
// if not base_units then
84792: LD_VAR 0 1
84796: NOT
84797: IFFALSE 84801
// exit ;
84799: GO 84888
// result := false ;
84801: LD_ADDR_VAR 0 2
84805: PUSH
84806: LD_INT 0
84808: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84809: LD_ADDR_VAR 0 5
84813: PUSH
84814: LD_VAR 0 1
84818: PPUSH
84819: LD_INT 21
84821: PUSH
84822: LD_INT 3
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PPUSH
84829: CALL_OW 72
84833: ST_TO_ADDR
// if not tmp then
84834: LD_VAR 0 5
84838: NOT
84839: IFFALSE 84843
// exit ;
84841: GO 84888
// for i in tmp do
84843: LD_ADDR_VAR 0 3
84847: PUSH
84848: LD_VAR 0 5
84852: PUSH
84853: FOR_IN
84854: IFFALSE 84886
// begin result := EnemyInRange ( i , 22 ) ;
84856: LD_ADDR_VAR 0 2
84860: PUSH
84861: LD_VAR 0 3
84865: PPUSH
84866: LD_INT 22
84868: PPUSH
84869: CALL 83124 0 2
84873: ST_TO_ADDR
// if result then
84874: LD_VAR 0 2
84878: IFFALSE 84884
// exit ;
84880: POP
84881: POP
84882: GO 84888
// end ;
84884: GO 84853
84886: POP
84887: POP
// end ;
84888: LD_VAR 0 2
84892: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84893: LD_INT 0
84895: PPUSH
84896: PPUSH
// if not units then
84897: LD_VAR 0 1
84901: NOT
84902: IFFALSE 84906
// exit ;
84904: GO 84976
// result := [ ] ;
84906: LD_ADDR_VAR 0 3
84910: PUSH
84911: EMPTY
84912: ST_TO_ADDR
// for i in units do
84913: LD_ADDR_VAR 0 4
84917: PUSH
84918: LD_VAR 0 1
84922: PUSH
84923: FOR_IN
84924: IFFALSE 84974
// if GetTag ( i ) = tag then
84926: LD_VAR 0 4
84930: PPUSH
84931: CALL_OW 110
84935: PUSH
84936: LD_VAR 0 2
84940: EQUAL
84941: IFFALSE 84972
// result := Insert ( result , result + 1 , i ) ;
84943: LD_ADDR_VAR 0 3
84947: PUSH
84948: LD_VAR 0 3
84952: PPUSH
84953: LD_VAR 0 3
84957: PUSH
84958: LD_INT 1
84960: PLUS
84961: PPUSH
84962: LD_VAR 0 4
84966: PPUSH
84967: CALL_OW 2
84971: ST_TO_ADDR
84972: GO 84923
84974: POP
84975: POP
// end ;
84976: LD_VAR 0 3
84980: RET
// export function IsDriver ( un ) ; begin
84981: LD_INT 0
84983: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84984: LD_ADDR_VAR 0 2
84988: PUSH
84989: LD_VAR 0 1
84993: PUSH
84994: LD_INT 55
84996: PUSH
84997: EMPTY
84998: LIST
84999: PPUSH
85000: CALL_OW 69
85004: IN
85005: ST_TO_ADDR
// end ;
85006: LD_VAR 0 2
85010: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85011: LD_INT 0
85013: PPUSH
85014: PPUSH
// list := [ ] ;
85015: LD_ADDR_VAR 0 5
85019: PUSH
85020: EMPTY
85021: ST_TO_ADDR
// case d of 0 :
85022: LD_VAR 0 3
85026: PUSH
85027: LD_INT 0
85029: DOUBLE
85030: EQUAL
85031: IFTRUE 85035
85033: GO 85168
85035: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85036: LD_ADDR_VAR 0 5
85040: PUSH
85041: LD_VAR 0 1
85045: PUSH
85046: LD_INT 4
85048: MINUS
85049: PUSH
85050: LD_VAR 0 2
85054: PUSH
85055: LD_INT 4
85057: MINUS
85058: PUSH
85059: LD_INT 2
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: PUSH
85067: LD_VAR 0 1
85071: PUSH
85072: LD_INT 3
85074: MINUS
85075: PUSH
85076: LD_VAR 0 2
85080: PUSH
85081: LD_INT 1
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: LIST
85088: PUSH
85089: LD_VAR 0 1
85093: PUSH
85094: LD_INT 4
85096: PLUS
85097: PUSH
85098: LD_VAR 0 2
85102: PUSH
85103: LD_INT 4
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: LIST
85110: PUSH
85111: LD_VAR 0 1
85115: PUSH
85116: LD_INT 3
85118: PLUS
85119: PUSH
85120: LD_VAR 0 2
85124: PUSH
85125: LD_INT 3
85127: PLUS
85128: PUSH
85129: LD_INT 5
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: LIST
85136: PUSH
85137: LD_VAR 0 1
85141: PUSH
85142: LD_VAR 0 2
85146: PUSH
85147: LD_INT 4
85149: PLUS
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: LIST
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: ST_TO_ADDR
// end ; 1 :
85166: GO 85866
85168: LD_INT 1
85170: DOUBLE
85171: EQUAL
85172: IFTRUE 85176
85174: GO 85309
85176: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85177: LD_ADDR_VAR 0 5
85181: PUSH
85182: LD_VAR 0 1
85186: PUSH
85187: LD_VAR 0 2
85191: PUSH
85192: LD_INT 4
85194: MINUS
85195: PUSH
85196: LD_INT 3
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: LIST
85203: PUSH
85204: LD_VAR 0 1
85208: PUSH
85209: LD_INT 3
85211: MINUS
85212: PUSH
85213: LD_VAR 0 2
85217: PUSH
85218: LD_INT 3
85220: MINUS
85221: PUSH
85222: LD_INT 2
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: LIST
85229: PUSH
85230: LD_VAR 0 1
85234: PUSH
85235: LD_INT 4
85237: MINUS
85238: PUSH
85239: LD_VAR 0 2
85243: PUSH
85244: LD_INT 1
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: LIST
85251: PUSH
85252: LD_VAR 0 1
85256: PUSH
85257: LD_VAR 0 2
85261: PUSH
85262: LD_INT 3
85264: PLUS
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: LIST
85273: PUSH
85274: LD_VAR 0 1
85278: PUSH
85279: LD_INT 4
85281: PLUS
85282: PUSH
85283: LD_VAR 0 2
85287: PUSH
85288: LD_INT 4
85290: PLUS
85291: PUSH
85292: LD_INT 5
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: LIST
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: ST_TO_ADDR
// end ; 2 :
85307: GO 85866
85309: LD_INT 2
85311: DOUBLE
85312: EQUAL
85313: IFTRUE 85317
85315: GO 85446
85317: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85318: LD_ADDR_VAR 0 5
85322: PUSH
85323: LD_VAR 0 1
85327: PUSH
85328: LD_VAR 0 2
85332: PUSH
85333: LD_INT 3
85335: MINUS
85336: PUSH
85337: LD_INT 3
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: LIST
85344: PUSH
85345: LD_VAR 0 1
85349: PUSH
85350: LD_INT 4
85352: PLUS
85353: PUSH
85354: LD_VAR 0 2
85358: PUSH
85359: LD_INT 4
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: LIST
85366: PUSH
85367: LD_VAR 0 1
85371: PUSH
85372: LD_VAR 0 2
85376: PUSH
85377: LD_INT 4
85379: PLUS
85380: PUSH
85381: LD_INT 0
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: LIST
85388: PUSH
85389: LD_VAR 0 1
85393: PUSH
85394: LD_INT 3
85396: MINUS
85397: PUSH
85398: LD_VAR 0 2
85402: PUSH
85403: LD_INT 1
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: LIST
85410: PUSH
85411: LD_VAR 0 1
85415: PUSH
85416: LD_INT 4
85418: MINUS
85419: PUSH
85420: LD_VAR 0 2
85424: PUSH
85425: LD_INT 4
85427: MINUS
85428: PUSH
85429: LD_INT 2
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: LIST
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: LIST
85441: LIST
85442: LIST
85443: ST_TO_ADDR
// end ; 3 :
85444: GO 85866
85446: LD_INT 3
85448: DOUBLE
85449: EQUAL
85450: IFTRUE 85454
85452: GO 85587
85454: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
85455: LD_ADDR_VAR 0 5
85459: PUSH
85460: LD_VAR 0 1
85464: PUSH
85465: LD_INT 3
85467: PLUS
85468: PUSH
85469: LD_VAR 0 2
85473: PUSH
85474: LD_INT 4
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: LIST
85481: PUSH
85482: LD_VAR 0 1
85486: PUSH
85487: LD_INT 4
85489: PLUS
85490: PUSH
85491: LD_VAR 0 2
85495: PUSH
85496: LD_INT 4
85498: PLUS
85499: PUSH
85500: LD_INT 5
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: LIST
85507: PUSH
85508: LD_VAR 0 1
85512: PUSH
85513: LD_INT 4
85515: MINUS
85516: PUSH
85517: LD_VAR 0 2
85521: PUSH
85522: LD_INT 1
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: LIST
85529: PUSH
85530: LD_VAR 0 1
85534: PUSH
85535: LD_VAR 0 2
85539: PUSH
85540: LD_INT 4
85542: MINUS
85543: PUSH
85544: LD_INT 3
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: LIST
85551: PUSH
85552: LD_VAR 0 1
85556: PUSH
85557: LD_INT 3
85559: MINUS
85560: PUSH
85561: LD_VAR 0 2
85565: PUSH
85566: LD_INT 3
85568: MINUS
85569: PUSH
85570: LD_INT 2
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: LIST
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: ST_TO_ADDR
// end ; 4 :
85585: GO 85866
85587: LD_INT 4
85589: DOUBLE
85590: EQUAL
85591: IFTRUE 85595
85593: GO 85728
85595: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85596: LD_ADDR_VAR 0 5
85600: PUSH
85601: LD_VAR 0 1
85605: PUSH
85606: LD_VAR 0 2
85610: PUSH
85611: LD_INT 4
85613: PLUS
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: LIST
85622: PUSH
85623: LD_VAR 0 1
85627: PUSH
85628: LD_INT 3
85630: PLUS
85631: PUSH
85632: LD_VAR 0 2
85636: PUSH
85637: LD_INT 3
85639: PLUS
85640: PUSH
85641: LD_INT 5
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: LIST
85648: PUSH
85649: LD_VAR 0 1
85653: PUSH
85654: LD_INT 4
85656: PLUS
85657: PUSH
85658: LD_VAR 0 2
85662: PUSH
85663: LD_INT 4
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: LIST
85670: PUSH
85671: LD_VAR 0 1
85675: PUSH
85676: LD_VAR 0 2
85680: PUSH
85681: LD_INT 3
85683: MINUS
85684: PUSH
85685: LD_INT 3
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: LIST
85692: PUSH
85693: LD_VAR 0 1
85697: PUSH
85698: LD_INT 4
85700: MINUS
85701: PUSH
85702: LD_VAR 0 2
85706: PUSH
85707: LD_INT 4
85709: MINUS
85710: PUSH
85711: LD_INT 2
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: LIST
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: ST_TO_ADDR
// end ; 5 :
85726: GO 85866
85728: LD_INT 5
85730: DOUBLE
85731: EQUAL
85732: IFTRUE 85736
85734: GO 85865
85736: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85737: LD_ADDR_VAR 0 5
85741: PUSH
85742: LD_VAR 0 1
85746: PUSH
85747: LD_INT 4
85749: MINUS
85750: PUSH
85751: LD_VAR 0 2
85755: PUSH
85756: LD_INT 1
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: LIST
85763: PUSH
85764: LD_VAR 0 1
85768: PUSH
85769: LD_VAR 0 2
85773: PUSH
85774: LD_INT 4
85776: MINUS
85777: PUSH
85778: LD_INT 3
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: LIST
85785: PUSH
85786: LD_VAR 0 1
85790: PUSH
85791: LD_INT 4
85793: PLUS
85794: PUSH
85795: LD_VAR 0 2
85799: PUSH
85800: LD_INT 4
85802: PLUS
85803: PUSH
85804: LD_INT 5
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: LIST
85811: PUSH
85812: LD_VAR 0 1
85816: PUSH
85817: LD_INT 3
85819: PLUS
85820: PUSH
85821: LD_VAR 0 2
85825: PUSH
85826: LD_INT 4
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: LIST
85833: PUSH
85834: LD_VAR 0 1
85838: PUSH
85839: LD_VAR 0 2
85843: PUSH
85844: LD_INT 3
85846: PLUS
85847: PUSH
85848: LD_INT 0
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: LIST
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: ST_TO_ADDR
// end ; end ;
85863: GO 85866
85865: POP
// result := list ;
85866: LD_ADDR_VAR 0 4
85870: PUSH
85871: LD_VAR 0 5
85875: ST_TO_ADDR
// end ;
85876: LD_VAR 0 4
85880: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85881: LD_INT 0
85883: PPUSH
85884: PPUSH
85885: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85886: LD_VAR 0 1
85890: NOT
85891: PUSH
85892: LD_VAR 0 2
85896: PUSH
85897: LD_INT 1
85899: PUSH
85900: LD_INT 2
85902: PUSH
85903: LD_INT 3
85905: PUSH
85906: LD_INT 4
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: IN
85915: NOT
85916: OR
85917: IFFALSE 85921
// exit ;
85919: GO 86013
// tmp := [ ] ;
85921: LD_ADDR_VAR 0 5
85925: PUSH
85926: EMPTY
85927: ST_TO_ADDR
// for i in units do
85928: LD_ADDR_VAR 0 4
85932: PUSH
85933: LD_VAR 0 1
85937: PUSH
85938: FOR_IN
85939: IFFALSE 85982
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85941: LD_ADDR_VAR 0 5
85945: PUSH
85946: LD_VAR 0 5
85950: PPUSH
85951: LD_VAR 0 5
85955: PUSH
85956: LD_INT 1
85958: PLUS
85959: PPUSH
85960: LD_VAR 0 4
85964: PPUSH
85965: LD_VAR 0 2
85969: PPUSH
85970: CALL_OW 259
85974: PPUSH
85975: CALL_OW 2
85979: ST_TO_ADDR
85980: GO 85938
85982: POP
85983: POP
// if not tmp then
85984: LD_VAR 0 5
85988: NOT
85989: IFFALSE 85993
// exit ;
85991: GO 86013
// result := SortListByListDesc ( units , tmp ) ;
85993: LD_ADDR_VAR 0 3
85997: PUSH
85998: LD_VAR 0 1
86002: PPUSH
86003: LD_VAR 0 5
86007: PPUSH
86008: CALL_OW 77
86012: ST_TO_ADDR
// end ;
86013: LD_VAR 0 3
86017: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86018: LD_INT 0
86020: PPUSH
86021: PPUSH
86022: PPUSH
// result := false ;
86023: LD_ADDR_VAR 0 3
86027: PUSH
86028: LD_INT 0
86030: ST_TO_ADDR
// x := GetX ( building ) ;
86031: LD_ADDR_VAR 0 4
86035: PUSH
86036: LD_VAR 0 2
86040: PPUSH
86041: CALL_OW 250
86045: ST_TO_ADDR
// y := GetY ( building ) ;
86046: LD_ADDR_VAR 0 5
86050: PUSH
86051: LD_VAR 0 2
86055: PPUSH
86056: CALL_OW 251
86060: ST_TO_ADDR
// if not building or not x or not y then
86061: LD_VAR 0 2
86065: NOT
86066: PUSH
86067: LD_VAR 0 4
86071: NOT
86072: OR
86073: PUSH
86074: LD_VAR 0 5
86078: NOT
86079: OR
86080: IFFALSE 86084
// exit ;
86082: GO 86176
// if GetTaskList ( unit ) then
86084: LD_VAR 0 1
86088: PPUSH
86089: CALL_OW 437
86093: IFFALSE 86176
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86095: LD_STRING e
86097: PUSH
86098: LD_VAR 0 1
86102: PPUSH
86103: CALL_OW 437
86107: PUSH
86108: LD_INT 1
86110: ARRAY
86111: PUSH
86112: LD_INT 1
86114: ARRAY
86115: EQUAL
86116: PUSH
86117: LD_VAR 0 4
86121: PUSH
86122: LD_VAR 0 1
86126: PPUSH
86127: CALL_OW 437
86131: PUSH
86132: LD_INT 1
86134: ARRAY
86135: PUSH
86136: LD_INT 2
86138: ARRAY
86139: EQUAL
86140: AND
86141: PUSH
86142: LD_VAR 0 5
86146: PUSH
86147: LD_VAR 0 1
86151: PPUSH
86152: CALL_OW 437
86156: PUSH
86157: LD_INT 1
86159: ARRAY
86160: PUSH
86161: LD_INT 3
86163: ARRAY
86164: EQUAL
86165: AND
86166: IFFALSE 86176
// result := true end ;
86168: LD_ADDR_VAR 0 3
86172: PUSH
86173: LD_INT 1
86175: ST_TO_ADDR
// end ;
86176: LD_VAR 0 3
86180: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86181: LD_INT 0
86183: PPUSH
// result := false ;
86184: LD_ADDR_VAR 0 4
86188: PUSH
86189: LD_INT 0
86191: ST_TO_ADDR
// if GetTaskList ( unit ) then
86192: LD_VAR 0 1
86196: PPUSH
86197: CALL_OW 437
86201: IFFALSE 86284
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86203: LD_STRING M
86205: PUSH
86206: LD_VAR 0 1
86210: PPUSH
86211: CALL_OW 437
86215: PUSH
86216: LD_INT 1
86218: ARRAY
86219: PUSH
86220: LD_INT 1
86222: ARRAY
86223: EQUAL
86224: PUSH
86225: LD_VAR 0 2
86229: PUSH
86230: LD_VAR 0 1
86234: PPUSH
86235: CALL_OW 437
86239: PUSH
86240: LD_INT 1
86242: ARRAY
86243: PUSH
86244: LD_INT 2
86246: ARRAY
86247: EQUAL
86248: AND
86249: PUSH
86250: LD_VAR 0 3
86254: PUSH
86255: LD_VAR 0 1
86259: PPUSH
86260: CALL_OW 437
86264: PUSH
86265: LD_INT 1
86267: ARRAY
86268: PUSH
86269: LD_INT 3
86271: ARRAY
86272: EQUAL
86273: AND
86274: IFFALSE 86284
// result := true ;
86276: LD_ADDR_VAR 0 4
86280: PUSH
86281: LD_INT 1
86283: ST_TO_ADDR
// end ; end ;
86284: LD_VAR 0 4
86288: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86289: LD_INT 0
86291: PPUSH
86292: PPUSH
86293: PPUSH
86294: PPUSH
// if not unit or not area then
86295: LD_VAR 0 1
86299: NOT
86300: PUSH
86301: LD_VAR 0 2
86305: NOT
86306: OR
86307: IFFALSE 86311
// exit ;
86309: GO 86475
// tmp := AreaToList ( area , i ) ;
86311: LD_ADDR_VAR 0 6
86315: PUSH
86316: LD_VAR 0 2
86320: PPUSH
86321: LD_VAR 0 5
86325: PPUSH
86326: CALL_OW 517
86330: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86331: LD_ADDR_VAR 0 5
86335: PUSH
86336: DOUBLE
86337: LD_INT 1
86339: DEC
86340: ST_TO_ADDR
86341: LD_VAR 0 6
86345: PUSH
86346: LD_INT 1
86348: ARRAY
86349: PUSH
86350: FOR_TO
86351: IFFALSE 86473
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86353: LD_ADDR_VAR 0 7
86357: PUSH
86358: LD_VAR 0 6
86362: PUSH
86363: LD_INT 1
86365: ARRAY
86366: PUSH
86367: LD_VAR 0 5
86371: ARRAY
86372: PUSH
86373: LD_VAR 0 6
86377: PUSH
86378: LD_INT 2
86380: ARRAY
86381: PUSH
86382: LD_VAR 0 5
86386: ARRAY
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
86392: LD_VAR 0 7
86396: PUSH
86397: LD_INT 1
86399: ARRAY
86400: PPUSH
86401: LD_VAR 0 7
86405: PUSH
86406: LD_INT 2
86408: ARRAY
86409: PPUSH
86410: CALL_OW 428
86414: PUSH
86415: LD_INT 0
86417: EQUAL
86418: IFFALSE 86471
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86420: LD_VAR 0 1
86424: PPUSH
86425: LD_VAR 0 7
86429: PUSH
86430: LD_INT 1
86432: ARRAY
86433: PPUSH
86434: LD_VAR 0 7
86438: PUSH
86439: LD_INT 2
86441: ARRAY
86442: PPUSH
86443: LD_VAR 0 3
86447: PPUSH
86448: CALL_OW 48
// result := IsPlaced ( unit ) ;
86452: LD_ADDR_VAR 0 4
86456: PUSH
86457: LD_VAR 0 1
86461: PPUSH
86462: CALL_OW 305
86466: ST_TO_ADDR
// exit ;
86467: POP
86468: POP
86469: GO 86475
// end ; end ;
86471: GO 86350
86473: POP
86474: POP
// end ;
86475: LD_VAR 0 4
86479: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
86480: LD_INT 0
86482: PPUSH
86483: PPUSH
86484: PPUSH
// if not side or side > 8 then
86485: LD_VAR 0 1
86489: NOT
86490: PUSH
86491: LD_VAR 0 1
86495: PUSH
86496: LD_INT 8
86498: GREATER
86499: OR
86500: IFFALSE 86504
// exit ;
86502: GO 86691
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86504: LD_ADDR_VAR 0 4
86508: PUSH
86509: LD_INT 22
86511: PUSH
86512: LD_VAR 0 1
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 21
86523: PUSH
86524: LD_INT 3
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: EMPTY
86532: LIST
86533: LIST
86534: PPUSH
86535: CALL_OW 69
86539: ST_TO_ADDR
// if not tmp then
86540: LD_VAR 0 4
86544: NOT
86545: IFFALSE 86549
// exit ;
86547: GO 86691
// enable_addtolog := true ;
86549: LD_ADDR_OWVAR 81
86553: PUSH
86554: LD_INT 1
86556: ST_TO_ADDR
// AddToLog ( [ ) ;
86557: LD_STRING [
86559: PPUSH
86560: CALL_OW 561
// for i in tmp do
86564: LD_ADDR_VAR 0 3
86568: PUSH
86569: LD_VAR 0 4
86573: PUSH
86574: FOR_IN
86575: IFFALSE 86682
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86577: LD_STRING [
86579: PUSH
86580: LD_VAR 0 3
86584: PPUSH
86585: CALL_OW 266
86589: STR
86590: PUSH
86591: LD_STRING , 
86593: STR
86594: PUSH
86595: LD_VAR 0 3
86599: PPUSH
86600: CALL_OW 250
86604: STR
86605: PUSH
86606: LD_STRING , 
86608: STR
86609: PUSH
86610: LD_VAR 0 3
86614: PPUSH
86615: CALL_OW 251
86619: STR
86620: PUSH
86621: LD_STRING , 
86623: STR
86624: PUSH
86625: LD_VAR 0 3
86629: PPUSH
86630: CALL_OW 254
86634: STR
86635: PUSH
86636: LD_STRING , 
86638: STR
86639: PUSH
86640: LD_VAR 0 3
86644: PPUSH
86645: LD_INT 1
86647: PPUSH
86648: CALL_OW 268
86652: STR
86653: PUSH
86654: LD_STRING , 
86656: STR
86657: PUSH
86658: LD_VAR 0 3
86662: PPUSH
86663: LD_INT 2
86665: PPUSH
86666: CALL_OW 268
86670: STR
86671: PUSH
86672: LD_STRING ],
86674: STR
86675: PPUSH
86676: CALL_OW 561
// end ;
86680: GO 86574
86682: POP
86683: POP
// AddToLog ( ]; ) ;
86684: LD_STRING ];
86686: PPUSH
86687: CALL_OW 561
// end ;
86691: LD_VAR 0 2
86695: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86696: LD_INT 0
86698: PPUSH
86699: PPUSH
86700: PPUSH
86701: PPUSH
86702: PPUSH
// if not area or not rate or not max then
86703: LD_VAR 0 1
86707: NOT
86708: PUSH
86709: LD_VAR 0 2
86713: NOT
86714: OR
86715: PUSH
86716: LD_VAR 0 4
86720: NOT
86721: OR
86722: IFFALSE 86726
// exit ;
86724: GO 86918
// while 1 do
86726: LD_INT 1
86728: IFFALSE 86918
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86730: LD_ADDR_VAR 0 9
86734: PUSH
86735: LD_VAR 0 1
86739: PPUSH
86740: LD_INT 1
86742: PPUSH
86743: CALL_OW 287
86747: PUSH
86748: LD_INT 10
86750: MUL
86751: ST_TO_ADDR
// r := rate / 10 ;
86752: LD_ADDR_VAR 0 7
86756: PUSH
86757: LD_VAR 0 2
86761: PUSH
86762: LD_INT 10
86764: DIVREAL
86765: ST_TO_ADDR
// time := 1 1$00 ;
86766: LD_ADDR_VAR 0 8
86770: PUSH
86771: LD_INT 2100
86773: ST_TO_ADDR
// if amount < min then
86774: LD_VAR 0 9
86778: PUSH
86779: LD_VAR 0 3
86783: LESS
86784: IFFALSE 86802
// r := r * 2 else
86786: LD_ADDR_VAR 0 7
86790: PUSH
86791: LD_VAR 0 7
86795: PUSH
86796: LD_INT 2
86798: MUL
86799: ST_TO_ADDR
86800: GO 86828
// if amount > max then
86802: LD_VAR 0 9
86806: PUSH
86807: LD_VAR 0 4
86811: GREATER
86812: IFFALSE 86828
// r := r / 2 ;
86814: LD_ADDR_VAR 0 7
86818: PUSH
86819: LD_VAR 0 7
86823: PUSH
86824: LD_INT 2
86826: DIVREAL
86827: ST_TO_ADDR
// time := time / r ;
86828: LD_ADDR_VAR 0 8
86832: PUSH
86833: LD_VAR 0 8
86837: PUSH
86838: LD_VAR 0 7
86842: DIVREAL
86843: ST_TO_ADDR
// if time < 0 then
86844: LD_VAR 0 8
86848: PUSH
86849: LD_INT 0
86851: LESS
86852: IFFALSE 86869
// time := time * - 1 ;
86854: LD_ADDR_VAR 0 8
86858: PUSH
86859: LD_VAR 0 8
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: MUL
86868: ST_TO_ADDR
// wait ( time ) ;
86869: LD_VAR 0 8
86873: PPUSH
86874: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86878: LD_INT 35
86880: PPUSH
86881: LD_INT 875
86883: PPUSH
86884: CALL_OW 12
86888: PPUSH
86889: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86893: LD_INT 1
86895: PPUSH
86896: LD_INT 5
86898: PPUSH
86899: CALL_OW 12
86903: PPUSH
86904: LD_VAR 0 1
86908: PPUSH
86909: LD_INT 1
86911: PPUSH
86912: CALL_OW 55
// end ;
86916: GO 86726
// end ;
86918: LD_VAR 0 5
86922: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86923: LD_INT 0
86925: PPUSH
86926: PPUSH
86927: PPUSH
86928: PPUSH
86929: PPUSH
86930: PPUSH
86931: PPUSH
86932: PPUSH
// if not turrets or not factories then
86933: LD_VAR 0 1
86937: NOT
86938: PUSH
86939: LD_VAR 0 2
86943: NOT
86944: OR
86945: IFFALSE 86949
// exit ;
86947: GO 87256
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86949: LD_ADDR_VAR 0 10
86953: PUSH
86954: LD_INT 5
86956: PUSH
86957: LD_INT 6
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 2
86966: PUSH
86967: LD_INT 4
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 3
86976: PUSH
86977: LD_INT 5
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 24
86991: PUSH
86992: LD_INT 25
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 23
87001: PUSH
87002: LD_INT 27
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 42
87015: PUSH
87016: LD_INT 43
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 44
87025: PUSH
87026: LD_INT 46
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 45
87035: PUSH
87036: LD_INT 47
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: LIST
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: LIST
87052: ST_TO_ADDR
// result := [ ] ;
87053: LD_ADDR_VAR 0 3
87057: PUSH
87058: EMPTY
87059: ST_TO_ADDR
// for i in turrets do
87060: LD_ADDR_VAR 0 4
87064: PUSH
87065: LD_VAR 0 1
87069: PUSH
87070: FOR_IN
87071: IFFALSE 87254
// begin nat := GetNation ( i ) ;
87073: LD_ADDR_VAR 0 7
87077: PUSH
87078: LD_VAR 0 4
87082: PPUSH
87083: CALL_OW 248
87087: ST_TO_ADDR
// weapon := 0 ;
87088: LD_ADDR_VAR 0 8
87092: PUSH
87093: LD_INT 0
87095: ST_TO_ADDR
// if not nat then
87096: LD_VAR 0 7
87100: NOT
87101: IFFALSE 87105
// continue ;
87103: GO 87070
// for j in list [ nat ] do
87105: LD_ADDR_VAR 0 5
87109: PUSH
87110: LD_VAR 0 10
87114: PUSH
87115: LD_VAR 0 7
87119: ARRAY
87120: PUSH
87121: FOR_IN
87122: IFFALSE 87163
// if GetBWeapon ( i ) = j [ 1 ] then
87124: LD_VAR 0 4
87128: PPUSH
87129: CALL_OW 269
87133: PUSH
87134: LD_VAR 0 5
87138: PUSH
87139: LD_INT 1
87141: ARRAY
87142: EQUAL
87143: IFFALSE 87161
// begin weapon := j [ 2 ] ;
87145: LD_ADDR_VAR 0 8
87149: PUSH
87150: LD_VAR 0 5
87154: PUSH
87155: LD_INT 2
87157: ARRAY
87158: ST_TO_ADDR
// break ;
87159: GO 87163
// end ;
87161: GO 87121
87163: POP
87164: POP
// if not weapon then
87165: LD_VAR 0 8
87169: NOT
87170: IFFALSE 87174
// continue ;
87172: GO 87070
// for k in factories do
87174: LD_ADDR_VAR 0 6
87178: PUSH
87179: LD_VAR 0 2
87183: PUSH
87184: FOR_IN
87185: IFFALSE 87250
// begin weapons := AvailableWeaponList ( k ) ;
87187: LD_ADDR_VAR 0 9
87191: PUSH
87192: LD_VAR 0 6
87196: PPUSH
87197: CALL_OW 478
87201: ST_TO_ADDR
// if not weapons then
87202: LD_VAR 0 9
87206: NOT
87207: IFFALSE 87211
// continue ;
87209: GO 87184
// if weapon in weapons then
87211: LD_VAR 0 8
87215: PUSH
87216: LD_VAR 0 9
87220: IN
87221: IFFALSE 87248
// begin result := [ i , weapon ] ;
87223: LD_ADDR_VAR 0 3
87227: PUSH
87228: LD_VAR 0 4
87232: PUSH
87233: LD_VAR 0 8
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// exit ;
87242: POP
87243: POP
87244: POP
87245: POP
87246: GO 87256
// end ; end ;
87248: GO 87184
87250: POP
87251: POP
// end ;
87252: GO 87070
87254: POP
87255: POP
// end ;
87256: LD_VAR 0 3
87260: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87261: LD_INT 0
87263: PPUSH
// if not side or side > 8 then
87264: LD_VAR 0 3
87268: NOT
87269: PUSH
87270: LD_VAR 0 3
87274: PUSH
87275: LD_INT 8
87277: GREATER
87278: OR
87279: IFFALSE 87283
// exit ;
87281: GO 87342
// if not range then
87283: LD_VAR 0 4
87287: NOT
87288: IFFALSE 87299
// range := - 12 ;
87290: LD_ADDR_VAR 0 4
87294: PUSH
87295: LD_INT 12
87297: NEG
87298: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87299: LD_VAR 0 1
87303: PPUSH
87304: LD_VAR 0 2
87308: PPUSH
87309: LD_VAR 0 3
87313: PPUSH
87314: LD_VAR 0 4
87318: PPUSH
87319: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87323: LD_VAR 0 1
87327: PPUSH
87328: LD_VAR 0 2
87332: PPUSH
87333: LD_VAR 0 3
87337: PPUSH
87338: CALL_OW 331
// end ;
87342: LD_VAR 0 5
87346: RET
// export function Video ( mode ) ; begin
87347: LD_INT 0
87349: PPUSH
// ingame_video = mode ;
87350: LD_ADDR_OWVAR 52
87354: PUSH
87355: LD_VAR 0 1
87359: ST_TO_ADDR
// interface_hidden = mode ;
87360: LD_ADDR_OWVAR 54
87364: PUSH
87365: LD_VAR 0 1
87369: ST_TO_ADDR
// end ;
87370: LD_VAR 0 2
87374: RET
// export function Join ( array , element ) ; begin
87375: LD_INT 0
87377: PPUSH
// result := Replace ( array , array + 1 , element ) ;
87378: LD_ADDR_VAR 0 3
87382: PUSH
87383: LD_VAR 0 1
87387: PPUSH
87388: LD_VAR 0 1
87392: PUSH
87393: LD_INT 1
87395: PLUS
87396: PPUSH
87397: LD_VAR 0 2
87401: PPUSH
87402: CALL_OW 1
87406: ST_TO_ADDR
// end ;
87407: LD_VAR 0 3
87411: RET
// export function JoinUnion ( array , element ) ; begin
87412: LD_INT 0
87414: PPUSH
// result := array union element ;
87415: LD_ADDR_VAR 0 3
87419: PUSH
87420: LD_VAR 0 1
87424: PUSH
87425: LD_VAR 0 2
87429: UNION
87430: ST_TO_ADDR
// end ;
87431: LD_VAR 0 3
87435: RET
// export function GetBehemoths ( side ) ; begin
87436: LD_INT 0
87438: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
87439: LD_ADDR_VAR 0 2
87443: PUSH
87444: LD_INT 22
87446: PUSH
87447: LD_VAR 0 1
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 31
87458: PUSH
87459: LD_INT 25
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PPUSH
87470: CALL_OW 69
87474: ST_TO_ADDR
// end ;
87475: LD_VAR 0 2
87479: RET
// export function Shuffle ( array ) ; var i , index ; begin
87480: LD_INT 0
87482: PPUSH
87483: PPUSH
87484: PPUSH
// result := [ ] ;
87485: LD_ADDR_VAR 0 2
87489: PUSH
87490: EMPTY
87491: ST_TO_ADDR
// if not array then
87492: LD_VAR 0 1
87496: NOT
87497: IFFALSE 87501
// exit ;
87499: GO 87600
// Randomize ;
87501: CALL_OW 10
// for i = array downto 1 do
87505: LD_ADDR_VAR 0 3
87509: PUSH
87510: DOUBLE
87511: LD_VAR 0 1
87515: INC
87516: ST_TO_ADDR
87517: LD_INT 1
87519: PUSH
87520: FOR_DOWNTO
87521: IFFALSE 87598
// begin index := rand ( 1 , array ) ;
87523: LD_ADDR_VAR 0 4
87527: PUSH
87528: LD_INT 1
87530: PPUSH
87531: LD_VAR 0 1
87535: PPUSH
87536: CALL_OW 12
87540: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87541: LD_ADDR_VAR 0 2
87545: PUSH
87546: LD_VAR 0 2
87550: PPUSH
87551: LD_VAR 0 2
87555: PUSH
87556: LD_INT 1
87558: PLUS
87559: PPUSH
87560: LD_VAR 0 1
87564: PUSH
87565: LD_VAR 0 4
87569: ARRAY
87570: PPUSH
87571: CALL_OW 2
87575: ST_TO_ADDR
// array := Delete ( array , index ) ;
87576: LD_ADDR_VAR 0 1
87580: PUSH
87581: LD_VAR 0 1
87585: PPUSH
87586: LD_VAR 0 4
87590: PPUSH
87591: CALL_OW 3
87595: ST_TO_ADDR
// end ;
87596: GO 87520
87598: POP
87599: POP
// end ;
87600: LD_VAR 0 2
87604: RET
// export function GetBaseMaterials ( base ) ; begin
87605: LD_INT 0
87607: PPUSH
// result := [ 0 , 0 , 0 ] ;
87608: LD_ADDR_VAR 0 2
87612: PUSH
87613: LD_INT 0
87615: PUSH
87616: LD_INT 0
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: LIST
87626: ST_TO_ADDR
// if not base then
87627: LD_VAR 0 1
87631: NOT
87632: IFFALSE 87636
// exit ;
87634: GO 87685
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87636: LD_ADDR_VAR 0 2
87640: PUSH
87641: LD_VAR 0 1
87645: PPUSH
87646: LD_INT 1
87648: PPUSH
87649: CALL_OW 275
87653: PUSH
87654: LD_VAR 0 1
87658: PPUSH
87659: LD_INT 2
87661: PPUSH
87662: CALL_OW 275
87666: PUSH
87667: LD_VAR 0 1
87671: PPUSH
87672: LD_INT 3
87674: PPUSH
87675: CALL_OW 275
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: LIST
87684: ST_TO_ADDR
// end ;
87685: LD_VAR 0 2
87689: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87690: LD_INT 0
87692: PPUSH
87693: PPUSH
// result := array ;
87694: LD_ADDR_VAR 0 3
87698: PUSH
87699: LD_VAR 0 1
87703: ST_TO_ADDR
// if size > 0 then
87704: LD_VAR 0 2
87708: PUSH
87709: LD_INT 0
87711: GREATER
87712: IFFALSE 87758
// for i := array downto size do
87714: LD_ADDR_VAR 0 4
87718: PUSH
87719: DOUBLE
87720: LD_VAR 0 1
87724: INC
87725: ST_TO_ADDR
87726: LD_VAR 0 2
87730: PUSH
87731: FOR_DOWNTO
87732: IFFALSE 87756
// result := Delete ( result , result ) ;
87734: LD_ADDR_VAR 0 3
87738: PUSH
87739: LD_VAR 0 3
87743: PPUSH
87744: LD_VAR 0 3
87748: PPUSH
87749: CALL_OW 3
87753: ST_TO_ADDR
87754: GO 87731
87756: POP
87757: POP
// end ;
87758: LD_VAR 0 3
87762: RET
// export function ComExit ( unit ) ; var tmp ; begin
87763: LD_INT 0
87765: PPUSH
87766: PPUSH
// if not IsInUnit ( unit ) then
87767: LD_VAR 0 1
87771: PPUSH
87772: CALL_OW 310
87776: NOT
87777: IFFALSE 87781
// exit ;
87779: GO 87841
// tmp := IsInUnit ( unit ) ;
87781: LD_ADDR_VAR 0 3
87785: PUSH
87786: LD_VAR 0 1
87790: PPUSH
87791: CALL_OW 310
87795: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87796: LD_VAR 0 3
87800: PPUSH
87801: CALL_OW 247
87805: PUSH
87806: LD_INT 2
87808: EQUAL
87809: IFFALSE 87822
// ComExitVehicle ( unit ) else
87811: LD_VAR 0 1
87815: PPUSH
87816: CALL_OW 121
87820: GO 87831
// ComExitBuilding ( unit ) ;
87822: LD_VAR 0 1
87826: PPUSH
87827: CALL_OW 122
// result := tmp ;
87831: LD_ADDR_VAR 0 2
87835: PUSH
87836: LD_VAR 0 3
87840: ST_TO_ADDR
// end ;
87841: LD_VAR 0 2
87845: RET
// export function ComExitAll ( units ) ; var i ; begin
87846: LD_INT 0
87848: PPUSH
87849: PPUSH
// if not units then
87850: LD_VAR 0 1
87854: NOT
87855: IFFALSE 87859
// exit ;
87857: GO 87885
// for i in units do
87859: LD_ADDR_VAR 0 3
87863: PUSH
87864: LD_VAR 0 1
87868: PUSH
87869: FOR_IN
87870: IFFALSE 87883
// ComExit ( i ) ;
87872: LD_VAR 0 3
87876: PPUSH
87877: CALL 87763 0 1
87881: GO 87869
87883: POP
87884: POP
// end ;
87885: LD_VAR 0 2
87889: RET
// export function ResetHc ; begin
87890: LD_INT 0
87892: PPUSH
// InitHc ;
87893: CALL_OW 19
// hc_importance := 0 ;
87897: LD_ADDR_OWVAR 32
87901: PUSH
87902: LD_INT 0
87904: ST_TO_ADDR
// end ;
87905: LD_VAR 0 1
87909: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87910: LD_INT 0
87912: PPUSH
87913: PPUSH
87914: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87915: LD_ADDR_VAR 0 6
87919: PUSH
87920: LD_VAR 0 1
87924: PUSH
87925: LD_VAR 0 3
87929: PLUS
87930: PUSH
87931: LD_INT 2
87933: DIV
87934: ST_TO_ADDR
// if _x < 0 then
87935: LD_VAR 0 6
87939: PUSH
87940: LD_INT 0
87942: LESS
87943: IFFALSE 87960
// _x := _x * - 1 ;
87945: LD_ADDR_VAR 0 6
87949: PUSH
87950: LD_VAR 0 6
87954: PUSH
87955: LD_INT 1
87957: NEG
87958: MUL
87959: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87960: LD_ADDR_VAR 0 7
87964: PUSH
87965: LD_VAR 0 2
87969: PUSH
87970: LD_VAR 0 4
87974: PLUS
87975: PUSH
87976: LD_INT 2
87978: DIV
87979: ST_TO_ADDR
// if _y < 0 then
87980: LD_VAR 0 7
87984: PUSH
87985: LD_INT 0
87987: LESS
87988: IFFALSE 88005
// _y := _y * - 1 ;
87990: LD_ADDR_VAR 0 7
87994: PUSH
87995: LD_VAR 0 7
87999: PUSH
88000: LD_INT 1
88002: NEG
88003: MUL
88004: ST_TO_ADDR
// result := [ _x , _y ] ;
88005: LD_ADDR_VAR 0 5
88009: PUSH
88010: LD_VAR 0 6
88014: PUSH
88015: LD_VAR 0 7
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: ST_TO_ADDR
// end ;
88024: LD_VAR 0 5
88028: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88029: LD_INT 0
88031: PPUSH
88032: PPUSH
88033: PPUSH
88034: PPUSH
// task := GetTaskList ( unit ) ;
88035: LD_ADDR_VAR 0 7
88039: PUSH
88040: LD_VAR 0 1
88044: PPUSH
88045: CALL_OW 437
88049: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88050: LD_VAR 0 7
88054: NOT
88055: PUSH
88056: LD_VAR 0 1
88060: PPUSH
88061: LD_VAR 0 2
88065: PPUSH
88066: CALL_OW 308
88070: NOT
88071: AND
88072: IFFALSE 88076
// exit ;
88074: GO 88194
// if IsInArea ( unit , area ) then
88076: LD_VAR 0 1
88080: PPUSH
88081: LD_VAR 0 2
88085: PPUSH
88086: CALL_OW 308
88090: IFFALSE 88108
// begin ComMoveToArea ( unit , goAway ) ;
88092: LD_VAR 0 1
88096: PPUSH
88097: LD_VAR 0 3
88101: PPUSH
88102: CALL_OW 113
// exit ;
88106: GO 88194
// end ; if task [ 1 ] [ 1 ] <> M then
88108: LD_VAR 0 7
88112: PUSH
88113: LD_INT 1
88115: ARRAY
88116: PUSH
88117: LD_INT 1
88119: ARRAY
88120: PUSH
88121: LD_STRING M
88123: NONEQUAL
88124: IFFALSE 88128
// exit ;
88126: GO 88194
// x := task [ 1 ] [ 2 ] ;
88128: LD_ADDR_VAR 0 5
88132: PUSH
88133: LD_VAR 0 7
88137: PUSH
88138: LD_INT 1
88140: ARRAY
88141: PUSH
88142: LD_INT 2
88144: ARRAY
88145: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88146: LD_ADDR_VAR 0 6
88150: PUSH
88151: LD_VAR 0 7
88155: PUSH
88156: LD_INT 1
88158: ARRAY
88159: PUSH
88160: LD_INT 3
88162: ARRAY
88163: ST_TO_ADDR
// if InArea ( x , y , area ) then
88164: LD_VAR 0 5
88168: PPUSH
88169: LD_VAR 0 6
88173: PPUSH
88174: LD_VAR 0 2
88178: PPUSH
88179: CALL_OW 309
88183: IFFALSE 88194
// ComStop ( unit ) ;
88185: LD_VAR 0 1
88189: PPUSH
88190: CALL_OW 141
// end ;
88194: LD_VAR 0 4
88198: RET
// export function Abs ( value ) ; begin
88199: LD_INT 0
88201: PPUSH
// result := value ;
88202: LD_ADDR_VAR 0 2
88206: PUSH
88207: LD_VAR 0 1
88211: ST_TO_ADDR
// if value < 0 then
88212: LD_VAR 0 1
88216: PUSH
88217: LD_INT 0
88219: LESS
88220: IFFALSE 88237
// result := value * - 1 ;
88222: LD_ADDR_VAR 0 2
88226: PUSH
88227: LD_VAR 0 1
88231: PUSH
88232: LD_INT 1
88234: NEG
88235: MUL
88236: ST_TO_ADDR
// end ;
88237: LD_VAR 0 2
88241: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88242: LD_INT 0
88244: PPUSH
88245: PPUSH
88246: PPUSH
88247: PPUSH
88248: PPUSH
88249: PPUSH
88250: PPUSH
88251: PPUSH
// if not unit or not building then
88252: LD_VAR 0 1
88256: NOT
88257: PUSH
88258: LD_VAR 0 2
88262: NOT
88263: OR
88264: IFFALSE 88268
// exit ;
88266: GO 88494
// x := GetX ( building ) ;
88268: LD_ADDR_VAR 0 4
88272: PUSH
88273: LD_VAR 0 2
88277: PPUSH
88278: CALL_OW 250
88282: ST_TO_ADDR
// y := GetY ( building ) ;
88283: LD_ADDR_VAR 0 6
88287: PUSH
88288: LD_VAR 0 2
88292: PPUSH
88293: CALL_OW 251
88297: ST_TO_ADDR
// d := GetDir ( building ) ;
88298: LD_ADDR_VAR 0 8
88302: PUSH
88303: LD_VAR 0 2
88307: PPUSH
88308: CALL_OW 254
88312: ST_TO_ADDR
// r := 4 ;
88313: LD_ADDR_VAR 0 9
88317: PUSH
88318: LD_INT 4
88320: ST_TO_ADDR
// for i := 1 to 5 do
88321: LD_ADDR_VAR 0 10
88325: PUSH
88326: DOUBLE
88327: LD_INT 1
88329: DEC
88330: ST_TO_ADDR
88331: LD_INT 5
88333: PUSH
88334: FOR_TO
88335: IFFALSE 88492
// begin _x := ShiftX ( x , d , r + i ) ;
88337: LD_ADDR_VAR 0 5
88341: PUSH
88342: LD_VAR 0 4
88346: PPUSH
88347: LD_VAR 0 8
88351: PPUSH
88352: LD_VAR 0 9
88356: PUSH
88357: LD_VAR 0 10
88361: PLUS
88362: PPUSH
88363: CALL_OW 272
88367: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
88368: LD_ADDR_VAR 0 7
88372: PUSH
88373: LD_VAR 0 6
88377: PPUSH
88378: LD_VAR 0 8
88382: PPUSH
88383: LD_VAR 0 9
88387: PUSH
88388: LD_VAR 0 10
88392: PLUS
88393: PPUSH
88394: CALL_OW 273
88398: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
88399: LD_VAR 0 5
88403: PPUSH
88404: LD_VAR 0 7
88408: PPUSH
88409: CALL_OW 488
88413: PUSH
88414: LD_VAR 0 5
88418: PPUSH
88419: LD_VAR 0 7
88423: PPUSH
88424: CALL_OW 428
88428: PPUSH
88429: CALL_OW 247
88433: PUSH
88434: LD_INT 3
88436: PUSH
88437: LD_INT 2
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: IN
88444: NOT
88445: AND
88446: IFFALSE 88490
// begin ComMoveXY ( unit , _x , _y ) ;
88448: LD_VAR 0 1
88452: PPUSH
88453: LD_VAR 0 5
88457: PPUSH
88458: LD_VAR 0 7
88462: PPUSH
88463: CALL_OW 111
// result := [ _x , _y ] ;
88467: LD_ADDR_VAR 0 3
88471: PUSH
88472: LD_VAR 0 5
88476: PUSH
88477: LD_VAR 0 7
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: ST_TO_ADDR
// exit ;
88486: POP
88487: POP
88488: GO 88494
// end ; end ;
88490: GO 88334
88492: POP
88493: POP
// end ;
88494: LD_VAR 0 3
88498: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88499: LD_INT 0
88501: PPUSH
88502: PPUSH
88503: PPUSH
// result := 0 ;
88504: LD_ADDR_VAR 0 3
88508: PUSH
88509: LD_INT 0
88511: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88512: LD_VAR 0 1
88516: PUSH
88517: LD_INT 0
88519: LESS
88520: PUSH
88521: LD_VAR 0 1
88525: PUSH
88526: LD_INT 8
88528: GREATER
88529: OR
88530: PUSH
88531: LD_VAR 0 2
88535: PUSH
88536: LD_INT 0
88538: LESS
88539: OR
88540: PUSH
88541: LD_VAR 0 2
88545: PUSH
88546: LD_INT 8
88548: GREATER
88549: OR
88550: IFFALSE 88554
// exit ;
88552: GO 88629
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88554: LD_ADDR_VAR 0 4
88558: PUSH
88559: LD_INT 22
88561: PUSH
88562: LD_VAR 0 2
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PPUSH
88571: CALL_OW 69
88575: PUSH
88576: FOR_IN
88577: IFFALSE 88627
// begin un := UnitShoot ( i ) ;
88579: LD_ADDR_VAR 0 5
88583: PUSH
88584: LD_VAR 0 4
88588: PPUSH
88589: CALL_OW 504
88593: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88594: LD_VAR 0 5
88598: PPUSH
88599: CALL_OW 255
88603: PUSH
88604: LD_VAR 0 1
88608: EQUAL
88609: IFFALSE 88625
// begin result := un ;
88611: LD_ADDR_VAR 0 3
88615: PUSH
88616: LD_VAR 0 5
88620: ST_TO_ADDR
// exit ;
88621: POP
88622: POP
88623: GO 88629
// end ; end ;
88625: GO 88576
88627: POP
88628: POP
// end ;
88629: LD_VAR 0 3
88633: RET
// export function GetCargoBay ( units ) ; begin
88634: LD_INT 0
88636: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88637: LD_ADDR_VAR 0 2
88641: PUSH
88642: LD_VAR 0 1
88646: PPUSH
88647: LD_INT 2
88649: PUSH
88650: LD_INT 34
88652: PUSH
88653: LD_INT 12
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 34
88662: PUSH
88663: LD_INT 51
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 34
88672: PUSH
88673: LD_INT 32
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 34
88682: PUSH
88683: LD_EXP 73
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: PPUSH
88699: CALL_OW 72
88703: ST_TO_ADDR
// end ; end_of_file end_of_file
88704: LD_VAR 0 2
88708: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88709: LD_INT 0
88711: PPUSH
// if p2 = 100 then
88712: LD_VAR 0 2
88716: PUSH
88717: LD_INT 100
88719: EQUAL
88720: IFFALSE 89669
// begin if not StreamModeActive then
88722: LD_EXP 136
88726: NOT
88727: IFFALSE 88737
// StreamModeActive := true ;
88729: LD_ADDR_EXP 136
88733: PUSH
88734: LD_INT 1
88736: ST_TO_ADDR
// if p3 = 0 then
88737: LD_VAR 0 3
88741: PUSH
88742: LD_INT 0
88744: EQUAL
88745: IFFALSE 88751
// InitStreamMode ;
88747: CALL 89829 0 0
// if p3 = 1 then
88751: LD_VAR 0 3
88755: PUSH
88756: LD_INT 1
88758: EQUAL
88759: IFFALSE 88769
// sRocket := true ;
88761: LD_ADDR_EXP 141
88765: PUSH
88766: LD_INT 1
88768: ST_TO_ADDR
// if p3 = 2 then
88769: LD_VAR 0 3
88773: PUSH
88774: LD_INT 2
88776: EQUAL
88777: IFFALSE 88787
// sSpeed := true ;
88779: LD_ADDR_EXP 140
88783: PUSH
88784: LD_INT 1
88786: ST_TO_ADDR
// if p3 = 3 then
88787: LD_VAR 0 3
88791: PUSH
88792: LD_INT 3
88794: EQUAL
88795: IFFALSE 88805
// sEngine := true ;
88797: LD_ADDR_EXP 142
88801: PUSH
88802: LD_INT 1
88804: ST_TO_ADDR
// if p3 = 4 then
88805: LD_VAR 0 3
88809: PUSH
88810: LD_INT 4
88812: EQUAL
88813: IFFALSE 88823
// sSpec := true ;
88815: LD_ADDR_EXP 139
88819: PUSH
88820: LD_INT 1
88822: ST_TO_ADDR
// if p3 = 5 then
88823: LD_VAR 0 3
88827: PUSH
88828: LD_INT 5
88830: EQUAL
88831: IFFALSE 88841
// sLevel := true ;
88833: LD_ADDR_EXP 143
88837: PUSH
88838: LD_INT 1
88840: ST_TO_ADDR
// if p3 = 6 then
88841: LD_VAR 0 3
88845: PUSH
88846: LD_INT 6
88848: EQUAL
88849: IFFALSE 88859
// sArmoury := true ;
88851: LD_ADDR_EXP 144
88855: PUSH
88856: LD_INT 1
88858: ST_TO_ADDR
// if p3 = 7 then
88859: LD_VAR 0 3
88863: PUSH
88864: LD_INT 7
88866: EQUAL
88867: IFFALSE 88877
// sRadar := true ;
88869: LD_ADDR_EXP 145
88873: PUSH
88874: LD_INT 1
88876: ST_TO_ADDR
// if p3 = 8 then
88877: LD_VAR 0 3
88881: PUSH
88882: LD_INT 8
88884: EQUAL
88885: IFFALSE 88895
// sBunker := true ;
88887: LD_ADDR_EXP 146
88891: PUSH
88892: LD_INT 1
88894: ST_TO_ADDR
// if p3 = 9 then
88895: LD_VAR 0 3
88899: PUSH
88900: LD_INT 9
88902: EQUAL
88903: IFFALSE 88913
// sHack := true ;
88905: LD_ADDR_EXP 147
88909: PUSH
88910: LD_INT 1
88912: ST_TO_ADDR
// if p3 = 10 then
88913: LD_VAR 0 3
88917: PUSH
88918: LD_INT 10
88920: EQUAL
88921: IFFALSE 88931
// sFire := true ;
88923: LD_ADDR_EXP 148
88927: PUSH
88928: LD_INT 1
88930: ST_TO_ADDR
// if p3 = 11 then
88931: LD_VAR 0 3
88935: PUSH
88936: LD_INT 11
88938: EQUAL
88939: IFFALSE 88949
// sRefresh := true ;
88941: LD_ADDR_EXP 149
88945: PUSH
88946: LD_INT 1
88948: ST_TO_ADDR
// if p3 = 12 then
88949: LD_VAR 0 3
88953: PUSH
88954: LD_INT 12
88956: EQUAL
88957: IFFALSE 88967
// sExp := true ;
88959: LD_ADDR_EXP 150
88963: PUSH
88964: LD_INT 1
88966: ST_TO_ADDR
// if p3 = 13 then
88967: LD_VAR 0 3
88971: PUSH
88972: LD_INT 13
88974: EQUAL
88975: IFFALSE 88985
// sDepot := true ;
88977: LD_ADDR_EXP 151
88981: PUSH
88982: LD_INT 1
88984: ST_TO_ADDR
// if p3 = 14 then
88985: LD_VAR 0 3
88989: PUSH
88990: LD_INT 14
88992: EQUAL
88993: IFFALSE 89003
// sFlag := true ;
88995: LD_ADDR_EXP 152
88999: PUSH
89000: LD_INT 1
89002: ST_TO_ADDR
// if p3 = 15 then
89003: LD_VAR 0 3
89007: PUSH
89008: LD_INT 15
89010: EQUAL
89011: IFFALSE 89021
// sKamikadze := true ;
89013: LD_ADDR_EXP 160
89017: PUSH
89018: LD_INT 1
89020: ST_TO_ADDR
// if p3 = 16 then
89021: LD_VAR 0 3
89025: PUSH
89026: LD_INT 16
89028: EQUAL
89029: IFFALSE 89039
// sTroll := true ;
89031: LD_ADDR_EXP 161
89035: PUSH
89036: LD_INT 1
89038: ST_TO_ADDR
// if p3 = 17 then
89039: LD_VAR 0 3
89043: PUSH
89044: LD_INT 17
89046: EQUAL
89047: IFFALSE 89057
// sSlow := true ;
89049: LD_ADDR_EXP 162
89053: PUSH
89054: LD_INT 1
89056: ST_TO_ADDR
// if p3 = 18 then
89057: LD_VAR 0 3
89061: PUSH
89062: LD_INT 18
89064: EQUAL
89065: IFFALSE 89075
// sLack := true ;
89067: LD_ADDR_EXP 163
89071: PUSH
89072: LD_INT 1
89074: ST_TO_ADDR
// if p3 = 19 then
89075: LD_VAR 0 3
89079: PUSH
89080: LD_INT 19
89082: EQUAL
89083: IFFALSE 89093
// sTank := true ;
89085: LD_ADDR_EXP 165
89089: PUSH
89090: LD_INT 1
89092: ST_TO_ADDR
// if p3 = 20 then
89093: LD_VAR 0 3
89097: PUSH
89098: LD_INT 20
89100: EQUAL
89101: IFFALSE 89111
// sRemote := true ;
89103: LD_ADDR_EXP 166
89107: PUSH
89108: LD_INT 1
89110: ST_TO_ADDR
// if p3 = 21 then
89111: LD_VAR 0 3
89115: PUSH
89116: LD_INT 21
89118: EQUAL
89119: IFFALSE 89129
// sPowell := true ;
89121: LD_ADDR_EXP 167
89125: PUSH
89126: LD_INT 1
89128: ST_TO_ADDR
// if p3 = 22 then
89129: LD_VAR 0 3
89133: PUSH
89134: LD_INT 22
89136: EQUAL
89137: IFFALSE 89147
// sTeleport := true ;
89139: LD_ADDR_EXP 170
89143: PUSH
89144: LD_INT 1
89146: ST_TO_ADDR
// if p3 = 23 then
89147: LD_VAR 0 3
89151: PUSH
89152: LD_INT 23
89154: EQUAL
89155: IFFALSE 89165
// sOilTower := true ;
89157: LD_ADDR_EXP 172
89161: PUSH
89162: LD_INT 1
89164: ST_TO_ADDR
// if p3 = 24 then
89165: LD_VAR 0 3
89169: PUSH
89170: LD_INT 24
89172: EQUAL
89173: IFFALSE 89183
// sShovel := true ;
89175: LD_ADDR_EXP 173
89179: PUSH
89180: LD_INT 1
89182: ST_TO_ADDR
// if p3 = 25 then
89183: LD_VAR 0 3
89187: PUSH
89188: LD_INT 25
89190: EQUAL
89191: IFFALSE 89201
// sSheik := true ;
89193: LD_ADDR_EXP 174
89197: PUSH
89198: LD_INT 1
89200: ST_TO_ADDR
// if p3 = 26 then
89201: LD_VAR 0 3
89205: PUSH
89206: LD_INT 26
89208: EQUAL
89209: IFFALSE 89219
// sEarthquake := true ;
89211: LD_ADDR_EXP 176
89215: PUSH
89216: LD_INT 1
89218: ST_TO_ADDR
// if p3 = 27 then
89219: LD_VAR 0 3
89223: PUSH
89224: LD_INT 27
89226: EQUAL
89227: IFFALSE 89237
// sAI := true ;
89229: LD_ADDR_EXP 177
89233: PUSH
89234: LD_INT 1
89236: ST_TO_ADDR
// if p3 = 28 then
89237: LD_VAR 0 3
89241: PUSH
89242: LD_INT 28
89244: EQUAL
89245: IFFALSE 89255
// sCargo := true ;
89247: LD_ADDR_EXP 180
89251: PUSH
89252: LD_INT 1
89254: ST_TO_ADDR
// if p3 = 29 then
89255: LD_VAR 0 3
89259: PUSH
89260: LD_INT 29
89262: EQUAL
89263: IFFALSE 89273
// sDLaser := true ;
89265: LD_ADDR_EXP 181
89269: PUSH
89270: LD_INT 1
89272: ST_TO_ADDR
// if p3 = 30 then
89273: LD_VAR 0 3
89277: PUSH
89278: LD_INT 30
89280: EQUAL
89281: IFFALSE 89291
// sExchange := true ;
89283: LD_ADDR_EXP 182
89287: PUSH
89288: LD_INT 1
89290: ST_TO_ADDR
// if p3 = 31 then
89291: LD_VAR 0 3
89295: PUSH
89296: LD_INT 31
89298: EQUAL
89299: IFFALSE 89309
// sFac := true ;
89301: LD_ADDR_EXP 183
89305: PUSH
89306: LD_INT 1
89308: ST_TO_ADDR
// if p3 = 32 then
89309: LD_VAR 0 3
89313: PUSH
89314: LD_INT 32
89316: EQUAL
89317: IFFALSE 89327
// sPower := true ;
89319: LD_ADDR_EXP 184
89323: PUSH
89324: LD_INT 1
89326: ST_TO_ADDR
// if p3 = 33 then
89327: LD_VAR 0 3
89331: PUSH
89332: LD_INT 33
89334: EQUAL
89335: IFFALSE 89345
// sRandom := true ;
89337: LD_ADDR_EXP 185
89341: PUSH
89342: LD_INT 1
89344: ST_TO_ADDR
// if p3 = 34 then
89345: LD_VAR 0 3
89349: PUSH
89350: LD_INT 34
89352: EQUAL
89353: IFFALSE 89363
// sShield := true ;
89355: LD_ADDR_EXP 186
89359: PUSH
89360: LD_INT 1
89362: ST_TO_ADDR
// if p3 = 35 then
89363: LD_VAR 0 3
89367: PUSH
89368: LD_INT 35
89370: EQUAL
89371: IFFALSE 89381
// sTime := true ;
89373: LD_ADDR_EXP 187
89377: PUSH
89378: LD_INT 1
89380: ST_TO_ADDR
// if p3 = 36 then
89381: LD_VAR 0 3
89385: PUSH
89386: LD_INT 36
89388: EQUAL
89389: IFFALSE 89399
// sTools := true ;
89391: LD_ADDR_EXP 188
89395: PUSH
89396: LD_INT 1
89398: ST_TO_ADDR
// if p3 = 101 then
89399: LD_VAR 0 3
89403: PUSH
89404: LD_INT 101
89406: EQUAL
89407: IFFALSE 89417
// sSold := true ;
89409: LD_ADDR_EXP 153
89413: PUSH
89414: LD_INT 1
89416: ST_TO_ADDR
// if p3 = 102 then
89417: LD_VAR 0 3
89421: PUSH
89422: LD_INT 102
89424: EQUAL
89425: IFFALSE 89435
// sDiff := true ;
89427: LD_ADDR_EXP 154
89431: PUSH
89432: LD_INT 1
89434: ST_TO_ADDR
// if p3 = 103 then
89435: LD_VAR 0 3
89439: PUSH
89440: LD_INT 103
89442: EQUAL
89443: IFFALSE 89453
// sFog := true ;
89445: LD_ADDR_EXP 157
89449: PUSH
89450: LD_INT 1
89452: ST_TO_ADDR
// if p3 = 104 then
89453: LD_VAR 0 3
89457: PUSH
89458: LD_INT 104
89460: EQUAL
89461: IFFALSE 89471
// sReset := true ;
89463: LD_ADDR_EXP 158
89467: PUSH
89468: LD_INT 1
89470: ST_TO_ADDR
// if p3 = 105 then
89471: LD_VAR 0 3
89475: PUSH
89476: LD_INT 105
89478: EQUAL
89479: IFFALSE 89489
// sSun := true ;
89481: LD_ADDR_EXP 159
89485: PUSH
89486: LD_INT 1
89488: ST_TO_ADDR
// if p3 = 106 then
89489: LD_VAR 0 3
89493: PUSH
89494: LD_INT 106
89496: EQUAL
89497: IFFALSE 89507
// sTiger := true ;
89499: LD_ADDR_EXP 155
89503: PUSH
89504: LD_INT 1
89506: ST_TO_ADDR
// if p3 = 107 then
89507: LD_VAR 0 3
89511: PUSH
89512: LD_INT 107
89514: EQUAL
89515: IFFALSE 89525
// sBomb := true ;
89517: LD_ADDR_EXP 156
89521: PUSH
89522: LD_INT 1
89524: ST_TO_ADDR
// if p3 = 108 then
89525: LD_VAR 0 3
89529: PUSH
89530: LD_INT 108
89532: EQUAL
89533: IFFALSE 89543
// sWound := true ;
89535: LD_ADDR_EXP 164
89539: PUSH
89540: LD_INT 1
89542: ST_TO_ADDR
// if p3 = 109 then
89543: LD_VAR 0 3
89547: PUSH
89548: LD_INT 109
89550: EQUAL
89551: IFFALSE 89561
// sBetray := true ;
89553: LD_ADDR_EXP 168
89557: PUSH
89558: LD_INT 1
89560: ST_TO_ADDR
// if p3 = 110 then
89561: LD_VAR 0 3
89565: PUSH
89566: LD_INT 110
89568: EQUAL
89569: IFFALSE 89579
// sContamin := true ;
89571: LD_ADDR_EXP 169
89575: PUSH
89576: LD_INT 1
89578: ST_TO_ADDR
// if p3 = 111 then
89579: LD_VAR 0 3
89583: PUSH
89584: LD_INT 111
89586: EQUAL
89587: IFFALSE 89597
// sOil := true ;
89589: LD_ADDR_EXP 171
89593: PUSH
89594: LD_INT 1
89596: ST_TO_ADDR
// if p3 = 112 then
89597: LD_VAR 0 3
89601: PUSH
89602: LD_INT 112
89604: EQUAL
89605: IFFALSE 89615
// sStu := true ;
89607: LD_ADDR_EXP 175
89611: PUSH
89612: LD_INT 1
89614: ST_TO_ADDR
// if p3 = 113 then
89615: LD_VAR 0 3
89619: PUSH
89620: LD_INT 113
89622: EQUAL
89623: IFFALSE 89633
// sBazooka := true ;
89625: LD_ADDR_EXP 178
89629: PUSH
89630: LD_INT 1
89632: ST_TO_ADDR
// if p3 = 114 then
89633: LD_VAR 0 3
89637: PUSH
89638: LD_INT 114
89640: EQUAL
89641: IFFALSE 89651
// sMortar := true ;
89643: LD_ADDR_EXP 179
89647: PUSH
89648: LD_INT 1
89650: ST_TO_ADDR
// if p3 = 115 then
89651: LD_VAR 0 3
89655: PUSH
89656: LD_INT 115
89658: EQUAL
89659: IFFALSE 89669
// sRanger := true ;
89661: LD_ADDR_EXP 189
89665: PUSH
89666: LD_INT 1
89668: ST_TO_ADDR
// end ; if p2 = 101 then
89669: LD_VAR 0 2
89673: PUSH
89674: LD_INT 101
89676: EQUAL
89677: IFFALSE 89805
// begin case p3 of 1 :
89679: LD_VAR 0 3
89683: PUSH
89684: LD_INT 1
89686: DOUBLE
89687: EQUAL
89688: IFTRUE 89692
89690: GO 89699
89692: POP
// hHackUnlimitedResources ; 2 :
89693: CALL 100842 0 0
89697: GO 89805
89699: LD_INT 2
89701: DOUBLE
89702: EQUAL
89703: IFTRUE 89707
89705: GO 89714
89707: POP
// hHackSetLevel10 ; 3 :
89708: CALL 100975 0 0
89712: GO 89805
89714: LD_INT 3
89716: DOUBLE
89717: EQUAL
89718: IFTRUE 89722
89720: GO 89729
89722: POP
// hHackSetLevel10YourUnits ; 4 :
89723: CALL 101060 0 0
89727: GO 89805
89729: LD_INT 4
89731: DOUBLE
89732: EQUAL
89733: IFTRUE 89737
89735: GO 89744
89737: POP
// hHackInvincible ; 5 :
89738: CALL 101508 0 0
89742: GO 89805
89744: LD_INT 5
89746: DOUBLE
89747: EQUAL
89748: IFTRUE 89752
89750: GO 89759
89752: POP
// hHackInvisible ; 6 :
89753: CALL 101619 0 0
89757: GO 89805
89759: LD_INT 6
89761: DOUBLE
89762: EQUAL
89763: IFTRUE 89767
89765: GO 89774
89767: POP
// hHackChangeYourSide ; 7 :
89768: CALL 101676 0 0
89772: GO 89805
89774: LD_INT 7
89776: DOUBLE
89777: EQUAL
89778: IFTRUE 89782
89780: GO 89789
89782: POP
// hHackChangeUnitSide ; 8 :
89783: CALL 101718 0 0
89787: GO 89805
89789: LD_INT 8
89791: DOUBLE
89792: EQUAL
89793: IFTRUE 89797
89795: GO 89804
89797: POP
// hHackFog ; end ;
89798: CALL 101819 0 0
89802: GO 89805
89804: POP
// end ; end ;
89805: LD_VAR 0 7
89809: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89810: GO 89812
89812: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89813: LD_STRING initStreamRollete();
89815: PPUSH
89816: CALL_OW 559
// InitStreamMode ;
89820: CALL 89829 0 0
// DefineStreamItems ( ) ;
89824: CALL 90269 0 0
// end ;
89828: END
// function InitStreamMode ; begin
89829: LD_INT 0
89831: PPUSH
// streamModeActive := false ;
89832: LD_ADDR_EXP 136
89836: PUSH
89837: LD_INT 0
89839: ST_TO_ADDR
// normalCounter := 36 ;
89840: LD_ADDR_EXP 137
89844: PUSH
89845: LD_INT 36
89847: ST_TO_ADDR
// hardcoreCounter := 16 ;
89848: LD_ADDR_EXP 138
89852: PUSH
89853: LD_INT 16
89855: ST_TO_ADDR
// sRocket := false ;
89856: LD_ADDR_EXP 141
89860: PUSH
89861: LD_INT 0
89863: ST_TO_ADDR
// sSpeed := false ;
89864: LD_ADDR_EXP 140
89868: PUSH
89869: LD_INT 0
89871: ST_TO_ADDR
// sEngine := false ;
89872: LD_ADDR_EXP 142
89876: PUSH
89877: LD_INT 0
89879: ST_TO_ADDR
// sSpec := false ;
89880: LD_ADDR_EXP 139
89884: PUSH
89885: LD_INT 0
89887: ST_TO_ADDR
// sLevel := false ;
89888: LD_ADDR_EXP 143
89892: PUSH
89893: LD_INT 0
89895: ST_TO_ADDR
// sArmoury := false ;
89896: LD_ADDR_EXP 144
89900: PUSH
89901: LD_INT 0
89903: ST_TO_ADDR
// sRadar := false ;
89904: LD_ADDR_EXP 145
89908: PUSH
89909: LD_INT 0
89911: ST_TO_ADDR
// sBunker := false ;
89912: LD_ADDR_EXP 146
89916: PUSH
89917: LD_INT 0
89919: ST_TO_ADDR
// sHack := false ;
89920: LD_ADDR_EXP 147
89924: PUSH
89925: LD_INT 0
89927: ST_TO_ADDR
// sFire := false ;
89928: LD_ADDR_EXP 148
89932: PUSH
89933: LD_INT 0
89935: ST_TO_ADDR
// sRefresh := false ;
89936: LD_ADDR_EXP 149
89940: PUSH
89941: LD_INT 0
89943: ST_TO_ADDR
// sExp := false ;
89944: LD_ADDR_EXP 150
89948: PUSH
89949: LD_INT 0
89951: ST_TO_ADDR
// sDepot := false ;
89952: LD_ADDR_EXP 151
89956: PUSH
89957: LD_INT 0
89959: ST_TO_ADDR
// sFlag := false ;
89960: LD_ADDR_EXP 152
89964: PUSH
89965: LD_INT 0
89967: ST_TO_ADDR
// sKamikadze := false ;
89968: LD_ADDR_EXP 160
89972: PUSH
89973: LD_INT 0
89975: ST_TO_ADDR
// sTroll := false ;
89976: LD_ADDR_EXP 161
89980: PUSH
89981: LD_INT 0
89983: ST_TO_ADDR
// sSlow := false ;
89984: LD_ADDR_EXP 162
89988: PUSH
89989: LD_INT 0
89991: ST_TO_ADDR
// sLack := false ;
89992: LD_ADDR_EXP 163
89996: PUSH
89997: LD_INT 0
89999: ST_TO_ADDR
// sTank := false ;
90000: LD_ADDR_EXP 165
90004: PUSH
90005: LD_INT 0
90007: ST_TO_ADDR
// sRemote := false ;
90008: LD_ADDR_EXP 166
90012: PUSH
90013: LD_INT 0
90015: ST_TO_ADDR
// sPowell := false ;
90016: LD_ADDR_EXP 167
90020: PUSH
90021: LD_INT 0
90023: ST_TO_ADDR
// sTeleport := false ;
90024: LD_ADDR_EXP 170
90028: PUSH
90029: LD_INT 0
90031: ST_TO_ADDR
// sOilTower := false ;
90032: LD_ADDR_EXP 172
90036: PUSH
90037: LD_INT 0
90039: ST_TO_ADDR
// sShovel := false ;
90040: LD_ADDR_EXP 173
90044: PUSH
90045: LD_INT 0
90047: ST_TO_ADDR
// sSheik := false ;
90048: LD_ADDR_EXP 174
90052: PUSH
90053: LD_INT 0
90055: ST_TO_ADDR
// sEarthquake := false ;
90056: LD_ADDR_EXP 176
90060: PUSH
90061: LD_INT 0
90063: ST_TO_ADDR
// sAI := false ;
90064: LD_ADDR_EXP 177
90068: PUSH
90069: LD_INT 0
90071: ST_TO_ADDR
// sCargo := false ;
90072: LD_ADDR_EXP 180
90076: PUSH
90077: LD_INT 0
90079: ST_TO_ADDR
// sDLaser := false ;
90080: LD_ADDR_EXP 181
90084: PUSH
90085: LD_INT 0
90087: ST_TO_ADDR
// sExchange := false ;
90088: LD_ADDR_EXP 182
90092: PUSH
90093: LD_INT 0
90095: ST_TO_ADDR
// sFac := false ;
90096: LD_ADDR_EXP 183
90100: PUSH
90101: LD_INT 0
90103: ST_TO_ADDR
// sPower := false ;
90104: LD_ADDR_EXP 184
90108: PUSH
90109: LD_INT 0
90111: ST_TO_ADDR
// sRandom := false ;
90112: LD_ADDR_EXP 185
90116: PUSH
90117: LD_INT 0
90119: ST_TO_ADDR
// sShield := false ;
90120: LD_ADDR_EXP 186
90124: PUSH
90125: LD_INT 0
90127: ST_TO_ADDR
// sTime := false ;
90128: LD_ADDR_EXP 187
90132: PUSH
90133: LD_INT 0
90135: ST_TO_ADDR
// sTools := false ;
90136: LD_ADDR_EXP 188
90140: PUSH
90141: LD_INT 0
90143: ST_TO_ADDR
// sSold := false ;
90144: LD_ADDR_EXP 153
90148: PUSH
90149: LD_INT 0
90151: ST_TO_ADDR
// sDiff := false ;
90152: LD_ADDR_EXP 154
90156: PUSH
90157: LD_INT 0
90159: ST_TO_ADDR
// sFog := false ;
90160: LD_ADDR_EXP 157
90164: PUSH
90165: LD_INT 0
90167: ST_TO_ADDR
// sReset := false ;
90168: LD_ADDR_EXP 158
90172: PUSH
90173: LD_INT 0
90175: ST_TO_ADDR
// sSun := false ;
90176: LD_ADDR_EXP 159
90180: PUSH
90181: LD_INT 0
90183: ST_TO_ADDR
// sTiger := false ;
90184: LD_ADDR_EXP 155
90188: PUSH
90189: LD_INT 0
90191: ST_TO_ADDR
// sBomb := false ;
90192: LD_ADDR_EXP 156
90196: PUSH
90197: LD_INT 0
90199: ST_TO_ADDR
// sWound := false ;
90200: LD_ADDR_EXP 164
90204: PUSH
90205: LD_INT 0
90207: ST_TO_ADDR
// sBetray := false ;
90208: LD_ADDR_EXP 168
90212: PUSH
90213: LD_INT 0
90215: ST_TO_ADDR
// sContamin := false ;
90216: LD_ADDR_EXP 169
90220: PUSH
90221: LD_INT 0
90223: ST_TO_ADDR
// sOil := false ;
90224: LD_ADDR_EXP 171
90228: PUSH
90229: LD_INT 0
90231: ST_TO_ADDR
// sStu := false ;
90232: LD_ADDR_EXP 175
90236: PUSH
90237: LD_INT 0
90239: ST_TO_ADDR
// sBazooka := false ;
90240: LD_ADDR_EXP 178
90244: PUSH
90245: LD_INT 0
90247: ST_TO_ADDR
// sMortar := false ;
90248: LD_ADDR_EXP 179
90252: PUSH
90253: LD_INT 0
90255: ST_TO_ADDR
// sRanger := false ;
90256: LD_ADDR_EXP 189
90260: PUSH
90261: LD_INT 0
90263: ST_TO_ADDR
// end ;
90264: LD_VAR 0 1
90268: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
90269: LD_INT 0
90271: PPUSH
90272: PPUSH
90273: PPUSH
90274: PPUSH
90275: PPUSH
// result := [ ] ;
90276: LD_ADDR_VAR 0 1
90280: PUSH
90281: EMPTY
90282: ST_TO_ADDR
// if campaign_id = 1 then
90283: LD_OWVAR 69
90287: PUSH
90288: LD_INT 1
90290: EQUAL
90291: IFFALSE 93229
// begin case mission_number of 1 :
90293: LD_OWVAR 70
90297: PUSH
90298: LD_INT 1
90300: DOUBLE
90301: EQUAL
90302: IFTRUE 90306
90304: GO 90370
90306: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
90307: LD_ADDR_VAR 0 1
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: LD_INT 4
90317: PUSH
90318: LD_INT 11
90320: PUSH
90321: LD_INT 12
90323: PUSH
90324: LD_INT 15
90326: PUSH
90327: LD_INT 16
90329: PUSH
90330: LD_INT 22
90332: PUSH
90333: LD_INT 23
90335: PUSH
90336: LD_INT 26
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 101
90352: PUSH
90353: LD_INT 102
90355: PUSH
90356: LD_INT 106
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: LIST
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: ST_TO_ADDR
90368: GO 93227
90370: LD_INT 2
90372: DOUBLE
90373: EQUAL
90374: IFTRUE 90378
90376: GO 90450
90378: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
90379: LD_ADDR_VAR 0 1
90383: PUSH
90384: LD_INT 2
90386: PUSH
90387: LD_INT 4
90389: PUSH
90390: LD_INT 11
90392: PUSH
90393: LD_INT 12
90395: PUSH
90396: LD_INT 15
90398: PUSH
90399: LD_INT 16
90401: PUSH
90402: LD_INT 22
90404: PUSH
90405: LD_INT 23
90407: PUSH
90408: LD_INT 26
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 101
90424: PUSH
90425: LD_INT 102
90427: PUSH
90428: LD_INT 105
90430: PUSH
90431: LD_INT 106
90433: PUSH
90434: LD_INT 108
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: ST_TO_ADDR
90448: GO 93227
90450: LD_INT 3
90452: DOUBLE
90453: EQUAL
90454: IFTRUE 90458
90456: GO 90534
90458: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
90459: LD_ADDR_VAR 0 1
90463: PUSH
90464: LD_INT 2
90466: PUSH
90467: LD_INT 4
90469: PUSH
90470: LD_INT 5
90472: PUSH
90473: LD_INT 11
90475: PUSH
90476: LD_INT 12
90478: PUSH
90479: LD_INT 15
90481: PUSH
90482: LD_INT 16
90484: PUSH
90485: LD_INT 22
90487: PUSH
90488: LD_INT 26
90490: PUSH
90491: LD_INT 36
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 101
90508: PUSH
90509: LD_INT 102
90511: PUSH
90512: LD_INT 105
90514: PUSH
90515: LD_INT 106
90517: PUSH
90518: LD_INT 108
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: ST_TO_ADDR
90532: GO 93227
90534: LD_INT 4
90536: DOUBLE
90537: EQUAL
90538: IFTRUE 90542
90540: GO 90626
90542: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
90543: LD_ADDR_VAR 0 1
90547: PUSH
90548: LD_INT 2
90550: PUSH
90551: LD_INT 4
90553: PUSH
90554: LD_INT 5
90556: PUSH
90557: LD_INT 8
90559: PUSH
90560: LD_INT 11
90562: PUSH
90563: LD_INT 12
90565: PUSH
90566: LD_INT 15
90568: PUSH
90569: LD_INT 16
90571: PUSH
90572: LD_INT 22
90574: PUSH
90575: LD_INT 23
90577: PUSH
90578: LD_INT 26
90580: PUSH
90581: LD_INT 36
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 101
90600: PUSH
90601: LD_INT 102
90603: PUSH
90604: LD_INT 105
90606: PUSH
90607: LD_INT 106
90609: PUSH
90610: LD_INT 108
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: ST_TO_ADDR
90624: GO 93227
90626: LD_INT 5
90628: DOUBLE
90629: EQUAL
90630: IFTRUE 90634
90632: GO 90734
90634: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90635: LD_ADDR_VAR 0 1
90639: PUSH
90640: LD_INT 2
90642: PUSH
90643: LD_INT 4
90645: PUSH
90646: LD_INT 5
90648: PUSH
90649: LD_INT 6
90651: PUSH
90652: LD_INT 8
90654: PUSH
90655: LD_INT 11
90657: PUSH
90658: LD_INT 12
90660: PUSH
90661: LD_INT 15
90663: PUSH
90664: LD_INT 16
90666: PUSH
90667: LD_INT 22
90669: PUSH
90670: LD_INT 23
90672: PUSH
90673: LD_INT 25
90675: PUSH
90676: LD_INT 26
90678: PUSH
90679: LD_INT 36
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 101
90700: PUSH
90701: LD_INT 102
90703: PUSH
90704: LD_INT 105
90706: PUSH
90707: LD_INT 106
90709: PUSH
90710: LD_INT 108
90712: PUSH
90713: LD_INT 109
90715: PUSH
90716: LD_INT 112
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: ST_TO_ADDR
90732: GO 93227
90734: LD_INT 6
90736: DOUBLE
90737: EQUAL
90738: IFTRUE 90742
90740: GO 90862
90742: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90743: LD_ADDR_VAR 0 1
90747: PUSH
90748: LD_INT 2
90750: PUSH
90751: LD_INT 4
90753: PUSH
90754: LD_INT 5
90756: PUSH
90757: LD_INT 6
90759: PUSH
90760: LD_INT 8
90762: PUSH
90763: LD_INT 11
90765: PUSH
90766: LD_INT 12
90768: PUSH
90769: LD_INT 15
90771: PUSH
90772: LD_INT 16
90774: PUSH
90775: LD_INT 20
90777: PUSH
90778: LD_INT 21
90780: PUSH
90781: LD_INT 22
90783: PUSH
90784: LD_INT 23
90786: PUSH
90787: LD_INT 25
90789: PUSH
90790: LD_INT 26
90792: PUSH
90793: LD_INT 30
90795: PUSH
90796: LD_INT 31
90798: PUSH
90799: LD_INT 32
90801: PUSH
90802: LD_INT 36
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 101
90828: PUSH
90829: LD_INT 102
90831: PUSH
90832: LD_INT 105
90834: PUSH
90835: LD_INT 106
90837: PUSH
90838: LD_INT 108
90840: PUSH
90841: LD_INT 109
90843: PUSH
90844: LD_INT 112
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: ST_TO_ADDR
90860: GO 93227
90862: LD_INT 7
90864: DOUBLE
90865: EQUAL
90866: IFTRUE 90870
90868: GO 90970
90870: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90871: LD_ADDR_VAR 0 1
90875: PUSH
90876: LD_INT 2
90878: PUSH
90879: LD_INT 4
90881: PUSH
90882: LD_INT 5
90884: PUSH
90885: LD_INT 7
90887: PUSH
90888: LD_INT 11
90890: PUSH
90891: LD_INT 12
90893: PUSH
90894: LD_INT 15
90896: PUSH
90897: LD_INT 16
90899: PUSH
90900: LD_INT 20
90902: PUSH
90903: LD_INT 21
90905: PUSH
90906: LD_INT 22
90908: PUSH
90909: LD_INT 23
90911: PUSH
90912: LD_INT 25
90914: PUSH
90915: LD_INT 26
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 101
90936: PUSH
90937: LD_INT 102
90939: PUSH
90940: LD_INT 103
90942: PUSH
90943: LD_INT 105
90945: PUSH
90946: LD_INT 106
90948: PUSH
90949: LD_INT 108
90951: PUSH
90952: LD_INT 112
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: ST_TO_ADDR
90968: GO 93227
90970: LD_INT 8
90972: DOUBLE
90973: EQUAL
90974: IFTRUE 90978
90976: GO 91106
90978: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90979: LD_ADDR_VAR 0 1
90983: PUSH
90984: LD_INT 2
90986: PUSH
90987: LD_INT 4
90989: PUSH
90990: LD_INT 5
90992: PUSH
90993: LD_INT 6
90995: PUSH
90996: LD_INT 7
90998: PUSH
90999: LD_INT 8
91001: PUSH
91002: LD_INT 11
91004: PUSH
91005: LD_INT 12
91007: PUSH
91008: LD_INT 15
91010: PUSH
91011: LD_INT 16
91013: PUSH
91014: LD_INT 20
91016: PUSH
91017: LD_INT 21
91019: PUSH
91020: LD_INT 22
91022: PUSH
91023: LD_INT 23
91025: PUSH
91026: LD_INT 25
91028: PUSH
91029: LD_INT 26
91031: PUSH
91032: LD_INT 30
91034: PUSH
91035: LD_INT 31
91037: PUSH
91038: LD_INT 32
91040: PUSH
91041: LD_INT 36
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 101
91068: PUSH
91069: LD_INT 102
91071: PUSH
91072: LD_INT 103
91074: PUSH
91075: LD_INT 105
91077: PUSH
91078: LD_INT 106
91080: PUSH
91081: LD_INT 108
91083: PUSH
91084: LD_INT 109
91086: PUSH
91087: LD_INT 112
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: ST_TO_ADDR
91104: GO 93227
91106: LD_INT 9
91108: DOUBLE
91109: EQUAL
91110: IFTRUE 91114
91112: GO 91250
91114: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
91115: LD_ADDR_VAR 0 1
91119: PUSH
91120: LD_INT 2
91122: PUSH
91123: LD_INT 4
91125: PUSH
91126: LD_INT 5
91128: PUSH
91129: LD_INT 6
91131: PUSH
91132: LD_INT 7
91134: PUSH
91135: LD_INT 8
91137: PUSH
91138: LD_INT 11
91140: PUSH
91141: LD_INT 12
91143: PUSH
91144: LD_INT 15
91146: PUSH
91147: LD_INT 16
91149: PUSH
91150: LD_INT 20
91152: PUSH
91153: LD_INT 21
91155: PUSH
91156: LD_INT 22
91158: PUSH
91159: LD_INT 23
91161: PUSH
91162: LD_INT 25
91164: PUSH
91165: LD_INT 26
91167: PUSH
91168: LD_INT 28
91170: PUSH
91171: LD_INT 30
91173: PUSH
91174: LD_INT 31
91176: PUSH
91177: LD_INT 32
91179: PUSH
91180: LD_INT 36
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 101
91208: PUSH
91209: LD_INT 102
91211: PUSH
91212: LD_INT 103
91214: PUSH
91215: LD_INT 105
91217: PUSH
91218: LD_INT 106
91220: PUSH
91221: LD_INT 108
91223: PUSH
91224: LD_INT 109
91226: PUSH
91227: LD_INT 112
91229: PUSH
91230: LD_INT 114
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: ST_TO_ADDR
91248: GO 93227
91250: LD_INT 10
91252: DOUBLE
91253: EQUAL
91254: IFTRUE 91258
91256: GO 91442
91258: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
91259: LD_ADDR_VAR 0 1
91263: PUSH
91264: LD_INT 2
91266: PUSH
91267: LD_INT 4
91269: PUSH
91270: LD_INT 5
91272: PUSH
91273: LD_INT 6
91275: PUSH
91276: LD_INT 7
91278: PUSH
91279: LD_INT 8
91281: PUSH
91282: LD_INT 9
91284: PUSH
91285: LD_INT 10
91287: PUSH
91288: LD_INT 11
91290: PUSH
91291: LD_INT 12
91293: PUSH
91294: LD_INT 13
91296: PUSH
91297: LD_INT 14
91299: PUSH
91300: LD_INT 15
91302: PUSH
91303: LD_INT 16
91305: PUSH
91306: LD_INT 17
91308: PUSH
91309: LD_INT 18
91311: PUSH
91312: LD_INT 19
91314: PUSH
91315: LD_INT 20
91317: PUSH
91318: LD_INT 21
91320: PUSH
91321: LD_INT 22
91323: PUSH
91324: LD_INT 23
91326: PUSH
91327: LD_INT 24
91329: PUSH
91330: LD_INT 25
91332: PUSH
91333: LD_INT 26
91335: PUSH
91336: LD_INT 28
91338: PUSH
91339: LD_INT 30
91341: PUSH
91342: LD_INT 31
91344: PUSH
91345: LD_INT 32
91347: PUSH
91348: LD_INT 36
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: PUSH
91382: LD_INT 101
91384: PUSH
91385: LD_INT 102
91387: PUSH
91388: LD_INT 103
91390: PUSH
91391: LD_INT 104
91393: PUSH
91394: LD_INT 105
91396: PUSH
91397: LD_INT 106
91399: PUSH
91400: LD_INT 107
91402: PUSH
91403: LD_INT 108
91405: PUSH
91406: LD_INT 109
91408: PUSH
91409: LD_INT 110
91411: PUSH
91412: LD_INT 111
91414: PUSH
91415: LD_INT 112
91417: PUSH
91418: LD_INT 114
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: ST_TO_ADDR
91440: GO 93227
91442: LD_INT 11
91444: DOUBLE
91445: EQUAL
91446: IFTRUE 91450
91448: GO 91642
91450: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
91451: LD_ADDR_VAR 0 1
91455: PUSH
91456: LD_INT 2
91458: PUSH
91459: LD_INT 3
91461: PUSH
91462: LD_INT 4
91464: PUSH
91465: LD_INT 5
91467: PUSH
91468: LD_INT 6
91470: PUSH
91471: LD_INT 7
91473: PUSH
91474: LD_INT 8
91476: PUSH
91477: LD_INT 9
91479: PUSH
91480: LD_INT 10
91482: PUSH
91483: LD_INT 11
91485: PUSH
91486: LD_INT 12
91488: PUSH
91489: LD_INT 13
91491: PUSH
91492: LD_INT 14
91494: PUSH
91495: LD_INT 15
91497: PUSH
91498: LD_INT 16
91500: PUSH
91501: LD_INT 17
91503: PUSH
91504: LD_INT 18
91506: PUSH
91507: LD_INT 19
91509: PUSH
91510: LD_INT 20
91512: PUSH
91513: LD_INT 21
91515: PUSH
91516: LD_INT 22
91518: PUSH
91519: LD_INT 23
91521: PUSH
91522: LD_INT 24
91524: PUSH
91525: LD_INT 25
91527: PUSH
91528: LD_INT 26
91530: PUSH
91531: LD_INT 28
91533: PUSH
91534: LD_INT 30
91536: PUSH
91537: LD_INT 31
91539: PUSH
91540: LD_INT 32
91542: PUSH
91543: LD_INT 34
91545: PUSH
91546: LD_INT 36
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 101
91584: PUSH
91585: LD_INT 102
91587: PUSH
91588: LD_INT 103
91590: PUSH
91591: LD_INT 104
91593: PUSH
91594: LD_INT 105
91596: PUSH
91597: LD_INT 106
91599: PUSH
91600: LD_INT 107
91602: PUSH
91603: LD_INT 108
91605: PUSH
91606: LD_INT 109
91608: PUSH
91609: LD_INT 110
91611: PUSH
91612: LD_INT 111
91614: PUSH
91615: LD_INT 112
91617: PUSH
91618: LD_INT 114
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: ST_TO_ADDR
91640: GO 93227
91642: LD_INT 12
91644: DOUBLE
91645: EQUAL
91646: IFTRUE 91650
91648: GO 91858
91650: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91651: LD_ADDR_VAR 0 1
91655: PUSH
91656: LD_INT 1
91658: PUSH
91659: LD_INT 2
91661: PUSH
91662: LD_INT 3
91664: PUSH
91665: LD_INT 4
91667: PUSH
91668: LD_INT 5
91670: PUSH
91671: LD_INT 6
91673: PUSH
91674: LD_INT 7
91676: PUSH
91677: LD_INT 8
91679: PUSH
91680: LD_INT 9
91682: PUSH
91683: LD_INT 10
91685: PUSH
91686: LD_INT 11
91688: PUSH
91689: LD_INT 12
91691: PUSH
91692: LD_INT 13
91694: PUSH
91695: LD_INT 14
91697: PUSH
91698: LD_INT 15
91700: PUSH
91701: LD_INT 16
91703: PUSH
91704: LD_INT 17
91706: PUSH
91707: LD_INT 18
91709: PUSH
91710: LD_INT 19
91712: PUSH
91713: LD_INT 20
91715: PUSH
91716: LD_INT 21
91718: PUSH
91719: LD_INT 22
91721: PUSH
91722: LD_INT 23
91724: PUSH
91725: LD_INT 24
91727: PUSH
91728: LD_INT 25
91730: PUSH
91731: LD_INT 26
91733: PUSH
91734: LD_INT 27
91736: PUSH
91737: LD_INT 28
91739: PUSH
91740: LD_INT 30
91742: PUSH
91743: LD_INT 31
91745: PUSH
91746: LD_INT 32
91748: PUSH
91749: LD_INT 33
91751: PUSH
91752: LD_INT 34
91754: PUSH
91755: LD_INT 36
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 101
91796: PUSH
91797: LD_INT 102
91799: PUSH
91800: LD_INT 103
91802: PUSH
91803: LD_INT 104
91805: PUSH
91806: LD_INT 105
91808: PUSH
91809: LD_INT 106
91811: PUSH
91812: LD_INT 107
91814: PUSH
91815: LD_INT 108
91817: PUSH
91818: LD_INT 109
91820: PUSH
91821: LD_INT 110
91823: PUSH
91824: LD_INT 111
91826: PUSH
91827: LD_INT 112
91829: PUSH
91830: LD_INT 113
91832: PUSH
91833: LD_INT 114
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: ST_TO_ADDR
91856: GO 93227
91858: LD_INT 13
91860: DOUBLE
91861: EQUAL
91862: IFTRUE 91866
91864: GO 92062
91866: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91867: LD_ADDR_VAR 0 1
91871: PUSH
91872: LD_INT 1
91874: PUSH
91875: LD_INT 2
91877: PUSH
91878: LD_INT 3
91880: PUSH
91881: LD_INT 4
91883: PUSH
91884: LD_INT 5
91886: PUSH
91887: LD_INT 8
91889: PUSH
91890: LD_INT 9
91892: PUSH
91893: LD_INT 10
91895: PUSH
91896: LD_INT 11
91898: PUSH
91899: LD_INT 12
91901: PUSH
91902: LD_INT 14
91904: PUSH
91905: LD_INT 15
91907: PUSH
91908: LD_INT 16
91910: PUSH
91911: LD_INT 17
91913: PUSH
91914: LD_INT 18
91916: PUSH
91917: LD_INT 19
91919: PUSH
91920: LD_INT 20
91922: PUSH
91923: LD_INT 21
91925: PUSH
91926: LD_INT 22
91928: PUSH
91929: LD_INT 23
91931: PUSH
91932: LD_INT 24
91934: PUSH
91935: LD_INT 25
91937: PUSH
91938: LD_INT 26
91940: PUSH
91941: LD_INT 27
91943: PUSH
91944: LD_INT 28
91946: PUSH
91947: LD_INT 30
91949: PUSH
91950: LD_INT 31
91952: PUSH
91953: LD_INT 32
91955: PUSH
91956: LD_INT 33
91958: PUSH
91959: LD_INT 34
91961: PUSH
91962: LD_INT 36
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 101
92000: PUSH
92001: LD_INT 102
92003: PUSH
92004: LD_INT 103
92006: PUSH
92007: LD_INT 104
92009: PUSH
92010: LD_INT 105
92012: PUSH
92013: LD_INT 106
92015: PUSH
92016: LD_INT 107
92018: PUSH
92019: LD_INT 108
92021: PUSH
92022: LD_INT 109
92024: PUSH
92025: LD_INT 110
92027: PUSH
92028: LD_INT 111
92030: PUSH
92031: LD_INT 112
92033: PUSH
92034: LD_INT 113
92036: PUSH
92037: LD_INT 114
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: ST_TO_ADDR
92060: GO 93227
92062: LD_INT 14
92064: DOUBLE
92065: EQUAL
92066: IFTRUE 92070
92068: GO 92282
92070: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
92071: LD_ADDR_VAR 0 1
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 2
92081: PUSH
92082: LD_INT 3
92084: PUSH
92085: LD_INT 4
92087: PUSH
92088: LD_INT 5
92090: PUSH
92091: LD_INT 6
92093: PUSH
92094: LD_INT 7
92096: PUSH
92097: LD_INT 8
92099: PUSH
92100: LD_INT 9
92102: PUSH
92103: LD_INT 10
92105: PUSH
92106: LD_INT 11
92108: PUSH
92109: LD_INT 12
92111: PUSH
92112: LD_INT 13
92114: PUSH
92115: LD_INT 14
92117: PUSH
92118: LD_INT 15
92120: PUSH
92121: LD_INT 16
92123: PUSH
92124: LD_INT 17
92126: PUSH
92127: LD_INT 18
92129: PUSH
92130: LD_INT 19
92132: PUSH
92133: LD_INT 20
92135: PUSH
92136: LD_INT 21
92138: PUSH
92139: LD_INT 22
92141: PUSH
92142: LD_INT 23
92144: PUSH
92145: LD_INT 24
92147: PUSH
92148: LD_INT 25
92150: PUSH
92151: LD_INT 26
92153: PUSH
92154: LD_INT 27
92156: PUSH
92157: LD_INT 28
92159: PUSH
92160: LD_INT 29
92162: PUSH
92163: LD_INT 30
92165: PUSH
92166: LD_INT 31
92168: PUSH
92169: LD_INT 32
92171: PUSH
92172: LD_INT 33
92174: PUSH
92175: LD_INT 34
92177: PUSH
92178: LD_INT 36
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 101
92220: PUSH
92221: LD_INT 102
92223: PUSH
92224: LD_INT 103
92226: PUSH
92227: LD_INT 104
92229: PUSH
92230: LD_INT 105
92232: PUSH
92233: LD_INT 106
92235: PUSH
92236: LD_INT 107
92238: PUSH
92239: LD_INT 108
92241: PUSH
92242: LD_INT 109
92244: PUSH
92245: LD_INT 110
92247: PUSH
92248: LD_INT 111
92250: PUSH
92251: LD_INT 112
92253: PUSH
92254: LD_INT 113
92256: PUSH
92257: LD_INT 114
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: ST_TO_ADDR
92280: GO 93227
92282: LD_INT 15
92284: DOUBLE
92285: EQUAL
92286: IFTRUE 92290
92288: GO 92502
92290: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
92291: LD_ADDR_VAR 0 1
92295: PUSH
92296: LD_INT 1
92298: PUSH
92299: LD_INT 2
92301: PUSH
92302: LD_INT 3
92304: PUSH
92305: LD_INT 4
92307: PUSH
92308: LD_INT 5
92310: PUSH
92311: LD_INT 6
92313: PUSH
92314: LD_INT 7
92316: PUSH
92317: LD_INT 8
92319: PUSH
92320: LD_INT 9
92322: PUSH
92323: LD_INT 10
92325: PUSH
92326: LD_INT 11
92328: PUSH
92329: LD_INT 12
92331: PUSH
92332: LD_INT 13
92334: PUSH
92335: LD_INT 14
92337: PUSH
92338: LD_INT 15
92340: PUSH
92341: LD_INT 16
92343: PUSH
92344: LD_INT 17
92346: PUSH
92347: LD_INT 18
92349: PUSH
92350: LD_INT 19
92352: PUSH
92353: LD_INT 20
92355: PUSH
92356: LD_INT 21
92358: PUSH
92359: LD_INT 22
92361: PUSH
92362: LD_INT 23
92364: PUSH
92365: LD_INT 24
92367: PUSH
92368: LD_INT 25
92370: PUSH
92371: LD_INT 26
92373: PUSH
92374: LD_INT 27
92376: PUSH
92377: LD_INT 28
92379: PUSH
92380: LD_INT 29
92382: PUSH
92383: LD_INT 30
92385: PUSH
92386: LD_INT 31
92388: PUSH
92389: LD_INT 32
92391: PUSH
92392: LD_INT 33
92394: PUSH
92395: LD_INT 34
92397: PUSH
92398: LD_INT 36
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: PUSH
92438: LD_INT 101
92440: PUSH
92441: LD_INT 102
92443: PUSH
92444: LD_INT 103
92446: PUSH
92447: LD_INT 104
92449: PUSH
92450: LD_INT 105
92452: PUSH
92453: LD_INT 106
92455: PUSH
92456: LD_INT 107
92458: PUSH
92459: LD_INT 108
92461: PUSH
92462: LD_INT 109
92464: PUSH
92465: LD_INT 110
92467: PUSH
92468: LD_INT 111
92470: PUSH
92471: LD_INT 112
92473: PUSH
92474: LD_INT 113
92476: PUSH
92477: LD_INT 114
92479: PUSH
92480: EMPTY
92481: LIST
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: ST_TO_ADDR
92500: GO 93227
92502: LD_INT 16
92504: DOUBLE
92505: EQUAL
92506: IFTRUE 92510
92508: GO 92634
92510: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
92511: LD_ADDR_VAR 0 1
92515: PUSH
92516: LD_INT 2
92518: PUSH
92519: LD_INT 4
92521: PUSH
92522: LD_INT 5
92524: PUSH
92525: LD_INT 7
92527: PUSH
92528: LD_INT 11
92530: PUSH
92531: LD_INT 12
92533: PUSH
92534: LD_INT 15
92536: PUSH
92537: LD_INT 16
92539: PUSH
92540: LD_INT 20
92542: PUSH
92543: LD_INT 21
92545: PUSH
92546: LD_INT 22
92548: PUSH
92549: LD_INT 23
92551: PUSH
92552: LD_INT 25
92554: PUSH
92555: LD_INT 26
92557: PUSH
92558: LD_INT 30
92560: PUSH
92561: LD_INT 31
92563: PUSH
92564: LD_INT 32
92566: PUSH
92567: LD_INT 33
92569: PUSH
92570: LD_INT 34
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 101
92596: PUSH
92597: LD_INT 102
92599: PUSH
92600: LD_INT 103
92602: PUSH
92603: LD_INT 106
92605: PUSH
92606: LD_INT 108
92608: PUSH
92609: LD_INT 112
92611: PUSH
92612: LD_INT 113
92614: PUSH
92615: LD_INT 114
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: ST_TO_ADDR
92632: GO 93227
92634: LD_INT 17
92636: DOUBLE
92637: EQUAL
92638: IFTRUE 92642
92640: GO 92854
92642: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92643: LD_ADDR_VAR 0 1
92647: PUSH
92648: LD_INT 1
92650: PUSH
92651: LD_INT 2
92653: PUSH
92654: LD_INT 3
92656: PUSH
92657: LD_INT 4
92659: PUSH
92660: LD_INT 5
92662: PUSH
92663: LD_INT 6
92665: PUSH
92666: LD_INT 7
92668: PUSH
92669: LD_INT 8
92671: PUSH
92672: LD_INT 9
92674: PUSH
92675: LD_INT 10
92677: PUSH
92678: LD_INT 11
92680: PUSH
92681: LD_INT 12
92683: PUSH
92684: LD_INT 13
92686: PUSH
92687: LD_INT 14
92689: PUSH
92690: LD_INT 15
92692: PUSH
92693: LD_INT 16
92695: PUSH
92696: LD_INT 17
92698: PUSH
92699: LD_INT 18
92701: PUSH
92702: LD_INT 19
92704: PUSH
92705: LD_INT 20
92707: PUSH
92708: LD_INT 21
92710: PUSH
92711: LD_INT 22
92713: PUSH
92714: LD_INT 23
92716: PUSH
92717: LD_INT 24
92719: PUSH
92720: LD_INT 25
92722: PUSH
92723: LD_INT 26
92725: PUSH
92726: LD_INT 27
92728: PUSH
92729: LD_INT 28
92731: PUSH
92732: LD_INT 29
92734: PUSH
92735: LD_INT 30
92737: PUSH
92738: LD_INT 31
92740: PUSH
92741: LD_INT 32
92743: PUSH
92744: LD_INT 33
92746: PUSH
92747: LD_INT 34
92749: PUSH
92750: LD_INT 36
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: PUSH
92790: LD_INT 101
92792: PUSH
92793: LD_INT 102
92795: PUSH
92796: LD_INT 103
92798: PUSH
92799: LD_INT 104
92801: PUSH
92802: LD_INT 105
92804: PUSH
92805: LD_INT 106
92807: PUSH
92808: LD_INT 107
92810: PUSH
92811: LD_INT 108
92813: PUSH
92814: LD_INT 109
92816: PUSH
92817: LD_INT 110
92819: PUSH
92820: LD_INT 111
92822: PUSH
92823: LD_INT 112
92825: PUSH
92826: LD_INT 113
92828: PUSH
92829: LD_INT 114
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: ST_TO_ADDR
92852: GO 93227
92854: LD_INT 18
92856: DOUBLE
92857: EQUAL
92858: IFTRUE 92862
92860: GO 92998
92862: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92863: LD_ADDR_VAR 0 1
92867: PUSH
92868: LD_INT 2
92870: PUSH
92871: LD_INT 4
92873: PUSH
92874: LD_INT 5
92876: PUSH
92877: LD_INT 7
92879: PUSH
92880: LD_INT 11
92882: PUSH
92883: LD_INT 12
92885: PUSH
92886: LD_INT 15
92888: PUSH
92889: LD_INT 16
92891: PUSH
92892: LD_INT 20
92894: PUSH
92895: LD_INT 21
92897: PUSH
92898: LD_INT 22
92900: PUSH
92901: LD_INT 23
92903: PUSH
92904: LD_INT 25
92906: PUSH
92907: LD_INT 26
92909: PUSH
92910: LD_INT 30
92912: PUSH
92913: LD_INT 31
92915: PUSH
92916: LD_INT 32
92918: PUSH
92919: LD_INT 33
92921: PUSH
92922: LD_INT 34
92924: PUSH
92925: LD_INT 35
92927: PUSH
92928: LD_INT 36
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 101
92956: PUSH
92957: LD_INT 102
92959: PUSH
92960: LD_INT 103
92962: PUSH
92963: LD_INT 106
92965: PUSH
92966: LD_INT 108
92968: PUSH
92969: LD_INT 112
92971: PUSH
92972: LD_INT 113
92974: PUSH
92975: LD_INT 114
92977: PUSH
92978: LD_INT 115
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: ST_TO_ADDR
92996: GO 93227
92998: LD_INT 19
93000: DOUBLE
93001: EQUAL
93002: IFTRUE 93006
93004: GO 93226
93006: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
93007: LD_ADDR_VAR 0 1
93011: PUSH
93012: LD_INT 1
93014: PUSH
93015: LD_INT 2
93017: PUSH
93018: LD_INT 3
93020: PUSH
93021: LD_INT 4
93023: PUSH
93024: LD_INT 5
93026: PUSH
93027: LD_INT 6
93029: PUSH
93030: LD_INT 7
93032: PUSH
93033: LD_INT 8
93035: PUSH
93036: LD_INT 9
93038: PUSH
93039: LD_INT 10
93041: PUSH
93042: LD_INT 11
93044: PUSH
93045: LD_INT 12
93047: PUSH
93048: LD_INT 13
93050: PUSH
93051: LD_INT 14
93053: PUSH
93054: LD_INT 15
93056: PUSH
93057: LD_INT 16
93059: PUSH
93060: LD_INT 17
93062: PUSH
93063: LD_INT 18
93065: PUSH
93066: LD_INT 19
93068: PUSH
93069: LD_INT 20
93071: PUSH
93072: LD_INT 21
93074: PUSH
93075: LD_INT 22
93077: PUSH
93078: LD_INT 23
93080: PUSH
93081: LD_INT 24
93083: PUSH
93084: LD_INT 25
93086: PUSH
93087: LD_INT 26
93089: PUSH
93090: LD_INT 27
93092: PUSH
93093: LD_INT 28
93095: PUSH
93096: LD_INT 29
93098: PUSH
93099: LD_INT 30
93101: PUSH
93102: LD_INT 31
93104: PUSH
93105: LD_INT 32
93107: PUSH
93108: LD_INT 33
93110: PUSH
93111: LD_INT 34
93113: PUSH
93114: LD_INT 35
93116: PUSH
93117: LD_INT 36
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: PUSH
93158: LD_INT 101
93160: PUSH
93161: LD_INT 102
93163: PUSH
93164: LD_INT 103
93166: PUSH
93167: LD_INT 104
93169: PUSH
93170: LD_INT 105
93172: PUSH
93173: LD_INT 106
93175: PUSH
93176: LD_INT 107
93178: PUSH
93179: LD_INT 108
93181: PUSH
93182: LD_INT 109
93184: PUSH
93185: LD_INT 110
93187: PUSH
93188: LD_INT 111
93190: PUSH
93191: LD_INT 112
93193: PUSH
93194: LD_INT 113
93196: PUSH
93197: LD_INT 114
93199: PUSH
93200: LD_INT 115
93202: PUSH
93203: EMPTY
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: ST_TO_ADDR
93224: GO 93227
93226: POP
// end else
93227: GO 93446
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
93229: LD_ADDR_VAR 0 1
93233: PUSH
93234: LD_INT 1
93236: PUSH
93237: LD_INT 2
93239: PUSH
93240: LD_INT 3
93242: PUSH
93243: LD_INT 4
93245: PUSH
93246: LD_INT 5
93248: PUSH
93249: LD_INT 6
93251: PUSH
93252: LD_INT 7
93254: PUSH
93255: LD_INT 8
93257: PUSH
93258: LD_INT 9
93260: PUSH
93261: LD_INT 10
93263: PUSH
93264: LD_INT 11
93266: PUSH
93267: LD_INT 12
93269: PUSH
93270: LD_INT 13
93272: PUSH
93273: LD_INT 14
93275: PUSH
93276: LD_INT 15
93278: PUSH
93279: LD_INT 16
93281: PUSH
93282: LD_INT 17
93284: PUSH
93285: LD_INT 18
93287: PUSH
93288: LD_INT 19
93290: PUSH
93291: LD_INT 20
93293: PUSH
93294: LD_INT 21
93296: PUSH
93297: LD_INT 22
93299: PUSH
93300: LD_INT 23
93302: PUSH
93303: LD_INT 24
93305: PUSH
93306: LD_INT 25
93308: PUSH
93309: LD_INT 26
93311: PUSH
93312: LD_INT 27
93314: PUSH
93315: LD_INT 28
93317: PUSH
93318: LD_INT 29
93320: PUSH
93321: LD_INT 30
93323: PUSH
93324: LD_INT 31
93326: PUSH
93327: LD_INT 32
93329: PUSH
93330: LD_INT 33
93332: PUSH
93333: LD_INT 34
93335: PUSH
93336: LD_INT 35
93338: PUSH
93339: LD_INT 36
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 101
93382: PUSH
93383: LD_INT 102
93385: PUSH
93386: LD_INT 103
93388: PUSH
93389: LD_INT 104
93391: PUSH
93392: LD_INT 105
93394: PUSH
93395: LD_INT 106
93397: PUSH
93398: LD_INT 107
93400: PUSH
93401: LD_INT 108
93403: PUSH
93404: LD_INT 109
93406: PUSH
93407: LD_INT 110
93409: PUSH
93410: LD_INT 111
93412: PUSH
93413: LD_INT 112
93415: PUSH
93416: LD_INT 113
93418: PUSH
93419: LD_INT 114
93421: PUSH
93422: LD_INT 115
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: ST_TO_ADDR
// if result then
93446: LD_VAR 0 1
93450: IFFALSE 93739
// begin normal :=  ;
93452: LD_ADDR_VAR 0 3
93456: PUSH
93457: LD_STRING 
93459: ST_TO_ADDR
// hardcore :=  ;
93460: LD_ADDR_VAR 0 4
93464: PUSH
93465: LD_STRING 
93467: ST_TO_ADDR
// for i = 1 to normalCounter do
93468: LD_ADDR_VAR 0 5
93472: PUSH
93473: DOUBLE
93474: LD_INT 1
93476: DEC
93477: ST_TO_ADDR
93478: LD_EXP 137
93482: PUSH
93483: FOR_TO
93484: IFFALSE 93585
// begin tmp := 0 ;
93486: LD_ADDR_VAR 0 2
93490: PUSH
93491: LD_STRING 0
93493: ST_TO_ADDR
// if result [ 1 ] then
93494: LD_VAR 0 1
93498: PUSH
93499: LD_INT 1
93501: ARRAY
93502: IFFALSE 93567
// if result [ 1 ] [ 1 ] = i then
93504: LD_VAR 0 1
93508: PUSH
93509: LD_INT 1
93511: ARRAY
93512: PUSH
93513: LD_INT 1
93515: ARRAY
93516: PUSH
93517: LD_VAR 0 5
93521: EQUAL
93522: IFFALSE 93567
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93524: LD_ADDR_VAR 0 1
93528: PUSH
93529: LD_VAR 0 1
93533: PPUSH
93534: LD_INT 1
93536: PPUSH
93537: LD_VAR 0 1
93541: PUSH
93542: LD_INT 1
93544: ARRAY
93545: PPUSH
93546: LD_INT 1
93548: PPUSH
93549: CALL_OW 3
93553: PPUSH
93554: CALL_OW 1
93558: ST_TO_ADDR
// tmp := 1 ;
93559: LD_ADDR_VAR 0 2
93563: PUSH
93564: LD_STRING 1
93566: ST_TO_ADDR
// end ; normal := normal & tmp ;
93567: LD_ADDR_VAR 0 3
93571: PUSH
93572: LD_VAR 0 3
93576: PUSH
93577: LD_VAR 0 2
93581: STR
93582: ST_TO_ADDR
// end ;
93583: GO 93483
93585: POP
93586: POP
// for i = 1 to hardcoreCounter do
93587: LD_ADDR_VAR 0 5
93591: PUSH
93592: DOUBLE
93593: LD_INT 1
93595: DEC
93596: ST_TO_ADDR
93597: LD_EXP 138
93601: PUSH
93602: FOR_TO
93603: IFFALSE 93708
// begin tmp := 0 ;
93605: LD_ADDR_VAR 0 2
93609: PUSH
93610: LD_STRING 0
93612: ST_TO_ADDR
// if result [ 2 ] then
93613: LD_VAR 0 1
93617: PUSH
93618: LD_INT 2
93620: ARRAY
93621: IFFALSE 93690
// if result [ 2 ] [ 1 ] = 100 + i then
93623: LD_VAR 0 1
93627: PUSH
93628: LD_INT 2
93630: ARRAY
93631: PUSH
93632: LD_INT 1
93634: ARRAY
93635: PUSH
93636: LD_INT 100
93638: PUSH
93639: LD_VAR 0 5
93643: PLUS
93644: EQUAL
93645: IFFALSE 93690
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93647: LD_ADDR_VAR 0 1
93651: PUSH
93652: LD_VAR 0 1
93656: PPUSH
93657: LD_INT 2
93659: PPUSH
93660: LD_VAR 0 1
93664: PUSH
93665: LD_INT 2
93667: ARRAY
93668: PPUSH
93669: LD_INT 1
93671: PPUSH
93672: CALL_OW 3
93676: PPUSH
93677: CALL_OW 1
93681: ST_TO_ADDR
// tmp := 1 ;
93682: LD_ADDR_VAR 0 2
93686: PUSH
93687: LD_STRING 1
93689: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93690: LD_ADDR_VAR 0 4
93694: PUSH
93695: LD_VAR 0 4
93699: PUSH
93700: LD_VAR 0 2
93704: STR
93705: ST_TO_ADDR
// end ;
93706: GO 93602
93708: POP
93709: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93710: LD_STRING getStreamItemsFromMission("
93712: PUSH
93713: LD_VAR 0 3
93717: STR
93718: PUSH
93719: LD_STRING ","
93721: STR
93722: PUSH
93723: LD_VAR 0 4
93727: STR
93728: PUSH
93729: LD_STRING ")
93731: STR
93732: PPUSH
93733: CALL_OW 559
// end else
93737: GO 93746
// ToLua ( getStreamItemsFromMission("","") ) ;
93739: LD_STRING getStreamItemsFromMission("","")
93741: PPUSH
93742: CALL_OW 559
// end ;
93746: LD_VAR 0 1
93750: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93751: LD_EXP 136
93755: PUSH
93756: LD_EXP 141
93760: AND
93761: IFFALSE 93885
93763: GO 93765
93765: DISABLE
93766: LD_INT 0
93768: PPUSH
93769: PPUSH
// begin enable ;
93770: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93771: LD_ADDR_VAR 0 2
93775: PUSH
93776: LD_INT 22
93778: PUSH
93779: LD_OWVAR 2
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: PUSH
93788: LD_INT 2
93790: PUSH
93791: LD_INT 34
93793: PUSH
93794: LD_INT 7
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 34
93803: PUSH
93804: LD_INT 45
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: PUSH
93811: LD_INT 34
93813: PUSH
93814: LD_INT 28
93816: PUSH
93817: EMPTY
93818: LIST
93819: LIST
93820: PUSH
93821: LD_INT 34
93823: PUSH
93824: LD_INT 47
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PPUSH
93842: CALL_OW 69
93846: ST_TO_ADDR
// if not tmp then
93847: LD_VAR 0 2
93851: NOT
93852: IFFALSE 93856
// exit ;
93854: GO 93885
// for i in tmp do
93856: LD_ADDR_VAR 0 1
93860: PUSH
93861: LD_VAR 0 2
93865: PUSH
93866: FOR_IN
93867: IFFALSE 93883
// begin SetLives ( i , 0 ) ;
93869: LD_VAR 0 1
93873: PPUSH
93874: LD_INT 0
93876: PPUSH
93877: CALL_OW 234
// end ;
93881: GO 93866
93883: POP
93884: POP
// end ;
93885: PPOPN 2
93887: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93888: LD_EXP 136
93892: PUSH
93893: LD_EXP 142
93897: AND
93898: IFFALSE 93982
93900: GO 93902
93902: DISABLE
93903: LD_INT 0
93905: PPUSH
93906: PPUSH
// begin enable ;
93907: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93908: LD_ADDR_VAR 0 2
93912: PUSH
93913: LD_INT 22
93915: PUSH
93916: LD_OWVAR 2
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 32
93927: PUSH
93928: LD_INT 3
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PPUSH
93939: CALL_OW 69
93943: ST_TO_ADDR
// if not tmp then
93944: LD_VAR 0 2
93948: NOT
93949: IFFALSE 93953
// exit ;
93951: GO 93982
// for i in tmp do
93953: LD_ADDR_VAR 0 1
93957: PUSH
93958: LD_VAR 0 2
93962: PUSH
93963: FOR_IN
93964: IFFALSE 93980
// begin SetLives ( i , 0 ) ;
93966: LD_VAR 0 1
93970: PPUSH
93971: LD_INT 0
93973: PPUSH
93974: CALL_OW 234
// end ;
93978: GO 93963
93980: POP
93981: POP
// end ;
93982: PPOPN 2
93984: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93985: LD_EXP 136
93989: PUSH
93990: LD_EXP 139
93994: AND
93995: IFFALSE 94088
93997: GO 93999
93999: DISABLE
94000: LD_INT 0
94002: PPUSH
// begin enable ;
94003: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94004: LD_ADDR_VAR 0 1
94008: PUSH
94009: LD_INT 22
94011: PUSH
94012: LD_OWVAR 2
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 2
94023: PUSH
94024: LD_INT 25
94026: PUSH
94027: LD_INT 5
94029: PUSH
94030: EMPTY
94031: LIST
94032: LIST
94033: PUSH
94034: LD_INT 25
94036: PUSH
94037: LD_INT 9
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 25
94046: PUSH
94047: LD_INT 8
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PPUSH
94064: CALL_OW 69
94068: PUSH
94069: FOR_IN
94070: IFFALSE 94086
// begin SetClass ( i , 1 ) ;
94072: LD_VAR 0 1
94076: PPUSH
94077: LD_INT 1
94079: PPUSH
94080: CALL_OW 336
// end ;
94084: GO 94069
94086: POP
94087: POP
// end ;
94088: PPOPN 1
94090: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94091: LD_EXP 136
94095: PUSH
94096: LD_EXP 140
94100: AND
94101: PUSH
94102: LD_OWVAR 65
94106: PUSH
94107: LD_INT 7
94109: LESS
94110: AND
94111: IFFALSE 94125
94113: GO 94115
94115: DISABLE
// begin enable ;
94116: ENABLE
// game_speed := 7 ;
94117: LD_ADDR_OWVAR 65
94121: PUSH
94122: LD_INT 7
94124: ST_TO_ADDR
// end ;
94125: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94126: LD_EXP 136
94130: PUSH
94131: LD_EXP 143
94135: AND
94136: IFFALSE 94338
94138: GO 94140
94140: DISABLE
94141: LD_INT 0
94143: PPUSH
94144: PPUSH
94145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94146: LD_ADDR_VAR 0 3
94150: PUSH
94151: LD_INT 81
94153: PUSH
94154: LD_OWVAR 2
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 21
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PPUSH
94177: CALL_OW 69
94181: ST_TO_ADDR
// if not tmp then
94182: LD_VAR 0 3
94186: NOT
94187: IFFALSE 94191
// exit ;
94189: GO 94338
// if tmp > 5 then
94191: LD_VAR 0 3
94195: PUSH
94196: LD_INT 5
94198: GREATER
94199: IFFALSE 94211
// k := 5 else
94201: LD_ADDR_VAR 0 2
94205: PUSH
94206: LD_INT 5
94208: ST_TO_ADDR
94209: GO 94221
// k := tmp ;
94211: LD_ADDR_VAR 0 2
94215: PUSH
94216: LD_VAR 0 3
94220: ST_TO_ADDR
// for i := 1 to k do
94221: LD_ADDR_VAR 0 1
94225: PUSH
94226: DOUBLE
94227: LD_INT 1
94229: DEC
94230: ST_TO_ADDR
94231: LD_VAR 0 2
94235: PUSH
94236: FOR_TO
94237: IFFALSE 94336
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94239: LD_VAR 0 3
94243: PUSH
94244: LD_VAR 0 1
94248: ARRAY
94249: PPUSH
94250: LD_VAR 0 1
94254: PUSH
94255: LD_INT 4
94257: MOD
94258: PUSH
94259: LD_INT 1
94261: PLUS
94262: PPUSH
94263: CALL_OW 259
94267: PUSH
94268: LD_INT 10
94270: LESS
94271: IFFALSE 94334
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94273: LD_VAR 0 3
94277: PUSH
94278: LD_VAR 0 1
94282: ARRAY
94283: PPUSH
94284: LD_VAR 0 1
94288: PUSH
94289: LD_INT 4
94291: MOD
94292: PUSH
94293: LD_INT 1
94295: PLUS
94296: PPUSH
94297: LD_VAR 0 3
94301: PUSH
94302: LD_VAR 0 1
94306: ARRAY
94307: PPUSH
94308: LD_VAR 0 1
94312: PUSH
94313: LD_INT 4
94315: MOD
94316: PUSH
94317: LD_INT 1
94319: PLUS
94320: PPUSH
94321: CALL_OW 259
94325: PUSH
94326: LD_INT 1
94328: PLUS
94329: PPUSH
94330: CALL_OW 237
94334: GO 94236
94336: POP
94337: POP
// end ;
94338: PPOPN 3
94340: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94341: LD_EXP 136
94345: PUSH
94346: LD_EXP 144
94350: AND
94351: IFFALSE 94371
94353: GO 94355
94355: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94356: LD_INT 4
94358: PPUSH
94359: LD_OWVAR 2
94363: PPUSH
94364: LD_INT 0
94366: PPUSH
94367: CALL_OW 324
94371: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94372: LD_EXP 136
94376: PUSH
94377: LD_EXP 173
94381: AND
94382: IFFALSE 94402
94384: GO 94386
94386: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94387: LD_INT 19
94389: PPUSH
94390: LD_OWVAR 2
94394: PPUSH
94395: LD_INT 0
94397: PPUSH
94398: CALL_OW 324
94402: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94403: LD_EXP 136
94407: PUSH
94408: LD_EXP 145
94412: AND
94413: IFFALSE 94515
94415: GO 94417
94417: DISABLE
94418: LD_INT 0
94420: PPUSH
94421: PPUSH
// begin enable ;
94422: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94423: LD_ADDR_VAR 0 2
94427: PUSH
94428: LD_INT 22
94430: PUSH
94431: LD_OWVAR 2
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: LD_INT 2
94442: PUSH
94443: LD_INT 34
94445: PUSH
94446: LD_INT 11
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 34
94455: PUSH
94456: LD_INT 30
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: LIST
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PPUSH
94472: CALL_OW 69
94476: ST_TO_ADDR
// if not tmp then
94477: LD_VAR 0 2
94481: NOT
94482: IFFALSE 94486
// exit ;
94484: GO 94515
// for i in tmp do
94486: LD_ADDR_VAR 0 1
94490: PUSH
94491: LD_VAR 0 2
94495: PUSH
94496: FOR_IN
94497: IFFALSE 94513
// begin SetLives ( i , 0 ) ;
94499: LD_VAR 0 1
94503: PPUSH
94504: LD_INT 0
94506: PPUSH
94507: CALL_OW 234
// end ;
94511: GO 94496
94513: POP
94514: POP
// end ;
94515: PPOPN 2
94517: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94518: LD_EXP 136
94522: PUSH
94523: LD_EXP 146
94527: AND
94528: IFFALSE 94548
94530: GO 94532
94532: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94533: LD_INT 32
94535: PPUSH
94536: LD_OWVAR 2
94540: PPUSH
94541: LD_INT 0
94543: PPUSH
94544: CALL_OW 324
94548: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94549: LD_EXP 136
94553: PUSH
94554: LD_EXP 147
94558: AND
94559: IFFALSE 94740
94561: GO 94563
94563: DISABLE
94564: LD_INT 0
94566: PPUSH
94567: PPUSH
94568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94569: LD_ADDR_VAR 0 2
94573: PUSH
94574: LD_INT 22
94576: PUSH
94577: LD_OWVAR 2
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 33
94588: PUSH
94589: LD_INT 3
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: PPUSH
94600: CALL_OW 69
94604: ST_TO_ADDR
// if not tmp then
94605: LD_VAR 0 2
94609: NOT
94610: IFFALSE 94614
// exit ;
94612: GO 94740
// side := 0 ;
94614: LD_ADDR_VAR 0 3
94618: PUSH
94619: LD_INT 0
94621: ST_TO_ADDR
// for i := 1 to 8 do
94622: LD_ADDR_VAR 0 1
94626: PUSH
94627: DOUBLE
94628: LD_INT 1
94630: DEC
94631: ST_TO_ADDR
94632: LD_INT 8
94634: PUSH
94635: FOR_TO
94636: IFFALSE 94684
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94638: LD_OWVAR 2
94642: PUSH
94643: LD_VAR 0 1
94647: NONEQUAL
94648: PUSH
94649: LD_OWVAR 2
94653: PPUSH
94654: LD_VAR 0 1
94658: PPUSH
94659: CALL_OW 81
94663: PUSH
94664: LD_INT 2
94666: EQUAL
94667: AND
94668: IFFALSE 94682
// begin side := i ;
94670: LD_ADDR_VAR 0 3
94674: PUSH
94675: LD_VAR 0 1
94679: ST_TO_ADDR
// break ;
94680: GO 94684
// end ;
94682: GO 94635
94684: POP
94685: POP
// if not side then
94686: LD_VAR 0 3
94690: NOT
94691: IFFALSE 94695
// exit ;
94693: GO 94740
// for i := 1 to tmp do
94695: LD_ADDR_VAR 0 1
94699: PUSH
94700: DOUBLE
94701: LD_INT 1
94703: DEC
94704: ST_TO_ADDR
94705: LD_VAR 0 2
94709: PUSH
94710: FOR_TO
94711: IFFALSE 94738
// if Prob ( 60 ) then
94713: LD_INT 60
94715: PPUSH
94716: CALL_OW 13
94720: IFFALSE 94736
// SetSide ( i , side ) ;
94722: LD_VAR 0 1
94726: PPUSH
94727: LD_VAR 0 3
94731: PPUSH
94732: CALL_OW 235
94736: GO 94710
94738: POP
94739: POP
// end ;
94740: PPOPN 3
94742: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94743: LD_EXP 136
94747: PUSH
94748: LD_EXP 149
94752: AND
94753: IFFALSE 94872
94755: GO 94757
94757: DISABLE
94758: LD_INT 0
94760: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94761: LD_ADDR_VAR 0 1
94765: PUSH
94766: LD_INT 22
94768: PUSH
94769: LD_OWVAR 2
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 21
94780: PUSH
94781: LD_INT 1
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 3
94790: PUSH
94791: LD_INT 23
94793: PUSH
94794: LD_INT 0
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: LIST
94809: PPUSH
94810: CALL_OW 69
94814: PUSH
94815: FOR_IN
94816: IFFALSE 94870
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94818: LD_VAR 0 1
94822: PPUSH
94823: CALL_OW 257
94827: PUSH
94828: LD_INT 1
94830: PUSH
94831: LD_INT 2
94833: PUSH
94834: LD_INT 3
94836: PUSH
94837: LD_INT 4
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: IN
94846: IFFALSE 94868
// SetClass ( un , rand ( 1 , 4 ) ) ;
94848: LD_VAR 0 1
94852: PPUSH
94853: LD_INT 1
94855: PPUSH
94856: LD_INT 4
94858: PPUSH
94859: CALL_OW 12
94863: PPUSH
94864: CALL_OW 336
94868: GO 94815
94870: POP
94871: POP
// end ;
94872: PPOPN 1
94874: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94875: LD_EXP 136
94879: PUSH
94880: LD_EXP 148
94884: AND
94885: IFFALSE 94964
94887: GO 94889
94889: DISABLE
94890: LD_INT 0
94892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94893: LD_ADDR_VAR 0 1
94897: PUSH
94898: LD_INT 22
94900: PUSH
94901: LD_OWVAR 2
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 21
94912: PUSH
94913: LD_INT 3
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PPUSH
94924: CALL_OW 69
94928: ST_TO_ADDR
// if not tmp then
94929: LD_VAR 0 1
94933: NOT
94934: IFFALSE 94938
// exit ;
94936: GO 94964
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94938: LD_VAR 0 1
94942: PUSH
94943: LD_INT 1
94945: PPUSH
94946: LD_VAR 0 1
94950: PPUSH
94951: CALL_OW 12
94955: ARRAY
94956: PPUSH
94957: LD_INT 100
94959: PPUSH
94960: CALL_OW 234
// end ;
94964: PPOPN 1
94966: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94967: LD_EXP 136
94971: PUSH
94972: LD_EXP 150
94976: AND
94977: IFFALSE 95075
94979: GO 94981
94981: DISABLE
94982: LD_INT 0
94984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94985: LD_ADDR_VAR 0 1
94989: PUSH
94990: LD_INT 22
94992: PUSH
94993: LD_OWVAR 2
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 21
95004: PUSH
95005: LD_INT 1
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PPUSH
95016: CALL_OW 69
95020: ST_TO_ADDR
// if not tmp then
95021: LD_VAR 0 1
95025: NOT
95026: IFFALSE 95030
// exit ;
95028: GO 95075
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95030: LD_VAR 0 1
95034: PUSH
95035: LD_INT 1
95037: PPUSH
95038: LD_VAR 0 1
95042: PPUSH
95043: CALL_OW 12
95047: ARRAY
95048: PPUSH
95049: LD_INT 1
95051: PPUSH
95052: LD_INT 4
95054: PPUSH
95055: CALL_OW 12
95059: PPUSH
95060: LD_INT 3000
95062: PPUSH
95063: LD_INT 9000
95065: PPUSH
95066: CALL_OW 12
95070: PPUSH
95071: CALL_OW 492
// end ;
95075: PPOPN 1
95077: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95078: LD_EXP 136
95082: PUSH
95083: LD_EXP 151
95087: AND
95088: IFFALSE 95108
95090: GO 95092
95092: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95093: LD_INT 1
95095: PPUSH
95096: LD_OWVAR 2
95100: PPUSH
95101: LD_INT 0
95103: PPUSH
95104: CALL_OW 324
95108: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95109: LD_EXP 136
95113: PUSH
95114: LD_EXP 152
95118: AND
95119: IFFALSE 95202
95121: GO 95123
95123: DISABLE
95124: LD_INT 0
95126: PPUSH
95127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95128: LD_ADDR_VAR 0 2
95132: PUSH
95133: LD_INT 22
95135: PUSH
95136: LD_OWVAR 2
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 21
95147: PUSH
95148: LD_INT 3
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PPUSH
95159: CALL_OW 69
95163: ST_TO_ADDR
// if not tmp then
95164: LD_VAR 0 2
95168: NOT
95169: IFFALSE 95173
// exit ;
95171: GO 95202
// for i in tmp do
95173: LD_ADDR_VAR 0 1
95177: PUSH
95178: LD_VAR 0 2
95182: PUSH
95183: FOR_IN
95184: IFFALSE 95200
// SetBLevel ( i , 10 ) ;
95186: LD_VAR 0 1
95190: PPUSH
95191: LD_INT 10
95193: PPUSH
95194: CALL_OW 241
95198: GO 95183
95200: POP
95201: POP
// end ;
95202: PPOPN 2
95204: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95205: LD_EXP 136
95209: PUSH
95210: LD_EXP 153
95214: AND
95215: IFFALSE 95326
95217: GO 95219
95219: DISABLE
95220: LD_INT 0
95222: PPUSH
95223: PPUSH
95224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95225: LD_ADDR_VAR 0 3
95229: PUSH
95230: LD_INT 22
95232: PUSH
95233: LD_OWVAR 2
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: PUSH
95242: LD_INT 25
95244: PUSH
95245: LD_INT 1
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PPUSH
95256: CALL_OW 69
95260: ST_TO_ADDR
// if not tmp then
95261: LD_VAR 0 3
95265: NOT
95266: IFFALSE 95270
// exit ;
95268: GO 95326
// un := tmp [ rand ( 1 , tmp ) ] ;
95270: LD_ADDR_VAR 0 2
95274: PUSH
95275: LD_VAR 0 3
95279: PUSH
95280: LD_INT 1
95282: PPUSH
95283: LD_VAR 0 3
95287: PPUSH
95288: CALL_OW 12
95292: ARRAY
95293: ST_TO_ADDR
// if Crawls ( un ) then
95294: LD_VAR 0 2
95298: PPUSH
95299: CALL_OW 318
95303: IFFALSE 95314
// ComWalk ( un ) ;
95305: LD_VAR 0 2
95309: PPUSH
95310: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95314: LD_VAR 0 2
95318: PPUSH
95319: LD_INT 5
95321: PPUSH
95322: CALL_OW 336
// end ;
95326: PPOPN 3
95328: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95329: LD_EXP 136
95333: PUSH
95334: LD_EXP 154
95338: AND
95339: PUSH
95340: LD_OWVAR 67
95344: PUSH
95345: LD_INT 3
95347: LESS
95348: AND
95349: IFFALSE 95368
95351: GO 95353
95353: DISABLE
// Difficulty := Difficulty + 1 ;
95354: LD_ADDR_OWVAR 67
95358: PUSH
95359: LD_OWVAR 67
95363: PUSH
95364: LD_INT 1
95366: PLUS
95367: ST_TO_ADDR
95368: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95369: LD_EXP 136
95373: PUSH
95374: LD_EXP 155
95378: AND
95379: IFFALSE 95482
95381: GO 95383
95383: DISABLE
95384: LD_INT 0
95386: PPUSH
// begin for i := 1 to 5 do
95387: LD_ADDR_VAR 0 1
95391: PUSH
95392: DOUBLE
95393: LD_INT 1
95395: DEC
95396: ST_TO_ADDR
95397: LD_INT 5
95399: PUSH
95400: FOR_TO
95401: IFFALSE 95480
// begin uc_nation := nation_nature ;
95403: LD_ADDR_OWVAR 21
95407: PUSH
95408: LD_INT 0
95410: ST_TO_ADDR
// uc_side := 0 ;
95411: LD_ADDR_OWVAR 20
95415: PUSH
95416: LD_INT 0
95418: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95419: LD_ADDR_OWVAR 29
95423: PUSH
95424: LD_INT 12
95426: PUSH
95427: LD_INT 12
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: ST_TO_ADDR
// hc_agressivity := 20 ;
95434: LD_ADDR_OWVAR 35
95438: PUSH
95439: LD_INT 20
95441: ST_TO_ADDR
// hc_class := class_tiger ;
95442: LD_ADDR_OWVAR 28
95446: PUSH
95447: LD_INT 14
95449: ST_TO_ADDR
// hc_gallery :=  ;
95450: LD_ADDR_OWVAR 33
95454: PUSH
95455: LD_STRING 
95457: ST_TO_ADDR
// hc_name :=  ;
95458: LD_ADDR_OWVAR 26
95462: PUSH
95463: LD_STRING 
95465: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95466: CALL_OW 44
95470: PPUSH
95471: LD_INT 0
95473: PPUSH
95474: CALL_OW 51
// end ;
95478: GO 95400
95480: POP
95481: POP
// end ;
95482: PPOPN 1
95484: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95485: LD_EXP 136
95489: PUSH
95490: LD_EXP 156
95494: AND
95495: IFFALSE 95504
95497: GO 95499
95499: DISABLE
// StreamSibBomb ;
95500: CALL 95505 0 0
95504: END
// export function StreamSibBomb ; var i , x , y ; begin
95505: LD_INT 0
95507: PPUSH
95508: PPUSH
95509: PPUSH
95510: PPUSH
// result := false ;
95511: LD_ADDR_VAR 0 1
95515: PUSH
95516: LD_INT 0
95518: ST_TO_ADDR
// for i := 1 to 16 do
95519: LD_ADDR_VAR 0 2
95523: PUSH
95524: DOUBLE
95525: LD_INT 1
95527: DEC
95528: ST_TO_ADDR
95529: LD_INT 16
95531: PUSH
95532: FOR_TO
95533: IFFALSE 95732
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95535: LD_ADDR_VAR 0 3
95539: PUSH
95540: LD_INT 10
95542: PUSH
95543: LD_INT 20
95545: PUSH
95546: LD_INT 30
95548: PUSH
95549: LD_INT 40
95551: PUSH
95552: LD_INT 50
95554: PUSH
95555: LD_INT 60
95557: PUSH
95558: LD_INT 70
95560: PUSH
95561: LD_INT 80
95563: PUSH
95564: LD_INT 90
95566: PUSH
95567: LD_INT 100
95569: PUSH
95570: LD_INT 110
95572: PUSH
95573: LD_INT 120
95575: PUSH
95576: LD_INT 130
95578: PUSH
95579: LD_INT 140
95581: PUSH
95582: LD_INT 150
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: PUSH
95602: LD_INT 1
95604: PPUSH
95605: LD_INT 15
95607: PPUSH
95608: CALL_OW 12
95612: ARRAY
95613: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95614: LD_ADDR_VAR 0 4
95618: PUSH
95619: LD_INT 10
95621: PUSH
95622: LD_INT 20
95624: PUSH
95625: LD_INT 30
95627: PUSH
95628: LD_INT 40
95630: PUSH
95631: LD_INT 50
95633: PUSH
95634: LD_INT 60
95636: PUSH
95637: LD_INT 70
95639: PUSH
95640: LD_INT 80
95642: PUSH
95643: LD_INT 90
95645: PUSH
95646: LD_INT 100
95648: PUSH
95649: LD_INT 110
95651: PUSH
95652: LD_INT 120
95654: PUSH
95655: LD_INT 130
95657: PUSH
95658: LD_INT 140
95660: PUSH
95661: LD_INT 150
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: PUSH
95681: LD_INT 1
95683: PPUSH
95684: LD_INT 15
95686: PPUSH
95687: CALL_OW 12
95691: ARRAY
95692: ST_TO_ADDR
// if ValidHex ( x , y ) then
95693: LD_VAR 0 3
95697: PPUSH
95698: LD_VAR 0 4
95702: PPUSH
95703: CALL_OW 488
95707: IFFALSE 95730
// begin result := [ x , y ] ;
95709: LD_ADDR_VAR 0 1
95713: PUSH
95714: LD_VAR 0 3
95718: PUSH
95719: LD_VAR 0 4
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: ST_TO_ADDR
// break ;
95728: GO 95732
// end ; end ;
95730: GO 95532
95732: POP
95733: POP
// if result then
95734: LD_VAR 0 1
95738: IFFALSE 95798
// begin ToLua ( playSibBomb() ) ;
95740: LD_STRING playSibBomb()
95742: PPUSH
95743: CALL_OW 559
// wait ( 0 0$14 ) ;
95747: LD_INT 490
95749: PPUSH
95750: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95754: LD_VAR 0 1
95758: PUSH
95759: LD_INT 1
95761: ARRAY
95762: PPUSH
95763: LD_VAR 0 1
95767: PUSH
95768: LD_INT 2
95770: ARRAY
95771: PPUSH
95772: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95776: LD_VAR 0 1
95780: PUSH
95781: LD_INT 1
95783: ARRAY
95784: PPUSH
95785: LD_VAR 0 1
95789: PUSH
95790: LD_INT 2
95792: ARRAY
95793: PPUSH
95794: CALL_OW 429
// end ; end ;
95798: LD_VAR 0 1
95802: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95803: LD_EXP 136
95807: PUSH
95808: LD_EXP 158
95812: AND
95813: IFFALSE 95825
95815: GO 95817
95817: DISABLE
// YouLost (  ) ;
95818: LD_STRING 
95820: PPUSH
95821: CALL_OW 104
95825: END
// every 0 0$1 trigger StreamModeActive and sFog do
95826: LD_EXP 136
95830: PUSH
95831: LD_EXP 157
95835: AND
95836: IFFALSE 95850
95838: GO 95840
95840: DISABLE
// FogOff ( your_side ) ;
95841: LD_OWVAR 2
95845: PPUSH
95846: CALL_OW 344
95850: END
// every 0 0$1 trigger StreamModeActive and sSun do
95851: LD_EXP 136
95855: PUSH
95856: LD_EXP 159
95860: AND
95861: IFFALSE 95889
95863: GO 95865
95865: DISABLE
// begin solar_recharge_percent := 0 ;
95866: LD_ADDR_OWVAR 79
95870: PUSH
95871: LD_INT 0
95873: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95874: LD_INT 10500
95876: PPUSH
95877: CALL_OW 67
// solar_recharge_percent := 100 ;
95881: LD_ADDR_OWVAR 79
95885: PUSH
95886: LD_INT 100
95888: ST_TO_ADDR
// end ;
95889: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95890: LD_EXP 136
95894: PUSH
95895: LD_EXP 160
95899: AND
95900: IFFALSE 96139
95902: GO 95904
95904: DISABLE
95905: LD_INT 0
95907: PPUSH
95908: PPUSH
95909: PPUSH
// begin tmp := [ ] ;
95910: LD_ADDR_VAR 0 3
95914: PUSH
95915: EMPTY
95916: ST_TO_ADDR
// for i := 1 to 6 do
95917: LD_ADDR_VAR 0 1
95921: PUSH
95922: DOUBLE
95923: LD_INT 1
95925: DEC
95926: ST_TO_ADDR
95927: LD_INT 6
95929: PUSH
95930: FOR_TO
95931: IFFALSE 96036
// begin uc_nation := nation_nature ;
95933: LD_ADDR_OWVAR 21
95937: PUSH
95938: LD_INT 0
95940: ST_TO_ADDR
// uc_side := 0 ;
95941: LD_ADDR_OWVAR 20
95945: PUSH
95946: LD_INT 0
95948: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95949: LD_ADDR_OWVAR 29
95953: PUSH
95954: LD_INT 12
95956: PUSH
95957: LD_INT 12
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: ST_TO_ADDR
// hc_agressivity := 20 ;
95964: LD_ADDR_OWVAR 35
95968: PUSH
95969: LD_INT 20
95971: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95972: LD_ADDR_OWVAR 28
95976: PUSH
95977: LD_INT 17
95979: ST_TO_ADDR
// hc_gallery :=  ;
95980: LD_ADDR_OWVAR 33
95984: PUSH
95985: LD_STRING 
95987: ST_TO_ADDR
// hc_name :=  ;
95988: LD_ADDR_OWVAR 26
95992: PUSH
95993: LD_STRING 
95995: ST_TO_ADDR
// un := CreateHuman ;
95996: LD_ADDR_VAR 0 2
96000: PUSH
96001: CALL_OW 44
96005: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96006: LD_VAR 0 2
96010: PPUSH
96011: LD_INT 1
96013: PPUSH
96014: CALL_OW 51
// tmp := tmp ^ un ;
96018: LD_ADDR_VAR 0 3
96022: PUSH
96023: LD_VAR 0 3
96027: PUSH
96028: LD_VAR 0 2
96032: ADD
96033: ST_TO_ADDR
// end ;
96034: GO 95930
96036: POP
96037: POP
// repeat wait ( 0 0$1 ) ;
96038: LD_INT 35
96040: PPUSH
96041: CALL_OW 67
// for un in tmp do
96045: LD_ADDR_VAR 0 2
96049: PUSH
96050: LD_VAR 0 3
96054: PUSH
96055: FOR_IN
96056: IFFALSE 96130
// begin if IsDead ( un ) then
96058: LD_VAR 0 2
96062: PPUSH
96063: CALL_OW 301
96067: IFFALSE 96087
// begin tmp := tmp diff un ;
96069: LD_ADDR_VAR 0 3
96073: PUSH
96074: LD_VAR 0 3
96078: PUSH
96079: LD_VAR 0 2
96083: DIFF
96084: ST_TO_ADDR
// continue ;
96085: GO 96055
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96087: LD_VAR 0 2
96091: PPUSH
96092: LD_INT 3
96094: PUSH
96095: LD_INT 22
96097: PUSH
96098: LD_INT 0
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PPUSH
96109: CALL_OW 69
96113: PPUSH
96114: LD_VAR 0 2
96118: PPUSH
96119: CALL_OW 74
96123: PPUSH
96124: CALL_OW 115
// end ;
96128: GO 96055
96130: POP
96131: POP
// until not tmp ;
96132: LD_VAR 0 3
96136: NOT
96137: IFFALSE 96038
// end ;
96139: PPOPN 3
96141: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96142: LD_EXP 136
96146: PUSH
96147: LD_EXP 161
96151: AND
96152: IFFALSE 96206
96154: GO 96156
96156: DISABLE
// begin ToLua ( displayTroll(); ) ;
96157: LD_STRING displayTroll();
96159: PPUSH
96160: CALL_OW 559
// wait ( 3 3$00 ) ;
96164: LD_INT 6300
96166: PPUSH
96167: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96171: LD_STRING hideTroll();
96173: PPUSH
96174: CALL_OW 559
// wait ( 1 1$00 ) ;
96178: LD_INT 2100
96180: PPUSH
96181: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96185: LD_STRING displayTroll();
96187: PPUSH
96188: CALL_OW 559
// wait ( 1 1$00 ) ;
96192: LD_INT 2100
96194: PPUSH
96195: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96199: LD_STRING hideTroll();
96201: PPUSH
96202: CALL_OW 559
// end ;
96206: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96207: LD_EXP 136
96211: PUSH
96212: LD_EXP 162
96216: AND
96217: IFFALSE 96280
96219: GO 96221
96221: DISABLE
96222: LD_INT 0
96224: PPUSH
// begin p := 0 ;
96225: LD_ADDR_VAR 0 1
96229: PUSH
96230: LD_INT 0
96232: ST_TO_ADDR
// repeat game_speed := 1 ;
96233: LD_ADDR_OWVAR 65
96237: PUSH
96238: LD_INT 1
96240: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96241: LD_INT 35
96243: PPUSH
96244: CALL_OW 67
// p := p + 1 ;
96248: LD_ADDR_VAR 0 1
96252: PUSH
96253: LD_VAR 0 1
96257: PUSH
96258: LD_INT 1
96260: PLUS
96261: ST_TO_ADDR
// until p >= 60 ;
96262: LD_VAR 0 1
96266: PUSH
96267: LD_INT 60
96269: GREATEREQUAL
96270: IFFALSE 96233
// game_speed := 4 ;
96272: LD_ADDR_OWVAR 65
96276: PUSH
96277: LD_INT 4
96279: ST_TO_ADDR
// end ;
96280: PPOPN 1
96282: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96283: LD_EXP 136
96287: PUSH
96288: LD_EXP 163
96292: AND
96293: IFFALSE 96439
96295: GO 96297
96297: DISABLE
96298: LD_INT 0
96300: PPUSH
96301: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96302: LD_ADDR_VAR 0 1
96306: PUSH
96307: LD_INT 22
96309: PUSH
96310: LD_OWVAR 2
96314: PUSH
96315: EMPTY
96316: LIST
96317: LIST
96318: PUSH
96319: LD_INT 2
96321: PUSH
96322: LD_INT 30
96324: PUSH
96325: LD_INT 0
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 30
96334: PUSH
96335: LD_INT 1
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: LIST
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PPUSH
96351: CALL_OW 69
96355: ST_TO_ADDR
// if not depot then
96356: LD_VAR 0 1
96360: NOT
96361: IFFALSE 96365
// exit ;
96363: GO 96439
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96365: LD_ADDR_VAR 0 2
96369: PUSH
96370: LD_VAR 0 1
96374: PUSH
96375: LD_INT 1
96377: PPUSH
96378: LD_VAR 0 1
96382: PPUSH
96383: CALL_OW 12
96387: ARRAY
96388: PPUSH
96389: CALL_OW 274
96393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96394: LD_VAR 0 2
96398: PPUSH
96399: LD_INT 1
96401: PPUSH
96402: LD_INT 0
96404: PPUSH
96405: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96409: LD_VAR 0 2
96413: PPUSH
96414: LD_INT 2
96416: PPUSH
96417: LD_INT 0
96419: PPUSH
96420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96424: LD_VAR 0 2
96428: PPUSH
96429: LD_INT 3
96431: PPUSH
96432: LD_INT 0
96434: PPUSH
96435: CALL_OW 277
// end ;
96439: PPOPN 2
96441: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96442: LD_EXP 136
96446: PUSH
96447: LD_EXP 164
96451: AND
96452: IFFALSE 96549
96454: GO 96456
96456: DISABLE
96457: LD_INT 0
96459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96460: LD_ADDR_VAR 0 1
96464: PUSH
96465: LD_INT 22
96467: PUSH
96468: LD_OWVAR 2
96472: PUSH
96473: EMPTY
96474: LIST
96475: LIST
96476: PUSH
96477: LD_INT 21
96479: PUSH
96480: LD_INT 1
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PUSH
96487: LD_INT 3
96489: PUSH
96490: LD_INT 23
96492: PUSH
96493: LD_INT 0
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: LIST
96508: PPUSH
96509: CALL_OW 69
96513: ST_TO_ADDR
// if not tmp then
96514: LD_VAR 0 1
96518: NOT
96519: IFFALSE 96523
// exit ;
96521: GO 96549
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96523: LD_VAR 0 1
96527: PUSH
96528: LD_INT 1
96530: PPUSH
96531: LD_VAR 0 1
96535: PPUSH
96536: CALL_OW 12
96540: ARRAY
96541: PPUSH
96542: LD_INT 200
96544: PPUSH
96545: CALL_OW 234
// end ;
96549: PPOPN 1
96551: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96552: LD_EXP 136
96556: PUSH
96557: LD_EXP 165
96561: AND
96562: IFFALSE 96641
96564: GO 96566
96566: DISABLE
96567: LD_INT 0
96569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96570: LD_ADDR_VAR 0 1
96574: PUSH
96575: LD_INT 22
96577: PUSH
96578: LD_OWVAR 2
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 21
96589: PUSH
96590: LD_INT 2
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PPUSH
96601: CALL_OW 69
96605: ST_TO_ADDR
// if not tmp then
96606: LD_VAR 0 1
96610: NOT
96611: IFFALSE 96615
// exit ;
96613: GO 96641
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96615: LD_VAR 0 1
96619: PUSH
96620: LD_INT 1
96622: PPUSH
96623: LD_VAR 0 1
96627: PPUSH
96628: CALL_OW 12
96632: ARRAY
96633: PPUSH
96634: LD_INT 60
96636: PPUSH
96637: CALL_OW 234
// end ;
96641: PPOPN 1
96643: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96644: LD_EXP 136
96648: PUSH
96649: LD_EXP 166
96653: AND
96654: IFFALSE 96753
96656: GO 96658
96658: DISABLE
96659: LD_INT 0
96661: PPUSH
96662: PPUSH
// begin enable ;
96663: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96664: LD_ADDR_VAR 0 1
96668: PUSH
96669: LD_INT 22
96671: PUSH
96672: LD_OWVAR 2
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: PUSH
96681: LD_INT 61
96683: PUSH
96684: EMPTY
96685: LIST
96686: PUSH
96687: LD_INT 33
96689: PUSH
96690: LD_INT 2
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: LIST
96701: PPUSH
96702: CALL_OW 69
96706: ST_TO_ADDR
// if not tmp then
96707: LD_VAR 0 1
96711: NOT
96712: IFFALSE 96716
// exit ;
96714: GO 96753
// for i in tmp do
96716: LD_ADDR_VAR 0 2
96720: PUSH
96721: LD_VAR 0 1
96725: PUSH
96726: FOR_IN
96727: IFFALSE 96751
// if IsControledBy ( i ) then
96729: LD_VAR 0 2
96733: PPUSH
96734: CALL_OW 312
96738: IFFALSE 96749
// ComUnlink ( i ) ;
96740: LD_VAR 0 2
96744: PPUSH
96745: CALL_OW 136
96749: GO 96726
96751: POP
96752: POP
// end ;
96753: PPOPN 2
96755: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96756: LD_EXP 136
96760: PUSH
96761: LD_EXP 167
96765: AND
96766: IFFALSE 96906
96768: GO 96770
96770: DISABLE
96771: LD_INT 0
96773: PPUSH
96774: PPUSH
// begin ToLua ( displayPowell(); ) ;
96775: LD_STRING displayPowell();
96777: PPUSH
96778: CALL_OW 559
// uc_side := 0 ;
96782: LD_ADDR_OWVAR 20
96786: PUSH
96787: LD_INT 0
96789: ST_TO_ADDR
// uc_nation := 2 ;
96790: LD_ADDR_OWVAR 21
96794: PUSH
96795: LD_INT 2
96797: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96798: LD_ADDR_OWVAR 37
96802: PUSH
96803: LD_INT 14
96805: ST_TO_ADDR
// vc_engine := engine_siberite ;
96806: LD_ADDR_OWVAR 39
96810: PUSH
96811: LD_INT 3
96813: ST_TO_ADDR
// vc_control := control_apeman ;
96814: LD_ADDR_OWVAR 38
96818: PUSH
96819: LD_INT 5
96821: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96822: LD_ADDR_OWVAR 40
96826: PUSH
96827: LD_INT 29
96829: ST_TO_ADDR
// un := CreateVehicle ;
96830: LD_ADDR_VAR 0 2
96834: PUSH
96835: CALL_OW 45
96839: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96840: LD_VAR 0 2
96844: PPUSH
96845: LD_INT 1
96847: PPUSH
96848: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96852: LD_INT 35
96854: PPUSH
96855: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96859: LD_VAR 0 2
96863: PPUSH
96864: LD_INT 22
96866: PUSH
96867: LD_OWVAR 2
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PPUSH
96876: CALL_OW 69
96880: PPUSH
96881: LD_VAR 0 2
96885: PPUSH
96886: CALL_OW 74
96890: PPUSH
96891: CALL_OW 115
// until IsDead ( un ) ;
96895: LD_VAR 0 2
96899: PPUSH
96900: CALL_OW 301
96904: IFFALSE 96852
// end ;
96906: PPOPN 2
96908: END
// every 0 0$1 trigger StreamModeActive and sStu do
96909: LD_EXP 136
96913: PUSH
96914: LD_EXP 175
96918: AND
96919: IFFALSE 96935
96921: GO 96923
96923: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96924: LD_STRING displayStucuk();
96926: PPUSH
96927: CALL_OW 559
// ResetFog ;
96931: CALL_OW 335
// end ;
96935: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96936: LD_EXP 136
96940: PUSH
96941: LD_EXP 168
96945: AND
96946: IFFALSE 97087
96948: GO 96950
96950: DISABLE
96951: LD_INT 0
96953: PPUSH
96954: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96955: LD_ADDR_VAR 0 2
96959: PUSH
96960: LD_INT 22
96962: PUSH
96963: LD_OWVAR 2
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PUSH
96972: LD_INT 21
96974: PUSH
96975: LD_INT 1
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PPUSH
96986: CALL_OW 69
96990: ST_TO_ADDR
// if not tmp then
96991: LD_VAR 0 2
96995: NOT
96996: IFFALSE 97000
// exit ;
96998: GO 97087
// un := tmp [ rand ( 1 , tmp ) ] ;
97000: LD_ADDR_VAR 0 1
97004: PUSH
97005: LD_VAR 0 2
97009: PUSH
97010: LD_INT 1
97012: PPUSH
97013: LD_VAR 0 2
97017: PPUSH
97018: CALL_OW 12
97022: ARRAY
97023: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97024: LD_VAR 0 1
97028: PPUSH
97029: LD_INT 0
97031: PPUSH
97032: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97036: LD_VAR 0 1
97040: PPUSH
97041: LD_OWVAR 3
97045: PUSH
97046: LD_VAR 0 1
97050: DIFF
97051: PPUSH
97052: LD_VAR 0 1
97056: PPUSH
97057: CALL_OW 74
97061: PPUSH
97062: CALL_OW 115
// wait ( 0 0$20 ) ;
97066: LD_INT 700
97068: PPUSH
97069: CALL_OW 67
// SetSide ( un , your_side ) ;
97073: LD_VAR 0 1
97077: PPUSH
97078: LD_OWVAR 2
97082: PPUSH
97083: CALL_OW 235
// end ;
97087: PPOPN 2
97089: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97090: LD_EXP 136
97094: PUSH
97095: LD_EXP 169
97099: AND
97100: IFFALSE 97206
97102: GO 97104
97104: DISABLE
97105: LD_INT 0
97107: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97108: LD_ADDR_VAR 0 1
97112: PUSH
97113: LD_INT 22
97115: PUSH
97116: LD_OWVAR 2
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 2
97127: PUSH
97128: LD_INT 30
97130: PUSH
97131: LD_INT 0
97133: PUSH
97134: EMPTY
97135: LIST
97136: LIST
97137: PUSH
97138: LD_INT 30
97140: PUSH
97141: LD_INT 1
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: LIST
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PPUSH
97157: CALL_OW 69
97161: ST_TO_ADDR
// if not depot then
97162: LD_VAR 0 1
97166: NOT
97167: IFFALSE 97171
// exit ;
97169: GO 97206
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97171: LD_VAR 0 1
97175: PUSH
97176: LD_INT 1
97178: ARRAY
97179: PPUSH
97180: CALL_OW 250
97184: PPUSH
97185: LD_VAR 0 1
97189: PUSH
97190: LD_INT 1
97192: ARRAY
97193: PPUSH
97194: CALL_OW 251
97198: PPUSH
97199: LD_INT 70
97201: PPUSH
97202: CALL_OW 495
// end ;
97206: PPOPN 1
97208: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97209: LD_EXP 136
97213: PUSH
97214: LD_EXP 170
97218: AND
97219: IFFALSE 97430
97221: GO 97223
97223: DISABLE
97224: LD_INT 0
97226: PPUSH
97227: PPUSH
97228: PPUSH
97229: PPUSH
97230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97231: LD_ADDR_VAR 0 5
97235: PUSH
97236: LD_INT 22
97238: PUSH
97239: LD_OWVAR 2
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: PUSH
97248: LD_INT 21
97250: PUSH
97251: LD_INT 1
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PPUSH
97262: CALL_OW 69
97266: ST_TO_ADDR
// if not tmp then
97267: LD_VAR 0 5
97271: NOT
97272: IFFALSE 97276
// exit ;
97274: GO 97430
// for i in tmp do
97276: LD_ADDR_VAR 0 1
97280: PUSH
97281: LD_VAR 0 5
97285: PUSH
97286: FOR_IN
97287: IFFALSE 97428
// begin d := rand ( 0 , 5 ) ;
97289: LD_ADDR_VAR 0 4
97293: PUSH
97294: LD_INT 0
97296: PPUSH
97297: LD_INT 5
97299: PPUSH
97300: CALL_OW 12
97304: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97305: LD_ADDR_VAR 0 2
97309: PUSH
97310: LD_VAR 0 1
97314: PPUSH
97315: CALL_OW 250
97319: PPUSH
97320: LD_VAR 0 4
97324: PPUSH
97325: LD_INT 3
97327: PPUSH
97328: LD_INT 12
97330: PPUSH
97331: CALL_OW 12
97335: PPUSH
97336: CALL_OW 272
97340: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97341: LD_ADDR_VAR 0 3
97345: PUSH
97346: LD_VAR 0 1
97350: PPUSH
97351: CALL_OW 251
97355: PPUSH
97356: LD_VAR 0 4
97360: PPUSH
97361: LD_INT 3
97363: PPUSH
97364: LD_INT 12
97366: PPUSH
97367: CALL_OW 12
97371: PPUSH
97372: CALL_OW 273
97376: ST_TO_ADDR
// if ValidHex ( x , y ) then
97377: LD_VAR 0 2
97381: PPUSH
97382: LD_VAR 0 3
97386: PPUSH
97387: CALL_OW 488
97391: IFFALSE 97426
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97393: LD_VAR 0 1
97397: PPUSH
97398: LD_VAR 0 2
97402: PPUSH
97403: LD_VAR 0 3
97407: PPUSH
97408: LD_INT 3
97410: PPUSH
97411: LD_INT 6
97413: PPUSH
97414: CALL_OW 12
97418: PPUSH
97419: LD_INT 1
97421: PPUSH
97422: CALL_OW 483
// end ;
97426: GO 97286
97428: POP
97429: POP
// end ;
97430: PPOPN 5
97432: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97433: LD_EXP 136
97437: PUSH
97438: LD_EXP 171
97442: AND
97443: IFFALSE 97537
97445: GO 97447
97447: DISABLE
97448: LD_INT 0
97450: PPUSH
97451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97452: LD_ADDR_VAR 0 2
97456: PUSH
97457: LD_INT 22
97459: PUSH
97460: LD_OWVAR 2
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 32
97471: PUSH
97472: LD_INT 1
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: LD_INT 21
97481: PUSH
97482: LD_INT 2
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: EMPTY
97490: LIST
97491: LIST
97492: LIST
97493: PPUSH
97494: CALL_OW 69
97498: ST_TO_ADDR
// if not tmp then
97499: LD_VAR 0 2
97503: NOT
97504: IFFALSE 97508
// exit ;
97506: GO 97537
// for i in tmp do
97508: LD_ADDR_VAR 0 1
97512: PUSH
97513: LD_VAR 0 2
97517: PUSH
97518: FOR_IN
97519: IFFALSE 97535
// SetFuel ( i , 0 ) ;
97521: LD_VAR 0 1
97525: PPUSH
97526: LD_INT 0
97528: PPUSH
97529: CALL_OW 240
97533: GO 97518
97535: POP
97536: POP
// end ;
97537: PPOPN 2
97539: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97540: LD_EXP 136
97544: PUSH
97545: LD_EXP 172
97549: AND
97550: IFFALSE 97616
97552: GO 97554
97554: DISABLE
97555: LD_INT 0
97557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97558: LD_ADDR_VAR 0 1
97562: PUSH
97563: LD_INT 22
97565: PUSH
97566: LD_OWVAR 2
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 30
97577: PUSH
97578: LD_INT 29
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PPUSH
97589: CALL_OW 69
97593: ST_TO_ADDR
// if not tmp then
97594: LD_VAR 0 1
97598: NOT
97599: IFFALSE 97603
// exit ;
97601: GO 97616
// DestroyUnit ( tmp [ 1 ] ) ;
97603: LD_VAR 0 1
97607: PUSH
97608: LD_INT 1
97610: ARRAY
97611: PPUSH
97612: CALL_OW 65
// end ;
97616: PPOPN 1
97618: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97619: LD_EXP 136
97623: PUSH
97624: LD_EXP 174
97628: AND
97629: IFFALSE 97758
97631: GO 97633
97633: DISABLE
97634: LD_INT 0
97636: PPUSH
// begin uc_side := 0 ;
97637: LD_ADDR_OWVAR 20
97641: PUSH
97642: LD_INT 0
97644: ST_TO_ADDR
// uc_nation := nation_arabian ;
97645: LD_ADDR_OWVAR 21
97649: PUSH
97650: LD_INT 2
97652: ST_TO_ADDR
// hc_gallery :=  ;
97653: LD_ADDR_OWVAR 33
97657: PUSH
97658: LD_STRING 
97660: ST_TO_ADDR
// hc_name :=  ;
97661: LD_ADDR_OWVAR 26
97665: PUSH
97666: LD_STRING 
97668: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97669: LD_INT 1
97671: PPUSH
97672: LD_INT 11
97674: PPUSH
97675: LD_INT 10
97677: PPUSH
97678: CALL_OW 380
// un := CreateHuman ;
97682: LD_ADDR_VAR 0 1
97686: PUSH
97687: CALL_OW 44
97691: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97692: LD_VAR 0 1
97696: PPUSH
97697: LD_INT 1
97699: PPUSH
97700: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97704: LD_INT 35
97706: PPUSH
97707: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97711: LD_VAR 0 1
97715: PPUSH
97716: LD_INT 22
97718: PUSH
97719: LD_OWVAR 2
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PPUSH
97728: CALL_OW 69
97732: PPUSH
97733: LD_VAR 0 1
97737: PPUSH
97738: CALL_OW 74
97742: PPUSH
97743: CALL_OW 115
// until IsDead ( un ) ;
97747: LD_VAR 0 1
97751: PPUSH
97752: CALL_OW 301
97756: IFFALSE 97704
// end ;
97758: PPOPN 1
97760: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97761: LD_EXP 136
97765: PUSH
97766: LD_EXP 176
97770: AND
97771: IFFALSE 97783
97773: GO 97775
97775: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97776: LD_STRING earthquake(getX(game), 0, 32)
97778: PPUSH
97779: CALL_OW 559
97783: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97784: LD_EXP 136
97788: PUSH
97789: LD_EXP 177
97793: AND
97794: IFFALSE 97885
97796: GO 97798
97798: DISABLE
97799: LD_INT 0
97801: PPUSH
// begin enable ;
97802: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97803: LD_ADDR_VAR 0 1
97807: PUSH
97808: LD_INT 22
97810: PUSH
97811: LD_OWVAR 2
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: LD_INT 21
97822: PUSH
97823: LD_INT 2
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 33
97832: PUSH
97833: LD_INT 3
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: LIST
97844: PPUSH
97845: CALL_OW 69
97849: ST_TO_ADDR
// if not tmp then
97850: LD_VAR 0 1
97854: NOT
97855: IFFALSE 97859
// exit ;
97857: GO 97885
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97859: LD_VAR 0 1
97863: PUSH
97864: LD_INT 1
97866: PPUSH
97867: LD_VAR 0 1
97871: PPUSH
97872: CALL_OW 12
97876: ARRAY
97877: PPUSH
97878: LD_INT 1
97880: PPUSH
97881: CALL_OW 234
// end ;
97885: PPOPN 1
97887: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97888: LD_EXP 136
97892: PUSH
97893: LD_EXP 178
97897: AND
97898: IFFALSE 98039
97900: GO 97902
97902: DISABLE
97903: LD_INT 0
97905: PPUSH
97906: PPUSH
97907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97908: LD_ADDR_VAR 0 3
97912: PUSH
97913: LD_INT 22
97915: PUSH
97916: LD_OWVAR 2
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: PUSH
97925: LD_INT 25
97927: PUSH
97928: LD_INT 1
97930: PUSH
97931: EMPTY
97932: LIST
97933: LIST
97934: PUSH
97935: EMPTY
97936: LIST
97937: LIST
97938: PPUSH
97939: CALL_OW 69
97943: ST_TO_ADDR
// if not tmp then
97944: LD_VAR 0 3
97948: NOT
97949: IFFALSE 97953
// exit ;
97951: GO 98039
// un := tmp [ rand ( 1 , tmp ) ] ;
97953: LD_ADDR_VAR 0 2
97957: PUSH
97958: LD_VAR 0 3
97962: PUSH
97963: LD_INT 1
97965: PPUSH
97966: LD_VAR 0 3
97970: PPUSH
97971: CALL_OW 12
97975: ARRAY
97976: ST_TO_ADDR
// if Crawls ( un ) then
97977: LD_VAR 0 2
97981: PPUSH
97982: CALL_OW 318
97986: IFFALSE 97997
// ComWalk ( un ) ;
97988: LD_VAR 0 2
97992: PPUSH
97993: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97997: LD_VAR 0 2
98001: PPUSH
98002: LD_INT 9
98004: PPUSH
98005: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98009: LD_INT 28
98011: PPUSH
98012: LD_OWVAR 2
98016: PPUSH
98017: LD_INT 2
98019: PPUSH
98020: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98024: LD_INT 29
98026: PPUSH
98027: LD_OWVAR 2
98031: PPUSH
98032: LD_INT 2
98034: PPUSH
98035: CALL_OW 322
// end ;
98039: PPOPN 3
98041: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98042: LD_EXP 136
98046: PUSH
98047: LD_EXP 179
98051: AND
98052: IFFALSE 98163
98054: GO 98056
98056: DISABLE
98057: LD_INT 0
98059: PPUSH
98060: PPUSH
98061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98062: LD_ADDR_VAR 0 3
98066: PUSH
98067: LD_INT 22
98069: PUSH
98070: LD_OWVAR 2
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 25
98081: PUSH
98082: LD_INT 1
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: PPUSH
98093: CALL_OW 69
98097: ST_TO_ADDR
// if not tmp then
98098: LD_VAR 0 3
98102: NOT
98103: IFFALSE 98107
// exit ;
98105: GO 98163
// un := tmp [ rand ( 1 , tmp ) ] ;
98107: LD_ADDR_VAR 0 2
98111: PUSH
98112: LD_VAR 0 3
98116: PUSH
98117: LD_INT 1
98119: PPUSH
98120: LD_VAR 0 3
98124: PPUSH
98125: CALL_OW 12
98129: ARRAY
98130: ST_TO_ADDR
// if Crawls ( un ) then
98131: LD_VAR 0 2
98135: PPUSH
98136: CALL_OW 318
98140: IFFALSE 98151
// ComWalk ( un ) ;
98142: LD_VAR 0 2
98146: PPUSH
98147: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98151: LD_VAR 0 2
98155: PPUSH
98156: LD_INT 8
98158: PPUSH
98159: CALL_OW 336
// end ;
98163: PPOPN 3
98165: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98166: LD_EXP 136
98170: PUSH
98171: LD_EXP 180
98175: AND
98176: IFFALSE 98320
98178: GO 98180
98180: DISABLE
98181: LD_INT 0
98183: PPUSH
98184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98185: LD_ADDR_VAR 0 2
98189: PUSH
98190: LD_INT 22
98192: PUSH
98193: LD_OWVAR 2
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: PUSH
98202: LD_INT 21
98204: PUSH
98205: LD_INT 2
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 2
98214: PUSH
98215: LD_INT 34
98217: PUSH
98218: LD_INT 12
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 34
98227: PUSH
98228: LD_INT 51
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: LD_INT 34
98237: PUSH
98238: LD_INT 32
98240: PUSH
98241: EMPTY
98242: LIST
98243: LIST
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: LIST
98255: PPUSH
98256: CALL_OW 69
98260: ST_TO_ADDR
// if not tmp then
98261: LD_VAR 0 2
98265: NOT
98266: IFFALSE 98270
// exit ;
98268: GO 98320
// for i in tmp do
98270: LD_ADDR_VAR 0 1
98274: PUSH
98275: LD_VAR 0 2
98279: PUSH
98280: FOR_IN
98281: IFFALSE 98318
// if GetCargo ( i , mat_artifact ) = 0 then
98283: LD_VAR 0 1
98287: PPUSH
98288: LD_INT 4
98290: PPUSH
98291: CALL_OW 289
98295: PUSH
98296: LD_INT 0
98298: EQUAL
98299: IFFALSE 98316
// SetCargo ( i , mat_siberit , 100 ) ;
98301: LD_VAR 0 1
98305: PPUSH
98306: LD_INT 3
98308: PPUSH
98309: LD_INT 100
98311: PPUSH
98312: CALL_OW 290
98316: GO 98280
98318: POP
98319: POP
// end ;
98320: PPOPN 2
98322: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98323: LD_EXP 136
98327: PUSH
98328: LD_EXP 181
98332: AND
98333: IFFALSE 98516
98335: GO 98337
98337: DISABLE
98338: LD_INT 0
98340: PPUSH
98341: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98342: LD_ADDR_VAR 0 2
98346: PUSH
98347: LD_INT 22
98349: PUSH
98350: LD_OWVAR 2
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PPUSH
98359: CALL_OW 69
98363: ST_TO_ADDR
// if not tmp then
98364: LD_VAR 0 2
98368: NOT
98369: IFFALSE 98373
// exit ;
98371: GO 98516
// for i := 1 to 2 do
98373: LD_ADDR_VAR 0 1
98377: PUSH
98378: DOUBLE
98379: LD_INT 1
98381: DEC
98382: ST_TO_ADDR
98383: LD_INT 2
98385: PUSH
98386: FOR_TO
98387: IFFALSE 98514
// begin uc_side := your_side ;
98389: LD_ADDR_OWVAR 20
98393: PUSH
98394: LD_OWVAR 2
98398: ST_TO_ADDR
// uc_nation := nation_american ;
98399: LD_ADDR_OWVAR 21
98403: PUSH
98404: LD_INT 1
98406: ST_TO_ADDR
// vc_chassis := us_morphling ;
98407: LD_ADDR_OWVAR 37
98411: PUSH
98412: LD_INT 5
98414: ST_TO_ADDR
// vc_engine := engine_siberite ;
98415: LD_ADDR_OWVAR 39
98419: PUSH
98420: LD_INT 3
98422: ST_TO_ADDR
// vc_control := control_computer ;
98423: LD_ADDR_OWVAR 38
98427: PUSH
98428: LD_INT 3
98430: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98431: LD_ADDR_OWVAR 40
98435: PUSH
98436: LD_INT 10
98438: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98439: LD_VAR 0 2
98443: PUSH
98444: LD_INT 1
98446: ARRAY
98447: PPUSH
98448: CALL_OW 310
98452: NOT
98453: IFFALSE 98500
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98455: CALL_OW 45
98459: PPUSH
98460: LD_VAR 0 2
98464: PUSH
98465: LD_INT 1
98467: ARRAY
98468: PPUSH
98469: CALL_OW 250
98473: PPUSH
98474: LD_VAR 0 2
98478: PUSH
98479: LD_INT 1
98481: ARRAY
98482: PPUSH
98483: CALL_OW 251
98487: PPUSH
98488: LD_INT 12
98490: PPUSH
98491: LD_INT 1
98493: PPUSH
98494: CALL_OW 50
98498: GO 98512
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98500: CALL_OW 45
98504: PPUSH
98505: LD_INT 1
98507: PPUSH
98508: CALL_OW 51
// end ;
98512: GO 98386
98514: POP
98515: POP
// end ;
98516: PPOPN 2
98518: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98519: LD_EXP 136
98523: PUSH
98524: LD_EXP 182
98528: AND
98529: IFFALSE 98751
98531: GO 98533
98533: DISABLE
98534: LD_INT 0
98536: PPUSH
98537: PPUSH
98538: PPUSH
98539: PPUSH
98540: PPUSH
98541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98542: LD_ADDR_VAR 0 6
98546: PUSH
98547: LD_INT 22
98549: PUSH
98550: LD_OWVAR 2
98554: PUSH
98555: EMPTY
98556: LIST
98557: LIST
98558: PUSH
98559: LD_INT 21
98561: PUSH
98562: LD_INT 1
98564: PUSH
98565: EMPTY
98566: LIST
98567: LIST
98568: PUSH
98569: LD_INT 3
98571: PUSH
98572: LD_INT 23
98574: PUSH
98575: LD_INT 0
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: EMPTY
98587: LIST
98588: LIST
98589: LIST
98590: PPUSH
98591: CALL_OW 69
98595: ST_TO_ADDR
// if not tmp then
98596: LD_VAR 0 6
98600: NOT
98601: IFFALSE 98605
// exit ;
98603: GO 98751
// s1 := rand ( 1 , 4 ) ;
98605: LD_ADDR_VAR 0 2
98609: PUSH
98610: LD_INT 1
98612: PPUSH
98613: LD_INT 4
98615: PPUSH
98616: CALL_OW 12
98620: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98621: LD_ADDR_VAR 0 4
98625: PUSH
98626: LD_VAR 0 6
98630: PUSH
98631: LD_INT 1
98633: ARRAY
98634: PPUSH
98635: LD_VAR 0 2
98639: PPUSH
98640: CALL_OW 259
98644: ST_TO_ADDR
// if s1 = 1 then
98645: LD_VAR 0 2
98649: PUSH
98650: LD_INT 1
98652: EQUAL
98653: IFFALSE 98673
// s2 := rand ( 2 , 4 ) else
98655: LD_ADDR_VAR 0 3
98659: PUSH
98660: LD_INT 2
98662: PPUSH
98663: LD_INT 4
98665: PPUSH
98666: CALL_OW 12
98670: ST_TO_ADDR
98671: GO 98681
// s2 := 1 ;
98673: LD_ADDR_VAR 0 3
98677: PUSH
98678: LD_INT 1
98680: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98681: LD_ADDR_VAR 0 5
98685: PUSH
98686: LD_VAR 0 6
98690: PUSH
98691: LD_INT 1
98693: ARRAY
98694: PPUSH
98695: LD_VAR 0 3
98699: PPUSH
98700: CALL_OW 259
98704: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98705: LD_VAR 0 6
98709: PUSH
98710: LD_INT 1
98712: ARRAY
98713: PPUSH
98714: LD_VAR 0 2
98718: PPUSH
98719: LD_VAR 0 5
98723: PPUSH
98724: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98728: LD_VAR 0 6
98732: PUSH
98733: LD_INT 1
98735: ARRAY
98736: PPUSH
98737: LD_VAR 0 3
98741: PPUSH
98742: LD_VAR 0 4
98746: PPUSH
98747: CALL_OW 237
// end ;
98751: PPOPN 6
98753: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98754: LD_EXP 136
98758: PUSH
98759: LD_EXP 183
98763: AND
98764: IFFALSE 98843
98766: GO 98768
98768: DISABLE
98769: LD_INT 0
98771: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98772: LD_ADDR_VAR 0 1
98776: PUSH
98777: LD_INT 22
98779: PUSH
98780: LD_OWVAR 2
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: PUSH
98789: LD_INT 30
98791: PUSH
98792: LD_INT 3
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PPUSH
98803: CALL_OW 69
98807: ST_TO_ADDR
// if not tmp then
98808: LD_VAR 0 1
98812: NOT
98813: IFFALSE 98817
// exit ;
98815: GO 98843
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98817: LD_VAR 0 1
98821: PUSH
98822: LD_INT 1
98824: PPUSH
98825: LD_VAR 0 1
98829: PPUSH
98830: CALL_OW 12
98834: ARRAY
98835: PPUSH
98836: LD_INT 1
98838: PPUSH
98839: CALL_OW 234
// end ;
98843: PPOPN 1
98845: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98846: LD_EXP 136
98850: PUSH
98851: LD_EXP 184
98855: AND
98856: IFFALSE 98968
98858: GO 98860
98860: DISABLE
98861: LD_INT 0
98863: PPUSH
98864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98865: LD_ADDR_VAR 0 2
98869: PUSH
98870: LD_INT 22
98872: PUSH
98873: LD_OWVAR 2
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: LD_INT 2
98884: PUSH
98885: LD_INT 30
98887: PUSH
98888: LD_INT 27
98890: PUSH
98891: EMPTY
98892: LIST
98893: LIST
98894: PUSH
98895: LD_INT 30
98897: PUSH
98898: LD_INT 26
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: LD_INT 30
98907: PUSH
98908: LD_INT 28
98910: PUSH
98911: EMPTY
98912: LIST
98913: LIST
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PPUSH
98925: CALL_OW 69
98929: ST_TO_ADDR
// if not tmp then
98930: LD_VAR 0 2
98934: NOT
98935: IFFALSE 98939
// exit ;
98937: GO 98968
// for i in tmp do
98939: LD_ADDR_VAR 0 1
98943: PUSH
98944: LD_VAR 0 2
98948: PUSH
98949: FOR_IN
98950: IFFALSE 98966
// SetLives ( i , 1 ) ;
98952: LD_VAR 0 1
98956: PPUSH
98957: LD_INT 1
98959: PPUSH
98960: CALL_OW 234
98964: GO 98949
98966: POP
98967: POP
// end ;
98968: PPOPN 2
98970: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98971: LD_EXP 136
98975: PUSH
98976: LD_EXP 185
98980: AND
98981: IFFALSE 99255
98983: GO 98985
98985: DISABLE
98986: LD_INT 0
98988: PPUSH
98989: PPUSH
98990: PPUSH
// begin i := rand ( 1 , 7 ) ;
98991: LD_ADDR_VAR 0 1
98995: PUSH
98996: LD_INT 1
98998: PPUSH
98999: LD_INT 7
99001: PPUSH
99002: CALL_OW 12
99006: ST_TO_ADDR
// case i of 1 :
99007: LD_VAR 0 1
99011: PUSH
99012: LD_INT 1
99014: DOUBLE
99015: EQUAL
99016: IFTRUE 99020
99018: GO 99030
99020: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99021: LD_STRING earthquake(getX(game), 0, 32)
99023: PPUSH
99024: CALL_OW 559
99028: GO 99255
99030: LD_INT 2
99032: DOUBLE
99033: EQUAL
99034: IFTRUE 99038
99036: GO 99052
99038: POP
// begin ToLua ( displayStucuk(); ) ;
99039: LD_STRING displayStucuk();
99041: PPUSH
99042: CALL_OW 559
// ResetFog ;
99046: CALL_OW 335
// end ; 3 :
99050: GO 99255
99052: LD_INT 3
99054: DOUBLE
99055: EQUAL
99056: IFTRUE 99060
99058: GO 99164
99060: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99061: LD_ADDR_VAR 0 2
99065: PUSH
99066: LD_INT 22
99068: PUSH
99069: LD_OWVAR 2
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: PUSH
99078: LD_INT 25
99080: PUSH
99081: LD_INT 1
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PPUSH
99092: CALL_OW 69
99096: ST_TO_ADDR
// if not tmp then
99097: LD_VAR 0 2
99101: NOT
99102: IFFALSE 99106
// exit ;
99104: GO 99255
// un := tmp [ rand ( 1 , tmp ) ] ;
99106: LD_ADDR_VAR 0 3
99110: PUSH
99111: LD_VAR 0 2
99115: PUSH
99116: LD_INT 1
99118: PPUSH
99119: LD_VAR 0 2
99123: PPUSH
99124: CALL_OW 12
99128: ARRAY
99129: ST_TO_ADDR
// if Crawls ( un ) then
99130: LD_VAR 0 3
99134: PPUSH
99135: CALL_OW 318
99139: IFFALSE 99150
// ComWalk ( un ) ;
99141: LD_VAR 0 3
99145: PPUSH
99146: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99150: LD_VAR 0 3
99154: PPUSH
99155: LD_INT 8
99157: PPUSH
99158: CALL_OW 336
// end ; 4 :
99162: GO 99255
99164: LD_INT 4
99166: DOUBLE
99167: EQUAL
99168: IFTRUE 99172
99170: GO 99233
99172: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99173: LD_ADDR_VAR 0 2
99177: PUSH
99178: LD_INT 22
99180: PUSH
99181: LD_OWVAR 2
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: LD_INT 30
99192: PUSH
99193: LD_INT 29
99195: PUSH
99196: EMPTY
99197: LIST
99198: LIST
99199: PUSH
99200: EMPTY
99201: LIST
99202: LIST
99203: PPUSH
99204: CALL_OW 69
99208: ST_TO_ADDR
// if not tmp then
99209: LD_VAR 0 2
99213: NOT
99214: IFFALSE 99218
// exit ;
99216: GO 99255
// DestroyUnit ( tmp [ 1 ] ) ;
99218: LD_VAR 0 2
99222: PUSH
99223: LD_INT 1
99225: ARRAY
99226: PPUSH
99227: CALL_OW 65
// end ; 5 .. 7 :
99231: GO 99255
99233: LD_INT 5
99235: DOUBLE
99236: GREATEREQUAL
99237: IFFALSE 99245
99239: LD_INT 7
99241: DOUBLE
99242: LESSEQUAL
99243: IFTRUE 99247
99245: GO 99254
99247: POP
// StreamSibBomb ; end ;
99248: CALL 95505 0 0
99252: GO 99255
99254: POP
// end ;
99255: PPOPN 3
99257: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99258: LD_EXP 136
99262: PUSH
99263: LD_EXP 186
99267: AND
99268: IFFALSE 99424
99270: GO 99272
99272: DISABLE
99273: LD_INT 0
99275: PPUSH
99276: PPUSH
99277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99278: LD_ADDR_VAR 0 2
99282: PUSH
99283: LD_INT 81
99285: PUSH
99286: LD_OWVAR 2
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: PUSH
99295: LD_INT 2
99297: PUSH
99298: LD_INT 21
99300: PUSH
99301: LD_INT 1
99303: PUSH
99304: EMPTY
99305: LIST
99306: LIST
99307: PUSH
99308: LD_INT 21
99310: PUSH
99311: LD_INT 2
99313: PUSH
99314: EMPTY
99315: LIST
99316: LIST
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: LIST
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: PPUSH
99327: CALL_OW 69
99331: ST_TO_ADDR
// if not tmp then
99332: LD_VAR 0 2
99336: NOT
99337: IFFALSE 99341
// exit ;
99339: GO 99424
// p := 0 ;
99341: LD_ADDR_VAR 0 3
99345: PUSH
99346: LD_INT 0
99348: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99349: LD_INT 35
99351: PPUSH
99352: CALL_OW 67
// p := p + 1 ;
99356: LD_ADDR_VAR 0 3
99360: PUSH
99361: LD_VAR 0 3
99365: PUSH
99366: LD_INT 1
99368: PLUS
99369: ST_TO_ADDR
// for i in tmp do
99370: LD_ADDR_VAR 0 1
99374: PUSH
99375: LD_VAR 0 2
99379: PUSH
99380: FOR_IN
99381: IFFALSE 99412
// if GetLives ( i ) < 1000 then
99383: LD_VAR 0 1
99387: PPUSH
99388: CALL_OW 256
99392: PUSH
99393: LD_INT 1000
99395: LESS
99396: IFFALSE 99410
// SetLives ( i , 1000 ) ;
99398: LD_VAR 0 1
99402: PPUSH
99403: LD_INT 1000
99405: PPUSH
99406: CALL_OW 234
99410: GO 99380
99412: POP
99413: POP
// until p > 20 ;
99414: LD_VAR 0 3
99418: PUSH
99419: LD_INT 20
99421: GREATER
99422: IFFALSE 99349
// end ;
99424: PPOPN 3
99426: END
// every 0 0$1 trigger StreamModeActive and sTime do
99427: LD_EXP 136
99431: PUSH
99432: LD_EXP 187
99436: AND
99437: IFFALSE 99472
99439: GO 99441
99441: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99442: LD_INT 28
99444: PPUSH
99445: LD_OWVAR 2
99449: PPUSH
99450: LD_INT 2
99452: PPUSH
99453: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99457: LD_INT 30
99459: PPUSH
99460: LD_OWVAR 2
99464: PPUSH
99465: LD_INT 2
99467: PPUSH
99468: CALL_OW 322
// end ;
99472: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99473: LD_EXP 136
99477: PUSH
99478: LD_EXP 188
99482: AND
99483: IFFALSE 99604
99485: GO 99487
99487: DISABLE
99488: LD_INT 0
99490: PPUSH
99491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99492: LD_ADDR_VAR 0 2
99496: PUSH
99497: LD_INT 22
99499: PUSH
99500: LD_OWVAR 2
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: PUSH
99509: LD_INT 21
99511: PUSH
99512: LD_INT 1
99514: PUSH
99515: EMPTY
99516: LIST
99517: LIST
99518: PUSH
99519: LD_INT 3
99521: PUSH
99522: LD_INT 23
99524: PUSH
99525: LD_INT 0
99527: PUSH
99528: EMPTY
99529: LIST
99530: LIST
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: LIST
99540: PPUSH
99541: CALL_OW 69
99545: ST_TO_ADDR
// if not tmp then
99546: LD_VAR 0 2
99550: NOT
99551: IFFALSE 99555
// exit ;
99553: GO 99604
// for i in tmp do
99555: LD_ADDR_VAR 0 1
99559: PUSH
99560: LD_VAR 0 2
99564: PUSH
99565: FOR_IN
99566: IFFALSE 99602
// begin if Crawls ( i ) then
99568: LD_VAR 0 1
99572: PPUSH
99573: CALL_OW 318
99577: IFFALSE 99588
// ComWalk ( i ) ;
99579: LD_VAR 0 1
99583: PPUSH
99584: CALL_OW 138
// SetClass ( i , 2 ) ;
99588: LD_VAR 0 1
99592: PPUSH
99593: LD_INT 2
99595: PPUSH
99596: CALL_OW 336
// end ;
99600: GO 99565
99602: POP
99603: POP
// end ;
99604: PPOPN 2
99606: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99607: LD_EXP 136
99611: PUSH
99612: LD_EXP 189
99616: AND
99617: IFFALSE 99898
99619: GO 99621
99621: DISABLE
99622: LD_INT 0
99624: PPUSH
99625: PPUSH
99626: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99627: LD_OWVAR 2
99631: PPUSH
99632: LD_INT 9
99634: PPUSH
99635: LD_INT 1
99637: PPUSH
99638: LD_INT 1
99640: PPUSH
99641: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99645: LD_INT 9
99647: PPUSH
99648: LD_OWVAR 2
99652: PPUSH
99653: CALL_OW 343
// uc_side := 9 ;
99657: LD_ADDR_OWVAR 20
99661: PUSH
99662: LD_INT 9
99664: ST_TO_ADDR
// uc_nation := 2 ;
99665: LD_ADDR_OWVAR 21
99669: PUSH
99670: LD_INT 2
99672: ST_TO_ADDR
// hc_name := Dark Warrior ;
99673: LD_ADDR_OWVAR 26
99677: PUSH
99678: LD_STRING Dark Warrior
99680: ST_TO_ADDR
// hc_gallery :=  ;
99681: LD_ADDR_OWVAR 33
99685: PUSH
99686: LD_STRING 
99688: ST_TO_ADDR
// hc_noskilllimit := true ;
99689: LD_ADDR_OWVAR 76
99693: PUSH
99694: LD_INT 1
99696: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99697: LD_ADDR_OWVAR 31
99701: PUSH
99702: LD_INT 30
99704: PUSH
99705: LD_INT 30
99707: PUSH
99708: LD_INT 30
99710: PUSH
99711: LD_INT 30
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: ST_TO_ADDR
// un := CreateHuman ;
99720: LD_ADDR_VAR 0 3
99724: PUSH
99725: CALL_OW 44
99729: ST_TO_ADDR
// hc_noskilllimit := false ;
99730: LD_ADDR_OWVAR 76
99734: PUSH
99735: LD_INT 0
99737: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99738: LD_VAR 0 3
99742: PPUSH
99743: LD_INT 1
99745: PPUSH
99746: CALL_OW 51
// p := 0 ;
99750: LD_ADDR_VAR 0 2
99754: PUSH
99755: LD_INT 0
99757: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99758: LD_INT 35
99760: PPUSH
99761: CALL_OW 67
// p := p + 1 ;
99765: LD_ADDR_VAR 0 2
99769: PUSH
99770: LD_VAR 0 2
99774: PUSH
99775: LD_INT 1
99777: PLUS
99778: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99779: LD_VAR 0 3
99783: PPUSH
99784: CALL_OW 256
99788: PUSH
99789: LD_INT 1000
99791: LESS
99792: IFFALSE 99806
// SetLives ( un , 1000 ) ;
99794: LD_VAR 0 3
99798: PPUSH
99799: LD_INT 1000
99801: PPUSH
99802: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99806: LD_VAR 0 3
99810: PPUSH
99811: LD_INT 81
99813: PUSH
99814: LD_OWVAR 2
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: LD_INT 91
99825: PUSH
99826: LD_VAR 0 3
99830: PUSH
99831: LD_INT 30
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: LIST
99838: PUSH
99839: EMPTY
99840: LIST
99841: LIST
99842: PPUSH
99843: CALL_OW 69
99847: PPUSH
99848: LD_VAR 0 3
99852: PPUSH
99853: CALL_OW 74
99857: PPUSH
99858: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99862: LD_VAR 0 2
99866: PUSH
99867: LD_INT 60
99869: GREATER
99870: PUSH
99871: LD_VAR 0 3
99875: PPUSH
99876: CALL_OW 301
99880: OR
99881: IFFALSE 99758
// if un then
99883: LD_VAR 0 3
99887: IFFALSE 99898
// RemoveUnit ( un ) ;
99889: LD_VAR 0 3
99893: PPUSH
99894: CALL_OW 64
// end ;
99898: PPOPN 3
99900: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99901: LD_INT 0
99903: PPUSH
// case cmd of 301 :
99904: LD_VAR 0 1
99908: PUSH
99909: LD_INT 301
99911: DOUBLE
99912: EQUAL
99913: IFTRUE 99917
99915: GO 99949
99917: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99918: LD_VAR 0 6
99922: PPUSH
99923: LD_VAR 0 7
99927: PPUSH
99928: LD_VAR 0 8
99932: PPUSH
99933: LD_VAR 0 4
99937: PPUSH
99938: LD_VAR 0 5
99942: PPUSH
99943: CALL 101150 0 5
99947: GO 100070
99949: LD_INT 302
99951: DOUBLE
99952: EQUAL
99953: IFTRUE 99957
99955: GO 99994
99957: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99958: LD_VAR 0 6
99962: PPUSH
99963: LD_VAR 0 7
99967: PPUSH
99968: LD_VAR 0 8
99972: PPUSH
99973: LD_VAR 0 9
99977: PPUSH
99978: LD_VAR 0 4
99982: PPUSH
99983: LD_VAR 0 5
99987: PPUSH
99988: CALL 101241 0 6
99992: GO 100070
99994: LD_INT 303
99996: DOUBLE
99997: EQUAL
99998: IFTRUE 100002
100000: GO 100039
100002: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100003: LD_VAR 0 6
100007: PPUSH
100008: LD_VAR 0 7
100012: PPUSH
100013: LD_VAR 0 8
100017: PPUSH
100018: LD_VAR 0 9
100022: PPUSH
100023: LD_VAR 0 4
100027: PPUSH
100028: LD_VAR 0 5
100032: PPUSH
100033: CALL 100075 0 6
100037: GO 100070
100039: LD_INT 304
100041: DOUBLE
100042: EQUAL
100043: IFTRUE 100047
100045: GO 100069
100047: POP
// hHackTeleport ( unit , x , y ) ; end ;
100048: LD_VAR 0 2
100052: PPUSH
100053: LD_VAR 0 4
100057: PPUSH
100058: LD_VAR 0 5
100062: PPUSH
100063: CALL 101834 0 3
100067: GO 100070
100069: POP
// end ;
100070: LD_VAR 0 12
100074: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100075: LD_INT 0
100077: PPUSH
100078: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100079: LD_VAR 0 1
100083: PUSH
100084: LD_INT 1
100086: LESS
100087: PUSH
100088: LD_VAR 0 1
100092: PUSH
100093: LD_INT 3
100095: GREATER
100096: OR
100097: PUSH
100098: LD_VAR 0 5
100102: PPUSH
100103: LD_VAR 0 6
100107: PPUSH
100108: CALL_OW 428
100112: OR
100113: IFFALSE 100117
// exit ;
100115: GO 100837
// uc_side := your_side ;
100117: LD_ADDR_OWVAR 20
100121: PUSH
100122: LD_OWVAR 2
100126: ST_TO_ADDR
// uc_nation := nation ;
100127: LD_ADDR_OWVAR 21
100131: PUSH
100132: LD_VAR 0 1
100136: ST_TO_ADDR
// bc_level = 1 ;
100137: LD_ADDR_OWVAR 43
100141: PUSH
100142: LD_INT 1
100144: ST_TO_ADDR
// case btype of 1 :
100145: LD_VAR 0 2
100149: PUSH
100150: LD_INT 1
100152: DOUBLE
100153: EQUAL
100154: IFTRUE 100158
100156: GO 100169
100158: POP
// bc_type := b_depot ; 2 :
100159: LD_ADDR_OWVAR 42
100163: PUSH
100164: LD_INT 0
100166: ST_TO_ADDR
100167: GO 100781
100169: LD_INT 2
100171: DOUBLE
100172: EQUAL
100173: IFTRUE 100177
100175: GO 100188
100177: POP
// bc_type := b_warehouse ; 3 :
100178: LD_ADDR_OWVAR 42
100182: PUSH
100183: LD_INT 1
100185: ST_TO_ADDR
100186: GO 100781
100188: LD_INT 3
100190: DOUBLE
100191: EQUAL
100192: IFTRUE 100196
100194: GO 100207
100196: POP
// bc_type := b_lab ; 4 .. 9 :
100197: LD_ADDR_OWVAR 42
100201: PUSH
100202: LD_INT 6
100204: ST_TO_ADDR
100205: GO 100781
100207: LD_INT 4
100209: DOUBLE
100210: GREATEREQUAL
100211: IFFALSE 100219
100213: LD_INT 9
100215: DOUBLE
100216: LESSEQUAL
100217: IFTRUE 100221
100219: GO 100273
100221: POP
// begin bc_type := b_lab_half ;
100222: LD_ADDR_OWVAR 42
100226: PUSH
100227: LD_INT 7
100229: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100230: LD_ADDR_OWVAR 44
100234: PUSH
100235: LD_INT 10
100237: PUSH
100238: LD_INT 11
100240: PUSH
100241: LD_INT 12
100243: PUSH
100244: LD_INT 15
100246: PUSH
100247: LD_INT 14
100249: PUSH
100250: LD_INT 13
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: LIST
100257: LIST
100258: LIST
100259: LIST
100260: PUSH
100261: LD_VAR 0 2
100265: PUSH
100266: LD_INT 3
100268: MINUS
100269: ARRAY
100270: ST_TO_ADDR
// end ; 10 .. 13 :
100271: GO 100781
100273: LD_INT 10
100275: DOUBLE
100276: GREATEREQUAL
100277: IFFALSE 100285
100279: LD_INT 13
100281: DOUBLE
100282: LESSEQUAL
100283: IFTRUE 100287
100285: GO 100364
100287: POP
// begin bc_type := b_lab_full ;
100288: LD_ADDR_OWVAR 42
100292: PUSH
100293: LD_INT 8
100295: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100296: LD_ADDR_OWVAR 44
100300: PUSH
100301: LD_INT 10
100303: PUSH
100304: LD_INT 12
100306: PUSH
100307: LD_INT 14
100309: PUSH
100310: LD_INT 13
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: LIST
100317: LIST
100318: PUSH
100319: LD_VAR 0 2
100323: PUSH
100324: LD_INT 9
100326: MINUS
100327: ARRAY
100328: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100329: LD_ADDR_OWVAR 45
100333: PUSH
100334: LD_INT 11
100336: PUSH
100337: LD_INT 15
100339: PUSH
100340: LD_INT 12
100342: PUSH
100343: LD_INT 15
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: PUSH
100352: LD_VAR 0 2
100356: PUSH
100357: LD_INT 9
100359: MINUS
100360: ARRAY
100361: ST_TO_ADDR
// end ; 14 :
100362: GO 100781
100364: LD_INT 14
100366: DOUBLE
100367: EQUAL
100368: IFTRUE 100372
100370: GO 100383
100372: POP
// bc_type := b_workshop ; 15 :
100373: LD_ADDR_OWVAR 42
100377: PUSH
100378: LD_INT 2
100380: ST_TO_ADDR
100381: GO 100781
100383: LD_INT 15
100385: DOUBLE
100386: EQUAL
100387: IFTRUE 100391
100389: GO 100402
100391: POP
// bc_type := b_factory ; 16 :
100392: LD_ADDR_OWVAR 42
100396: PUSH
100397: LD_INT 3
100399: ST_TO_ADDR
100400: GO 100781
100402: LD_INT 16
100404: DOUBLE
100405: EQUAL
100406: IFTRUE 100410
100408: GO 100421
100410: POP
// bc_type := b_ext_gun ; 17 :
100411: LD_ADDR_OWVAR 42
100415: PUSH
100416: LD_INT 17
100418: ST_TO_ADDR
100419: GO 100781
100421: LD_INT 17
100423: DOUBLE
100424: EQUAL
100425: IFTRUE 100429
100427: GO 100457
100429: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100430: LD_ADDR_OWVAR 42
100434: PUSH
100435: LD_INT 19
100437: PUSH
100438: LD_INT 23
100440: PUSH
100441: LD_INT 19
100443: PUSH
100444: EMPTY
100445: LIST
100446: LIST
100447: LIST
100448: PUSH
100449: LD_VAR 0 1
100453: ARRAY
100454: ST_TO_ADDR
100455: GO 100781
100457: LD_INT 18
100459: DOUBLE
100460: EQUAL
100461: IFTRUE 100465
100463: GO 100476
100465: POP
// bc_type := b_ext_radar ; 19 :
100466: LD_ADDR_OWVAR 42
100470: PUSH
100471: LD_INT 20
100473: ST_TO_ADDR
100474: GO 100781
100476: LD_INT 19
100478: DOUBLE
100479: EQUAL
100480: IFTRUE 100484
100482: GO 100495
100484: POP
// bc_type := b_ext_radio ; 20 :
100485: LD_ADDR_OWVAR 42
100489: PUSH
100490: LD_INT 22
100492: ST_TO_ADDR
100493: GO 100781
100495: LD_INT 20
100497: DOUBLE
100498: EQUAL
100499: IFTRUE 100503
100501: GO 100514
100503: POP
// bc_type := b_ext_siberium ; 21 :
100504: LD_ADDR_OWVAR 42
100508: PUSH
100509: LD_INT 21
100511: ST_TO_ADDR
100512: GO 100781
100514: LD_INT 21
100516: DOUBLE
100517: EQUAL
100518: IFTRUE 100522
100520: GO 100533
100522: POP
// bc_type := b_ext_computer ; 22 :
100523: LD_ADDR_OWVAR 42
100527: PUSH
100528: LD_INT 24
100530: ST_TO_ADDR
100531: GO 100781
100533: LD_INT 22
100535: DOUBLE
100536: EQUAL
100537: IFTRUE 100541
100539: GO 100552
100541: POP
// bc_type := b_ext_track ; 23 :
100542: LD_ADDR_OWVAR 42
100546: PUSH
100547: LD_INT 16
100549: ST_TO_ADDR
100550: GO 100781
100552: LD_INT 23
100554: DOUBLE
100555: EQUAL
100556: IFTRUE 100560
100558: GO 100571
100560: POP
// bc_type := b_ext_laser ; 24 :
100561: LD_ADDR_OWVAR 42
100565: PUSH
100566: LD_INT 25
100568: ST_TO_ADDR
100569: GO 100781
100571: LD_INT 24
100573: DOUBLE
100574: EQUAL
100575: IFTRUE 100579
100577: GO 100590
100579: POP
// bc_type := b_control_tower ; 25 :
100580: LD_ADDR_OWVAR 42
100584: PUSH
100585: LD_INT 36
100587: ST_TO_ADDR
100588: GO 100781
100590: LD_INT 25
100592: DOUBLE
100593: EQUAL
100594: IFTRUE 100598
100596: GO 100609
100598: POP
// bc_type := b_breastwork ; 26 :
100599: LD_ADDR_OWVAR 42
100603: PUSH
100604: LD_INT 31
100606: ST_TO_ADDR
100607: GO 100781
100609: LD_INT 26
100611: DOUBLE
100612: EQUAL
100613: IFTRUE 100617
100615: GO 100628
100617: POP
// bc_type := b_bunker ; 27 :
100618: LD_ADDR_OWVAR 42
100622: PUSH
100623: LD_INT 32
100625: ST_TO_ADDR
100626: GO 100781
100628: LD_INT 27
100630: DOUBLE
100631: EQUAL
100632: IFTRUE 100636
100634: GO 100647
100636: POP
// bc_type := b_turret ; 28 :
100637: LD_ADDR_OWVAR 42
100641: PUSH
100642: LD_INT 33
100644: ST_TO_ADDR
100645: GO 100781
100647: LD_INT 28
100649: DOUBLE
100650: EQUAL
100651: IFTRUE 100655
100653: GO 100666
100655: POP
// bc_type := b_armoury ; 29 :
100656: LD_ADDR_OWVAR 42
100660: PUSH
100661: LD_INT 4
100663: ST_TO_ADDR
100664: GO 100781
100666: LD_INT 29
100668: DOUBLE
100669: EQUAL
100670: IFTRUE 100674
100672: GO 100685
100674: POP
// bc_type := b_barracks ; 30 :
100675: LD_ADDR_OWVAR 42
100679: PUSH
100680: LD_INT 5
100682: ST_TO_ADDR
100683: GO 100781
100685: LD_INT 30
100687: DOUBLE
100688: EQUAL
100689: IFTRUE 100693
100691: GO 100704
100693: POP
// bc_type := b_solar_power ; 31 :
100694: LD_ADDR_OWVAR 42
100698: PUSH
100699: LD_INT 27
100701: ST_TO_ADDR
100702: GO 100781
100704: LD_INT 31
100706: DOUBLE
100707: EQUAL
100708: IFTRUE 100712
100710: GO 100723
100712: POP
// bc_type := b_oil_power ; 32 :
100713: LD_ADDR_OWVAR 42
100717: PUSH
100718: LD_INT 26
100720: ST_TO_ADDR
100721: GO 100781
100723: LD_INT 32
100725: DOUBLE
100726: EQUAL
100727: IFTRUE 100731
100729: GO 100742
100731: POP
// bc_type := b_siberite_power ; 33 :
100732: LD_ADDR_OWVAR 42
100736: PUSH
100737: LD_INT 28
100739: ST_TO_ADDR
100740: GO 100781
100742: LD_INT 33
100744: DOUBLE
100745: EQUAL
100746: IFTRUE 100750
100748: GO 100761
100750: POP
// bc_type := b_oil_mine ; 34 :
100751: LD_ADDR_OWVAR 42
100755: PUSH
100756: LD_INT 29
100758: ST_TO_ADDR
100759: GO 100781
100761: LD_INT 34
100763: DOUBLE
100764: EQUAL
100765: IFTRUE 100769
100767: GO 100780
100769: POP
// bc_type := b_siberite_mine ; end ;
100770: LD_ADDR_OWVAR 42
100774: PUSH
100775: LD_INT 30
100777: ST_TO_ADDR
100778: GO 100781
100780: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100781: LD_ADDR_VAR 0 8
100785: PUSH
100786: LD_VAR 0 5
100790: PPUSH
100791: LD_VAR 0 6
100795: PPUSH
100796: LD_VAR 0 3
100800: PPUSH
100801: CALL_OW 47
100805: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100806: LD_OWVAR 42
100810: PUSH
100811: LD_INT 32
100813: PUSH
100814: LD_INT 33
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: IN
100821: IFFALSE 100837
// PlaceWeaponTurret ( b , weapon ) ;
100823: LD_VAR 0 8
100827: PPUSH
100828: LD_VAR 0 4
100832: PPUSH
100833: CALL_OW 431
// end ;
100837: LD_VAR 0 7
100841: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100842: LD_INT 0
100844: PPUSH
100845: PPUSH
100846: PPUSH
100847: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100848: LD_ADDR_VAR 0 4
100852: PUSH
100853: LD_INT 22
100855: PUSH
100856: LD_OWVAR 2
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: PUSH
100865: LD_INT 2
100867: PUSH
100868: LD_INT 30
100870: PUSH
100871: LD_INT 0
100873: PUSH
100874: EMPTY
100875: LIST
100876: LIST
100877: PUSH
100878: LD_INT 30
100880: PUSH
100881: LD_INT 1
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PUSH
100888: EMPTY
100889: LIST
100890: LIST
100891: LIST
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: PPUSH
100897: CALL_OW 69
100901: ST_TO_ADDR
// if not tmp then
100902: LD_VAR 0 4
100906: NOT
100907: IFFALSE 100911
// exit ;
100909: GO 100970
// for i in tmp do
100911: LD_ADDR_VAR 0 2
100915: PUSH
100916: LD_VAR 0 4
100920: PUSH
100921: FOR_IN
100922: IFFALSE 100968
// for j = 1 to 3 do
100924: LD_ADDR_VAR 0 3
100928: PUSH
100929: DOUBLE
100930: LD_INT 1
100932: DEC
100933: ST_TO_ADDR
100934: LD_INT 3
100936: PUSH
100937: FOR_TO
100938: IFFALSE 100964
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100940: LD_VAR 0 2
100944: PPUSH
100945: CALL_OW 274
100949: PPUSH
100950: LD_VAR 0 3
100954: PPUSH
100955: LD_INT 99999
100957: PPUSH
100958: CALL_OW 277
100962: GO 100937
100964: POP
100965: POP
100966: GO 100921
100968: POP
100969: POP
// end ;
100970: LD_VAR 0 1
100974: RET
// export function hHackSetLevel10 ; var i , j ; begin
100975: LD_INT 0
100977: PPUSH
100978: PPUSH
100979: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100980: LD_ADDR_VAR 0 2
100984: PUSH
100985: LD_INT 21
100987: PUSH
100988: LD_INT 1
100990: PUSH
100991: EMPTY
100992: LIST
100993: LIST
100994: PPUSH
100995: CALL_OW 69
100999: PUSH
101000: FOR_IN
101001: IFFALSE 101053
// if IsSelected ( i ) then
101003: LD_VAR 0 2
101007: PPUSH
101008: CALL_OW 306
101012: IFFALSE 101051
// begin for j := 1 to 4 do
101014: LD_ADDR_VAR 0 3
101018: PUSH
101019: DOUBLE
101020: LD_INT 1
101022: DEC
101023: ST_TO_ADDR
101024: LD_INT 4
101026: PUSH
101027: FOR_TO
101028: IFFALSE 101049
// SetSkill ( i , j , 10 ) ;
101030: LD_VAR 0 2
101034: PPUSH
101035: LD_VAR 0 3
101039: PPUSH
101040: LD_INT 10
101042: PPUSH
101043: CALL_OW 237
101047: GO 101027
101049: POP
101050: POP
// end ;
101051: GO 101000
101053: POP
101054: POP
// end ;
101055: LD_VAR 0 1
101059: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101060: LD_INT 0
101062: PPUSH
101063: PPUSH
101064: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101065: LD_ADDR_VAR 0 2
101069: PUSH
101070: LD_INT 22
101072: PUSH
101073: LD_OWVAR 2
101077: PUSH
101078: EMPTY
101079: LIST
101080: LIST
101081: PUSH
101082: LD_INT 21
101084: PUSH
101085: LD_INT 1
101087: PUSH
101088: EMPTY
101089: LIST
101090: LIST
101091: PUSH
101092: EMPTY
101093: LIST
101094: LIST
101095: PPUSH
101096: CALL_OW 69
101100: PUSH
101101: FOR_IN
101102: IFFALSE 101143
// begin for j := 1 to 4 do
101104: LD_ADDR_VAR 0 3
101108: PUSH
101109: DOUBLE
101110: LD_INT 1
101112: DEC
101113: ST_TO_ADDR
101114: LD_INT 4
101116: PUSH
101117: FOR_TO
101118: IFFALSE 101139
// SetSkill ( i , j , 10 ) ;
101120: LD_VAR 0 2
101124: PPUSH
101125: LD_VAR 0 3
101129: PPUSH
101130: LD_INT 10
101132: PPUSH
101133: CALL_OW 237
101137: GO 101117
101139: POP
101140: POP
// end ;
101141: GO 101101
101143: POP
101144: POP
// end ;
101145: LD_VAR 0 1
101149: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101150: LD_INT 0
101152: PPUSH
// uc_side := your_side ;
101153: LD_ADDR_OWVAR 20
101157: PUSH
101158: LD_OWVAR 2
101162: ST_TO_ADDR
// uc_nation := nation ;
101163: LD_ADDR_OWVAR 21
101167: PUSH
101168: LD_VAR 0 1
101172: ST_TO_ADDR
// InitHc ;
101173: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101177: LD_INT 0
101179: PPUSH
101180: LD_VAR 0 2
101184: PPUSH
101185: LD_VAR 0 3
101189: PPUSH
101190: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101194: LD_VAR 0 4
101198: PPUSH
101199: LD_VAR 0 5
101203: PPUSH
101204: CALL_OW 428
101208: PUSH
101209: LD_INT 0
101211: EQUAL
101212: IFFALSE 101236
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101214: CALL_OW 44
101218: PPUSH
101219: LD_VAR 0 4
101223: PPUSH
101224: LD_VAR 0 5
101228: PPUSH
101229: LD_INT 1
101231: PPUSH
101232: CALL_OW 48
// end ;
101236: LD_VAR 0 6
101240: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101241: LD_INT 0
101243: PPUSH
101244: PPUSH
// uc_side := your_side ;
101245: LD_ADDR_OWVAR 20
101249: PUSH
101250: LD_OWVAR 2
101254: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101255: LD_VAR 0 1
101259: PUSH
101260: LD_INT 1
101262: PUSH
101263: LD_INT 2
101265: PUSH
101266: LD_INT 3
101268: PUSH
101269: LD_INT 4
101271: PUSH
101272: LD_INT 5
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: IN
101282: IFFALSE 101294
// uc_nation := nation_american else
101284: LD_ADDR_OWVAR 21
101288: PUSH
101289: LD_INT 1
101291: ST_TO_ADDR
101292: GO 101337
// if chassis in [ 11 , 12 , 13 , 14 ] then
101294: LD_VAR 0 1
101298: PUSH
101299: LD_INT 11
101301: PUSH
101302: LD_INT 12
101304: PUSH
101305: LD_INT 13
101307: PUSH
101308: LD_INT 14
101310: PUSH
101311: EMPTY
101312: LIST
101313: LIST
101314: LIST
101315: LIST
101316: IN
101317: IFFALSE 101329
// uc_nation := nation_arabian else
101319: LD_ADDR_OWVAR 21
101323: PUSH
101324: LD_INT 2
101326: ST_TO_ADDR
101327: GO 101337
// uc_nation := nation_russian ;
101329: LD_ADDR_OWVAR 21
101333: PUSH
101334: LD_INT 3
101336: ST_TO_ADDR
// vc_chassis := chassis ;
101337: LD_ADDR_OWVAR 37
101341: PUSH
101342: LD_VAR 0 1
101346: ST_TO_ADDR
// vc_engine := engine ;
101347: LD_ADDR_OWVAR 39
101351: PUSH
101352: LD_VAR 0 2
101356: ST_TO_ADDR
// vc_control := control ;
101357: LD_ADDR_OWVAR 38
101361: PUSH
101362: LD_VAR 0 3
101366: ST_TO_ADDR
// vc_weapon := weapon ;
101367: LD_ADDR_OWVAR 40
101371: PUSH
101372: LD_VAR 0 4
101376: ST_TO_ADDR
// un := CreateVehicle ;
101377: LD_ADDR_VAR 0 8
101381: PUSH
101382: CALL_OW 45
101386: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101387: LD_VAR 0 8
101391: PPUSH
101392: LD_INT 0
101394: PPUSH
101395: LD_INT 5
101397: PPUSH
101398: CALL_OW 12
101402: PPUSH
101403: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101407: LD_VAR 0 8
101411: PPUSH
101412: LD_VAR 0 5
101416: PPUSH
101417: LD_VAR 0 6
101421: PPUSH
101422: LD_INT 1
101424: PPUSH
101425: CALL_OW 48
// end ;
101429: LD_VAR 0 7
101433: RET
// export hInvincible ; every 1 do
101434: GO 101436
101436: DISABLE
// hInvincible := [ ] ;
101437: LD_ADDR_EXP 190
101441: PUSH
101442: EMPTY
101443: ST_TO_ADDR
101444: END
// every 10 do var i ;
101445: GO 101447
101447: DISABLE
101448: LD_INT 0
101450: PPUSH
// begin enable ;
101451: ENABLE
// if not hInvincible then
101452: LD_EXP 190
101456: NOT
101457: IFFALSE 101461
// exit ;
101459: GO 101505
// for i in hInvincible do
101461: LD_ADDR_VAR 0 1
101465: PUSH
101466: LD_EXP 190
101470: PUSH
101471: FOR_IN
101472: IFFALSE 101503
// if GetLives ( i ) < 1000 then
101474: LD_VAR 0 1
101478: PPUSH
101479: CALL_OW 256
101483: PUSH
101484: LD_INT 1000
101486: LESS
101487: IFFALSE 101501
// SetLives ( i , 1000 ) ;
101489: LD_VAR 0 1
101493: PPUSH
101494: LD_INT 1000
101496: PPUSH
101497: CALL_OW 234
101501: GO 101471
101503: POP
101504: POP
// end ;
101505: PPOPN 1
101507: END
// export function hHackInvincible ; var i ; begin
101508: LD_INT 0
101510: PPUSH
101511: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101512: LD_ADDR_VAR 0 2
101516: PUSH
101517: LD_INT 2
101519: PUSH
101520: LD_INT 21
101522: PUSH
101523: LD_INT 1
101525: PUSH
101526: EMPTY
101527: LIST
101528: LIST
101529: PUSH
101530: LD_INT 21
101532: PUSH
101533: LD_INT 2
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: PUSH
101540: EMPTY
101541: LIST
101542: LIST
101543: LIST
101544: PPUSH
101545: CALL_OW 69
101549: PUSH
101550: FOR_IN
101551: IFFALSE 101612
// if IsSelected ( i ) then
101553: LD_VAR 0 2
101557: PPUSH
101558: CALL_OW 306
101562: IFFALSE 101610
// begin if i in hInvincible then
101564: LD_VAR 0 2
101568: PUSH
101569: LD_EXP 190
101573: IN
101574: IFFALSE 101594
// hInvincible := hInvincible diff i else
101576: LD_ADDR_EXP 190
101580: PUSH
101581: LD_EXP 190
101585: PUSH
101586: LD_VAR 0 2
101590: DIFF
101591: ST_TO_ADDR
101592: GO 101610
// hInvincible := hInvincible union i ;
101594: LD_ADDR_EXP 190
101598: PUSH
101599: LD_EXP 190
101603: PUSH
101604: LD_VAR 0 2
101608: UNION
101609: ST_TO_ADDR
// end ;
101610: GO 101550
101612: POP
101613: POP
// end ;
101614: LD_VAR 0 1
101618: RET
// export function hHackInvisible ; var i , j ; begin
101619: LD_INT 0
101621: PPUSH
101622: PPUSH
101623: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101624: LD_ADDR_VAR 0 2
101628: PUSH
101629: LD_INT 21
101631: PUSH
101632: LD_INT 1
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: PPUSH
101639: CALL_OW 69
101643: PUSH
101644: FOR_IN
101645: IFFALSE 101669
// if IsSelected ( i ) then
101647: LD_VAR 0 2
101651: PPUSH
101652: CALL_OW 306
101656: IFFALSE 101667
// ComForceInvisible ( i ) ;
101658: LD_VAR 0 2
101662: PPUSH
101663: CALL_OW 496
101667: GO 101644
101669: POP
101670: POP
// end ;
101671: LD_VAR 0 1
101675: RET
// export function hHackChangeYourSide ; begin
101676: LD_INT 0
101678: PPUSH
// if your_side = 8 then
101679: LD_OWVAR 2
101683: PUSH
101684: LD_INT 8
101686: EQUAL
101687: IFFALSE 101699
// your_side := 0 else
101689: LD_ADDR_OWVAR 2
101693: PUSH
101694: LD_INT 0
101696: ST_TO_ADDR
101697: GO 101713
// your_side := your_side + 1 ;
101699: LD_ADDR_OWVAR 2
101703: PUSH
101704: LD_OWVAR 2
101708: PUSH
101709: LD_INT 1
101711: PLUS
101712: ST_TO_ADDR
// end ;
101713: LD_VAR 0 1
101717: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101718: LD_INT 0
101720: PPUSH
101721: PPUSH
101722: PPUSH
// for i in all_units do
101723: LD_ADDR_VAR 0 2
101727: PUSH
101728: LD_OWVAR 3
101732: PUSH
101733: FOR_IN
101734: IFFALSE 101812
// if IsSelected ( i ) then
101736: LD_VAR 0 2
101740: PPUSH
101741: CALL_OW 306
101745: IFFALSE 101810
// begin j := GetSide ( i ) ;
101747: LD_ADDR_VAR 0 3
101751: PUSH
101752: LD_VAR 0 2
101756: PPUSH
101757: CALL_OW 255
101761: ST_TO_ADDR
// if j = 8 then
101762: LD_VAR 0 3
101766: PUSH
101767: LD_INT 8
101769: EQUAL
101770: IFFALSE 101782
// j := 0 else
101772: LD_ADDR_VAR 0 3
101776: PUSH
101777: LD_INT 0
101779: ST_TO_ADDR
101780: GO 101796
// j := j + 1 ;
101782: LD_ADDR_VAR 0 3
101786: PUSH
101787: LD_VAR 0 3
101791: PUSH
101792: LD_INT 1
101794: PLUS
101795: ST_TO_ADDR
// SetSide ( i , j ) ;
101796: LD_VAR 0 2
101800: PPUSH
101801: LD_VAR 0 3
101805: PPUSH
101806: CALL_OW 235
// end ;
101810: GO 101733
101812: POP
101813: POP
// end ;
101814: LD_VAR 0 1
101818: RET
// export function hHackFog ; begin
101819: LD_INT 0
101821: PPUSH
// FogOff ( true ) ;
101822: LD_INT 1
101824: PPUSH
101825: CALL_OW 344
// end ;
101829: LD_VAR 0 1
101833: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101834: LD_INT 0
101836: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101837: LD_VAR 0 1
101841: PPUSH
101842: LD_VAR 0 2
101846: PPUSH
101847: LD_VAR 0 3
101851: PPUSH
101852: LD_INT 1
101854: PPUSH
101855: LD_INT 1
101857: PPUSH
101858: CALL_OW 483
// CenterOnXY ( x , y ) ;
101862: LD_VAR 0 2
101866: PPUSH
101867: LD_VAR 0 3
101871: PPUSH
101872: CALL_OW 84
// end ; end_of_file
101876: LD_VAR 0 4
101880: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101881: LD_INT 0
101883: PPUSH
101884: PPUSH
101885: PPUSH
101886: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101887: LD_VAR 0 1
101891: PPUSH
101892: CALL_OW 264
101896: PUSH
101897: LD_EXP 76
101901: EQUAL
101902: IFFALSE 101974
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101904: LD_INT 68
101906: PPUSH
101907: LD_VAR 0 1
101911: PPUSH
101912: CALL_OW 255
101916: PPUSH
101917: CALL_OW 321
101921: PUSH
101922: LD_INT 2
101924: EQUAL
101925: IFFALSE 101937
// eff := 70 else
101927: LD_ADDR_VAR 0 4
101931: PUSH
101932: LD_INT 70
101934: ST_TO_ADDR
101935: GO 101945
// eff := 30 ;
101937: LD_ADDR_VAR 0 4
101941: PUSH
101942: LD_INT 30
101944: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101945: LD_VAR 0 1
101949: PPUSH
101950: CALL_OW 250
101954: PPUSH
101955: LD_VAR 0 1
101959: PPUSH
101960: CALL_OW 251
101964: PPUSH
101965: LD_VAR 0 4
101969: PPUSH
101970: CALL_OW 495
// end ; end ;
101974: LD_VAR 0 2
101978: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101979: LD_INT 0
101981: PPUSH
// end ;
101982: LD_VAR 0 4
101986: RET
// export function SOS_Command ( cmd ) ; begin
101987: LD_INT 0
101989: PPUSH
// end ;
101990: LD_VAR 0 2
101994: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101995: LD_INT 0
101997: PPUSH
// if cmd = 121 then
101998: LD_VAR 0 1
102002: PUSH
102003: LD_INT 121
102005: EQUAL
102006: IFFALSE 102008
// end ;
102008: LD_VAR 0 6
102012: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102013: LD_INT 0
102015: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102016: LD_VAR 0 1
102020: PUSH
102021: LD_INT 250
102023: EQUAL
102024: PUSH
102025: LD_VAR 0 2
102029: PPUSH
102030: CALL_OW 264
102034: PUSH
102035: LD_EXP 79
102039: EQUAL
102040: AND
102041: IFFALSE 102062
// MinerPlaceMine ( unit , x , y ) ;
102043: LD_VAR 0 2
102047: PPUSH
102048: LD_VAR 0 4
102052: PPUSH
102053: LD_VAR 0 5
102057: PPUSH
102058: CALL 104411 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102062: LD_VAR 0 1
102066: PUSH
102067: LD_INT 251
102069: EQUAL
102070: PUSH
102071: LD_VAR 0 2
102075: PPUSH
102076: CALL_OW 264
102080: PUSH
102081: LD_EXP 79
102085: EQUAL
102086: AND
102087: IFFALSE 102108
// MinerDetonateMine ( unit , x , y ) ;
102089: LD_VAR 0 2
102093: PPUSH
102094: LD_VAR 0 4
102098: PPUSH
102099: LD_VAR 0 5
102103: PPUSH
102104: CALL 104688 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102108: LD_VAR 0 1
102112: PUSH
102113: LD_INT 252
102115: EQUAL
102116: PUSH
102117: LD_VAR 0 2
102121: PPUSH
102122: CALL_OW 264
102126: PUSH
102127: LD_EXP 79
102131: EQUAL
102132: AND
102133: IFFALSE 102154
// MinerCreateMinefield ( unit , x , y ) ;
102135: LD_VAR 0 2
102139: PPUSH
102140: LD_VAR 0 4
102144: PPUSH
102145: LD_VAR 0 5
102149: PPUSH
102150: CALL 105105 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
102154: LD_VAR 0 1
102158: PUSH
102159: LD_INT 253
102161: EQUAL
102162: PUSH
102163: LD_VAR 0 2
102167: PPUSH
102168: CALL_OW 257
102172: PUSH
102173: LD_INT 5
102175: EQUAL
102176: AND
102177: IFFALSE 102198
// ComBinocular ( unit , x , y ) ;
102179: LD_VAR 0 2
102183: PPUSH
102184: LD_VAR 0 4
102188: PPUSH
102189: LD_VAR 0 5
102193: PPUSH
102194: CALL 105476 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102198: LD_VAR 0 1
102202: PUSH
102203: LD_INT 254
102205: EQUAL
102206: PUSH
102207: LD_VAR 0 2
102211: PPUSH
102212: CALL_OW 264
102216: PUSH
102217: LD_EXP 74
102221: EQUAL
102222: AND
102223: PUSH
102224: LD_VAR 0 3
102228: PPUSH
102229: CALL_OW 263
102233: PUSH
102234: LD_INT 3
102236: EQUAL
102237: AND
102238: IFFALSE 102254
// HackDestroyVehicle ( unit , selectedUnit ) ;
102240: LD_VAR 0 2
102244: PPUSH
102245: LD_VAR 0 3
102249: PPUSH
102250: CALL 103771 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102254: LD_VAR 0 1
102258: PUSH
102259: LD_INT 255
102261: EQUAL
102262: PUSH
102263: LD_VAR 0 2
102267: PPUSH
102268: CALL_OW 264
102272: PUSH
102273: LD_INT 14
102275: PUSH
102276: LD_INT 53
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: IN
102283: AND
102284: PUSH
102285: LD_VAR 0 4
102289: PPUSH
102290: LD_VAR 0 5
102294: PPUSH
102295: CALL_OW 488
102299: AND
102300: IFFALSE 102324
// CutTreeXYR ( unit , x , y , 12 ) ;
102302: LD_VAR 0 2
102306: PPUSH
102307: LD_VAR 0 4
102311: PPUSH
102312: LD_VAR 0 5
102316: PPUSH
102317: LD_INT 12
102319: PPUSH
102320: CALL 102337 0 4
// end ;
102324: LD_VAR 0 6
102328: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
102329: LD_INT 0
102331: PPUSH
// end ;
102332: LD_VAR 0 4
102336: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102337: LD_INT 0
102339: PPUSH
102340: PPUSH
102341: PPUSH
102342: PPUSH
102343: PPUSH
102344: PPUSH
102345: PPUSH
102346: PPUSH
102347: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102348: LD_VAR 0 1
102352: NOT
102353: PUSH
102354: LD_VAR 0 2
102358: PPUSH
102359: LD_VAR 0 3
102363: PPUSH
102364: CALL_OW 488
102368: NOT
102369: OR
102370: PUSH
102371: LD_VAR 0 4
102375: NOT
102376: OR
102377: IFFALSE 102381
// exit ;
102379: GO 102721
// list := [ ] ;
102381: LD_ADDR_VAR 0 13
102385: PUSH
102386: EMPTY
102387: ST_TO_ADDR
// if x - r < 0 then
102388: LD_VAR 0 2
102392: PUSH
102393: LD_VAR 0 4
102397: MINUS
102398: PUSH
102399: LD_INT 0
102401: LESS
102402: IFFALSE 102414
// min_x := 0 else
102404: LD_ADDR_VAR 0 7
102408: PUSH
102409: LD_INT 0
102411: ST_TO_ADDR
102412: GO 102430
// min_x := x - r ;
102414: LD_ADDR_VAR 0 7
102418: PUSH
102419: LD_VAR 0 2
102423: PUSH
102424: LD_VAR 0 4
102428: MINUS
102429: ST_TO_ADDR
// if y - r < 0 then
102430: LD_VAR 0 3
102434: PUSH
102435: LD_VAR 0 4
102439: MINUS
102440: PUSH
102441: LD_INT 0
102443: LESS
102444: IFFALSE 102456
// min_y := 0 else
102446: LD_ADDR_VAR 0 8
102450: PUSH
102451: LD_INT 0
102453: ST_TO_ADDR
102454: GO 102472
// min_y := y - r ;
102456: LD_ADDR_VAR 0 8
102460: PUSH
102461: LD_VAR 0 3
102465: PUSH
102466: LD_VAR 0 4
102470: MINUS
102471: ST_TO_ADDR
// max_x := x + r ;
102472: LD_ADDR_VAR 0 9
102476: PUSH
102477: LD_VAR 0 2
102481: PUSH
102482: LD_VAR 0 4
102486: PLUS
102487: ST_TO_ADDR
// max_y := y + r ;
102488: LD_ADDR_VAR 0 10
102492: PUSH
102493: LD_VAR 0 3
102497: PUSH
102498: LD_VAR 0 4
102502: PLUS
102503: ST_TO_ADDR
// for _x = min_x to max_x do
102504: LD_ADDR_VAR 0 11
102508: PUSH
102509: DOUBLE
102510: LD_VAR 0 7
102514: DEC
102515: ST_TO_ADDR
102516: LD_VAR 0 9
102520: PUSH
102521: FOR_TO
102522: IFFALSE 102639
// for _y = min_y to max_y do
102524: LD_ADDR_VAR 0 12
102528: PUSH
102529: DOUBLE
102530: LD_VAR 0 8
102534: DEC
102535: ST_TO_ADDR
102536: LD_VAR 0 10
102540: PUSH
102541: FOR_TO
102542: IFFALSE 102635
// begin if not ValidHex ( _x , _y ) then
102544: LD_VAR 0 11
102548: PPUSH
102549: LD_VAR 0 12
102553: PPUSH
102554: CALL_OW 488
102558: NOT
102559: IFFALSE 102563
// continue ;
102561: GO 102541
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102563: LD_VAR 0 11
102567: PPUSH
102568: LD_VAR 0 12
102572: PPUSH
102573: CALL_OW 351
102577: PUSH
102578: LD_VAR 0 11
102582: PPUSH
102583: LD_VAR 0 12
102587: PPUSH
102588: CALL_OW 554
102592: AND
102593: IFFALSE 102633
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102595: LD_ADDR_VAR 0 13
102599: PUSH
102600: LD_VAR 0 13
102604: PPUSH
102605: LD_VAR 0 13
102609: PUSH
102610: LD_INT 1
102612: PLUS
102613: PPUSH
102614: LD_VAR 0 11
102618: PUSH
102619: LD_VAR 0 12
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PPUSH
102628: CALL_OW 2
102632: ST_TO_ADDR
// end ;
102633: GO 102541
102635: POP
102636: POP
102637: GO 102521
102639: POP
102640: POP
// if not list then
102641: LD_VAR 0 13
102645: NOT
102646: IFFALSE 102650
// exit ;
102648: GO 102721
// for i in list do
102650: LD_ADDR_VAR 0 6
102654: PUSH
102655: LD_VAR 0 13
102659: PUSH
102660: FOR_IN
102661: IFFALSE 102719
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102663: LD_VAR 0 1
102667: PPUSH
102668: LD_STRING M
102670: PUSH
102671: LD_VAR 0 6
102675: PUSH
102676: LD_INT 1
102678: ARRAY
102679: PUSH
102680: LD_VAR 0 6
102684: PUSH
102685: LD_INT 2
102687: ARRAY
102688: PUSH
102689: LD_INT 0
102691: PUSH
102692: LD_INT 0
102694: PUSH
102695: LD_INT 0
102697: PUSH
102698: LD_INT 0
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: LIST
102706: LIST
102707: LIST
102708: LIST
102709: PUSH
102710: EMPTY
102711: LIST
102712: PPUSH
102713: CALL_OW 447
102717: GO 102660
102719: POP
102720: POP
// end ;
102721: LD_VAR 0 5
102725: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102726: LD_EXP 193
102730: NOT
102731: IFFALSE 102781
102733: GO 102735
102735: DISABLE
// begin initHack := true ;
102736: LD_ADDR_EXP 193
102740: PUSH
102741: LD_INT 1
102743: ST_TO_ADDR
// hackTanks := [ ] ;
102744: LD_ADDR_EXP 194
102748: PUSH
102749: EMPTY
102750: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102751: LD_ADDR_EXP 195
102755: PUSH
102756: EMPTY
102757: ST_TO_ADDR
// hackLimit := 3 ;
102758: LD_ADDR_EXP 196
102762: PUSH
102763: LD_INT 3
102765: ST_TO_ADDR
// hackDist := 12 ;
102766: LD_ADDR_EXP 197
102770: PUSH
102771: LD_INT 12
102773: ST_TO_ADDR
// hackCounter := [ ] ;
102774: LD_ADDR_EXP 198
102778: PUSH
102779: EMPTY
102780: ST_TO_ADDR
// end ;
102781: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102782: LD_EXP 193
102786: PUSH
102787: LD_INT 34
102789: PUSH
102790: LD_EXP 74
102794: PUSH
102795: EMPTY
102796: LIST
102797: LIST
102798: PPUSH
102799: CALL_OW 69
102803: AND
102804: IFFALSE 103059
102806: GO 102808
102808: DISABLE
102809: LD_INT 0
102811: PPUSH
102812: PPUSH
// begin enable ;
102813: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102814: LD_ADDR_VAR 0 1
102818: PUSH
102819: LD_INT 34
102821: PUSH
102822: LD_EXP 74
102826: PUSH
102827: EMPTY
102828: LIST
102829: LIST
102830: PPUSH
102831: CALL_OW 69
102835: PUSH
102836: FOR_IN
102837: IFFALSE 103057
// begin if not i in hackTanks then
102839: LD_VAR 0 1
102843: PUSH
102844: LD_EXP 194
102848: IN
102849: NOT
102850: IFFALSE 102933
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102852: LD_ADDR_EXP 194
102856: PUSH
102857: LD_EXP 194
102861: PPUSH
102862: LD_EXP 194
102866: PUSH
102867: LD_INT 1
102869: PLUS
102870: PPUSH
102871: LD_VAR 0 1
102875: PPUSH
102876: CALL_OW 1
102880: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102881: LD_ADDR_EXP 195
102885: PUSH
102886: LD_EXP 195
102890: PPUSH
102891: LD_EXP 195
102895: PUSH
102896: LD_INT 1
102898: PLUS
102899: PPUSH
102900: EMPTY
102901: PPUSH
102902: CALL_OW 1
102906: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102907: LD_ADDR_EXP 198
102911: PUSH
102912: LD_EXP 198
102916: PPUSH
102917: LD_EXP 198
102921: PUSH
102922: LD_INT 1
102924: PLUS
102925: PPUSH
102926: EMPTY
102927: PPUSH
102928: CALL_OW 1
102932: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102933: LD_VAR 0 1
102937: PPUSH
102938: CALL_OW 302
102942: NOT
102943: IFFALSE 102956
// begin HackUnlinkAll ( i ) ;
102945: LD_VAR 0 1
102949: PPUSH
102950: CALL 103062 0 1
// continue ;
102954: GO 102836
// end ; HackCheckCapturedStatus ( i ) ;
102956: LD_VAR 0 1
102960: PPUSH
102961: CALL 103505 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102965: LD_ADDR_VAR 0 2
102969: PUSH
102970: LD_INT 81
102972: PUSH
102973: LD_VAR 0 1
102977: PPUSH
102978: CALL_OW 255
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: PUSH
102987: LD_INT 33
102989: PUSH
102990: LD_INT 3
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: PUSH
102997: LD_INT 91
102999: PUSH
103000: LD_VAR 0 1
103004: PUSH
103005: LD_EXP 197
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: LIST
103014: PUSH
103015: LD_INT 50
103017: PUSH
103018: EMPTY
103019: LIST
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: LIST
103025: LIST
103026: PPUSH
103027: CALL_OW 69
103031: ST_TO_ADDR
// if not tmp then
103032: LD_VAR 0 2
103036: NOT
103037: IFFALSE 103041
// continue ;
103039: GO 102836
// HackLink ( i , tmp ) ;
103041: LD_VAR 0 1
103045: PPUSH
103046: LD_VAR 0 2
103050: PPUSH
103051: CALL 103198 0 2
// end ;
103055: GO 102836
103057: POP
103058: POP
// end ;
103059: PPOPN 2
103061: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103062: LD_INT 0
103064: PPUSH
103065: PPUSH
103066: PPUSH
// if not hack in hackTanks then
103067: LD_VAR 0 1
103071: PUSH
103072: LD_EXP 194
103076: IN
103077: NOT
103078: IFFALSE 103082
// exit ;
103080: GO 103193
// index := GetElementIndex ( hackTanks , hack ) ;
103082: LD_ADDR_VAR 0 4
103086: PUSH
103087: LD_EXP 194
103091: PPUSH
103092: LD_VAR 0 1
103096: PPUSH
103097: CALL 55784 0 2
103101: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
103102: LD_EXP 195
103106: PUSH
103107: LD_VAR 0 4
103111: ARRAY
103112: IFFALSE 103193
// begin for i in hackTanksCaptured [ index ] do
103114: LD_ADDR_VAR 0 3
103118: PUSH
103119: LD_EXP 195
103123: PUSH
103124: LD_VAR 0 4
103128: ARRAY
103129: PUSH
103130: FOR_IN
103131: IFFALSE 103157
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
103133: LD_VAR 0 3
103137: PUSH
103138: LD_INT 1
103140: ARRAY
103141: PPUSH
103142: LD_VAR 0 3
103146: PUSH
103147: LD_INT 2
103149: ARRAY
103150: PPUSH
103151: CALL_OW 235
103155: GO 103130
103157: POP
103158: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
103159: LD_ADDR_EXP 195
103163: PUSH
103164: LD_EXP 195
103168: PPUSH
103169: LD_VAR 0 4
103173: PPUSH
103174: EMPTY
103175: PPUSH
103176: CALL_OW 1
103180: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103181: LD_VAR 0 1
103185: PPUSH
103186: LD_INT 0
103188: PPUSH
103189: CALL_OW 505
// end ; end ;
103193: LD_VAR 0 2
103197: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103198: LD_INT 0
103200: PPUSH
103201: PPUSH
103202: PPUSH
// if not hack in hackTanks or not vehicles then
103203: LD_VAR 0 1
103207: PUSH
103208: LD_EXP 194
103212: IN
103213: NOT
103214: PUSH
103215: LD_VAR 0 2
103219: NOT
103220: OR
103221: IFFALSE 103225
// exit ;
103223: GO 103500
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103225: LD_ADDR_VAR 0 2
103229: PUSH
103230: LD_VAR 0 1
103234: PPUSH
103235: LD_VAR 0 2
103239: PPUSH
103240: LD_INT 1
103242: PPUSH
103243: LD_INT 1
103245: PPUSH
103246: CALL 56434 0 4
103250: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103251: LD_ADDR_VAR 0 5
103255: PUSH
103256: LD_EXP 194
103260: PPUSH
103261: LD_VAR 0 1
103265: PPUSH
103266: CALL 55784 0 2
103270: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103271: LD_EXP 195
103275: PUSH
103276: LD_VAR 0 5
103280: ARRAY
103281: PUSH
103282: LD_EXP 196
103286: LESS
103287: IFFALSE 103476
// begin for i := 1 to vehicles do
103289: LD_ADDR_VAR 0 4
103293: PUSH
103294: DOUBLE
103295: LD_INT 1
103297: DEC
103298: ST_TO_ADDR
103299: LD_VAR 0 2
103303: PUSH
103304: FOR_TO
103305: IFFALSE 103474
// begin if hackTanksCaptured [ index ] = hackLimit then
103307: LD_EXP 195
103311: PUSH
103312: LD_VAR 0 5
103316: ARRAY
103317: PUSH
103318: LD_EXP 196
103322: EQUAL
103323: IFFALSE 103327
// break ;
103325: GO 103474
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103327: LD_ADDR_EXP 198
103331: PUSH
103332: LD_EXP 198
103336: PPUSH
103337: LD_VAR 0 5
103341: PPUSH
103342: LD_EXP 198
103346: PUSH
103347: LD_VAR 0 5
103351: ARRAY
103352: PUSH
103353: LD_INT 1
103355: PLUS
103356: PPUSH
103357: CALL_OW 1
103361: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103362: LD_ADDR_EXP 195
103366: PUSH
103367: LD_EXP 195
103371: PPUSH
103372: LD_VAR 0 5
103376: PUSH
103377: LD_EXP 195
103381: PUSH
103382: LD_VAR 0 5
103386: ARRAY
103387: PUSH
103388: LD_INT 1
103390: PLUS
103391: PUSH
103392: EMPTY
103393: LIST
103394: LIST
103395: PPUSH
103396: LD_VAR 0 2
103400: PUSH
103401: LD_VAR 0 4
103405: ARRAY
103406: PUSH
103407: LD_VAR 0 2
103411: PUSH
103412: LD_VAR 0 4
103416: ARRAY
103417: PPUSH
103418: CALL_OW 255
103422: PUSH
103423: EMPTY
103424: LIST
103425: LIST
103426: PPUSH
103427: CALL 55999 0 3
103431: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103432: LD_VAR 0 2
103436: PUSH
103437: LD_VAR 0 4
103441: ARRAY
103442: PPUSH
103443: LD_VAR 0 1
103447: PPUSH
103448: CALL_OW 255
103452: PPUSH
103453: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103457: LD_VAR 0 2
103461: PUSH
103462: LD_VAR 0 4
103466: ARRAY
103467: PPUSH
103468: CALL_OW 141
// end ;
103472: GO 103304
103474: POP
103475: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103476: LD_VAR 0 1
103480: PPUSH
103481: LD_EXP 195
103485: PUSH
103486: LD_VAR 0 5
103490: ARRAY
103491: PUSH
103492: LD_INT 0
103494: PLUS
103495: PPUSH
103496: CALL_OW 505
// end ;
103500: LD_VAR 0 3
103504: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103505: LD_INT 0
103507: PPUSH
103508: PPUSH
103509: PPUSH
103510: PPUSH
// if not hack in hackTanks then
103511: LD_VAR 0 1
103515: PUSH
103516: LD_EXP 194
103520: IN
103521: NOT
103522: IFFALSE 103526
// exit ;
103524: GO 103766
// index := GetElementIndex ( hackTanks , hack ) ;
103526: LD_ADDR_VAR 0 4
103530: PUSH
103531: LD_EXP 194
103535: PPUSH
103536: LD_VAR 0 1
103540: PPUSH
103541: CALL 55784 0 2
103545: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103546: LD_ADDR_VAR 0 3
103550: PUSH
103551: DOUBLE
103552: LD_EXP 195
103556: PUSH
103557: LD_VAR 0 4
103561: ARRAY
103562: INC
103563: ST_TO_ADDR
103564: LD_INT 1
103566: PUSH
103567: FOR_DOWNTO
103568: IFFALSE 103740
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103570: LD_ADDR_VAR 0 5
103574: PUSH
103575: LD_EXP 195
103579: PUSH
103580: LD_VAR 0 4
103584: ARRAY
103585: PUSH
103586: LD_VAR 0 3
103590: ARRAY
103591: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103592: LD_VAR 0 5
103596: PUSH
103597: LD_INT 1
103599: ARRAY
103600: PPUSH
103601: CALL_OW 302
103605: NOT
103606: PUSH
103607: LD_VAR 0 5
103611: PUSH
103612: LD_INT 1
103614: ARRAY
103615: PPUSH
103616: CALL_OW 255
103620: PUSH
103621: LD_VAR 0 1
103625: PPUSH
103626: CALL_OW 255
103630: NONEQUAL
103631: OR
103632: IFFALSE 103738
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103634: LD_VAR 0 5
103638: PUSH
103639: LD_INT 1
103641: ARRAY
103642: PPUSH
103643: CALL_OW 305
103647: PUSH
103648: LD_VAR 0 5
103652: PUSH
103653: LD_INT 1
103655: ARRAY
103656: PPUSH
103657: CALL_OW 255
103661: PUSH
103662: LD_VAR 0 1
103666: PPUSH
103667: CALL_OW 255
103671: EQUAL
103672: AND
103673: IFFALSE 103697
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103675: LD_VAR 0 5
103679: PUSH
103680: LD_INT 1
103682: ARRAY
103683: PPUSH
103684: LD_VAR 0 5
103688: PUSH
103689: LD_INT 2
103691: ARRAY
103692: PPUSH
103693: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103697: LD_ADDR_EXP 195
103701: PUSH
103702: LD_EXP 195
103706: PPUSH
103707: LD_VAR 0 4
103711: PPUSH
103712: LD_EXP 195
103716: PUSH
103717: LD_VAR 0 4
103721: ARRAY
103722: PPUSH
103723: LD_VAR 0 3
103727: PPUSH
103728: CALL_OW 3
103732: PPUSH
103733: CALL_OW 1
103737: ST_TO_ADDR
// end ; end ;
103738: GO 103567
103740: POP
103741: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103742: LD_VAR 0 1
103746: PPUSH
103747: LD_EXP 195
103751: PUSH
103752: LD_VAR 0 4
103756: ARRAY
103757: PUSH
103758: LD_INT 0
103760: PLUS
103761: PPUSH
103762: CALL_OW 505
// end ;
103766: LD_VAR 0 2
103770: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103771: LD_INT 0
103773: PPUSH
103774: PPUSH
103775: PPUSH
103776: PPUSH
// if not hack in hackTanks then
103777: LD_VAR 0 1
103781: PUSH
103782: LD_EXP 194
103786: IN
103787: NOT
103788: IFFALSE 103792
// exit ;
103790: GO 103877
// index := GetElementIndex ( hackTanks , hack ) ;
103792: LD_ADDR_VAR 0 5
103796: PUSH
103797: LD_EXP 194
103801: PPUSH
103802: LD_VAR 0 1
103806: PPUSH
103807: CALL 55784 0 2
103811: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103812: LD_ADDR_VAR 0 4
103816: PUSH
103817: DOUBLE
103818: LD_INT 1
103820: DEC
103821: ST_TO_ADDR
103822: LD_EXP 195
103826: PUSH
103827: LD_VAR 0 5
103831: ARRAY
103832: PUSH
103833: FOR_TO
103834: IFFALSE 103875
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103836: LD_EXP 195
103840: PUSH
103841: LD_VAR 0 5
103845: ARRAY
103846: PUSH
103847: LD_VAR 0 4
103851: ARRAY
103852: PUSH
103853: LD_INT 1
103855: ARRAY
103856: PUSH
103857: LD_VAR 0 2
103861: EQUAL
103862: IFFALSE 103873
// KillUnit ( vehicle ) ;
103864: LD_VAR 0 2
103868: PPUSH
103869: CALL_OW 66
103873: GO 103833
103875: POP
103876: POP
// end ;
103877: LD_VAR 0 3
103881: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103882: LD_EXP 199
103886: NOT
103887: IFFALSE 103922
103889: GO 103891
103891: DISABLE
// begin initMiner := true ;
103892: LD_ADDR_EXP 199
103896: PUSH
103897: LD_INT 1
103899: ST_TO_ADDR
// minersList := [ ] ;
103900: LD_ADDR_EXP 200
103904: PUSH
103905: EMPTY
103906: ST_TO_ADDR
// minerMinesList := [ ] ;
103907: LD_ADDR_EXP 201
103911: PUSH
103912: EMPTY
103913: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103914: LD_ADDR_EXP 202
103918: PUSH
103919: LD_INT 5
103921: ST_TO_ADDR
// end ;
103922: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103923: LD_EXP 199
103927: PUSH
103928: LD_INT 34
103930: PUSH
103931: LD_EXP 79
103935: PUSH
103936: EMPTY
103937: LIST
103938: LIST
103939: PPUSH
103940: CALL_OW 69
103944: AND
103945: IFFALSE 104408
103947: GO 103949
103949: DISABLE
103950: LD_INT 0
103952: PPUSH
103953: PPUSH
103954: PPUSH
103955: PPUSH
// begin enable ;
103956: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103957: LD_ADDR_VAR 0 1
103961: PUSH
103962: LD_INT 34
103964: PUSH
103965: LD_EXP 79
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: PPUSH
103974: CALL_OW 69
103978: PUSH
103979: FOR_IN
103980: IFFALSE 104052
// begin if not i in minersList then
103982: LD_VAR 0 1
103986: PUSH
103987: LD_EXP 200
103991: IN
103992: NOT
103993: IFFALSE 104050
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103995: LD_ADDR_EXP 200
103999: PUSH
104000: LD_EXP 200
104004: PPUSH
104005: LD_EXP 200
104009: PUSH
104010: LD_INT 1
104012: PLUS
104013: PPUSH
104014: LD_VAR 0 1
104018: PPUSH
104019: CALL_OW 1
104023: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104024: LD_ADDR_EXP 201
104028: PUSH
104029: LD_EXP 201
104033: PPUSH
104034: LD_EXP 201
104038: PUSH
104039: LD_INT 1
104041: PLUS
104042: PPUSH
104043: EMPTY
104044: PPUSH
104045: CALL_OW 1
104049: ST_TO_ADDR
// end end ;
104050: GO 103979
104052: POP
104053: POP
// for i := minerMinesList downto 1 do
104054: LD_ADDR_VAR 0 1
104058: PUSH
104059: DOUBLE
104060: LD_EXP 201
104064: INC
104065: ST_TO_ADDR
104066: LD_INT 1
104068: PUSH
104069: FOR_DOWNTO
104070: IFFALSE 104406
// begin if IsLive ( minersList [ i ] ) then
104072: LD_EXP 200
104076: PUSH
104077: LD_VAR 0 1
104081: ARRAY
104082: PPUSH
104083: CALL_OW 300
104087: IFFALSE 104115
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
104089: LD_EXP 200
104093: PUSH
104094: LD_VAR 0 1
104098: ARRAY
104099: PPUSH
104100: LD_EXP 201
104104: PUSH
104105: LD_VAR 0 1
104109: ARRAY
104110: PPUSH
104111: CALL_OW 505
// if not minerMinesList [ i ] then
104115: LD_EXP 201
104119: PUSH
104120: LD_VAR 0 1
104124: ARRAY
104125: NOT
104126: IFFALSE 104130
// continue ;
104128: GO 104069
// for j := minerMinesList [ i ] downto 1 do
104130: LD_ADDR_VAR 0 2
104134: PUSH
104135: DOUBLE
104136: LD_EXP 201
104140: PUSH
104141: LD_VAR 0 1
104145: ARRAY
104146: INC
104147: ST_TO_ADDR
104148: LD_INT 1
104150: PUSH
104151: FOR_DOWNTO
104152: IFFALSE 104402
// begin side := GetSide ( minersList [ i ] ) ;
104154: LD_ADDR_VAR 0 3
104158: PUSH
104159: LD_EXP 200
104163: PUSH
104164: LD_VAR 0 1
104168: ARRAY
104169: PPUSH
104170: CALL_OW 255
104174: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104175: LD_ADDR_VAR 0 4
104179: PUSH
104180: LD_EXP 201
104184: PUSH
104185: LD_VAR 0 1
104189: ARRAY
104190: PUSH
104191: LD_VAR 0 2
104195: ARRAY
104196: PUSH
104197: LD_INT 1
104199: ARRAY
104200: PPUSH
104201: LD_EXP 201
104205: PUSH
104206: LD_VAR 0 1
104210: ARRAY
104211: PUSH
104212: LD_VAR 0 2
104216: ARRAY
104217: PUSH
104218: LD_INT 2
104220: ARRAY
104221: PPUSH
104222: CALL_OW 428
104226: ST_TO_ADDR
// if not tmp then
104227: LD_VAR 0 4
104231: NOT
104232: IFFALSE 104236
// continue ;
104234: GO 104151
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104236: LD_VAR 0 4
104240: PUSH
104241: LD_INT 81
104243: PUSH
104244: LD_VAR 0 3
104248: PUSH
104249: EMPTY
104250: LIST
104251: LIST
104252: PPUSH
104253: CALL_OW 69
104257: IN
104258: PUSH
104259: LD_EXP 201
104263: PUSH
104264: LD_VAR 0 1
104268: ARRAY
104269: PUSH
104270: LD_VAR 0 2
104274: ARRAY
104275: PUSH
104276: LD_INT 1
104278: ARRAY
104279: PPUSH
104280: LD_EXP 201
104284: PUSH
104285: LD_VAR 0 1
104289: ARRAY
104290: PUSH
104291: LD_VAR 0 2
104295: ARRAY
104296: PUSH
104297: LD_INT 2
104299: ARRAY
104300: PPUSH
104301: CALL_OW 458
104305: AND
104306: IFFALSE 104400
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104308: LD_EXP 201
104312: PUSH
104313: LD_VAR 0 1
104317: ARRAY
104318: PUSH
104319: LD_VAR 0 2
104323: ARRAY
104324: PUSH
104325: LD_INT 1
104327: ARRAY
104328: PPUSH
104329: LD_EXP 201
104333: PUSH
104334: LD_VAR 0 1
104338: ARRAY
104339: PUSH
104340: LD_VAR 0 2
104344: ARRAY
104345: PUSH
104346: LD_INT 2
104348: ARRAY
104349: PPUSH
104350: LD_VAR 0 3
104354: PPUSH
104355: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104359: LD_ADDR_EXP 201
104363: PUSH
104364: LD_EXP 201
104368: PPUSH
104369: LD_VAR 0 1
104373: PPUSH
104374: LD_EXP 201
104378: PUSH
104379: LD_VAR 0 1
104383: ARRAY
104384: PPUSH
104385: LD_VAR 0 2
104389: PPUSH
104390: CALL_OW 3
104394: PPUSH
104395: CALL_OW 1
104399: ST_TO_ADDR
// end ; end ;
104400: GO 104151
104402: POP
104403: POP
// end ;
104404: GO 104069
104406: POP
104407: POP
// end ;
104408: PPOPN 4
104410: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104411: LD_INT 0
104413: PPUSH
104414: PPUSH
// result := false ;
104415: LD_ADDR_VAR 0 4
104419: PUSH
104420: LD_INT 0
104422: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104423: LD_VAR 0 1
104427: PPUSH
104428: CALL_OW 264
104432: PUSH
104433: LD_EXP 79
104437: EQUAL
104438: NOT
104439: IFFALSE 104443
// exit ;
104441: GO 104683
// index := GetElementIndex ( minersList , unit ) ;
104443: LD_ADDR_VAR 0 5
104447: PUSH
104448: LD_EXP 200
104452: PPUSH
104453: LD_VAR 0 1
104457: PPUSH
104458: CALL 55784 0 2
104462: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104463: LD_EXP 201
104467: PUSH
104468: LD_VAR 0 5
104472: ARRAY
104473: PUSH
104474: LD_EXP 202
104478: GREATEREQUAL
104479: IFFALSE 104483
// exit ;
104481: GO 104683
// ComMoveXY ( unit , x , y ) ;
104483: LD_VAR 0 1
104487: PPUSH
104488: LD_VAR 0 2
104492: PPUSH
104493: LD_VAR 0 3
104497: PPUSH
104498: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104502: LD_INT 35
104504: PPUSH
104505: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104509: LD_VAR 0 1
104513: PPUSH
104514: LD_VAR 0 2
104518: PPUSH
104519: LD_VAR 0 3
104523: PPUSH
104524: CALL 86181 0 3
104528: NOT
104529: PUSH
104530: LD_VAR 0 1
104534: PPUSH
104535: CALL_OW 314
104539: AND
104540: IFFALSE 104544
// exit ;
104542: GO 104683
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104544: LD_VAR 0 2
104548: PPUSH
104549: LD_VAR 0 3
104553: PPUSH
104554: CALL_OW 428
104558: PUSH
104559: LD_VAR 0 1
104563: EQUAL
104564: PUSH
104565: LD_VAR 0 1
104569: PPUSH
104570: CALL_OW 314
104574: NOT
104575: AND
104576: IFFALSE 104502
// PlaySoundXY ( x , y , PlantMine ) ;
104578: LD_VAR 0 2
104582: PPUSH
104583: LD_VAR 0 3
104587: PPUSH
104588: LD_STRING PlantMine
104590: PPUSH
104591: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104595: LD_VAR 0 2
104599: PPUSH
104600: LD_VAR 0 3
104604: PPUSH
104605: LD_VAR 0 1
104609: PPUSH
104610: CALL_OW 255
104614: PPUSH
104615: LD_INT 0
104617: PPUSH
104618: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104622: LD_ADDR_EXP 201
104626: PUSH
104627: LD_EXP 201
104631: PPUSH
104632: LD_VAR 0 5
104636: PUSH
104637: LD_EXP 201
104641: PUSH
104642: LD_VAR 0 5
104646: ARRAY
104647: PUSH
104648: LD_INT 1
104650: PLUS
104651: PUSH
104652: EMPTY
104653: LIST
104654: LIST
104655: PPUSH
104656: LD_VAR 0 2
104660: PUSH
104661: LD_VAR 0 3
104665: PUSH
104666: EMPTY
104667: LIST
104668: LIST
104669: PPUSH
104670: CALL 55999 0 3
104674: ST_TO_ADDR
// result := true ;
104675: LD_ADDR_VAR 0 4
104679: PUSH
104680: LD_INT 1
104682: ST_TO_ADDR
// end ;
104683: LD_VAR 0 4
104687: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104688: LD_INT 0
104690: PPUSH
104691: PPUSH
104692: PPUSH
// if not unit in minersList then
104693: LD_VAR 0 1
104697: PUSH
104698: LD_EXP 200
104702: IN
104703: NOT
104704: IFFALSE 104708
// exit ;
104706: GO 105100
// index := GetElementIndex ( minersList , unit ) ;
104708: LD_ADDR_VAR 0 6
104712: PUSH
104713: LD_EXP 200
104717: PPUSH
104718: LD_VAR 0 1
104722: PPUSH
104723: CALL 55784 0 2
104727: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104728: LD_ADDR_VAR 0 5
104732: PUSH
104733: DOUBLE
104734: LD_EXP 201
104738: PUSH
104739: LD_VAR 0 6
104743: ARRAY
104744: INC
104745: ST_TO_ADDR
104746: LD_INT 1
104748: PUSH
104749: FOR_DOWNTO
104750: IFFALSE 104911
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104752: LD_EXP 201
104756: PUSH
104757: LD_VAR 0 6
104761: ARRAY
104762: PUSH
104763: LD_VAR 0 5
104767: ARRAY
104768: PUSH
104769: LD_INT 1
104771: ARRAY
104772: PUSH
104773: LD_VAR 0 2
104777: EQUAL
104778: PUSH
104779: LD_EXP 201
104783: PUSH
104784: LD_VAR 0 6
104788: ARRAY
104789: PUSH
104790: LD_VAR 0 5
104794: ARRAY
104795: PUSH
104796: LD_INT 2
104798: ARRAY
104799: PUSH
104800: LD_VAR 0 3
104804: EQUAL
104805: AND
104806: IFFALSE 104909
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104808: LD_EXP 201
104812: PUSH
104813: LD_VAR 0 6
104817: ARRAY
104818: PUSH
104819: LD_VAR 0 5
104823: ARRAY
104824: PUSH
104825: LD_INT 1
104827: ARRAY
104828: PPUSH
104829: LD_EXP 201
104833: PUSH
104834: LD_VAR 0 6
104838: ARRAY
104839: PUSH
104840: LD_VAR 0 5
104844: ARRAY
104845: PUSH
104846: LD_INT 2
104848: ARRAY
104849: PPUSH
104850: LD_VAR 0 1
104854: PPUSH
104855: CALL_OW 255
104859: PPUSH
104860: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104864: LD_ADDR_EXP 201
104868: PUSH
104869: LD_EXP 201
104873: PPUSH
104874: LD_VAR 0 6
104878: PPUSH
104879: LD_EXP 201
104883: PUSH
104884: LD_VAR 0 6
104888: ARRAY
104889: PPUSH
104890: LD_VAR 0 5
104894: PPUSH
104895: CALL_OW 3
104899: PPUSH
104900: CALL_OW 1
104904: ST_TO_ADDR
// exit ;
104905: POP
104906: POP
104907: GO 105100
// end ; end ;
104909: GO 104749
104911: POP
104912: POP
// for i := minerMinesList [ index ] downto 1 do
104913: LD_ADDR_VAR 0 5
104917: PUSH
104918: DOUBLE
104919: LD_EXP 201
104923: PUSH
104924: LD_VAR 0 6
104928: ARRAY
104929: INC
104930: ST_TO_ADDR
104931: LD_INT 1
104933: PUSH
104934: FOR_DOWNTO
104935: IFFALSE 105098
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104937: LD_EXP 201
104941: PUSH
104942: LD_VAR 0 6
104946: ARRAY
104947: PUSH
104948: LD_VAR 0 5
104952: ARRAY
104953: PUSH
104954: LD_INT 1
104956: ARRAY
104957: PPUSH
104958: LD_EXP 201
104962: PUSH
104963: LD_VAR 0 6
104967: ARRAY
104968: PUSH
104969: LD_VAR 0 5
104973: ARRAY
104974: PUSH
104975: LD_INT 2
104977: ARRAY
104978: PPUSH
104979: LD_VAR 0 2
104983: PPUSH
104984: LD_VAR 0 3
104988: PPUSH
104989: CALL_OW 298
104993: PUSH
104994: LD_INT 6
104996: LESS
104997: IFFALSE 105096
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104999: LD_EXP 201
105003: PUSH
105004: LD_VAR 0 6
105008: ARRAY
105009: PUSH
105010: LD_VAR 0 5
105014: ARRAY
105015: PUSH
105016: LD_INT 1
105018: ARRAY
105019: PPUSH
105020: LD_EXP 201
105024: PUSH
105025: LD_VAR 0 6
105029: ARRAY
105030: PUSH
105031: LD_VAR 0 5
105035: ARRAY
105036: PUSH
105037: LD_INT 2
105039: ARRAY
105040: PPUSH
105041: LD_VAR 0 1
105045: PPUSH
105046: CALL_OW 255
105050: PPUSH
105051: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105055: LD_ADDR_EXP 201
105059: PUSH
105060: LD_EXP 201
105064: PPUSH
105065: LD_VAR 0 6
105069: PPUSH
105070: LD_EXP 201
105074: PUSH
105075: LD_VAR 0 6
105079: ARRAY
105080: PPUSH
105081: LD_VAR 0 5
105085: PPUSH
105086: CALL_OW 3
105090: PPUSH
105091: CALL_OW 1
105095: ST_TO_ADDR
// end ; end ;
105096: GO 104934
105098: POP
105099: POP
// end ;
105100: LD_VAR 0 4
105104: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
105105: LD_INT 0
105107: PPUSH
105108: PPUSH
105109: PPUSH
105110: PPUSH
105111: PPUSH
105112: PPUSH
105113: PPUSH
105114: PPUSH
105115: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105116: LD_VAR 0 1
105120: PPUSH
105121: CALL_OW 264
105125: PUSH
105126: LD_EXP 79
105130: EQUAL
105131: NOT
105132: PUSH
105133: LD_VAR 0 1
105137: PUSH
105138: LD_EXP 200
105142: IN
105143: NOT
105144: OR
105145: IFFALSE 105149
// exit ;
105147: GO 105471
// index := GetElementIndex ( minersList , unit ) ;
105149: LD_ADDR_VAR 0 6
105153: PUSH
105154: LD_EXP 200
105158: PPUSH
105159: LD_VAR 0 1
105163: PPUSH
105164: CALL 55784 0 2
105168: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105169: LD_ADDR_VAR 0 8
105173: PUSH
105174: LD_EXP 202
105178: PUSH
105179: LD_EXP 201
105183: PUSH
105184: LD_VAR 0 6
105188: ARRAY
105189: MINUS
105190: ST_TO_ADDR
// if not minesFreeAmount then
105191: LD_VAR 0 8
105195: NOT
105196: IFFALSE 105200
// exit ;
105198: GO 105471
// tmp := [ ] ;
105200: LD_ADDR_VAR 0 7
105204: PUSH
105205: EMPTY
105206: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105207: LD_ADDR_VAR 0 5
105211: PUSH
105212: DOUBLE
105213: LD_INT 1
105215: DEC
105216: ST_TO_ADDR
105217: LD_VAR 0 8
105221: PUSH
105222: FOR_TO
105223: IFFALSE 105418
// begin _d := rand ( 0 , 5 ) ;
105225: LD_ADDR_VAR 0 11
105229: PUSH
105230: LD_INT 0
105232: PPUSH
105233: LD_INT 5
105235: PPUSH
105236: CALL_OW 12
105240: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105241: LD_ADDR_VAR 0 12
105245: PUSH
105246: LD_INT 2
105248: PPUSH
105249: LD_INT 6
105251: PPUSH
105252: CALL_OW 12
105256: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105257: LD_ADDR_VAR 0 9
105261: PUSH
105262: LD_VAR 0 2
105266: PPUSH
105267: LD_VAR 0 11
105271: PPUSH
105272: LD_VAR 0 12
105276: PPUSH
105277: CALL_OW 272
105281: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105282: LD_ADDR_VAR 0 10
105286: PUSH
105287: LD_VAR 0 3
105291: PPUSH
105292: LD_VAR 0 11
105296: PPUSH
105297: LD_VAR 0 12
105301: PPUSH
105302: CALL_OW 273
105306: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105307: LD_VAR 0 9
105311: PPUSH
105312: LD_VAR 0 10
105316: PPUSH
105317: CALL_OW 488
105321: PUSH
105322: LD_VAR 0 9
105326: PUSH
105327: LD_VAR 0 10
105331: PUSH
105332: EMPTY
105333: LIST
105334: LIST
105335: PUSH
105336: LD_VAR 0 7
105340: IN
105341: NOT
105342: AND
105343: PUSH
105344: LD_VAR 0 9
105348: PPUSH
105349: LD_VAR 0 10
105353: PPUSH
105354: CALL_OW 458
105358: NOT
105359: AND
105360: IFFALSE 105402
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105362: LD_ADDR_VAR 0 7
105366: PUSH
105367: LD_VAR 0 7
105371: PPUSH
105372: LD_VAR 0 7
105376: PUSH
105377: LD_INT 1
105379: PLUS
105380: PPUSH
105381: LD_VAR 0 9
105385: PUSH
105386: LD_VAR 0 10
105390: PUSH
105391: EMPTY
105392: LIST
105393: LIST
105394: PPUSH
105395: CALL_OW 1
105399: ST_TO_ADDR
105400: GO 105416
// i := i - 1 ;
105402: LD_ADDR_VAR 0 5
105406: PUSH
105407: LD_VAR 0 5
105411: PUSH
105412: LD_INT 1
105414: MINUS
105415: ST_TO_ADDR
// end ;
105416: GO 105222
105418: POP
105419: POP
// for i in tmp do
105420: LD_ADDR_VAR 0 5
105424: PUSH
105425: LD_VAR 0 7
105429: PUSH
105430: FOR_IN
105431: IFFALSE 105469
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105433: LD_VAR 0 1
105437: PPUSH
105438: LD_VAR 0 5
105442: PUSH
105443: LD_INT 1
105445: ARRAY
105446: PPUSH
105447: LD_VAR 0 5
105451: PUSH
105452: LD_INT 2
105454: ARRAY
105455: PPUSH
105456: CALL 104411 0 3
105460: NOT
105461: IFFALSE 105467
// exit ;
105463: POP
105464: POP
105465: GO 105471
105467: GO 105430
105469: POP
105470: POP
// end ;
105471: LD_VAR 0 4
105475: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105476: LD_INT 0
105478: PPUSH
105479: PPUSH
105480: PPUSH
105481: PPUSH
105482: PPUSH
105483: PPUSH
105484: PPUSH
// if not GetClass ( unit ) = class_sniper then
105485: LD_VAR 0 1
105489: PPUSH
105490: CALL_OW 257
105494: PUSH
105495: LD_INT 5
105497: EQUAL
105498: NOT
105499: IFFALSE 105503
// exit ;
105501: GO 105891
// dist := 8 ;
105503: LD_ADDR_VAR 0 5
105507: PUSH
105508: LD_INT 8
105510: ST_TO_ADDR
// viewRange := 12 ;
105511: LD_ADDR_VAR 0 7
105515: PUSH
105516: LD_INT 12
105518: ST_TO_ADDR
// side := GetSide ( unit ) ;
105519: LD_ADDR_VAR 0 6
105523: PUSH
105524: LD_VAR 0 1
105528: PPUSH
105529: CALL_OW 255
105533: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105534: LD_INT 61
105536: PPUSH
105537: LD_VAR 0 6
105541: PPUSH
105542: CALL_OW 321
105546: PUSH
105547: LD_INT 2
105549: EQUAL
105550: IFFALSE 105560
// viewRange := 16 ;
105552: LD_ADDR_VAR 0 7
105556: PUSH
105557: LD_INT 16
105559: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105560: LD_VAR 0 1
105564: PPUSH
105565: LD_VAR 0 2
105569: PPUSH
105570: LD_VAR 0 3
105574: PPUSH
105575: CALL_OW 297
105579: PUSH
105580: LD_VAR 0 5
105584: GREATER
105585: IFFALSE 105664
// begin ComMoveXY ( unit , x , y ) ;
105587: LD_VAR 0 1
105591: PPUSH
105592: LD_VAR 0 2
105596: PPUSH
105597: LD_VAR 0 3
105601: PPUSH
105602: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105606: LD_INT 35
105608: PPUSH
105609: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105613: LD_VAR 0 1
105617: PPUSH
105618: LD_VAR 0 2
105622: PPUSH
105623: LD_VAR 0 3
105627: PPUSH
105628: CALL 86181 0 3
105632: NOT
105633: IFFALSE 105637
// exit ;
105635: GO 105891
// until GetDistUnitXY ( unit , x , y ) < dist ;
105637: LD_VAR 0 1
105641: PPUSH
105642: LD_VAR 0 2
105646: PPUSH
105647: LD_VAR 0 3
105651: PPUSH
105652: CALL_OW 297
105656: PUSH
105657: LD_VAR 0 5
105661: LESS
105662: IFFALSE 105606
// end ; ComTurnXY ( unit , x , y ) ;
105664: LD_VAR 0 1
105668: PPUSH
105669: LD_VAR 0 2
105673: PPUSH
105674: LD_VAR 0 3
105678: PPUSH
105679: CALL_OW 118
// wait ( 5 ) ;
105683: LD_INT 5
105685: PPUSH
105686: CALL_OW 67
// _d := GetDir ( unit ) ;
105690: LD_ADDR_VAR 0 10
105694: PUSH
105695: LD_VAR 0 1
105699: PPUSH
105700: CALL_OW 254
105704: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105705: LD_ADDR_VAR 0 8
105709: PUSH
105710: LD_VAR 0 1
105714: PPUSH
105715: CALL_OW 250
105719: PPUSH
105720: LD_VAR 0 10
105724: PPUSH
105725: LD_VAR 0 5
105729: PPUSH
105730: CALL_OW 272
105734: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105735: LD_ADDR_VAR 0 9
105739: PUSH
105740: LD_VAR 0 1
105744: PPUSH
105745: CALL_OW 251
105749: PPUSH
105750: LD_VAR 0 10
105754: PPUSH
105755: LD_VAR 0 5
105759: PPUSH
105760: CALL_OW 273
105764: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105765: LD_VAR 0 8
105769: PPUSH
105770: LD_VAR 0 9
105774: PPUSH
105775: CALL_OW 488
105779: NOT
105780: IFFALSE 105784
// exit ;
105782: GO 105891
// ComAnimCustom ( unit , 1 ) ;
105784: LD_VAR 0 1
105788: PPUSH
105789: LD_INT 1
105791: PPUSH
105792: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105796: LD_VAR 0 8
105800: PPUSH
105801: LD_VAR 0 9
105805: PPUSH
105806: LD_VAR 0 6
105810: PPUSH
105811: LD_VAR 0 7
105815: PPUSH
105816: CALL_OW 330
// repeat wait ( 1 ) ;
105820: LD_INT 1
105822: PPUSH
105823: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105827: LD_VAR 0 1
105831: PPUSH
105832: CALL_OW 316
105836: PUSH
105837: LD_VAR 0 1
105841: PPUSH
105842: CALL_OW 314
105846: OR
105847: PUSH
105848: LD_VAR 0 1
105852: PPUSH
105853: CALL_OW 302
105857: NOT
105858: OR
105859: PUSH
105860: LD_VAR 0 1
105864: PPUSH
105865: CALL_OW 301
105869: OR
105870: IFFALSE 105820
// RemoveSeeing ( _x , _y , side ) ;
105872: LD_VAR 0 8
105876: PPUSH
105877: LD_VAR 0 9
105881: PPUSH
105882: LD_VAR 0 6
105886: PPUSH
105887: CALL_OW 331
// end ; end_of_file
105891: LD_VAR 0 4
105895: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105896: LD_INT 0
105898: PPUSH
105899: PPUSH
105900: PPUSH
105901: PPUSH
105902: PPUSH
105903: PPUSH
105904: PPUSH
105905: PPUSH
105906: PPUSH
105907: PPUSH
105908: PPUSH
105909: PPUSH
105910: PPUSH
105911: PPUSH
105912: PPUSH
105913: PPUSH
105914: PPUSH
105915: PPUSH
105916: PPUSH
105917: PPUSH
105918: PPUSH
105919: PPUSH
105920: PPUSH
105921: PPUSH
105922: PPUSH
105923: PPUSH
105924: PPUSH
105925: PPUSH
105926: PPUSH
105927: PPUSH
105928: PPUSH
105929: PPUSH
105930: PPUSH
105931: PPUSH
// if not list then
105932: LD_VAR 0 1
105936: NOT
105937: IFFALSE 105941
// exit ;
105939: GO 110600
// base := list [ 1 ] ;
105941: LD_ADDR_VAR 0 3
105945: PUSH
105946: LD_VAR 0 1
105950: PUSH
105951: LD_INT 1
105953: ARRAY
105954: ST_TO_ADDR
// group := list [ 2 ] ;
105955: LD_ADDR_VAR 0 4
105959: PUSH
105960: LD_VAR 0 1
105964: PUSH
105965: LD_INT 2
105967: ARRAY
105968: ST_TO_ADDR
// path := list [ 3 ] ;
105969: LD_ADDR_VAR 0 5
105973: PUSH
105974: LD_VAR 0 1
105978: PUSH
105979: LD_INT 3
105981: ARRAY
105982: ST_TO_ADDR
// flags := list [ 4 ] ;
105983: LD_ADDR_VAR 0 6
105987: PUSH
105988: LD_VAR 0 1
105992: PUSH
105993: LD_INT 4
105995: ARRAY
105996: ST_TO_ADDR
// mined := [ ] ;
105997: LD_ADDR_VAR 0 27
106001: PUSH
106002: EMPTY
106003: ST_TO_ADDR
// bombed := [ ] ;
106004: LD_ADDR_VAR 0 28
106008: PUSH
106009: EMPTY
106010: ST_TO_ADDR
// healers := [ ] ;
106011: LD_ADDR_VAR 0 31
106015: PUSH
106016: EMPTY
106017: ST_TO_ADDR
// to_heal := [ ] ;
106018: LD_ADDR_VAR 0 30
106022: PUSH
106023: EMPTY
106024: ST_TO_ADDR
// repairs := [ ] ;
106025: LD_ADDR_VAR 0 33
106029: PUSH
106030: EMPTY
106031: ST_TO_ADDR
// to_repair := [ ] ;
106032: LD_ADDR_VAR 0 32
106036: PUSH
106037: EMPTY
106038: ST_TO_ADDR
// if not group or not path then
106039: LD_VAR 0 4
106043: NOT
106044: PUSH
106045: LD_VAR 0 5
106049: NOT
106050: OR
106051: IFFALSE 106055
// exit ;
106053: GO 110600
// side := GetSide ( group [ 1 ] ) ;
106055: LD_ADDR_VAR 0 35
106059: PUSH
106060: LD_VAR 0 4
106064: PUSH
106065: LD_INT 1
106067: ARRAY
106068: PPUSH
106069: CALL_OW 255
106073: ST_TO_ADDR
// if flags then
106074: LD_VAR 0 6
106078: IFFALSE 106222
// begin f_ignore_area := flags [ 1 ] ;
106080: LD_ADDR_VAR 0 17
106084: PUSH
106085: LD_VAR 0 6
106089: PUSH
106090: LD_INT 1
106092: ARRAY
106093: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
106094: LD_ADDR_VAR 0 18
106098: PUSH
106099: LD_VAR 0 6
106103: PUSH
106104: LD_INT 2
106106: ARRAY
106107: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
106108: LD_ADDR_VAR 0 19
106112: PUSH
106113: LD_VAR 0 6
106117: PUSH
106118: LD_INT 3
106120: ARRAY
106121: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
106122: LD_ADDR_VAR 0 20
106126: PUSH
106127: LD_VAR 0 6
106131: PUSH
106132: LD_INT 4
106134: ARRAY
106135: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
106136: LD_ADDR_VAR 0 21
106140: PUSH
106141: LD_VAR 0 6
106145: PUSH
106146: LD_INT 5
106148: ARRAY
106149: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
106150: LD_ADDR_VAR 0 22
106154: PUSH
106155: LD_VAR 0 6
106159: PUSH
106160: LD_INT 6
106162: ARRAY
106163: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
106164: LD_ADDR_VAR 0 23
106168: PUSH
106169: LD_VAR 0 6
106173: PUSH
106174: LD_INT 7
106176: ARRAY
106177: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106178: LD_ADDR_VAR 0 24
106182: PUSH
106183: LD_VAR 0 6
106187: PUSH
106188: LD_INT 8
106190: ARRAY
106191: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106192: LD_ADDR_VAR 0 25
106196: PUSH
106197: LD_VAR 0 6
106201: PUSH
106202: LD_INT 9
106204: ARRAY
106205: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106206: LD_ADDR_VAR 0 26
106210: PUSH
106211: LD_VAR 0 6
106215: PUSH
106216: LD_INT 10
106218: ARRAY
106219: ST_TO_ADDR
// end else
106220: GO 106302
// begin f_ignore_area := false ;
106222: LD_ADDR_VAR 0 17
106226: PUSH
106227: LD_INT 0
106229: ST_TO_ADDR
// f_capture := false ;
106230: LD_ADDR_VAR 0 18
106234: PUSH
106235: LD_INT 0
106237: ST_TO_ADDR
// f_ignore_civ := false ;
106238: LD_ADDR_VAR 0 19
106242: PUSH
106243: LD_INT 0
106245: ST_TO_ADDR
// f_murder := false ;
106246: LD_ADDR_VAR 0 20
106250: PUSH
106251: LD_INT 0
106253: ST_TO_ADDR
// f_mines := false ;
106254: LD_ADDR_VAR 0 21
106258: PUSH
106259: LD_INT 0
106261: ST_TO_ADDR
// f_repair := false ;
106262: LD_ADDR_VAR 0 22
106266: PUSH
106267: LD_INT 0
106269: ST_TO_ADDR
// f_heal := false ;
106270: LD_ADDR_VAR 0 23
106274: PUSH
106275: LD_INT 0
106277: ST_TO_ADDR
// f_spacetime := false ;
106278: LD_ADDR_VAR 0 24
106282: PUSH
106283: LD_INT 0
106285: ST_TO_ADDR
// f_attack_depot := false ;
106286: LD_ADDR_VAR 0 25
106290: PUSH
106291: LD_INT 0
106293: ST_TO_ADDR
// f_crawl := false ;
106294: LD_ADDR_VAR 0 26
106298: PUSH
106299: LD_INT 0
106301: ST_TO_ADDR
// end ; if f_heal then
106302: LD_VAR 0 23
106306: IFFALSE 106333
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106308: LD_ADDR_VAR 0 31
106312: PUSH
106313: LD_VAR 0 4
106317: PPUSH
106318: LD_INT 25
106320: PUSH
106321: LD_INT 4
106323: PUSH
106324: EMPTY
106325: LIST
106326: LIST
106327: PPUSH
106328: CALL_OW 72
106332: ST_TO_ADDR
// if f_repair then
106333: LD_VAR 0 22
106337: IFFALSE 106364
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106339: LD_ADDR_VAR 0 33
106343: PUSH
106344: LD_VAR 0 4
106348: PPUSH
106349: LD_INT 25
106351: PUSH
106352: LD_INT 3
106354: PUSH
106355: EMPTY
106356: LIST
106357: LIST
106358: PPUSH
106359: CALL_OW 72
106363: ST_TO_ADDR
// units_path := [ ] ;
106364: LD_ADDR_VAR 0 16
106368: PUSH
106369: EMPTY
106370: ST_TO_ADDR
// for i = 1 to group do
106371: LD_ADDR_VAR 0 7
106375: PUSH
106376: DOUBLE
106377: LD_INT 1
106379: DEC
106380: ST_TO_ADDR
106381: LD_VAR 0 4
106385: PUSH
106386: FOR_TO
106387: IFFALSE 106416
// units_path := Replace ( units_path , i , path ) ;
106389: LD_ADDR_VAR 0 16
106393: PUSH
106394: LD_VAR 0 16
106398: PPUSH
106399: LD_VAR 0 7
106403: PPUSH
106404: LD_VAR 0 5
106408: PPUSH
106409: CALL_OW 1
106413: ST_TO_ADDR
106414: GO 106386
106416: POP
106417: POP
// repeat for i = group downto 1 do
106418: LD_ADDR_VAR 0 7
106422: PUSH
106423: DOUBLE
106424: LD_VAR 0 4
106428: INC
106429: ST_TO_ADDR
106430: LD_INT 1
106432: PUSH
106433: FOR_DOWNTO
106434: IFFALSE 110556
// begin wait ( 5 ) ;
106436: LD_INT 5
106438: PPUSH
106439: CALL_OW 67
// tmp := [ ] ;
106443: LD_ADDR_VAR 0 14
106447: PUSH
106448: EMPTY
106449: ST_TO_ADDR
// attacking := false ;
106450: LD_ADDR_VAR 0 29
106454: PUSH
106455: LD_INT 0
106457: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106458: LD_VAR 0 4
106462: PUSH
106463: LD_VAR 0 7
106467: ARRAY
106468: PPUSH
106469: CALL_OW 301
106473: PUSH
106474: LD_VAR 0 4
106478: PUSH
106479: LD_VAR 0 7
106483: ARRAY
106484: NOT
106485: OR
106486: IFFALSE 106595
// begin if GetType ( group [ i ] ) = unit_human then
106488: LD_VAR 0 4
106492: PUSH
106493: LD_VAR 0 7
106497: ARRAY
106498: PPUSH
106499: CALL_OW 247
106503: PUSH
106504: LD_INT 1
106506: EQUAL
106507: IFFALSE 106553
// begin to_heal := to_heal diff group [ i ] ;
106509: LD_ADDR_VAR 0 30
106513: PUSH
106514: LD_VAR 0 30
106518: PUSH
106519: LD_VAR 0 4
106523: PUSH
106524: LD_VAR 0 7
106528: ARRAY
106529: DIFF
106530: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106531: LD_ADDR_VAR 0 31
106535: PUSH
106536: LD_VAR 0 31
106540: PUSH
106541: LD_VAR 0 4
106545: PUSH
106546: LD_VAR 0 7
106550: ARRAY
106551: DIFF
106552: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106553: LD_ADDR_VAR 0 4
106557: PUSH
106558: LD_VAR 0 4
106562: PPUSH
106563: LD_VAR 0 7
106567: PPUSH
106568: CALL_OW 3
106572: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106573: LD_ADDR_VAR 0 16
106577: PUSH
106578: LD_VAR 0 16
106582: PPUSH
106583: LD_VAR 0 7
106587: PPUSH
106588: CALL_OW 3
106592: ST_TO_ADDR
// continue ;
106593: GO 106433
// end ; if f_repair then
106595: LD_VAR 0 22
106599: IFFALSE 107088
// begin if GetType ( group [ i ] ) = unit_vehicle then
106601: LD_VAR 0 4
106605: PUSH
106606: LD_VAR 0 7
106610: ARRAY
106611: PPUSH
106612: CALL_OW 247
106616: PUSH
106617: LD_INT 2
106619: EQUAL
106620: IFFALSE 106810
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106622: LD_VAR 0 4
106626: PUSH
106627: LD_VAR 0 7
106631: ARRAY
106632: PPUSH
106633: CALL_OW 256
106637: PUSH
106638: LD_INT 700
106640: LESS
106641: PUSH
106642: LD_VAR 0 4
106646: PUSH
106647: LD_VAR 0 7
106651: ARRAY
106652: PUSH
106653: LD_VAR 0 32
106657: IN
106658: NOT
106659: AND
106660: IFFALSE 106684
// to_repair := to_repair union group [ i ] ;
106662: LD_ADDR_VAR 0 32
106666: PUSH
106667: LD_VAR 0 32
106671: PUSH
106672: LD_VAR 0 4
106676: PUSH
106677: LD_VAR 0 7
106681: ARRAY
106682: UNION
106683: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106684: LD_VAR 0 4
106688: PUSH
106689: LD_VAR 0 7
106693: ARRAY
106694: PPUSH
106695: CALL_OW 256
106699: PUSH
106700: LD_INT 1000
106702: EQUAL
106703: PUSH
106704: LD_VAR 0 4
106708: PUSH
106709: LD_VAR 0 7
106713: ARRAY
106714: PUSH
106715: LD_VAR 0 32
106719: IN
106720: AND
106721: IFFALSE 106745
// to_repair := to_repair diff group [ i ] ;
106723: LD_ADDR_VAR 0 32
106727: PUSH
106728: LD_VAR 0 32
106732: PUSH
106733: LD_VAR 0 4
106737: PUSH
106738: LD_VAR 0 7
106742: ARRAY
106743: DIFF
106744: ST_TO_ADDR
// if group [ i ] in to_repair then
106745: LD_VAR 0 4
106749: PUSH
106750: LD_VAR 0 7
106754: ARRAY
106755: PUSH
106756: LD_VAR 0 32
106760: IN
106761: IFFALSE 106808
// begin if not IsInArea ( group [ i ] , f_repair ) then
106763: LD_VAR 0 4
106767: PUSH
106768: LD_VAR 0 7
106772: ARRAY
106773: PPUSH
106774: LD_VAR 0 22
106778: PPUSH
106779: CALL_OW 308
106783: NOT
106784: IFFALSE 106806
// ComMoveToArea ( group [ i ] , f_repair ) ;
106786: LD_VAR 0 4
106790: PUSH
106791: LD_VAR 0 7
106795: ARRAY
106796: PPUSH
106797: LD_VAR 0 22
106801: PPUSH
106802: CALL_OW 113
// continue ;
106806: GO 106433
// end ; end else
106808: GO 107088
// if group [ i ] in repairs then
106810: LD_VAR 0 4
106814: PUSH
106815: LD_VAR 0 7
106819: ARRAY
106820: PUSH
106821: LD_VAR 0 33
106825: IN
106826: IFFALSE 107088
// begin if IsInUnit ( group [ i ] ) then
106828: LD_VAR 0 4
106832: PUSH
106833: LD_VAR 0 7
106837: ARRAY
106838: PPUSH
106839: CALL_OW 310
106843: IFFALSE 106911
// begin z := IsInUnit ( group [ i ] ) ;
106845: LD_ADDR_VAR 0 13
106849: PUSH
106850: LD_VAR 0 4
106854: PUSH
106855: LD_VAR 0 7
106859: ARRAY
106860: PPUSH
106861: CALL_OW 310
106865: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106866: LD_VAR 0 13
106870: PUSH
106871: LD_VAR 0 32
106875: IN
106876: PUSH
106877: LD_VAR 0 13
106881: PPUSH
106882: LD_VAR 0 22
106886: PPUSH
106887: CALL_OW 308
106891: AND
106892: IFFALSE 106909
// ComExitVehicle ( group [ i ] ) ;
106894: LD_VAR 0 4
106898: PUSH
106899: LD_VAR 0 7
106903: ARRAY
106904: PPUSH
106905: CALL_OW 121
// end else
106909: GO 107088
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106911: LD_ADDR_VAR 0 13
106915: PUSH
106916: LD_VAR 0 4
106920: PPUSH
106921: LD_INT 95
106923: PUSH
106924: LD_VAR 0 22
106928: PUSH
106929: EMPTY
106930: LIST
106931: LIST
106932: PUSH
106933: LD_INT 58
106935: PUSH
106936: EMPTY
106937: LIST
106938: PUSH
106939: EMPTY
106940: LIST
106941: LIST
106942: PPUSH
106943: CALL_OW 72
106947: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106948: LD_VAR 0 4
106952: PUSH
106953: LD_VAR 0 7
106957: ARRAY
106958: PPUSH
106959: CALL_OW 314
106963: NOT
106964: IFFALSE 107086
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106966: LD_ADDR_VAR 0 10
106970: PUSH
106971: LD_VAR 0 13
106975: PPUSH
106976: LD_VAR 0 4
106980: PUSH
106981: LD_VAR 0 7
106985: ARRAY
106986: PPUSH
106987: CALL_OW 74
106991: ST_TO_ADDR
// if not x then
106992: LD_VAR 0 10
106996: NOT
106997: IFFALSE 107001
// continue ;
106999: GO 106433
// if GetLives ( x ) < 1000 then
107001: LD_VAR 0 10
107005: PPUSH
107006: CALL_OW 256
107010: PUSH
107011: LD_INT 1000
107013: LESS
107014: IFFALSE 107038
// ComRepairVehicle ( group [ i ] , x ) else
107016: LD_VAR 0 4
107020: PUSH
107021: LD_VAR 0 7
107025: ARRAY
107026: PPUSH
107027: LD_VAR 0 10
107031: PPUSH
107032: CALL_OW 129
107036: GO 107086
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107038: LD_VAR 0 23
107042: PUSH
107043: LD_VAR 0 4
107047: PUSH
107048: LD_VAR 0 7
107052: ARRAY
107053: PPUSH
107054: CALL_OW 256
107058: PUSH
107059: LD_INT 1000
107061: LESS
107062: AND
107063: NOT
107064: IFFALSE 107086
// ComEnterUnit ( group [ i ] , x ) ;
107066: LD_VAR 0 4
107070: PUSH
107071: LD_VAR 0 7
107075: ARRAY
107076: PPUSH
107077: LD_VAR 0 10
107081: PPUSH
107082: CALL_OW 120
// end ; continue ;
107086: GO 106433
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
107088: LD_VAR 0 23
107092: PUSH
107093: LD_VAR 0 4
107097: PUSH
107098: LD_VAR 0 7
107102: ARRAY
107103: PPUSH
107104: CALL_OW 247
107108: PUSH
107109: LD_INT 1
107111: EQUAL
107112: AND
107113: IFFALSE 107591
// begin if group [ i ] in healers then
107115: LD_VAR 0 4
107119: PUSH
107120: LD_VAR 0 7
107124: ARRAY
107125: PUSH
107126: LD_VAR 0 31
107130: IN
107131: IFFALSE 107404
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
107133: LD_VAR 0 4
107137: PUSH
107138: LD_VAR 0 7
107142: ARRAY
107143: PPUSH
107144: LD_VAR 0 23
107148: PPUSH
107149: CALL_OW 308
107153: NOT
107154: PUSH
107155: LD_VAR 0 4
107159: PUSH
107160: LD_VAR 0 7
107164: ARRAY
107165: PPUSH
107166: CALL_OW 314
107170: NOT
107171: AND
107172: IFFALSE 107196
// ComMoveToArea ( group [ i ] , f_heal ) else
107174: LD_VAR 0 4
107178: PUSH
107179: LD_VAR 0 7
107183: ARRAY
107184: PPUSH
107185: LD_VAR 0 23
107189: PPUSH
107190: CALL_OW 113
107194: GO 107402
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107196: LD_VAR 0 4
107200: PUSH
107201: LD_VAR 0 7
107205: ARRAY
107206: PPUSH
107207: CALL 84704 0 1
107211: PPUSH
107212: CALL_OW 256
107216: PUSH
107217: LD_INT 1000
107219: EQUAL
107220: IFFALSE 107239
// ComStop ( group [ i ] ) else
107222: LD_VAR 0 4
107226: PUSH
107227: LD_VAR 0 7
107231: ARRAY
107232: PPUSH
107233: CALL_OW 141
107237: GO 107402
// if not HasTask ( group [ i ] ) and to_heal then
107239: LD_VAR 0 4
107243: PUSH
107244: LD_VAR 0 7
107248: ARRAY
107249: PPUSH
107250: CALL_OW 314
107254: NOT
107255: PUSH
107256: LD_VAR 0 30
107260: AND
107261: IFFALSE 107402
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107263: LD_ADDR_VAR 0 13
107267: PUSH
107268: LD_VAR 0 30
107272: PPUSH
107273: LD_INT 3
107275: PUSH
107276: LD_INT 54
107278: PUSH
107279: EMPTY
107280: LIST
107281: PUSH
107282: EMPTY
107283: LIST
107284: LIST
107285: PPUSH
107286: CALL_OW 72
107290: PPUSH
107291: LD_VAR 0 4
107295: PUSH
107296: LD_VAR 0 7
107300: ARRAY
107301: PPUSH
107302: CALL_OW 74
107306: ST_TO_ADDR
// if z then
107307: LD_VAR 0 13
107311: IFFALSE 107402
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107313: LD_INT 91
107315: PUSH
107316: LD_VAR 0 13
107320: PUSH
107321: LD_INT 10
107323: PUSH
107324: EMPTY
107325: LIST
107326: LIST
107327: LIST
107328: PUSH
107329: LD_INT 81
107331: PUSH
107332: LD_VAR 0 13
107336: PPUSH
107337: CALL_OW 255
107341: PUSH
107342: EMPTY
107343: LIST
107344: LIST
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: PPUSH
107350: CALL_OW 69
107354: PUSH
107355: LD_INT 0
107357: EQUAL
107358: IFFALSE 107382
// ComHeal ( group [ i ] , z ) else
107360: LD_VAR 0 4
107364: PUSH
107365: LD_VAR 0 7
107369: ARRAY
107370: PPUSH
107371: LD_VAR 0 13
107375: PPUSH
107376: CALL_OW 128
107380: GO 107402
// ComMoveToArea ( group [ i ] , f_heal ) ;
107382: LD_VAR 0 4
107386: PUSH
107387: LD_VAR 0 7
107391: ARRAY
107392: PPUSH
107393: LD_VAR 0 23
107397: PPUSH
107398: CALL_OW 113
// end ; continue ;
107402: GO 106433
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107404: LD_VAR 0 4
107408: PUSH
107409: LD_VAR 0 7
107413: ARRAY
107414: PPUSH
107415: CALL_OW 256
107419: PUSH
107420: LD_INT 700
107422: LESS
107423: PUSH
107424: LD_VAR 0 4
107428: PUSH
107429: LD_VAR 0 7
107433: ARRAY
107434: PUSH
107435: LD_VAR 0 30
107439: IN
107440: NOT
107441: AND
107442: IFFALSE 107466
// to_heal := to_heal union group [ i ] ;
107444: LD_ADDR_VAR 0 30
107448: PUSH
107449: LD_VAR 0 30
107453: PUSH
107454: LD_VAR 0 4
107458: PUSH
107459: LD_VAR 0 7
107463: ARRAY
107464: UNION
107465: ST_TO_ADDR
// if group [ i ] in to_heal then
107466: LD_VAR 0 4
107470: PUSH
107471: LD_VAR 0 7
107475: ARRAY
107476: PUSH
107477: LD_VAR 0 30
107481: IN
107482: IFFALSE 107591
// begin if GetLives ( group [ i ] ) = 1000 then
107484: LD_VAR 0 4
107488: PUSH
107489: LD_VAR 0 7
107493: ARRAY
107494: PPUSH
107495: CALL_OW 256
107499: PUSH
107500: LD_INT 1000
107502: EQUAL
107503: IFFALSE 107529
// to_heal := to_heal diff group [ i ] else
107505: LD_ADDR_VAR 0 30
107509: PUSH
107510: LD_VAR 0 30
107514: PUSH
107515: LD_VAR 0 4
107519: PUSH
107520: LD_VAR 0 7
107524: ARRAY
107525: DIFF
107526: ST_TO_ADDR
107527: GO 107591
// begin if not IsInArea ( group [ i ] , to_heal ) then
107529: LD_VAR 0 4
107533: PUSH
107534: LD_VAR 0 7
107538: ARRAY
107539: PPUSH
107540: LD_VAR 0 30
107544: PPUSH
107545: CALL_OW 308
107549: NOT
107550: IFFALSE 107574
// ComMoveToArea ( group [ i ] , f_heal ) else
107552: LD_VAR 0 4
107556: PUSH
107557: LD_VAR 0 7
107561: ARRAY
107562: PPUSH
107563: LD_VAR 0 23
107567: PPUSH
107568: CALL_OW 113
107572: GO 107589
// ComHold ( group [ i ] ) ;
107574: LD_VAR 0 4
107578: PUSH
107579: LD_VAR 0 7
107583: ARRAY
107584: PPUSH
107585: CALL_OW 140
// continue ;
107589: GO 106433
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107591: LD_VAR 0 4
107595: PUSH
107596: LD_VAR 0 7
107600: ARRAY
107601: PPUSH
107602: LD_INT 10
107604: PPUSH
107605: CALL 83124 0 2
107609: NOT
107610: PUSH
107611: LD_VAR 0 16
107615: PUSH
107616: LD_VAR 0 7
107620: ARRAY
107621: PUSH
107622: EMPTY
107623: EQUAL
107624: NOT
107625: AND
107626: IFFALSE 107892
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107628: LD_VAR 0 4
107632: PUSH
107633: LD_VAR 0 7
107637: ARRAY
107638: PPUSH
107639: CALL_OW 262
107643: PUSH
107644: LD_INT 1
107646: PUSH
107647: LD_INT 2
107649: PUSH
107650: EMPTY
107651: LIST
107652: LIST
107653: IN
107654: IFFALSE 107695
// if GetFuel ( group [ i ] ) < 10 then
107656: LD_VAR 0 4
107660: PUSH
107661: LD_VAR 0 7
107665: ARRAY
107666: PPUSH
107667: CALL_OW 261
107671: PUSH
107672: LD_INT 10
107674: LESS
107675: IFFALSE 107695
// SetFuel ( group [ i ] , 12 ) ;
107677: LD_VAR 0 4
107681: PUSH
107682: LD_VAR 0 7
107686: ARRAY
107687: PPUSH
107688: LD_INT 12
107690: PPUSH
107691: CALL_OW 240
// if units_path [ i ] then
107695: LD_VAR 0 16
107699: PUSH
107700: LD_VAR 0 7
107704: ARRAY
107705: IFFALSE 107890
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107707: LD_VAR 0 4
107711: PUSH
107712: LD_VAR 0 7
107716: ARRAY
107717: PPUSH
107718: LD_VAR 0 16
107722: PUSH
107723: LD_VAR 0 7
107727: ARRAY
107728: PUSH
107729: LD_INT 1
107731: ARRAY
107732: PUSH
107733: LD_INT 1
107735: ARRAY
107736: PPUSH
107737: LD_VAR 0 16
107741: PUSH
107742: LD_VAR 0 7
107746: ARRAY
107747: PUSH
107748: LD_INT 1
107750: ARRAY
107751: PUSH
107752: LD_INT 2
107754: ARRAY
107755: PPUSH
107756: CALL_OW 297
107760: PUSH
107761: LD_INT 6
107763: GREATER
107764: IFFALSE 107839
// begin if not HasTask ( group [ i ] ) then
107766: LD_VAR 0 4
107770: PUSH
107771: LD_VAR 0 7
107775: ARRAY
107776: PPUSH
107777: CALL_OW 314
107781: NOT
107782: IFFALSE 107837
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107784: LD_VAR 0 4
107788: PUSH
107789: LD_VAR 0 7
107793: ARRAY
107794: PPUSH
107795: LD_VAR 0 16
107799: PUSH
107800: LD_VAR 0 7
107804: ARRAY
107805: PUSH
107806: LD_INT 1
107808: ARRAY
107809: PUSH
107810: LD_INT 1
107812: ARRAY
107813: PPUSH
107814: LD_VAR 0 16
107818: PUSH
107819: LD_VAR 0 7
107823: ARRAY
107824: PUSH
107825: LD_INT 1
107827: ARRAY
107828: PUSH
107829: LD_INT 2
107831: ARRAY
107832: PPUSH
107833: CALL_OW 114
// end else
107837: GO 107890
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107839: LD_ADDR_VAR 0 15
107843: PUSH
107844: LD_VAR 0 16
107848: PUSH
107849: LD_VAR 0 7
107853: ARRAY
107854: PPUSH
107855: LD_INT 1
107857: PPUSH
107858: CALL_OW 3
107862: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107863: LD_ADDR_VAR 0 16
107867: PUSH
107868: LD_VAR 0 16
107872: PPUSH
107873: LD_VAR 0 7
107877: PPUSH
107878: LD_VAR 0 15
107882: PPUSH
107883: CALL_OW 1
107887: ST_TO_ADDR
// continue ;
107888: GO 106433
// end ; end ; end else
107890: GO 110554
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107892: LD_ADDR_VAR 0 14
107896: PUSH
107897: LD_INT 81
107899: PUSH
107900: LD_VAR 0 4
107904: PUSH
107905: LD_VAR 0 7
107909: ARRAY
107910: PPUSH
107911: CALL_OW 255
107915: PUSH
107916: EMPTY
107917: LIST
107918: LIST
107919: PPUSH
107920: CALL_OW 69
107924: ST_TO_ADDR
// if not tmp then
107925: LD_VAR 0 14
107929: NOT
107930: IFFALSE 107934
// continue ;
107932: GO 106433
// if f_ignore_area then
107934: LD_VAR 0 17
107938: IFFALSE 108026
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107940: LD_ADDR_VAR 0 15
107944: PUSH
107945: LD_VAR 0 14
107949: PPUSH
107950: LD_INT 3
107952: PUSH
107953: LD_INT 92
107955: PUSH
107956: LD_VAR 0 17
107960: PUSH
107961: LD_INT 1
107963: ARRAY
107964: PUSH
107965: LD_VAR 0 17
107969: PUSH
107970: LD_INT 2
107972: ARRAY
107973: PUSH
107974: LD_VAR 0 17
107978: PUSH
107979: LD_INT 3
107981: ARRAY
107982: PUSH
107983: EMPTY
107984: LIST
107985: LIST
107986: LIST
107987: LIST
107988: PUSH
107989: EMPTY
107990: LIST
107991: LIST
107992: PPUSH
107993: CALL_OW 72
107997: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107998: LD_VAR 0 14
108002: PUSH
108003: LD_VAR 0 15
108007: DIFF
108008: IFFALSE 108026
// tmp := tmp diff tmp2 ;
108010: LD_ADDR_VAR 0 14
108014: PUSH
108015: LD_VAR 0 14
108019: PUSH
108020: LD_VAR 0 15
108024: DIFF
108025: ST_TO_ADDR
// end ; if not f_murder then
108026: LD_VAR 0 20
108030: NOT
108031: IFFALSE 108089
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108033: LD_ADDR_VAR 0 15
108037: PUSH
108038: LD_VAR 0 14
108042: PPUSH
108043: LD_INT 3
108045: PUSH
108046: LD_INT 50
108048: PUSH
108049: EMPTY
108050: LIST
108051: PUSH
108052: EMPTY
108053: LIST
108054: LIST
108055: PPUSH
108056: CALL_OW 72
108060: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108061: LD_VAR 0 14
108065: PUSH
108066: LD_VAR 0 15
108070: DIFF
108071: IFFALSE 108089
// tmp := tmp diff tmp2 ;
108073: LD_ADDR_VAR 0 14
108077: PUSH
108078: LD_VAR 0 14
108082: PUSH
108083: LD_VAR 0 15
108087: DIFF
108088: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
108089: LD_ADDR_VAR 0 14
108093: PUSH
108094: LD_VAR 0 4
108098: PUSH
108099: LD_VAR 0 7
108103: ARRAY
108104: PPUSH
108105: LD_VAR 0 14
108109: PPUSH
108110: LD_INT 1
108112: PPUSH
108113: LD_INT 1
108115: PPUSH
108116: CALL 56434 0 4
108120: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
108121: LD_VAR 0 4
108125: PUSH
108126: LD_VAR 0 7
108130: ARRAY
108131: PPUSH
108132: CALL_OW 257
108136: PUSH
108137: LD_INT 1
108139: EQUAL
108140: IFFALSE 108588
// begin if WantPlant ( group [ i ] ) then
108142: LD_VAR 0 4
108146: PUSH
108147: LD_VAR 0 7
108151: ARRAY
108152: PPUSH
108153: CALL 55935 0 1
108157: IFFALSE 108161
// continue ;
108159: GO 106433
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
108161: LD_VAR 0 18
108165: PUSH
108166: LD_VAR 0 4
108170: PUSH
108171: LD_VAR 0 7
108175: ARRAY
108176: PPUSH
108177: CALL_OW 310
108181: NOT
108182: AND
108183: PUSH
108184: LD_VAR 0 14
108188: PUSH
108189: LD_INT 1
108191: ARRAY
108192: PUSH
108193: LD_VAR 0 14
108197: PPUSH
108198: LD_INT 21
108200: PUSH
108201: LD_INT 2
108203: PUSH
108204: EMPTY
108205: LIST
108206: LIST
108207: PUSH
108208: LD_INT 58
108210: PUSH
108211: EMPTY
108212: LIST
108213: PUSH
108214: EMPTY
108215: LIST
108216: LIST
108217: PPUSH
108218: CALL_OW 72
108222: IN
108223: AND
108224: IFFALSE 108260
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108226: LD_VAR 0 4
108230: PUSH
108231: LD_VAR 0 7
108235: ARRAY
108236: PPUSH
108237: LD_VAR 0 14
108241: PUSH
108242: LD_INT 1
108244: ARRAY
108245: PPUSH
108246: CALL_OW 120
// attacking := true ;
108250: LD_ADDR_VAR 0 29
108254: PUSH
108255: LD_INT 1
108257: ST_TO_ADDR
// continue ;
108258: GO 106433
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108260: LD_VAR 0 26
108264: PUSH
108265: LD_VAR 0 4
108269: PUSH
108270: LD_VAR 0 7
108274: ARRAY
108275: PPUSH
108276: CALL_OW 257
108280: PUSH
108281: LD_INT 1
108283: EQUAL
108284: AND
108285: PUSH
108286: LD_VAR 0 4
108290: PUSH
108291: LD_VAR 0 7
108295: ARRAY
108296: PPUSH
108297: CALL_OW 256
108301: PUSH
108302: LD_INT 800
108304: LESS
108305: AND
108306: PUSH
108307: LD_VAR 0 4
108311: PUSH
108312: LD_VAR 0 7
108316: ARRAY
108317: PPUSH
108318: CALL_OW 318
108322: NOT
108323: AND
108324: IFFALSE 108341
// ComCrawl ( group [ i ] ) ;
108326: LD_VAR 0 4
108330: PUSH
108331: LD_VAR 0 7
108335: ARRAY
108336: PPUSH
108337: CALL_OW 137
// if f_mines then
108341: LD_VAR 0 21
108345: IFFALSE 108588
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108347: LD_VAR 0 14
108351: PUSH
108352: LD_INT 1
108354: ARRAY
108355: PPUSH
108356: CALL_OW 247
108360: PUSH
108361: LD_INT 3
108363: EQUAL
108364: PUSH
108365: LD_VAR 0 14
108369: PUSH
108370: LD_INT 1
108372: ARRAY
108373: PUSH
108374: LD_VAR 0 27
108378: IN
108379: NOT
108380: AND
108381: IFFALSE 108588
// begin x := GetX ( tmp [ 1 ] ) ;
108383: LD_ADDR_VAR 0 10
108387: PUSH
108388: LD_VAR 0 14
108392: PUSH
108393: LD_INT 1
108395: ARRAY
108396: PPUSH
108397: CALL_OW 250
108401: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108402: LD_ADDR_VAR 0 11
108406: PUSH
108407: LD_VAR 0 14
108411: PUSH
108412: LD_INT 1
108414: ARRAY
108415: PPUSH
108416: CALL_OW 251
108420: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108421: LD_ADDR_VAR 0 12
108425: PUSH
108426: LD_VAR 0 4
108430: PUSH
108431: LD_VAR 0 7
108435: ARRAY
108436: PPUSH
108437: CALL 83209 0 1
108441: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108442: LD_VAR 0 4
108446: PUSH
108447: LD_VAR 0 7
108451: ARRAY
108452: PPUSH
108453: LD_VAR 0 10
108457: PPUSH
108458: LD_VAR 0 11
108462: PPUSH
108463: LD_VAR 0 14
108467: PUSH
108468: LD_INT 1
108470: ARRAY
108471: PPUSH
108472: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108476: LD_VAR 0 4
108480: PUSH
108481: LD_VAR 0 7
108485: ARRAY
108486: PPUSH
108487: LD_VAR 0 10
108491: PPUSH
108492: LD_VAR 0 12
108496: PPUSH
108497: LD_INT 7
108499: PPUSH
108500: CALL_OW 272
108504: PPUSH
108505: LD_VAR 0 11
108509: PPUSH
108510: LD_VAR 0 12
108514: PPUSH
108515: LD_INT 7
108517: PPUSH
108518: CALL_OW 273
108522: PPUSH
108523: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108527: LD_VAR 0 4
108531: PUSH
108532: LD_VAR 0 7
108536: ARRAY
108537: PPUSH
108538: LD_INT 71
108540: PPUSH
108541: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108545: LD_ADDR_VAR 0 27
108549: PUSH
108550: LD_VAR 0 27
108554: PPUSH
108555: LD_VAR 0 27
108559: PUSH
108560: LD_INT 1
108562: PLUS
108563: PPUSH
108564: LD_VAR 0 14
108568: PUSH
108569: LD_INT 1
108571: ARRAY
108572: PPUSH
108573: CALL_OW 1
108577: ST_TO_ADDR
// attacking := true ;
108578: LD_ADDR_VAR 0 29
108582: PUSH
108583: LD_INT 1
108585: ST_TO_ADDR
// continue ;
108586: GO 106433
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108588: LD_VAR 0 4
108592: PUSH
108593: LD_VAR 0 7
108597: ARRAY
108598: PPUSH
108599: CALL_OW 257
108603: PUSH
108604: LD_INT 17
108606: EQUAL
108607: PUSH
108608: LD_VAR 0 4
108612: PUSH
108613: LD_VAR 0 7
108617: ARRAY
108618: PPUSH
108619: CALL_OW 110
108623: PUSH
108624: LD_INT 71
108626: EQUAL
108627: NOT
108628: AND
108629: IFFALSE 108775
// begin attacking := false ;
108631: LD_ADDR_VAR 0 29
108635: PUSH
108636: LD_INT 0
108638: ST_TO_ADDR
// k := 5 ;
108639: LD_ADDR_VAR 0 9
108643: PUSH
108644: LD_INT 5
108646: ST_TO_ADDR
// if tmp < k then
108647: LD_VAR 0 14
108651: PUSH
108652: LD_VAR 0 9
108656: LESS
108657: IFFALSE 108669
// k := tmp ;
108659: LD_ADDR_VAR 0 9
108663: PUSH
108664: LD_VAR 0 14
108668: ST_TO_ADDR
// for j = 1 to k do
108669: LD_ADDR_VAR 0 8
108673: PUSH
108674: DOUBLE
108675: LD_INT 1
108677: DEC
108678: ST_TO_ADDR
108679: LD_VAR 0 9
108683: PUSH
108684: FOR_TO
108685: IFFALSE 108773
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108687: LD_VAR 0 14
108691: PUSH
108692: LD_VAR 0 8
108696: ARRAY
108697: PUSH
108698: LD_VAR 0 14
108702: PPUSH
108703: LD_INT 58
108705: PUSH
108706: EMPTY
108707: LIST
108708: PPUSH
108709: CALL_OW 72
108713: IN
108714: NOT
108715: IFFALSE 108771
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108717: LD_VAR 0 4
108721: PUSH
108722: LD_VAR 0 7
108726: ARRAY
108727: PPUSH
108728: LD_VAR 0 14
108732: PUSH
108733: LD_VAR 0 8
108737: ARRAY
108738: PPUSH
108739: CALL_OW 115
// attacking := true ;
108743: LD_ADDR_VAR 0 29
108747: PUSH
108748: LD_INT 1
108750: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108751: LD_VAR 0 4
108755: PUSH
108756: LD_VAR 0 7
108760: ARRAY
108761: PPUSH
108762: LD_INT 71
108764: PPUSH
108765: CALL_OW 109
// continue ;
108769: GO 108684
// end ; end ;
108771: GO 108684
108773: POP
108774: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108775: LD_VAR 0 4
108779: PUSH
108780: LD_VAR 0 7
108784: ARRAY
108785: PPUSH
108786: CALL_OW 257
108790: PUSH
108791: LD_INT 8
108793: EQUAL
108794: PUSH
108795: LD_VAR 0 4
108799: PUSH
108800: LD_VAR 0 7
108804: ARRAY
108805: PPUSH
108806: CALL_OW 264
108810: PUSH
108811: LD_INT 28
108813: PUSH
108814: LD_INT 45
108816: PUSH
108817: LD_INT 7
108819: PUSH
108820: LD_INT 47
108822: PUSH
108823: EMPTY
108824: LIST
108825: LIST
108826: LIST
108827: LIST
108828: IN
108829: OR
108830: IFFALSE 109086
// begin attacking := false ;
108832: LD_ADDR_VAR 0 29
108836: PUSH
108837: LD_INT 0
108839: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108840: LD_VAR 0 14
108844: PUSH
108845: LD_INT 1
108847: ARRAY
108848: PPUSH
108849: CALL_OW 266
108853: PUSH
108854: LD_INT 32
108856: PUSH
108857: LD_INT 31
108859: PUSH
108860: LD_INT 33
108862: PUSH
108863: LD_INT 4
108865: PUSH
108866: LD_INT 5
108868: PUSH
108869: EMPTY
108870: LIST
108871: LIST
108872: LIST
108873: LIST
108874: LIST
108875: IN
108876: IFFALSE 109062
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108878: LD_ADDR_VAR 0 9
108882: PUSH
108883: LD_VAR 0 14
108887: PUSH
108888: LD_INT 1
108890: ARRAY
108891: PPUSH
108892: CALL_OW 266
108896: PPUSH
108897: LD_VAR 0 14
108901: PUSH
108902: LD_INT 1
108904: ARRAY
108905: PPUSH
108906: CALL_OW 250
108910: PPUSH
108911: LD_VAR 0 14
108915: PUSH
108916: LD_INT 1
108918: ARRAY
108919: PPUSH
108920: CALL_OW 251
108924: PPUSH
108925: LD_VAR 0 14
108929: PUSH
108930: LD_INT 1
108932: ARRAY
108933: PPUSH
108934: CALL_OW 254
108938: PPUSH
108939: LD_VAR 0 14
108943: PUSH
108944: LD_INT 1
108946: ARRAY
108947: PPUSH
108948: CALL_OW 248
108952: PPUSH
108953: LD_INT 0
108955: PPUSH
108956: CALL 64579 0 6
108960: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108961: LD_ADDR_VAR 0 8
108965: PUSH
108966: LD_VAR 0 4
108970: PUSH
108971: LD_VAR 0 7
108975: ARRAY
108976: PPUSH
108977: LD_VAR 0 9
108981: PPUSH
108982: CALL 83249 0 2
108986: ST_TO_ADDR
// if j then
108987: LD_VAR 0 8
108991: IFFALSE 109060
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108993: LD_VAR 0 8
108997: PUSH
108998: LD_INT 1
109000: ARRAY
109001: PPUSH
109002: LD_VAR 0 8
109006: PUSH
109007: LD_INT 2
109009: ARRAY
109010: PPUSH
109011: CALL_OW 488
109015: IFFALSE 109060
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109017: LD_VAR 0 4
109021: PUSH
109022: LD_VAR 0 7
109026: ARRAY
109027: PPUSH
109028: LD_VAR 0 8
109032: PUSH
109033: LD_INT 1
109035: ARRAY
109036: PPUSH
109037: LD_VAR 0 8
109041: PUSH
109042: LD_INT 2
109044: ARRAY
109045: PPUSH
109046: CALL_OW 116
// attacking := true ;
109050: LD_ADDR_VAR 0 29
109054: PUSH
109055: LD_INT 1
109057: ST_TO_ADDR
// continue ;
109058: GO 106433
// end ; end else
109060: GO 109086
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109062: LD_VAR 0 4
109066: PUSH
109067: LD_VAR 0 7
109071: ARRAY
109072: PPUSH
109073: LD_VAR 0 14
109077: PUSH
109078: LD_INT 1
109080: ARRAY
109081: PPUSH
109082: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
109086: LD_VAR 0 4
109090: PUSH
109091: LD_VAR 0 7
109095: ARRAY
109096: PPUSH
109097: CALL_OW 265
109101: PUSH
109102: LD_INT 11
109104: EQUAL
109105: IFFALSE 109383
// begin k := 10 ;
109107: LD_ADDR_VAR 0 9
109111: PUSH
109112: LD_INT 10
109114: ST_TO_ADDR
// x := 0 ;
109115: LD_ADDR_VAR 0 10
109119: PUSH
109120: LD_INT 0
109122: ST_TO_ADDR
// if tmp < k then
109123: LD_VAR 0 14
109127: PUSH
109128: LD_VAR 0 9
109132: LESS
109133: IFFALSE 109145
// k := tmp ;
109135: LD_ADDR_VAR 0 9
109139: PUSH
109140: LD_VAR 0 14
109144: ST_TO_ADDR
// for j = k downto 1 do
109145: LD_ADDR_VAR 0 8
109149: PUSH
109150: DOUBLE
109151: LD_VAR 0 9
109155: INC
109156: ST_TO_ADDR
109157: LD_INT 1
109159: PUSH
109160: FOR_DOWNTO
109161: IFFALSE 109236
// begin if GetType ( tmp [ j ] ) = unit_human then
109163: LD_VAR 0 14
109167: PUSH
109168: LD_VAR 0 8
109172: ARRAY
109173: PPUSH
109174: CALL_OW 247
109178: PUSH
109179: LD_INT 1
109181: EQUAL
109182: IFFALSE 109234
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109184: LD_VAR 0 4
109188: PUSH
109189: LD_VAR 0 7
109193: ARRAY
109194: PPUSH
109195: LD_VAR 0 14
109199: PUSH
109200: LD_VAR 0 8
109204: ARRAY
109205: PPUSH
109206: CALL 83520 0 2
// x := tmp [ j ] ;
109210: LD_ADDR_VAR 0 10
109214: PUSH
109215: LD_VAR 0 14
109219: PUSH
109220: LD_VAR 0 8
109224: ARRAY
109225: ST_TO_ADDR
// attacking := true ;
109226: LD_ADDR_VAR 0 29
109230: PUSH
109231: LD_INT 1
109233: ST_TO_ADDR
// end ; end ;
109234: GO 109160
109236: POP
109237: POP
// if not x then
109238: LD_VAR 0 10
109242: NOT
109243: IFFALSE 109383
// begin attacking := true ;
109245: LD_ADDR_VAR 0 29
109249: PUSH
109250: LD_INT 1
109252: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109253: LD_VAR 0 4
109257: PUSH
109258: LD_VAR 0 7
109262: ARRAY
109263: PPUSH
109264: CALL_OW 250
109268: PPUSH
109269: LD_VAR 0 4
109273: PUSH
109274: LD_VAR 0 7
109278: ARRAY
109279: PPUSH
109280: CALL_OW 251
109284: PPUSH
109285: CALL_OW 546
109289: PUSH
109290: LD_INT 2
109292: ARRAY
109293: PUSH
109294: LD_VAR 0 14
109298: PUSH
109299: LD_INT 1
109301: ARRAY
109302: PPUSH
109303: CALL_OW 250
109307: PPUSH
109308: LD_VAR 0 14
109312: PUSH
109313: LD_INT 1
109315: ARRAY
109316: PPUSH
109317: CALL_OW 251
109321: PPUSH
109322: CALL_OW 546
109326: PUSH
109327: LD_INT 2
109329: ARRAY
109330: EQUAL
109331: IFFALSE 109359
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109333: LD_VAR 0 4
109337: PUSH
109338: LD_VAR 0 7
109342: ARRAY
109343: PPUSH
109344: LD_VAR 0 14
109348: PUSH
109349: LD_INT 1
109351: ARRAY
109352: PPUSH
109353: CALL 83520 0 2
109357: GO 109383
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109359: LD_VAR 0 4
109363: PUSH
109364: LD_VAR 0 7
109368: ARRAY
109369: PPUSH
109370: LD_VAR 0 14
109374: PUSH
109375: LD_INT 1
109377: ARRAY
109378: PPUSH
109379: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109383: LD_VAR 0 4
109387: PUSH
109388: LD_VAR 0 7
109392: ARRAY
109393: PPUSH
109394: CALL_OW 264
109398: PUSH
109399: LD_INT 29
109401: EQUAL
109402: IFFALSE 109768
// begin if WantsToAttack ( group [ i ] ) in bombed then
109404: LD_VAR 0 4
109408: PUSH
109409: LD_VAR 0 7
109413: ARRAY
109414: PPUSH
109415: CALL_OW 319
109419: PUSH
109420: LD_VAR 0 28
109424: IN
109425: IFFALSE 109429
// continue ;
109427: GO 106433
// k := 8 ;
109429: LD_ADDR_VAR 0 9
109433: PUSH
109434: LD_INT 8
109436: ST_TO_ADDR
// x := 0 ;
109437: LD_ADDR_VAR 0 10
109441: PUSH
109442: LD_INT 0
109444: ST_TO_ADDR
// if tmp < k then
109445: LD_VAR 0 14
109449: PUSH
109450: LD_VAR 0 9
109454: LESS
109455: IFFALSE 109467
// k := tmp ;
109457: LD_ADDR_VAR 0 9
109461: PUSH
109462: LD_VAR 0 14
109466: ST_TO_ADDR
// for j = 1 to k do
109467: LD_ADDR_VAR 0 8
109471: PUSH
109472: DOUBLE
109473: LD_INT 1
109475: DEC
109476: ST_TO_ADDR
109477: LD_VAR 0 9
109481: PUSH
109482: FOR_TO
109483: IFFALSE 109615
// begin if GetType ( tmp [ j ] ) = unit_building then
109485: LD_VAR 0 14
109489: PUSH
109490: LD_VAR 0 8
109494: ARRAY
109495: PPUSH
109496: CALL_OW 247
109500: PUSH
109501: LD_INT 3
109503: EQUAL
109504: IFFALSE 109613
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109506: LD_VAR 0 14
109510: PUSH
109511: LD_VAR 0 8
109515: ARRAY
109516: PUSH
109517: LD_VAR 0 28
109521: IN
109522: NOT
109523: PUSH
109524: LD_VAR 0 14
109528: PUSH
109529: LD_VAR 0 8
109533: ARRAY
109534: PPUSH
109535: CALL_OW 313
109539: AND
109540: IFFALSE 109613
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109542: LD_VAR 0 4
109546: PUSH
109547: LD_VAR 0 7
109551: ARRAY
109552: PPUSH
109553: LD_VAR 0 14
109557: PUSH
109558: LD_VAR 0 8
109562: ARRAY
109563: PPUSH
109564: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109568: LD_ADDR_VAR 0 28
109572: PUSH
109573: LD_VAR 0 28
109577: PPUSH
109578: LD_VAR 0 28
109582: PUSH
109583: LD_INT 1
109585: PLUS
109586: PPUSH
109587: LD_VAR 0 14
109591: PUSH
109592: LD_VAR 0 8
109596: ARRAY
109597: PPUSH
109598: CALL_OW 1
109602: ST_TO_ADDR
// attacking := true ;
109603: LD_ADDR_VAR 0 29
109607: PUSH
109608: LD_INT 1
109610: ST_TO_ADDR
// break ;
109611: GO 109615
// end ; end ;
109613: GO 109482
109615: POP
109616: POP
// if not attacking and f_attack_depot then
109617: LD_VAR 0 29
109621: NOT
109622: PUSH
109623: LD_VAR 0 25
109627: AND
109628: IFFALSE 109723
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109630: LD_ADDR_VAR 0 13
109634: PUSH
109635: LD_VAR 0 14
109639: PPUSH
109640: LD_INT 2
109642: PUSH
109643: LD_INT 30
109645: PUSH
109646: LD_INT 0
109648: PUSH
109649: EMPTY
109650: LIST
109651: LIST
109652: PUSH
109653: LD_INT 30
109655: PUSH
109656: LD_INT 1
109658: PUSH
109659: EMPTY
109660: LIST
109661: LIST
109662: PUSH
109663: EMPTY
109664: LIST
109665: LIST
109666: LIST
109667: PPUSH
109668: CALL_OW 72
109672: ST_TO_ADDR
// if z then
109673: LD_VAR 0 13
109677: IFFALSE 109723
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109679: LD_VAR 0 4
109683: PUSH
109684: LD_VAR 0 7
109688: ARRAY
109689: PPUSH
109690: LD_VAR 0 13
109694: PPUSH
109695: LD_VAR 0 4
109699: PUSH
109700: LD_VAR 0 7
109704: ARRAY
109705: PPUSH
109706: CALL_OW 74
109710: PPUSH
109711: CALL_OW 115
// attacking := true ;
109715: LD_ADDR_VAR 0 29
109719: PUSH
109720: LD_INT 1
109722: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109723: LD_VAR 0 4
109727: PUSH
109728: LD_VAR 0 7
109732: ARRAY
109733: PPUSH
109734: CALL_OW 256
109738: PUSH
109739: LD_INT 500
109741: LESS
109742: IFFALSE 109768
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109744: LD_VAR 0 4
109748: PUSH
109749: LD_VAR 0 7
109753: ARRAY
109754: PPUSH
109755: LD_VAR 0 14
109759: PUSH
109760: LD_INT 1
109762: ARRAY
109763: PPUSH
109764: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109768: LD_VAR 0 4
109772: PUSH
109773: LD_VAR 0 7
109777: ARRAY
109778: PPUSH
109779: CALL_OW 264
109783: PUSH
109784: LD_INT 49
109786: EQUAL
109787: IFFALSE 109908
// begin if not HasTask ( group [ i ] ) then
109789: LD_VAR 0 4
109793: PUSH
109794: LD_VAR 0 7
109798: ARRAY
109799: PPUSH
109800: CALL_OW 314
109804: NOT
109805: IFFALSE 109908
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109807: LD_ADDR_VAR 0 9
109811: PUSH
109812: LD_INT 81
109814: PUSH
109815: LD_VAR 0 4
109819: PUSH
109820: LD_VAR 0 7
109824: ARRAY
109825: PPUSH
109826: CALL_OW 255
109830: PUSH
109831: EMPTY
109832: LIST
109833: LIST
109834: PPUSH
109835: CALL_OW 69
109839: PPUSH
109840: LD_VAR 0 4
109844: PUSH
109845: LD_VAR 0 7
109849: ARRAY
109850: PPUSH
109851: CALL_OW 74
109855: ST_TO_ADDR
// if k then
109856: LD_VAR 0 9
109860: IFFALSE 109908
// if GetDistUnits ( group [ i ] , k ) > 10 then
109862: LD_VAR 0 4
109866: PUSH
109867: LD_VAR 0 7
109871: ARRAY
109872: PPUSH
109873: LD_VAR 0 9
109877: PPUSH
109878: CALL_OW 296
109882: PUSH
109883: LD_INT 10
109885: GREATER
109886: IFFALSE 109908
// ComMoveUnit ( group [ i ] , k ) ;
109888: LD_VAR 0 4
109892: PUSH
109893: LD_VAR 0 7
109897: ARRAY
109898: PPUSH
109899: LD_VAR 0 9
109903: PPUSH
109904: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109908: LD_VAR 0 4
109912: PUSH
109913: LD_VAR 0 7
109917: ARRAY
109918: PPUSH
109919: CALL_OW 256
109923: PUSH
109924: LD_INT 250
109926: LESS
109927: PUSH
109928: LD_VAR 0 4
109932: PUSH
109933: LD_VAR 0 7
109937: ARRAY
109938: PUSH
109939: LD_INT 21
109941: PUSH
109942: LD_INT 2
109944: PUSH
109945: EMPTY
109946: LIST
109947: LIST
109948: PUSH
109949: LD_INT 23
109951: PUSH
109952: LD_INT 2
109954: PUSH
109955: EMPTY
109956: LIST
109957: LIST
109958: PUSH
109959: EMPTY
109960: LIST
109961: LIST
109962: PPUSH
109963: CALL_OW 69
109967: IN
109968: AND
109969: IFFALSE 110094
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109971: LD_ADDR_VAR 0 9
109975: PUSH
109976: LD_OWVAR 3
109980: PUSH
109981: LD_VAR 0 4
109985: PUSH
109986: LD_VAR 0 7
109990: ARRAY
109991: DIFF
109992: PPUSH
109993: LD_VAR 0 4
109997: PUSH
109998: LD_VAR 0 7
110002: ARRAY
110003: PPUSH
110004: CALL_OW 74
110008: ST_TO_ADDR
// if not k then
110009: LD_VAR 0 9
110013: NOT
110014: IFFALSE 110018
// continue ;
110016: GO 106433
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110018: LD_VAR 0 9
110022: PUSH
110023: LD_INT 81
110025: PUSH
110026: LD_VAR 0 4
110030: PUSH
110031: LD_VAR 0 7
110035: ARRAY
110036: PPUSH
110037: CALL_OW 255
110041: PUSH
110042: EMPTY
110043: LIST
110044: LIST
110045: PPUSH
110046: CALL_OW 69
110050: IN
110051: PUSH
110052: LD_VAR 0 9
110056: PPUSH
110057: LD_VAR 0 4
110061: PUSH
110062: LD_VAR 0 7
110066: ARRAY
110067: PPUSH
110068: CALL_OW 296
110072: PUSH
110073: LD_INT 5
110075: LESS
110076: AND
110077: IFFALSE 110094
// ComAutodestruct ( group [ i ] ) ;
110079: LD_VAR 0 4
110083: PUSH
110084: LD_VAR 0 7
110088: ARRAY
110089: PPUSH
110090: CALL 83418 0 1
// end ; if f_attack_depot then
110094: LD_VAR 0 25
110098: IFFALSE 110210
// begin k := 6 ;
110100: LD_ADDR_VAR 0 9
110104: PUSH
110105: LD_INT 6
110107: ST_TO_ADDR
// if tmp < k then
110108: LD_VAR 0 14
110112: PUSH
110113: LD_VAR 0 9
110117: LESS
110118: IFFALSE 110130
// k := tmp ;
110120: LD_ADDR_VAR 0 9
110124: PUSH
110125: LD_VAR 0 14
110129: ST_TO_ADDR
// for j = 1 to k do
110130: LD_ADDR_VAR 0 8
110134: PUSH
110135: DOUBLE
110136: LD_INT 1
110138: DEC
110139: ST_TO_ADDR
110140: LD_VAR 0 9
110144: PUSH
110145: FOR_TO
110146: IFFALSE 110208
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
110148: LD_VAR 0 8
110152: PPUSH
110153: CALL_OW 266
110157: PUSH
110158: LD_INT 0
110160: PUSH
110161: LD_INT 1
110163: PUSH
110164: EMPTY
110165: LIST
110166: LIST
110167: IN
110168: IFFALSE 110206
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110170: LD_VAR 0 4
110174: PUSH
110175: LD_VAR 0 7
110179: ARRAY
110180: PPUSH
110181: LD_VAR 0 14
110185: PUSH
110186: LD_VAR 0 8
110190: ARRAY
110191: PPUSH
110192: CALL_OW 115
// attacking := true ;
110196: LD_ADDR_VAR 0 29
110200: PUSH
110201: LD_INT 1
110203: ST_TO_ADDR
// break ;
110204: GO 110208
// end ;
110206: GO 110145
110208: POP
110209: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110210: LD_VAR 0 4
110214: PUSH
110215: LD_VAR 0 7
110219: ARRAY
110220: PPUSH
110221: CALL_OW 302
110225: PUSH
110226: LD_VAR 0 29
110230: NOT
110231: AND
110232: IFFALSE 110554
// begin if GetTag ( group [ i ] ) = 71 then
110234: LD_VAR 0 4
110238: PUSH
110239: LD_VAR 0 7
110243: ARRAY
110244: PPUSH
110245: CALL_OW 110
110249: PUSH
110250: LD_INT 71
110252: EQUAL
110253: IFFALSE 110294
// begin if HasTask ( group [ i ] ) then
110255: LD_VAR 0 4
110259: PUSH
110260: LD_VAR 0 7
110264: ARRAY
110265: PPUSH
110266: CALL_OW 314
110270: IFFALSE 110276
// continue else
110272: GO 106433
110274: GO 110294
// SetTag ( group [ i ] , 0 ) ;
110276: LD_VAR 0 4
110280: PUSH
110281: LD_VAR 0 7
110285: ARRAY
110286: PPUSH
110287: LD_INT 0
110289: PPUSH
110290: CALL_OW 109
// end ; k := 8 ;
110294: LD_ADDR_VAR 0 9
110298: PUSH
110299: LD_INT 8
110301: ST_TO_ADDR
// x := 0 ;
110302: LD_ADDR_VAR 0 10
110306: PUSH
110307: LD_INT 0
110309: ST_TO_ADDR
// if tmp < k then
110310: LD_VAR 0 14
110314: PUSH
110315: LD_VAR 0 9
110319: LESS
110320: IFFALSE 110332
// k := tmp ;
110322: LD_ADDR_VAR 0 9
110326: PUSH
110327: LD_VAR 0 14
110331: ST_TO_ADDR
// for j = 1 to k do
110332: LD_ADDR_VAR 0 8
110336: PUSH
110337: DOUBLE
110338: LD_INT 1
110340: DEC
110341: ST_TO_ADDR
110342: LD_VAR 0 9
110346: PUSH
110347: FOR_TO
110348: IFFALSE 110446
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110350: LD_VAR 0 14
110354: PUSH
110355: LD_VAR 0 8
110359: ARRAY
110360: PPUSH
110361: CALL_OW 247
110365: PUSH
110366: LD_INT 1
110368: EQUAL
110369: PUSH
110370: LD_VAR 0 14
110374: PUSH
110375: LD_VAR 0 8
110379: ARRAY
110380: PPUSH
110381: CALL_OW 256
110385: PUSH
110386: LD_INT 250
110388: LESS
110389: PUSH
110390: LD_VAR 0 20
110394: AND
110395: PUSH
110396: LD_VAR 0 20
110400: NOT
110401: PUSH
110402: LD_VAR 0 14
110406: PUSH
110407: LD_VAR 0 8
110411: ARRAY
110412: PPUSH
110413: CALL_OW 256
110417: PUSH
110418: LD_INT 250
110420: GREATEREQUAL
110421: AND
110422: OR
110423: AND
110424: IFFALSE 110444
// begin x := tmp [ j ] ;
110426: LD_ADDR_VAR 0 10
110430: PUSH
110431: LD_VAR 0 14
110435: PUSH
110436: LD_VAR 0 8
110440: ARRAY
110441: ST_TO_ADDR
// break ;
110442: GO 110446
// end ;
110444: GO 110347
110446: POP
110447: POP
// if x then
110448: LD_VAR 0 10
110452: IFFALSE 110476
// ComAttackUnit ( group [ i ] , x ) else
110454: LD_VAR 0 4
110458: PUSH
110459: LD_VAR 0 7
110463: ARRAY
110464: PPUSH
110465: LD_VAR 0 10
110469: PPUSH
110470: CALL_OW 115
110474: GO 110500
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110476: LD_VAR 0 4
110480: PUSH
110481: LD_VAR 0 7
110485: ARRAY
110486: PPUSH
110487: LD_VAR 0 14
110491: PUSH
110492: LD_INT 1
110494: ARRAY
110495: PPUSH
110496: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110500: LD_VAR 0 4
110504: PUSH
110505: LD_VAR 0 7
110509: ARRAY
110510: PPUSH
110511: CALL_OW 314
110515: NOT
110516: IFFALSE 110554
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110518: LD_VAR 0 4
110522: PUSH
110523: LD_VAR 0 7
110527: ARRAY
110528: PPUSH
110529: LD_VAR 0 14
110533: PPUSH
110534: LD_VAR 0 4
110538: PUSH
110539: LD_VAR 0 7
110543: ARRAY
110544: PPUSH
110545: CALL_OW 74
110549: PPUSH
110550: CALL_OW 115
// end ; end ; end ;
110554: GO 106433
110556: POP
110557: POP
// wait ( 0 0$2 ) ;
110558: LD_INT 70
110560: PPUSH
110561: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110565: LD_VAR 0 4
110569: NOT
110570: PUSH
110571: LD_VAR 0 4
110575: PUSH
110576: EMPTY
110577: EQUAL
110578: OR
110579: PUSH
110580: LD_INT 81
110582: PUSH
110583: LD_VAR 0 35
110587: PUSH
110588: EMPTY
110589: LIST
110590: LIST
110591: PPUSH
110592: CALL_OW 69
110596: NOT
110597: OR
110598: IFFALSE 106418
// end ;
110600: LD_VAR 0 2
110604: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
110605: LD_INT 0
110607: PPUSH
110608: PPUSH
110609: PPUSH
110610: PPUSH
110611: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
110612: LD_VAR 0 1
110616: NOT
110617: PUSH
110618: LD_EXP 92
110622: PUSH
110623: LD_VAR 0 1
110627: ARRAY
110628: NOT
110629: OR
110630: PUSH
110631: LD_VAR 0 2
110635: NOT
110636: OR
110637: PUSH
110638: LD_VAR 0 3
110642: NOT
110643: OR
110644: IFFALSE 110648
// exit ;
110646: GO 111161
// side := mc_sides [ base ] ;
110648: LD_ADDR_VAR 0 6
110652: PUSH
110653: LD_EXP 118
110657: PUSH
110658: LD_VAR 0 1
110662: ARRAY
110663: ST_TO_ADDR
// if not side then
110664: LD_VAR 0 6
110668: NOT
110669: IFFALSE 110673
// exit ;
110671: GO 111161
// for i in solds do
110673: LD_ADDR_VAR 0 7
110677: PUSH
110678: LD_VAR 0 2
110682: PUSH
110683: FOR_IN
110684: IFFALSE 110745
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110686: LD_VAR 0 7
110690: PPUSH
110691: CALL_OW 310
110695: PPUSH
110696: CALL_OW 266
110700: PUSH
110701: LD_INT 32
110703: PUSH
110704: LD_INT 31
110706: PUSH
110707: EMPTY
110708: LIST
110709: LIST
110710: IN
110711: IFFALSE 110731
// solds := solds diff i else
110713: LD_ADDR_VAR 0 2
110717: PUSH
110718: LD_VAR 0 2
110722: PUSH
110723: LD_VAR 0 7
110727: DIFF
110728: ST_TO_ADDR
110729: GO 110743
// SetTag ( i , 18 ) ;
110731: LD_VAR 0 7
110735: PPUSH
110736: LD_INT 18
110738: PPUSH
110739: CALL_OW 109
110743: GO 110683
110745: POP
110746: POP
// if not solds then
110747: LD_VAR 0 2
110751: NOT
110752: IFFALSE 110756
// exit ;
110754: GO 111161
// repeat wait ( 0 0$2 ) ;
110756: LD_INT 70
110758: PPUSH
110759: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
110763: LD_ADDR_VAR 0 5
110767: PUSH
110768: LD_VAR 0 6
110772: PPUSH
110773: LD_VAR 0 3
110777: PPUSH
110778: CALL 52800 0 2
110782: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110783: LD_EXP 92
110787: PUSH
110788: LD_VAR 0 1
110792: ARRAY
110793: NOT
110794: PUSH
110795: LD_EXP 92
110799: PUSH
110800: LD_VAR 0 1
110804: ARRAY
110805: PUSH
110806: EMPTY
110807: EQUAL
110808: OR
110809: IFFALSE 110846
// begin for i in solds do
110811: LD_ADDR_VAR 0 7
110815: PUSH
110816: LD_VAR 0 2
110820: PUSH
110821: FOR_IN
110822: IFFALSE 110835
// ComStop ( i ) ;
110824: LD_VAR 0 7
110828: PPUSH
110829: CALL_OW 141
110833: GO 110821
110835: POP
110836: POP
// solds := [ ] ;
110837: LD_ADDR_VAR 0 2
110841: PUSH
110842: EMPTY
110843: ST_TO_ADDR
// exit ;
110844: GO 111161
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
110846: LD_VAR 0 5
110850: NOT
110851: PUSH
110852: LD_VAR 0 5
110856: PUSH
110857: LD_INT 3
110859: GREATER
110860: OR
110861: PUSH
110862: LD_EXP 114
110866: PUSH
110867: LD_VAR 0 1
110871: ARRAY
110872: OR
110873: IFFALSE 110914
// begin for i in solds do
110875: LD_ADDR_VAR 0 7
110879: PUSH
110880: LD_VAR 0 2
110884: PUSH
110885: FOR_IN
110886: IFFALSE 110910
// if HasTask ( i ) then
110888: LD_VAR 0 7
110892: PPUSH
110893: CALL_OW 314
110897: IFFALSE 110908
// ComStop ( i ) ;
110899: LD_VAR 0 7
110903: PPUSH
110904: CALL_OW 141
110908: GO 110885
110910: POP
110911: POP
// break ;
110912: GO 111149
// end ; for i in solds do
110914: LD_ADDR_VAR 0 7
110918: PUSH
110919: LD_VAR 0 2
110923: PUSH
110924: FOR_IN
110925: IFFALSE 111141
// begin if IsInUnit ( i ) then
110927: LD_VAR 0 7
110931: PPUSH
110932: CALL_OW 310
110936: IFFALSE 110947
// ComExitBuilding ( i ) ;
110938: LD_VAR 0 7
110942: PPUSH
110943: CALL_OW 122
// if GetLives ( i ) > 333 then
110947: LD_VAR 0 7
110951: PPUSH
110952: CALL_OW 256
110956: PUSH
110957: LD_INT 333
110959: GREATER
110960: IFFALSE 110988
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110962: LD_VAR 0 7
110966: PPUSH
110967: LD_VAR 0 5
110971: PPUSH
110972: LD_VAR 0 7
110976: PPUSH
110977: CALL_OW 74
110981: PPUSH
110982: CALL_OW 115
110986: GO 111139
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110988: LD_ADDR_VAR 0 8
110992: PUSH
110993: LD_EXP 92
110997: PUSH
110998: LD_VAR 0 1
111002: ARRAY
111003: PPUSH
111004: LD_INT 2
111006: PUSH
111007: LD_INT 30
111009: PUSH
111010: LD_INT 0
111012: PUSH
111013: EMPTY
111014: LIST
111015: LIST
111016: PUSH
111017: LD_INT 30
111019: PUSH
111020: LD_INT 1
111022: PUSH
111023: EMPTY
111024: LIST
111025: LIST
111026: PUSH
111027: LD_INT 30
111029: PUSH
111030: LD_INT 6
111032: PUSH
111033: EMPTY
111034: LIST
111035: LIST
111036: PUSH
111037: EMPTY
111038: LIST
111039: LIST
111040: LIST
111041: LIST
111042: PPUSH
111043: CALL_OW 72
111047: PPUSH
111048: LD_VAR 0 7
111052: PPUSH
111053: CALL_OW 74
111057: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
111058: LD_VAR 0 7
111062: PPUSH
111063: LD_VAR 0 8
111067: PPUSH
111068: CALL_OW 250
111072: PPUSH
111073: LD_INT 3
111075: PPUSH
111076: LD_INT 5
111078: PPUSH
111079: CALL_OW 272
111083: PPUSH
111084: LD_VAR 0 8
111088: PPUSH
111089: CALL_OW 251
111093: PPUSH
111094: LD_INT 3
111096: PPUSH
111097: LD_INT 5
111099: PPUSH
111100: CALL_OW 273
111104: PPUSH
111105: CALL_OW 111
// SetTag ( i , 0 ) ;
111109: LD_VAR 0 7
111113: PPUSH
111114: LD_INT 0
111116: PPUSH
111117: CALL_OW 109
// solds := solds diff i ;
111121: LD_ADDR_VAR 0 2
111125: PUSH
111126: LD_VAR 0 2
111130: PUSH
111131: LD_VAR 0 7
111135: DIFF
111136: ST_TO_ADDR
// continue ;
111137: GO 110924
// end ; end ;
111139: GO 110924
111141: POP
111142: POP
// until solds ;
111143: LD_VAR 0 2
111147: IFFALSE 110756
// MC_Reset ( base , 18 ) ;
111149: LD_VAR 0 1
111153: PPUSH
111154: LD_INT 18
111156: PPUSH
111157: CALL 24925 0 2
// end ;
111161: LD_VAR 0 4
111165: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
111166: LD_INT 0
111168: PPUSH
111169: PPUSH
111170: PPUSH
111171: PPUSH
111172: PPUSH
111173: PPUSH
111174: PPUSH
111175: PPUSH
111176: PPUSH
111177: PPUSH
111178: PPUSH
111179: PPUSH
111180: PPUSH
111181: PPUSH
111182: PPUSH
111183: PPUSH
111184: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111185: LD_ADDR_VAR 0 13
111189: PUSH
111190: LD_EXP 92
111194: PUSH
111195: LD_VAR 0 1
111199: ARRAY
111200: PPUSH
111201: LD_INT 25
111203: PUSH
111204: LD_INT 3
111206: PUSH
111207: EMPTY
111208: LIST
111209: LIST
111210: PPUSH
111211: CALL_OW 72
111215: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111216: LD_EXP 132
111220: PUSH
111221: LD_VAR 0 1
111225: ARRAY
111226: IFFALSE 111250
// mechs := mechs diff mc_remote_driver [ base ] ;
111228: LD_ADDR_VAR 0 13
111232: PUSH
111233: LD_VAR 0 13
111237: PUSH
111238: LD_EXP 132
111242: PUSH
111243: LD_VAR 0 1
111247: ARRAY
111248: DIFF
111249: ST_TO_ADDR
// for i in mechs do
111250: LD_ADDR_VAR 0 5
111254: PUSH
111255: LD_VAR 0 13
111259: PUSH
111260: FOR_IN
111261: IFFALSE 111296
// if GetTag ( i ) > 0 then
111263: LD_VAR 0 5
111267: PPUSH
111268: CALL_OW 110
111272: PUSH
111273: LD_INT 0
111275: GREATER
111276: IFFALSE 111294
// mechs := mechs diff i ;
111278: LD_ADDR_VAR 0 13
111282: PUSH
111283: LD_VAR 0 13
111287: PUSH
111288: LD_VAR 0 5
111292: DIFF
111293: ST_TO_ADDR
111294: GO 111260
111296: POP
111297: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111298: LD_ADDR_VAR 0 9
111302: PUSH
111303: LD_EXP 92
111307: PUSH
111308: LD_VAR 0 1
111312: ARRAY
111313: PPUSH
111314: LD_INT 2
111316: PUSH
111317: LD_INT 25
111319: PUSH
111320: LD_INT 1
111322: PUSH
111323: EMPTY
111324: LIST
111325: LIST
111326: PUSH
111327: LD_INT 25
111329: PUSH
111330: LD_INT 5
111332: PUSH
111333: EMPTY
111334: LIST
111335: LIST
111336: PUSH
111337: LD_INT 25
111339: PUSH
111340: LD_INT 8
111342: PUSH
111343: EMPTY
111344: LIST
111345: LIST
111346: PUSH
111347: LD_INT 25
111349: PUSH
111350: LD_INT 9
111352: PUSH
111353: EMPTY
111354: LIST
111355: LIST
111356: PUSH
111357: EMPTY
111358: LIST
111359: LIST
111360: LIST
111361: LIST
111362: LIST
111363: PPUSH
111364: CALL_OW 72
111368: ST_TO_ADDR
// if not defenders and not solds then
111369: LD_VAR 0 2
111373: NOT
111374: PUSH
111375: LD_VAR 0 9
111379: NOT
111380: AND
111381: IFFALSE 111385
// exit ;
111383: GO 113075
// depot_under_attack := false ;
111385: LD_ADDR_VAR 0 17
111389: PUSH
111390: LD_INT 0
111392: ST_TO_ADDR
// sold_defenders := [ ] ;
111393: LD_ADDR_VAR 0 18
111397: PUSH
111398: EMPTY
111399: ST_TO_ADDR
// if mechs then
111400: LD_VAR 0 13
111404: IFFALSE 111557
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111406: LD_ADDR_VAR 0 5
111410: PUSH
111411: LD_VAR 0 2
111415: PPUSH
111416: LD_INT 21
111418: PUSH
111419: LD_INT 2
111421: PUSH
111422: EMPTY
111423: LIST
111424: LIST
111425: PPUSH
111426: CALL_OW 72
111430: PUSH
111431: FOR_IN
111432: IFFALSE 111555
// begin if GetTag ( i ) <> 20 then
111434: LD_VAR 0 5
111438: PPUSH
111439: CALL_OW 110
111443: PUSH
111444: LD_INT 20
111446: NONEQUAL
111447: IFFALSE 111461
// SetTag ( i , 20 ) ;
111449: LD_VAR 0 5
111453: PPUSH
111454: LD_INT 20
111456: PPUSH
111457: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111461: LD_VAR 0 5
111465: PPUSH
111466: CALL_OW 263
111470: PUSH
111471: LD_INT 1
111473: EQUAL
111474: PUSH
111475: LD_VAR 0 5
111479: PPUSH
111480: CALL_OW 311
111484: NOT
111485: AND
111486: IFFALSE 111553
// begin un := mechs [ 1 ] ;
111488: LD_ADDR_VAR 0 11
111492: PUSH
111493: LD_VAR 0 13
111497: PUSH
111498: LD_INT 1
111500: ARRAY
111501: ST_TO_ADDR
// ComExit ( un ) ;
111502: LD_VAR 0 11
111506: PPUSH
111507: CALL 87763 0 1
// AddComEnterUnit ( un , i ) ;
111511: LD_VAR 0 11
111515: PPUSH
111516: LD_VAR 0 5
111520: PPUSH
111521: CALL_OW 180
// SetTag ( un , 19 ) ;
111525: LD_VAR 0 11
111529: PPUSH
111530: LD_INT 19
111532: PPUSH
111533: CALL_OW 109
// mechs := mechs diff un ;
111537: LD_ADDR_VAR 0 13
111541: PUSH
111542: LD_VAR 0 13
111546: PUSH
111547: LD_VAR 0 11
111551: DIFF
111552: ST_TO_ADDR
// end ; end ;
111553: GO 111431
111555: POP
111556: POP
// if solds then
111557: LD_VAR 0 9
111561: IFFALSE 111620
// for i in solds do
111563: LD_ADDR_VAR 0 5
111567: PUSH
111568: LD_VAR 0 9
111572: PUSH
111573: FOR_IN
111574: IFFALSE 111618
// if not GetTag ( i ) then
111576: LD_VAR 0 5
111580: PPUSH
111581: CALL_OW 110
111585: NOT
111586: IFFALSE 111616
// begin defenders := defenders union i ;
111588: LD_ADDR_VAR 0 2
111592: PUSH
111593: LD_VAR 0 2
111597: PUSH
111598: LD_VAR 0 5
111602: UNION
111603: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111604: LD_VAR 0 5
111608: PPUSH
111609: LD_INT 18
111611: PPUSH
111612: CALL_OW 109
// end ;
111616: GO 111573
111618: POP
111619: POP
// repeat wait ( 0 0$2 ) ;
111620: LD_INT 70
111622: PPUSH
111623: CALL_OW 67
// enemy := mc_scan [ base ] ;
111627: LD_ADDR_VAR 0 3
111631: PUSH
111632: LD_EXP 115
111636: PUSH
111637: LD_VAR 0 1
111641: ARRAY
111642: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111643: LD_EXP 92
111647: PUSH
111648: LD_VAR 0 1
111652: ARRAY
111653: NOT
111654: PUSH
111655: LD_EXP 92
111659: PUSH
111660: LD_VAR 0 1
111664: ARRAY
111665: PUSH
111666: EMPTY
111667: EQUAL
111668: OR
111669: IFFALSE 111706
// begin for i in defenders do
111671: LD_ADDR_VAR 0 5
111675: PUSH
111676: LD_VAR 0 2
111680: PUSH
111681: FOR_IN
111682: IFFALSE 111695
// ComStop ( i ) ;
111684: LD_VAR 0 5
111688: PPUSH
111689: CALL_OW 141
111693: GO 111681
111695: POP
111696: POP
// defenders := [ ] ;
111697: LD_ADDR_VAR 0 2
111701: PUSH
111702: EMPTY
111703: ST_TO_ADDR
// exit ;
111704: GO 113075
// end ; for i in defenders do
111706: LD_ADDR_VAR 0 5
111710: PUSH
111711: LD_VAR 0 2
111715: PUSH
111716: FOR_IN
111717: IFFALSE 112535
// begin e := NearestUnitToUnit ( enemy , i ) ;
111719: LD_ADDR_VAR 0 14
111723: PUSH
111724: LD_VAR 0 3
111728: PPUSH
111729: LD_VAR 0 5
111733: PPUSH
111734: CALL_OW 74
111738: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111739: LD_ADDR_VAR 0 8
111743: PUSH
111744: LD_EXP 92
111748: PUSH
111749: LD_VAR 0 1
111753: ARRAY
111754: PPUSH
111755: LD_INT 2
111757: PUSH
111758: LD_INT 30
111760: PUSH
111761: LD_INT 0
111763: PUSH
111764: EMPTY
111765: LIST
111766: LIST
111767: PUSH
111768: LD_INT 30
111770: PUSH
111771: LD_INT 1
111773: PUSH
111774: EMPTY
111775: LIST
111776: LIST
111777: PUSH
111778: EMPTY
111779: LIST
111780: LIST
111781: LIST
111782: PPUSH
111783: CALL_OW 72
111787: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111788: LD_ADDR_VAR 0 17
111792: PUSH
111793: LD_VAR 0 8
111797: NOT
111798: PUSH
111799: LD_VAR 0 8
111803: PPUSH
111804: LD_INT 3
111806: PUSH
111807: LD_INT 24
111809: PUSH
111810: LD_INT 600
111812: PUSH
111813: EMPTY
111814: LIST
111815: LIST
111816: PUSH
111817: EMPTY
111818: LIST
111819: LIST
111820: PPUSH
111821: CALL_OW 72
111825: OR
111826: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111827: LD_VAR 0 5
111831: PPUSH
111832: CALL_OW 247
111836: PUSH
111837: LD_INT 2
111839: DOUBLE
111840: EQUAL
111841: IFTRUE 111845
111843: GO 112241
111845: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111846: LD_VAR 0 5
111850: PPUSH
111851: CALL_OW 256
111855: PUSH
111856: LD_INT 1000
111858: EQUAL
111859: PUSH
111860: LD_VAR 0 5
111864: PPUSH
111865: LD_VAR 0 14
111869: PPUSH
111870: CALL_OW 296
111874: PUSH
111875: LD_INT 40
111877: LESS
111878: PUSH
111879: LD_VAR 0 14
111883: PPUSH
111884: LD_EXP 117
111888: PUSH
111889: LD_VAR 0 1
111893: ARRAY
111894: PPUSH
111895: CALL_OW 308
111899: OR
111900: AND
111901: IFFALSE 112023
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111903: LD_VAR 0 5
111907: PPUSH
111908: CALL_OW 262
111912: PUSH
111913: LD_INT 1
111915: EQUAL
111916: PUSH
111917: LD_VAR 0 5
111921: PPUSH
111922: CALL_OW 261
111926: PUSH
111927: LD_INT 30
111929: LESS
111930: AND
111931: PUSH
111932: LD_VAR 0 8
111936: AND
111937: IFFALSE 112007
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111939: LD_VAR 0 5
111943: PPUSH
111944: LD_VAR 0 8
111948: PPUSH
111949: LD_VAR 0 5
111953: PPUSH
111954: CALL_OW 74
111958: PPUSH
111959: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111963: LD_VAR 0 5
111967: PPUSH
111968: LD_VAR 0 8
111972: PPUSH
111973: LD_VAR 0 5
111977: PPUSH
111978: CALL_OW 74
111982: PPUSH
111983: CALL_OW 296
111987: PUSH
111988: LD_INT 6
111990: LESS
111991: IFFALSE 112005
// SetFuel ( i , 100 ) ;
111993: LD_VAR 0 5
111997: PPUSH
111998: LD_INT 100
112000: PPUSH
112001: CALL_OW 240
// end else
112005: GO 112021
// ComAttackUnit ( i , e ) ;
112007: LD_VAR 0 5
112011: PPUSH
112012: LD_VAR 0 14
112016: PPUSH
112017: CALL_OW 115
// end else
112021: GO 112124
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112023: LD_VAR 0 14
112027: PPUSH
112028: LD_EXP 117
112032: PUSH
112033: LD_VAR 0 1
112037: ARRAY
112038: PPUSH
112039: CALL_OW 308
112043: NOT
112044: PUSH
112045: LD_VAR 0 5
112049: PPUSH
112050: LD_VAR 0 14
112054: PPUSH
112055: CALL_OW 296
112059: PUSH
112060: LD_INT 40
112062: GREATEREQUAL
112063: AND
112064: PUSH
112065: LD_VAR 0 5
112069: PPUSH
112070: CALL_OW 256
112074: PUSH
112075: LD_INT 650
112077: LESSEQUAL
112078: OR
112079: PUSH
112080: LD_VAR 0 5
112084: PPUSH
112085: LD_EXP 116
112089: PUSH
112090: LD_VAR 0 1
112094: ARRAY
112095: PPUSH
112096: CALL_OW 308
112100: NOT
112101: AND
112102: IFFALSE 112124
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112104: LD_VAR 0 5
112108: PPUSH
112109: LD_EXP 116
112113: PUSH
112114: LD_VAR 0 1
112118: ARRAY
112119: PPUSH
112120: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
112124: LD_VAR 0 5
112128: PPUSH
112129: CALL_OW 256
112133: PUSH
112134: LD_INT 1000
112136: LESS
112137: PUSH
112138: LD_VAR 0 5
112142: PPUSH
112143: CALL_OW 263
112147: PUSH
112148: LD_INT 1
112150: EQUAL
112151: AND
112152: PUSH
112153: LD_VAR 0 5
112157: PPUSH
112158: CALL_OW 311
112162: AND
112163: PUSH
112164: LD_VAR 0 5
112168: PPUSH
112169: LD_EXP 116
112173: PUSH
112174: LD_VAR 0 1
112178: ARRAY
112179: PPUSH
112180: CALL_OW 308
112184: AND
112185: IFFALSE 112239
// begin mech := IsDrivenBy ( i ) ;
112187: LD_ADDR_VAR 0 10
112191: PUSH
112192: LD_VAR 0 5
112196: PPUSH
112197: CALL_OW 311
112201: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112202: LD_VAR 0 10
112206: PPUSH
112207: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112211: LD_VAR 0 10
112215: PPUSH
112216: LD_VAR 0 5
112220: PPUSH
112221: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112225: LD_VAR 0 10
112229: PPUSH
112230: LD_VAR 0 5
112234: PPUSH
112235: CALL_OW 180
// end ; end ; unit_human :
112239: GO 112506
112241: LD_INT 1
112243: DOUBLE
112244: EQUAL
112245: IFTRUE 112249
112247: GO 112505
112249: POP
// begin b := IsInUnit ( i ) ;
112250: LD_ADDR_VAR 0 19
112254: PUSH
112255: LD_VAR 0 5
112259: PPUSH
112260: CALL_OW 310
112264: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112265: LD_ADDR_VAR 0 20
112269: PUSH
112270: LD_VAR 0 19
112274: NOT
112275: PUSH
112276: LD_VAR 0 19
112280: PPUSH
112281: CALL_OW 266
112285: PUSH
112286: LD_INT 32
112288: PUSH
112289: LD_INT 31
112291: PUSH
112292: EMPTY
112293: LIST
112294: LIST
112295: IN
112296: OR
112297: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112298: LD_VAR 0 17
112302: PUSH
112303: LD_VAR 0 2
112307: PPUSH
112308: LD_INT 21
112310: PUSH
112311: LD_INT 2
112313: PUSH
112314: EMPTY
112315: LIST
112316: LIST
112317: PPUSH
112318: CALL_OW 72
112322: PUSH
112323: LD_INT 1
112325: LESSEQUAL
112326: OR
112327: PUSH
112328: LD_VAR 0 20
112332: AND
112333: PUSH
112334: LD_VAR 0 5
112338: PUSH
112339: LD_VAR 0 18
112343: IN
112344: NOT
112345: AND
112346: IFFALSE 112439
// begin if b then
112348: LD_VAR 0 19
112352: IFFALSE 112401
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112354: LD_VAR 0 19
112358: PPUSH
112359: LD_VAR 0 3
112363: PPUSH
112364: LD_VAR 0 19
112368: PPUSH
112369: CALL_OW 74
112373: PPUSH
112374: CALL_OW 296
112378: PUSH
112379: LD_INT 10
112381: LESS
112382: PUSH
112383: LD_VAR 0 19
112387: PPUSH
112388: CALL_OW 461
112392: PUSH
112393: LD_INT 7
112395: NONEQUAL
112396: AND
112397: IFFALSE 112401
// continue ;
112399: GO 111716
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112401: LD_ADDR_VAR 0 18
112405: PUSH
112406: LD_VAR 0 18
112410: PPUSH
112411: LD_VAR 0 18
112415: PUSH
112416: LD_INT 1
112418: PLUS
112419: PPUSH
112420: LD_VAR 0 5
112424: PPUSH
112425: CALL_OW 1
112429: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112430: LD_VAR 0 5
112434: PPUSH
112435: CALL_OW 122
// end ; if sold_defenders then
112439: LD_VAR 0 18
112443: IFFALSE 112503
// if i in sold_defenders then
112445: LD_VAR 0 5
112449: PUSH
112450: LD_VAR 0 18
112454: IN
112455: IFFALSE 112503
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112457: LD_VAR 0 5
112461: PPUSH
112462: CALL_OW 314
112466: NOT
112467: PUSH
112468: LD_VAR 0 5
112472: PPUSH
112473: LD_VAR 0 14
112477: PPUSH
112478: CALL_OW 296
112482: PUSH
112483: LD_INT 30
112485: LESS
112486: AND
112487: IFFALSE 112503
// ComAttackUnit ( i , e ) ;
112489: LD_VAR 0 5
112493: PPUSH
112494: LD_VAR 0 14
112498: PPUSH
112499: CALL_OW 115
// end ; end ; end ;
112503: GO 112506
112505: POP
// if IsDead ( i ) then
112506: LD_VAR 0 5
112510: PPUSH
112511: CALL_OW 301
112515: IFFALSE 112533
// defenders := defenders diff i ;
112517: LD_ADDR_VAR 0 2
112521: PUSH
112522: LD_VAR 0 2
112526: PUSH
112527: LD_VAR 0 5
112531: DIFF
112532: ST_TO_ADDR
// end ;
112533: GO 111716
112535: POP
112536: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112537: LD_VAR 0 3
112541: NOT
112542: PUSH
112543: LD_VAR 0 2
112547: NOT
112548: OR
112549: PUSH
112550: LD_EXP 92
112554: PUSH
112555: LD_VAR 0 1
112559: ARRAY
112560: NOT
112561: OR
112562: IFFALSE 111620
// MC_Reset ( base , 18 ) ;
112564: LD_VAR 0 1
112568: PPUSH
112569: LD_INT 18
112571: PPUSH
112572: CALL 24925 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112576: LD_ADDR_VAR 0 2
112580: PUSH
112581: LD_VAR 0 2
112585: PUSH
112586: LD_VAR 0 2
112590: PPUSH
112591: LD_INT 2
112593: PUSH
112594: LD_INT 25
112596: PUSH
112597: LD_INT 1
112599: PUSH
112600: EMPTY
112601: LIST
112602: LIST
112603: PUSH
112604: LD_INT 25
112606: PUSH
112607: LD_INT 5
112609: PUSH
112610: EMPTY
112611: LIST
112612: LIST
112613: PUSH
112614: LD_INT 25
112616: PUSH
112617: LD_INT 8
112619: PUSH
112620: EMPTY
112621: LIST
112622: LIST
112623: PUSH
112624: LD_INT 25
112626: PUSH
112627: LD_INT 9
112629: PUSH
112630: EMPTY
112631: LIST
112632: LIST
112633: PUSH
112634: EMPTY
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: PPUSH
112641: CALL_OW 72
112645: DIFF
112646: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112647: LD_VAR 0 3
112651: NOT
112652: PUSH
112653: LD_VAR 0 2
112657: PPUSH
112658: LD_INT 21
112660: PUSH
112661: LD_INT 2
112663: PUSH
112664: EMPTY
112665: LIST
112666: LIST
112667: PPUSH
112668: CALL_OW 72
112672: AND
112673: IFFALSE 113011
// begin tmp := FilterByTag ( defenders , 19 ) ;
112675: LD_ADDR_VAR 0 12
112679: PUSH
112680: LD_VAR 0 2
112684: PPUSH
112685: LD_INT 19
112687: PPUSH
112688: CALL 84893 0 2
112692: ST_TO_ADDR
// if tmp then
112693: LD_VAR 0 12
112697: IFFALSE 112767
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112699: LD_ADDR_VAR 0 12
112703: PUSH
112704: LD_VAR 0 12
112708: PPUSH
112709: LD_INT 25
112711: PUSH
112712: LD_INT 3
112714: PUSH
112715: EMPTY
112716: LIST
112717: LIST
112718: PPUSH
112719: CALL_OW 72
112723: ST_TO_ADDR
// if tmp then
112724: LD_VAR 0 12
112728: IFFALSE 112767
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112730: LD_ADDR_EXP 104
112734: PUSH
112735: LD_EXP 104
112739: PPUSH
112740: LD_VAR 0 1
112744: PPUSH
112745: LD_EXP 104
112749: PUSH
112750: LD_VAR 0 1
112754: ARRAY
112755: PUSH
112756: LD_VAR 0 12
112760: UNION
112761: PPUSH
112762: CALL_OW 1
112766: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112767: LD_VAR 0 1
112771: PPUSH
112772: LD_INT 19
112774: PPUSH
112775: CALL 24925 0 2
// repeat wait ( 0 0$1 ) ;
112779: LD_INT 35
112781: PPUSH
112782: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112786: LD_EXP 92
112790: PUSH
112791: LD_VAR 0 1
112795: ARRAY
112796: NOT
112797: PUSH
112798: LD_EXP 92
112802: PUSH
112803: LD_VAR 0 1
112807: ARRAY
112808: PUSH
112809: EMPTY
112810: EQUAL
112811: OR
112812: IFFALSE 112849
// begin for i in defenders do
112814: LD_ADDR_VAR 0 5
112818: PUSH
112819: LD_VAR 0 2
112823: PUSH
112824: FOR_IN
112825: IFFALSE 112838
// ComStop ( i ) ;
112827: LD_VAR 0 5
112831: PPUSH
112832: CALL_OW 141
112836: GO 112824
112838: POP
112839: POP
// defenders := [ ] ;
112840: LD_ADDR_VAR 0 2
112844: PUSH
112845: EMPTY
112846: ST_TO_ADDR
// exit ;
112847: GO 113075
// end ; for i in defenders do
112849: LD_ADDR_VAR 0 5
112853: PUSH
112854: LD_VAR 0 2
112858: PUSH
112859: FOR_IN
112860: IFFALSE 112949
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112862: LD_VAR 0 5
112866: PPUSH
112867: LD_EXP 116
112871: PUSH
112872: LD_VAR 0 1
112876: ARRAY
112877: PPUSH
112878: CALL_OW 308
112882: NOT
112883: IFFALSE 112907
// ComMoveToArea ( i , mc_parking [ base ] ) else
112885: LD_VAR 0 5
112889: PPUSH
112890: LD_EXP 116
112894: PUSH
112895: LD_VAR 0 1
112899: ARRAY
112900: PPUSH
112901: CALL_OW 113
112905: GO 112947
// if GetControl ( i ) = control_manual then
112907: LD_VAR 0 5
112911: PPUSH
112912: CALL_OW 263
112916: PUSH
112917: LD_INT 1
112919: EQUAL
112920: IFFALSE 112947
// if IsDrivenBy ( i ) then
112922: LD_VAR 0 5
112926: PPUSH
112927: CALL_OW 311
112931: IFFALSE 112947
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112933: LD_VAR 0 5
112937: PPUSH
112938: CALL_OW 311
112942: PPUSH
112943: CALL_OW 121
// end ;
112947: GO 112859
112949: POP
112950: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112951: LD_VAR 0 2
112955: PPUSH
112956: LD_INT 95
112958: PUSH
112959: LD_EXP 116
112963: PUSH
112964: LD_VAR 0 1
112968: ARRAY
112969: PUSH
112970: EMPTY
112971: LIST
112972: LIST
112973: PPUSH
112974: CALL_OW 72
112978: PUSH
112979: LD_VAR 0 2
112983: EQUAL
112984: PUSH
112985: LD_EXP 115
112989: PUSH
112990: LD_VAR 0 1
112994: ARRAY
112995: OR
112996: PUSH
112997: LD_EXP 92
113001: PUSH
113002: LD_VAR 0 1
113006: ARRAY
113007: NOT
113008: OR
113009: IFFALSE 112779
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113011: LD_ADDR_EXP 114
113015: PUSH
113016: LD_EXP 114
113020: PPUSH
113021: LD_VAR 0 1
113025: PPUSH
113026: LD_VAR 0 2
113030: PPUSH
113031: LD_INT 21
113033: PUSH
113034: LD_INT 2
113036: PUSH
113037: EMPTY
113038: LIST
113039: LIST
113040: PPUSH
113041: CALL_OW 72
113045: PPUSH
113046: CALL_OW 1
113050: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113051: LD_VAR 0 1
113055: PPUSH
113056: LD_INT 19
113058: PPUSH
113059: CALL 24925 0 2
// MC_Reset ( base , 20 ) ;
113063: LD_VAR 0 1
113067: PPUSH
113068: LD_INT 20
113070: PPUSH
113071: CALL 24925 0 2
// end ; end_of_file
113075: LD_VAR 0 4
113079: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113080: LD_VAR 0 1
113084: PUSH
113085: LD_INT 200
113087: DOUBLE
113088: GREATEREQUAL
113089: IFFALSE 113097
113091: LD_INT 299
113093: DOUBLE
113094: LESSEQUAL
113095: IFTRUE 113099
113097: GO 113131
113099: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113100: LD_VAR 0 1
113104: PPUSH
113105: LD_VAR 0 2
113109: PPUSH
113110: LD_VAR 0 3
113114: PPUSH
113115: LD_VAR 0 4
113119: PPUSH
113120: LD_VAR 0 5
113124: PPUSH
113125: CALL 102013 0 5
113129: GO 113208
113131: LD_INT 300
113133: DOUBLE
113134: GREATEREQUAL
113135: IFFALSE 113143
113137: LD_INT 399
113139: DOUBLE
113140: LESSEQUAL
113141: IFTRUE 113145
113143: GO 113207
113145: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
113146: LD_VAR 0 1
113150: PPUSH
113151: LD_VAR 0 2
113155: PPUSH
113156: LD_VAR 0 3
113160: PPUSH
113161: LD_VAR 0 4
113165: PPUSH
113166: LD_VAR 0 5
113170: PPUSH
113171: LD_VAR 0 6
113175: PPUSH
113176: LD_VAR 0 7
113180: PPUSH
113181: LD_VAR 0 8
113185: PPUSH
113186: LD_VAR 0 9
113190: PPUSH
113191: LD_VAR 0 10
113195: PPUSH
113196: LD_VAR 0 11
113200: PPUSH
113201: CALL 99901 0 11
113205: GO 113208
113207: POP
// end ;
113208: PPOPN 11
113210: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
113211: LD_VAR 0 1
113215: PPUSH
113216: LD_VAR 0 2
113220: PPUSH
113221: LD_VAR 0 3
113225: PPUSH
113226: LD_VAR 0 4
113230: PPUSH
113231: LD_VAR 0 5
113235: PPUSH
113236: CALL 101995 0 5
// end ; end_of_file
113240: PPOPN 5
113242: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113243: LD_VAR 0 1
113247: PPUSH
113248: LD_VAR 0 2
113252: PPUSH
113253: LD_VAR 0 3
113257: PPUSH
113258: LD_VAR 0 4
113262: PPUSH
113263: LD_VAR 0 5
113267: PPUSH
113268: LD_VAR 0 6
113272: PPUSH
113273: CALL 88709 0 6
// end ;
113277: PPOPN 6
113279: END
